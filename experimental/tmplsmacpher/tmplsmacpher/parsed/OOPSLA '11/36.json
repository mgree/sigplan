{"article_publication_date": "10-22-2011", "fulltext": "\n Gradual Typing for Generics LintaroIna AtsushiIgarashi GraduateSchoolofInformatics,KyotoUniversity \nGraduateSchoolofInformatics,KyotoUniversity ina@kuis.kyoto-u.ac.jp igarashi@kuis.kyoto-u.ac.jp Abstract \nGradual typing is a framework to combine static and dy\u00adnamic typingin a singleprogramminglanguage.In \nthispa\u00adper,wedevelopagradualtypesystemforclass-basedobject\u00adoriented languages with generics. We introduce \na special type to denote dynamically typed parts of a program; un\u00adlike dynamic types introduced to C. \n4.0, however, our type system allowsfor more seamlessintegration ofdynamically and statically typed code. \nWeformalize agradualtype systemforFeatherweightGJ with a semantics given by a translation that inserts \nexplicit run-time checks. The type system guarantees that statically typedparts of aprogramdo notgo wrong, \nevenifitincludes dynamicallytypedparts.We alsodescribeabasicimplemen\u00adtation schemeforJava and reportpreliminaryperformance \nevaluation. Categories and Subject Descriptors D.3.1[Programming Languages]:FormalDe.nitions andTheory; \nD.3.2[Pro\u00adgramming Languages]: Language Classi.cations object\u00adorientedlanguages; D.3.3[Programming Languages]:Lan\u00adguage \nConstructs and Features classes and objects, poly\u00admorphism General Terms Languages,Design,Theory Keywords \nGradualtyping,generics,dynamictypes 1. Introduction Statically and dynamically typed languages have \ntheir own bene.ts. On the one hand, statically typed languages enjoy type safetyproperties; onthe otherhand,dynamicallytyped \nlanguagesare saidtobe suitablefor rapidprototyping.There is a signi.cantamountofwork(e.g.,[1,3,5,6,8,10,15,16, \n27 29] to cite some) tointegratebothkinds oflanguagesto have thebest ofboth worlds.Siek andTahahave coined \nthe term gradualtyping [27]foraparticularstyleoflinguistic Permission to make digital or hard copies \nof all or part of this work for personal or classroomuseisgranted withoutfeeprovided that copiesarenot \nmadeordistributed forpro.tor commercial advantage andthat copiesbearthis notice andthefull citation onthe \n.rstpage.Tocopy otherwise,torepublish,topostonservers ortoredistribute tolists, requiresprior speci.cpermission \nand/or afee. OOPSLA 11, October22 27,2011,Portland,Oregon,USA. Copyright c &#38;#169;2011ACM978-1-4503-0940-0/11/10. \n. .$10.00 support of the seamless integration of static and dynamic typing in a single language. A typical \ngradual type system introducesto a staticallytypedlanguagea specialtype(often called dynamic or dyn)to \nspecify dynamically typedparts inaprogramand allows aprogramtobepartially typed,or evenfullydynamicallytyped. \nOne of the main challenges in the design of a gradual typesystemistogivea .exibletypecompatibility relation, \nwhichis an extension of subtypingand usedfor assignments and argumentpassing.For example, agradual type \nsystem usually assumes dyn tobe compatible with any type so that a statically typed expression can be \nused where dyn is ex\u00adpectedand vice versa.Moreover,whentypeshave structures (as in function types), the \ncompatibilityrelation usually al\u00adlows structuralcomparison:forexample,afunctiontype,say dyn . int, is \ncompatible with int . int [27], which is usefulinhigher-orderprograms. Another, more technical challenge \nis to establish some safetyproperty evenforpartially typedprograms.Infact,it is possible to ensure that \nrun-time errors are always due to a dynamically typed part in a program. Roughly speaking, themainideaistoinsert \nrun-timechecksbetweenthe bor\u00adder betweenthe statically anddynamicallytyped worlds to preventstatically \ntyped codefromgoing wrong.Akeyidea here is that the insertion can be guided by the use of the compatibility \nrelation. In thispaper, wedevelopagradualtype systemfor class\u00adbased object-oriented languages with generics. \nAlthough there are similar attempts at mixing static anddynamic typ\u00adingin object-orientedlanguages[3,5,20,28,38],(to \nour knowledge)veryfewtakegenericsintoaccount.One notable exceptionisdynamictypesforC. 4.0[4],buttheintegration \nofdynamicand statictypingis not as smooth as one might expect. For example, it requires tedious coding \nto convert a collectionwhoseelementtypeis statically known,say,to be integers to a collection of dynamically \ntyped values. We designa .exiblecompatibilityrelation,whichallows,for ex\u00adample, List<Integer> tobe used \nas List<dyn> and vice versa. Since the type system has inheritance-based subtyp\u00ading,itis not a trivial \ntask togive a reasonable compatibility relation. We also introduce the notion of bounded dynamic types, \nwhichhave characteristics ofbothdynamic and static types, to mediateboundedpolymorphism anddynamic typ\u00ading. \nWe formalize these ideas as FGJdyn , an extension of FeatherweightGJ(FGJ)[18] withboundeddynamictypes \nandprovethedesired safetyproperty, which statesthat stati\u00adcallytypedpartsin aprogramcannotgowrong.Inparticular, \nitimpliesthe standardtypesafetyforaprogramthatdoesnot contain any dynamic types. The semantics of FGJdyn \nthe surface language in which programs are written is given  iI byatranslationtoanintermediatelanguageFGJ,inwhich \nrun-timechecksare explicit.Thetranslationis notonly ex\u00adpediencyfortheformalproofbutalso aguidetoimplemen\u00adtation. \nOur main contributions canbe summarizedasfollows: A .exiblecompatibilityrelationforparametrictypes; \n Theintroduction ofboundeddynamictypes;  Formalizationofthelanguagewithgenericsanddynamic types; and \n Proof of safety properties, which show that statically typedpartsin aprogram nevergo wrong.  We are \ncurrentlydevelopinga compilerforgradually typed Java. We also describe our basic implementation scheme. \nThis work at an earlier stage has been reported at the STOP 09 workshop[19], where wehave only sketched \nthe combination ofgenerics anddynamictyping anditsformal\u00adization.Inthispaper,wehave revised theformalde.nition \nofboth surface andintermediatelanguages signi.cantly and provedsafetyproperties. The rest of the paper \nis organized as follows. Section 2 gives an overview of gradual typing for a class-based lan\u00adguage withgenerics.Then,Sections3and4givetheformal\u00adization \nof our proposal and prove desired properties. Sec\u00adtion5describes ourimplementation schemeforJava and \nre\u00adports very preliminary benchmark results. After Section 6 discusses relatedwork,Section7gives concluding \nremarks. Some of formal de.nitions and proofs of the theorems are omittedforbrevity; they appearin afull \nversionof thispa\u00adper, available at http://www.sato.kuis.kyoto-u.ac. jp/~igarashi/papers/gradual.html. \n 2. GradualTypingforGenerics Following the previous approaches to gradual typing [27, 28], weintroduce \na special type dyn that representsdynam\u00adically typedportionsin aprogramto a class-basedlanguage with \ngenerics. A variable can be declared to have the dy\u00adnamic type; then, any expression can be assigned \nto it and the variable canbe used as an expression of anytype.Inthis section,we .rstdescribehow dyn interacts \nwithgenericsby means of examples and then what kind of dynamic checks are performed to prevent statically \ntyped parts from going wrong. We use the following simple generic class as a running example: class Cell<X> \n{ X x; Cell(X x){ this.x=x; } void set(X x){ this.x=x; } } Cell is a class of one-element containers, \nwhere the ele\u00adment type is parameterized as X. The element is accessed through the .eld x and modi.ed \nthrough method set. We will also use classes Shape and its subclasses Rectangle and Polygon.(Neither \nRectangle nor Polygon extends the other.)Moreover,class Shape has a methodwiththe sig\u00adnature boolean \ncontains(double x, double y); which returns whether a given point at (x,y)is inside the shape. 2.1 \nTypedyn asTypeArguments One naturalconsequenceoftheintroductionofdyn as atype isthatdyn canbe used as \natype argumentto ageneric class. For example, a programmer can use a variable c1 of type Cell<dyn>. This \ntype is similar to Cell<Object> in the sense that one can set anythingtoit. Cell<dyn> c1 = ...; c1.set(new \nPolygon(...)); c1.set(new Integer(1)); Unlike Cell<Object>,however, the type of .eld x is dyn, which \nrepresents dynamically typed code and accepts any method invocation and .eld access, which are assumed \nto return dyn. dyn fld = c1.x.anyField; dyn ret = c1.x.anyMethod(...); Also,dyn canbe assignedto any \nvariable. boolean b = c1.x.contains(1,1); // The type of RHS is dyn Of course, it must be checked at \nrun time whether these .elds and methods really exists and whether an assignment is valid. In the previous \nwork on gradual typing for a language with subtyping, the subtyping relation is replaced with the compatibility \nrelation[27,28], which,for example, allows statically typed expressions to be passed where dyn is ex\u00adpected \nand vice versa.The compatibility relation shouldbe rich enough to support .exible integration of statically \nand dynamicallytypedcode and,fortype systems withstructural subtyping,itsde.nition requires careful examination. \nWe introduce a rich compatibility relation for paramet\u00adric types. In particular, we allow an expression \nof a dyn\u00adfree type, say Cell<Rectangle>, to be assigned to a vari\u00adable whose type involves dyn as a type \nargument, say Cell<dyn>.For example,thefollowing codeis acceptedby the type system: Cell<dyn> c1 = new \nCell<Rectangle>(new Rectangle(...)); Note that c1 will point to an object that can store only Rectangles, \nrather than anything (as indicated by dyn).  So, actually, theinvocation of set should check at run \ntime whetherthe actual argumentis a valid one. c1.set( new Rectangle(...) ); // succeeds c1.set( new \nPolygon(...) ); // fails The intuition behind a parametric type to which dyn is given as an argument \nis that it denotes the set of types where dyn is replaced with any type. For ex\u00adample, a variable of \ntype Cell<dyn> may point to objects new Cell<Shape>(), new Cell<Rectangle>(), new Cell<Integer>(), and \nso on. In this sense, type Cell<dyn> is closer to the wildcard type Cell<?> than Cell<Object>,but, unlike \nCell<?>,potentiallyunsafe op\u00aderations such asinvocation of set are(statically) allowed. Our compatibility \nrelation allows the opposite direction of.ow,too thatis,anexpressionwhosetypeinvolves dyn as a type argument \ncan be assigned to a variable of a dyn\u00adfree type asin thefollowingcode: Cell<Rectangle> c2 = c1; Cell<Polygon> \nc3 = c1; Just as in an assignment of an expression of type dyn to a concretetype, the run-time system \nwill check whether these arevalid assignments:inthiscase,only the .rst assignment will succeed. In summary, \nour compatibility relation allows dyn in a type expressiontobe replaced with a concretetype and vice \nversa.As we will seeinthe next section,however,itsformal de.nitionis more subtle than mighthave appearedwhen \nwe takeinheritance-based,nominalsubtypinginto account.Due to nominalsubtyping,wetakean approachdifferentfromthe \nprevious work. Seamless Integration. Allowing dyn as a type argument lets us easily evolve a class de.nition \nfrom its non-generic versionintoagenericversion.For example,atthebeginning, aprogrammerhad a non-generic \nclass List, which has its head item head and the rest of list tail, and some client code usingit. class \nList { dyn head; List tail; } List list = new List(...); list.head.doSomething(); Then, the programmer \nwanted to have a generic version of List because he added another client code using List containing Integers \nand nothing else. So, he modi.ed the de.nition ofclass List. class List<X> { X head; List<X> tail; } \n List<Integer> intlist = new List<Integer>(...); This modi.cation breaks other client code using List \nand he need to .x them all, however, all he have to do is to replace List with List<dyn>. List<dyn> list \n= new List<dyn>(...); list.head.doSomething(); iTI e checks if the run-time type of the value of e is \ncompatible with T, and then returnsthe value. get(e, f) checks if the value of e has .eld f, and thenreducestothe \n.eld value. e.m[T|C<X>](e) checks if the types of arguments e are correct(using thestatictypein\u00adformationT, \nC<X>), andtheninvoke method m on receiver e. invoke(e, m, e) checks if the value of receiver e has methodm \nand the types of argu\u00adments e are correct, andtheninvoke the method on the receiver. Table1. Constructsfor \nrun-time checks. If the compiler allows List as an abbreviation of List<dyn>1, he could have done the \nmodi.cation even without any othertype-name .xes! Note that we need to allow new List<dyn>(...).This \nisquitedifferentfrom wildcards, sincenew List<?>(...) isdisallowed.  2.2 Run-timeChecks To ensurethatstaticallytyped \ncode(or, moreprecisely, code that would be well typed in the standard type system) will notgo wrong, \nerrorsdue todynamically typed codehave to becapturedatthe border betweenthetwoworlds.Forthis purpose, \nwe introduce an intermediatelanguage, which has explicit constructsfor run-time checks; the semantics \nof the surfacelanguage, which wedescribe above, willbegivenin terms of the translationto theintermediatelanguage. \nAlthoughthereis nodirectsemanticsfor the surfacelan\u00adguage, a program in the surface language can be mostly \ndirectly understandablebecausethetranslation only inserts run-time checks and preserves the structure \nof a program. Moreover, run-time checks areinsertedonly wheredynamic types areinvolved.So, asfar as statically \ntyped codeis con\u00adcerned, the translationis theidentity map,inserting no run\u00adtime check. Then, to show \nthat statically typed code never goes wrong,it suf.ces to show that all run-timefailures are dueto those \nexplicitchecks. We will give an overview of constructs for run-time checks and the translation below. \nTable 1 shows constructs for run-time checks and their intuitive meanings. In what ' follows, we write \ne e to mean that a surface language ' expression(or statement) e is translatedto e . First, when an \nexpression of a type that involves dyn is passedto where atype withoutdyn is expected, a castiI is inserted: \n1List is a raw type of List<X> in the current Java speci.cation, where it is allowed to assign a value \nof List<T> to a variable of List. Since this behavior is similar to List<dyn>, it is quite natural to \nallow the abbreviationinstead of using rawtypes.SeeSection6fordetails.  Cell<dyn> c1; Cell<Rectangle> \nc2; Cell<Polygon> c3; c2 =c1; c2 = .Cell<Rectangle>. c1; c3 =c1; c3 = .Cell<Polygon>. c1; We use different \nparentheses iI to denote casts because the semantics is slightly different from Java s. Note that the \n.rst cast above has to check that the run-time value of c1 is an instance of Cell<Rectangle> and not \nthat of, say, Cell<Integer>. So, this cast requires run-time type argumentinformation.Thereare otherdifferences,whichwe \ndiscusslater, as well. A member access on dyn will be translated to special forms get() or invoke(), \nwhich checks the existence of the member at run-time. Cell<dyn> c1; c1.x.radius; get(c1.x, radius); \nc1.x.contains(1, 1); invoke(c1.x, contains, 1, 1); When c1.x has method contains, invoke above also checks \nwhetherit can take twointegers. As we have already discussed, the invocation of set on type Cell<dyn> \nwill have to check whether the run-time type of the argumentis appropriatefor the run-timetype ar\u00adgument \nto the receiver s class, even though the existence of method set is staticallyguaranteed.For such cases, \nwe use method invocation of the form e0.m[T|C<X>](e) (where an overlinedenotes alist).For example, wehavethefollow\u00adingtranslation. \nc1.set( new Polygon(...) ); c1.set[X|Cell<X>]( new Polygon(...) ); The annotationsX and Cell<X> record \naparametertype and a receiver s static type before type parameters are instanti\u00adated and are usedto checkthe \nargument.It worksasfollows: Whenc1 evaluatesto a value new Cell<T>(...) for some type T, the actual receiver \ntype Cell<T> is matched against Cell<X> and X is bound to T. Then, the actual argument s type(here Polygon)is \ncheckedagainst T, whichis obtained by replacing X with T in the recorded parameter type. So, this method \ninvocation succeeds when c1 s value is an ob\u00adjectof Cell<Polygon> (orCell<T> where T is a supertype of \nPolygon).  2.3 Ensuring statically typedpartscannotgowrong One of our goals of the gradual type system \nis to ensure that statically typed parts in a program never go wrong , in particular, class de.nitions \nthat pass the standard type checker should notgo wrong.Anotherdesirableproperty of the systemis modularity \nof type checking,thatis,determin\u00ading whether thegivenpart of theprogramis statically typed or not should \nbe done by looking at no more than a single classde.nition and typeinformationthatitdepends on.We also \naim atimplementationby erasuretranslation[7].2Actu\u00adally, modular checking and erasuretranslation makeit \ntrick\u00adier to ensure the safetyof statically typed code . First of all, even if a class de.nition contains \nno occur\u00adrence of dyn, it should not be considered statically typed because subexpressions maybegiventype \ndyn.So, a sensi\u00adble de.nition of a statically typed class de.nition is some\u00adthinglike aclassde.nitionisstatically \ntypedif thereisno occurrence of dyn and every subexpressionisgivena dyn\u00adfree type. Infact,as wewill seelater,inourtranslation,a \nmethodinvocation requires no run-time checkifthe receiver andactualargumenttypes are all dyn-free.Then,a \nclassdef\u00adinition that passes the standard type checking will translate toitself, without run-time checks. \nHowever, the problem is more subtle than it might have appeared,duetothepresence of type variables.Ingeneral, \ntype variables should not be considered dyn-free simply because type variables canbeinstantiated with \ndyn.Infact, the following classes, which are typed under the standard type system ofgenerics class StrCell \nextends Cell<String> { void set(String x){ ... x.length() ... } } class Foo<Y> { void bar(Cell<Y> c, \nY x) { c.set(x); } } willraise a run-timeerrorwhencombinedwiththefollowing code: new Foo<dyn>().bar(new \nStrCell(...), new Object()); Thelast expressionpasses a StrCell and an Object to Foo<dyn>.bar(), which \nexpects a Cell<dyn> and dyn, and this is allowed due to the extended compatibility re\u00adlation we have \nalready mentioned. In Foo<Y>.bar(), an object x is passed to Cell<Y>.set(). However, in this case, the \nreceiver is a StrCell and StrCell.set() will be called with an argument new Object(), whichdoes not havelength()! \nTo avoidthisproblem,we separatetypevariablesintotwo kinds: one can only be replaced with dyn-free types, \nand the other can be replaced with dynamic types. These kinds are indicated in the class de.nition, for \nexample, class Foo<Y.>... for the former and class Foo<Y+>... for the latter. If Foo is de.ned as class \nFoo<Y.>..., then no run-time check is inserted but the problematic expres\u00adsion aboveis rejected at compiletime.Otherwise,if \nFoo is de.ned as class Foo<Y+>..., then the invocation of set will check whether the actual argument \ntypes are valid for theformal(by using e.m[T|C<X>](e)). Although, in principle, a programmer can choose \nthe kind for each type variable declaration in a single class 2Ourcompilation schemeactually requires \nsupportforrun-timetypeargu\u00adments.However,method signatures aresubjecttoerasure.  de.nition,wedonotexpectthat \naprogrammerwantstodo it. A practical design would be that a compiler option will decide the kind of all \nthe type variables in a compiled .le at once. In the beginning of development, the programmer may compile \nmost generic classes with kind ., and then switches some classes to . gradually as the development progresses \nsuch a switch would force their client code to remove the use of dynamic types. In the rest of the paper, \nwe omit kinds of type variables when they do not make signi.cantdifference. There canbe another solutiontotheproblemin \nwhichthe StrCell is wrapped with anotherobject whenitispassed to Cell<dyn>. The wrapper object mimics \nthe interface of StrCell by delegating member accesses to the original object and performs run-time checks \non every delegation. Inthis case,therun-timecheckblamesthemisusage of the StrCell ontheinvocation of \nset().Wedo not choosethis solution mainly because of a dif.culty of implementation andleaveitforfuture \nwork.  2.4 BoundedDynamicTypes Anotherproblemoccurswhen atype variableisgiven an up\u00adperbound.Toillustrate \ntheproblem, consider thefollowing class: class ShapeCell<X+ extends Shape> { X x; ShapeCell(X x){ this.x=x; \n} void set(X x){ this.x=x; } boolean contains(double px, double py){ return this.x.contains(px, py); \n} } Class ShapeCell, which is similar to class Cell above, speci.es Shape as X s upper bound. Note that \nShapeCell does not contain dyn anywhere and the whole class de.ni\u00adtion willbe well typedin the standardtype \nsystem ofgener\u00adics(byremoving .). Now considertypeShapeCell<dyn>.Thequestionhere is what we can set to \nx. One choice would be to allow any object tobe set to x, as wedidfor Cell<dyn>: ShapeCell<dyn> sc = \n...; sc.set( new Object() ); However,this choicewould notbe compatiblewith theim\u00adplementationbyerasure,which \ntranslatesthetypeof .eld x tobeShape,the upperboundof X.In alanguagewithoutera\u00adsuresemantics,forexampleinC.,this \nchoicewouldnotcon\u00ad.ict with theimplementation,but, aslong ashomogeneous translation[25]is used, we would \nneedtotreattype variable X with kind . as dyn. This leads to a major performance disadvantage since operations \non expressions oftypeX need tobe augmented with run-time checksthat require member\u00adship tests: for example \nin the case above, the invocation of contains on this.x need to be replaced with an expen\u00adsive run-timecheckby \ninvoke,which checksthepresence of method contains and(ifit exists) whetherthetypes of formal and actual \narguments match. Thus, our choice here is tokeepcompatibility withimplementationby erasure and to avoidperformancepenalty \nas much aspossible:in other words, we reject the code above statically. We introduce bounded dynamic \ntypes, written dyn<T> (where T stands for a parametric type). A type parameter with an upper bound T \ncan be instantiated by a bounded dynamic type dyn<T ' > when T ' is a subtype of T. Thus, ShapeCell<dyn<Shape>> \nis a well-formed type, whereas ShapeCell<dyn<Object>> is not. We de.ne a bounded dynamic type dyn<T> \nto be com\u00adpatible only with subtypes of T.So, thefollowing code will beill typed and rejectedby the type \nchecker. ShapeCell<dyn<Shape>> sc = ...; sc.set( new Object() ); // Object is not compatible with dyn<Shape>! \n Aboundeddynamictypehasbothstatic anddynamictyping natures. While it still allows potentially unsafe \noperations tobeperformed,it enforces static typing asfar as members de.ned in the bound are concerned. \nSo, the .rst two lines inthefollowing codearestill accepted(and checked at run time)but notthethird3 \nandfourth. sc.x.anyField; sc.x.anyMethod(...); sc.x.contains(); // two arguments are expected! Shape \ns = sc.x.contains(3, 4); // returns boolean! In a real language, we do not expect programmers to write \nthose upper bounds explicitly. Rather, when dyn is used as a type argument, the compiler can recover \nits up\u00adper bound automatically by assigning the upper bounds of the corresponding typeparametersinthegeneric \nclassdef\u00adinition.4 For other uses of dyn, they can be regarded as dyn<Object>; in fact, we use dyn as \nan abbreviation of dyn<Object>, throughoutthepaper.  2.5 TwoCompatibilityRelations As we have already \nmentioned, the type system of the sur\u00adface language uses the compatibility relation, denoted by ;, to \ncheck argument passing and assignments. This rela\u00adtion has both co-and contra-variant .avors when dyn \nis considered a top type: for example, both Cell<Shape> ; Cell<dyn> and Cell<dyn> ; Cell<Shape> hold \nand so both Cell<Shape> c1 = ...; Cell<dyn> c2 = c1; and Cell<dyn> c1 = ...; Cell<Shape> c2 = c1; are \naccepted(statically).The reasonto allow contravariance (thelatterkindof compatibility)is simplybecauseit \nsome\u00adtimes runs safely. For example, when c1 happens to be an 3It could be allowed in thepresence of \noverloading. 4For F-bounded type variables, such automatic recovery is dif.cult. We wouldhave tohaveprogrammers \nwrite upperbounds explicitly.  object new Cell<Shape>(...),thelatter codefragmentis just .ne. However, \nwe should not use this compatibility relation for casts.For example,considerthefollowing(surfacelan\u00adguage)code: \nCell<dyn> c1 = new Cell<dyn>(new Polygon(...)); Cell<Rectangle> c2 = c1; // accepted thanks // to contravariance \nc2.x.methodOnlyInRectangle(); // accepted since // c2.x is Rectangle On the second line, a run-time \ncheck iCell<Rectangle>I c1 is performed. Since the run\u00adtime type of c1 is Cell<dyn>,if iI used the compatibility \nrelation, the cast will succeed, resulting in the unexpected method-not-found error! (Notice that the \ninvocation of methodOnlyInRectangle should involve no checks because the receiver s static typedoes notcontain \ndyn.) Thus, we use another relation .:called run-time compat\u00adibility for run-time checks. This relation \nis a subrelation of ; anddisallows contravariance:for example, Cell<dyn> .:Cell<Rectangle> does not hold. \nHowever, it still allows covariance (such as Cell<Rectangle> .:Cell<dyn>), so it is more permissive than \nsubtyping. (It is not com\u00adpletely safe that is why we still need argument checks by e0.m[T1,..., Tn|C<X>](e1,..., \nen).) Having thesediscussionsin mind, weformalize the core of the surface and intermediate languages \nin the following sections.  3. FeatherweightGJ withDynamicTypes Inthis section, weformalizethe surfacelanguageFGJdyn \n, an extension ofFGJ withdynamictypesto modelatype system of gradually typed generics. For simplicity, \nwe omit some featuresfoundinFGJ:polymorphic methods and typecasts, whichwouldbe easyto add.AsinFGJ, we \nalso omitmethod overloading. We focus on the type system in this section and leave the de.nition of the \nintermediatelanguage called FGJiI and translation from FGJdyn to FGJiI to Section 4. ForthosewhoarefamiliarwithFGJ,weuse \ngrayboxes to show maindifferencesfromFGJ. 3.1 SyntaxandLookupFunctions The abstract syntax of FGJdyn \nclasses, constructors and methoddeclarations, and expressions arede.ned asfollows: De.nition1 (Syntax \nofFGJdyn ). ., . ::= . |. S, T, U, V ::= X |N | dyn<N> N, P, Q ::= C<T> e ::= x |new N(e) |e.f |e.m(e) \n. L ::= class C<X .N> . N{Tf; K M} K ::= C(T f){super(f); this.f=f;} M ::= T m(T x){ return e; } The \nmetavariablesA, B, C, D and E rangeoverclass names; W, X, Y and Z range over type variables; N, P and \nQ range over class types(dyn<N> is not a class type); S, T, U and V range overtypes; .and .range overkinds \nof type variables; f and g rangeover .eldnames; m ranges overmethodnames; x ranges over variables; d \nand e range over expressions; L ranges over class declarations; K ranges over constructor declarations; \nand M ranges over method declarations. We assume that the set of variablesincludesthe special variable \nthis. We write f as shorthand for a possibly empty sequence f1,f2,... ,fn (andsimilarly for C, X, N, \nT, x, e, etc.) and write M as shorthand for M1... Mn (with no commas). The length of a sequence f is \nwritten #(f). We write f . f when f equals to fi where 1 = i = #(f), and write f ./f otherwise. We also \nabbreviate various forms of sequences ofpairs, writing Tf as shorthandfor T1 f1,... ,Tn fn where #(T) \n=#(f), and similarly T f; for the se\u00adquence of declarations T1 f1;\u00b7\u00b7\u00b7 Tnfn; , this.f=f; . for this.f1=f1;\u00b7\u00b7\u00b7 \nthis.fn=fn; ,and X .N for X.1 1 n . N1,... ,X.. Nn . We write the empty sequence as n anddenote concatenation \nof sequences using a comma. Se\u00adquences are assumedto contain noduplicate names.We ab\u00adbreviatethekeywordextends \nto the symbol .. dyn<N> is atype ofdynamicallytypedexpressions.Since itis nota class type, dyn<N> can \nneitherbe used toinstanti\u00adate an object(by new expressions) norbe used as abound of a type variable. \nWe always write the bound N in the formal language. A program in FGJdyn is a pair (CT,e)of a class table, \nwhichisa .nitemappingfromclassnames C to classdecla\u00adrations L, and a closed expression correspondingtothebody \nofthe main method.We assume that CT satis.es some san\u00adityconditions:(1)CT(C)= class C<X . N> . ... {...} \nfor every C . dom(CT);(2) Object ./dom(CT);(3) for every class name C (exceptObject)appearing anywherein \nCT, we have C . dom(CT); and(4) there are no cycles in the transitive closure of . (as a relation between \nclass names).Inwhatfollows,we .xaclasstable. As in FGJ, we use functions .elds and mtype to look up .eldde.nitionsand \nmethod typesinagivenclasstable. We also use a predicate nomethod to state non-existence of a method.We \nomittheir straightforwardde.nitions(see appendixin thefull version of thispaper orIgarashi,Pierce, and \nWadler [18] for the de.nitions of .elds and mtype); theirfunctionalities are summarizedinTable2. Some \nother auxiliary functions are de.ned in Figure 1. We use a function bound to compute the upper bound \nof a typein aboundenvironment.,whichisa .nitesequenceof triples of a type variable,itskind andits bound, \nwhere type variables are pairwise distinct.5 When bound is used with a class type, it returns the given \ntype itself. When bound is used with a dynamic type, it returns the bound of the 5So,. canbeconsidered \na .nitemapping.  .elds(N)= Tf collects .elds in class N and its super type. mtype(m, N)= T . T looks \nup the type of method m in class N orits supertype. nomethod(m, N) holdswhenthereis nomethod m in class \nN orits super type. Table 2. De.nition of FGJdyn : Auxiliary functions and predicates. dynamic type. \nWe have a function kind to look up kinds of typevariables.We use apredicate dynfree to state that a typeisdynamic-free,i.e.,it \ncontains nodynamictype.  3.2 SubtypingandCompatibility Now wede.ne subtypingandcompatibilityrelations.As \nwe have mentioned, there are two compatibility relations(writ\u00adten .:for run-time compatibility and ; \nfor static compati\u00adbility). We write . . S <: T to mean S is a subtype of T under bound environment .. \nSimilarly for . . S .:T and . . S ; T.We abbreviate a sequence ofjudgments . . S1 <: T1,..., . . Sn <: \nTn to . . S <: T (and similarlyfor .:and ;). De.nition 2 (FGJdyn subtyping and compatibility). The subtyping \nand compatibilityjudgments . . S <: T and . . S .:T and . . S ; T are de.ned by the rules in Figure2. \nThe subtype relation<:is mostlythe same asthatofFGJ. The .rst two rules mean that it is re.exive and \ntransitive; the third rule that a type variable is a subtype of its bound; thefourthruleis aboutinheritance-basedsubtyping \nanyin\u00adstance of a . clause gives subtyping. The last rule says a boundeddynamic type dyn<N> is a subtype \nof its bound N. In fact, dyn<N> and N denote the same set of instances instances of N and its subtypes \nand dyn<N> allows more operations(which arepotentially unsafe, though) to beper\u00adformed than N. So, dyn<N> \n<: N indeed agrees with the substitutionprinciple[23]. The compatibility relations are de.ned with the \nhelp of the auxiliary relation .. Intuitively, S . T means that T is obtained by replacing some class \ntypes in S with dy\u00adnamic types (with an appropriate bound). For example, Rectangle . dyn<Object> and \nCell<Rectangle> . Cell<dyn<Object>> hold(under anyboundenvironment). So, . represents a form of covariance. \nThen, the compati\u00adbility relations .:and ; are de.ned as compositions of . and <: the former as (<:;.)(\u00b7;\u00b7 \nis a composition of two relations) and the latter as (.-1;<:;.), where .-1 is the inverse of . and represents \naform of contravariance.As a result, two types are statically compatible if replacing dy\u00adnamic types \nwith class typesyields two typesin the subtyp\u00adingrelation. For example, . . Cell<dyn<Object>> ; Cell<Rectangle> \n.-1 can be derived since Cell<dyn<Object>> Cell<Rectangle>.Also, . . Cell<dyn<Shape>> ; Cell<dyn<Object>> \n.-1 since Cell<dyn<Shape>> Cell<Shape> and Cell<Shape> . Cell<dyn<Object>>. (Note that Cell<dyn<Shape>> \n<: Cell<dyn<Object>> does not hold.) dyn<Object> can be considered either a top type or a bottom type, \ni.e., . . T ; dyn<Object> and . . dyn<Object> ; T are satis.ed for any T, and the relation ; is nottransitivebecause \notherwise . . S ; T wouldbe impliedfor any S,T (as mentionedin[27,28]).dyn<N> can alsobe considered as \na top/bottomtypefor subtypes of N.  3.3 TypeWell-formednessandTyping We, then,de.ne well-formedtypes \nandtyping. De.nition3(FGJdyn type well-formedness). Thetype well\u00adformednessjudgment. . T ok,read as inbound \nenviron\u00adment ., type T is well formed, is de.ned by the rules in Figure3. The last rule means that a \nbounded dynamic type is well formed if its upper bound is well formed. The third rule means that a class \ntype is well formed if it has well formed type arguments that satisfy the correspond\u00ading type parameters \nupper bounds. Note that we use .:rather than <: or ;. First, <: cannot be used because we want to use \ndynamic types as type arguments. For example, Cell<dyn<Object>> is well formed because dyn<Object> .:Object. \n; should notbe used, either,be\u00adcause we want to reject a type like ShapeCell<Object>. (Note thatObject \n; Shape.) The third rule also requires that type arguments mustbedynamic-freeif thekind of the correspondingtype \nvariableis .. Now we are ready to de.ne typing. We use G as a type environment, which is a .nite mapping \nfrom variables to types, written x :C. De.nition4 (FGJdyn typing). The typejudgments.;G .G e :T, readas \nin environment .and G, expression e hastype T, and M OK IN C<X .N>, read as method M is well-formed in \nclassC<X .N> and L OK, read as class L is well-formed arede.ned asinFigure4. Most of the rules are straightforward \nadaptation of those inFGJ[18], except that the relation ; is substitutedfor <:. TG-FIELD2 and TG-INVK2 \nare additional rules, used when the receivertypeis aboundeddynamictype.Note that these rules are applied \nonly when it is not known whether the receiverhasa .eld ormethod tobeaccessed(thepremises f .. f in TG-FIELD2 \nand nomethod(m, N)in TG-INVK2).  Bound environment .(X)=(.,N) bound.(N)= N bound.(X)= N Dynamic-free \ntypes  Figure1. De.nition ofFGJdyn:Auxiliaryfunctions andpredicates. Subtyping . . S <: U . . U <: \nT . . T <: T . . X <: bound.(X) . . S <: T . class C<X . . C<T> <:[T/X ]N Compatibility . . S . U \n. . U . T . . S <: U . . U . T . . T . T . . S . T . . S .:T . . S . T . . T <: S . . S . N . . U . \nS . . U .:T . . C<S> . C<T> . . T . dyn<N> . . S ; T .N> . N {...} Figure2. De.nition ofFGJdyn :Subtyping \nand compatibility. . class C<X .N> . N {...} . . T ok . . Object ok X . dom(.) . . X ok . . C<T> ok \n  Figure3. De.nition ofFGJdyn :Type well-formedness. In other words, TG-FIELD1 or TG-INVK1 can be used \nfor expressions whose receiver type is dyn<N>, as long as the memberisde.nedin the classde.nition of \nN. The predicate override, used in method typing, is to checkif a method m in classN canbe overriddenby \na method of type T . T. Parameter types must be the same between the overriding and overridden methods6 \nand the return type of the overriding method mustbe run-time compatible with that of the overriddenmethod.We \ncannot use ; here: if ; were used, it would be possible to override a method that returns T by one that \nreturns dyn<Object> in a subclass, and then to override it by another that returns S for any S. As a \nresult,invokinga method, whose static returntypeis T, 6This restriction can easily be relaxed by using \nthe relation .:,but then we need a careful examination when we add method overloading. might actuallyinvokethe \nthird methodthat returns S, which canbe verydifferentfrom T,duetolatebinding! We write .G (CT,e): T to \nmean the program is well formed,i.e,ifall the classesin CT are wellformed and e is well typed underthe \nempty environment. Wehave notcompleteddeveloping a type checking algo\u00adrithm. In fact, it is not even \nclear that the compatibility re\u00adlation ; isdecidableforthesame reasonas variance-based subtyping[21]. \nConservative Typing over FGJ. Even at this point, we can show an interesting property that typing in \nFGJdyn is a conservative extension of that in FGJ. Namely, as far as a class table written in the FGJ \nsyntax is concerned, it is well typed undertheFGJ rulesif and onlyifitis well typed undertheFGJdyn rules.Thefollowinglemmais \nakey to the conservative extensionproperty(Theorem6).   Expression typing .;G .G x :G(x)(Tg-Var) . \n.G N ok .elds(N)= T f .;G .G e :U .;G .G new N(e) :N (Tg-New) .;G .G e0:T0 .elds(bound.(T0))= Tf (Tg-Field1) \n.;G .G e0.fi:Ti  .;G .G e0:T0 .;G .G e :V mtype(m, bound.(T0))= S . S (Tg-Invk1) .;G .G e0.m(e) :S \n Method typing mtype(m, N)= U . U implies T = U and . . T .:U override.(m, N, T . T) . .= X <:N . . \nT,T ok .;x :T,this :C<X> .G e0:S .  . . S ; T class C<X .N> . N {...} override.(m, N, T . T) (Tg-Method) \n T m(T x){ return e0; }OKINC<X .N> Class typing . X <: N . N,T,N ok .elds(N)= Ug M OK IN C<X .N> K = \nC(U g, T f){super(g); this.f=f;} . (Tg-Class) class C<X .N> . N{Tf; K M}OK Figure4. De.nition ofFGJdyn \n:Typing. Lemma5. If. . S . T and dynfree.(T), then S = T.  If. . S .:T and dynfree.(T), then . . S \n<: T.  If. . S ; T and dynfree.(S), then . . S .:T.  If . . S ; T and dynfree.(S)and dynfree.(T), then \n. . S <: T.  We write.FGJ (CT,e): T iftheprogram,whichdoes not contain dyn<N>,is wellformed undertheFGJ \nrules. Theorem 6 (FGJdyn Typing is Conservative over FGJ Typ\u00ad . ing). If. = . for every class C<X .N> \n. N {...} inCT and none of dyn<P> appearsin (CT,e),then .FGJ (CT,e): T ...G (CT,e): T. c1  4. FromFGJdyn \ntoFGJ I In this section, we .rst de.ne a formal model FGJiof the intermediate language, into which source \nprograms are I translated. FGJihas operational semantics, as well as a type system. After stating theorems \nabout type safety of I I FGJi, wepresentformaltranslationfromFGJdyn toFGJiandstatetheoremsthattranslationpreservestyping.Wehave \nweak and strong versions of type safety: the weak version means that a well typed program can raise errors \nonly at run-time checks and the strong version means that a well typed program without containing run-time \nchecks never goes wrongin the usualsense. c1 4.1 TheTargetLanguageFGJ I The syntax of FGJiextends that \nof FGJdyn , by including special forms for run-time checks and run-time errors. We show only the grammar \nfor expressions, values (used to de.nethe semantics), anderrors;the others are the same. I De.nition7(Syntax \nofFGJi).  e ::= x |new N(e) |e.f |e.m(e) v,w ::= new N(v) E ::= NoSuchField |NoSuchMethod |IllegalArgument \n|BadCast We avoid repeating thede.nitions of thefollowingfunc\u00adtions,predicates, and relations sincethey \narede.ned exactly the same way asinFGJdyn . Functions bound kind .elds mtype Predicates dynfree nomethod \noverride Relations Subtyping<: Compatibility., :. Judgments Type well-formedness Figure 5 introduces \nan auxiliary function tyargs(N, C), which is used in the reduction rules described later to get type \nargumentsfrom run-timetypes.We also use afunction mbody(m, N), which returns a pair x.e of a sequence \nof formal parameters and a method body expression, if N has m.Its straightforwardde.nitionis omitted. \nI We show the main typing rules of FGJiin Figure 6. Animportantpointto noteisthat we use only the run-time \ncompatibility .:andno ; appearsinthetypingrulesbecause a use of ; compiles to a cast iI , which uses \n.:foritsrun\u00adtime check. TR-INVK1 is the rule for a method invocation without run-time checks. The receiver \ntype must be dyn\u00adfree.TR-INVK2isthe rulefor a methodinvocationwithrun\u00adtime argument checking. C<T> can \nbe considered an initial (i.e., compile-time)static type of receiver e0; the condition N .:C<T> is required \nsince the receiver type may change as reduction proceeds. TR-INVK3 is the rule for a method invocation \nthat checks whether the method m exists at run time. The receiver and arguments can be arbitrary typeable \nexpressions and the type of theinvocationis dyn<Object>. TR-CAST isthe rulefor casts;andTR-ERROR isthe \nrulefor errors. We omit typing rules for object constructions, .eld ac\u00adcesses, methods and classes, since \nthey are similar to those I inFGJdyn .We write .R (CT,e): T to mean theFGJipro\u00adgram(CT,e)is wellformed. \nWe give main reduction rules in Figure 7. The evalua\u00adtionorderis,unlikeFGJ, .xedtobeleft-to-rightandcall-by\u00advaluetodeal \nwith run-time errors moreprecisely.R-FIELD1 and R-INVK1 are quite standard. They check the existence \nof a .eld/method in the receiver type but the check should never fail for well-typed expressions as we \nwill see later. R-FIELD2, R-INVK2, R-INVK3 and R-CAST are for run\u00adtime checks, which can raise a run-time \nerror. In R-INVK2, the type arguments in method parameter types are .lled in according to the run-time \nclass of the receiver value, and checked against the run-time class of the actual arguments. In R-INVK3, \nwe needtolookupthe method argumenttypes by mtype toperform run-time checksfor actual arguments. The rule \nR-CAST means that a cast succeeds when the sub\u00adject typeis run-time compatible withthe target type. We \nalsohave reductionrulesfor errors showninFigure8. Each rulehaspremises negating those in the corresponding \nreduction rule. Note that only run-time checks have error\u00adraising reductions.We also need rulesthatpropagateraised \nerrors upwards,but we omit them. I FGJiis(weakly)type-safeinthe sensethata well-typed program, if it \nterminates, yields a value or raises an error. Moreover,ifaprogramdoes notcontaindynamictypes,then itis \nstronglytype safe. I Theorem8(FGJiweaktype safety). If.R (CT,e):T and '' ' e -.* e where e is a normalform,thene \nis either 1. a valuev with ; .R v :N and . N .:T, or 2. an errorError[E].  I Theorem 9 (FGJistrong \ntype safety). If .R (CT,e):T where (CT,e)does notcontain run-time checks and e -.* '' ' e where e is \na normal form, then e is a value v with ; .R v :N and . N .:T. These theorems areprovedin a standardmanner \nof com\u00adbining subject reduction andprogress[37].The statements and proofs of both properties are, in \nfact, very similar to those for FGJ. One non-trivial property required is transi\u00adtivity of .:. Theorem \n8 should be understood with the typing and I error-raising reduction rules of FGJi. First, in Figure \n6, TR-INVK1saysthatthe receivertype of an ordinarymethod invocationis alwaysdyn-free.Then,inFigure8, \nError[E] is reduced onlyfrom run-time checks, notfrom an ordinary member access.Consideringthese andthe \nsubject reduction propertytogether,we can seethatno memberaccess on dyn\u00adfree receiver raises an error. \n 4.2 TranslationfromFGJdyn toFGJc1 I Thejudgmentof translationfromFGJdyn toFGJiis of the ' form.;G . \nee :T, read FGJdyn expression e oftype T I under environments Gand .translatestoFGJiexpression e ' . \nThetranslationisdirectedbytypinginFGJdyn .We show onlythe rulesfor methodinvocationsinFigure9. (S . T).e \ninserts a cast when source type T is not run-time compatible with S.This reduces unnecessary casts. TRNS-INVK1isforordinaryinvocations; \ncasts areinserted for testing run-time compatibility of arguments. If V are dyn-free, then actually no \ncasts will be inserted, thanks to Lemma5. TRNS-INVK2isforinvocations whose arguments  . N <: P tyargs(P, \nC)= T tyargs(C<T>, C)= T tyargs(N, C)= T I Figure5. De.nition ofFGJi:Auxiliaryfunction. .;G .R e0:T0 \n.;G .R e :V bound.(T0)= P . . P .:N mtype(m, N)= S . S (Tr-Invk1)  .;G .R e0.m(e) :S I Figure6. De.nition \nofFGJi:Typing. I Figure7. De.nition ofFGJi:Reductions. .:T . N . .elds(N)= Tf f .. f (E-Cast) (E-Field) \nnT) new N(v) -. Error[BadCast] get(new N(v), f) -. Error[NoSuchField] nomethod(m, N) (E-Invk) invoke(new \nN(v), m, w) -. Error[NoSuchMethod] w = new P(...) . Pi ..:[tyargs(N, C)/X]Ui (E-Invk-Arg1) new N(v).m[U|C<X>](w) \n-. Error[IllegalArgument] mtype(m, N)= U . Uw = new P(...) . Pi .: . Ui (E-Invk-Arg2) invoke(new N(v), \nm, w) -. Error[IllegalArgument] I Figure8. De.nition ofFGJi:Error-raising reductions. Cast insertion \n e (if .. T .:S) def (S . T).e = nS) e (otherwise) Translation of method invocation '' .;G . e0 e0:T0 \n.;G . ee :V bound.(T0)= N dynfree.(N) mtype(m, N)= S . S . . V ; S (Trns-Invk1) ' .;G . e0.m(e) e .m((S \n. V).e ' ) :S 0 '' .;G . e0 e0:T0 .;G . ee :V bound.(T0)=[T/X]C<X> \u00acdynfree.(C<T>) mtype(m, C<X>)= U \n. U . . V ; [T/X]U (Trns-Invk2) ' .;G . e0.m(e) e .m[U|C<X>](([T/X]U . V).e ' ) :[T/X]U 0 '' .;G . \ne0 e0:dyn<N> .;G . ee :V nomethod(m, N) (Trns-Invk3) .;G . e0.m(e) invoke(e 0' , m, e ' ) :dyn<Object> \nI Figure9. TranslationfromFGJdyn toFGJi. must be checked at run time. Note that the receiver type T0 \nin these two rules can be dyn<N> when there is an appro\u00adpriate method m in N because the existence of \nm is statically guaranteed. TRNS-INVK3 is forinvocations whose receiver typeis dyn<N> and N has no appropriate \nmethodm. Although we omit its de.nition, we write (CT,e) ' (CT ,e ' )to meanthattheFGJdyn program(CT,e)is \ntrans- I ' lated to theFGJiprogram(CT ,e ' ).Then, the translation preserves well-typedness,i.e., a well-typedFGJdyn \nprogram I translates to a well-typedFGJiprogram. Theorem 10 (Weak translation). If .G (CT,e):T, then \n'' (CT,e)(CT ,e ' ) and .R (CT ,e ' ):T for some ' (CT ,e ' ). Theorem 11 (Strong translation). If . \n= . for every . class C<X .N> . N {...} in CT and none of dyn<P> appears in (CT,e) and .G (CT,e):T, \nthen (CT,e) '' ' (CT ,e ' ) and .R (CT ,e ' ):T for some (CT ,e ' ) and ' (CT ,e ' )does notcontain run-time \nchecks. CombiningTheorem8andTheorem10, we can seethata member access which translates to an ordinary \nmember ac\u00adcess without run-time checks will notfail.In other words, a statically typedportion(methodinvocations \nwhose receiver and argument types are dyn-free) will neverfail.Thisis the type safety ofFGJdyn .  5. \nImplementation In this section, we report the basic implementation scheme for Java. Our plan is to add \na new compilation phase to transform a code tree to have the run-time checks inserted as the same way \nas the other existing compilation phases such as the type erasing transformation.The transformation follows \nthe rules in Section 4 and the run-time checks can be implemented using existing re.ective features of \nJava. Sincethe currentJVMhas norun-timeinformationof type arguments ofgenerics, we need a mechanismtolook \nupfull run-time typeinformation.We follow the technique of type passing[32 34]for this. 5.1 Run-timeChecks \nThe run-time checks iTI e, get(e, f) and invoke(e, m, e) can be implemented by re.ection APIs such as \njava.lang.Class, java.lang.reflect.Field and java.lang.reflect.Method. We implement a class Cla to represent \ntype descriptors and a static method Cla.$() togetthe run-timetypeinformationofobj includ\u00ading type arguments. \nThe return value of Cla.$(...) is a typedescriptord (aninstance ofclass Cla describedin more detail later), \nwhich has .eld cl of a java.lang.Class instance, .eld p of an array of type descriptors of type arguments, \nand h of an array of a superclass chain, where d.h[0] is d itselfand d.h[d.h.length-1] is Object. The \ncast iTI e, which corresponds to R-CAST, can be implemented as the following method cast(), which casts \nobj to class klass. Object cast(Cla klass, Object obj) { if ((obj instanceof Parametric &#38;&#38; isRuntimeCompatible(Cla.$(obj), \nklass)) || klass.cl.isInstance(obj)) { return obj; } else throw new ClassCastException(); } If the type \nof obj has type arguments, then isRuntimeCompatible() method checks if the type of obj and the target \ntype of the cast satisfy the relation .:. Otherwise, the cast acts as a normal one, which uses the subtype \nrelation <:. The argument type checking for e.m[T|C<X>](e) in R-INVK2 can also be done by this method. \nAlthough not proved, we conjecture that the explicittransitivity rulefor .is actuallyredundant.Without \ntransitivity,itis easy to check run-time compatibility.  Since iTI is inserted by the translation and \ntypes T in e.m[T|C<X>](e) are speci.edbythe translation,the target type of a cast can be determined mostly \nat compile time, except that the type argumentsfor X have to be .lled at run time. Theimplementation \nofget(e, f), which correspondsto R-FIELD2,isquite easy.We have Object.getClass() to get an instance of \njava.lang.Class, which has method getField(), which looks up a .eld by a .eld name and throws NoSuchField \nexception when no .eld is found. The return value of getField() is an instance of java.lang.reflect.Field, \nwhich has method get(), which retrievesthe .eld valuefromthereceiver. Object get(Object r, String f) \n{ Field fld = r.getClass().getField(f); return fld.get(r); } The special form invoke(e, m, e), which \ncorresponds to R-INVK3, canbeimplemented as the method invoke() below. Suppose Met is a class for parameter \ntypes of a method,whichhas .eld m of java.lang.reflect.Method and .eld params of method typedescriptors.Also \nsuppose mtypes() is a method to look up method signatures by a method name. Object invoke(Object r, String \nm, Object[] args) { Met[] mets = mtypes(r, m); M: for (int i=0, l=mets.length; i < l; i++) { if (mets[i].args.length \n!= args.length) continue M; for (int j=args.length-1; 0 <= j; j--) { try { mets[i].params[j].cast(args[j]); \n} catch (ClassCastException e) { continue M; } } return mets[i].m.invoke(r, args); } throw new NoSuchMethodException(); \n} This method looks up methods named m, and calls the .rst method7 whose parameter types match the argument \ntypes. cast() is used to match parameters and arguments. Ifthe casts succeed,thenjava.lang.Method.invoke \nAPI performs realinvocation ofthe method.Otherwise,itthrows NoSuchMethodException.Note that the target \ntype of the cast must be determined at run time because we have no information ofthe receivertype at \ncompiletime. 7Wearenotconsidering method overloading hereforsimplicity.  5.2 InformationonTypeArgumentsatRunTime \nAs we have already seen, we need information on type ar\u00adguments at run time. It requires additional memory \nusage and time costs,but a relativelyhighperformancetechnique isproposedbyViroli et al.[32 34].Wequickly \nreview this technique. Thebasicidea of thistechniqueistopasstypeinforma\u00adtionasa .eld of anobjectbytransformingthecode.Forex\u00adample, \nthefollowing codedescribeshow the transformation goes. Cell<Shape> c = new Cell<Shape>(new Rectangle(...)); \n// Cell<Shape> c // = new Cell<Shape>( // new Cla(Cell.class, // new Cla[]{ // new Cla(Shape.class) }), \n// new Rectangle(...)); The .rstlineistheoriginalcode,and thecommentisthe translatedcode.TheinstanceofCla,whichis \natypedescrip\u00adtorclass,ispassed asa .rstargument of theconstructor.Of course,thede.nition of class Cell \nis alsotransformedto re\u00adceive a typedescriptor at the constructor, and to implement aninterface, whichprovides \naccess to the typedescriptor. The transformation described above is not optimized at all: a new type \ndescriptor is generated every time the con\u00adstructoris called.So, a mechanism to reduce the number of \ngenerations oftypedescriptorsto onefor adistinct type, us\u00adingdoublehashing,is reportedin[32 34].  5.3 \nPreliminaryBenchmarkEvaluation Since wehave no workingcompileryet, we onlygivebench\u00admarksfor each run-time \ncheckwith minimalhand-translated code usingthose checks separately.These mayhelpto seeif our implementation \nidea is reasonable and how much dy\u00adnamictypes slowdown executionoftheprogram.Execution ofdynamically \ntyped codeisquite expensiveespecially for method invocations on a receiver of dynamic type, but we believethat \nthe costis notunacceptable. Benchmarksfor eachrun-time checkis showninTable3. Foreach run-timecheck,weused \ntest codeincluding asin\u00adgle expression with a run-time check and the same expres\u00adsion without it. Each \ntest code iterates 100/10000/1000000 times and overalltime consumptions arelisted. For the expression \niTI e, we used a static type for the target type of the cast. The cast looks into type arguments but \nwe can sayitis not so expensive accordingto the result. We can say the same thing about the run-time \ncheck in the expression e.m[T|C<X>](e) since it only needs a cast for each argument. The run-time check \nin the expression get(e, f) is relatively expensive because it uses a feature of java.lang.reflect.Field.The \nrun-time checkin the expression invoke(e, m, e) isquite expensivebut the cost  #ofiterations 100 10000 \n1000000 iTI e e 0.006 0.004 0.019 0.008 0.125 0.087 get(e, f) e.f 0.003 0.001 0.043 0.003 0.356 0.056 \ne.m[T|C<X>](e) e.m(e) 0.000 0.000 0.003 0.002 0.072 0.080 invoke(e, m, e) e.m(e) 0.007 0.000 0.093 0.003 \n3.430 0.069 Table3. Executiontime ofeach run-time check(sec.) seems somewhat inevitable since it must \nresolve a method signature and check run-timetypes of the arguments. InTable4, wehavetestedcasts with \nmore complextarget types.We used adynamictype argumentfor the targettype. The dynamic type argument has \na bound, which is a class typepossiblyincludinganotherdynamictype argument.We count the nested dynamic \ntype argument as depth and the resultfor each targettype of thedepthislistedin the rows. Depth(s)\\# ofiterations \n100 10000 1000000 1 0.000 0.004 0.105 2 0.000 0.007 0.171 3 0.001 0.009 0.235 4 0.001 0.008 0.268 5 0.001 \n0.009 0.301 Table4. Executiontime ofcasts(sec.) We can conclude that the operationfor checkingthe run\u00adtimecompatibility \n.:isnottooexpensiveincomparisonwith the other run-time checks.  6. RelatedWork Thereis muchworkonmixingdynamicandstatictypes(see, \nfor example,SiekandTaha[27,28]for a moreextensivesur\u00advey).Here, we compare our work mainly with related \nwork on object-oriented programming languages and parametric polymorphism. We .rstreviewproposalstoapply \nstatictypecheckingto dynamicallytypedlanguages.Bracha andGriswold[6]have proposedStrongtalk, whichis \natypecheckerfor adownward compatible variant ofSmalltalk, adynamically typed class\u00adbasedobject-orientedprogramminglanguage.Thetype \nsys\u00adtem of Strongtalk is structural and supports subtyping and genericsbutdoes notacceptpartiallytypedprograms.Thie\u00admann \n[30] has proposed a type system for (a subset of) JavaScript, which is a prototype-based object-oriented \nlan\u00adguage, to avoid somekinds of run-time errorsby static type checking.Furr,An,Foster, andHicks[11] \nhavedeveloped DiamondbackRuby, an extension ofRubywith a static type system.Theirtypesystem,which seemsuseful \nto .ndbugs, however,does notoffer static type safety. Anderson and Drossopoulou [3] have proposed a type \nsystemfor(a subsetof) JavaScriptfortheevolutionfrom JavaScript to Java. Although it is nominal and concerned \nwith script-to-program evolution,theirtype systemdoes not have subtyping, inheritance, or polymorphism; \nmoreover, this work is not concerned about safety of partially typed programsin the middle ofthe evolution. \nLagorioandZucca[22]havedevelopedJust, an extension ofJava with unknowntypes.Althoughthereis some overlap \nin the expected uses of this system and gradual typing, the mainpurpose of unknowntypesis to omittypedeclarations; \npossiblyunsafe use of unknowntypesis rejectedbythetype system.They use re.ectiontoimplement member access \non unknowntypes. Gray,Findler, andFlatt[14]haveimplementedan exten\u00adsion ofJava withdynamictypes and contract \nchecking[9] forinteroperability withScheme.They mainlyfocus on the design andimplementationissues andgive \nnodiscussion on theinteraction withgenerics.Their technique to implement re.ective calls canbe usedfor \nour setting. Gray[12,13] studied mixingJava as a statically typed language and JavaScript as a dynamically \ntyped scripting language. Unlike our language, classes with dynamically typed methods are allowed to \ninherit from a class that is statically typed, and vice versa. As wehave alreadymentioned,Siek andTahahave \nstud\u00adiedgradualtypingforAbadi-Cardelli s objectcalculus[28]. However,thelanguageis object-based(as opposedto \nclass\u00adbased)andparametricpolymorphismis notstudied.Another pointisthattheimplementationofrun-timechecksforclass\u00adbased \nlanguages seems easier than that for object-based languages, since, in class-based languages, every value \nis tagged with its run-time type information and the check canbeperformedin one step(unlikehigher-order \ncontract checking,whichchecksinputsto andoutputsfromfunctions separately). Sage [15], a functional language \nbased on hybrid type checking[10], supportsbothparametricpolymorphismand dynamic types. Matthews and \nAhmed [24] and, more re\u00adcently,Ahmed,Findler,Siek, andWadler[2] givetheoret\u00adicalaccountsforthe combination \nofimpredicativepolymor\u00adphism withdynamictyping.In allofthese works, adynamic typeis compatible(in ourterminology)with \nuniversaltypes whereasthereis no counterpart of universaltypesin our set-ting.None of themhas addressed \nbounded polymorphism. Wrigstad, Nardelli, Lebresne, \u00a8 Ostlund andVitek[5,38] have developed a language \ncalled Thorn, which integrates static and dynamic types in a different way. They have in\u00adtroduced the \nnotion of like types, which interface between statically and dynamically typed code. A variable of like \nC is treatedas type C at compiletimebut any valuecan .ow into the variable at run time (subject to run-time \nchecks).  Thisisdifferentfrom dyn<C>, which allows any operations staticallybut only subtypes of C can \n.owintoa dyn<C>. Bierman, Meijer and Torgersen[4] added dynamic types toC..They also translate aprogram \nof the surfacelanguage into intermediate code, which has explicit run-time checks. Intheirsetting,dynamictypescanbe \nargumentsofgeneric classes, but their subtype relation is only invariant with re\u00adspecttotypeparameters, \nso,for example,itis notpossible topass Cell<Rectangle> to Cell<dyn>. Thereis some work on applying thegradual \napproach to advancedtypesystemsforobject-orientedprogramminglan\u00adguages.Wolff, Garcia,Tanter andAldrich[36] \ndeveloped a gradual system for typestate-oriented programming, where operations on an object are restricted \nby the internal state of the object. Potentially safe code which rejected by other typestate-orientedtype \nsystems canbe acceptedintheir sys\u00adtemthanksto adynamictype.Sergey andClarke[26] pro\u00adposed a gradual system \nfor ownership types, which repre\u00adsent encapsulation of objects and are used as invariants in type checking. \nTheir gradual system allows a programmer to omit ownership annotations withoutlosing encapsulation properties \nofannotated code. There are some relatedfeaturesthatalready existinJava. Wildcards, studied by Igarashi \nand Viroli [17] and Torg\u00adersen,Ernst,Hansen,Ah\u00b4e,Bracha andGafter[31], enable a .exible subtyping with \nboth co-and contra-variant para\u00admetric types, though only statically resolved members can be accessed \non a receiver of a wildcard type anditis not al\u00adlowedto specifya wildcardtype as atype argumentin a new \nexpression. Raw types are proposed by Bracha, Odersky, Stoutamire, and Wadler [7] to deal with compatibility \nbe\u00adtweenlegacymonomorphicJava code and newpolymorphic Java code.Ageneric classC<X> canbe used as a rawtype \nC, without type arguments, and assigning a value of C<T> to a variable of C, or even creating an instance \nof C via new ex\u00adpression are allowed.Thisbehavioris similar toFGJdyn sif we consider C tobe an abbreviation \nofC<dyn, ..., dyn>. However, with raw types, even statically typed code can go wrong.  7. Conclusions \nWehavedesigned alanguagethat combinesdynamictypes andgenerics.Thelanguage allowsdynamictypestobe used \nas type arguments of a generic class and realizes smooth interfacing between dynamically and statically \ntyped code thankstothe .exiblecompatibility relation.Wehaveintro\u00adducedboundeddynamictypestodealwith the \ncase where a typeparameterhas an upperbound. The language is formalized as a minimal core model of Java \nincluding the feature of generics. As in other gradual type systems, we have proved safety properties, \nwhich en\u00adsure that statically typedpartsin aprogram nevergo wrong. We have also reviewed the sketch of \nan implementation scheme,whichis anideatodevelop agradually typedJava compiler by extending an existing \nJava compiler without modifyingJVM. Future Work. Our run-time compatibility does not al\u00adlow argument \npassing, for example, from Cell<dyn> to Cell<Rectangle>. It might be too early to abort the exe\u00adcution \nat this point since the value in the Cell may not be used at all.Wethinkwe can relaxthe restrictionbydeferring \nthecheck until the .eldisaccessed.Then,weneed ablame assignment system[2,35] forprecise error reports.Imple\u00admentation \nof the blame tracking system for this design we think is done by wrapping an object with another object. \nThe wrapping object has the same interface as the original one,butitperformsa run-timecheck on every \nmemberac\u00adcess.Inasimplesetting,a subclass ofthe class oftheoriginal objectsuf.cesforthe class ofthe wrappingobject.However, \nthere are atleast twoproblemsin thisimplementation strat\u00adegyforJava-likelanguages.First, we need some \nmechanism to wrap anordinary.eld access.Second,awrapping class cannot extend a .nal class. Whenbytecode \nofagenericlibrary class compiledbythe standard Java compiler is used with client bytecode com\u00adpiled by \nour compiler, the client is not allowed to use dy\u00adnamic type arguments to the generic class since type \nvari\u00adables in the generic class are declared without kind .. We think that converting the library bytecode \nat load time will helpto relax this restriction. We also plan to investigate the interactions of dynamic \ntypes with other features such as overloading to make the language more realistic.  Acknowledgments \nWe thank the anonymous reviewers very muchfor thought\u00adful and thorough reviews. Ina is a Research Fellow \nof the Japan Society of the Promotion of Science. This work was supportedin part by Grant-in-Aidfor Young \nScientists(A) No. 21680002 and by Grant-in-Aid for JSPS Fellows No. 10J06019.  References [1] M. Abadi, \nL. Cardelli, B. Pierce, and G. Plotkin. Dynamic typingin a staticallytypedlanguage. ACM Trans. Prog. \nLang. Syst.,13(2):237 268, 1991. [2] A.Ahmed,R.B.Findler,J.G.Siek, andP.Wadler. Blamefor all. In Proc. \nof ACM POPL 11, pages 201 214, Austin, TX, Jan.2011. [3] C.AndersonandS.Drossopoulou.BabyJ-fromobjectbased \nto classbasedprogramming via types. In Proc. of WOOD 03, volume82 of Elsevier ENTCS,pages53 81,2003. \n[4] G. Bierman, E. Meijer, and M. Torgersen. Adding dynamic types toC. . In Proc. of ECOOP 10, volume6183 \nof Springer LNCS,pages76 100, Maridbor,Slovenia,June2010. \u00a8 [5] B. Bloom, J. Field, N. Nystrom, J. Ostlund, \nG. Richards, R. Strni.sa, J. Vitek, and T. Wrigstad. Thorn robust, con\u00adcurrent, extensible scripting \non the JVM. In Proc. of ACM OOPSLA 09,pages117 136, Orlando,FL,Oct.2009.  [6] G. Bracha and D. Griswold. \nStrongtalk: Typechecking Smalltalk in a production environment. In Proc. of ACM OOPSLA 93,pages215 230, \n1993. [7] G.Bracha,M.Odersky,D.Stoutamire,andP.Wadler.Making the future safe for the past: Adding genericity \nto the Java programminglanguage. In Proc. of ACM OOPSLA 98,pages 183 200,Vancouver,BC,Oct.1998. [8] R. \nCartwright and M. Fagan. Soft typing. In Proc. of ACM PLDI 91,pages278 292, 1991. [9] R. B. Findler and \nM. Felleisen. Contracts for higher-order functions. In Proc. of ACM ICFP 02,pages48 59,2002. [10] C. \nFlanagan. Hybrid type checking. In Proc. of ACM POPL 06,pages245 256, Charleston,SC,Jan.2006. [11] M.Furr,J.An,J.S.Foster,andM.Hicks.Statictypeinference \nforRuby. InProc. of ACM Symposium on Applied Computing (SAC 09),pages1859 1866, Mar.2009. [12] K. E. \nGray. Safe cross-language inheritance. In Proc. of ECOOP 08, volume 5142 of Springer LNCS, pages 52 75, \n2008. [13] K. E. Gray. Interoperability in a scripted world: Putting inheritance&#38;prototypes together. \nIn Proc. of FOOL 10,Oct. 2010. [14] K. E. Gray, R. B. Findler, and M. Flatt. Fine-grained inter\u00adoperability \nthrough mirrors and contracts. In Proc. of ACM OOPSLA 05,pages231 245, 2005. [15] J.Gronski,K.Knowles,A.Tomb,S.N.Freund, \nandC.Flana\u00adgan. Sage: Hybrid checking for .exible speci.cations. In Proc. of the Scheme and Functional \nProgramming Workshop, pages93 104, Sept.2006. [16] F. Henglein. Dynamic typing. In Proc. of ESOP 92, \nvolume 582 of Springer LNCS,pages 233 253, Rennes, France, Feb. 1992. [17] A.IgarashiandM.Viroli.Variantparametrictypes:A.exible \nsubtyping schemeforgenerics. ACM Trans. Prog. Lang. Syst., 28(5):795 847, Sept.2006. [18] A.Igarashi,B.C.Pierce,andP.Wadler. \nFeatherweightJava: A minimal core calculus for Java and GJ. ACM Trans. Prog. Lang. Syst.,23(3):396 450, \nMay2001. [19] L. Ina and A. Igarashi. Towards gradual typing for generics. In Proc. of STOP 09,pages \n17 29, Genova, Italy, July 2009. Available alsoin theACMDigitalLibrary. [20] L.Ina andA.Igarashi. GradualtypingforFeatherweightJava. \nComputer Software,26(2):18 40, Apr.2009. InJapanese. [21] A. J. Kennedy and B. C. Pierce. On decidability \nof nominal subtyping with variance. In Proc. of FOOL/WOOD 07,Nice, France,Jan.2007. [22] G. Lagorio and \nE. Zucca. Just: safe unknown types in Java\u00adlike languages. Journal of Object Technology, 6(2):69 98, \nFeb.2007. [23] B.H.Liskov andJ.M.Wing. Abehavioral notion of subtyp\u00ading. ACM Trans. Prog. Lang. Syst., \n16(6):1811 1841, Nov. 1994. [24] J. Matthews and A. Ahmed. Parametric polymorphism through run-time sealing, \nor, thorems for low, low prices! In Proc. of ESOP 08, volume4960 of Springer LNCS,pages16 31,2008. [25] \nM.OderskyandP.Wadler. PizzaintoJava:Translatingtheory intopractice. InProc. of ACM POPL 97,pages146 159,Jan. \n1997. [26] I.SergeyandD.Clarke. Towardsgradual ownership types. In Proc. of IWACO 11,Lancaster,UK,July2011. \n[27] J. G. Siek and W. Taha. Gradual typing for functional lan\u00adguages. In Proc. of the Scheme and Functional \nProgramming Workshop,pages81 92,Sept.2006. [28] J. G. Siek and W. Taha. Gradual typing for objects. In \nProc. of ECOOP 07, volume 4509 of Springer LNCS, pages 2 27, 2007. [29] S. Thatte. Quasi-static typing. \nIn Proc. of ACM POPL 90, pages367 381, Jan.1990. [30] P.Thiemann. Towards a type systemfor analyzingJavaScript \nprograms. In Proc. of ESOP 09, volume 3444 of Springer LNCS,pages408 422, 2005. [31] M. Torgersen, E. \nErnst, C. P. Hansen, P. von der Ah\u00b4e, G. Bracha, and N. Gafter. Adding wildcards to the Java pro\u00adgramminglanguage. \nJournal of Object Technology,3(11):97 116,Dec.2004. Specialissue:OOPS track atSAC2004. [32] M. Viroli. \nA type-passing approach for the implementation ofparametric methodsinJava. The Computer Journal,46(3): \n263 294, 2003. [33] M. Viroli. Effective and ef.cient compilation of run-time generics in Java. In Proc. \nof WOOD 04, volume 138 of Elsevier ENTCS,pages95 116, 2004. [34] M.ViroliandA.Natali.ParametricpolymorphisminJava:An \napproach to translation based on re.ective features. In Proc. of ACM OOPSLA 00,pages146 165, Oct.2000. \n[35] P. Wadler and R. B. Findler. Well-typed programs can t be blamed. In Proc. of ESOP 09, volume 5502 \nof Springer LNCS,pages1 16,York,UK,Mar.2009. \u00b4 tate. In Proc. of ECOOP 11, volume6813 of Springer LNCS, \npages459 483, Lancaster,UK,July2011. [36] R.Wolff,R.Garcia, E.Tanter, andJ.Aldrich. Gradual types\u00ad [37] \nA. K. Wright and M. Felleisen. A syntactic approach to type soundness. Information and Computation,115(1):38 \n94, Nov.1994. \u00a8 [38] T. Wrigstad, F. Z. Nardelli, S. Lebresne, J. Ostlund, and J. Vitek. Integrating \ntyped and untyped code in a scripting language. In Proc. of ACM POPL 10,pages377 388,2010.  \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Gradual typing is a framework to combine static and dynamic typing in a single programming language. In this paper, we develop a gradual type system for class-based object-oriented languages with generics. We introduce a special type to denote dynamically typed parts of a program; unlike dynamic types introduced to C# 4.0, however, our type system allows for more seamless integration of dynamically and statically typed code.</p> <p>We formalize a gradual type system for Featherweight GJ with a semantics given by a translation that inserts explicit run-time checks. The type system guarantees that statically typed parts of a program do not go wrong, even if it includes dynamically typed parts. We also describe a basic implementation scheme for Java and report preliminary performance evaluation.</p>", "authors": [{"name": "Lintaro Ina", "author_profile_id": "81438596361", "affiliation": "Kyoto University, Kyoto, Japan", "person_id": "P2839238", "email_address": "ina@kuis.kyoto-u.ac.jp", "orcid_id": ""}, {"name": "Atsushi Igarashi", "author_profile_id": "81309510908", "affiliation": "Kyoto University, Kyoto, Japan", "person_id": "P2839239", "email_address": "igarashi@kuis.kyoto-u.ac.jp", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048114", "year": "2011", "article_id": "2048114", "conference": "OOPSLA", "title": "Gradual typing for generics", "url": "http://dl.acm.org/citation.cfm?id=2048114"}