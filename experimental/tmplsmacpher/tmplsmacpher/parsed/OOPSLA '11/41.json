{"article_publication_date": "10-22-2011", "fulltext": "\n Declaratively Programming the Mobile Web with Mobl Zef Hemel Eelco Visser Delft University of Technology \n&#38; Cloud9 IDE Inc. Delft University of Technology z.hemel@tudelft.nl visser@acm.org Abstract A new \ngeneration of mobile touch devices, such as the iPhone, iPad and Android devices, are equipped with pow\u00aderful, \nmodern browsers. However, regular websites are not optimized for the speci.c features and constraints \nof these devices, such as limited screen estate, unreliable Internet ac\u00adcess, touch-based interaction \npatterns, and features such as GPS. While recent advances in web technology enable web developers to \nbuild web applications that take advantage of the unique properties of mobile devices, developing such \napplications exposes a number of problems, speci.cally: de\u00advelopers are required to use many loosely \ncoupled languages with limited tool support and application code is often ver\u00adbose and imperative. We \nintroduce mobl, a new language designed to declaratively construct mobile web applications. Mobl integrates \nlanguages for user interface design, styling, data modeling, querying and application logic into a single, \nuni.ed language that is .exible, expressive, enables early detection of errors, and has good IDE support. \nCategories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features; D.2.11 \n[Software Engineering]: Software Architectures; D.2.4 [Soft\u00adware Engineering]: Software/Program Veri.cation \nGeneral Terms Design, Languages, Veri.cation 1. Introduction With the rapid growth in sales of modern \nsmart phones and tablets, such as iPhone, iPad, Android and BlackBerries, the web becomes available on \nan increasing number of pow\u00aderful mobile devices equipped with modern web browsers. However, today s \nwebsites are optimized for personal com\u00adputer browsers and environments, whereas mobile devices are used \nin different contexts, and have different features and constraints than personal computers, for instance: \nInternet access is not always available, reliable or fast; Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 11, October 22 27, 2011, Portland, Oregon, \nUSA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. . . $10.00 Screen estate is limited; \n Expected user interaction patterns are different, such as touch controls and gestures such as tapping, \nswiping and pinching;  Applications are expected to respond to changes in con\u00adtext, such as holding \nthe device in portrait or landscape mode, or changes in location.  Consequently, hundreds of thousands \nof custom native mobile applications are being developed. Examples include communication applications \n(e-mail, messaging), content viewers (books, articles, papers, RSS feeds, video, photos, audio) and location-based \nservices (wikihood, foursquare, loopt). While these applications run locally on the device itself, a \nlarge class of these applications are data-driven ap\u00adplications that communicate with one or more web \nservices to exchange data. While iOS, Android, BlackBerry, WebOS, Windows Phone 7 and other platforms \nare similar in terms of inter\u00adaction, features and restrictions, their development envi\u00adronments are \nquite different. iPhone and iPad applications are developed using the Objective-C language; Android and \nBlackBerry applications are built using Java, but using very different APIs; WebOS applications use HTML, \nCSS and JavaScript; Windows Phone 7 development is done using .NET. Developing software that is portable \nto multiple plat\u00adforms is dif.cult. In addition, deployment is non-trivial; most platforms come with \nan application marketplace, some of which require manual testing of submitted applications by the marketplace \nprovider before being published a pro\u00adcess that can take many weeks and applications can be rejected \nfor seemingly arbitrary reasons. At the end of the 1990s, mobile phones started to gain access to the \nInternet through WAP (Wireless Application Protocol). The development model for WAP applications was \nvery similar to the development of regular web appli\u00adcations. Rather than sending HTML, a server would \nsend WML (Wireless Markup Language) to the mobile phone. With the release of the original iPhone in 2007, \na new gener\u00adation of smart phones and tablets started to be released with more powerful browsers that \nsupport all modern web tech\u00adnologies. At the same time, advancements in HTML (HTML 5) and CSS (CSS 3) \nstarted to enable the creation of web ap\u00adplications that offer a comparable experience to native appli\u00adcations, \nespecially for data-driven applications, by support\u00ading application and data caching, detection of touch \ngestures and access to geographical position information (GPS). The portability and deployment advantages \nof web applications make the use of web technologies for building mobile appli\u00adcations very attractive. \n Similar to native applications, mobile web applications can now be developed that run completely disconnected \nfrom the server, requiring a different development model than regular web applications. When a mobile \nweb appli\u00adcation is .rst launched through the web browser, its applica\u00adtion code is cached on the device. \nThe application can use local SQL databases to cache data obtained from a server for of.ine use. When \nno Internet connection is available, the mobile browser retrieves the application from its cache and \ncontinues to operate. All application logic, written in JavaScript, resides on the device rather than \non the server as is the case in regular web applications. Communication with the server, similar to native \napplications, happens by performing web service calls using AJAX (Asynchronous JavaScript and XML). At \nthe time of writing, HTML5 is well supported by the iPhone, iPad, Android, WebOS and BlackBerry (6+) \nplatforms. While HTML5 makes it possible to develop of.ine\u00adcapable mobile web applications that are portable \nand easy to deploy, development of such applications exposes a num\u00adber of problems. First of all, web \ndevelopment does not enforce a par\u00adticular application architecture; application concerns (such as data \nmodeling, user interface and application logic) can be mixed arbitrarily an approach that does not scale \nwell. Therefore, a structured architecture is required to de\u00advelop mobile web applications. A common \narchitectural style in organizing user-facing software is the Model-View-Controller (MVC) pattern [6]. \nThe MVC pattern separates the Model (data, e.g. in a database) strictly from the View (the user interface) \nby making the Controller responsible for communication between the two. While the separation of View \nand Model is good, the MVC pattern results in boiler plate code that needs to be written to glue the \napplication together. Second, mobile web applications are built by mixing a number of loosely coupled \nlanguages including HTML, CSS, JavaScript, SQL and a cache manifest. While the use of domain-speci.c \nlanguages in web development support a declarative programming model, they are not very well in\u00adtegrated. \nIn previous work we have studied the current state of server-side web frameworks [8] which, similar to \nmo\u00adbile web development, take advantage of multiple loosely\u00adcoupled languages. The consequence of this \ndesign is the same both in mobile and regular web development: lack of static analyses detecting inconsistencies \nresults in late detection of failures. In addition, developers have come to expect excellent IDE support \nfor their languages, includ\u00ading in-line error highlighting, reference resolving, outlines, code completion \nand refactoring support. The dynamic na\u00adture and loose coupling of the web languages complicates the \nconstruction of IDE support. Third, web languages such as HTML and CSS do not sup\u00adport basic abstraction \nmechanisms, complicating the reuse of user interface elements. As a result, HTML and CSS arti\u00adfacts contain \na lot of code duplication. Fourth, JavaScript in the browser is a single-threaded environment, forcing \ndevelopers to use asynchronous APIs for performing expensive computations, including database queries \nand obtaining GPS coordinates. These asynchronous APIs require the developer to write code in the unnatural \ncontinuation-passing style, one example of accidental com\u00adplexity in mobile web development. In this \npaper, we introduce mobl1, a high-level, declar\u00adative language for programming mobile web applications, \nwhich addresses these problems. Mobl is our second case study in the design and implementation of syntactically \ninte\u00adgraded DSLs, DSLs that integrate sub-languages for multi\u00adple application aspects, enabling static \nveri.cation of the en\u00adtire application. Previously, we developed WebDSL, a DSL to develop data-driven \nweb applications. While covering a different domain, many ideas from WebDSL are reused in the design \nof mobl. Mobl integrates languages for user in\u00adterface design, styling, data modeling, query and application \nlogic into a single, uni.ed language. The language is high\u00adlevel since it avoids accidental complexity \nsuch as contin\u00aduation passing style and supports the de.nition of reusable user interface elements. The \nlanguage is declarative since it ensures automatic updates of the user interface through re\u00adactive programming \nand automatic persistence of data in the client-side database. Mobl implements the Model-View (MV) pattern, \na variant of Model-View-Controller where the role of Controller has been automated, data model-related \nlogic has been moved to the Model and user interface logic has been moved to the View. The MV pattern \nreduces the amount of boilerplate code that needs to be written compared to MVC. The integration of the \nvarious concerns of mobile web programming into a single language, enables consistency checking across \nconcern boundaries, ensuring early detec\u00adtion of many common errors by the mobl IDE (integrated into \nEclipse), which provides in-line error reporting, code completion and reference resolving. The mobl compiler \ncompiles mobl code into a pure client-side web applica\u00adtion, implemented using a combination of HTML, \nCSS, JavaScript and application caching manifests. Mobl appli\u00adcations can be deployed to any web server \nand are server\u00adtechnology agnostic. 1 http://www.mobl-lang.org Outline The rest of this paper is organized \nas follows: Sec\u00adtion 2 analyzes the mobile domain and its problems. Sec\u00adtion 3 describes the general \narchitecture and design princi\u00adples of mobl. Subsequent sections discuss the various as\u00adpects of mobile \napplications and how mobl supports them: data modeling (Section 4), user interfaces (Section 5), nav\u00adigation \n(Section 6), higher-order controls (Section 7) and styling (Section 8). Section 9 discusses related work \nand Section 10 concludes. 2. Mobile Web Applications The design of a new language for mobile web application \nde\u00advelopment requires a thorough understanding of the mobile domain. This section discusses the architecture \nof traditional web applications and compares it to the architecture of mo\u00adbile web applications. Subsequently, \nwe identify a number of problems in the development of mobile web applications. 2.1 Technical Architecture \nThe traditional style of web applications, sometimes referred to as RESTful web applications [20], are \nrequest-oriented. Objects on the server have the life span of a single request, and are recreated as \nneeded on every request. Since making HTTP requests is relatively expensive, they are used spar\u00adingly, \nwhen navigating to a new page, submitting a form or performing an AJAX (Asynchronous Javascript and XML) \ncall. The web application server responds to requests from the client (browser). When a request comes \nin, it is handled by a server written using, for instance, Java, .NET, PHP or Ruby. The server communicates \nwith a database to retrieve or manipulate data, and eventually sends back HTML to the browser which renders \nit on the user s screen. A server han\u00addles multiple users and typically stores data for all its users \nin a shared database. HTTP requests can also be sent by JavaScript code on the web page, using AJAX calls. \nBased on the result of such a request, the JavaScript may manip\u00adulate the HTML DOM (Document Object Model) \nto make changes to the user interface without requiring an entire page reload. In addition to performing \nAJAX calls, JavaScript is used for client-side validation of user input in forms. There are multiple \napproaches to developing mobile web applications. For older, non-smart phones, processing power is the \nmain bottleneck. Therefore, several thin-client ap\u00adproaches exist [12, 11] where all processing happens \non the server and phones are served with pre-rendered pages. How\u00adever, today s modern smart phones have \nmore powerful pro\u00adcessors, thus client-side processing is no longer a bottleneck. Therefore, for these \ndevices applications can be developed in a range of styles. On one end of the scale are web applica\u00adtions \nthat are built similarly to regular web applications, ex\u00adcept reducing the amount of data presented on \na single page, to .t the screen size of the mobile device. It is relatively easy to adjust a regular \nweb application to produce pages that are more friendly to the smaller screen size of a mobile device. \n Figure 1. Mobile web application technical architecture A drawback of this approach is that such applications \nare not available without an Internet connection. In addition, In\u00adternet speeds on mobile devices are \non average a lot slower than on PCs, resulting in a bad user experience. At the other end of the spectrum \nare of.ine-capable mo\u00adbile web applications that, once accessed by the mobile browser, are cached locally. \nThey may fetch data from the server and cache it in a local database on the device as well. The development \nmodel of this type of application is very similar to desktop applications and native mobile applica\u00adtions \nand merely use web technologies as an implementa\u00adtion means. All the application logic, written in JavaScript, \nexecutes at the client, in the device s browser. This enables much more responsive user interfaces, because \na click no longer requires a HTTP request be sent to the server. Events can therefore be processed much \nmore granularly than in RESTful-style web applications, and can respond immedi\u00adately to gestures and \nkey presses. Like desktop applications, mobile web applications are single-user applications that do \nnot require user authentication and access control. This type of application can be used without an Internet \nconnection, after the application and its data is loaded and cached locally. Internet latency on mobile \nnetworks is also less problematic because fewer requests have to be sent to the server. Figure 1 shows \nthe technical architecture of of.ine\u00adcapable mobile web application. The user interface is de\u00ad.ned using \nHTML (HyperText Markup Language) and styled using CSS (Cascading StyleSheets). The runtime rep\u00adresentation \nof the user interface is the Document Object Model (DOM), which can be manipulated at runtime using JavaScript. \nJavaScript acts as a glue language, manipulat\u00ading the DOM, calling web services and executing database \nqueries. The application s data is stored in a SQLite database running locally on the device. The database \nis accessed through an asynchronous JavaScript API that supports the execution of SQL queries. All application \nresources (such as HTML, CSS, JavaScript and images) are cached locally on the device using the HTML5 \nApplication Cache. When an Internet connection is available, the application can request data from, and \npush data to the server.  2.2 Architectural Patterns There is no particular application architecture \nenforced in web development. HTML, JavaScript and CSS can be mixed arbitrarily. While lowering the barrier \nto entry, this unstruc\u00adtured web application development does not scale well for larger applications. \nTherefore, a number of architectural patterns have been developed for user facing applications. The most \ncommonly used is the Model-View-Controller (MVC) [6] pattern, but alternatives include Model-View-Presenter \n[19] and Model-View-ViewModel [21]. The Model-View-Controller pattern creates a strict sepa\u00adration between \nthree layers of the application: 1. The Model represents the data to be manipulated by the application, \ne.g. persistent data objects. 2. The View de.nes a user interface, presenting (elements of) the Model. \n 3. The Controller responds to user events and adapts the View and Model accordingly.  While developing \nWebDSL [22], we studied MVC web frameworks that are commonly used in web development. We observed that \nthe Controller is required to perform a mostly infrastructural role. It is responsible for reading user \ninput, applying requested changed to the Model, and manip\u00adulating the View. It impedes the rapid development \nof appli\u00adcations: minor changes, such as a new property in the Model that has to be editable from the \nView, requires not only the adaptation of the Model and View, but the Controller as well. Consequently, \nthe use of the Model-View-Controller, as well as similar patterns, result in a lot of boiler plate code \nthat needs to be written.  2.3 No Integration In previous work we surveyed the state of practice in \nweb de\u00advelopment [8]. We observed that web frameworks typically rely on a number of loosely-coupled languages, \ne.g. Java, XML con.guration .les, SQL, HTML, CSS and Javascript. Due to their loose coupling, these framework \ntypically lack tools that can statically verify applications to detect incon\u00adsistencies between components \nof the applications de.ned using different languages, such as HTML pages that link to non-existing Java \ncontrollers, or HTML elements that refer\u00adence non-existing CSS styles. As a result, errors materialize \nas runtime faults with obscure error messages that are hard to trace back to their origin. Mobile web \ndevelopment suffers from the same problem. It too relies on the use of multiple languages, such as HTML \nfor creating user interfaces, CSS for styling, JavaScript for application logic, SQL for database querying \nand caching manifests for application caching. In addition, since all web languages are dynamically typed, \naccurate implementation of typical IDE features such as code completion and refer\u00adence resolving has \nbecome challenging. Consequently, tool support for mobile web development is sub-optimal.  2.4 No Abstraction \nHTML was architected to de.ne the structure of an entire web page. It does not support the de.nition \nof reusable HTML templates, or means to invoke a template. Simi\u00adlarly, CSS s support for abstraction \nis also limited. Using CSS classes, styles can reused by attaching them to multi\u00adple HTML tags, but no \nparameterization of these styles is supported to vary colors slightly, for instance. SQL does not support \nabstraction either. A SQL query can only be expressed as a whole, not in reusable parts. Although it \nis possible to iteratively construct a query by concatenating strings, this is very error prone. 2.5 \nAccidental Complexity JavaScript in the browser runs on a single thread that is shared with the page \nrenderer. Therefore, JavaScript calls that take a long time to complete can freeze the browser. As Javascript \ndoes not allow developers to create threads, many JavaScript APIs are de.ned as asynchronous APIs. Asyn\u00adchronous \ncomputations are computed on a separate thread (managed by the browser), and call back to the Javascript \nthread when the computation completes. While synchronous calls return the result of their computation \nas a return value, asynchronous methods are passed a callback function (or continuation), which is called \nwith the result when the com\u00adputation has .nished. This style of programming is called continuation passing \nstyle. Asynchronous APIs have favorable performance charac\u00adteristics, because they do not block the user-interface \nthread. Nevertheless continuation-passing style leads to verbose, dif.cult to read and maintain code. \nEffectively, developers have to adapt their programming style as a result of a low\u00adlevel performance-related \nissue. 3. Mobl Architecture We have developed mobl. Mobl is a new statically typed, domain-speci.c language \ndesigned speci.cally for the rapid development of data-driven mobile web applications. Mobl linguistically \nintegrates all aspects of mobile ap\u00adplication development into a single, statically veri.able lan\u00adguage. \nIt enables separation of concerns by supporting the separation of user interface and data model. It applies \ndo\u00admain abstraction to abstract from accidental complexity and irrelevant details of the platform/domain. \nIt supports user\u00adde.ned abstractions by enabling users to de.ne reusable screens, controls and styles. \nThis section discusses the high-level aspects of the lan\u00adguage and application architecture. Subsequent \nsections give detailed descriptions of the sub-languages that mobl com\u00adprises.  Figure 2. Mobl application \ncompilation and deployment 3.1 Integration and Tooling HTML, JavaScript and CSS contain numerous cross-references. \nFor instance, CSS selectors rely on the structure of the HTML page and JavaScript is used to manipulate \nthe HTML DOM at run-time, e.g. by attaching or removing CSS classes. Verifying that these cross references \nare correct, e.g. that a CSS selector matches the right HTML tag and JavaScript attempts to manipulate \nan existing DOM node, is typically done by running the program, resulting in late failure. In addition, \nloose coupling of web languages makes imple\u00admenting accurate IDE support dif.cult. Therefore, web de\u00advelopment \nIDEs are not at the level of languages such as Java and C#. By contrast, mobl integrates the aspects \nof mobile appli\u00adcations into a single, integrated language, rather than us\u00ading several loosely-coupled \nlanguages. Mobl consists of a number of integrated sub-languages for the de.nition of data models, queries, \nuser interfaces, styles and application logic. Language elements are shared across the sub-languages. \nFor instance, the expression language used in application logic is reused in user interfaces, resulting \nin a consistent language. This linguistic integration, previously also applied in the im\u00adplementation \nof WebDSL [8], enables accurate end-to-end static veri.cation of applications, e.g. verifying that controls \nare invoked correctly, invoked screens exist, the properties of data objects presented in the user interface \nexist and are of the correct type, and queries .lter based on existing prop\u00aderties. The mobl compiler \ncompiles a mobl module to a combi\u00adnation of HTML, JavaScript and CSS. As Figure 2 shows, the resulting \ncompiled .les can be deployed to a web server along with any web services that the application may use. \nA mobile device requests the HTML .le, automatically fetch\u00ading the CSS and JavaScript resources. All \napplication re\u00adsources are cached in the browser s HTML5 application cache, allowing the application \nto be launched even when no Internet connection is available. The application runs on the device and \nhas access to a local database, as well as other APIs including Geo Location. The application may call \na  Figure 3. Model-View pattern web service on the server pulling or pushing data, presenting that \ndata and optionally caching it locally in the database. The mobl IDE is implemented as an Eclipse plug-in \nusing Spoofax [9]. As Figure 4 illustrates, it offers an outline view, in-line highlighting of veri.cation \nerrors, reference resolv\u00ading and code completion. The mobl compiler is integrated into the IDE, and triggered \non every save of a mobl module. There is also a stand-alone compiler available. 3.2 Model-View Pattern \nWhile the Model-View-Controller pattern is a good organi\u00adzational tool, it also requires a considerable \namount of boiler plate code to set up and to achieve simple tasks. This boiler plate is largely caused \nby the Controller. In a typical appli\u00adcation, the Controller has the following responsibilities: Read \ndata from the Model and send it to the View;  Manipulate the Model based on forms de.ned in the View \n(user input);  Persist changes in the Model to database;  Activate and deactivate (parts of) Views; \n Communicate with external data sources, e.g. web ser\u00advices.  While the core of the application is \nencoded in the Model and the View, a lots of plumbing code is required in the Con\u00adtroller, while most \nof the Controller s tasks are very common and infrastructural in nature. Therefore, mobl implements the \nModel-View (Figure 3) architecture. The MV architec\u00adture is an adaptation of the MVC pattern, automating \nthe tasks of the Controller rather than letting the developer en\u00adcode them manually. In the MVC architecture \nthe Controller is responsible for instantiating Views and populating them with data. In con\u00adtrast, in \nthe MV architecture Views are the initiators. Views can be parameterized with one or more Model objects \nto present, or they can send a request to the Model themselves to retrieve data. Views are also responsible \nfor handling user input events, such as button clicks and responding to them, e.g. navigating to another \nView or calling a method on the Model. The Model is automatically persisted to a database, no explicit \nsave operations are required. In addition, the Model communicates with web services to synchronize and \ncache data. Data binding establishes a direct connection be\u00ad  Figure 4. The mobl Eclipse IDE tween the \nModel and View, eliminating the need to manually copying data from the Model to the View and vice versa. \n4. Data Model The implementation of an application s data model, as well as the manipulation of data \nat run-time, is cumbersome in mobile web development because of the lack of domain abstraction. This \nsection details the underlying issues and shows how mobl raises the level of abstraction by using declarative \ndata models, its imperative language and inte\u00adgrated query language. It concludes with an example detail\u00ading \nthe implementation of a data model for a simple task manager application. HTML5 data persistence Part \nof HTML5 is the Web SQL API2, enabling the creation of local (SQLite) databases in a mobile device s \nbrowser. The amount of space available to a database varies from the device to device, but is typically \naround 5 megabytes. Therefore, the local database is per\u00adfectly suited to store small amounts of data \nand cache data from remote resources. Since the HTML5 database APIs are new, libraries and frameworks \nbuilt around them are still limited. Therefore, communicating with an HTML5 database is still done at \nthe level of low-level SQL statements, which is not only incon\u00advenient for developers, but also more \nprone to security prob\u00adlems such as SQL injection attacks. In addition, encoding queries in strings is \nerror prone because developers do not 2 http://www.w3.org/TR/webdatabase/ get the support from the IDE \nthat they do get for the rest of the language, including syntax checking, semantic checking and code \ncompletion. SQL queries do not compose well. It is dif.cult to pass a partial query to a different part \nof the application where it can be extended, e.g by adding an additional .lter condition. Therefore, \nreuse of queries is limited to what can easily be achieved using string concatenation. Search Most mobile \nweb applications require simple full\u00adtext search functionality, allowing users to quickly search through \nlocal data. HTML5 does not offer direct support for this. Therefore, custom solutions need to be built. \nLogic Database and web service related Javascript APIs are exposed as asynchronous APIs. This requires \nthe devel\u00adoper to write code in a continuation-passing style. For in\u00adstance, consider the following code \nwritten using (hypothet\u00adical) synchronous JavaScript APIs: var tasksJSON = httpRequest(\"/export\"); tx.executeQuery(\"INSERT \nINTO Task ...\"); alert(\"Done!\"); Javascript s asynchronous APIs, rather than returning the re\u00adsult as \nthe result of a function, are passed a callback func\u00adtion and return immediately. The actual execution \noccurs on a separate thread, managed by the browser. When the com\u00adputation .nishes, the callback function \nis invoked with the result. Therefore, the above code using asynchronous APIs has to be rewritten as \nfollows: function completed() { Def ::= \"entity\" ID \"{\" EBD* \"}\" EBD ::= ID \":\" Type (\"(\" {Anno \",\"}* \n\")\")? | \"static\"? \"function\" ID \"(\" {FArg \",\"}* \")\" \":\" Type \"{\" Stat* \"}\" Type ::= ID | \"Collection\" \n\"<\" Type \">\" | \"[\" Type \"]\" | \"(\" {Type \",\"}* \")\" Anno ::= \"inverse:\" ID | \"searchable\" FArg ::= ID \":\" \nType | ID \":\" Type \"=\" Exp Figure 5. Data model syntax alert(\"Done!\"); } function receiveTasks(tasksJSON) \n{ tx.executeQuery(\"INSERT INTO Task ...\", completed); } var tasksJSON = httpRequest(\"/export\", receiveTasks); \nAs can be observed, the code in continuation-passing style is written in an inverted order. While this \nasynchronous code leads to more responsive applications in the browser, it impedes developer productivity. \nIt is a typical example of accidental complexity. 4.1 Data Mobl contains domain abstractions for declaratively \nde.n\u00ading persistent data structures (entity de.nitions), abstract\u00ading from the underlying SQL database \nthat implements them. Persistence of data is handled by the mobl runtime transparently. The syntax of \ndata models is detailed in Figure 5. Data model declarations consist of zero or more entity de.\u00adnitions. \nEvery entity has a name, zero or more properties and associated functions expressing application logic \nrelated to the entity. Each property has a name, type and option\u00adally one or more annotations. Its type \ncan be of a scalar type (e.g. String, Num, DateTime or Bool) as well as Collections of other entities. \nA Collection represents a (virtual) collection of en\u00adtity instances that can be .ltered, sorted, paged \nand ma\u00adnipulated. Collections are used to represent one-to\u00admany and many-to-many relationships in models, \nbut also to query persistent data. In addition, the Collection ab\u00adstraction is used for full-text search. \nThe (searchable) annotations on textual properties indicate that the property should be included when \nperforming full-text searches on in\u00adstances of this entity. These searches are performed through a EntityName.search(phrase) \ncall, which returns a Collection object representing the search results. As with any Collection, the \nresults can subsequently be .ltered and paged. An (inverse: property) annotation on a property de.nes \nproperty as the inverse property of this one. Prop\u00aderties declared as each other s inverse keep each \nother in sync and are used to declare one-to-one, one-to-many and many-to-many relationships. Outside \ndata models, mobl also supports variables of other collection types, including arrays and tuples. Arrays \nare declared using the [Type] notation and tuple types using (T1, T2, T3) syntax. Implementation We have \ndeveloped a JavaScript object\u00adrelational mapper [1] (ORM) library called persistence.js3 to handle data \npersistence mobl. The library implements trans\u00adparent data persistence, querying and search. Data models \nde.ned in mobl are translated to calls to persistence.js by the mobl compiler. A full-text search index \n(implementing a simple stemming algorithm [13]) is automatically main\u00adtained by the ORM library. 4.2 \nLogic Mobl s imperative object-oriented sub-language enables programming in the natural, synchronous \nstyle, abstracting from the accidental complexity of the asynchronous pro\u00adgramming style enforced by \nHTML5 JavaScript APIs. Imperative code is written using a JavaScript-like [4] syn\u00adtax. The language supports \nvariable declarations, assign\u00adments, if-statements, for-each and while loops, function and method calls, \nand various arithmetic expressions. Its full syntax is de.ned in Figure 6. Mobl comes with an extensive \nset of libraries4 containing reusable user interface elements, as well as APIs to call web services, \nperform web searches and get contextual information such as GPS location and de\u00advice orientation. At \ncompile-time, the mobl compiler analyzes mobl im\u00adperative code to determine whether it relies on asynchronous \nmethods and functions. If so, it automatically performs the continuation-passing style transform [18], \nturning code writ\u00adten in a synchronous style to the asynchronous style with callback functions as illustrated \nin the beginning of this sec\u00adtion. 4.3 Query Mobl s query language is linguistically integrated into \nthe expression language part of the imperative language de.ned in the previous sub-section. The query \nabstraction is built on the Collection abstraction. Collections can be in\u00adstantiated by the user, but \nfor each entity there is also an Entity.all() collection de.ned, and for each one-to\u00admany and many-to-many \nproperty there is a collection ob\u00ad 3 http://persistencejs.org 4 http://docs.mobl-lang.org Stat ::= \"var\" \nID \"=\" Exp \";\" | LVal \"=\" Exp \";\" | Exp \";\" | \"if\" \"(\" Exp \")\" Stat (\"else\" Stat)? | \"foreach\" \"(\" LVal \n\"in\" Exp \")\" \"{\" Stat* \"}\" | \"while\" \"(\" Exp \")\" \"{\" Stat* \"}\" \"{\" Stat* \"}\" | \"return\" Exp? \";\" | \"screen\" \n\"return\" Exp? \";\" LVal ::= ID | Exp \".\" ID | \"(\" LVal \",\" {LVal \",\"}* \")\" NamedExp ::= Exp | ID \"=\" Exp \nExp ::= STRING | NUMBER | ID | \"true\" | \"false\" | \"null\" | \"this\" | \"!\" Exp | \"(\" Exp \")\" | \"[\" {Exp \n\",\"}* \"]\" | \"(\" Exp \",\" {Exp \",\"}* \")\" | ID \"(\" {NamedExp \",\"}* \")\" | Exp \".\" ID \"(\" {NamedExp \",\"}* \n\")\" | Exp \".\" ID | Exp Op Exp | Exp \"?\" Exp \":\" Exp | \"{\" Stat* \"}\" Op ::= \"||\" | \"&#38;&#38;\" | \"==\" \n| \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"*\" | \"/\" | \"%\" | \"+\" | \"-\" | \"++\" | \"--\" Figure 6. Imperative language \nsyntax Exp ::= Exp Filter+ Filter ::= \"where\" SetExp | \"order\" \"by\" OrderExp | \"limit\" Exp | \"offset\" \nExp OrderExp ::= ID | ID \"asc\" | ID \"desc\" SetExp ::= ID \"==\" Exp | ID \"!=\" Exp | ID \"<\" Exp | ID \"<=\" \nExp | ID \">\" Exp | ID \">=\" Exp | ID \"in\" Exp | ID \"not\" \"in\" Exp | SetExp \"&#38;&#38;\" SetExp Figure \n7. Query syntax ject as well. The Collection type has methods for .lter\u00ading, sorting, paginating, aggregating \nand manipulating the collection. For instance: Task.all().filter(\"done\", \"=\", true) .order(\"due\", false) \n.limit(10)  Figure 8. Todo list data model This expression represents the top ten results of tasks \nthat are not done, sorted by due date in descending order. The disadvantage of encoding queries as method \ncalls is the lack of static checking of property names as well as its verbose syntax. Therefore, mobl \nde.nes a thin syntactic layer, similar to LINQ [14] on these methods as de.ned in Figure 7. This (optional) \nsyntactic layer has the added advantage of enabling code completion support in the IDE. The same expression \nusing the query syntax look as follows: Task.all() where done == true order due desc limit 10 Full-text \nsearch queries are formulated using an entity s search(phrase) method, returning a Collection representing \nsearch results, ordered by relevance. Like any other Collection, results can be .ltered and paginated. \nThese (virtual) query collections can be reused and ex\u00adtended by storing them in variables and passing \nthem to functions. The result of a query is only calculated when required (e.g. when iterating over the \nresult). Therefore, it is possible to de.ne a method on an entity that returns a .ltered collection (using \nwhere clauses), which is subse\u00adquently called and paginated in the user interface by adding limit and \noffset clauses to the method s resulting Collection object. 4.4 A Task Manager Data Model To demonstrate \nthe data modeling language, as well as model-related logic, we describe the data model of a sim\u00adple task \nmanager (Figure 8). The mobl implementation of this data model is listed in Figure 9. The data model \nde.nes three entities: Task, Category and Tag. A task has a name, a done property to keep track of whether \nthe task has been completed or not, a due date, a category it belongs to and a collection of tasks. Implicitly \nthere is a one-to-many relationship between Task and Category: a task belongs (points to) a category, \nand a category has many tasks. The inverse annotations de.ne the inverse relationship so that a task \nis automatically added to a category s collection of tasks when the category property is set and vice \nversa. The function postpone, de.ned on Task, postpones the task a number of days, i.e. it moves the \ndue date back. The static function (a function that is called on the entity it\u00adself, not an instance) \nimport takes two arguments: a user\u00adname and a password, and invokes a web service (located entity Task \n{ name : String (searchable) done : Bool due : DateTime category : Category (inverse: tasks) tags : Collection<Tag> \n(inverse: tasks) function postpone(days : Num) { this.due = DateTime.create( this.due.getFullYear(), \nthis.due.getMonth(), this.due.getDate() + days); } static function import(user : String, pw : String) \n{ var tasksJSON = httpRequest(\"/export?user=\" + user + \"&#38;pw=\" + pw); foreach(t in tasksJSON) { add(Task.fromSelectJSON(t); \n} } } entity Category { name : String tasks : Collection<Task> (inverse: category) } entity Tag { name \n: String tasks : Collection<Task> (inverse: tags) } Figure 9. Mobl implementation of data model on the \nURI /export) to import all tasks de.ned on the server for the given user and cache them locally in the \nde\u00advice s database. Web service results, by default, are returned as JSON5 objects, a lightweight notation \nto represent struc\u00adtured data. The service returns an array of JSON objects, each representing a task. \nThe Task.fromSelectJSON method is used to convert a JSON object into a Task object and cache it locally. \n5. Reactive User Interfaces In the current state of practice, web-based user interfaces are implemented \nat a low-level of abstraction. A lot of UI\u00adrelated code is the result of accidental complexity. This \nsec\u00adtion identi.es the underlying problems and shows how mobl solves them by introducing domain abstractions \nsuch as data binding and reactive programming and by supporting user\u00adde.ned abstractions such as controls. \nCoupling View and Model The interaction between (per\u00adsistent) application data and the user interface \nrequires a lot 5 http://json.org of Controller boilerplate code. Data values have to be copied into \nthe user interface when it is .rst loaded and stored back into data objects when certain events occur \n(e.g. when a Save button is pushed). Similarly, changes to data often give rise to changes in the user \ninterface. For instance, when the user of a task manager application creates a new task in the database, \nthe screen that displays all tasks has to be up\u00addated. Current frameworks require developers to encode \nthis behavior manually. Adapting the user interface is done by traversing the DOM and manipulating it \nin-place. These manipulations are imperative, e.g. replace this node with this new node and remove this \nnode . Abstraction A HTML page de.nes the content and struc\u00adture of a page. CSS styles are used to apply \nstyling to a HTML page (e.g. de.ning fonts, colors, borders and posi\u00adtioning), based on the knowledge \nit has about the page struc\u00adture (using CSS selectors). A feature that both HTML and CSS do not support \nare user-de.ned abstractions. Reuse of page and style fragments, e.g. to reuse a calendar wid\u00adget or \na grid view control, is not supported by these lan\u00adguages. It also lacks support to de.ne such reusable \ncom\u00adponents. Consequently, JavaScript frameworks, such as jQTouch6 and jQuery Mobile7 attempt to .x this \nreuse issue by inventing an encoding. For instance, a frame\u00adwork like jQuery mobile may reinterpret a \nHTML tag <div class=\"calendar\"/> as a calendar control, dy\u00adnamically adapting the DOM to implement it. \nNeverthe\u00adless, such mechanisms only allow use of controls built into the framework, while de.nition of \nnew controls has to be done using imperative JavaScript. Other frameworks, such as GWT8 and Sencha Touch9 \nabstract from HTML alto\u00adgether with a Java (GWT) or JavaScript (Sencha) API to imperatively construct \nuser interfaces. Neither of these approaches is perfect. Annotating HTML is declarative, but uses an \narcane encoding and attaching new meaning to HTML elements; using JavaScript to build the UI is imperative \nand low-level. 5.1 Declarative User Interfaces Mobl supports user-de.ned abstractions for user interfaces \nthrough two core syntactic constructs: screens and controls. Screens take up the entire size of the physical \nscreen (hence the name) and are composed of controls, state variables, con\u00additionals and loops. Both \nscreens and controls have a name, a set of formal arguments and a body. Screens, in addition, have an \noptional return type. The full syntax of user inter\u00adfaces in mobl is detailed in Figure 10. The body \nof screens and controls consist of local variable declarations, HTML tags, control calls, conditionals \n(when, 6 http://jqtouch.com 7 http://www.jquerymobile.com 8 http://code.google.com/webtoolkit/ 9 http://www.sencha.com/products/touch/ \n Def ::= Anno* \"control\" ID \"(\" {FArg \",\"}* \")\" \"{\" SE* \"}\" | Anno* \"screen\" ID \"(\" {FArg \",\"}* \")\" \":\" \nType \"{\" SE* \"}\" SE ::= \"<\" HTMLID HtmlArg* \">\" SE* \"</\" HTMLID \">\" | Exp \"(\" {NamedExp \",\"}* \")\" \"{\" \nSE* \"}\" | \"var\" ID \"=\" Exp | \"list\" \"(\" ID \"in\" Exp \")\" \"{\" SE* \"}\" | \"when\" \"(\" Exp \")\" \"{\" SE* \"}\" \nHtmlArg ::= ID \"=\" Exp | \"body\" \"=\" Exp NamedExp ::= Exp | ID \"=\" Exp Anno ::= \"@when\" Exp Figure 10. \nUser interface syntax for conditionally rendering parts of the user interface) and loops (list, for rendering \nUI fragments for every item in a collection). Local variables are used to store state relevant to the \nuser interface. At the lowest level, mobl embeds HTML tags to construct a DOM. As can be seen from the \nsyntax, HTML attributes in mobl cannot only contain strings, but arbitrary mobl expressions (numbers, \nvariables, calculations, function calls). Controls are domain abstractions, abstracting from low\u00adlevel \nHTML. Controls are called by name with zero or more (optionally named) arguments and, optionally, a control \nbody (in-between { and }). Screen and control arguments are passed by reference, enabling controls to \nwrite values back to the variables and properties passed to them, which is an essential element to enable \nuser-de.ned abstractions, as will be demonstrated in the next sub-section.  5.2 Data Binding and Reactive \nProgramming Mobl user interfaces declare a View of the Model. Data bindings establish a direct connection \nbetween View and Model. The View is automatically updated when the Model is changed, and the Model is \nupdated when Model properties are changed in the View. The following fragment of user interface code \ndemon\u00adstrates how this data binding works using HTML tags: var name = \"John\" <input type=\"text\" value=name/> \n<span body=\"Hello, \"+name/> A local variable name is used to keep track of the user s name. The <input> \nHTML tag implements an input .eld and binds its value to the variable name. Consequently, the input .eld \ndisplays John as initial value and as the user types in the text .eld (on every key stroke), the changed \ntext box value is propagated back to the name variable. The <span> tag implements a label in the user \ninter\u00adface, whose body (the text that appears inside the label) is bound to the expression \"Hello, \" \n+ name. Conse\u00adquently, when the user types in the input .eld, the name is adapted, which, in turn, propagates \nto the <span> whose body is updated to re.ect the new value of name. Beside local variables and inline \nHTML, user interfaces use conditionals and loops which expose similar reactive behavior. The when construct \nconditionally shows a part of the user interface as long as a certain condition holds, i.e. when the \ncondition s value changes the when construct adapts the user interface accordingly. As an example, in \nthe following example the validation error remains hidden while the length of name exceeds 3 characters \nin length and appears as soon as the name is shorter than 3 characters: var name = \"John\" <input type=\"text\" \nvalue=name/> when(name.length < 3) { <span body=\"Name should be at least three characters\"/> } The list \nconstruct iterates over a collection and renders its body for every item in the collection. Similar to \nwhen, list automatically adapts to changes in application state; it reacts to changes in the collection \nit iterates over, i.e. if items are added or removed from the collection, it adapts the user interface \naccordingly. In summary, rather than imperatively manipulating the DOM to make changes to the user interface, \nmobl s user in\u00adterfaces are reactive [7] their structure and content depend on application state and \nadapts to changes automatically. As a result boiler plate code to implement this behavior manu\u00adally is \neliminated. 5.3 Implementation Mobl s data binding establishes a direct connection between the value \nor an attribute of an HTML node in the DOM (representing an HTML tag) and a variable, property or expression \nin the Model. For variables and properties, a two-way binding is established: when the DOM is modi.ed \n(for instance, when a user edits a text input .eld), this new value is propagated back into the variable \nor property. When the value of a variable or property changes this change is propagated back to the DOM. \nWhen a DOM node is bound to a more complex mobl expression, a one-way connection is established: whenever \nthe value of the expression changes, it is propagated to the DOM. Changes are propagated by using the \nObserver Pat\u00adtern [6]. Any piece of data in a mobl application is observ\u00adable (including local variables, \ncontrol arguments and entity properties) and UI constructs subscribe to change events of the observable \nvalues that they rely on. For instance, a label that shows a user s full name by concatenating its firstName \nwith its lastName property, will subscribe to both of these properties and rerender itself whenever any \nof these two properties trigger a change event. Similarly, a list loop that iterates over a search collec\u00adtion, \nas is the case in Figure 13, subscribes to changes in the search collection. The search collection, in \nturn, keeps track of all Task objects and their name properties (which has been marked as searchable) \nand on every change, reevaluate if they match the search phrase or not.  5.4 Reusable Controls Rather \nthan requiring the duplication of the same HTML code in multiple places, controls can be used to implement \nuser-de.ned abstractions for user interfaces. Control argu\u00adments are passed by reference, enabling constructing \ncon\u00adtrols that abstract from low-level HTML while maintaining data binding semantics. Figure 11 demonstrates \nthe imple\u00admentation of the textField and label controls. Using these de.nitions the previous code, using \nHTML tags, can be reduced to the following, more clean and concise code, maintaining the same behavior. \nSection 7 gives more com\u00adplex examples of control implementations. var name = \"John\" textField(name) \nlabel(\"Hello, \" + name) Control arguments, as well as function and screen argu\u00adments, are passed in order, \nor can be explicitly named. For instance, label(\"Hello\") is equivalent to label(s=\"Hello\"). This proves \nparticularly useful for optional arguments. By annotating controls with a @when <exp> annotation it is \npossible to implement multiple versions of a control, deciding at run-time which implemention to use, \nbased on a run-time condition. An application of this will be demon\u00adstrated in Section 7.2. 6. Navigation \nSection 5 only considered the de.nition of single-screen interfaces. However, a typical application requires \nmultiple screens and navigation between them. control textField(s : String) { <input type=\"text\" value=s/> \n} control label(s : String) { <span body=s/> } Figure 11. Text .eld and label control implementation \nscreen prompt(question : String) : String { var answer = \"\" header(question) { button(\"Done\", onclick={ \nscreen return answer; }) } textField(answer) } screen root() { button(\"Ask\", onclick={ alert(\"Hello \n\" + prompt(\"First name\") + \" \" + prompt(\"Last name\")); }) } Figure 12. A screen with return type The \nregular web is navigated by clicking hyperlinks, sending the user from one web page to another. Browsing \npatterns can be random, and websites are not always or\u00adganized in a strictly hierarchical manner. We \nobserve that in mobile applications, navigation patterns are more strin\u00adgent. Data-driven mobile applications \ntypically organize in\u00adformation as trees. Some applications present the top-level of the tree as tabs, \nenabling the user to quickly switch be\u00adtween them. Deeper levels of information are presented in list \nviews. When the user selects a list item, the current screen slides to the left, and a new one slides \nin from the right. Navigation between screens usually happens by navi\u00adgating deeper into the hierarchy \nor moving back to a higher level (using the back button). On iPhones and iPads, navigation is implemented \nusing a stack of screens where only the top of the stack is visible. When an item is selected, a new \nscreen, representing the item is pushed onto the stack and when the user pushes the back button, the \nscreen at the top is popped off the stack and the previous screen appears. This screen stack has to be \nmanaged manually by the developer, by pushing and popping screens. 6.1 Multiple screens This stack-based \nnavigation very closely matches the call stack of function invocations in programming languages, a concept \nfamiliar to any programmer. Therefore, in mobl, screens are called as if they were functions and can \noption\u00adally return a value using screen return. As an example, Figure 12 de.nes a prompt screen, which \ntakes a question as argument and returns the answer as result. The textField is bound to a local answer \nvariable, which is returned by the screen when the Done button is clicked. The root screen contains a \nbutton, which, when clicked, invokes the prompt screen twice: .rst asking for the .rst name, then for \nthe last name, then showing an alert pop-up box producing a greeting concatenating the results from the \ntwo prompt screen calls.   6.2 A Task Manager User Interface Section 4.4 demonstrated how to de.ne \na data model for a task management application. Figure 13 shows how to build a simple user interface \nfor this data model. When a mobl application launches, the root screen is loaded. Figure 13 de.nes the \nmain screen of the task manager application. The screen shows a header, a search box and a group of at \nmost 20 tasks that match the search phrase. Each task has a check box that can be used to mark the task \nas done. The user interface is realized using a local user interface variable phrase to keep track of \nthe search phrase. The search box is bound to this variable. The body of the group control contains a \nlist construct that iterates over the search collection representing all tasks that match phrase with \na maximum of 20 results. The body of the list con\u00adstruct instantiates an item control for every task, \ncontaining a checkBox which is bound to the done property of the task, as well as using the name property \nof the task for the checkbox label. As the user types a search phrase in the search box, the changed \nsearch phrase is written back to the phrase variable. The list construct iterates over a collection that \nrelies on the phrase variable. Therefore, it is recalculated as well. As a result, the list of tasks \nupdates as the user is typing in the search phrase. Whenever new tasks are added to the database that \nmatch the search phrase, the task list will automatically be updated as well. When the Add button is \npushed, the addTask screen activates. The addTask screen uses a local variable t to keep a new task object \nwhose name property is bound to a textField control and whose due property is bound to a datePicker control. \nThe button control takes two ar\u00adguments: a label to put on the button, as well as a named ar\u00adgument onclick \nof type Callback. Callbacks are snip\u00adpets of imperative code, written using the same language as described \nin Section 4.2, to be executed when a certain event occurs (in this case an on click event). These snippets \ncan be de.ned in-line in between { and }. When the user is done editting the name, he pushes the Done \nbutton, which adds the t object to the database and returns the user to the previ\u00adous screen using a \nscreen return. 7. Higher-Order Controls Mobl comes with a extensive library of reusable controls. These \ncontrols have been implemented in mobl itself, con\u00adcisely de.ned using its abstraction, data binding \nand reactive programming features. Section 5 demonstrated how simple controls such as textField and label \ncan be imple\u00admented top of HTML with data binding. This section will describe how higher-level controls \nare implemented. Specif\u00adically, the tabSet and masterDetail controls are de\u00adscribed. The tabSet control \nis a higher-order control, tak\u00ading other controls as arguments. The masterDetail takes control arguments \nas well, but in addition has two sepa\u00adrate implementations: the right implementation is chosen at run-time \nbased on the screen width. To support higher-order controls, mobl has a set of types to represent controls \nas values: Control, represents a con\u00adtrol without arguments. Similarly, Control1<Num> rep\u00adresents a control \nwith one argument, of type Num. Control arguments are passed as arguments are instantiated as any other \ncontrol. 7.1 Tab Set Figure 14 demonstrates how the tabSet control is used. It de.nes two controls: one \nfor each tab. The root screen invokes the tabSet control with a list of tuples where each tuple represents \na single tab. The .rst element of the tuple is the tab title (of type String), the second a reference \nto the control to use for the body of the tab (of type Control,  control tabSet(tabs : [(String,Control)], \nactiveTab : String) { list((tabName, tabControl) in tabs) { block(onclick={ activeTab = tabName; }, style=activeTab==tabName \n? activeTabButton : inactiveTabButton) { label(tabName) } } list((tabName, tabControl) in tabs) { block(activeTab==tabName \n? visibleTab : invisibleTab) { tabControl() } } } Figure 15. tabSet implementation a control without \narguments). The defaultTab argument speci.es the title of the tab to activate .rst. The screenshots in \nFigure 14 show the result: a tab bar along the top and when a tab is selected, the tab view changes to \nthe selected tab s body. Implementation Figure 15 details the entire implemen\u00adtation of the tabSet control. \nIt takes two arguments: an array of tuples and the currently active tab. The tab set implementation relies \non a few styles (styling in mobl will be discussed in Section 8) that are used with block  Figure 16. \nUsing the masterDetail control controls. The block control is a simple stylable con\u00adtainer control. \nAn activeTabButton block appears as a selected tab, with rounded borders at the top. An inactiveTabButton \nblock is similar, but looks like an inactive tab. The visibleTab and invisibleTab block respectively \nare visible and invisible. Thus, when a tab is not selected, its control is still rendered, it is just \nhid\u00adden using styling. The activeTab argument keeps track of the currently selected tab. When a tab is \nselected, the activeTab vari\u00adable is changed. Consequently, due to the reactive semantics, the styles \non the tabs are toggled (tab content gets visible style, tab button gets selected style) and the new \ntab appears. The list((tabName, tabControl) in tabs) { ... } notation uses tuple syntax on the left-hand \nside. It binds the .rst value of each tuple in tabs to tabName and the second to tabControl. 7.2 Master-detail \nA common pattern in mobile user interfaces is the master\u00addetail user interface pattern. There are two \ncommon imple\u00admentations of this pattern, based on the available screen es\u00adtate: On mobile devices with \nnarrow screens, such as phones, initially a list of items appears and after selecting one, its de\u00adtails \nappear on a separate screen containing a back button to navigate back to the list. On devices with wider \ndisplays, such as tablet devices, the list of items appears along the left side of the screen and details \nof the selected items appear along the right. Figure 16 shows how the masterDetail is used and how it \nlooks on a narrow-screen device (.rst two screen\u00adshots) and on a wide screen (third screenshot). Two \ncon\u00adtrols are de.ned: taskItem is used in the list view and control masterDetail(items : Collection<?>, \nmasterItem : Control1<?>, detail : Control1<?>) { group { list(it in items) { item(onclick={ detailScreen(it,detail); \n}) { masterItem(it) } } } } screen detailScreen(it : ?, detail : Control1<?>) { header(\"Detail\") { backButton() \n} detail(it) } Figure 17. masterDetail implementation @when window.innerWidth > 500 control masterDetail(items \n: Collection<?>, masterItem : Control1<?>, detail : Control1<?>) { var current = items.one() block(sideBarStyle) \n{ group { list(it in items) { item(style=current == it ? selectedItemStyle : notSelectedItemStyle, onclick={ \ncurrent = it; }) { masterItem(it) } } } } block(mainContentStyle){ detail(current) } } Figure 18. A \nwide-screen masterDetail taskDetail in the detail view. The root screen calls the master detail control \nwith a collection representing all tasks ordered by due date in descending order, the taskItem and taskDetail \ncontrols. Implementation Figure 17 shows the default implementa\u00adtion of the masterDetail control (used \nfor devices with a narrow screen). It takes three arguments: a collection of any type (? is syntactic \nsugar for the Dynamic type, repre\u00adsenting dynamically typed values), a masterItem control that is used \nfor the list view and a detail control that is used to show the details of the item. Both the masterItem \nand detail are controls that take an item from the items collection as argument. The control iterates \nover each item and renders an item control for it, using the masterItem control to render the content \nof the item. When the item is clicked, the detailScreen is called with both the item and the detail control \nas arguments. The implementation of the detailScreen renders a header control with a backBut\u00adton, that, \nwhen click returns the user to the previous screen. It calls the detail control, passed as an argument \nwith the it argument to render the detail view. Figure 18 shows an alternative implementation of the \nmasterDetail control that is only used when the browser window s inner width is larger than 500 pixels \n(expressed us\u00ading the @when annotation), i.e. on wider screens. The argu\u00adments match exactly with the \nprevious implementation, but the control body differs. A local variable current is used to keep track \nof the currently selected item in the collection. It is initialized to the .rst item in the collection \n(the .one() method limits the collection to a single item, returning the .rst one). The sideBarStyle \nis used to show a block to the left of the screen containing the list of items. The style (color) used \nfor the item depends on whether it is selected or not. When the item is clicked, it is assigned as the \ncurrent item. The block styled with the mainContentStyle ap\u00adpears right of the list and uses the detail \ncontrol to ren\u00adder the currently selected item s details. The item rendered by the detail control automatically \nupdates as new values are assigned to current. 8. Styling Cascading Stylesheets (CSS) are used to de.ne \nthe look and feel of a mobile web application. Styles are attached to HTML either automatically (using \nCSS selectors) or explic\u00aditly by attaching class attributes to HTML tags. Neverthe\u00adless, stylesheets \nare source of code duplication due to its lack of support for parameterization. For instance, the following \nstyle can be attached to an HTML element to implement rounded corners. Due to the current state of browser \nsupport for the border-radius (a CSS3 feature), it uses browser-speci.c properties for We\u00adbkit and Gecko-based \nbrowsers (two common rendering en\u00adgines) to make it work on all browsers: .rounded-corners { -moz-border-radius: \n5px; -webkit-border-radius: 5px; border-radius: 5px; } However, whenever rounded corners are required \nwith a ra\u00addius other than 5 pixels, these three lines have to be dupli\u00adcated and adapted. Def ::= \"style\" \nID \"{\" StyleProp* \"}\" | \"style\" \"mixin\" ID \"(\" {StyleFarg \",\"}* \")\" \"{\" StyleProp* \"}\" | \"style\" \"$\" \nID \"=\" StyleVal StyleProp ::= ID \"=\" StyleVal* \";\" | ID \"(\" {StyleVal \",\"}* \")\" \";\" StyleVal ::= CSSSTYLEVALUE \n| \"$\" ID | \"$\" ID \".\" \"r\" | \"$\" ID \".\" \"g\" | \"$\" ID \".\" \"b\" | StyleVal \"+\" StyleVal | StyleVal \"*\" StyleVal \n| StyleVal \"-\" StyleVal Figure 19. Styling language syntax 8.1 Styling in Mobl In order not to reinvent \nthe wheel, mobl s styling language reuses all of CSS3 s styling properties [23]. In addition, it adds \nstyling constants, calculations based on these constants and style mixins. These additions were inspired \nby Sass10, an extension of CSS that adds similar features. Figure 19 de.nes the syntax for styles in \nmobl. At the HTML level, style values are attached to the class attribute of tags. Typically, controls \nhave a style argument (of type Style) that is used to pass styles around. For instance, the block control: \nstyle largeStyle { font-size: 100pt; } screen root() { block(largeStyle) { label(\"Large text\") } }  \n8.2 Theming Applications can easily be themed with custom colors by overriding style constants used by \nthe standard mobl library of controls. For this purpose, mobl supports global style constants that can \nbe referenced in styles. When using RGB (Red-Green-Blue) colors, the individual color components can \nbe accessed to build new colors: style $baseColor = rgb(72, 100, 180) style $textButtonColor = rgb($baseColor.r-50, \n$baseColor.g-50, $baseColor.b-50) style buttonStyle { color: $buttonTextColor; ... } 10 http://sass-lang.com \n style mixin borderRadiusMixin($radius) { -moz-border-radius: $radius; -webkit-border-radius: $radius; \nborder-radius: $radius; } style buttonStyle { color: $buttonTextColor; borderRadiusMixin(5px); ... } \nFigure 21. Style mixin example The controls that come with mobl all derive their colors from the $baseColor \nconstant. Therefore, simply overriding this constant and changing it to a different color, creates a \nnew color theme based on the given base color. Figure 20 shows how buttons change with different $baseColor \nsettings. Parameterized styles are implemented using style mix\u00adins. Style mixins can be used and parameterized \nin other styles. Figure 21 implements a parameterized version of a border radius style taking the border \nradius as argument. The buttonStyle uses the mixin to realize a border radius of 5 pixels. Mobl comes \nwith a library of reusable style mixins, including border radius and gradient mixins. 9. Discussion To \nevaluate the coverage of mobl we have built a number of applications using mobl, ranging from simple \ntoy appli\u00adcations such as a todo list manager and a tip calculator to more complex applications such \nas a twitter client, a confer\u00adence planner application and even simple graphical games and a collaborative \ndrawing application. Mobl receives a lot of interest from industry. Several companies are working on \nmobile applications built using mobl. Together with our user community we grew a library of reusable \ncontrols, ranging from basic, such as labels and buttons, to more complex, such as the tab set, a master-detail, \naccordion, date picker and context menu controls. The de.nitions of these controls are all declarative \nand concise. A member of the community has also developed a framework (using mobl) to enable unit testing \nof the data model and logic. This section discusses the limitations of our approach and compares it to \nrelated work. Language Limitations While mobl s type checker checks many program properties, it does \nnot yet check everything. For instance, item controls controls have to be nested within groups to be \nrendered properly. Mobl does not yet support declaring such nesting requirements. Data synchronization \nwith web services currently has to be implemented manually. In the future we intend to sup\u00adport transparent \ndata synchronization web services as part of the mobl language, thereby eliminating the custom synchro\u00adnization \ncode that need to be written on an application-by\u00adapplication basis. Mobile web applications generated \nby mobl are portable to any mobile platform that supports HTML 5. However, the user interface does not \nadapt to the look-and-feel of the plat\u00adform, while mobl supports this variability using @when an\u00adnotations, \nwe have not yet developed many platform-speci.c control implementations. Performance The performance \nof mobile web applications will always be worse than native applications, just as web applications in \ngeneral are slower than native desktop appli\u00adcations. Nevertheless, by caching both the application and \nits data locally and the recent performance improvements of (mobile) browsers, performance of mobile \nweb applications is very reasonable. While performance has not been the pri\u00admary focus of the mobl compiler \nthus far, it is possible to produce an optimized build which eliminates all unused def\u00adinitions from \nthe generated JavaScript and CSS .les. In ad\u00addition, unnecessary whitespace is removed and variables \nare renamed with shorter names to considerably reduce the ap\u00adplication s download size. Good Web Citizenship \nWhile mobl uses the web as a medium to deliver applications, and uses web technologies to run applications, \na mobl application is not built like a regular web application: a mobl application does not con\u00adsist \nof pages with unique URLs; breaks the browser s back button; and is not indexable by search engines. \nWe intend to solve some of these issues. A working back button is rela\u00adtively easy to implement. Full \nhistory support is much more complex, requiring some type of encoding of the application state in the \nURL of the application. Indexing mobile appli\u00adcations can be useful for some data-driven applications. \nA tool such as CrawlJax [15] could be used to generate a static, indexable version of the application. \nWeb Application Limitations While web applications have the advantage of being portable, they have limitations \ntoo. HTML5 offers many JavaScript APIs that give access to various device services, but their implementation \nin mobile devices is not always complete. Access to audio and video services is limited it is possible \nto play an audio or video .le, but only by launching the dedicated audio or video player. Access to other \ndevice-speci.c features such as bluetooth, the built-in compass, camera and local .le storage are not \nsupported yet. A way around these restrictions is a native/web hybrid approach. PhoneGap11 allows a developer \nto build applica\u00ad 11 http://www.phonegap.com tions using web technologies, and expose additional native \nAPIs including a .le storage API and a camera API through JavaScript, an approach that works nicely with \nmobl. Appli\u00adcations built with PhoneGap can be deployed as native ap\u00adplications through e.g. the Apple \nAppStore or Android Mar\u00adketplace. Web applications have limitations in user experience as well. It is \nvery dif.cult to reproduce certain native applica\u00adtion behaviors in web applications. Inertia scrolling \nis one such behavior, where, after a .nger .ick on the screen, the screen keeps scrolling for a while \nlonger after the .nger no longer touches the screen. There are a number of projects that attempt to emulate \nthis behavior in the browser, but it has proven very dif.cult to do perfectly. Fixed position\u00ading is \nanother behavior that is dif.cult to achieve in mobile browsers. A control that has a .xed position, \ndoes not move when the rest of the screen scrolls. A typical example is a screen header. A header is \npositioned at the top of the screen and while the rest of the content scrolls, the header remains .xed \nat the top. 9.1 WebDSL In previous work we developed WebDSL [22], a domain\u00adspeci.c language for the development \nof RESTful web ap\u00adplications. From a WebDSL program, the WebDSL compiler generates a Java web application, \ndeployable in any Java servlet container. Mobl borrows many concepts from WebDSL. For in\u00adstance, like \nWebDSL, mobl is statically veri.able [8] and has similar constructs for the de.nition of data models. \nState and Event Handling Syntactically, the de.nition of WebDSL and mobl user interfaces are similar, \nbut their se\u00admantics differ when it comes to the time of data binding. The unit of interaction within \na WebDSL application is a HTTP request, either executed using an AJAX call, a form submit or page request. \nPages are reconstructed on every request, instead of incrementally updated as is the case in mobl. In\u00adcremental \nuser interface updating is cheap when maintain\u00ading state locally, while implementing incremental updates \nef.ciently in a client-server application requires application state to be maintained on the server as \nwell as client, which would require the storage of application state for potentially thousands or millions \nof users. Handling of events in mobl is more .ne-grained than in WebDSL: when editing a data object in \nWebDSL, changes are persisted only when the edit form is submitted to the server, rather than instantaneously \nas is the case with mobl applications. Since all interaction and persistence happens locally, such continuous \npersistence is much cheaper to im\u00adplement. Sending every keystroke to the server would be very expensive. \nExtension Mobl has a different philosophy than WebDSL when it comes to language extension. WebDSL developed \nmany abstractions as built-ins, including built-in types, con\u00adtrols and functions. As a result, any modi.cations \nor im\u00adprovements to these constructs requires extension or adap\u00adtation of the compiler. Mobl takes the \napproach of library extension. Rather than hard-coding types and controls into the compiler, they are \nde.ned in libraries either encoded in mobl itself, or through the native Javascript interface. The advantage \nof this approach is that users can easily add new functionality to mobl, without the need to know how \nits com\u00adpiler works. This approach is currently in process of being adopted in WebDSL as well.  9.2 \nRelated work DSLs for mobile development Behrens [2] describes a domain-speci.c language for creating \nnative mobile appli\u00adcations, using a single language from which both iPhone and Android applications \ncan be generated. Similar to mobl, the language comes with an IDE plug-in for Eclipse that supports error \nhigh-lighting, code completion and reference resolving. Berhens language has a number of high-level controls \nbuilt into the language, including sections, detail views and cells. It can fetch its data from data \nproviders. However, the DSL currently only supports data viewing and is not as .exible as mobl; de.ning \ncustom controls is not supported, for instance. Kejriwal and Bedekar developed MobiDSL [10], an XML-based \nlanguage for developing mobile web applica\u00adtions. Unlike mobl, the application is executed on the server \nand plain HTML is sent to the mobile device. MobiDSL comes with a number of built-in controls, such as \nquery views, page headers and search requests that can be used to build pages. It is not possible to \nde.ne custom controls, nor is there speci.c IDE support available. Google Web Toolkit is a tool that \nenables client-side web applications using Java. The use of Java has the advan\u00adtage of having excellent \nIDE support. A GWT plug-in12 en\u00adables access to HTML 5 APIs such as geolocation and local databases. \nLike mobl, GWT applications are compiled to a combination of HTML, Javascript and CSS. However, user \ninterfaces using GWT have to be de.ned using verbose Java code. In addition, GWT does not provide data \nbinding or reactive programming support, therefore requiring a lot of boiler plate code to bind the Model \nto the View. Reactive User Interfaces Courtney and Elliot developed Fruit [3], a Haskell framework that \napplies functional reac\u00adtive programming [17, 5, 24] to user interfaces. It is based on signals (streams \nof events) and signal transformers (func\u00adtions that transform streams of events). On top of these con\u00adcepts, \nFruit builds a purely functional user interface library. Mobl s user interfaces are also reactive, but \nnot based on pure functions. Concepts such as signals and signal trans\u00adformers are not exposed to the \ndeveloper in mobl. Instead, events triggered by changes in data or control events, result in updates \nto the user interface. 12 http://code.google.com/p/gwt-mobile-webkit/ Meyerovich et al. describe FlapJax \n[16], a language for building AJAX applications. Flapjax is also built on the con\u00adcept of event streams: \nstreams of events that model, for in\u00adstance, mouse movements, clicks and web service responses. These \nstreams can be .ltered and merged to build responsive user interfaces. Mobl takes a more traditional \napproach to event handling. Events in mobl trigger event handler logic, which can modify application \nstate potentially resulting in user interface changes. 10. Conclusion In this paper we introduced mobl, \na new language for de\u00adveloping mobile web applications. Mobl linguistically inte\u00adgrates languages for \ndata model de.nition, user interface, styling and application logic. It introduces domain abstrac\u00adtions \nto abstract from accidental complexity and irrelevant details of the platform and domain. Mobl s support \nfor user\u00adde.ned abstractions, data binding and reactive program en\u00adable the reusable implementation of \nboth simple controls (labels and button) and higher-level controls (tab sets and master-detail). Mobl \nautomates the tasks typically manually encoded in Controller logic, thereby reducing the amount of boiler \nplate code that needs to be written. Mobl has received a lot of interest from industry. A number of companies \nhave already committed to implement their mobile applications using mobl. 11. Acknowledgments This research \nwas supported by NWO/JACQUARD project 638.001.610, MoDSE: Model-Driven Software Evolution. We would like \nto thank Google for providing Android phones for testing and development. References [1] D. K. Barry \nand T. Stanienda. Solving the Java object storage problem. computer, 31(11):33 40, 1998. [2] H. Behrens. \nMDSD for the iPhone. In SPLASH 10: Proceed\u00adings of Object oriented programming systems languages and \napplications companion, 2010. [3] A. Courtney and C. Elliott. Genuinely functional user inter\u00adfaces. \nIn PLI, 2001. [4] ECMA. ECMA-262 ECMAScript language speci.cation. http://www.ecma-international.org/ \npublications/files/ECMA-ST/ECMA-262.pdf, December 2009. [5] C. Elliott and P. Hudak. Functional reactive \nanimation. In ICFP, pages 263 273, 1997. [6] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. De\u00adsign \npatterns: elements of reusable object-oriented software. Addison-Wesley Professional, 1995. [7] D. Harel \nand A. Pnueli. On the development of reactive systems. Logics and models of concurrent systems, 1985. \n [8] Z. Hemel, D. M. Groenewegen, L. C. L. Kats, and E. Visser. Static consistency checking of web applications \nwith WebDSL. JSC, 46(2):150 182, 2011. [9] L. C. L. Kats and E. Visser. The Spoofax language workbench: \nrules for declarative speci.cation of languages and IDEs. In OOPSLA, pages 444 463, 2010. [10] A. A. \nKejriwal and M. Bedekar. MobiDSL -a domain spe\u00adci.c langauge for mobile web applications: developing \nappli\u00adcations for mobile platform without web programming. In Proceedings of the 9th OOPSLA Workshop \non Domain Spe\u00adci.c Modelling (DSM 09), October 2009. [11] J. Kim, R. A. Baratto, and J. Nieh. pthinc: \na thin-client architecture for mobile wireless web. In WWW, pages 143 152, 2006. [12] A. M. Lai, J. Nieh, \nB. Bohra, V. Nandikonda, A. P. Surana, and S. Varshneya. Improving web browsing performance on wireless \npdas using thin-client computing. In WWW, pages 143 154, 2004. [13] J. B. Lovins. Development of a stemming \nalgorithm. Me\u00adchanical Translation and Computational Linguistics, 11:22 31, 1968. [14] E. Meijer, B. \nBeckman, and G. M. Bierman. LINQ: reconcil\u00ading object, relations and xml in the .net framework. In sigmod, \npage 706, 2006. [15] A. Mesbah, E. Bozdag, and A. van Deursen. Crawling ajax by inferring user interface \nstate changes. In ICWE, pages 122 134, 2008. [16] L. A. Meyerovich, A. Guha, J. P. Baskin, G. H. Cooper, \nM. Greenberg, A. Brom.eld, and S. Krishnamurthi. Flapjax: a programming language for ajax applications. \nIn OOPSLA, pages 1 20, 2009. [17] H. Nilsson, A. Courtney, and J. Peterson. Functional reactive programming, \ncontinued. In Proceedings of the 2002 ACM SIGPLAN workshop on Haskell, 2002. [18] G. D. Plotkin. Call-by-name, \ncall-by-value and the lambda\u00adcalculus. TCS, 1(2):125 159, 1975. [19] M. Potel. MVP: Model-View-Presenter \nthe taligent program\u00adming model for c++ and java. Taligent Inc, 1996. [20] L. Richardson and S. Ruby. \nRESTful Web Services. O Reilly, May 2007. [21] J. Smith. WPF Apps With The Model-View-ViewModel De\u00adsign \nPattern. http://msdn.microsoft.com/en-us/ magazine/dd419663.aspx, February 2009. [22] E. Visser. WebDSL: \nA case study in domain-speci.c language engineering. In GTTSE, pages 291 373, 2007. [23] W3C. CSS 3 working \ndraft. http://www.w3.org/TR/ css3-roadmap, 2011. [24] Z. Wan and P. Hudak. Functional reactive programming \nfrom .rst principles. In PLDI, pages 242 252, 2000.     \n\t\t\t", "proc_id": "2048066", "abstract": "<p>A new generation of mobile touch devices, such as the iPhone, iPad and Android devices, are equipped with powerful, modern browsers. However, regular websites are not optimized for the specific features and constraints of these devices, such as limited screen estate, unreliable Internet access, touch-based interaction patterns, and features such as GPS. While recent advances in web technology enable web developers to build web applications that take advantage of the unique properties of mobile devices, developing such applications exposes a number of problems, specifically: developers are required to use many loosely coupled languages with limited tool support and application code is often verbose and imperative. We introduce mobl, a new language designed to declaratively construct mobile web applications. Mobl integrates languages for user interface design, styling, data modeling, querying and application logic into a single, unified language that is flexible, expressive, enables early detection of errors, and has good IDE support.</p>", "authors": [{"name": "Zef Hemel", "author_profile_id": "81381605197", "affiliation": "Delft University of Technology &#38; Cloud9 IDE, Inc., Delft, Netherlands", "person_id": "P2839253", "email_address": "z.hemel@tudelft.nl", "orcid_id": ""}, {"name": "Eelco Visser", "author_profile_id": "81100561215", "affiliation": "Delft University of Technology, Delft, Netherlands", "person_id": "P2839254", "email_address": "visser@acm.org", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048121", "year": "2011", "article_id": "2048121", "conference": "OOPSLA", "title": "Declaratively programming the mobile web with Mobl", "url": "http://dl.acm.org/citation.cfm?id=2048121"}