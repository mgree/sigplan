{"article_publication_date": "10-22-2011", "fulltext": "\n Immutable Speci.cations for More Concise and Precise Veri.cation Cristina David Department of Computer \nScience, National University of Singapore cristina@comp.nus.edu.sg Abstract In the current work, we \ninvestigate the bene.ts of immutabil\u00adity guarantees for allowing more .exible handling of alias\u00ading, \nas well as more precise and concise speci.cations. Our approach supports .ner levels of control that \ncan mark data structures as being immutable through the use of immutabil\u00adity annotations. By using such \nannotations to encode im\u00admutability guarantees, we expect to obtain better speci.ca\u00adtions that can more \naccurately describe the intentions, as well as prohibitions, of the method. Ultimately, our goal is improving \nthe precision of the veri.cation process, as well as making the speci.cations more readable, more pre\u00adcise \nand as an enforceable program documentation. We have designed and implemented a new entailment procedure \nto formally and automatically reason about immutability en\u00adhanced speci.cations. We have also formalised \nthe sound\u00adness for our new procedure through an operational seman\u00adtics with mutability assertions on \nthe heap. Lastly, we have carried out a set of experiments to both validate and af.rm the utility of \nour current proposal on immutability enhanced speci.cation mechanism. Categories and Subject Descriptors \nD.2.4 [SOFTWARE ENGINEERING]: Software/Program Veri.cation General Terms Languages, Veri.cation 1. Introduction \nThe importance of immutability information has been dis\u00adcussed in several works [2, 8]. Immutability \nis essential when we have to guarantee that non-privileged clients are never allowed to modify some given \nresource (or data struc\u00adture). Moreover, immutability is useful in the presence of Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 11, October 22 27, \n2011, Portland, Oregon, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. . . $10.00 Wei-Ngan \nChin Department of Computer Science, National University of Singapore chinwn@comp.nus.edu.sg aliasing, \nwhere it is challenging [8] to maintain invariants of aliased objects otherwise. In a concurrent programming \nset\u00adting, immutability, seen as a read-only permission, enables safe sharing between different threads \nwithout the cost of synchronization [3, 13]. Immutability was extensively investigated in the context \nof object-oriented programs under several forms, such as ob\u00adject immutability (a given object cannot \nbe mutated through any reference whatsoever), class immutability (no instance of an immutable class can \nbe changed), reference immutabil\u00adity (a given reference is not used to modify its referent) [2, 19, 20]. \nThese proposals were formulated as extensions of the underlying type system. However, to the best of \nour knowledge, the concept of immutability has not been applied to a richer speci.cation logic that could \nbe used to specify more concisely and pre\u00adcisely the behaviors of software programs, particularly in \nthe sequential programming setting. In the current paper, we investigate the bene.ts of enforcing immutability \nrequire\u00adments in the context of an expressive logic, called separation logic [16], that is particularly \nsuited for verifying properties of mutable data structures. In contrast to the previous works, our approach \napplies at the speci.cation level, rather than as part of the type system. The starting point of the \ncurrent work is an automated veri.cation system for ensuring the safety of pointer-based programs [11]. \nThis mechanism supports user-de.ned pred\u00adicates that can be used to describe the properties of a wide \nrange of data structures with different shapes. By shapes, we mean the expected forms of some linked \ndata structures, such as singly-linked lists, doubly-linked lists, circular lists or even height-balanced \ntrees and sorted lists/trees. The cur\u00adrent work enhances the approach introduced in [11] with the possibility \nof specifying which parts of the data struc\u00adtures cannot be mutated (are immutable), and by allowing \nthe sharing of aliases in the heap formula through the use of the conjunctive . operator. In several \nrecent veri.cation systems based on separation logic [1, 5, 11], a speci.cation formula is a restricted \nform of logic that allows only separating conjunction, *, in the heap description. The separating conjunction \nF1 * F2 denotes a program state with two disjoint heap spaces described by sub-formulae F1 and F2, respectively. \nSuch heap separation supports precise knowledge about the pointer aliasing, and can be exploited by a \nfundamental rule of the logic, called frame rule [17], that forms the basis for local reasoning.  Our \ngoal is to take advantage of the immutability prop\u00aderty, so as to generalize the heap description to \nallow a greater degree of sharing. Thus, instead of relying on just a spatial formula F1 * F2 in the \nspeci.cation logic, our new veri.cation system also supports conjunctive formula of the form F1 . F2 \nwhereby the heap formula F1 is expected to be marked as immutable, whilst F2 is unrestricted. This al\u00adlows \nthe heap nodes from both F1 and F2 to be possibly aliased with one another, thus supporting a more general \nspeci.cation mechanism for data structures, including the use of overlaid data structures. The main contributions \nof the current work can be sum\u00admarized as follows: Immutability Enhanced Speci.cations : We provide \na more concise and precise speci.cation mechanism that allows immutability annotations and heap sharing. \nWe show how our proposal enables better precision and ap\u00adplicability of the speci.cations, as well as \npreservation of cut-points in support of modular analysis.  Immutability Guarantees : We discuss several \nim\u00admutability guarantees that can be enforced through our approach. Among them, we differentiate between \ntotal immutability and partial immutability.  Entailment Procedure : We design a new entailment procedure \nto automatically reason about immutability en\u00adhanced speci.cations.  Prototype System and Correctness \nProof : We have implemented a prototype system to validate our proposal for a cleaner speci.cation that \nis both concise and pre\u00adcise, and formulated a set of lemmas on its correctness.  In the rest of the \npaper we shall focus on the apparatus for writing and verifying speci.cations with immutability anno\u00adtations. \nSec 2 provides examples to motivate the need for im\u00admutability annotations for a more concise and precise \nspec\u00adi.cation mechanism. Sec 3 introduces the speci.cation lan\u00adguage. Sec 4 and Sec 5 formalize the entailment \nproving for immutability enhanced speci.cations and the veri.cation rules to generate Hoare triples, \nrespectively. The soundness properties for both the forward veri.er and the entailment prover are discussed \nin Sec 6. Sec 7 presents our experimen\u00adtal results, before a discussion on related works in Sec 8.  \n2. Motivating Examples Immutable annotations allow us to write stronger speci.\u00adcations that lead to more \nconcise and precise program ver\u00adi.cation. We shall use simple examples to highlight how these desirable \ntraits for program speci.cations are being achieved. To help construct simple examples, let us consider \ntwo declarations below that can be used to specify singly\u00adlinked lists. data node { int val; node next} \nll(root, n)= root=null . n=0 . root . node( , q)* ll(q, n-1) inv n=0; The .rst declaration is for a data \nnode with two .elds, namely a data .eld val and a pointer .eld next for pointing to next node in the \nlinked list. The second declaration spec\u00adi.es an acyclic linked list through separation logic [16]. A \nkey operator present in this logic is the * operator, as used in root . node( , q)* ll(q, n-1). This \nseparation opera\u00adtor states that data node root . node(r, q) and heap pred\u00adicate ll(q, n-1) reside in \ndisjoint memory, allowing us to count accurately the length of the linked list using an inte\u00adger parameter \nn. Thus, apart from specifying that we have an acyclic linked-list that terminates will a null pointer, \nthe predicate ll(x, n) also precisely captures the length of the linked list. The keyword inv introduces \na heap-independent invariant over the parameters {root, n} that holds for each instance of the predicate. \nFormula p . c(v *) denotes a points-to fact of the heap where c is a data node. Formula c(p, v *) captures \na heap predicate where c is a named, parameterized assertion over * the heap. For both cases, v denotes \nthe arguments, and denotes an anonymous variable. 2.1 Concise Speci.cation Consider a method that receives \na list as its input, before returning the list s length as its result. Typically, such a method would \nnot be mutating its input list. Let us .rst specify this method without any immutability annotation. \nNote the use of a special variable res for denoting the result of the method. int length(node x) requires \nll(x, n) ensures ll(x, n).res=n ; { if (x==null) then return 0; else return 1 + length(x.next); } The \nprecondition assumes that variable x points to a singly\u00adlinked list of length n using the predicate ll(x, \nn).The same predicate, ll(x, n), is also present in the postcondi\u00adtion which suggests that a list of \nthe same length is being preserved by the method. However, we would really prefer to express something \nstronger for this method since it is the same input list (from the method s entry) that is being pre\u00adserved \nin the postcondition (at the method s exit). One solution for capturing total preservation of list is \nto introduce a stronger llS predicate that would capture the entire sequence of elements and their nodes, \nas shown below. Note that V captures the sequence of values, while L captures the sequence of pointers \nto nodes in the linked list.  llS(root, V, L, n)= root=null . n=0 . V=L=[] . root . node(v, q)* llS(q, \nV1, L1, n-1). V=v:V1 . L=root:L1 inv n=0; With this more informative predicate, we could now cap\u00adture \na more complete speci.cation of length method, as follows: int length(node x) requires llS(x, V, L, n) \nensures llS(x, V, L, n).res=n ; However, this approach makes our veri.cation more com\u00adplex as we are \nnow required to verify two additional prop\u00aderties, namely the preservation of sequence of values and \nsequence of addresses, for the input list. Apart from caus\u00ading more work for our veri.er, we must also \nrely on a more complex prover that is expected to handle proofs involving sequences. We propose a simpler \nsolution to this problem that uses immutability annotation of the form @I to annotate the spec\u00adi.cation \nof each node or each predicate that is only read (and not modi.ed) by its method. In the case of the \nlength method, we can indicate that the list pointed by x is not mu\u00adtated by its method through the following \nspeci.cation: int length(node x) requires ll(x, n)@I ensures res=n ; The precondition states that the \nlinked-list pointed by x will only be read by the length method. This indirectly en\u00adsures the preservation \nof the input list, which need not be re-proven in the postcondition. The net result is a cleaner speci.cation \nthat more succinctly captures the intended se\u00admanticsofthe length method. We said that the new spec\u00adi.cation \nis more concise (or shorter) since it has one fewer predicate in the postcondition. It is also more precise \n(or ac\u00adcurate) since it captures the total preservation of the input list without resorting to the use \nof a more complex predi\u00adcate. These improvements are due entirely to the use of an immutable predicate \nin the precondition.  2.2 Flexible Aliasing Let us now consider a method, called sum, that receives \ntwo data nodes pointed by x and y, respectively, and computes the sum of the values stored inside the \ntwo nodes. Under the principle of heap separation, as promoted by separation logic, our speci.cation \nlogic would explicitly state that the two input nodes are either disjoint, as speci.ed using x . node(a, \n)*y . node(b, ), or are exact aliases for one another, namely x . node(v1 , ).x=y. To support both these \nscenarios, one way for specifying this is to use two pairs of pre and post-conditions, one corre\u00adsponding \nto the case when x and y are disjoint, and another to the case when they are exact aliases, as shown \nbelow. int sum(node x, node y) requires x . node(a, q1)*y . node(b, q2) ensures x . node(a, q1)*y . node(b, \nq2).res=a+b; requires x . node(a, q).x=y ensures x . node(a, q).res=2 * a; {x.val + y.val} With the help \nof these two speci.cations, we can now deal with different scenarios, whereby the nodes may either be \naliased or otherwise. As an example, consider the two sum calls in the code fragment below. node u = \nnew node(...) node w = new node(...) int r1 = sum(u, u) int r2 = sum(u, w) The .rst call sum(u, u) would \nonly match with the sec\u00adond pre/post speci.cation, while the second call sum(u, w) where the input nodes \nare disjoint, would match with the .rst pre/post speci.cation. Though this speci.cation is fairly precise, \nit is unneces\u00adsary complicated for the given method. In particular, neither of the two nodes pointed \nto by x and y are being updated. For such a scenario, it is actually not important if x and y are aliases \nor not. What is important is that we are able to access the values of the two nodes. With the help of \nimmutability annotations, we can actually use a much simpler speci.ca\u00adtion below. int sum(node x, node \ny) requires x . node(a, )@I.y . node(b, )@I ensures res=a+b; We apply the immutability annotation @I \non both the nodes pointed by x and y, respectively. Moreover, we allow the use of . operator, instead \nof the * operator, to express the fact that x and y may either be aliases or otherwise. As a consequence, \nthe same pre/post speci.cation can now be used for both the sum calls, namely sum(u, u) and sum(u, w), \nfrom our earlier code fragment. Yet another improvement is that the two immutable nodes need not re-appear \nin the postcondition, thus avoiding the need to re-prove its preser\u00advationbythe sum method. With this \ncleaner speci.cation, we are able to claim that the result returned by the method is always a+b, regardless \nof whether or not x and y are aliases or not. Werefertothisas .exible aliasing due to the use of im\u00admutable \nspeci.cation. The knowledge that something is im\u00admutable enables us to support arbitrary aliasing in \nthe heap description with the use the conjunctive . operator. This re\u00adsults in a uni.ed speci.cation \nthat is both concise and pre\u00adcise. Functional programmers are all too aware of this ben\u00ade.t, whereby \naliasing was never an issue for understanding (or analysing) purely functional code without any heap \nmu\u00adtation. In the present work, we advocate for the use of im\u00admutable annotations to help us achieve \na similar bene.t for the speci.cation of data structures that are only being read, and never modi.ed, \nin the imperative setting.  2.3 Preservation of Cut-Points Cut-points refer to the intermediate data \npoints that may be encountered prior to a method call. Previous works on program analysis [7] have attempted \nto preserve cut-points for method calls, where possible. This is typically achieved by keeping track \nof multiple summaries for each method under analysis, so that more cut-points could be preserved. In \nthis section, we show how cut-points may be preserved with the help of immutability annotations. Let \nus re-visit the length example, covered in Sec 2.1. Consider the following code fragment: node y = new \nnode(2, null) node x = new node(1, y) int r = length(x) Prior to the length call, we would have the following \nheap state, x . node(1, y)*y . node(2, null), that is formed by two assignment statements. This heap \nstate captures two cut\u00adpoints from variables x and y. If we had used the following mutable speci.cation \nof length: int length(node x) requires ll(x, n)ensures ll(x, n).res=n ; We would have matched the current \nheap state to ll(x, 2)before asserting ll(x, 2).r=2 as the post-state of the code fragment. However, \nthis abstracted heap state has lost track of the entire cut-point from variable y, while the node at \nx is being replaced by a ll(x, 2) predicate. As a result, we are unable to reason about any information \npertaining to y (and to a lesser extend x) after the method call. To rectify this de.ciency, we can use \nthe earlier im\u00admutable speci.cation: int length(node x) requires ll(x, n)@I ensures res=n ; During the \nentailment for each immutable predicate, such as ll(x, n)@I, the original heap state remains unchanged \nbut instantiation on properties, such as n=2, can still be computed from the current heap state. Thus, \nat the end of the code fragment given earlier, we expect the following to be captured, x . node(1, y)* \ny . node(2, null).r=n=2, which preserves the cut-points for both x and y.Thisdiffer\u00adence in the treatments \nbetween mutable and immutable pred\u00adicates by our new entailment procedure, allows considerable more information \nto be preserved for immutable predicates. We shall formally describe this procedure later in Sec 4.2. \n 2.4 Partial Immutability Another aspect of our immutability enhanced speci.cation is that we support \nthe annotation of only a segment of linked nodes, rather than a fully linked data structure. Let us .rst \nconsider a segment of singly-linked nodes, as de.ned by the following predicate: lseg(root, p, n)= root=p \n. n=0 . root . node(r, q)* lseg(q, p, n-1)inv n=0 ; As an example of its use, let us also consider a \nmethod to join a linked list to another, as shown below. void append(node x, node y) requires lseg(x, \nnull, n).x =null ensures lseg(x, y, n) ; {if (x.next =null) then append(x.next, y); else x.next=y;} \nThe .rst linked-list must be non-empty and moreover it will be mutated by the method to join up with \nthe second list. On closer inspection, it is actually the last node of the .rst linked list that is being \nmutated. Thus, to capture the spec\u00adi.cation of append method in a more accurate manner, we can actually \nuse the following pre/post speci.cation instead: void append(node x, node y) requires lseg(x, p, n)@I*p \n. node(v, null)ensures p . node(v, y) ; The entire segment of the .rst linked list minus the last element, \nnamely lseg(x, p, n)@I, is now marked as im\u00admutable. Only the last node p . node(v, null) of the .rst \nlinked list is left as a mutable node, and suitably speci.ed as modi.ed in the post-condition of the \nmethod. This speci.\u00adcation is both simpler and more precise. All cut-points per\u00adtaining to the initial \nsegment of parameter x are preserved by the presence of an immutable lseg predicate in the pre\u00adcondition. \nIt can even be used to reason about the formation of cyclic linked list when x=y, or even lasso-style \ncircular linked list when y points to a node within the .rst list of nodes.  2.5 Read and Write Phases \nOne of the goals of the current proposal is to relax the heap separation principles speci.c to separation \nlogic, by allowing two phases in the heap description. The two phases have the following attributes: \na read phase, where all the predicates must be im\u00admutable. As mutation is disabled in the read phase, \nwe allow heap sharing between the constituting heap pred\u00adicates, which can be co-joined by both * and \n..This  corresponds to the initial reading phase in a program, and contains the heap being read before \nany writing took place. a write phase, where the predicates can be either mutable or immutable. As this \nphase might involve writing, we do not allow heap sharing. Hence, we require structural separation between \nthe heap predicates through *. Our formulation for entailment proving is simple as it comprises only \ntwo phases, but is general enough to cover several situations where .exible aliasing may be deployed. \nWe advocate for capturing the precise aliasing only when required, namely after at least one mutation/writing \ntook place. For illustration, let us assume a method call length, which calls the length method de.ned \nin Sec 2.1 for a list received as argument, and records the result in a data node, also received as argument. \nInitially, we leave the call length method unspeci.ed. void call length(node x, node y) { int l = length(x); \ny.val = l; } In the body of the call length method, we can distinguish two distinct phases, namely: \nan initial read phase, where the linked list pointed by x is being read by the length method.  a subsequent \nwrite phase, where the data node pointed by y is updated to record the length of the list pointed by \nx.  Using our read/write phases approach, we can provide the speci.cation given below, where the heap \ndescription precisely captures the code behavior. Semantically, F1#F2 is equivalent to F1.F2. Operationally, \nwe interpret F1#F2 as a speci.cation that comprised of a read phase for an immutable formula F1, followed \nby a write phase for a possibly mutated F2. In this example, the initial read phase is captured by ll(x, \nn)@I, while the subsequent write phase is denoted by y . node( , z). As all the reading takes place before \nupdating the node pointed by y, there is no need to capture the aliasing between x and y. This is exploited \nin our speci.cation through the use of the # connector. void call length(node x, nodey) requires ll(x, \nn)@I#y . node( , z)ensures y . node(n, z);  2.6 Immutable Postconditions Apart from improving the analysis \nof methods, one other ap\u00adplication of our immutability enhancement is the construc\u00adtion of immutable \n(or partially immutable) data structures. For illustration, consider a method for constructing a list \nof length n. Let us assume that after the construction phase we do not allow the list to be mutated. \nIn order to guarantee that the list cannot be mutated outside this method, we can mark it as immutable \nin the method s postcondition. Consequently, after a call to the ll build method, any caller will only \nbe allowed to read the list, and cannot update it in any way. node ll build(int n) requires n=0 ensures \nll(res, n)@I; { if (n == 0) then null; else { int v = ... ; new node(v, ll build(n-1)); }} We can use \nthis mechanism to specify the methods of immutable classes or data structures. We can also apply this \nconcept to selectively protect portions of a data structures from being modi.ed by other methods through \nthis concept of partial immutability.  3. Speci.cation Language In Figure 1 we introduce a core imperative \nlanguage. Our language is strongly typed and we assume programs and constraints are well-typed. The language \nsupports data type declaration via datat, and heap predicate de.nition via spred. For each heap de.nition \nspred, we also declare a heap\u00adindependent invariant p0 over the parameters {root,v *}that holds for each \ninstance of the predicate. Each heap predicate can be annotated with an immutability annota\u00adtion, u .{I, \nM}, which scopes over the entire predicate (c(v, v *)@u). This is to support use-site annotations. In \nor\u00adder to support declaration-site annotations, every data type declaration and heap predicate de.nition \ncan also contain immutability annotations. Note that, if no annotation is present, a data node/heap predicate \nis considered to be mu\u00adtable. For illustration, x . node(v, y)@I corresponds to an immutable node, meaning \na node whose both .elds cannot be mutated. Note that we support the following subtyping relation between \nthe immutability annotations M<:I. Each method is decorated with the speci.cation {requires Fi ensures \nFi }p that is made up of a col\u00ad pr poi=1 lection of pre-and postcondition pairs. The intended mean\u00ading \nis that whenever the method is called in a program state satisfying precondition Fi and if the method \nterminates, the pr resulting state will satisfy the corresponding postcondition Fi po. The F constraint \nis in disjunctive normal form. Each disjunct consists of a heap constraint ., referred to as heap part, \nand a heap-independent formula p,referredtoas pure part. The heap part is organized according to the \ncode s reading and writing phases: .R corresponding to the initial read phase in the code. This phase \ncontains only immutable predicates co-joined by either * or .. Note that it is compulsory in this phase \nfor each predicate to be immutable, i.e. to have an im\u00admutability annotation @I.  .W corresponding \nto the write phase in the code. This phase can contain both immutable and mutable predi\u00adcates co-joined \nby *.  The read and write phases are co-joined by the # con\u00adnector, whose semantic is given in Sec. \n6.2.  The pure part does not contain any heap nodes and is presently restricted to pointer equality/disequality \n., Pres\u00adburger arithmetic f and bag constraint ..Furthermore, . denotes a composite formula that could \nalways be nor\u00admalized into the F form. During the veri.cation process, the heap state might contain nested \nread and write phases, . ::= .R#(.W *.). For brevity, we only present the formal\u00adization for one read \nand one write phase. Our speci.cation is meant to minimize the need to ex\u00adplicitly express aliasing relations. \nAccordingly, we use the following principles: 1. Aliasing does not need to be explicitly speci.ed: inside \nthe read phase as none of the available pointers can be used to mutate the heap. between the read phase \nand the write phase as, during our entailment checking, once the writing phase is encountered, the read \nphase is discarded. Basically, we consider that writing to the heap invalidates all the previous reads \nfrom the heap. This will be further described during the entailment proving procedure in Sec4 . 2. Aliasing \nneeds to be explicitly speci.ed: inside the write phase  4. Entailment Proving Given formulas F1 and \nF2, our entailment prover checks if F1 entails F2, that is if in any heap satisfying F1, we can .nd a \nsub-heap satisfying F2: F1 . V,I F2 * FR. . is the history of nodes from the antecedent that have been \nused to match mu\u00adtable nodes from the consequent, V is the list of existentially quanti.ed variables \nfrom the consequent, and I keeps track of the history of nodes from the antecedent that have been used \nto match immutable nodes from the consequent and have been temporarily removed from the antecedent. Note \nthat ., V , and I are derived. The entailment checking pro\u00adcedure is initially invoked with . = emp, \nV = \u00d8, I = emp. Besides determining if the entailment relation holds, our en\u00adtailment prover also infers \nthe residual heap of the entail\u00adment, that is a formula FR such that F1=F2 *FR. To support proof search, \nwe generalized the entailment checking procedure to return a set of residues SR: F1 . V,I F2 * SR. The \nentailment succeeds when SR is non-empty, otherwise it is deemed to have failed. The multiple residual \nstates captured in SR signify different search outcomes during proving. In the rest of the paper, we \nmay refer to the LHS of an entailment judgment as antecedent, and to the RHS as consequent. Our entailment \nprocedure relies on unfolding and fold\u00ading of the predicate de.nitions. Unfolding refers to a sin\u00adgle \ninlining of a predicate in the antecedent, while folding is a recursive entailment with the body of a \npredicate in the consequent. Our goal in the current work is enhancing the entailment proving procedure \nto handle the current form of the heap formula with conjunction and immutability annota\u00adtions. 4.1 Splitting \nthe entailment Our entailment proving is structured as follows: split the heap on the RHS according \nto the rules [ENT-SPLIT-RHS1] and [ENT-SPLIT-RHS2] (Fig 2)  split the heap on the LHS according to the \nrules [ENT-SPLIT-LHS1] and [ENT-SPLIT-LHS2] (Fig 3)  For convenience, we also provide a lifted variant \nof the entailment checking procedure, which takes a set of prestates. The entailment succeeds in such \na case if any of the prestates gives rise to a successful entailment, that is if at least one of the \nSi is non-empty. This variant of the en\u00adtailment is useful when we break the entailment procedure according \nto the read and write phases, where each indi\u00advidual phase could potentially give rise to a set of residual \nstates. In order for the entire entailment to succeed, we need it to only succeed for one of the phases. \n.i.1...n\u00b7Fi . V,I F * Si {F1,..., Fn} . V,I F *.ni=1 Si For the case of the [ENT-SPLIT-RHS1] rule in \nFig 2, the splitting is performed when encountering a phase split, #. At that point, the heap entailment \nis divided into sub-phases corresponding to the read and write phases, respectively: First the read phase, \n.R, is entailed, obtaining a set of residual states, S. If the heap from the read phase is co\u00adjoined \nthrough ., then the entailment will be further split according to rule [ENT-SPLIT-RHS2] in Fig 2. To \ndif\u00adferentiate the entailment of the read phase, we provide the . entailment judgement F1|F2 * SR (Fig \n2). = RDRHS V,I Secondly, the write phase is entailed with the help of the residual state from the previous \nentailment. Take note that before entailing the write phase, .W , the read phase needs to be dropped \nas it is no longer safe to use that information (the heap from the read phase might have been mutated \nby a write in the write phase). The dropping of the read phase is performed by the dropRP function, \n P ::= tdecl* meth* tdecl ::= datat | spred datat ::= data c[@u] { (.eld)* } .eld ::= tv t ::= c | t \nt ::= int | bool | float | void u ::= I | M spred ::= c(v *)[@u] = F inv p0 }p meth ::= t mn ((tv)*) \n{requires Fi ensures Fi {e} pr poi=1 e ::= null | kt | v | v.f | v:=e | v1.f:=v2 | new c(v *) | e1; e2 \n| tv; e | mn(v *) | if v then e1 else e2 | while v where Fpr *. Fpo do e * F ::= (.v \u00b7..p)* p ::= ..f \n. ::= v1 =v2 | v=null | v1 =v2 | v=null | .1..2 . ::= .R#.W | emp .R ::= .R* ..R | c(v, v *)@I | v . \nc(v *)@I | emp .R* ::= .R* *.R* | c(v, v *)@I | v . c(v *)@I | emp .W ::= .W *.W | c(v, v *)[@u] | v \n. c(v *)[@u] | emp . ::= F | .1..2 | ..p | .1 *.2 |.v\u00b7. f ::= . | b | a | f1.f2 | f1.f2 |\u00acf |.v \u00b7 f |.v \n\u00b7 f b ::=true | false | v | b1 =b2 a ::=s1 =s2 | s1=s2 kint s ::= | v | kint \u00d7s | s1 +s2 |-s | max(s1,s2) \n| min(s1,s2) ||B| . ::= v.B |B1 =B2 |B1cB2 |.v.B\u00b7f |.v.B\u00b7f B ::= B1UB2 |B1nB2 |B1-B2 |{}|{v} Figure \n1. A Core Imperative Language which is given below. dropRP (S)=df .F . S.dropRPF(F) ** dropRPF((.v \u00b7..p)*)=df \n(.v \u00b7dropRP.(.).p)* dropRP.(.R # .W )=df .W Lastly, the pure information from the RHS, p2, is en\u00adtailed, \ngenerating the .nal set of residual states, S2. For the rule [ENT-SPLIT-LHS1] in Fig 3, we take advan\u00adtage \nof the proof search capability of our system by trying to entail the heap . from the RHS using both the \nread phase, .R, and write phase, .W , from the LHS. The entailment succeeds if either the read or the \nwrite phase on the LHS gives rise to a successful entailment, that is if at least one of the residual \nstates S1 and S2 is non-empty. When the LHS consists of only the read phase, rule [ENT-SPLIT-LHS2] from \nFig 3 applies. This rule continues splitting the an\u00adtecedent whenever . is encountered in the heap formula \non the LHS. The entailment succeeds if at least one of the sub\u00adentailments succeeds. We provide the entailment \njudgement . F1|F2 * SR (Fig 3). = RDLHS V,I  4.2 Matching During entailment, each pair of aliased nodes \nfrom the an\u00adtecedent and consequent are matched up, whenever they are proved identical. The formal rules \nfor matching are given in [ENT-MATCH-MUT] and [ENT-MATCH-IMM] in Fig 4. Rule [ENT-MATCH-MUT] applies \nwhenever the node to be matched on the RHS is mutable, while [ENT-MATCH-IMM] applies for immutable nodes \non the RHS. For the former rule, the matching node from the LHS is consumed. As the matching process \nis incremental, we keep the successfully matched nodes from antecedent in . for better precision. Function \nXPuren soundly approximates the heap formula in the antecedent, and it will be described in Sec 4.3. \nIn the case of the rule [ENT-MATCH-IMM], the match\u00ading node on the LHS is not consumed. However, the \nnode needs to be temporarily removed until the entire .2 is en\u00ad * tailed. This is due to the fact that \nc(p2,v2 )@I and .2 must reside in disjoint heaps as they are co-joined by the separat\u00ading conjunction. \nHence, we will extract the matching node from the antecedent and add it to the history of nodes tem\u00adporarily \nremoved, I. The temporarily removed nodes will be put back at the end of the entailment by the ENT-EMP \nrule given below: [ENT-EMP] .=[0/null] b=(XPuren(.1 *..p1)=..V\u00b7.p2) . .1.p1 V,I (p2) *{.1 *I.p1 | b} \nNote that, at the point in the entailment procedure when the matching is reached, the heap formulae in \nboth the an\u00adtecedent and consequent contain only heap predicates co\u00adjoined by *. This is due to the fact \nthat the entailment was already split according to the rules in Sec 4.1 such that . and # were eliminated \nfrom the heap.  [ENT-SPLIT-RHS1] . .1.p1|= RDRHS V,I .R * S [ENT-SPLIT-RHS2] .. dropRP (S) V,I .W * \nS1 .1.p1 V,I .R* * S . . S1 V,I p2 * S2 S|= RDRHS V,I .R * S1 .. .1.p1 V,I (.R#.W .p2) * S2 .1.p1|= \nRDRHS V,I (.R* ..R) * S1 Figure 2. Splitting RHS [ENT-SPLIT-LHS1][ENT-SPLIT-LHS2] .. .R|= RDLHS V,I . \n* S1 .R* V,I . * S1 ..W V,I . * S2 .R|= RDLHS V,I . * S2 .. . .R#.W V,I . * (S1 . S2) .R* ..R|= RDLHS \nV,I . * (S1 . S2) Figure 3. Splitting LHS ((cp,v2V,I 12 * 1 * 1* 2 * 2 [ENT-MATCH-MUT] ** XPuren(c(p1,v1 \n)@u*.1 *p1)=.p1 =p2 .=[v1 /v2 *] .*c(p1,vn .1.p1.freeEqn(., V ) .(.2.p2) * Su<:M V -{v },I * . * c(p1,v \n)@u*.1.p1 )@M*.2.p2) * S [ENT-MATCH-IMM] ** XPuren(c(p1,v1 )@u*.1 *p1)=.p1 =p2 .=[v1 /v2 *] . .1.p1.freeEqn(., \nV ) V -{v },I*c(p1,vn@u.(.2.p2) * Su<:I * . * c(p1,v1 )@u*.1.p1 V,I (c(p2,v2 )@I*.2.p2) * S Figure 4. \nHeap Entailment Rules Another feature of the entailment procedure is exem\u00adpli.ed by the transfer of the \nbindings between free vari\u00adables from the matched node in the consequent and the corresponding variables \nfrom the consequent to the an\u00adtecedent (and subsequently to the residue). In general, when a match occurs \n(rules [ENT-MATCH-MUT] and [ENT-MATCH-IMM]) and an argument of the heap pred\u00adicate coming from the consequent \nis free, the entailment procedure binds the argument to the corresponding vari\u00adable from the antecedent \nand moves the equality to the an\u00adtecedent. In our system, free variables in consequent are variables \nfrom method preconditions. These bindings play the role of parameter instantiations during forward reason\u00ading, \nand can be accumulated into the antecedent to allow the subsequent program state (from residual heap) \nto be aware of their instantiated values. This process is formalized by the function freeEqn below, where \nV is the set of existentially quanti.ed variables: freeEqn([ui/vi]ni=1,V )=df . n let pi =(if vi.V then \ntrue else vi =ui) in pi i=1  4.3 Heap Approximation by a pure formula In our entailment proof, the entailment \nbetween separation formulae is reduced to entailment between pure formulae by successively removing heap \nnodes from the consequent un\u00adtil only a pure formula remains. When this happens, the heap formula in \nthe antecedent can be soundly approximated by function XPuren. The function XPuren(F), whose de.nition \nis given in Fig 5, returns a sound approximation of F as a ** tuple of the form: ((.v \u00b7p)*,S) where (.v \n\u00b7p)* repre\u00adsents a pure formula approximating F and S denotes the set of disjoint memory sets in F. Each \ndisjoint memory set con\u00adtains non-aliased symbolic memory addresses. The de.ni\u00adtion of XPuren(F) is given \nin Fig 5. The function IsData(c) returns true if c is a data node, while IsPred(c) returns true if c \nis a heap predicate. .disj and ndisj are used for comput\u00ading the set of disjoint memory sets and are \nde.ned as fol\u00adlows:  S1 .disj S2 = {X . Y | X . S1 . Y . S2}S1 ndisj S2 = {X n Y | X . S1 . Y . S2} \nWe illustrate how the approximation functions work by com\u00adputing XPure0 (ll(x, n)@I*ll(y, m)@I#ll(z, \nv). n=0 . m=0 . v=0) Note that, according to the de.nition provided for the ll predicate, the pure invariant \nprovided is n=0. ll(root, n)= root=null . n=0 . root . node( , q)* ll(q, n-1)inv n=0; XPure0(ll(x, n)@I)=(Inv0(ll(x, \nn)@I), {{x}})= =(n=0, {{x}}) given that n=0 XPure0(ll(y, m)@I)=(Inv0(ll(y, m)@I), {{y}})= =(m=0, {{y}}) \ngiven that m=0 XPure0(ll(z, v))=(Inv0(ll(z, v)), {{z}})= =(v=0, {{z}}) given that v=0 XPure0(ll(x, n)@I*ll(y, \nm)@I)= =(n=0 . m=0, {{x}} .disj {{y}})= =(n=0 . m=0, {{x, y}}) XPure0(ll(x, n)@I*ll(y, m)@I#ll(z, v))= \n=(n=0 . m=0 . v=0, {{x, y}} . {{z}})= =(n=0 . m=0 . v=0, {{x, y}, {z}})   5. Forward Veri.cation Program \nveri.cation is typically formalised using Hoare triples of form {pre}code{post}, where pre and post are \nthe initial and .nal states of the program code in some logic (separation logic in our case). We use \nP to denote the pro\u00adgram being checked. With pre/post conditions declared for each method in P , we can \nnow apply modular veri.cation to its body using Hoare-style triples {.1} e {.2}. These are forward veri.cation \nrules as we expect .1 to be given before computing .2. To capture proof search, we general\u00adize the forward \nrule to the form {.1} e {S} where S is a set of heap states, discovered by a search-based veri.cation \nprocess. When S is empty, the forward veri.cation is said to have failed for .1 as prestate. As most \nof the forward veri.cation rules are standard [11], in Fig 6 we only provide those for method veri.cation, \nmethod call, .eld read and .eld update. Veri.cation of a method starts with each precondition, and proves \nthat the corresponding postcondition is guaran\u00adteed at the end of the method. The veri.cation is formalized \nin the rule [FV-METH-IMM]: function prime(V) returns {v. | v . V }.  predicate nochange(V) returns \n.(v = v.).If V = {},  v.V nochange(V)=true. .W \u00b7 S returns {.W \u00b7 Si|Si . S}. At a method call, each \nof the method s precondition is . checked, . V,I .Fi * Si, where . represents a substitution pr of vj \nby vj, for all j =1, .., n. The combination of the residue Si and the postcondition is added to the poststate \n(this addition might cause phase nesting). If a precondition is not entailed by the program state ., \nthe corresponding residue is not added to the set of states. The test S={}ensures that at least one precondition \nis satis.ed. Whenever there is a .eld access (read or update), the current state, ., must contain the \nnode to be dereferenced, c(v,v1, .., vn).For [FIELD-READ], it is suf.cient for the entailed node to be \nimmutable as it will only be read. For [FIELD-UPDATE], the node needs to be mutable, as it will be updated. \nAs shown in the matching rules from Sec 4.2, for the case of the immutable node c(v,v1, .., vn)@I,the \nmatching of the immutable node on the RHS with a cor\u00adresponding node from the LHS will not consume the \nnode from the LHS. Hence, for [FIELD-READ] there is no need to add back the node at the end of the entailment. \nHow\u00ad ever, when entailing the mutable node c(v,v1, .., vn) in the rule [FIELD-UPDATE], the corresponding \nnode on the LHS will be consumed and needs to be added back at the end of the entailment. Moreover, in \nthe entailment . . . V,I c(v,v1, .., vn)@I * S1 from rule [FIELD-READ],as the matching node on the LHS \nis not consumed, there might be heap sharing between the RHS and the residual states. Note that we use \nthe primed notation for denoting the lat\u00ad est value of a variable. Correspondingly, [v0/vi] is a substi\u00ad \ntution that replaces the value vi with the latest value of v0.  6. Soundness In this section we present \nthe soundness properties for both the forward veri.er and the entailment prover. 6.1 Storage Model The \nstorage model is similar to the classical separation logic one [17], with the difference that we support \nimmutability annotations. Accordingly, we de.ne our storage model by making use of a domain of heaps, \nwhich is equipped with a partial operator for gluing together disjoint heaps. h0 \u00b7 h1 takes the union \nof partial functions when h0 and h1 have disjoint domains of de.nition, and is unde.ned when h0 (l) and \nh1 (l) are both de.ned for at least one location l . Loc. To de.ne the model we assume sets Loc of locations \n(pos\u00aditive integer values), Val of primitive values, with 0 . Val  (c(v *)= F inv p) . P Inv0(c(p, v \n*)@u)=df [p/root, 0/null]p (c(v *)= F inv p) . P n=1 XPuren-1(F) = (pn-1,Sn-1) Invn(c(p, v *)@u)=df \n[p/root, 0/null]pn-1 XPuren(.i)=(pi.,S) ** XPuren(i(.vi \u00b7.i.pi)*)=df (i(.vi \u00b7pi..[0/null]pi)* , ndisji \nSi) XPuren(emp)=df (true, \u00d8) XPuren(.1)=(p1,S1) XPuren(.2)=(p2,S2) XPuren(.1 . .2)=df (p1.p2,S1 . S2) \nXPuren(.1)=(p1,S1) XPuren(.2)=(p2,S2) XPuren(.1#.2)=df (p1.p2,S1 . S2) XPuren(.1)=(p1,S1) XPuren(.2)=(p2,S2) \nXPuren(.1 * .2)=df (p1.p2,S1 .disj S2) IsData(c) fresh i XPuren(c(p, v *)@u)=df (true, {{p}}) IsPred(c) \np=null * Invn(c(p, v *)@u)= .(.u \u00b7p)* XPuren(c(p, v *)@u)=df (.(.u * \u00b7p)* , {{p}}) IsPred(c) p=null \n * Invn(c(p, v *)@u)= .(.u \u00b7p)* XPuren(c(p, v *)@u)=df (.(.u * \u00b7p)* , \u00d8) Figure 5. XPure : Translating \nto Pure Form denoting null, Var of variables (program and logical vari\u00adables), and ObjVal of object values \nstored in the heap, with c[f1..1, .., fn..n] denoting an object value of data type c where .1, .., .n \nare current values of the corresponding .elds f1, .., fn. Each object value has attached an immutability \nan\u00adnotation from {I,M}. I means that the corresponding object value cannot be modi.ed, while M allows \nits mutation. h . Heaps = df Loc '.n ObjVal x {I,M} s . Stacks = df Var . Val .Loc Note that each heap \nh is a .nite partial mapping while each stack s is a total mapping, as in the classical separation logic \n[9, 17].  6.2 Semantic Model of the Speci.cation Formula The semantics of our separation heap formula \nis similar to the model given for separation logic [17], except that we have extensions to handle our \nuser-de.ned heap predicates together with the immutability annotations. Let s, h |=F denote the model \nrelation, i.e. the stack s and heap h satisfy the constraint F. Function dom(f) returns the domain of \nfunction f.Now we use . to denote mappings, not the points-to assertion in separation logic. The model \nrelation for separation heap formulae is given in Def 6.1. The model relation for pure formula s |= p \ndenotes that the formula p evaluates to true in s.The addImm function in Fig 7 propagates the immutability \nannotation u inside the heap formula F. The last case in Def 6.1 is split into two cases: (1) c is a \ndata node de.ned in the program P;(2) c is a heap predicate de.ned in the program P. In the .rst case, \nh has to be a singleton heap. In the second case, the heap predicate c may be inductively de.ned. Note \nthat the semantics for an inductively de.ned heap predicate denotes the least .xpoint, i.e., for the \nset of states (s, h) satisfying the predicate. The monotonic nature of our heap predicate de.nition guarantees \nthe existence of the descending chain of unfoldings, thus the existence of the least solution.  6.3 \nDynamic Semantics This section presents a small-step operational semantics for our language. The rules \nare given in Fig. 8. The machine  [FV-METH-IMM] V ={vm..vn} W=prime(V ) .i =1, .., p \u00b7 ( {Fi .nochange(V \n)} e {S1i } pr (.W\u00b7Si. * Si Si 1) V,I Fi 22 ={}) po }p t0 mn((ref tj vj)m-1 , (tj vj )n ) {requires \nFi ensures Fi {e} j=1 j=mpr poi=1 [FV-CALL-IMM] }p t0 mn((ref tj vj)m-1 ) {requires Fi ensures Fi {e}. \nP j=1 , (tj vj )nj=mpr poi=1 . .=[vj /vj]n . * Si .i=1, .., p pr j=m V,I .Fi p S =Fi * Si S = {} i=1 \npo {.} m(v1..vn) {S} [FV-FIELD-READ][FV-FIELD-UPDATE] .. . V,I c(v ,v1, .., vn)@I * S1 fresh v1..vn \nS1 =\u00d8 . V,I c(v ,v1, .., vn)@M * S1 fresh v1..vn S1 =\u00d8 S2 = .v1..vn \u00b7(S1.res=vi)S2 = .v1..vn \u00b7(S1 * [v0/vi]c(v \n,v1, .., vn)) {.} v.fi {S2} {.} v.fi:=v0 {S2} Figure 6. Forward Veri.cation Rules De.nition 6.1 (Model \nfor Speci.cation Formula). s, h |=F1.F2 iff s, h |=F1 or s, h |=F2 s, h |= .v1..n \u00b7..p iff ..1..n \u00b7s[v1..1, \n.., vn..n],h |= . and s[v1..1, .., vn..n] |= p s, h |= .1 *.2 iff .h1,h2 \u00b7 h1.h2 and h = h1 \u00b7h2 and s, \nh1 |= .1 and s, h2 |= .2 s, h |= .1#.2 iff .h1,h2,h3 \u00b7 h1.h2.h3 and h = h1 \u00b7h2 \u00b7h3 and s, h1 \u00b7h3 |= .1 \nand s, h2 \u00b7h3 |= .2 s, h |= .1..2 iff .h1,h2,h3 \u00b7 h1.h2.h3 and h = h1 \u00b7h2 \u00b7h3 and s, h1 \u00b7h3 |= .1 and \ns, h2 \u00b7h3 |= .2 s, h |= emp iff dom(h)= \u00d8 s, h |= c(p, v1..n)@u iff data c {t1 f1, .., tn fn}.P,h=[s(p).wr], \nand r=c[f1.s(v1), .., fn.s(vn)] and u<:w or (c(v1..n)=F inv p).P and s, h |=[p/root](addImm(F,u)) con.guration \nis represented by (s, h, e), where s denotes the current stack, h denotes the current heap, and e denotes \nthe current program code. Note that the operational semantics must consider the mutability assertions \nrecorded in the heap h. Each reduction step is formalized as a transition of the form: (s, h, e)Y.(s1,h1,e1). \nWe have introduced an inter\u00ad * mediate construct ret(v ,e) to model the outcome of call invocation, where \ne denotes the residual code of the call. It is also used to handle local blocks. We now explain the notations \nused in the operational se\u00admantics. We make use of k to denote a constant, . to denote an unde.ned value, \nand () to denote the empty expression (program). The operation [v..]+s pops in the variable v to s with \nthe value ., such that ([v..]+s)(v)= ..The  ** addImm(F,u)=df addImm((.v \u00b7..p)* ,u)=df (.v \u00b7addImm.(., \nu).p)* addImm.(.X C.Y ,u)=df addImm.(.X ,u) CaddImm.(.Y ,u), for X,Y .{R, W } and C .{#, *, .}addImm.(c(p2,v1,..,vn)@u1,u)=df \np2::c(v1,..,vn)@u Figure 7. Function addImm operation s-{v *} pops out variables v * from the stack s. \nThe operation s[v..] changes the value of the most recent v in stack s to .. The mapping h[..ur] is the \nsame as h except that it maps . to r, with u as the attached immutability anno\u00adtation, u.{I,M}. If no \nimmutability annotation is present, then the mapping h[..r] maintains the previous immutabil\u00adity annotation. \nThe mapping h+[..ur] extends the domain of h with . and maps . to r with the immutability annotation \nu. The operation h(l)[vn.tn] updates the .eld vn of the ob\u00adject stored at location l in the heap h with \nthe value tn.We also make use of the function type(v) to get the run-time type of the variable v. In \norder to relate the logic with the storage model, we introduce an auxiliary construct, assert F, which \nchecks whether the model relation s, h |=F holds. The forward ver\u00adi.cation rule for this intermediate \nconstruct is given below. [FV-ASSERT] . . S1 =\u00d8 V,I F1 * S1 {.} assert F1 {.} The connection between \nthe immutability information from the speci.cation and the storage model is established at the beginning \nand end of each method execution, when the assert construct is used to check that the stack s and the \nheap h model the method s precondition and postcondition, respectively. Note that in the rule for new \nc(v *) we assume that the object newly created is immutable, and, whenever a .eld update takes place, \nthe immutability annotation is updated to @M (in the rule for .eld update v1.fi := v2 in Fig 8).  6.4 \nSoundness of Veri.cation The soundness of our veri.cation rules is de.ned with re\u00adspect to the small-step \noperational semantics. We need to ex\u00adtract the post-state of a heap constraint by function Post(.) de.ned \nin Def 6.2. De.nition 6.2 (Poststate). Given a constraint .,Post(.) captures the relation between primed \nvariables of .. That is: Post(.) = df . (.V\u00b7.), where V = {v1, .., vn} denotes all unprimed program variables \nin . . =[v1/v1, .., vn/v] n Theorem 6.1 (Preservation). If {.} e {S2} S2 ={} s, h |= Post(.) (s, h, \ne)Y.(s1,h1,e1) Then there exists S1 ={}, such that ..1 . S1 \u00b7s1,h1 |= Post(.1) and {.1} e1 {S3},S3.S2. \nProof: By structural induction on e. Details can be found in the technical report [4].  Theorem 6.2 \n(Progress). If {.} e {S1} S1 ={} s, h |= Post(.) then either e is a value, or there exist s1,h1, and \ne1,such that (s, h, e)Y.(s1,h1,e1). Proof: By structural induction on e. Details can be found in the \ntechnical report [4]. Theorem 6.3 (Safety). Consider a closed term e without free variables in which \nall methods have been successfully veri.ed. Assuming unlimited stack/heap spaces and that {true} e {.}, \nthen either ([], [],e)Y.*([],h,v) termi\u00adnates with a value v that is subsumed by the postcondition ., \nor it diverges ([], [],e)Y.* . Proof: Details can be found in the technical report [4]. Theorem 6.4 (Soundness \nof Entailment). If entailment check .1 .2 * S succeeds, we have: for all s, h, and . . S , if s, h |=.1 \nthen s, h |=.2 * .. Proof: Details can be found in the technical report [4].  7. Experiments We have \nbuilt a prototype system using Objective Caml. The proof obligations generated by our veri.cation are \ndis\u00adcharged using a number of off-the-shelf constraint solvers (like Omega Calculator [14]) or theorem \nprovers (like Is\u00adabelle [12] and Mona [10]). Preliminary experiments were conducted by testing our system \non a suite of examples summarized in Figure 9. The examples can handle data structures with sophisticated \nshape and size properties, such as sorted lists, and balanced trees, in a uniform way. Method sum is \nthe one described in Sec 2.1. Methods insert and delete refer to the insertion  (s, h, v)Y.(s, h, s(v))(s, \nh, k)Y(s, h, v.f)Y .(s, h, k) .(s, h, h(s(v))(f)) (s, h, v:=k)Y.(s[v.k],h, ())(s, h, (); e)Y .(s, h, \ne) (s, h, e1)Y.(s1,h1,e3)(s, h, e)Y .(s1,h1,e1)(s, h, e1; e2)Y.(s1,h1,e3; e2)(s, h, v:=e)Y .(s1,h1,v:=e1) \ns(v)=true s(v)=false (s, h, if v then e1 else e2)Y.(s, h, e1)(s, h, if v then e1 else e2)Y.(s, h, e2) \n(s, h, {tv; e})Y .([v..]+s, h, ret(v, e)) (s, h, ret(v * ,k))Y* },h,k) .(s-{v (s, h, e)Y .(s1,h1,e1)(s, \nh, ret(v * ,e))Y* ,e1)) .(s1,h1, ret(v type(v1)= c(w1,..,wn)r=h(s(v1))[f.s(v2)] h1 =h[s(v1).M r] (s, \nh, v1.fi := v2)Y .(s, h1, ()) s, h |=F (s, h, assert F)Y.(s, h, ()) data c {t1 f1, .., tn fn}.P ./.dom(h) \nr=c[f1.s(v1), .., fn.s(vn)] (s, h, new c(v *))Y .(s, h+[. .I r],.) }p t0 mn((ref tj wj)m-1 , (tj wj )n \n) {requires Fi ensures Fi {e} j=1 j=mpr poi=1 )p s1=[wj .s(vj)]n +s )Y(s1,h, (assert Fi .(s1,h, ()) j=mpri=1)p \n(s1,h, ret({wj }n , [vj/wj]m-1 ))Ye;(assert Fi .(s, h1,e1) j=mj=1 poi=1 (s, h, mn(v *))Y.(s, h1,e1) Figure \n8. Small-Step Operational Semantics and deletion of a value into/from the corresponding data structure, \nrespectively. Moreover, we verify a suite of sorting algorithms, which receive as input an unsorted singly-linked \nlist and return a sorted list. The benchmarks under the category Big Naturals con\u00adsider the representation \nof a big natural as a list, with each node containing a decimal digit. The order of recording the digits \nis such that the head of the list contains the least sig\u00adni.cant digit. We make use of the following \nheap predicate for describing the singly-linked list containing the big natu\u00adral number: bignat(root, \nv)= root=null . v=0 . root . node(p, q)* bignat(q, v1 ). 0=p=9 .v=10*v1 +p . v>0 inv v=0; The de.nition \nasserts that a big natural is either an empty list denoting the value 0 (the base case root=null.v=0), \nor it consists of a head data node (root . node(p, q)) and a separate tail data structure which is also \na big natural (bignat(q, v1 )). For the latter case, the value of the big nat\u00adural is computed as v=10*v1 \n+p. To ensure uniqueness in representing the value 0, this predicate also adds the con\u00adstraint v>0 for \nnon-null representations of big natural num\u00adbers. Using this de.nition, the methods under the Big Natu\u00adrals \ncategory compute the addition, subtraction and multipli\u00adcation of two big naturals in the corresponding \nmethods, re\u00adspectively. Under the same category, method compare takes as input two big naturals and returns \n0 if they are equal, 1 if the .rst one in bigger, and -1 if the .rst one is smaller. Lastly, method karatsuba \nmult uses the fast multiplica\u00adtion Karatsuba algorithm for multiplying two big naturals. The second column \nof Figure 9 contains the number of lines of code, followed by the timings in the third column. The fourth \ncolumn records whether or not the speci.cation contains heap sharing, meaning if there are any usage \nof . in the heap description. We mark the presence of heap sharing by ., and the absence by .. The .fth \ncolumn contains the immutability degree of a speci.cation, denoting the percent\u00adage of immutable heap \npredicates out of the total number of heap predicates in the speci.cation. The sixth and seventh  Program \nLOC Timings Heap Immutability Heap Aliasing scenarios codes [secs] sharing degree [%] reduction [%] reduction[%] \nData Nodes (veri.es data node value) sum 1 0.04 . 100 50 50 Big Naturals (veri.es bignat value) addition \n29 0.74 . 62 38 40 subtraction 24 0.76 . 62 38 40 multiplication 23 0.97 . 71 36 25 compare 20 0.66 . \n100 50 50 karatsuba mult 64 3.82 . 60 60 33 Linked List (veri.es shape + length) length 6 0.05 . 100 \n50 0 append 8 0.08 . 66 40 50 List Segment (veri.es shape + length) append 8 0.06 . 50 33 50 Sorted List \n(veri.es shape + bounds + sortedness) insert 17 0.26 . 50 33 0 insertion sort 45 0.32 . 57 36 25 selection \nsort 52 0.37 . 57 36 0 bubble sort 42 0.45 . 40 29 0 merge sort 105 0.51 . 77 35 20 quick sort 85 0.68 \n. 50 33 20 AVL Tree (veri.es shape + height + balance factor) insert 169 5.63 . 44 30 0 delete 287 8.92 \n. 69 40 74 Perfect Tree (veri.es shape + height + perfectness) insert 89 0.34 . 50 33 0 Binary Search \nTree (veri.es shape + min + max + sortedness) insert 40 0.45 . 50 33 0 delete 62 0.49 . 50 33 0 Priority \nQueue (veri.es shape + size + height + max-heap) insert 54 0.89 . 50 33 0 delete max 140 2.73 . 38 28 \n25 Red-Black Tree (veri.es shape + size + black-height) insert 167 2.65 . 75 42 75 delete 430 15.16 . \n70 42 93 Figure 9. Experimental Results columns record the reduction in the size of the speci.cation \nwhen using the immutability enhancements proposed by the current work. The sixth column represents the \nheap reduc\u00adtion, which is due to the fact that the heap predicates marked as immutable in the precondition \nare guaranteed to be pre\u00adserved by the corresponding method, and do not have to be mentioned in the postcondition. \nThe last column registers the reduction in the number of aliasing scenarios that have to be recorded \nby the speci.cation. This happens when sev\u00aderal aliasing scenarios are uni.ed through the use of . in \nthe heap description. In order to compute the timings, im\u00admutability degree, heap reduction and aliasing \nscenarios re\u00adduction for each benchmark, we took into consideration all the functions that are being \ncalled. For illustration, let us consider the results recorded for the method sum under Data Nodes. The \nspeci.cation, which is given below, employs heap sharing due to the presence of . in the precondition. \nThe immutability degree is 100% (all the heap predicates in the speci.cation are immutable), the reduction \nof heap predicates is 50% (the two immutable heap predicates from the precondition do not have to be \nrepeated in the postcondition) and the reduction of aliasing scenarios is 50% (the scenario when x and \ny are aliases is uni.ed with the scenario when they are disjoint). int sum(node x, node y) requires x \n. node(a, )@I.y . node(b, )@I ensures res=a+b;  The results of our preliminary experiments recorded \nin Fig 9 can be interpreted as follows: The heap sharing and immutability degree (fourth and .fth columns, \nrespectively) are measures on the appli\u00adcability of our enhancements. The potential heap sharing in a \nspeci.cation creates the opportunity to use . in the heap description for unifying multiple aliasing \nscenarios. Fig 9 shows that for 15 out of all 24 benchmarks, there is good potential for heap sharing \nin the speci.cation. Moreover, the immutability degree recorded in the .gure con.rms the fact that, on \naverage, from all the heap that a method accesses, 62% can be symbolically analyzed for read-only. Hence, \nonly less than half is marked for muta\u00adtion. The heap that is not being updated can be declared as immutable \nin the associated speci.cation. These re\u00adsults af.rms the applicability of our approach.  The heap and \naliasing scenarios reduction (sixth and sev\u00adenth columns, respectively) are used to quantify the gains \nrecorded by our current enhancements with respect to the conciseness of the speci.cation. The data shows \nthat, on average, there is a 38% reduction in the number of heap predicates, and a 28% reduction in the \nnumber of alias\u00ading scenarios. This heap and aliasing scenarios reduction shows an improvement in the \nspeci.cation conciseness when using the immutability annotations proposed by the current work.  The \nimmutability degree together with the heap reduction (.fth and sixth columns, respectively) are measures \nthat relate to the improvement on the precision of the speci.\u00adcations, as they denote the cases where \ncut-point preser\u00advations are possible.  When comparing the veri.cation timings for the immutability\u00adenhanced \napproach with those for the base approach, we found them to be similar. The biggest differences were \nrecorded in the case of the insert method for red-black tree (1.2 secs in favor of the base approach), \nand of the insert method for the AVL tree (1.1 secs in favor of the immutability-enhanced approach). \n 8. Related Work and Conclusions The importance of immutability annotations have been high\u00adlighted in \nseveral past works on extended type systems to detect immutable heap locations [2, 8, 15, 19, 20]. Our \ncur\u00adrent paper shows a new application of immutability anno\u00adtation, for verifying and reasoning of sequential \nprograms. What distinguishes our work from type-based approaches is that we can apply immutability annotation \non user-de.nable predicate de.nitions. This can be used to annotate either par\u00adtial or entire data structures \nfor read-only access, as may be required by the logics of a given program component. This new approach \nadds considerable expressiveness to im\u00admutable speci.cations, allowing us to support more concise, more \nprecise and more .exible schemes for both analysis and veri.cation of user programs. Our view is that \nfor the purpose of program veri.cation, it is necessary to rely on the .ner granularity of control that \nuser-de.ned predicates can provide for the speci.cation logic. Due to the .exibility of user-de.ned predicates, \nthe immutability annotations that we can provide via speci.ca\u00adtion logic would naturally subsume the \nimmutability anno\u00adtations that is available in existing type systems. Separation logic uses separation \nand local reasoning as a means to enforce exclusive ownership over each heap cell [17]. This interpretation \nof the points-to assertion in sep\u00adaration logic is not simply to describe a part of the heap, but can \nbe enhanced with read/write permissions for better analysis and control. This observation has been extensively \nexploited by works dealing with permissions [3, 6] for en\u00adabling race free sharing of heap storage between \nconcurrent threads. Bornat et al [3] extended separation logic to allow shared read access using permissions. \nThe authors consid\u00adered predicates that admit to a weaker permission, namely read-only permission. One \nproblem with the read-only per\u00admissions is that * can no longer be used to express disjoint\u00adness as the \nsame permission can appear twice, i.e. two read permissions on the same cell. Any two read permissions \non a .eld look identical and cannot be distinguished. Hence, per\u00admissions need to be disjoint. Parkinson \nsolves this problem by giving names to permissions [13]. Inspired by the use of permissions for the concurrent \npro\u00adgramming setting [3], we have designed a much simpler mechanism for enabling immutability annotations \nin the se\u00adquential programming setting. In our case, * still expresses disjointness. As our model is \nfocused on the sequential set\u00adting, we do not currently support multiple read-only per\u00admissions for a \ngiven resource. Instead, our goal is to ex\u00adploit those scenarios in which data structures can be treated \nas immutable in order to support a more precise veri.ca\u00adtion/analysis. Our solution is tailored towards \nmore .exi\u00adble alias analysis, supports partial immutability, better cut\u00adpoints preservation for modular \nanalysis and can support ac\u00adcess controls through immutable predicates within both pre and post-conditions. \nThe new speci.cation mechanism al\u00adlow us to design a more concise and more precise veri.ca\u00adtion/analysis \nsystem, with .ner controls over accesses to our resources (cf data structures). At the current moment, \nthe immutability annotations in the speci.cations are manually provided by the user. As a future direction, \nwe intend to auto\u00admatically derive them. This could be achieved by employing a purity analysis that can \ndetect read-only parameters [18]. In order to support immutability in modular veri.cation methodology, \nthe current work shows three main advantages of its use in a sequential setting: more concise speci.cations \n(38% reduction in heap pred\u00adicates, and 28% reduction in aliasing scenarios).  more precise analysis/veri.cation \n(62% immutability an\u00adnotations that increase precision by helping to preserve cutpoints across method \nboundaries).  capability for .ner-grain immutability.   Acknowledgments We thank Andreea Costea and \nthe reviewers of OOPSLA 2011 for their constructive comments. We also gratefully acknowledge the .nancial \nsupport from MoE Tier-2 grant R-252-000-411-112.  References [1] J. Berdine, C. Calcagno, and P. W. \nO Hearn. Smallfoot: Mod\u00adular automatic assertion checking with separation logic. In 4th International \nSymposium on Formal Methods for Com\u00adponents and Objects (FMCO05), volume 4111 of Springer LNCS, 2006. \n[2] Adrian Birka and Michael D. Ernst. A practical type system and language for reference immutability. \nIn John M. Vlissides and Douglas C. Schmidt, editors, OOPSLA, pages 35 49. ACM, 2004. [3] Richard Bornat, \nCristiano Calcagno, Peter W. O Hearn, and Matthew J. Parkinson. Permission accounting in separation logic. \nIn POPL, pages 259 270, 2005. [4] Cristina David and Wei-Ngan Chin. Immutable speci.\u00adcations for more \nconcise and precise veri.cation. Tech\u00adnical report, National University of Singapore, 2011. avail. at \nhttp://www.comp.nus.edu.sg/~davidcri/reports/ imm tech.pdf. [5] Dino Distefano and Matthew J. Parkinson. \njstar: towards practical veri.cation for java. In OOPSLA, pages 213 226, 2008. [6] Robert Dockins, Aquinas \nHobor, and Andrew W. Appel. A fresh look at separation algebras and share accounting. In APLAS, pages \n161 177, 2009. [7] A. Gotsman, J. Berdine, and B. Cook. Interprocedural Shape Analysis with Separated \nHeap Abstractions. In SAS, Springer LNCS, Seoul, Korea, August 2006. [8] Christian Haack, Erik Poll, \nJan Sch\u00a8afer, and Aleksy Schubert. Immutable objects for a java-like language. In ESOP, pages 347 362, \n2007. [9] S. Ishtiaq and P. W. O Hearn. BI as an Assertion Language for Mutable Data Structures. In ACM \nPOPL, London, January 2001. [10] Nils Klarlund and Anders Mller. Mona version 1.4 -user manual. [11] \nH. H. Nguyen, C. David, S.C. Qin, and W.N. Chin. Auto\u00admated Veri.cation of Shape And Size Properties \nvia Separa\u00adtion Logic. In Intl Conf. on Veri.cation, Model Checking and Abstract Interpretation, Nice, \nFrance, January 2007. [12] Tobias Nipkow, Lawrence C. Paulson, and Markus Wenzel. Isabelle/HOL A Proof \nAssistant for Higher-Order Logic, volume 2283 of LNCS. Springer, 2002. [13] M. J. Parkinson. Local Reasoning \nfor Java. PhD thesis, Com\u00adputer Laboratory, University of Cambridge, 2005. UCAM\u00adCL-TR-654. [14] W. Pugh. \nThe Omega Test: A fast practical integer program\u00adming algorithm for dependence analysis. Communications \nof the ACM, 8:102 114, 1992. [15] Jaime Quinonez, Matthew S. Tschantz, and Michael D. Ernst. Inference \nof reference immutability. In ECOOP, pages 616 641, 2008. [16] J. Reynolds. Separation Logic: A Logic \nfor Shared Mutable Data Structures. In IEEE Logic in Computer Science, Copen\u00adhagen, Denmark, July 2002. \n[17] J. Reynolds. Separation Logic: A Logic for Shared Mutable Data Structures. In IEEE Logic in Computer \nScience, Copen\u00adhagen, Denmark, July 2002. [18] Alexandru Salcianu and Martin C. Rinard. Purity and side \neffect analysis for java programs. In VMCAI, pages 199 215, 2005. [19] Yoav Zibin, Alex Potanin, Mahmood \nAli, Shay Artzi, Adam Kiezun, and Michael D. Ernst. Object and reference im\u00admutability using java generics. \nIn Ivica Crnkovic and Antonia Bertolino, editors, ESEC/SIGSOFT FSE, pages 75 84. ACM, 2007. [20] Yoav \nZibin, Alex Potanin, Paley Li, Mahmood Ali, and Michael D. Ernst. Ownership and immutability in generic \njava. In William R. Cook, Siobh\u00b4 an Clarke, and Martin C. Ri\u00adnard, editors, OOPSLA, pages 598 617. ACM, \n2010.  \n\t\t\t", "proc_id": "2048066", "abstract": "<p>In the current work, we investigate the benefits of immutability guarantees for allowing more flexible handling of aliasing, as well as more precise and concise specifications. Our approach supports finer levels of control that can mark data structures as being immutable through the use of immutability annotations. By using such annotations to encode immutability guarantees, we expect to obtain better specifications that can more accurately describe the intentions, as well as prohibitions, of the method. Ultimately, our goal is improving the precision of the verification process, as well as making the specifications more readable, more precise and as an enforceable program documentation. We have designed and implemented a new entailment procedure to formally and automatically reason about immutability enhanced specifications. We have also formalised the soundness for our new procedure through an operational semantics with mutability assertions on the heap. Lastly, we have carried out a set of experiments to both validate and affirm the utility of our current proposal on immutability enhanced specification mechanism.</p>", "authors": [{"name": "Cristina David", "author_profile_id": "81332495281", "affiliation": "National University of Singapore, Singapore, Singapore", "person_id": "P2839196", "email_address": "cristina@comp.nus.edu.sg", "orcid_id": ""}, {"name": "Wei-Ngan Chin", "author_profile_id": "81100655104", "affiliation": "National University of Singapore, Singapore, Singapore", "person_id": "P2839197", "email_address": "chinwn@comp.nus.edu.sg", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048096", "year": "2011", "article_id": "2048096", "conference": "OOPSLA", "title": "Immutable specifications for more concise and precise verification", "url": "http://dl.acm.org/citation.cfm?id=2048096"}