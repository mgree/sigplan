{"article_publication_date": "10-22-2011", "fulltext": "\n Accentuating the Positive: Atomicity Inference and Enforcement Using Correct Executions DasarathWeeratunge \nXiangyuZhang SureshJaganathan DepartmentofComputerScience,PurdueUniversity {dweeratu,xyzhang,suresh}@cs.purdue.edu \nAbstract Concurrencybugs are oftendue to inadequate synchroniza\u00adtionthatfail toprevent speci.c(undesirable) \nthreadinter\u00adleavings. Such errors, often referred to as Heisenbugs, are dif.cult to detect, prevent, \nand repair. In this paper, we present a new technique to increase program robustness againstHeisenbugs.Wepro.le \ncorrect executionsfrompro\u00advided test suites to infer .ne-grained atomicity properties. Additional deadlock-free \nlocking is injected into the pro\u00adgram toguarantee thesepropertiesholdonproduction runs. Notably, our \ntechnique does not rely on witnessing or ana\u00adlyzingerroneous executions. The end result is a scheme that \nonly permits executions which are guaranteed to preserve the atomicity properties derived from the pro.le. \nEvaluation results on large, real\u00adworld, open-source programs show that our technique can effectively \nsuppress subtle concurrency bugs, with small runtime overheads(typicallyless than15%). Categories and \nSubject Descriptors D.2.5[Software En\u00adgineering]: Testing and Debugging Debugging aids, Di\u00adagnostics, \nMonitors, Tracing; D.3.4 [Programming Lan\u00adguages]:Processors Debuggers General Terms Algorithms, Experimentation, \nMeasure\u00adment,Reliability,Performance Keywords Concurrency bugs, pro.le, atomicity, locking, debugging \n 1. Introduction Debugging concurrent programs is challenging because of non-determinisminducedbyschedulersandunintendedracy \nbehavior.Consequently,bugs thatdo manifest are often not Permission to make digital or hard copies of \nall or part of this work for personal or classroomuseisgranted withoutfeeprovided that copiesarenot madeordistributed \nforpro.tor commercial advantage andthat copiesbearthis notice andthefull citation onthe .rstpage.Tocopy \notherwise,torepublish,topostonservers ortoredistribute tolists, requiresprior speci.cpermission and/or \nafee. OOPSLA 11, October22 27,2011,Portland,Oregon,USA. Copyright c &#38;#169;2011ACM978-1-4503-0940-0/11/10. \n. .$10.00 easily reproduced eventhough aprogrammayyield many different results on the same input, only \na small fraction of these may be erroneous; these failures are called Heisen\u00adbugs. There has been much \nrecent work devoted to dis\u00adcovering these bugs. For example,logging and replay tech\u00adniques[13,22] monitorprogram \nexecutions and allow re\u00adplay when failures do occur, albeit at the expense of some\u00adtimes substantial \nspace and time overheads during normal execution.Alternatively,one could enrich testing strategies to \ndiscover speci.c interleavings that lead to such failures; thesetechniquesperformadirectedandboundedsearchover \nprogram executions [23, 25], but assume that the failures havebeen observed and the failureinducinginputs \narepro\u00advided.Unfortunately,discovering suchinputsduringtesting forlarge codebasesis oftenproblematic. \nEven if a speci.c interleaving can be automatically dis\u00adcoveredto consistently reproduce afailure, the \nonusfor un\u00adderstandingthe reasonfor thefailure, andmoreimportantly preventingit, remains squarelyon theprogrammer.Heisen\u00adbugs \nare triggered by race conditions, atomicity violations, and unintendeddependence ordering violations.Ingeneral, \nthese conditionsdo notdirectlyandimmediatelyleadtofail\u00adures,butgradually contaminateprogram state; thus, \nthe ac\u00adtual point where a failure is triggered may be far removed fromtheprimarycause.Evenifthe root \ncause canbeidenti\u00ad.ed,preventingthebugfromoccurringmayrequire substan\u00adtial non-localreasoning.For example,preventingan \natomic\u00adity violationby addinglocks mayhave the unintended con\u00adsequenceofintroducing adeadlock,or unnecessarilylimit\u00adingconcurrency. \nWebelievethatexpectingprogrammersto repairHeisen\u00adbugsby tedious analysis and meticulous reasoning offailed \nexecutionsis untenablefor complex real-world applications. An alternative approach exploredin thispaper \ntakes advan\u00adtageof thefactthatHeisenbugsoccurrarely thus,theex\u00adpected behavior of an execution is not \nto manifest the er\u00adror.This observationleads us tofocus on correct executions (the common case) to infer \napparent atomicity properties. For our purposes, these properties capture pairs of thread\u00adlocal accesses \nto a shared variable that occur without in\u00adterleaved remote accessesfrom other threads.Signi.cantly, \nwedo notrequirethatthesepairsbe relatedlexically; thus, they can crossdifferentfunctionboundaries and \nconditional branches. Our technique considers these pairwise accesses as a set ofconstraints.Apath-sensitivelockingschemeisde\u00adrivedby \nsolvingthese constraints.Acquisitions and releases of a set of new locks, generated by our analysis, \nare sub\u00adsequentlyinjectedinto theprogram.The locking schemeis safe asit only allows a subset of executionsthat \nare allowed in the original program -this subset is guaranteed to pro\u00adduce behavior consistent with the \natomicity properties ob\u00adservedin thepro.le.Because we infer atomic accesses that are substantially more \n.ne-grained than what programmers caneasilyexpressusinglexicalbracketingofatomiccodere\u00adgions,the approachenables \neffectivesuppression ofHeisen\u00adbugs with little loss of concurrency, and without requiring programmersto \nemploythelow-level and non-modular rea\u00adsoning that would otherwisebe necessary to remedy the er\u00adror. \n Thus, the distinguishing feature of our technique is that it does not require the availability of erroneous \nexecutions toprevent concurrencybugsthat arisebecause of an atom\u00adicity violation. Instead, the injected \ninstrumentation effec\u00adtively only admits executionsthat respectthe atomic regions inferred by pro.ling \ncorrect runs. Notably, our approach is not replay-based:theinstrumentedprogram allowsdifferent interleavingsfromthose \nwitnessedinthepro.le withrespect to non-atomic regions, onlyguaranteeing the absence ofin\u00adterleaved accessesinthosethat \nare.Moreover,thetechnique is safe:any execution realizable undertheinstrumentedpro\u00adgramis also realizable \nunder the original;a corollary of our safety conditionisthat ourinjectedinstrumentationdoes not introducedeadlocks. \nOur contributions are summarizedasfollows: Wepropose a novelpro.le-basedprogram analysisthat canbe used \nto suppressHeisenbugsfor complex,large\u00adscale concurrent applications.  Central to ourapproachistheinferenceof \nsalient atom\u00adicitypropertiesfrompro.les ofbenign executionsgener\u00adatedfromtest suites, without requiringthe \navailability of failure-inducinginputs.  Ourinstrumentationalgorithminjectspath-sensitivelock acquisitions \nand releases to tolerate atomic sections that are notlexical(e.g.,because the atomic region may span \ndifferentlexically-delimitedscopes).  We evaluate our technique on a set of large, real-world open-sourceprograms.Benchmark \nresults show that our techniquecan effectivelysuppresssubtlehard-to-identify and repair concurrencybugs.Performance \nevaluation on realistic workloadsindicate that the runtime overhead of ourtechniqueis small, typically \non the order of15%.  Theremainderof thepaperis structured asfollows.The next sectionpresents additional \nmotivation and somedetails ofthebenchmark corpus we usedin our study.Section3 ex\u00adamines one of thesebenchmarks \nas a case study toillustrate some ofthetechnicalchallengesourtechniquemustaddress. Section 4 gives an \noverview of our solution using this case study as a representative example. We present the scope of our \ntechnique with respect to thekinds of concurrencybugs it can suppress in Section 5. We present details \nof the pro\u00ad.lerinSection6.Thelockplacement algorithm andinstru\u00admentation mechanism is given in Section \n7. The deadlock resolution algorithm is described in Section 8. Extensions to our approach are required \nto deal with conditional syn\u00adchronization and shared heap objects; these extensions are describedinSection9.Weformalizethe \nsafetyproperties of our solutioninSection10.An evaluation study with respect to overheadand effectivenessisgiveninSection11.Related \nworkisgiveninSection12 and conclusions areprovidedin Section13.  2. Motivation Existing concurrency \nbug detection/.xing techniques [18, 25]often rely on exploiting negative information-giventhe observationofaknownorlikelyconcurrencybug,acquirean \ninputthattriggersthebug.Theimplicationisthatbugreme\u00addiation .rst requireseithermanifestationof thebug \noriden\u00adti.cationoflikely sources.Incontrast,ourtechniqueinfers potential atomic regions from observed \ncorrect executions, and enforces atomicity inthese regions,therebyguarantee\u00ading that atomicity invariants \nwitnessed in these executions are automatically preserved; by doing so, it prevents bugs that arisebecause \nan executionfailstopreservetheseinvari\u00adants without the needforhaving afailure-inducinginput. We conducted \na detailed evaluation study to support our intuition. Our study looked at 12 concurrency bugs from 6 \nwidely used concurrent applications including the apache web server and the mysql database server.(Table1) \nMysql comes with an extensive regression test suite, as well as several widely useddatabaseperformanceevaluationbench\u00admarks \nsuch as sysbench-oltp and tpcc. Apache and the otherprogramsdo nothave a their own test suites,but there \nare commonly used static/dynamic workloads that can be used as representative inputs. The test inputs \nused for pro\u00ad.ling eachbenchmark are showninTable2. These programs run correctly with the test inputs. \nWe collected atomicity pro.les from these runs and analyzed whether enforcing these properties would \nsuppress future bugs,i.e.bugs reportedafter theprogram and the test suites were released.Our atomicity \ncriteria wasbased on observed pairwise atomic sections: a code region (not necessarily lexical)bracketedbytwo \naccessestothe same variableinthe same thread, without anyintervening access to that variable byanotherthread. \nWe observedthat the test suites collectivelyprovide cov\u00aderage over the faulty statements, even though \nthey do not trigger the failures. Indeed, the key atomic pairs are eas\u00adily observed from the passing \ntest cases; these regions in\u00ad    program bug,date module affected, description atomicpair aget, 0.4 \n- A data race between threads downloading a webpage and SIGINT signal handler. When the data race occurs, \nthe downloaded .le is corrupted. The shared variable bwritten is consistently protected bylock bwritten \nmutex except inside the signal handler. bwritten needs read lock in save log()in Resume.c:41. pbzip2, \n2.094 - An order violation between the main thread and threads doing.le compression (consumer threads) \non mutex fifo->mut. The main thread maydelete the mutex before all consumer threads are done usingit. \nfifo->mut needs a read lock in func. consumer()in pbzip2.cpp:873-994 nszip, 1.8 342577, 23/6/2006 A data \nrace in Mozilla nsZipArchive::SeekToItem on nsZipItem::.ags. The data race corrupts the decompressed \n.le. nsZipItem::.ags needs write lock in func. nsZipArchive::SeekToItem() in nsZipArchive.cpp:1381-1408 \napache, 2.2.6 44402, 2/12/2008 In worker multi-processing module (mpm), the recycled pools list gets \ncorrupted under high concurrency causing server to crash. First observed while running specweb99 static \ncontent workload with 1000 simultaneous connections and 500 threads per worker. The server would run \nfor anything between 10 minutes to 4 hours before it would crash. recycled pool::next in fdqueue.c:104-107, \nfunc. ap queue info set idle() needs read lock. apache, 2.0\u00adhead 25520, 15/12/2003 In mod log con.g, \nloglines are corrupted at high volumes in access log. buffered log::outcnt needs write lock in mod log \ncon.g.c:1432-1469, in func. ap buffered log writer() spider\u00admonkey, 1.5 133773, 27/3/2002 An order violation \nbugin Mozilla JavaScript engine in func. js DestroyContext() on JSRuntime::state leads to crash. JSRuntime::state \nneeds read lock in func. main(). mysql, 4.0.12 791, 4/7/2003 In log.cc (binlog), when SQLFLUSHLOGSis \nexecuted concurrently with another SQL statement, e.g. SQLINSERT, the latter may not be recorded in binlog. \nMYSQL LOG::log type needs write lock in log.cc:867-869, func. MYSQL LOG::new .le() mysql, 4.0.12 12848, \n29/8/2005 In sql cache.cc (query cache), access to query cache while the cache is been resized caused \nserver to crash. The bug was reproduced by running query cache.test (size: 450 lines)in mysql-test suite \nfor 1-2min. Query cache::bins needs write lock in sql cache.cc:733-755, in func. Query cache::resize() \nmysql, 5.0.16 14747, 8/9/2005 In the index tree adaptive search module in Innobase database engine, two \nthreads trying to drop a hash index could race with one another, leading to a server crash. After the \nbug was .rst reported, the developers added diagnostics to the code and there was no activity for several \nmonths until it was reported again. Even then there was no way to reliably reproduce it except for the \nobservation that crash happened often on bigqueries. buf block struct::index needs write lock in btr0sea.c:893-1015 \nin func. btr search drop page hash index() mysql, 6.0.6 35714, 31/3/2008 A data race between THD::awake() \nand thd scheduler::thread detach() on variable THD::mysys var led to a server crash. THD::mysys var needs \nread lock sql class.cc:859-893 in THD::awake(). mysql, 5.0.19 16333, 10/1/2006 In the safe mutex API, \nassertion failure occurred in safe mutex assert not owner() due to inconsistent values in .elds count \nand thread in safe mutex objects. The crash was reproduced by running oltp test in sysbench benchmark. \nThe server would crash approx. 18min into the run when using8 client connections and a test database \nhaving 1 million records. A multi-variable atomicity violation. safe mutex t::count and safe mutex t::thread \nneed write lock in safe mutex lock()in thr mutex.c:163-170 mysql, 5.0.24 20850, 4/7/2006 A data race \noccurred between server termination code in end slave, and slave threads on variable Master info. The \nfunc. end slave could destroy the Master info object before all slaves were done using it. To reproduce \nthe bug the developers ran MySQL replication tests (size: 80 lines)in a loop with each iteration restarting \nthe server. It many take as many as 36 iterations before the server would crash and the crash happens \nduring server shutdown. Master info::run lock needs read lock in func. handle slave io()in slave.cc:3414-3745 \n Table1. Someknowndata race/atomicityviolation/order violationbugs andhowthey canbepreventedby enforcingpairwise \natomicity observedinpassing runs.Bugs44402,14747,16333have notbeendiscussedinliteraturebefore.Many ofthesebugs \nsuch as mysql 12848, 14747, 16333, 20850, and apache 44402 were dif.cult to deterministically reproduce \nand diagnose according to thebug reports,due to the special inputs required, thelarge number of threadsinvolved, \nand the long execution time necessary to triggerthefailure.Please refertoTable.2forinputs usedforpro.ling. \nduce a failure only with certain inputs that do not happen tobe usedin the regressions andbenchmarks, \nor under cer\u00adtain unforeseen schedules. By enforcing atomicity in these regions(i.e.,byinjecting suitablelocks), \nwe were able to successfully prevent these bugs: inputs identi.ed from the bug reports that were previously \nable to trigger the bug no longerdid, and theinsertedlocksprohibitedpreviously al\u00adlowedfaultyschedules.Thus,the \ntransformedprogram sup\u00adpressesthesebugsfromoccurringinthe .rstplace.Manyof thesebugs suchas mysql 12848,16333,20850,andapache \n44402 were dif.cult to deterministically reproduce and di\u00adagnose when they were reported, due to the \nspecial inputs required, thelarge number of threadsinvolved and thelong executiontime necessaryto reachthefailure.Indeed, \nseveral ofthebugs we considerhave notbeen studiedinthe research literaturetothebest of ourknowledge.Notethat \nwefocus on reportedbugs onlybecauseit simpli.es validation.  foo() foo() {{ if (<COND1>){ if (<COND1>){ \nP = NULL; acquire(L) } P = NULL; release(L) if (P){ } ... = *P; } acquire(L) } if (P){ ... = *P; } release(L) \n } Figure1. Aninputdependentatomicityviolation.The orig\u00adinal code is shown on the left; the version \ninstrumented by ourtechniqueis on the right. To make our discussion concrete, consider the example in \n.gure1,whichis anabstractionof several real atomicity violations we have observed. Here, P is a shared \npointer whichis notprotectedconsistently with alock.Thefunction foo() is calledby multiplethreads,leading \ntointerleaving of accesses to P. The assignment that sets P to NULL is guarded by the condition COND1. \nFor all test inputs found in the regression test suite, COND1 is always false. Hence, it is not possible \nto induce the bug even after exhaustively exploringthepossible schedulesfor the test runs. Consequently, \nwe do not observe any writes to P from other threads; our pro.le, on the other hand, indicates that the \ntwo reads to P arepairwiseatomic they occurwith no interveningaccesstoP byanotherthread.Sincethe readsare \nnot protected, our technique transforms the program to put these accesses within an atomic section. In \naddition, even though wehave not seen the execution of the assignment to P in ourpro.le, enforcingthe \natomicityof the two reads re\u00adquires us to also instrument the write access to ensure that it is not allowed \nto be interleaved with the reads. Our lock injection mechanism guarantees that even when COND1 is true(under \nsome newinputprovidedlaterduring aproduc\u00adtion run),twothreads will neverbeinterleavedwithin foo() such \nthat one sets P to NULL between the two read accesses to P.  3. TechnicalChallenges Realizing ourideasfor \nreal worldprogramsis challenging. We use a concurrencybugfoundinMySQL-4.0.12(bugid 791) to illustrate \nthese challenges. This non-deterministic bug results inSQLqueries notbeingproperlylogged.Log\u00adging failure \nis problematic because mysql relies on its log to revoke and replayqueriesin thepresence of transactional \ncommit failures. The failure is caused by an atomicity vio\u00adlation. The relevant code snippets are shown \nin Fig. 2. Ig\u00ad nore allthehighlightedstatementsforthe moment;these are statementsinsertedby our technique, \nand are notpresentin the original program. At line 867 in function new file() (the right-hand side code \nfragment), the current log .le reaches its size limit and is closed. A new log .le is sup\u00adposed to be \ncreated at line 870 to continue logging. Al\u00adthough there is a program lock LOCK log that protects the \nmainbody of new file(), thelockis not consistentlyheld in other accesses of log type. For instance, in \nfunction mysql insert() (shown on the left-handside), the call to mysql bin log.is open() at line 311 \nentails accessing log type (see the de.nition ofis open() on the top-left of the .gure),yettheaccessisnotprotected.Inthefailure\u00adinducingschedule \nas shownbythe arrowsbetween thelines 311, 867 and 870, the value is set to LOG CLOSED by the invocation \nto close() .rst atline867, thepredicate at311 is evaluatedbeforethe valueis setagain atline870 andthus \ntakes thefalsebranch, with theinsertquery notlogged. Like most Heisenbugs, this error illustrates two \nsigni.\u00adcant complexities:(a).ndingthebugischallenging,and not likely tobeeasily exposedby typical testing \nstrategies; and (b)evenafterthebug isfound,thereis adeep causal chain ofdependenciesthat mustbefollowedin \nordertodetermine howbestto repairit.For example,givenknowledgeof the bug and its cause, we might be tempted \nto lock the call to is open() atline311.However, non-trivial reasoning must be brought to bear to ensure \nthat such a change is in fact correct: Itis unclearifdeadlocks wouldbeintroduced.  Thebody of new file() \nisprotectedby multiplelocks (not shown in the .gure). There may be many other accessesto log type justlikethatatline311, \nwith some of them already protected by some subset of the locks in new file(). It is hence dif.cult to \ndetermine which lock(s) should be held in order to provide consistent protection.  Wrapping the access \nat line 311 with lock LOCK log would still not resolve the bug because there is another accessto log \ntype inthe calltois open() atline1922. Atomicitymustbepreservedbetweenthesetwo accesses as well.  We \nmight choose to simply protect the whole body of mysql insert() with lock LOCK log. However, doing solikelylimits \nconcurrency unnecessarily since only the two accesses to thelog need tobeprotected.The execu\u00adtion of \nthe rest of the function body can be interleaved with otherthreads.  4. OverviewofOurSolution Our technique \nis divided in three phases: a pro.ling phase collects pairwise atomicity information; a lock placement \nphase derives a locking scheme that satis.es the atomicity constraints collected by the pro.ler; and \na deadlock reso\u00adlution phase resolvespossibledeadlocksinducedby the in\u00ad               \n       Access\u00a0Trace\u00a0of e /*remote\u00a0reads*/ ]  \u00a0\u00a0Atomic\u00a0Pairs  Figure2. ArealbuginMySQL-4.0.12.The \narrowsbetweenstatementsshowthefailureinducingschedulebeforeapplyingour technique.The shared variableis \nlog type.The access trace of the variableis shownbelow the code snippets.Each entry of thetraceis an \naccess with contextinformation.Thepairwise atomicitypro.leispresentedinthebottom.Eachpro.le entryis a \ntriple.The .rsttwoelementsareapairofintraproceduralprogrampointswith atomicity.Thelast elementistheatomicitytype. \nR means read atomicity,i.e., remote readshavebeen observed tobe interleaved with thispair. X means exclusive \natomicity, i.e. nointerleaving remoteaccesshasbeenobservedinthepro.le.The shaded statements areinstrumentationsaddedby \nour technique.Primitive acquire(READ(log type),805) means acquiring a readlockfor variable log type, \nstarting at805.  serted locks. We illustrate these steps using the example in Fig.2in the remainder \nofthe section. Pro.ling. Our technique .rst collects a set of traces. To simplify our discussion, we \nonly present a trace relevant to variable log type belowthe code snippets.Eachtrace entry represents \nan access annotatedwithits context.Forinstance, the .rst entry [... : 805 : 150] means that the access \nis the read atline150infunction is open(), which wasinvoked atline805, and so on. We then consider each \npair of consecutive thread-local accesses to see if they have ever been interleaved with ac\u00adcessesfrom \notherthreads.For agivenpair oflocal accesses, we identify an intraprocedural path such that locking that \npath ensures atomicity of these accesses. Thus, our instru\u00admentation phase does not need to inject locking \nover arbi\u00adtraryinter-proceduralpaths. Inthe example,the commonfunctionbodyofthe .rsttwo localentriesis \nnew file, andthetwo accessesto log type are interleaved with remote reads. These accesses are thus aggregated \nto the atomicpair (805,830,READ),permitting read atomicity (i.e. remote reads are allowed but remote \nwrites are not) between lines 805 and 830. Similarly, since nointerleaved remote accesseshavebeen observedbetween \nentries [... : 867 : 1496] and [... : 870 : 143], which cor\u00adrespond to the accesses in close() and open() \nrespec\u00adtively, the atomic pair (867,870,EXCLUSIVE)is derived as shown, representing exclusive atomicity(i.e. \nno remote reads and writes are allowed).   Lock placement. Given a pro.led trace, we infer synchro\u00adnizations \nthat satisfy all pairwise constraints. The high\u00adlighted statements are the synchronizations introduced. \nIg\u00adnorethelock acquisitionat C \u00aefor the moment.A read-lock is acquired at Ato ensure read atomicity from805 \nto830. \u00ae Thelockis releasedat B \u00aesincetakingthefalsebranchat805 indicates line 830 is no longer reachable. \nThe read atomic pairs(830,834,READ)and (834,867,READ)do notleadto new acquisitions as they canbe considered \nas a continuation of thepairfrom805 to830.Thelockis upgraded to exclu\u00adsiveat Don (867,870,EXCLUSIVE).Itis \nreleased at \u00aebased E\u00ae, right after the access in 870. This avoids unnecessarily limitingconcurrency. \nSimilarly, the atomic pair (311,1922,READ)entails the acquisition at Fand the release at Gand HThe latter \n\u00ae\u00ae\u00ae. release is because 1922 is not reachable. Observe that our acquisitionprimitivestaketheline number \nas aparameterto achieveintra-proceduralpath-sensitivelocking, explainedin moredetailinSection7. Deadlock \nresolution. Observe that our technique augments but does not remove existing synchronization actions. \nCor\u00adrectness arguments dictate that instrumentation should not alterthe originalprogram semantics.However, \naddinglocks may interfere with existing ones or may interfere (e.g., cause deadlock) with locks added \nfor other variables. Our technique resolves deadlocks by injecting additional ac\u00adquisitions.Considerthe \nsynchronizationsadded tofunction new file() by our technique(ignoring C \u00ae for now).There is apotentialdeadlockdue \nto theinterference withprogram lock LOCK log. In particular, the program lock may be ac\u00adquired(at810)when \nthe readlockfor log type is held(at A\u00ae);andin adifferent thread, the exclusivelock maybe ac\u00adquired(at \nD \u00ae)whentheprogramlockisheld(at810).Our technique breaks the cycle by adding an extra acquire() (at C \n\u00ae)1. This operation ensures that the exclusive lock for log type is alwaysheldwhentheprogramlockis acquired. \nIt is straightforward to see that the resulting instrumented program effectivelypreventsthebug.  5. \nScope Manycommonkindsofconcurrencybugs,suchasdataraces and order violations, often involve violation \nof atomicity invariants. As long as a bug manifests such a violation, it isfeasible to applyourtechniquetopreventit. \nthread1() { thread2() { acquire(L) A: p= ...; release(L) B: p=null; acquire(L) C: *p; } release(L) \n} Figure3. Adata raceinvolvingan atomicity violation. We have observed that manybugs reported asdata \nraces entail violation ofpairwise atomicity.Fig.3presents a sim\u00ad pli.ed, yet typical, example. Here, \nexecuting statements A, B and C inthatorderresultsina nullpointerdereference.It might be assumed that \nthe bug arises because of a race be\u00adtween B and C.However,if correct executionsexhibitpair\u00adwise atomicity \nbetween the access to p at C and its pre\u00adceding access at A, enforcing atomicity between these two statements \nwould effectively suppress the bug. Mysql bugs 14747,35714, and20850inTable1belongto this category. Order \nviolations are a type of concurrencybug that often involve atomicity violations as well. An order violation \noc\u00adcurs whenaccessesto a shared variableindifferentthreads 1Ourruntimeallows alock tobeacquired multipletimes. \n fail to execute these accesses in the speci.c order in which they were intended to be executed. For \nexample, a socket may be intended to be .rst created and initialized in one thread, and then used in \nanother. We observe that in many cases, ensuring a speci.c order canbepreservedby enforc\u00ading atomicity. \nIn the case of sockets, this would mean that the creationandinitialization ofthe socketshouldbe atomic. \nThespidermonkey bugandthepbzip-2 buginTable1be\u00adlongto this category. Sofar, wehave assumedpairwise atomicityinvariantsare \nde.ned with respect to the same variables. But in practice, there are casesin which atomicityis requiredtohold \nacross multiple variables. For example, a .ag that must be set if the corresponding pointer becomes null \nis an instance in whichatomic accessestotwo variablesis required.Breaking such atomicity can lead to \nfailures. We leverage existing techniques(e.g.,[19])toidentify correlated shared variables (essentiallythosethat \nare accessed togetherin most cases), representingthem as a single abstract shared variable. Other concurrency \nbugs that do not necessarily involve atomicity violations, such as those that lead to deadlocks, are \nnothandledby our technique. 6. Pro.lingAtomicPairs TRACE-LANGUAGE L S . L ::= (v,T); S | o T . VarTrace \n::= (t, rw,c,is); T | o t . Thread ::= {t1 ,t2 ,...} c . Context ::= l rw . AccessType ::= {Rd,Wr} v \n. Var ::= {x,y,z, ...} is . LockInstanceSet ::= P(Lock \u00d7 Int) Lock ::= {k1 ,k2 ,...} l . Label ::= {entry,exit,l1 \n,l2 ,...} Figure4. TraceSyntax The .rst component of our technique is a pro.ler that identi.es atomic \naccess pairs. We say two local accesses to a variable observed by a pro.le are exclusive-atomic if no \nremote (i.e., non-thread-local) accesses occur between them.Any execution which respects thebehavior \nwitnessed bythepro.le ensures that an exclusivelock on that variable is acquired prior to the .rst access, \nand released after the second. Two local accesses are read-atomic if only remote reads occurbetween the \ntwo accesses, without thepresence of an intervening remote write. To mimic the conditions of the pro.led \nrun on subsequent executions, we require that a read lock be held for this pair. If a remote write was \never observed between the two accesses in the pro.le, then no atomicity conditionholds(denoted as no-atomic). \nWe distinguish read-atomic from exclusive-atomic to allow more concurrency.Itis animportantdesign choicegiventhe \nnon-trivial number of atomicinvariants we needto enforce. Traditionally, atomicity is de.ned lexically \nby the pro\u00adgrammer thus, we typically reason about atomicity in terms of methods or code blocks. Transplanting \nsuch no\u00adtionsinto apro.lingcontextis not straightforward,however. Lexically-scopedatomic regions aredif.cult \ntoidentify and pro.lebecause(a) multicore architecturespermit real con\u00adcurrency, allowing any code region \nto execute concurrently with code regions in other threads, confounding easy iden\u00adti.cation oflexical \nregioninterleavings; and(b)itishard to aggregate region-basedpro.les; the same region may occur in the \npro.le multiple times, exhibiting atomicity in some instances,but not others.We cannot simply mark the \nwhole regionas notbeing atomicbecausesub-regions(beforeand after agiven remote access) may stillbe atomic.Thus,iden\u00adtifying \natomicity using lexically-scoped code regions could be sub-optimalifatomicityis only neededin a smallportion \nof such regions. Pro.lingatomicpairs,instead of code regions, addresses these issues. The variable sensitive \nlocking that can be derived by discovering these pairs allows arbitrary (non\u00adlexical)interleavings ofatomic \nregions.Inthis sense, atomic pairsprovideatomicity at .negranularity,andfacilitateag\u00adgregationoflargeratomic \nregionsfrom smaller atomicpairs. To realize ourdesign, we need to overcome a number of technical challenges.Mostimportantly, \natomicpairs are not lexically well formed; for example, two accesses could oc\u00adcur in different calling \ncontexts. For instance, function A() might call B(),with the .rstaccessoccurringin B(); after B() returns, \nA() might subsequently call C(), which per\u00adforms the second access. Moreover, existing synchroniza\u00adtion \npresent in the program may contribute to the atomic\u00adityproperties observedin thepro.le.Hence, we should \nex\u00adclude identifying atomic accesses that are already guaran\u00adteedbased onprogram structure. We instrument \nprograms to generate traces, which are then analyzed to identify atomic pairs. The trace syntax is presentedinFig.4.A \ntrace S is a sequence of variable sub\u00adtraces, whichde.nethe accesshistory of a shared variable. The reason \nfor such a design is that there is a sequential order for accesses to the same variable instance while \nsuch an order may not be available across variables. An entry in the variable trace represents a shared \nvariable access, consisting ofthe threadid t, the calling context c, the access type rw, and the lock \ninstance set is. The lock instance set describes the set of lock instances held at the access point. \nA lock may have multiple instances at runtime, with an instance generated by an acquisition and destroyed \nby the corresponding release. Hence, we use a pair (k,i) to representthe ithinstance oflock k. The pro.ling \nrules are presented in Fig. 5. The pro.ler takesatraceasinputandgeneratesa setof accesspairsfor each \nshared variable. Each pair is associated with a type that could be no-atomic (NONE), read-atomic (READ), \nexclusive-atomic(EXCLUSIVE), ortop(.);the ordering relationship among these types form a simple lattice \nas de\u00ad.ned in Fig. 5. In order to determine if the atomicity of a pairis alreadyguaranteedbytheprogram, \nweintroducetwo relations: thepairlock set L describingthelocks thatguard bothaccesses; and,thelock set \nLS for a variabledescribing the set of commonlocksheldby all accesses ofthe variable. The rules are \ndivided into three sets, the .rst describing the evaluationofa variabletrace,the secondcomputingvari\u00adablelock \nsets, andthethird computingthe atomicpairs.The triple de.ning a trace evaluation con.guration, (T,L,Z) \ncontains a trace T, an access pair lockset L, and an access pair atomicity set Z. Rule (Exclusive) considers \nthe case whentwo consecutivelocal accesses are notinterleavedwith any remote access.To ensure that subsequent \nexecutions re\u00adspectthis observedatomicity, we must ensurethattheinstru\u00admented version of theprogramis(a) \nadequately augmented withlocksto enforce atomicity, and(b)thelockingprotocol is consistentwith all other \nobserved accesses of thispair.To address(a), we appeal to thede.nition of frontier shownin the .gure.Supposethe \n.rst access(withintheprocedurela\u00adbeled l4 )occurs in context: c1 =[l1 : l2 : l3 : l4 ]and the second(within \nthe procedure labeled l6 ) occurs in context c2 =[l1 : l2 : l5 : l6 ].Thefrontierof thesetwo contextsis \nde.ned to be frontier(c1 ,c2 )= (l3 ,l5 ). Thus, the frontier identi.es l3 and l5 as the call-sites found \nwithin l2 that en\u00adcapsulate the access pair. We use this information to insert an exclusivelock aroundthe \nregionthat encloses l3 and l5 in procedurel2 toprovide atomicityguarantees withouthaving lockacquisitions \nand releases spanprocedureboundaries.If the locks necessary to provide atomicity of the pair were not \nhoisted upto l2 , but instead acquired within l4 and re\u00adleasedwithinl6 , runtimedisambiguationwouldbe \nnecessary to consider thedifferentpossible callpaths to l4 (andl6 ), to ensurethat thelockis only acquiredinthepro.led \ncontexts. Inthe rule,the sets representsthelocksthat areheld atboth l1 and l2 .Byintersecting thislock \nset with L(l1 ,l2 ), the set of locks that protect all occurrences of access pair (l1 ,l2 ), wede.netheminimumset \noflocksthatareused toprotect thispair.Considertwo occurrencesofpair (l1 ,l2 )in which there is no intervening \nremote operation between the .rst pair,butthereis onebetweenthesecond.Theatomicity re\u00adquirement on this \npair is naturally dictated by the weakest observed action;in this case, the observed remote operation \nbetween the second pair of accesses precludes treating the accesspairbracketedby l1 and l2 as atomic. \nRule (Read)de.nes the conditions under which an in\u00adtervening remote read operation occurs between an \naccess pair, and rule None de.nes the conditions under which an intervening remotewrite operationtakesplace.Inthelatter \ncase, no additionalsynchronizationis requiredto enforceex\u00adecutions faithful to the pro.le; in the case \nof remote reads, read locks can be used to permit executions to admit inter\u00ad DEFINITIONS a . AtomicType \n::= {NONE , READ, EXCLUSIVE , .}, . > EXCLUSIVE > READ > NONE . Z . Pairs ::= Label\u00d7 Label -. AtomicType \nL . PairLockSet ::= Label\u00d7 Label -. P(Lock) A . VarPairs ::= Var -. P(Label \u00d7 Label \u00d7 AtomicType) LS \n.P(Lock) . . (l1 ,l2 ) if c1 = c2 ; . . L = {k1 ,...,kn|new lock()ki . Prog} frontier(c1 \u00b7 l1 ,c2 ) \nif c1 . c2 ; frontier(c1 \u00b7 l1 ,c2 \u00b7 l2 )= L0 (l1 ,l2 )= L . frontier(c1 ,c2 \u00b7 l2 ) if c2 . c1 ; . . \nZ0 (l1 ,l2 )= . frontier(c1 ,c2 ) otherwise. DESCRIPTION Input: Atrace S. Output: Amapping Athat maps \na variable to a set of atomicpairs. PROCESSING PER-VARIABLE TRACE (1) (l1 ,l2 )= frontier(c1 ,c2 ) \ns = {k|(k,i). is1 nis2 } L ' = L[(l1 ,l2 ) . L(l1 ,l2 )ns] Z ' = Z[(l1 ,l2 ) . min(Z(l1 ,l2 ), EXCLUSIVE)] \n(Exclusive) inst (T;(t,rw1 ,c1 ,is1 ); (t,rw2 ,c2 ,is2 ), L, Z) =.(T;(t,rw1 ,c1 ,is1 ),L ' ,Z ' ) ' \n' T2 nil \u00ac.(t,rwx,cx,isx).T2 \u00ac.(t, Wr,c ,is ' ). t= = T2 t ' Condition(1)from rule (Exclusive) Z = Z[(l1 \n,l2 ) . min(Z(l1 ,l2 ), READ)] (Read ) inst (T1 ;(t,rw1 ,c1 ,is1 ); T2 ; (t,rw2 ,c2 ,is2 ), L, Z) =.(T1 \n;(t,rw1 ,c1 ,is1 ); T2 ,L ' ,Z ' ) T2 nil \u00ac.(t,rwx,cx,isx).T2 (t ' , Wr,c ' ,is ' ).T2 = ' Condition(1)from \nrule (Exclusive) Z = Z[(l1 ,l2 ) . NONE] (None) inst (T1 ;(t,rw1 ,c1 ,is1 ); T2 ; (t,rw2 ,c2 ,is2 ), \nL, Z) =.(T1 ;(t,rw1 ,c1 ,is1 ); T2 ,L ' ,Z ' ) LOCKSET (LockSet )((t,rw,c,is);T, LS)=ls.(T, LS n{k|(k,i). \nis}) ATOMIC PAIRS ls ls inst inst (T,L) =. ... =.(o,LS)(T,L0 ,Z0 ). ... =.(o,L,Z) X = {(l1 ,l2 ,Z(l1 \n,l2 ))|L(l1 ,l2 )nLS = f .Z(l1 ,l2 ) .} == atom ((v,T);S, A)=.(S,A[v . X]) (Pairs) Figure5. Pro.lingrules. \nvening remote read operations.Rule (LockSet)speci.es the computation of the variablelock set. Rule (Pairs)generates \nthe atomicpairsfor a variable.Speci.cally, apro.ledatomic pairis admittedonlyif thepair and all other \naccesses of the same variable are not consistently protected by a program lock; these pairs represent \nregions that are potential targets for subsequentlockinstrumentation.  7. LockPlacement We nowdiscusshow \nappropriate synchronization canbein\u00adsertedintoaprogramtorespectpro.ledpairwise atomicity constraints. \nRecall that atomic pairs need not be lexically\u00adscoped. To avoid limiting concurrency, we need to release \nlocks thatprotect atomicpairs at the earliestpossiblepoint, taking into consideration their non-lexical \norganization. Moreover,atomicpairs may overlap:two atomicpairsmay span the same code region. Any synchronization \ninjection protocol must be cog\u00adnizant oftheseissues.Inthis section, we considerhowtoin\u00adjectappropriatesynchronizationfor \na single shared variable; in Section 8, we consider extensions that resolve con.icts betweeninsertedlocksfor \nmultiple variables orbetween an insertedlockand aprogramlock. Thepro.lingsemanticsidenti.es an atomicpair \nas apair oflocal accessestothe same variable with nointerveningre\u00admote access.To ensure safety, we over-approximatepro.led \ninformation;speci.cally, we consider allpathsbetween two accessesthat comprise an atomicpair as exhibitingthe \nsame atomicity characteristics with respecttothe variablethatde\u00ad.nes the pair. Our treatment is an over-approximation \nbe\u00adcause thepro.leis necessarilyincomplete,i.e., not allpaths between the two accesses areguaranteed \ntobe exercisedby thepro.linginput suite.Ontheotherhand,the approxima\u00adtion is safe and adding additional \nsynchronization only af\u00adfects thedegree ofconcurrency realized. We de.ne an intraprocedural .ow analysis \nto decide where additional synchronization mustbeinserted.For each control .ow node, represented by a \nlabel, we compute the set oflocksthat oughttobeheld upon entrytothat node and thendecidethe requiredsynchronizationinstrumentationac\u00adcordingly.If \nnopro.leis availablefor apair of accesses, we assume thereis no atomicity that mustbe enforcedbetween \nthatpair. The rules de.ning our analysis, presented in Fig. 6, are divided into two sets. The .rst set \ncomputes the locks that mustbeheld at aprogrampoint.The second setderives the instrumentation that must \nbe injected according to derived lock information. The computation is based on the atomic pairsfor a \nvariable.The relevantde.nitions arepresentedin the beginning. Function lc is a mapping from a label to \na set that mayinclude NONE andtriples (li ,lj ,a), referredto as the lock constraint set.The triple signi.es \nthat an a lock shouldbeheld,during the executionfrom li to lj , where a is either a readlock or an exclusivelock.Having \nNONE in the constraint set means thatitispossible nolockisheld at thispoint(along somepath).The remainingde.nitionsare \nfor auxiliaryfunctions usedin the rules. The rules aregivenbyjudgmentsof theform, P =.C where P is apredicateand \nC is either a lock constraint op\u00aderation or an instrumentation effect performed when P is true. Rule \n(Init) speci.es that the constraint set of a pro\u00adgrampoint l be a singleton holding the NONE lock, mean\u00ading \nnolockis needed, aslong as l is not onanypath of any atomic pair. Note that the NONE constraint may be \nfurther propagated to other nodes through .ow edges. Rule (Gen) speci.es that if node l isthehead(the \n.rstaccess) ofan atomic pair with read or exclusive lock type, the lock con\u00adstraint set for l must include \nthe atomicity type of all pairs that have l as the head, and must not include NONE. Intu\u00aditively,the \nrule requiresthatweholdsomelockstartingfrom l de.ned by the properties of the atomic pair. Rule (Join) \ndescribes the propagation of constraints along .ow edges. Speci.cally,lc(l)is computedfromthelockconstraint \nsets ofitspredecessors.The notreachable(lp ,l)setis computed asthe set of constraints of apredecessor \nlp suchthatthe cor\u00adrespondingatomicpairs cannot witness l.Recallthat atriple (li ,lj ,a).lc(lp )meansthata \nalockshouldbeheldasdic\u00adtatedby an atomicpairfrom li to lj .Intuitively,if l is noton anypathfromli tolj \n,the constraintshouldbeinvalidandex\u00adcludedfromtheconstraint set of l.The con.ict(lp ,l)setis computed \nas the set of constraints of lp that con.ict withthe program scontrol-.owandhenceshouldbe excludedfrom \nl lock constraint set.Givena constraint (li ,lj ,a), li and lj mustbetwo consecutive accesses along an \nexecutionpath. Hence,if l entailspaths along which adifferent access lk to the variable mustbe encounteredbefore \nlj , the atomicity of the variable under consideration musthavebeenpro.ledby thepair li and lk instead \nof li and lj . Hence, all constraints regarding li and lj shouldbe excludedfrom lc(l). Finally, if l \nhas multiple predecessors, the entailment operation in the consequent effectivelyde.nes a union of theirlock \ncon\u00adstraint sets. {N} Instrumentation  acquire(X,2) {X ?release(R,2)  ?degrade(X,2) {N acquire(R,7) \n?release(R,2)  ?release(X,2); ?release(R,7); acquire(X,9) { Profile: 2,12 :\u00a0EXCLUSIVE 2,7 :\u00a0READ 7,12 \n:\u00a0READ 9,12 :\u00a0EXCLUSIVE release(all) Figure 7. Example for lock placement. Nodes are anno\u00adtated with \ntheir lc() set. Symbol X2 is a shorthand for 12 (2,12,EXCLUSIVE). Symbols R and N denote READ(x) and \nNONE(x), respectively. Instrumentations on edges are shown on the right. The shaded ones are optimized \naway. Thequestion markbefore a releaseprimitiveis to testif the lockisheld.The degrade()primitivedegrades \nalock(from exclusiveto read). Example. Consider the exampleinFig. 7. TheCFG is pre\u00ad sented on the left. \nVariable x is accessed at nodes 2, 7, 9 and 12. Each node is annotated with its lock constraints. According \nto rule (init), lc(1) = lc(3) = {N} (for NONE).Node2hasthe constraintset {X2 ,R2 }according 12 7 to \nrule (Gen). Note that there are two atomic pairs start\u00ading with 2 in the pro.le; the notation X2 is an \nabbrevi\u00ad 12 ation for the lock constraint (2,12,EXCLUSIVE). lc(4) is the union of lc(2) and lc(3), dictated \nby rule (Join). For node 5, noreachable = {R2}as 5 is not on any path 7 from 2 to 7, hence lc(5) = lc(4)-{R2}. \nFor node 6, 7 conflict = {X2 }because control-.owthroughnode6im\u00ad 12 plies that an access to x at node \n7 will be encountered be\u00adfore execution reaches node 12. Hence the constraint X2 must not have been observed \nalong the path following 6 and shouldbe excluded.Computation ofthe remaining con\u00adstraintsfollows similarly. \n. The second set of rulesderivesappropriateinstrumenta\u00adtionfromthelockconstraints.Theinstrumentationis \nmainly lockacquisition and release.We allow alock tobe acquired DEFINITIONS  lc . LockConstraint ::= \nLabel -.P((Label\u00d7Label\u00d7 AtomicType) {NONE}) edge(l,l ' ): l . l ' is a .ow edge atomhead(l)= .l ' , . \n>Z(l,l ' )> NONE onpath(l,li,lj ): l is on atleastonepathfrom li to lj . access(l): the variable under \nconsiderationis accessed at l. mustonpath(l,li,lj ): l mustbe on allpathsfrom li to lj . maxlock(S)= \na iff.(l,l ' ,a ' ).S, a = a ' notreachable(lp,l)= {t |(t = (li,lj ,a)). lc(lp). \u00aconpath(l,li,lj )} \nconflict(lp,l)= {t |(t = (li,lj ,a)). lc(lp) ..lk = li,lj access(lk).mustonpath(lk,l,lj )} LOCK CONSTRAINTS \n .. >Z(li,lj )> NONE, \u00aconpath(l,li,lj )=. lc(l)= {NONE} (Init) atomhead(l)=. lc(l).{(l,li,Z(l,li))|.>Z(l,li)> \nNONE}. lc(l) .{NONE} (Gen) edge(lp,l)=. lc(l). lc(lp)-notreachable(lp,l)-conflict(lp,l)(Join) INSTRUMENTATION \n atomhead(l) . a = maxlock(lc(l)) =. instrumentbefore l with acquire(a(x),l) (INAcquire) edge(lp,l) . \n.= lc(lp)-lc(l)=. for each (li,lj ,a)..: (INRelease) if(.(li,lk,a ' ).lc(l),a >a ' ) instrument lp . \nl with ?degrade(a(x),li) else instrument lp . l with ?release(a(x),li) Figure6. LockPlacement.The analysisisparameterizedon \nthe variable x beingconsidered. multiple times but released only once. Both read or write capabilities \nmay be acquiredfor alock.Rule (INAcquire) speci.eslock acquisition.Locks are only acquired at a node \nlthatisthe start ofatleast one atomicpair.Ifthere are multi\u00adple constraints associatedwith l,thelock \nwiththe maximum strengthis acquired.Intuitively,if one constraintdemands a readlock and another onedemandsa \nwritelock, a writelock is acquiredin case thepathinducingthe stronger constraint is taken. The lock state \nis enhanced with label l to indicate the acquisitionpoint of the currentlock.Rule (INRelease) speci.esthe \nconditions under which aninjectedlock maybe released.Along acontrol .owedgefrompredecessor lp to node \nl, thedifferencebetween constraint sets at lp and l de\u00ad.nes thelocks that needtobe released at l.Depending \nupon whether thereis a weakerlock retainedby lc(l), theinstru\u00admentation mechanismdegrades thelock or \nreleasesit.Note that such operations are alwaysguardedby a comparison to test the origin of thelockbeing \nreleased/degraded. Example (continued). Continuing with the example in Fig.7, observethat edge 1 . 2isinstrumentedwith \nthe ac\u00adquisitionofan exclusivelockaccordingto rule(INAcquire). Edge 4 . 6 is instrumented with a degradation \nopera\u00adtion that weakens the exclusive lock to a read lock, since .= lc(4)- lc(6) = {X2 }.Intuitively,if \nthe execution 12 comes from path 2 . 4 . 6, the exclusive lock is not needed under execution 4 . 6 even \nthough the readlockis still required. If the path 2 . 4 . 6 . 7 is taken, an exclusive lock for x is \nacquired at node 2; the lock is degraded to a read lockpriorto execution ofnode6.The(re)-acquisition \nofthe readlockpriorto executing node7 trivially succeeds since thelockis alreadyheld; theinstrumentationthatinjectsthe \nreadlockhereis requiredbecause the control-.owpath that reaches node6 couldhavebeen 1 . 3 . 4 . 6.Alongthe \npathfrom2 to12passing7, ourinstrumentation aggregates thetwo atomicpairs(2,7)and (7,12)to alargerreadatomic \nregion, preventing any intervening remote write along the path.. There are also rules that insert locks \nto protect single accesses that are notin any atomicpairs,in ordertoprovide consistentprotection.The \nrules are elidedhere. Removing redundant instrumentation. We can optimize the instrumentation rules shown \nin Fig. 6. The basic idea is that the release of a lock is redundant if we can be sure the lock cannot \nbe held at the point where the release was injected. Assume the release is caused by a constraint c = \n(li,lj ,a)in .along edge lp . l. If there is a constraint in lc(l)denoting a pair starting at the samepoint \nli and thelock typeis stronger than a. The stronger lock must have been acquired at li but not a.The \nreleaseis redundant.This optimization allows us to remove release A \u00aeinFig.7.  Supposethereis a constraintinlc(l)that \nstarts at lj , the end of c,thereleaseis not necessary asanewlock must have been acquired at lj . The \noptimization allows us to remove release B  \u00ae; thus it has the effect of aggregating two atomicpairs \nto alarger atomic region. Similarly, acquisitions canbe optimized.Theideais that an acquisition at l \nis redundantif we are sure the same type oflock mustbeheld at l.We omit thedetailshere.  8. DeadlockResolution \nBefore\u00a0Hoisting After\u00a0Hoisting }{N} 2,7 : EXCLUSIVE 6,8 : READ  {N x: y: Figure8. Exampleforlockhoisting.Thegoalis \nto reverse thelockorder of variables x and y.In(a), each nodeis anno\u00adtatedwiththelc set regardingvariable \ny.In(b),modi.ed lc sets arepresented, which entail thehighlightedinstrumenta\u00adtion. ThelockplacementalgorithmpresentedinSection7does \nnotconsiderundesirableinterferenceamonglocks.Inpartic\u00adular,deadlocks mayformbetween thelocksinsertedby \nour algorithm for different variables or between inserted locks and locks already present in the program. \nIn this section, we explain how we identify and resolve such deadlocks. We have to guarantee deadlock-free \nfor all possible inputs even though the pro.le is acquired from only a small sub\u00adset. Hence, we have \nto resolve all possible deadlocks at compile time. We .rst construct a static lock-order graph thatidenti.eslockdependencies.Strongly \nconnected com\u00adponentsinthegraphindicatepotentialdeadlocks atruntime. We thenbreak cyclesby manipulating \nwherelock insertion takes place. To minimize impact on program structure, we do notrelocateprogramlocks. \nConstructingLockOrderGraph. In thelockordergraph, a node represents alock, which couldbe aninsertedlock \nor aprogramlock.An edgeisintroducedfromlock k1 to k2 if, at someprogrampoint, k2 is acquired when k1 \nis held.The locks held at a program point can be conservatively com\u00adputed through a standard data.ow \nanalysis. The analysis is analogousto a reachingde.nitionanalysiswithlockacquisi\u00adtions consideredas GEN()andthe \ncorrespondingreleases as KILL().The computation rule applies tobothinsertedlocks andprogramlocks.The \nanalysisisinterproceduraland sum\u00admary based. The summary of a function is the set of locks that may be \nacquired in the function. Suppose a function foo() is invoked at a program point l. Let the set of locks \nthat maybeheld at l beS.Edges are addedto thelock order graph from each lock in S to each lock in the \nsummary of foo(). Cycles in the graph indicate potential runtime dead\u00adlocks. Recall that our design distinguishes \nread and exclusive locksforthe same variable.In alock ordergraph,the read and exclusivelocks ofthe same \nvariable,however,are repre\u00adsented asthe same node.Intuitively,the mutually exclusive naturebetweena readandan \nexclusivelockofthe same vari\u00adable couldleadto adeadlock.For example, assumethread t1 holds aprogramlockk1 \nand acquires a readlock on variable x,denoted as READ(x), and t2 holds an exclusivelockof x, denoted \nas EXCLUSIVE(x)and acquires k1 . A deadlockis thusformed. On the other hand, if a lock dependence edge \nis exclu\u00adsivelydue to a READ lock on a variable x acquired while a READ lockon adifferent variable y \nisheld, the edge canbe safely removed. For example, assume k . READ(x). READ(y). k is a cycle in the \ngraph. It may correspond to the case that thread t1 holdsk and acquires READ(x), t2 holdsREAD(x) and \nacquires READ(y), and t3 holds READ(y)and acquires k.The non-exclusive nature of the readlocks allows \nt1 and t2 to proceed and eventually t3 to proceed. Thus, the edge canbe safely removed. Lock Hoisting. \nStrongly connected components(SCC) in the lock order graph indicate potential deadlocks. We need to resolve \nthese SCCs statically in order to avoid runtime deadlocks.There aretwopossible solutions:(1) mergethe \nlocksin aSCC to a singlelock, or(2) reverselock order edges. Because lock merging is likely to be too \nconserva\u00adtive, weproposeto reverselock order edges.Reversinglock edgesis tantamounttohoistinglock acquisitions.For \nexam\u00adple,ifreversingan edgefrom k1 to k2 canbreak a cycle,this implies we couldhoistthe acquisition ofk2 \ntobeforethe ac\u00adquisition ofk1 .Since wedo not changethe originalprogram semantics, onlyinsertedlocks \nare subject tohoisting. The challengeto reversinglock edgesliesin thefact that inserted locks are not \nlexically scoped. To reverse the lock order from k1 to k2 , hoisting the acquisition of k2 to right before \nthe acquisition of k1 ,oftenunnecessarilylimits con\u00adcurrency,andis evenproblematicin many cases.Inpartic\u00adular, \nthe inserted lock k2 is supposed to protect atomicity along a subset ofpaths P between apair of accesses \nasdic\u00adtatedby thepro.le.Ideally,hoisting k2 tobefore k1 should be abletoprotecta superset of P,(callit \nP ' ), suchthatorig\u00ad ' inally along each path in P , k1 is acquired and then k2 is acquired,but thelock \norderis reversed afterhoisting.How\u00adever, sincetheplacement of k1 is notlexical, simplymoving the acquisition \nof k2 to rightbefore that of k1 may resultin ' protecting a superset of P that, while safe, may unneces\u00adsarilylimit \nconcurrency, or a subset of P, which minimizes theimpact on concurrency,but may violate the observations \nde.nedbythepro.led execution. Consider the example in Fig. 8 (a). It shows the lock placement of thegivenpro.lefollowing \nthe rulesinFig. 6. The lock order is EXCLUSIVE(x) . READ(y). Assume we want to reverse this order to \nresolvepotentialdeadlocks. Movingthe acquisition atnode6to node2isbothinef.cient and problematic. If \nthe execution follows the path 2, 4, 5, 7 and 8, lock READ(y)is unnecessarily held as the pro.le only \ndemands locking the path 6, 7 and 8. If the execution follows thepath3,4,6,7and8, thelockis notheld whileit \nis needed. Our solution is as follows. To ensure that we always protect a superset of P, we do not relocate \nthe acquisition of k2 . Instead, we add an extra acquisition of k2 before the acquisition of k1 . We \ncall it the hoisted acquisition to distinguish it from the original acquisition. The intuitionis thatwe \nonly need toreversethelock orderalongpathsthat k1 is .rst held and then k2 is acquired. If a lock is \nalready heldas a result of ahoisted acquisition, reacquiringthelock on the originalpathis abenign action. \nNote that the hoisted k2 lock should be released if the control .owtakesapath along which theoriginal \nk2 acqui\u00adsitionis not encountered.In orderto systematicallyhandle hoistedlock releases, weleverage ourinstrumentation \nrules in Fig. 6. In particular, we add lock k2 to the lc set for all nodes that are on a path from the \nacquisition of k1 and the original acquisition of k2 , meaning that we add a new con\u00adstraint such that \nk2 must be held along all paths from the acquisition of k1 to the original acquisition of k2 .Instumen\u00adtations \ncanbederivedfrom the lc setsfollowingtheinstru\u00admentation rules in Fig. 6. Note that we cannot simply \nadd anatomicpairbetweenthe acquisitionof k1 and the acqui\u00adsition of k2 andlet the rules toinfer thelock \nconstraint sets. The reasonisthatthelockconstraint rules consider con.icts between atomicpairs(i.e.,thecon.ict \nsetin rule(Join))so that k2 may notbeheld along somepathsbetween k1 and k2 acquisitions(asdictatedby \na con.ict) eventhough weintro\u00adduce an atomic pair. As a result, the original acquisition of k2 may notbe \na no-op andthusthelock order k1 . k2 may notbe reversed. Considerthe exampleinFig.8(b).Areadlockfrom2 \nto 6,denotedasR2 ,isinsertedtothelockconstraintsetsforthe 6 pathbetween the two original acquisitions,including \nnodes 2,4and6.Thehoistingandthe new constraintsetleadtothe highlightedinstrumentations alongedge 1 . \n2and 4 . 5. Thediscussion abouthow to select dependence edges to break cycles can be found in the accompanying \ntechnical report[32]. 9. ConditionVariablesandSharedHeap Access // thread 2 // thread 1 acquire(our_lock) \n acquire(our_lock, ...) release(our_lock) ... ... //non-trivial cond_wait(C); ... //program path \ncond_signal(C); Figure 9. A deadlock involving a condition variable and a lock addedby ourtechnique.Thread1blocksatthe \ncondi\u00adtion wait andthread2blocks at our lock.  Condition variables: Our technique has so far not taken \ncondition variables into consideration. Statically resolv\u00ading deadlocks involving condition variables \nis challenging in general. Fig. 9 presents an abstraction of the cases we have encountered. Thread 1 \nblocks at the condition wait and thread 2 blocks at the added lock acquisition injected by our analysis. \nIn practice, such deadlocks may involve other program locks and added locks. Statically resolving thedeadlockishardbecausethe \ncondition signalin thread2 is not eveninthe regionprotectedby our lock and hence alockdependencegraph \ncannotbeeasily constructed.As\u00adsuming alockdependence existsbetween alock acquisition and any reachable \ncondition signal would be too conserva\u00adtiveinpractice.Because of these complexities, we resort to a runtime \nsolution. The basic idea is to disable our locks whenprogram executionblocks on a condition variable, \nun\u00adtil theconditionis satis.ed.Inparticular,wereleaseall our locks held by a thread when it blocks on \na condition vari\u00adable. Due to transitive lock dependencies, we also release ourlocksin other threads \nthat transitivelyblock on the con\u00addition variable. In the presence of condition variables, we re.ne our \nde.nition of pairwise atomicity appropriately: a pairwise atomic regionis a code region(notnecessarilylexi\u00adcal)bracketedbytwo \naccessesto the same variable, without any intervening access to that variable by another thread, providedthe \nregionhas nolockdependence with any thread currentlyblocked on a condition variable. Heapvariables:Heap-allocatedshareddataalsoposeschal\u00adlengesfor \nourtechnique.Anidealsolutionistoprovideper\u00adobjectlockingsothatmaximalconcurrencycanbe achieved. However, \nensuringdeadlock-freedom usingper-objectlock\u00adingisdif.cultsince staticdeadlock resolution often requires \nobject lock acquisitions to be hoisted; oftentimes, we can\u00adnotguarantee that the objecthas evenbeen allocated \nat this hoistpoint.Furthermore, static deadlock resolutionhasdif\u00ad.culty disambiguatingdifferentinstances \nof the sameheap type that will be protected by different locks at runtime. A conservativesolutionresultsin \nsolvingbogusdeadlocks. We therefore currently use a conservative type-based lock\u00adingstrategy, whichis \ntrivially compatible with ourdeadlock analysis described earlier. Note, however, that even though we \nobtain locks on types, our pro.ler still tracks atomicity propertiesindependentlyfor eachheapinstance \nofa type.In other words, the type based abstraction does not affect the qualityof thepro.led atomicityinvariants.Due \nto thelarge amountof sharedheaptypes and some ofthem comingfrom libraries, we expectprogrammersto annotatetheheaptypes \nof interest. In this paper, we focus on those for which bugs havebeen reported. 10. Safety There aretwofundamental \nsafetypropertiesguaranteedby our technique. First, the approach is execution safe: the in\u00adjectedinstrumentationdoes \nnotintroduce additionalbehav\u00adior beyond what could be exhibited by the original pro\u00adgram. Second, the \napproach is atomicity safe and respects the atomicityproperties ofthepro.ledexecution:ourinstru\u00admentationguarantees \nthat the transformedprogram will not permitnon-atomicbehaviorwithin atomicregionsfoundin the pro.le. \nProof details are provided in an accompanying technical report[32]. We formalize these notions below. \nLet the original pro\u00ad ' grambeP and theinstrumentedprogrambe P . THEOREM 1 (ExecutionSafety). For anyinputI, \nexecuting ' P on I produces the same result as executing P on I. THEOREM 2 (AtomicitySafety). A pairwise \natomic region identi.edin P will be executed atomicallyby any execution ' of P . LEMMA 1. Thelockplacement \nalgorithminFig.6 respects the atomicity constraintsde.nedby thepro.le. LEMMA 2. The deadlock resolution \nalgorithm in Section 8 respects the atomicity constraintsin thepro.le. According to the deadlock resolution \nalgorithm, dead\u00adlocks are resolved by hoisting locks. A lock is hoisted by adding entries to lc sets,leadingto \nextra acquisitions of the lock.Afterhoisting, thepaths on which thelockisheld are a superset of the original \npaths. Hence, the atomicity con\u00adstraints mustbe respected.The atomicitysafetypropertycan bederivedfromthese \ntwolemmas. 11. Evaluation Our system is implemented within LLVM. The pro.ler is implemented as aninstrumentationpassthat \nrunsindepen\u00addently of the rest of the system. The lock placement and deadlockresolution areimplemented \nastwopassesthattake the pro.le as input and insert deadlock free synchroniza\u00adtions. The overall implementation \nhas 8K LOC in C. The experiments are conducted on a Intel Xeon CPU 2x4 core 1.84GHz machine with 4GB \nRAM. We create 8 threads in all executions. program LOC func pro.le input aget-0.4 960 20 geta 100k.le \npbzip-2.094 2041 121 compress 100k.le with 1k block size mozilla nszip-1.8 2935 45 extract 100 .les apache-2.2.8 \n42k 1.7k 10krandom reqs spidermonkey 51k 1098 compute MD5 hash  Table2. Programs andpro.leinputs. 11.1 \nEffectiveness We evaluate the effectiveness of bug suppression by ap\u00adplying our technique on real bugs \nfound in production\u00adquality software. We have already previously discussed the applications we have studied \n(shown in Table 1); Ta\u00ad ble 2 presents the program characteristics and inputs used for collectingpro.lesfor \ntheseprograms.Column[func] presentsthefunctionsunder our analysis.Column[profile input] presents the \nworkload used for collecting atom\u00adicity pro.le. These programs are well-studied standard benchmarksfor \nstudying concurrency bugs[20].Inpartic\u00ad ular, spidermonkey is the JavaScript engine for Mozilla. mozilla-nszip \nisthedecompressioncomponentofMozilla. The real patches for these bugs are also available from thebug \nreportsortheirCVS repositories.We compared the patches withthe synchronizationsinsertedby our technique \nmanually and con.rm that our technique prevents these bugs.We also rantheinstrumentedprogramsonthefailure \ninducinginputs withanimplementation oftheCHESS[23] algorithm developed in our prior work [31], with the \n1\u00ad preemption setting. Bugs that were previously exposed no longer occurred. Note that even though ourinstrumentation \nmechanismis based on pro.les that extract pairwise atomicity, our tech\u00adnique can alsoprevent concurrencybugsthat \nare classi.ed as data races or order violations. For example, the pbzip bug was considered as an order \nviolation. The bug occurs because a read to a variable x in a thread T1 must always happen before a re-de.nition \nof x in a different thread T2 . But,theprogrampermits violationof such orderings,lead\u00ading to a failure. \nOur technique observes atomicity between the read and its preceding local read. As existing program synchronizations \npreserve that the preceding read happens before the remote write,bylocking the two reads, the order violationis \nsuppressed. ap_queue_info_set_idle(pool_t *pool) { node = apr_palloc(pool, sizeof(*node)); node->pool \n= pool; for (;;) { node->next = recycled_pools; if (apr_atomic_casptr(&#38;recycled_pools,  L: node, \nnode->next) == node->next) break; } ...  } Figure10. Apachebug#44402:Abug that manifests under a rare \ncomplicated interleaving with multiple preemptions. The two reads to node->next in the conditionaltest \nshould be executedatomically topreventa race condition. Case Study. Next, we present a fragment from \napache, tofurtherillustrate thebene.t of our approach.Bug#44402 showninFig.10wasobservedwhilerunningthe \nspecweb99 static contentworkload.The server wouldcrashtypicallyaf\u00adter10 minutesof starting thetest with500 \nactivethreads. 2 The bug took developers one week of investigation span\u00ad 2https://issues.apache.org/bugzilla/show \nbug.cgi?id=44402  ning more than 1000 lines of discussion before they were able toidentify thefaultyinterleaving.The \nmatterisfurther complicatedby thefactthatthe crashhappensatplacesfar removedfromthelocation where atomicityis \nviolated and a failure maymanifest atdifferentplaces atdifferenttimes. Inthe code showninFig.10, workerthreadsinthe \nweb server, call the function ap queue info set idle () to deposit a memory pool which is no longer in \nuse in the list of recycled pools. Under normal conditions, the list recycled pools is alinearlist.However,if \nthreedifferent threadsinterleave withinthisfunctionsimultaneously(a rare but possible occurrence), the \nlist can be modi.ed to be cir\u00adcular withjust onepool afterfourdifferentpreemptions.We refer the reader \nto the bug report for details. Consequently, all workers which should otherwise be using distinct mem\u00adorypoolsforhandling \nrequests end up usingthe same mem\u00adory pool, eventually leading to a server crash. Due to the higher number \nofthreads andmultiplepreemptions required (in addition to the atomicityviolation) and the fact that the \ncrash manifests elsewhereinthe server(necessitatingtesting thefull serverto exposethefailure),itisdif.cult \ntoboth re\u00adproduce andunderstand thisbug.However,by onlylooking at correct executions wherethe two readsto \nnode->next at line L are atomic, and thus enforcing this property, the bug can be prevented easily. This \nis, in fact, the patch that was eventuallyprovidedby thedevelopers.  11.2 PerformanceOverhead Next, \nwepresent experimental results that highlightquanti\u00adtative aspects onthe cost ofthe analysis andimplementation \non these benchmarks. Columns 2-4 in Table 3 present the pro.ling results. Column [shared vars/ unprotected] \npresents the shared variables identi.ed, and those that are not consistently protected by at least one \nlock. Columns 3 and4present the read and exclusive atomicpairsidenti.ed bythepro.ler andthe average number \nof(static)statements thatlieinbetween apair(i.e.the numbersinparentheses). As these programs are mostly \nevent-driven, executing the programs with various events (or event combinations) are equivalent to running \nthe programs multiple times. Hence, we construct the pro.le inputs as follows: we combine and duplicatetestinputsin \na regressionsuiteintoalargerinput consisting of all eventsfromindividual tests.We randomly insert sleep() \ncalls at synchronization points to increase our schedule coverage. Observe that the number of shared \nvariables that are not consistently protected is non-trivial. Our claim is that the statements enclosed \nby atomic pairs with respecttothese variables are vulnerableto concurrency bugs. Also observe that the \naverage number of such state\u00admentsin an atomicpairis notlarge. Columns under label [inserted locks] in \nTable 3 present the results of static lockplacement.Column[lock] presents the number of inserted locks. \nColumns [R acq], [X acq], and[degrade]denote the numbers of read lock acquisitions, exclusive lock acquisitions \nand lock degrada\u00adtions, respectively. For each of these columns, we present the numbersbefore and after \ndeadlock resolution.Columns under label[program locks] present the statistics of ex\u00adisting program locks \nfor reference. We make the following observations.    The number of injected locks is comparable \nto that of program locks. The number of injected synchronization primitivesbeforedeadlockresolutionis \nalso comparable tothe numberofexistingsynchronizations.Therearetwo reasons for this: one is that our \ntechnique induces .ne\u00adgrained guidance of executions based on pro.led data such guidance is controlled \nby lock acquires and re\u00adleases;secondly,path-sensitivelockinginjects releases at many points, corresponding \nto different atomicity prop\u00aderties manifest along differentpaths.But, notethatlock releasesfor the same \nvariable are usually alongdifferent paths so that they are not typically encountered multiple times along \nonepathduring an execution.  Deadlock resolution increases the number of injected synchronizations substantially.Thisisdue \nto the conser\u00advative nature of the analysis.  Comparingthe numbers ofthe unprotectedvariables and pro.led \natomic pairs with the numbers before deadlock resolution, we observethat wedo not needtoinsertlocks toprotect \nall unprotected variablesbecause some are not marked as atomic. Some atomic pairs are aggregated to larger \natomic regions. Some acquisitions are optimized away, which explains why the number of inserted syn\u00adchronizationsis \nsmaller thanthe number of atomicpairs.  Table 4 presents runtime characteristics. We execute the instrumented \nprograms on realistic workloads. The sec\u00adond column describes the workloads. The third column presents \nthe total number of executed instructions. Col\u00adumn[speedup]presents the speedup of running the orig\u00adinal \nprogram on 8 cores over 1 core. This provides a measure of the available concurrency in these workloads. \nNote that these numbers are collected without any involve\u00admentof oursystem.Column[P acq]presents thedynamic \ncount of the number ofprogramlock acquisitions.The next two columns show the ratio of instrumented locks \nwith re\u00adspect to this number. The last column shows overall run\u00adtime overhead. Observe that the overhead \nis low despite the large number of injected synchronizations, indicating our instrumentation rarely cause \nsevere blocking. This is because we arelockingon observed atomicpairs, whose ex\u00adecutions are mostly atomic, \nand consequently likely to not be a source of contention.The overhead of our techniqueis sometimes related \nto the available concurrencyin the work\u00adload. If available concurrency is low, the overhead of our techniqueis \nmaskedfurther.For example, we use two work\u00adloadsfor mysql.The .rst oneisastandard workload called sysbench. \nThe second is a reduced version of the tpcc workload, another standard workload.The tpcc workloadis \nshared var/ atomicpair insertedlocks  programlocks program unprotected  RX Racq X acq degrade rel \nlock acq rel lock (stmt) (stmt) (before/after) (b/a) (b/a) (b/a) aget 5/3 0(-) 7(2) 1 2 2 3 0/9 4/4 \n0/0 4/12 pbzip 18/17 60(12) 16(6) 3 24 26 15 28/35 13/28 2/0 76/104       mozilla nszip-1.8 2/2 \n3(1) 7(9) 1 1 5 2 0/0 4/3 0/0 9/8 apache 15/13 11(5) 28(10) 9 21 29 13 6/13 17/20 1/1 52/65 spidermonkey \n16/9 13(37) 26(11) 9 36 36 8 10/7 18/39 5/2 36/108 mysql 66/20 91(61) 181(7) 36 222 300 15 71/39 99/431 \n7/5 249/959 Table3. Pro.ling andlockplacement results.      9 program workload instr.(10) speedup \nP acq Racq/P acq Xacq/P acq overhead aget geta648M .le 0.045 2.58 147.4k 0 1.0 0% pbzip compress1.8G.le \n798.9 5.33 14.9k 2.0 1.28 1.4% mozilla nszip-1.8 extract400k .les 179.7 3.76 399k 0 2 0.0% apache 2million \nrandom reqs 158.5 4.2 14.2m 1.48 2.04 13.3% constraint solver 308.22 1.06 422m 0.0 0.0 2.1% spidermonkey \n null script 24.1 4.6 18m 0.11 0.44 17.3%     sysbench-oltp with10k rows 258.5 4.34 7.76m 1.29 \n0.57 13.9% mysql  reduced tpcc 185.8 1.74 4.22m 1.48 0.61 2.0% Table4. Runtime overhead(8threads).Inthe \nP acq column, units m and k mean million andthousand, resp. much more I/O bound. Consequently, the overhead \nof our technique is much lower. A similar workload con.guration is usedforspidermonkey.In contrast, notethatboth \npbzip and mozilla-nszip get substantial speedup with verylow overhead.  12. RelatedWork Concurrent \nwith our work,[18] also attempts to automat\u00adically repair concurrency bugs by inserting locks around \ninferred atomic regions. However, unlike our approach, which attempts to prevent bugs whose existence \nmay not even be known, their technique attempts to repair existing ones.Their technique usesCTrigger[25] \ntoidentify atomic pairs relatedto the observedfailure;ourtechniqueidenti.es atomic pairs by mining the \npool of passing test cases. As a result, we face the challenge of enforcing a much larger number of atomic \npairs, with the corresponding potential bene.t ofpreventing unobservedbugs.To reduce overhead, ourlockinginstrumentationusesboth \nreadlocksas well as exclusivelocks, whereas exclusivelocks suf.cein theirim\u00adplementation. Furthermore, \nthe two techniques also differ in the way they handle deadlock. We guarantee deadlock freedomthroughstatic \nanalysis. In [7, 35], hardware-based techniques are proposed to ensure dependence integrity. Violations \nincur rollback and cause adifferent schedule tobe explored.In[10], schedules are memoizedwith respecttoinputs \nsothatifthe sameinput is encountered, the same schedule is reused. LOOM [33] allows user to put in explicit \nannotations to repair races. Like[10],itprovides no safetyguarantees, anddeadlocks canbeintroduced. CoreDet[2] \nguaranteesdeterministic outputsby allow\u00ading threads to run concurrently when they are not commu\u00adnicating. \nIt tracks ownership and employs a deterministic commit protocol. In [6] authors present a language and \na type system that support nondeterministic computation with adeterministic-by-defaultguarantee where \nnondeterminism mustbe explicitly requested via specialparallel construct(s). None of these techniques \nattempt to suppressbugs orguide schedulers to enforce correct executions.Isolator[27]guar\u00ad antees isolation \nin well-behaved threads of a program that obey alockingdiscipline eveninthepresence ofill-behaved threadsthatdisobeythelockingdiscipline. \n In [9, 21], locking is statically inferred from atomic region annotations so that atomicity can be guaranteed. \nAtomicregionsarelexically scoped.Locksmith[26] stat\u00adically associates locks with object abstractions \nand at run time, abstract locks are safely instantiated to different con\u00adcrete locks under various contexts. \nAtomic set serializabil\u00adity[29]introducesthe notion ofdata centric synchronization inwhich usersannotateasetofdata \n.eldsthatshouldhave similar consistency properties. Synchronizations are auto\u00admatically inferred to ensure \nserializability of operations on atomic setsin a methodbody.In[11],the authorsdescribe a technique for \ninfering locks from atomic section annota\u00adtions.Itispath-sensitive and uses read/write, multi-granular \nlocks and also attempts to release locks as early as possi\u00adble.Similarly,in[14],locks are allocated automaticallyin \na multi-threaded program annotated with atomic sections. Their algorithm works in the presence of pointers \nand pro\u00adcedures, and sets up the lock allocation problem as a 0-1 ILP which minimizes the con.ict cost \nbetween atomic sec\u00adtions while simultaneously minimizingthe number oflocks. Unlike these approaches which \nrely on static analysis and programming abstractions, our approach infers properties from correct pro.led \nexecutions to inject suitable locking instrumentation.Our work couldbene.tfromlock coarsen\u00ading techniques \nsuch as[12]tofurtherimproveperformance and eliminatepotentialdeadlocks. There has been extensive investigation \non detection of variouskinds of concurrencybugs, such asdata races[3, 5,24,28], atomicity violations[15,16,30,34], \norder viola\u00ad tions[20], anddeadlocks[1,17].Therehas alsobeen recent progressindevising techniquesthat \ncangeneratedetermin\u00adisticfailure-inducingschedules[4,23,25].Thesetechniques systematicallyexploreaboundedspaceofschedules,andare \ncomplementaryto our work.  13. Conclusion This paper proposes a novel technique to suppress Heisen\u00adbugsbyinferring.ne-grainedatomicitypropertiesfrom \ncor\u00adrectpro.led executions.Wedescribe adeadlock-freepath\u00adsensitivelocking schemetoforceprogramexecutionto \nad\u00adhere to these properties. Experimental evaluation on real world workloads demonstrates that it can \nbe used to suc\u00adcessfully suppress subtle atomicity and order violation con\u00adcurrencybugs withlow overhead. \n  References [1] R. Agarwal, L. Wang, and S. D. Stoller. Detecting Potential Deadlocks with Static Analysis \nand Runtime Monitoring. In PADTAD 05. [2] T. Bergan, O. Anderson, J. Devietti, L. Ceze, D. Grossman. \nCoreDet: A Compiler and Runtime System for Deterministic MultithreadedExecution. In ASPLOS 10. [3] E.Bodden \nandK.Havelund. Racer:EffectiveRaceDetection UsingAspectJ. In ISSTA 08. [4] S. Burckhardt, P. Kothari, \nM. Musuvathi and S. Nagarakatte. Arandomized schedulerwithprobabilisticguaranteesof.nd\u00adingbugs. In ASPLOS \n10. [5] M.D.Bond,K.E.Coons andK.S.McKinley. Pacer:Propor\u00adtionalDetection ofDataRaces. In PLDI 10. [6] \nR. Jr. Bocchino, S. Heumann, N. Honarmand, S. V. Adve, V. S.Adve,A.Welc and T.Shpeisman, Safe nondeterminism \nin adeterministic-by-defaultparallellanguage, In POPL 11. [7] L. Chew and D. Lie, Kivati: fast detection \nand prevention of atomicity violations, In EuroSys 10. [8] F.Chen,T.F.Serbanuta,andG.Rosu.JPredictor:APredictive \nRuntimeAnalysisToolforJava. In ICSE 08. [9] S. Cherem, T. M. Chilimbi, S. Gulwani. Inferring Locks for \nAtomicSections. In PLDI 08. [10] H. Cui, J. Wu, C. Tsai and J. Yang. Stable Deterministic Multithreading \nthroughScheduleMemoization. In OSDI 10. [11] D. Cunningham, K. Gudka and S. Eisenbach, Keep off the grass: \nlocking the right path for atomicity, In CC 08/ETAPS 08. [12] P.DinizandM.Rinard, LockCoarsening:EliminatingLock \nOverhead in Automatically Parallelized Object-Based Pro\u00adgrams, In Journal of Parallel and Distributed \nComputing, 49(1):218 244, 1996, [13] G. W. Dunlap, D. G. Lucchetti, M. A. Fetterman, and P. M. Chen. \nExecutionReplay ofMultiprocessorVirtualMachines. InVEE 08. [14] M. Emmi, J. S. Fischer, R. Jhala, and \nR. Majumdar. Lock allocation, In POPL 07. [15] C.Flanagan andS.NFreund. Atomizer:ADynamicAtomic\u00adityCheckerforMultithreadedPrograms. \nInPOPL 04. [16] C.Hammer,J.Dolby,M.Vaziri, andF.Tip. DynamicDetec\u00adtion ofAtomic-Set-SerializabilityViolations. \nIn ICSE 08. [17] P.Joshi,M.Naik,K.Sen, andD.Gay. AnEffectiveDynamic AnalysisforDetectingGeneralizedDeadlocks. \nInFSE 10. [18] Z.Jin,L.Song,W.Zhang,S.Lu, andS.B.Liblit, Automated Atomicity-ViolationFixing. In PLDI \n11. [19] S. Lu and S. Park and C. Hu and X. Ma, and W. Jiang and Z. Li and R. Popa, R. and Y. Zhou. MUVI: \nAutomatically Inferring Multi-Variable Access Correlations and Detecting RelatedSemantic andConcurrencyBugs. \nInSOSP 07. [20] S.Lu,S.Park,E.Seo, andY.Zhou. LearningfromMistakes: A Comprehensive Study on Real-World \nConcurrency Bug Characteristics. InASPLOS 08. [21] B. McCloskey, F. Zhou, D. Gay and E. Brewer. Autolocker: \nSynchronization InferenceforAtomicSections. In POPL 06. [22] P. Montesinos, M. Hicks, S. T. King, and \nJ. Torrellas. Capo: A Software-Hardware Interface for Practical Deterministic MultiprocessorReplay. In \nASPLOS 09. [23] M.Musuvathi andS.Qadeer. FairStatelessModelChecking. In PLDI 08. [24] R. O Callahan and \nJ.-D. Choi. Hybrid Dynamic Data Race Detection. In PPoPP 03. [25] S. Park, S. Lu, and Y. Zhou. CTrigger: \nExposing Atomicity ViolationBugsfrom theirHidingPlaces. In ASPLOS 09. [26] P. Pratikakis, J. S. Foster \nand M. Hicks. LOCKSMITH: Context-SensitiveCorrelationAnalysisforRaceDetection.In PLDI 06. [27] S. Rajamani, \nG. Ramalingam, V. P. Ranganath, and K. Vaswani, ISOLATOR:dynamically ensuringisolationin con\u00adcurrentprograms, \nIn ASPLOS 09. [28] S.Savage, M. Burrows,G.Nelson, P.Sobalvarro, and T.An\u00adderson. Eraser: A Dynamic Data \nRace Detector for Multi\u00adthreadedPrograms. ACMTrans.Comp.Sys.,1997. [29] M. Vaziri, F. Tip and J. Dolby. \nAssociating Synchronization Constraints with Data in an Object-Oriented Language. In POPL 06. [30] L. \nWang and S. D. Stoller. Accurate and Ef.cient Runtime Detection of Atomicity Errors in Concurrent Programs. \nIn PPoPP 06. [31] D. Weeratunge, X. Zhang and S. Jagannathan, Analyzing multicore dumps to facilitate \nconcurrency bug reproduction. In ASPLOS 10. [32] D. Weeratunge, X. Zhang and S. Jagannathan, Suppressing \nConcurrency Bugs Using Sched\u00aduler Shepherding. Feb. 04, 2011, TR-11-002 http://www.cs.purdue.edu/research/technical_reports/2011/TR%2011-002.pdf \n  [33] J.Wu,H.Cui andJ.Yang. BypassingRacesinLiveApplica\u00adtions withExecutionFilters. In OSDI 10. [34] \nM.Xu,R.Bodik,andM.D.Hill. ASerializabilityViolation DetectorforShared-MemoryServerPrograms. InPLDI 05. \n[35] J. Yu and S. Narayanasamy. A Case for an Interleaving ConstrainedShared-Memory Multi-Processor. \nInISCA 09.  \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Concurrency bugs are often due to inadequate synchronization that fail to prevent specific (undesirable) thread interleavings. Such errors, often referred to as Heisenbugs, are difficult to detect, prevent, and repair. In this paper, we present a new technique to increase program robustness against Heisenbugs. We profile correct executions from provided test suites to infer fine-grained atomicity properties. Additional deadlock-free locking is injected into the program to guarantee these properties hold on production runs. Notably, our technique does not rely on witnessing or analyzing erroneous executions. The end result is a scheme that only permits executions which are guaranteed to preserve the atomicity properties derived from the profile. Evaluation results on large, real-world, open-source programs show that our technique can effectively suppress subtle concurrency bugs, with small runtime overheads (typically less than 15%).</p>", "authors": [{"name": "Dasarath Weeratunge", "author_profile_id": "81458659419", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P2839120", "email_address": "dweeratu@purdue.edu", "orcid_id": ""}, {"name": "Xiangyu Zhang", "author_profile_id": "81384614270", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P2839121", "email_address": "xyzhang@cs.purdue.edu", "orcid_id": ""}, {"name": "Suresh Jaganathan", "author_profile_id": "81100208907", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P2839122", "email_address": "suresh@cs.purdue.edu", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048071", "year": "2011", "article_id": "2048071", "conference": "OOPSLA", "title": "Accentuating the positive: atomicity inference and enforcement using correct executions", "url": "http://dl.acm.org/citation.cfm?id=2048071"}