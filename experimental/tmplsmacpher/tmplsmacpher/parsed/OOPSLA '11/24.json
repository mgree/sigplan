{"article_publication_date": "10-22-2011", "fulltext": "\n SugarJ: Library-based Syntactic Language Extensibility Sebastian Erdweg, Tillmann Rendel, Christian \nK\u00a8 astner, and Klaus Ostermann University of Marburg, Germany Abstract Existing approaches to extend \na programming language with syntactic sugar often leave a bitter taste, because they cannot be used with \nthe same ease as the main extension mechanism of the programming language libraries. Sugar libraries \nare a novel approach for syntactically extending a programming language within the language. A sugar \nlibrary is like an or\u00addinary library, but can, in addition, export syntactic sugar for using the library. \nSugar libraries maintain the compos\u00adability and scoping properties of ordinary libraries and are hence \nparticularly well-suited for embedding a multitude of domain-speci.c languages into a host language. \nThey also inherit self-applicability from libraries, which means that sugar libraries can provide syntactic \nextensions for the de.\u00adnition of other sugar libraries. To demonstrate the expressiveness and applicability \nof sugar libraries, we have developed SugarJ, a language on top of Java, SDF and Stratego, which supports \nsyntactic extensibility. SugarJ employs a novel incremental parsing technique, which allows changing \nthe syntax within a source .le. We demonstrate SugarJ by .ve language extensions, including embeddings \nof XML and closures in Java, all available as sugar libraries. We illustrate the utility of self\u00adapplicability \nby embedding XML Schema, a metalanguage to de.ne XML languages. Categories and Subject Descriptors D.3.2 \n[Language Classi.cations]: Extensible languages; D.2.13 [Reusable Software] General Terms Languages Keywords \nSugarJ, language extensibility, syntactic sugar, DSL embedding, language composition, libraries Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 11, October \n22 27, 2011, Portland, Oregon, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. . . $10.00 \n import pair.Sugar; public class Test {private (String, Integer) p = ( 12 , 34); } Figure 1. Using a \nsugar library for pairs. 1. Introduction Bridging the gap between domain concepts and the imple\u00admentation \nof these concepts in a programming language is one of the holy grails of software development. Domain\u00adspeci.c \nlanguages (DSLs), such as regular expressions for the domain of text recognition or Java Server Pages \nfor the domain of dynamic web pages have often been proposed to address this problem [31]. To use DSLs \nin large soft\u00ad ware systems that touch multiple domains, developers have to be able to compose multiple \ndomain-speci.c languages and embed them into a common host language [24]. In this context, we consider \nthe long-standing problem of domain\u00adspeci.c syntax [5, 6, 9, 29, 37, 53]. Our novel contribution in this \ndomain is the notion of sugar libraries, a technique to syntactically extend a pro\u00adgramming language \nin the form of libraries. In addition to the semantic artifacts conventionally exported by a li\u00adbrary, \nsuch as classes and methods, sugar libraries export also syntactic sugar that provides a user-de.ned \nsyntax for using the semantic artifacts exported by the library. Each piece of syntactic sugar de.nes \nsome extended syntax and a transformation called desugaring of the extended syn\u00adtax into the syntax of \nthe host language. Sugar libraries enjoy the same .exibility as conventional libraries: (i) They can \nbe used where needed by importing the syntactic sugar as ex\u00adempli.ed in Figure 1. (ii) The syntax of \nmultiple DSLs can be composed by importing all corresponding sugar libraries. Their composition may form \na new higher-level DSL that can again be packaged as a sugar library. (iii) Sugar libraries are self-applicable: \nThey can import other sugar libraries and the syntax for specifying syntactic sugar can be extended as \nwell. In other words, sugar libraries treat language extensions in a uni.ed and regular fashion at all \nmetalevels. Here, we apply a conceptual understanding of metalevel , which dis\u00ad package pair; public \nclass Pair<A,B> { ... } (a) Implementing the semantics of pairs as a generic Java class. package pair; \nimport org.sugarj.languages.Java; import concretesyntax.Java; public sugar Sugar { context-free syntax \n( JavaType , JavaType ) -> JavaType{cons( PType )} ( JavaExpr , JavaExpr ) -> JavaExpr{cons( PExpr )} \ndesugarings desugar-pair-type desugar-pair-expr rules desugar-pair-type : PType(t1, t2) -> |[ pair.Pair<~t1, \n~t2> ]| desugar-pair-expr : PExpr(e1, e2) -> |[ pair.Pair.create(~e1, ~e2) ]|} (b) Extending the Java \nsyntax and specifying desugaring rules. Figure 2. Sugar libraries comprise syntax and semantics. tinguishes \nthe de.nition of a language from its usage: A lan\u00adguage de.nition is on a higher metalevel than the programs \nwritten in that language. In this sense, sugar libraries (de.n\u00ading language extensions) are on a higher \nmetalevel than the programs that use the sugar library, and the import of a sugar library acts across \nmetalevels. Sugar libraries are not limited to DSL embeddings; they can be used for arbitrary extensions \nof the surface syntax of a host language (for instance, an alternative syntax for method calls). However, \ndue to their composability and their align\u00adment with the import and export mechanism of libraries, they \nqualify especially for embedding DSLs. To explore sugar libraries, we have designed and im\u00adplemented \nsugar libraries in SugarJ. SugarJ is a program\u00adming language based on Java that supports sugar libraries \nby building on the grammar formalism SDF [21] and the trans\u00ad formation system Stratego [48]. As an example \nof SugarJ s syntactic extensibility, in Figure 1, we import a sugar library for pairs that enables the \nuse of pair expressions and types with pair-speci.c syntax. The corresponding sugar library is illustrated \nin Figure 2 and consists of two components: a generic class Pair<A,B>, which implements pair expres\u00adsions \nand types semantically, and syntactic sugar pair.Sugar that provides a pair-speci.c syntactic interface \nfor the li\u00adbrary. The pair.Sugar declaration extends the Java syntax with syntax for pair types and expressions \nand stipulates how pair syntax is desugared to Java. In Figure 1, for exam\u00ad ple, desugaring transforms \nthe pair type (String, Integer) into the Java type Pair<String, Integer> and the pair expression ( 12 \n, 34) into a static method call pair.Pair.create( 12 , 34). Since SugarJ supports arbitrary compile-time \ncomputation, sugar libraries can implement even intricate source transfor\u00admations or perform domain-speci.c \ncompile-time checking. After brie.y reviewing the syntactic extensibility of ex\u00adisting DSL embedding \napproaches, we make the following contributions: We introduce the novel concept of sugar libraries, \na library-centric approach for syntactic extensibility of host languages (Section 3). Sugar libraries \nenable the uniform embedding of DSLs at syntactic and semantic level, and retain (with some limitations \ndiscussed in Sec\u00adtion 6.1) the composability properties of conventional libraries.  Sugar libraries \ncombine the bene.ts of existing ap\u00adproaches: Sugar libraries support .exible domain-speci.c syntax (based \non arbitrary context-free grammars and compile-time checks), and can be imported across met\u00adalevels to \nactivate language extensions in user programs, and act on all metalevels uniformly to enable syntactic \nextensions in metaprograms (self-applicability).  The simplicity of activating syntactic extensions \nby im\u00adport statements and the language support to develop new syntactic extension, even for small language \nextensions, encourages development in a language-oriented [52] fashion.  We present our implementation \nof SugarJ1 on top of ex\u00adisting languages, namely Java, SDF and Stratego, and ex\u00adplain the mechanics of \ncompiling our syntactically exten\u00adsible programming language (Section 4).  Technically, we present an \ninnovative incremental way of parsing .les, in which different regions of a .le adhere to different grammars \nfrom different syntactic extensions.  We demonstrate the expressiveness and applicability of SugarJ \non the basis of .ve case studies pairs, clo\u00adsures, XML, concrete syntax in transformations, and XML Schema. \nThe latter is an advanced example of self-applicability, since each XML Schema de.nes a new XML language \n(Section 5).  2. Syntactic embedding of DSLs Many approaches for embedding a DSL into a host language \nfocus on the integration of domain concepts at semantic level (e.g., [22, 23, 35]), but neglect the need \nfor expressing do\u00ad main concepts using domain syntax. To set the context for sugar libraries, we survey \nthe syntactic amenability of exist\u00ading DSL embedding approaches, whereas a more thorough treatment of \nrelated work appears in Section 7. 1 The source code of our SugarJ implementation and all case studies \nis available at http://sugarj.org. String encoding. The simplest form of representing a DSL program \nin a host language is as unprocessed source code encoded as a host language string. Since most characters \nmay occur in strings freely, such encoding is syntactically .exible. Consider, for instance, the following \nJava program, which writes an XML document to some output stream out. String title = Sweetness and Power \n; out.write( <book title=\\ + title + \\ >\\n ); out.write( <author name=\\ Sidney W. Mintz\\ />\\n ); out.write( \n</book> ); The string encoding allows writing XML code with tags and attributes naturally. Nevertheless, \nin XML documents nested quotes and special whitespace symbols such as new\u00adline have to be escaped, leading \nto less legible code. More\u00adover, the syntax of string encoded DSL programs is not stat\u00adically checked \nbut parsed at runtime; hence, syntactic errors are not detected during compilation and can occur after \nde\u00adploying the software. Furthermore, string encoded programs have no syntactic model and, thus, can \nonly be composed on a lexical level by concatenating strings. This form of com\u00adposition resembles lexical \nmacro expansion in a way that is not amenable to parsing [16] and opens the door to secu\u00ad rity problems \nsuch as SQL injection or cross-site scripting attacks [8]. Library embedding. To avoid lexical composition \nand syn\u00adtax errors at runtime, we can alternatively embed a DSL as a library, that is, a reusable collection \nof functionality ac\u00adcessible through an API. In Hudak s pure-embedding ap\u00adproach [24], for instance, \none builds a library whose func\u00ad tions implement DSL concepts and are used to describe DSL programs. \nFor example, we can embed XML purely as fol\u00adlows: String title = Sweetness and Power ; Element book = \nelement( book , attributes(attribute( title , title)), elements( element( author , attributes(attribute( \nname , Sidney W. Mintz )), elements()))); The syntax of the DSL can be encoded in the type sys\u00adtem of \nthe host language, so that, in a statically typed host language, the DSL program is syntax checked at \ncompile\u00adtime. In our example, such checks can prevent confusion of attributes and elements, for instance. \nEven in an untyped language, purely embedded XML documents are properly nested by design, that is, it \nis not possible to describe ill\u00adformed documents such as <a><b></a></b>. An apparent drawback of purely \nembedded DSLs is the syntactic in.exibility of the approach: Programmers must adopt the syntax of function \ncalls in the host language to de\u00adscribe DSL programs. Consequently, when solving a prob\u00adlem in terms \nof a certain domain, the programmer needs to translate the proposed solution into the host language s \nsyntax manually. Some host languages partially address this problem by overloading built-in or user-de.ned \nin.x opera\u00adtors (e.g., Smalltalk), integer or string literals (e.g. Haskell), or function calls (e.g., \nScala). Even in these languages, how\u00adever, a DSL implementer can only extend the host language s syntax \nin a limited, preplanned way. For example, while Scala supports quite .exible syntax for method calls, \nthe syntax for class declarations is .xed. To circumvent the need for manual translation of domain concepts, \nresearchers have proposed the use of syntactically extensible host languages that support the syntactic \nembed\u00adding of DSLs [4, 6, 44, 53]. In particular, languages with macro facilities (or similar metaprogramming \nfacilities) can be used to develop library-based syntactic embeddings of DSLs [28]. Unfortunately, most \nmacro languages only sup\u00ad port user-de.ned syntax for macro arguments [6]. This ob\u00ad structive requirement \nfor explicit macro invocations prevents the usage of macro systems to syntactically embed DSLs into a \nhost language freely [9]. Independent of their syntactic in.exibility, one essential advantage of library \nembeddings is the composability of DSLs. By importing multiple libraries, a programmer can easily compose \nthose libraries to build a new one. Since embedded DSLs are implemented as libraries of the host language, \nlibrary composition entails the composition of DSL implementations. Therefore, library embedding sup\u00adports \nmodular de.nitions of DSLs on top of previously ex\u00adisting ones [23]. These bene.ts of library embedding \nare the starting point and main motivation for our sugar-library ap\u00adproach. Language extension. To support \nstatically-checked domain\u00adspeci.c syntax, one possibility is to extend the host language such that it \ncomprises the DSL. In this approach, syntactic and semantic language extensions are incorporated into \nthe host language by directly modifying its implementation or using an extensible compiler. Usually, \nlanguage extensions are not restricted in the syntax they introduce; thus, DSL implementors can integrate \narbitrary DSL syntax and se\u00admantics into the host language. For example, Scala provides built-in support \nfor XML documents: val title = Sweetness and Power val book = <book title= {title} > <author name= Sidney \nW. Mintz /> </book>  Scala s support for XML syntax has been directly inte\u00adgrated into the Scala compiler, \nwhich translates XML syntax trees into calls to the scala.xml library [34]. Since the Scala compiler \nparses embedded XML documents at compile\u00adtime, runtime syntax errors cannot occur and ill-formed doc\u00aduments \ncannot be generated. However, in contrast to purely embedded DSLs, users of an XML-extended host language \ncan write programs using XML syntax more naturally, com\u00adpared to nested library calls. In general, modifying \na (nonextensible) compiler to in\u00adcorporate a DSL into the host language is impracticable and makes it \nhard to develop or compose independent DSLs. More generic approaches for extending a language therefore \nsupport modular de.nition and integration of DSLs and are not speci.c to the used host language. In these \napproaches, which include extensible compilers [14, 33] and program transformation systems [9, 47], the \nused language extensions are determined by compiler con.gurations or by generating and selecting the \nright compiler variant. This becomes im\u00adpractical if multiple DSLs are used, because compiler vari\u00adants \nor con.gurations have to be generated for each combi\u00adnation of DSLs, and a signi.cant part of the program \ns se\u00admantics and dependency structure is moved from the pro\u00adgram sources to build scripts or con.guration \n.les. Summary. String embedding is syntactically very .exible but lacks static safety and composability. \nLibrary embed\u00addings excel in composability but lack syntactic .exibility. Language extensions are powerful \nbut hard to implement and compose, and introduce an undesirable strati.cation into base code and metalevel \ncode. Obviously, it would be bene.\u00adcial to combine the respective strengths of these approaches. 3. SugarJ: \nSugar libraries for Java We propose to organize syntactic language extensions into sugar libraries that \nencapsulate speci.cations of syntax ex\u00adtensions and their desugaring into a host language. To use a sugar \nlibrary, a developer simply imports the library and may use the new syntax constructs in subsequent segments \nof the same .le. Programmers and metaprogrammers can uniformly import sugar libraries to implement applications \nor other sugar libraries. To demonstrate the concept, we have designed and im\u00adplemented SugarJ, a variant \nof Java with support for sugar libraries. The design and implementation of SugarJ is based on three existing \nlanguages: Java is used as host language for application code, the syntax de.nition formalism (SDF) [21] \nis used to describe concrete syntax, and the Stratego transfor\u00admation language [48] is used to desugar \nextension-speci.c code into SugarJ code. In particular, extension-speci.c code can not only desugar into \nJava, but also into SDF or Stratego fragments which de.ne another extension. This reuse of ex\u00adisting \ntechnology enables us to implement a fully-featured and highly expressive prototype of SugarJ, while \nstill con\u00adcentrating on the novel aspects of its language design and implementation. We introduce sugar \nlibraries by walking through an ex\u00adample. We extend Java with closures by introducing syntac\u00adtic sugar \nand corresponding desugarings of the introduced closure syntax into plain Java code. (Closures, or lambda \nexpressions, or anonymous functions are an often requested package javaclosure; public interface Closure<Result, \nArgument> {public Result invoke(Argument argument); } (a) An interface for function objects. .nal int \nfactor = ...; Closure<Integer, Integer> closure = new Closure<Integer, Integer>() {public Integer invoke(Integer \nx) {return x * factor; }}; List<Integer> scaled = original.map(closure); (b) Creating a closure. Figure \n3. Closures can be implemented as function objects, but Java does not offer convenient syntax for closure \nexpres\u00adsions. feature for Java and plans exist to integrate closures into Java 8, which is expected for \nlate 2012.) 3.1 Using a sugar library To use a sugar library, a programmer only has to import the library \nwith an ordinary import statement. In a .le that imports a sugar library, the programmer may use syntax \nin\u00adtroduced by the library anywhere after the import. All syn\u00adtax constructs from the library are desugared \ninto plain Java code (more precisely into SugarJ code, because desugar\u00adings can produce new syntax extensions) \nautomatically at compile-time. Our closure example illustrates the bene.ts of sugar li\u00adbraries for programmers \nand how easy such libraries are to use. In plain Java code, a programmer would typically implement closures \nas anonymous inner classes as illus\u00adtrated in Figure 3. However, the syntax is rather verbose, especially \nfor the frequent use case of an anonymous in\u00adner class with exactly one method. With SugarJ, we sim\u00adply \nimport a sugar library that introduces a more concise notation for closures, following roughly the proposal \nof Gafter and von der Ah\u00b4e [20] (one of several syntax sug\u00ad gestions). With this library, we can rewrite \nour example as illustrated in Figure 4: Instead of verbose plain Java code, we write #R(T) to denote \na closure type Closure<R, T> and #R(T t) { stmts...; return exp; } to denote a closure. Both code fragments \nare equivalent. SugarJ automatically desug\u00adars the concise version into plain Java code at compile-time. \n 3.2 Writing a sugar library To write a sugar library, one has to de.ne how to extend the language and \nhow to desugar the extension. Hence, also a sugar library conceptually consists of two parts: An exten\u00adsion \nof the host language s grammar with new syntax rules import javaclosure.Syntax; import javaclosure.Desugar; \n(a) Importing the sugar library for closures. .nal int factor = ...; #Integer(Integer) closure = #Integer(Integer \nx) {return x * factor;}; List<Integer> scaled = original.map(closure); (b) Creating a closure. Figure \n4. Specialized syntax for closures with SugarJ. and a desugaring of the new language constructs into \nthe original language. In SugarJ, programmers de.ne both parts through top\u00adlevel sugar declarations of \nthe form public sugar Name { ... }, which contain SDF and Stratego code organized into sec\u00adtions. All \nvalid SDF and Stratego sections can be used in a sugar declaration, but we concentrate on the features \nmost essential in writing sugar libraries: Syntax rules and desug\u00adaring rules. In an SDF section context-free \nsyntax, a library devel\u00adoper can extend the host language s grammar with new syn\u00adtax rules. We illustrate \nthe corresponding extensions for our closure example in Figure 5(a). A syntax rule speci.es the nonterminal \nto be extended (to the right of the arrow ->), a pattern for the newly introduced concrete syntax (to \nthe left of the arrow), and a name for the syntax tree node created by this production (in the cons annotation). \nIn this way, sugar libraries can introduce new syntax for any syntactic cate\u00adgory (e.g., class declarations, \nexpressions or import state\u00adments) by extending SugarJ nonterminals or nonterminals introduced by other \nsugar libraries. Analogously, in a Stratego section rules, a library devel\u00adoper can de.ne program transformations, \ncalled desugaring rules. We illustrate the rules for closures in Figure 5(b). A desugaring rule consists \nof a name (before the colon), a matching pattern (to the left of the arrow) and a generation template \n(to the right of the arrow). Both pattern and tem\u00adplate are speci.ed using concrete syntax in brackets \n|[ ... ]|, where metavariables are written with an initial tilde ~.A desugaring rule denotes a program \ntransformation from the extended to the original language (possibly with some other extension). Desugaring \nrules are speci.ed using concrete syntax, so that a programmer does not need to read or write abstract \nsyntax trees. In our example, the rule desugar-closure-type in Figure 5(b) matches on closure types using \nthe # ... (...) concrete syntax just introduced in Figure 5(a) For technical reasons, a syntax rule is \nonly activated after the sugar dec\u00ad package javaclosure; import org.sugarj.languages.Java; import concretesyntax.Java; \npublic sugar Syntax {context-free syntax # JavaType ( JavaType ) -> JavaType {cons( ClosureType )} # \nJavaType ( JavaFormalParam ) JavaBlock -> JavaExpr {cons( ClosureExpr )}} (a) Extending the Java grammar \npublic sugar Desugar {rules desugar-closure-type : |[#~result(~argument) ]| -> |[ javaclosure.Closure \n <? extends ~result, ? super ~argument> ]| desugar-closure-expr : ... -> ... desugarings desugar-closure-type \ndesugar-closure-expr } (b) Desugaring closures. Figure 5. Introducing syntactic sugar for closures. The \nsugar library is split over two sugar declarations so that the syntax rules from (a) are in scope in \n(b). laration where it is de.ned.2 Therefore, one typically splits a sugar library into two parts, introducing \nsyntax rules and desugaring rules separately, so the syntax rules for closures are in scope when we de.ne \nthe desugaring rules for clo\u00adsures. Accordingly, desugar-closure-type transforms a clo\u00adsure type into \na reference to the javaclosure.Closure interface. Generally, in desugarings, we write fully-quali.ed \nJava ref\u00aderences to maintain referential transparency [12]. In a .nal section desugarings of the sugar \nlibrary, the li\u00adbrary developer declares the entry-points for desugaring. Af\u00adter parsing, the SugarJ \ncompiler exhaustively applies these desugaring rules in a bottom-up fashion, starting at the syn\u00adtax \ntree s leaves and progressing towards its root. Compi\u00adlation fails if an input program cannot be unambiguously \nparsed with the combination of all syntax rules in scope, if any of the triggered desugaring rules signals \nan error, or if the desugared program still contains fragments of user ex\u00adtensions. 2 Our implementation \nsupports syntax changes only between top-level dec\u00adlarations, but not in the middle of, for example, \na sugar declaration. See Sections 3.3 and 4 for details. 1 package javaclosure; SugarJ 2 import javaclosure.Syntax; \n SugarJ + closures 4 import pair.Sugar;  public class Partial { public static <R, X, Y> #R(Y) invoke( \n.nal #R((X, Y)) f, SugarJ .nal X x) { + closures 5 return #R(Y y) { + pairs return f.invoke((x, y)); \n}; }  SugarJ import javaclosure.Desugar; + closures (syntax only) Figure 6. Composing two sugar libraries \nby importing both.  3.3 Composing sugar libraries Sugar libraries are composed by importing more than \none sugar library into the same .le. For example, in Figure 6, we import the sugar library for closures \ntogether with a sugar library for pairs to implement partial application of a function that expects a \npair as input. Instead of import\u00ading javaclosure.Syntax and javaclosure.Desugar separately, we could \nhave de.ned a compound module javaclosure.Sugar and import this one.3 The scope of each sugar library \nis an\u00adnotated in the .gure. The syntax for closures and the syntax for pairs can be freely mixed in the \nclass declaration, where both sugar libraries are in scope. To merge several syntactic sugar, SugarJ \ncomposes the grammar extension and desugaring declarations of sugar li\u00adbraries. The composability of \nthe underlying grammar for\u00admalism and transformation language was the main criteria for deciding to build \nSugarJ on top of SDF and Stratego. Composing two sugar libraries is not always possible en\u00adtirely without \ncon.icts or ambiguities if the syntactic exten\u00adsions overlap. Our experience, however, shows that in \nmost practical cases libraries can be freely composed or con.icts can be easily detected and .xed, see \nour discussion in Sec\u00adtion 6.1. 4. SugarJ: Technical realization A compiler for SugarJ parses and desugars \na SugarJ source .le and produces a Java .le together with grammar and desugaring rules as output. Subsequently, \nwe can compile the Java .le into byte code, whereas the grammar and desug\u00adaring rules are stored separately \nas a form of library interface for further imports from other SugarJ .les. In this section, 3 Java supports \nwildcard imports like import javaclosure.*, but their se\u00admantics is ill-suited for our purpose: A wildcard \nimport only affects unqual\u00adi.ed class names, but the name of a sugar library never occurs in a source \n.le. Instead, the SugarJ compiler needs to immediately import the sugar library to parse the next top-level \ndeclaration with an updated grammar. we assume that desugaring rules are program transforma\u00adtions between \nsyntax trees. Later, in Section 5.1, we show how an ordinary sugar library can extend SugarJ to support \ndesugarings rules in terms of concrete syntax, as used in the examples so far. 4.1 The scope of sugar \nlibraries To parse and desugar a SugarJ source .le, the compiler keeps track of which grammar and desugaring \nrules apply to which parts of the source .le. Through importing or de.ning a sugar library, the grammar \nand desugaring rules may change within a single source .le. Moreover, de.nitions and import statements \nof sugar libraries may in turn be written using syntactic sugar and thus have to be desugared before \ncontin\u00aduing with parsing. In SugarJ, imports and declarations of sugar libraries can only occur at the \ntop-most level of .les, but not nested inside other declarations. Therefore, the scope of grammar and \ndesugaring rules always aligns with the top-level structure of a .le. For example, in Figure 6, the grammar \nand desugaring rules change between the the second and the third top-level entry for the .rst time, hence \nthe third top-level entry is parsed and desugared in a different context. Subsequently, it changes again \nafter the third and after the fourth top\u00adlevel entry, which in.uences parsing and desugaring of the remaining \n.le. This alignment allows the SugarJ compiler to interleave parsing and desugaring at the granularity \nof top\u00adlevel entries. 4.2 Incremental processing of SugarJ .les Our SugarJ compiler parses and desugars \na SugarJ source .le one top-level entry at a time, keeping track of changes to the grammar and desugaring \nrules, which will affect the pro\u00adcessing of subsequent top-level entries. A top-level entry in SugarJ \nis either a package declaration, an import statement, a Java type declaration, a declaration of syntactic \nsugar or a user-de.ned top-level entry introduced with a sugar library. As illustrated in Figure 7, the \ncompiler processes each top\u00ad level declaration in four steps: parsing, desugaring, splitting and adaption. \nParsing. Each top-level entry is parsed using the current grammar, that is, the grammar which re.ects \nall sugar li\u00adbraries currently in scope. For the .rst top-level entry, the current grammar is the initial \nSugarJ grammar, which com\u00adprises Java, SDF and Stratego syntax de.nitions. For subse\u00adquent top-level \nentries, the current grammar may differ due to declared or imported syntactic sugar. The result of parsing \nis a heterogeneous abstract syntax tree, which can contain both prede.ned SugarJ nodes and user-de.ned \nnodes. Desugaring. Next, the compiler desugars user-de.ned ex\u00adtension nodes of each top-level entry into \nprede.ned SugarJ nodes using the current desugaring. For each top-level entry, the current desugaring \nconsists of the desugaring rules cur\u00adrently in scope, that is, the desugaring rules from the previ\u00ad \nadapt the current grammar only SugarJ nodes Grammar  SugarJ + PARSE  DESUGAR  SPLIT Java extensions \n   Desugaring mixed SugarJ and extension nodes   adapt the current desugaring Figure 7. Processing \nof a SugarJ top-level declaration. ously declared or imported sugar libraries. Desugarings are transformations \nof the abstract syntax tree, which the com\u00adpiler applies in a bottom-up order to all abstract-syntax-tree \nnodes until a .xed point is reached. The result of this desug\u00adaring step is a homogeneous abstract syntax \ntree, which con\u00adtains only nodes declared in the initial SugarJ grammar (if some user-speci.c syntax \nwas not desugared, the compiler issues an error message). Thus, this tree represents one of the prede.ned \ntop-level entries in SugarJ and is therefore com\u00adposed only of nodes describing Java code, grammar rules \nor desugarings. These constituents can now be splitted to yield three separate artifacts. Splitting. \nWe split each top-level SugarJ declaration into fragments of Java, SDF and Stratego and reuse their re\u00adspective \nimplementations. Java top-level forms are written into the Java output whereas a sugar declaration affects \nthe grammar speci.cation and desugaring output. Package dec\u00adlarations and import statements, on the other \nhand, are for\u00adwarded to all output artifacts to align the module systems of Java, SDF and Stratego. After \nprocessing the last top-level declaration, the Java .le contains pure Java code and the grammar speci.cation \nand desugaring rules are written in a form that can be im\u00adported by other SugarJ .les. In case any produced \nartifact does not compile, the SugarJ compiler issues a correspond\u00ading error message. So far, however, \nthe compiler can only report errors in terms of desugared programs. Adaption. As introduced above, sugar \ndeclarations and im\u00adports affect the parsing and desugaring of all subsequent code in the same .le. Therefore, \nafter each top-level entry, we re.ect possible syntactic extensions by adapting the cur\u00adrent grammar \nand the current desugaring. If a top-level declaration in the desugared abstract syn\u00adtax tree is a new \nsugar declaration, we (a) compose the cur\u00adrent grammar with the grammar of the new declaration and (b) \ncompose the current desugaring rules with the desugaring rules of the new declaration. If the top-level \ndeclaration is an import declaration, we load the corresponding sugar library from the class path and \ncompose its extensions of grammar and desugaring with the current grammar and desugaring. On pure Java \ndeclarations, we do not need to update the cur\u00adrent grammar or desugaring. When composed, productions \nof two grammars (e.g., from the initial SugarJ grammar and from a grammar in a sugar library) can interact \nthrough the use of shared non\u00adterminal names. Hence, a sugar library can add productions to any nonterminal \noriginally de.ned either in the initial grammar or in some other sugar library. In that way, non\u00adterminals \nde.ned in the initial grammar represent initial ex\u00adtensions points for grammar rules de.ned in sugar \nlibraries. Similarly, when composed, two sets of desugaring rules can interact through the use of shared \nnames and by producing abstract-syntax-tree nodes that are subsequently desugared by rules from the other \nset. Adaptation and composition of grammar and desugarings may take place after every top-level declaration \nand affect the processing of all subsequent top-level declarations. 4.3 The implementation of grammars \nand desugaring As mentioned earlier, SugarJ uses the syntax de.nition for\u00admalism SDF [21] to represent \nand implement grammars and the transformation language Stratego [48] to represent and implement desugarings. \nThe initial grammar (with regard to the process described in Section 4.2) is a standard Java 1.5 grammar \naugmented by top-level sugar declarations. To enable incremental parsing with different grammars, we \nhave adapted the Java gram\u00admar by a nonterminal which parses a single top-level en\u00adtry together with \nthe rest of the .le as a single string. An alternative approach to this incremental parsing are adap\u00adtive \ngrammars, which support changing the grammar at parse-time [40]. However, adaptive grammars are inherently \ncontext-sensitive, which makes their ef.ciency questionable. SDF, on the other hand, parses input into \na parse forest with a cubic worst-case complexity. Before using SDF grammars and Stratego transforma\u00adtions, \nSugarJ has to compile them. Our implementation caches the results of SDF and Stratego compilation to \nspeed up the usual case of using the same combination of sugar libraries multiple times, either processing \ndifferent .les us\u00ading the same set of sugar libraries, or reprocessing the same .le after changes which \ndo not affect the imports. In such a case, our compiler takes only a few seconds to compile a SugarJ \n.le. In contrast, when changing the language of a SugarJ .le, all syntax rules and desugaring rules in \nscope are recompiled, thus compilation takes considerably longer (but typically well under a minute). \nSeparate compilation [11] would help to speed up compilation, but SDF and Stratego traditionally focus \non the .exible combination of modules, not on compiling them separately. 5. Case studies Our primary \ngoal in designing SugarJ is to support the inte\u00adgration and composition of DSLs at semantic and syntactic \nlevel. To this end, we provide SugarJ with an extensible sur\u00adface syntax that sugar libraries can freely \nextend to embed arbitrary domain syntax. We have embedded a number of language extensions and DSLs into \nSugarJ, including syntax for pair expression and pair types (Section 1), closures for Java (Section 3) \nand regu\u00ad lar expressions. All of these case studies are implemented in similar style: One de.nes an \nextended syntax and its desug\u00adaring into an existing Java implementation for the domain. In this fashion, \nwe could have easily embedded many more DSLs such as Java Server Pages or SQL. Many such case studies \nhave been performed for MetaBorg [9]; since we use the same underlying languages for describing grammars \nand desugarings, namely SDF and Stratego, these embed\u00addings could easily be encoded as sugar libraries \nby lifting the implementations into SugarJ s syntax and module sys\u00adtem. In contrast to the case studies \nin MetaBorg, the result\u00ading SugarJ libraries can be activated across metalevels and composed by issuing \nimport instructions and need neither complicated compiler con.gurations nor explicit compound modules. \nDue to the simplicity of activating sugar libraries, they are not only well-suited for large-scale embeddings \nof DSLs but also for using several small language extensions such as pairs and closures. Since the embedding \nof further ordinary DSLs is not likely to yield more insight, we focus our attention on more sophisticated \nscenarios that demonstrate the .exibility of sugar libraries compared to other technologies. In the pair \nand closure case studies, we already used a sugar library that provides concrete syntax for implementing \nprogram trans\u00adformations. We will explain this sugar library for concrete syntax in the following subsection. \nSubsequently, we focus on the composability features of SugarJ, by discussing an embedding of XML syntax \ninto SugarJ, which reuses exist\u00ading sugar libraries in nontrivial ways. We close the present section \nby illustrating SugarJ s support for implementing meta-DSLs, that is, special-purpose languages for imple\u00admenting \nDSLs. Speci.cally, we embed XML Schema into SugarJ to describe languages of valid XML documents, for \nwhich validation is a compile-time check. 5.1 Concrete syntax in transformations As described in Section \n4, the SugarJ compiler parses a SugarJ top-level declaration into an abstract syntax tree be\u00adfore applying \nany desugaring rules. Internally, desugaring rules are expressed as transformation between abstract syn\u00adtax \ntrees, even when they are speci.ed in terms of concrete syntax, as described in Section 3.2. Concrete \nsyntax in trans\u00ad formations, however, signi.cantly increases the usability of SugarJ: A sugar library \ndeveloper, who wants to extend the visible surface syntax, should not need to reason about the underlying \ninvisible abstract structure. To support concrete syntax in transformations, we could have changed the \nSugarJ compiler, leading to a monolithic and not very .exible design. The self-applicability of SugarJ, \nhowever, allows a more .exible and modular solution: We implement concrete syntax in transformations \nas a sugar library concretesyntax.Java that extends the syntax for the speci.cation of sugar libraries \nitself. We have imported this sugar library in the sugar libraries for pairs and closures above. For \nexample, the desugaring rules for pair expressions can conveniently be written as a transformation between \nsnippets of concrete syntax as follows: desugar-pair : |[(~expr:e1, ~expr:e2) ]|-> |[ pair.Pair.create(~e1, \n~e2) ]| This rule is desugared into a transformation between abstract syntax trees as follows: desugar-pair: \nPExpr(e1, e2) -> Invoke( Method(MethodName( AmbName(AmbName(Id( pair )), Id( Pair )), Id( create ))), \n[e1, e2]) Visser proposed the use of concrete syntax in the imple\u00admentation of syntax tree transformation \n[49] for MetaBorg. Technically, a transformation that uses concrete syntax ex\u00adpands to a transformation \nwith abstract syntax by parsing the concrete syntax fragments and injecting the resulting ab\u00adstract syntax \ntree. Thus, the left-hand and right-hand sides of the former desugar-pair transformation expand to the \nones of the latter transformation. This technique is language\u00adindependent and has been implemented generically \n[49], such that the concrete syntax of any language can be in\u00adjected into Stratego by extending Stratego \ns grammar ac\u00adcordingly. For example, to enable concrete syntax for Java expressions in transformations, \nthe following productions specify that quoted Java code is written in brackets |[ ... |] and anti-quoted \nStratego code is preceded by a tilde ~. |[ JavaExpr ]| -> StrategoTerm {cons( ToMetaExpr )} ~ StrategoTerm \n-> JavaExpr {cons( FromMetaExpr )} In SugarJ, the sugar library for concrete syntax in trans\u00adformations, \nwhenever it is in scope, automatically desugars concrete syntax into abstract syntax as described above. \nIn contrast, in MetaBorg, the desugaring of concrete syntax is a preprocessing step which the programmer \nneeds to enable manually by accompanying the Stratego source .le with an equally named *.meta .le pointing \nto the SDF module used for desugaring [49]. The reason for this obstructive mechanism is that support \nfor concrete syntax is syntactic sugar at metalevel. Due to the homogeneous integration of metalanguages \nin SugarJ, however, SugarJ is host language and metalanguage at the same time. Therefore, language ex\u00adtensions \nof SugarJ can be developed as sugar libraries in SugarJ itself. The alignment of host language and metalanguage \nin SugarJ implies that a programmer can develop and apply lan\u00adguage extensions within a single language \nand never has to specify any con.guration external to the language such as a build script or MetaBorg \ns *.meta .le. This has a fun\u00addamental consequence: It enables programmers to conduct modular reasoning. \nEvery fact about a given SugarJ program is derivable from its source code and the modules it refer\u00adences; \nit is not necessary to take build scripts, con.guration .les, or, in fact, any code into account that \nis not referenced within the source .le. This becomes particularly important when the number of available \nDSLs grows, as, for instance, in our implementation of the XML sugar library.  5.2 XML documents The \nembedding of XML syntax [51], as discussed in Sec\u00ad tion 2, is a good show-case for syntactic extension: \nMany ex\u00ad isting APIs for XML suffer from a syntactic overhead com\u00adpared to direct use of XML tag notation, \nXML syntax does not follow the lexical structure of most host languages, and neither well-formedness \nnor validation of XML documents are context-free properties. The implementation of our sugar library \nfor XML syntax furthermore serves as an example to discuss SugarJ s support for modularity. Typically, \nXML is integrated into a host language by providing an API such as the Simple API for XML (SAX) or the \nDocument Object Model. Following the MetaBorg XML embedding [9], our sugar library for XML syntax desugars \nXML syntax into an indirect encoding of documents through SAX calls. In Figure 8, for example, an XML \ndocument is sent to a content handler ch. Compared to Scala s XML support (Section 2), sugar libraries \nprovide similar syntactic .exibility without changing the host language s compiler. The XML sugar library \nstatically ensures that all gener\u00adated XML documents are well-formed and, to this extent, supports the \nsame static checks as the pure embedding ap\u00adproach shown in Section 2. In contrast, the SAX API does \nnot statically detect illegal nesting as in <a><b></a></b> import xml.XmlJavaSyntax; import xml.AsSax; \n(a) Importing the XML syntax and desugaring. public void genXML(ContentHandler ch) {String title = Sweetness \nand Power ; ch.<book title= {title} > <author name= Sidney W. Mintz /> </book>; } (b) Generating an XML \ndocument using XML syntax. The anti-quote operator {...} allows SugarJ code to occur inside XML documents. \nFigure 8. XML documents are statically syntax checked and desugared to calls of SAX. or mismatching start \nand end tags as in <a></b>. The XML sugar library arranges to check both properties, the former during \nparsing and the latter during a separate check\u00ading phase. The XML sugar library illustrates an interesting \ndistinc\u00adtion of the kind of static checks we can perform in sugar libraries. On the one hand, context-free \nproperties such as legal nesting of XML elements can be encoded into the syn\u00adtax de.nition of a language \nextension; the compiler veri.es context-free properties while parsing the source code. On the other hand, \ncontext-sensitive properties cannot be en\u00adcoded into context-free syntax rules; instead, it is possible \nto encode the checking of context-sensitive properties as a program transformation that traverses a syntax \ntree and gen\u00aderates a list of error messages as needed. For example, the XML sugar library contains a \ncompile-time check that ver\u00adi.es that all XML elements have equal start and end tags. Consequently, an \nelement with mismatching tags is detected at compile-time and leads to a compiler error as expected. \nTo support domain-speci.c analyses, the SugarJ compiler ap\u00adplies context-sensitive checks before desugaring \na program. When developing the XML sugar library, we heavily reused other sugar libraries at metalevel \nin nontrivial ways, including the library for concrete syntax from the previ\u00adous subsection. The diagram \nin Figure 9 depicts the struc\u00ad ture and dependencies of the components involved in em\u00adbedding XML. Package \nxml contains three sugar declara\u00adtions. XmlSyntax de.nes the abstract and concrete syntax of XML, which \nis embedded into the syntax of Java by XmlJavaSyntax. AsSax de.nes how to desugar an XML doc\u00adument into \na sequence of SAX library calls. Since XML doc\u00aduments are integrated into Java at expression level, whereas \nthe SAX library is accessed via statements, calls to SAX have to be lifted from expression level to statement \nlevel. To this end, we adopted the use of expression blocks EBlock from MetaBorg [9]. Finally, AsSax \nuses concrete syntax and expression blocks to generate Java code.  Test Figure 9. The structure of the \nXML case study: arrows depict dependencies between sugar libraries and are resolved through sugar library \nimports. Evidently, composing and reusing language extensions is essential in the implementation of XML. \nSince, in SugarJ, the primary means of organizing language extensions and DSLs are libraries, programmers \ncan import sugar libraries to build their DSL or language extension on top of ex\u00adisting ones. In the \nimplementation of AsSax, for instance, we desugar XML trees into Java with expression blocks. The concrete \nsyntax of expression blocks is directly avail\u00adable in desugaring rules, even though the support for con\u00adcrete \nsyntax in transformations was de.ned independently in concretesyntax.Java. This is possible because both \nsugar libraries extend the same Java nonterminals imported from Java. In general, however, and as for \nordinary libraries, it might be necessary to write glue code to compose individ\u00adual sugar libraries meaningfully. \nThe XML case study illustrates how sugar libraries can be composed to make joint use of distinct syntactic \nextensions. It is important to note that the embedding of XML is not the end of the line of extensibility \nbut itself a sugar library that can be used to build further language extensions. We demonstrate this \nfeature in the following case study, where we implement a type system for XML as a sugar library.  5.3 \nXML Schema A meta-DSL is a DSL with which one can de.ne other DSLs. The de.nition of meta-DSLs is natural \nin SugarJ since SugarJ enables syntactic extensions of the metalan\u00ad import xml.schema.XmlSchema; public \nxmlschema BookSchema {<{http://www.w3.org/2001/XMLSchema}schema targetNamespace= lib > <!-- de.ne schema \ncontent here --> </{http://www.w3.org/2001/XMLSchema}schema> } (a) De.nition of an XML schema for the \nnamespace lib. import xml.XmlJavaSyntax; import xml.AsSax; import BookSchema; public void genXML(ContentHandler \nch) {@Validate ch.<{lib}book title= Sweetness and Power > <{lib}author name= Sidney W. Mintz > </{lib}author> \n</{lib}book>; } (b) SugarJ statically validates XML documents when validation is required by the @Validate \nannotation. To relate XML elements to their schema de.nition, element names are quali.ed by namespaces, \nhere {lib}. Figure 10. De.nition and application of an XML schema. guage and the host language uniformly. \nSugar libraries can thus provide new frontends for building other sugar libraries without any limitation \non the number of metalevels involved. To exemplify this, we have embedded XML Schema [50] declarations \ninto SugarJ as a sugar library for validating XML documents. Each concrete XML Schema speci.cation stipulates \na DSL of valid XML documents; a language of XML speci.cations is a meta-DSL. To validate XML documents \nthrough the compiler, we have integrated a subset of XML Schema into SugarJ as a sugar library. As shown \nin Figure 10(a), a programmer can de.ne an XML schema using a top-level xmlschema declara\u00adtion that contains \na conventional XML Schema document.4 A programmer can require the validation of an XML doc\u00adument by annotating \nit with @Validate, as we illustrate in Figure 10(b). During compilation, the XML schema of the corresponding \nnamespace traverses the XML document to check its validity and generate a (possibly empty) list of er\u00adror \nmessages. Technically, we have de.ned a program transformation that desugars an XML schema into transformation \nrules for validating XML documents. An XML Schema element dec\u00adlaration 4 For simplicity, we currently \ndo not support namespace abbrevia\u00adtions xmlns:abc= xyz that enable the more conventional notation <abc:node \n/>. However, this feature is syntactic sugar and can be im\u00adplemented in an additional sugar library. \n <{http://www.w3.org/2001/XMLSchema}element name= book type= BookType > </{http://www.w3.org/2001/XMLSchema}element>, \nfor example, desugars into a program transformation that matches on XML elements book and checks whether \ntheir attributes and children conform to BookType. According to the structure of an XML schema, validation \nrules like this one are composed to form a full validation procedure for matching XML documents and collecting \npossible errors. The XML Schema sugar library tries to validate an XML document against any validation \nprocedure that is in scope. Should no schema exist for the XML document s names\u00adpace, the sugar library \nissues a corresponding error message. The XML Schema case study not only demonstrates SugarJ s support \nfor compile-time checks, but moreover its self-applicability support: The sugar library introduces syn\u00adtactic \nsugar (XML Schema declarations) for the speci.ca\u00adtion of metaprograms. This possibility of applying SugarJ \nto itself allows programmers to build meta-DSLs. SugarJ s extensive support for self-application was \nalso helpful in our implementation of the XML Schema sugar library itself. Although standard XML Schema \ncannot de\u00adscribe itself in general [32], we identi.ed a self-describable subset of the language. This \nallowed us to bootstrap the sugar library for XML Schema declarations from a descrip\u00adtion of its syntax \nas an XML Schema declaration. In summary, we have presented .ve case studies show\u00ading the expressiveness \nand applicability of SugarJ for im\u00adplementing language extensions and syntactically embed\u00adding DSLs. \nEspecially the more complex sugar libraries reuse simpler libraries, and with XML Schema we demon\u00adstrate \nSugarJ s .exibility as well as the bene.ts of context\u00adsensitive checks and self-application. 6. Discussion \nand future work In the present section, we discuss SugarJ s current stand\u00ading, its limitations, and possible \nfuture development with respect to language composability, context-sensitive checks, tool support, and \na formal consolidation. 6.1 Language composability Composing languages with SugarJ is very simple because \nit only involves importing libraries. However, when compos\u00ading multiple DSLs, ambiguities can arise in \ncomposed gram\u00admars and composed desugaring rules, or additional glue code might be necessary to integrate \nboth languages more care\u00adfully (introduce intended interactions and prevent accidental interactions). \nNonetheless, when composing language extensions, our experience with SugarJ suggests that ambiguity problems \ndo not occur frequently in practice or are easily resolvable. For instance, no composition problems arise \nin the case studies presented in Section 5. However, to fully asses the composability of sugar libraries \na broader study is needed; here we give an initial assessment. In general, the composition of grammars \nmay cause con\u00ad.icts, which manifest as parse ambiguities at compile-time. For instance, when composing \nour XML sugar library with a library for HTML documents, the parser will recognize a syntactic ambiguity \nin the following program, because the generated document could be part of either language: import Xml; \nimport Html; public void genDocs(ContentHandler ch) { ch.<book title= Sweetness and Power > <author \nname= Sidney W. Mintz /> </book>; } It is always possible to resolve parse ambiguities without changing \nthe composed sugar libraries: Besides using one of the prede.ned disambiguation mechanisms provided by \nSDF [45], one can add an additional syntax rule which al\u00ad lows the user to write, say, ch.xml<...> or \nch.html<...> to resolve the disambiguity. This is similar to using fully\u00adquali.ed names to avoid name \nclashes. Another potential composition problem arises when im\u00adporting multiple desugarings for the same \nextended syntax. Currently, the compiler does not detect the resulting con.ict in the desugaring rules, \nleading to unexpected compile-time errors during desugaring. We believe that this is again not a big \npractical problem for the scenario of syntactic sugar and DSL embedding, since usually each DSL comes \nwith its own syntax and hence the desugaring rules do not overlap. That said, detecting syntactic and \nsemantic ambiguities or con.icts is an interesting research topic, related to de\u00adtecting feature interactions \n[10]. Although not in the scope of this work, in future work, we plan to evaluate existing technologies \nfor detecting ambiguities in grammars and pro\u00adgram transformations. For example, we want to investigate \nthe applicability of Axelsson et al. s encoding of context\u00adfree grammars as propositional formulas, which \nallows the application of SAT solving to verify ef.ciently the absence of ambiguous words up to a certain \nlength, but may fail to terminate in the general case [3]. Alternatively, Schmitz pro\u00ad posed a terminating \nalgorithm that conservatively approx\u00adimates ambiguity detection for grammars and generalizes on the ambiguity \ncheck build into standard LR parse ta\u00adble construction algorithms [38]. For the detection of con\u00ad .icting \ndesugaring rules, we want to assess the practicabil\u00adity of applying critical pair analysis to prohibit \nall critical pairs even joinable ones reachable from the entry points of desugaring. This idea has previously \nbeen applied for de\u00adtecting con.icts in program refactorings [30]. To rule out fewer critical pairs, \nwe could combine critical pair analysis with automatic con.uence veri.cation [2] to determine the joinability \nof critical pairs. Since SugarJ treats the host language and the metalan\u00adguage uniformly, all of these \nambiguity checks could be im\u00adplemented as metalanguage compile-time checks in SugarJ. However, these \nchecks operate on the fully desugared base language, whereas SugarJ performs checking before desug\u00adaring. \nThus, SugarJ would need to support more .ne-grained control over when checks are executed.  6.2 Expressiveness \nof compile-time checks Sugar libraries support checking programs for syntactic and semantic correctness: \nEach syntactic extension speci.es what correctness means in terms of a context-free grammar and compile-time \nassertions. During parsing, conformance to an extension s grammar is checked. For example, we en\u00adsure \nmatching brackets in our pair and closure DSLs. For context-sensitive properties (necessary, for example, \nfor context-sensitive languages or statically typed DSLs), however, the question arises when to check \nthem. In addi\u00adtion to encoding constraints as part of desugaring rules, our current implementation of \nSugarJ also offers initial support for a more direct implementation of error reporting: Sugar libraries \ncan specify a Stratego transformation which trans\u00adforms the nondesugared syntax tree of an input .le \ninto a list of error messages. This approach enables the def\u00adinition of context-sensitive properties \nin terms of surface syntax and comprises pluggable type systems [7]. For in\u00ad stance, the check for matching \nstart and end tags of XML documents and XML Schema validation is naturally spec\u00adi.ed in terms of XML \nsyntax. However, the use of non\u00addesugared syntax restricts the extensibility of compile-time checks. \nConsider, for example, a syntactic extension that in\u00adtroduces JavaScript Object Notation (JSON) syntax \nas an alternative syntax for describing tree-structured data, which desugars to XML code: { book :{ title \n: Sweetness and Power , author : { name : Sidney W. Mintz } } } Even though this code desugars to XML \ncode eventually, our current implementation of XML Schema validation will fail because it operates on \nthe nondesugared JSON syntax tree, but can only match on XML documents. To reuse XML Schema validation \nfor JSON, we require some interleaving of compile-time checking and desugaring to enable compile\u00adtime \nchecks not only on nondesugared surface syntax, but also on desugared base language syntax and intermediate \nstages of desugaring. To this end, in future work, we would like to investigate the applicability of \na constraint system that separates constraint generation from constraint resolu\u00adtion and performs both \ninterleaved with desugaring. We plan to let constraints keep track of the actually performed desug\u00adarings, \nso that constraint veri.cation does not interfere with the application of desugarings.  6.3 Tool support \nIn order to ef.ciently develop software in the large, er\u00adror reporting, debugging and other IDE support \nis essen\u00adtial [19, 25, 37]. Due to the .uent change of syntax, and thus language, sugar libraries place \nextraordinary challenges on tools: all language-dependent components of an IDE depend on the sugar libraries \nin scope. Consider syntax highlighting, for example, in which keywords are colored or highlighted in \na bold font. Since syntactic extensions can introduce new keywords to the host language, syntax highlighting \nneeds to take sugar-library imports into account. In fact, we are currently working on an integration \nof SugarJ and Spoofax. Spoofax provides a framework for developing IDEs by specifying a language s syntax \nand language-speci.c editor services such as reference resolv\u00ading and content completion [25]. From these \nspeci.ca\u00ad tions, Spoofax generates a fully-.edged, Eclipse-based ed\u00aditor component for the user s language \nthat is loaded while the user types. Depending on the imported sugar libraries, we plan to automatically \ngenerate and reload editors for each source .le independently, so that an editor correspond\u00ading to a \n.le always re.ects the language extensions in scope. Whereas basic editor services such as syntax highlighting \nare easy to integrate by reusing syntax de.nitions from sugar libraries, more sophisticated services \nrequire the implemen\u00adtation of language-dependent analyses. We propose to im\u00adplement these analyses in \neditor libraries, which in con\u00adjunction with a language s sugar library supplies the neces\u00adsary information \nfor providing advanced editor services in a library-centric fashion [15]. 6.4 Core language In the study \nof sugar libraries, we used SugarJ to evaluate the expressiveness and applicability of our approach, \nfor in\u00adstance, by developing complex case studies such as XML Schema. However, it would be interesting \nto formally con\u00adsolidate sugar libraries and study them more fundamentally. One aspect we intend to study \nis the relation between syntactic extensions and scopes. It is not obvious how to support sugar libraries \nin languages that allow local import statements, e.g., within a method, such as in Scala and ML. Consider \nfor instance the following piece of code, in which we assume s1 after s2 to desugar to s2; s1, i.e., \nto swap the order of the statements s1 and s2. ( 12 ,34) after import pair.PairSugar After swapping \nthe two statements, the scope of the import of pair.PairSugar includes ( 12 ,34), which, thus, is a syntac\u00adtically \nvalid expression. However, to parse a program in the form s1 after s2, the parser already requires knowledge \nof how to parse ( 12 ,34) before it can even consider parsing import pair.PairSugar; this is a paradox. \n Another interesting aspect of such core language is to identify the minimal components of a syntactically \nexten\u00adsible language such that a full language like SugarJ can be boot-strapped from this core language. \n 6.5 Module system The semantics of imports in SugarJ is intended to closely match the semantics of \nimports in Java. In our proof-of\u00adconcept implementation, however, imports are split into Java, SDF and \nStratego by reproducing them in the respec\u00adtive syntax. Unfortunately, though, the scoping rules of these \nlanguages differ: Imports are transitive in Stratego and SDF but nontransitive in Java. Therefore, in \nthe current imple\u00admentation of SugarJ, if A imports syntactic sugar from B, which in turn imports syntactic \nsugar from C, the syntactic sugar from C will be available in A. In contrast, A cannot access Java declarations \nfrom C without .rst importing C or using fully quali.ed names. We plan to investigate whether this mismatch \ncan be resolved using systematic renaming. Java, the base language for SugarJ, has a rather simple module \nsystem in which the interface of a library is often rather implicit because users of a library just import \nthe library s implementation. In future work, we would like to make syntactic exten\u00adsions a formal part \nof a dedicated interface description lan\u00adguage. In this context, we want to address also the question \nof whether there should be some kind of abstraction bar\u00adrier in an interface that hides the details of \nthe desugaring of a syntactic extension. In the current SugarJ program\u00adming model, a programmer has to \nunderstand the associ\u00adated desugaring to reason about, say, the well-typedness of a program written in \nextended syntax. Hence the desug\u00adaring rules must be part of the interface. We believe that this is acceptable \nas long as transformations are simple and compositional which is typically the case for syntactic sugar. \nHowever, for more sophisticated transformations, it makes sense to have an abstraction mechanism that \nhides the details of the transformation, yet allows programmers to reason about their code in terms of \nthe interface. 7. Related work In Table 1, we give an overview that compares syntactic em\u00ad bedding approaches \nregarding the novel combination of fea\u00adtures of sugar libraries. Sugar libraries provide a (1) library\u00adbased \napproach for implementing (2) arbitrary domain\u00adspeci.c syntax extensions in a (3) composable and reusable \nform. Furthermore, sugar libraries arrange to (4) statically check user code at compile-time and (5) \nact at all metalevels in a self-applicable fashion. String encoded DSLs require to escape quotes and \nonly allow lexical composition of programs, that is, by string concatenation. Furthermore, string encoded \nprograms are not statically checked, but parsed at runtime. In contrast, Hudak s pure embedding [24] \ndoes not suf\u00ad fer from the de.cits of string encodings. However, since in a pure DSL embedding all implementation \naspects are encoded into the host language, domain syntax and static checking are restricted through \nthe host language s syntac\u00adtic .exibility and type system. Therefore, a pure embedding of XML with domain \nsyntax and document validation as in SugarJ remains a distant prospect. Macro systems such as Scheme, \nthe C preprocessor, C++ templates, M4, and Dylan (see their comparison by Brabrand and Schwartzbach [6]), \nas well as the Java syntactic ex\u00ad tender [4] and the macro-like metaprogramming facilities of Converge \n[44] support library-based syntactic extensi\u00ad bility, but syntactic extension is restricted to macro \nargu\u00adments [6]. Macro systems are either lexical or syntactic. Lex\u00ad ical macro systems such as the C \npreprocessor perform pro\u00adgram transformations oblivious to the program s structure and are therefore \nill-suited for implementing DSL desugar\u00adings. Syntactic macro systems such as Scheme, on the other hand, \nparse a program before expanding macros. Scheme macros are organized in libraries [17] and pro\u00ad vide \nreferentially transparent and hygienic structural rewrit\u00ading of programs [12, 27], that is, macro expansion \nrespects the lexical scoping of identi.ers. While sugar libraries also respect referential transparency \nwhen using fully quali.ed class names in desugarings, we opted for more .exible but unhygienic transformations \nin our prototype implementa\u00adtion. For instance, the composability of Scheme macros is limited, since \nthey prohibit macro expansion in quoted ex\u00adpressions such as the patterns of a case statement [26, 27]. \nThe design of a .exible and extensible (including the de.ni\u00adtion of new variable binders) mechanism for \nkeeping desug\u00adarings hygienic and referentially transparent is an interesting avenue of future work. \nRecently, Tobin-Hochstadt et al. proposed Racket, a di\u00adalect of Scheme, as a host language for library-based \nlan\u00adguage extensibility [43]. In contrast to Scheme and similar to Lisp, Racket provides facilities for \nadapting its lexical syntax (using readers) and thus supports more .exible syntactic em\u00adbeddings of DSLs \n[18]. However, Racket lacks support for a high-level syntax formalism, and reader implementations do \nnot compose well. While SugarJ addresses language ex\u00adtensions of varying complexity through composition, \nTobin-Hochstadt et al. focus on singular large-scale language ex\u00adtensions; it is not clear how to compose \nlanguages in Racket. Similar to SugarJ, Allen et al. provide syntactic extensi\u00adbility for the Fortress \nprogramming language [1]. A funda\u00ad mental difference to SugarJ is the lack of self-applicability for \nsyntactic extensions in Fortress. Fortress parses all gram\u00admar extensions in one go using the base grammar. \nTherefore, no syntactic extensibility for grammar de.nitions them\u00adselves is supported and the undesirable \nstrati.cation into base level and metalevel remains. Self-applicability and libraries across metalevels \nare an essential bene.t of our Approach Libraries across metalevels Domain syntax Composability Static \nchecking Self\u00adapplicability string encoding pure embedding [24] macro systems [4, 6, 43, 44] extensible \ncompilers [14, 33, 47] prog. transformations [9, 46] dynamic metaobject protocols [36, 37, 39] sugar \nlibraries in SugarJ  n/a addressed as goal addressed but with restrictions not regarded as goal Table \n1. Comparison of syntactic DSL embedding approaches. library-based approach, for example, used to implement \nthe XML Schema case study. It is unclear whether a similar embedding of XML Schema is possible in Fortress. \nThe .exibility of language extensions through extensible compilers, in general, provides excellent support \nfor syn\u00adtactic embedding of domain-speci.c syntax into a host lan\u00adguage. Unfortunately, the host language \nof extensible com\u00adpilers is usually different from their metalanguage. For ex\u00adample, none of the extensible \nJava compilers JastAddJ [14], AbleJ [47], and Polyglot [33] uses Java as their metalan\u00ad guage; they provide \ntheir own speci.cation languages in\u00adstead. Consequently, application developers cannot select and develop \nlanguage extensions in their programs, but must declare and de.ne the desired extensions externally. \nFurther\u00admore, in implementing language extensions, programmers cannot employ already existing syntactic \nextensions because the extended language is different from the metalanguage. Finally, the mentioned extensible \ncompilers rely on syntax formalisms that are not closed under composition of gram\u00admars and therefore \nsuffer syntactic composability issues. In contrast to extensible compilers, program transforma\u00adtion systems \nsuch as MetaBorg [9] and Silver [46] support self-applicability (indeed, Silver itself is implemented \nin Sil\u00adver). In these systems, programmers can write transforma\u00adtions that target the system itself, \nthus enabling the de.nition of meta-DSLs. However, to compile a meta-DSL program, a programmer needs \nto execute three steps: First, compile the meta-DSL transformation using the base compiler; second, apply \nthe meta-DSL transformation to the meta-DSL pro\u00adgram; and third, apply the base compiler to the transformed \nmeta-DSL program. For more advanced uses of DSLs and meta-DSLs, as, for example, in our XML Schema case \nstudy, performing the relevant compilation steps by hand is hardly practical and requires tool support \nin form of build scripts. In contrast, a SugarJ programmer never has to leave the programming language \nand can compile all programs alike, namely by calling the SugarJ compiler only once. Metaobject protocols \nenable the implementation of lan\u00adguage extensions through re.ection and modi.cation of ob\u00adjects and classes \nat either compile-time or runtime. Static metaobject protocols such as OpenJava [42] are similar to macro \nsystems and focus on semantic extensibility but pro\u00advide limited support for syntactic extensions. Helvetia, \non the other hand, is a re.ection-based extensible compiler and IDE for the Smalltalk programming language \nthat supports syntactic extensibility through a dedicated dynamic metaob\u00adject protocol [36, 37]. In Helvetia, \nsyntactic extensions are implemented as Smalltalk programs that parse and trans\u00adform other Smalltalk \nprograms. These metaprograms, how\u00adever, are not organized as libraries they are not imported but rather \nactivated within a Smalltalk image. Similar to Hel\u00advetia, Katahdin [39] supports dynamic syntax adaption \nat runtime. However, the composability and self-applicability of language extensions in Katahdin is unclear. \n Finally, projectional workbenches [13, 19, 41] add an in\u00ad teresting twist, by working around parsing \nentirely. Instead of parsing source code, projectional workbenches store pro\u00adgrams in a database and, \non demand, provide projections in textual form. Programmers change programs in structure ed\u00aditors, some \nof which emulate textual editors to some degree. Projectional workbenches allow easy extension and compo\u00adsition \nof languages (by extending and composing their un\u00adderlying structures) and support self-applicability \nin projec\u00adtions. Since projectional workbenches work with a different model of source code, they cannot \nbe directly compared to SugarJ, which focuses on traditional text-based source code. 8. Conclusion We \nintroduced sugar libraries as a modular mechanism to extend a host language with domain-speci.c syntax. \nDevel\u00adopers can import syntax extensions and their desugaring as libraries, for instance, to develop \nstatically checked domain\u00adspeci.c programs. Sugar libraries preserve the look-and-feel of conventional \nlibraries and facilitate composability and reuse: A developer may .exibly select from multiple syntac\u00adtic \nextensions and import and combine them, and a library developer may reuse sugar libraries when developing \nother sugar libraries (even in a self-applicable fashion). Composi\u00adtion con.icts can occur, but we believe \nthat they are rare in practice. Nevertheless, we would like to have better support for avoiding (by better \nscoping constructs) and detecting (by better analyses) composition con.icts statically. To demonstrate \n.exibility and expressiveness, we have implemented sugar libraries in the Java-based language SugarJ. \nWith SugarJ, we have implemented .ve case studies with growing complexity: pairs, closures, XML, concrete \nsyntax for transformations, and XML Schema. The latter of these case studies heavily reuse syntax extensions \nimported from former and the last one implements a meta-DSL for which self-applicability is a signi.cant \nadvantage. In con\u00adtrast to many other metaprogramming systems, a SugarJ programmer never has to reason \noutside the language since SugarJ comprises full metaprogramming facilities. Our main goal for SugarJ \nwas to provide a library-based mechanism for developing and embedding domain speci.c languages. More \ngenerally, we believe that libraries are the best means for organizing software artifacts into reusable \nand composable units, and should be more often utilized to account for the growing complexity of software \nsystems. Acknowledgments We would like to thank Lennart Kats, Eelco Visser, Shri\u00adram Krishnamurthi and \nRalf L\u00a8ammel for discussions on this project and the reviewers for their helpful comments. This work \nis supported in part by the European Research Coun\u00adcil, grant No. 203099. References [1] E. Allen, R. \nCulpepper, J. D. Nielsen, J. Rafkind, and S. Ryu. Growing a syntax. In Proceedings of Workshop on Foun\u00addations \nof Object-Oriented Languages, 2009. Available at http://www.cs.cmu.edu/~aldrich/FOOL09/allen. pdf. [2] \nT. Aoto, J. Yoshida, and Y. Toyama. Proving con.uence of term rewriting systems automatically. In Proceedings \nof Conference on Rewriting Techniques and Applications (RTA), volume 5595 of LNCS, pages 93 102. Springer, \n2009. [3] R. Axelsson, K. Heljanko, and M. Lange. Analyzing context\u00adfree grammars using an incremental \nSAT solver. In Proceed\u00adings of International Colloquium on Automata, Languages and Programming (ICALP), \nvolume 5125 of LNCS, pages 410 422. Springer, 2008. [4] J. Bachrach and K. Playford. The Java syntactic \nextender (JSE). In Proceedings of Conference on Object-Oriented Pro\u00adgramming, Systems, Languages, and \nApplications (OOPSLA), pages 31 42. ACM, 2001. [5] D. Batory, B. Lofaso, and Y. Smaragdakis. JTS: Tools \nfor implementing domain-speci.c languages. In Proceedings of International Conference on Software Reuse \n(ICSR), pages 143 153. IEEE, 1998. [6] C. Brabrand and M. I. Schwartzbach. Growing languages with metamorphic \nsyntax macros. In Proceedings of Workshop on Partial Evaluation and Program Manipulation (PEPM), pages \n31 40. ACM, 2002. [7] G. Bracha. Pluggable type systems. In OOPSLA Workshop on Revival of Dynamic Languages, \n2004. Available at http: //bracha.org/pluggableTypesPosition.pdf. [8] M. Bravenboer, E. Dolstra, and \nE. Visser. Preventing injec\u00adtion attacks with syntax embeddings. Science of Computer Programming, 75(7):473 \n495, 2010. [9] M. Bravenboer and E. Visser. Concrete syntax for objects: Domain-speci.c language embedding \nand assimilation with\u00adout restrictions. In Proceedings of Conference on Object-Oriented Programming, \nSystems, Languages, and Applica\u00adtions (OOPSLA), pages 365 383. ACM, 2004. [10] M. Calder, M. Kolberg, \nE. H. Magill, and S. Reiff-Marganiec. Feature interaction: A critical review and considered forecast. \nComputer Networks, 41(1):115 141, 2003. [11] L. Cardelli. Program fragments, linking, and modularization. \nIn Proceedings of Symposium on Principles of Programming Languages (POPL), pages 266 277. ACM, 1997. \n[12] W. Clinger and J. Rees. Macros that work. In Proceed\u00adings of Symposium on Principles of Programming \nLanguages (POPL), pages 155 162. ACM, 1991. [13] S. Dmitriev. Language oriented programming: The next \npro\u00adgramming paradigm. Available at http://www.jetbrains. com/mps/docs/Language_Oriented_Programming.pdf, \n2004. [14] T. Ekman and G. Hedin. The JastAdd extensible Java com\u00adpiler. In Proceedings of Conference \non Object-Oriented Pro\u00adgramming, Systems, Languages, and Applications (OOPSLA), pages 1 18. ACM, 2007. \n[15] S. Erdweg, L. C. L. Kats, T. Rendel, C. K\u00a8astner, K. Oster\u00admann, and E. Visser. Growing a language \nenvironment with editor libraries. In Proceedings of Conference on Generative Programming and Component \nEngineering (GPCE). ACM, 2011. [16] S. Erdweg and K. Ostermann. Featherweight TeX and parser correctness. \nIn Proceedings of Conference on Software Lan\u00adguage Engineering (SLE), volume 6563 of LNCS, pages 397 \n416. Springer, 2010. [17] M. Flatt. Composable and compilable macros: You want it when? In Proceedings \nof International Conference on Functional Programming (ICFP), pages 72 83. ACM, 2002. [18] M. Flatt, \nE. Barzilay, and R. B. Findler. Scribble: Closing the book on ad hoc documentation tools. In Proceedings \nof In\u00adternational Conference on Functional Programming (ICFP), pages 109 120. ACM, 2009. [19] M. Fowler. \nLanguage workbenches: The killer-app for domain speci.c languages? Available at http://martinfowler. \ncom/articles/languageWorkbench.html, 2005. [20] N. Gafter and P. von der Ah\u00b4e. Closures for Java. Available \nat http://javac.info/closures-v06a.html. [21] J. Heering, P. R. H. Hendriks, P. Klint, and J. Rekers. \nThe syn\u00adtax de.nition formalism SDF reference manual. SIGPLAN Notices, 24(11):43 75, 1989. [22] C. Hofer \nand K. Ostermann. Modular domain-speci.c lan\u00adguage components in Scala. In Proceedings of Conference \n on Generative Programming and Component Engineering (GPCE), pages 83 92. ACM, 2010. [23] C. Hofer, K. \nOstermann, T. Rendel, and A. Moors. Poly\u00admorphic embedding of DSLs. In Proceedings of Confer\u00adence on \nGenerative Programming and Component Engineer\u00ading (GPCE), pages 137 148. ACM, 2008. [24] P. Hudak. Modular \ndomain speci.c languages and tools. In Proceedings of International Conference on Software Reuse (ICSR), \npages 134 142. IEEE, 1998. [25] L. C. L. Kats and E. Visser. The Spoofax language work\u00adbench: Rules for \ndeclarative speci.cation of languages and IDEs. In Proceedings of Conference on Object-Oriented Pro\u00adgramming, \nSystems, Languages, and Applications (OOPSLA), pages 444 463. ACM, 2010. [26] O. Kiselyov. Macros that \ncompose: Systematic macro pro\u00adgramming. In Proceedings of Conference on Generative Programming and Component \nEngineering (GPCE), volume 2487 of LNCS, pages 202 217. Springer, 2002. [27] E. Kohlbecker, D. P. Friedman, \nM. Felleisen, and B. Duba. Hygienic macro expansion. In Proceedings of Conference on LISP and Functional \nProgramming (LFP), pages 151 161. ACM, 1986. [28] S. Krishnamurthi. Educational pearl: Automata via macros. \nJournal of Functional Programming, 16(3):253 267, 2006. [29] B. M. Leavenworth. Syntax macros and extended \ntranslation. Communications of the ACM, 9:790 793, 1966. [30] T. Mens, G. Taentzer, and O. Runge. Detecting \nstruc\u00adtural refactoring con.icts using critical pair analysis. Elec\u00adtronic Notes in Theoretical Computer \nScience, 127(3):113 128, 2005. [31] M. Mernik, J. Heering, and A. M. Sloane. When and how to develop \ndomain-speci.c languages. ACM Computing Surveys, 37:316 344, 2005. [32] A. M\u00f8ller and M. I. Schwartzbach. \nAn Introduction to XML and Web Technologies. Addison-Wesley, 2006. [33] N. Nystrom, M. R. Clarkson, and \nA. C. Myers. Polyglot: An extensible compiler framework for Java. In Proceedings of Conference on Compiler \nConstruction (CC), volume 2622 of LNCS, pages 138 152. Springer, 2003. [34] M. Odersky. The Scala language \nspecication, version 2.8. Available at http://www.scala-lang.org/docu/files/ ScalaReference.pdf., 2010. \n[35] B. C. Oliveira. Modular visitor components. In Proceedings of European Conference on Object-Oriented \nProgramming (ECOOP), volume 5653 of LNCS, pages 269 293. Springer, 2009. [36] L. Renggli, M. Denker, \nand O. Nierstrasz. Language boxes: Bending the host language with modular language changes. In Proceedings \nof Conference on Software Language Engineer\u00ading (SLE), volume 5969 of LNCS, pages 274 293. Springer, \n2009. [37] L. Renggli, T. G irba, and O. Nierstrasz. Embedding languages without breaking tools. In Proceedings \nof European Con\u00adference on Object-Oriented Programming (ECOOP), volume 6183 of LNCS, pages 380 404. Springer, \n2010. [38] S. Schmitz. Conservative ambiguity detection in context\u00adfree grammars. In Proceedings of \nInternational Colloquium on Automata, Languages and Programming (ICALP), volume 4596 of LNCS, pages 692 \n703. Springer, 2007. [39] C. Seaton. A programming language where the syntax and semantics are mutable \nat runtime. Master s thesis, University of Bristol, 2007. [40] J. N. Shutt. Recursive adaptable grammars. \nMaster s thesis, Worcester Polytechnic Institute, 1993. [41] C. Simonyi. The death of computer languages, \nthe birth of intentional programming. In NATO Science Committee Conference, 1995. [42] M. Tatsubori, \nS. Chiba, M.-O. Killijian, and K. Itano. Open-Java: A class-based macro system for Java. In Proceedings \nof Workshop on Re.ection and Software Engineering, volume 1826 of LNCS, pages 117 133. Springer, 2000. \n[43] S. Tobin-Hochstadt, V. St-Amour, R. Culpepper, M. Flatt, and M. Felleisen. Languages as libraries. \nIn Proceedings of Con\u00adference on Programming Language Design and Implementa\u00adtion (PLDI). ACM, 2011. \n[44] L. Tratt. Domain speci.c language implementation via compile-time meta-programming. Transactions \non Program\u00adming Languages and Systems (TOPLAS), 30(6):1 40, 2008. [45] M. van den Brand, J. Scheerder, \nJ. J. Vinju, and E. Visser. Dis\u00adambiguation .lters for scannerless generalized LR parsers. In Proceedings \nof Conference on Compiler Construction (CC), volume 2304 of LNCS, pages 143 158. Springer, 2002. [46] \nE. Van Wyk, D. Bodin, J. Gao, and L. Krishnan. Silver: An extensible attribute grammar system. Science \nof Computer Programming, 75(1-2):39 54, 2010. [47] E. Van Wyk, L. Krishnan, D. Bodin, and A. Schwerdfeger. \nAt\u00adtribute grammar-based language extensions for Java. In Pro\u00adceedings of European Conference on Object-Oriented \nPro\u00adgramming (ECOOP), volume 4609 of LNCS, pages 575 599. Springer, 2007. [48] E. Visser. Stratego: A \nlanguage for program transforma\u00adtion based on rewriting strategies. In Proceedings of Confer\u00adence on \nRewriting Techniques and Applications (RTA), vol\u00adume 2051 of LNCS, pages 357 362. Springer, 2001. [49] \nE. Visser. Meta-programming with concrete object syntax. In Proceedings of Conference on Generative Programming \nand Component Engineering (GPCE), volume 2487 of LNCS, pages 299 315. Springer, 2002. [50] W3C XML Schema \nWorking Group. XML schema part 0: Primer second edition. Available at http://www.w3.org/ TR/xmlschema-0, \n2004. [51] W3C XML Working Group. Extensible markup language (XML) 1.0 (.fth edition). Available at http://www.w3. \norg/TR/xml, 2008. [52] M. P. Ward. Language-oriented programming. Software Concepts and Tools, 15:147 \n161, 1995. [53] D. Weise and R. F. Crew. Programmable syntax macros. In Proceedings of Conference on \nProgramming Language Design and Implementation (PLDI), pages 156 165. ACM, 1993.   \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Existing approaches to extend a programming language with syntactic sugar often leave a bitter taste, because they cannot be used with the same ease as the main extension mechanism of the programming language - libraries. Sugar libraries are a novel approach for syntactically extending a programming language within the language. A sugar library is like an ordinary library, but can, in addition, export syntactic sugar for using the library. Sugar libraries maintain the composability and scoping properties of ordinary libraries and are hence particularly well-suited for embedding a multitude of domain-specific languages into a host language. They also inherit self-applicability from libraries, which means that sugar libraries can provide syntactic extensions for the definition of other sugar libraries. To demonstrate the expressiveness and applicability of sugar libraries, we have developed SugarJ, a language on top of Java, SDF and Stratego, which supports syntactic extensibility. SugarJ employs a novel incremental parsing technique, which allows changing the syntax within a source file. We demonstrate SugarJ by five language extensions, including embeddings of XML and closures in Java, all available as sugar libraries. We illustrate the utility of self-applicability by embedding XML Schema, a metalanguage to define XML languages.</p>", "authors": [{"name": "Sebastian Erdweg", "author_profile_id": "81490684973", "affiliation": "University of Marburg, Marburg, Germany", "person_id": "P2839200", "email_address": "seba@informatik.uni-marburg.de", "orcid_id": ""}, {"name": "Tillmann Rendel", "author_profile_id": "81381610410", "affiliation": "University of Marburg, Marburg, Germany", "person_id": "P2839201", "email_address": "rendel@informatik.uni-marburg.de", "orcid_id": ""}, {"name": "Christian K&#228;stner", "author_profile_id": "81331495728", "affiliation": "University of Marburg, Marburg, Germany", "person_id": "P2839202", "email_address": "kaestner@informatik.uni-marburg.de", "orcid_id": ""}, {"name": "Klaus Ostermann", "author_profile_id": "81100028971", "affiliation": "University of Marburg, Marburg, Germany", "person_id": "P2839203", "email_address": "kos@informatik.uni-marburg.de", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048099", "year": "2011", "article_id": "2048099", "conference": "OOPSLA", "title": "SugarJ: library-based syntactic language extensibility", "url": "http://dl.acm.org/citation.cfm?id=2048099"}