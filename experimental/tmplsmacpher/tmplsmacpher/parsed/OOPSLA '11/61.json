{"article_publication_date": "10-22-2011", "fulltext": "\n RoleCast: Finding Missing Security Checks When You Do Not Know What Checks Are Sooel Son Kathryn S. \nMcKinley VitalyShmatikov The UniversityofTexas at Austin Microsoft Research and The UniversityofTexas \nat Austin samuel@cs.utexas.edu The UniversityofTexas at Austin shmat@cs.utexas.edu mckinley@cs.utexas.edu \n Abstract Web applications writteninlanguages such asPHP andJSP are notoriouslyvulnerableto accidentallyomittedauthoriza\u00adtion \nchecks and other securitybugs.Existingtechniquesthat .nd missing security checks in library and system \ncode as\u00adsume that (1) security checks can be recognized syntacti\u00adcally and(2) the samepatternof checksappliesuniversally \nto allprograms.These assumptionsdo notholdforWeb ap\u00adplications.EachWebapplicationusesdifferentvariablesand \nlogicto checkthe user spermissions.Even withinthe appli\u00adcation, security logic varies based on the user \ns role, e.g., regular users versus administrators. Thispaperdescribes ROLECAST,the .rst system capable \nofstaticallyidentifyingsecuritylogicthat mediatessecurity\u00adsensitive events(such asdatabase writes) inWeb \napplica\u00adtions, ratherthantaking a speci.cation ofthislogic asinput. We observe a consistent software \nengineering pattern the code that implementsdistinct user rolefunctionality andits securitylogicresidesindistinct \nmethodsand .les andde\u00advelop a novel algorithmfordiscovering thispatterninWeb applications. Our algorithm \npartitions the set of .le con\u00adtexts(a coarsening of calling contexts) on which security\u00adsensitive events \nare control dependent into roles. Roles are based on commonfunctionality and securitylogic. ROLE-CAST \nidenti.es security-critical variables and applies role\u00adspeci.c variable consistency analysis to .nd missing \nse\u00adcurity checks. ROLECAST discovered 13 previously unre\u00adported, remotelyexploitable vulnerabilitiesin11 \nsubstantial PHP andJSP applications, with only3falsepositives. This paper demonstrates that (1) accurate \ninference of application-and role-speci.c security logic improves the security ofWeb applicationswithoutspeci.cations,and(2) \nPermission to make digital or hard copies of all or part of this work for personal or classroomuseisgranted \nwithoutfeeprovided that copiesarenot madeordistributed forpro.tor commercial advantage andthat copiesbearthis \nnotice andthefull citation onthe .rstpage.Tocopy otherwise,torepublish,topostonservers ortoredistribute \ntolists, requiresprior speci.cpermission and/or afee. OOPSLA 11, October22 27,2011,Portland,Oregon,USA. \nCopyright c &#38;#169; 2011ACM978-1-4503-0940-0/11/10. . .$10.00 static analysis can discover security \nlogic automatically by exploitingdistinctive software engineeringfeatures. Categories and Subject Descriptors \nD.2.4[SoftwareEngi\u00adneering]:Software/ProgramVeri.cation Validation; F.3.2 [Logics andMeanings ofPrograms]:Semantics \nofProgram\u00admingLanguages Program analysis General Terms Algorithm,Languages,Security Keywords Security, \nstatic analysis, interprocedural analy\u00adsis, security checks, access control, user roles,PHP,JSP 1. Introduction \nBy design, Web applications interact with untrusted users and receive untrusted network inputs. Therefore, \nthey must not perform security-sensitive operations unless users hold proper permissions. This mechanism \nis known as security mediation. In Web applications, security mediation is typ\u00adically implemented by \nperforming security checks prior to executing security-sensitive events.For example, aprogram may verify \nthat the userisloggedin as an administratorbe\u00adforelettingthe user update the administrativedatabase. \nOur objectivein thispaperis todevelopa robust method for .ndingmissing security checksinWeb applications.The \nmain challenge is that each application and even differ\u00adent roles within the same application, such as \nadministra\u00adtors and regular users implements checks in a different, often idiosyncratic way, using different \nvariables to deter\u00admine whether the user is authorized to perform a particular operation.Finding missing \nchecksis easierif theprogram\u00admerformally speci.es the application s securitypolicy, e.g., via annotations \nordata-.ow assertions[6,27],but the over\u00adwhelming majority of Web applications today are not ac\u00adcompaniedby \nspeci.cations of their intended authorization policies. Previous techniques for .nding missing authorization \nchecks without aprogrammer-providedpolicy take the syn\u00adtactic de.nition of checks as input. Therefore, \nthey must know a priori the syntacticform of every check.For exam\u00adple, Java programs perform security \nmediation by calling prede.ned methods in the SecurityManager class from theJavalibraries[12,17,19,22], \nandSELinuxkernel code callsknownprotectionroutines[23].This approachis suit\u00adable for verifying security \nmediation in library and system code,for which there exists a standardprotectionparadigm, butitdoesnotworkfor \n.nding missing authorizationchecks in applications because there is no standard set of checks usedby \nall applications or even withinthe same application. Whereas analysis of security mediationinlibraries \nrequires checks asinputs, analysisof security mediationinWeb ap\u00adplications mustinfer the set of role-speci.c \nchecksfromthe application s code andproduceit as an output.  Our contributions. Wedesigned andimplementedROLE-CAST, \na new static analysis tool for .nding missing secu\u00adrity checks in Web applications. Given a Web application, \nROLECAST automatically infers(1) the set of user rolesin this application and(2)the securitychecks speci.cto \neach role that must be performed prior to executing security\u00adsensitive events such as database updates. \nROLECAST then (3).nds missingsecurity checks. ROLECAST does not rely onprogrammer annotations or an external \nspeci.cation that indicatesthe application sintendedauthorizationpolicy, nor does it assume a priori \nwhich methods or variables imple\u00adment security checks. ROLECAST exploits common software engineeringpat\u00adternsinWeb \napplications.In ourexperience,thesepatterns are almost universal. A typical Web application has only \na small number of sourcesfor authorizationinformation(e.g., session state, cookies, results of reading \nthe user database). Therefore, all authorization checks involve a conditional branch on variablesholding \nauthorizationinformation.Fur\u00adthermore, individual Web pages function as program mod\u00adules and each role \nwithin the application is implemented byits own set of modules(i.e., pages). Because each page is typically \nimplemented by one or more program .les in PHP and JSP applications, the sets of .les associated with \ndifferentuser roles arelargelydisjoint. Our static analysis has four phases. Phase I performs .ow-and \ncontext-sensitive interprocedural analysis to col\u00adlect calling contexts on which security-sensitive events \nare control dependent. For each context, ROLECAST analyzes interprocedural control dependencies to identify \ncritical variables, i.e., variablesthat control reachability of security\u00adsensitive events. It then uses \nbranch asymmetry to elimi\u00adnate conditional statements that are unlikely to implement security checksbecause \ntheydo not containbranches corre\u00adspondingto abnormalexitinthe eventofafailedcheck.This step alone is \ninsuf.cient, however, because many critical variables(e.g., those responsible for logging) are unrelated \nto security. PhaseIIperforms roleinference.This stepisthekeynew analysis and is critical because different \nroles within the same application often require different checks. For exam\u00adple,prior to removingan entryfrom \nthepassworddatabase, a photo-sharing application may check the session variable to verifythatthe userperformingthe \nactionisloggedin with administratorprivileges,but this checkis not neededfor up\u00addating thecontentdatabasewith \nusers photos.ROLECAST infers application-speci.c roles by analyzing the modular structure of the application. \nAs mentioned above, in PHP and JSP applications this structure is represented by pro\u00adgram .les. Phase \nII partitions .le contexts that use critical variablesinto roles.A.lecontextissimply acoarsened rep\u00adresentation \nof a calling context. The partitioning algorithm arranges .le contextsintogroups so asto minimizethe \nnum\u00adberof.les sharedbetweengroups.We calleachgroupa role. PhaseIIIof ROLECAST determines, within a role, \nwhich critical variables are checked consistently and classi.es this subset of the critical variables \nas security-critical variables. PhaseIVthen reportspotential vulnerabilitiesin thefollow\u00adingcases:(1)if \na calling context reaches a security-sensitive eventwithoutacheck; or(2) iftherolecontainsa single context \nand thus there is no basis for consistency analysis; or(3)if a checkisperformedinconsistently(inthe majority, \nbutnot all calling contexts ofthe role). Because our approach infers the Web application s au\u00adthorization \nlogic under the assumption that the application follows common code design patterns, it may suffer from \nbothfalsepositivesandfalse negatives.Thisimprecisionis inevitablebecause thereis no standard, well-de.nedprotec\u00adtion \nparadigm for Web applications. Furthermore, no .xed set of operations is syntactically recognizable as \nsecurity checks(in contrasttoprior approaches). Instead, ROLE-CAST partitionstheprograminto roles andinfers,for \neach role,the security checks and security-relevantprogram vari\u00adables by recognizing how they are used \nconsistently (or almost consistently) within the role to control access to security-sensitive events. \nWe show the generality of our approach by applying it to Web applications written in both PHP and JSP. \nWithout an oracle that .nds all missing security checks, we cannot measurethe number offalse negatives.When \nevaluated on 11substantial, real-worldPHP andJSP applications, ROLE-CAST discovered13previouslyunreportedsecurityvulnera\u00adbilities \nwith only3falsepositives,demonstratingits useful\u00adnessforpractical security analysis ofWeb applications. \nIn summary,thispaperdemonstratesthatitispossible to accuratelyinferthe securitylogic ofWeb applications \natthe levelofindividualuser rolesbystatic analysis, withoutusing any programmer annotations or formally \nspeci.ed policies but relying instead on common software engineering pat\u00adterns usedby applicationdevelopers. \n2. RelatedWork Finding security vulnerabilities in Web applications. A lot of research has been devoted \nto .nding and analyzing data-.ow vulnerabilitiesinWeb applications[9, 10,13, 25, 26]. This taint analysis \nfocuses on cross-site scripting and SQL injection vulnerabilities, in which untrusted user in\u00adputs .ow \ninto sensitive database operations without proper sanitation. Missing-check vulnerabilities considered \nin this paper are control-.ow vulnerabilities. Consider the follow\u00ading example: if (user == ADMIN) {DB \nquery( DROP TABLE AllUsers )}.Because the query string does not depend on user input, taint analysis \nwill not detect an error if the checkis missing.In securityparlance, thereis an(im\u00adplicit)information \n.owfromthe conditionalto the security\u00adsensitiveevent[7].Thegoal of ouranalysisisnotto .nd suchinformation \n.ows(they areinevitableinallWebap\u00adplicationsdealing with user authorization),but to automati\u00adcallyidentifythe \ncontrol-.owlogicthatdominates security\u00adsensitivedatabase operations and check whether or notit is presenton \nallpathsleadingto these operations.  Balzarotti et al.proposed amethodfor .nding work.ow violations \ncausedby unintended entrypointsinWeb appli\u00adcations[1].Their methodfocuses onlink relationsbetween pages \nand involves statically analyzing string arguments of page redirectfunctions.Thedif.cultyof resolving \nstring ar\u00adguments varies greatly between applications. Their analy\u00adsis resolved only 78% of string arguments \nstatically. Fur\u00adthermore, analyzing onlyinter-pagelinksis not suf.cient to discover vulnerabilities caused \nby missing security checks within the samepage.By contrast,the techniquesin thispa\u00adper analyze whole-programcontrol.ow \nofWebapplications and are thus more robust. A promising line of research on .nding security bugs in application \ncode requires the programmer to specify an explicit securitypolicy[3,4,6,27].Fewdeveloperstoday provide \nsuch policies for their Web applications. In this paper, we focus on .nding missing security checks without \nexplicitpolicies. Inferring security policies by static analysis. There are many techniques for (i) inferring \nsecurity policies imple\u00admented by the code, implicitly or with a manual template, and(ii).ndingpolicy \nviolations.Herea policyis a mapping from security-sensitive events to security checks that must precede \nthem. For example, Tan et al. use interprocedural analysis to .nd missing security checks in SELinux \n[23], while Pistoia et al. [12, 17] and Sistla et al. [19] propose techniquesfor .ndingmissingsecuritychecksinJavalibrary \ncode. These papers rely on policy speci.cation and/or as\u00adsume that the samepolicy musthold everywherefor \nevents of agiventype. The problem considered in this paper is signi.cantly harder. In all of the papers \ncited above, the set of security checksis .xed andknowninadvance.Forexample,security checks in the Java \nclass library are calls to methods in the SecurityManager class, thus the correct policy must in\u00adclude \na call to a SecurityManager methodpriorto execut\u00adinga security-sensitive event.Forinstance, networking \ncalls are oftenprotectedby checkConnect calls.Inthis case,the problem ofpolicyinferenceislimited to(i)inferring \nwhich of the SecurityManager methods implement the correct policyfor an event, and(ii) verifying thatthepolicyholds \neverywhere. By contrast,thereis nouniformprotectionparadigmfor application code.The set of security checks \nand relatedpro\u00adgram variables varies from application to application and even from role to role within \nthe same application. There\u00adfore,itis notpossibleto specify,implicitlyor explicitly, uni\u00adversalsecuritymediationrulesthatmustholdfor \nallWeb ap\u00adplications.Figure1showsthreeinstances of security checks fromdifferentPHPapplications.The checkshave \nno syntac\u00adtic similarities, renderingprevious approaches unusable. 1 <?php 2 // Authentication check \n3 if (!defined( IN ADMIN ) || ! defined( IN BLOG )) 4 { 5 header ( Location: admin .php ); 6 exit ; 7 \n} 8 switch ($mode) 9 { 10 case edit : 11 ... 12 // Security-sensiti ve database operation 13 $sql = \nmysql query( UPDATE miniblog SET { $sql} WHERE post id = { $id} ) or die (mysql error ()); 14 ... 15 \n} 16 ?> (a)Miniblog:securitylogicin adm/index.php 1 <?php 2 ... 3 require once( ./ admin .php ) ; \n4 // Authentication check 5 if ( ! isAdmin() ) 6 die ( You are not the admin . ); 7 $page title = Comment \nSuccessfully Deleted ; 8 ... 9 $db = DB connect( $site , $user , $pass); 10 DB select db($database , \n$db); 11 ... 12 // Security-sensiti ve database operation 13 DB query( delete from $tblComments where \nid=$id , $db); 14 ?> (b)Wheatblog:securitylogicin admin/delete comment.php 1 <?php 2 sessi on st art \n(); 3 // Authentication checking routi ne 4 if (!$ SESSION[ member ]) 5 { 6 // not logged in , move \nto login page 7 header ( Location: login .php ) ; 8 e x it ; 9 } 10 include inc / config . php ; 11 \ninclude inc / conn . php ; 12 . . . 13 // Security-s e n s iti v e database operation 14 $q5 = mysql \nquery( INSERT INTO clo s e bid (item name , seller name , bidder name , c lo s e pr ic e ) . $sql5 ); \n15 $del = mysql query( de le te from dn bid where dn name = . $r e s u lt [ dn name ].  ); 16 . . \n. 17 ?> (c)DNscript:securitylogicin accept bid.php Figure1:Examples ofapplication-speci.c securitylogic \n Unlike previous approaches, ROLECAST does not rely ondomain-orapplication-speci.cknowledgeof what a \nse\u00adcurity check is. Instead, ROLECAST uses new static analy\u00adsis algorithms to infer the semantic role \nthat different vari\u00adables play in the program and automatically identify secu\u00adrity checks. It then .nds \nmissing checks using role-speci.c consistency analysis. The idea of analyzing consistency of checks on \ncritical variables was .rst proposed by Son and Shmatikov [20]. In contrast, this paper is the .rst to \n(1)demonstrate the need for role-speci.c analysis because different roles of the same application use \ndifferent secu\u00adrity checksforprotection,(2) design andimplement a new static method for automatically \npartitioning contexts into application-speci.csemantic roles, and(3) exploitthefun\u00addamental asymmetry \nbetween the branches corresponding to, respectively, successfulandfailed security checkstohelp recognizethese \nchecksin application code. Inferring security policies using auxiliary information. Inference and veri.cation \nof security policies implemented byagivenprogram oftenbene.tfrom auxiliaryinformation and speci.cations. \nFor example, Livshits et al. .nd errors by mining software revisionhistories[14].Srivastava et al. use \nindependent implementations of the same Java class libraryAPImethodto .nddiscrepanciesinsecuritypolicies \nbetweenimplementations[22].The approachinthispaper does notrely on any auxiliaryinformation or speci.cation. \nInferringsecuritypoliciesbydynamic analysis. Dynamic analysis can also infer application-and role-speci.c \npoli\u00adcies.Forexample,Felmetsgeretal. collectinvariantsatthe end of each function by dynamically monitoring \nthe appli\u00adcation sbenignbehavior[8].Bond et al.dynamically ana\u00adlyze calling contexts in which security-sensitive \nevents are executedtocreatecall-chain signatures, which they useto detect anomalies[2].Because thereis \nnoguarantee that the set of checks observedduringtest executionsis comprehen\u00adsive, dynamic analysis may \nmiss checks on rarely executed paths.Dynamic andstatic analyses are complementary.The former is more \nprone to false negatives, while the latter is morepronetofalsepositives. 3. SecurityLogicinWebApplications \nWe focus on server-side Web applications, which are typi\u00adcallyimplementedinPHP andJSP, as opposedto client-side \napplications, which aretypicallyimplementedinJavaScript. The latter have their own security issues, but \nare outside the scope of this paper. In this section, we brie.y describe PHP and JSP and explain the \ncommon design patterns for application-and role-speci.c securitylogic. 3.1 PHPandJSP ThePHP(PHP:HypertextPreprocessor) \nscriptinglanguage isdesignedfordynamicallygeneratingWebpages[15].PHP is commonlyusedtoimplementWebapplicationswith \nuser\u00adgenerated content or content stored in back-end databases (as opposedto static HTMLpages).A recent \nsurvey of120 milliondomainsfoundthat59% usePHPtogenerateHTML content[16]. PHP borrows syntaxfromPerl \nandC. InPHPprograms, executable statements responsibleforgenerating content are mixed withXML andHTML \ntags.PHPprovidesbasicdata types, adynamictypingsystem, rich supportfor string oper\u00adations, some object-oriented \nfeatures, and automatic mem\u00adory management withgarbage collection.Instead of a mod\u00adule or class system, \nPHP programs use a .at .le structure with adesignated main entrypoint.Consequently,(1) a net\u00adwork usercandirectlyinvokeanyPHP \n.lebyprovidingits nameaspartoftheURL,and(2) ifthe .lecontainsexe\u00adcutable code outside of function de.nitions, \nthis code will be executed. These two features of PHP require defensive programming of each entrypoint \nand are a source of secu\u00adrity errors.Security analysis ofPHP code must considerthat every .le comprising \nan application is an alternative entry point. JSP (Java Server Pages) is a Java technology for dy\u00adnamically \ngenerating HTML pages [11]. It adds scripting support to Java and mixes Java statements with XML and \nHTMLtags.Scriptingfeaturesincludelibraries ofpagetem\u00adplates andan expressionlanguage.JSPisdynamicallytyped, \nbut because it builds on Java, it has more object-oriented features than PHP. JSP executes in a Java \nVirtual Machine (JVM). Although the languages are quite different, JSP was de\u00adveloped with the same goals \nas PHP. To demonstrate that our approach provides a generic method for analyzing se\u00adcurity ofWeb applications \nregardless of theimplementation language, we applyour analysis tobothJSP andPHP appli\u00adcations.We .ndthatprogrammingpracticesand \napplication security abstractions arequite similarinPHP andJSP appli\u00adcations, and our analysis works \nwell on real-worldprograms implementedin eitherlanguage. 3.2 TranslatingWebApplicationsintoJava TranslatingscriptinglanguagesintoJavaisbecoming \napop\u00adular approachbecauseithelpsimproveperformanceby tak\u00adingadvantage of matureJVM compilers andgarbage \ncollec\u00adtors.We exploitthispracticeby(1) convertingWeb applica\u00adtionsintoJavaclass .les,and(2) extending \ntheSootstatic analysisframeworkforJavaprograms[21] with new algo\u00adrithmsfor static security analysis ofWeb \napplications. To translate JSP and PHP programs into Java class .les we use, respectively,theTomcatWeb \nserver[24] andQuer\u00adcuscompiler[18].Tomcatproduceswell-formedJava;Quer\u00adcusdoesnot.PHPis adynamically typedlanguageand \nthe target of every callsite is potentially bound at runtime. In\u00adstead of analyzing callsin thePHP code,Quercustranslates \neach PHP function into a Java class that contains a main method and methodsthatinitialize theglobalhash \ntable and member variables.Everyfunction callistranslatedbyQuer\u00adcusinto a re.ectivemethodcall or alookupinthehashtable. \nThisprocess obscuresthe callgraph.  Because our security analysis requires a precise call graph, we \nmustreverse-engineerthistranslation.We resolve thetargets ofindirect method callsproducedbyQuercus us\u00ading \na .ow-and context-insensitive intraprocedural symbol propagation.This analysisisdescribedin the appendix. \n 3.3 Application-Speci.cSecurityLogic Our security analysis targets interactive Web applications such \nasblogs, e-commerceprograms, and user content man\u00adagement systems. Interactive applications of this type \ncon\u00adstitute the overwhelming majority of real-world Web ap\u00adplications. Since the main purpose of these \napplications is to display, manage, and/or update information stored in a back-enddatabase(s), access \ncontrolondatabase operations is criticalto theintegrity of the application s state. Security-sensitive \nevents. We consider all operations that may affect the integrity of database to be security-sensitive \nevents.Theseincludeallqueriesthat insert, delete, or update thedatabase.Web applicationstypically useSQL \ntointeract with the back-end database. Therefore, ROLECAST marks INSERT,DELETE, andUPDATEmysql query \nstatements inPHPcode as security-sensitive events.Notethat statically determiningthetype ofaSQLqueryin \nagiven statement re\u00adquires program analysis. ROLECAST conservatively marks all statically unresolved \nSQL queries as sensitive. For JSP, ROLECAST marks java.sql.Statement.executeQuery and .executeUpdate \ncalls executing INSERT, DELETE, orUPDATESQLqueries as security-sensitive events. We deliberately do not \ninclude SELECT and SHOW queries which retrieve information from the database in our de.nition of security-sensitive \nevents. Many Web ap\u00adplications intend certain SELECT operations to be reach\u00adable without any prior access-control \nchecks. For example, during authentication, a SELECT statement may retrieve a stored password from the \ndatabase in order to compare it withthepasswordtypedbythe user.Without aprogrammer\u00adprovided annotation \nor speci.cation, it is not possible to separateSELECT operations that need tobeprotectedfrom those that \nmaybelegitimately accessed without any checks. To avoidgenerating aprohibitive number offalsepositives, \nwe omitSELECT andSHOW operationsfromouranalysis ofWeb applications securitylogic. Examples of security \nlogic. Figure 1 shows the security logic of three sample Web applications: Miniblog, Wheat\u00adblog, and \nDNscript. DNscript is a trading application for sellers and buyers of domain names. Figure 1(a) shows \na security-sensitive event on line 13. This database operation is only executedif IN ADMIN and IN BLOG \narede.ned(line 3), otherwise the program exits immediately. Figure 1(b) shows a security-sensitive event \non line 10. It is executed only when the return value of isAdmin() is true; other\u00adwise theprogram exitsby \nexecutingthe die command.Fig\u00adure1(c) shows two security-sensitive events(lines14 and 15).They are executed \nonlyif the userisloggedin and the session authentication .agin $ SESSION[ member ] is set. By studying \nthese and other examples, wefound several ro\u00adbustdesignpatternsfor securitylogic.Thesepatternsguide our \nanalysis.   Figure2:File structure ofDNscript Security logic as a software design pattern. To identify \napplication-and role-speci.c securitylogic, we take advan\u00adtage ofthe software engineeringpatterns commonlyusedby \nthedevelopers ofWeb applications.AWeb application typ\u00adically produces multiple HTML pages and generates \neach page by invoking code from several .les. The following three observationsguide our analysis. Our \n.rst observation about security logic is that when a security check fails, the program quickly terminates \nor restarts. Intuitively, when a user does not hold the appro\u00adpriatepermissions orhis credentialsdo notpass \nveri.cation, theprogram exitsquickly. Our second observation about correct security logic is thateverypathleadingto \na security-sensitive eventfrom any program entrypointmust contain a security check.This ob\u00adservation \nalone,however,is not suf.cient toidentify checks in application codebecausedifferentpaths mayinvolvedif\u00adferentchecks \nanddifferentprogram variables. Our third observationis that distinct application-speci.c rolesusuallyinvolvedifferentprogram \n.les.Since the main purpose of interactive Web applications is to manage user\u00adspeci.c content andtoprovide \nservicesto users, users priv\u00adileges and semantic roles determine the services that are availabletothem.Therefore,theapplication \ns .lestructure, which in Web applications represents the module structure, re.ectsa cleardistinctionbetweenrolesde.nedbythe \nuser s privileges. For instance, blog applications typically include administrator pages that modify \ncontent and register new userpro.les.Onthe otherhand, regularblog users may only read other users content, \nadd comments, and update their own content.Intheory,developerscould structuretheir ap\u00adplications sothatone \n.lehandles multiple user roles,butthis is not the casein real-worldapplications.  IntheWebapplicationsthatwe \nexamined,individualpro\u00adgram .les containedonly code speci.c to a single user role. Figure2shows a representative \nexample with a simplepage structure taken from the DNscript application. DNscript supports two types \nof users: an administrator and a regular user.All administratorcodeandpagesareinoneset of.les, whileall \nusercodeandpagesareinadifferent set of.les. Our analysis exploitsthe observationthatsecurity checks within \neach role are usually very similar.Inferring the roles requires automatic partitioning of contexts based \non com\u00admonalitiesintheirsecuritylogic.Thiscomponentisthe most challengingpart of our analysis.  3.4 \nExampleVulnerability Becauseeveryapplication .leisalsoaprogramentrypoint, PHP andJSPdevelopers must replicate \nthe application s se\u00adcuritylogicinevery.le.Inparticular,evenif thecodecon\u00adtained in some .le is intended \nto be called only from other .les,it must stillbeprogrammeddefensivelybecause a user may invoke it directly \nvia its URL. Adding these security checksis a repetitive, error-pronetask and a common cause of missing-check \nvulnerabilities. Figure 3 shows an example of a security vulnerability due to a missing check on a path \nfrom an unintended pro\u00adgram entry point. The intended entry point index.php cor\u00adrectly checks permissions \nfor security-sensitive database operations. However, a malicious user can directly invoke delete post.phpbysupplyingitsURL \nto theWeb server and execute a DELETE query because delete post.php is miss\u00ading a check on the $ SESSION \nvariable. In complex appli\u00adcations,the number of unintended entrypoints canbe very large.Thisgreatlycomplicates \nmanualinspection and moti\u00advates the needfor automated analysis. 4. AnalysisOverview ROLECAST hasfour \nanalysisphases.PhaseIidenti.es crit\u00adical variables that control whether security-sensitive events execute \nor not. Phase II partitions contexts into groups that approximate application-speci.c user roles. For \neach role, Phase III computes the subset of critical variables respon\u00adsible for enforcing the security \nlogic of that role. Phase IV discovers missing security checks by verifying whether the relevant variables \nare checked consistently within the role. To identify critical variables, Phase I performs interpro\u00adcedural, \n.ow-and context-sensitivecontrol-dependenceand data-.ow analysis. It re.nes the set of critical variables \nus\u00ading branch asymmetry,based onthe observationthatfailed authorization checksquickly lead to program \nexit. To infer application roles, Phase II maps the set of methods respon\u00adsiblefor checking critical \nvariablestoprogram .les andpar\u00adtitions them into groups, minimizing the number of shared .les between \ngroups. This algorithm seeks to discover the  index.php 1 // Security check 2 if (!$ SESSION[ logged \nin ]) 3 { 4 doLogin() ; 5 die; 6 } 7 if( isset($ GET[ action ])) 8 $action =$GET[ action ]; 9 switch( \n$action ){ 10 case delete  post : 11 include delete post .php ; 12 break; 13 case update   post : \n14 include update   post .php ; 15 break;  16 ..... 17 default: 18 include default .php ;  19 } \ndelete post.php 1 // No security check 2 if (isset ($ GET[ post id ])) 3 $post id =$ GET[ post id ]; \n4 DBConnect() ; 5 // Security-sensiti ve event 6 $sql= DELETEFROMblogdata WHEREpost id=$post  id ; 7 \n$ret= mysql query($sql) or die ( Cannot query the database.<br> ); 8Ln6: ..... update post.php 1 // \nSecurity check 2 if (!$ SESSION[ logged  in ]) die ; 3 if (isset ($ GET[ post   id ])) 4 $post id \n= $GET[ post id ]; 5 if (isset ($ GET[ content ])) 6 $content =$ GET[ content ]; 7 DBConnect() ;  8 \n// Security-sensiti ve event 9 $sql = UPDATE table post SET cont=$content WHERE id = $post id ; 10 $ret= \nmysql query($sql) or die ( Cannot query the database.<br> ); 11 .... Figure3:Example ofa missing security \ncheck popularprogram structurein whichdevelopersput the code responsiblefordifferent application rolesintodifferent.les. \nThisheuristicis thekeynew component of our analysis and works wellinpractice. Phase III considers each \nrole and computes the subset of critical variables that are used consistently that is, in a suf.ciently \nlarge fraction of contexts associated with this role to control reachability of security-sensitive events \nin that role. The threshold is a parameter of the system. PhaseIV reportsapotential vulnerability wheneverit \n.nds a security-sensitive eventthat canbe reached without check\u00ading the security-critical variablesspeci.ctotherole.It \nalso reports all roles that involve a single context and thus pre\u00adclude consistency analysis,but this \ncaseis relatively rare.  5. PhaseI:FindingSecurity-SensitiveEvents, CallingContexts, andCriticalVariables \nOur algorithmforidentifyingsecuritylogic takes advantage of thefollowing observations: 1. Any security \ncheck involves a branch statement on one or more critical variables. 2. In thebranch correspondingto \nthefailed check, thepro\u00adgramdoes notreachthe security-sensitiveevent and exits abnormally. For example, \nthe program calls exit, calls die, or returnsto theinitialpage. 3. Thenumberofprogramstatementsinthebranchfromthe \ncheck to the abnormal exit is signi.cantly smaller than the number ofprogram statementsin thebranchleading \nto the security-sensitive event. 4. Correct security logic must consistently check a certain subset \nof critical variables prior to executing security\u00adsensitive events.  This sectiondescribes our algorithmsthat,for \neachsecurity\u00adsensitive event, statically compute the following: calling contexts, criticalbranches(i.e., \nconditional statements that determine whether or not the security-sensitive event exe\u00adcutes), critical \nmethods(i.e., methods that contain critical branches), and critical variables (i.e., variables referenced \nbycriticalbranches). Our analysisisfairlycoarse.It only computes which vari\u00adables are checkedpriorto \nsecurity-sensitiveevents,but not howthey are checked.Therefore, ROLECAST will miss vul\u00adnerabilities causedby \nincorrectlyimplemented(as opposed to entirely missing) checks on the right variables. 5.1 Security-SensitiveEventsandCallingContexts \n Our analysis starts by identifying security-sensitive opera\u00adtions that may affect the integrity of the \ndatabase. A typ\u00adical Web application speci.es database operations using a string parameter passed to \na generic SQL query state\u00adment. We identify all calls to mysql query in PHP and java.sql.Statement.executeQuery \nand java.sql.\u00adStatement.executeUpdate inJSPas candidatesforsecurity\u00adsensitive events.The same call,however,mayexecutediffer\u00adentdatabaseoperationsdepending \nonthe valueofitsstring parameter. Therefore, we perform an imprecise context\u00adsensitive data-.ow analysis \nto resolve the string arguments of database calls and eliminate all database operations that do notmodifythedatabase(seeSection3.3)from \nour set of security-sensitive events. ROLECAST computes the set of all calling contexts for each security-sensitive \nevent e. ROLECAST identi.es the methods that may directly invoke e, then performs a back\u00adward depth-.rst \npass from each such method over the call  Figure 4: Architecture of ROLECAST. graph.(The callgraphconstruction \nalgorithmisdescribedin the appendix.)The analysisbuilds atree of contextswhose rootis e andwhoseleaves \nareprogramentrypoints.For each calling context cc correspondingto a call-chainpathfrom e to aleaf,the \n(cc,e) pairis addedtothe setof all calling con\u00adtexts.This analysis records eachinvoked method only once \nper calling context, even in the presence of cyclic contexts. This is suf.cient for determining whether \nor not a security checkispresentin the context. Next, ROLECAST propagates the strings passed as pa\u00adrametersin \neach calling context cc to the candidate event e. Thegoalisto eliminate allpairs (cc,e) where we can \nstat\u00adicallyprove that e cannot be a security-sensitive event, i.e., none of the staticallyfeasibledatabase \noperations at e affect the integrity of the database because they can only execute SELECTorSHOWqueries. \n We .ndthatmanyWebapplicationsgenerateSQLqueries by assigning a seed string constant to a variable and \nthen concatenating additional string constants. The seed string usually identi.es the type of the SQL \nquery (UPDATE, SELECT, etc.). Therefore, ROLECAST models string con\u00adcatenation, assignment of strings, \nand thebehavior of string get() and set() methods. It performs forward, interpro\u00adcedural, context-sensitive \nconstantpropagation onthe string argumentsfor each callingcontext cc ofevent e. ROLECAST does notmodelthe \nvalue of strings returnedby method calls notinthe calling context.If thestringispassed asanargu\u00adment \nto some method m ./cc, we conservatively assume thatthestringismodi.ed andROLECAST marksevent e as security-sensitive.Otherwise, \nthe analysispropagates string values of actual argumentstotheformalparametersof meth\u00adods. If this analysis \nproves that e is a SELECT or SHOW query, then ROLECAST removes the (cc,e) from the set of calling contexts. \nThe unresolved column in Table 1, explainedin moredetailinSection9, shows thatfewer than 5% of query \ntypes are unresolved, while for at least 95% of all database operations in our sample Web applications, \nROLECAST successfully resolves whether or not they are sensitive, i.e., whether they can affect the integrity \nof the database.  5.2 CriticalBranchesandCriticalMethods For each calling context and security-sensitive \nevent pair (cc,e), ROLECAST performs an interprocedural control\u00addependence analysis to .nd the critical \nbranches B(cc,e) performedinthecritical methods CM(cc,e).Thesebranches determine whether or note executes.A \ncritical method con\u00adtains one or more criticalbranches on which e isinterproce\u00addurally control dependent. \nNote that some critical methods are in cc and some are not. For the reader s convenience, we review the \nclassicalintraproceduralde.nition of control dependence[5]. DEFINITION 1. If G =(N,E) is a control-.ow \ngraph (CFG) and s,b . N, b . s iff there exists at least one pathreachingfrom bto s in G. DEFINITION \n2. If G =(N,E) is a control-.ow graph (CFG)and s,b . N, s is controldependent onbiff b . s and s post-dominates \nall v= b on b . s, and s does not post-dominateb. The setofbranchstatements onwhich e is controldependent \nis computedin two steps. 1. ROLECAST uses intraprocedural control dependence to identifybranch statementsin \nmethodsfrom cc that con\u00adtrol whether e executes or not.For each method mi . cc where mi calls mi+1, the \nalgorithm .nds branch state\u00adments on whichthe callsite of mi+1 is controldependent and adds them to B(cc,e). \n2. ROLECAST then considers the set of methods N such that the callsite of ni . N dominates some method \nm . cc or ni is called unconditionally from nj . N. Because every method ni . N is invoked before reaching \ne, ni interprocedurally dominates e. For each ni . N, ROLECAST .nds branch statements on which theprogram-exitcallsinni \n(ifany)are controldependent and adds them to B(cc,e). Next, ROLECAST eliminates statements from B that \ndo not match our observationthatfailed security checksinWeb applications terminate or restart the program \nquickly. To .nd branch statements in which one branch exits quickly whilethe other executes many more \nstatements, ROLECAST calculatesthe asymmetric ratio for eachb . B asfollows. ROLECAST counts the number \nof statements in, respec\u00adtively, the shortest path reaching program termination and the shortestpath \nreaching e.Each statementin aloop counts as one statement. The asymmetric ratio is the latter count dividedby \ntheformer.Thelarger the value, the more asym\u00admetric the branches are. If the calculated asymmetric ratio \nfor b is less than the threshold .asymm , we remove b from B becausebdoes nothave abranchthatcauses theprogram \nto exit quickly and thus is not likely to be security-critical. Our experiments use 100 as the default \n.asymm threshold when the calculated ratiofor one or morebranch statements is greater than 100; otherwise, \nwe use the median ratio of allbranch statements.AsTable3 shows,the resultsare not very sensitive to the \ndefault value. In our sample applica\u00adtions,applyingthedefault .lterreducesthenumberof criti\u00adcalbranchesby36% \nto83%(54% on average). After this step, the set B(cc,e) contains critical branch statements. We map B(cc,e) \nto the set of critical methods CM(cc,e) thatcontain one or morebranchesfrom B(cc,e). Recallthatsome critical \nmethods arein cc and some are not. Critical methods are a superset of the methods responsible forimplementingthe \napplication s securitylogic.  5.3 CriticalVariables Informally, a program variable is critical if its \nvalue de\u00adtermines whether or not some security-sensitive event is reached. All security-critical variables \ninvolved in the pro\u00adgram s security logic (e.g., variables holding user permis\u00adsions, session state, \netc.)are critical, but the reverse is not always true: critical variables are a superset of security\u00adcritical \nvariables.Wederivethe set of critical variablesfrom the variables referenceddirectly orindirectlyby the \ncritical branchesB(cc,e).Section8further re.nesthe set of critical variablesinto the set of security-critical \nvariables. Given B(cc,e), we compute the set of critical variables V(cc,e) where v . V iff .b . B that \nreferences v directly orindirectlythrough anintraproceduraldata-.ow chain.We use a simple reachingde.nitions \nalgorithmto computeindi\u00adrectreferenceswithina method.We computethebackward intraproceduraldata-.ow slice \nofv for allv referencedby b. Thusifbreferences v and v dependsonu (e.g.,v = foo(u)), we add v and u to \nV.  Wefoundthatintraprocedural analysis was suf.cientfor our applications,but more sophisticated and \nobject-oriented applications may requireinterprocedural slicing. 6. PhaseII:PartitioningIntoRoles This \nsection describes how ROLECAST partitions applica\u00adtionsinto roles.We use rolepartitioningto answertheques\u00adtion: \nWhich critical variablesshouldbecheckedbeforein\u00advoking a security-sensitive event e in a given calling \ncon\u00adtext? Without role partitioning, critical variables are not very usefulbecausethere are alotofthem \nandtheyare notalways checked before every security-sensitive event. Reporting a vulnerability whenever \nsome critical variableis checkedin\u00adconsistently resultsin many falsepositives(seeSection9). Role partitioning \nexploits the observation made in Sec\u00adtion3.3 thatWeb applications are organized arounddistinct user roles(e.g., \nadministrator and regular user).We notethat (1)applicationsplace the code thatgeneratespagesfordif\u00adferentrolesintodifferent.les,and,furthermore,(2)the \n.les containingthesecuritylogicforagivenrolearedistinctfrom the .les containing the security logic for \nother roles. These observations motivate an approach that focuses on .nding sets of (cc,e) in which the \ncritical methods CM(cc,e) use the same .les to enforcetheir securitylogic. ROLECAST startsby coarseningitsprogramrepresenta\u00adtionfrommethodsandcalling \ncontextsto .les.Thisanalysis maps each set of critical methods CM(cc,e) to a set we call the critical-.le \ncontext CF.A .le cf . CF(cc,e) if cf de\u00ad.nes any method m . CM(cc,e). We also de.ne the .le context F(cc,e).A.le \nf . F(cc,e) iff de.nes anymethod m which interprocedurally dominates e. F is a superset of CF some .lesin \nF(cc,e) are criticalandsome arenot.We refer to the set of all .le contexts F of all security-sensitive \nevents in the program as FFand to the set of all critical-.le C contexts CF as CF. Since we do not know \na priori which .le corresponds to which application role, our algorithm generates candi\u00addate partitions \nof C CF and picks the one that minimizes the number of shared .les between roles. The goal is to group \nsimilar critical-.le contexts into the same element of the partition. We consider two critical-.le contexts \nsimilar if they share critical .les. To generate a candidate partition, the algorithm chooses a seed \ncritical .le cf1 and puts all critical-.le contexts from Cinto the CF that reference cf1 samegroup,choosesanothercritical.le \ncf2 andputsthe re\u00admaining critical-.le contextsfrom C CF that contain cf2 into anothergroup, and so on.The \nresultingpartitiondepends on the order in which seed critical .les are chosen. Our algo\u00adrithm explores \nall orders, but only considers frequently oc\u00adcurring critical.les.Inpractice,thenumberof such .lesis \nsmall, thusgenerating candidatepartitionsbased on allpos\u00adsibleorderingsof seed.lesisfeasible. To choose \nthe best partition from the candidates, our algorithm evaluates how well the candidates separate the \nmore general .le contexts FF. The insight here is that since programmers organize the entire application \nby roles (not justtheparts responsibleforthe securitylogic),the correct partition ofsecurity-related.le \ncontexts should alsoprovide agoodpartitionof all .lecontexts.ROLECAST thusprefers the partition in which \nthe groups are most self-contained, i.e.,donot referencemany.lesusedby othergroups. Moreformally, ROLECAST \nspartitioning algorithm con\u00adsistsofthefollowing.vesteps. 1. For each CM(cc,e), compute the critical-.le \ncontext CF(cc,e) and.le context F(cc,e). 2.Eliminatecritical .lesthatarecommontoall CF(cc,e), i.e.,if \n.le f belongs to the critical-.le context cf for all cf . CCF.Since CF, then remove f from all contextsin \nCthese .les occur in every critical-.le context, they will nothelpdifferentiate roles. 3. Extract a set \nof seed .les (SD) from C CF. We put .le f into SD if it occurs in at least the .seed fraction of critical-.lecontexts \ncf . C CF.Inourexperiments,we set .seed =0.2.We use only relatively common critical.les as the seeds \nof the partitioning algorithm, which helps makethefollowing steps more ef.cient. 4. Generate all ordered \npermutations SDi. For each SDi, generateapartitionPi = {G1,...Gk}of C CF asfollows. Let SDi = {f1,...fnTF \n= CF and set k =1. }. Let CC For i = n,let Ci . C 1 to TF be the set of all critical-.le contextsfrom \nC TF containing .le fi. If Ci is not empty, remove these contextsfrom C TF, add them togroup Gk, andincrement \nk. 5. Given candidate partitions, choose the one that mini\u00admizes the overlap between .les from different \ngroups. Our algorithm evaluates each candidate {G1,...Gk}as follows.First,for eachgroupof critical-.le \ncontexts Gj, take the corresponding set of .le contexts Fj. Then, for each pair Fk,Fl where k = l, calculate \nthe number of .les they have in common: |Fk n Fl|. The algorithm l choosesthepartition with the smallest \n|Fk nFl|. k<l Figure 5 gives an example of the partitioning process. At the top, we show .ve initial \n.le contexts and critical-.le contextsproducedbyStep 1.Step2 removesthe .lescom\u00admonto all critical-.le \ncontexts, common.phpinthis exam\u00adple, producing three .les, process.php, user.php and ad\u00admin.php. Step \n3 selects these three .les as the seed .les, because they appear in 1/5, 3/5, and 2/5 of all critical-.le \ncontexts, respectively. There are 6 permutations of this set, thusStep4produces6 candidatepartitions.InFigure5, \nwe compare two of them: (admin.php, user.php, process.php)  Figure5:Example ofpartitioningcontexts \nand (process.php, admin.php, user.php). The correspond\u00ading candidates are P1 = {(A,C),(B,D,E)} and P2 \n= {(B),(A,C),(D,E)}. To decide which one best approx\u00adimates user roles, Step 5 computes the intersection \nof .le contextsbetweeneverypairofgroupsin eachpartitionand selects thepartition withthe smallestintersection.In \nour ex\u00adample, since P1 hasthefewest .les(one)intheintersection, ROLECAST choosesit as thebestpartition. \nThe accuracy of the partitioning step depends on using goodseed.les.Weselect .lesthat containcritical \nvariables and appear in many critical-.le contexts, based on our ob\u00adservation that Web applications use \ncommon security logic in most contexts that belong to the same role. One concern is that exploring all \npermutations of the seed-.le set is ex\u00adponentialinthenumberof seed .les.Theselectioncriteria for seed \n.les are fairly stringent, and therefore their actual number tends tobe small. It never exceededfourin \nour ex\u00adperiments.Ifthenumberof seed.lesgrowslarge,theparti\u00adtioning algorithm could explorefewer options.For \nexample, Algorithm1:Partitioning.lecontextsintoroles P . f{ initializepartition candidate set} n .|SD|{ \nget the size ofSD } for each SDi . npermutation of SD do d TF . d CF { initializeworklist with all critical-.le \ncontexts } k . 1 for each fj . SDi do { putall critical-.le context that contain seed.le fj into Gk } \nfor each CF . d TF do if fj . CF then Gk . Gk . CF d TF . dTF -{CF} endif endfor if Gk is not empty \nthen k . k +1 { increment thegroupindex } endif if d TF is empty then break{ if worklistis empty, thenbreak \n} endif endfor Pi .{G1 . . .Gk }{ store the currentgroupsinto Pi } DSi . 0 { computethenumberof common \n.lesamong allpairsin Gi } for eachpair (Ga,Gb)a<b from {G1 . . .Gk } do Fa = the .lecontextscorresponding \ntocritical-.lecontextsin Ga Fb = the .lecontextscorresponding tocritical-.lecontextsin Gb DSi . DSi + \n|Fa n Fb | endfor P . P .{Pi }{ add the currentpartition to the candidatelist } for x =1 to k do Gx . \nf{ resetgroupsfor the next candidate SDi+1 } endfor endfor Pick thebest Pi . P thathas a minimum DSi \nit couldprioritizebyhowoftena seed .le occursinthe .le contexts. 7. PhaseIII:FindingSecurity-Critical \nVariables The groups in the partition computed by Phase II approxi\u00admate semantic user rolesinthe application.PhaseIII \ncom\u00adputes thesecurity-critical variables for eachrole: the subset ofthe critical variablesthat enforcethe \nrole s securitylogic. We assume that the application correctly checks the security-critical variables \nin at least some fraction of the critical-.le contexts and use this observation to separate security-critical \nvariables from the rest of the critical vari\u00adables. Recall that there is a one-to-one mapping between \neach critical-.le context CF(cc,e) and the set of its criti\u00adcal variables V(cc,e). Given thepartition \n{G1,...,Gk}of C CF,let Vi bethe setof all critical variablesfromthe critical\u00ad.le contexts in Gi. We initialize \nthe set of security-critical variables SVi = Vi. ROLECAST then removes all variables v . SVi that appear \nin fewer than a .consistent fraction of the critical-.le contexts in Gi. We use .consistent = 0.5 as \nourdefault.Table5 shows that our results are not very sen\u00adsitive to thisparameter.Wede.ne the remaining \nsubset SVi tobe the security-critical variablesfor role i.   DB operations (|contexts|) critical branches \nWeb applications LoC Java LoC analysis time candidates sensitive unresolved candidates asymm minibloggie1.1 \nDNscript mybloggie1.0.0 FreeWebShop2.2.9 Wheatblog1.1 phpnews1.3.0 Blog199j1.9.9 eBlog1.7 kaibb1.0.2 \nJsForum(JSP)0.1 JSPblog(JSP)0.2  2287 5395 47 sec 13 3 0 3150 11186 47 sec 99 26 0 8874 26958 74 min \n195 26 0 8613 28406 110 min 699 175 0 4032 11959 2 min 111 30 0 6037 13086 166 min 80 14 3 8627 18749 \n75 min 195 68 2 13862 24361 410 min 677 261 0 4542 21062 197 min 676 160 0 4242 4242 52 sec 60 32 0 \n987 987 16 sec 63 0 Table1:Benchmarks andanalysis characterization 12 7 27 5 135 58 186 82 31 20 65 \n15 104 54 136 17 306 152 61 00 8. PhaseIV:Finding MissingSecurity Checks Thisphase reports vulnerabilities.Within \neach role, all con\u00adtexts should consistently check the same security-critical variablesbeforeperforminga \nsecurity-sensitiveevent e.For\u00admally,given sv . SVi, ROLECAST examines every (cc,e) in thegroupof contexts \ncorrespondingto role i and veri.es whether sv . V(cc,e) or not.If sv /. V(cc,e), ROLECAST reports apotentialsecurity \nvulnerability.Tohelpdevelopers, ROLECAST also reportsthe .le(s)that containsthe security\u00adsensitive event \ne forthe vulnerable(cc,e). ROLECAST reports a potential security vulnerability in two additional cases: \n(1) for each .le that executes a security-sensitive event anddoes not check any critical vari\u00adables whatsoever, \nand(2)for each singleton critical-.le con\u00adtext(i.e., a role with only one critical-.le context).Because \nthereis nothing with which to compare this context, ROLE-CAST cannot apply consistency analysis and conservatively \nsignals apotential vulnerability. 9. ExperimentalEvaluation We evaluatedROLECAST by applyingittoa representative \nset of open-source PHP and JSP applications. All experi\u00adments in this section were performed on a Pentium(R) \nD 3GHZwith2G ofRAM. Table 1 shows the benchmarks, lines of original source code, lines of Java source \ncode produced by translation, and analysis time. We have not tuned our analysis for per\u00adformance. For \nexample, we unnecessarily re-analyze every context, even if we have analyzed a similar context be\u00adfore. \nMemoizing analysis results and other optimizations are likely to reduce analysis time. The three columns \nin the middle of the table show the number of contexts for alldatabase operations(candidate security-sensitive \nevents), operations that can affect the integrity of the database (security-sensitive events), and database \noperations whose type could notbe resolvedby our analysis.Comparingthese three columns shows that our \nstringpropagationis effective at resolving the type of database operations and rarely has to assume an \noperationis security-sensitivebecauseit could not resolve the string argument determining its type. The \nlast two columns show the number of critical branch state\u00adments before and after eliminating statements \nthat are not suf.ciently asymmetric. Table 2 shows the results of applying ROLECAST to our benchmarks. \nAs described in Section 6, ROLECAST par\u00adtitions calling contexts containing security-sensitive events \ninto groups approximating application-speci.c user roles. For each role, ROLECAST .nds critical variables \nthat are checked in at least the .consistency fraction of the contexts inthis role.If such a critical \nvariableis not checkedin one of the contexts, ROLECAST reports a potential vulnerabil\u00adity. ROLECAST also \nreports a potential vulnerability if a security-sensitive event is reachable without any checks at all. \nWe examined each report by hand and classi.ed it as a falsepositive or realvulnerability. Note the importance \nof role partitioning in Table 2 for reducing the number of false positives. Without role parti\u00adtioning, \na conservative analysis might assume that critical variables shouldbe checked consistentlyin allprogram \ncon\u00adtexts.All contexts associated with rolesthatdo not require a particular securitycheck wouldthen resultinfalsepositives. \nThe number of false positives after role-speci.c consis\u00adtency analysis is very small. There are several \nreasons for the remaining false positives. First, if a role contains only one context, ROLECAST cannot \napply consistency analysis and conservatively reports apotential vulnerability.Second, aWeb application \nmay use a special set of critical variables onlyfor a smallfraction of contexts(this caseis rare).Con\u00adsider \nFigure 7. Both the post2() method call on Line 11 inindex.phpand the fullNews() method call onLine4in \nnews.php contain security-sensitive events.A largefraction ofcallingcontextsuse $auth variableto enforce \naccess con\u00adtrol(Line10in auth.php).Onthe otherhand, a smallfrac\u00adtion of contexts leading to the sensitive \ndatabase operation  Web applications minibloggie1.1 DNscript mybloggie2.1.6 FreeWebShop2.2.9 Wheatblog1.1 \nphpnews1.3.0 Blog199j1.9.9 eBlog1.7 kaibb1.0.2 JsForum(JSP)0.1 JSPblog(JSP)0.2 totals false positives \nno roles no roles auth. vuln. 0 0 0 1 1 5 0 3 0 0 0 1 0 1 0 0 1 0 1 0 1 12 0 0 0 1 0 0 0 4 2 0 0 11 1 \n0 0 0 0 5 0 0 0 3 3 34 413 Table2:Accuracy(.consistency = .5).Notethereductionin falsepositivesdue to \nrolepartitioning. infullNews use only $Settings (Line9in news.php).Be\u00adcause ROLECAST decidesthat$auth \nisthe variable respon\u00adsiblefor security enforcementdue toits consistentpresence inthe contexts ofsecurity-sensitiveevents,itdecidesthatthe \nfew contexts that only use $Settings are missing aproper security check. Table2distinguishesbetween twokinds \nof unauthorized database operations. Some database updates may be rela\u00adtivelyharmless,e.g.,updatingcounters.Nevertheless,ifsuch \nan update is executed without a security check, it still en\u00adables a malicious user to subvert the intended \nsemantics of the application.Therefore, wedo not consider such updates as false positives and count them \nin the 3rd column of Ta\u00adble2,labeled no auth. .The4thcolumnofTable2,labeled vuln., reportsdatabase updatesthat \nallow a malicious user to store contentintothedatabase withoutan access-control check.Because these vulnerabilities \nareboth severe and re\u00admotely exploitable, we noti.ed the authors of all affected applications. Figure \n6 shows two .les from DNscript that ROLE-CAST reports as vulnerable. Neither .le contains any se\u00adcurity \nchecks,thus a malicious user can alter the contents of the back-end database by sending an HTTP request \nwith the name of either .le as part of the URL. ROLECAST reports that the security-sensitive events in \nDelCB.php and admin/AddCat2.php should be protected by check\u00ading$ SESSION[ member ] and $ SESSION[ admin \n],re\u00adspectively. Our analysis usesthreethresholds:thebranchasymmetry threshold .asymm,thecommonality \nthresholdforseed .les .seed, andthe consistencythresholdforsecurity-criticalvari\u00adables .consistency.Tables3 \nthrough5 showthat the analysis is notvery sensitive to these values. Web applications minibloggie1.1 \nDNscript mybloggie1.0.0 FreeWebShop2.2.9 Wheatblog1.1 phpnews1.3.0 Blog199j1.9.9 eBlog1.7 kaibb1.0.2 \nJsForum(JSP)0.1 JSPblog(JSP)0.2 .asymm 25 50 100 150 200 vl fp vl fp vl fp vl fp vl fp 1 0 1 0 1 0 1 \n0 1 0 3 1 3 1 3 1 3 1 3 1 1 0 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 0 1 0 1 0 1 \n0 1 0 2 0 1 0 0 0 0 0 0 2 0 2 0 2 0 2 0 1 0 1 0 1 0 1 0 1 0 1 0 3 0 3 0 3 0 3 0 3 0 5 0 5 0 5 0 5 0 5 \n0 Table3:Sensitivity ofactual vulnerabilities(vl) and false positives(fp)to .asymm Web applications \nminibloggie1.1 DNscript mybloggie 1.0.0 FreeWebShop2.2.9 Wheatblog1.1 phpnews 1.3.0 Blog199j1.9.9 eBlog1.7 \nkaibb1.0.2 JsForum(JSP)0.1 JSPblog(JSP)0.2 .seed 0.2 0.3 0.4 0.5 0.6 vl fp vl fp vl fp vl fp vl fp 1 \n0 1 0 1 0 1 0 1 0 3 1 3 1 3 2 3 1 3 1 1 0 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 1 \n0 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 2 0 2 0 2 0 2 0 2 0 1 0 1 0 1 0 1 0 1 11 3 0 3 0 3 0 3 0 3 0 5 0 \n5 0 5 0 5 0 5 0 Table4:Sensitivity ofactual vulnerabilities(vl) and false positives(fp)to .seed Web \napplications minibloggie1.1 DNscript mybloggie1.0.0 FreeWebShop2.2.9 Wheatblog1.1 phpnews1.3.0 Blog199j1.9.9 \neBlog1.7 kaibb1.0.2 JsForum(JSP)0.1 JSPblog(JSP)0.2 .consistency 0.5 0.6 0.7 0.8 0.9 vl fp vl fp vl fp \nvl fp vl fp 1 0 1 0 1 0 1 0 1 0 3 1 3 1 3 1 3 0 0 0 1 0 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 \n1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 2 0 2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 3 0 3 0 3 0 \n3 0 3 0 5 0 5 0 5 0 5 0 5 0 Table3 shows the sensitivity of our results to thebranch Table5:Sensitivity \nofactual vulnerabilities(vl) and false asymmetry threshold .asymm as it varies between 25 and positives(fp) \nto .consistency 200. The default value is 100. With .asymm values smaller  admin/AddCat2.php index.php \n1 <?php 2 // No s e c u r ity check . It should have been checked with $ SESSION[ admin ] 3 include \n inc / config . php ; 4 include inc / conn . php ; 5 $values = VALUES (  . $ POST[ cat name ]. \n ) ; 6 // Security-s e n s iti v e event 7 $in s e r t = mysql query( INSERT INTO gen cat ( cat name \n) . $values ) ; 8 if ($in s e r t ) 9 { 10 mysql close ($conn ) ; 11 . . . 12 } 13 14 ?> DelCB.php \n1 <?php 2 // No s e c u r ity check . It should have been checked with $ SESSION[ member ] 3 include \n inc / config . php ; 4 include inc / conn . php ; 5 // Security-s e n s iti v e event 6 $de le te \n= mysql query( DELETE FROM c lo s e bid where item name =  . $item name .  ); 7 if ($de le te ) 8 \n{ 9 mysql close ($conn ) ; 10 . . . 11 } 12 ?> Figure6:Detectedvulnerable .lesinDNscript than100, ROLECAST \nanalyzes morebranches, more critical methods,and morecritical variables,but still .ndsthesame vulnerabilities, \nalthough with two morefalsepositives when .asymm =25. Table 4 shows the sensitivity of our results to \nthe value of the seed threshold .seed used to generate role partitions. Thedefault valueis 0.2.For kaibb, \nwhen .seed is toolarge, ROLECAST may exclude seed .les that actually play an importantroleinpartitioningthe \napplicationinto roles.Note that the results for DNscript do not change monotonically with the value of \n.seed.When .seed = .2 or .3, ROLECAST .nds three seed .les. Two of them correspond to actual user roles(administrator \nand regular user) andROLECAST produces the correct partition. When .seed = .4, there are only two seed \n.les, one of which corresponds to the user role,whiletheotherproducesaspurious role with asingle context, \nresulting in a false positive. When .seed = .5 or .6, ROLECAST .nds a single seed .le, which corresponds \nto the administrator role. The resulting partition has two groups contexts that use the seed .le and \ncontexts that do not use the seed .le which are exactly the same as in the partition createdwhen .seed \n= .2 or .3. 1 if ($ GET[ action ] == redirect ) 2 { 3 ... 4 }  5 $time start = getMicrotime() ; 6 define \n( PHPNews , 1); 7 sessi on   sta rt() ; 8 require( auth .php ) ;  9 ... 10 // Security-sensiti ve \noperation is in post2 11 post2() ;  auth.php 1 sessi on st art (); 2 ... 3 $result = mysql query( SELECT \n* FROM .$db prefix . posters WHERE username = \\  .$in user . \\ AND password = password(\\  .$in \npassword . \\ ) ); 4 $dbQueries++; 5 if (mysql numrows( $result) != 0) 6 { 7 $auth = true ; 8 ... 9 \n// Security check using criti cal variable $auth 10 if (! $auth) { 11 exit ; 12 } 13 } news.php 1 include \n( setting s .php ); 2 ... 3 else if ($ GET[ action ] == post ) 4 fullNews() ;  5 ... 6 function fullNews(){ \n 7 ... 8 // Criti cal variable $Settings 9 if ($Settings[ enablecountviews ] == 1 ) {  10 $countviews \n= mysql query( UPDATE .$db prefix . news SET views=views+1WHEREid = .$ GET[ id ].  ) ; 11 } 12 ... \n13 } Figure7:Example ofafalsepositiveinphpnews1.3.0 Table5 showshow our results change as the .consistency \nthreshold varies between 0.5 and 0.9. This threshold con\u00adtrols thefraction of critical-.le contextsin \nwhich a variable must appear in order to be considered security-critical for thegiven role.Thedefault \nvalueis0.5.In two applications, increasing the threshold decreases both the number of vul\u00adnerabilitiesdetectedandthe \nnumberoffalsepositives(as ex\u00adpected).Formostapplications,thereisnodifferencebecause the root cause of \nmany reported vulnerabilitiesis eitherthe absence of anycheckspriorto some security-sensitiveevent, or \nroles containing a single context.  In summary, the algorithm is not sensitive to its three thresholds, \nrequires role analysis to reducethefalsepositive rate, and.nds actual vulnerabilities. 10. Conclusion \nWe designed and implemented ROLECAST, a new tool for statically.nding missing security checksinthesourcecode \nofWeb applications without an explicitpolicy speci.cation. Priorapproachestostatic, speci.cation-less \nveri.cationof security mediation assumed that security checks are syntac\u00adtically recognizable and/or \nthat the samepattern of security checks must be used consistently in all applications. Nei\u00adther approach \nworksforWeb applicationsbecausedifferent applicationsand evendifferent roleswithinthe same appli\u00adcation \nusedifferent,idiosyncratic security checks. ROLECAST exploits the standard software engineer\u00ading conventions \nused in server-side Web programming to (1) identify security-sensitive operations such as database updates, \n(2) automatically partition all contexts in which such operations are executed into groups approximating \napplication-speci.cuser roles,(3) identify application-and role-speci.c security checks by their semantic \nfunction in the application (namely, these checks control reachability of security-sensitive operations \nand afailed check resultsin quickly terminating or restarting the application), and (4) .nd missing checksby \nconsistency analysisof critical vari\u00adables within each role. When evaluated on a representative sample \nof open\u00adsource, relativelylargePHP andJSP applications,ROLE-CAST discovered 13 previously unreported \nvulnerabilities with only3falsepositives. Acknowledgments The researchdescribedin thispaper waspartiallysupported \nby theNSFgrantsCNS-0746888,CNS-0905602, andSHF\u00ad0910818, aGoogle research award, and theMURIprogram underAFOSRGrantNo.FA9550-08-1-0352. \nReferences [1] D. Balzarotti, M. Cova, V. Felmetsger, and G. Vigna. Multi\u00admodule vulnerability analysis \nof Web-based applications. In CCS,pages25 35,2007. [2] M.Bond,V.Srivastava,K.McKinley, andV.Shmatikov. \nEf\u00ad.cient, context-sensitive detection of real-world semantic at\u00adtacks. In PLAS,pages1 10,2010. [3] W. \nChang, B. Streiff, and C. Lin. Ef.cient and extensible security enforcement using dynamic data .ow analysis. \nIn CCS,pages39 50,2008. [4] A.Chlipala. Staticchecking ofdynamically-varying security policiesindatabase-backedapplications.In \nPLDI,pages234 245,2011. [5] R.Cytron,J.Ferrante,B.Rosen,M.Wegman, andK.Zadeck. Ef.ciently computing static \nsingle assignment form and the control dependence graph. ACM Transactions on Program\u00admingLanguages andSystems,13(4):451 \n490, Oct.1991. [6] M. Dalton, C. Kozyrakis, and N. Zeldovich. Nemesis: Pre\u00adventing authentication and \naccess control vulnerabilities in Webapplications. In USENIXSecurity,pages267 282,2009. [7] D. Denning \nand P. Denning. Certi.cation of programs for secureinformation .ow. CACM,20(7):504 513, 1977. [8] V.Felmetsger,L.Cavedon,C.Kruegel, \nandG.Vigna. Toward automated detection of logic vulnerabilities in Web applica\u00adtions. In USENIXSecurity,pages143 \n160, 2010. [9] Y. Huang, F. Yu, C. Hang, C. Tsai, D. Lee, and S. Kuo. SecuringWeb application codeby \nstatic analysis and runtime protection. InWWW,pages40 52,2004. [10] N.Jovanovic,C.Kruegel,andE.Kirda.Pixy:A \nstatic analysis tool for detecting Web application vulnerabilities. In S&#38;P, pages258 263, 2006. [11] \nJSP. http://java.sun.com/products/jsp. [12] L. Koved, M. Pistoia, and A. Kershenbaum. Access rights analysisforJava. \nIn OOPSLA,pages359 372, 2002. [13] B. Livshits, A. Nori, S. Rajamani, and A. Banerjee. Mer\u00adlin:Speci.cationinferenceforexplicitinformation \n.owprob\u00adlems. In PLDI,pages75 86,2009. [14] B. Livshits and T. Zimmermann. Dynamine: Finding com\u00admon \nerror patterns by mining software revision histories. In ESEC/FSE,pages296 305, 2005. [15] PHP. http://www.php.net. \n[16] PHP advent 2010: Usage statistics. http://phpadvent. org/2010/usage-statistics-by-ilia-alshanetsky. \n[17] M.Pistoia,R.Flynn,L.Koved,andV.Sreedhar.Interprocedu\u00adral analysisforprivileged codeplacement andtainted \nvariable detection. In ECOOP,pages362 386, 2005. [18] Quercus. http://quercus.caucho.com. [19] A. Sistla, \nV. Venkatakrishnan, M. Zhou, and H. Branske. CMV: Automatic veri.cation of complete mediation forJava \nVirtualMachines. In ASIACCS,pages100 111, 2008. [20] S. Son and V. Shmatikov. SAFERPHP: Finding semantic \nvulnerabilitiesinPHP applications. In PLAS,2011. [21] Soot:AJava optimizationframework. http://www.sable. \nmcgill.ca/soot/. [22] V. Srivastava, M. Bond, K. McKinley, and V. Shmatikov. A securitypolicy oracle:Detecting \nsecurityholes using multiple APIimplementations. In PLDI,pages343 354, 2011. [23] L.Tan,X.Zhang,X.Ma,W.Xiong, \nandY.Zhou. AutoISES: Automatically inferring security speci.cations and detecting violations. In USENIXSecurity,pages379 \n394, 2008. [24] ApacheTomcat. http://tomcat.apache.org. [25] G.Wasserman andZ.Su. Sound andprecise analysis \nofWeb applicationsforinjectionvulnerabilities. In PLDI,pages 32 41,2007. [26] Y. Xie and A. Aiken. Static \ndetection of security vulnerabil\u00aditiesinscriptinglanguages. In USENIX Security,pages 179 192,2006. [27] \nA.Yip,X.Wang,N.Zeldovich,andF.Kaashoek. Improving applicationsecurity withdata .owassertions.In SOSP,pages \n291 304, 2009. A. Building theCallGraph Security analysis performed by ROLECAST requires a pre\u00adcise callgraph.As \nmentionedinSection3.2,we .rsttrans\u00adlateWebapplicationsintoJava.ForJSP,thistranslationpro\u00adduceswell-formed \nmethodinvocationsand we construct an accurate call graph for the resulting Java code using the class \nhierarchy analysis(CHA) in Soot. For PHP, however, the translation performed by the Quercus compiler \nmakes all method calls indirect, either via re.ective calls or via lookupsin ahash table.TheCHA analysisinSootdoes \nnot supporteitherand thus cannotbe useddirectly to construct the callgraph of the resultingJavaprogram. \n Quercustranslates eachPHPfunctioninto adistinctJava class. Therefore, to statically .nd the targets \nof unresolved methodcalls,itis suf.cienttoperformintraproceduralprop\u00adagation of symbolic method names \nin the main method of theQuercus-generatedclass. First, ROLECAST analyzes the initialization methods, \nwhich assign to the global method lookup hash table. It initializes each member variable in the class \nto the symbolic method name(s) in the initializa\u00adtion methods.ROLECAST thenpropagatessymbolicnames withinthemainfunctionof \neach classuntilit reachesa .xed point.Re.ective callsdynamicallyreference an actual argu\u00admentto resolvetheirtarget \nmethods.Therefore,ROLECAST also checkssymbolicvalues ofargumentsat unresolvedcall\u00adsites. ROLECAST then \nadds a call-graph edge between the callsite and the target method. The call graph constructed by ROLECAST \nusing this technique is object-and context-insensitive. As described in Section 5.1, ROLECAST then uses \na context-sensitive al\u00adgorithm to compute the contextsin which security-sensitive operations maybe executed.In \nour experimental evaluation, ROLECAST resolved 95% or more of user-de.ned method calls in every benchmark \nWeb application. The remaining unresolved callsites were all due to missing plug-in func\u00adtion bodies. \nOnly two callsites in our benchmarks required manual annotation. Recall thatinWeb applications,eachprogram \n.lecanbe invoked directly by the network user and thus represents a potential entry point. These entry \npoints require additional edgesin the callgraph.The call-graph analysisin ROLE-CAST identi.es allpotentialprogramentrypointsand \ncon\u00adstructs a single call graph with multiple entry points one entrypointfor eachprogram .le and all \nmethodsit contains. However,programmers often neglect todefensivelypro\u00adgramunintendedentrypoints.This \ncreatescallingsequences inthe callgraphthatinclude methods notde.nedin the cur\u00adrent .le, since the programmer \nintended this .le to be in\u00advoked only from some other .le which does de.ne these methods.ThePHPinterpreter \nwill stop executionif thepro\u00adgraminvokes an unde.nedmethod. In theory, we simply need to eliminate all \ncalls to unde\u00ad.ned methodsinthe callgraph.Inourcurrentimplementa\u00adtion, we perform this pruning of unde.ned \nmethods on the set of calling contexts CC for each security-sensitive event e.We computethedominator \nrelationshipfor every method. For each method m . cc . CC, if it dominates e inter\u00adprocedurally but m \nis unde.ned, we eliminate the calling context cc from the set CC.Eliminating unde.ned methods in the \ncallgraphshouldproducethe same result as eliminat\u00ading themintheset of calling contexts,and theef.ciency \nof our analysis canbeimprovedbyperformingthis elimination directlyon the callgraph.   \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Web applications written in languages such as PHP and JSP are notoriously vulnerable to accidentally omitted authorization checks and other security bugs. Existing techniques that find missing security checks in library and system code assume that (1) security checks can be recognized syntactically and (2) the same pattern of checks applies universally to all programs. These assumptions do not hold for Web applications. Each Web application uses different variables and logic to check the user's permissions. Even within the application, security logic varies based on the user's role, e.g., regular users versus administrators. This paper describes ROLECAST, the first system capable of statically identifying security logic that mediates security-sensitive events (such as database writes) in Web applications, rather than taking a specification of this logic as input. We observe a consistent software engineering pattern-the code that implements distinct user role functionality and its security logic resides in distinct methods and files-and develop a novel algorithm for discovering this pattern in Web applications. Our algorithm partitions the set of file contexts (a coarsening of calling contexts) on which security-sensitive events are control dependent into roles. Roles are based on common functionality and security logic. ROLECAST identifies security-critical variables and applies rolespecific variable consistency analysis to find missing security checks. ROLECAST discovered 13 previously unreported, remotely exploitable vulnerabilities in 11 substantial PHP and JSP applications, with only 3 false positives.</p> <p>This paper demonstrates that (1) accurate inference of application- and role-specific security logic improves the security of Web applications without specifications, and (2) static analysis can discover security logic automatically by exploiting distinctive software engineering features.</p>", "authors": [{"name": "Sooel Son", "author_profile_id": "81388590748", "affiliation": "University of Texas at Austin , Austin, TX, USA", "person_id": "P2839328", "email_address": "samuel@cs.utexas.edu", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "Microsoft Research and Universirty of Texas at Austin, Austin, USA", "person_id": "P2839329", "email_address": "mckinley@cs.utexas.edu", "orcid_id": ""}, {"name": "Vitaly Shmatikov", "author_profile_id": "81338491121", "affiliation": "University of Texas at Austin, Austin, TX, USA", "person_id": "P2839330", "email_address": "shmat@cs.utexas.edu", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048146", "year": "2011", "article_id": "2048146", "conference": "OOPSLA", "title": "RoleCast: finding missing security checks when you do not know what checks are", "url": "http://dl.acm.org/citation.cfm?id=2048146"}