{"article_publication_date": "10-22-2011", "fulltext": "\n A Syntactic Type System for Recursive Modules Hyeonseung Im Keiko Nakata Jacques Garrigue Pohang University \nof Science and Institute of Cybernetics at Tallinn Graduate School of Mathematical Technology (POSTECH), \nKorea University of Technology, Estonia Sciences, Nagoya University, Japan genilhs@postech.ac.kr keiko@cs.ioc.ee \ngarrigue@math.nagoya-u.ac.jp Sungwoo Park Pohang University of Science and Technology (POSTECH), Korea \n gla@postech.ac.kr Abstract A practical type system for ML-style recursive modules should address at \nleast two technical challenges. First, it needs to solve the double vision problem, which refers to an \ninconsistency between external and internal views of re\u00adcursive modules. Second, it needs to overcome \nthe tension between practical decidability and expressivity which arises from the potential presence \nof cyclic type de.nitions caused by recursion between modules. Although type systems in previous proposals \nsolve the double vision problem and are also decidable, they fail to typecheck common patterns of recursive \nmodules, such as functor .xpoints, that are essen\u00adtial to the expressivity of the module system and the \nmodular development of recursive modules. This paper proposes a novel type system for recursive modules \nthat solves the double vision problem and type\u00adchecks common patterns of recursive modules including \nfunctor .xpoints. First, we design a type system with a type equivalence based on weak bisimilarity, \nwhich does not lend itself to practical implementation in general, but accom\u00admodates a broad range of \ncyclic type de.nitions. Then, we identify a practically implementable fragment using a type equivalence \nbased on type normalization, which is expres\u00adsive enough to typecheck typical uses of recursive modules. \nOur approach is purely syntactic and the de.nition of the type system is ready for use in an actual implementation. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n11, October 22 27, 2011, Portland, Oregon, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. \n. . $10.00 Categories and Subject Descriptors D.3.1 [Programming Languages]: Formal De.nitions and Theory; \nD.3.3 [Pro\u00adgramming Languages]: Language Constructs and Features Recursion, Modules General Terms Languages, \nTheory, Design Keywords Type systems, modules, recursion, abstract types, weak bisimulations 1. Introduction \nModular programming is considered the key enabling tech\u00adnology for large-scale software development and \nmainte\u00adnance. Consequently, a modern programming language usu\u00adally provides its own module system to \nfacilitate modular programming. The ML module system [22], among oth\u00aders, provides powerful support for \nmodular programming and data abstraction through nested modules, higher-order functors (functions from \nmodules to modules), and abstract types. While regarded as a powerful mechanism for modular programming, \nthe ML module system does not traditionally support recursive modules. This is in sharp contrast to typed \nobject-oriented languages such as Java, which put almost no restriction on recursion between components. \nOne could ar\u00adgue that recursive modules are harder to support in ML pre\u00adcisely because of the strengths \nof the language, such as its type system, which supports polymorphic type inference, or the absence of \ndefault values such as null pointers, which makes more dif.cult de.ning a semantics for recursive mod\u00adule \ninitialization. Due to the lack of recursive modules, ML programmers often have to consolidate conceptually \nsepa\u00adrate mutually recursive de.nitions into a single module, thus compromising modular programming. \nIn response, recently, several authors have proposed recursive module extensions to ML [6 9, 21, 26, \n28, 34], some of which are successfully implemented in Moscow ML [2] and OCaml [3].  Despite such abundant \nliterature and practical implemen\u00adtations, however, the number of examples of using recur\u00adsive modules \nreported in the literature is still rather limited: expression/binding recursive modules [6], Okasaki \ns boot\u00adstrapped heaps [31], polymorphic recursion [21], tree/forest recursive data structures [28], and \nthe expression prob\u00adlem [13]. While they give us some idea of how recursive modules can be useful in \npractice, their scarcity may also demonstrate that existing systems are either too cumbersome or not \nexpressive enough to accommodate other interesting examples. Speci.cally, to reach its full power, a \ntype system for re\u00adcursive modules needs to address the double vision prob\u00adlem [9] and cyclic type de.nitions. \nThe double vision prob\u00adlem refers to the inability to identify the external name of an abstract type \nwith its internal name inside the recursive module where the type is de.ned. It has proven dif.cult to \nsolve and only Dreyer [8] and Montagu and R\u00b4emy [26] suc\u00adcessfully solve it in a type-theoretic way. \nIndependently of recursive type de.nitions, recursive modules allow us to indirectly introduce recursion \nin types that span across module boundaries. The potential presence of arbitrary cyclic types would require \nequi-recursive type constructors of higher-kind, for which no practical algorithm for type equivalence \nis known [6], and non-contractive types, for which the equational theory is not known. Moreover, one \nhas to decide what to do with type cycles hidden through opaque sealings. Most previous proposals choose \nto reject type cycles, whether or not they are hidden through opaque sealings, in a conservative way \nat the expense of reducing the .exibility and expressive power of recursive modules. Here, we use the \nterm conservatively because it is generally impossible to accurately detect cycles without breaking ab\u00adstraction. \nFor example, Dreyer [8] supports only a restricted form of functor .xpoints, and Montagu and R\u00b4 emy [26] \ndo not support functor .xpoints returning structures at all. As we will see in Sections 2 and 3, however, \nthere are important examples that are rejected by these approaches. In this paper, we start our analysis \nby providing three practical examples illustrating basic uses of recursive mod\u00adules: tree and forest \nrecursive data structures adapted from [28]; encodings of classes and objects using functors and functor \n.xpoints; and an implementation of a compiler back\u00adend. These examples demonstrate that, when suf.ciently \nex\u00adpressive, recursive modules have a wide range of applica\u00adtions and help us improve modularity. We \nthen address the double vision problem and decidability of typechecking sep\u00adarately. To solve the double \nvision problem, we introduce a notion of path substitutions, which are mappings from ex\u00adternal names \nto internal names of abstract types. Locally en\u00adriching the typing context with path substitutions proves \nsuf\u00ad.cient to solve the double vision problem. To avoid restrict\u00ading expressivity, we allow the type \nsystem to account for arbitrary cyclic type de.nitions. Speci.cally, we use weak bisimilarity [23] on \na labeled transition system on types [28] to build our type equivalence relation. Using weak bisimi\u00adlarity, \nwe generalize extensional equality, or bisimilarity, on in.nite trees to account for type abbreviations. \nThis type sys\u00adtem is proven sound but may be dif.cult to implement in general. We then propose an algorithmic \ntype system by re\u00adjecting transparent type cycles (as de.ned in Section 3.2). The algorithmic type system \nis sound and complete with re\u00adspect to the one based on weak bisimilarity if the program does not contain \ntransparent type cycles, and can still type\u00adcheck all our motivating examples. The main motivation of \nthis work is to design a type system that typechecks .exible uses of recursive modules already supported \nby OCaml, and possibly more. (OCaml 3.12.0, the most recent version, does not completely solve the double \nvision problem.) Hence, we focus only on typ\u00ading issues and do not investigate a logical account of recur\u00adsive \nmodules in contrast to Dreyer [7, 8] and Montagu and R\u00b4 emy [26], who give logical interpretations of \nrecursive type generativity and abstract types, respectively. Our contributions are summarized as follows: \n We provide three practical examples that are useful for understanding basic uses of recursive modules. \n We propose a novel type system that solves the double vision problem and rejects only transparent type \ncycles, which is suf.cient to keep typechecking practically im\u00adplementable and does not impede expressivity. \nWe also de.ne a light-weight call-by-value operational semantics and show that the type system is sound \nwith respect to it.  Our type system is purely syntactic and may thus act as a reference for the implementation \nof an external pro\u00adgrammable module language. We believe that our type system is simpler than previous \nproposals.  The rest of the paper is organized as follows. Section 2 gives three practical examples \nof using recursive modules. Section 3 presents technical challenges, namely the double vision problem \nand cyclic type de.nitions. It also discusses previous approaches to these challenges and the key ideas \nof our approach. Section 4 gives the concrete syntax of our language. Section 5 explains the type system, \nand Section 6 shows the operational semantics and a type soundness re\u00adsult. Section 7 presents an algorithmic \ntype equivalence re\u00adlation. Section 8 discusses separate compilation of mutually recursive modules and \ntype reconstruction for our language. Section 9 discusses related work and Section 10 concludes.  2. \nExamples of Using Recursive Modules This section illustrates typical uses of recursive modules and gives \nus a baseline for what a practical type system for recur\u00adsive modules should handle. All the examples \ntypecheck in OCaml 3.12.0 (with Figures 3 and 4 being given appropriate de.nitions for the omitted part). \n module rec Tree : sig type t val max :t->int end = struct type t = Leaf of int | Node of int * Forest.f \nlet max x= match x with Leafi-> i | Node (i, f) -> let j = Forest.max f in ifi >jtheni elsej end and \nForest : sig type f val max :f->int end = struct type f = Tree.t list let rec maxx = match x with [] \n-> 0 |hd ::tl-> let i = Tree.max hd in let j = max tl in ifi> jthenielsej end Figure 1. Tree and Forest \nmutually recursive modules 2.1 Basic Terminology Basic modular programming constructs in the ML module \nsystem are structures, signatures, and functors. A structure, or a module, is a collection of related \ndeclarations such as de.nitions of datatypes and associated operations. A func\u00adtor, or a parameterized \nmodule, is a function from structures to structures. A signature and a functor signature, which are also \ncalled module types, specify an interface for a structure and a functor, respectively. An opaque signature \nsealing al\u00adlows one to hide the implementation details of a module be\u00adhind the signature; hence, one \nmay de.ne abstract types via sealings. The notion of modules extends to nested modules which allow modules \nas components, and the notion of func\u00adtors extends to higher-order functors which take functors as arguments. \n2.2 Tree and Forest Mutually Recursive Modules The .rst example is Tree and Forest mutually recursive \nmodules in Figure 1, which is adapted from [28]. Tree is a module for trees whose leaves and nodes are \nlabeled with integers while Forest is a module for a list of those integer trees. Components of Tree \nand Forest refer to each other in a mutually recursive way: type components Tree.t and Forest.f refer \nto each other and similarly value components Tree.max and Forest.max, which .nd the maximum integer that \na given tree and forest contain, respectively. In this example, we enforce type abstraction inside the \nrecursion by sealing each module with a signature specifying an abstract type individually. The main \nbene.t of using recursive modules in this ex\u00adample is the modularity between Tree and Forest. Without \nrecursive modules, the programmer has to consolidate two conceptually separate modules, each of which \nmay usually include dozens of function de.nitions, into a single mod\u00adule. This merges two separate namespaces \ninto a single one, module type Point = sig val getx : unit -> int val move : int -> unit end module PointF \n(X : sig end)= struct let x= ref0 let getx () = !x let move d=x:=!x+d end let new point () = (module \nPointF(struct end) : Point) module type Show = sig val show : unit -> string end module ShowF (P : Point) \n= struct let show () = Printf.sprintf \"x = %i\" (P.get x ()) end module type ShowPoint = sig include \nPoint include Show end module ShowPointF (P : ShowPoint) = struct include PointF(P) include ShowF(P) \nend (* Create a new showpoint, by tying the knot *) let new showpoint () = let module M= struct module \nrec SP : ShowPoint = ShowPointF(SP) end in (module M.SP : ShowPoint) let sp = new showpoint () let a= \nlet module SP= (val sp : ShowPoint) in SP.move 2; SP.show () let spasp = (module (val sp : ShowPoint) \n: Point) Figure 2. Encodings of classes and objects thereby reducing the modularity and readability of \nthe pro\u00adgram. For example, similar functions in Tree and Forest with the same name such as max should \nnow be renamed max tree and max forest to avoid a name collision. Tree/Forest-style recursive modules \nare indeed used in a real world project such as Amthing [1] which is a multi\u00adthreaded GUI library for \nOCaml. For example, recursive modules Focus/Focusee and Signal/Event are a variant of the Tree/Forest \npattern.  2.3 Encodings of Classes and Objects The second example is an encoding of classes and objects \nusing functors and functor .xpoints. The basic idea is to turn classes (or traits [35]) into functors \nreceiving the object to be constructed and returning a list of methods. Figure 2 demon\u00adstrates this idea \nusing recursive modules and .rst-class mod\u00adules. First-class modules, as provided by Moscow ML and OCaml, \nallow us to pack a module as a value of the core language, which can later be dynamically unpacked with \nthe same signature. While the type system we will present does not support .rst-class modules, they can \neasily be added. A more powerful encoding would represent object state as a separate abstract type, avoiding \nthe need for .rst-class mod\u00adules and permitting more advanced operations such as binary methods, but \nat the cost of more complexity.  Figure 2 .rst de.nes a Point interface and the corre\u00adsponding class, \nde.ned as a functor PointF. In this basic case, where methods do not call one another, a functor is suf\u00ad.cient \nto allow our points to have some state. We then de.ne a constructor new point by applying PointF to an \narbitrary argument, and wrapping the result in a .rst-class module us\u00ading the packing construct (module \n... : Point). We now see how traits and inheritance can be encoded. We .rst de.ne an interface Show containing \na single show method. The corresponding trait is a functor ShowF which receives a module satisfying the \nsignature Point and uses its method to de.ne an implementation for show. The next step, corresponding \nto inheritance, is to merge this trait into the PointF class, which is done by de.ning a func\u00adtor taking \nan argument satisfying the signature ShowPoint (the union of Show and Point) and returning the union \nof PointF and ShowF. The last step is to de.ne the constructor new showpoint. Since methods may now call \none another, we need to tie the recursive knot by taking the .xpoint of ShowPointF. For syntactic reasons, \nthis has to be done in\u00adside a local module, before returning this .xpoint M.SP as a .rst-class module. \nOnce we create such an object, we can use it as a normal one. Syntactically, we .rst need to unpack it \nas (val sp : ShowPoint) to be able to call its methods. Module subtyp\u00ading also provides for object subtyping, \nand can be used by unpacking and repacking. Using recursive modules and .rst-class modules, we can similarly \nencode other features of object-oriented languages such as method overriding, virtual methods, or private \nmeth\u00adods.  2.4 An Implementation of a Compiler Back-end The third example is an implementation of a \ncompiler back\u00adend1 in Figures 3 and 4, where we omit many type and func\u00adtion de.nitions. Basically, it \nimplements a compilation pass for translating a machine independent intermediate language into machine \ndependent ones, with different instructions. The basic idea is similar to class and object encodings \nin Section 2.3: we de.ne a functor which takes the target lan\u00adguage and machine-speci.c translation functions \nand returns 1 It is inspired by the OCaml implementation and was suggested by Xavier Leroy. type id = \n... (* identifier *) type reg = ... (* register location *) and reg s = reg list type env = (id * reg \ns) list (* The source language *) type exp = Cint of int | Cadd of exp * exp | Cif of exp*exp*exp |... \ntype test=Leq|Lne |... module type S= sig (* The target language *) type spec op type instr = Ladd | \n... | Lspec of spec op and instr s = instr list . . . (* a bunch of declarations *) val sel cond : exp \n-> test * exp * exp val sel add : env -> exp -> exp -> instr s -> instr * regs * instrs end module FSelectgen \n(X : S) = struct (* emit exp : env -> exp -> X.instr s *) (* -> regs * X.instrs *) let emitexp env e \ni = match e with | Cadd (e1, e2) -> ... X.sel add env arg1 arg2 i ... | Cif (econd, eif, eelse) -> let \n(cond, e1, e2) = X.sel cond econd in . . . let sel cond e = ... let seladd env e1 e2 i = let (r1, i1) \n= emit exp env e1 i in let (r2, i2) = emit exp env e2 i1 in (X.Ladd, concat r1 r2, i2) (* The entry point \nto the translation *) let emit e = emit exp empty env e (init ()) end Figure 3. A machine independent \ntranslation a list of translation functions tailored to the target machine. The functor FSelectgen2 in \nFigure 3 is such a generic func\u00adtor, which implements translation functions for the general machine. \nThe target language instr contains, besides ma\u00adchine independent instructions, a special instruction \nLspec to support machine speci.c instructions. While FSelectgen takes two functions sel cond and sel \nadd as arguments, which may exploit the optimizing instructions for condi\u00adtionals and arithmetic that \nthe target machine provides, it also de.nes default implementations, which do not exploit such optimizing \ninstructions, for both functions. Note that function emit exp, which translates a source language ex\u00ad \n2 The OCaml implementation uses its object system rather than recursive modules, and a virtual class \nselector generic in the selectgen.ml .le is a counterpart of the functor FSelectgen.  module rec ProcA \n: sig ... end = struct module Selectgen = FSelectgen(ProcA.Selection) module Selection = struct type \nspec op = Laddi of int type instr = Ladd | ... | Lspec of spec op and instr s = instr list . . . (* a \nbunch of declarations *) let seladd env e1 e2 i = match e1 with | Cint n -> let (r, i ) = Selectgen.emit \nexp env e2 i in (Lspec (Laddi n), r, i ) | -> Selectgen.sel add env e1 e2 i let sel cond = Selectgen.sel \ncond let emit = Selectgen.emit end end Figure 4. A translation tailored to a speci.c target machine with \na special addition instruction pression, uses machine dependent functions X.sel add and X.sel cond rather \nthan their default implementations. Figure 4 shows an example of instantiating the general functor FSelectgen \nto a speci.c machine. The recursive module ProcA is a machine dependent translation that is obtained \nby taking the .xpoint of FSelectgen. The target machine provides a special instruction Laddi for the \nad\u00addition with integer constants, so the module Selection de.nes a new implementation for the function \nsel add which exploits the instruction Laddi. By tying the recur\u00adsive knot between FSelectgen and ProcA.Selection, \nwe obtain translation functions tailored to the target machine. The module Selection reuses the default \nimplementation of sel cond provided by FSelectgen. For different tar\u00adget machines with different optimizing \ninstructions, we can similarly obtain machine dependent translations by taking the .xpoint of FSelectgen. \nWe believe that all these examples provide strong evi\u00addence that recursive modules are useful in practice \nand give us more expressive power to improve modularity.  3. Technical Challenges This section presents \ntechnical challenges for typechecking recursive modules, namely the double vision problem [9] and cyclic \ntype de.nitions. As suggested in the introduction, we address these issues separately, which allows us \nto clarify the problems involved and propose a simpler solution. In the following, we .rst look at the \ndouble vision problem and then cyclic type de.nitions, examining previous approaches and explaining our \napproach along the way. 3.1 The Double Vision Problem The double vision problem refers to the inability \nto identify the external name of an abstract type, which is cyclically imported, with its internal name \ninside the recursive module module rec Forest : sig type f val empty : unit -> f val plant : Tree.t -> \nf -> f end = struct type f = Nil | Cons of Tree.t * f let empty () = Nil let plant x y = Cons (x, y) \nend and Tree : sig type t val empty : unit -> t val plant : int -> Forest.f -> Forest.f -> Forest.f end \n= struct type t = int * Forest.f let empty () = 0, Forest.empty () let plant i x y = Forest.plant (i, \nx) y end Figure 5. The double vision problem where it is de.ned. For example, consider Figure 5, a variant \nof Figure 1. Here, we slightly modify the de.nitions of types Tree.t and Forest.f so that we can use \nFigure 5 as our running example, expressible in our language: Tree.t is de.ned as a pair of an integer \nand a forest, where the forest represents the branches of a tree, while Forest.f as a datatype representing \na list of trees. Hence, we need not extend the entire system with parameterized type de.nitions such \nas a list, which is feasible but beyond the scope of this paper. Both modules Tree and Forest now contain \na new function called plant but with a different type, which inserts a tree into a forest. The example \ndoes not typecheck in OCaml 3.12.0 be\u00adcause of the function plant in Tree. Speci.cally, the ex\u00adpression \n(i, x) is of type int * Forest.f while the function Forest.plant expects a value of type Tree.t, which \nis an abstract type and thus cannot be identi.ed with int * Forest.f. Inside Tree, however, Tree.t is \nmerely a recursive reference to, or equivalently an external name of, t which equals int * Forest.f. \nHence, inside Tree, the type system should also identify Tree.t with int * Forest.f. The inability to \ndo so is called the double vision problem. OCaml partially solves this problem by automati\u00adcally adding \na type equation pointing from the internal de.\u00adnition to the external de.nition, when typechecking the \nbody of a recursive module. However, in OCaml, a type de.nition has at most one type equation and therefore \nthis approach is only applicable to datatype de.nitions, but not to type abbreviations or datatype de.nitions \nwith equations. Previous approaches To our knowledge, only RMC by Dreyer [8] and FY by Mon\u00adtagu and R\u00b4emy \n[26] solve the double vision problem in a type-theoretic way. The key idea of RMC is to separate the \ncreation of the name for an abstract type from the de.ni\u00adtion of the type. Speci.cally, by elaboration \nsimilar to the De.nition of Standard ML [24], the RMC type system .rst creates a semantic type variable \nand assigns it to both ex\u00adternal and internal names of an abstract type. The seman\u00adtic type variable \nis then de.ned only once and the RMC type system ensures its de.nition to be visible only inside the \nmodule where the type variable is de.ned. For example, the RMC type system .rst assigns a new type variable \na to both Tree.t and t inside Tree. Then, a is de.ned as int * Forest.f inside Tree. As Forest.plant \nexpects a value of type Tree.t, or equivalently a, which is known to equal int * Forest.f inside Tree, \nthe function plant in Tree typechecks in RMC. We remark that the type variable a is abstract outside \nTree. The typability in RMC, however, de\u00adpends on the order of de.nitions (see Section 3.2 in this pa\u00adper \nfor details). This is why we should de.ne Forest before Tree. Indeed, if the order is reversed, the resultant \nprogram does not typecheck in RMC.  FY by Montagu and R\u00b4emy is a variant of explicitly typed System \nF extended with recursive types and values, intended as a core language for modules. FY decomposes the \nintro\u00adduction and elimination of existential types into more atomic constructs. In FY, one may refer \nto a single type compo\u00adnent via using either its external name or internal name, and thus the double \nvision problem arises. FY addresses the problem simply by locally enriching the typing context with equations \nbetween external and internal names. For exam\u00adple, when typechecking the module Tree, FY locally ex\u00adtends \nthe typing context with an equation V(t t Tree.t = int * Forest.f). The equation means that the external \nname Tree.t can be viewed internally as t which is de\u00ad.ned as int * Forest.f. Hence, Figure 5 also typechecks \nin FY with the help of proper encodings. (FY does not sup\u00adport paths, so t and Tree.t should be represented \nas two distinct type variables.) Our approach: Path substitutions We address the double vision problem \nin a similar way to FY: our type system also extends the typing context locally with path substitutions, \nwhich are mappings from external names to internal names of abstract types. This is in con\u00adtrast to RMC, \nwhich modi.es the typing context globally. Speci.cally, as in most previous work, we employ recur\u00adsive \nstructures with explicitly typed recursion variables. We, however, do not distinguish between forward \nand backward references, and allow components of structures to refer to each other (recursively) only \nvia recursion variables. This makes module component access uniform and simpli.es the use of path substitutions. \nTo solve the double vision prob\u00adlem, when typechecking a recursive module, we add into the typing context \na path substitution of its internal recursion variable for its external path. Then, when checking equiva\u00adlence \non abstract types, we convert their external names to internal names (whose de.nitions are available \nto the type module type ST(type u) = rec(Y)sig type t val plant :int ->u ->u ->u end module type SF(type \nu) = rec(Z)sig type f val plant : u -> Z.f -> Z.f end module type S= rec(X)sig module Tree : ST(X.Forest.f) \nmodule Forest : SF(X.Tree.t) end rec(X : S)struct module Tree : ST(X.Forest.f) = rec(Y : ST(X.Forest.f) \nwith type t = int * X.Forest.f) struct type t = int * X.Forest.f let plant (i : int) (x : X.Forest.f) \n (y : X.Forest.f) = X.Forest.plant (i, x) y end module Forest : SF(X.Tree.t) = rec(Z : SF(X.Tree.t) with \n type f = Nil | Cons of X.Tree.t * Z.f) struct type f = Nil | Cons of X.Tree.t * Z.f let plant (x : X.Tree.t) \n(y : Z.f) = Z.Cons (x, y) end end Figure 6. Encodings of Tree and Forest modules in our language system) \nby applying path substitutions, and thus identify their two different names. To illustrate how we exploit \npath substitutions in solving the double vision problem, consider Figure 6, an encoding of Figure 5 in \nthe abstract syntax of our language (extended with top-level parameterized signatures [17] for concision). \nTo simplify the code, we omit the empty function in both Tree and Forest modules. The code may look a \nbit verbose because it is written in the abstract syntax, but in practice, most of the type annotations \ncan be automatically inferred, as discussed in Section 8.2. We wrap Tree and Forest mod\u00adules in a top-level \nrecursive module X and assign them recur\u00adsion variables Y and Z, respectively. Both Y and Z are anno\u00adtated \nwith their principal signatures. To typecheck plant in Tree, from which the double vision problem arises, \nthe type system should identify an abstract type X.Tree.t, which is the type of the .rst argument of \nX.Forest.plant, with int * X.Forest.f, which is the type of (i, x). To do that, when typechecking Tree, \nthe type system locally enriches the typing context with a path substitution X.Tree = Y. Then, by rewriting \nX.Tree.t to Y.t, which equals int * X.Forest.f, the type system typechecks plant. In this way, we solve \nthe double vision problem.  Our approach to the double vision problem differs from those of RMC and \nFY in the following two points. First, we address the problem in a purely syntactic way, as opposed to \nRMC adopting SML-style elaboration into semantic objects. Second, we address the problem in the context \nof path-based recursive modules, whereas FY considers a low-level core language in the style of System \nF, and has to be extended to encode full .edged ML modules supporting recursion. Our approach is close \nto the OCaml implementation of recursive modules, but our approach to handling path substitutions is \nmore general and allows us to typecheck more programs.  3.2 Cyclic Type De.nitions Besides the double \nvision problem, another subtle issue in typechecking recursive modules is to determine what kinds of \ncyclic type de.nitions to support. Independently of re\u00adcursive type de.nitions, recursive modules allow \nus to indi\u00adrectly introduce recursion in types and also to hide it through opaque sealings. Hence, we \nneed to distinguish different kinds of recursion in types. We say that a type cycle is guarded if it \ngoes through, or is intercepted by, a datatype. Otherwise, it is unguarded. We say that an unguarded \ntype cycle is opaque if it is hidden through opaque sealings. Oth\u00aderwise, it is transparent. 3 Examples \nof type cycles The example below, written in OCaml syntax, illustrates guarded and transparent type cycles \nin an observable sig\u00ad nature. sig module type type type end rs t u ec = = = X : Int X.t int sig of X.s \n* X.u (* (* (* guarded *) transparent transparent *) *) end In the next example, the cycle may appear \nto be hidden through an opaque sealing, but actually it is still observable (hence transparent). The \nreason is that our type system iden\u00adti.es types t and L.t using path substitutions introduced to solve \nthe double vision problem. In OCaml, where the dou\u00adble vision problem remains, the cycle would be left \nopaque. module rec L: sig type t end = struct type t = int * L.t end (* transparent *) In our system, \nopaque type cycles have to be built in a more subtle way. Here, we use mutual recursion between two modules \nto create an opaque type cycle. To make it transparent, both type de.nitions are needed simultaneously, \nbut only one of them is available in each of M and N. 3 Dreyer [8] uses the term transparent for unguarded \n. We think our naming better matches the intuition that a transparent type cycle should be observable \nwithout peeking inside opaque sealings. module rec M: sig type t end = struct type t = int * N.t end \n(* opaque *) and N: sig type t end = struct type t = int * M.t end (* opaque *) The distinction between \nthe two last examples is seman\u00adtical. In our system, type abbreviations, even cyclic ones, are handled \nin a structural way. In particular, inside L, L.t would be equal to any other type de.ned as an in.nite \nse\u00adquence of int s such as type s = int * s. On the other hand, while M.t and N.t are related to each \nother inside M and N, they have no such in.nite expansion. Problems with unguarded type cycles Transparent \ntype cycles are problematic for keeping type\u00adchecking practical. For example, Crary et al. [6] support \ntransparent type cycles such as the above X.u. For this, they extend their type theory with equi-recursive \ntype construc\u00adtors of higher kind. There is, however, no known practical algorithm for checking their \nequivalence. While opaque type cycles are harmless with respect to typechecking, they may still introduce \ndif.culties when proving type soundness. Indeed, proving a type preservation lemma requires proving typability \nin the presence of reduc\u00adtion, which may require removing opaque sealings. After removing sealings, all \nopaque type cycles become transpar\u00adent. Hence, if we do not reject opaque type cycles altogether in the \nsurface language, we eventually need to handle trans\u00adparent ones when proving type soundness. To reject \nopaque type cycles, however, may reduce the .exibility and expressive power of recursive modules, be\u00adcause \nit is generally impossible to detect such cycles with\u00adout breaking abstraction. This is explained in \nthe example below. module type S= sig type t end module F(X:S): S= struct type t = X.t end module G(X:S): \nS= struct type t = int end module rec Ffix : S = F(Ffix) module rec Gfix : S = G(Gfix) Ffix creates an \nopaque type cycle, whereas Gfix does not. Yet, they are both de.ned as .xpoints of functors with the \nsame signature functor (X : S) -> S. Therefore, with\u00adout peeking at the actual de.nitions of F and G, \nwe cannot tell Ffix from Gfix and cannot reject Ffix while accepting Gfix. We can reject opaque type \ncycles conservatively only by rejecting some modules that do not contain such cycles at all.  Dreyer \ns approach The RMC type system of Dreyer [8] rejects unguarded type cycles altogether conservatively, \nwhether they are transpar\u00adent or opaque. The reason is that RMC removes opaque sealings in its operational \nsemantics (thus making opaque type cycles transparent) and uses an equational theory in which transparent \ntype cycles are problematic [7]. Hence,  module Set (X : sig type t end) : sig type t = X.t type f end \n= struct type t = X.t type f = Nil | Cons of t*f end module rec Tree : sig type t end = struct type t \n= int * Forest.f end and Forest : sig type t = Tree.t type f end = Set(Tree) Figure 7. Cyclic type de.nitions \nthe potential presence of unguarded type cycles has to be prevented. Speci.cally, in RMC, the internal \nde.nitions of abstract types in sealed modules and the type components of the argument modules in functor \napplications may not depend on any type variables marked as unde.ned in the typing context. A type variable \nis said to be unde.ned if the typechecker has not accepted its de.nition yet. In this way, RMC guarantees \nthat even when opaque sealings are stripped away, there are still no transparent type cycles. As solving \nthe double vision problem corresponds to locally stripping away opaque sealings in some sense, this approach \nis also compatible with Dreyer s approach to the double vi\u00adsion problem. Dreyer s approach of rejecting \nunguarded type cycles, however, imposes restrictions on uses of functor .xpoints. Note that functor .xpoints \nare crucial for encoding objects and classes as shown in Figure 2 and useful for .exible code reuse as \nshown in Figure 4. In fact, Figure 4 also hides the double vision problem since types such as spec op \nand instr have external names (through ProcA) as well as internal names (insides the module Selection). \nTo il\u00adlustrate, consider Figure 7, which is a variant of Tree and Forest modules de.ned using functor \n.xpoints. For clarity, we include only type de.nitions. In Figure 7, Tree.t and Forest.f refer to each \nother in a mutually recursive way: Tree.t is de.ned as int * Forest.f, and Forest.f as a datatype using \nTree.t through the functor application Set(Tree). The cycle between Tree.t and Forest.f is guarded because \nit is intercepted by the datatype Forest.f. The RMC type system, however, rejects Figure 7. The rea\u00adson \nis that the internal de.nition of the abstract type Tree.t depends on the type variable for Forest.f \nwhich is marked as unde.ned in the typing context. To reverse the order of de.nitions does not help here \nbecause then the type variable for Tree.t is marked as unde.ned at the point of the appli\u00adcation Set(Tree). \nTo exploit functor .xpoints in RMC, one should write them in accordance with the following conditions. \nFirst, given a functor application F(M), the module M must be de\u00ad.ned before the application. For example, \nthe .rst example below is allowed, while the second and third are not: module rec M : S = ... and N: \nT=F(M) module rec N: T=F(M) and M: S=... module rec M: S=F(M) Here, we assume that either the signature \nS declares an abstract type, or a type component of M refers to an abstract type of N. Second, if a type \ncomponent t of the (argument) module M depends on an abstract type of N (whose de.nition appears after \nthe de.nition of M), t must be de.ned as a datatype. The second condition similarly applies to general \nmutually recursive modules. For example, in Figure 5, if we change the order of de.nitions for modules \nTree and Forest, they do not typecheck in RMC. This explains why we had to .rst de.ne Forest before Tree, \nnot vice versa, in Figure 5. Our approach: Weak bisimilarity In this paper, we accept all opaque type \ncycles. As a result, we need to deal with transparent type cycles in the soundness proof. We therefore \n.rst work with a type system permitting transparent type cycles and prove its type soundness. Then, we \nidentify a practically implementable fragment, producing an algorithmic type system, by rejecting transparent \ntype cy\u00adcles. As transparent type cycles are observable, we can accu\u00adrately detect them without peeking \ninside opaque sealings. To account for transparent type cycles, we de.ne a type equivalence relation \nusing weak bisimilarity [23]. Using weak bisimilarity, we generalize extensional equality, or bisimilarity, \non arbitrary (non-regular) in.nite trees to ac\u00adcount for type abbreviations. Roughly speaking, two types \nare equivalent if they have the same tree-like expansions by unfolding type abbreviations. For instance, \ntypes t and s are equivalent with respect to type abbreviations type t = int *int, type s=u*u, and type \nu = int. Weak bisimilarity also naturally handles the possibility that unfolding type abbreviations goes \non forever without pro\u00adducing constructors, such as for type t=t. This allows us to step aside the problem \nwith non-contractive types [26]. We still need to avoid equating all such vacuous cycles by carefully \ncrafting their semantics. We prove type soundness by a standard proof technique for weak bisimilarity, \ni.e. .nding a weak bisimulation. The algorithmic type system is then obtained by additionally re\u00adjecting \ntransparent type cycles, which renders type equiva\u00adlence based on weak bisimilarity easily decidable. \nComparison with OCaml and FY Our approach to type cycles was inspired by OCaml, which also rejects only \ntransparent type cycles. Due to our solv\u00ading the double vision problem, however, we detect more transparent \ntype cycles, which are opaque in OCaml, and therefore end up rejecting more of them. The soundness of \nOCaml s recursive modules is not yet proved, but here again weak bisimilarity may be used. The handling \nof type cycles in FY [26] is harder to com\u00adpare because FY itself is only a core language. Moreover, \n Module paths p, q ::= X, Y, Z recursion variable | p.M Module expressions m ::= rec(X : S)s recursive \nstructure | functor (X : S) = m functor | p1 (p2 ) functor application | (m : S) opaque sealing | p module \npath Structure bodies s ::= struct d1 ... dn end structure de.nition De.nitions d ::= module M = m module \nde.nition | datatype t [= p ']= c of p datatype de.nition | type t = p type abbreviation | let l = e \nvalue de.nition Module types S ::= rec(X)sig D1 ... Dn end signature | functor (X : S1 ) = S2 functor \nsignature Speci.cations D ::= module M : S module spec. | datatype t [= p ']= c of p datatype spec. | \ntype t = p manifest type spec. | type t abstract type spec. | val l : p value spec. Programs P ::= (rec(X \n: S)s, e) Figure 8. The abstract syntax of the module language while it accommodates recursion between \ntype de.nitions, the proposed translation from ML modules [25] does not in\u00adclude recursive modules. Technically, \nFY ensures syntacti\u00adcally that recursive types are always contractive, which al\u00adlows FY to use an equational \ntheory for recursive types. While this may make the syntactic theory simpler, this is already a restriction. \nAs a result, if we freely extend the translation to recursive modules, it seems that functors suffer \nfrom the same problem as in RMC: an abstract type gener\u00adated by a functor cannot be directly used in \nits input, making the construction of generative functor .xpoints impossible. This con.rms our intuition \nthat, at least for the semantics, it is better not to impose any restriction in terms of type cycles. \n  4. Syntax Figure 8 gives the syntax of our module language, which is based on that of OCaml. We use \nX, Y, Z as metavariables for recursion variables and module variables, M, N for module names, t for type \nnames, and l for value names. As explained in Section 3.1, we extend structures with explicitly typed \ndeclarations of recursion variables. Every structure is a recursive structure rec(X : S)s; every sig- \nCore types p ::= 1 | p1 = p2 | p1 * p2 | p.t Core expr. e ::= x | () | Ax : p.e | e1 e2 | (e1 , e2 ) \n| ai(e) | p.c e | case e of p.c x . e' | p.l Figure 9. The abstract syntax of the core language nature \nis a recursively dependent signature rec(X)sig D1 ... Dn end. Components of structures and signatures \nmay refer to each other (recursively) only via recursion variables. A module path p, by which types, \nvalues, and submodules may be projected, is a recursion variable X followed by a series of module names \nseparated by dots (.). Unlike OCaml, we do not support applicative functors [19], so module paths do \nnot include functor application paths p1 (p2 ); we support only generative functors as in SML. A module \nexpression m is a recursive structure, a func\u00adtor, a functor application, a sealed module, or a path. \nThe forward declaration signature S in a recursive structure rec(X : S)s should contain all the necessary \ninformation to typecheck forward references in the body s. Functors are higher-order, meaning that they \nmay take functors as argu\u00adments. Moreover, they behave generatively in the sense that each application \nof the same functor generates fresh abstract types from types that are declared abstractly in its signature. \nWe ensure this generativity simply by requiring every func\u00adtor application to be bound to a distinct \nname before being used and by allowing projections from modules only via module paths [20]. For simplicity, \nwe permit only module paths in functor applications. Signature sealing is opaque as in OCaml and we do \nnot support transparent signature sealing ` a la SML. A module type S is either a recursively dependent \nsigna\u00adture or a functor signature. In a structure rec(X : S)struct d1 ... dn end and a sig\u00adnature rec(X)sig \nD1 ... Dn end, the variable X is bound in d1 ... dn and D1 ... Dn, respectively. Free and bound variables \nare de.ned in the usual way. We identify module expressions and module types modulo renaming bound vari\u00adables. \nA de.nition d is a binding of a module, a datatype, a type, or a value; a speci.cation D declares a module, \na datatype, a manifest type, an abstract type, or a value. For datatypes, we use an optional equality \ndenoted by [= p ']. datatype t = p ' = c of p means that the datatype t is a repli\u00adcation of another \ndatatype p ' whose constructor c expects an argument of type p. A program P is a pair of a top-level \nrecursive structure and a core expression to be evaluated. We assume that a program does not contain \nfree variables. Figure 9 gives the syntax of the core language, which is a simple functional language \nextended with type and value paths. A type path p.t and a value path p.l refer to the type component \nt and the value component l in the structure that p refers to, respectively. We use x as a metavariable \nfor term variables and c for datatype constructors.  We introduce the core language mainly for an illustrative \npurpose such as for proving type soundness and its de.nition is largely orthogonal to the formulation \nof our type system. In the rest of paper, we assume the following two useful conventions: 1) all binding \noccurrences of bound variables use distinct names; 2) no sequence of de.nitions or speci\u00ad.cations includes \nduplicate de.nitions or speci.cations for the same name.  5. A Type System for Recursive Modules Our \ntype system solves the double vision problem by intro\u00adducing path substitutions. It permits transparent \nas well as opaque type cycles by considering weakly bisimilar types as equivalent. A fragment allowing \npractical typechecking is presented in Section 7, by additionally rejecting transparent type cycles. \n 5.1 Typing Rules For typing rules, we use module contexts r, path substitu\u00adtions ., and core contexts \n.. A module context r is a .nite mapping from recursion variables to their signatures; a set . of path \nsubstitutions is a mapping from external module paths to internal recursion variables; and a core context \n. is a .nite mapping from core variables to core types: Module contexts r ::= \u00b7| r,X : S Path substitutions \n. ::= \u00b7| ., X.M = Y Core contexts . ::= \u00b7| .,x : p Note that unlike usual substitutions which substitute \npaths for variables, . substitutes variables for paths. Moreover, . maintains only the shortest external \npath for each internal recursion variable. For example, when X.M.N and Y.N are external paths for Z, \n. contains only Y.N = Z and not X.M.N = Z. In this case, by construction, . must contain X.M = Y and \nthus we can deduce X.M.N = Z. Our typing rules use the following judgments: r; .; p . m : S Well-typed \nmodules r; .; X . d : D Well-typed de.nitions r; .; p . S1 S2 S1 is a subtype of S2 r; .; X . D1 D2 \nD1 is a sub-speci.cation of D2 r . S wf Well-formed signatures r . D wf Well-formed speci.cations . P \n:(S, p) Well-typed programs r; .; . . e : p Well-typed expressions r . p wf Well-formed types r . p = \nD The signature of p contains D r; . . p1 . p2 p1 is weakly bisimilar to p2 The judgment r; .; p . m \n: S includes context path p, which is the external path for module m. The judgment r; .; X . d : D includes \nas a context path the recursion variable X of the module to which de.nition d belongs. By exploiting \ncontext paths, our type system generates path substitutions to solve the double vision problem when type\u00adchecking \nrecursive structures. The subtyping judgments for module types and speci.cations also include a context \npath so that our type system solves the double vision problem arising when checking subtyping relations. \nSubtyping rules are explained in Section 5.4. We use a dummy path . as a placeholder for path contexts. \nIn typing rules, ill-formed paths such as ..M never appear. The membership judgment r . p = D means that \nunder context r, the signature of module p contains a speci.cation D (see Section 5.2 for de\u00adtails). \nWe use weak bisimilarity r; . . p1 . p2 for type equivalence, which exploits path substitutions . to \nidentify external names with internal names of abstract types (see Section 5.5). Figure 10 shows typing \nrules for the module language. Most of the rules are standard and similar to those in the literature \n[18, 19, 28, 37]; we highlight only distinguishing features. To solve the double vision problem, the \nrule typ-str adds a new path substitution p = X to the typing context. When typechecking the structure \nbody, the type system exploits the fact that the context path p is an external reference of the recursion \nvariable X. For example, when typechecking the module Tree in Figure 6, the rule typ-str adds a substitution \nX.Tree = Y into the context. Our type system generates path substitutions for the shortest external paths \nonly: the rule typ-mdef sets the context path to the shortest external path X.M of module m; if m is \na recursive structure whose recursion variable is Y , the rule typ-str then adds a substitu\u00adtion X.M \n= Y . The rule typ-str requires that the forward declaration signature S be equivalent to the resultant \nsignature. Here, by equivalence r; .; p . S1 . S2 , we mean that both r; .; p . S1 S2 and r; .; p . \nS2 S1 hold. The reason why we require the equivalence is simply that components that are not speci.ed \nin S cannot be reached; their de.nitions are dead code. Recall that we allow components of structures \nto refer to each other only via recursion variables. The rule typ-path assigns module type S to module \npath q.M if the signature of module q contains a module speci.\u00adcation module M : S. The rule typ-self \nassigns module type S/q to module path q if q is of type S. Roughly speaking, strengthening S/q [15, \n18] makes each abstract type t in S manifestly equal to itself by changing speci.cation type t in S to \ntype t = q.t. For further discussion on strengthening, we refer the reader to Section 5.3. The subsumption \nrule typ-seal accounts for signature sealing and coerces the type S ' of module m into S. Here, we use \n[p] to mean p if m is a recursive structure in which case the double vision problem may arise; otherwise, \nit means a dummy path ..  Module expressions r; ; p . m : S X . dom(r) r . q = module M : S r; ; p \n. q : S typ-var typ-path typ-self r; ; p . X : r(X) r;; p . q.M : S r; ; p . q : S/q r . S wf r,X : S; \n,p = X; X . di : Di (1 i n) r; ; p . rec(X)sig D1 ... Dn end . S typ-str r; ; p . rec(X : S)struct \nd1 ... dn end : rec(X)sig D1 ... Dn end r . S wf r,X : S;; . . m : S ' r . S wf r;; p . m : S ' r; .;[p] \n. S ' S typ-fun typ-seal ' r; ; p . functor (X : S) = m : functor (X : S) = S r; ; p . (m : S): S r; \n; p . q1 : functor (X : S1 ) = S2 r; ; p . q2 : S ' r; ; . . S ' S1 11 typ-app r; ; p . q1 (q2 ):[X \n= q2 ]S2 De.nitions r; ; X . d : D r; ; X.M . m : S r . p wf typ-mdef typ-type r; ; X . module M = \nm : module M : S r; ; X . type t = p : type t = p r . p wf [r . q = datatype t = c of p] r;; \u00b7. e : p \ntyp-data typ-val r; ; X . datatype t [= q.t]= c of p : datatype t [= q.t]= c of p r; ; X . let l = e \n: val l : p Module types r . S wf r,X : rec(X)sig D1 ... Dn end . Di wf (1 i n)r . S1 wf r,X : S1 \n. S2 wf wf-sig wf-fsig r . rec(X)sig D1 ... Dn end wf r . functor (X : S1 ) = S2 wf Speci.cations r \n. D wf r . p wf [r . q = datatype t = c of p ] r . S wf wf-mspec wf-data r . module M : S wf r . datatype \nt [= q.t]= c of p wf r . p wf r . p wf wf-type wf-abs wf-vspec r . type t = p wf r . type t wf r . val \nl : p wf Programs . P :(S, p) \u00b7; \u00b7; . . rec(X : S)s : S ' X : S; \u00b7; \u00b7. e : p typ-prog . (rec(X : S)s, \ne):(S ' ,p) Figure 10. Typing rules for the module language Since we allow cyclic type de.nitions, the \nrules typ-type and wf-type do not check whether there is a type cycle involving t. They only check that \nthe type p is well-formed, i.e. whether every type path used in p is declared in the typing context. \nThe rule typ-prog sets the context path to a dummy path . and inspects the top-level module rec(X : S)s. \nAs the recursion variable X is bound in the top-level expression e (to be evaluated), it inspects e under \nthe context (X : S, \u00b7, \u00b7). Figure 11 shows typing rules for the core language. As most of the rules are \nstandard, we highlight only distinguish\u00ading features; see Appendix A for the omitted rules. The rule \nc-typ-path assigns type p to value path p.l if the signature of module p contains a value speci.cation \nval l : p. A type path p.t is well-formed if the signature of module p contains a speci.cation for the \ntype t (the rules c-wf-data, c-wf-type, and c-wf-abs).  5.2 Membership In Figures 10 and 11, we use \nthe membership judgment r . p = D which is inspired by .Obj of Odersky et al. [30]. The judgment means \nthat under context r, the signature of module p contains a speci.cation D. The rule mem-spec below precisely \ndescribes this idea: r; ; q . p : rec(X)sig D1 ... Dn end mem-spec r . p = [X = p]Di Since the recursion \nvariable X is local, the rule mem-spec replaces it with the corresponding external module path p. In \nthe premise, any and q may be used.  r; ; . e : p r . p wf Core expressions r . p = val l : p c-typ-path \nr; ; . p.l : p Core types ' ] r . p = datatype t [= p = c of p c-wf-data r . p.t wf r . p = type t = \np r . p = type t c-wf-type c-wf-abs r . p.t wf r . p.t wf Figure 11. Typing rules for the core language \n(excerpt)  5.3 Type Strengthening To propagate type equalities across module boundaries, we introduce \na type strengthening operation [15, 18]. To illus\u00adtrate, consider the following code (written in OCaml \nsyntax): module type S= sig type t end module M:S= struct type t = int end module N=M module F(X :S) \n=X module L = F(M) In the above code, the module M declares an abstract type t via a sealing. If the \ntype system assigned exactly the same signature S to both modules M and N, the abstract types M.t and \nN.t would be considered different. Here, we assume that two abstract types are equal only if their paths \nare the same. However, since N is merely another name for M, the type system should identify the two \ntypes M.t and N.t. Strengthening extends the signature of M so that the abstract type t in the signature \nbecomes manifestly equal to itself (using its external path M.t). By assigning the strengthened signature \nsig type t = M.t end to N, the type system can now identify M.t with N.t. The same technique applies \nto the module L, which is another alias for M obtained by applying the identity functor F. In order to \nidentify M.t and L.t, F should have type functor (X : S)-> S with type t = X.t rather than just functor \n(X: S)-> S. The strengthening operation S/q extends the signature S of module q and makes each abstract \ntype t in S manifestly equal to itself using its external path. It is de.ned as follows: (rec(X)sig D \nend)/q \u00a3 rec(X)sig D/q end (D1 ... Dn)/q \u00a3 D1 /q ... Dn/q (functor (X : S1 ) = S2 )/q \u00a3 functor (X : \nS1 ) = S2 (module M : S)/q \u00a3 module M : S/q.M (datatype t = c of p )/q \u00a3 datatype t = q.t = c of p (datatype \nt = p.t = c of p)/q \u00a3 datatype t = p.t = c of p (type t = p )/q \u00a3 type t = p (type t)/q \u00a3 type t = q.t \n(val l : p)/q \u00a3 val l : p For notational convenience, we write D for a sequence of speci.cations D1 ... \nDn. Datatype and manifest type spec\u00adi.cations may have only one type equality as in OCaml. Hence, if \na datatype is already a replication of another one, we do not strengthen it again. We also do not strengthen \nmanifest type speci.cations. The rule typ-self in Figure 10 uses the strengthening oper\u00adation: if module \npath q is of module type S, it is also of mod\u00adule type S/q. Using the rule typ-self, our type system \ncor\u00adrectly propagates type equalities across module boundaries including .rst-order functor boundaries. \nTo fully propagate type equalities across higher-order functor boundaries, how\u00adever, we need to extend \nour system with applicative func\u00adtors [19] or singleton kinds [39], which is beyond the scope of this \npaper. 5.4 Subtyping Rules Figure 12 shows subtyping rules. As the double vision prob\u00adlem may arise \nin checking subtyping relations, the rules sub-sig and sub-mod update the context path appropriately \nas in the rules typ-str and typ-mdef in Figure 10. The rules sub-sig and sub-fsig implicitly assume alpha-conversion \nof bound variables, as indicated by the use of the same recur\u00adsion variable X. The rule sub-sig for subtyping \non signa\u00adtures permits depth, width, and permutation subtyping as in record subtyping. The rule sub-fsig \nfor subtyping on functor signatures is, as usual, contravariant in argument signatures and covariant \nin result signatures. The rules for subtyping on speci.cations are standard except that we use weak bisimi\u00adlarity \nr; . p1 . p2 for type equivalence.  5.5 Type Equivalence by Weak Bisimilarity This section de.nes our \ntype equivalence relation as the largest weak bisimulation [23] of a labeled transition system on types \n[28]. The labeled transition system is parameterized by the typing context (r, .). Alternatively, we \ncould have de.ned type equivalence more declaratively using mixed induction-coinduction in the style \nof [29]. Indeed, our ac\u00adcount of cyclic types and type abbreviations relies on the ability to mix induction \nand coinduction, which weak bisim\u00adilarity naturally supports by de.nition. Figure 13 shows the labeled \ntransition system on types, which consists of two sets of rules: one for labeled tran\u00adsitions and the \nother for silent transitions. Informally, two types are weakly bisimilar, or equivalent, if their tree-like \nex\u00adpansions share the same pattern of labeled transitions. More\u00adover, given a type p, all the types reachable \nfrom p by silent transitions are equivalent to p. Technically, labeled transi\u00adtions analyze the structure \nof a given type, while silent tran\u00adsitions allow us to analyze trivially equivalent types such as type \nabbreviations and datatype replications. For labeled transitions, we use 0 to denote a stuck state to \nwhich no transition can be applied. The rules l-tran-unit, l-tran-abs, and l-tran-data transform the \nunit type 1, abstract types p.t, and datatypes q.t to 0 with the labels 1, p.t, and  r,X : rec(X)sig \nD1 ... Dn end; ,p = X; X . DU(i) Di ' (1 i m) \u00df : {1, \u00b7\u00b7\u00b7 ,m} ={1, \u00b7\u00b7\u00b7 ,n} sub-sig r; ; p . rec(X)sig \nD1 ... Dn end rec(X)sig D ' ... D ' end 1 m r; ; . . S ' S1 r,X : S1 ' ;; . . S2 S ' r; ; X.M . \nS S ' 12 sub-fsig sub-mod '' r; ; p . functor (X : S1 ) = S2 functor (X : S1 ) = S ' r; ; X . module \nM : S module M : S 2 '' r; . p1 . p2 r; . p1 . p2 sub-data '' r; ; X . datatype t = p1 = c of p1 \ndatatype t = p2 = c of p2 r; . p1 . p2 r; . p1 . p2 sub-data2 sub-type ' r; ; X . datatype t [= p1 ]= \nc of p1 datatype t = c of p2 r; ; X . type t = p1 type t = p2 sub-abs-abs sub-type-abs r; ; X . type \nt type t r; ; X . type t = p type t r; . p1 . p2 sub-data-abs sub-val r; ; X . datatype t [= p ' ]= \nc of p type t r; ; X . val l : p1 val l : p2 Figure 12. Subtyping rules Labeled transition rules r; \n. 1 1f 0 (l-tran-unit) r; . p1 = p2 arif pi (l-tran-fun) r; . p1 * p2 prdif pi (l-tran-prod) r . p = \ntype tp = q/. l-tran-abs p.t r; . p.t f 0 r . p = datatype t = c of pp = q/. l-tran-data p.t r; . p.t \nf 0 r; . p1 .t1 f \u00b7\u00b7\u00b7 fpn.tn fp1 .t1 l-tran-cycle pi .ti r; . p1 .t1 f 0 Silent transition rules r . \np = type t = p s-tran-type r; . p.t f p r . p = type tp = q . s-tran-abs r; . p.t f q.t r . p = datatype \nt = c of pp = q . s-tran-data r; . p.t f q.t r . p = datatype t = q.t = c of p s-tran-alias r; . p.t \nf q.t Figure 13. A labeled transition system q.t, respectively. As their labels are distinct from each \nother, the unit type, abstract types, and datatypes are equivalent to only themselves (and their aliases). \nThe rule l-tran-cycle allows us to transform a path p1 .t1 pertaining to a silent cycle (which otherwise \nwould go on forever without emitting any label) into 0, with the label pi.ti of any member of this cycle; \nas a result, all members of this cycle are seen as equivalent, but they are still distinct from members \nof other silent cycles. The rule l-tran-fun transforms a function type p1 = p2 to either p1 with the \nlabel ar1 or p2 with the label ar2 . Similarly, the rule l-tran-prod transforms a product type p1 *p2 \nto either p1 with the label prd1 or p2 with the label prd2 . Silent transition rules cover type abbreviations, \npath sub\u00adstitutions, and datatype replications. First, the rule s-tran-type unfolds a type abbreviation. \nSecond, the rules s-tran-abs and s-tran-data inspect path substitutions so as to transform an external \ntype path p.t to its internal type path q.t. Finally, the rule s-tran-alias transforms a replicated datatype \np.t to its original one q.t. For the silent transition rules s-tran-type, s-tran-abs, and s-tran-data, \nwe use a new judgment p = q . which is de.ned as follows: ' p = X . ,p = X,  if p = q . , then p.M \n= q.M . for any M.  As we now have transition rules, we are ready to de.ne weak bisimilarity. Let us \nstart with de.ning several new notations. We write r; . p1 f* p2 for the transitive re.exive closure \nof the single-step silent transition. We write ll r; . p1 f* p2 to mean r; . p1 f* p3 , r; . p3 fp4 , \nand r; . p4 f* p2 for some p3 and p4 . For a binary relation S, we write p1 Sp2 to mean (p1 ,p2 ) .S \nand de.ne its inverse as {(p1 ,p2 ) | (p2 ,p1 ) . S}. De.nition 5.1 (Weak simulation). A binary relation \nS over types is a weak simulation under context (r, ) if and only if, whenever r; . p1 Sp2 , '' 1. if \nr; . p1 fp 1 , then there exists some p such that 2 ' '' r; . p2 f* p and r; . p1 Sp2 ; 2 l '' 2. if \nr; . p1 fp , then there exists some p such that 12 l ' '' r; . p2 f* p and r; . p1 Sp 22 .  De.nition \n5.2 (Weak bisimulation and weak bisimilar\u00adity). A binary relation S is said to be a weak bisimula\u00adtion \nif both S and its inverse are weak simulations. We say that p1 and p2 are weakly bisimilar under (r, \n.), written r; . p1 . p2 , if there exists a weak bisimulation S such that r; . p1 Sp2 . To illustrate \nhow weak bisimulations work, we show how to typecheck the function plant in Tree in Figure 6. Specif\u00adically, \nwe show a weak bisimulation S such that X.Tree.t and int * X.Forest.f are weakly bisimilar. When type\u00adchecking \nplant, the typing context is as follows: r= X:S Y : rec(Y)sig type t = int * X.Forest.f val plant : int \n-> X.Forest.f -> X.Forest.f -> X.Forest.f end = X.Tree = Y We let S0 be {(X.Tree.t, int * X.Forest.f)}. \n Since r; . X.Tree.t f Y.t by the rule s-tran-abs, we let S1 be {(Y.t, int * X.Forest.f)}.  Since r; \n. Y.t f int * X.Forest.f by the rule s-tran-type, we let S2 be {(int * X.Forest.f, int * X.Forest.f)}. \n Then, S = S0 \u00d8S1 \u00d8S2 \u00d8SId is a desired weak bisimula\u00adtion where SId = {(p, p) | p is a type}. Hence, \nthe function plant in Tree typechecks. Conversely, X.t and X.u below are not weakly bisimilar. rec(X)sig \ntype t = X.t type u = X.u end They both can go on forever without generating any label, but they can \nalso respectively emit the labels X.t and X.u which are distinct.  6. Operational Semantics This section \npresents a light-weight small-step operational semantics similar to that of Traviata [28]. Speci.cally, \nwe give the operational semantics for a program (m, e) where the evaluation begins by reducing the given \nexpression e under the top-level recursive structure m. For core expressions, we use a call-by-value \nreduction strategy using evaluation contexts. For module expressions, especially for functor applications, \nwe use a call-by-name reduction strategy using module environments, which are mappings from recursion \nvariables to their de.nitions. We do not statically reject ill-founded recursions and let them diverge. \nWe choose this style of operational semantics in or\u00adder to be independent of the evaluation strategy \nof recursive modules and to be able to successfully evaluate our moti\u00advating examples, which OCaml can \nhandle as well. Addi\u00adtionally, it makes it easy to establish a type soundness re- Values v ::= () | Ax \n: p.e | (v1 ,v2 ) | p.c v Contexts K ::= {} | Ke | vK | (K,e) | (v, K) | ai(K) | p.c K | case K of p.c \nx . e Environments E ::= \u00b7|E,X = m (Ax.p : e) v =( [x = v]e ai(v1 ,v2 ) =( vi case p.c v of q.c x . e \n=( [x = v]e '' E. r .n r |E E. p = let l = e red-path red-val ' E. r.l = r ' .l |E E. p.l = e |E ' '' \ne =( e E. e = e |E K {} = red-beta red-ctx ' ' E. e = e |E E. K{e1 }= K{e ' }|E Figure 14. Small-step \ncall-by-value operational semantics using evaluation contexts for the core language sult at the surface \nlanguage level. However, this semantics is not required by the type system, and we may eventually choose \na more usual backpatching operational semantics as in RTG [7] or OCaml. Since the evaluation of a functor \napplication may diverge without leading to a structure, we introduce extended mod\u00adule paths which contain \nfunctor applications as components. Module paths p ::= X | p.M Extended module paths r ::= r(p) | r.M \n| p Core expressions e ::= \u00b7\u00b7\u00b7 | r.l The extended module paths only appear during evaluation; they may \nnot be used in a source program. Note that in a functor application path r(p), the argument p is a normal \nmodule path. This is because we adopt the call-by-name reduction strategy for module expressions. Core \nexpressions e now contain extended value paths r.l. Figure 14 shows the de.nition of values v, evaluation \ncontexts K, module environments E, and reduction rules for '' the core language. We use the judgment \nE. e = e |E which means that under environment E, expression e reduces ' to e with extended environment \nE '. If the reduction of e does ' not involve the reduction of a functor application, E and E are the \nsame. The rule red-path expands a value path r.l into another one r ' .l by a one-step expansion of its \nmodule path r. The rule red-val unfolds the de.nition of a value path p.l if p is a structure containing \na value de.nition let l = e. The rule ' red-beta covers the usual .-reductions, denoted by e =( e . The \nrule red-ctx is an inner reduction rule following the call\u00adby-value reduction order. Figure 15 shows \ncall-by-name reduction rules for the module language. The path normalization judgment E. r .n '' r |E \nmeans a one-step expansion of module abbreviation r. ' The module reduction judgment E. r = m |E means \nthat under environment E, extended module path r reduces  '' Path normalization E. r n r |E '' E. r \n= r |E pn-red '' E. r n r |E '' E. r n r |E pn-path ' E. r.M n r ' .M |E '' E. r n r |E pn-app ' E. r(p) \nn r ' (p) |E ' Module reduction E. r = m |E ' E. r = (functor (X : S) = m) |E ms= m ' m = rec(Y : S ' \n)sY ./dom(E) red-app ' E. r(p) = Y |E,Y = [X = p]m E. r = (functor (X : S) = m) |E '' ms= mm is not a \nstructure red-app2 ' E. r(p) = [X = p]m |E ' E. p = module M = m ms= m red-mdef ' E. p.M = m |E X . dom(E) \nred-var E. X =E(X) |E Membership E. p = d E. p = rec(X : S)struct d1 ... dn end |E mem-def E. p = [X \n= p]di ' Unsealing ms= m ' m is not a signature sealing ms= m unseal2unseal ' ms= m (m : S) s= m Figure \n15. Call-by-name reduction rules for the module language to its de.nition m with extended environment \nE '. The rule red-app chooses an alpha-equivalent structure of the func\u00ad ' tor body m without sealings, \nif its recursion variable Y is already used in the domain of the environment E. Hence, the functor application \npath r(p) reduces to a new recursion variable Y while the environment is extended with a map\u00adping from \nY to its de.nition. The rule red-mdef is de.ned in terms of module paths instead of extended module paths \nbe\u00adcause it uses as its premise a membership judgment, which is also de.ned in terms of module paths. \nThe membership judgment E. p = d means that under environment E, module p contains a de.nition d. It \nis de.ned in terms of module paths because functor application paths are always .rst replaced with recursion \nvariables by the rule red-app before being applied to the membership judgment. r . p = type tp = q/. \nn-unit n-abs r; .;G . 1 \\ 1 r; .;G . p.t \\ p.t '' r; .;G . p1 \\ p r; .;G . p2 \\ p 12 n-fun '' r; .;G \n. p1 = p2 \\ p1 = p 2 '' r; .;G . p1 \\ p r; .;G . p2 \\ p 12 n-prod '' r; .;G . p1 * p2 \\ p1 * p2 r . p \n= datatype t = c of pp = q/. n-data r; .;G . p.t \\ p.t ' r . p = type t = p r; .;G . p.t . p \\ p n-type \n' r; .;G . p.t \\ p r . p = type tp = q . r; .;G . p.t . q.t \\ p n-abs2 r; .;G . p.t \\ p r . p = datatype \nt = c of p ' p = q . r; .;G . p.t . q.t \\ p n-data2 ' r; .;G . p.t \\ p r . p = datatype t = q.t = c \nof p ' r; .;G . p.t . q.t \\ p n-self ' r; .;G . p.t \\ p Figure 16. Type normalization As in the rule \nmem-spec in Section 5.2, the rule mem-def replaces the local recursion variable X with its valid external \npath p. ' The unsealing judgment ms= m strips away sealed signatures in the module m. Theorem 6.1 (Soundness). \nLet a program (m, e) be well\u00adtyped. Then, the evaluation of e either returns a value or else gives rise \nto an in.nite reduction sequence. We prove type soundness by the usual progress and type preservation \nproperties. Progress is easy, but type preserva\u00adtion is subtle: it does not hold when a value is passed \nacross opaque sealings. We address this by making all path substi\u00adtutions available globally; hence, \nwe can always obtain the most precise type of a given value using path substitutions. This is indeed \nequivalent to removing opaque sealings, thus breaking type abstraction. The key lemma in the soundness \nproof states that the program remains well-typed after mak\u00ading all path substitutions available globally, \nor equivalently removing sealings. We prove the lemma by .nding an appro\u00adpriate weak bisimulation in \nthe absence of sealings, which equates all the types that are weakly bisimilar in the pres\u00adence of sealings. \n 7. An Algorithmic Type System This section presents an algorithmic type system which is obtained by \nrejecting transparent type cycles. To reject such cycles, we .rst de.ne type normalization which fails \nif and only if a type contains a dangling reference or a transpar\u00adent type cycle. Then, we extend with \ntype normalization the rules for checking the well-formedness of types in Figure 10: now a type is well-formed \nif and only if its normalization succeeds. Finally, instead of weak bisimilarity, we employ an algorithmic \ntype equivalence relation based on type nor\u00admalization, which makes our type system clearly decidable. \n Figure 16 de.nes a type normalization algorithm. The judgment r; .;G . p1 \\ p2 means that the algorithm \nnor\u00admalizes type p1 into type p2 with respect to r and .We use a metavariable G for a set of type paths \np.t. The notation G . p.t means G \u00d8{p.t} whenever p.t /. G. Normalization fails either if it tries to \nunfold a type path p.t which is already a member of G or if the membership judgment for p.t fails. The \nformer indicates that the de.nition of p.t constitutes a transparent type cycle, whereas the latter happens \nwhen p.t is a dangling reference. To reject transparent type cycles and thereby the program containing \nsuch cycles altogether, we replace r . S wf and r . D wf with new well-formedness judgments r; . S wf \nand r; . D wf in all typing rules in Figure 10. Moreover, in the rules typ-type and wf-type, we check \nwhether a given type p is normalizable, using the judgment r; ; *. p \\ p ' : ' r; ; *. p \\ p typ-type \nr; ; p . type t = p : type t = p ' r; ; *. p \\ p wf-type r . type t = p wf As for type equivalence, given \ntwo arbitrary types, we .rst normalize them and then check equivalence on the nor\u00admalized types by syntactic \nequality. We employ a new judg\u00adment r; . p1 . p2 for the algorithmic type equivalence relation, which \nmeans that two types p1 and p2 are equiva\u00adlent under r and , and is de.ned as follows: ' ' ' ' r; ; * \n. p1 \\ p r; ; * . p2 \\ p p = p 1 2 1 2 eq-types r; . p1 . p2 The algorithmic type system uses type \nequivalence r; . p1 . p2 instead of weak bisimilarity r; . p1 . p2 . Thanks to the rules n-abs2 and n-data2 \nin Figure 16, which exploit path substitutions, we still solve the double vision problem while the type \nsystem remains decidable. Lemmas 7.1 and 7.2 below imply that our algorithmic type equivalence is sound \nand complete with respect to weak bisimilarity if the program does not contain transparent type cycles. \nLemma 7.1. r; . p1 . p2 if and only if r; . p1 . p2 , ' '' ' :p1 , r; ; *. p1 \\ p and :p2 , r; ; *. p2 \n\\ p2 . 1 Lemma 7.2. For any p , r, , and G, it is decidable whether '' there exists a type p such that \nr; .;G . p \\ p . As a corollary of Lemmas 7.1 and 7.2 and Theorem 6.1, the algorithmic type system is \nsound and decidable. Theorem 7.3. The algorithmic type system is sound and decidable. Without type parameters, \nour language of types can ex\u00adpress only regular types. As practical algorithms are avail\u00adable both for \nequality and uni.cation4 on regular types, we could have built an algorithmic type system based on the \nfull weak bisimilarity, without excluding transparent type cy\u00adcles. However, extending our language with \ntype parameters introduces non-regular equi-recursive types. Strictly speak\u00ading, equality of equi-recursive \ntypes with type parameters is still decidable [6]. Solomon [38] has shown it to be equiv\u00adalent to the \nequivalence problem for deterministic push\u00addown automata (DPDA), which has been shown decidable by S\u00b4enizergues \n[36]. There is, unfortunately, no known prac\u00adtical algorithm for DPDA-equivalence, and it is not known \nwhether there exists any algorithm for uni.cation either. Therefore, in the case of extending our language \nwith type parameters, the normalization based type system becomes crucial in providing concrete algorithms \nfor equality, uni.\u00adcation, and typechecking. Technical considerations are not the only reason that one \nwould want to reject transparent type cycles. If we were to allow them in the surface language, we would \nnot only have to accept them in de.nitions, but also infer them in core lan\u00adguage expressions, so as \nto keep the principality of type in\u00adference. Experience with early versions of OCaml, which put no restriction \non regular types, has shown that they often lead the typechecker to accept wrong programs, whose types \nmay be unsatis.able. For instance, a slightly erroneous version of List.append would lead to inferring \nthe type \u00b5a. a list, which allows only the value nil. To avoid this problem, sub\u00adsequent versions of \nOCaml restrict regular types to object and polymorphic variant types. Disallowing transparent type cycles \nduring type inference is suf.cient to avoid this issue.  8. Discussion 8.1 Separate Compilation Our \ntype system does not support separate compilation of mutually recursive modules in its current form. \nTo illustrate, consider Figure 17. In order to compile the two recursive modules Tree and Forest separately, \nwe turn each mod\u00adule into a functor that is parameterized over the recursive variable X and later tie \nthe recursive knot. Unfortunately, the functor TreeFn suffers from the double vision problem. The reason \nis that there is no way in the body of TreeFn to con\u00adnect X.Tree.t with V.t, which is the implementation \nof X.Tree.t that the body of TreeFn provides. To solve the double vision problem while supporting sep\u00adarate \ncompilation, we require the programmer to explicitly specify that the de.ning functor body be an implementa\u00adtion \nof (a submodule of) the functor parameter, for exam\u00adple, using the notation where X.Tree = V . Whenever \nit 4 Uni.cation is required for type inference in the core language.  module type ST(type u) = rec(Y)sig \ntype t val plant : int -> u -> u -> u end module type SF(type u) = rec(Z)sig type f val plant : u -> \nZ.f -> Z.f end module type S= rec(X)sig module Tree : ST(X.Forest.f) module Forest : SF(X.Tree.t) end \nmodule TreeFn (X : S) = rec(V : ST(X.Forest.f) with type t = int * X.Forest.f) where X.Tree f V struct \ntype t = int * X.Forest.f let plant (i : int) (x : X.Forest.f) (y : X.Forest.f) = X.Forest.plant (i, \nx) y (* error without the equation in the box *) (* as V.t = int * X.Forest.f= X.Tree.t *) end module \nForestFn (X : S) = rec(W : SF(X.Tree.t) with type f = Nil | Cons of X.Tree.t * W.f) struct type f = Nil \n| Cons of X.Tree.t * W.f let plant (x : X.Tree.t) (y : W.f) = W.Cons (x, y) end module TreeForest = rec(X \n:S)struct module Tree = TreeFn(X) module Forest = ForestFn(X) end Figure 17. Separate compilation encounters \nsuch an equation, the type system simply adds a path substitution X.Tree = V into the typing context. \nThen, we can conclude that X.Tree.t and V.t are weakly bisimilar (and also equivalent by the algorithmic \ntype equiv\u00adalence relation), and thus solve the double vision problem while supporting separate compilation. \nWhen declaring and applying the functor TreeFn, the type system additionally checks if the signature \nof the functor body V is a subtype of that of the argument X.Tree. This mechanism can be further simpli.ed \nif we con\u00adsider a .le based approach, similar to OCaml s packing mechanism [3]. The OCaml compiler provides \ntwo options: -for-pack Name tells it that a module should be com\u00adpiled as though it were a substructure \nof a module Name; -pack then combines several separately compiled modules into a hierarchical structure, \nwhose name must match the one declared by -for-pack. An explicit sealing signature can be provided for \nthis structure. To extend this approach to recursive modules, one just has to provide in advance the \nsignature for Name, allowing it to be used recursively in all modules compiled with -for-pack Name . \nThe already available sealing mechanism is suf.cient to ensure the va\u00adlidity of the provided signature. \nNote that this is essentially the same functionality as in the functor based scheme; we are just generating \nautomatically the where clauses accord\u00ading to the name of the compiled module and its -for-pack information. \nTo our knowledge, no previous work supports separate compilation of recursive modules using functors \nwhile solv\u00ading the double vision problem. Whereas others rely on mixin-style recursive linking to support \nseparate compila\u00adtion [10, 12, 32], which deviates much from ML modules, we only slightly extend the \nnotation of functors. We remark, however, that our approach may be considered a restricted form of mixin-style \nrecursive linking.  8.2 Type Reconstruction The type system requires that each recursion variable be \nan\u00adnotated with the principal signature and the argument of each function with a core type. We can easily \nrelax this restriction by requiring annotations only for components used in for\u00adward references as in \n[34]. Furthermore, there are several ways to reduce redundancy in annotations. For example, for nested \nrecursive modules, one needs to specify forward dec\u00adlaration signatures only for leaf-level modules, \nwhich are structures containing no module de.nitions. Starting with those explicitly annotated signatures, \na type reconstruction algorithm may build up signatures for enclosing modules in the bottom up fashion. \nFor function de.nitions that do not use forward references, we may use the usual type inference algorithm \nto infer their types.  9. Related Work 9.1 Recursive Modules Crary et al. [6] were the .rst to propose \na type-theoretic foundation of recursive modules. They introduce recursively dependent signatures and \nrecursive structures, and interpret them in the context of a phase distinction formalism [16]. To avoid \nthe double vision problem, their calculus requires forward declaration signatures to be transparent. \nFor exam\u00adple, this means in Figure 5 that the speci.cations of Tree.t and Forest.f should reveal their \nde.nitions, thus prevent\u00ading data abstraction between Tree and Forest. To support cyclic type de.nitions, \nthey use equi-recursive type con\u00adstructors [4] of higher kind, for which there is no known practical \nalgorithm for checking equivalence. Russo [2, 34] proposes a recursive module extension to Standard ML \n[24]. In his system, any abstract type com\u00adponents must be implemented as being manifestly equal to themselves. \nFor example, in Figure 5, one must write type t = Tree.t in Tree and type f = Forest.f in Forest.  Hence, \nforward declaration signatures may effectively in\u00adclude only manifest type speci.cations and datatype \nspec\u00adi.cations as in [6]. Although OCaml [3, 21] provides a powerful and .ex\u00adible support for recursive \nmodules, it does not have a for\u00admal speci.cation for typechecking recursive modules nor its soundness \nproof. Furthermore, it does not fully solve the double vision problem. To avoid this problem, OCaml requires \nthat abstract type speci.cations in forward decla\u00adration signatures be de.ned internally by datatype \nde.ni\u00adtions. Speci.cally, when typechecking the body of a recur\u00adsive module, type abbreviations cannot \nbe strengthened to be equal to their external paths, while datatype de.nitions can be. As for cyclic \ntype de.nitions, our approach of re\u00adjecting only transparent type cycles is inspired by OCaml. We, however, \nend up observing more transparent type cy\u00adcles due to our more robust approach to the double vision problem. \nMoreover, OCaml s support of applicative functors makes it more dif.cult to accurately detect transparent \ntype cycles [27]. Nakata and Garrigue [28] propose a recursive module cal\u00adculus called Traviata, which \nis based on OCaml. While the use of weak bisimilarity is inspired by Traviata, there are several major \ndifferences. First, Traviata supports only .rst\u00adorder applicative functors [19], while we support higher\u00adorder \ngenerative functors. This restriction to .rst-order func\u00adtors is required to render type equivalence \ndecidable in the presence of applicative functors. Indeed, path normaliza\u00adtion is generally undecidable \nwith applicative functors [14]. Second, in Traviata, the programmer has to manually spec\u00adify type coercion \nfrom internal type paths to external ones to solve the double vision problem, while our type system solves \nthis problem in a simple type theoretic way using path substitutions. Finally, in Traviata, the programmer \nneed not specify forward declaration signatures; the type system can infer them. In contrast, we require \nthe programmer to anno\u00adtate such signatures as in [3, 6, 8, 34]. Dreyer [7] proposes RTG which gives \na logical account of recursive type generativity. He later extends its ideas and techniques in the context \nof recursive modules and proposes RMC [8]. Recently, Montagu and R\u00b4emy [26] propose FY , which is a variant \nof System F, by decomposing the intro\u00adduction and elimination of existential types into more atomic constructs. \nAlthough FY is a core calculus, it may be con\u00adsidered a simple logical foundation of recursive modules. \nIn contrast to RTG and FY, we do not investigate a logical inter\u00adpretation of recursive modules, but \nfocus on how to address their typing issues from a practical point of view. Our type system typechecks \nmore recursive modules that are useful in practice. For detailed comparisons with RMC and FY, we refer \nthe reader to Section 3.  9.2 Units and Mixin Modules Instead of extending the ML module system with \nrecursive modules, several authors [10 12, 30, 32] have investigated mixin-style recursive composition \n[5] in conjunction with ML-style abstraction mechanisms and hierarchical compo\u00adsition. Compared with \nrecursive module extensions to ML, the main bene.t of using mixin-style recursive linking is that it \nis more suitable for separate compilation of mutually re\u00adcursive de.nitions. Flatt and Felleisen [12] \npropose units as a recursive link\u00ading mechanism for Scheme. Units may be considered a gen\u00aderalization \nof functors, where imports may refer to exports. Owens and Flatt [32] later extend units with ML-style \nnested modules to provide hierarchical composition. They also pro\u00advide encodings of ML-style structures \nand .rst-order func\u00adtors, but without module abbreviations, in their unit lan\u00adguage. In their language, \nan abstract type cannot be referred to in two ways in a given scope, and thus only a restricted form \nof the double vision problem arises when linking units, which can be easily avoided. Their source language \ndoes not include recursive type or value de.nitions, but it is later extended with the rec construct \nfor creating recursive def\u00adinitions to de.ne the operational semantics and prove type soundness. The \nrec construct may introduce transparent type cycles and they provide an axiomatic system for de.ning \na type equivalence on these cyclic types. In contrast, we ac\u00adcount for transparent type cycles and type \nabbreviations by means of weak bisimilarity, or mixed induction-coinduction, which has a semantic foundation. \nRecently, Dreyer and Rossberg [10] propose MixML as a unifying framework for ML modules and mixin mod\u00adules. \nMixML is able to express most interesting features of the ML module system including recursive modules \nvia relatively simple encodings. Moreover, by mixin composi\u00adtion, it also supports separate compilation \nof mutually re\u00adcursive de.nitions. Since their mixin composition requires bidirectional ML-style signature \nmatching in the presence of data abstraction and recursion, they need to solve a bidirec\u00adtional version \nof the double vision problem. For proving type soundness, they elaborate MixML to an internal language, \nshowing that well-typed programs in MixML are translated into well-typed programs in the internal language \nand the in\u00adternal language is type-sound. Again, they have to deal with transparent type cycles in their \nsoundness proof. Since the complete proof, including the de.nition of type equivalence in the presence \nof type cycles, is not published yet at the moment of writing this paper, further comparison with their \napproach has to be deferred to future work. While integrating ML modules with mixin modules is a promising \ndirection for further investigation, it requires rather drastic changes to the current implementation \nof the ML module system such as the OCaml implementation. In contrast, our system may be regarded as \na lightweight ex\u00adtension of the current implementation of recursive modules in OCaml. In particular, \nwe generalize OCaml s approach to the double vision problem and cyclic type de.nitions, and also prove \ntype soundness, which is one of our main contri\u00adbutions.   10. Conclusion This paper proposes a syntactic \ntype system for recursive modules which both solves the double vision problem and accounts for cyclic \ntype de.nitions. To solve the double vision problem, we introduce path substitutions to locally maintain \nconsistency between external and internal views of recursive modules. To account for cyclic type de.nitions, \nwe de.ne a type equivalence relation by weak bisimilarity. Our type system typechecks .exible uses of \nrecursive modules such as functor .xpoints, whose uses are restricted in pre\u00advious work. We show that \nthe type system is sound with respect to a call-by-value operational semantics. As weak bisimulations \nare hard to handle in practice, we also propose an algorithmic type equivalence relation that is compatible \nwith our solution to the double vision problem. The algorith\u00admic type system still typechecks .exible \nuses of functor .x\u00adpoints. Future work will include extending our system with .rst-class modules as in \n[33] and applicative functors [19], both of which are already available in OCaml. Acknowledgments We \nthank Andreas Rossberg, Didier R\u00b4 emy, and the anony\u00admous reviewers for their helpful comments. This \nwork was supported by the Engineering Research Center of Excellence Program of Korea Ministry of Education, \nScience and Tech\u00adnology (MEST) / National Research Foundation of Korea (NRF) (Grant 2011-0000977), Mid-career \nResearcher Pro\u00adgram through NRF funded by the MEST (2010-0022061), and National IT Industry Promotion \nAgency (NIPA) under the program of Software Engineering Technologies Devel\u00adopment and Experts Education. \nKeiko Nakata was supported by the EU FP7 project 231620 Highly Adaptable and Trust\u00adworthy Software using \nFormal Models (HATS) and the Eu\u00adropean Regional Development Fund (ERDF) through the Es\u00adtonian Centre \nof Excellence in Computer Science (EXCS).  References [1] Amthing. https://forge.ocamlcore.org/projects/ \namthing/. [2] Moscow ML. http://www.itu.dk/~sestoft/mosml. html. [3] OCaml. http://caml.inria.fr/ocaml/. \n[4] R. M. Amadio and L. Cardelli. Subtyping recursive types. ACM Transactions on Programming Languages \nand Systems, 15(4):575 631, September 1993. [5] G. Bracha and G. Lindstrom. Modularity meets inheritance. \nIn ICCL 92: Proceedings of the 1992 International Conference on Computer Languages, pages 282 290. IEEE \nComputer Society, 1992. [6] K. Crary, R. Harper, and S. Puri. What is a recursive module? In PLDI 99: \nProceedings of the ACM SIGPLAN 1999 Confer\u00adence on Programming Language Design and Implementation, pages \n50 63, 1999. [7] D. Dreyer. Recursive type generativity. Journal of Functional Programming, 17(4-5):433 \n471, 2007. [8] D. Dreyer. A type system for recursive modules. In ICFP 07: Proceedings of the 12th ACM \nSIGPLAN International Confer\u00adence on Functional Programming, pages 289 302, 2007. [9] D. Dreyer. Understanding \nand Evolving the ML Module System. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, USA, May 2005. \n[10] D. Dreyer and A. Rossberg. Mixin up the ML module system. In ICFP 08: Proceeding of the 13th ACM \nSIGPLAN International Conference on Functional Programming, pages 307 320, 2008. [11] D. Duggan and C. \nSourelis. Mixin modules. In ICFP 96: Proceedings of the .rst ACM SIGPLAN International Confer\u00adence on \nFunctional Programming, pages 262 273, 1996. [12] M. Flatt and M. Felleisen. Units: Cool modules for \nHOT languages. In PLDI 98: Proceedings of the ACM SIGPLAN 1998 Conference on Programming Language Design \nand Im\u00adplementation, pages 236 248, 1998. [13] J. Garrigue. Private rows: Abstracting the unnamed. In \nAPLAS 06: Proceedings of the 4th Asian Symposium on Program\u00adming Languages and Systems, pages 44 60. \nSpringer-Verlag, 2006. [14] J. Garrigue and K. Nakata. Path resolution for recursive nested modules. \nAvailable at http://www.math.nagoya-u.ac. jp/~garrigue/papers/, 2010. [15] R. Harper and M. Lillibridge. \nA type-theoretic approach to higher-order modules with sharing. In POPL 94: Proceed\u00adings of the 21st \nACM SIGPLAN-SIGACT Symposium on Prin\u00adciples of Programming Languages, pages 123 137, 1994. [16] R. Harper, \nJ. C. Mitchell, and E. Moggi. Higher-order mod\u00adules and the phase distinction. In POPL 90: Proceedings \nof the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 341 354, 1990. \n[17] R. Harper and B. C. Pierce. Design considerations for ML\u00adstyle module systems. In B. C. Pierce, \neditor, Advanced Topics in Types and Programming Languages, chapter 8. MIT press, 2005. [18] X. Leroy. \nManifest types, modules, and separate compila\u00adtion. In POPL 94: Proceedings of the 21st ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Lan\u00adguages, pages 109 122, 1994. [19] X. Leroy. Applicative functors \nand fully transparent higher\u00adorder modules. In POPL 95: Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium \non Principles of Program\u00adming Languages, pages 142 153, 1995. [20] X. Leroy. A syntactic theory of type \ngenerativity and sharing. Journal of Functional Programming, 6(05):667 698, 1996. [21] X. Leroy. A proposal \nfor recursive modules in Objective Caml, 2003. Available at http://caml.inria.fr/about/ papers.en.html. \n [22] D. MacQueen. Modules for Standard ML. In LFP 84: Pro\u00adceedings of the 1984 ACM Symposium on LISP \nand Func\u00adtional Programming, pages 198 207, 1984. [23] R. Milner. Communicating and mobile systems: the \npi\u00adcalculus. Cambridge University Press, 1999. [24] R. Milner, M. Tofte, R. Harper, and D. MacQueen. \nThe De.nition of Standard ML (Revised). The MIT Press, 1997. [25] B. Montagu. Programming with .rst-class \nmodules in a core language with subtyping, singleton kinds and open existential types. PhD thesis, Ecole \nPolytechnique, Palaiseau, France, \u00b4 December 2010. [26] B.MontaguandD.R\u00b4emy.Modelingabstracttypesinmodules \nwith open existential types. In POPL 09: Proceedings of the 36th annual ACM SIGPLAN-SIGACT Symposium \non Princi\u00adples of Programming Languages, pages 354 365, 2009. [27] K. Nakata. Bug report, nr. 0003674. \nhttp://caml.inria. fr/mantis/view.php?id=3674, 2005. [28] K. Nakata and J. Garrigue. Recursive modules \nfor program\u00adming. In ICFP 06: Proceedings of the eleventh ACM SIG-PLAN International Conference on Functional \nProgramming, pages 74 86, 2006. [29] K. Nakata and T. Uustalu. Resumptions, weak bisimilarity and big-step \nsemantics for While with interactive I/O: An exercise in mixed induction-coinduction. In SOS 10: Seventh \nWorkshop on Structural Operational Semantics, pages 57 75, 2010. [30] M. Odersky, V. Cremet, C. R\u00a8ockl, \nand M. Zenger. A nom\u00adinal theory of objects with dependent types. In ECOOP 03: Proceedings of the 17th \nEuropean Conference on Object-Oriented Programming, pages 201 224. Springer-Verlag, 2003. [31] C. Okasaki. \nPurely functional data structures. Cambridge University Press, 1998. [32] S. Owens and M. Flatt. From \nstructures and functors to mod\u00adules and units. In ICFP 06: Proceedings of the eleventh ACM SIGPLAN International \nConference on Functional Program\u00adming, pages 87 98, 2006. [33] C. V. Russo. First-class structures for \nStandard ML. Nordic Journal of Computing, 7(4):348 374, 2000. [34] C. V. Russo. Recursive structures \nfor Standard ML. In ICFP 01: Proceedings of the sixth ACM SIGPLAN International Conference on Functional \nProgramming, pages 50 61, 2001. [35] N. Sch\u00a8arli, S. Ducasse, O. Nierstrasz, and A. Black. Traits: Composable \nunits of behaviour. In ECOOP 03: Proceedings of the 17th European Conference on Object-Oriented Pro\u00adgramming, \npages 248 274. Springer-Verlag, 2003. [36] G. S\u00b4enizergues. The equivalence problem for deterministic \npushdown automata is decidable. In ICALP 97: Proceed\u00adings of the 24th International Colloquium on Automata, \nLan\u00adguages, and Programming, pages 671 681. Springer-Verlag, 1997. [37] Z. Shao. Transparent modules \nwith fully syntatic signatures. In ICFP 99: Proceedings of the fourth ACM SIGPLAN Inter\u00adnational Conference \non Functional Programming, pages 220 232, 1999. [38] M. Solomon. Type de.nitions with type parameters \n(extended abstract). In POPL 78: Proceedings of the 5th ACM Sympo\u00adsium on Principles of Programming Languages, \npages 31 38, 1978. Full version available as technical report DAIMI PB-54. [39] C. A. Stone and R. Harper. \nDeciding type equivalence in a language with singleton kinds. In POPL 00: Proceedings of the 27th ACM \nSIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 214 227, 2000. A. Typing Rules \nfor the Core Language Core expressions r; ; . e : p x : p . c-typ-var c-typ-unit r; ; . x : p r; ; . \n() : 1 ' r . p wf r;; ,x : p . e : p c-typ-lam ' r; ; . Ax : p.e : p = p r; ; . e1 : p1 = p r; ; . e2 \n: p2 r; . p1 . p2 c-typ-app r; ; . e1 e2 : p r; ; . e1 : p1 r; ; . e2 : p2 c-typ-pair r; ; . (e1 ,e2 \n): p1 * p2 r; ; . e : p1 * p2 c-typ-proj r; ; . ai(e): pi r . q = datatype t [= p '' ]= c of p '' r; \n; . e : p r; . p . p c-typ-con r; ; . q.c e : q.t r; ; . e1 : p1 r . q = datatype t [= p ' ]= c of p \nr; . p1 . q.t r; ; ,x : p . e2 : p2 c-typ-case r; ; . case e1 of q.c x . e2 : p2 r . p = val l : p \nc-typ-path r; ; . p.l : p Core types r . p wf r . p1 wf r . p2 wf c-wf-unit c-wf-fun r . 1 wf r . p1 \n= p2 wf r . p1 wf r . p2 wf c-wf-prod r . p1 * p2 wf r . p = datatype t [= p ' ]= c of p c-wf-data r \n. p.t wf r . p = type t = p r . p = type t c-wf-type c-wf-abs r . p.t wf r . p.t wf Figure 18. Typing \nrules for the core language   \n\t\t\t", "proc_id": "2048066", "abstract": "<p>A practical type system for ML-style recursive modules should address at least two technical challenges. First, it needs to solve the double vision problem, which refers to an inconsistency between external and internal views of recursive modules. Second, it needs to overcome the tension between practical decidability and expressivity which arises from the potential presence of cyclic type definitions caused by recursion between modules. Although type systems in previous proposals solve the double vision problem and are also decidable, they fail to typecheck common patterns of recursive modules, such as functor fixpoints, that are essential to the expressivity of the module system and the modular development of recursive modules. This paper proposes a novel type system for recursive modules that solves the double vision problem and typechecks common patterns of recursive modules including functor fixpoints. First, we design a type system with a type equivalence based on weak bisimilarity, which does not lend itself to practical implementation in general, but accommodates a broad range of cyclic type definitions. Then, we identify a practically implementable fragment using a type equivalence based on type normalization, which is expressive enough to typecheck typical uses of recursive modules. Our approach is purely syntactic and the definition of the type system is ready for use in an actual implementation.</p>", "authors": [{"name": "Hyeonseung Im", "author_profile_id": "81416603989", "affiliation": "Pohang University of Science and Technology (POSTECH), Pohang, South Korea", "person_id": "P2839314", "email_address": "genilhs@postech.ac.kr", "orcid_id": ""}, {"name": "Keiko Nakata", "author_profile_id": "81318490160", "affiliation": "Institute of Cybernetics at Tallinn University of Technology, Tallinn, Estonia", "person_id": "P2839315", "email_address": "keiko@cs.ioc.ee", "orcid_id": ""}, {"name": "Jacques Garrigue", "author_profile_id": "81100518834", "affiliation": "Nagoya University, Nagoya, Japan", "person_id": "P2839316", "email_address": "garrigue@math.nagoya-u.ac.jp", "orcid_id": ""}, {"name": "Sungwoo Park", "author_profile_id": "81100161164", "affiliation": "Pohang University of Science and Technology (POSTECH), Pohang, South Korea", "person_id": "P2839317", "email_address": "gla@postech.ac.kr", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048141", "year": "2011", "article_id": "2048141", "conference": "OOPSLA", "title": "A syntactic type system for recursive modules", "url": "http://dl.acm.org/citation.cfm?id=2048141"}