{"article_publication_date": "10-22-2011", "fulltext": "\n Cedalion: A Language for Language Oriented Programming * David H. Lorenz Boaz Rosenan Open University \nof Israel, 1 University Rd., P.O.Box 808, Raanana 43107 Israel lorenz@openu.ac.il brosenan@cslab.openu.ac.il \nAbstract Language Oriented Programming (LOP) is a paradigm that puts domain speci.c programming languages \n(DSLs) at the center of the software development process. Currently, there are three main approaches \nto LOP: (1) the use of internal DSLs, implemented as libraries in a given host language; (2) the use \nof external DSLs, implemented as interpreters or compilers in an external language; and (3) the use of \nlan\u00adguage workbenches, which are integrated development en\u00advironments (IDEs) for de.ning and using external \nDSLs. In this paper, we contribute: (4) a novel language-oriented ap\u00adproach to LOP for de.ning and using \ninternal DSLs. While language workbenches adapt internal DSL features to over\u00adcome some of the limitations \nof external DSLs, our approach adapts language workbench features to overcome some of the limitations \nof internal DSLs. We introduce Cedalion, an LOP host language for internal DSLs, featuring static vali\u00addation \nand projectional editing. To validate our approach we present a case study in which Cedalion was used \nby biolo\u00adgists in designing a DNA microarray for molecular Biology research. Categories and Subject Descriptors \nD.1.6 [Programming Techniques]: Logic Programming DSLs; D.2.6 [Software Engineering]: Programming Environments \nProgrammer workbench; D.3.2 [Programming Languages]: Language Classi.cations Extensible languages. General \nTerms Design, Languages. Keywords Language-oriented programming (LOP), Lan\u00adguage workbenches, Logic programming, \nDomain-speci.c languages (DSL). * This research was supported in part by the Israel Science Foun\u00addation \n(ISF) under grant No. 926/08. Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. OOPSLA 11, October 22 27, 2011, Portland, Oregon, USA. Copyright c &#38;#169; \n2011 ACM 978-1-4503-0940-0/11/10. . . $10.00 1. Introduction Language Oriented Programming (LOP) [5, \n7, 34]1 is a paradigm that puts domain speci.c programming lan\u00adguages (DSLs) at the center of the software \ndevelopment process. LOP is known by different code names. At Mi\u00adcrosoft, LOP was named Intentional Programming \n[27]. That project lead to the formation of the Intentional Soft\u00adware company, which uses that name to \ndescribe their ver\u00adsion of LOP [28]. Other terms related to LOP include Con\u00adcept Programming in the XL \nprogramming language [36] and Dialecting in REBOL [25]. Model Driven (Software) Development (MDD/MDSD) \n[19, 30] is also a related term, when considering domain-speci.c modeling languages as DSLs [10]. The \nLOP software development process consists of three steps: (1) a de.nition of a DSL or several interoperable \nDSLs; (2) the implementation of these DSLs, e.g., by means of interpreters, translators or compilers; \nand (3) the develop\u00adment of the software using these interoperable DSLs. LOP software development is \noften viewed as working from the middle out. The DSL de.nitions (Step 1) come .rst, fol\u00adlowed by development \nof the application on top (Step 3), which can be done in parallel with the underlying imple\u00admentation \nof the DSLs (Step 2). 1.1 Classi.cation of LOP Environments We use the term LOP environment to generally \nrefer to a language or a tool facilitating LOP software development. There are currently three general \ncategories of LOP environ\u00adments [7], each representing a unique approach to LOP. We discuss each of the \ncategories brie.y here. Table 1 provides a summary of their trade-offs. (I) Internal DSLs (or embedded \n[13] DSLs) are DSLs imple\u00ad mented from within a host programming language. Code in an internal DSL is \nactually code in the host language. These DSLs are easy and thus cost-effective to imple\u00adment, and enjoy \ninteroperability out of the box. How\u00adever, the syntax and semantics of the DSL are subject to the constraints \nof the host language. Tools provided for 1 To the best of our knowledge, the term LOP was coined by Ward \n[34] and adopted by Dmitriev [5] and Fowler [7].  DSL Development (I) Internal DSLs (II) External DSLs \n(III) Lang. Workbench (IV) CEDALION Freedom in de.nition o Cost-effectiveness use \u00ado implementation o \nuse (o implementation Interoperability  o Table 1: Properties of LOP environments the host language \ncan be used when working with inter\u00adnal DSLs, but since these tools are not made for DSLs, productivity \nwhen using them does not match that of cus\u00adtom DSL tooling. (II) External DSLs are DSLs implemented as \ncompilers or interpreters, and are thus external to the language in which they were implemented. Because \nthey are imple\u00admented externally, their developers enjoy more freedom of expression in de.ning them, \nand are only bound by the limitations of the tools they use, typically compiler\u00adgeneration tool chains, \nsuch as Lex and Yacc (which they are free to choose). However, that freedom comes at a price. Implementing \nexternal DSLs is usually costly. Tra\u00additional tool chains do not support DSL interoperability, and leave \nthe construction of productivity tools to the DSL developer, thereby making the use of these DSLs also \ncost-ineffective. (III) Language workbenches [5, 7, 14, 28] are integrated de\u00ad velopment environments \n(IDEs) for de.ning, implement\u00ading and using external DSLs. They combine the features of external and \ninternal DSLs to provide a better solu\u00adtion for LOP. They use external DSLs as a stepping stone and add \na common representation for all DSLs, a fea\u00adture associated with internal DSLs. Working with exter\u00adnal \nDSLs, language workbenches retain their freedom in de.ning DSLs, but also support interoperability between \nDSLs. They provide tooling to make the use of DSLs more practical. They also provide their own meta-DSLs \nto facilitate DSL implementation, but this part is still not as cost-effective as it is for internal \nDSLs [17].  1.2 Contribution This paper introduces Cedalion an LOP environment of a new sort, and a \ncategory in itself, we name LOP languages: (IV) LOP languages present a novel approach to LOP (Fig\u00adure \n1) . Instead of taking external DSLs and giving them internal DSL tooling (Figure 1, III), LOP languages \ntake internal DSLs and give them external DSL tooling (Fig\u00adure 1, IV). Cedalion is an example of such \nan LOP lan\u00adguage. It is the .rst LOP environment to feature hosting of internal DSLs, projectional editing \n[8], and static vali\u00ad dation. Collectively, these help to overcome the inherent restrictions on syntax \nand semantics de.nition associated with the use of internal DSLs. LOP Paradigm (II)(I) External DSLs \nInternal DSLs MPS [5] (III) (IV) LOP environment LOP environment Intentional [28] for External DSLs \nfor Internal DSLs Cedalion [4] Figure 1: Classi.cation of LOP environments The main observation is that \ninternal DSLs can provide a much better stepping stone for an LOP environment than ex\u00adternal DSLs. Internal \nDSLs are naturally interoperable and are already cost-effective with respect to DSL implementa\u00adtion. \nTheir main limitation is the constraints imposed by the hosting language on the DSL de.nition. However, \nthis limi\u00adtation seems to be easier to bridge, relative to the limitations posed by external DSLs (Table \n1). Since we use internal DSLs as the stepping stone, our LOP environment solution is essentially a host \nlanguage. We call such a host language for LOP a workbench language (as opposed to language workbench) \nor, to avoid confusion, simply: an LOP language. LOP languages contest language workbenches as the sole \npractical approach to LOP. We demonstrate that an LOP lan\u00adguage can provide a viable alternative to a \nlanguage work\u00adbench in combining the advantages of internal DSLs with the .exibility associated with \nexternal DSLs. Speci.cally, we contribute a concrete implementation of an LOP language: Cedalion [4, \n16, 23].  1.3 Evaluation As evidence of the effectiveness of Cedalion as an LOP lan\u00adguage and environment, \nwe present for illustration a small time schedule example (Section 4) and for validation a real\u00ad life \nBioinformatics case study (Section 5). The effectiveness is further evident from the use of Cedalion \nin the implemen\u00adtation of parts of Cedalion itself and its DSL libraries. These examples demonstrate \nthe viability and versatility of an LOP language as an LOP environment.  2. Properties of LOP Environments \nIn order to reason about LOP environments, we identify the following indispensable yet incomplete aspects \nof nearly every LOP environment ( DSL Bill of Rights ): Freedom of expression (DSL de.nition): An ideal \nLOP environment poses almost no syntactic or semantic lim\u00aditations on de.ning DSLs, allowing DSL code \nto be ex\u00adpressed in the way that is most familiar and intuitive to domain experts.  Economic freedom \n(DSL implementation and use): An important goal of an LOP environment is to make LOP practical and cost-effective. \nOne of the prohibitive factors in the practicality of LOP is the cost of implementing the DSLs (the cost \nof going down the LOP process). A good LOP environment reduces this cost enough to make LOP cost-effective. \nHowever, implementing the DSL is not enough. Using it (the cost of going up the LOP process) must be \ncost-effective as well. The level of tooling, such as syntax highlighting and auto-completion, determines \nthe effectiveness of the LOP environment.  DSLs freedom of association (DSL interoperability): The true \nbene.t of LOP is realized when the LOP en\u00advironment enables separate, reusable DSLs to be used together \nto implement a complex system [17]. In partic\u00ad ular, interoperability means that phrases in one DSL can \nbe embedded inside phrases in another DSL, to express multi-paradigm behavior [31].  Next, we elaborate \non each of these aspects. 2.1 Freedom of Expression (DSL De.nition) Freedom in DSL de.nition is the most \nbasic characteristic of an LOP environment. In LOP, we need to be able to de.ne DSLs to match the problem \nat hand. To be able to do that, we have to be able to de.ne a DSL exhibiting the syntax and the semantics \ndesired by the domain expert. Syntactic Freedom A good LOP environment needs to give its users the freedom \nto de.ne DSLs that resemble, as much as possible, the notation used by the domain experts. For example, \nconsider a DSL for de.ning sets, with a lan\u00adguage construct for the union operation. The natural math\u00adematical \nnotation from set theory (for the union of sets A and B) is: A . B Ideally, we should be able to make \nthe syntax for that con\u00adstruct in our DSL identical to its mathematical representa\u00adtion. One problem \nhere would be the fact that . is not an ASCII character, and thus unacceptable in ASCII-based lan\u00adguages. \nAn acceptable solution for that might be to use in\u00adstead: A union B However, using pre-.x syntax such \nas union(A, B) or (union AB) would be unadvised, since large expressions may be hard to read that way. \nIn general, some restrictions on syntax such as confor\u00admance to a grammar class, e.g., LALR(1) or LL(k), \nare ac\u00adceptable here, but may not be acceptable when DSL interop\u00aderability is considered (Section 2.3). \nOther restrictions, such as con.nement to ASCII characters or a certain lexical struc\u00adture, can be considered, \nbut obviously, the less restrictions the better. For Cedalion, our requirement is to enable the more \nnatural mathematical notation in this case (see Sec\u00adtion 3.4). Semantic Freedom Semantic freedom applies \nto both static and dynamic semantics. An important requirement from an LOP environment is the ability \nto statically validate that the DSL code is well-formed, so that errors can be de\u00adtected early, and in \nsome cases, tooling may help write valid code to begin with. An LOP environment should give DSL designers \nthe freedom to de.ne any static semantics rules of validity that make sense for their own DSL. DSLs created \non an LOP environment should also be able to have any dynamic semantics. For example, .uent in\u00adterfaces \n[6], sometime used as textual DSLs (e.g., jMock call-chains [9]) or visual DSLs (e.g., JavaBeans event\u00adgraphs \n[18]), are very limited in their meaning. They are only capable of describing things that can be represented \nby chained method calls. Many host languages for internal DSLs are very good at providing freedom in \nde.ning dynamic semantics, but because of their dynamic nature, they often do not support custom static \nsemantic rules for DSLs. For Cedalion, we require both static and dynamic semantic freedom to be supported. \n 2.2 Economic Freedom (Cost-effective DSL Implementation and Use) Cost-effectiveness is necessary for \nmaking LOP a viable ap\u00adproach in software development. All too often, software de\u00advelopers dismiss DSLs \nand use general-purpose languages instead, due to the perceived cost of developing them. In addition \nto the DSL development effort, one must take into account the cost of using DSLs. DSLs are made to be \nmore concise than code in a general-purpose language, but general-purpose languages often come with rich \ntools such as smart editors, debuggers, pro.lers, etc., that compensate for the verbosity of the language. \nWhen a DSL is lacking this kind of tools, productivity is harmed. However, pro\u00adviding such tools for \neach DSL can be prohibitively costly too [20].   (a) Interoperability through a general-purpose language \nFigure 2: DSL interoperability illustrated For Cedalion our requirement here is therefore twofold. On \nthe one hand, we require a cost-effective method for DSL implementation. On the other hand, we require \nthat the cost of providing reasonable tooling for these DSLs will be low. Only a ful.llment of both requirements \nwill enable a cost\u00adeffective LOP process.  2.3 DSLs Freedom of Association (DSL Interoperability) DSLs \nprovide good tools for solving problems in their own domains, but practical software systems are never \nabout a single problem domain. In fact, most real-life software sys\u00adtems work with multiple domains. \nOne can claim that the software of an auto-pilot mechanism of a light aircraft is all about nested control \nloops. However, what good will that software do if it cannot communicate with the motion drivers steering \nthe plane, and the sensors reading .ight informa\u00adtion? Also, while piloting in a straight line is good \nenough for limited purposes, a good auto-pilot system should be able to connect to the plane s navigational \nsystem and make geodetic computations to follow a .ight plan. All these are problem domains that require \ntheir own DSLs. DSLs freedom of association is what we call the abil\u00adity to have several DSLs work together \nto build large, com\u00adplex, multi-paradigm software, such as the software for an auto-pilot system. Traditionally, \nDSL interoperability has been achieved by having each DSL interact with a general\u00adpurpose programming \nlanguage. An example, depicted in Figure 2a, is the cooperation of Lex and Yacc (and their alike), by \nintegration to C. Both Lex and Yacc use actions written in C, and the overall scanner/parser is translated \ninto C code. The C code produced by Lex and Yacc is then com\u00adbined to create a complete scanner-parser. \nWith LOP we want to avoid the need for glue code. We want the DSLs to interact with one another directly. \nJust like Yacc .les contain embedded C code, we wish to embed code in one DSL inside code in another \nDSL. In the auto-pilot example this means, e.g., that motion code can be embedded inside control loops \n(Figure 2b). It is obvious that this kind of interoperability requires integration on both the syntactic \nand the semantic levels. Syntactic Interoperability This requires that the syntax of multiple DSLs can \nbe combined into a syntax of a com\u00adbined language. This requirement is far from trivial. For ex\u00adample, \nif our LOP environment uses a parser generator that requires grammars to be LALR(1), it is not guaranteed \nthat combining two valid LALR(1) grammars will emit a valid LALR(1) grammar. Moreover, when combining \ntwo unam\u00adbiguous grammars, there is no guarantee that the resulting grammar will remain unambiguous. \nSyntactic interoperabil\u00adity requires a method of dealing with such ambiguities. Semantic Interoperability \nWhen combining DSLs, their implementations need to interact, in order to provide a uni\u00ad.ed semantics. \nThis requires some notion of common rep\u00adresentation for all DSLs provided by the LOP environment. In \naddition, it requires coordination between the DSL imple\u00admentations. 3. Cedalion in a Nutshell Cedalion \nis a logic programming, LOP language and an IDE workbench for hosting internal DSLs. Cedalion represent \na novel approach to LOP, one that like language workbenches, bridges the gap between internal and external \nDSLs, allow\u00ading its users to enjoy the best of both worlds. However, un\u00adlike language workbenches, which \nstart with external DSLs and add a feature of internal DSLs (namely, a common rep\u00adresentation for DSLs), \nCedalion starts with internal DSLs, and adds language workbenches features (namely, projec\u00adtional editing \nand static validation) to the host programming language. However, interestingly enough, while projectional \nediting is used in language workbenches to support syntactic inter\u00adoperability for external DSLs, it \nis used in Cedalion to enable syntactic freedom in de.ning internal DSLs. The other fea\u00adture we take \nfrom language workbenches, static validation capabilities, is used in Cedalion to check DSL code as the \ncode is being edited, and for providing tooling support (e.g., auto-completion) based on that. 3.1 The \nCedalion Workbench Cedalion code cannot be edited using traditional text editors and can only be edited \nusing a special projectional editor,a dedicated editor for projectional editing. The Cedalion work\u00adbench \n[4], an Eclipse-based IDE, implements such a projec\u00ad tional editor. Projectional editing offers an alternative \nto the traditional parsing approach. With projectional editing, in\u00adstead of editing the code in a text \neditor and then parsing it to form an abstract syntax tree (AST) of the code, we edit the AST directly, \nand present it to the user using a projection, that is, a transformation to some human readable representa\u00adtion, \nwhich is usually (but not necessarily) textual. Figure 3 is a screenshot of the Cedalion workbench. The \neditor screen is structured similar to the user interface of  Figure 3: A screenshot of the Cedalion \nworkbench a Web browser. The top of the window contains a text bar (similar to the address bar of a Web \nbrowser) with a few action buttons to its left. The text bar displays the text rep\u00adresentation of the \ncurrently selected Cedalion code. The rest of the window s real-estate (code area) is dedicated to pro\u00adjecting \nthe content of the .le being edited. The tab label in\u00addicates the name of the .le. Even at .rst glance, \none can see that the Cedalion work\u00adbench differs from a text editor. The projected Cedalion code contains \nspecial symbols, and it is displayed using varying font sizes and unorthodox layout. We will explain \nthe mean\u00ading of this code in Section 4. The code comprises a hierar\u00ad chy of rectangular elements (we \ncall terms), nested inside one another. When the user clicks on a term, a selection box appears around \nit, and the content of the text bar is replaced with a textual Prolog-like projection of that term. This \ntex\u00adtual representation can be edited, and when hitting Enter, the changes are applied to the code area, \nassuming the text com\u00adplies with the simple Prolog-like syntax. The edited code can be either valid or \ninvalid Cedalion code. Unlike many syntax driven editors, Cedalion does al\u00adlow invalid code to be edited. \nFor example, an unde.ned term can be used. In such a case, Cedalion will mark this term with an error \nmarker (a red rectangle with a small red warning sign symbol at its top left), and provide the details \nof the error as a tooltip. As can be seen in Figure 3, in the case of an unde.ned concept, Cedalion claims \na missing sig\u00adnature, and uses type inference to suggest what this signature might be. Indeed, double \nclicking the red warning sign will suggest inserting such a type signature before the current statement. \nThis is the way new concepts can be introduced. Concepts and type signatures are discussed in Sections \n3.2 and 3.5, respectively.  3.2 Abstract Syntax Figure 4 shows an entity diagram of the structure of \na Cedalion program. A program consists of multiple state\u00adments. A statement consists of a single compound \nterm, and provides scope for logic variables. A compound term holds an identi.er, associating it with \na concept that determine its meaning and its arity (the number of arguments it takes). Ac\u00adcording to \nits arity, each compound term takes zero or more arguments, which are themselves terms. A term can be \nei\u00adFigure 4: Entity diagram of the Cedalion program structure  ther a number,a string,2 a variable \nreference, or a compound term. The latter allows compound terms to be complex. Concepts and variables \nare depicted in Figure 4 in gray, since they are not an actual part of the AST structure, but rather \nare de.ned implicitly by referencing them from com\u00adpound terms and variable references, respectively. \nReference to both is done through an identi.er. Identi.ers used in vari\u00adable references to specify a \nvariable are scoped within the enclosing statement. The identi.ers used in compound terms to specify \na concept are globally scoped. To avoid name col\u00adlisions, all concept identi.ers in Cedalion contain \na names\u00adpace pre.x. This is a string that represents the package in which this concept has been de.ned, \nor sometimes the DSL to which the concept belongs. Informally, DSLs can be seen as sets of concepts. \nStatements form directed acyclic graphs (DAGs). A com\u00adpound term forms a tree, where each internal node \nis a com\u00adpound term with a non-zero arity, and the leafs are com\u00adpound terms with zero arity (atoms), \nnumbers, strings, and variable references. Linking the variable references to the (implicit) variables \nthey refer to, forms a DAG, since a vari\u00adable can be referenced more then once in the same statement. \n 3.3 Dynamic Semantics The dynamic semantics of Cedalion is based on that of Pro\u00adlog, with logic variables \nand predicates playing a major role in its semantics. Logic Variables Cedalion s logic variables are \nborn un\u00adbound, and can be bound to a term. Once bound to a term, they do not change their value, unless \nthe interpreter back\u00adtracks beyond the point in time when they were bound. Cedalion has the same notion \nof term uni.cation as Prolog. This is a process in which two terms are being compared to see if they \nmatch (i.e., there exists an assignment to their variables that would make them equal). Predicates Predicates \nare concepts that de.ne a relation. Their instances (compound terms for which their concept is a predicate) \nare called goals. A goal can have zero or more solutions, i.e., assignments to the variables referenced \nfrom within the goal for which the resulting terms satisfy the relationship de.ned by the predicate. \n2 Unlike Prolog, where atoms (compound terms with zero arguments) are used as strings Like in Prolog, \nrunning a Cedalion program is done by querying a goal. The result is given in the form of zero or more \nvariable assignments. However, unlike Prolog, Cedalion predicates do not have side-effects, so Cedalion \npredicates are limited to pure logic operations. Cedalion provides around forty built-in predicates, \nwhich are predicates that provide functionality otherwise not avail\u00adable to Cedalion programs. None of \nCedalion s built-in pred\u00adicates have side effects. Cedalion programs extend this pool of predicates by \nde.ning new predicates. Similar to Prolog, this is done using Horn clauses, which are statements of the \nform: Head :-Body (Clause) where both Head and Body are goals. However, different than Prolog, in Cedalion \nthis is merely a textual representa\u00adtion for an abstract structure, where a Horn Clause statement has \na compound term of the concept named :-, with two argu\u00adments, named Head and Body. Generally, this clause \nmeans that a goal matching Head is true for every solution of Body. Each predicate can have one or more \nHorn clauses de.n\u00ading its semantics. As in Prolog, they are joined through disjunction, so a goal has \na solution if it satis.es any of the clauses de.ning the predicate it is based on. Note that clauses \nin Prolog have either the form Head :-Body. or the form Head. without a body, which is equivalent to \nHead :-true.. Cedalion does not support clauses without bodies, so the form Head :-true. should be used \nin such cases. Rewrite Rules Cedalion supports user de.ned statements. These are statements that are \nnot Horn clauses themselves, but can be translated to Horn clauses using rewrite rules. Rewrite rules \nare statements of the form: S1 S2 which gives S1 meaning in terms of S2, that is, for every statement \nS6matching S1, a statement S6, which is given by 12 S2 under the same variable assignment, is contributed. \nThis rewrite rule will de.ne semantics for statements matching S1 when either S2 is a Horn clause, or \nrewrite rules exist such that S2 can be expressed in terms of a Horn clause. Rewrite rules are not destructive. \nApplying S1 S2 does not remove S1, and it can still be used in other rewrite rules.  3.4 Projection \nDe.nition So far we discussed Cedalion s abstract syntax and dynamic semantics. We did not (yet) discuss \nconcrete syntax, since this is only provided by Cedalion s projectional editing, which is based on its \ndynamic semantics. Cedalion uses projectional editing to allow DSL de\u00advelopers to freely de.ne the syntax \nof the DSL, regard\u00adless of the limitations of any parsing algorithm, charac\u00adter set (e.g., ASCII), or \neven reading order (e.g., left to right, top to bottom). DSL syntax can include variable font sizes, \nstyles and colors. A DSL may include special sym\u00adbols and even some interaction capabilities, such as \ncol\u00adlapse/expand capabilities. Some of these capabilities (font style and color, collapse/expand) are \navailable as text edi\u00adtor features within IDEs for some programming languages. However, in Cedalion, \nthese features are part of the DSL s concrete syntax.  The concrete syntax of DSL concepts is determined \nby their projection de.nitions. A projection de.nition is a state\u00adment that de.ne how a certain concept \nis displayed. This is similar to a production rule in a grammar, only that instead of parsing a string, \nhere we render a visualization. A projec\u00adtion de.nition has the following form: display Term :: Type \nas Projection (Projection de.nition) where Term is a prototype of the concept we would like to refer \nto (i.e., a compound term that belongs to that concept, where all its arguments are variable references), \nType is its type (to be discussed in Section 3.5), and Projection is a term describing how Term is to \nbe visualized. Projection can use any of Cedalion s visualization primitives, providing labels, symbols, \nlayouts, styles and interactions. Cedalion provides around twenty such primitives, and more can be added \nby extending the Eclipse plug-in (each primitive is implemented as a Java class, associated to the Cedalion \ncode). For example, the projection de.nition of a Horn clause is: display (Head:-Body)::statement as \nh ((Head ::pred)) \":-\" ((Body ::pred)) Here we use three kinds of visualization primitives: (1) a horizontal \nlayout, represented by a whitespace-separated list, annotated with a tiny h to its top-left; (2) a label, \nrepresented by a double quoted string; and (3) place-holders for arguments, represented by double angle \nbrackets, con\u00adtaining each argument along with its type. Note how the concept Head:-Body is depicted \nusing its projection, even in its own projection de.nition. Projection de.nitions are not mandatory. \nCedalion de\u00ad.nes Prolog-like default projections for concepts. A com\u00adpound term with no arguments is \nprojected as a label con\u00adtaining its identi.er, without namespace pre.xing (e.g., a compound term of \nconcept a is projected as a ). A com\u00adpound term with arguments is projected as a label with its identi.er, \nfollowed by parentheses, containing a comma\u00adseparated list of the arguments (e.g., concept a with argu\u00adments \n1 and 2 is projected as a(1, 2) ). Projection de.ni\u00adtions are desired wherever the default rendering \nis unsatis\u00adfactory. For example, the union operator discussed in Sec\u00adtion 2.1 can be de.ned without a \nprojection de.nition, but then it would appear in the form union(A, B). A projection de.nition can do \nbetter than that, displaying it as A . B. Cedalion s projectional editing is implemented in Ceda\u00adlion. \nThe Cedalion workbench queries a predicate de.ned by the Cedalion program to know how to visualize a \ncer\u00adtain term. This predicate calls an internal predicate that pro\u00advides user-de.ned projections. Projection \nde.nitions con\u00adtribute results to that predicate, using a rewrite rule. In addition to providing Cedalion \ns concrete syntax, the projection de.nition mechanism provides hooks for Cedalion code to provide checkers \n(predicate clauses that examine the code that is being edited), and provide markers (annotations on the \ncode). Markers can, for example, report errors associated with a certain term. This mechanism opens the \ndoor for users to de.ne static semantics for their DSLs, and for Cedalion to de.ne its type system. \n 3.5 Cedalion s Type System Cedalion is statically typed. Its type system is completely implemented in \nCedalion and runs as a set of checkers, from within the projectional editor. As such, it can be extended \nby Cedalion code. Like most type systems for typed logic programming [26, 29], Cedalion s type system \nis implicit with regard to logic variables and explicit with regards to concepts. It infers the type \nof logic variables, but requires that every concept be\u00ading used shall have a type signature (stating \nthe concept s type and the types of its arguments), although, in most cases, that type signature can \nbe inferred during editing. Type er\u00adrors are presented too during editing, well before execu\u00adtion/interpretation. \nUnlike the traditional, conservative approach [22], taken by most typed logic programming languages [26, \n29], Ce\u00addalion allows some of the type checking to be performed at runtime. In a case where not all types \nare known during editing, e.g., some types are parametric and conveyed by variables, Cedalion s type \nsystem insists that these variables are to be exposed to the runtime environment. In such cases, the \nruntime environment will ensure type safety, knowing the actual types being used. Typed Terms One important \nexample of this is the typed term. A typed term is a pair of the form: Term ::Type (Typed term) where \nTerm is a term of type Type. This is a type safe way to pass arguments regardless of their type, making \ntheir type available for checking at runtime. In Section 3.4 we already saw examples for typed terms \nin projection de.nitions. Type Signatures Another example of where typed terms are in use is type signatures. \nA type signature is a statement that declares a new concept, by assigning types to itself and its arguments. \nA type signature has the form: declare Concept where ArgList (Signature) where Concept is a typed term, \ncontaining the concept being de.ned along with its type, and ArgList is a list of typed terms, providing \nthe types of the arguments. For example, the type signature of a typed term is:  declare (Term ::Type)::typedTerm \nwhere Term ::Type, Type :: type Note the difference between Type (a type variable, contain\u00ading the Term \ns type), and type a concrete type, the type of all Cedalion types. Another interesting example is the \ntype signature of the type signature statement. Since Cedalion s type system is implemented in Cedalion, \nits type signature statement has a type signature. It looks like this: declare (declare Concept where \nArgList)::statement where Concept ::typedTerm, ArgList ::list (typedTerm)  3.6 Cedalion s Tooling Support \nThe fact that Cedalion code is edited using a projectional editor, allows productivity features to be \nintegrated into the language. Here we discuss some of them. Context Menu Cedalion provides a context \nmenu for ev\u00adery term. Right clicking a term will cause a pop-up menu to appear, listing operations relevant \nto this term. Selecting this operation will execute it, performing an action such as modifying code or \ndisplaying content in the view area (a part of the Cedalion workbench made for displaying infor\u00admation \nand interacting with the user). User code can con\u00adtribute context menu entries by using context menu \nentry statements. These statements associate the caption of the en\u00adtry with an action. They also specify \na pattern for the term to be matched, in a form of a typed term. This allows entries to be speci.ed for \nspeci.c concepts, or speci.c types, thus making the menu context-dependent. Auto-completion Auto-completion \nis the feature that is used the most when editing Cedalion code. When enter\u00ading text in the text bar, \nthe user can press a key combina\u00adtion (Control+Space) to get a list of suggestions. Cedalion queries \nthe collection of concepts that can be used in the selected location, and .nds ones which have aliases \n(ex\u00adplained next) starting with the string entered. The list is then presented to the user for choosing \nthe appropriate concept, which is then inserted as a new term. Aliases Aliases are strings associated \nwith concepts. Each concept has a natural alias, which is its internal identi.er (the name Cedalion uses \ninternally, regardless of projection), without namespace pre.xing. Additional aliases can be de\u00ad.ned \nby the user. Cedalion also infers aliases in some cases from projection de.nitions (e.g., when the projection \nis a label, the content of the label is used as an alias for this con\u00adcept). Concepts and aliases have \na many-to-many relation\u00adship, where a single concept can have multiple aliases (e.g., its internal name \nand something based on its projection), and several concepts can share the same alias. In the latter \ncase, disambiguation is done by choosing the desired entry from the auto-completion list of choices. \nAdapters An adapter of type T1 to type T2 is a concept of type T2, which takes one argument of type T1, \nand seman\u00adtically acts as a proxy, adding no additional meaning to its argument. Cedalion has a special \ndeclaration for declaring a concept as an adapter. This allows Cedalion to reconcile con\u00adcepts of type \nT1 in the context where a concept of type T2 is needed. Adapters allow Cedalion s auto-completion to \noffer concepts of type T1 in these cases, and when a type mis\u00admatch between T1 and T2 is presented, Cedalion \nautomati\u00adcally inserts the adapter to .x this error. De.nition Search Concepts are centric to the way \nCedalion code is programmed. Concepts are introduced in Cedalion in both the DSL de.nition and the DSL \ncode. To allow Cedalion users to be able to understand the different con\u00adcepts and be able to track their \nde.nitions, Cedalion provides a mechanism for searching concept de.nitions. When select\u00ading a compound \nterm, Cedalion s context menu displays the option Show De.nitions. Selecting this option will dis\u00adplay \nthe full story behind the concept associated with the selected term. This story includes all aliases \nassigned to this concept, the type signature, projection de.nition and all semantic de.nitions. The nature \nof the semantic de.nitions for a concept depend on the concept type. For example, for predicates, the \nsemantic de.nition includes all clauses con\u00adtributing results to that predicate. A semantic de.nition \nof a statement includes all rewrite rules translating this state\u00adment into others. For a type, it includes \nall type signatures of concepts of that type. The user can relate new de.ning state\u00adments to concepts \nusing de.nes statements. Each de.ning statement is displayed along with the .le name in which it is de.ned. \nClicking that de.nition will open that .le, and highlight the relevant de.nitions with a green background. \n 3.7 Implementation Cedalion is implemented as an open source project [4], in a pre-alpha maturity state. \nIt is implemented as an Eclipse plug-in, in Java (a little over 5K lines of code), Prolog (less than \n500 lines of code) and Cedalion (about 700 statements). The Java code provides integration to Eclipse \nand to the Prolog engine (SWI Prolog [35]), and provides visualization and interaction capabilities, \nsuch as the Cedalion editor win\u00addow, a collection of .gures to display, context menu capabil\u00adities, etc. \nThe Java code does not have any knowledge of the Cedalion programming language nor of its DSLs. It merely \nprovides the physical capabilities. The Prolog code implements a logic engine, i.e., a soft\u00adware module \ncapable of storing facts and deduction rules, and answering queries, supporting namespaces and rewrite \nrules. To communicate with the part of Cedalion imple\u00admented in Java, the Prolog part implements the \nserver side of that communication protocol. It also implements Cedalion s built-in predicates. The Cedalion \ncode implements Cedalion s advanced fea\u00adtures, such as its projection editing, type system, and tooling \nsupport, in what we call the bootstrap package. These fea\u00adtures are implemented in a pure logic fashion, \nas answers to queries. The queries originate from the Java code through a set of predicate we call the \nCedalion Public Interface (CPI). These predicates de.ne the contract between the Java code (the front-end) \nand the Cedalion code (the back-end). For example, CPI contains a predicate for querying what needs to \nbe displayed in a certain segment of a source .le. The bootstrap package implements this predicate to \nconsult the projection de.nition of the term in that segment to provide an answer. The concepts in the \nanswer correspond to Java classes implementing the actual visuals to be displayed. The formulation of \nthe CPI allows the front-end to be replaced by a different implementation (e.g., one not based on Eclipse), \nso long as it implements its side of the CPI.  4. Example: LOP with Cedalion To demonstrate LOP with \nCedalion we present in this section a complete step-by-step example. The scope of the example was deliberately \nnarrowed down to allow us to provide the complete source code, allowing the reader to extrapolate this \nexample to larger problems. Consider the problem of providing free text queries in websites of transportation \ncarriers, such as train, bus, and air operators. An example of a query may be to .nd the schedule for \ntrains from Paris to Rome today. The assumption is that these queries, while being free text, are actually \ncon.ned to a .nite (and relatively small) language, since they all have the same elements: source, destination \nand time. In this example, we shall build a parser for this language. Our input is a list of tokens, \nprovided by a smart lexical analyzer (or scanner), which, for the simplicity of our example, we assume \nis smart enough to understand date patterns and names of places. For starters, our output will be Boolean, \nindicating whether or not the list of tokens is a legal query. Later in this example we will extend our \ncode to provide more informative output. About Code Samples in this Paper Because Cedalion uses projectional \nediting, displaying Cedalion code should be done through its projection. For this reason we use the Ce\u00addalion \nworkbench s built-in code snippet mechanism, which allows us to save Cedalion code fragments into an \nimage .les. For the purpose of this paper, we use numbered lists, so that statements can be referred \nto from the text. We use the numbering Statement n.m to reference the statement at line m in Figure n. \n4.1 Step 1: DSL De.nition Following the LOP approach, we do not resort to an ad-hoc solution to this \nproblem (i.e., implement a parsing algorithm for train queries). Rather, we start with a wider angle, \nthink\u00ading of the class of problems this relates to. In this case, this is a parsing problem. We can assume \nthis is a context free lan\u00adguage, and therefore, can be solved in that scope. With LOP, query ::= routeQuery \ntimeQuery | timeQuery 6 , 6 routeQuery | routeQuery routeQuery ::= 6from6 location 6to6 location | 6to6 \nlocation 6from6 location timeQuery ::= 6today6 | 6tomorrow6 | 6on6 date Figure 5: Grammar for transportation \nqueries we always think of how to express the problem or its solution in terms of the problem domain. \nA common way to express syntax in the problem domain of context-free parsing is the use of the Backus-Naur \nForm (BNF) [15]. With this form, we can express the grammar for our query language (Figure 5). This is \nobviously a simple language, and a real-life lan\u00adguage would be much bigger. However, it is large enough \nso that implementing an ad-hoc parser for this language in a general-purpose programming language is \nrelatively hard. We would like our parser implementation to be as similar as possible to the grammar. \nThis will make it concise and easy to maintain. To make this happen, we implement the BNF notation as \na DSL in Cedalion. In Figure 5, we can identify .ve constructs used to de.ne the grammar: 1. The use \nof a token (quoted strings, location, and date). 2. The use of a non-terminal symbol. 3. Pattern alternation \n(|). 4. Concatenation of two patterns (by placing a space be\u00adtween them). 5. A production rule (the \n::= operator).  In Cedalion, we can avoid having special constructs for items 2 and 3, making our language \nsmaller. The pattern alterna\u00ad tion is given to us for free, by specifying several production rules with \nthe same symbol on their left hand side. This is because statements in Cedalion are related through disjunc\u00adtion \nby default, each contributing its own solutions. We also do not provide a construct for referring to \na symbol, because every symbol in Cedalion is a concept on its own merit. We do, however, add a sixth \nconstruct: 6. e, matching an empty string. We do so for the completeness of our DSL and for making it \nviable for other grammars as well, although for the task at hand we could do without it.  4.2 Step 2: \nImplementing the DSL in Cedalion Figure 6 provides the de.nition and implementations of the four required \nconstructs (6, 1, 4, and 5). Statement 6.1 through Statement 6.3 de.nes the e pattern, matching an  \n Figure 6: Implementation of the BNF DSL in Cedalion empty string. Statement 6.1 provides a type signature, \nde.n\u00ad ing it as a pattern with no arguments: declare e:: pattern (6.1) Statement 6.2 provides the projection \nde.nition for e, de.n\u00ading its representation as the Greek letter Epsilon whose Uni\u00adcode is 949: display \ne:: pattern as e (6.2) 949 This projection de.nition on the right hand side of the as in Statement 6.2 \nimmediately affects the way Epsilon is projected on the left hand side in Statement 6.2, as well as in \nStatement 6.1 and everywhere else. The blue words in these statements, as well as in the rest of the \ncode, highlight the top level of the statement. This gives the reader a sense of what the statement is, \nand what the arguments are. Statement 6.3 de.nes the semantics of e (thus implement\u00ading it). It de.nes \nit as a condition for a state transition. We can look at the problem of top-down parsing as a state transi\u00adtion \nproblem, where the state represents our location on the input, or alternatively, the list of tokens yet \nto be read. Our initial state is therefore the full list of tokens, and our accept\u00ading .nal state is \nan empty list. We say that text T matches pattern p if there is a transition p from T to [] (an empty \nlist). We denote that as: T . [] p The e pattern provides transitions from each state to it\u00adself. Statement \n6.3 indicates this, by providing a Prolog-like clause: Text . Text :-true (6.3) e The true on the right \nhand side of the :-operator indicates that Text . Text is true without condition. e Statement 6.4 through \nStatement 6.7 de.ne the reference to a token. Once again, it starts with a type signature: declare tToken \n::pattern where Token :: token (6.4) This time, this concept has one argument of type token. Statement \n6.5 provides a projection de.nition, presenting the token with a tiny superscript t at its left: h 12 \nt display tToken ::pattern as i ((Token ::token)) (6.5) The right hand side of the as contains a compound \nvisual, consisting of a horizontal list (the list with the tiny h at its left), containing two elements: \na half size label (a label visual inside a half size modi.er) presenting the tiny t, and to its right, \na place holder for the token. The place holder is indicated using double angle brackets, containing a \ntyped term. The tiny i indicates that Token is depicted in (green) Italics in the projectional editor. \nStatement 6.6 de.nes this construct as an adapter: use tToken ::pattern as adapter for Token :: token \n(6.6) In this case, our concept acts as a pattern while hosting a token. De.ning it as an adapter allows \nCedalion to consider tokens in the context of patters (e.g., when providing auto complete options), automatically \ninserting this adapter. Statement 6.7 de.nes the semantics of this pattern, as a consumption of a matching \ntoken (assuming one exists): [First Rest] . Rest :-true (6.7) tFirst Here too we use true as the condition, \nbut the left hand side term only matches origin states starting with this token. Statement 6.8 through \nStatement 6.10 de.ne the concate\u00ad nation of patterns: declare P1 P2 ::pattern where P1 ::pattern,P2 ::pattern \n(6.8) Note that in Statement 6.9 we use a whitespace as the oper\u00ad ator between the two patterns (recall \nitem 4). While uncon\u00ad ventional, this is possible in Cedalion, since it uses projec\u00adtional editing: display \nP1 P2 :: pattern (6.9) as h ((P1 ::pattern)) \"\" ((P2 :: pattern)) Statement 6.10 uses recursive conditions \nto de.ne the tran\u00ad sition based on a concatenation, building a transition from  Figure 7: Base de.nitions \nfor the BNF DSL Before to After if a path exists both from Before to Middle and from Middle to After: \nBefore . After :-Before . Middle, Middle . After P1 P2 P1 P2 (6.10) Finally, Statement 6.11 through Statement \n6.13 de.ne the production rule. A production rule is a Cedalion statement, and as such, its semantics \nis provided using the rewrite rule in Statement 6.13. This rewrite rule creates a transition over the \npattern at the left hand side of the ::= operator (Symbol), if a transition exists for the pattern on \nthe right hand side of the operator (Pattern): Symbol ::= Pattern (6.13) Before . After :-Before . After \nSymbol Pattern The de.nitions in Figure 6 rely on pre-existing de.nitions of the types pattern and token, \nand on the de.nition of the transition predicate. Figure 7 provides these de.nitions. The new things \nhere include a vertical layout (indicated by the tiny v and the vertical list) in Statement 7.4, and \nan alias de.nition in Statement 7.5.  4.3 Step 3: Implementing the Parser Now that we have de.ned (and \nimplemented) our DSL, we can turn to using it to implement our parser. Figure 8 shows the implementation \nof the train schedule query parser in our BNF DSL. It starts with declarations of the three token types \nour parser will encounter: a word (Statements 8.1 through 8.4, indicated by quotes), a date (Statement \n8.5) and a location (Statements 8.6 and 8.7). Statements 8.3 and 8.4 de.nes word as an adapter to a string \nin both the contexts of a token and a pattern, so that strings can be entered in these contexts. Cedalion \nwill then reconcile them by adding this concept as an adapter. The grammar is given in Statements 8.8 \nthrough 8.18. It is similar to the one shown in Figure 5, with some differ\u00ad ences. One difference we \nalready mentioned is the fact that we use separate production rules instead of using the | oper\u00adator. \nWe will need it this way later, when generating output. Another difference is the fact that we provide \ntype signa\u00adtures for the symbols (Statements 8.8, 8.12, and 8.15). They allow Cedalion to validate the \ngrammar, only based on the type signatures we already provided in Figure 6, and to pro\u00ad vide symbol names \nas options for auto completion. The last Figure 8: Implementation of the train schedule query parser \nin the BNF DSL difference is the fact that tokens appear with a tiny t to their left. We saw similar \nmarkings in projection de.nitions, e.g., for vertical and horizontal layouts (tiny v and h, re\u00adspectively). \nThis is more of a convention than a strict rule, but in Cedalion we prefer having things visible. In \nthis case, we have an adapter (the token pattern) allowing a token to be used as a pattern. The tiny \nt allows the user to either select the adapter (by clicking the t ), or to select the token it wraps \n(by clicking it). Statements 8.19 and 8.20 provide unit tests for our parser. A Cedalion Unit Test construct \ntakes a logic goal as argu\u00adment, and marks it with an error marker if this goal fails. In this case, \nwe test that both the string from Paris to Rome to\u00adday (Statement 8.19), and tomorrow, from Rome to Paris \n(Statement 8.20) are legal. Note that we provide the input tokenized as the initial state, and the .nal \nstate is an empty list. We check for a single transition, on pattern query.  Figure 9: De.nition of \na DSL for querying the train schedule  4.4 DSL Interoperability We implemented a parser that allows \nus to know whether a given list of tokens conforms to some context-free grammar. However, for our imaginary \nWeb application we would like to do more. We would like to understand what the list of tokens means. \nFor this, we need some way to specify the meaning of train schedule queries. Figure 9 shows type signatures \nand projection de.nitions for the constructs of a DSL for querying the train schedule database. We do \nnot provide the implementation of this DSL here, as it relies on the way the actual train schedule is \nstored, and is therefore beyond the scope of this example. We pur\u00adposely de.ned the projection of its \nconstructs to resemble English text, and for this reason there is a noticeable simi\u00adlarity between some \nof the projection de.nitions in Figure 9 and the production rules in Figure 8. With that said, notice \nthat these de.nitions are independent of one another. They merely describe the same problem. We now wish \nto allow our parser to produce query terms in the query DSL de.ned in Figure 9. Figure 10 shows such \na parser, as a re.nement to the one we implemented in Figure 8. We re-de.ne our grammar symbols to take \narguments. These arguments are the query terms represented by the text that was parsed by these symbols. \nOn the right hand side, these variables appear as logic variables, and they are constructed into query \nterms on the left hand side. This way, parsing some text will emit an equivalent query term. The unit \ntests in Statements 10.12 and 10.13 show how the query terms constructed by the parser are similar to \nthe original text. This is a good example of DSL interoperability, where the BNF DSL and the query DSL \nare agnostic of each other, but still can be used together, with no need for glue code in some general-purpose \nlanguage. 5. Validation: DSL for Bioinformatics In this sections, we describe a larger case study to \ndemon\u00adstrate Cedalion s usefulness. In this case study, we de.ned in Cedalion a DSL that helped our colleagues \nat Technion IIT s Department of Biology specify a custom made DNA microarrays for Protein Binding [2]. \nThe outcome of their DSL program was sent to production and used in a real ex\u00adperiment in Biology research \n[1].  5.1 Brief Overview of the Problem Domain In Biology research, the interaction between proteins \nand DNA is studied extensively. Such interactions between DNA and a special class of proteins called \ntranscription fac\u00adtors (TF) regulates the transcription of genes encoded by the DNA into RNA and eventually \ninto other proteins [3]. Studying these interactions is important to the understand\u00ading of physiology \nand disease processes. However, research\u00ading them is far from trivial, due to the complexity of the biological \nsystems involved. Traditionally, performing in vitro (in a test tube) exper\u00adimentation to test a theory \nabout binding of a protein to a DNA sequence was very expensive and time consuming, since a different \nexperiment was required for every DNA sequence that was tested. Recent development in the .eld introduced \nthe Protein Binding Microarray (PBM) [2]. This is a special kind of DNA microarray, a chip containing \nmi\u00adcroscopic wells, each containing a different DNA sequence, with multiple instances in each well (a \nPBM is a microarray dedicated to binding proteins to DNA sequences). Perform\u00ading experiments with a microarray \nallows one experiment to be applied on multiple DNA sequences. Contemporary arrays contain the order \nof 105 different sequences. Exper\u00adimentation is done by introducing a solution containing the protein \nunder test and possible supplements, such as .uores\u00adcent markers to the chip. The protein will bind to \na speci.c DNA sequences, other nonspeci.c interactions will be elim\u00adinated during the wash steps, such \nthat the signal represents only the binding of the TF to a speci.c DNA sequence. The chip is then scanned \nusing a visible-light scanner, and the .u\u00adorescent markers attached to either the protein or the DNA \nare used to determine which sequences have been bound and which have not. This approach speeds up experimentation \ntremendously against traditional testing in test tubes, where only one sequence could be tested at a \ntime. 5.2 Problem Statement The main enabler of this technique is the ability of manu\u00adfacturers to produce \nthe microarray, along with an order of 105 different sequences. This is thanks to a highly automated \nproduction process. This possibility leaves the biologist with the need to prescribe these sequences. \nOur colleagues at Technion IIT have previously taken an ad-hoc approach to this problem. They created \na Java pro\u00adgram of about 500 lines-of-code, that provides a text .le, containing the desired sequences. \nThis program was made speci.cally to re.ect a certain design, based on a certain bi\u00adological hypothesis, \ntargeted at a certain experiment. As the research advances, hypotheses change and new microarray designs \nrequire changes to that program. This is where we proposed LOP and Cedalion. With Ce\u00addalion we can de.ne \na DSL for de.ning microarray designs, which will allow the generation of the sequence set. The ad\u00advantage \nof using a DSL is that the DSL code resembles the way the biologist thinks of the microarray design. \nThis is in contrast to the Java program, where the design is trans\u00adlated to a sequence of commands that \nproduce the list of se\u00adquences. We are not naive as to think that a biologist with no programming background \nwould be comfortable imple\u00admenting such a design using our DSL. However, they would be absolutely comfortable \nreviewing the DSL code to see that it matches their needs, and even make changes to it.  5.3 Solution \nOverview To address the problem of de.ning DNA microarrays, we .rst consider a wider problem: de.ning \nDNA sequence sets. A DNA microarray consists of different sections (experi\u00adment, negative control, positive \ncontrol, etc.), each is a set of DNA sequences. We provide a DSL for specifying such sets. It is used \nto specify each section in the DNA microar\u00adray. For each section in the microarray, the user needs to \nspecify three things: 1. the name of this section (for tracking); 2. the DNA sequence set to be used \nfor this section; and 3. the number of sequences to be randomly selected from this set. This will typically \nbe the full size of the set in experiment sections, and an arbitrary small number for control sections. \n Generating the microarray is done in two phases. First, use Cedalion to construct .les with the full \nsequence sets for each section. The .le name is derived from the microarray name, the section name and \nthe quantity (the number of sequences to be selected). Then a Perl script (<30 lines of code) performs \nthe random selection and provides the .nal sequences to be used in the microarray. The script also formats \nthe .les in a way acceptable by the microarray manufacturer. Our choice of using a script here aligns \nwith the overall Cedalion philosophy. With this philosophy, a software so\u00adlution is divided into two \nparts: (1) the program logic, im\u00adplemented in Cedalion, preferably by making extensive use of declarative \nDSLs; and (2) the program s integration to its environment, usually implemented in imperative general\u00adpurpose \nlanguages. Much of Cedalion s power comes from the fact that it is declarative, with no side effects. \nFor this end, performing some action requires the involvement of some other programming language being \nable to query Ce\u00addalion programs. The idea is to keep the imperative part as small as possible, as part \nof the DSL implementation and agnostic of the DSL code. In our case, we need to perform an action (the \nrandom decimation of DNA sequences) which does not map well into declarative terms. For this we provide \na script. However, this script is agnostic of the DSL code, that is, it has no knowledge that we are \ndealing with DNA sequences.  The .les created by the script can be uploaded to the DNA microarray manufacturer \ns website when placing an order.  5.4 The Challenge The challenge in this case study is to provide a \nDSL that will be intuitive and easy to use by non-programming bi\u00adologists. We do not expect biologists \nto be able to build a design from scratch, but we do expect them to be able to re\u00adview and maybe even \nmodify existing designs. For that, the language must be absolutely intuitive for them. It needs to be \ndeclarative, concise, and most importantly, use the common terms of the Bioinformatics world. To accomplish \nthat, we need our LOP environment to provide full freedom in de.n\u00ading this DSL, and not pose any syntactic \nor other restrictions that would make this language unintuitive to biologists. In addition, we had a \nvery short window of opportunity to complete the implementation. We had just one week from the time our \ncolleagues knew they needed to de.ne a new microarray design, until they had to submit the list of se\u00adquences \nto the manufacturer. This is due to the long pro\u00adduction time of the microarray itself (around one month). \nIn that time frame we needed to implement the DSL, the mi\u00adcroarray generation mechanism, the decimation \nscript and help them de.ne their microarray design. Failing to do so would have resulted in our colleagues \nmodifying their Java program to re.ect the new design, and using it to generate the sequences.  5.5 \nA DSL for DNA Sequence Sets We start by describing a DSL for de.ning sets of DNA se\u00adquences, and its \nimplementation in Cedalion. While we de\u00ad.ne this DSL for the purpose of DNA microarray de.nition, DNA \nsequence sets can be used in a variety of Bioinformat\u00adics tasks, such as specifying search patterns for \nchromoso\u00admal searches. Sets in Cedalion Since our goal is to de.ne sets, expres\u00adsions in our DSL all \nrepresent sets of DNA sequences. Ceda\u00adlion s bootstrap package provides a mini DSL for handling sets. \nit de.nes set(T ) as the type of sets where all elements are of type T . As in common mathematical notation, \ntesting whether an element X is in set S, and enumerating over the elements of a countable set is done \nusing the . operator. In Cedalion, the . operator is a predicate that can be used in the context of logic \nprogramming. Cedalion code can de.ne new set constructs by contributing clauses to this predicate. Due \nto the type system (Section 3.5) the element type must be speci.ed when using the . operator. Testing \nwhether el\u00adement X of type T is in set S is therefore done as follows: X .T S For convenience, Cedalion \ns mini DSL for sets also con\u00adtains a construct for de.ning new sets: T def S = D This will de.ne set \nS of type set(T ) as equal to D. Here too, we need to specify the element type for type safety. We will \nuse either of these constructs to de.ne our DNA sequence sets. In addition, this mini DSL de.nes concepts \nsuch as set uni.cation, intersection, set comprehensions, and a singleton set. Lists in Cedalion To represent \nsequences of nucleotides, we use Cedalion lists. Lists are fundamental in Cedalion, as they are in any \nlogic programming language. Nucleotides and Sequences DNA sequences are sequences of nucleotides, marked \nwith the letters A, C, G, and T. We de.ne the type Nucleotide to refer to them, and de.ne the four nucleotides \nas concepts of this type. Figure 11 demon\u00ad strates this for the A nucleotide. Statement 11.1 provides \nthe de.nition of the Nucleotide type. For convenience, we use here a single statement for both the type \nsignature and the projection de.nition. The same kind of statement is used in Statement 11.2, to de.ne \nA as a Nucleotide. Note that in both statements we de.ne atoms (i.e., concepts with no ar\u00adguments) but \nprovide a projection de.nition, mapping it to a label. We do so because we wish to display these concepts \ndifferently then their internal representation. For example, the nucleotide A is represented internally \nas a lower-case a, to conform with the naming convention for concepts in Cedalion. To conform with the \ncommon convention in Bioinformatics, we need a capital A, and we resolve that by assigning a projection. \nSimilar de.nitions exist for C, G, and T. The building blocks of our DSL will be sets representing a \nsingle sequence, containing a single nucleotide. Since we have four nucleotides, only four such sets \nexist, one per each nucleotide. For all practical purposes, these sets are exchangeable with the nucleotide \nthey are related to. We therefore wish to denote them A, C, G, and T as well. Statement 11.3 de.nes such \na concept (for A). To the naked eye, it looks just like the nucleotide A, however, its internal name \n(visible by clicking it and looking at the text bar), is different. Its type is different too set of \nlist of Nucleotide, in contrast to just Nucleotide. Statement 11.4 provides the meaning, de.ning it as \na singleton set, containing a sequence (list) with one element: the nucleotide A. Similar de.nitions \nare present for C, G, and T.   T def In Statement 11.4 we used the S = D statement to provide meaning \nto a set. It was necessary to enter the type because this concept is polymorphic. In our DSL, however, \nwe are going to de.ne a lot of sets, all with the same ele\u00adment type: list(Nucleotide). We therefore \nwish to hide the type from the user, given that our users (biologists) are of\u00adten unfamiliar with type \nsystems, and adding this type (or merely seeing it on the screen) may be a nuisance for them. For this \nreason, we de.ne the := operator, as a set assign\u00adment, speci.cally de.ned for nucleotide sequences. \nSince it always takes the same type (i.e., it is monomorphic), the type does not need to appear (as it \nis inferred by its type signa\u00adture). Figure 12 provides the de.nition of the := operator. Single Nucleotide \nSets The International Union of Pure and Applied Chemistry (IUPAC) de.nes standard codes to denote not \nonly a single nucleotide, but also sets of possible nucleotides.3 The most important one is N, representing \nany of the four nucleotides. Figure 14 shows the de.nition of three such codes, using the := operator \nde.ned in Figure 12, and Cedalion s standard set union operation. Sequences We de.ne the dot (.) operator \nto denote con\u00adcatenation of two sets. X.Y denotes a set of sequences, such 3 http://www.bioinformatics.org/sms/iupac.html \n that each such sequence can be seen as a concatenation of a sequence in X and a sequence in Y . Formally \nwe de.ne: X.Y = {s | x . X, y . Y, s is a concatenation of x and y} Figure 13 show the de.nition of this \noperator in Cedalion. Note the similarity between Statement 13.2 and the above de.nition. Xn denotes \nconcatenation of n elements of X, de.ned in Cedalion as a union of two sets: an empty se\u00adquence when \nn =0, and an element of X.Xn-1 when n> 0. For example, N3 is the set of all DNA sequences of size 3. \nWith what we have so far we can de.ne any set of se\u00adquences of a given size, restricting the nucleotides \nin each position. For example, the sequence N3.A.T.N3 matches all sequences of length 8, where positions \n4 and 5 hold A and T , respectively. Binding We sometimes would like to express sets of se\u00adquences that \nhave relations between parts of them. For ex\u00adample, we would like to choose two nucleotides and then \nrepeat them twice, providing a sequence of size four. The sequence N2.N2 will obviously not perform this \ntask, since each instance of N2 will be chosen independently. To .x this we bind a part of the sequence \nto a name, and later use this name in one or more places in the sequence. We use the syntax: Y =[X] to \ndenote a binding of an element in X to the name Y so Y can be used later in the sequence. In the above \nexample, the formula: Y =N2.Y will emit the correct result. The parentheses here are only for convenience \nof showing that the = operator has precedence over the . operator. In Cedalion the parentheses are optional, \nas the projectional editing resolves the ambiguity problem.  Domain-Speci.c Operators So far we discussed \nfeatures that relate to sequencing in general. We now add domain\u00adspeci.c operators to the languages, \nones that are unique to the .eld of DNA sequences. In living creatures, DNA appears double stranded (see \nFigure 15). Given the sequence of one strand of DNA will allow us to tell the sequence of the other strand, \nby following two simple steps: 1. Replacing all A s with T s (and vice versa), and all C s with G s (and \nvice versa). We call the resulting sequence the conjugate of the original. 2. Reverse the order. This \nis because the two strands are positioned in opposite directions.  We use the term complement to refer \nto the sequence of the other strand, denoted Xcomp, where X is the original strand. Due to symmetry, \nA double stranded DNA sequence can be depicted by either strands. If we wish to specify a set of double \nstranded DNA sequences, we need to make sure that, for every sequence in the set, its complement is not \nin the set. This is unless the sequence is its complement, i.e., when X = Xcomp (a palyndromial sequence). \nTo facilitate this, we introduce the restrict operator. comp restrict(X) contains for each x . X, either \nx or x, the lower of the two in lexicographic order.  5.6 Generating Microarray Designs We de.ned (and \nimplemented) a DSL for de.ning DNA se\u00adquence sets. Now we use them to generate microarray de\u00adsigns. As \nstated in Section 5.3, we do so in two phases. First, we generate .les containing the full factorial \nof sequences for each section of the microarray design. This is done from within Cedalion. Then, a short \nPerl script decimates these .les, leaving only the ones to be used in the .nal microarray. We de.ne a \nmicroarray statement. This statement has no meaning of its own, that is, it does not have a rewrite rule \nassociated with it. It only provides a place for de.ning mi\u00adcroarray designs. A context menu entry associated \nwith the microarray statement facilitates its generation. The associ\u00adated procedure generates a .le for \neach section, calculating the .le name based on the name of the microarray name, the section name and \nthe quantity (the number of sequences desired after decimation). The Perl script uses the name to generate \na decimated .le based on the speci.cations in the microarray statement.  5.7 A DNA Microarray Design \nExample Figure 16 shows an example of a microarray de.nition in our DSL. This example is similar in many \nways to the one designed by our colleagues, which we do not provide here, since this is still unpublished \nwork on their part. The microarray design, de.ned in Statement 16.9, de.nes three groups: an experiment, \nand two control groups. They all follow the same pattern, denoted by the fullSequence(X) operator, de.ned \nin Statements 16.7 and 16.8, where X is a set of sequences that de.nes the difference between the different \ngroups. The experiment tests ACGT , and the control groups replace the C and G with other nucleotides \n(the \\ operator depicts set subtraction). The fullSequence(X) operator de.nes a set of sequences, containing \ntwo instances of feature(X), separated by spacers (spacer1 on both ends, and spacer2 in the middle). \nThe two instances are set to be the same, by using binding. feature(X), de.ned in Statements 16.5 and \n16.6, repre\u00ad sents a sequence of twelve nucleotides. The central four are determined by X, wrapped by \nfour nucleotides on each side. Such an experiment is meant to .nd the combinations of these nucleotides \nthat best bind the protein in question. We restrict the set of features, to avoid considering the same \ndouble stranded sequence twice. The spacers, de.ned in Statements 16.1 through 16.4 are constant sequences, \nwhose purpose is to place the interest\u00ading features at the right distance from each other and from the \nedges. Generating the microarray design is done by selecting Generate Microarray Design from the microarray \ns con\u00adtext menu. Generating the sequences for this example took a little less than six minutes, about \nthe same time it took to generate the microarray design required by our colleagues. This constructed \nthe full factorial. The decimation (per\u00adformed by the Perl script) takes a few seconds.  6. Assessment \nand Discussion In this section we assess our language-oriented approach to LOP based on our own experience \nwith implementing and using Cedalion and based on the Bioinformatics case study presented in Section \n5. We revisit the properties set forth in Section 2 as criteria for this assessment. In our assessment \nwe also consider the following additional DSLs that were implemented in Cedalion. These were not presented \nhere but are available with the Cedalion distribution [4]: A general-purpose DSL for lazy-evaluation \nfunctional programming, featuring the ability to de.ne new expres\u00adsions (functions), Lambda abstractions \nand more.  Two domain-speci.c DSLs for de.ning processes us\u00ading CCS notation [21], and for testing their \nattributes ex\u00ad pressed using HML [11, 12].  Our DSL solution [24] to the challenge assignment de.ned \nby the Language Workbench Competition of 2011 (LWC 11).  An example of a software product line (SPL) \nin Cedalion for calculator software [17].  6.1 Results of the Bioinformatics Case Study In the Bioinformatics \ncase study we were able to de.ne a DSL in terms the domain experts speak and understand. With some assistance, \nour Biology colleagues were able to specify with Cedalion the microarray they needed. In fact, before \nsubmitting the list of sequences to the manufacturer, they changed the design twice, to accommodate new \ninsights about the problem at hand. The DSL code expressing the design was straightforward enough to \nallow them to make these necessary modi.cations by themselves. The implementation of the DSL took us \nabout one day s work. The implementation of the .rst microarray design took our colleagues about one \nhour, with our close assis\u00adtance. Each modi.cation took them about one or two min\u00adutes. The execution \nof the design, i.e., the generation of the sequences took approximately six minutes. This is in contrast \nto their Java implementation, where generating se\u00adquences typically takes only a few seconds. However, \nsince we only need to generate a design once, one should take the programming time (i.e., the time it \ntakes to create or change a design) into account. According to our colleagues, modify\u00ading their Java \ncode to re.ect a new microarray design takes them long minutes and even hours in some cases, relative \nto the minute or two it took to change the DSL code. Tak\u00ading that into account, the Cedalion implementation \nperforms much better. The set of sequences produced by the Cedalion-based DSL have been sent to the manufacturer \nto produce a mi\u00adcroarray based on that design. As we are writing these lines, our colleagues are using \nthis microarray for an experiment. Next we discuss how well Cedalion performed with re\u00adspect to the properties \nreviewed in Section 2. 6.2 DSL De.nition (Freedom of Expression) Syntactic Freedom Cedalion uses projectional \nediting to provide this freedom, breaking away from any restriction posed by a parsing algorithm, or \neven by the mere use of ASCII text .les. Projectional editing allows us to de.ne the syntax for our DSLs \nin a way that is intuitive for the subject matter experts. In the Bioinformatics case study in Section \n5 we used a notation that was intuitive for biologists. We were able to, for example, use superscript \n(e.g., Xn) to indicate repetition. If we were to use a parsed language (based on text .les), we would \nnot be able to do so, and would need to use an operator that is less intuitive to the domain experts. \nSince we based our DSL on Cedalion s mini DSL for sets, we could use set operators such as . in these \nexpressions (recall it was used to de.ne N and other IUPAC codes as depicted in Figure 14). In the train \nschedule example in Section 4 we used a double arrow with text below it, to indicate transition. This \ntoo could not have been achieved with a parsed language. Semantic Freedom The diversity of our case studies \nshow that Cedalion DSLs can have diverse semantics. However, the bigger challenge de.ned by this requirement \nis to be able to control semantic analysis, and have control over what is considered well-formed DSL \ncode. The case study that put this feature to the test was the LWC [24]. It required a DSL for instances, \nwhere each instance conforms with an entity de.ned by the entity DSL. We used Cedalion s type system \nto enforce this relationship, e.g., making sure there is a conformance between instances and the entities \nthey are based on. The type system was not powerful enough to enforce cardinality, so we added custom \ncheckers for that task.  6.3 Cost Effectiveness (Economic Freedom) The most adequate case study to demonstrate \nDSL cost\u00adeffective implementation and usage is the Bioinformatics case study. Here we solved a real-life \nproblem, one that could have been solved in some other way. Estimating the efforts of both ways can allow \nus to evaluate the cost\u00adeffectiveness of using Cedalion for this purpose. With everything in place, specifying \na new design took about one hour. Small modi.cations to that design took a minute or two each. With the \nalternative approach, imple\u00admenting the Java program to generate the sequences took about one day s work, \nwhich is comparable with the amount of time we spent setting up the .rst microarray design in Cedalion. \nCedalion s advantage in this starts with the .rst modi.cation. It is dif.cult to assess how long such \na mod\u00adi.cation would have taken for the Java implementation, but it is safe to assume that it would have \ntaken much longer than the minute or two it took with Cedalion, taking into ac\u00adcount that the logic for \nde.ning the design is spread among approximately 500 lines of code. Changing this code would probably \nrequire some level of debugging to achieve the de\u00adsired results.  6.4 DSL Interoperability (DSLs Freedom \nof Association) Cedalion supports DSL interoperability both semantically and syntactically. Syntactically, \nit comes from the use of projectional editing. Semantically, this ability is inherent from the fact all \nDSL code is code in the same programming language, Cedalion. In the example in Section 4 we demonstrated \nseamless integration of two mutually independent DSLs: a DSL for parsing based on BNF, and a business \nlogic DSL for querying train schedule. They were joined on the DSL code, with no need to modify any of \ntheir de.nitions to allow that. In this integration they were joined both syntactically and semantically. \nThe DNA sequence set DSL described in Section 5 was based on another DSL, the set mini DSL. The de.nitions \nof most of its concepts were actually made within that DSL, and only few of them were implemented using \nlogic pro\u00adgramming clauses. This makes the set operators natural in our DSL, and indeed they were used \nseamlessly, as in Fig\u00adure 14 (the . operator) and Figure 16 (the \\ operator).  6.5 Limitations and Threats \nto Validity Cedalion presents a viable approach to LOP, and we have shown that our prototyped implementation \ncan be used in a real-life setting to provide a desired outcome. However, we have also witnessed limitations \nof the approach. Performance Cedalion is a logic programming language. The programmer enjoys features \nsuch as backtracking and term uni.cation without effort. However, these very features of logic programming \naffect performance. Indeed, in our case study in Section 5, running the Cedalion code took a few minutes, \nwhile the Java implementation performing a similar task needed only a few seconds. However, there are \ntechniques to overcome this limita\u00adtion. Cedalion can use a faster Prolog engine, which is ex\u00adpected \nto provide a nice speedup at very little cost. We can also consider combining code generation techniques \nwith logic programming, as a speedup option for mature DSLs. Investigation and implementation of speedup \noptions are left for future work. Fault Tolerance Cedalion allows for user code to be exe\u00adcuted from \nwithin the Cedalion workbench, while the code is being edited. This is a powerful tool, but may cause \nprob\u00adlems if that code contains bugs. A limitation of Cedalion is its inability to withstand all user \nerrors. For example, it is not uncommon in Cedalion to reach non-termination. In such cases, the editor \ncrashes or gets stuck when editing a certain piece of code. Such problems cannot be avoided altogether. \nInstead, Ce\u00addalion needs to be able to contain these problems. In some cases (e.g., when an exception \nis thrown), this is easy. How\u00adever, in some other cases (e.g., non-termination), identifying the problem \nis hard, and treating it effectively is not easy. We hope that as Cedalion matures we will .nd ways to \naddress these issues. Threats to Validity A noticeable threat to validity is the choice of Bioinformatics \nas a case study. One could claim that this case study coincidentally maps well into Cedalion. However, \nthe variety of examples and other case studies show Cedalion provides consistent result for numerous \nprob\u00adlem domains, which makes us con.dent that the results of the case study in Section 5 are indeed \nrepresentative. 7. Related Work Cedalion is a host language for internal DSLs that is de\u00adsigned to support \n.exible DSL syntax and semantics. In comparison, traditional internal DSLs are relatively cost\u00adeffective, \nhighly interoperable, but are limited in their syntax and semantics. Lisp and its dialects, for example, \nhave very .exible semantics. However, the syntax of Lisp-based DSLs is usually limited to S-expressions. \nImplementing readers can help customize the syntax for a single DSL, but does not provide syntactic interoperability. \nMost other host languages for internal DSLs are dynamic languages and therefore do not provide static \nvalidation for DSL code. However, there are exceptions to the rule, such as typed Scheme [32] and typed \nProlog [26], which both imple\u00ad ment custom validation through their respective language s macro expansion \nmechanisms. Language workbenches share the same goal as Cedalion. The most notable language workbench \ninclude the Meta Programming System (MPS) [5], the Intentional Domain Workbench (IDW) [28], and Spoofax \n[14]. Targeting exter\u00ad nal DSLs, they mitigate some of their drawbacks by doing one thing similar to \ninternal DSLs: provide a common rep\u00adresentation for all DSLs. This common representation often refers \nto the abstract syntax tree (AST) of the DSL. Although different DSLs use different language constructs, \nwithin one language workbench they all have a common notion of what a language construct is. These are \ncalled concepts in MPS, as in Cedalion; and intentions in IDW. This common representation allows the \nintegration of an AST segment for code in one DSL, into the AST of code in another DSL. For this to happen, \nthe DSLs need to agree on some interface (beyond the common representation). The common representation \nallows semantic interoperability of DSLs. However, DSL interoperability also requires interop\u00aderability \non the syntactic level (syntactic interoperability).  Language workbenches support that with either \nscannerless\u00adgeneralized parsing or projectional editing. Scannerless generalized LR (SGLR) parsing [33] \nis an ap\u00ad proach that allows parsing of text consisting of a combina\u00adtion of languages (DSLs), when each \nis de.ned by a set of production rules (context free grammar), and a set of dis\u00adambiguation rules (e.g., \nprecedence and associativity). The parser combines all rules (production and disambiguation) from all \nlanguages into one grammar. There are no guaran\u00adtees for it being unambiguous, not to mention belonging \nto a speci.c grammar class, such as LALR(1). However, the generalized LR parsing algorithm can use it \nto parse the .le in polynomial time. Ambiguities in parsing the user code are reported as errors. They \nare then taken care of by either mod\u00adifying the DSL code (e.g., by placing parentheses or alike to state \nthe structure more explicitly), or by adding disambigua\u00adtion rules to one of the DSLs. This approach \nis implemented in the Spoofax [14] language workbench. Projectional editing [8] is an approach that addresses \nsyn\u00ad tactic interoperability from a different angle. Instead of im\u00adproving the parsing algorithms to \nmeet the challenges of syntactic interoperability, projectional editing takes the ap\u00adproach of avoiding \nparsing altogether. In contrast to the traditional approach to programming languages, where the code \nis being edited in a text editor, saved to a text .le, and then parsed to provide a volatile AST, with \nprojec\u00adtional editing the AST is persistent (mostly referred to as the model), and is being edited using \na dedicated editor, edit\u00ading it through a projection to a view. The projection here is analogous to the \ncontroller in the model-view-controller (MVC) architecture. The main difference between projec\u00adtional \nediting and traditional MVC is in the fact that here the controller (the projection) is de.ned per-DSL. \nThe most notable projectional language workbenches include MPS [5] and the IDW [28]. Cedalion uses projectional \nediting for internal DSLs. To our knowledge, this combination has not been tried before. Combining internal \nDSLs with SGLR parsing has not been tried either, and is a topic for future work. 8. Conclusion LOP is \na paradigm that has been recently attracting more at\u00adtention. So far it has not been widely adopted in \npractice, due to the limitations of traditional implementation approaches, namely internal and external \nDSLs. In a more recent ap\u00adproach, language workbenches offer a promising direction in .ghting these limitations, \nby giving external DSLs a com\u00admon representation, a feature borrowed from internal DSLs. In this paper \nwe introduce a novel approach to LOP and an alternative to language workbenches. In contrast to language \nworkbenches, we take internal DSLs and pro\u00advide them with language workbench features, to make them closer \nto external DSLs. We introduced Cedalion, an im\u00adplementation of this approach, as a proof of concept. \nAs evidence that this approach provides a viable alternative to language workbenches, with some trade-offs, \nwe present small examples and a larger case study showing usage of Cedalion to solve a real life problem. \nIn that case study, a Cedalion-based DSL was success\u00adfully used to by biologists in designing a DNA microarray \nfor molecular Biology research. The most glaring advan\u00adtages of doing so were the readability and the \nease of change of the design. The most notable disadvantage was the pro\u00adcessing time. This is not a big \nproblem as long as we are at the scale of minutes. When considering the total time it took to generate \nthe sequences, including the code modi.\u00adcation time, the Cedalion-based approach showed a signi.\u00adcant \nadvantage over the traditional approach. This case study demonstrates how cost-effective LOP can be with \nour ap\u00adproach. The Cedalion Eclipse plug-in is implemented as an open source project and publicly available \n[4]. Acknowledgment The Bioinformatics case study was a done in collabora\u00adtion with Itai Beno and Tali \nE. Haran, Department of Biol\u00adogy, Technion Israel Institute of Technology, Technion City, Haifa 32000, \nIsrael. References [1] I. Beno, K. Rosenthal, M. Levitine, L. Shaulov, and T. E. Haran. Sequence-dependent \ncooperative binding of p53 to DNA targets and its relationship to the structural properties of the DNA \ntargets. Nucleic Acids Research, 39(5):1919 1932, Mar. 2011. [2] M. F. Berger and M. L. Bulyk. Universal \nprotein-binding mi\u00adcroarrays for the comprehensive characterization of the DNA\u00adbinding speci.cities of \ntranscription factors. Nature protocols, 4(3):393 411, 2009. [3] M. L. Bulyk. Protein binding microarrays \nfor the character\u00adization of DNA protein interactions. Advances in Biochemi\u00adcal Engineering/Biotechnology, \n104:65 85, 2007. Analytics of Protein DNA Interactions. [4] Cedalion. The Cedalion project homepage. \nSoftware Engi\u00adneering Research Lab, The Open University of Israel, 2010. http://cedalion.sourceforge.net. \n[5] S. Dmitriev. Language oriented programming: The next pro\u00adgramming paradigm. JetBrains onBoard, 1(2), \nNov. 2004. [6] M. Fowler. Bliki: Fluent interface, Dec. 2005. http:// martinfowler.com/bliki/FluentInterface.html. \n[7] M. Fowler. Language workbenches: The killer-app for domain speci.c languages, June 2005. http://www. \nmartinfowler.com/articles/languageWorkbench. html. [8] M. Fowler. Bliki: Projectional editing, Jan. 2008. \nhttp: //martinfowler.com/bliki/ProjectionalEditing. html. [9] S. Freeman and N. Pryce. Evolving an embedded \ndomain\u00adspeci.c language in Java. In Proceedings of the 21st An\u00ad  nual Conference on Object-Oriented \nProgramming Systems, Languages, and Applications (OOPSLA 06), pages 855 865, Portland, Oregon, USA, Oct. \n22 26 2006. ACM Press. [10] A. Hen-Tov, D. H. Lorenz, A. Pinhasi, and L. Schachter. ModelTalk: When everything \nis a domain-speci.c language. IEEE Software, 26(4):39 46, 2009. Special issue on Domain-Speci.c Modeling. \n[11] M. Hennessy and R. Milner. On observing nondeterminism and concurrency. In Automata, Languages and \nProgramming, number 85 in Lecture Notes in Computer Science, pages 299 309. Springer-Verlag, Berlin, \nHeidelberg, 1980. [12] M. Hennessy and R. Milner. Algebraic laws for nondetermin\u00adism and concurrency. \nJ. ACM, 32(1):137 161, Jan. 1985. [13] P. Hudak. Building domain-speci.c embedded languages. ACM Computing \nSurveys (CSUR), 28(4es), 1996. [14] L. C. Kats and E. Visser. The Spoofax language workbench: Rules for \ndeclarative speci.cation of languages and IDEs. In Proceedings of the ACM International Conference on \nSys\u00adtems, Programming Languages, and Applications: Software for Humanity (SPLASH 10), pages 444 463, \nReno/Tahoe, Nevada, USA, Oct. 2010. ACM. [15] D. Knuth. Backus normal form vs. Backus Naur form. Com\u00admunications \nof the ACM, 7(12):735 736, 1964. [16] D. H. Lorenz and B. Rosenan. Cedalion: A language oriented programming \nlanguage. In IBM Programming Languages and Development Environments Seminar (PLDE 10), Haifa, Israel, \nApr. 2010. IBM Research. [17] D. H. Lorenz and B. Rosenan. Code reuse with language oriented programming. \nIn Proceedings of the 12th Interna\u00adtional Conference on Software Reuse (ICSR12), number 6727 in Lecture \nNotes in Computer Science, pages 165 180, Po\u00adhang, Korea, June 13-17 2011. Springer Verlag. [18] D. H. \nLorenz and J. Vlissides. Designing components ver\u00adsus objects: A transformational approach. In Proceedings \nof the 23th International Conference on Software Engineer\u00ading (ICSE 01), pages 253 262, Toronto, Canada, \nMay 12-19 2001. IEEE Computer Society. [19] S. Mellor, A. Clark, and T. Futagami. Model-driven develop\u00adment. \nIEEE software, 20(5):14 18, 2003. [20] M. Mernik, J. Heering, and A. M. Sloane. When and how to develop \ndomain-speci.c languages. ACM Comput. Surv., 37, Dec. 2005. [21] R. Milner. A Calculus of Communicating \nSystems. Number 92 in Lecture Notes in Computer Science. Springer-Verlag, New York, NY, USA, 1980. [22] \nA. Mycroft and R. A. O Keefe. A polymorphic type system for Prolog. Arti.cial intelligence, 23(3):295 \n307, 1984. [23] B. Rosenan. Designing language-oriented programming lan\u00adguages. In Companion to the ACM \nInternational Confer\u00adence on Systems, Programming Languages, and Applica\u00adtions: Software for Humanity \n(SPLASH 10), pages 207 208, Reno/Tahoe, Nevada, USA, Oct. 2010. ACM. Student Re\u00adsearch Competition, 2nd \nprize. [24] B. Rosenan. Cedalion submission to the language workbench competition of 2011. In M. V\u00f6lter, \nE. Visser, S. Kelly, A. Hul\u00adshout, J. Warmer, P. J. Molina, B. Merkle, and K. Thoms, edi\u00adtors, Language \nWorkbench Competition. 2011. http://www. languageworkbenches.net/lwc11-cedalion.pdf. [25] C. Sassenrath. \nThe REBOL scripting language. Dr. Dobb s Journal: Software Tools for the Professional Programmer, 25 \n(7):64 68, 2000. http://rebol.com. [26] T. Schrijvers, V. S. Costa, J. Wielemaker, and B. Demoen. Towards \ntyped Prolog. In Proceedings of the 24th Interna\u00adtional Conference on Logic Programming (ICLP 08), pages \n693 697, Udine, Italy, 2008. Springer-Verlag. [27] C. Simonyi. The death of computer languages, the birth \nof intentional programming. Technical Report MSR-TR-95-52, Microsoft Corporation, 1995. [28] C. Simonyi, \nM. Christerson, and S. Clifford. Intentional software. ACM SIGPLAN Notices, 41(10):451 464, 2006. [29] \nZ. Somogyi, F. Henderson, and T. Conway. Mercury, an ef.cient purely declarative logic programming language. \nAustralian Computer Science Communications, 17:499 512, 1995. [30] T. Stahl and M. V\u00f6lter. Model-Driven \nSoftware Development: Technology, Engineering, Management. John Wiley &#38; Sons, 2006. [31] C. Szyperski. \nComponent Software, Beyond Object-Oriented Programming. Addison-Wesley, 2nd edition, 2002. With Dominik \nGruntz and Stephan Murer. [32] S. Tobin-Hochstadt and M. Felleisen. The design and imple\u00admentation of \ntyped Scheme. In Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Pro\u00adgramming \nLanguages (POPL 08), pages 395 406, San Fran\u00adcisco, California, USA, Jan. 2008. ACM. [33] E. Visser. \nScannerless generalized-LR parsing. Technical Report P9707, University of Amsterdam, Programming Re\u00adsearch \nGroup, Department of Computer Science, Kruislaan 403, NL-1098 SJ Amsterdam, The Netherlands, Aug. 1997. \n[34] M. P. Ward. Language-oriented programming. Software-Concepts and Tools, 15(4):147 161, 1994. [35] \nJ. Wielemaker. An overview of the SWI-Prolog programming environment. In F. Mesnard and A. Serebrenik, \neditors, Pro\u00adceedings of the 13th International Workshop on Logic Pro\u00adgramming Environments (WLPE 03), \npages 1 16, Mumbai, India, Dec. 2003. Report CW371, Katholieke Universiteit Leuven, Nov. 2003. [36] XLR. \nXLR: Extensible language and runtime, 2008. http: //xlr.sourceforge.net/concept/XL.html.     \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Language Oriented Programming (LOP) is a paradigm that puts domain specific programming languages (DSLs) at the center of the software development process. Currently, there are three main approaches to LOP: (1) the use of internal DSLs, implemented as libraries in a given host language; (2) the use of external DSLs, implemented as interpreters or compilers in an external language; and (3) the use of language workbenches, which are integrated development environments (IDEs) for defining and using external DSLs. In this paper, we contribute: (4) a novel language-oriented approach to LOP for defining and using internal DSLs. While language workbenches adapt internal DSL features to overcome some of the limitations of external DSLs, our approach adapts language workbench features to overcome some of the limitations of internal DSLs. We introduce Cedalion, an LOP host language for internal DSLs, featuring static validation and projectional editing. To validate our approach we present a case study in which Cedalion was used by biologists in designing a DNA microarray for molecular Biology research.</p>", "authors": [{"name": "David H. Lorenz", "author_profile_id": "81100540418", "affiliation": "Open University of Israel, Raanana, Israel", "person_id": "P2839260", "email_address": "lorenz@openu.ac.il", "orcid_id": ""}, {"name": "Boaz Rosenan", "author_profile_id": "81470654143", "affiliation": "Open University of Israel, Raanana, Israel", "person_id": "P2839261", "email_address": "brosenan@cslab.openu.ac.il", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048123", "year": "2011", "article_id": "2048123", "conference": "OOPSLA", "title": "Cedalion: a language for language oriented programming", "url": "http://dl.acm.org/citation.cfm?id=2048123"}