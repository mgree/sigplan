{"article_publication_date": "10-22-2011", "fulltext": "\n First-Class State Change in Plaid \u00b4 Joshua Sunshine Karl Naden Sven Stork\u00a7 Jonathan Aldrich Eric Tanter \n* Carnegie Mellon University \u00a7University of Coimbra PLEIAD Lab / Computer Science Department (DCC) / \nUniversity of Chile {sunshine, kbn, svens, jonathan.aldrich}@cs.cmu.edu etanter@dcc.uchile.cl Abstract \nObjects model the world, and state is fundamental to a faith\u00adful modeling. Engineers use state machines \nto understand and reason about state transitions, but programming languages provide little support for \nbuilding software based on state ab\u00adstractions. We propose Plaid, a language in which objects are modeled \nnot just in terms of classes, but in terms of changing abstract states. Each state may have its own representation, \nas well as methods that may transition the object into a new state. A formal model precisely de.nes the \nsemantics of core Plaid constructs such as state transition and trait-like state composition. We evaluate \nPlaid through a series of examples taken from the Plaid compiler and the standard libraries of Smalltalk \nand Java. These examples show how Plaid can more closely model state-based designs, enhancing understandabil\u00adity, \nenhancing dynamic error checking, and providing reuse bene.ts. Categories and Subject Descriptors D.2.10 \n[Software En\u00adgineering]: Design Representation; D.3.2 [Programming Languages]: Language Classi.cations \nObject-oriented lan\u00adguages; D.3.3 [Programming Languages]: Language Con\u00adstructs and Features State General \nTerms Design, Documentation, Languages, Relia\u00adbility Keywords typestate, state-chart, plaid 1. Introduction \nObject-oriented programming provides a rich environment for modeling real-world and conceptual objects \nwithin the computer. Fields capture attributes of objects, methods cap\u00adture their behavior, and subtyping \ncaptures specialization * Partially funded by FONDECYT Project 1110051 Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 11, October 22 27, 2011, Portland, Oregon, \nUSA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. . . $10.00 relationships among objects. \nA key element missing from object-oriented programming languages, however, is abstract states and conceptual \nstate change. State change is pervasive in the natural world; as a dramatic example, consider the state \ntransition from egg, to caterpillar, to pupae, to butter.y. Mod\u00adeling systems with abstract states and \ntransitions between them is also common in many engineering disciplines. In computer science, state machines \nare important model\u00ading concepts in the UML. Abstract states are also a critical, though often implicit, \npart of many library APIs and any client using that API must be aware of those states to use the API \ncorrectly. For example, a .le may be in the open or closed state. In the open state, one may read or \nwrite to a .le, or one may close it, which causes a state transition to the closed state. In the closed \nstate, the only permitted operation is to (re-)open the .le. Files provide a simple example of abstract \nstates, but there are many more. Streams may be open or closed, iterators may have elements available \nor not, collections may be empty or not, and even lowly exceptions can have their cause set, or not1. \nState spaces may be complex: In ResultSet from the Java JDBC library, we found 33 unique states dealing \nwith different combinations of openness, direction, random access, insertions, etc [7]. States are also \ncommon: a recent study of protocols in Java suggests that almost three times as many types de.ne protocols \nas de.ne type parameters [3]. They also cause signi.cant pain: for instance, in a study of problems developers \nexperienced when using the ASP.NET framework, 3/4 of the issues identi.ed involved temporal constraints \nsuch as the state of the framework in various callback functions [16]. All this raises a natural question: \nwhy not support abstract states in programming languages? We previously proposed Typestate-Oriented Programming \nas a new programming paradigm in which programs are made up of dynamically created objects, each object \nhas a types\u00adtate that is changeable, and each typestate has an interface, representation, and behavior \n[1]. The term typestate refers to a static abstract state checking methodology proposed by Strom and \nYemini [25]; this paper focuses on a dynamically\u00ad 1 E.g. in Java, the cause of an exception can only \nbe set once. typed setting, and so we will use the terms (abstract) state and protocol in place of typestate \nto avoid confusion. A programming language with abstract states can have many bene.ts. First, in the \ncase of stateful abstractions, the code will more clearly re.ect the intended design. This in turn will \nmake state constraints more salient to developers who need to be aware of them. If state constraints \nare implicitly enforced by the object model, there is no need to code up explicit checks; thus code implementing \nstates can be more concise. Explicit state models raise the level of error messages; instead of (perhaps) \nsilently corrupting a data structure when an inappropriate method is called, the runtime can signal an \nerror that that method is unavailable in the current state. Finally, explicit modeling of states also \nexposes new concepts for widespread reuse; candidates may include open/closed resources or positioning \n(beginning, middle, end) of streams. Contribution. The contribution of this paper is the concrete design \nand evaluation of Plaid, an object-oriented program\u00adming language that incorporates .rst-class state \nchange as well as trait-like state composition. Plaid has been imple\u00admented, and has proven effective \nfor writing a diverse set of small and medium-sized (up to 10kLOC) programs, including a self-hosted \ncompiler. For the purposes of this paper, Plaid is dynamically typed, though there are plans to add a \ngradual type system following recent work on gradual typestates [29]. The most interesting aspects of \nPlaid s design come from the intersection of state change with support for a trait-like model of composition \n[12]. Central goals of the language design include supporting the primary state modeling con\u00adstructs \nfrom statecharts [14], as well as .exible code reuse. Our design includes a hierarchical state space, \nso that the open state of a stream can be re.ned into within and eof substates indicating whether there \nis data left to be processed. Handling real designs in a modular way requires support for multi-dimensional \nstate spaces, as in and-states from [14]; an example is a separate dimension of a stream s state indicating \nwhether the stream has been marked with a location or not. Modularity further requires reasoning about \ndimensions sep\u00adarately; for example, the mark() method should affect the marked state dimension but it \nshould not affect whether the stream is at eof. Dimensions also delineate natural points of reuse; we \nwould like to specify them separately and combine them using a trait-like composition operator. We position \nPlaid relative to earlier work in the next section. Plaid s design is described by example in section \n3. This section validates our design, using a number of carefully chosen examples to concretely illustrate \nhow Plaid provides the potential bene.ts described above. We also discuss our prototype implementation \nof Plaid, targeting the JVM. In order to be precise about Plaid s semantics, Section 4 provides a formal \nmodel that includes the semantics of all of Plaid s major features. Section 5 describes how the surface \nPlaid language is elaborated into the core formal model. The paper concludes with a discussion of ongoing \nwork on Plaid, together with an argument that the concrete bene.ts validated by example lead to higher-level \nbene.ts in software development and evolution. 2. Background and Related Work Plaid s state constructs \nare inspired and guided by state modeling approaches such as Harel s statecharts [14]. Other modeling \napproaches include Pernici s Objects with Roles Model [20], which models objects using a set of roles, \neach of which can be in one of several abstract states. Strom and Yemini proposed typestate as a compiler\u00adcheckable \nabstraction of the states of a data structure [25]. The Fugue system was the .rst to integrate typestates \nwith an object-oriented programming language [10]. Bierhoff et al. later observed that the complexity \nof protocols such as the one de.ned by the JDBC ResultSet interface requires rich state modeling constructs \nlike those proposed by Harel [7]. This paper considers a dynamically-typed setting, so we do not discuss \nstatic checkers further. State-dependent behavior can be encoded using the State design pattern [13]. \nHowever, this pattern is less direct than the language support we propose, and it does not help with \nensuring that a client only uses operations that are available in the current state. Dynamic languages \nsuch as Self [28] provide the ability to add and remove methods, as supported by Plaid s state change \noperator. Changing a delegation slot in Self can also be used to simulate state change, as can the become \nmethod in Smalltalk [18]. We believe that Plaid s more structured and more declarative constructs for \nstate modeling have advantages in terms of error checking, succinctness, and clear expression of design \ncompared to these encodings. Plaid s prototype-based object model is also inspired by Self s. Prior State-Based \nLanguages. The Actor model [15] treats states in a .rst-class way, using the current state of an actor \nto de.ne the response to messages in a concurrent setting. Taivalsaari extended class-based languages \nwith explicit de.nitions of logical states (modes), each with its own set of operations and corresponding \nimplementations [27]. Plaid s object model differs in providing explicit state transitions (rather than \nimplicit ones determined by .elds) and in allow\u00ading different .elds in different states. The Ferret language \n[8] provides multiple classi.cation, in which objects can be classi.ed in one of several states in each \nof multiple dimensions. Ferret attaches dimensions to classes, not other states, so dimensions cannot \ncome and go with state changes (unlike in Plaid and Statecharts). A number of CAD tools such as iLogic \nRhapsody or IBM/Rational Rose Real-Time support a programming model based even more directly on Statecharts \n[14]; such models bene.t from many rich state modeling features but lack the dynamism of object-oriented \nsystems. Recently Sterkin proposed embedding the principal features of Statecharts as a library within \nGroovy, providing a smoother integration with objects [23]. Our approach focuses on adding states to \nobject-oriented languages, rather than libraries.  Other researchers have explored adding a class change \nprimitive to statically-typed languages [4, 6, 11]. These systems, however, do not support the richness \nof state models (e.g. and-states) as provided in Statecharts and in Plaid. Schaerli et al. proposed traits \n[12] as a composition mecha\u00adnism that avoids some of the semantic ambiguities of multiple inheritance. \nSchaerli s traits did not have .elds, but Plaid fol\u00adlows prior designs [5] to add them. Like some other \nrecent work [9, 22], Plaid does not have the .attening property, in which the composition structure of \ntraits is compiled away and does not affect the semantics of the resulting program. We lose the simplicity \nof .attening but gain the ability to model structured state spaces more directly, as described below. \nAn initial sketch of the Plaid language design was pre\u00adsented earlier [1] as an instance of the Typestate-Oriented \nProgramming paradigm. While we recap the motivation and concept of the language from this earlier work, \nthat paper de\u00adscribed an unimplemented language, and neither de.ned the language semantics nor investigated \nthe modeling of complex state spaces, which are the key contributions of this paper. In an earlier 4-page \nworkshop paper, we explored the need for a modular state change operator that affects only one dimension \nof state change at a time [2]; this paper gives the semantics for a concrete solution to that problem. \nOther recent work has begun to explore a gradual, permission-based type system for Plaid [29]. 3. Language \nIn this section we will introduce Plaid by example. These examples serve the dual purpose of explaining \nthe language and validating the concrete bene.ts of Plaid. 3.1 Basics of State Change Object protocols \nare rules dictating the ordering of method calls on objects. The concrete state of an object with a proto\u00adcol \ncan be abstracted into a .nite number of abstract states and the object transitions dynamically between \nthese abstract states. Therefore, clients must be aware of the abstract states in order to use the object \ncorrectly. Most programming languages provide no direct support for protocols. Instead, protocols are \nencoded in the language using some combination of the state design pattern [13], conditional tests on \n.elds, and other indirect mechanisms. In Plaid, protocols are supported directly with states, which are \nlike classes in Java, with the crucial distinction that an object s state changes as the object evolves. \nConsider the state space of .les, the canonical protocol example [1], shown in Figure 1. Some .les are \nopen and some are closed. We close an open .le by calling the close method and open a closed .le by calling \nthe open method. Figure 1. State space of File. 1 state File { 2 val filename; 3 } 4 state OpenFile \ncase of File = { 5 val filePtr; 6 method read() { ... } 7 method close() { this <- ClosedFile; } 8 } \n9 state ClosedFile case of File { 10 method open() { this <- OpenFile; } 11 } Listing 1. File states \nin Plaid One cannot open an open .le so the open .le state does not include the close method. Similarly, \none cannot read a closed .le so the closed .le state does not include the read method. The state space \nof .les can be encoded cleanly in Plaid as shown in Listing 1. The state keyword is used to de.ne a state. \nThe File state contains the .elds and methods that are common between open and closed .les. In this case, \nonly the .lename is shared. Fields are declared with the val keyword. OpenFile and ClosedFile de.ne the \nmethods and .elds that are speci.c to open and closed states. Both are substates of File. Specialization \nis declared with the case of keyword. In addition, case of implies orthogonality: .les can either be \nopen or closed, not both. Methods are de.ned with the method keyword. Open .les have a read method, a \n.le pointer .eld which is presumably used by the read method to read the .le, and a close method. Closed \n.les have the open method. The open and close method bodies contain the most novel bit of syntax. An \nobject referred to by a variable x can be changed to state S by writing x <-S. In the open method we \ntransition the receiver, referred to as in Java by the keyword this, to the open state by writing this \n<-OpenFile. An example .le client is shown in Listing 2. The readClosedFile method takes a .le as an \nargument, opens it, reads from it, closes it, and returns the value read from the .le. All of the method \ncalls are valid if a closed .le is passed to the method. If an open .le is passed instead the open method \ncall will fail. The library writers do not need to write any special error handling code to handle this \ncondition  1 method readClosedFile(f) { 2 f.open(); 3 val x = f.read(); 4 f.close(); 5 x; //return 6 \n} Listing 2. File client in Plaid  Figure 2. Butte.y life-cycle. like they would in Java. This has the \nconcrete bene.t that Plaid code for the equivalent design is smaller. In most programming languages, \n.elds of an object are often null in certain abstract states. For example, Java .les might contain a \nnull filePtr when the .le is closed. Null pointers are a frequent cause of runtime errors and their cause \ncan be dif.cult to diagnose. For these reasons, Tony Hoare recently called null pointers a billion dollar \nmistake, and we have not repeated this mistake in Plaid. Plaid objects are always consistent: in other \nlanguages a programmer might forget to check the state before performing an operation and perform the \noperation on an object in the wrong state. Similarly, the operation might fail, but with a less speci.c \nerror message. For example, if a client calls the read method, implemented in Java without error handling, \non a closed .le, Java might throw a NullPointerException for a null dereference of filePtr.  3.2 State \nTranstions The .le state space is a complete directed graph, every pair of states is connected in both \ndirections by an edge. Other kinds of objects have incomplete state spaces. Consider the life\u00adcycle of \na butter.y, which is illustrated by the state-space in Figure 2. A butter.y egg hatches to a caterpillar, \nbut it cannot un-hatch . Similarly, a butter.y never transitions directly from a caterpillar to an imago, \nit always transforms to a chrysalis .rst. To preserve the integrity of incomplete protocols, only the \nmethod receiver (this), can be the target of a state change op\u00aderation. If Plaid did not have this restriction \nit would be trivial for programmers to inadvertently violate a protocol. Con\u00adsider: val x = new Egg; \nx<-Caterpillar; x<-Egg. This il\u00adlegal Plaid code violates the protocol by restoring a caterpillar to \nan egg. Instead, in legal Plaid code, methods de.ned in the butter.y states perform all of the state \ntransitions.  3.3 Dimensions of State Change Many objects in the real world are not as simple as .les \nor butter.ies. Some objects are composed of multiple states, par\u00adticularly when objects are built up \nfrom reusable components. These components may change their state independently, or orthogonally. For \nexample, cars have both gears and brakes and when the car shifts gears it has no effect on the brakes. \nStates that change independently are in different dimensions. State dimensions in programming languages \nwere introduced in [7]. More concretely, let us say a stream is in state unmarked in dimension markable, \nand state within in dimension position. If the object changes to state marked, also in dimension markable, \nit will lose all of the .elds and methods de.ned in unmarked (such as mark), gain those in marked (such \nas reset), and keep those in within (such as read). The full power of Plaid comes when component states \nare themselves composed of multiple states. In such a setting the component states are gained and lost \nalong with their parents. Many of this kind of deep hierarchies exist in the wild [3]. For example, in \nthe Java Database Connectivity library, the ResultSet interface is composed from a combination of 33 \nstates, four levels of nesting, and eight dimensions. A slightly simpli.ed schematic of the state space \nis shown in Figure 3. The features of the language just described correspond directly to the hierarchical-states \n, and-states and or-states proposed by Harel in his seminal state-chart paper [14]. Hierarchical-states \nare states that are composed of other states. And-states are states that both must be present in an object \nseparate dimensions that are modeled using with composition in Plaid. Finally, or-states are states in \nthe same dimension, and therefore only one can be present in an object a state that is a case of another \nstate. These features are the fundamental building blocks of the Harel state chart formalism (which forms \nthe basis for UML state diagrams), and are naturally encoded in Plaid exactly in the manner we just described. \nIn the ResultSet diagram (Figure 3), or-states are sep\u00adarated by white space. For example, Open and Closed \nare states in one dimension, ForwardOnly and Scrollable are in another. Hierarchical-states are indicated \nby nesting of the state rectangles. For example, Scrolling is a child of Open and Begin of Scrolling. \nThe names of states with children, like Open appear outside the state-rectangle, and the names of simple \nstates without children, like Inserted, appear inside the state-rectangle. Finally, and-states are sepa\u00adrated \ninto orthogonal regions by dotted lines, so Direction and Status are and-states. There is a natural one-to-one \ncorrespondence between the state rectangles in the diagram and the state declarations in Plaid code. \nA subset of the declarations for ResultSet states are shown in Listing 3. The or-states are all declared \nto be cases of their dimensions. For example, ForwardOnly and Scrollable are cases of the Direction dimension. \n  Figure 3. ResultSet state-chart. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 state Open case of ResultSet \n= Direction with Status with Action; state Direction; state ForwardOnly case of Direction; state Scrollable \ncase of Direction; state Status; state ReadOnly case of Status; state Updatable case of Status; state \nAction; state Scrolling case of Action; state Inserting case of Action; state Insert case of Inserting; \nstate Inserted case of Inserting; ... val myResultSet = new Open @ ForwardOnly with Updatable with Insert; \nListing 3. ResultSet state declarations and instantiation The dimensions are themselves states in which \ncase their or\u00adstates will inherit all of the dimension s .elds and members. Sometimes, however the state \nis a pure dimension and does not contain members. In this case the state only serves to ensure that or-states \ndo not appear together. The and-states nested with Open, are declared using with together into the myResultSet \nstate. Any object in the Open state is also in the Direction, Status, and Action states. Often ResultSet \nobjects will be instantiated with children of the three dimensions Direction, Status, and Action. For \nexample, at the end of Figure 3, myResultSet is as\u00adsigned to an open object in the ForwardOnly, Updatable \nand Insert states. This object will contain the methods and .elds from Insert, Inserting, Action, Updatable, \nStatus, Forwardonly, Direction, Open and ResultSet. If we were to change the state of myResultSet to \nInserted by calling a method that does so for us the object would have all of the same states, with the \nexception that Insert will be replaced with Inserted. This is because Insert and Inserted are or-states \nfrom the same dimension. When we close the object, we lose not only the Open state but all of the states \nnested inside it. We are left only with Closed and ResultSet. The @ operator is syntactic sugar that \nallows an initializer to conveniently choose nested sub-states. The myResultSet initializer in Figure \n3 is desugared to the following code: 1 var myResultSet = new Open; 2 myResultSet <- For ward Only with \nUpdatable 3 with Insert; First, an Open object is created. Then the object is changed to specializations \nof the three dimensions using the state change operator. Notice that the left side of the state-change \noperator is not this in the de-sugared code which violates the restriction discussed in Section 3.2. \nThis is okay, because the restriction only applies to Plaid source which in this case uses the @ operator. \nIn this example the reader can see that the Plaid code closely re.ects the design embodied in the state \nchart. The stateful design is salient in the state declarations. Since the mapping between the code and \nthe state chart is so clear, a programmer reading the state declarations can easily understand the relationship \nbetween the states. In fact, our group has built a tool to automatically extract a state chart from Plural2, \na typestate checker for annotated Java code, and although we have not built such a tool for Plaid, the \nlanguage design clearly enables it. A second potential bene.t is that code for each state can be given \nseparately in the appropriate state declaration, potentially permitting more .ne-grained reuse across \nmultiple implementations of the ResultSet interface.  3.4 State members As we mentioned in the introduction, \nPlaid combines state change with support for a trait-like model of composition [12]. We now illustrate \na particularly novel feature of Plaid, namely, state members. States can have other states as members, \nand these state members can be customized upon composition. This allows for consistent state update, \nin presence of com\u00adposite states. We illustrate state members and their bene.ts through a Plaid version \nof a ReadWriteStream adapted from [12], which is in turn adapted from the Smalltalk standard library. \nThe Plaid components mirror the trait components, except in our version the methods of a single trait \nare sometimes divided across multiple states. The Position state represents the position of the pointer \ninto a stream or collection. It has a very limited interface which therefore makes it easy to reuse throughout \nan input\u00adoutput and collection library. The code for Position is shown in Listing 4. Position declares \ntwo abstract methods for setting the position, a reference to the underlying collec\u00adtion (vector), constant \n.elds for minimum and maximum position, and a variable .eld for the current position3. Interestingly, \nPosition contains two state members, one for the end-state and one for the not-end-state. The state members \nare initialized to NotEnd and End, also de.ned in Listing 4. These states are sub-states of Position, \nas speci.ed by the case of declarations. They implement the abstract methods of Position. In addition, \nNotEnd has an additional method nextPosition, re.ecting the fact that in that state, the position can \nbe advanced. This method increments the current position, tests if the current position is at or past \nthe maximum position, and transitions the receiver to the end state if the position is at the end. Similarly, \nsetToStart in End transitions the receiver back to the not\u00adend state. The crucial part in this example \nis that the state tran\u00adsitions do not explicitly reference a speci.c target state, but rather reference \nthe state members of Position. For instance, nextPosition in NotEnd transitions this to 2 http://code.google.com/p/pluralism/ \n3 Abstract methods are indicated by eliding the method body; constant .elds are declared with val, and \nvariable .elds with var. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \n29 30 31 32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 state Position { state notEndState = NotEnd; state endState \n= End; method setToEnd(); method setToStart(); val vector, minPos, maxPos; var currPos; } state NotEnd \ncase of Position { method setToEnd() { this.currPos = this.maxPos; this <-this.endState; } method setToStart() \n{ this.currPos = this.minPos; } method nextPosition() { this.currPos++; if (this.currPos >= this.maxPos) \n{ this <-this.endState; } } } state End case of Position { method setToEnd() { /* no op */} method setToStart() \n{ this.currPos = this.minPos; this <-this.notEndState; } } Listing 4. Position code. state Reader { } \nstate Reading case of Reader { method read() { val ret = this.vector.get(this.currPos); this.nextPosition(); \n} } state ReadEnd case of Reader { } state ReadStream = Position { val notEndState = Reading with NotEnd; \nval endState = ReadEnd with End; } with Reader; Listing 5. ReadStream code. this.endState, not End. This \nallows for consistent and .exible reuse, composition, and extension of states, as illus\u00adtrated hereafter. \n 1 state ReadWriteStream = Position { 2 val notEndState = 3 Writing with Reading with NotEnd; 4 val \nendState = 5 WriteEnd with ReadEnd with End; 6 } with Reader with Writer; Listing 6. ReadWriteStream \ncode. Consider the code for a ReadStream, as shown in List\u00ading 5. The ReadStream de.nition includes a \npure dimen\u00adsion, Reader. This dimension has two children Reading and ReadEnd, which correspond to the \nReadStream in the not\u00adend-state and the end-state, respectively. In the not-end-state, the ReadStream \ncan read, and therefore Reading de.nes the read method. This method reads from the underlying collection \nat the current position and advances the position. The ReadStream is composed from the two dimensions \nPosition and Reader. ReadStream specializes NotEnd by overriding the two state members in Position. The \nstate members in ReadStream are composed from two states, one from each dimension of ReadStream. Therefore, \nwhen the methods in Position and its children change state, they will change both dimensions of ReadStream. \nFor example, when nextPosition advances the stream to the end, the ReadStream object composed of Reading \nwith NotEnd will change to a ReadEnd with End. Initializing a ReadStream requires two-phase initializa\u00adtion \nlike for ResultSet. In particular, the code to create a ReadStream x that is not at the end is val x \n= new ReadStream; x<-this.notEndState;. Here again, tran\u00adsitioning x to the state member notEndState \nensures that the consistent composition of actual states is used. Since the Reader dimension has the \nsame structure as the Position dimension it is natural for transitions in Position to change Reader as \nwell. In this example, there is no code in the Reader states that enacts the state change. Instead, the \nReader dimension relies on the Position dimension to perform state changes. The state members in this \nexample allow for this kind of dimensional reuse without extensive glue code4. The only code required \nto required to reuse the dimension is the specialization of state members in ReadStream. We now illustrate \na further step of consistent composition of states with the de.nition of ReadWriteStream in List\u00ading \n6. The de.nition uses a new dimension, Writer, with two substates Writing and WriteEnd, de.ned in the \nsame manner as the Reader states. This ReadWriteStream reuses code from all three dimen\u00adsions with very \nlittle effort. The ReadWriteStream is the 4 State members also have a more traditional purposes. State \nmembers, like all states, can be used to create objects. They allow us to encode ML-style structures \nand functors. These abstraction mechanisms can be very powerful, especially in a typed version of Plaid. \nHowever, these purposes are not novel to Plaid so we do not focus on these here. natural extension of \nReadStream. The state members are composed from all three dimensions. The state transitions in a ReadWriteStream \nobject will change all three dimension at once. The ReadWriteStream example demonstrates both the power \nof a trait-like composition model and its novel ex\u00adtension to states. We reuse ReadStream and WriteStream \nwith little effort, as we could achieve in a language with traits. In addition, we have a new unit of \nreuse, the Position di\u00admension, which is shared with two other dimensions. This reuse eliminates duplicate \ncode, and helps avoid bugs. Both the Reader and Writer of a ReadWriteStream are in the end-state or not-end \nstate. Because the dimension is reused we can guarantee that no programmer will err and end up with an \nobject in an inconsistent state like WriteEnd with Reading. One important note is that the Writer and \nReader contain no members in common, and therefore no con.ict arises. Plaid requires explicit con.ict \nresolution at the point of composition. This con.ict resolution will be described in Section 4.2.  3.5 \nValidation The introduction claims four concrete bene.ts of Plaid: code closely re.ects design, programs \nare concise, error checking is implicit, and new opportunities for reuse. These bene.ts were illustrated \nin the examples in this section and they were discussed while describing the examples. We summarize the \ncase here for emphasis. We then re.ect on our experience writing mid-sized programs in Plaid, in diverse \ndomains. 3.5.1 Concrete bene.ts Code re.ects design. Designs with stateful abstractions are clearly \nre.ected in Plaid code. This is clear in of all three examples in this section. The implementation of \nthe .le, result set, and read-write streams all match their designs. Arbitrarily complex state-charts \ncan be encoded in Plaid with the simple rules described alongside the result set example. Each abstract \nstate maps to its own state in code, so the design of the abstraction and its protocol as a whole is \nhighly salient in the code. Concise programs. Since state constraints are implicitly enforced by the \nobject model, none of our examples included any error checking code. The implementation are therefore \nsmaller. Error Prevention. Plaid s explicit state models make error checking more consistent, because \nthe programmer cannot forget to check state constraints when a method is called. The level of abstraction \nof error messages is also thereby raised: when an inappropriate method is called, instead of triggering \nan internal run-time exception such as a null pointer, or (what is worse) silently corrupting data, the \nruntime can signal an  Project Lines of Code # Files CodeGenerator 1205 24 AeminiumCodeGen 2610 8 Typechecker \n4196 55 ASTtranslator 9506 107 PlaidApps 528 21 Standard Library 372 18 TestCompiler 2811 96 TestTypechecker \n363 9 Total 21591 338 Table 1. Plaid code written for eight projects. error that a particular method \nis unavailable in the current state. Also, we have shown how state members can be used to enforce consistency \nof multiple dimensions of state at once. Reuse. Plaid provides new reuse opportunities. Some state machines \nare used in many objects. For instance, the Position dimension was reused in both read and write streams, \nand it could also be reused in many IO and Collec\u00adtion libraries. Open and closed resources like the \nFile and ResultSet are also very common. Obj Val ov ::= mvdvmv 7 ovdv 7 ov Dim Val dv ::= tag{ov}tag{ov} \n<: dv  val n = v  medee   {}method MbrVal ()::=mvmxe777ObjExp de::=oemeoeoeeoe{}{}DimExp dedvde::= \ntagtag<:oeoe{}freshtagStateDecl sdde::= <:oe ee{to}  Mbr Exp me ::= mvval f [ x = erecstate{val s [ \nx = proto sd} freshtag{oe}oe ' Trait Op to ::= \\nn . nme(tagOf e).me Val v ::= govproto oefn(x) . e \nExp e ::= xvlet x = e in ee(e)e.m(e)e.ne . ee t enew ematch(e){c}freeze erecstate{mv}#l Case c ::= case(tagOf \ne) {e}default {e} Figure 4. Internal Syntax  3.5.2 Applicability to diverse domains In order to gain \npractical experience with the language and ex\u00adperiment with typestate-oriented programming beyond small \nexamples, we have written several mid-sized programs in Plaid. These programs further demonstrate the \nexpressive\u00adness of Plaid in a diverse set of domains including compi\u00adlation, input-output, GUIs, and \nweb. They are all available for download from the Plaid repository5. In total, we have written 22KLOC \nacross 338 .les. A breakdown of our im\u00adplementations is in Table 1. We call out items of particular interest \nhere. Compiler. Plaid is self-hosting; the CodeGenerator project compiles Plaid code into Java source. \nPlaid code can easily use Java libraries and many of our examples are implemented that way. In a sister \nproject [24], we have implemented a separate compiler for parallel-by-default code, which is the AeminiumCodeGen \nproject. We are currently working on a Plaid typechecker; the implementation is the Typechecker project. \nAll these projects are supported by AST transforma\u00adtions performed by the ASTtranslator project. GUI \nLibrary. GUI libraries often impose state constraints on their clients. We implemented Plaid wrappers \nfor a few key Java Swing classes, including Window, Pane, and Canvas abstractions. We use states to enforce \nproper initialization of these abstractions. In particular, windows should have some contents added, \notherwise they are created with size zero. Furthermore, windows are Hidden until show() is called, then \nthey become Visible. Panes should also have contents 5 http://code.google.com/p/plaid-lang/ added. Both \npanes and canvases must be assigned a parent window, and canvases should be given a preferred size. Our \nlibrary is not comprehensive, but it is suf.cient to build demonstration applications in our case, a \nTuring machine that uses Plaid s states to represent the .nite state control, the marks on the tape, \nand the illusion of an in.nite tape. Both the windowing library and Turing demonstration application \nare in the PlaidApps project. Miscellaneous The Plaidapps project includes the examples discussed earlier \nand a small web server and work.ow engine. The Plaid standard library includes integers, rationals, strings, \noptions, and standard control (e.g. if) and looping (e.g. for, while) structures. Finally, two testing \nprojects include a number of smaller tests and examples. 4. Semantics In this section we present the \nformal de.nition of the Plaid language and give it a precise semantics. At its core, Plaid is an object \nsystem with .rst-class generators and functions. Individual generators can be combined and specialized \nusing composition and operators inspired by traits [12], instantiated to create objects, or used to specify \nthe abstract state the object should change to. We start by describing the syntax and object model of \na core language, which is intended to be simpler than Plaid source code yet be capable of representing \nall of the major semantic elements of Plaid. Then we discuss the execution semantics of the core language. \n 4.1 Core Syntax The syntax of the internal representation of Plaid is given in Figure 4. In these de.nitions, \nx ranges over bound variables, while members of objects are represented by f, m, and s, which respectively \nrange over .elds, methods, and state members. We use n to represent any kind of object members when we \ndo not distinguish between them. Abstract states are represented using tags which are generated as needed. \nWe will introduce each syntactic category in turn, describing its purpose and motivations. 4.1.1 Expression \nSyntax Plaid contains the standard expressions found in object sys\u00adtems, including object creation through \nnew, .eld selection, and method calls. Because Plaid also has .rst-class functions, we include standard \nfunction de.nition and application as well. For sequential expressions, we include let bindings and bound \nvariable references. The rest of the expression forms are related to Plaid s encoding of abstract states \nand the transitions between them: Changing state. The Plaid core has two state change oper\u00adators. . represents \na state update and only removes portions of the receiving object that are mutually exclusive with the \nincoming states. For completeness and .exibility, Plaid also includes a state replacement operator, t, \nwhich wipes the re\u00adceiving object clean before adding the incoming states, much like an in-place new \noperation. One could imagine using this operator in a situation where an object needed to be in a particular \nstate and no other states. This cannot be guaran\u00adteed by the state update operator because state update \nleaves dimensions unrelated to the updating state alone. Unlike the source language, Plaid s core does \nnot require the target of a state change operator to be this. This makes the core simpler and more .exible \nsince the restriction can be enforced at the source level. proto values. First class instance generators \nare provided by proto expressions. These are values which can be stored in .elds and passed as parameters. \nDuring a well-formed execution, the target of new expressions and the right-hand side of state change \nexpressions will evaluate to a proto value. This is because they encapsulate object expressions, oe, \nwhich are uninitialized objects. The state change and new expressions cause the initialization steps \nspeci.ed by the object expression wrapped in the proto to be evaluated for use in creating a new object \nor changing the state of an existing one. State expressions. To allow states to be chosen dynamically \nat runtime, we include several expression forms that can evaluate to a proto. As they are values, standard \ndeference or bound variables could result in proto expressions. Because most states included in protocols \nmust be de.ned with (mutual) recursion, proto values represented source-declared states are wrapped into \na recstate. A particular proto can be selected from the recstate as from a standard record. The freeze \nexpression is a more novel way to get a proto. It takes the object and wraps it up in a proto allowing \nnew instances to be generated from it. As an example of the use of freeze, consider the myResultSet value \nde.ned in Listing 3. Say we wanted to do some extra initialization of the ResultSet before using it and \nthat over the course of a program we would create the same ResultSet over and over. To avoid needing \nto do the same initialization repeatedly, one could freeze the object the fully initialized object and \nthen instantiated it each time a new ResultSet of this form was needed. freeze has already been used \nin the Plaid compiler to more cleanly support certain initialization paradigms, such as the transformation \nto let-normal form, where strings of let bindings must be concatenated together. Matching tags. Finally, \nthe match construct allows pattern matching based on tags. Each case tests the target object against \nthe tagOf another expression. This expression is expected to evaluate to a proto value with a single \nouter tag which is grabbed by tagOf and compared with the tags of the target object. If the object contains \nthe tag, the corresponding case is executed. Cases are evaluated in order. An example of the use of match \ncomes from the Plaid standard library. Plaid s syntax does not include control structures. Instead, if \nand while are encoded as functions that make use of match. The states True and False are each de.ned \nas a case of Boolean. Thus, the if function determines whether or not to evaluate the body based on whether \nthe object returned by the condition matches the True tag.  4.1.2 Object Value Syntax Plaid objects \nare collections of tags representing the states that the object is in along with .elds and methods that \nprovide the representation and operations of those states. In order to implement the desired semantics \nthese object must be organized to formally encode the relationships between tags and members that the \nsemantics depend on. In particular, we need to represent the following relationships between the abstract \nstates that the tags represent: 1. Superstates: An object in state, S, which is de.ned to be a case of \na superstate, T , must also be in state T . For instance, an object in the NotEnd state de.ned in .gure \n4 is also in the Position state. 2. Or-states: Distinct cases of a given state, such as the OpenFile \nand ClosedFile case of File, cannot exists together in an object. 3. And-states: Both objects and states \ncan be de.ned as a composite of other states. For example, the Open state from Listing 3 is de.ned in \nterms of states Direction, Status, and Action. Objects in the composite state are considered to be in \neach of the component states as well.   4. De.ning states: Members must be associated with the state \nthat declares them so that they can be removed from an object when their de.ning state is removed. To \nformalize these relationships, objects values are organized as hierarchical collections of dimensions, \nwhich contain tags for the state and all of its transitive super states, and members. Object values. \nThe basic component of an object is an object value, ov, which is a list of dimension values, dv, and \nmember values, mv. They are used to represent both top-level objects and the dimensions and members that \nde.ne a given state (see dimension values below). The 7 operator that separates each element of the list \nrepresents composition. Object values encode and-states by allowing two dimensions to coexist together \ninside the de.nition of a state. For instance, the object value that de.nes a ReadStream would have two \ncomposed dimensions, one for the Position dimension, and the other for the Reader dimension. Dimension \nvalues. Dimension values, tag{ov}[<: dv], encode the structure of a state and its super states. They \nare represented by a tag, tag, which is a unique name for the most specialized state from the dimension. \nAssociated with the tag is an object value which represents the collection of members that the state \nde.nes along with any other dimensions that make up the and-states of the state. A dimension value may \noptionally contain another dimension value encoding the superstate relationship. By containing the representation \nof a given states super\u00adstates, dimension values give us a way to encode the or-state relationship as \nwell. Two states that are the case of the same superstate would be encoded as separate dimensions with \nthe same state at the root of the dimension. Because the tags in the dimensions partially overlap, by \nrestricting tags to ap\u00adpear only once in a given object value, we can ensure that no or-states can coexist \nin a single object. Concretely, we would represent an instantiated Open state from Listing 3 as Open{Direction \n7 Status 7 Action} <: ResultSet. Here the most speci.c state of the represented dimension value is Open. \nThis state is de.ned based on the three states Direction, Status, and Action (de.ning object values not \nshown), and specializes the ResultSet state, which it was de.ned as a case of. A dimension is also Plaid \ns version of a trait. Multiple inheritance is achieved by allowing multiple dimensions to be composed \nin an object value as well as in the object val\u00adues associated with the tags of a dimension. The hierarchical \nnature of Plaid s dimension prevent us from using all of the trait mechanisms for solving the problems \nof multiple in\u00adheritance. In particular, a multiple inheritance system must deal with the case when one \nclass inherits from two classes that share a (transitive) parent. This situation is challenging because \nit is non-obvious how to inherit members from the common grandparent. This problem is commonly referred \nto as the diamond problem [19], because of the shape of the inheritance hierarchy diagram. The original \ntraits proposal [12] .attens 6 composed traits and forces any con.icts be\u00adtween method names to be explicitly \nresolved (.eld were not allowed in traits). However, as Plaid s semantics depend on members being related \nto the tag they are de.ned in, we cannot use .attening. Instead, Plaid prevents the diamond problem by \npreventing or-states from coexisting, thereby pre\u00adventing the same tag and member de.nition from appearing \nmore than once (following Malayeri s no-diamonds rule [19]). Plaid s solution follows recent extensions \nof traits including [5, 9, 22]. Like Plaid, these system support traits with .elds and work in a variety \nof object models including those that, like Plaid, add hierarchy and do not enforce the .attening property. \nAs with the original trait proposal, all name con\u00ad.icts across dimensions must be explicitly resolved \nin Plaid via the trait operators described below. Member values. A member value is either a method, with \na set of arguments and a body, or a .eld, val f, bound to a value, v. The member is said to be de.ned \nin the state represented by its immediately enclosing tag. As a concrete example, an object in the ClosedFile \nstate described in List\u00ading 1 would be represented formally as ClosedFile{method close(){e}}<: File{val \n.lename = v} This indicates that the object is in both the ClosedFile and the File states, one of which \nis a substate of the other, and each of which de.nes a single member.  4.1.3 Uninitialized Object Syntax \nPlaid has corresponding syntax for uninitialized objects or\u00adganized into object expressions, dimension \nexpressions, and member expressions. When compared to their value counter\u00adparts, they share the same \nstructure but contain expressions which are not yet values. In this section, we discuss the places where \nexecution can occur in these forms and the motivation behind them. Object expressions. Object expressions, \noe, are made up of the composition of dimension expressions, member expres\u00adsions, as well as raw expressions. \nThe purpose of unevaluated expressions in dimension and member expressions will be explained below. Raw \nexpressions as components of object expressions allow part of an uninitialized object to be deter\u00admined \nat the time of initialization. These expressions evaluate to proto values which are then incorporated \ninto the initial\u00adizing object. This provides for Plaid s implementation of dynamic trait composition \nby allowing portions of the object to be selected at runtime. 6 The .attening property from [12] states \nthat members of an are treated equally regardless of what trait they were de.ned in.  Dimension Expressions \nDimension expression can contain unexecuted expressions in the object expression associated with the \nmost speci.c tag as well as in tags up the hierarchy if they exist. Dimension expressions may also have \nassoci\u00adated trait operations, to, which need to be evaluated. Trait operations allow standard manipulations \nsuch as renaming, n . n ', and removal, \\n. Note that these operate on the whole dimension, renaming \nor removing all members of the speci.ed name de.ned directly in tags in the hierarchy (not including \nnested dimensions). This allows the changes to be preserved by state change in the dimension as we will \nsee below. Members can also be added or replaced7. By default, they are (re)placed in the most speci.c \ntag of the dimension expres\u00adsion. However, In cases where members need to be added or replaced in a particular \ntag, they can be quali.ed by a particu\u00adlar tag, speci.ed as with tags in case statements by tagOf an\u00adother \nexpression. The rede.nition of Position.EndState for the ReadStream in Listing 5 is an example of using \nqual\u00adi.ed trait operations. This mechanism is important in Plaid because of the hierarchical nature of \nPlaid s object model and when and how member de.nitions are removed during state change. Member expressions. \nOnly .elds can be member expres\u00adsions, me, as methods do not have any initialization code. On the other \nhand, .elds can be de.ned with initialization expres\u00adsions that require evaluation as a part of object \ncreation or update. In order to allow .elds to refer to the initialized value of previous .elds in the \nsame state, .eld expressions de.ne an internal bound variable in addition to their external name (this \nis a standard approach from [21], chapter 8). Fields are also generated by state declarations. Since \nthe de.nitions of related states, such as the OpenFile and ClosedFile from Listing 1, are typically recursive, \nthe initialization of state members occurs in a recstate binding. State members are also special in that \nwhen an uninitial\u00adized object containing state members is initialized, new tags may need to be generated. \nThe proto expression encapsu\u00adlates uninitialized objects as discussed above. Normally they contain object \nexpressions, but when appearing in a recstate, they contain state declarations, sd which may contain \nthe freshtag operations that generates a new tag when executed, resulting in an object expression. This \nfeature means that new tags are generated for states de.ned inside states each time the outer state is \ninstantiated. Because these tags can then be used to pattern match on objects, this allows Plaid to implement \nML-style generative functors8. Functors have 7 The semantics de.ned here do not allow .elds and states \nin trait operations to refer to other trait operation members. The formalism could be extended to support \nthis, mirroring the case for declarations in states 8 Generative functors, in contrast to applicative \nfunctors, generate new abstract types for each application of the functor. This impacts pattern matching \nwhen using these generated types in a similar way as pattern matching on freshly generated tags in Plaid. \nHeap H ::= [g ' ov], H \u00b7 Eval E ::= [ ] let x = E in e E(e) v(v, E, e) E.m(e) v.m(v, E, e) E.f E . e \nv . E v . proto E E t e v t E v t proto E new E new proto E match(E){c}match(v){case(tagOf E) {e}, c}freeze \nE ov 7 E O 7 oe O Obj O ::= val n [ x = E tag{oe} <: E tag{E} tag{E} <: dv E{to}dv{to, val n = E, to}dv{to, \n(tagOf e).(val n = E), to}dv{to, (tagOf E).mv, to} Figure 5. Contexts well recognized modularity bene.ts \nthat we do not discuss here.  4.2 Dynamic Semantics We now introduce the dynamic semantics of Plaid. \nWe for\u00admalize the execution using a small step operational semantics. ' The basic evaluation judgment \nhas the form e@H . e ' @H and is read expression e with heap H evaluates to ex\u00ad ' pression e in heap \nH ' . We de.ne a similar judgment ' oe@H . oe ' @H for the evaluation of object expressions. In this \nsection, we will de.ne the form of the heap and the invariants that we maintain on it. We will also discuss \nthe Plaid-speci.c evaluation rules, in particular those that use ancillary judgments for implementing \nstate change. As state change is at the core of Plaid s design and is the most com\u00adplicated we go into \ndepth about the motivation and design of the rules that implement it. Finally, we describe object initialization \nand trait operations that may be involved. 4.2.1 Heap A heap, H, is a mapping from locations, g, to \nobject values. We place additional well-formedness requirements on all object values stored in the heap. \nThese restrictions prevent ambiguities from multiple inheritance. Tag uniqueness. We require that all \nwell-formed object values have no duplicate tags. As alluded to above, this property ensures that an \nobject is not in two cases of a single or-state at the same time. This is because the tags representing \ntwo mutually exclusive or-states must come from the same dimension and thus must have at the least the \nroot tag of the dimension in common. It also prevents the diamond problem of multiple inheritance by \nensuring that a particular member de.nition does not appear multiple times in a single object. This invariant \nis encoded in the helper judgment uniqueTags also de.ned in Figure 10. Member uniqueness. Even though \na given de.nition for a member cannot appear more than once, it is still possible  e@H . e@H |{x}| = \n|{v}| E-LET E-APP let x = v in e@H . e[v/x]@H (fn (x) . e)(v)@H . e[v/x]@H H[g]= ov lookup(m, ov)=(method \nm(x){e}) H[g]= ov |{x}| = |{v}| lookup(f, ov)=(val f = v) E-CALL E-FIELD g.m(v)@H . e[g/this][v/x]@H \ng.f@H . v@H H[g]= ov1 uniqueTags(ov2) ov1 . ov2 . ov3 uniqueMembers(ov3) uniqueTags(ov) uniqueMembers(ov) \nE-SU E-REPLACE g . proto(ov2)@H . void@H[g ' ov3] g t proto(ov)@H . void@H[g ' ov] g/. H uniqueTags(ov) \nuniqueMembers(ov) E-NEW new (proto ov)@H . g@H[g ' ov] de = tag{oe}[<: de ' ] tag /. tags(H[g]) E-CASENOMATCH \n match(g){case (tagOf proto de){e},C}@H . match(g){C}@H de = tag{oe}[<: de ' ] tag . tags(H[g]) E-CASEMATCH \n match(g){case (tagOf proto de){e},C}@H . e@H H[g]= ov E-CASEDEFAULT E-FREEZE match(g){default{e},C}@H \n. e@H freeze g@H . proto ov@H l = ls oe = oels [recstate{val si = proto oei}#li/si] E-RECSTATESELECT \n recstate{val si = proto oei}#l@H . proto oe@H Figure 6. Expression Evaluation that multiple tags de.ne \nmembers with the same name. To prevent ambiguities in this case we require that all members of an object \nare provided by exactly one dimension. Because the hierarchy of dimensions gives us a natural way to \nchoose the visible de.nition (the one from the most speci.c tag in the dimension) we allow a single name \nto be de.ned directly in multiple tags from a single dimension. Formally, two tags are in the same dimension \nis one is a transitive case of the other. This relaxation of classical traits allows, for instance, a \ncommon super state to de.ne a default behavior for a method which can be overridden by (some of) its \nsubstates. The judgment uniqueMembers de.ned in Figure 10 captures this requirement. It uses the judgments \nmv :: tag.x@ov, which states that member value mv from tag tag de.nes name x in object value ov, and \ntag << tag ' @ov which asserts the property that tag tag is a transitive subtag of tag ' in object value \nov. Based on these helper judgments, an object value has unique members if whenever we .nd the same member \nde.ned in two tags, then one of these tags is a transitive subtag of the other. We prove that evaluation \npreserves member and tag uniqueness in the companion technical report [26]. Member lookup. As an object \ncan contain multiple mem\u00adbers with the same name, we need an unambiguous way to choose which one is visible. \nThe lookup function also in Figure 10 de.nes this logic. When multiple de.nitions are found, we know \nby uniqueMembers that they all come from the same dimension. Since the tags of a dimension form a total \norder, we know that one of tags de.ning the member will be a transitive subtag of all other tags de.ning \nthe member. The de.nition from this most speci.c tag is the one returned by lookup.  4.2.2 Expressions \nThe evaluation rules for expressions in Plaid are given in Figure 6. We only list only computation rules \nhere, de.ning congruence rules using evaluation contexts shown in Figure 5. In these, each expression \nwith a subexpression that requires  evaluation de.nes a hole, [], into which any expression can be placed. \nEvaluation proceeds by using the computation rule that evaluates the expression in the hole. Standard \nrules. The computation rules for the evaluation of the expressions from general object systems and the \nlambda calculus are almost all completely standard in our system. These include the rules E-LET, E-APP, \nE-CALL, and E-FIELD for let expressions, application, method calls and .eld dereferences respectively. \nOne note is that mem\u00adber selection during calls and dereferences use the lookup judgment described above. \nWe also use standard record evaluation rules when selecting a label from a recstate (E-RECSTATESELECT). \nMatch. Plaid uses a .rst-match semantics, so that we .nd the .rst case clause whose tag matches the target \nobject. We .nd the tag to match against by grabbing the most speci.c tag (tagOf) from a dimension expression \nwrapped in a proto value. Note that in this case the dimension expression is not evaluated since we are \nonly interested in the tag. If the tag is found in the target object, the code for this case is evaluated \n(E-CASEMATCH); otherwise, execution proceeds to the next case (E-CASENOTMATCH). Default cases are always \nexecuted and terminate the match if reached (E-CASEDEFAULT). Evaluation gets stuck if no matching case \nis found. Freezing. To freeze a location in the heap (E-FREEZE), we simply pull the object value from \nthe heap and wrap it in a proto expression. Manipulating objects in the heap. The state change oper\u00adators \nand new cause objects in the heap to be changed or allocated. Because we only allow object values to \nappear in the heap, we must .rst initialize the object that will be used to alter the heap by reducing \nit to an object value. Evaluation is mostly handled by the evaluation contexts: .rst the expres\u00adsion \nrepresenting the object is reduced to a proto value and then the object expression wrapped in the proto \nis evaluated down to an object value. An important design decision in Plaid was to run the initializers \nfor all members of an object expression. This happens despite the fact that not all mem\u00adbers may end \nup in the object (see the explanation of state update below). In particular, any effectful initializers \nwill al\u00adways be run and update the wider context. We experimented with other possible semantics but decided \nthat a clear and unambiguous rule for when initializers were run (always) was better than a .exible but \ncomplicated one. Furthermore, we consider it good Plaid style to avoid the use of effectful initializers \nand instead use other design techniques, such as factory methods, when effectful operations are required \nas a part of object initialization. Once the initialization code in the proto has been run, the resulting \nobject value can be used to update the heap. In the case of new and state replacement (t) expressions \nit is clear what the object value that is inserted into the heap will be. new allocates a new location \non the heap and maps it Listing 7. Open, Inserted, Scrollable, Updatable ResultSet 1 val rs = Open { \n2 Inserted <: Inserting <: Action, 3 Scrollable <: Direction, 4 Updatable <: Status } 5 <: ResultSet \n to the resulting object value. State replacement replaces the mapping of the target location on the \nheap with the updating object value. Since we know the precise form of the object value that is being \ninserted into the heap, in order to maintain the heap invariants on object values, we can simply check \nthat uniqueTags and uniqueMembers both hold on the new object value as done in the rules E-REPLACE and \nE-NEW. On the other hand, the semantics of updating an object on the heap using state update are much \nmore complicated, and so we devote the next section to a discussion of its design and proof that they \nmaintain the necessary invariants.  4.2.3 State Update At the core of the rule E-SU which updates the \nheap with the result of a state update is the state update judgment, ov . ov . ov, which is described \nin Figure 7. The judgment takes two object values and determines the resulting object value when the \ntarget object on the left side of the arrow is changed to the state given by the update object from the \nright side. The semantics of this judgement are the most complicated and important part of Plaid s dynamic \nsemantics. Thus, before describing the semantics given by the rules, we step back and give a high-level \noverview of the desired behavior. We then de.ne some general properties and assumptions of the judgment \nbefore describing the rules themselves. Design considerations. Our goal is that the design of the state \nchange judgment should match the semantics of stateful abstractions as modeled by state charts and similar \ntools. Thus, a state update should transition a target object from its current set of abstract states \nto a possibly new set of abstract states as speci.ed by the update object. To do this, we need to formalize \nthis intuition in terms of object values. Update dimensions. Our .rst task is to determine which abstract \nstate the update object is changing. That is, which dimensions of the target object need to be updated? \nConsider the object value (without members) of an Open ResultSet in the Inserted, Scrollable, Updatable \nstate, stored in val rs as depicted in Listing 7. What should happen if we update rs to the ReadOnly \nstate? rs . ReadOnly <: Status While there are clearly matches between tags in the target and update \nobjects, since the tags are nested inside the Open tag of the target object, it is not clear that they \nshould be updated. ov . ov . ov ' ' ovt . ov . ov ov . ovu . ovo  SU-LIST SU-MV ovt . ov 7 ovu . ovo \novt . mvu . ovt 7 mvu tags(dv) n outerTags(dvu) = \u00d8 dv . dvu . dvr tags(ovt) n tags(dvu) = \u00d8 uniqueTags(dvu) \nSU-ADDH tags(ov) n tags(dvr) = \u00d8 SU-MATCHDIM ovt . dvu . ovt 7 dvu ov 7 dv . dvu . ov 7 dvr outerTags(dvu) \nn tags(ov)= \u00d8 ov . dvu . ovr [tags(dvu) n tags(dv)= \u00d8] tag . tags(dvu) SU-MATCHINNER tag{ov}[<: dv] \n. dvu . tag{ovr}[<: dv] outerTags(dvu) n innerTags(dv)= \u00d8 dv . dvu . dvr tags(tag{ov}) n tags(dvu)= \u00d8 \nSU-MATCHSUPERINNER tag{ov} <: dv . dvu . tag{ov} <: dvr tag /. outerTags(dvu) outerTags(dvu) n outerTags(dv) \ndv . dvu . dvr = \u00d8 SU-MATCHSUPER tag{ov} <: dv . dvu . dvr dvu =[dvsub] <: tag{ov ' } <:[dvsup][tags(dvsub) \nn tags(tag{ov}[<: dv]) = \u00d8] uniqueTags(dvsub) SU-MATCH tag{ov}[<: dv] . dvu . [dvsub] <: tag{ov}[<: \ndv] Figure 7. State Update However, if we think of the state update as an transition to a new abstract \nstate, then we can see that the nesting in the target object should not matter. This state update speci.es \nthat the Status dimension should transition to the ReadOnly substate, and thus out of the Updatable state. \nThe converse question is does nesting matter in the other direction? In other words, can a nested state \ntrigger a change in an abstract state? Concretely, would this state update rs . Foo{ReadOnly <: Status} \nresult in an object in the ReadOnly state? Based on the semantics of state charts, the answer would be \nno . Our de.nitions of object dimension indicates that the Status dimension of the Foo state is part \nof the de.nition of Foo. Thus, it is brought along with the transition to the Foo state. The Status state \nis also a de.ning and-state of the Open state. Thus the resulting object cannot be consistent because \ntwo separate dimensions are claiming the Status state meaning there would need to be duplicate tags. \nTherefore, we de.ne the dimensions along which a state update occurs to be only those found at the top \nlevel of the object value that describes the update object. All other dimensions that are a part of the \nupdate object are considered de.nitions of these dimensions and do not induce transitions but are only \nadded to the object with their enclosing state. Dimension updates. Once we know which dimensions will \nbe updated, we need to know what in those dimensions is changed. We .rst note that we can treat the transition \nin each dimension independently as dimensions are orthogonal by de.nition. Second, recall the .le example \nfrom Listing 1. In this example, we stated that the filename member was shared between the OpenFile and \nClosedFile states. Thus, when we transition from an ClosedFile to an OpenFile the members of the File \nstate should remain constant. This is the semantics behind the restricted update semantics of state change \ndescribed in [2]. We use and extend these semantics in a natural way to account for our hierarchical \nobject model. Properties of object and state update. With the intuition we have for the design, we can \nde.ne some terminology that is used in the judgment itself. Inner and outer tags. In the informal description \nof state change, we differentiated between dimensions and tags de\u00ad.ned at the top level of the update \nobject and those that appear within a top-level dimension. Figure 10 de.nes two judgments, outerTags \nand innerTags, which capture this distinction. The outerTags of an object value, ov, are all the tags \nwhich appear as the most speci.c tag and any of its super tags from dimensions appearing directly in \nov. For example, using rs, the ResultSet object from Listing 7, outerTags(rs)= {Open, ResultSet}. Conversely, \nthe innerTags of an object value are all of the tags de.ned in dimensions that are recursively included \nin the de.nition of each of the outer tags. For example,  innerTags(rs)= {Inserted, Inserting, Action, \nScrollable, Direction, Updatable, Status} Unique dimension property. Given a dimension within which to \ntransition the target object, we need to .nd the location of the matching dimension within the target \nobject value. To do this, we look for the part of the object that has tags which overlap the outer tags \nof the update dimension. We ignore all super-tags of the matching tag in the update dimension under the \nassumption that these supertags will match the tags in the target. This assumption is based on the the \nUnique Dimension Property which states that a single unique tag can only ever appear in a single dimension. \nThat is a tag is either has no super tags or always appears with the same supertag. While this property \nis not guaranteed by the syntax and semantics of the internal language, it is enforced by the elaboration \nfrom Plaid s source syntax so we assume it in our rules. Maintaining the uniqueTags property. Rule E-SU \nin Fig\u00adure 6 does not check whether the object returned from the state update judgement has unique tags. \nTherefore the state update judegment must maintain this property. For\u00admally: If uniqueTags(ov1) . ov1 \n. ov2 . ov3, then uniqueTags(ov3). A proof of this property is in the compan\u00adion technical report [26]. \nInference rules. With this understanding, we can describe the rules that produce the object value after \na state update operation. The rules start by breaking apart the update object ov into the individual \nmember values and dimension values and processing the state changes for each dimension or value individually \n(SU-LIST). This is allowed since each dimension can be treated independently. We can assume that uniqueTags \nholds for each dimension individually since it holds for the object as a whole. For member values (SU-MV) \nand dimension values for which there is no overlap between the tags of the target object and update dimension \n(SU-ADDH), we just compose the update object with the target object. The rest of the rules assume that \nthere is a match between the outer tags of the update object and the tags of the target object. If that \nis not the case, then the evaluation gets stuck. SU-MATCHDIM covers the case where we have found a particular \ndimension of the target object that contains the tags that are changing. By the unique dimension property \nexplained above, we know that the outerTags(dvu) will not appear in ov, so it suf.ces to calculate the \nstate update on just the matched dimension. To ensure that we maintain the unique tags property, we can \nassume that both the result of the state update and the unmatched portion of the object have unique tags, \nand so it suf.ces to check that the tags of these two portions of the object do not intersect. SU-MATCHINNER \nhandles the case where there is over\u00adlap between the innerTags of the current tag and the outerTags of \nthe update dimension. We recursively .nd the state update on just this matching portion and then check \nthat the tags from the resulting object value do not intersect with the tags of the super tag, if it \nexists, to maintain the uniqueTags invariant. In SU-MATCHSUPERINNER, we .nd that the matching dimension \nis de.ned somewhere inside of a super tag. Thus, we run state update on just the supertags. We then verify \nthat the tags of the result are distinct from the tags of the subtag and its innerTags to maintain the \nuniqueTags invariant. SU-MATCHSUPER represents the case where we have found the right dimension, but \nhave not reached the level of the dimension where the tags overlap. The current tag of this dimension \nis not in the outer tags of the update dimension, but there is overlap somewhere in its super tags and \nso we .nd the updated state from that portion of the dimension. In this case, we know that the current \ntag will be removed with any of its nested tags, which means that we do not need to check if these tags \nwould con.ict with tags that enter the object with the update dimension to preserve uniqueTags. The base \ncase SU-MATCH handles the actual alteration of the target dimension. The current tag matches a speci.c \ntag in the outer tags of the update dimension, which indicates that the state update only affects states \nbelow this point in the dimension. In particular the tags below this one in the dimension in the target \nobject are discarded, as already occurred through the SU-MATCHSUPER rule. In their place are put all \nthe subtags of the matched tag from the incoming dimension. To make sure that we do not have duplicate \ntags anywhere, we only need to check that the tags added from the update dimension do not intersect with \nthe tags that are in its new supertags. Example. To give a speci.c example, consider evaluating the following \nstate update on the object de.ned in Listing 7: rs . ReadOnly <: Status The state updates proceeds .rst \nby .nding that there is tag overlap between the incoming and target objects and a match for the Status \ntag of the incoming state nested inside the Open state with the SU-MATCHINNER. Next it .nds the correct \ndimension Updateable <: Status using the SU-MATCHDIM rule. It discards the Updateable tag and recurses \nup the dimension in the SU-MATCHSUPER rule and .nally adds the ReadOnly tag in its place with the SU-MATCH \nrule. Reduction rule The E-SU reduction rule uses the state up\u00addate judgement to determine what object \nvalue to update the target object to. The state update judgement incremen\u00adtally checked that uniqueTags \nwas maintained. It does not  oe@H; T . oe@H; T ' [oe = oe[v/f ' ]] E-RECFIELD ' val f [ f = v[ 7 oe]@H \n. val f = v[ 7 oe ' ]@H sd = freshtag{oe}[<: de] tag is fresh r = recstate{val sd [ xd = v, val s [ x \n= proto (tag{oe}[<: de]), val sr [ xr = proto sdr}[ 7 oe] E-RECSTATE1 ' recstate{val sd [ xd = v, val \ns [ x = proto sd, val sr [ xr = proto sdr}[ 7 oe]@H . r@H ' ' oe = oei[recstate{val si = proto oei}#si/xi][oe \n= oe[recstate{val si = proto oe}#si/xi]] i E-RECSTATE2 ' recstate{val si [ xi = proto oei}[ 7 oe]@H \n. val si = proto oe [ 7 oe ' ]@H i E-DE (tag{oe} <: proto de[{to}])[ 7 oe ' ]@H . (tag{oe} <: de[{to}])[ \n7 oe ' ]@H E-OE proto[ov 7 ](proto oe[{to}])[ 7 oe ' ]@H . proto[ov 7 ](oe[{to}])[ 7 oe ' ]@H dv{to}. \ndv ' E-TRAITOPS (dv{to})[ 7 oe]@H . dv ' [ 7 oe]@H Figure 8. Object Evaluation guarantee that uniqueMembers \nis satis.ed and so the rule checks that the resulting object value has unique member declarations.  \n4.2.4 Object Evaluation The .nal class of reductions that we must model is that of state expressions, \nincluding the initialization of object expressions within a proto. These rules are de.ned in Figure 8. \nCongruence rules are again taken care of by evaluation contexts from Figure 5. E-RECFIELD: When .eld \nmembers have been evaluated down to values, we propagate them forward into the rest of the declarations \nthat need to be initialized by substituting the value in for the bound variable on the right of the [. \nThis allows subsequent .elds to use the values of previously declared .elds during their initialization. \nAfter this propagation, we do not need to keep track of the bound variable any longer and so do not record \nit in the member value. Note that these semantics force us to be strict about the order in which portions \nof the object are initialized. In particular member declarations are initialized from left to right as \nspeci.ed by the evaluation contexts.  E-RECSTATE1: If there are freshtag directives in the state declarations \nof a recstate, new tags are generates by picking a fresh tag not previously mentioned.  E-RECSTATE2: \nAfter assigning new tags to all of the state declarations inside a recstate, we need to remove the recstate \nconstruct and convert it into a list of val declarations. This is done in a manner similar to the .x \nconstruct in the lambda calculus. Since our recstate is  modeled as a record, we replace all references \nto the inner bound variable of each of the nested state vals with selections of the external name from \nthe recstate. We do this both inside the object expressions of each proto as well as in subsequent declarations. \nNote again that after propagation we can remove the bound variable from the val declaration. E-DE and \nE-OE: These rules state that it is possible to un\u00adwrap a proto that is nested inside another proto. This \ncan occur when a proto is part of an object expression inside another proto (E-OE), or when a proto is \nin a dimension expression, which only appear in proto expressions (E-DE). In either case, if trait operations \nare associated with this proto, then they are retained. Execution will continue by evaluating the wrapped \nobject expression if needed.  E-TRAITOPS: This rule applies only once the all of the trait operations \nhave been fully reduced and proceeds using the trait operations judgment de.ned below to produce a new \ndimension value.   4.2.5 Trait Operations As with state change, we de.ne a separate judgement for trait \noperations that applies once all trait operations have been fully initialized, meaning that they can \nall be applied atomically without reduction. The rules for initialization of trait operations are all \ncongruence rules handled by evaluation contexts (see Figure 5). Thus, the judgement, ov{sp}. ov, does \nnot require a heap. In general, trait operations follows previous work on traits. However, Plaid s object \nmodel, unlike traditional traits models, is hierarchical. Hence, trait  Figure 9. Trait Operations \noperations other than the local member addition must take this hierarchy into account. Local member updates \nare agnostic to whether the added member is already a member of the tag and simply add the new member, \nreplacing the existing member if one exists (T-MEMBER). Updates of members in speci.c tags act the same, \nbut .rst must recurse through the object value looking for the speci.ed tag before performing the member \nupdate. The computation will get stuck if the tag is not found. Because each of these trait operations, \nas well as member renaming described below, may potentially add new members, there is the danger that \nthe object value might no longer satisfy the uniqueMembers invariant. However, since the specialization \nmust be occurring as part of object instantiation, it will be checked at the point that the object is \ncreated, so we do not make the check here. Member removal and renaming operate on the whole object, removing \nor renaming instances of members with the given name throughout. This is in contrast to lookup, which \nstops at the .rst declaration of the member. These semantics are required in order to allow trait composition, \nwhich includes the ability to remove members from a trait and instead provide them in another trait. \nThis would result in a con.ict if some members were left in the old dimension. 5. Elaboration The core \nlanguage de.ned in the previous section shares much in common with the full Plaid programming language, \nbut there are still differences. The semantics of the full Plaid language are de.ned as an elaboration \ninto the core language. Space does not permit including the full elaboration in this paper, but we present \nthe highlights and refer the interested reader to the accompanying technical report [26]. For most expressions, \nthe elaboration proceeds struc\u00adturally, without changing the construct itself. For .eld bind\u00adings, we \nadd the internal variable referred to above, and re\u00adplace references to the .eld in later .eld initializers \nwith the fresh variable. Sequences of state declarations are trans\u00adformed into recstate blocks. Each \nstate declaration is trans\u00adformed into a val declaration which binds to a proto repre\u00adsenting the uninitialized \nstate, with a freshtag expression for generating the state s tag when the declaration is executed.  \n Declarations D ::= SD method m(x){SE} val f = SE State Decl. SD ::= val s = S state s = S state s case \nof s{T O} = S States S ::= freeze(SE) {D} s{T } S with S SE.s s ' Trait Ops T O ::= \\n n . n val f = \nSE val s = S val s.f = SE val s.t = S method m(x){SE} method s.m(x){SE} Expression SE ::= x let x = SE \nin SE SE.f SE(SE) SE.m(SE) SE . S SE t S new S match(SE){C} Case C := case SE.s {SE} case s {SE} default \n{SE} Compil. Unit CU ::= D Figure 11. Source Syntax  Our formal semantics de.nes all of the Plaid language \nex\u00adcept for module linking and cross language binding. Module linking currently follows the Java standard, \nincluding pack\u00adages, imports, and a classpath for loading elements. Plaid primitives are de.ned using \nJava classes and methods, which can be directly accessed in Plaid via their fully-quali.ed Java names. \nDetails of both of these aspects of Plaid are discussed in more detail in the Plaid language de.nition \n[17]. 6. Discussion and Future Work The primary contribution of the Plaid language is providing a way \nfor programmers to express state machine abstractions directly in the source code of their programs. \nPlaid supports the major state modeling features of Statecharts, including state hierarchy, or-states, \nand and-states. The explicit rep\u00adresentation of states makes the design more salient in the code, enhancing \nprogrammer understanding. For example, the separation of members into different abstract states helps \nprogrammers quickly learn what operations are available in each state. In the future, visualization tools \nthat leverage ex\u00adplicit state constructs to automatically generate statecharts from Plaid code could \nprovide even greater bene.ts. Plaid has the potential to make code more reliable. Not only do explicit \nstates help programmers understand libraries better, avoiding errors in the .rst place; the runtime will \nalso verify that the libraries are used correctly according to their state abstractions. Even a method \nnot available in this state error is better than a silent corruption, but in future work, we believe \nwe can leverage explicit states to do much better. For example, a state-related error message could be \npaired with a suggestion about what methods could be called in order to move the object into a correct \nstate. Plaid s trait-like state composition model provides a way of reusing not just .elds and methods, \nbut state abstractions. This additional layer of reuse has the potential to reduce redundancy in code \nand speci.cations, while enhancing developer productivity. The con.dence that comes with the error checking \nin Plaid s state model may also help developers to evolve and refactor software with greater con.dence. \nIn future work, we plan to build more programs with Plaid in order to investigate the possible bene.ts \noutlined above. We are also developing a gradual type system that can complement Plaid s dynamic state \nchecking with static checking, where desired by programmers [29]. We believe Plaid demonstrates a new \nkind of language, and we are excited to explore the consequences that language may entail. Acknowledgments \n We thank Nels Beckman and Robert Bocchino for their work on the semantics of Plaid; Manuel Mohr, Mark \nHahnenberg, Aparup Banerjee, Matthew Rodriguez, and Fuyao Zhao for their work on the Plaid compiler; \nand the PLAID group for their helpful feedback and suggestions. This research was supported by DARPA \ngrant #HR00110710019. Sven Stork is supported by the Portuguese Research Agency FCT, through a scholarship \n(SFRH/BD/33522/2008). Joshua Sunshine was supported by the Department of Defense (DoD) through the National \nDefense Science and Engineering Graduate Fellowship (NDSEG) Program. References [1] J. Aldrich, J. Sunshine, \nD. Saini, and Z. Sparks. Typestate\u00adoriented programming. In Proc. Onward, 2009. \u00b4state update in Plaid. \nIn Proc. MechAnisms for SPEcialization, Generalization and inHerItance, MASPEGHI, 2010. [2] J. Aldrich, \nK. Naden, and E. Tanter. Modular composition and [3] N. E. Beckman, D. Kim, and J. Aldrich. An empirical \nstudy of object protocols in the wild. In European Conference on Object-Oriented Programming 2011. [4] \nA. Bejleri, J. Aldrich, and K. Bierhoff. Ego: Controlling the Power of Simplicity. In Proc. Foundations \nof Object-Oriented Languages, 2006. [5] A. Bergel, S. Ducasse, O. Nierstrasz, and R. Wuyts. Stateful \ntraits and their formalization. Journal of Computer Languages, Systems and Structures, 34(2):83 108, \n2008. [6] L. Bettini, S. Capecchi, and F. Damiani. A Mechanism for Flexible Dynamic Trait Replacement. \nIn Proc. Formal Techniques for Java-like Programs, 2009. [7] K. Bierhoff and J. Aldrich. Lightweight \nobject speci.cation with typestates. In Proc. Foundations of Software Engineering, 2005. [8] B. Bloom, \nP. Keyser, I. Simmonds, and M. Wegman. Ferret: Programming language support for multiple dynamic classi.\u00adcation. \nComputer Languages, Systems and Structures, 35(3): 306 321, 2009.  [9] T. V. Cutsem, A. Bergel, S. \nDucasse, and W. D. Meuter. Adding state and visibility control to traits using lexical nesting. In Proc. \nEuropean Conference on Object-Oriented Programming, 2009. [10] R. Deline and M. Fahndrich. Typestates \nfor Objects. In Proc. European Conference on Object-Oriented Programming, 2004. [11] S. Drossopoulou, \nF. Damiani, M. Dezani-Ciancaglini, and P. Giannini. Fickle: Dynamic Object Re-classi.cation. In Proc. \nEuropean Conference on Object-Oriented Programming, 2001. [12] S. Ducasse, O. Nierstrasz, N. Sch\u00a8arli, \nR. Wuyts, and A. Black. Traits: A mechanism for .ne-grained reuse. ACM Transactions on Programming Languages \nand Systems, 28(2):331 388, 2006. [13] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design pat\u00adterns: \nelements of reusable object-oriented software. Addison-Wesley, 1995. [14] D. Harel. Statecharts: A visual \nformalism for complex systems. Science of computer programming, 8(3):231 274, 1987. [15] C. Hewitt, P. \nBishop, and R. Steiger. A Universal Modular Ac\u00adtor Formalism for Arti.cial Intelligence. In Proc. International \nJoint Conference on Arti.cial Intelligence, 1973. [16] C. Jaspan. Proper plugin protocols: Cost-effective \nveri.cation of frameworks. Technical Report CMU-ISR-11-101, Institute for Software Research, Carnegie \nMellon University, April 2011. Thesis Proposal, originally accepted April 2010. [17] Jonathan Aldrich. \nThe Plaid Language: Dynamic Core Speci.\u00adcation, 2010. http://plaid-lang.googlecode.com/hg/ docs/spec/current/current.pdf. \n[18] A. C. Kay. The Early History of Smalltalk. SIGPLAN Notices, 28(3), 1993. [19] D. Malayeri and J. \nAldrich. CZ: multiple inheritance without diamonds. Proc. Object-Oriented Programming, Systems, Languages, \nand Applications, 2009. [20] B. Pernici. Objects with Roles. In Proc. Conference on Of.ce Information \nSystems, 1990. [21] B. C. Pierce. Advanced Topics in Types and Programming Languages. MIT Press, 2005. \n[22] J. Reppy and A. Turon. Metaprogramming with traits. In Proc. European Conference on Object-Oriented \nProgramming, 2007. [23] A. Sterkin. State[chart]-Oriented Programming. In Proc. Multiparadigm Programming \nwith Object-Oriented Languages, 2008. [24] S. Stork, P. Marques, and J. Aldrich. Concurrency by default: \nusing permissions to express data.ow in stateful programs. In Proceeding of the 24th ACM SIGPLAN conference \ncompan\u00adion on Object oriented programming systems languages and applications, pages 933 940. ACM, 2009. \n[25] R. Strom and S. Yemini. Typestate: A programming language concept for enhancing software reliability. \nIEEE Transactions on Software Engineering, 12(1):157 171, 1986. [26] J. Sunshine, K. Naden, S. Stork, \nJ. Aldrich, and \u00b4 E. Tanter. First\u00adclass state change in plaid. Technical Report CMU-ISR-11-114, Institute \nfor Software Research, Carnegie Mellon University, October 2011. [27] A. Taivalsaari. Object-Oriented \nProgramming with Modes. Journal of Object-Oriented Programming, 6(3):25 32, 1993. [28] D. Ungar and R. \nB. Smith. Self: The Power of Simplicity. In Proc. Object-Oriented Programming, Systems, Languages, and \nApplications, 1987. [29] R. Wolff, R. Garcia, \u00b4 E. Tanter, and J. Aldrich. Gradual typestate. In European \nConference on Object-Oriented Programming 2011.    \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Objects model the world, and state is fundamental to a faithful modeling. Engineers use state machines to understand and reason about state transitions, but programming languages provide little support for building software based on state abstractions. We propose Plaid, a language in which objects are modeled not just in terms of classes, but in terms of changing abstract states. Each state may have its own representation, as well as methods that may transition the object into a new state. A formal model precisely defines the semantics of core Plaid constructs such as state transition and trait-like state composition. We evaluate Plaid through a series of examples taken from the Plaid compiler and the standard libraries of Smalltalk and Java. These examples show how Plaid can more closely model state-based designs, enhancing understandability, enhancing dynamic error checking, and providing reuse benefits.</p>", "authors": [{"name": "Joshua Sunshine", "author_profile_id": "81436601093", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2839255", "email_address": "sunshine@cs.cmu.edu", "orcid_id": ""}, {"name": "Karl Naden", "author_profile_id": "81479661703", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2839256", "email_address": "kbn@cs.cmu.edu", "orcid_id": ""}, {"name": "Sven Stork", "author_profile_id": "81442592591", "affiliation": "Carnegie Mellon University, University of Coimbra, Pittsburgh, PA, USA", "person_id": "P2839257", "email_address": "svens@cs.cmu.edu", "orcid_id": ""}, {"name": "Jonathan Aldrich", "author_profile_id": "81100454133", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2839258", "email_address": "jonathan.aldrich@cs.cmu.edu", "orcid_id": ""}, {"name": "&#201;ric Tanter", "author_profile_id": "81100346970", "affiliation": "University of Chile, Santiago, Chile", "person_id": "P2839259", "email_address": "etanter@dcc.uchile.cl", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048122", "year": "2011", "article_id": "2048122", "conference": "OOPSLA", "title": "First-class state change in plaid", "url": "http://dl.acm.org/citation.cfm?id=2048122"}