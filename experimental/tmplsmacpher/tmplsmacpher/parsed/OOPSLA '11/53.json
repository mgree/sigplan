{"article_publication_date": "10-22-2011", "fulltext": "\n Virtual Values for Language Extension Thomas H. Austin Tim Disney Cormac Flanagan University of California, \nSanta Cruz Abstract This paper focuses on extensibility, the ability of a program\u00admer using a particular \nlanguage to extend the expressiveness of that language. This paper explores how to provide an in\u00adteresting \nnotion of extensibility by virtualizing the interface between code and data. A virtual value is a special \nvalue that supports behavioral intercession. When a primitive op\u00aderation is applied to a virtual value, \nit invokes a trap on that virtual value. A virtual value contains multiple traps, each of which is a \nuser-de.ned function that describes how that operation should behave on that value. This paper formalizes \nthe semantics of virtual values, and shows how they enable the de.nition of a variety of lan\u00adguage extensions, \nincluding additional numeric types; de\u00adlayed evaluation; taint tracking; contracts; revokable mem\u00adbranes; \nand units of measure. We report on our experience implementing virtual values for Javascript within an \nexten\u00adsion for the Firefox browser. Categories and Subject Descriptors D.3.1 [Formal De.ni\u00adtions and \nTheory]: Semantics General Terms Languages, Reliability, Security. Keywords Proxies, Metaobject Protocols, \nBehavioral In\u00adtercession. 1. Introduction Programming language design is driven by multiple, of\u00adten con.icting \ndesiderata, such as: expressiveness, simplic\u00adity, elegance, performance, correctness, and extensibility, \nto name just a few. This paper focuses primarily on extensibil\u00adity: the ability of a programmer using \na particular language to extend the functionality and expressiveness of that lan\u00adguage. Extensibility \nis desirable on its own merits; it also helps control language complexity by allowing many as\u00adpects of \nfunctionality to be delegated to libraries, and it en- Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 11, October 22 27, 2011, Portland, Oregon, USA. Copyright \nc &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. . . $10.00 ables grassroots innovation, where individual \nprogrammers can extend the language rather than being restricted to par\u00adticular features chosen by the \nlanguage designer. Our starting point for language extension is the obser\u00advation that language semantics \ntypically involve interaction between code and data, where code performs various opera\u00adtions (allocation, \nassignment, addition, etc.) on data values. The behavior of each operation is typically hardwired by \nthe language semantics. If a function wants to perform addition on its argument, then it must be passed \na numeric value that can be understood by the built-in addition operation. Conse\u00adquently, a user-de.ned \ncomplex type will not interoperate with code that uses the built-in addition operation. Computer science \nhas a strong history of virtualizing var\u00adious well-de.ned interfaces. For example, virtualizing the interface \nbetween a processor and its memory subsystem en\u00adabled innovations such as virtual memory, distributed \nshared memory, and memory mapped .les. Virtualizing the entire processor enables multiple virtual machines \nto run on a sin\u00adgle hardware processor, or to migrate between processors. This paper explores the bene.ts \nof virtualizing the interface between code and data values. Speci.cally, we present a language that supports \nvirtual values. When a primitive operation expects a regular value but .nds a virtual value in its place, \nthat operation invokes a trap on the vir\u00adtual value. Each virtual value is simply a collection of traps, \neach of which is a user-de.ned function that describes how a particular operation should behave on that \nvirtual value. Although virtualization is often considered esoteric, with complex interactions between \nvarious meta-levels, we show that the semantics of data virtualization can be elegantly cap\u00adtured using \nthe standard tools of operational semantics. This operational semantics is mostly straightforward, with \naddi\u00adtional evaluation rules for invoking traps for operations on virtual values. We formalize this semantics \nof virtual values in the context of a particular dynamically typed language; however, our ideas should \nbe generally extensible to other languages. We believe that virtual values provide a rather useful no\u00adtion \nof language extensibility. Of course, validating a lan\u00adguage design feature is always dif.cult. In this \npaper, we aim to validate the expressiveness and extensibility bene.ts of virtual values by illustrating \nthe kinds of language exten\u00adsions that they enable. These extensions include:  1. Additional numeric \ntypes, such as rationals, bignums, complex numbers, or decimal .oating points1, with tra\u00additional operator \nsyntax. 2. Units of measure (meters, seconds, etc). 3. Lazy or delayed evaluation, with implicit forcing \nwhen a delayed value is passed to a strict operation. 4. Taint tracking. 5. Dynamically checked contracts \n[6], including contracts on functions and data structures that are enforced lazily. 6. Revocable membranes, \nwhich allow two components to interact until the membrane is revoked, after which fur\u00adther interaction \nis forbidden [17].  Each language extension is powerful yet small (the complete code is included in \nthe paper), thus illustrating that virtual values offer an elegant and expressive mechanism for lan\u00adguage \nextension. These extensions are nicely composable. For example, we extend the language with contracts, \nand use that contract ex\u00adtension to document other extensions. Our taint extension automatically tracks \ntaint information through all code, in\u00adcluding through the complex numbers extension or the de\u00adlayed \nevaluation extension. To emphasize the modularity bene.ts of virtual values, we brie.y consider the consequences \nof an alternative archi\u00adtecture in which these extensions are implemented as part of the language itself. \nThis approach radically complicates the language, since each extension may cross-cut the other features \nand evaluation rules of the language. For example, the taint tracking and complex number extension would \nin\u00adteract in a non-trivial fashion, since we would need to track how taint information .ows through operations \non complex numbers. In contrast, virtual values enable a clear separation of concerns between the various \nextension modules, and pro\u00advide a coherent and extensible architecture. Composed vir\u00adtual values are \nessentially an instance of the Decorator Pat\u00adtern [10], which is a fairly general pattern that can be \nap\u00adplied to any interface, but in our experience it is particularly powerful when applied to the widely-used \ninterface between code and data. 1.1 Related Work This work is inspired by Miller and Van Cutsem s proposal \nfor Javascript Catch-All Proxies [4, 18], which provide traps for operations on functions and objects. \nThese object prox\u00ad 1 Decimal .oating point numbers (IEEE 754-2008) avoids the unintuitive rounding errors \nof binary .oating point. Our work is partly motivated by discussions within the ECMA TC39 Javascript \nstandardization committee regarding the desire for a decimal .oating point library that could support \nconvenient operator syntax. ies virtualize the interface between code and objects (in\u00adcluding function \nobjects). Analogous functionality has been provided in other languages, including via Racket s chaper\u00adones \n[8]. Virtual values generalizes these prior ideas to virtualize the interface between code and all data \nvalues, including primitive values such as integers. This generalization enables additional applications, \nincluding applications (1) (5) from the list above, and may prove helpful for mainstream lan\u00adguages, \nwhich typically include a large collection of non\u00adobject values. SmallTalk [11] demonstrated the bene.ts \nof pure object\u00adoriented programming, in which all data values are ob\u00adjects, and all operations (including \naddition and conditional tests) are method calls. Smalltalk supports the de.nition of proxy objects that \nimplement the doesNotUnderstand: method and that delegate to an underlying object, a tech\u00adnique called \nbehavioral intercession. This pure object ar\u00adchitecture provides .exibility and partially virtualizes \nthe interface between code and data, since many operations are performed via dynamically-dispatched method \ncalls. How\u00adever, Smalltalk and related pure object languages such as AmbientTalk [20], E [19], and Python \ntypically do not pro\u00advide the full set of required traps, and in particular often omit the geti and seti \ntraps (discussed below) that are essential for full virtualization. This paper extends the virtualization \nprovided by pure ob\u00adject languages, and moreover demonstrates that extensibil\u00adity is not restricted to \npure object languages: virtual values enable similar extensibility in languages that are not object oriented, \nor that are only partially object oriented and which include non-object values. Language extensibility \nhas been the target of a rich body of prior research. For example, CLOS provides a very .ex\u00adible metaobject \nprotocol [15], which gives the ability to in\u00adspect and modify the behavior of the object runtime system, \noften in a very general manner. In comparison to CLOS, vir\u00adtual values provides a focused mechanism for \nchanging the language semantics at a per-value granularity, which is well\u00adsuited for the kinds of language \nextensions that we address. Aspect-oriented programming (AOP) [14] focuses on cross-cutting concerns \nthat span multiple components of a system. As one example, aspects have been used to en\u00adforce .ne-grained \nsecurity policies in browsers [16]. Virtual values share similar motivations to AOP, and both enable \nthe developer to insert code at different point-cuts, but using vir\u00adtual values these point-cuts are \nchosen dynamically (based on where virtual values are used) rather than statically (as in weaving-based \napproaches to AOP). In a language with a rich static type system, the trap dispatch operations on virtual \nvalues could be resolved statically, e.g. via Haskell s [22] type classes. This static type based approach \nprovides stronger correctness guaran\u00adtees and improved performance over virtual values, but at a cost \nof more conceptual complexity and some decrease in .exibility. Overall, virtual values seem best suited \nto provid\u00ading extensibility in languages whose static type systems are less rich than Haskell, or in \ndynamically typed languages. Also, whereas type classes such as Haskell s Num class vir\u00adtualize some \nlanguage operations (those that manipulate Num values), virtual values generalize this idea to all language \nop\u00aderations.  Contributions: The main contributions of this paper are: it virtualizes the entire interface \nbetween code and data values, thus providing a general mechanism for value\u00adspeci.c behavioral intercession; \n it clari.es that languages that are not object oriented or only partially object oriented can still \nenjoy the extensi\u00adbility bene.ts of pure object languages;  it presents an operational semantics for \nvirtual values;  it illustrate the extensibility bene.ts of virtual values by implementing six non-trivial \nlanguage extensions: (1) complex numbers; (2) units of measure; (3) delayed evaluation; (4) taint analysis; \n(5) contracts; and (6) re\u00advokable membranes;  and it reports on our experience implementing this design \nin the Firefox browser.  2. A Language With Virtual Values We formalize the semantics of virtual values \nin the context of an idealized language that extends the dynamically typed .-calculus with virtual values, \nas well as with mutable, ex\u00adtensible records, as in Javascript. For brevity, we use proxy as a synonym \nfor virtual value, and so refer to the language as .proxy. 2.1 Syntax The syntax of .proxy is summarized \nin .gure 1. In addition to the usual abstractions (.x. e), applications (ee), and vari\u00adables (x) of the \n.-calculus, the language also has constants (c), conditionals (if eee), and unary and binary operators \n(uop e and e bop e, respectively). Constants include numbers (n) and strings (s), as well as unit and \nboolean constants. A record is mutable .nite map from strings to values, as in Javascript. The language \nincludes constructs to create ({ s : e }), lookup (e[e]), and update (e[e] := e) this map. Following \nJavascript, we include the syntactic sugar e.x to abbreviate e[\"x\"], etc. A record access returns false \nby default (similar to undefined in Javascript) if an accessed .eld is not de.ned in a record. A proxy \nvalue p is created by the expression proxy e1 e2. Here, e1 should be a secret (discussed below) and e2 \nshould be a handler record that de.nes nine trap functions with the Figure 1: The Language .proxy Syntax \ne ::= Expressions x variable c constants .x. e abstraction ee application if eee conditional uop e unary \noperators e bop e binary operators { s : e } record creation e[e] record lookup e[e] := e record update \nproxy ee proxy creation isProxy e proxy predicate unProxy ee proxy inspection c ::= n | s | false | true \n| unit Constants uop ::= -| ! | isNum | isBool Unary operators isFunction | isRecord | tostring | ... \nbop ::= + | * | / | = | != | ... Binary operators Syntactic Sugar def e.x = e[\"x\"] ' def ' e.x := e= \ne[\"x\"] := e def x : e = \"x\" : e def let x = e1; e2 =(.x. e2) e1 def e1; e2 =(.x. e2) e1 x . FV (e2) def \nletrec x = e1; e2 = let y = {}; y.x := .e1; .e2 where . =[x := y.x] def e1 || e2 = let x = e1; if xxe2 \ndef e1 &#38;&#38; e2 = let x = e1; if xe2 x def .. e = .d.e d . FV (e) def f() = f unit def assert e \n= if e unit (unit unit) ' private x = e; y = e def = let p = {}; let q = {}; p.x := .e; q.y := .e'; q \nwhere . =[x := p.x, y := q.y]  following informal types: call :: argument . result getr :: index . \ncontents setr :: index . newcontents . Unit geti :: record . contents seti :: record . newcontents . \nUnit unary :: uop . result left :: bop . rightarg . result right :: bop . leftarg . result test :: Unit \n. Any The call trap de.nes how the proxy p should behave when it is used as a function and applied to \na particular argument, as in (p arg). The getr and setr traps de.ne the proxy s behavior when used as \na record, as in p[w] and p[w] := v, respectively. The geti and seti traps are called when the proxy p \nis used as a record index, as in a[p] and a[p] := v. The unary trap is invoked when a unary operator \nis applied to the proxy (e.g., !p). The speci.c unary operator is passed as a string argument (e.g., \n\"!\"), which facilitates handling all unary operations in a consistent manner. For binary operators, the \nproxy could occur on the left or the right side of the operator, and each case invokes a cor\u00adresponding \ntrap (left or right), with the binary operator string and the other operand being passed as arguments. \nIf both operands are proxies we give precedence to the left ar\u00adgument, and so the right trap is invoked \nonly when the left operand is not a proxy. Finally, if a proxy is used in a con\u00additional test, then the \nproxy s test trap is invoked, which should return a value to be used in that test. The isProxy construct \nprovides a reliable mechanism to distinguish proxy and non-proxy values, since isProxy is a separate \nconstruct in the language and not a unary operator whose behavior can be overridden by a proxy s unary \ntrap. Each proxy value (proxy ah) includes a secret a in addition to its handler record h. The purpose \nof this secret is to allow a module that allocates proxies to recognize its own proxies and to distinguish \nthem from proxies created by other (potentially adversarial) modules. In particular, code that knows \nthe secret a can use the unProxy primitive to extract the underlying handler record h from the proxy, \nvia unProxy a (proxy ah), which evaluates to h. Conversely, code that does not know the secret a cannot \ngain access to the underlying handler record h. Figure 1 includes the usual abbreviations for let and \nletrec, for the short-circuiting operators || and &#38;&#38;, and for de.ning and invoking thunks. A \nfailing assert is mod\u00adeled by getting stuck. To facilitate de.ning each language extension, we introduce \na lightweight syntax for modules ' private x = e; y = e with private variables x, public variables y, \nand where all de.nitions can be mutually recursive. (Here, overline de\u00adnotes a repeated sequence.) In \nthe desugared form of this construct, the records p and q hold the private and public bindings respectively, \nand only the public bindings in q are exposed to the rest of the program. The substitution . re\u00adplaces \nreferences to the module-de.ned variables x and y with accesses to corresponding .elds of p and q respectively. \n 2.2 Formal Semantics Figure 2 formalizes the informal semantics outlined above. A heap H is a .nite \nmap from addresses (a) to records, where each record maps strings to values. A raw value r is a constant, \nan address, or a .-expression. A value v is either a raw value or else proxy ah, where a is the secret \naddress and h is the handler record (or possibly a proxy that behaves like a handler record). An evaluation \nstate H, e contains a heap and the expression being evaluated. '' The rules for the evaluation relation \nH, e . H ,e de\u00ad.ne how to evaluate the various constructs in the language. The .rst collection of evaluation \nrules are mostly straight\u00adforward. The conditional test considers any raw value other than false as being \ntrue. As usual, the partial function d de\u00ad.nes the semantics of unary and binary operators (uop and bop, \nrespectively) on raw values. For example, the equal\u00adity operator is de.ned as follows, and always considers \n.\u00adexpressions to be distinct (due to the dif.culties of testing functional equivalence). def true if \nr1 = r2, neither are .-exprs d(\"=\",r1,r2)= false otherwise The unProxy primitive returns the handler \nrecord h only when the secret a in the proxy matches the address a passed to unProxy; and returns false \notherwise. The third collection of rules de.ne how traps are in\u00advoked for proxy values. For example, \naccording to the [CALLPROXY] rule, in a function application (fv), if the function f is actually a proxy \n(proxy ah), then the trap h.call (or equivalently, h[\"call\"]) is invoked on the ar\u00adgument v. Note that \nh can either be a handler record, or a proxy representing a handler record; the [CALLPROXY] rule handles \nboth cases uniformly. On a record access v[w] where v =(proxy ah), the trap h.getr is applied to the \nrecord index w, via the [GETRPROXY] rule. Updating a .eld of a proxy invokes its setr trap, and assignments \nalways return the assigned value. Using a proxy as a record index invokes its geti and seti traps via \n[GETIPROXY] and [SETIPROXY]. For a unary operation on a proxy, the unary trap is in\u00advoked, with the speci.c \nunary operator being passed as a string argument. For a binary operation, the semantics .rst attempts \nto dispatch to the left proxy argument, if that is a proxy, by calling its left trap via the rule [LEFTPROXY]. \nIf the left argument is a raw value but the right argument is a proxy, then that proxy s right trap is \ninvoked, passing the binary operation string and the left (raw) argument.  Figure 2: .proxy Semantics \nRuntime Syntax: r ::= c | a | .x. e Raw values v, w, h ::= r | proxy ah Values e ::= ... | a Expressions \nwith addresses H ::= Address .p (String .p Value) Heaps E ::= e | v | if ee | uop | bop e | v bop \nEvaluation context frames | proxy e | proxy v | isProxy | unProxy e | unProxy v | [e] | v[ ] | [e] \n:= e | v[ ] := e | v[w] := |{ s : v, s : ,s : e } Evaluation Rules: H, (.x. e) v . H, e[x := v] [CALL] \nH, { s : v }. H[a := { s : v }],a a . dom(H) [ALLOC] H, a[s] . H,v s . dom(H(a)),v = H(a)(s) [GET] H, \na[s] . H, false s . dom(H(a)) [GETFALSE] '' H, a[s] := v . H,v H = H[a := H(a)[s := v]] [SET] H, uop \nr . H, d(uop,r) [UNARYOP] H, r1 bop r2 . H, d(bop,r1,r2) [BINARYOP] H, if re1 e2 . H, e1 r = false [IFTRUE] \nH, if false e1 e2 . H, e2 [IFFALSE] H, isProxy (proxy ah) . H, true [ISPROXY] H, isProxy r . H, false \n[NOTPROXY] H, unProxy a (proxy ah) . H, h [UNPROXY] H, unProxy av . H, false v =(proxy ah) [UNPROXYFALSE] \n H, (proxy ah) v . H, h.call v [CALLPROXY] H, (proxy ah)[w] . H, h.getr w [GETRPROXY] H, r[proxy ah] \n. H, h.geti r [GETIPROXY] H, (proxy ah)[w] := v . H, (h.setr wv); v [SETRPROXY] H, r[proxy ah] := v . \nH, (h.seti rv); v [SETIPROXY] H, uop (proxy ah) . H, h.unary \"uop\" [UNARYPROXY] H, (proxy ah) bop v . \nH, h.left \"bop\" v [LEFTPROXY] H, r bop (proxy ah) . H, h.right \"bop\" r [RIGHTPROXY] H, if (proxy ah) \ne1 e2 . H, if (h.test()) e1 e2 [TESTPROXY] '' H, E[e] . H ' ,E[e ' ] if H, e . H ,e [CONTEXT] Figure \n3: Identity Proxy 1 identityProxy :: Any . Proxy = .x. proxy {} { 2 call : .y. xy 3 getr : .n. x[n] \n4 geti : . r. r[x] 5 setr : .n,y. x[n] := y 6 seti : .r,y. r[x] := y 7 unary : .o. unaryOps[o] x 8 left \n: .o, r . binOps[o] x r 9 right : .o, l . binOps[o] l x 10 test : . .x 11 }12 13 unaryOps : : UnaryOp \n. Any . Any = {14 \"-\" : .x. -x 15 \"!\" : .x. !x / / negation 16 isBool : .x. isBool x 17 // etc for all \nunary ops 18 }19 20 binOps : : BinaryOp . Any . Any . Any = {21 \"+\" : .x,y. x+y 22 \"=\" : .x,y. x=y 23 \n// etc for all binary ops 24 } 3. Language Extension Examples To illustrate the expressiveness and extensibility \nbene.ts of proxies, we use the .proxy language to implement a series of interesting language extensions. \nEach extension is small yet adds signi.cant expressive power to the language. In each language extension, \nwe often omit punctuation such as commas or semicolons, and use indentation to clar\u00adify nesting structure, \nas in Haskell. For brevity, we mostly ignore error handling, and so some proxies simply get stuck if \nused inappropriately. For documentation purposes, each de.nition includes a contract, whose semantics \nwe formal\u00adize (via proxies) in section 3.3 below. 3.1 Identity Proxy As a starting point for our series \nof language extensions, .g\u00adure 3 sketches a simple proxy that has no effect on program evaluation. In \nparticular, evaluating (identityProxy x) re\u00adturns a proxy in which each trap handler simply performs \nthe appropriate operation on the underlying argument x. For unary operations, the unary trap dispatches \nto an auxiliary record unaryOps, which maps each unary operator string to a function that performs the \ncorresponding operation. The left and right traps similarly dispatch to the binOps lookup table. Identity \nproxies have no need to recognize each other, and so we pass an arbitrary fresh record address as the \nsecret to proxy. Figure 4: Lazy Evaluation Proxy 1 delay : : Thunk . Proxy = . f. 2 letrec z = (. .let \nr=f(); z := . .r; r) 3 proxy {} { 4 call : .y. z()y 5 getr : .n. z()[n] 6 geti : . r. r[z()] 7 setr \n: .n,y. z()[n] := y 8 seti : .r,y. r[z()] := y 9 unary : .o. unaryOps[o] z() 10 left : .o,r. binOps[o] \nz() r 11 right : .o,l. binOps[o] l z() 12 test : . . z() 13 } The identityProxy may appear to be somewhat \ncircu\u00adlar, since it de.nes each unary operation in terms of that op\u00aderation itself. To illustrate how \nthis circularity bottoms out, consider: -(identityProxy (identityProxy 4)) This expression creates a \nproxy p1, in which x is bound to a second proxy p2, in which x is in turn bound to the in\u00adteger 4. The \n- operator above therefore invokes the trap p1.unary(\"-\"), which calls unaryOps[\"-\"](p2), which calls \na second trap p2.unary(\"-\"), which in turn calls unaryOps[\"-\"](4), which .nally returns -4. Thus, the \nap\u00adparent circularity bottoms out at the end of the proxy chain, allowing proxies to compose conveniently. \nIn order for identityProxy to be transparent, we need to hide the difference between a proxy and its \nunderlying value. In particular, identityProxy overrides the equality operation, and so \"a\" = (identityProxy \n\"a\") evaluates to true. Similarly, the geti trap ensures that {\"a\":3}[identityProxy \"a\"] evaluates to \n3. The appendix includes a proof that the identity proxy for a value v correctly simulates the behavior \nof v (provided no code in the system uses the isProxy or unProxy re.ection primitives). Satisfying this \nproperty required several careful design choices in our language semantics for example, the equality \noperator always considers .-expressions to be dis\u00adtinct.  3.2 Lazy Evaluation Extension We next extend \nthe identity proxy to provide more inter\u00adesting functionality, namely lazy or delayed evaluation, as \nshown in .gure 4. The function delay takes as an argument a thunk f and returns a proxy that behaves \nlike the result of f, except that that result is computed lazily, when some strict operation invokes \na trap on that proxy. Speci.cally, the  Figure 5: Contract Extension 1 // Four contract constructors \n2 Flat c = .pred . 3 .x. assert (pred x); x 4 5 Functionc = .Domain,Range. 6 .x. assert (isFunction x) \n7 proxy {} { 8 call : .y. Range (x (Domain y)) 9 \u00b7\u00b7\u00b7 // as in identityProxy 10 } 11 12 Recordc = . \ncontracts . 13 .x. assert (isRecord x) 14 proxy {} { 15 getr : .n. contracts[n] (x[n]) 16 setr : .n,y. \nx[n] := (contracts[n] y) 17 \u00b7\u00b7\u00b7 // as in identityProxy 18 }19 20 Mapc = .Domain,Range. 21 .x. assert \n(isRecord x) 22 proxy {} { 23 getr : .n. Range (x[Domain n]) 24 setr : .n,y. x[Domain n] := Range y 25 \n\u00b7\u00b7\u00b7 // as in identityProxy 26 }27 28 // Some useful contracts 29 Bool = Flat c (.x. isBool x) 30 Num \n= Flat c (.x. isNum x) 31 Any = Flat c (.x. true) 32 Unit = Flat c (.x. x=unit) 33 Thunk = Unit . Any \n34 UnaryOp = Flat c (.x. { - :true , \u00b7\u00b7\u00b7 }[x]) 35 BinaryOp = Flat c (.x. { + :true , \u00b7\u00b7\u00b7 }[x]) 36 Proxy \n= Flat c (.x. isProxy x) function delay creates a mutable variable2 z containing a thunk that, when \ncalled, computes f() and stores the result\u00ading value, wrapped in a thunk, back into z. Thus, z() returns \nthe result of f while avoiding repeated computation. Each trap then calls z() to access the result of \nf. In this manner, the resulting proxy causes delayed values to be implicitly forced when needed; no \nexplicit force op\u00aderations are required in the source program and no built-in support for lazy evaluation \nis required in the language im\u00adplementation. 2 According to the desugaring of .gure 1, the letrec-bound \nvariable z is actually a record .eld and so is mutable.  3.3 Contract Extension A contract [6] is a \nfunction that mediates between two soft\u00adware components: the function s argument and the context that \nobserves the function s result. As long as these two com\u00adponents interact appropriately, the contract \nbehaves like the identity function; if either component engages in inappropri\u00adate interaction (for example, \npassing a string argument when an integer is expected), the intermediating contract detects the error \nand halts execution. Figure 5 shows how to implement contracts using prox\u00adies, and provides four contract \nconstructors. By convention, we use capitalized identi.ers to denote contracts, and use the subscript \nc to denote contract constructors that return con\u00adtracts. A .at contract has the form (Flatc pred). \nWhen ap\u00adplied to an argument x, this contract requires that x sat\u00adisfy the predicate pred.  A function \ncontract (Functionc Domain Range) re\u00adquires that its argument should be a function that is ap\u00adplied only \nto values satisfying the contract Domain and that returns only values satisfying Range.  We support \nboth homogeneous and heterogeneous record contracts. A homogeneous record contract or map has the form \n(Mapc Domain Range); a record r satis.es this contract if each string index s in the domain of r satis.es \nthe Domain contract, and the corresponding value r[s] satis.es Range. Domain should be a Flatc \u00adgenerated \ncontract that preserves identity, in order for record lookups to work correctly.  A heterogeneous record \ncontract has the form (Recordc contracts), where contracts is a record mapping record indices to contracts. \nA record r satis.es this con\u00adtract if for each string index s of r, the value r[s] satis\u00ad.es contracts[s]. \n Both kinds of record contracts are enforced in a lazy man\u00adner, on each access and update of the resulting \nproxy. We use the syntax Domain . Range and Domain . Range to abbreviate function and map contracts, \nrespectively. We adapt the module de.nition syntax from .gure 1 to support contracts on module bindings, \nand use this contract syntax to document our language extensions. def Domain . Range = Functionc Domain \nRange def Domain . Range = Mapc Domain Range '' private x :: C = e; y :: C = e def = let p = {}; let \nq = {}; p.x := .(Ce); ' q.y := .(Ce ' ); q (where . =[x := p.x, y := q.y])  Figure 6: Tainting Extension \n 1 private secret = {} 2 3 taint :: Any . Tainted = .x. 4 if (isTainted x) 5x 6 else 7 proxy secret \n{8 value : x 9 call : .y. taint (x y) 10 getr : .n. taint (x[n]) 11 geti : . r. taint(r[x]) 12 setr : \n.n,y. x[n] := taint (y) 13 seti : .r,y. r[x] := taint(y) 14 unary : .o. taint (unaryOps[o] x) 15 left \n: .o,r. taint(binOps[o] x r) 16 right : .o, l . taint (binOps[o] l x) 17 test : . .x 18 }19 20 isTainted \n:: Any . Bool = 21 .x. if (unProxy secret x) true false 22 23 untaint :: Any . Untainted = 24 .x. let \nh = unProxy secret x 25 if (h) h.value x 26 27 Tainted = Flat c (.x. (isTainted x) 28 Untainted = Flat \nc (.x. !(isTainted x)) 3.4 Tainting Extension Several languages, such as Perl, provide tainting as a \nbuilt\u00adin feature of the language implementation, which introduces additional complexity into the compiler/interpreter \nand run\u00adtime data representations. Proxies allow this complexity to be isolated into a small extension \nmodule, as shown in .gure 6. The function taint takes an argument x and returns a proxy that behaves \nmuch like x, in that all traps .rst perform the corresponding op\u00aderation on x but then taint the result. \nEach tainting proxy is marked with a secret that is kept private to the module, so that we can reliably \nidentify tainting proxies. A value is tainted if it is one of these tainting proxies and is untainted \notherwise. To untaint values (after they have been appro\u00adpriately sanitized), the handler record in the \ntainting proxy keeps the original value in the value .eld, so that it can be later returned by untaint. \nBased on these de.nitions, tainted values now propagate through all primitive operations of the language. \nFor exam\u00adple, 4 + (taint 5) evaluates to a tainted 9, that is, a taint\u00ading proxy whose underlying raw \nvalue is 9. Figure 8: Revokable Membranes 1 private secret = {} 2 3 private revoked :: Bool = false \n4 5 swap : : Any . Any = .x. 6 assert !revoked 7 if (( isNum x || isBool x || isString x) 8 &#38;&#38; \n!(isProxy x)) 9x 10 else 11 let h = unProxy secret x 12 if (h) 13 h . value 14 else 15 proxy secret \n{ 16 value: x 17 call : .y. swap (x (swap y)) 18 getr : .n. swap (x[swap n]) 19 geti : . r . swap ((swap \nr )[x]) 20 setr : .n,y. x[swap n] := swap y 21 seti : .r,y. (swap r)[x] := swap y 22 unary : .o. swap \n(unaryOps[o] x) 23 left : .o, r . swap (binOps[o] x (swap r )) 24 right : .o, l . swap (binOps[o] (swap \nl ) x) 25 test : . . if (x) true false 26 }27 28 revoke = . . (revoked := true) 3.5 Revokable Membranes \nFigure 8 describes how to implement revokable membranes, which provide unavoidable transitive interposition \nbetween two software components [17], which we call the dry and wet components. The two components can \ncommunicate via the membrane in a transparent manner, but cannot share true references (functions or \nrecords), only proxies to refer\u00adences. Consequently, once the membrane is revoked, no fur\u00adther communication \nis possible between the two components (unless of course there is a side channel for communication, for \nexample via a global mutable variable). The function swap passes a value x from one side of the membrane \nto the other (from dry to wet, or vice-versa). Constants are passed without being wrapped, as they cannot \ncontain references. Since proxies can masquerade as con\u00adstants, we also need to check that x is not a \nproxy. Note that isProxy is a special form and not a unary operator, and so it cannot be trapped; it \nalways reveals the true nature of a proxy, which is critical for reasoning about the security guar\u00adantees \nprovided by code such as membranes. In the case where x is not a constant, we next use unProxy to check \nif it is a membrane proxy p, in which case the value .eld of the handler record contains the orig\u00ad  \nFigure 7: Complex Number Extension 1 private secret = {} 2 3 private complexUnaryOps :: UnaryOp . Num \n. Num . Any = {4 \"-\" : .r , i . makeComplex (-r) (-i) 5 tostring : .r,i. (tostring r) + \"+\" + ( tostring \ni ) + \"i\" 6 \u00b7\u00b7\u00b7 7 } 8 9 private complexBinOps :: BinaryOp .Num .Num .Num .Num . Any = {10 \"+\" : . r1 \n,i 1 ,r2 ,i 2 . makeComplex ( r1+r2 ) (i 1+i 2 ) 11 \"=\" : . r1 ,i 1 ,r2 ,i 2 . (r1=r2 ) &#38;&#38; (i \n1=i 2 ) 12 \u00b7\u00b7\u00b7 13 } 14 15 makeComplex : : Num .Num . Complex = .r,i. 16 proxy secret {17 real :r 18 \nimg :i 19 unary : .o. complexUnaryOps[o] r i 20 left : .o,y. let h = unProxy secret y 21 if (h) 22 complexBinOps[o] \nr i h.real h.img 23 else 24 complexBinOps[o] r i y 0 25 right : .o,y. complexBinOps[o] y 0 r i 26 test \n: . . true // all Complex are non-false 27 }28 29 isComplex : : Any . Bool = .x. if (unProxy secret x) \ntrue false 30 31 i : : Complex = makeComplex 0 1 32 33 Complex = Flat c isComplex inal unwrapped value \nv, which is then returned. Essentially, passing v across the membrane produced proxy p, and pass\u00ading \np back through the membrane returns the original v. Otherwise, if x is not a membrane proxy, we create \na new proxy that performs the appropriate wrapping in its traps, and whose value .eld records the original \nvalue x. For example, if (swap dry-fn ) passes a function dry-fn from the dry to the wet component, yielding \na proxy wet-fn, then on any application (wet-fn wet-arg ), the call trap of wet-fn .rst passes wet-arg \nto the dry component (via swap) before feeding it as the argument into dry-fn, and .nally passes the \nresult of dry-fn back to the wet component (again, via swap). Note that we implement all traps, and not \njust the get, set, and call traps, to support situations where, for exam\u00adple, s might be a complex number \nproxy. That complex num\u00adber proxy would get wrapped in an additional membrane proxy, and so both extensions \ncompose nicely.  3.6 Additional Numeric Types An often-requested feature of a programming language is \nthe ability to introduce additional numeric types beyond what are provided in the language implementation, \nand to manip\u00adulate these additional types using traditional operator syntax. In many languages, this \nkind of extension is dif.cult. For example, Java provides Bignums, but only as a library with awkward \nmethod invocation syntax, and it does not provide rationals, complex numbers, or decimal .oating points. \nFigure 7 illustrates how to extend .proxy with an addi\u00adtional numeric type, namely complex numbers. The \nfunc\u00adtion makeComplex takes as input the two components of a complex number, and creates a proxy that \ndispatches unary and binary operations appropriately. For binary operations, the left trap .rst checks \nif the right argument y is a or\u00addinary number or a complex number. If y is complex, then we pass its \nreal and imaginary components (extracted from y s handler record h) to the appropriate function in the \n Figure 9: Dynamic Units of Measure Extension private secret = {} private makeQuantity :: String . \nInt . Quantity . Quantity = .u,i ,n. let h = unProxy secret n if (i =0) / / drop zero-ary unit n else \nif (h&#38;&#38;h.unit = u) // same unit , avoid duplicates makeQuantity u (h.index + i) h.value else \nif (h&#38;&#38;h.unit > u) // keep proxies ordered makeQuantity h.unit h.index (makeQuantity u i h.value) \nelse // add this unit to proxy chain proxy secret {unit :u // record the unit , index , and underlying \nvalue in the handler index : i value : n // no call , getr , geti , setr , seti traps unary : .o. unitUnaryOps[o] \nu i n left : .o, r . unitLeftOps [o] u i n r right : .o, l . unitRightOps[o] u i n l test : . .n // ignore \nunits in test } private unitUnaryOps :: UnaryOp . String . Int . Quantity . Any = {\"-\" : .u, i ,n. \nmakeQuantity u i (-n) tostring : .u, i ,n. ( tostring n) + \"\" +u+ \"^\" +i \u00b7\u00b7\u00b7 }private unitLeftOps :: \nBinaryOp . String . Int . Quantity . Any . Any = { \"+\" : .u, i ,n, r . makeQuantity u i (n + (dropUnit \nu i r )) \"*\" : .u, i ,n, r . makeQuantity u i (n * r) \"/\" : .u,i,n,r. makeQuantity u i (n / r) \"=\" : \n.u,i,n,r. n = (dropUnit u i r) \u00b7\u00b7\u00b7 }private unitRightOps :: BinaryOp . String . Int . Quantity . Any \n. Any = { // left arg never a proxy \"+\" : .u, i ,n, l . assert false // unit mismatch \"*\" : .u,i,n,l. \nmakeQuantity u i (l * n) \"/\" : .u, i ,n, l . makeQuantity u (-i)(l /n) \"=\" : .u,i,n,l. false // unit \nmismatch \u00b7\u00b7\u00b7 } private dropUnit :: String . Int . Quantity . Quantity = .u,i ,n. let h = unProxy secret \nn assert h!= false&#38;&#38;h.unit =u&#38;&#38;h.index =i h. value makeUnit :: String . Quantity = .u \n. makeQuantity u 1 1 Quantity = Flat c (.x. if (isNum x || unProxy secret x) true false)  complexBinOps \ntable. Otherwise we assume that y is a real number and pass 0 as the imaginary component to the complexBinOps \ntable function. The right trap is simpler, since its left argument is never complex. Our example implementation \nexports the variable i, from which client code can conveniently construct arbitrary com\u00adplex numbers, \nfor example 1.0 + (1.0 * i) Note that proxies are not a silver bullet for compositional\u00adity. In particular, \nproxies use a double dispatch protocol for overloading binary operators. Consequently, two indepen\u00addent \nproxy-based extensions, say Complex and Rational, may not be composable, since neither implementation \nknows how to add a complex and a rational number. Generic func\u00adtions, as in CLOS [15] and elsewhere, \nprovide more .exibil\u00adity but with some additional complexity.  3.7 Dynamic Units Of Measure Several \ntype systems (see for example, [13]) have been pro\u00adposed to track units of measure, such as meters or \nseconds, and to avoid the confusion of units that caused the Mars Cli\u00admate Orbiter mishap. We use the \nterm quantity to mean a .oating point number annotated with zero or more units of measure, each of which \nmay have an associated integer mul\u00adtiplicity or index (as in second-2). Thus, an example quan\u00adtity is \n9.81 meters second-2 . Proxies provide a convenient means to track units dynam\u00adically, as illustrated \nin .gure 93. Each quantity is represented as a chain of proxies, terminating in a .oating point num\u00adber. \nAs shown in lines 13 15, each proxy contains a unit of measure, an integer index, and an underlying value \n(the next proxy in the chain, or a .oating point number). The function makeQuantity creates these proxies, \nensuring that each proxy has a non-zero index, and that the proxy chain is kept in lexicographic ordering \nof units with at most one proxy for each unit (i.e., no duplicates). Unary and binary operators on a \nQuantity propagate down the proxy chain to the underlying numbers, provided the units are appropriately \ncompatible. In particular, \"+\" requires that its arguments have identical units by calling the function \n(dropUnit u i r), which ensures that the right argument r has the unit u with index i, and returns the \nunwrapped version of r. The units module then exports a binding makeUnit, which can be used by client \ncode to create desired units of measure, as in: 1 let meter = makeUnit \"meter\" 2 let second = makeUnit \n\"second\" 3 let g = 9.81 * meter / second / second 4g+1 // dynamic unit mismatch error 3 For simplicity, \nthis implementation does not support dimensions (such as mass), but only units of measure (such as kilograms). \nFigure 10: NonProxy Extension 1 private secret = {} 2 3 swap : : Any . Any = .x. 4 if (isProxy x) 5 \n// error if not our proxy 6 (unProxy secret x).value 7 else if (isNum x || isBool x || isString x) 8x \n9 else 10 proxy secret {11 value: x 12 call : .y. swap (x (swap y)) 13 getr : .n. swap (x[swap n]) 14 \ngeti : . r . swap ((swap r )[x]) 15 setr : .n,y. x[swap n] := swap y 16 seti : .r,y. (swap r)[x] := swap \ny 17 unary : .o. swap (unaryOps[o] x) 18 left : .o, r . swap (binOps[o] x (swap r )) 19 right : .o, \nl . swap (binOps[o] (swap l ) x) 20 test : . . if (x) true false 21 } 4. Discussion 4.1 Virtual Values, \nSecurity and Observable Behavior Proxies allow the implementation of additional kinds of val\u00adues, and \nso they increase the possible observable behaviors of values. For example, in the presence of proxies, \nx*x can return a negative number (e.g., when x is complex). Moreover, (a.x = a.x) could evaluate to false, \nboth be\u00adcause a is a proxy whose get trap returns different values, or because a.x is a proxy that de.nes \nunusual, non-re.ective behavior for its = operation. A larger space of value behaviors does make it harder \nto write defensive or security-critical code. In particular, secu\u00adrity checks that are correct under \nthe assumption that strings are immutable may fail when passed a proxy representing mutable strings. \nThere is some tension on how to limit the possible ob\u00adservable behaviors of proxies. A value consumer \nmight want strict limits on the behavior of values (including proxy val\u00adues), while a proxy creator might \nwant maximum .exibility to introduce novel kinds of proxy behaviors. Consequently, an important design \nchoice is what restrictions should be placed on proxy behaviors. For example, Javascript prox\u00adies [4] \ncannot override the identity operator, which therefore remains an equivalence operation. In .proxy, we \nchoose to permit proxies to exhibit very general behaviors, both for simplicity and to facilitate explo\u00adration \nof proxy-based language extensions. To address secu\u00adrity concerns, we provide an isProxy construct that \ncannot be trapped, which then allows value consumers to reliably identify proxies and to defend against \nunwanted proxy be\u00adhaviors.  One convenient way to protect code against unwanted proxy behavior is by \nusing the NonProxy extension shown in .gure 10. This extension is essentially a membrane, in that it \ncan sit between two modules and stop values such as functions or objects from being transmitted from \none mod\u00adule to the other, and instead sends a proxy in place of that value. The key difference is that \nthe NonProxy extension for\u00adbids any attempt to send a proxy across the non-proxy mem\u00adbrane, and so it \nprotects client code from values with strange, proxy-speci.c behavior. Thus, for example, the code frag\u00adment: \n 1 swap (identityProxy 4) is permitted under the revokable membrane of .gure 8 but not under the non-proxy \nmembrane of .gure 10.  4.2 Design Principles for Re.ective APIs Bracha and Ungar propose three design \nprinciples for re.ec\u00adtive APIs [2], namely encapsulation, strati.cation, and onto\u00adlogical correspondence. \nProxies satisfy the principle of encapsulation, since the proxy API does not expose details regarding \nthe underlying implementation of the language. Proxies also satisfy the principle of strati.cation, since \nthere is a clear distinction between base level values (both raw values and proxies), and meta-level \nvalues (the handler for a proxy value). In particular, there is no way for a user of a proxy value to \naccess the underlying handler. Evaluating (proxy a h)[\"unary\"] does not return the unary trap function \nof the handler a; instead it invokes a s get trap on the argument \"unary\". Finally, proxies satisfy the \nprinciple of ontological corre\u00adspondence, since each trap handler corresponds directly to a particular \noperation being performed by code on a (virtual) data value. 5. Implementation: Firefox and JavaScript \nIn order to evaluate our approach, we extended this design for virtual values to the Javascript programming \nlanguage and implemented the extended language within the Firefox browser. Our implementation leveraged \nthe recently devel\u00adoped Zaphod add-on [21] for Firefox, which is based on the Narcissus [25] meta-circular \nJavascript interpreter. Since JavaScript is a richer language than .proxy, this extension required the \nintroduction of the following additional traps: A has trap to determine if a proxy object has a given \n.eld.  A construct trap similar to call, but used when the proxy is called with the new keyword.  A \nkeys trap to de.ne a proxy value s behavior in a for/in loop.  We then implemented several of the language \nexten\u00adsion modules, including lazy evaluation, complex numbers, and units of measure. These implementations \nwere quite straightforward and helped to validate the utility of our de\u00adsign. Our modi.ed Narcissus implementation, \nthe proxy ex\u00adtension modules, and the proxy test code are all available online [1]. As an illustration, \n.gure 11 shows a web applica\u00adtion that uses the units of measurement extension. Performance. As a meta-circular \ninterpreter, Narcissus does not provide a good foundation for evaluating the perfor\u00admance overhead of \nproxies. However, we believe this over\u00adhead is likely to be quite small for the common case where traps \nare not invoked. In a dynamically typed language, the implementation of each primitive operation typically \nneeds to perform a tag check that identi.es the dynamic type of each argument value. Figure 12 contains \na code snippet from the SpiderMonkey Javascript interpreter for perform\u00ading unary minus. This code contains \na fast path for han\u00addling integer values, a second fast path for doubles, and then  Figure 12: Tag Checks \nin SpiderMonkey s Unary Minus 1 if (JSVAL IS INT( rval )&#38;&#38;(i=JSVAL TO INT(rval ))!=0) { 2 // \nFast path for ints 3 i= -i; 4 regs .sp[-1] = INT TO JSVAL(i); 5 } else if (JSVAL IS DOUBLE(rval)) { \n6 // Second fast path for doubles 7 \u00b7\u00b7\u00b7 8 } else { 9 \u00b7\u00b7\u00b7 // Slow path for handling implicit conversions \n 10 \u00b7\u00b7\u00b7 // Ideal spot for handling proxies 11 \u00b7\u00b7\u00b7 // Error handling 12 } a slow path for handling Javascript \ns various implicit con\u00adversions, error handling, etc. We expect that the slow path would be an ideal \nplace for incorporating proxy handling, without introducing any additional overhead on the common fast \npaths. Andreas Gal demonstrated that Javascript Catch-All Proxies introduce negligible overheads for \nthe common case where traps are not invoked [4, table 2], and he expects that the performance overhead \nfor virtual values would be comparably small. Of course, frequent trap invocations (e.g., for complex \nnumbers) could introduce signi.cant overhead, and might motivate the need for additional optimization \ntechniques. Trace-based compilation could provide highly optimized code paths that inline trap code into \nclient code within hot loops [9]. In our current design, a proxy needs a handler record with nine traps, \neach of which likely needs to close over the un\u00adderlying value. More ef.cient representations are possible. \nFor example, proxy ahv could represent a proxy for the value v, where the handler h is common to many \nproxies, and each trap is passed the underlying value v each time it is invoked. This alternative representation \nwould reduce the space required for each proxy from tens of words to perhaps four words: a header word \nplus slots for a, h, and v. Over\u00adall, it appears likely that proxies can be implemented fairly ef.ciently, \nparticular in dynamic languages. 6. Future Work The language extensions presented in Section 3 provide \nanecdotal evidence that virtual values provide a .exible and useful language extension mechanism. In \naddition, our ex\u00adperience suggest that virtual values are fairly straightforward to incorporate into \na language implementation, and that pro\u00adgramming in the extended language remains mostly intuitive and \nconvenient. The introduction of virtual values does signi.cantly change the semantics of the language, \nand suggests that fur\u00adther study of the observable equivalence relation and the denotational semantics \nof the language is required. In par\u00adticular, a full abstraction result [3] for .proxy would clarify the \nspace of behaviors that values (including proxy values) can exhibit, and so might be helpful in deciding \nhow to design proxy APIs that facilitate security and program veri\u00ad.cation, while still providing .exibility \nto enable interesting language extensions. More research is also needed on ef\u00ad.cient compilation and \noptimization techniques for virtual values. Virtual values are motivated by the rich proliferation of \nresearch on various kinds of wrappers and proxies, includ\u00ading higher-order contracts [5, 6], language \ninteroperation via proxies [12], and hybrid and gradual typing [7, 23] and space-ef.cient gradual typing \n[24]. We conjecture that vir\u00adtual values may allow some of this research to be performed by experimenting \nwithin a language with virtual values, rather than by designing new languages and implementa\u00adtions. Acknowledgements \nWe thank David Herman, Tom Van Cutsem, and Mark Miller for valuable comments on an ear\u00adlier draft of \nthis paper. This work was supported by NSF grants CNS-0905650 and CCF-1116883. References [1] T. H. Austin. \nProxy values implementation and examples. http://slang.soe.ucsc.edu/proxy-values, 2010. [2] G. Bracha \nand D. Ungar. Mirrors: design principles for meta\u00adlevel facilities of object-oriented programming languages. \nIn OOPSLA, pages 331 344, 2004. [3] R. Cartwright, P.-L. Curien, and M. Felleisen. Fully abstract semantics \nfor observably sequential languages. Inf. Comput., 111(2):297 401, 1994. [4] T. V. Cutsem and M. S. Miller. \nProxies: Design principles for robust object-oriented intercession APIs. In Dynamic Languages Symposium, \n2010. [5] R. B. Findler and M. Blume. Contracts as pairs of projec\u00adtions. In International Symposium \non Functional and Logic Programming, pages 226 241, 2006. [6] R. B. Findler and M. Felleisen. Contracts \nfor higher-order functions. In Proceedings of the International Conference on Functional Programming, \npages 48 59, 2002. [7] C. Flanagan. Hybrid type checking. In Symposium on Princi\u00adples of Programming \nLanguages, pages 245 256, 2006. [8] M. Flatt and PLT. Reference: Racket. Technical Report PLT-TR2010-1, \nPLT Inc., June 7, 2010. http://racket\u00adlang.org/tr1/. [9] A. Gal, B. Eich, M. Shaver, D. Anderson, B. \nKa\u00adplan, G. Hoare, D. Mandelin, B. Zbarsky, J. Orendorff, M. Bebenita, M. Chang, M. Franz, E. Smith, \nR. Reitmaier, and M. Haghighat. Trace-based just-in-time type specializa\u00adtion for dynamic languages. \nIn PLDI, 2009. [10] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns. Addison-Wesley, \nBoston, MA, 1995. [11] A. Goldberg and D. Robson. Smalltalk-80: the language and its implementation. \nAddison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 1983.  [12] K. E. Gray, R. B. Findler, \nand M. Flatt. Fine-grained inter\u00adoperability through mirrors and contracts. In OOPSLA, pages 231 245, \n2005. [13] A. Kennedy. Relational parametricity and units of measure. In Principles of Programming Languages, \npages 442 455, 1997. [14] G. Kiczales. Aspect-oriented programming. ACM Comput. Surv., page 154, 1996. \n[15] G. Kiczales, J. D. Rivieres, and D. G. Bobrow. The Art of the Metaobject Protocol. The MIT Press, \nJuly 1991. [16] L. A. Meyerovich, A. P. Felt, and M. S. Miller. Object views: Fine-grained sharing in \nbrowsers. In Proceedings of the WWW 2010, Raleigh NC, USA, 2010. [17] M. S. Miller. Robust Composition: \nTowards a Uni.ed Ap\u00adproach to Access Control and Concurrency Control. PhD thesis, Johns Hopkins University, \nBaltimore, Maryland, USA, May 2006. [18] M. S. Miller and T. V. Cutsem. Catch-all proxies. http:// wiki.ecmascript.org/doku.php?id=harmony:proxies. \n[19] M. S. Miller, E. D. Tribble, and J. Shapiro. Concurrency among strangers: Programming in E as plan \ncoordination. In In Trustworthy Global Computing, International Symposium, TGC 2005, pages 195 229. Springer, \n2005. [20] S. Mostinckx, T. V. Cutsem, S. Timbermont, E. G. Boix, \u00b4 E. Tanter, and W. D. Meuter. Mirror-based \nre.ection in Am\u00adbientTalk. Softw., Pract. Exper., 39(7):661 699, 2009. [21] Mozilla labs: Zaphod add-on \nfor the .refox browser. http://mozillalabs.com/zaphod, accessed October 2010. [22] Paul Hudak and Simon \nPeyton-Jones and Philip Wadler (eds.). Report on the programming language Haskell: A non-strict, purely \nfunctional language version 1.2. SIGPLAN Notices, 27(5), 1992. [23] J. Siek and W. Taha. Gradual typing \nfor objects. In European Conference on Object Oriented Programming, pages 2 27, 2007. [24] J. G. Siek \nand P. Wadler. Threesomes, with and without blame. In POPL, pages 365 376, 2010. [25] Wikipedia: Narcissus \nJavaScript engine. http://en.wiki\u00adpedia.org/wiki/ Narcissus (JavaScript engine), accessed October 2010. \nA. Correctness of the Identity Proxy In this appendix, we provide an illustrative proof that the identity \nproxy for a value v simulates the behavior of v, provided the code does not use the isProxy or unProxy \nprimitives. In other words, the isProxy and unProxy prim\u00aditives provide the only way to distinguish between \na value and an identity proxy for that value. (Correctness proofs for the other language extensions are \nsimilar but somewhat more involved.) To allow a more direct and cleaner proof, we rewrite the identity \nproxy as shown in .gure 13, and use HRv = {call : .y.v y,...} Figure 13: Revised Identity Extesion 1 \n.x . proxy {} { 2 call : .y. xy 3 getr : .n. x[n] 4 geti : . r. r[x] 5 setr : .n,y. x[n] := y 6 seti \n: .r,y. r[x] := y 7 unary : .o. { \"-\" : .x. -x 8 \"!\" : .x. !x / / negation 9 isBool : .x. isBool x 10 \n// etc for all unary ops 11 }[o] x 12 left : .o,r. { \"+\" : .x,y. x+y 13 \"=\" : .x,y. x=y 14 // etc for \nall binary ops 15 }[o] x r 16 right : .o,l. { \"+\" : .x,y. x+y 17 \"=\" : .x,y. x=y 18 // etc for all binary \nops 19 }[o] lx 20 test : . .x 21 } to denote the handler record from .gure 13 with x replaced by the \nclosed value v. Consider a value v where the heap maps an address a to the handler record HRv, and consider \na proxy value (proxy ca). Here, c is a heap address (the secret) that is irrelevant to the correctness \nargument. We need to show that proxy ca simulates v in any context C, that is, that C[proxy ca] simulates \nC[v]. For this purpose, we de.ne a simulation relation that relates the evaluations of C[v] and C[proxy \nca]. The evaluation of C[proxy ca] will execute additional proxy code that will allocate additional records \nin the heap. We refer to these proxy-allocated records (in\u00adcluding HRv) as meta-records, and use G to \nrefer to the meta portion of the heap. We .rst de.ne a simulation relation e1 ~G e2 on ex\u00adpressions (with \nrespect to a meta-heap G) as shown in .g\u00adure 14. The rule [S-PROXY] states that a value v is simulated \nby proxy ca provided G(a) is a handler record HRv! where v is in turn simulated by v '. The remaining \nrules essentially provide the compatible closure of the [S-PROXY] rule, with the exception that the isProxy \nand unProxy primitives are not permitted (since they would distinguish between a value and its identity \nproxy). Note that the relation e1 ~G e2 is not re.exive or symmetric. The simulation relation H1 ~G H2 \non heaps holds if H1 and H2 have the same domain and for all addresses a in this domain we have: dom(H1(a)) \n= dom(H2(a)) . w . dom(H1(a)).H1(a)(w) ~G H2(a)(w) Finally, the simulation relation (H1,e1) ~ (H2 I G, \ne2) relates a state (H1,e1) with another state (H2 I G, e2) with meta-records G, where the heaps and \nexpressions are appro\u00ad  Figure 14: Expression Simulation Relation e ~G e ' v ~G vG(a)= HRv! v ~G proxy \nca v is a variable, constant, or address v ~G v ' e ~G e .x. e ~G .x. e ' '' e1 ~G e1 e1 ~G e2 '' e1 \ne2 ~G e 1 e2 ''' e1 ~G ee2 ~G ee3 ~G e 123 ''' if e1 e2 e3 ~G if e1 e2 e 3 ' e ~G e ' uop e ~G uop e \n'' e1 ~G e1 e2 ~G e2 '' e1 bop e2 ~G e1 bop e 2 ' ' ev ef ~G ef ~G ev ' ' { ef : ev }~G { e : e } f v \n'' e1 ~G e1 e2 ~G e2 '' e1[e2] ~G e1[e2] ''' e1 ~G ee2 ~G ee3 ~G e 123 '' ' e1[e2] := e3 ~G e1[e2] := \ne 3 ''' e1 ~G ee2 ~G e 12 '' proxy e1 e2 ~G proxy e 1 e2 [S-PROXY] [S-ID] [S-FUN] [S-CALL] [S-IF] [S-UNARY] \n[S-BINARY] [S-ALLOC] [S-GET] [S-SET] [S-MK-PROXY] priately simulated with respect to the meta-records: \n(H1,e1) ~ (H2 I G, e2) i. e1 ~G e2 and H1 ~G H2 Here, H2 I G denotes the union of maps with disjoint \ndo\u00admains. The following lemma shows that this relation ~ is indeed a simulation relation. LEMMA 1. Suppose \nS1 ~ S2 and S1 . S ' . Then there 1exists S2 ' such that S2 .+ S2 ' and S1 ' ~ S2' . Proof: We have that \nS1 = H1,e1 ~ H2 I G, e2 = S2 where H1 ~G H2 and e1 ~G e2. The proof proceeds by induction and case analysis \non the derivation of S1 . S ' 1 and by a second induction on the derivation of e1 ~G e2. [CALL] In this \ncase S1 = H1, (.x. e) v . H1,e[x := v]= S ' 1 Also, S2 = fv ' where .x. e ~G f and v ~G v '. This case \nproceeds by subcase analysis on .x. e ~G f. ' [S-FUN] For f =(.x. e ' ) where e ~G e we have: ' S2 = \nH2 I G, (.x. e ' ) v . H2 I G, e ' [x := v ' ] [CALL] = S2 ' Thus S1 ' ~ S2' . [S-PROXY] For f =(proxy \nca) where G(a)= HRv!! '' and (.x. e) ~G v we have: ' S2 = H2 I G, (proxy ca) v ' . H2 I G, a.call v \n' . H2 I G, (.y. v '' y) v ' . H2 I G, v '' v S ''  = 2 '' ' [CALLPROXY] [GET] [CALL] Then (.x. e) \nv ~G vv by a smaller derivation, so by induction there exists S ' such that S '' .+ S ' and 2 22 S1 ' \n~ S2' . [ALLOC] In this case S1 = H1, { s : v }. H1[a := { s : v }],a = S ' 1 where a . dom(H1). Without \nloss of generality assume a . G. Then: ' S2 = H2 I G, { s : v ' } where v ~G v . H2[a := { s : v ' }] \nI G, a [ALLOC] = S2 ' Since we have H1[a := { s : v }] ~G H2[a := { s : v ' }] we also have S1 ' ~ S2' \n. [GET] In this case S ' S1 = H1,a[i] . H1,v = 1 where v = H1(a)(i). This case proceeds by subcase analysis \non a[i] ~G e2. For e2 = a[i] we have: S2 = H2 I G, a[i] . H2 I G, v ' [GET] = S2 ' ' where v = H1(a)(i) \n~G H2(a)(i)= v .  For e2 =(proxy cb)[v ' ] where G(b)= HRw and ' a ~G w and i ~G v we have: S2 = H2 \nI G, (proxy cb)[v ' ] ' . H2 I G, b.getr v [GETRPROXY] ' . H2 I G, (.n. w[n]) v [GET] . H2 I G, w[v \n' ] [CALL] S ''  = 2 S '' We have S1 ~ by a smaller derivation, so by 2 induction there exists S ' such \nthat S '' .+ S ' and 2 22 S1 ' ~ S2' . For e2 = a[(proxy cb)] where G(b)= HRw and i ~G w we have: S2 \n= H2 I G, a[(proxy cb)] . H2 I G, b.geti a [GETIPROXY] . H2 I G, (.q. q[w]) a [GET] . H2 I G, a[w] \n[CALL] S ''  = 2 S '' We have S1 ~ by a smaller derivation, so by 2 induction there exists S ' such \nthat S '' .+ S ' and 2 22 S1 ' ~ S ' 2. [SET] In this case ' S1 = H1,a[i]= v . H1,v = S ' 1 ' where H \n= H1[a := H1(a)[i := v]]. We proceed by 1 subcase analysis on (a[i]= v) ~G e2. ' For e2 =(a[i]= v ' ) \nwhere v ~G v we have: ' S2 = H2 I G, a[i]= v ' . H2 I G, v ' [SET] = S ' 2 ' ' where H = H2[a := H2(a)[i \n:= v ' ]]. Since v ~G v 2 '' we have H1 ~G H and S1 ' ~ S2' . 2 ' For e2 = ((proxy cb)[w ' ]= v ' ) where \nv ~G v and ' G(b)= HRw and a ~G w and i ~G w we have: ' S2 = H2 I G, (proxy cb)[w ' ]= v '' . H2 I G, \n(b.setr wv ' ); v [SETRPROXY] '' ' . H2 I G, (.n, y. w[n]= y) wv ; v [SET] '' . H2 I G, w[w ' ]= v ; \nv [CALL] S '' = 2 ' where H = H2[a := H2(a)[w := v ' ]]. We have 2 S '' S1 ~ 2 by a smaller derivation, \nso by induction there exists S ' such that S '' .+ S ' and S1 ' ~ S2' . 2 22 For e2 =(a[(proxy cb)] = \nv ' ) where G(b)= HRw ' and v ~G v and i ~G w we have: ' S2 = H2 I G, a[proxy cb]= v ' . H2 I G, (b.seti \nav ' ); v [SETIPROXY] '' . H2 I G, (.r, y. r[w]= y) av ; v [SET] '' . H2 I G, a[w] := v ; v [CALL] S \n'' = 2 ' where H = H2[a := H2(a)[w := v ' ]]. We have 2 S '' ~ by a smaller derivation, so by induction \nS12 there exists S ' such that S '' .+ S ' and S1 ' ~ S2' . 2 22 [S-UNARY] In this case S1 = H1, uop \nr . H1,d(uop,r)= S ' 1 This case proceeds by subcase analysis on uop r ~G e2. '' For e2 = uop r where \nr ~G r we have: ' S2 = H2 I G, uop r . H2 I G, d(uop,r ' ) [UNARYOP] S ' = 2 Thus S1 ' ~ S2' . For e2 \n= uop (proxy ca) where G(a)= HRv,r ~g v we have: S2 = H2 I G, uop (proxy ca) . H2 I G, a.unary \"uop\" \n[UNARYPROXY] .+ H2 I G ' , uop vG ' . G S '' = 2 S '' We have S1 ~ by a smaller derivation, so by 2 induction \nthere exists S ' such that S '' .+ S ' and 2 22 S1 ' ~ S ' 2. [S-BINARY] In this case S1 = H1,r1 bop \nr2 . H1,d(bop,r1,r2)= S ' 1 This case proceeds by a subcase analysis on the deriva\u00adtion of (r1 bop r2) \n~G e2. '' '' For e2 =(r bop r2) where r1 ~G r and r2 ~G r 1 12 we have: ' S2 = H2 I G, r ' bop r 12 ' \n' . H2 I G, d(bop,r 1,r 2) [BINARYOP] = S2 ' Thus S1 ' ~ S2' . ' For e2 = ((proxy ca) bop r2) where G(a)= \nHRv ' and r1 ~G v and r2 ~G r we have: 2 ' S2 = H2 I G, (proxy ca) bop r2 ' . H2 I G, a.left r [LEFTPROXY] \n2 ' .+ H2 I G ' ,v bop rG ' . G 2 S '' = 2 S '' We have S1 ~ by a smaller derivation, so by 2 induction \nthere exists S ' such that S '' .+ S ' and 2 22 S1 ' ~ S2' . ' For e2 = r bop (proxy ca) where G(a)= \nHRv and 1 ' r1 ~G r and r2 ~G v we have: 1 S2 = H2 I G, r 1 ' bop (proxy ca) ' . H2 I G, a.right r [LEFTPROXY] \n1 .+ ' G ' H2 I G ' ,r bop v . G 1 S '' = 2  S '' We have S1 ~ by a smaller derivation, so by 2 induction \nthere exists S ' such that S '' .+ S ' and 2 22 S1 ' ~ S2' . [IFTRUE] In this case = H1, if re1 e2 . \nH1,e1 = S ' S11 where r = true. This case proceeds by subcase analysis on (if re1 e2) ~G e3. '' '' For \ne3 =(if re 2) where e1 ~G e and e2 ~G e 1 e 12 we have: '' = H2 I G, if re S21 e2 . H2 I G, e ' [IFTRUE] \n1 = S2 ' Thus S1 ' ~ S2' . '' For e3 =(if (proxy ca) e1 e2) where G(a)= HRv '' and r ~G v and e1 ~G \ne and e2 ~G e we have: 12 '' S2 = H2 I G, if (proxy ca) e1 e 2 '' . H2 I G, if (a.test()) e [TESTPROXY] \n1 e2 '' .+ H2 I G, if ve 1 e [GET], [CALL] 2 S '' = 2 By induction there exists S ' such that S '' .+ \nS ' and 2 22 S1 ' ~ S ' 2. [IFFALSE] Similar to the previous case.  [ISPROXY],[NOTPROXY],[UNPROXY],[UNPROXYFALSE] \nThe simulation relation does not permit the isProxy or unProxy primitives in e1.  [CONTEXT] In this \ncase  '' S1 = H1,E1[e1] . H1,E1[e1]= S1 ' '' where H1,e1 . H1,e 1. We extend the ~G relation from expressions \nto evaluation contexts in a compatible manner. In order to have S1 ~ S2 we must have S2 = H2 I G, e3 \nwhere H1 ~G H2 and E1[e1] ~G e3. So .E2,e2 such that E2[e2]= e3 and E1 ~G E2 and e1 ~G e2. Since H1,e1 \n~ H2 I G, e2 '' H1,e1 . H1,e 1 '' by induction there exists H2,e such that 2 ' H2 I G, e2 . H2 I G, e \n' 2 '' ' H1,e ~ H2 I G, e ' 12 By the [CONTEXT] rule we have '' S2 = H2 I G, E2[e2] . H2 I G, E2[e2]= \nS2 ' and S1 ' ~ S2' .    \n\t\t\t", "proc_id": "2048066", "abstract": "<p>This paper focuses on extensibility, the ability of a programmer using a particular language to extend the expressiveness of that language. This paper explores how to provide an interesting notion of extensibility by virtualizing the interface between code and data. A virtual value is a special value that supports behavioral intercession. When a primitive operation is applied to a virtual value, it invokes a trap on that virtual value. A virtual value contains multiple traps, each of which is a user-defined function that describes how that operation should behave on that value. This paper formalizes the semantics of virtual values, and shows how they enable the definition of a variety of language extensions, including additional numeric types; delayed evaluation; taint tracking; contracts; revokable membranes; and units of measure. We report on our experience implementing virtual values for Javascript within an extension for the Firefox browser.</p>", "authors": [{"name": "Thomas H. Austin", "author_profile_id": "81435602959", "affiliation": "University of California, Santa Cruz, Santa Cruz, CA, USA", "person_id": "P2839298", "email_address": "taustin@ucsc.edu", "orcid_id": ""}, {"name": "Tim Disney", "author_profile_id": "81488668581", "affiliation": "University of California, Santa Cruz, Santa Cruz, CA, USA", "person_id": "P2839299", "email_address": "tdisney@ucsc.edu", "orcid_id": ""}, {"name": "Cormac Flanagan", "author_profile_id": "81100538763", "affiliation": "University of California, Santa Cruz, Santa Cruz, CA, USA", "person_id": "P2839300", "email_address": "cormac@ucsc.edu", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048136", "year": "2011", "article_id": "2048136", "conference": "OOPSLA", "title": "Virtual values for language extension", "url": "http://dl.acm.org/citation.cfm?id=2048136"}