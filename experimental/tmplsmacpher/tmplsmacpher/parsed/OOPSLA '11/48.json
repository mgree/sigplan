{"article_publication_date": "10-22-2011", "fulltext": "\n Safe and Atomic Run-time Code Evolution for Java and its Application to Dynamic AOP * Thomas W\u00a8urthinger* \nDanilo Ansaloni Walter Binder Christian Wimmer\u00a7 Hanspeter M\u00a8ossenb\u00a8ock* * \u00a7 Johannes Kepler University \nLinz, Austria University of Lugano, Switzerland University of California, Irvine wuerthinger@ssw.jku.at \ndanilo.ansaloni@usi.ch walter.binder@usi.ch cwimmer@uci.edu Abstract Dynamic updates to running programs \nimprove development productivity and reduce downtime of long-running applica\u00adtions. This feature is however \nseverely limited in current vir\u00adtual machines for object-oriented languages. In particular, changes to \nclasses often apply only to methods invoked after a class change, but not to active methods on the call \nstack of threads. Additionally, adding and removing methods as well as .elds is often not supported. \nWe present a novel programming model for safe and atomic code updates of Java programs that also updates \nmethods that are currently executed. We introduce safe up\u00addate regions and pause threads only there before \nan update. We automatically convert the stack frames to suit the new versions of the methods. Our implementation \nis based on a production-quality Java virtual machine. Additionally, we present SafeWeave, a dynamic \naspect\u00adoriented programming system that exposes the atomic code updates through a high-level programming \nmodel. AspectJ advice can be added to and removed from a running ap\u00adplication. Changes are atomic and \ncorrectness is guaranteed even though weaving happens in parallel to program execu\u00adtion, and the system \nfully supports the dynamic class load\u00ading of Java. We show that the enhanced evolution features do not \nincur any performance penalty before and after version changes. Categories and Subject Descriptors D.3.4 \n[Programming Languages]: Processors Run-time environments * This work was supported by Oracle. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 11, October \n22 27, 2011, Portland, Oregon, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. . . $10.00 \n moessenboeck@ssw.jku.at General Terms Algorithms, Languages, Performance Keywords Java, virtual machine, \nrun-time evolution, code evolution, dynamic software updating, update regions, dy\u00adnamic aspect-oriented \nprogramming, AOP, AspectJ 1. Introduction Run-time code evolution allows to change the semantics of \na running program. The program is temporarily suspended, parts are replaced with new code, and then the \nexecution continues with the new version of the program. Such code updates are useful for several use \ncases: During development and debugging, it speeds up the process when large applica\u00adtions do not have \nto be restarted after small bug .xes. For long running servers, it reduces the downtime when an ap\u00adplication \nis migrated to a new version. It is also relevant for aspect-oriented programming (AOP). AOP assembles \nthe .nal executed code by weaving a base program with several aspects. While most current AOP tools perform \nthe weaving at compile time or at load time, i.e., before the actual program execution starts, there \nare sev\u00aderal dynamic AOP tools that perform aspect weaving at run time. Run-time code evolution can provide \nthe underlying infrastructure for such tools. Using a virtual machine (VM) to execute programs helps \nsolving the challenges of code evolution. The VM increases the possibilities for dynamic code evolution \nbecause of the additional abstraction layer between the executing program and the hardware. The main \ntasks of this intermediate layer are automatic memory management, dynamic class loading, and code veri.cation. \nThe algorithms for code evolution presented in this paper make heavy use of the existing VM infrastructure. \nIn current Java VMs, dynamic changes are known as hotswapping and they are restricted to swapping method \nbodies only. However, in object-oriented languages, class member declarations and subtype relationships \nare impor\u00adtant parts of a program s behavior. A complete dynamic code update also has to include object \nlayout changes and changes to the semantics of method calls due to a new class hierar\u00adchy. The enhancement \nof hotswapping to allow additional kinds of dynamic changes is therefore a high priority for many Java \ndevelopers.  For the use case of debugging, it is desirable that code evolution is unrestricted so that \narbitrary code changes can be applied to a running application. However, this also allows binary incompatible \nchanges, i.e., changes that break existing code. For example, when a currently running method is deleted, \nthe most reasonable solution is to keep this method running. This can however lead to unexpected program \nexceptions. The worst case scenario is that the de\u00adveloper needs to restart the application. For use \ncases such as updating of long running servers or dynamic AOP, the restart of an application is not an \noption. It is necessary to de.ne a subset of update features that avoids spurious exceptions and application \ncrashes. Additionally, the update has to be delayed until no method is executing code that could cause \nupdate problems. This paper de.nes the necessary preconditions for such safe updates and presents an \nalgorithm for atomic updates between program versions. Then, we describe an implemen\u00adtation that is based \non the Java HotSpotTM VM. The source code and binaries of our VM are available for download [16]. To \ndemonstrate that our model of safe update regions is use\u00adful and not too restrictive, we present a dynamic \nAOP tool that performs dynamic aspect weaving via run-time code evolution. In summary, this paper contributes \nthe following: We present a programming model that allows dynamic switching between a base program and \nan extended pro\u00adgram containing additional bytecode instructions and class member de.nitions.  We describe \nsuf.cient conditions for safely switching back to the base program and furthermore present a model for \nchanges between two extended programs.  We ensure that the version switches are also performed on currently \nrunning methods, i.e., methods with frames on the stack.  We guarantee that version switches are atomic. \nAfter an update, the old code version is not executed by any thread.  We describe the implementation \nof our model in a production-quality Java VM and show that there is no performance loss before and after \nversion switches.  We utilize our VM in a dynamic AOP tool that uses AspectJ.  The rest of this paper \nis organized as follows: Section 2 introduces our prior work on enabling enhanced class redef\u00adinition \nin a production-quality VM. It also shows the limi\u00adtations of our prior work and motivates the work presented \nin this paper. Section 3 introduces our programming model for .ne-grained safe updates. We classify possible \nchanges to Java programs in terms of the level of update safety. Sec\u00adtion 4 describes the implementation \nof our approach in the Java HotSpotTM VM. Section 5 presents a dynamic aspect\u00adoriented programming tool \nthat uses the enhanced VM fea\u00adtures. Section 6 evaluates the performance of our tools. We report the \ntime necessary for performing a dynamic update and show that there is no performance penalty before and \naf\u00adter the change. Related work is discussed in Section 7, and Section 8 concludes the paper.  2. The \nDynamic Code Evolution VM Our prior work on dynamic code evolution for Java is pre\u00adsented in [44]. We \nmodi.ed the Java HotSpotTM VM to sup\u00adport unlimited class rede.nition capabilities and created the Dynamic \nCode Evolution VM (DCE VM). This section de\u00adscribes the DCE VM and explains our motivations for adding \nsupport for atomic run-time code evolution at the bytecodes level. 2.1 Architecture and Features Dynamic \nclass rede.nition replaces a set of loaded classes with new versions. The current product version of \nthe Java HotSpotTM VM allows such changes as long as only the bod\u00adies of methods are affected. Our DCE \nVM allows changes to class member de.nitions, i.e., adding and removing meth\u00adods and .elds. Additionally, \nit allows changes to the class hierarchy such as changing the super class or the set of im\u00adplemented \ninterfaces. The Java Platform Debugger Architecture [27] command for rede.ning classes initiates the \nupdate. It triggers the replacement of classes with new de.nitions, and the VM then compares the new \nand old class de.nitions to .nd out about the actual changes. For example, the VM considers a .eld equal \nin two versions of a class if both name and signature of the .eld are the same. The VM searches for subclasses \nof rede.ned classes as they can be affected by the change. This is necessary be\u00adcause a .eld added to \na superclass also changes the instance format of a subclass. After parsing and linking the new class \nde.nitions, the algorithm pauses all Java threads at safe\u00adpoints. A safepoint is a program counter position \nat which a thread knows which machine locations, i.e., registers and stack slots, contain pointers. Running \nJava threads are for example stopped at the next safepoint position when the garbage collector needs \nto run. A safepoint is always reached by every thread in a .nite time span. We use this mechanism to \nperform the class rede.nition as an atomic operation. Our algorithm scans the heap in order to update \npointers to the old class version to become pointers to the new class version. A modi.ed mark-and-compact \ngarbage collection run increases the instance sizes in case of added .elds. All instances are immediately \nupdated to the new class versions. However, modi.ed methods that are active on the stack at the time \nof rede.nition continue in the old version of their bytecodes. It is only guaranteed that subsequent \ncalls to methods target the latest version of a method.  2.2 Limitations and Motivation for Improvement \nThe base design of the Dynamic Code Evolution VM is suit\u00adable for being used during application development \nand de\u00adbugging. A key feature is that it is unrestricted, with the downside to allow for a possible failure \nin continued exe\u00adcution. The continued execution of an old method can lead to invocations of old deleted \nmethods or to accesses of old deleted .elds. When the code evolution is used to speed up the development \nprocess by reducing the number of neces\u00adsary program restarts, this is acceptable. The worst case sce\u00adnario \nis that the programmer has to restart the application un\u00adder development, which would anyway be necessary \nwithout the enhanced VM. The requirements when updating long\u00adrunning server applications or performing \ndynamic aspect\u00adoriented programming are however signi.cantly higher re\u00adgarding stability and correctness \nof class updates. Changes to Java programs that can impair the correctness of currently loaded bytecodes \nare called binary incompatible changes. Such changes may lead to runtime exceptions or even crash the \nVM when the old bytecodes continue to execute. In particular, we distinguish two kinds of binary incompatible \nchanges: Deleting Class Members. A method or .eld that is deleted in the new version of the program may \nstill be ac\u00adcessed from bytecodes of old methods. In such a case, our VM throws a NoSuchFieldError or \na NoSuchMethodError, respectively. Type Narrowing. When the subtype relationship between two types A \nand B is no longer valid in the new version of the program, type safety may be compromised. It can no \nlonger be guaranteed that the dynamic type of a .eld or local variable is a subtype of its static type. \nThis can lead to a crash of the VM. In order to safely use our enhanced VM in a wide range of application \nareas, we add safe update regions as a novel feature. The extended DCE VM guarantees that the version \nchange is performed immediately if all threads are in safe update regions. Thus, old code is never executed \nafter a successful class update. Type narrowing changes are only allowed under speci.c circumstances \nas described in the following section. Our model guarantees that not only the update of the instances \nto new classes is atomic, but also that the update of methods to their new versions is an atomic operation. \nIf there are no restrictions on the update point, it can be dif.cult for programmers to design updates \nin a way that ensures semantic correctness. The update needs to be correct for every possible current \nstate and current execution position of the program threads. If the program may only be updated at limited \npoints, the update may be however delayed or impossible, e.g., if there is an in.nite loop. In the following \nsection, we de.ne a programming model that restricts the possible update regions, while keeping the time \nfor reaching an update region low.  3. Atomic Run-time Code Evolution The class rede.nition techniques \nof the base DCE VM de.ne changes between two program versions at the level of .elds, methods, and supertypes. \nIn this section, we take this one step further by looking at the detailed differences between two methods \nat the bytecode level. In particular, we outline a new solution for the problem of changing Java methods \nthat are active on the stack at the time of rede.nition. This is especially helpful for updating methods \nwith long-running or in.nite loops, e.g., the message receiving loop of a server application. We de.ne \na programming model that allows us to switch between two arbitrary program versions in three steps: First, \nwe describe how to switch from a base program to an ex\u00adtended program (see Section 3.1). Then we explain \nhow we can switch back safely (see Section 3.2). This switch safely removes .elds and methods that were \nadded by the extended program. Finally, we show how the model can be general\u00adized to switch between two \narbitrary programs by extracting their common base program (see Section 3.3). Our programming model describes \nconditions and rules for the speci.cation of the extended programs, but the VM does not provide an algorithm \nfor automatically deriving the speci.cation from the differences between two programs. Section 4 shows \nhow the speci.cation of the extended pro\u00adgram is added to Java class .les. The following sections describe \ndetailed rules at the Java bytecode level that restrict the possible changes to a pro\u00adgram. They serve \nthree high-level goals: Guarantee that continued execution after an atomic ver\u00adsion change is always \nvalid with respect to the Java vir\u00adtual machine speci.cation [20].  Restrict the complexity of a change \nfrom the base to the extended program in such a way that reasoning about its semantics is simpli.ed. \n Guarantee safe and correct base program execution after a change from the extended program back to \nthe base program. This property is especially important for the correctness of changes between two arbitrary \nprogram versions using a common base program de.nition.  3.1 Switching to the Extended Program The \nextended program must be derived from the base pro\u00adgram by adding .elds and methods, but not removing \nthem. The extended program must not change the type hierarchy of base program classes, but it may load \nnew classes. The bytecodes of previously existing methods may be modi.ed, with some restrictions that \nare explained in this section.  Base Program Extended Program class Receiver { void recv(BufferedReader \nin) { 1 2 3 class Receiver { void recv(BufferedReader in) { private int count; while(true) { 4 while(true) \n{ String s = in.readLine(); 5 6 String s = in.readLine(); count++; if (s.length() == 0) break; } } } \n7 8 9 10 11 12 if (s.length() == 0) break; } } } System.out.println(count); Figure 1. A base program \nthat reads lines of text and an extended program that additionally counts the number of lines. The left \npart of Figure 1 shows an example base program implementing a receiver loop that reads text lines from \nan input stream. The loop is exited when an empty line is read. The right hand side shows a possible \nextension of the base program that counts and prints the number of received text lines. It adds a .eld \ncount to the class and increases its value in the loop. Additionally, it adds a println statement. The \nbase version of the DCE VM can correctly per\u00adform the class rede.nition of the Receiver class from the \nbase version to the extended version. The newly introduced count .eld is initialized to 0 and the bytecodes \nof the recv method are updated. However, currently running activations of the recv method are unaffected \nand continue to execute the bytecodes of the base version. We extended the DCE VM with the ability to \nswitch atomically from the base program to an extended program at any time. The switch is performed instantaneously. \nIf a mod\u00adi.ed method is currently active on the stack, the program counter immediately switches to the \nequivalent position in the new version of the method. Thus, currently executing re\u00adceiver loops are immediately \naffected by the change in our example program. They start printing the number of received text lines \nsince the rede.nition. For every position in the base program, the VM must know the corresponding position \nin the extended program that should be used for continued program execution after the rede.nition. This \nis necessary because all threads exe\u00adcuting a base method at the time of rede.nition immediately change \nto executing the new extended version of the method. Therefore, the bytecodes of a method in the base \nprogram must not be changed in arbitrary ways. In particular, the ex\u00adtended program must be derived from \nthe base program by only adding new bytecodes to the base program. We de.ne a bytecode region in the \nbase program that matches a code region in the extended program as a base code region.In the example \nof Figure 1, lines 4 to 5 and lines 8 to 10 form base code regions. Newly introduced code is contained \nin extended code regions, e.g., lines 6 to 7 in the example. 3.1.1 Class De.nition Changes The extended \nprogram may add class members to the base program. Also, the extended program can refer to new classes \nthat are not used in the base program. Changing the signature of a .eld or method is prohibited. The \nsame ap\u00adplies to changes to the modi.ers static, synchronized, and native.An abstract base method can \nbe replaced with a concrete implementation in the extended version, but not vice versa. The extended \nprogram must not override a non-abstract base method. Overriding a method changes the semantics of the \ndynamic dispatch at the call site. At the time of the ver\u00adsion change, the program could currently execute \na method that was invoked due to a dynamic dispatch in the base pro\u00adgram, while the same dynamic dispatch \nin the extended pro\u00adgram would have led to the execution of a new method. This would invalidate our claim \nof an atomic version change. The only allowed change to the class hierarchy is to add an in\u00adterface to \na class. Changing the superclass of a class is also prohibited, because it could result in new overridden \nmeth\u00adods.  3.1.2 Method Body Changes When the bytecodes of a method are different in the base program \nand the extended program, we distinguish between the base method and the extended method.We de.ne the \nmodi.cations to the Java bytecodes of the base method that are allowed when forming the extended method \nas follows: Constant Pool References: A bytecode of the base pro\u00adgram may be modi.ed to contain a different \nconstant pool index as long as the referenced constant pool entry rep\u00adresents the same constant. The \nold and new bytecode are then said to be equivalent modulo constant pool [10]. Extended Code Regions: \nAn extended code region is a se\u00adquence of n bytecodes that is used to extend the base program. It can \nbe inserted before any bytecode of the base program with some index i. In the Java bytecodes of the base \nprogram, every reference to a bytecode with an index greater than i must be adjusted by adding n. For \nreferences to i, the adjustment by n is optional. Such references are, e.g., branch targets and exception \nhandler ranges. The adjustment of branch targets of the base pro\u00adgram guarantees that the new extended \ncode region can only be entered at its .rst bytecode.  In order to avoid semantic problems when an extended \nprogram causes parts of the base program to be skipped, we furthermore de.ne the following restrictions \non control .ow modi.cations: Branches: Branch instructions in extended code regions must always target \nbytecodes in the same code region. Therefore, an extended code region cannot be exited with a branch \ninstruction. Return: The extended code sections may contain a return instruction. This is the only way \nhow parts of the base program can be skipped. Exception Handlers: An extended code region must catch \nany exception that it throws. It is allowed to add excep\u00adtion table entries that cover a range within \nan extended code region. The exception handler block must however be within the same code region. Exception \nInterception: An extended code region may in\u00adtercept an exception thrown by a base program bytecode. \nHowever, it must re-throw the same exception again. Fig\u00adure 2 shows such a case. The try statement itself \ndoes not produce a bytecode, therefore the extended code sec\u00adtion that intercepts the exception is continuous \nto the base code section at the bytecode level. With the above constraints, the VM can match every bytecode \nposition in the base method to a corresponding bytecode position in the extended method. The extended \ncode regions and the base code regions are using the same stack frame. We restrict the way it can be \nmodi.ed by the extended code regions in the following way: Operand Stack: The operand stack height upon \nexit of an extended code region must be the same as the operand stack height at the entry of the region. \nAdditionally, all values on the stack at the entry of an extended code region must remain unmodi.ed. \nLocal Variables: The extended code region may introduce new local variables and also read from and write \nto all local variables of the base program. The Java veri.er ensures that the bytecode accesses to local \nvariables are consistent with their types. If a local variable is only modi.ed by either the base program \nor the extended program, then independent veri.cation of both program versions is suf.cient. Otherwise \ncross veri.cation of the two method versions is necessary, as explained in the next section. Base Method \nIntermediate Extended Method iconst_1 1 iconst_1 1 iconst_1 istore_1 2 3 istore_1 2 3 istore_1 fconst_1 \niconst_0 4 5 6 iconst_0 fload_1 4 5 6 iconst_0 fstore_1 fload_1 return 7 8 return fstore_2 7 8 return \nfstore_2 Figure 3. Example where cross veri.cation detects an ille\u00adgal intermediate version.  3.1.3 \nCross Veri.cation As the version change can happen at any bytecode position of the base program, the \nextended code regions cannot as\u00adsume that any other extended code region was executed be\u00adfore them. Therefore, \nan extended code region must not rely on the initialization of local variables in other extended code \nregions. Figure 3 shows an example of a base method and an ex\u00adtended method that both verify correctly, \nbut the version change would still be invalid. At line 6, the local variable with index 1 is of type \nfloat in the extended program. This is necessary, because the extended program performs a fload 1 instruction \nat this line. If the version change hap\u00adpens at line 5, the type of the local variable would however \nbe int (set by the execution of istore 1 in the base pro\u00adgram). The bytecodes in the middle of the .gure \nshow the executed bytecodes sequence for this case. In order to prevent this problem, the veri.er must \nperform a cross veri.cation of the two programs, if the extended and the base code regions write to the \nsame local variable. It in\u00adfers the possible types of local variables in the base program after every \nbytecode that is followed by an extended code re\u00adgion, i.e., the bytecodes at line 2 and 5 in Figure \n3. For each of these lines, it starts a modi.ed veri.cation pass of the ex\u00adtended program: It sets the \ntypes of the local variables to those inferred during the base program veri.cation and then performs \na veri.cation beginning at the corresponding ex\u00adtended code region, i.e., the regions starting at line \n3 and 6. This makes sure that the bytecode sequence shown in the center of Figure 3 is also subject to \nveri.cation, and thus the change is rejected.  3.1.4 Transformer Methods Fields added in the extended \nversion of the program are by default initialized with 0, false,or null.However, an extended program \ncan require other initialization values for its .elds. Figure 4 shows such an extended program. The buffer \n.eld is initialized in the constructor of the Receiver class to a new StringBuilder object. At the time \nof the version change, there are already Receiver objects on the heap. For such objects, the VM offers \nthe   Base Program Extended Program try { foo(); 1 2 3 4 try { foo(); try { } 5 catch(Throwable t) \n{ 6 System.out.println(\"intercepted\"); 7 throw t; } 8 9 } } catch(Throwable t) { 10 catch(Throwable t) \n{ System.out.println(\"handled\"); 11 System.out.println(\"handled\"); } 12 } Figure 2. An extended code \nregion that intercepts an exception that is thrown by a base code region. possibility to specify transformer \nmethods that manually convert between the old version and the new version of the object. For every class, \nthe programmer can write a transformer method with no parameters, a void return type, and the name $transformer. \nThis method is then called for every instance of that class that exists on the Java heap. The example \ntransformer method initializes the buffer variable to an empty StringBuilder object. The two extended \ncode regions in the method recv of Figure 4 both require that the value of buffer is properly initialized. \nTherefore, it would not be possible to model it as a local variable in the extended program that does \nnot exist in the base program. By de.ning buffer as a .eld, it is possible to write an adequate transformer \nmethod that initializes its value. For the initialization of static .elds, it is also possible to specify \na method called $staticTransformer in the extended program version. Static transformers are always executed \nbefore instance transformers. All transformers are guaranteed to be executed before any extended code \nregion is entered.  3.2 Changing Back to the Base Program When converting back from the extended program \nto the base program, the VM removes .elds and methods that are only de.ned in the extended program. In \norder to prevent any exceptions in continued program execution, the VM guarantees that those deleted \nmembers are never accessed after the change. This is achieved by applying the update only at a point \nwhere it can immediately change all methods on the stack to their new version. The update is delayed \nuntil all method activations of all threads are in base code regions and not in extended code regions. \nOnly then the update is safe, therefore we refer to base code regions also as safe update regions. There \nis no guarantee that a safe update region is reached by all threads. Therefore, the command for changing \nback to the base program has to specify a timeout. If there is a thread that does not reach a safe update \nregion within the given time, the operation fails gracefully. There are two additional restrictions on \nthe difference between the base program and the extended program in order to make switching back to the \nbase program a safe operation: Veri.cation: For a type-safe conversion back to the base method, another \nkind of cross veri.cation is necessary. The VM performs a modi.ed veri.cation of the base pro\u00adgram for \neach extended code region. It infers the types of local variables at the end of every extended code region. \nThen, it starts the veri.er at the base program bytecode following the code region using the inferred \ntypes as the initial types of the local variables. This makes sure that changing from the extended to \nthe base program is a valid operation for each base program position. Type Narrowing: When changing from \nthe base to the ex\u00adtended program, it is allowed to add an interface to a class. When switching back, \nthis would however result in a type narrowing change. Therefore, such a change is only valid if there \nis no local variable or .eld violating the subtype relationship between its static and dynamic type. \nThe VM performs a stack and heap analysis and cancels the operation if it .nds such a violation. If the \nadded and removed interface is only known to the ex\u00adtended program, then the type narrowing change is \nal\u00adways safe, because the base program cannot have .elds or variables of the interface type.  To make \nthe change back to the base program safe, we need to make sure that the base program is not aware that \nit was executed in an extended version. This imposes addi\u00adtional restrictions on the kind of changes \nallowed to form the extended program. We suggest to refrain from using the following code patterns in \nextended code regions to ensure correctness of the continued base program execution after the switch \nback: State: In order to sustain invariants of the base program, the extended code regions must not write \nto local variables and .elds known to the base program. The state of the base program must be read-only \nfor the extended pro\u00adgram. Return: A return statement in the extended code region may lead to base program \ncode with side effects not being executed. Additionally, it could violate invariants on the return value \nof the modi.ed method or just change the base program behavior because of the different return value. \nTherefore, the extended program must not add a return bytecode to a base program method. Call: Calling \na base program method from an extended code region is only allowed if the called method does not modify \nthe state of the base program (i.e., if the called method is a pure function). If one of those patterns \nis used, possible negative effects on continued base program execution have to be checked manually. If \nall speci.ed restrictions are followed, the base program s control .ow as well as the values of its local \nvari\u00adables and .elds are not in.uenced by the execution of ex\u00adtended program regions. Therefore, the \nbase program is un\u00adaware that it has ever been executed in an extended version. Only timing differences \ndue to the execution of extended code regions can result in a different base program behav\u00adior. The two \nextended programs presented in Figure 1 and Figure 4 both do not use any of the problematic actions. \nThey only access their own local variables and .elds. There is a call to the base program method println, \nbut this method does not change the state of the base program. Therefore, it is safe to switch between \nthe base program and any of those two extended programs.  3.3 Changing Between Two Arbitrary Programs \nThe restrictions for the differences between the base pro\u00adgram and the extended program that were presented \nin the last two sections are severe and prohibit many possible changes if the currently running program \nis considered to be the base program. However, we can de.ne a safe update between a currently running \nextended program X and a new extended program Y. This enables us to safely change be\u00adtween two arbitrary \nprogram versions by .nding their com\u00admon base program. A safe update is possible, if a valid base program \nB can be extracted from a comparison of X and Y. The safety of the transformation from X to Y can then \nbe evaluated based on the safety of the transformation from X to B and from B to Y (including possible \nstate transformers de.ned by Y). Figure 5 shows the two extended receiver loop pro\u00adgrams: the program \nX that counts the number of text lines and the program Y that accumulates the text lines in a StringBuilder \nobject. The common base program is shown on the rights side. All of the restrictions between the extended \nprogram and the base program as de.ned in Sec\u00adtion 3.1 and Section 3.2 are followed. Therefore, we can \nsafely switch between the two extended program versions. The base program is never actually executed, \nbut only serves as a de.nition for the safe update regions between the two versions. When changing between \nthree program versions X, Y,and Z, different base program de.nitions can be used. Figure 6 introduces \na program Z, which is a third version of the example program. It increases the count variable by 10 instead \nof 1 as in program X. The common base program C between X and Z can now also include the call to println \nand the .eld count. The common base program between Y and Z is program B as listed in Figure 5. The de.nition \nof the additional base program member count means that the value of the counter is preserved be\u00adtween \nthe two program versions. It is however a violation of the condition that extended programs must not \nwrite to .elds of the base program. The programmer needs to be aware of this possible problem and manually \ndecide whether the tran\u00adsition between X and Z with C as the base program is semanti\u00adcally safe, i.e., \nthat the value produced by one program does not violate the invariants of the other program. Another \npos\u00adsibility would be to exclude count from the base program and perform the version change without preserving \nthe .eld value. The println statement can be added safely to the base program C and has the effect that \nthe transition between X and Z is also possible while this statement is currently ex\u00adecuting. It is always \npossible to de.ne a common base program, because in the worst case the common base program is an empty \nmain method. However, the more an extended program differs from the common base program, the more effort \nis necessary to set up the state of the new extended program upon a version switch. Also, a change between \ntwo extended programs requires the old extended program to reach an execution state where all of its \nthreads are in base program regions.  Extended Program X Extended Program Y Extracted Base Program B \nclass Receiver { private int count; void recv(BufferedReader in) { count++; System.out.println(count); \n} } while(true){String s = in.readLine(); if (s.length() == 0)break; } class Receiver { StringBuilder \nb; void $transformer() { b = new StringBuilder(); } public Receiver() { b = new StringBuilder(); } void \nrecv(BufferedReader in) { b.append(l); } System.out.println(buffer); } } while(true){String s = in.readLine(); \nif (s.length() == 0)break; } class Receiver { void recv(BufferedReader in) { } } while(true){String s \n= in.readLine();if (s.length() == 0)break; }  safe update regions Figure 5. Changing between two program \nversions. Extended Program X Extended Program Z Extracted Base Program C class Receiver { void recv(BufferedReader \nin) { count++; } } while(true){String s = in.readLine(); System.out.println(count);if (s.length() == \n0)break; } private int count; class Receiver { void recv(BufferedReader in) { count += $0; } } while(true){String \ns = in.readLine(); System.out.println(count);if (s.length() == 0)break; } private int count; class Receiver \n{ void recv(BufferedReader in) { } } while(true){String s = in.readLine();System.out.println(count);if \n(s.length() == 0)break; } private int count;  safe update regions and base program fields Figure 6. \nChanging between two program versions that share an instance .eld.  4. Implementation We implemented \nthe functionality of switching between pro\u00adgram versions on top of the base algorithm for class redef\u00adinition \n[44]. The change still has no negative effect on any of the properties of the DCE VM and using the feature \nis optional. For specifying the ranges of extended code regions and base code regions, we do not change \nthe class .le format, but use the built-in possibility to specify a new custom byte\u00adcode attribute with \nthe name CodeRegions . The attribute speci.es the extended code regions as a list of tuples. Each tuple \ndenotes an extended code region with its starting byte\u00adcode position in the extended program and its \nlength. Every extended code region must begin with a NOP instruction. This NOP is used as a special marker \nbytecode, which enables us to perform actions at the code region entry in the interpreter, while the \ncode generated by the just-in-time compiler is not affected. The safe version change is triggered by \na standard class rede.nition command that speci.es the bytecodes of all classes modi.ed in the new version. \nThe only difference to a normal rede.nition is the optionally speci.ed extended code regions in the CodeRegions \nbytecodes attribute. Figure 7 shows the steps performed in the VM for a safe version change. The base \nclass rede.nition algorithm is extended with four parts that are explained in detail in the follow\u00ading \nsections: Compilation prevention, update synchroniza\u00adtion, method forwarding, and transformer execution. \n Class Redefinition Command execute with all threads stopped at safepoints n Update safe? Timeout? \n n y   Notify waiting threads FAILURE SUCCESS Figure 7. Steps performed by the class rede.nition \nalgo\u00adrithm for a safe version change. 4.1 Compilation Prevention Every extended code region begins with \na NOP instruction. We modi.ed the implementation of the NOP instructions in the interpreter to enable \nupdate synchronization at the be\u00adginning of extended code sections as explained in the next section. \nWhen a NOP instruction is executed, the interpreter can look up the extended code region that starts \nat the byte\u00adcode index of the NOP instruction. The NOP instructions are ignored by the just-in-time compilers. \nThis guarantees that despite the presence of extended code regions, the peak per\u00adformance of the VM is \nnot negatively affected. We must make sure that at the time of the safe version change, the arti.cial \nNOP instructions are executed by the in\u00adterpreter. Therefore, we deoptimize [15] methods that con\u00adtain \nextended code regions after receiving the rede.nition command. Deoptimization replaces frames of just-in-time \ncompiled methods with equivalent interpreter frames. Also, we temporarily disable the just-in-time compiler \nfor those methods. Both steps are necessary to guarantee that dur\u00ading the update synchronization, methods \nwith extended code sections are always executing in the interpreter. After the re\u00adde.nition is complete, \nwe enable the just-in-time compiler again for all methods. 4.2 Update Synchronization For a safe version \nchange, we need to make sure that every thread is in a safe update region and not in an extended code \nregion. We do this with two mechanisms: If a thread is in a safe update region, it is prevented from \nentering an extended code region.  We iteratively check the threads, whether all of their activations \nare in safe update regions.  The .rst mechanism is implemented as a modi.cation to the NOP template \nof the interpreter. When the global synchronizing .ag is set, the interpreter checks whether the current \nNOP instruction is at the start of an extended code section. If this is the case, it iterates over the \nstack frames of the currently executing thread. If there is at least one stack frame that is currently \nin an extended code region, then the interpreter continues execution. Otherwise, it suspends exe\u00adcution \nbecause it is now safe for the current thread to per\u00adform the version change. We iteratively check whether \nit is safe for all threads to perform the version change. If there is at least one stack frame that is \nin an extended code region, we keep on waiting. If all of them are outside extended code regions, we \ncan guarantee that none of them again enters such a region before the version change. Therefore, we can \nguarantee that we can .nd a corresponding bytecode position in the new program for all methods active \non the stack and can safely perform the update. Whether a safe update region is reached by all threads \nwithin a given time depends on the properties of the program and therefore cannot be guaranteed. The \nuser can specify a timespan that the algorithm waits until the version change is rejected.  4.3 Method \nForwarding Now, we can perform the standard class rede.nition algo\u00adrithm that loads the new classes and \nthen updates the pointers and instances. In addition to the normal rede.nition, the al\u00adgorithm iterates \nover all active threads and looks at the byte\u00adcode index of active methods. If the method is a forwarding \nmethod, i.e., the old or the new method version de.nes an ex\u00adtended code region, we check the current \nbytecode index. If the method is currently in a base program region, we imme\u00addiately perform the forwarding \nby changing the current byte\u00adcode index and the current method of the interpreter frame. We can safely \ndo this, because it is guaranteed that the new bytecode is equivalent to the currently executing bytecode, \ni.e., even if the interpreter has already executed parts of the bytecode, continued execution is safe. \nIf the execution of the method is currently halted at the NOP instruction at the entry  Class Redefinition \nCommand Class Redefinition Lock Continued Execution of New Program Figure 8. Locks acquired during \nclass rede.nition. to an extended code region, the forwarding happens after we resume the thread.  4.4 \nLocking We need to use locking mechanisms in order to prevent concurrency problems during a version change. \nFigure 8 shows the locks and the order in which they are acquired. Immediately after receiving the class \nrede.nition command, a global lock makes sure that only one thread is currently performing a class rede.nition. \nThe next step is to perform the update synchronization that gathers all threads in safe update regions. \nWhen the update synchronization succeeds without a timeout, the VM begins to load and verify the new \nclass versions. During this process, the Java HotSpotTM VM calls class .le transformers that were registered \nusing the java.lang.instrument API. Those class .le transform\u00aders can intercept the bytecodes of newly \nloaded classes. Concurrently running compilations are also a problem for a version change. Even if the \ncompiler is paused during the class rede.nition, the continued compilation after replacing the old class \nwith the new class version could cause a VM crash. The compiler could access an entry of the constant \npool of the new class at an index read from the bytecodes of the old class. Therefore, we wait for all \nactive compilations to .nish and prevent new compilations until the end of the rede.nition step. In order \nto stop the compiler more quickly, we set a bailout .ag that is regularly checked by the com\u00adpiler. When \nthe .ag is set, the current compilation is aborted and its results are discarded. Every class that is \na subclass of a rede.ned class is called an affected class that needs to be rede.ned itself. We acquire \na class loading lock and then search the class hierarchy for new affected classes that were loaded in \nparallel. If new af\u00adfected classes are found, the class loading and the compila\u00adtion lock are freed and \nthe new classes are processed. We need to release the locks, because class loading and veri.ca\u00adtion can \nagain trigger new class loading. Also, we must not hold a class loading lock while calling the registered \nclass .le transformers. After building a side universe for all affected classes, we can proceed with \nthe rede.nition by stopping all threads at the next safepoints. During the pointer and instance updates, \nevery Java thread must be suspended. After this step, the class rede.nition is completed and the VM can \nrelease all acquired locks and continue program execution. 4.5 Transformer Execution After the rede.nition, \nthreads waiting at normal safepoints immediately start running, but they cannot enter extended code regions. \nThreads waiting at extended code regions are still blocked. It is therefore still guaranteed that no \nthread executes an extended code region. At this time, we execute the static transformer methods and \nthe instance transformer methods for all active instances of classes. After executing the transformers, \nwe notify the threads that are waiting at extended code region entries. They im\u00admediately recognize that \nthey need to transfer the current execution point to the appropriate bytecode index in the new version \nof the method. Also, we enable the just-in-time com\u00adpiler again for all methods.  5. Application to \nDynamic AOP In this section we present SafeWeave, a dynamic AOP framework that builds on top of the DCE \nVM and enables run-time weaving also of methods in execution. While the DCE VM offers a general-purpose \nmechanism for safe and atomic run-time code evolution which is not limited to dy\u00adnamic AOP, the SafeWeave \nframework serves us as a case study to illustrate how a bytecode transformation tool (in this case an \naspect weaver) can take advantage of the DCE VM. SafeWeave is also used for our evaluation in Section \n6. 5.1 AOP Terminology AOP [18] enables the speci.cation of cross-cutting con\u00adcerns in applications, \navoiding related code that is scattered throughout methods, classes, or components. Aspects spec\u00adify \npointcuts to intercept certain points in the execution of programs (so-called join points), such as method \ncalls and .eld accesses. Advice are executed before, after,or around the intercepted join points, and \nhave access to contextual in\u00adformation of the join points. During the weaving process, aspect weavers \nmodify the code of the base application to insert code at intercepted join points; the inserted code \nin\u00advokes advice at run time.  Traditionally, AOP has been used for disposing of de\u00adsign smells such \nas needless repetition, and for improv\u00ading modularity and maintainability of applications. AOP has also \nbeen successfully applied to the development of soft\u00adware engineering tools, such as pro.lers, debuggers, \nor test\u00ading tools [4, 29, 41], which in many cases can be speci.ed as aspects in a concise manner. Hence, \nin a sense, AOP can be regarded as a versatile approach for specifying certain pro\u00adgram transformations \nat a high level, hiding low-level imple\u00admentation details, such as bytecode manipulation, from the programmer. \nDynamic AOP allows aspects to be changed and code to be (re)woven in a running system, thus enabling \nrun-time adaptation of applications. For instance, dynamic AOP has been used for adding persistence or \ncaching at run time [25] and for .xing bugs in a running server [8].  5.2 The SafeWeave Dynamic AOP \nSystem SafeWeave supports all constructs of the AspectJ lan\u00adguage [19], including around() advice and \ninter-type decla\u00adrations (i.e., explicit structural class modi.cations), within a dynamic AOP setting. \nIt relies on the DCE VM to allow arbitrary class changes at run time. SafeWeave uses the stan\u00addard AspectJ \nweaver (as a black box) to weave aspects, and afterwards applies additional bytecode transformations \nand generates the CodeRegions attributes (see Section 4) that are needed to de.ne the base program. SafeWeave \nis implemented as a Java agent that is at\u00adtached to the VM. It relies on the java.lang.instrument API \nfor class rede.nition. SafeWeave deals with runtime (re)weaving of previously loaded classes (class rede.nition) \nand with load-time weaving if an aspect has been deployed before a class is loaded. SafeWeave relies \non a class .le transformer that intercepts any class loading and class re\u00adde.nition; the class .le transformer \nis registered upon VM startup. SafeWeave allows to deploy aspects at run time with a console and offers \nan API to programmatically deploy, change, and remove aspects by application code. The bytecode transformations \ngenerate the necessary transformer methods (see Section 3.1.4). In particular, if re\u00ad.ective join point \ninformation is used in advice (e.g., through the AspectJ pseudo-variables thisJoinPointStaticPart or \nthisJoinPoint), the AspectJ weaver inserts static .elds to hold the static part of the re.ective information. \nThe class initializer is extended to initialize the inserted static .elds. The bytecode transformations \nperformed by SafeWeave copy the code for initializing these .elds into a static trans\u00adformer method. \nSimilarly, initialization code for .elds in\u00adserted by inter-type declarations needs to be copied into \ntransformer methods. The DCE VM requires explicit information on the in\u00adserted extended code regions \nsuch as method attributes in the class .le. Since we want to use the AspectJ weaver as a black box, we \ndo not modify it to directly emit informa\u00adtion on inserted extended code sections, but instead imple\u00admented \na bytecode comparison algorithm that takes the class .les with the original and the woven bytecodes as \ninputs and augments the class .le holding the woven bytecodes with CodeRegions attributes. The comparison \nalgorithm takes into account that constant pool indices may differ but refer to the same constants, as \nwell as the possible use of wide byte\u00adcodes in the original or in the woven program. This approach introduces \nmore overhead than directly modifying the As\u00adpectJ weaver, but allows our system to work with different \nversions of the AspectJ weaver. For before() and after() advice, the AspectJ weaver and SafeWeave only \ninsert bytecodes.1 Hence, the original code represents the base program, and the woven code is the ex\u00adtended \nprogram. Figure 9 shows an example advice that is woven before each read access to the instance .eld \noffset in class C. The execution of method printAll() can be for\u00adwarded to the woven method at any bytecode \nposition. This example also illustrates the code generated for accessing re\u00ad.ective join point information. \nThe static part is stored in a static .eld by the AspectJ weaver, and SafeWeave generates the according \nstatic transformer method. For around() advice, the AspectJ weaver removes the bytecode shadows from \nthe woven method and inserts them into a new method that is invoked by proceed() [13]. That is, bytecodes \nare not only inserted, but also removed. Hence, SafeWeave needs to de.ne the base program by excluding \nthe removed bytecode shadows, and both the original pro\u00adgram and the woven program correspond to extended \npro\u00adgrams. Figure 10 shows an example advice that is woven around calls to method print(int) in class \nC. The execu\u00adtion of method printAll() can be forwarded to the woven method only when no thread is executing \nthe print(val) statement.  5.3 Atomicity of a Version Change The update synchronization of the DCE VM \nmakes sure that all classes given to the rede.nition command are up\u00addated atomically to their new version. \nIn order to realize an atomic program change, SafeWeave must make sure that ev\u00adery class affected by \nan aspect is rede.ned at the same time. It is however impossible to know this set of classes before giving \nthe class rede.nition command, because there could be new classes loaded in after giving the class rede.nition \ncommand. As described in Section 4.4, the update synchro\u00adnization and large parts of the class rede.nition \nhappens in parallel to the running Java application that can load new Java classes. To overcome this \nproblem, SafeWeave uses the fact that the DCE VM automatically adds all affected classes (i.e., subclasses \nof rede.ned classes) to the class rede.nition com\u00admand. SafeWeave calls the class rede.nition only with \nthe 1 The AspectJ weaver also applies some simple bytecode optimizations, which are taken into account \nby SafeWeave s bytecode comparison algo\u00adrithm.  Original Program Woven Program class C { int offset; \nvoid print(int val) { ... } void printAll() { for(int i = 0; i<100; i++){ int val = i + offset; print(val); \n} } } Aspect class C { int offset; void print(int val) { ... } void printAll() { for(int i = 0; i<100; \ni++){ int val = i + offset; print(val); } } } static JoinPoint$StaticPart ajc$tjp_0;static void $staticTransformer() \n{ ajc$tjp_0 = ... ; } JoinPoint jp = Factory.makeJP(ajc$tjp_0, this, this);BeforeAspect.aspectOf().ajc$BeforeGetAspect(jp); \naspect BeforeAspect { before() : get(int offset) &#38;&#38; within(C){ System.out.println(thisJoinPoint); \n} } extended code regions and extended program class members... Figure 9. Example advice woven before \nread access of the instance .eld offset in class C. In the woven program, bytecodes are only inserted. \nHence, the original program is the base program and the woven program is the the extended program. Original \nProgram Woven Program class C { int offset; void print(int val) { ... } void printAll() { for(int i = \n0; i<100; i++){ int val = i + offset; } } } print(val); Aspect class C { int offset; void print(int val) \n{ ... } void printAll() { for(int i = 0; i<100; i++){ int val = i + offset; } } MyIntArray this2, int \narg) { } print_aroundBody1$advice(this, this, val,AroundAspect.aspectOf(), null); static void print_aroundBody1$advice(C \nthis1, C this2,int a, AroundAspect aca, AroundClosure ac) {long start = System.nanoTime();try { print_aroundBody0(this1, \nthis2, a);} finally {System.out.println(System.nanoTime() start); }}static void print_aroundBody0(C this1, \nC this2, int a) {this2.print(a);} aspect AroundAspect { void around() : call(void print(int)) &#38;&#38; \nwithin(C) { long start = System.nanoTime(); try { proceed(); } finally { System.out.println(System.nanoTime() \nstart); } } } extended code regions and extended program class members... Figure 10. Example advice woven \naround calls to method print(int) in class C. In the woven program, bytecodes are not only inserted, \nbut some bytecodes from the original program are also removed. Hence, the base program differs from the \noriginal program; both the original and the woven program are extended programs.   base class of all \nJava classes, i.e., java.lang.Object.The class rede.nition algorithm of the DCE VM then makes sure that \nall loaded Java classes are rede.ned and their byte\u00adcodes are sent to the registered class .le transformers. \nIn the class .le transformer, SafeWeave can then apply the aspect and it is guaranteed that the new version \nof the class be\u00adcomes effective immediately after class rede.nition. In the current version of SafeWeave, \nthe class .le transformer does not weave in the Java class library, which is consistent with the behavior \nof AspectJ s load-time weaver. This limitation, which stems from AspectJ, will be lifted in a future \nver\u00adsion of SafeWeave using polymorphic bytecode instrumen\u00adtation [23].  5.4 Restrictions of the SafeWeave \nProgramming Model The constraints speci.ed in Section 3 have some impact on the SafeWeave programming \nmodel, since the bytecode transformations performed by the AspectJ weaver and by SafeWeave itself must \nmeet these constraints. We require that advice that intercepts an exception in the analyzed program re-throws \nan exception of the same type. We do not allow advice to block for an unlimited time, e.g., in.nite loops \nin advice; otherwise, threads executing advice while class rede.nition is triggered would not reach a \nsafe update region. For similar reasons, aspects must not synchronously trigger class rede.nition within \nadvice; oth\u00aderwise, the method on the call stack executing advice that triggers class rede.nition would \nprevent reaching a safe up\u00addate region. Hence, class rede.nition must be triggered asyn\u00adchronously by \nanother thread (created by the aspect). The thread triggering class rede.nition must be within a safe \nup\u00addate region when it invokes rede.nition. While SafeWeave supports all kinds of AspectJ advice, around() \nadvice must be used with caution. The bytecode shadows removed by the AspectJ weaver should not cor\u00adrespond \nto code that may take a signi.cant amount of time to complete, since method forwarding is not possi\u00adble \nwhile threads are executing that code. For example, around() advice with generic execution or call pointcuts \n(e.g., execution(* *(..)), call(* *(..))) must not be applied to all classes, since otherwise method \nforwarding would only be possible if the call stacks of all threads have been unwound before, i.e., class \nrede.nition would most likely fail after a timeout.  6. Evaluation In this section we evaluate the performance \nof SafeWeave on the DCE VM. We conduct two different evaluations. First, we successively weave aspects \nof increasing complexity into two example applications at run time, measure the time of weaving and class \nrede.nition, and investigate the impact on application performance. Second, we explore the perfor\u00admance \nof class rede.nition when weaving different kinds of aspects in a standard benchmark suite. Our measurement \nenvironment is a quad-core machine (Intel Core 2 Quad Q9650 CPU, 3.0 GHz, 4 GB RAM) running Microsoft \nWindows 7 Professional 64 bit. The ref\u00aderence VM is the 32 bit Oracle JDK 1.6.0 23 Java Hot-SpotTM Server \nVM with 1 GB maximum heap size and the default garbage collector; in the JDK, we replace the Java HotSpotTM \nVM with the DCE VM. The reference aspect weaver is AspectJ version 1.6.10, which is also used in\u00adternally \nby SafeWeave. We use the DaCapo 2006-10-MR2 benchmark suite [6] with the default workload size.2 6.1 \nCode Performance after Weaving For the .rst evaluation, we developed an adaptive dynamic program analysis \ntool with SafeWeave, which allows to en\u00adable and disable different analysis aspects at run time. The \ntool offers three independent features pro.ling of method invocations, object allocations, and .eld accesses. \nThese fea\u00adtures can be arbitrarily combined and applied to the program classes at run time. For each \nclass, a different combination of the pro.ling features may be chosen and changed at run time. Each time \nthe active pro.ling features are changed for at least one class, a corresponding aspect is created and \nwo\u00adven with SafeWeave. For the evaluation with the adaptive dy\u00adnamic analysis tool, we select two benchmarks \nfrom the Da-Capo suite, bloat (single threaded) and lusearch (multi threaded). Figure 11 presents the \ncompletion times of the bench\u00admarks (15 runs) while concurrently applying different com\u00adbinations of \npro.ling features. The reported values corre\u00adspond to the average of 10 repetitions of the same exper\u00adiment \nin different VM processes. Initially, the benchmarks are started without any pro.ling. In the third benchmark \nrun, pro.ling of method invocations is activated for all bench\u00admark classes. In the sixth run, object \nallocation pro.ling is activated in addition to method invocation pro.ling. In the ninth run, pro.ling \nof .eld accesses is additionally activated. Finally, in the twelfth run, all pro.ling features are removed. \nAs shown in Figure 11, the activation (or deactivation) of a pro.ling feature introduces an immediate \nslowdown, i.e., benchmark runs 3, 6, 9, 12, because of aspect weaving and class rede.nition. Furthermore, \nclass rede.nition discards affected compiled methods, which need to be recompiled later on. However, \nafter class rede.nition, the benchmarks quickly achieve stable performance, i.e., benchmark runs 4, 5, \n7, 8, 10, 11, 13, 14, 15. After all pro.ling features have been removed in benchmark run 12, initial \npeak performance is reached again in benchmark run 13. Figure 11 also distinguishes the different sources \nof over\u00adhead when a pro.ling feature is activated respectively deac\u00adtivated (in benchmark runs 3, 6, \n9, 12). The overhead due to class rede.nition in the DCE VM is signi.cantly lower than 2 We do not use \nthe most recent version of the benchmark suite, Da-Capo 9.12-bach, because of problems with the AspectJ \nweaver (and there\u00adfore also with SafeWeave, as it relies on the AspectJ weaver) on some benchmarks. \n     (    (    )    )    (  )   (a) bloat (b) lusearch Figure 11. Dynamic AOP: \naverage iteration time while weaving different aspects on bloat and lusearch using SafeWeave on DCE VM. \n(\"-* )\"'( (\"-* )\"') .    )\"(&#38; )\"(+ )\"(&#38; )\"(,    . * (\")- (\"+' (\")- (\"+' /    (\"+. \n(\",* (\",' (\",*    / *  \"    # $ \"    # $      .   .      /   /   . \n   / (a) bloat (b) lusearch Figure 12. Steady state analysis: performance comparison of the average \niteration time after weaving different aspects on bloat and lusearch using the AspectJ load-time weaver \n(aj5) on the Java HotSpotTM 1.6.0 23 VM and SafeWeave on DCE VM. the overhead due to the code transformations \nperformed by SafeWeave. While Figure 11 shows how our system can effec\u00adtively insert and remove instrumentations \nwithout incur\u00adring any performance penalties after class rede.nition, Fig\u00adure 12 shows that steady-state \nperformance is comparable to a setting where an aspect is woven at load time with the standard AspectJ \nweaver on the standard Java Hot-SpotTM Server VM 1.6.0 23. In particular, we show val\u00adues for the execution \nof the benchmarks without any instru\u00admentation, and for the three combinations of pro.ling fea\u00adtures \n(represented by three different aspects) described be\u00adfore. The reported values correspond to the average \nof 10 ex\u00adecutions of the same experiment in separate VM processes, excluding the run in which rede.nition \nis performed. In summary, before weaving, our system does not incur any overhead when compared with \nthe latest product release of the Java HotSpotTM VM. During the weaving phase, the program threads execute \nuntil they reach a safe update re\u00adgion, and the transition to the woven classes is done atomi\u00adcally. \nAfter class rede.nition, the program rapidly achieves the same level of performance as an application \nwoven with the AspectJ load-time weaver.  Benchmark Scope classes methods weaving time [s] Experiment \n1 synch rede.nition time [s] time [s] weaving time [s] Experiment 2 synch rede.nition time [s] time [s] \nantlr bloat chart eclipse fop hsqldb jython luindex lusearch pmd xalan 95 113 111 861 511 94 206 62 60 \n310 293 1320 1694 1266 13970 3144 2288 1921 592 655 3121 3805 3.350 2.883 1.324 7.668 4.560 3.360 2.240 \n1.586 1.637 4.157 3.630 0.015 0.001 0.001 0.006 0.013 0.058 0.002 0.070 0.012 0.010 0.030 0.037 0.048 \n0.038 0.822 1.014 0.411 0.146 0.685 0.125 0.185 0.392 3.393 3.098 1.583 10.056 4.668 3.431 2.824 1.820 \n1.886 4.405 4.573 0.015 0.001 0.001 0.007 0.020 0.062 0.002 0.070 0.012 0.011 0.029 0.045 0.057 0.040 \n0.838 1.365 0.560 0.167 0.893 0.174 0.205 0.409 average stdev 247 246 3071 3761 3.309 1.801 0.020 0.024 \n0.355 0.345 3.794 2.347 0.021 0.024 0.432 0.436 (a) Experiments 1 and 2 Benchmark Scope classes calls \nto constructors weaving time [s] Experiment 3 synch rede.nition time [s] time [s] weaving time [s] Experiment \n4 synch rede.nition time [s] time [s] antlr bloat chart eclipse fop hsqldb jython luindex lusearch pmd \nxalan 95 113 111 861 511 94 206 62 60 310 293 2213 2139 1178 9853 1948 929 2520 477 471 1540 2080 4.372 \n4.158 1.987 11.540 4.918 3.554 3.389 1.900 1.912 4.633 5.162 0.018 0.002 0.001 0.008 0.028 0.074 0.002 \n0.080 0.026 0.016 0.058 0.097 0.097 0.115 1.206 2.425 1.160 0.208 1.986 0.268 0.391 1.177 5.188 4.489 \n2.138 13.779 5.718 3.630 3.572 2.030 2.044 4.930 5.360 0.019 0.002 0.001 0.008 0.026 0.078 0.002 0.083 \n0.024 0.017 0.056 0.119 0.114 0.151 1.366 2.872 1.648 0.232 2.103 0.386 0.485 1.503 average stdev 247 \n246 2304 2602 4.320 2.681 0.028 0.029 0.830 0.821 4.807 3.275 0.029 0.030 0.998 0.951 (b) Experiments \n3 and 4 Table 1. Performance of aspect weaving and class rede.nition. 6.2 Time for Weaving and Rede.nition \ntions performed by the AspectJ weaver and by SafeWeave increases with each experiment. For the second \nevaluation, we explore the contributions of the different sources of overhead when weaving different \n1. An after(): execution(* *(..)) advice is woven types of aspects at run time. We conduct four experiments \ninto all benchmark methods. Consequently, all method with the aspects described below, which represent \nsome bodies are transformed to invoke the advice upon com\u00adcommon use cases of AOP for dynamic program \nanaly\u00adpletion. The advice does not access any re.ective sis [23, 41]. The complexity of the program transforma\u00adjoin \npoint information. Neither .elds nor methods are in\u00adserted by the AspectJ weaver.  2. An after(): execution(* \n*(..)) advice is woven into all benchmark methods. The advice makes use of thisJoinPointStaticPart. A \nstatic .eld is inserted for each woven method by AspectJ, and SafeWeave gen\u00aderates a static transformer \nmethod for each class in order to initialize these .elds. 3. An Object around() : call(*.new(..)) advice \nis woven around all constructor calls within the bench\u00admarks. The advice does not access any re.ective \njoin point information. The AspectJ weaver generates two methods for each woven advice (for an example \nof around() advice weaving, see Figure 10). 4. An Object around() : call(*.new(..)) advice is woven \naround all constructor calls within the benchmarks. The advice makes use of thisJoinPointStaticPart. \nFor each woven advice, the AspectJ weaver inserts two methods and a static .eld, and SafeWeave generates \na static transformer method for each class where at least one advice is woven.  The measurements for \nthese four experiments are pre\u00adsented in Table 1. We run each DaCapo benchmark 3 times within the same \nVM process before triggering weaving and class rede.nition. The columns Scope present the number of woven \nclasses and the number of woven advice. For each experiment, we distinguish the time for weaving, the \ntime for synchronization within the DCE VM, and the time for the actual class rede.nition in the DCE \nVM. The synchro\u00adnization time includes the time for deoptimization and the time for reaching a safe update \nregion for all threads, which requires (possibly repetitive) execution until safepoints are reached and \nstack walking. The time for class rede.nition includes the time for executing transformer methods. Table \n1 shows that the weaving time predominates the other sources of overhead. The weaving time clearly de\u00adpends \non the number of woven advice and also on the ex\u00adperiment, as the weaving of different types of advice \nincurs different overhead. In the fourth (and most complex) exper\u00adiment, weaving takes between 2.03 seconds \nfor luindex and 13.779 seconds for eclipse . Both the AspectJ weaver and the bytecode transformations \nand the computation of the CodeRegions attributes by SafeWeave contribute to this relatively high overhead. \nThe time for the actual class redef\u00adinition is between 0.114 seconds for bloat and 2.872 sec\u00adonds for \nfop in the fourth experiment. The synchroniza\u00adtion time is relatively insigni.cant in all experiments. \nSafe update regions can be rapidly reached also in the case of the around() advice, because calls to \nconstructors (i.e., the ex\u00adtracted bytecode shadows that are not part of the common base program) typically \ncomplete within short time, albeit there is no such guarantee. Our evaluation con.rms that the overhead \nof class re\u00adde.nition due to the DCE VM is relatively small in com\u00adparison with the overhead introduced \nby aspect weaving in SafeWeave. In particular, reaching a safe update region for all threads takes only \nnegligible time in our experiments.  7. Related Work We .rst describe general dynamic update systems \nfor C and Java. Then we focus on more speci.c comparison on sys\u00adtems that allow dynamic AOP and updates \nto active meth\u00adods. 7.1 Procedural Languages DYMOS is a dynamic update system developed by Cook and Lee \n[9]. It uses an adjusted version of the Modula pro\u00adgramming language and introduces a command language \nfor performing the update. If a procedure is modi.ed, then the old version of the procedure keeps running \nand only new invocations target the new version. They note that this can lead to inconsistencies and \ntherefore enhanced their update language: An update may contain a list of procedures that must not be \nin execution at the time of the update. DYMOS supports the ability to manually specify pre-de.ned update \npoints in the old method that are potential transfer points to the new version of a method. Frieder and \nSegal developed a system called PODUS [11, 34]. Similar to DYMOS, updates are performed at the pro\u00adcedure \nlevel, however the user need not specify the list of procedures that must be inactive to perform the \nupdate. The system updates a procedure only if it is not active and if it cannot call directly or indirectly \nany other procedure that is currently active. Ginseng allows dynamic software updates for programs written \nin C [24]. They need to compile the programs in a different way and report a performance overhead of \nup to 32% if several updates are applied. Safe update points have to be speci.ed in the original program \nas calls into the runtime system. The user therefore has to anticipate all possible update points in \nthe original program version. For each update point, Ginseng performs an analysis on the update constraints, \ne.g., which types may be changed at that point. Procedures can only be updated as a whole unit. The authors \nof Ginseng later presented Proteus, a calculus for automatically inferring the update constraints [35]. \n 7.2 Java The hotswapping capabilities of the current product ver\u00adsion of the Java HotSpotTM VM were \ndeveloped by Dmitriev [10]. It allows changes to method bodies and can be triggered using the Java Platform \nDebugger Architecture. Old activations of changed methods continue to run, the de\u00adbugger may however \nchose to rerun the method that is at the top of the stack. Several bytecode rewriting tools [28, 32, \n33] use the stan\u00addard hotswapping as its basis and try to improve its features to allow changes to the \nclass de.nitions. The granularity of the change is still at method level and they need to introduce indirections \nin order to simulate the class de.nition changes. This leads to obscure stack traces and performance \npenalties that do not occur with our system. The main advantage of the bytecode rewriting solutions is \nthat they work with any VM that supports the method rede.nition feature.  There are modi.cations of \nexisting Java VMs that al\u00adlow changes to the class data structure. But still none of them are capable \nof replacing the code of currently running methods. JVolve, a modi.cation of Jikes by Subramanian et \nal. [36], restricts the update by checking active methods on the stack. The previous version of the DCE \nVM [44] allows the old versions of methods continue to execute, but can\u00adnot guarantee that this does \nnot result in unexpected excep\u00adtions. JDrums [2] and the DVM [22] are two modi.cations of JDK 1.2 that \nallow class rede.nitions. They both report a signi.cant overhead of their modi.cations and also continue \nrunning old methods.  7.3 Stack Updates All dynamic update systems described so far are not capa\u00adble \nof performing an update more .ne-grained than at the method level. Therefore, they are not suitable for \nupdating long-running loops or the main method of the program. The authors of Ginseng propose a technique \ncalled loop extraction to reduce this drawback [24]. The body of the loop is extracted into a newly generated \nmethod such that it can be updated. The user has to manually select loops that should be extracted and \nthe extraction implies a performance overhead. Upstare is a dynamic update system for C developed by \nMakris and Bazzi that allows to replace active execu\u00adtions [21]. They perform a full stack unrolling \nand allow the user to specify continuation mappings between old and new method version. Update points \nare automatically inserted at the beginning of loops and methods. Due to the additional in\u00addirections \nand update point checks, they report an overhead of up to 38.5% for their benchmarks. The update model \nof Upstare offers a high .exibility, because the new method can effectively run different code starting \nfrom the current exe\u00adcution point in the old method. It is however not possible to switch back to the \nold version, and the user is responsi\u00adble for checking the semantic correctness of a continuation mapping. \nEvery speci.ed update point has to provide a valid mapping to the new version.  7.4 Dynamic AOP in Java \nWhile dynamic AOP is often supported in dynamic lan\u00adguages [5, 14] such as Lisp or Smalltalk, where code \ncan be easily manipulated at run time, it is more dif.cult and challenging to offer dynamic AOP for languages \nlike Java. Several popular AOP frameworks for Java such as As\u00adpectJ [19] or abc [3], do not support dynamic \nAOP. That is, aspects are woven statically at build time or at load time, but cannot be (re)woven in \na running system. However, there are several AOP frameworks for Java that explicitly sup\u00adport dynamic \nAOP, such as PROSE [26, 30, 31], Steam\u00adloom [7, 12], Wool [8], JAsCo [37, 38], JBossAOP [17], AspectWerkz \n[39], HotWave [40], and HotWave2 [42, 43]. These frameworks are discussed below. PROSE [26, 30, 31] is \nan adaptive middleware platform offering dynamic AOP. PROSE has evolved in three ver\u00adsions, which make \nuse of the three different approaches to dynamic AOP. The .rst version of PROSE is not tuned for perfor\u00admance, \nand uses the Java Virtual Machine Debugger Inter\u00adface (JVMDI) [27] to request noti.cations from the debug\u00adger \nlayer in the JVM each time the execution reaches one of the registered join points. The second version \nof PROSE is implemented at the JVM level, and an implementation based on the IBM Jikes Re\u00adsearch Virtual \nMachine (RVM) [1] is available. An execu\u00adtion monitor is embedded in the JVM to activate join points \nby registering callbacks each time a new aspect is added to the system. Since the base version of Jikes \nRVM has no in\u00adterpreter and relies exclusively on just-in-time compilation, the baseline just-in-time \ncompiler is modi.ed to weave min\u00adimal hooks at all potential join points to check for registered callbacks. \nIn this version, the overhead due to inserted hooks may reach a slowdown factor of 8.5 when only dummy \nad\u00advice are activated that do not compute anything. The third version of PROSE replaces hook weaving \nwith two weaving strategies: advice weaving based on method re\u00adplacement, and stub weaving for join points \ninvolving ad\u00advice. This version has been implemented in two JVMs, the Jikes RVM and the Java HotSpotTM \nVM. The Jikes RVM implementation is based on a modi.cation to the just-in-time compiler that forces the \nrecompilation of the original method and replaces it with the woven version. This implementation of PROSE \ncannot locate target methods in case of compiler optimizations such as method inlining. The implementation \nfor the Java HotSpotTM VM does not require changes to the JVM, as it is based on the hotswapping technique \nto update class de.nitions at run time, which however allow neither in\u00adsertion and removal of methods \nand .elds, nor modi.cations to method signatures. Steamloom [7, 12] provides support for AOP at the JVM \nlevel, based on Jikes RVM. At load time, application classes are represented in a custom format that \nrelies on doubly\u00adlinked lists of instruction objects to ease bytecode manipu\u00adlation. Steamloom extends \nthe Java bytecode language with two additional instructions speci.c to AOP: beginadvice and endadvice. \nAt weaving time, the woven code is au\u00adtomatically surrounded by these two instruction to simplify the \nremoval of the aspect. Three different classes of aspects are supported, depending on the dynamic scope: \nclass-wide, instance-local, and thread-local aspects. Steamloom sup\u00adports AspectJ syntax to de.ne pointcut \nexpressions, which are automatically translated to join point shadows .lters. Wool [8] combines two different \nweaving strategies. The Java Platform Debugger Architecture (JPDA) [27] is used to insert breakpoints \nat all possible join points. Once an active join point has been intercepted a suf.cient amount of times, \nthe hotswapping mechanism is used to replace the class de.nition with its woven version to reduce run-time \noverhead. Custom heuristics can be used to de.ne when the hotswapping mechanism should be triggered. \n Run-time weaving in JAsCo [37, 38] relies on the hotswapping mechanism to update class de.nitions at \nrun time. If JPDA is used, JAsCo requires preliminary load-time insertion of hooks for aspect weaving. \nJAsCo uses a new as\u00adpect language that introduces two new entities: aspect beans and connectors. Aspect \nbeans are based on the JavaBeans programming model and contain hooks that de.ne which join points have \nto be intercepted and the corresponding ad\u00advice. Connectors are used to deploy aspect beans in a con\u00adcrete \ncontext. Similar to JAsCo, JBossAOP [17] relies on a modi.ed class loader to prepare join point shadows \nand add the cor\u00adresponding auxiliary .elds at load time. Run-time weaving is supported by means of the \nhotswapping mechanism of the java.lang.instrument API. JBossAOP uses an as\u00adpect language based on annotations \nand XML. AspectWerkz [39] allows to deploy and undeploy aspects at run time using hotswapping. Similar \nto JBossAOP, As\u00adpectWerkz forces a preparation step at load time using a cus\u00adtomized class loader to \nadd auxiliary .elds to support differ\u00adent pointcuts. AspectWerkz uses an aspect language based on annotations \nand XML. HotWave [40] and HotWave2 [42, 43] are dynamic AOP frameworks particularly designed for the \nimplementation of adaptive dynamic analysis tools. The main focus of these frameworks is on run-time \nweaving in any method that has a bytecode representation, including methods in the Java class library. \nBoth HotWave and HotWave2 are based on AspectJ [19]. HotWave runs on any standard JVM and re\u00adstricts \nthe AspectJ programming model; e.g., around() ad\u00advice and explicit structural modi.cations of classes, \ni.e., so\u00adcalled static cross-cutting, are not supported. In contrast, HotWave2 is based on a prior version \nof the DCE VM [44] that allows the necessary class transformations in support of around() advice and \nstatic cross-cutting. In contrast to the SafeWeave system presented in Sec\u00adtion 5, run-time weaving with \nthe aforementioned dynamic AOP systems does not affect the execution of active methods on the call stacks \nof executing threads; the active methods continue executing the body before weaving. The update on active \nmethods enables SafeWeave to apply aspects to state\u00adments of the bodies of in.nite loops. Additionally, \nwe can make the update atomic without waiting for every updated method to become inactive. Moreover, \nthe aforementioned frameworks relying on VM modi.cations (i.e., SteamLoom and some versions of PROSE) \nenhance a research VM with speci.c support for dynamic AOP. In contrast, our approach integrates a gen\u00aderal \nmechanism for safe and atomic run-time code evolution into a state-of-the-art, production-quality VM. \nThe use of the DCE VM is not limited to dynamic AOP; the SafeWeave framework presented in Section 5 serves \nmerely as a case study for demonstrating the new VM features.  8. Conclusions We presented a system \nthat allows dynamic updates to run\u00adning Java programs. It guarantees atomicity of updates and is capable \nof performing the update at bytecode granular\u00adity changing the execution point in currently running meth\u00adods. \nThe additional functionality of our enhanced VM comes with no costs in terms of execution performance \nbefore or after the change. We believe that this is an important charac\u00adteristic of our approach, because \nit brings the new possibil\u00adities without drawbacks for normal program execution. Our source code modi.cations \nbased on the Java HotSpotTM VM and binaries of our enhanced version of the DCE VM are available for download \n[16]. We described how AOP concepts map to our program\u00adming model and presented SafeWeave, a dynamic \nAOP sys\u00adtem that uses the atomic update capabilities of the VM. SafeWeave is capable of atomically applying \nan aspect even in the context of dynamic class loading. The evaluation shows that the peak performance \nof the VM is not impaired by run-time code evolution due to aspect weaving, and that the time for rede.nition \nis insigni.cant.  Acknowledgments We would like to thank current and former members of the Java HotSpotTM \nVM team at Oracle, especially Thomas Rodriguez, John Rose, David Cox, and Kenneth Russell, for their \npersistent support, for contributing many ideas and for helpful comments on all parts of the VM. Additionally, \nwe would like to thank Oracle and Guidewire for sponsoring this work.  References [1] B. Alpern, C. \nR. Attanasio, J. J. Barton, B. Burke, P. Cheng, J.-D. Choi, A. Cocchi, S. J. Fink, D. Grove, M. Hind, \nS. F. Hummel, D. Lieber, V. Litvinov, M. F. Mergen, N. Ngo, J. R. Russell, V.Sarkar,M. J.Serrano, J.C.Shepherd, \nS.E.Smith, V. C. Sreedhar, H. Srinivasan, and J. Whaley. The Jalape no virtual machine. IBM Systems Journal, \n39(1):211 238, 2000. [2] J. Andersson and T. Ritzau. Dynamic code update in JDrums. In Workshop on Software \nEngineering for Wearable and Per\u00advasive Computing, 2000. [3] P. Avgustinov, A. S. Christensen, L. J. \nHendren, S. Kuzins, J. Lhot\u00b4ak, O. Lhot\u00b4ak, O. de Moor, D. Sereni, G. Sittampalam, and J. Tibble. abc: \nAn extensible AspectJ compiler. In Pro\u00adceedings of the International Conference on Aspect-Oriented Software \nDevelopment, pages 87 98. ACM Press, 2005. doi: 10.1145/1052898.1052906. [4] L. D. Benavides, R. Douence, \nand M. S\u00a8udholt. Debugging and testing middleware with aspect-based control-.ow and causal  patterns. \nIn Proceedings of the International Conference on Middleware, pages 183 202. Springer-Verlag, 2008. [5] \nA. Bergel. FacetS: First class entities for an open dynamic AOP language. In Proceedings of the Open \nand Dynamic Aspect Languages Workshop, 2006. [6] S. M. Blackburn, R. Garner, C. Hoffman, A. M. Khan, \nK. S. McKinley,R.Bentzur,A. Diwan,D.Feinberg,D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump, \nH. Lee, J. E. B. Moss, A. Phansalkar, D. Stefanovi\u00b4c, T. VanDrunen, D. von Dincklage, and B. Wiedermann. \nThe DaCapo benchmarks: Java benchmarking development and analysis. In Proceed\u00adings of the ACM SIGPLAN \nConference on Object-Oriented Programming Systems, Languages, and Applications, pages 169 190. ACM Press, \n2006. doi: 10.1145/1167473.1167488. [7] C. Bockisch, M. Haupt, M. Mezini, and K. Ostermann. Virtual machine \nsupport for dynamic join points. In Proceedings of the International Conference on Aspect-Oriented Software \nDevelopment, pages 83 92. ACM Press, 2004. doi: 10.1145/ 976270.976282. [8] S. Chiba, Y. Sato, and M. \nTatsubori. Using HotSwap for im\u00adplementing dynamic AOP systems. In Proceedings of the Workshop on Advancing \nthe State-of-the-Art in Run-time In\u00adspection, 2003. [9] R. P. Cook and I. Lee. DYMOS: A dynamic modi.cation \nsystem. In Proceedings of the Symposium on High-level Debugging, pages 201 202. ACM Press, 1983. doi: \n10.1145/ 1006147.1006188. [10] M. Dmitriev. Safe Class and Data Evolution in Large and Long-Lived Java \nApplications. PhD thesis, University of Glasgow, 2001. [11] O. Frieder and M. E. Segal. On dynamically \nupdating a computer program: From concept to prototype. Journal on System Software, 14:111 128, February \n1991. doi: 10.1016/ 0164-1212(91)90096-O. [12] M. Haupt, M. Mezini, C. Bockisch, T. Dinkelaker, M. Eich\u00adberg, \nand M. Krebs. An execution layer for aspect-oriented programming languages. In Proceedings of the ACM/USENIX \nInternational Conference on Virtual Execution Environments, pages 142 152. ACM Press, 2005. doi: 10.1145/1064979. \n1065000. [13] E. Hilsdale and J. Hugunin. Advice weaving in AspectJ. In Proceedings of the International \nConference on Aspect-Oriented Software Development, pages 26 35. ACM Press, 2004. doi: 10.1145/976270.976276. \n[14] R. Hirschfeld. AspectS -aspect-oriented programming with Squeak. In Revised Papers from the International \nConference NetObjectDays on Objects, Components, Architectures, Ser\u00advices, and Applications for a Networked \nWorld, pages 216 232. Springer-Verlag, 2003. [15] U. H\u00a8olzle, C. Chambers, and D. Ungar. Debugging opti\u00admized \ncode with dynamic deoptimization. In Proceedings of the ACM SIGPLAN Conference on Programming Language \nDesign and Implementation, pages 32 43. ACM Press, 1992. doi: 10.1145/143095.143114. [16] Dynamic Code \nEvolution VM. Institute for System Software, Johannes Kepler University Linz, 2011. http://ssw.jku.at/dcevm/. \n [17] JBoss AOP. JBoss, 2011. http://labs.jboss.com/jbossaop/. [18] G. Kiczales, J. Lamping, A. Menhdhekar, \nC. Maeda, C. Lopes, J.-M. Loingtier, and J. Irwin. Aspect-Oriented Program\u00adming. In Proceedings of the \nEuropean Conference on Object-Oriented Programming, pages 220 242. Springer-Verlag, 1997. [19] G. Kiczales, \nE. Hilsdale, J. Hugunin, M. Kersten, J. Palm, and W. G. Griswold. An overview of AspectJ. In Proceedings \nof the European Conference on Object-Oriented Programming, pages 327 353. Springer-Verlag, 2001. [20] \nT. Lindholm and F. Yellin. The JavaTM Virtual Machine Speci.cation. Addison-Wesley, 2nd edition, 1999. \n[21] K. Makris and R. Bazzi. Immediate multi-threaded dynamic software updates using stack reconstruction. \nIn Proceedings of the USENIX Annual Technical Conference. USENIX Asso\u00adciation, 2009. [22] S. Malabarba, \nR. Pandey, J. Gragg, E. Barr, and J. F. Barnes. Runtime support for type-safe dynamic Java classes. In \nPro\u00adceedings of the European Conference on Object-Oriented Programming, pages 337 361. Springer-Verlag, \n2000. \u00b4instrumentation. In Proceedings of the International Confer\u00adence on Aspect-Oriented Software Development, \npages 129 [23] P. Moret, W. Binder, and E. Tanter. Polymorphic bytecode 140. ACM Press, 2011. doi: 10.1145/1960275.1960292. \n[24] I. Neamtiu, M. Hicks, G. Stoyle, and M. Oriol. Practical dynamic software updating for C. In Proceedings \nof the ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM Press, 2006. doi: \n10.1145/1133981. 1133991. [25] A. Nicoara and G. Alonso. Making applications persistent at run-time. \nProceedings of the International Conference on Data Engineering, pages 1368 1372, 2007. doi: 10.1109/ \nICDE.2007.369013. [26] A. Nicoara, G. Alonso, and T. Roscoe. Controlled, systematic, and ef.cient code \nreplacement for running Java programs. In Proceedings of the European Conference on Computer Systems, \npages 233 246. ACM Press, 2008. doi: 10.1145/ 1352592.1352617. [27] Java Platform Debugger Architecture. \nOracle Corporation, 2011. http://java.sun.com/javase/technologies/core/toolsapis/ jpda/. [28] A. Orso, \nA. Rao, and M. J. Harrold. A technique for dynamic updating of Java software. In Proceedings of the International \nConference on Software Maintenance, pages 649 658. IEEE Computer Society, 2002. doi: 10.1109/ICSM.2002.1167829. \n[29] D. J. Pearce, M. Webster, R. Berry, and P. H. J. Kelly. Pro.ling with AspectJ. Software: Practice \nand Experience, 37(7):747 777, 2007. doi: 10.1002/spe.788. [30] A. Popovici, T. Gross, and G. Alonso. \nDynamic weaving for aspect-oriented programming. In Proceedings of the In\u00adternational Conference on Aspect-Oriented \nSoftware Devel\u00adopment, pages 141 147. ACM Press, 2002. doi: 10.1145/ 508386.508404. [31] A. Popovici, \nG. Alonso, and T. Gross. Just-in-time aspects: ef.cient dynamic weaving for Java. In Proceedings of the \nIn\u00ad  ternational Conference on Aspect-Oriented Software Devel\u00adopment, pages 100 109. ACM Press, 2003. \ndoi: 10.1145/ 643603.643614. [32] M. Pukall, C. K\u00a8astner, and G. Saake. Towards unanticipated runtime \nadaptation of Java applications. In Proceedings of the Asia-Paci.c Software Engineering Conference, pages \n85 92. IEEE Computer Society, 2008. doi: 10.1109/APSEC.2008.66. [33] B. Redmond and V. Cahill. Supporting \nunanticipated dy\u00adnamic adaptation of application behaviour. In Proceedings of the European Conference \non Object-Oriented Program\u00adming, pages 205 230. Springer-Verlag, 2002. doi: 10.1007/ 3-540-47993-7 9. \n[34] M. E. Segal and O. Frieder. On-the-.y program modi.cation: Systems for dynamic updating. IEEE Software, \n10:53 65, 1993. doi: 10.1109/52.199735. [35] G. Stoyle, M. Hicks, G. Bierman, P. Sewell, and I. Neamtiu. \nMutatis mutandis: Safe and predictable dynamic software up\u00addating. ACM Transactions on Programming Languages \nand Systems, 29(4), 2007. doi: 10.1145/1255450.1255455. [36] S. Subramanian, M. Hicks, and K. S. McKinley. \nDynamic software updates: a VM-centric approach. In Proceedings of the ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, pages 1 12. ACM Press, 2009. doi: 10.1145/1542476.1542478. [37] D. \nSuv\u00b4ee, W. Vanderperren, and V. Jonckers. JAsCo: an aspect-oriented approach tailored for component based \nsoft\u00adware development. In Proceedings of the International Con\u00adference on Aspect-Oriented Software Development, \npages 21 29. ACM Press, 2003. doi: 10.1145/643603.643606. [38] W. Vanderperren, D. Suv\u00b4ee, B. Verheecke, \nM. A. Cibr\u00b4an, and V. Jonckers. Adaptive programming in JAsCo. In Proceedings of the International Conference \non Aspect-Oriented Software Development, pages 75 86. ACM Press, 2005. doi: 10.1145/ 1052898.1052905. \n[39] A. Vasseur. Dynamic AOP and runtime weaving for Java How does AspectWerkz address it? In Dynamic \nAspects Workshop, 2004. [40] A. Villaz\u00b4on, W. Binder, D. Ansaloni, and P. Moret. Advanced runtime adaptation \nfor Java. In Proceedings of the Inter\u00adnational Conference on Generative Programming and Com\u00adponent Engineering, \npages 85 94. ACM Press, 2009. doi: 10.1145/1621607.1621621. [41] A. Villaz\u00b4on, W. Binder, and P. Moret. \nFlexible calling context rei.cation for aspect-oriented programming. In Proceedings of the International \nConference on Aspect-Oriented Software Development, pages 63 74. ACM Press, 2009. doi: 10.1145/ 1509239.1509249. \n[42] T. W\u00a8urthinger, W. Binder, D. Ansaloni, P. Moret, and H. M\u00a8ossenb\u00a8ock. Improving aspect-oriented \nprogramming with dynamic code evolution in an enhanced Java virtual ma\u00adchine. In Proceedings of the Workshop \non Re.ection, AOP and Meta-Data for Software Evolution, pages 5:1 5:5. ACM Press, 2010. doi: 10.1145/1890683.1890688. \n[43] T. W\u00a8urthinger, W. Binder, D. Ansaloni, P. Moret, and H. M\u00a8ossenb\u00a8ock. Applications of enhanced \ndynamic code evolution for Java in GUI development and dynamic aspect\u00adoriented programming. In Proceedings \nof the International Conference on Generative Programming and Component En\u00adgineering, pages 123 126. \nACM Press, 2010. doi: 10.1145/ 1868294.1868312. [44] T. W\u00a8urthinger, C. Wimmer, and L. Stadler. Dynamic \ncode evolution for java. In Proceedings of the International Con\u00adference on the Principles and Practice \nof Programming in Java, pages 10 19. ACM Press, 2010. doi: 10.1145/1852761. 1852764.  \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Dynamic updates to running programs improve development productivity and reduce downtime of long-running applications. This feature is however severely limited in current virtual machines for object-oriented languages. In particular, changes to classes often apply only to methods invoked after a class change, but not to active methods on the call stack of threads. Additionally, adding and removing methods as well as fields is often not supported.</p> <p>We present a novel programming model for safe and atomic code updates of Java programs that also updates methods that are currently executed. We introduce safe update regions and pause threads only there before an update. We automatically convert the stack frames to suit the new versions of the methods. Our implementation is based on a production-quality Java virtual machine.</p> <p>Additionally, we present SafeWeave, a dynamic aspect-oriented programming system that exposes the atomic code updates through a high-level programming model. AspectJ advice can be added to and removed from a running application.Changes are atomic and correctness is guaranteed even though weaving happens in parallel to program execution, and the system fully supports the dynamic class loading of Java. We show that the enhanced evolution features do not incur any performance penalty before and after version changes.</p>", "authors": [{"name": "Thomas W&#252;rthinger", "author_profile_id": "81414605426", "affiliation": "Johannes Kepler University Linz, Linz, Austria", "person_id": "P2839277", "email_address": "wuerthinger@ssw.jku.at", "orcid_id": ""}, {"name": "Danilo Ansaloni", "author_profile_id": "81372593980", "affiliation": "University of Lugano, Lugano, Switzerland", "person_id": "P2839278", "email_address": "danilo.ansaloni@usi.ch", "orcid_id": ""}, {"name": "Walter Binder", "author_profile_id": "81100315534", "affiliation": "University of Lugano, Lugano, Switzerland", "person_id": "P2839279", "email_address": "walter.binder@usi.ch", "orcid_id": ""}, {"name": "Christian Wimmer", "author_profile_id": "81331507319", "affiliation": "University of California, Irvine, Irvine, USA", "person_id": "P2839280", "email_address": "cwimmer@uci.edu", "orcid_id": ""}, {"name": "Hanspeter M&#246;ssenb&#246;ck", "author_profile_id": "81100481478", "affiliation": "Johannes Kepler University Linz, Linz, Austria", "person_id": "P2839281", "email_address": "moessenboeck@ssw.jku.at", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048129", "year": "2011", "article_id": "2048129", "conference": "OOPSLA", "title": "Safe and atomic run-time code evolution for Java and its application to dynamic AOP", "url": "http://dl.acm.org/citation.cfm?id=2048129"}