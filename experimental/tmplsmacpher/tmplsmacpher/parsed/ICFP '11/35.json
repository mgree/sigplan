{"article_publication_date": "09-19-2011", "fulltext": "\n Incremental Updates for Ef.cient Bidirectional Transformations Meng Wang Jeremy Gibbons Nicolas Wu \nComputer Science and Engineering Department of Computer Science Well-Typed LLP Chalmers University of \nTechnology University of Oxford Oxford, UK 412 96 G\u00a8oteborg, Sweden wmeng@chalmers.se Wolfson Building, \nParks Road Oxford OX1 3QD, UK nick@well-typed.com jeremy.gibbons@cs.ox.ac.uk Abstract A bidirectional \ntransformation is a pair of mappings between source and view data objects, one in each direction. When \nthe view is modi.ed, the source is updated accordingly. The key to handling large data objects that are \nsubject to relatively small modi.cations is to process the updates incrementally. Incrementality has \nbeen explored in the semi-structured settings of relational databases and graph transformations; this \n.exibility in structure makes it rela\u00adtively easy to divide the data into separate parts that can be \ntrans\u00adformed and updated independently. The same is not true if the data is to be encoded with more general-purpose \nalgebraic datatypes, with transformations de.ned as functions: dividing data into well\u00adtyped separate \nparts is tricky, and recursions typically create inter\u00addependencies. In this paper, we study transformations \nthat support incremental updates, and devise a constructive process to achieve this incrementality. Categories \nand Subject Descriptors D.3.2 [Programming Lan\u00adguages]: Language Classi.cations Applicative (functional) \nlan\u00adguages, Specialized application languages; D.3.3 [Programming Languages]: Language Constructs and \nFeatures Data types and structures, Polymorphism General Terms Languages, Design, Performance, Theory \nKeywords Functional Programming, Bidirectional Programming, Incremental Computing, Program Transformation, \nView-update Problem 1. Introduction From a programming perspective, bidirectional programming is an exercise \nin writing programs that execute both forwards and back\u00adwards. This goal is not always achievable: non-injective \nfunctions obscure the route back, while non-surjective functions leave the backward execution partial. \nNevertheless, the need to invert a computation does arise in many contexts in which pairs of pro\u00adgrams \nnaturally interact with one another; parser/printer, embed\u00adding/projection, marshalling/unmarshalling, \nand compression/de\u00adcompression are typical examples. For decades, the needs of bidi\u00adrectionality have \nbeen ful.lled by individually crafted pairs of pro- Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. ICFP 11, September 19 21, 2011, Tokyo, Japan. Copyright c &#38;#169; \n2011 ACM 978-1-4503-0865-6/11/09. . .$10.00. grams. This is a signi.cant duplication of work, because \nthe two programs in a pair are closely related. Furthermore, maintaining the relationship between these \nprogams becomes a source of er\u00adrors, where changes to only one of the programs may lead to an inconsistency \nwithin the pair. A more promising solution to the challenge of bidirectional pro\u00adgramming is to design \nlanguages that execute bidirectionally. In such languages, any user-de.ned program, mapping a source \ninto a view, is coupled with an automatically generated backward ver\u00adsion, whose correctness with regards \nto certain bidirectional prop\u00aderties is guaranteed. An obvious bidirectional property is invertibil\u00adity. \nFor a given program fwd, its inverse bwd satis.es fwd .bwd = id and bwd .fwd = id. While this invertibility \nis elegant, it restricts the expressiveness of the approach, since fwd must be bijective. Mod\u00adulo information \nencoded in fwd itself, the source and view neces\u00adsarily contain exactly the same information, probably \nwith different presentations. This is an unrealistically strong assumption, and has driven research into \nmore widely applicable frameworks: More generally, bijective transformations are the exception rather \nthan the rule: the fact that one model contains infor\u00admation not represented in the other is part of \nthe reason for having separate models. [27] 1.1 Semi-Invertibility To circumvent the bijectivity restriction, \nother languages have been designed with particular applications in mind, where less demand\u00ading constraints \nsuch as one-sided invertibility are imposed: left\u00adinvertibility (fwd . bwd = id) in [24], and right-invertibility \n(bwd . fwd = id) in [31]. A more dramatic diversion from the invertibility framework is the lens approach \n[10, 4, 12, 11, 3, 18], which orig\u00adinated from the study of the view-update problem of databases [7, \n2, 14]. In the setting of lenses, (all or part of) the original source is copied and is used in the backward \ncomputation: a get func\u00adtion has type s . v from source to view, while a put function has type (v,s) \n. s. We make the following notational convention: for a get function f , the counterpart put function \nis written as f < . The task of a put function is to discover the connection between a view update and \nan appropriate corresponding source update. This appropriateness is de.ned by the de.nitional properties \n[6, 27]: Consistency f (f < (v,s)) = v Acceptability f < (fs,s)= s Here consistency (also known as the \nPutGet law) roughly corre\u00adsponds to right-invertibility, basically ensuring that all updates on a view \nare captured by the updated source, and acceptability (also known as the GetPut law) roughly corresponds \nto left-invertibility, prohibiting changes to the source if no update has been made on the view. Bidirectional \ntransformations satisfying the above two laws are sometimes called well-behaved [10]. In addition to \nthese laws, an optional undoability property is sometimes introduced: i Undoability f < (fs,f < (v,s)) \n= s This property states that the result of an update can be undone through the view. For the sake of \nthis paper, we will present our proposal within the lenses framework, with the understanding that the \nsame technique applies to invertible languages as well.  1.2 State-Based and Operation-Based Approaches \nThe word update is commonly found in the bidirectional transfor\u00admation literature, and used to describe \nchanges both in views and in sources. In the sequel, we restrict the use of the term update to the transformed \neffect on a source, as a result of an edit to the view. De\u00adspite being fundamental to bidirectional transformation, \nthere is no universal agreement on what constitutes an edit. Roughly speak\u00ading, opinions are divided \nas to whether one should look into the mechanism of an edit or simply its result. Translated into language \ndesign, one can either take an operation-based approach, consid\u00adering an editing function that changes \na view, or a state-based ap\u00adproach, which only sees the unedited and edited views. It happens that the \nmajority of existing bidirectional frameworks take the lat\u00adter approach, due to its mathematical simplicity \nand good compat\u00adibility. The bidirectional laws discussed above are speci.ed from a state-based perspective. \nSince only the edited view is required for the put function, it is easier to design a bidirectional framework \nindependently of any editing system. On the other hand, a state\u00adbased approach necessarily discards information \nabout an edit, and must reverse-engineer it later by performing some kind of differ\u00adence analysis on \nthe two view values. Consequently, the run-time performance of a state-based put function is bound by \nthe dif\u00adference analysis that is required: even a small change to the view implies a complete re-traversal. \nMeertens [23] observed that to maintain constraints between two structures, it is useful to know how \na view is edited. Consider the scenario where two lists are connected by a mapping relation (i.e. each \nis the result of mapping some function over the other); an edit to one list, say deletion at a particular \nposition, can be trans\u00adlated to a deletion at the same position in the other list. In this set\u00adting, \na lot more information about the edit is made available to the bidirectional framework, including where \n(the location) and what (a deletion) has changed. As a result, the updating process could be more straightforward \ncompared to a state-based approach in the latter, all that is known is that one list is changed into \nanother list that is one element shorter, which is fairly ambiguous. In ad\u00addition, having an operation \nfor source update potentially achieves better-than-linear runtime performance. If run-time performance \nis the only concern, the where part of the knowledge of an edit is the key. For a given edit-affected \nview fragment, once the corresponding source fragment is picked out, a state-based approach could perform \nthe changes as ef.ciently as an operation-based counterpart, without the undesired complications that \nthe latter brings. This idea is not new. As a matter of fact, for bidirectional systems in the neighbouring \n.elds of databases and software engineering, incrementality of source updates is the norm rather than \nthe exception [5, 8, 15]. With the more recent upsurge in (mostly functional) programming language approaches \nto bidi\u00adrectional transformation [19, 10, 21, 28, 25, 29], fresh challenges emerge: structured data cannot \neasily be divided into separate parts to be transformed and updated independently; and recursions typ\u00adically \ncreate interdependencies. As a result, in contrast to the sit\u00aduation with databases and model transformations, \nnone of the ex\u00adisting bidirectional languages supports any kind of incremental be\u00adhaviour.  1.3 A Change-Based \nApproach In this paper, we propose a novel change-based framework for bidirectional transformation. Instead \nof inventing from .rst prin\u00adciples to add to the already burgeoning population of bidirectional languages, \nwe focus on the preservation and propagation of user\u00adprovided editing information. In a sense, our proposal \ncan be seen as a generic optimiser of certain given state-based bidirectional frameworks: we exploit \nany locality in the editing of views, and try to translate it into incrementality in the updating of \nsources. Obviously, such preservation of locality does not hold for arbitrary transformations. Identifying \nthe semantic properties, or conditions, required forms one of the major technical contributions of this \npa\u00adper. The ultimate goal of our framework is to reduce an update of a (large) structure into one of \na (small) delta, and then outsource the hopefully much smaller problem of actually translating the update \nto an existing state-based frameworks. This step positively impacts the run-time behaviour of put , due \nto the newly gained incremen\u00adtality. Our proposal aims at modularity: there is a clearly de.ned interface \nthat decouples any editing system from our framework; and different state-based bidirectional approaches \ncan be plugged in as black boxes, whatever their manifestation as purpose-built bidirectional languages \nor syntactic/semantic transformations of unidirectional programs. As a result, a change-based bidirectional \nframework arises automatically from a given state-based one, while preserving the bidirectional properties \nof the latter. We choose Haskell [26] as the language of discourse, but no speci.c language feature other \nthan algebraic datatypes is required for our technique to apply. 1.4 A Small Example As a motivating \nexample, consider the structure of a binary tree: data Tree a = Empty | Fork a (Tree a)(Tree a)  One \npossible get function from this source is an inorder traversal, which produces a list, and can be de.ned \nas follows: inorder :: Tree a . [a] inorder Empty =[] inorder (Fork a t u)= inorder t ++ [a] ++ inorder \nu For instance, a traversal of the source Fork 5 (Fork 6 (Fork 7 Empty Empty) Empty) (Fork 8 (Fork 4 \nEmpty Empty)(Fork 9 Empty Empty)) yields the list [7,6,5, 4,8,9]. Now, suppose the number 4 is deleted \nfrom this view. A state-based put function will take the edited view and try to construct a tree without \nthe deleted element; and hopefully the new source remains similar to the original one, so that unnecessary \nchanges are kept to a minimum. (Note that we have deliberately kept all the functions abstract, because \nour proposal is not dependent on any particular implementation.) The method described above takes effort \nproportional to the size of the data, not to the size of the change. Assuming a func\u00adtional cons-list, \nthe deletion of 4 involves traversing the view list to the location of the deletion, and changing only \nthe sub\u00adlist [4,8,9] rooted at that location; a more ef.cient approach is to update only the source subtree \n(Fork 8 (Fork 4 Empty Empty) (Fork 9 Empty Empty)) that is responsible for generating the view fragment \n[4,8,9]. That is to say, the bidirectional updating should be incremental. Better still, in the case \nof lists, where a deletion is local and does not induce subsequent changes to a substruc\u00adture, a more \nre.ned analysis may discover that only the subtree (Fork 4 Empty Empty) is really affected by the edit, \nand updating this is suf.cient. We were able to conclude above that the view sublist [4,8,9] corresponds \nto the source subtree (Fork 8 (Fork 4 Empty Empty) (Fork 9 Empty Empty)), because all elements in the \nformer can be found in the latter, and the get function (inorder traversal) hap\u00adpens to have certain \nproperties that allow structure correspondences to be derived from element correspondences. In the sequel, \nwe will discuss in detail how get functions that support incremental up\u00addates can be identi.ed; and present \na constructive method for per\u00adforming the said update in a change-based framework. Assuming a fairly \nbalanced source tree, the complexity of our algorithm is O (m \u00d7 log n + fm) where n is the size of the \nsource tree, m is the size of the affected source part, and f is the complexity function of a state-based \nput function. The update itself takes time propor\u00adtional to m; but it takes m \u00d7 log n time to locate \nthe target source location. The rest of the paper is structured as follows. Section 2 gives the overall \nsetting of change-based bidirectional frameworks. Section 3 discusses the propagation of locality of \nview editing to the level of source updating, and Section 4 presents a constructive method for deriving \nchange-based put functions. We then re.ne the technique for list views (Section 5), and discuss related \nissues (Section 6), be\u00adfore surveying related work (Section 7) and concluding (Section 8). 2. The Overall \nSetting We restrict our attention to polymorphically typed tree-structured data, and polymorphic get \nfunctions. To be explicit about our assumptions, we express our requirements in terms of a type class \nTypeFunctor: class TypeFunctor s where bimap :: (a . b) . (c . d) . sac . sbd arity :: sab . Int select \n:: sab . Int . b lab :: s (Label,a) Labels . Labels data Delta s :: *.*.* close :: Delta s a b . b . \nsab The remainder of Section 2 elaborates on these requirements. 2.1 Algebraic Datatypes We restrict \nattention to regular datatypes that is, de.ned in terms of sums, products, and least .xed points. We \nassume that the type functor is (as the name suggests) a bifunctor, satisfying the functor laws bimap \nid id = id bimap (f . g)(h . k)= bimap f h . bimap g k The type functor determines the shape of the tree; \npolymorphic tree terms are then formed by taking the .xpoint (in the second argument) of this bifunctor. \ndata TypeFunctor s . Term s a = InT {outT :: sa (Term s a)} For example, the binary tree type from Section \n1.4 is represented by the following de.nitions: data TreeF a b = EmptyF | ForkF abb type Tree a = Term \nTreeF a with the obvious de.nition of bimap. In the interests of brevity, we will usually write binary \ntype constructors s in the type class TypeFunctor as single bold capitals S; and in an abuse of notation, \nwe will often omit the element type, writing just \u00b5S for Term s a. As usual, the type functor induces \na fold operator for consuming tree terms: fold :: TypeFunctor s . (sab . b) . Term s a . b foldf t = \nf (bimap id (fold f )(outT t)) The idea is that get functions should be written as polymorphic instances \nof fold. For example, with an appropriate type functor de.nition for lists: data ListF a b = NilF | ConsF \na b type List a = Term ListF a we could implement the inorder transformation as follows: inorder :: \nTree a . List a inorder t = fold step t (InT NilF) where step EmptyF = id step (ForkFaf g)= f . InT . \nConsF a . g  2.2 Tree Navigation We use functions arity :: TypeFunctor s . sab . Int select :: TypeFunctor \ns . sab . Int . b to capture the number of recursive components in an S-structure, and to select one \nof those components. For example, for binary trees we have arity EmptyF = 0 arity (ForkF )= 2 select \n(ForkF t ) 0 = t select (ForkF u) 1 = u Note that select is a partial function, and select x i is de.ned \niff 0 . i < arity x. As a shorthand, we write xi for select x i, and xi .t to denote the substitution \nof t for xi in x. We de.ne a function child to select an immediate subterm of a term: child :: TypeFunctor \ns . Term s a . Int . Term s a child t i =(outT t)i and a function zoom to select an arbitrarily deep \nsubterm, following a path represented as a list of positions: type Path =[Int] zoom :: TypeFunctor s \n. Term s a . Path . Term s a zoom = foldl child  2.3 Labelling We assume that all tree elements are \nassociated with unique labels; for this purpose we assume an abstract type Label, and a corre\u00adsponding \ntype Labels of sets of labels. (For example, the unique la\u00adbel associated with an element at a particular \nnode might be formed out of the path from the root of the tree to that node, together with a disambiguating \nindex in case there are multiple elements at the same node.) type Label = ... type Labels = Set Label \n Generally speaking, the labels should be thought of as being be\u00adhind the scenes, inaccessible to normal \nfunctions; that is why we insist that get functions should be polymorphic. In particular, we assume that \nthe get function cannot invent labels: all the labels that turn up in a view subterm originated from \nthe corresponding source term. But for the purposes of discussing labels and labelsets themselves, we \nrequire the type functor to provide a mechanism for combining the labelsets from subterms to make the \nlabelset for a term itself: lab :: TypeFunctor s . s (Label,a) Labels . Labels  Figure 1. The context-focus \nrepresentation. For example, for binary trees we have lab EmptyF = 0/ lab (ForkF (l,a) xy)= singleton \nl . x . y This forms an S-algebra, which can be exploited by a partly poly\u00admorphic fold to compute the \nlabelset of a labelled term: type LTerm s a = Term s (Label, a) labels :: TypeFunctor s . LTerm s a . \nLabels labels = fold lab We will often use the shorthand (t) to denote labels t; we extend this notation \nto S-structures of \u00b5Si trees x :: S \u00b5Si by writing (x) for labS (S labels\u00b5Si x) , and, as a shorthand, \nwrite (xx=i) for labS (S labels\u00b5Si x)i .0/ ). Splitting an S-structure into one component and the remainder \nyields an exhaustive and (at least for S-structures arising directly from a \u00b5S-structure) disjoint partition \nof the label sets: for x :: S \u00b5Si and for any valid i, (x=i).(xi) = (x) x and for s :: \u00b5S and any valid \ni, ((outT s)=i) # ((outT s)i) x where # denotes disjointness, that is, x # y =(x n y = 0/ ). Note that \n(x . y) . (y # z) . (x # z) by monotonicity of intersection, so we allow ourselves to write derivations \nof the form w . x#y . z , with a chain of inclusions, a disjointness, and a chain of containments, and \nconclude from it that w # z.  2.4 Tree Contexts As implemented by function zoom, a subtree of interest \ncan be accessed by navigating from the root of a tree and following a given path. Such a path need not \nrepresent a traversal from the root all the way to a leaf: paths may point to internal nodes in a tree. \nThe traversal of a tree following a path opens that tree into two disjoint structures: one represents \nthe subtree below the node reached by the path, known as the current focus; the other represents the \nrest of the tree and is known as the context of the focus (see Figure 1). On typing grounds, we only \nconsider as valid those paths that lead to recursive components; for example, the focus of the binary \ntree datatype above can descend to the left or the right subtree, but not to the element stored in a \nnode. We represent a context as a tree with a hole in it, denoting the location of the subtree given \nby the focus. This can be captured in terms of a type function Delta, such that Delta s a b is the type \nof one-hole contexts for sab. That is, a value of type Delta s a b is equivalent to one of type sab that \nis missing one value of type b; so the type functor should be equipped with the corresponding operation \nto close a Delta s a b around the missing b to make an sab. data Delta s :: *.*.* close :: TypeFunctor \ns . Delta s a b . b . sab Then a one-hole context for a tree consists of a list of one-hole contexts \nfor nodes; we have chosen to represent that list outermost context .rst, so that closing is a foldr. \ntype Context s a =[Delta s a (Term s a)] (<) :: TypeFunctor s . Context s a . Term s a . Term s a cs \n<t = foldr (.du . InT (close d u)) t cs For example, for binary trees, there are two ways of making \na TreeF a b that is missing a single b, one for each side of a Fork node but there is no way for an Empty \nnode to have a hole: data Delta TreeF a b = LForkF a b | RForkF a b close (LForkF a u) t = ForkF atu \nclose (RForkF a t) u = ForkF atu In fact, the context type Delta s follows directly from the structure \ns of the tree; contexts are a type-indexed data type [17], and can be de.ned generically [16, 22]. 2.5 \nSubterms We prohibit trees with junk structures that are not labelled, be\u00adcause such structures break \nthe one-to-one correspondence between subtrees of a given tree and their labelsets, a property required \nfor tracing structure transformations using labels. REQUIREMENT 1 (No Junk). Given a tree t, (child t \ni).(t), for any valid index i. D The no-junk condition enforces that the labelset of any subtree tree \nmust be a proper subset of that of its parent. For many datatypes, similar to the representation of binary \ntrees above, this no-junk condition is enforced by the constructors. But for other datatypes such as \nleaf-labelled trees data LTree a = EmptyL | Leaf a | Bin (LTree a)(LTree a)  one can construct invalid \nvalues such as Bin EmptyL (Leaf 1), where Leaf 1 is a strict subterm of Bin EmptyL (Leaf 1), but has \nthe same labelset. In this paper, we rule out datatypes like this that do not enforce the no-junk requirement. \nTree navigation induces a subterm ordering on trees. DEFINITION 2 (Subterm Ordering). Given trees r \nand t, we say r is a subterm of t, written r . t, if r = zoom t p for some p. We say that a subterm r \nis trivial if (r) = 0/. D Throughout this paper, we assume non-trivial subterms unless oth\u00aderwise stated. \nCOROLLARY 3 (Distinct Subterms). Because tree elements are uniquely labelled, when r . t (and r is non-trivial), \nthen r is in fact at the end of a unique path; that is, there is a (partial) function locate :: \u00b5S . \n\u00b5S . Path satisfying locate t r = p . r = zoom t p We say that r is at depth n in t when n = length \n(locate t r). D DEFINITION 4 (Orderedness). We say r and t are ordered, written as r ~ t, if r .t . t \n.r. D A consequence of the no-junk requirement is a close correlation between the subterm relation and \ninclusion among labelsets. COROLLARY 5 (Labels of Subterms). The subterm relationship is a re.nement \nof inclusion of labelsets: r . t .(r).(t). And for ordered trees r ~ t, the converse holds too: r .t \n.(r).(t). D Another consequence is that the labelsets of two ordered trees intersect. COROLLARY 6. We \nhave r ~ t . ((r)n(t)x0/ ) for non-trivial = trees r,t. D The operator (<) that closes a context around \na tree has a partial inverse (/), in the sense that c <r = t . t / r = c when rt; in particular, (t / \nr) <r = t and (c <r) / r = c. One might think of t / r as the result of subtracting subtree r from tree \nt. The two operators (<) and (/) associate to the right, and (/) has a higher precedence than (<); we \ncan therefore nest them: PROPOSITION 7 (Nesting). Given that r s t, then t / s <s / r <q = t / r <q. \nD Subtraction is related to substition: PROPOSITION 8. For trees r and t and position i, InT (outT r)i \n.t = r / (outT r)i <t. D Closing extends the input tree, as captured by the following mono\u00adtonicity \ncondition. PROPOSITION 9 (Monotonicity). t (c <t) D Lastly, all holes are equal. REQUIREMENT 10 (Hole \nEquality). s / s = t / t. D COROLLARY 11 (Left Unit). s / s <t = t. D  2.6 Local Editing An editing \nfunction is an endofunction edit :: v . v; we will con\u00adsider editing functions only on views. We require \nall editing func\u00adtions to be total, so that they can always be applied to a subterm of a view. We treat \nediting functions as being in some sense location\u00adindependent: they can be applied to any superterm enclosing \nthe subterm that is actually affected by the edit. DEFINITION 12 (Locality). We say an editing function \ne is local to a subterm u0 ofaview v if .u. u0 uv . ev = v / u <eu D In the above de.nition, applying \nthe local editing function e to any subterm u of v enclosing the affected subterm u0 has the same effect \nas applying the function to v. For example, as we have seen in the binary tree example, deleting 4 from \nthe sublist [4,8, 9] and combining the result with the context [7, 6,5] is the same as deleting 4 from \nthe complete view [7,6,5, 4,8,9]. From the equality of holes, we can conclude that the trivial locality \nalways holds. COROLLARY 13. Given a view v, any editing function is local to subterm v of v. D Beyond \nthe trivial one, there is certainly an ordering among differ\u00adent levels of locality, based on the subterm \nordering, which falls out from the above de.nition. In this sense, a context-sensitive (path\u00adbased) editing \nfunction, always requiring traversing from the root, .xes u0 to be v, which implies very poor locality \ncharacteristics. We will discuss an option for remedying this in Section 6.1. In our proposal, the subterm \nu0 to which an editing function is local is user-provided; our approach is based on the assumption that \nu0 is signi.cantly smaller than v. We pair the editing function with an additional function that returns \nthe affected subterm. data Edit a = E {edit :: a . a,affect :: a . a} (The above declaration creates \na polymorphic record type Edit with named .elds edit and affect, each of which is a function. The .eld \nextractors are named after the .elds; so given a value e :: Edit a, the two functions encapsulated in \nit can be retrieved as edit e :: a . a and affect e :: a . a. We require that edit e is local to affect \ne.)  2.7 Change-Based Bidirectional Frameworks A change-based bidirectional framework consists of two \nfunctions: a get function f :: s . v from source to view, and a change-based put function f < ch ::Edit \nv . s . s. We only consider get functions that are regular structural recursions, because they are more \nlikely to bene.t from our proposed improvement. We will discuss this choice in detail in Section 3.2. \nWe also rule out get functions involving duplication of labels, so that uniqueness of identi.ers is preserved. \nThe function f < :: ch is higher-order, in contrast to f < st (v,s) . s in a state-based setting. Thus \nf < ch no longer constructs an updated source from an edited view, but from the original source; any \ninformation in the edited view can be derived from the editing function and the original source. In contrast \nto an operation-based approach, f < ch is not dependent on the actual editing functions. Bidirectional \nlaws semantically equivalent to those developed for state-based bidirectional frameworks can be speci.ed \nin the new setting. Consistency f (f < ch es)= edit e (fs) Acceptability f < ch (E {edit = id})= id \n Undoability f < ch e = id. ch (e {edit =(edit e).}) . f < The relationships between different view \nvalues are expressed through explicit editing functions. For acceptability, we construct a record with \nthe identity edit (and leave the affect .eld unspeci.ed). For undoability, a record is updated with the \nleft-inverse ((edit e).) of its editing function to cancel its effect on the source. Moving from a state-based \nframework to a change-based frame\u00adwork potentially improves run-time performance, as we exploit the locality \nof updating. We look into the details in the next section. 3. Locality Preservation Incremental updates \ncan be achieved if the locality of an editing function is propagated to the source level. Figure 2 shows \nhow a get function may relate subterms in the source to subterms in the view. The idea is that the subterm \nv of the view depends only on the subterm s of the source. Furthermore, the sequences of source contexts \nsc1,...,scn and view contexts vc1,...,vcm maintain this relationship, so that vc1 <v depends only on \nsc1 <s, and so on, until vcm <... <vc1 <v depends only on scn <... <sc1 <s. Note that we can always arrange \nthe two columns in a way that both have the same length (i.e., m = n); when one subterm on one side matches \nwith multiple ones on the other side, we only need to insert a few empty contexts (since []<t = t) to \nrealign the two sides. This kind of locality preservation is determined by the get function, which de.nes \nthe connection between a view and its source. 3.1 Alignment DEFINITION 14 (Alignment). We say get function \nf aligns at subterm r of s if for all t we have f (s / r <t)= fs / fr <ft We call r an alignment position \nin s with respect to f . D When a get function f and a source s are unambiguous, the term r may be referred \nto as an alignment position, where f is said to align at r. The above de.nition not only characterizes \nthe matching of source subterms r to corresponding view subterms fr, but also a kind of isolation between \nthem. An alignment position can be seen as a resistive barrier between the construction of a subterm \nand its  Figure 2. Source-view alignment. context, through which information does not .ow. At an alignment \nposition, fr is independent of s / r and fs / fr is independent of r. The signi.cance of alignment positions \nis that they capture the mapping between the locality to fr in the view and the locality to r in the \nsource. As a result, if fr can be locally edited, then r can be locally updated: f < ii sti (fs / fr \n<v,s)= s / r <f < (v,r) st The above de.nes an optimization of an existing put function. Basically, to \nprocess an edited view fs / fr <vi, we only need to process vi (the edited fr), provided f aligns at \nr. To show that the above transformation is correct, we prove the consistency of f < sti . i f (fst< \ni (fs / fr <v, s)) = { de.nition of fst< i} f (s / r <f < (vi ,r)) st = { f aligns at r} fs / fr <f \n(f < (vi ,r)) st = { consistency of fst < } i fs / fr <v Other bidirectional properties hold as well; \nwe postpone their proofs until Section 4, where the complete solution is presented. Not all view subterms \nmatch exactly with a source subterm; sometimes we need to resort to a looser .t. DEFINITION 15. Given \na get function f , we say an alignment position s covers v if v f s. We now show some example get functions \nthat preserve dif\u00adferent degrees of alignment. Consider a function that returns the mirror image of a \ntree. mirror :: Tree a . Tree a mirror Empty = Empty mirror (Fork a l r)= Fork a (mirror r)(mirror l) \nEvery subtree in the source is an alignment position, because the constructions of the view and of the \nsource coincide. Another such function is inorder, de.ned in Section 1.4. In this case, only the right \nsubtrees are alignment positions, because the left subtrees do not correspond to subterms in the view. \nYet another example is the function spine that extracts the ele\u00adments on the spine of a tree: spine :: \nTree a . [a] spine Empty =[] spine (Fork a l r)= a : spine r In this case, all subterms of the source \nare alignment positions, though the left subtrees, which always correspond to the empty list in the view, \nare not very interesting.  3.2 Exploiting Regularity Change-based put functions are only interesting \nwhen there are plenty of alignment positions to choose from, so that view subterms can be covered tightly \n. As alignment positions represent matches between source and view constructions, for a recursive get \nfunc\u00adtion, this matching of constructions suggests a kind of structural recursion pattern. Though not \na suf.cient condition, regularity of the recursion pattern is likely to positively impact the availabil\u00adity \nof alignment positions. Thus, we focus on regular structural recursions functions that can be implemented \nas folds. For a regu\u00adlar structural recursion, a source is deconstructed in a uniform way, which leaves \nthe fold body to determine whether the construction of a view matches up. To explain the intuition behind \nhow get functions determine alignment positions, let us revisit the function spine. A fold de\u00adconstructs \na non-empty input tree into two source subterms l and r and a single element a; for the spine computation, \nthe fold body discards l and adds the element a to spine r. The recursive calls al\u00adways produce a view \nrecursive component (such as spine r) from a source subterm (r); whether the view recursive component \nso pro\u00adduced is made into a view subterm by the fold body determines the possibility of alignment. For \nexample, recursive component spine r is a subterm of a : spine r, which makes r an alignment position. \nIn this case, any edit local to spine r can be addressed by updating r. In contrast, if we de.ne spine \nas spineRev (Fork a l r)= spineRev r ++ [a] then the view construction is the opposite of the source \nconstruc\u00adtion, with the parent a at the bottom (tail end) of the list. This mis\u00adalignment manifests itself \nby causing spineRev r not to form a sub\u00adterm in the view. Any edit to the view affects a sublist including \na, which implies an update to the complete source tree. In the case of spine, a view subterm not only \nhas a recursive component as its origin, but also as its exclusive origin: spine r is copied to the view \nwithout modi.cation. This exclusivity is necessary for producing alignment positions. Consider a variant \nof spine that breaks this rule: spineRot (Fork a l r)= a : reverse (spineRot r) The recursive component \nspineRot r is changed by reverse; and its manifestation in the view depends on its context, which de\u00adcides \nhow many times reverse is applied to it. Though at each individual recursive step reverse (spineRot r) \nis a subterm of a : reverse (spineRot r), a subsequent step does not preserve this prop\u00aderty: reverse \n(spineRot r) ceases to be a subterm of b : (reverse (a : reverse (spineRot r))). In this case, only three \nalignment positions (the complete source and the root s two immediate children) exist, which is not very \ninteresting. 3.2.1 The Well-Aligning Condition We formalize the above observation into a condition on \nthe bodies of get functions de.ned as folds that guarantees the availability of alignment positions. \nDEFINITION 16 (Well-aligning). We say a fold body b is well\u00adaligning if for all x such that arity x x \n= 0, and for all non-trivial subterms u of b x, we have .i. u ~ xi ..w. b xi.w = bx / xi <w Further, \nwe say that f = fold b is well-aligning if its body b is. D We do not worry about the case when there \nare no recursive com\u00adponents in x (i.e., arity x = 0), as they are terminals in construction, and will \nnot affect alignment. There are two parts to the condi\u00adtion: the .rst part (u ~ xi) enforces that each \nnon-trivial view sub\u00adterm u has a recursive component as its origin; the second part (.w. b xi.w = b \n/ xi <w) guarantees the exclusivity of the origins (with no in.uence by external factors) the recursive \ncomponent in question is copied unchanged to the view. It is important for the expressiveness of get \nfunctions that this copying requirement only applies to selected recursive components; some, that will \nappear as subterms of bx, are taken as opaque blocks, leaving the rest to be broken up for gluing the \nblocks together. For example, consider the following functions: vlr (v,ls,rs)=[v] ++ ls ++ rs lvr (v,ls,rs)= \nls ++ [v] ++ rs lrv (v,ls,rs)= ls ++ rs ++ [v] The functions vlr, lvr, and lrv (standing for visit, left, \nright , etc) correspond to individual cases of the fold bodies for traversing binary trees in pre-, in-, \nand post-order, respectively. There are two inputs to the functions that are recursive view components, \nnamely ls and rs. Functions vlr and lvr are well-aligning, as rs is ordered with respect to all the view \nsubterms that are visited, whereas lrv is not. Generalizing the de.nition to the semantics of transformations, \nwe say that a get function is well-aligning if all cases of its body are well-aligning. By that de.nition, \npreorder, inorder, unzip, mirror, spine, .lter, map are examples of well-aligning get func\u00adtions, while \npostorder is not. (However, we will discuss how this function can be made well-aligning in Section 5.) \n 3.2.2 Availability of Alignment Positions The well-aligning property guarantees the availability of \nalignment positions; and we can state a declarative result about how they may be found. THEOREM 17. Given \na well-aligning get function f such that fs = v, we have that f aligns at subterm r of s if there exists \na non-trivial subterm u of v such that u f r. D The well-aligning condition tells us clearly that some \nselected re\u00adcursive components become subterms in the view; and the source subterms producing the selected \nsubcomponents are alignment po\u00adsitions. The key to proving Theorem 17 is to establish the fact that recursive \ncomponent fr is among those selected due to the premise u fr; this can be achieved by connecting the \nunique labels in u with those in fr. As preparation for formally proving Theorem 17, we state some properties \nregarding labels of trees under transformation. As men\u00adtioned at the beginning of Section 2, one important \nrequirement of get functions is that they do not invent labels. REQUIREMENT 18 (Conservation of Labels). \nGiven a get func\u00adtion f = fold b, we have that b does not invent labels: .x. (bx). lab x and hence, neither \ndoes f = fold b invent labels: .s. (fs).(s) D An important consequence of the fact that get functions \ndo not invent labels is that labels cannot reappear after they have been dropped during the construction \nof a view. Conversely, if a label set (v) has been generated after processing subterm r of t by the get \nfunction f (that is, rt and (v).(fr)), and (v) is still present after processing t itself (that is, (v).(ft)), \nthen (v) is present at every intermediate stage too ((v).(fs) for every s such that rst). This is a kind \nof convexity property of label sets. More importantly in what follows, a similar result holds for subterms, \nrather than their projections to label sets; but for this, we need the additional assumption that the \nget function f is well\u00adaligning. The primary result (Corollary 20) is a convexity property for terms: \ngiven sources r,t with rt such that v fr and v ft, then also v fs for any s such that rst. (In fact, \nv ft is not strictly required; (v).(ft) suf.ces.) The essential step (Lemma 19) is the one from the outermost \nterm t to one of its immediate children: if view subterm v shows up after processing a subterm r within \nthe ith child (outT t)i of t, and v is still present after processing t, then v must have come from the \nith child: v f (outT t)i. Note that, for both of these results, we make use of our implicit assumption \nthat v is non-trivial. LEMMA 19 (Maintaining terms). Suppose a well-aligning get function f = fold b. \nFor source terms r,t with r (outT t)i,ifv f r andv ft,thenalsov f (outT t)i. PROOF. Let x = S f (outT \nt), so that ft = bx and f (outT t)i = xi. Since b is well-aligning, and v is a non-trivial subterm of \nbx, there exists a j such that v ~ xj = f (outT t)j. In fact, this j must be i: (v).{ labels of subterms \n(Corollary 5); v fr, by assumption} (fr) .{ f does not invent labels} (r) .{ r (outT t)i; Corollary \n5 again} ((outT t)i) # { disjointness of labels} ((outT t)=i) x.{ f does not invent labels; monotonicity \nof intersection}((S f (outT t))=i) x = { de.nition of x} (x=i) x and so (v) # (x=i), and hence (v).(xi) \nby disjointness of labels. xFinally, v ~ xi and (v).(xi) imply v xi, by Corollary 5. D COROLLARY 20 (Term \nconvexity). Suppose a well-aligning get function f = fold b. For source terms r, twithr t,ifv frand v \nft,thenalsov fsforeveryssuchthatr s t. PROOF. The proof is by induction over the length of locate t r. \nThe base case is when the path is empty, so r = t; then the lemma is trivially true. For the inductive \ncase, assume the statement is valid for paths of length n. Suppose that rt, and that r is at depth n \n+ 1 in t (so that r (outT t)i for some unique index i, and locate (outT t)ir has length n), and that \nv fr and v ft. By Lemma 19, we get vf (outT t)i; then by induction we get v fs for every s with rs (outT \nt)i too; and the .nal case s = t trivially holds. D Theorem 17 follows directly from the following result: \ngiven a well-aligning get function f , and sources r,s such that rs, if there exists any view subterm \nv such that v fr and v fs, then f aligns at subterm r of s. (Again, we assume that v is non-trivial.) \nLEMMA 21 (Get alignment). Given a well-aligning get function f , sources r,twithr t,andviewvsuchthatv \nfrandv ft, then f aligns at subterm r of t. PROOF. Again, by induction over the length of locate t r. \nThe base case is when the path is empty; then t = r and the theorem is trivially true (since f necessarily \naligns at the root t of source t). For the inductive case, we assume that the statement is valid for \npaths of length n; we are given terms r,t with rt and r at depth n + 1 in t, and a term v with v fr and \nv ft, and we have to show that f aligns at subterm r of t. Suppose that r is within the i th child of \nt, that is, rs where s = (outT t)i. Then by Corollary 20, we have v fs, and by induction, f aligns at \nsubterm r of s. Let x = S f (outT t), so that ft = bx and f (outT t)i = xi. Because b is well-aligning \nand v bx, there exists a j such that v ~xj and b xj .w = bx / xj <w for any w. In fact, that j must be \ni, by the same argument as in the proof of Lemma 19. In particular, fs = xi bx, a fact that we shall \nuse below. Finally, we show that f aligns at subterm r of t. For an arbitrary source term p, we have: \nf (t / r <p) = { since rst} f (t / s <(s / r <p)) = { Proposition 8 s =(outT t)i } f (InT (outT t)i .(s/r.p)) \n= { evaluation rule for f = fold b} b (S f (outT t)i .(s/r.p)) = { naturality of select} b (S f (outT \nt))i .(f (s/r.p)) = { b is well-aligning; discussion above} b (S f (outT t)) / f (outT t)i <f (s / r \n<p) = { evaluation rule for f again; s =(outT t)i } ft / fs <f (s / r <p) = { induction} ft / fs <(fs \n/ fr <fp) = { nesting} ft / fr <fp D So far, we have established well-alignment as a suf.cient con\u00addition \nfor the availability of alignment positions (De.nition 16), and proved a declarative result about how \nalignment positions can be found (Theorem 17). Next, we move on to devise a construc\u00adtive method of .nding \nalignment positions, and deriving a change\u00adbased put function based on this method. 4. Change-Based Put \nFunctions The derivation of a put function is divided into three steps: (i) .nding an alignment position \ncovering the edited view subterm; (ii) using a state-based put function to map the view subterm to a \nsource subterm; and (iii) merging the original source context with the updated source subterm. The key \npart of this process is step (i); the other two follow on quite naturally. Taking the previous result, \nwe know that a source subterm is an alignment position if there is a corresponding subterm in the view. \nA standard way of estab\u00adlishing the source/view correspondence semantically is to trace the uniquely \nidentifying labels.  4.1 Labelling and Re.ecting Unique identi.ers are created using paths in the source, \nfrom the root to the node constructors of the elements. As a result, a node is at the root position of \nthe subterm identi.ed by the path. As far as get functions are concerned, an element and its label form \nan atomic unit; an element in the view originates from an element in the source associated with the same \nlabel. (It is worth noting that the labels only represent paths in the source, not those in the view.) \nGiven an edit-affected view subterm v, a sensible alignment position should include all the labels in \n(v); the path leading to such a source subterm is the maximum common pre.x mcp (v) of all the paths to \nnodes with these labels. Consider a simple example with mirror as the get function (see Figure 3). Note \nthat the labels in the source the list component of each pair in the diagram are copied over to the view. \nSuppose we insert a new node at the location labelled [1] in the view, af\u00ad  Figure 3. Using mirror as \na get function. fecting the element 68 at location [1] and the locations below it [[1,1],[1, 2]]. (Note \nthat we don t require a concrete label for the newly inserted node since it will not contribute to the \nidenti.cation of the affected source.) The maximum common pre.x of the af\u00adfected labels [[1],[1, 1],[1,2]] \nis [1]. Now tracing the pedigree of the path [1] back to the source, we conclude that it is the subtree \nwith root element 68 that needs to be changed. The key to demonstrating the correctness of the above \nprocess is to show that the subset relation between label sets corresponds to the subterm relation between \ntrees. LEMMA 22. Given a well-aligning get function f = fold b, and source terms s,twiths t,andviewtermv,ifv \nftand (v).(s)thenv fs. PROOF. Again, by induction over the length of locate t s. The base case is when \nthe path is empty; then s = t, and the result trivially holds. For the inductive case, assume that the \nresult holds for paths of length n, and that s is at depth n + 1 in t. Let i be such that s (outT t)i, \nso that locate (outT t)is has length n. We will show that vf (outT t)i; then we can conclude v fs by \nappeal to the inductive hypothesis. Let x = S f (outT t), so ft = bx and f (outT t)i = xi. Since v is \na non-trivial subterm of bx, and b is well-aligning, there exists a j such that v ~ xj. By the usual \nargument, that j must be i: (v) .{ assumption} (s) .{ hypothesis, and Corollary 5} ((outT t)i) # { \ndisjointness of labels} ((outT t)=i) x .{ f does not invent labels} ((S f (outT t))=i) x = { de.nition} \n(x=i) x So v ~ xi. Moreover, (v).(xi), by disjointness of labels, since by assumption we have v ft \nand hence (v).(ft) = (bx).(x), and we have just shown that (v) # (x=i). Therefore, by Corollary 5 we \nx conclude v xi = f (outT t)i. D As a side remark, so far we have been oblivious to the fact that the \nsource and view nodes are now labelled, and have assumed that the get and put functions work uniformly \non them. This is certainly correct given parametrically polymorphic datatypes and functions; free theorems \n[30] provide the guarantee we need. It is straightforward to relax this fully-parametric type restriction \nto constrained polymorphic types. For example, we can use equality in the transformation by introducing \nthe following: f :: Eq a . sa . va f < :: Eq a . (va,sa) . sa st and a generic instance to bypass the \nlabels: instance Eq a . Eq (Label,a) where (=)( ,a)( ,b)= a = b This kind of generic de.nition is all \nthat is required to introduce constrained polymorphism. For example, consider a function that .lters \nthe labels of a tree and returns them as a list. .lterT :: Eq a . (a,Tree a) . [a] .lterT (x,Empty) =[] \n.lterT (x,Fork a l r)= if a = x then lr else a : lr where lr = .lterT l ++ .lterT r Function .lterT is \nwell-aligning, and our technique is applicable without modi.cation. It is worth mentioning that labelling \ntree elements uniquely and exploiting parametricity to establish connections between source and view \nis not limited to .nding subterm correspondence. In [28], get functions are applied to source values \nwith elements replaced by labels, which allows one to conduct a kind of forensic examina\u00adtion of the \ntransformation, determining its effect without examining its implementation; with such information a \nput function can be constructed. We will discuss in more detail in Section 7 the con\u00adnection between \nour technique and the approach in [28].  4.2 The Change-Based Put Function We are now ready to present \nthe change-based put function. For any fst <, a generic f < ch function can be de.ned as follows: f < \nch :: Edit v . s . s f < ch es = s / r <(f < . ((edit e . f ) /id)) r st where r = zoom i s i = mcp \n(affect e (fs)) The function f < ch maps an edit operation on views, e, into an update operation on \nsources. The evaluation of f < ch is illustrated in Figure 4, which shows how an updated source is obtained \nby an indirect route. A source is .rstly mapped into a view via f , with the affected view subterm of \nthe edit extracted via affect e. After that, the labels in the affected view subterm are collected and \nare used to identify an alignment position, r, covering the affected view subterm. A view of the alignment \nposition is then constructed by applying f , and is edited before the state-based put function f < maps \nit into st an updated source subterm. Finally, the standard split operator, /, with type (a . b) . (a \n. c) . (a . (b,c)), is used to produce a pair containing the result of applying two functions to a value. \nHere it combines the newly created source subterm with the original context that remains unchanged. (The \nstraightforward re-labelling of the newly generated source subterm with i as the root label is omitted.) \nAs shown in Figure 4, there are several passes across the source/view boundary, and apart from the initial \nget function application, all of them concern only the edit-affected subterms. Assuming the editing and \nget functions have no worse run\u00adtime performance than the put function, the complexity of f < ch is O \n(m \u00d7 log n + cm) where n and m are the sizes of the source s and the change r, and c is the complexity \nfunction for fst <. Note that affect e (fs) will have been executed prior to the put function execution, \nand is not included in the performance analysis. The cost of computing s / r is not considered because \nthe context s / r can be computed together with the focus r when the zooming is performed. The m \u00d7 log \nn part of the above complexity function comes from the computation of mcp, where m labels of size log \nn need to be processed. The function f < ch is expected to preserve the bidirectional prop\u00aderties of \nfst <. This is established when f < ch operates at alignment po\u00adsitions. THEOREM 23. Given a well-aligning \nget function f such that fs = v, then for all source subterms r of s and view subterms u of v, zoom (mcp \n(u)) s is the smallest alignment position covering u. PROOF. By de.nition, we have (u).(zoom (mcp (u)) \ns). (u).(zoom (mcp (u)) s). u fs . (zoom (mcp (u)) s) s . { lemma 22} uf (zoom (mcp (u)) s) . u fs . \n(zoom (mcp (u)) s) s  . { theorem 17} f aligns at subterm zoom (mcp (u)) s of s   Also from the de.nition \nof mcp, there exists no r such that r -zoom (mcp (u)) s and (u).(r). Thus, zoom (mcp (u)) s is the smallest \nalignment position covering u. D We can state the bidirectional properties of f < ch . THEOREM 24 (Consistency). \nf (f < ch es)= edit e (fs) PROOF. f (f < ch es) = { de.nition of f < ch } f (s / r <(f < . ((edit e \n. f ) /id)) r)) st = { r is an alignment position} fs / fr <(f . f < . ((edit e . f ) /id)) r) st = \n{ consistency of fst < } fs / fr <(edit e . f ) r = { r covers affect e (fs), and locality of edit} edit \ne (fs / fr <fr) = { r is an alignment position} edit e (f (s / r <r))) = { cancellation} edit e (fs) \n D For acceptability, we need an identity edit that does not change the view. THEOREM 25 (Acceptability). \nf < ch (E {edit = id})= id. PROOF. f < ch (E {edit = id}) s = { de.nition of f < ch } s / r <(f < . \n((id . f ) /id)) r st = { acceptability of fst < } s / r <r = { cancellation} s D Undoability involves \ninverting an edit as a function. THEOREM 26 (Undoability). f < == ch (e {edit (edit e).}) . f < ch e \n id. PROOF. (f < ch (e {edit =(edit e).}) . f < ch e) s = { de.nition of f < ch , and constant affect \nin e}s / r <(f < . ((edit e).. f /id)) ((f < . (edit e . f /id)) r) st st = { de.nition of /} s / r <f \n< (((edit e).. f . fst <) ((edit e . f ) r, r), st f < ((edit e . f ) r,r)) st  Figure 4. Change-based \nput execution, showing relationship between source (top) and associated view (bottom) during transformation. \n= { consistency of fst < }s / r <f < (((edit e).. edit e . f ) r,f < ((edit e . f ) r,r)) st st = { (edit \ne).. edit e = id} s / r <f < (fr, f < ((edit e . f ) r, r)) st st = { undoability of fst < } s / r <r \n= { cancellation} s D 5. More Re.ned Locality As we have seen, the performance of our proposal depends \non the height of the source tree and the size of the affected region (i.e., the degree of locality of \nthe edit). The former is clearly beyond the control of any bidirectional framework, and the latter is \nlargely decided by the structure of the view. For fairly balanced trees, the majority of nodes are deep \nin the structure, so it is reasonable to suppose that the majority of edits will be too; given structure \nalignment, this implies a good degree of locality. A problem arises when the view tree is skewed, such \nas in a list, since the likelihood that a node appears at any depth is the same. If a node high in the \nstructure is affected by an edit, such as a deletion, the affected subtree could be rather large. This \nproblem has already manifested itself in our binary-tree traversal example (see Section 1.4, where it \nis excessive to mark the whole sublist [4, 8,9] as affected). A better alternative is to recognize the \nsublist [8,9] as unaffected context too. Another example is post-order tree traversal, where any non\u00adempty \nsublist of the view contains the head of the source, which results in very poor locality preservation. \nAs a matter of fact, post\u00adorder traversal is excluded through the well-aligning condition. Nevertheless, \nbeing a special kind of tree, lists enjoy a number of unique properties. We notice that unlike general \ntrees, where a separate datatype is needed for contexts, the context type for lists is isomorphic to \nthe list type itself, and so we can simply use lists as both contexts and foci, and use the append function \n(++) as the close function (<). Given the symmetry of (++), either the context or the focus can be edited, \nand all the de.nitions and results dualize. For example, consider the reverse function. Editing the front \nof the list view can be localized to a pre.x of the view and mapped back to a suf.x of the source. As \na result, it makes sense to try to capture a lower (right) bound of an edit-affected sublist, in addition \nto the upper (left) bound. Instead of splitting a list view into a pre.x (context) and a suf.x (focus), \nwe can now see it as l1 ++ l2 ++ l3. To re.ect this specialization, we overload the in.x operator < and \nde.ne its list version as (l1,l3) <l2 = l1 ++ l2 ++ l3. (In a sense, this is treating lists as semi-structured \ndata, similar to traditional treatments of relational databases and graphs, and not as an algebraic datatype.) \nAll the other de.nitions developed for general trees remain valid. Now instead of always picking out \na complete suf.x or pre.x, we can mark an interior list segment as affected by editing, and the same \nde.nition of f < ch directly applies. For example, deleting 4 from [7,6,5,4,8, 9] only affects the interior \nsegment [4], leaving both contexts [7,6,5] and [8,9] unaffected. Correspondingly, the alignment positions \nnow match subterms in the source with seg\u00adments (rather than with tails) in the view. 6. Discussion 6.1 \nContext-Sensitive Editing The editing system we have looked at so far is context-independent; this is \nparticularly convenient for local editing, since the same edit can be applied both to a structure and \nto its subterms. For tree\u00adstructured views, it is sometimes useful to provide a full (or partial) path \nto the intended editing location, to narrow down the search. In this case, the editing becomes context \nsensitive, because the starting point of the path matters. Consider a path-based editing system. type \nEditP t = {edit :: Path . t . t,affect :: Path . t . Path} An edit operation now .nds its target in \na structure following a path, and produces the edited structure together with the path leading to the \naffected subterm. Note that these paths in the view should not be confused with labels of nodes that \nrepresent paths in the source. The de.nition of f < ch can be adapted for the new editing system. We \nseparate all interesting steps into where clauses to facilitate explanation. f < ch :: Edit v . Path \n. s . s i fch < eps =(s / r) <f < (edit e p3 u,r) where st v = fs p1 = affect e p v u = zoom p1 v --affected \nsubterm i = mcp (u) r = zoom i s ui = fr ii p2 = travelUntil (p1,v) u--path to u Just p3 = stripPre.x \np2 p1 --relative editing path Note that we keep the path information of the edit explicit, so that it \ncan be modi.ed along with the shifting of focus. Compared with the context-independent version, there \nare a few additional steps. As the editing function returns a path locating the affected subterm, we \nneed to open the view to get to it (u in the third clause above). A bigger challenge posed by this context-sensitivity \nis to .nd a relative editing path when the starting point is moved to the root of subterm ui. We denote \nthe path from the root of a structure x to its i subterm y as x . y. Since we know the subterm relations \nuuv among the affected subterm, the view of the alignment position and the complete view, the path p3 \n= ui . u is the difference between p1 = v . u and p2 = v . ui. We already know p1; traversing i p1 until \nthe root of ugives us p2, before we can perform path arithmetic to recover the correspondence between \nthe path and structure inputs of edit e. Function travelUntil follows a path down a tree until it reaches \na given subtree; the part of the path travelled is returned as the output. Function stripPre.x is a standard \nHaskell function of type Eq a . [a] . [a] . Maybe [a] that strips the .rst input from the second one; \nsince we know that p2 is a pre.x of p1, the execution of stripPre.x p2 p1 is always going to succeed. \nA concern here is that the additional computation does impose a performance overhead: travelling the \npath takes time linear in the height of the view tree. Clearly, the multiple traversals in the above \ncode can be combined; we have presented them in separate steps for clarity.  6.2 Totality of Put Functions \nThe proofs of bidirectional properties in Section 4.2 are done in a total setting, where the state-based \ntransformations are assumed to execute successfully when given well-de.ned terms. Since the get functions \nare regular structural recursions, it is reasonable to expect that if the execution over a complete source \nis successful, then the evaluation over subterms will also succeed. Establishing a similar safety property \nfor put functions is much harder; put functions are often partial due to the con.icts between the edited \nview and the original source (though advanced type systems may help to specify their domains [10]), and \nusually do not expose their semantics other than through the bidirectional laws. Since our approach employs \nstate-based bidirectional frame\u00adworks as black-boxes, it is impossible to conclude that the ap\u00adproach \nis universally safe. Nevertheless, there are patterns to fol\u00adlow: most bidirectional frameworks create \nput functions that try to trace the original get execution backwards, and recursively de\u00adconstruct their \nview and source inputs in parallel, until a discrep\u00adancy is encountered, which is the point where the \nput function has to either resolve the con.ict or fail. Our change-based approach re\u00adduces the scope \nof a put function by removing a context that is known to be unaffected by the edit. Consequently, we \nexpect that failures, if there are any, happen within the processing of the align\u00adment position, and \nso moving from a state-based approach to the change-based approach preserves the safety property. 7. \nRelated Work Incremental updates have been studied in the context of model transformation, for improving \nspeed [13], and for achieving more re.ned semantics [8]. Similar to our design, both of these ap\u00adproaches \nalso require additional speci.cation of the effect of an edit. In contrast to tree-like datatypes, models \nare loosely\u00adconnected untyped graphs, which are more easily divided into independent fragments to be \nupdated separately; whereas our well\u00adaligning property of typed and overlapping subtrees is much harder \nto establish. In their work on graph transformations via structural recursion, Hidaka et al. [15] use \na simpli.ed assumption that dif\u00adferent parts of the graph are always independent. As a result, the structural \nrecursion is effectively reduced to a concatMap opera\u00adtion. However, this assumption is not valid in \ngeneral; and as a result, the acceptability property does not hold in their framework. The concept of \nan alignment position is also known as an exclu\u00adsive data source in the database literature [9], and \nis used to prevent side effects on the view that is edited (similar to our consistency requirement). \nExclusive data sources are commonly computed by establishing lineages between a database and its view \nthrough trac\u00ading identi.ers of data [5]. Databases are typically large, so it is never practical to process \nthem completely for an update; as a re\u00adsult, identifying exclusive data sources is not considered as \nan opti\u00admization, but the core part of the update. Despite the obvious sim\u00adilarity of these ideas, techniques \ndeveloped for databases are not applicable in our setting, due to the very different representations \nof data and transformations. Despite being in a unidirectional setting, the concept of adap\u00adtive programming \n[1] is closely related to incremental updates. The basic idea of adaptive programming is to build up \na complete input\u00adoutput dependency graph for a given input, from some syntactic an\u00adnotations to the program. \nBased on the dependency, a correspond\u00ading output change can be derived from an input change, which hopefully \nhas a much better run-time performance compared to re\u00adexecuting the program with the new input. However, \nit is not ob\u00advious how the technique can be applied in a bidirectional setting, where we need to derive \nan input change from an output change. Nevertheless, this would be an interesting future direction to \nex\u00adplore. Explicit caching of intermediate computations is another way of achieving incremental execution. \nIf an input change can be de\u00adscribed as a loop increment, an incremental version of the program under \nthe change can be constructed and bene.t from previously computed results [20]. In a sense, the contexts \nin our approach can be seen as cached values, and the focuses can be seen as incre\u00adments. Since in our \ncase the closing operation (<) that combines the cached result and the newly computed increment is not \ndepen\u00addent on the transformations, we do not need to improve the trans\u00adformations to achieve incrementality. \nIndexed elements in source structures and parametricity arising from polymorphic get functions are the \nkey components of se\u00admantic bidirectionalization [28] deriving a put function without inspecting the \nsyntactic de.nition of the get function. Similar to our approach, the indices in [28] are unique and \ncannot be created by get transformations, so that individual elements in the view can be mapped back \nto their source origins, as can any edits. Neverthe\u00adless, there has not been any attempt to derive structure \ncorrespon\u00addences from the element correspondences, as we do in this paper. Consequently, editing view \nstructures is not permitted in seman\u00adtic bidirectionalization, while our approach only optimizes a given \nput function instead of creating one. Maintaining proper alignment between ordered source and view is \nitself an important semantic issue of bidirectional programming, as view editing may cause mismatchings \nbetween view/source data. Matching lenses [3] aims at addressing this issue without hard\u00adwiring alignment \nstrategies into bidirectional systems. Though our use of alignment in this paper is intended for optimization \npur\u00adposes, we note that a change-based put function should preserve the alignment semantics of the state-based \nput function it uses, because the unaffected context that is not processed will have no impact on alignment. \nThe connection between alignment and incrementality is spec\u00adulated in [18]. However, as far as we are \naware, there has not been any concrete proposal before. 8. Conclusions We have developed a change-based \nbidirectional transformation framework that focuses on changes rather than data. The technique we have \npresented is very general, and most existing state-based frameworks may draw bene.ts from its adoption, \nso long as the get function is well-aligning. This condition is semantic; there is no restriction on \nthe language that is used for implementation. In the future, we plan to look at ways of dealing with \nmonomor\u00adphic functions, which are widely used in XML transformations. In contrast to the polymorphic \ncase presented in this paper, the la\u00adbelling of tree nodes does require some adjustment of a state-based \nbidirectional framework. It will be interesting to see whether such adjustments can be made in a systematic \nway. Acknowledgements We are grateful to Ralf Hinze for his valuable comments on an early draft of the \npaper; and the ICFP reviewers for their detailed and insightful reviews. The work was partly conducted \nwhen the .rst author was at the University of Oxford supported by the UK EPSRC grant Generic and Indexed \nProgramming (EP/E02128X). References [1] U. A. Acar, G. E. Blelloch, and R. Harper. Adaptive functional \nprogramming. ACM Transactions on Programming Languages and Systems, 28:990 1034, November 2006. [2] F. \nBancilhon and N. Spyratos. Update semantics of relational views. ACM Transactions on Database Systems, \n6(4):557 575, 1981. [3] D. M. Barbosa, J. Cretin, N. Foster, M. Greenberg, and B. C. Pierce. Matching \nlenses: alignment and view update. In International Conference on Functional Programming (ICFP), pages \n193 204, New York, NY, USA, 2010. ACM. [4] A. Bohannon, J. N. Foster, B. C. Pierce, A. Pilkiewicz, and \nA. Schmitt. Boomerang: Resourceful lenses for string data. In Principles of Programming Languages, pages \n407 419, New York, NY, USA, Jan. 2008. ACM. [5] Y. Cui, J. Widom, and J. L. Wiener. Tracing the lineage \nof view data in a warehousing environment. ACM Transactions on Database Systems, 25:179 227, June 2000. \n[6] K. Czarnecki, J. N. Foster, Z. Hu, R. L\u00a8ammel, A. Sch\u00a8urr, and J. F. Terwilliger. Bidirectional transformations: \nA cross-discipline perspective. In Theory and Practice of Model Transformations, pages 260 283, Berlin, \nHeidelberg, 2009. Springer-Verlag. [7] U. Dayal and P. A. Bernstein. On the correct translation of update \noperations on relational views. ACM Transactions on Database Systems, 7(3):381 416, 1982. [8] Z. Diskin, \nY. Xiong, and K. Czarnecki. From state-to delta-based bidirectional model transformations. In Theory \nand Practice of Model Transformations, ICMT 10, pages 61 76, Berlin, Heidelberg, 2010. Springer-Verlag. \n[9] L. Fegaras. Propagating updates through XML views using lineage tracing. In International Conference \non Data Engineering, pages 309 320, Los Alamitos, CA, USA, 2010. IEEE Computer Society. [10] J. N. Foster, \nM. B. Greenwald, J. T. Moore, B. C. Pierce, and A. Schmitt. Combinators for bidirectional tree transformations: \nA linguistic approach to the view update problem. ACM Transactions on Programming Languages and Systems, \n29(3), May 2007. Preliminary version in POPL 05. [11] J. N. Foster, B. C. Pierce, and S. Zdancewic. Updatable \nsecurity views. In Computer Security Foundations, pages 60 74, Washington, DC, USA, 2009. IEEE Computer \nSociety. [12] J. N. Foster, A. Pilkiewicz, and B. C. Pierce. Quotient lenses. In International Conference \non Functional Programming (ICFP), pages 383 396, New York, NY, USA, 2008. ACM. [13] H. Giese and R. Wagner. \nFrom model transformation to incremental bidirectional model synchronization. Software and Systems Modeling, \n8:21 43, 2009. 10.1007/s10270-008-0089-9. [14] G. Gottlob, P. Paolini, and R. Zicari. Properties and \nupdate semantics of consistent views. ACM Transactions on Database Systems, 13(4):486 524, 1988. [15] \nS. Hidaka, Z. Hu, K. Inaba, H. Kato, K. Matsuda, and K. Nakano. Bidirectionalizing graph transformations. \nIn International Confer\u00adence on Functional Programming (ICFP), ICFP 10, pages 205 216, New York, NY, \nUSA, 2010. ACM. [16] R. Hinze and J. Jeuring. Functional Pearl: Weaving a web. Journal of Functional \nProgramming, 11(6):681 689, nov 2001. [17] R. Hinze, J. Jeuring, and A. L\u00a8oh. Type-indexed data types. \nScience of Computer Programming, 51(1-2):117 151, 2004. [18] M. Hofmann, B. Pierce, and D. Wagner. Symmetric \nlenses. In Principles of Programming Languages (POPL), POPL 11, pages 371 384, New York, NY, USA, 2011. \nACM. [19] Z. Hu, S.-C. Mu, and M. Takeichi. A programmable editor for developing structured documents \nbased on bidirectional transforma\u00adtions. In Workshop on Partial Evaluation and Program Manipulation (PEPM), \npages 178 189, New York, NY, USA, 2004. ACM. [20] Y. A. Liu, S. D. Stoller, and T. Teitelbaum. Static \ncaching for incremental computation. ACM Transactions on Programming Languages and Systems, 20:546 585, \nMay 1998. [21] K. Matsuda, Z. Hu, K. Nakano, M. Hamana, and M. Takeichi. Bidirectionalization transformation \nbased on automatic derivation of view complement functions. In International Conference on Functional \nProgramming (ICFP), pages 47 58, New York, NY, USA, 2007. ACM. [22] C. McBride. The derivative of a regular \ntype is its type of one-hole contexts (extended abstract). http://strictlypositive.org/ diff.pdf, University \nof Durham, 2001. [23] L. Meertens. Designing constraint maintainers for user interaction. ftp://ftp.kestrel.edu/pub/papers/meertens/dcm.ps, \nCWI, Amsterdam, 1998. [24] S.-C. Mu, Z. Hu, and M. Takeichi. An injective language for reversible computation. \nIn Mathematics of Program Construction, volume 3125 of Lecture Notes in Computer Science, pages 289 313. \nSpringer, 2004. [25] H. Pacheco and A. Cunha. Generic point-free lenses. In C. Bolduc, J. Desharnais, \nand B. Ktari, editors, Mathematics of Program Construction, volume 6120 of Lecture Notes in Computer \nScience, pages 331 352. Springer Berlin / Heidelberg, 2010. [26] S. Peyton Jones, editor. Haskell 98 \nLanguage and Libraries: The Revised Report. Cambridge University Press, 2003. [27] P. Stevens. Bidirectional \nmodel transformations in QVT: semantic issues and open questions. Software and Systems Modeling, 9:7 \n20, 2010. [28] J. Voigtl\u00a8ander. Bidirectionalization for free! (Pearl). In Principles of Programming \nLanguages (POPL), pages 165 176, New York, NY, USA, 2009. ACM. [29] J. Voigtl\u00a8ander, Z. Hu, K. Matsuda, \nand M. Wang. Combining syntactic and semantic bidirectionalization. In International Conference on Functional \nProgramming (ICFP), pages 181 192, New York, NY, USA, 2010. ACM. [30] P. Wadler. Theorems for free! In \nFunctional Programming Languages and Computer Architecture, pages 347 359, New York, NY, USA, 1989. ACM. \n[31] M. Wang, J. Gibbons, K. Matsuda, and Z. Hu. Gradual re.nement: Blending pattern matching with data \nabstraction. In C. Bolduc, J. Desharnais, and B. Ktari, editors, Mathematics of Program Construction, \nvolume 6120 of Lecture Notes in Computer Science, pages 397 426. Springer Berlin / Heidelberg, 2010. \n    \n\t\t\t", "proc_id": "2034773", "abstract": "<p>A bidirectional transformation is a pair of mappings between <i>source</i> and <i>view</i> data objects, one in each direction. When the view is modified, the source is updated accordingly. The key to handling large data objects that are subject to relatively small modifications is to process the updates incrementally. Incrementality has been explored in the semi-structured settings of relational databases and graph transformations; this flexibility in structure makes it relatively easy to divide the data into separate parts that can be transformed and updated independently. The same is not true if the data is to be encoded with more general-purpose algebraic datatypes, with transformations defined as functions: dividing data into well-typed separate parts is tricky, and recursions typically create interdependencies. In this paper, we study transformations that support incremental updates, and devise a constructive process to achieve this incrementality.</p>", "authors": [{"name": "Meng Wang", "author_profile_id": "81351595589", "affiliation": "Chalmers Univeristy, Goteborg, Sweden", "person_id": "P2801450", "email_address": "wmeng@chalmers.se", "orcid_id": ""}, {"name": "Jeremy Gibbons", "author_profile_id": "81339501222", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P2801451", "email_address": "jeremy.gibbons@cs.ox.ac.uk", "orcid_id": ""}, {"name": "Nicolas Wu", "author_profile_id": "81488641214", "affiliation": "Well-Typed LLP, Oxford, United Kingdom", "person_id": "P2801452", "email_address": "nick@well-typed.com", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034825", "year": "2011", "article_id": "2034825", "conference": "ICFP", "title": "Incremental updates for efficient bidirectional transformations", "url": "http://dl.acm.org/citation.cfm?id=2034825"}