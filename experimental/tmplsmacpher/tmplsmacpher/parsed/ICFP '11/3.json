{"article_publication_date": "09-19-2011", "fulltext": "\n Functional Programming through DeepTime: Modeling the .rst complex ecosystems on Earth Experience Report \nEmily G. Mitchell Universityof Cambridge&#38;British Antarctic Survey, Cambridge,UK ek338@cam.ac.uk Abstract \nThe ecology of Earth s .rst large organisms is an unsolved prob\u00adlem in palaeontology. This experience \nreport discusses the deter\u00admination of which ecosystems could have been feasible, by con\u00adsidering the \nbiological feedbacks within them. Haskell was used to model the ecosystems for these .rst large organisms \n the Edi\u00adacara biota.Forveri.cationofthe results,the statistical languageR wasused. NeitherHaskellnorRwouldhavebeensuf.cientforthis \nwork Haskell s libraries for statistics are weak, whileRlacks the structure for expressing algorithms \nin a maintainable manner. This work is the .rst to quantify all feedback loops in an ecosystem, and has \ngenerated considerable interest from both the ecological and palaeontological communities. Categories \nand Subject Descriptors D.3[Software]: Program\u00adming Languages General Terms Languages, Experimentation \nKeywords Haskell,R,Palaeontology, Ecology 1. Introduction Complex life on Earth evolved 600 million years \nago, after billions of years of simple microbial life. The .rst complex organisms were the Ediacara biota, \nwhich lasted only 30 million years a blink of a geological eye. The Ediacara biota were shortly followed \nby the Cambrian Explosion, bringing with it the precursors to modern life, which have dominated the Earth \never since. Understanding whythese Ediacara biotafailed cangive cluestohow ecosystems function. These \nunsuccessful organisms are unlikeanything else, so manytraditional techniques from biology and palaeontology \ndo not apply. Computer modelling cangiveus newinsightsbyallowing us to test theories, including some \nthat have been debated for over 40 years. Rangeomorphs are a group of Ediacaran species, with a fractal \nbranching structure, which maximizes surface area see Figure 1. Organisms that maximize their surface \narea normally feed in one of three ways: 1. Photosynthetic -converting sunlight to energy [8]. 2. Suspension \nfeeding -.ltering plankton from the water column [6]. 3. Osmotrophic -absorbing organic carbon directly \nthrough their membrane walls [7].  We now know that most rangeomorphs lived in the deep ocean, so can \nthave been photosynthetic [15],but the debate rages on be\u00adtween the other two strategies. Using Haskell,Imodelled \npotential Ediacaran ecosystem as graphs, with species as nodes and feeding relationships as edges [10]. \nFrom these graphs the feeding strate\u00adgies corresponding to feasible ecosystems were determined. Most \nrangeomorphs were found to be osmotrophic. How fossils are spatially distributed in the rock gives clues \nto their interactions in life. These distributions were used to validate my models by comparing feasible \necosystems to those suggested by the actual fossils. To extract a graph from spatial positions I used \ntwo approaches. Firstly, the programming language R [11] was used to compare the actual locations of \nfossils against a ran\u00addom layout (generated using Poisson processes). Monte Carlo sim\u00adulationwas usedto \nquantify the signi.canceof any variation. Sec\u00adondly, Bayesian network inference was used on the spatial \ndata to search for the most probable graph.To perform Bayesian network inference, a Haskell script was \nused which invokes Banjo, a pro\u00adgram written in Java [13]. This experience report .rst discusses the \nuse of computer pro\u00adgrams in ecology and palaeontology in \u00a72. The work is described in \u00a73, then, sinceRis \nboth the most commonly used language in ecologyandthe languagethis projectwas startedin,Ris compared \nto Haskell in \u00a74. \u00a75describes how this work has been received by the wider ecological and palaeontological \ncommunities, and gives advice to colleagues choosing a programming language. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 11, September 19 21, 2011,Tokyo, Japan. \nCopyright c . 2011ACM 978-1-4503-0865-6/11/09... $10.00 Figure1. Fractofusus misrai,atypeof Rangeomorph.Aisaphoto \nof the original fossil,Bshows the primary branches andCshows the primary and secondary branches. The \nscale bar is 1cm.Taken from [2]  2. Language usein Ecology andPalaeontology Ecology and palaeontology \nare both diverse subjects, ranging from qualitative descriptive work to theoretical work. Computer literacy \nvaries greatly in both .elds, from people who don t use computers evenforword processing,to former computer \nscientists.Outofthe two groups, ecologists tend to be more computer literate. 2.1 Ecologists Computational \nand theoretical ecologists have the highest knowl\u00adedge of computer science. These two areas require complex \nalgo\u00adrithms, and languages such as C/C++,Fortran and Perl are used. Ecology often requires statistical \nanalysis, so most ecologists have experience using either a specialized GUI, or a programming lan\u00adguage, \ntypicallyR [11]. There area numberof reasons whyRis preferred for statistics: There are many workshops \nand courses in R, from basic intro\u00adductions to applying the latest statistical methods.  Bookson statistical \necology oftengiveexamplesinR,andhave Rscripts available for download [5].  Statisticians and computational \necologists often develop new techniques in R, resulting in a large number of specialist pack\u00adages.  \nPapers often referenceRpackages, documenting their applica\u00adtions and limitations.  2.2 Palaeontology \nPalaeontology is often qualitative, so it is unusual for palaeontol\u00adogists to have experience with programming \nlanguages, or even command line driven programs. Both quantitative and computa\u00adtional palaeontology are \ndominated by GUIs speci.cally written for palaeontologists [3] (apart from the small .eld of macroevo\u00adlutionary \nmodelling which is dominated by C++). Additionally, Microsoft Excel is used for plots and regressions. \nAs palaeontol\u00adogy startsto become more quantitative, thereisasmallbutgrowing trendtowards usingR, with \npalaeontologicalR courses startingto be taught at masters level and above.  2.3 Choosing Haskell Prior \nto entering the .eld of palaeontology,most of my previous re\u00adsearch was in analytical mathematical physics. \nMy main program\u00admingexperiencewasinR, andI had also used some Matlab and C++.Formyworkin palaeontology,Iinitially \nusedR. I started considering alternative languages whenI had trouble expressing more complex algorithmsinR.I \nwasawareof Haskell as my husband both works as a functional programmer and is active in the Haskell community. \nOne motivation for choosing Haskellwastotakeadvantageofhisexpertise.However,I found our programming styles \nsurprisingly incompatible, and in practice programmed almost entirely independently. My husband puts \ngreat emphasis on code that is beauti\u00adful that is, economical, reusable, modular. This focus seems widespreadintheHaskell \ncommunity.In contrast,Iamhappywith code thatworks onceIhave writtena function,Irarely revisit it. Isuspect \nthat my style is widespread in scienti.c programming. My primary resource when learning Haskell was Hutton \n[4], whichIfoundtobeclear,andhadmanysuitableexercises.Ireada varietyof online Haskell tutorials (including \nLearnYoua Haskell for Great Good),but did not .nd these particularly helpful none had exercises which \ngradually increased in dif.culty. I wrotemy Haskell codeinTextPad onWindowsXP,experi\u00admented onit using \nGHCi and compiledit using GHC [14].Imade light use of the built in GHC pro.ler. Once I had reached a \nba\u00adsic level in my understanding of types, Hoogle [9] was useful for .nding functions. 3. Haskellfor \nComputationalPalaeoecology My work involves using biological interactions to understand the development \nof ancient ecosystems [1]. An ecosystem can be mod\u00adelled as a graph, where species are represented as \nnodes, and inter\u00adactions as edges. Feedback mechanisms are one way of analysing the structure of ecosystems, \nand these are represented by loops in the graph [10].I.rst considered the relationship between feedback \nloops and stability for modern ecosystems, then applied the insights gained to Ediacaran ecosystems. \n3.1 Technique Development Properties of feedback loops have been shown to indicate ecosys\u00adtem stability \n[10]. Previouswork focused on biologically interest\u00ading feedback mechanisms, which account for less than \n1% of the total number of loops. The natural extension to this work is to con\u00adsiderevery typeof loop. \nThereisaRpackage which qualitatively .nds all the loopsina graph(LoopAnalyst), however this pack\u00adage \nwould have required signi.cant adapting to be useful for my analysis. Therefore,Iimplementeda programinRthatwas \nableto quantitatively analyse all loops, and output the most signi.cant. Analysis of all loops revealed \nan unexpected result regarding ecosystem stability.To con.rm this .nding,variationsonhowthe loops were \ncomputed and analysed neededtobeexplored. Thisex\u00adplorationwas problematicinRfortwo reasons,the program \ndidn t run fast enough, and program modi.cation was .ddly. Improve\u00admentof the algorithminR wouldhave \nmadeit more intricate, and thus even harder to modify. Writing a second version of the pro\u00adgram in Haskell \nsolved both these problems.A more advanced al\u00adgorithm was used, but thanks to static typing and algebraic \ndata types, modi.cation was straightforward the compiler did lots of the hardwork.Witha signi.cantly \nimproved algorithm, and with theadvanced compilation techniquesofGHC,the program ranover 10,000 timesfaster. \nUsing the Haskell program, possible relationships between loops and stability were investigated, which \nallowed con.rmation of my initial results. Given my programming level, I would not have been able to \nget the same results using R, Matlab or C++. For this work, Haskell provided an easily modi.able language \nthat ran quickly Ican t think of anyimprovements to Haskell which would have made it more suitable. \n 3.2 Application toPalaeontology TheHaskell programwasusedtoinvestigatethe plausibilityofdif\u00adferent feeding \nstrategies of Ediacaran species.For each permuta\u00adtion of feeding strategy, an ecosystem graph was created, \nall loops found, and stability calculated. Using these stabilities,Ishowed that most of the early Ediacaran \nspecies must have been osmotrophic. During this modelling work, the Haskell program was run hun\u00addreds \nof thousands of times, which would not have been feasible withtheRprogram.Forthistypeofwork, seconds \nquicklyaddup, soafaster programisalways better but the Haskell programwas fast enough. Finding Haskell \npackages to produce the right type of plot was hard, so the data was saved and viewed in R. It is important \nto verify anyconclusions drawn from modelling using statistical analysis of real data.I collected data \nfrom fossil sites in order to be able to statistically analyse the distributions of fossils on the rockface, \nallowinga networkof fossil interactions to bebuilt up. The bookIused to learn the appropriate statistical \ntechniques includedexamplesinR,makingiteasytouseRformy analysis.Ilooked at the statistical packagesavailable \nfor Haskell, but the techniquesIrequired were not supported (see\u00a74.4). Switch\u00adingbacktoR wastheobvious \nchoice.  4. Comparing Haskell andR MyworkhasusedbothHaskellandR,sothis sectionisa compari\u00adson between \nthem.Risalanguage designedfor statistical comput\u00ading and graphics [11].Rdefersevaluationof function arguments, \nbut is otherwise a strict language, R is impure and has no static typing; it has some functional aspects,but \nis typically used in an imperative manner. In contrast, Haskell is a lazy, pure, statically\u00adtyped functional \nlanguage. Writing simple programsinRis easy,but writing more complex programs can get messy. In contrast, \nwriting simple programs in Haskell requires a greater understanding of the language (such as monads, \ntypes, etc.), but producing complicated programs is not much harder. 4.1 Syntax and Reasoning Iprefer \nthe Haskell syntax because it is consistent, and has an obvi\u00adous correspondence with mathematical concepts. \nThis correspon\u00addence means that colleagues with no Haskell or functional pro\u00adgramming experience can \nclearly understand my calculations. In comparison,the syntaxforRis moreverbose,and less consistent, but \nsome statistical functions are writteninaintuitiveway forex\u00adample regressions are written lm(z . x + \ny). Unfortunately, these syntactic shortcuts can be confusing in themselves, for example polynomial regressions \nare then written lm(z . I(x 3)+ y). The consistent syntax of Haskell means that when returning to Haskell \nafter a break, getting back up to speed is quicker compared to re\u00adturning to R. Haskell s purity allows \nextensive use of equational reasoning for example the code if a then b else b is equivalent to b (providing \na terminates).In contrast, the equivalentRtransforma\u00adtion is only true if a both terminates and does \nnot produce side effects, which canbe subtle,suchas coercion changingavariable s underlying type.Ihave \nmade such mistakesinR, which meansitis hardertorefactormyRcode,andthusmyHaskellcodeis cleaner. Similarly, \nwhen debugging HaskellI am able to deduce properties aboutmy code using only local knowledge, whereasRrequiresa \nmuch more advanced understanding of both the program and the language. Thedownsideof purityisthe requirementto \nuse monadicIO.I foundthe descriptionsofIOin tutorials obtuse,but foundthe reality tobe signi.cantly simpler.Theonlyawkwardnessisthat \nswitching between pure and monadic code feels like changing mode, the syntax is different and so are \nmany of the functions (e.g. map vs. mapM). 4.2 Types The statictypesystemofHaskellisdif.culttoadjusttoat.rst,but \nworth the struggle the reduction in debugging time is signi.cant. Rhas no static types, and makes signi.cant \nuse of coercions. If you tryanduseastringasamatrix,thestringwillbeparsedasamatrix, which is particularly \nuseful when reading data tables from a .le. If you try and use a vector as a matrix, a matrix will be \ncreated by repeating the vector. These coercions make debugging hard, and signi.cantly re\u00adduce the con.dence \nin numerical results. Manybugs that result in compile time type errors in Haskell, result in wrong (but \nplausi\u00adble) results in R. Additionally, coercions can be handled somewhat inconsistently, e.g. a matrix \nproduced by converting a list using as.matrix will cause a runtime type error when used with some matrix \nfunctions. Static types are particularly helpful for beginners to .nd basic library functions, using \nHoogle.Forexample, the typeof the func\u00adtion to remove duplicates from a list is obvious(Eq a => [a] -> \n[a]),but it s namein Haskellis obscure(nub). Sadly, Haskell packages do not always use consistent types \n for example there are manydifferent vectors/arrays, which makes using multiple packages painful. SomeRpackages \nalso have dif\u00adferent types,but these problems are entirely maskedby coercions, meaning lotsofRpackages \ncanbe used together with ease. 4.3 Complex Code Muchofmyworkinvolves calling library functions, combiningthe \nresults, and doing calculations which are mathematically taxing, butcanbeexpressedfairly directlyinanylanguage.However,some \nofmyworkdoesrequiremorecarefulthoughtabout algorithmsand more intricate structural manipulations.I.ndit \nsigni.cantly easier to write this complex code in Haskell, for three reasons: Static types have an enormous \nimpact on reliability,but for more complex code, theyalso provide a clear pattern for combining functions. \nStatic types allow chunks of code to be combined like a jigsaw puzzle. Algebraic data types allow me \nto accurately encode my data structures, and combined with the static type checking, make managing complexity \nmuch easier. Higher-order functions allow detangling complex code, splitting out speci.c details from \nan algorithm. Both Haskell andRallow higher-order functions,but the lackof static type checkinginR makes \nthem much harder to use. In Haskell, using higher-order functions with algebraic data types,I was ableto \nparameterize operationsby the detailsIneeded to tweak, making modi.ca\u00adtions straightforward.  4.4 Libraries \nFor the librariesIrequire,Rhasfar better coverage than Haskell. The default installation of R has all \nthe tools necessary for pre\u00aduniversity maths or statistics. In comparison, the standard Haskell installation \n(the Haskell Platform) includes advanced multithread\u00ading,butlacksafunctionto computethe mean.Fromthebase \ninstal\u00adlation,R can install new packages through the GUI, while Haskell requires the useofa command line \ntool, andfar more background computer knowledge. R has a huge range of specialist statistics packages \navailable, including many cutting edge statistical techniques. In compari\u00adson, Haskell has nine statistics \nlibraries, which have a reasonable amountofoverlap,but skip things as basic as t-tests. Oneof the most \nimportant aspects of performing statistical tests is checking all the necessary assumptions arevalid, \nsomething oftenoverlookedin biological sciences [12]. Haskell packages provide normal distribu\u00adtion functions,but \nlack the Shapiro-WilksTest which checks data for normality akeyassumptionin most parametric tests. R \nhas a built in plotting environment, which easily produces a wide range of plots. Complex plots are provided \nin libraries, and most statistical packages integrate plotting functionality. In comparison, Haskell \nhas a choice of many plotting libraries, all of which are signi.cantly different, and none of which have \nthe integrationofR.InR a plotis onlya simple function callaway, and they are used continuously. In Haskell, \na plot is signi.cantly harder IjustexportmydatatoRandplotit there. Asanexampleofthe library issues discussed,the \nfollowingR code plots the eigenvalues of a matrix read from disk: plot(eigen(read.delim(\"matrix.txt\"))$ \nvalues) In Haskell .nding eigenvalues involves installing hmatrix (which onWindows requires changing \nenvironmentvariables and setting Dll paths), reading a matrix requires parsing code, and plotting is \nnever as simple as just calling plot. Performing this operation from abase installofRtakes seconds,inHaskellittakesfar \nmoreeffort.  5. Evaluation This section discusses how my work was received by the ecolog\u00adical and palaeontological \ncommunities, along with plans for my programand futureuseofHaskell.Iconcludewith adviceonusing Haskell \nfor computational palaeoecology. 5.1 Reception Ecologists are excited about my work. The work done by \nNeutel et al. [10] provoked much interest in loop analysis of ecological graphs, and because my program \nis quick and easy to use, people can now explore the importance of loops in much larger real and theoretical \necosystems. My code is available on Hackage as loopy1, but for my col\u00adleagues I provide a precompiled \nexecutable with an R wrapper script, which suits them well. Palaeontologists are interested in my results, \nbut not in my methods. Modelling ancient ecosystems as graphs is a new tech\u00adnique, and has yet to become \nmainstream. If I wanted palaeon\u00adtologists to use my program, a GUI would probably be necessary, somethingIcurrentlyhave \nno plans for. 5.2 Future Development For huge graphs, it is infeasible to enumerate all loops (the number \nofloops cangrowexponentially).Iplantoexplore approximations to allow larger graphs to be processed, which \npermit ecosystems tobe modelledin .ner detail.For thiswork,Iwill continue using Haskell, withRfor anyplotting \nor statistical analysis. Haskell is my programming language of choice, and if it had adequate statistics \nlibraries,I would rarely use anything else.IfI ever need to run intensive statistical analysis on lots \nof large data sets, it would be worth writing the necessary libraries in Haskell. Another languageI am \nconsidering is F#. WhenI started this project,F#wasa relatively new language,but nowIthinkit could suit \nme quite well. F# provides access to the .NET libraries, which would provide much of the functionality \nmissing in Haskell, while still keeping the bene.ts of functional programming and static typing. 5.3 \nExpansion of Haskell use in Ecology/Palaeoecology Ecologists tend to use programming languages they have \nbeen taught at university, or languages already established in their re\u00adsearch group. Once a language \nbecomes dominant, it takes a long timeto become unseated Fortranis stillbeing taught. Theoretical ecologists \ncould .nd Haskell useful, because it s quicker to write complex code. However, the lack of simple integrated \nplots would beasevere obstacle.For statisticaluse,Haskellisunlikelyto com\u00adpete with R, which is deeply \nembedded in the community. Computational palaeoecologyisanew .eld Iamonlyaware of two other practitioners. \nHaskell is well suited for this domain, and if it became established, it would be unlikely for another \nlan\u00adguage to take over. Whether it becomes established probably has more to do with the future career \npaths of existing computational palaeoecologists than with the language itself. Itwouldbedif.cultforHaskellto \nbecomethedefacto language for scienti.c computing, due to its steep learning curve. Most un\u00addergraduate \nscience degrees do not teach a separate programming course, instead teaching programming alongside a \ntechnique, such as statistics. Programming skills are gentlybuilt up in little steps, over several courses. \nHaskell could not be taught in this way, since static types and monads would need to be taught before \ngetting to anytechnique,andthiswouldprobablybetoomuchforone course. Numerate disciplines like physics \ndo have separate program\u00adming courses, where the choice of language depends on its use\u00ad 1http://hackage.haskell.org/package/loopy \nfulness post degree. If Haskell, or another functional language, be\u00adcame widely used commercially, universities \nwould probably start to teach it outside the computer science department. These nu\u00admerate disciplines \ncould then write appropriate scienti.c libraries which could be used by less numerate sciences.  5.4 \nConclusions When colleagues ask which language theyshould use,Ionly rec\u00adommend Haskell if they are an \nexperienced programmer, and deal mostly with theoretical work.Foreveryone else,IrecommendR. WhileIthink \nHaskellisa superior language,it hasa much steeper learningcurve,and unlessI waswillingtoteachthem,Risasim\u00adpler \nchoice.Withinmy department thereis anR learning group, and various university run courses, which give \nuseful support. Haskell enabled me to get detailed results that I could not otherwise have found. I .nd \nfunctional programming and static typing powerful concepts, and other than R, would not consider using \nlanguages lacking these features. Acknowledgments Neil Mitchell for introducing me to Haskell, Mike Dodds \nfor feed\u00adback on this paper and my supervisors Nicholas Butter.eld and Anje Neutel. This work was funded \nby a NERC studentship. References [1] N. J. Butter.eld. Macroevolution and macroecology through deep \ntime. Paleontology, 50:41 55, 2007. [2] J. Gehling and G. Narbonne. Spindle-shaped Ediacara fossils from \nthe Mistaken Point assemblage,Avalon Zone, Newfoundland. Canadian Journal of Earth Sciences, 44(3):367 \n387, 2007. [3]\u00d8. Hammer,D.Harper,andP.Ryan.PAST:Paleontological statistics software package for education \nand data analysis. Palaeontologia Electronica, 4(1), 2001. [4] G. Hutton. Programming in Haskell. CUP, \n2007. [5] J. Illian. Statistical analysis and modelling of spatial point patterns. [6] R. Jenkins and \nJ. Gehling. A review of the frond-like fossils of the Ediacara assemblage. South Australian Museum, 1978. \n[7] M. La.amme, S. Xiao, and M.Kowalewski. Osmotrophyin modular Ediacara organisms. Proceedings of the \nNational Academy of Sci\u00adences, 106(34):14438, 2009. [8] M. McMenamin. Thegarden of Ediacara. Palaios, \npages 178 182, 1986. [9] N. Mitchell. Hoogle overview. The Monad.Reader, (12):27 35, November 2008. [10] \nA. M. Neutel, J. A. P. Heesterbeek, J. van de Koppel, G. Hoender\u00adboom, A.Vos, C. Kaldeway,F. Berendse, \nandP. C. de Ruiter. Rec\u00adonciling complexity with stability in naturally assembling foodwebs. Nature, \n449:559 602, 2007. [11]RDevelopment CoreTeam. R: A Language and Environment for Sta\u00adtistical Computing.RFoundation \nfor Statistical Computing,Vienna, Austria, 2008. [12]T.Siegfried. Odds are,it s wrong: Sciencefailstofacethe \nshortcom\u00adings of statistics. Science News, 177(7):26 29, 2010. [13]V. Smith,J.Yu,T. Smulders,A. Hartemink,andE. \nJarvis. Computa\u00adtional inference of neural information .ow networks. PLoS Computa\u00adtional Biology, 2, \n2006. [14] The GHC Team. The GHC compiler, version 6.12.3. http://www.haskell.org/ghc/, 2010. [15] D.Wood, \nR. Dalrymple, G. Narbonne, J. Gehling, and M. Clapham. Paleoenvironmental analysis of the late Neoproterozoic \nMistaken Point andTrepasseyformations, southeastern Newfoundland. Cana\u00addian Journal of Earth Sciences, \n40(10):1375 1391, 2003.    \n\t\t\t", "proc_id": "2034773", "abstract": "<p>The ecology of Earth's first large organisms is an unsolved problem in palaeontology. This experience report discusses the determination of which ecosystems could have been feasible, by considering the biological feedbacks within them. Haskell was used to model the ecosystems for these first large organisms - the Ediacara biota. For verification of the results, the statistical language R was used. Neither Haskell nor R would have been sufficient for this work - Haskell's libraries for statistics are weak, while R lacks the structure for expressing algorithms in a maintainable manner. This work is the first to quantify all feedback loops in an ecosystem, and has generated considerable interest from both the ecological and palaeontological communities.</p>", "authors": [{"name": "Emily G. Mitchell", "author_profile_id": "81488642118", "affiliation": "University of Cambridge &#38; British Antarctic Survey, Cambridge, United Kingdom", "person_id": "P2801367", "email_address": "ek338@cam.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034779", "year": "2011", "article_id": "2034779", "conference": "ICFP", "title": "Functional programming through deep time: modeling the first complex ecosystems on earth", "url": "http://dl.acm.org/citation.cfm?id=2034779"}