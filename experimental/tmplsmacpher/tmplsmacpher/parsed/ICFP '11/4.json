{"article_publication_date": "09-19-2011", "fulltext": "\n Monads, Zippers andViews Virtualizing the Monad Stack Tom Schrijvers Department of Applied Mathematics \nand Computer Science, Universiteit Gent tom.schrijvers@ugent.be Abstract Wemakemonadic components more \nreusable and robust to changes byemploying twonewtechniques forvirtualizing the monad stack: the monad \nzipper and monad views. The monad zipper is a higher\u00adorder monad transformer that creates virtual monad \nstacks by ig\u00adnoring particular layers in a concrete stack. Monad views provide a general framework for \nmonad stack virtualization: theytake the monad zipper one step further and integrate it with a wide range \nof other virtualizations.For instance, particular views allow restricted access to monads in the stack. \nFurthermore, monad views provide components witha call-by-reference-like mechanism for accessing particular \nlayers of the monad stack. With our two new mechanisms, the monadice.ects requiredby components no longer \nneed to be literally re.ected in the concrete monad stack. This makes these components more reusable \nand robust to changes. Categories and Subject Descriptors D.3.3[Programming Lan\u00adguages]: Language Classi.cations \nApplicative (functional) lan\u00adguages General Terms Design, Languages Keywords Components with Side E.ects, \nModularity, Monad Transformers, Zipper 1. Introduction Monads [15, 31] are a useful abstraction for encapsulating \nside\u00ade.ectsin purely functional languages like Haskell [18].With mon\u00adads di.erent types of e.ects such \nas state, non-determinism or exceptions can be modeled with the same abstract interface. Monads are \ncomposed via mechanisms such as monad trans\u00adformers [13].With monad transformers writing programs that \nuse multiple e.ects is possible by stacking di.erent transformers on top of each other to form a larger \nmonad. Monads and monad transformers are interesting because they allow programmers to write realistic \ne.ectful programs that are still purely functional, thus enjoying reasoning principles such as equational \nreasoning and parametricity [21, 29]. Furthermore, because of these rea\u00adsoning principles, monads and \nmonad transformers also provide Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. ICFP 11, September 19 21, 2011,Tokyo, Japan. Copyright .c2011ACM 978-1-4503-0865-6/11/09...$10.00 \nBruno C. d. S. Oliveira ROSAEC Center, Seoul National University bruno@ropas.snu.ac.kr a good setting \nfor studying modular e.ectful components, like Aspect-Oriented Programming (AOP) style advice [17] or \nmodels of Feature-Oriented Programming (FOP) [20]. Monad transformers come with a responsibility: it \nis necessary to manage the monad stack. In Haskell there are two existing approaches for this: implicit \nliftings and explicit liftings. Implicit liftings exploit type-directed overloading of methods, provided \nby type classes [32], to automatically route an e.ectful operation to the .rst layer of the right type \nin the monad stack. Explicit liftings o.er more control to programmers, at the cost of automation, by \nallowing monadic components to directly refer to a monad layer at some position below the current layer \nusing multiple invocations of the lift method (which moves from the current layer to the one immediately \nbelow). However, there are two main problems with the current mecha\u00adnisms for manipulating the monad \nstack: 1. Inconvenience: The .rst problem is that explicit lifting is sim\u00adply awkward to use. Explicit \nlifting relies on a positional mechanism, similar to de Bruijn indices, to refer to particular layers \nof the monad stack. Because access to the nth layer be\u00adlow the current layer requires n calls to the \nlift method, code quickly becomes polluted with lift method invocations. 2. Lack of robustness, limited \nexpressiveness and reusability: The second, and more fundamental, problem is that the current approach \nis not robust to changes and o.ers only limited ex\u00adpressiveness and reusability, specially when higher-order \ncom\u00adponents (or control .ow operators) are involved. Implicit lift\u00ading through overloaded methods is \nrobust,but it is also quite limited in expressiveness since handling multiple monads of the same type \nis not possible. Explicit liftings are not robust to changes because the relative (positional) references \nimpose a tight coupling between monadic components and the monad stack, which makes those components \nless adaptable. Further\u00admore, explicit lifting still has limited expressiveness because it only allows \nto refer to layers below the current layer,but not layers above.  The .rst problem is well-known in \nthe Haskell community and there have been some proposals for solving it. Piponi [19] and Snyder&#38;Alexander \n[25] suggesteda solutionby labeling monad transformers with (type-level) tags, allowing particular layers \nin a monad stack to be accessed by name rather than by position, eliminating the pollution arising from \nmultiple calls to lift. The second problem is a bit more subtle because it only shows up when monadic \ncomponents are meant to be reused in di.er\u00adent contexts with di.erent monad stack layouts as, for example, \nin the modular e.ectful components studied by Prehofer [20] and Oliveira et al. [17].For this to be possible, \nmonadic components should abstractover the monad stackbykeeping the type represent\u00ading the monad stack \npolymorphic (though constrained). The use of names is also useful to solve this second problem because \nnames are more robust to changes in the monad layout. However, existing tagged approaches [19, 25] are \ninvasive, in the sense that monadic components have to be written specially with tagging in mind, and \ntheystill have reusability limitations (such as name clashes).  Contributions This paper proposes two \nnew techniques for ma\u00adnipulating monad stacks: the monad zipper and monad views. The monad zipper is \na monad transformer that allows ignoring particu\u00adlar layers in the concrete stack. Monad views abstract \nthe concrete monad stack intoavirtual monad stack, which presents itself witha more suitable interfacetoaparticular \ncomponent.Views also allow restricting access (in the sense of permissions) to particular layers of the \nmonad. An important characteristic of both techniques is that they can be used non-invasively, by being \napplied externally and e.ectively providing the component with a tailored virtual monad stack. When there \nare con.icts that are local to a certain compo\u00adnent, monad views can also be used invasively to provide \na call\u00adby-reference mechanism to refer to particular layers in the monad stack.Byworking with virtual \nstacks, requirementsof components in terms of the monad stack shape no longer need to be literally re.ected \nin the concrete monad stack, making these components more reusable and robust to changes. We also brie.y \nreport on a non-trivial application of our tech\u00adniques, developed by Schrijvers et al. [24], which shows \nthat the techniques proposed by us scale well in terms of the number of monads in a monad stack. In that \napplication 30 monadic compo\u00adnents and equally as manymonad transformers were used.We are notawareofanyHaskell \nprojectsusingasmanytransformersatthe same time. 2. Overview The presentation of our work will be made \nin Haskell, and we will assume knowledge of the language. Nevertheless, as discussed in more detail in \nSection 7.1, we believe that none of the main concepts presented by us (the monad zipper, views and masks) \nare Haskell-speci.c. In this section we brie.y introduce the Haskell monad trans\u00adformer library (MTL), \nprovide an overview of the current state-of\u00adthe-art in manipulating monad stacks and illustrate how the \nmonad zipper and monad views improve upon that state-of-the-art by vir\u00adtualizing the monad stack. 2.1 \nQuick MonadTransformers Reference Our ideas and examples are formulated in terms of a variant of the \nMTL.1 See Liang et al. [13] for a more in-depth introduction to MTL. Figure 1 summarizes the monad transformers, \nclasses and operations that we use in the course of this paper. The transformers consist of pure computations(IT, \nthe identity monad transformer) and computations witha read-only environment(RT), updateable state(ST)and \nexceptions(ET). These transformers are combined into di.erent monad stacks with the identity monad(I) \nat the bottom. The type classes (denoted with subscript M) constrain a monad stack to provide support \nfor a particular e.ect, without as\u00adsuminga particular stack con.guration. Each classo.ers a number of \nprimitive operations, such as ask to access the environment for RM. 2.2 Monadic Components An important \ndistinction throughout this paper is between monadic component and client code. The main goal of this \npaper is to im\u00adprove the robustness, reusability and convenience of use of the for\u00admer. At .rst sight, \nit will seem that the client code pays the price for 1Section 7.2 discusses the di.erences. this improvement, \nbecause it is forced to make the necessary con\u00ad.guration choices for the more adaptable components.Fortunately, \nthe complexity can be neatly hidden behind combinators. Component code Component code is intended to \nbe reused in di.erent contexts.Typically such code resides in libraries, which are used by clients in \nvarious di.erent applications. As two simple examples of monadic components, consider an incrementer \nand an assertion checker: inc :: SM Int m . m Int inc = do x . get put (x + 1) return (x+ 1) assert :: \nEM String m . Bool = m () assert test = if test then return () else throwError \"Assertion failed\" What \nis interesting about these components is that they can be adapted to work with di.erent concrete monad \nstacks. This is possible because we use parametric polymorphism to abstract over the monad, imposing \nonly the required restrictions on the layoutby using (type-class) constraints.Forexample, what the signatureof \ninc tells us is that it can be used by anyclient whose monad stack supports state. Components can, of \ncourse, be combined into larger compo\u00adnents.For example: comp ::(SM Int m, EM String m). m () comp = \ndo x . inc assert (x > 0) Client code Client code instantiates the monad stack, and is de\u00ad.nedbythe \nend-userwhenusingthe componentstobuild particular applications. Di.erent stack con.gurations may be possible: \ntype M1 = ST Int (ET String I) type M2 = ET String (ST Int I) In general, di.erent monad stack layouts \nhave di.erent semantics. Consider the following run functions for M1 and M2: runM1 :: Int = M1 a = Either \nString (a, Int) runM1 n = runI. runET . .ip runST n runM2 :: Int = M2 a = (Either String a, Int) runM2 \nn = runI. .ip runST n. runET When we use these functions to instantiate the monad in comp we can observe \nthe semantic di.erences between the two monad stacks: > runM1 (-1) comp Left \"Assertion failed\" > runM2 \n(-1) comp (Left \"Assertion failed\", 0) In the case of M1 changes to the state are lost upon throwing \nan error, while this is not the case for M2.  2.3 State-of-the-art Manipulation of the Monad Stack Implicit \nlifting The monadic components presented in Sec\u00adtion 2.2 use implicit lifting for accessing the right \nlayer in the monad stack.E.ectful operations like get, put or throwError are automatically routed to \nthe .rst layer of the right type in the monad stack,byexploiting the type-basedoverloading mechanismof \ntype classes. This approach is robust, because the routing automatically adapts to multiple layouts of \nthe monad stack (such as M1 or M2).  -\u00adidentity transformer -\u00adidentity monad newtype IT m a newtype \nI a IT :: m a = IT m a I :: a = I a runIT :: IT m a = m a runI:: I a = a -\u00adreader transformer -\u00adreader \nclass newtype RT e m a class Monad m . RM e m | m = e RT :: (e = m a)= RT e m a ask :: RM e m . m e runRT \n:: RT e m a = e = m a -\u00adstate transformer -\u00adstate class newtype ST s m a class Monad m . SM s m | m = \ns ST :: (s = m (a, s)) = ST s m a get :: SM s m . m s runST :: ST s m a = s = m (a, s) put :: SM s m \n. s = m () -\u00adexception transformer -\u00adexception class newtype ET x m a class Monad m . EM x m | m = x \nET :: m (Either x a)= ET x m a throwError :: EM x m . x = m a runET :: ET x m a = m (Either x a) catchError \n:: EM x m . m a = (x = m a)= m a Figure 1. MTL quick reference. Figure 2. Three composition scenarios: \nifpos inc, ifpos (lift inc)and~ (ifpos (. inc)). Implicit lifting has one big limitation: it is ine.ective \nfor com\u00adbining multiple instances of the same e.ect because the automatic type-based selection of a monad \nlayer always picks the .rst layer of the right type. If there is another layer of that type below that \nlayer, implicit lifting cannot access it. Explicit Lifting Explicit lifting addresses the limitation \nof im\u00adplicit lifting to some extent because it allows moving down the monad stack into a lower layer. \nTherefore, by calling the e.ect\u00adful operations in lower layers, implicit liftings are routed to monad \ntransformers that are not at the top of the stack. The approach consists of using lift methods explicitly \nto disam\u00adbiguate the targets of accesses to the monad stack. Suppose that we want to combine two instances \nof inc in such a way that they update di.erent counters. Using explicit lifting we could write a component \ndoubleInc that does the job: doubleInc ::(SM Int (tm), SM Int m, MonadTranst). tm () doubleInc = inc \n> lift inc > return () The role of lift is to ensure that the second instance of inc updates a counter \nin the monad below the current layer (and not at the top\u00admost layer). The use of lift is re.ected in \nthe constraints imposed on the stack. In this case, the requirement is that the top-level monad tm must \nsupport state and the monad m below must also support state. If the monad stack is ST Int (ST Int I), \nthen doubleInc updates the two state layers. Hence, running doubleInc with the run function below yields \nthe result (((), 1), 6). run c = runI$runST(runST c 0)5 Explicit liftingis essentially,likede Bruijn \nindices,a relative refer\u00adence mechanism: it allows moving nlayers below2 the current layer by using n \ncalls to lift. A clear limitation of this mechanism is that it is not possible to refer to layers above \nthe current layer.Yet this functionality is particularly desirable to preserve modularity when higher-order \ncomponents (also known as control .ow operators)are involved. Some compositions of primitive monadic \ncontrol .ow operators (e.g. catchError)cannot be expressed withlift at all. Furthermore, components that \nuse lift internally usually impose unnecessary restrictions on the layout of the monad stack, because \ntheyexpress relative orderings of layers. In summary implicit liftings are quite robust to changes and \nare convenientto use,buthave limitedexpressiveness;and, while explicit liftings address the limitations \nof implicit liftings to some extent, they too are still limited in expressiveness and there is a price \nto pay, in terms of a tighter coupling between component and monad stack. 2Note that there are two points \nof view for lift m in a certain calling context. From the calling context s point of view towards m the \ndirection of movement is downwards, while, vice versa, the direction of movement from m s point of view \ntowards the calling context is upwards. Usually, we adheretothe calling context spointofview,but occasionallywemayhave \nto use m s perspective; when that is the case, it should be clear from the context.  2.4 Virtualizing \nthe Monad Stack By presenting the component code with a virtual monad stack, components become decoupled \nfrom the client code s concrete monad stack. The monad stack virtualization is achieved by: 1. avoiding \nlift method invocations inside component code, which are responsible for the tight coupling; and 2. \nusing the monad zipper and monad views to manage virtual monad stacks.  In this section we explain how \nthe monad zipper and monad views are used to develop components free of lift invocations while, at the \nsame time, allowing for additional expressiveness that is not possible with explicit lifting alone. Note \nthat, in the remainder of this section, the intention is just to demonstrate how the monad zipper, structural \nmasks, nominal masks and views can be used from the user s point of view to solve various problems related \nto the manipulation of monad transform\u00aders. The reader is not expected to understand in detail how the \nex\u00adamples work by the end of Section 2. Instead, the details of each mechanism willbeexplainedin later \nsections: Section3describes how the monad zipperworks, Section4presents views, and Sec\u00adtion5presents \nthedi.erent .avors of masks. The Monad Zipper With the monad zipper we derive a virtual stack froma concrete \none, that ignoresa pre.xbut does not forget it. For instance, M3 is a virtual stack for ST Int (ST Int \nI)that ignores,but does not forget, the topmost transformer: type M3 = (ST Int . ST Int)I Ignoring a \npre.x enables an operation ~ much like lift, while still enabling an inverse . that has no counterpart \nin the explicit lifting approach. This is useful for adapting higher-order monadic components such as \nifpos ifpos :: SM Int m . m Int = m Int ifpos c = do x . get if x> 0 then c else return 0 (which routes \nthe .ow of control to c when a state is positive) to monad layouts where the component c is supposed \nto access a monad above the current layer.With the monad zipper this problem is solved as follows: > \nrun (~ (ifpos (. inc))) ((1, 1), 5) Without the monad zipper, the only way to achieve the same result \nis to invasively (non-modularly) modify ifpos such that the get method is lifted: explicit lifting alone \nis not enough to handle the scenario on the right of Figure 2. The zipper, on the other hand, allows \nifpos to be reused without any invasive changes to the original code. Structural Masks Masks take the \nmonad zipper one step further and allow selectively ignoring stack layers at multiple arbitrary po\u00adsitions \nin the monad stack (not just pre.xes). Consider for instance the monad stack type M= ST Int (ST Int (ET \nString (ET String I))) to which the twocomponents ifpos and comp> gethaveinterleaved access in the composition \nclient :: MInt client = from m1 (ifpos (to m1 (from m2 (comp > get)))) where m1 = _ m2 = D ::: _ ::: \n_ ::: D Figure3. The monad stack Mand the layers visible through masks m1, m2 and m3: black layers are \nmasked and gray layers are ab\u00adstracted over. Here, the mask m2 = D ::: _ ::: _ ::: D has a meaning similar \nto the bitvector 1001. When imposed on a monad stack, it ignores the second and third layers. The from \nm and to m functions, with m a mask, generalize ~ and ..For instance, from m2 comp gives comp access \nto the .rst and fourth layer in a monad stack. Similarly, m1 provides ifpos with access to the second \nand third layers. See Figure 3 for a graphical depiction. Note that the layers in gray are not masked \nfor the corresponding component, but nor is that component aware of their presence. This is either because \na visible layer higher up in the monad stack blocks a similar layer lower down from view, or because \nthe component s polymorphic type does not mention (i.e., abstracts away) the e.ect of a layer. Masks \nwith Restricted Views Masks are special instances of a more general mechanism called views. As such, \nmasks can be freely combined with other types of views. For instance, the following example shows how \nto use masks in combination with a read-only view r1, which provides a read-only view of a state monad. \n client' :: MInt client' = from m1 (ifpos (to m1 (from m2 comp > from m3 ask))) where m1 = _ m2 = D \n::: _ ::: _ ::: D m3 = r1 The ask component, whose type is RM em . me (see also Figure1), requiresa \nreader monad,butthe concrete monad Mhas no layer with a monad of that kind. However, we can view one \nof the state monads as a reader. The read-only view r1, used in the mask m3, does precisely this and \nallows the component ask to view the .rst state monad in Mas a reader monad. Nominal Masks Referringto \nlayersina structuralfashion (with the monad zipper or bitvector-like masks) can be fragile when the layoutofthemonadstackislikelytochange.Withanominalmask, \nthe client code speci.es the names (not the locations) of the layers to be used by a component. That \ncomponent is then automatically matched up with the correspondingly named layers in the monad stack.For \ninstance, with nominal masks the client example would be rewritten as: client'' = ifpos ((comp > get) \nuse (Counter1 &#38;Err2))  Here, Counter1 and Err2 are the names of respectively the .rst and fourth \nstack layer. The combinator use takes a list of names and makes the layers tagged with those names visible \nto the compo\u00adnents. The list of names is assembled using the combinator &#38; . The nominal masking infrastructure \nisbuilt on top of structural masks. The big bene.t of using the nominal approach instead is that it is \nmuch more robust: if the layers are rearranged, the nominal masks do not have to change at all. Call-by-reference \nwith Views A .nal application of views and masks is to allow for a call-by-reference programming style \n(that is discussed in Section 5.3) in which the view arguments act as references to particular layers \nin the monad stack. add ::(Monad m, SM Int n1, SM Int n2) . (n1 &#38; m)= (n2 &#38; m)= m () add xref \nyref = do x . getv xref y. getv yref putv xref (x + y) In this example xref and yref are two view arguments \nand the getv and putv operations, which generalize the state monad getand put operations, use such views \nto access the right layer in the monad stack. This functionality is especially useful when a component \nemploys multiple instances uses of the same e.ect. By using this call-by-reference style it is possible \nto avoid the pollution and the ordering constraints on the stack imposed by lift methods. 3. The Monad \nZipper This section presents the monad zipper: a monad transformer that is used to shift the focus of \nautomatic lifting to the desired layer in the monad stack. In essence, the monad zipper allows us to \nignore layers at the top of the stack while, at the same time, preserving these same layers, which allows \nshifting the focus back to the top when needed. 3.1 Stacks and Zippers Sometimes type-level problems \nget easier when we move them to the term level. Let s reify the structure of the monad stack in a data \ntype data Stack = Trans\u00b7 Stack | Bottom Monad data Trans = T1 | ... | Tn data Monad = I where the Ti \nrepresent the di.erent transformers and Irepresents I. Huet [9] taught us how to shift the focus to any \nposition in a data structure, with his zipper. Here is the Zipper for Stack: data Zipper = ZipperPathTrans \nStack data Path = Path. Trans| Top where Zipperpl s denotes a stack with layer lin focus, remainder of \nthe stack s and path pback to the top of the stack. The path is a reversed list, where the .rst element \nis closest to the layer in focus andthelast elementisthetopofthe stack.Witha little syntactic sugar (.)= \nZipper we obtain the self-explanatory notation(Top . T1 . T2 . T3 . T4)(T5 \u00b7 I), where the triangles \npoint towards the layer in focus T4. The zipper function turns a stack into a zipper with the .rst element \nin focus: zipper :: Stack = Zipper zipper (t\u00b7 s)= (Top. t)s while the up and down functions allow shifting \nthe focus one position up or down: up, down :: Zipper = Zipper up (Zipper (p. t1)t2 s)= (p. t1)(t2 \u00b7 \ns) down (Zipperpt1 (t2 \u00b7 s)) = (p. t1 . t2)s It s all well and good to zip around a rei.ed form of the \nmonad stack,but can wedoit on the real thing too?  3.2 Monad Zipper The answeris yes. Hereishow the \nmonad zipper(.)is de.ned: newtype (t1 . t2)ma = ZT {runZT :: t1 (t2 m)a} where the type(p.t)shas similar \nmeaning to the rei.ed data struc\u00adture above. However, the monad zipper only changes the type rep\u00adresentation: \nthe newtype indicates that no actual structural change to the monad stack t1 (t2 m)takes place. The only \nchange takes place in the form of the type, which will enable us to select a dif\u00adferent type class instance \ndepending on the layer in focus.We will see more on this later,but .rst let us complete the analogy between \ntypes and terms. Term-level stack composition(\u00b7), asin T1 \u00b7 M1, corresponds to type application, as in \nt1 m1. As to ., the type system will not allow terms of type Zipper to be used when terms of type Stack \nare expected. This segregation is not the case at the type level: the monad zipper type(.)can appearaspartofa \nmonad stack. Indeed, we de.ne t1. t2 to be the monad transformer composition of t1 and t2: instance (MonadTranst1, \nMonadTranst2) . MonadTrans (t1 . t2)where lift = ZT . lift . lift Hence, at the type level, we simply \nuse . where . was needed at the term level. So, the monad stack representation(t1 . \u00b7\u00b7\u00b7 . ti)(ti+1 \u00b7\u00b7\u00b7 \nm)denotes a monad stack with focus onti. Finally, analogous to what the zipper function does with Stack, \na monad transformer stack can be transformed into explicit zipper form by the following function: zipper \n:: tma = (IT . t)ma zipper = ZT . IT where the identity monad transformer IT acts as the Topsentinel. \nHowever, the IT sentinel is unnecessary, as the unadorned monad stack tma already expresses that the \nfocus rests on t. There is no point in adding IT to subsequently ignore it again with IT . t. In general, \nt1 (t2 \u00b7\u00b7\u00b7 (tn m)) represents a monad stack with focus on t1. So we will not actually use the above zipper \nfunction. In summary, the term(Top . T1 . T2 . T3 . T4)(T5 \u00b7 I)is the rei.ed form of the type(t1 . t2 \n. t3 . t4)(t5 I). Relative Navigation Supposewehaveamonad transformer stack t1 (t2 \u00b7\u00b7\u00b7 (tn m)). Then \nthe focus lies by default on the top-most transformer t1. The monad zipper becomes useful only when we \nshift the focusaway from t1 to t2. The constructor ZT accomplishes that shiftof focus,buthow canwenavigate \nfurtherdown,andback up? Let us start with moving the focus one step further down: step2to3 ::(t1 . t2)(t3 \nm)a = (t1 . t2 . t3)ma step2to3 = ZT Afurther step down: step3to4 ::(t1.t2.t3)(t4 m)a = (t1.t2.t3.t4)ma \nstep3to4 = ZT The pattern should now be obvious.Asingle step down at any position in the stack is de.ned \nas: . :: t1 (t2 m)a = (t1 . t2)ma . = ZT   Stepping back up is similar: ~ ::(t1 . t2)ma = t1 (t2 m)a \n~ = runZT Finally, note that ..~. id and ~... id hold. Focused Behavior Sofar, all we have seen is notation. \nThe in\u00adteresting behavior of t1 . t2, where it should deviate from a plain monad transformer composition, \nlies in the methods of the monad classes, e.g. put of SM.For lookingup the method implementations it \nshould ignore (look through) t1 and only consider t2 m. This is achieved, e.g. for the state monad SM \nde.nedin Figure1,by lifting the operations through t1: instance (MonadTranst1, MonadTranst2, Monad m, \nSM s (t2 m)) . SM s ((t1 . t2)m)where get= ZT$lift $get put = ZT . lift . put Contrast this with GHC \ns newtype deriving construct, that would adopt the same behavior for(t1.t2)mas for t1 (t2 m), e.g., de.ning \nthe former s getin terms of the latter s as ZT get. In order to generally characterize the required behavior \nof monad subclass instances such as the above one for SM, we im\u00adpose the following law. Law 1 (Lift Compatibility). \nGiven any monad subclass constraint CM and any computation in this monad subclass x :: . m.CMm . m A, \nfor any type A. Then we must have that ~ (x ::(T1 . T2)MA). lift (x :: T2MA) for any monad transformers \nT1 and T2, and monad M such that CM (T2M)holds. Observe that this law holds for the above SM instance. \nAs we have no space to provide the details of all monad trans\u00adformer instances for the monad zipper, \nwe refer the interested readertoour implementationsusingourvariantoftheMTLlibrary3 and the Monatron library \n[10].4 In summary, like explicit lifting, the monad zipper allows us to shift the focus to layers below \nthe current focused layer via ~. However,unlikeexplicit lifting,wecanalsoshiftthefocustolayers above \nthe focused layer with .. As we saw in Section 2.4 the extra expressiveness of the monad zipper allows \nfor applications which are not possible with explicit liftings. 4. Views The general problem we face \nwhen composing e.ectful compo\u00adnents is that of incompatible assumptions about the monad stack. The solution \nis to work with one concrete monad stack, but to present each component with a suitable virtual monad \nstack. The correspondence between the concrete and virtual monad stack is capturedinaview.5In Section5wewillseehowtheviews \nframe\u00adwork bene.ts from the monad zipper. 4.1 VirtualViews as Monad Morphisms Semantically, a view corresponds \nto the categorical notion of a monad morphism (also called monad transformation in category theory,not \nto be confused with Haskell monad transformers that are a special case). Because we will be using di.erent \nrepresentations for monad morphisms, we capture the essential features in the MonadCategory type class. \n3http://users.ugent.be/ tschrijv/Haskell/MTLzipper.tgz 4http://hackage.haskell.org/package/Monatron 5Nottobe \nconfused withWadler s notionof view [28]. class MonadCategory (.)where idM ::(Monad m). m . m ( ) ::(Monadl, \nMonad m, Monad n) . (m . n)= (l. m)= (l. n) hmap ::(Monad m, Monad n, MonadTranst)  . (m . n)= (tm \n. tn) from ::(Monad m, Monad n). (n . m)= na = ma  The MonadCategory class describes a category with \nmonads as objects and monad morphisms as arrows. The identity and compo\u00adsition of the category are idM \nand( ), which satisfy the right and left identity, and associativity laws: v idM . v idM v . v v1 (v2 \n v3) . (v1 v2) v3 AHaskell monad transformert corresponds to an in.nite num\u00adber of monad morphisms in \na particular representation .: {from-1lift :: m . tm | m . Monad} At the same time not all monad morphisms \ncan be expressed by means of Haskell monad transformers.For instance, RT I . ST I does not re.ect the \napplicationofa monad transformertoa monad. What characterizes Haskell monad transformers is that they \nare functors over monad morphisms, and hmap allows mapping a morphism throughamonad transformer,which \nsatis.es the functor laws: hmap idM . idM hmap (v2 v1) . hmap v2 hmap v1 The from function applies \na monad morphism to a monadic com\u00adputation.Amonad morphism preserves the monad structure. from v. return \n. return from v (x > = f) . from v x > = from v . f  4.2 Uni-directionalViews Uni-directional views \nconstitute the obvious implementation of MonadCategory. newtype n . m = Uni (.a.na = ma) instance MonadCategory \n(.)where idM = Uni id v2 v1 = Uni $from v2 . from v1 hmap v = Uni $tmap (from v) from (Uni v)= v The \nabove implementation is mostly straightforward, but we require a new operation tmap supported by all \nmonad transformers to implement hmap. To avoid interrupting the .ow, we continue with uni-directional \nviews and refer to Section 7.2 for details on tmap. The lift function is the most prominent example of \na uni\u00addirectional view, which turns a monad transformer into the uni\u00addirectional view presentation: liftv \n::(MonadTranst, Monad m). m . tm liftv = Uni lift Uni-directional viewsforrestricted access Uni-directional \nviews are useful to restrict access to monadic layers that are shared by multiple components.Forexample, \nsupposewewantedtoprovide particular components only with read access to a shared state. The view r1 can \nbe used to achieve this.  r1 ::(MonadTranst, Monad m, SM s (tm)) . RT sm tm r1 = Uni $An = do s . get \nlift $runRT ns In this case the monad transformer t can be anystate monad trans\u00adformer (in particular \nit can be ST s).  4.3 Bi-DirectionalViews Some views are invertible. An invertible view is a monad isomor\u00adphism,or \nbi-directionalview.We capture bi-directionalviewsina separate datatype. data n &#38; m = Bi {from&#38; \n:: .a.na = ma , to&#38; :: .a.ma = na} Abi-directional view is of course an instance ofMonadCategory. \ninstance MonadCategory (&#38;)where idM = Bi {from&#38; = id , to&#38; = id} v2 v1 = Bi {from&#38; = \nfrom&#38; v2 . from&#38; v1 , to&#38; = to&#38; v1 . to&#38; v2} hmap v = Bi {from&#38; = tmap (from \nv) , to&#38; = tmap (to v)} from v = from&#38; v to ::(Monad n, Monad m). n &#38; m = ma = na to = to&#38; \ninverse ::(Monad n, Monad m). n &#38; m = m &#38; n inverse (Bi from to)= Bi to from where v inverse \nv . idM . inverse v v Abstract view constructor To abstract from theUni and Bi repre\u00adsentations of bi-directional \nviews, we provide an overloaded view constructor function. class MonadCategory (). View()where view::(.a.na \n= ma)= (.a.ma = na)= nm instance View()where viewf f-1 = Unif instance View(&#38;)where viewf f-1 = \nBif f-1 Using this constructor has the advantage that we canbuildover\u00adloadedviewsthatworknotonlyas bi-directionalviews,butalsoas \nuni-directional views. This is useful to capture isomorphic views like: stateIso ::(Monad m, View( )) \n. (s2 = s1)= (s1 = s2)= ST s2 m ST s1 m stateIsof f-1 = view (isof f-1)(isof-1f)where isoghm = ST$As2 \n= do (a, s1). runST m (hs2) return (a, gs1) without committing to bi-directional views in particular. \nIn this case stateIso converts between ST s1 m and ST s2 m where s1 and s2 are isomorphic. This is useful, \nfor instance, to share a state between components that expect values in di.erent units, or to employdi.erent \ncharacter or data encodings. Isomorphic Read-Only Views Consider how we can turn the uni\u00addirectional \nread-only view r1 into a bi-directional one. For that purpose, the target type RT sm is unsuitable because \nit cannot keep track of updates. So we need to alter the target type for bi\u00addirectional read-only views.Fortunately, \ncomponents are typically polymorphic in the monad stack and do not particularly care about a RT view; \nanyinstance of RM will do.We may put this freedom to gooduseby de.ningourown instancethatis(trivially) \nisomorphic with anystate monad. newtype SMRT sma = SMRT {runSMRT :: ma} instance SM sm . RM s (SMRT sm)where \nask = SMRT get instance MonadTrans (SMRT s) r ::(SM sm, View( )). SMRT sm m r = view runSMRT SMRT 5. \nMasks The operations on views presented in Section 4 can be seen as the foundation for a masking language \nfor monad transformers. Using this masking language it is possible to apply a mask to a particular monad \nstack to hide, restrict access or grant full access to the various layers in the monad stack. 5.1 Structural \nMasking Consider again the example program of Section 2.4 where two components, ifpos and comp > get, \naccess disjoint layers in the monad stack M. type M= ST Int (ST Int (ET String (ET String I))) The former \ncomponent accesses the second and third layer, while the latter component accesses the .rst and fourth \nlayer. The snag is that the same state monad transformer type is used for the .rst and second layer, \nand the same error monad transformer for the third and fourth layer. The repeated transformer types suggest \nto use the monad zipper, but thereisa complication.Sofarwehave usedthe monad zipper to create a single \nfocal point, ignoring a pre.x of the monad stack. What we need now are multiple focal points, ignoring \narbitrary partsof the monad stack inbetween.We achieve thisby composing multiple zippers intoa single \nview.Wecall suchaviewa structural mask,a mask because it hides particular layers of the monad stack, \nand structural because the form of the mask follows the structure of the monad stack (we will see non-structural \nmasks later). To facilitate writing structural masks, we formulate them in terms of two primitive (1-layer \nor 1-bit) masks D and _, and one combinator (:::) that associates to the left. The symbols D and _ denote \nrespectively a transparent and an opaquemask, similartorolethebits1and0playinabit mask.In our approach, \nD means as much as I want to see the current layer of the monad stack and _ means I don t want to see \nthe current layer . The (:::) combinator, that associates to the left, adds a 1-bit mask at the front \nof an n-bit mask, similar to the list cons operator (:). The views framework of Section 4 provides the \nappropriate infrastructure to implement the mask primitives: The D mask is nothing more than the identity \nisomorphism. D ::(Monad m, View( )). mm D = idM The _ mask captures another familiar isomorphism, that \nof the monad zipper. _ :: (MonadTranst1, MonadTranst2, Monad m, View( )) . (t1 . t2)m t1 (t2 m) _ = view \n~. Finally, the composition operator is: (:::) ::(Monad m, Monad n , MonadTranst1, MonadTranst2, View( \n)) . (t1n t2n)= (mn)= (t1m t2n) v1 ::: v2 = v1 hmap v2 So a mask that hides the second and third layer \nis  m2 :: ... . t1 (((t2 . t3). t4)m) t1 (t2 (t3 (t4 m))) m2 = D ::: _ ::: _ ::: D Similarly,we could \nwriteamask that hides the .rst and fourth layer as _ ::: D ::: D ::: _. However, the much shorter m1 \n:: ... . (t1 . t2)m t1 (t2 m) m1 = _ has exactly the same e.ect in this example. In conclusion, the \ndesired composition is client :: MInt client = from m1 (ifpos (to m1 (from m2 (comp > get))))  5.2 \nNominal Masking While the structural masking approach above resolves the issue of focusing on di.erent \nlayers, it can be awkward to use and maintain. Masking the stack requires global structural knowledge \nof the monad stack that is fragile with respect to changes. When the stack layout changes, all masks \nhave to be adjusted accordingly. As a remedy, we propose a nominal masking technique. A nominal mask \nspeci.es the names rather than the positions of the monad stack layers that a component may access. The \nlayers in the monad stack are correspondingly tagged with these names. Using the names and the tagged \nstack structure, the appropriate structural masks are automatically derived. This makes the approach \nmuch more robust: when the stack layers are reorganized (e.g. to insert a new layer or to swap two layers), \nthe structural masks are adjusted accordingly. Tagged Monad Stack The TT tag monad transformer labels \na particular position in the monad stack with a type-level name tag. newtype TT tagm a = TT {runTT :: \nma} instance MonadTrans (TT tag)where lift = TT which can be combined with other monad transformers, \ne.g. ST to create tagged transformers. type TST tags m = TT tag(ST sm) runTST :: Monad m . tag= s = TST \ntags m a = m (a, s) runTST tsm = runST(runTT m)s Singleton types are used for tag names, e.g. data Counter1 \n= Counter1 data Counter2 = Counter2 The type class TWith tag n m relates a monad stack n with a particular \nmask m that puts the focus on the layer with name tag. class (Monad m, Monad n). TWith tagn m where structure:: \nView(). tag= (nm) We refer to Appendix A for the instances implementing TWith; these automatically derive \nthe appropriate structural mask. Two convenient additional combinators are use :: TWith tagn m . na = \ntag= ma c use name = from&#38; (structure name)c expose:: TWith tagn m . ma = tag= na c expose name = \nto&#38; (structure name)c Hence, we may write c = do inc use Counter1 (inc > inc) use Counter2 return \n() to con.gure a number of incrementers. The stack layout is easily modi.ed without requiring changes \nto the component con.gura\u00adtion. > runI$runTST Counter2 5$runTST Counter1 0$c (((), 1), 7) > runI$runTST \nCounter1 0$runTST Counter2 5$c (((), 7), 1) The above approach can be extended from masking with a single \ntag to masking with a type-level list of tags. For instance, Counter1 &#38; Error1 represents a mask \nthat views both layers Counter1 and Error1. Here, (&#38;) is the constructor for non-empty type-level \nlists.We refer to the source code for all the necessary de.nitions. Moreover,itnicelyintegrateswiththeotherviews.For \ninstance, stateIsof f-1 structure Counter selects the layer named Counter and applies a state isomorphism \nto it.  5.3 Formal MaskParameters Sofar, we have applied masks, and views in general, on compo\u00adnentsina \nnon-invasivefashion, fromthe outside. However, views as formal parameters within components also have \nan important use in disambiguating di.erent instances of an e.ect. Obviously externally applied views \nare no solution to this problem that al\u00adready manifests itself inside a component. The traditional solution \nto disambiguate two di.erent states within a component is to use lift. Consider again the doubleInc example \nin Section 2.To disam\u00adbiguate the two states, we have used lift. Unfortunately, such in\u00adternally motivated \nuses of lift impose unnecessary ordering con\u00adstraints: in the monad stack one state transformer must \nappear above the other. Reversing the order of the two transformers is not possible; for that purpose \nwe need to change the component imple\u00admentation or write an alternate version. Explicit view parameters \nallow us to abstract from the ordering, similarly to tagged transformers [19, 25]but with two advantages: \n(i) we get the full expressivity of views for adapting the concrete monad stack, and (ii) we get the \nfull expressivity of bi-directional views for handling mutual embedding of components. doubleInc2 ::(MonadCategory \n(), SM Int n1 , SM Int n2, Monad m) . (n1 m)= (n2 m)= m Int doubleInc2 v1 v2 = do from v1 inc from v2 \ninc So doubleInc2 D_, doubleInc2 _D and doubleInc2 DD express both orderingsoftwodisjoint statesaswellasasingle \nshared state. Call-by-reference Operations It is possible to create variants of e.ectful operations that \ntake a view argument. For example, the getv and putv operations used in the add example in Section2are \nde.ned as: getv v = from v $get putv v = from v . put 6. Case Study: Monadic Mixins This section illustrates \nthe uses of the monad zipper and monad views on monadic mixins. Because monadic mixins are higher\u00adorder \ncomponents with non-trivial control .ow patterns, traditional mechanisms to manipulate the monad stack \ndo not provide ade\u00adquate support. However, with the monad zipper and monad views, the complex control-.ow \npatterns of monadic mixins do not pose a problem.  6.1 Monadic Mixin Components Mixins We brie.y summarize \nthe notion of mixins, and refer the interested reader to previous literature on the topic for a more \nin\u00addepth treatment [4].Asimple form of mixins can be easily imple\u00admented in Haskell as follows: type \nMixin s = s = s .x :: Mixin s = s .x a = a (.x a) (\u00ae)::Mixin s = Mixin s = Mixin s a1 \u00ae a2 = Aproceed \n= a1 (a2 proceed) The type Mixin s is a synonym for a function with type s = s representing open recursion. \nThe parameter of that function is called a join point, that is, the point in the component at which another \ncomponent is added. The operation \u00ae de.nes component composition. The function .x is a .xpoint combinator \nused for closing, or sealing, an open and potentially composed component. Combining monads with mixins \nWhen combined with monads, mixinsallowusto modela simpleformofAOP-like advice[17]. However, the control-.ow \npatterns of programs using mixins are complex.For instance, consider the followingmemoization com\u00adponent \nand a monadic .bonacci function. memo :: SM(Map Int Int)m . Mixin (Int = m Int) memo proceed x = do m \n. get if member x m then return (m !x) else do y. proceed x m '. get put (insert xym ') returny .b \n:: Monad m . Mixin (Int = m Int) .b proceed n = case n of 0= return 0 1= return 1 = do y. proceed (n \n- 1) x . proceed (n- 2) return (x + y) We can instantiate di.erent monads, using the corresponding run \nfunctions of Figure 1, to recover variations of the .bonacci func\u00adtion.Forexample, the identity monad \nrecovers thee.ect-free func\u00adtion whileafast .bonacci functionis obtainedby addingthe memo advice and \nsuitably instantiating the state monad: slow.b :: Int = Int slow.b = runI. .x .b fast.b :: Int = Int \nfast.b = evalM empty . .x (memo \u00ae .b) evalM :: s = ST s I a = a evalM s m = runI$runST ms > = return. \nfst Another component for pro.ling is prof :: SM Int m . Mixin (a = mb) prof proceed x = do c . get \nput (c+ 1) proceed x which allows us to count the number of calls to the .bonacci function pro.b= evalM \n0. .x (prof \u00ae .b) Transformer Con.icts Of course, we would also like to pro.le the memoized .bonacci \nfunction to get an idea of how much more e.cient it is. profmemo.b :: Int = ST Int (ST(Map Int Int)I)Int \nprofmemo.b = .x (prof \u00ae memo \u00ae .b) Unfortunately, the type checker complains that Int and Map Int Int \nare distinct types. The problem is that there are two uses of get in our components: one in prof; and \nanother in memo. Due to automatic lifting, both get methods read the state from the same top-level ST, \nwhich happens to contain an Int value. This is the right thing to do for prof,but wrong for memo that \nexpects a value of type Map Int Int. 6.2 Zipping Mixins The problem above can be solved using the monad \nzipper to pro\u00advide a new composition operator 0 for mixins. (0) :: Mixin (a = t1 (t2 m)b) = Mixin (a \n= (t1 . t2)mb) = Mixin (a = t1 (t2 m)b) c1 0 c2 = Aproceed x = c1 (~. c2 (.. proceed)) x This combinator \nassociates the left-to-right order of components with a corresponding top-to-bottom order of monad layers. \nHere component c1 focuses on the current layer, and c2 looks one posi\u00adtion down that s why we have to \nbring proceed down(.)to its level and shift the whole back up(~)to the current level. This combinator \nis very useful whenever we have a set of com\u00adponents that uses a disjoint set of monads (that is, each \ncomponent will use di.erent monads). No additional work is needed to make the two state transformers \nof prof and memo happily coexist. profmemo.b :: Int = ST Int (ST(Map Int Int)(IT I)) Int profmemo.b = \n.x (prof 0 memo 0 .b) Note that every component has its own transformer, notably IT for .b, and we use \nthe base monad I at the bottom of the stack.  6.3 Views and Masks When using mixins we generally need \nthe full power of bi\u00addirectional views to shift between two isomorphic monads. To make this shifting \nconvenient we use the following combinator: fmask ::(Monad m, Monad n) . (n &#38; m)= Mixin (a = nb)= \nMixin (a = mb) fmask v mix proceed = from v. mix (to v . proceed) mix usesm names = fmask (structure \nnames)mix The fmask combinator takes a view v and applies it to a mixin mix executing the to function \nafter proceeding and the from function after the mixin. Nominal views are applied with usesm. To demonstrate \nthe application of masks and views on monadic mixin components, consider a simple assertion component \nthat is usedto checkthe outputofa computation.Wewillshowhowthis component is useful for checking whether \nthe result of computing the .bonacci function has over.owed or not. assertDump ::(EM String m, RM sm, \nShow a, Showb, Show s) . (b= Bool)= Mixin (a = mb) The assertDump component applies an assertion (a function \nof type b= Bool)to the output ofproceed scomputation. If the asser\u00adtionfails,an erroris raised.The error \nmessage includes information onthe stateatthetimeofthe error,tofacilitatedebugging. This assertDump componentallowsthe \ncreationof anothervari\u00adant of the .bonacci program where, along with memoization and pro.ling, we also \ncheck for over.ow and dump the memo table when over.ow happens. Because we may be interested in recov\u00adering \nfrom the over.ow (for example, by changing the represen\u00adtations of the inputs and outputs from Int to \nInteger)and continu\u00ading the computation, the exception layer should be at the top of the stack. Also, \npro.lingworks betterifitisexecuted before memoiza\u00adtion, so the pro.ler component should be in between \nassertDump and memo. However, assertDump requires access to the monadic layer with the memo table. In \norder to combine these components together we should make sure that all the constraints are satis.ed. \n Because there is no simple one-to-one correspondence between mixins and stack layers, we use the nominal \napproach. In addition, the r imposes a read-only view on the Memo state for assertDump. test :: Int = \n((Either String Int, Int), Map Int Int) test = myEval . .x ( assertDump (> 0) fmask r usesm Err &#38;Memo \n\u00ae prof usesm Prof \u00ae memo usesm Memo \u00ae .b) myEval m = runI$runTST Memo empty $runTST Prof 0 $runTET \nErr $m  6.4 Monadic Mixins in Practice: Search Combinators Schrijvers et al. [24] present a compelling \napplication of the monadic mixins. TheyprovideaDomain Speci.c Language (DSL) forexpressinga complex search \nheuristicasa concise combination of primitive combinators. In their implementation, each primitive combinator \ncorresponds to a monadic mixin component. The ad\u00advantage and novelty is twofold: 1) .exibility because \nthe user is ableto combine combinatorsanywayshewants,and2) extensibil\u00adity because the system developer \nis able to add new combinators without touching the existing ones. To .t in with the Gecode C++ Constraint \nProgramming li\u00adbrary and for performance reasons, a staged approach is taken. The Haskell mixin components \nare code generators that collaborate to produce the C++ code for the overall search algorithm. For ex\u00adample, \na search heuristic tailored to solving radiation therapyplan\u00adning problems [1] of typical size consists \nof 20-30 monadic mixins, each with theirown monad transformer,that collaborateto produce around 2000 \nlines of specializedC++ code.We are notawareof other Haskell projects with comparable monad stack sizes. \nE.ect Encapsulation Additionally to the techniques already in\u00adtroducedbyus earlierinthis section,the \nsearch combinatorsappli\u00adcation employsatechnique thatfacilitates the dynamic composition of manymixin \ncomponents froma parsed speci.cation string: each component encapsulates its own e.ect. Even statically \nthis encap\u00adsulation makes sense. After all, the type of a monad stack with 20 layers is rather unwieldy. \nThe Component datatype below illustrates the encapsulation technique on the simple Mixin type.6 Thee.ect \nt2 of the component is existentially quanti.ed to hide it, and the included run function allows eliminating \nit. data Component ab = . t2.MonadTranst2 . Component {behavior :: . t1 m.(MonadTranst1, Monad m) . Mixin \n(a = (t1 . t2)mb) , run :: . mx.Monad m . t2 m x = mx} While not all monad transformers support a run \nfunction of the above type, it is convenient and su.cient for our search combina\u00adtors.For more details \non the encapsulation technique anda more general form of run function, we refer to [22, Section 3.4]. \n6The mixin record type of search components is too elaborate to show here. Performance Considerations \nWe have not performed any sys\u00adtematic benchmarks yet, but do have a few observations on per\u00adformance. \nBecause it is de.ned as a newtype, wrapping and un\u00adwrapping the monad zipper does not add anyspace or \nruntimeover\u00adhead. It does generate di.erent type class dictionaries for the di.er\u00adent components, and \ndepending on the amount of inlining this ei\u00adther happens once (statically)or repeatedlyforeachinvocationofa \ncomponent (dynamically). The latter scenario notably arises when the e.ect types areexistentially quanti.ed.Wehave \nobserved that this repeated creation of dictionaries puts compositions with around 60 monad transformers \nout of reach. In conclusion, gracefully and predictably scaling performance to monad stack sizes well \nbeyond 30 layers is an open challenge. 7. Discussion and RelatedWork 7.1 The Haskell Setting Our approachmakesuseoftwokeyingredients, \nmonadictypesand constrained polymorphism, which are both available in Haskell. The combination of these \nprovides the necessary .exibility for e.ectful components to be adapted to manydi.erent settings. One \nimportant advantage of using of Haskell is type-inference. In a setting like ours, where types can be \nrelatively complex, type\u00adinference is a blessing and allows most types to be inferred auto\u00admatically. \nIndeed, although we have often used type annotations in our examples for documentation, those annotations \nare (for the most part) not necessary. While Haskell provides the two necessary ingredients, there is \npotential for transferring the presented ideas to other settings. The monad zipper, views and structural \nmasks have category theory interpretations and as such are of a more general nature. Indeed, they are \nrelevant and adaptable to other settings that deal with explicit e.ects. Haskell-speci.c implementation \naspects can .nd alternative counterparts in other languages.For instance, in Scala implicits can replace \ntype classes [16]. The type-class tricks to look up names for nominal masks, popularized by Kiselyov \n[12], could be considerably simpli.ed in a dependently typed language. Finally, a language design that \nnatively supports the presented concepts is another option.  7.2 E.ect Systems and Modular Monads E.ect \nsystems (also known as type-and-e.ect systems) [14] form a popular non-monadic approach for making side \ne.ects explicit. However, theyonly describe (and do not de.ne) programs that al\u00adready have a meaning \nindependent of the e.ect system. Hence, the e.ect annotations cannot adapt component behavior. Filin\u00adski \ns MultiMonadic MetaLanguage (M3L) [7, 8] does embrace the monadic approach, but uses subtyping (or sube.ecting) \nto com\u00adbine the e.ects of di.erent components. The subtyping relation is .xed at the program or language \nlevel, which does not provide the adaptability we achieve with constrained polymorphism. Since Moggi \n[15] proposed monads to model side-e.ects, and Wadler [30] popularized them in the context of Haskell, \nvarious researchers (e.g., [11, 26]) have sought to modularize monads. Monad transformers emerged [3, \n13] from this process, and in later yearsvarious alternative implementation designs,facilitating monad \n(transformer) implementations, have been proposed, such as Filinksi s layered monads [6] and Jaskelio. \ns Monatron [10]. In this paper, we rely on several of Monatron s techniques for implementing monad transformers. \nHowever, so as not to confuse the reader, we have incorporated the necessary techniques form Monatron \nin the familiar setting of the Monad Transformer Li\u00adbrary7 (MTL). 7which implements the original ideas \nof [13]  InourvariantoftheMTL, 8 monad transformershavetosupply two additional operations, tmap and \nmw, which are inspired by Monatron: class MonadTranst where lift :: Monad m . ma = tma tmap ::(Monad \nm, Monad n) . (.x.mx = nx)= tma = tna mw :: Monad m . MonadWitnesst m Here, tmap allows transforming \nthe monad underneath a trans\u00adformer t.We have two uses for this additional operation: Our .rst use, just \nlike in Monatron, is to lift control opera\u00adtors like catchError and local through other transformers; \nin the original MTL these operations could not be lifted. In our setting, it enables us to implement \nthese control operators ap\u00adpropriately for the zipper(.). For instance, here is the zipper implementation \nof the local operator from the RM type class: localf m = ZT$tmap (localf )$runZT m The second use, already \ncovered in Section 4, is for the im\u00adplementation of the hmap function of the MonadCategory type class. \n The mw method encodes the property .m.Monad m . Monad (tm) as a GADT witness. data MonadWitnesst m \nwhere MW :: Monad (tm). MonadWitnesst m In the original MTL, this property holds informally,but is neither \nenforced nor exploitable. We require this property to implement many of the zipper s operations. For \ninstance, the return method for the zipper is de.ned as: return x = case (mw :: MonadWitnesst2 m)of MW \n= case (mw :: MonadWitnesst1 (t2 m)) of MW = ZT$return x In the Monatron design, the property is directly \nconveyed to the type checker in the form of a single type class instance: instance (Monad m, MonadTranst). \nMonad (tm)where ... However, this approach is not compatible with the MTL design. Hence, our GADT witness \napproach. Alimitation oftmap, both in Monatron and our MTL variant, is thatitonlyworksforcovariant monad \ntransformers.For instance, the contravariant continuation monad transformer cannot imple\u00adment this operation. \n 7.3 Tag-indexed monads Ithasbeen independently suggestedbySnyder&#38;Alexander[25] and Piponi [19] \nthat indexing monad transformers with a type\u00adlevel tag improves their convenience and robustness to changes. \nMTLX[25]isa monad transformer librarythat embodiesthis idea: automatic lifting ambiguities are resolved \nby tags. For example, consider the programs p1 and p2 written, respectively, in the MTL and MTLX. p1 \n::(SM Int m, SM Bool m). m Int p1 = do b. get x . get return (if bthen x else 0) 8available at http://users.ugent.be/ \ntschrijv/Haskell/ MTLzipper.tgz. p2 ::(SM Ix1 Int m, SM Ix2 Bool m). m Int p2 = do b. get Ix1 x . get \nIx2 return (if bthen x else 0) The p1 program does not type-check because the functional depen\u00addencies \nin the type class SM require that the state type is uniquely determined by m,but in this program two \ndi.erent state types are used. The program p2,written for MTLX, solves this issuebyusing a SM class with \na third type parameter, which is used to index the monad and determine the state type (along with the \nmonad type), which avoids the con.ict in p1. The main advantage of indexed monads is that theysimplify \nthe implementation of monadic components with multiple instances of the same e.ect. However tags commit \nto global names, which restricts reuse. If the lack of .exibility is not an objection, tags are a good \nsolution. However,when the primary focus is .exibility and reusability, tags have important drawbacks \ncompared to the monad zipper and monad views. In the MTLX approach, it is possible to abstract over the \ntag in order to be able to choose the monad layer later.For example: inc ::(SM ix Intm). ix = m Int inc \nix = do x . get ix put ix (x + 1) return (x + 1) This value-level abstraction is more verbose than the \nmonad zip\u00adper s type-level abstraction; it is an invasive approach that requires the component to be \nwritten with tags in mind. Moreover, for the priceofvalue-level abstraction,wegetalot moreexpressivityfrom \nviews: restricting access to layers is not possible with tags. Finally, a prede.ned set of tags is unsuitable \nwhen components are gen\u00aderated and composed dynamically, as in our search combinators application. Ultimately, \nindexed monads and our techniques are useful for solving di.erent problems and it is possible to get \nthe bene.ts of both approaches by combining some of the techniques. For example, if we added monad views \nand the monad zipper to MTLX, wecoulduseviewsto virtualizethetagnames,byrenamingoreven removing the tags \nto suit the client s monad stack, and e.ectively acting as a scoping mechanism for the name tags.  7.4 \nMonadic Components Many workshave identi.ed a need for reusable monadic compo\u00adnents,buthavenot addressedthe \nlimitations relatedto monad stack management. Mixins were introduced by Cook [4] as a functional form \nof inheritance. Brown and Cook [2] .rst considered monadic mixins for memoization, while Oliveira et \nal. [17] model arbitrary AOP-style advice with them and showhowto reason about interfer\u00adence between \ntwo components based on equational reasoning and parametricity.Ourwork should enablea generalizationofthe \nlatter reasoning results to scenarios with arbitrarily many components. Prehofer [20] also considers \na monadic model for FOP, which is not based on mixins. The techniques presented in this paper can be \nused to improve the current state-of-the-art approaches to modular interpreters [5, 13, 27]. We describe \na modular e.ectful interpreter case study, which uses the techniques presented in this paper, in a separate \nmanuscript [23]. 8. Conclusion The current-state-of-the-art in monad stack management is too re\u00adstrictive \nto e.ectively support reusable monadic components. The monad zipper provides the basic mechanism to lift \nthese restric\u00adtions, and enables more powerful solutions such as structural and nominal masking.Views \nunite masks and other monad transforma\u00adtions in a single framework for adapting monadic components to \na wide range of monad stacks.  Acknowledgments We are grateful to the anonymous reviewers, Jeremy Gibbons, \nheisenbug, Mauro Jaskelio., Wonchan Lee, Wouter Swierstra, Tarmo Uustalu, PhilWadler, StephanieWeirich \nand the members of IFIP WG 2.1 for their help and feedback. Bruno Oliveira is supported by the Engineering \nResearch Cen\u00adterof Excellence ProgramofKorea Ministryof Education, Science andTechnology (MEST) / Korea \nScience and EngineeringFoun\u00addation (KOSEF) grant R11-2008-007-01002-0 and the Mid-career Researcher Program \n(2010-0022061) through NRF grant fundedby the MEST. References [1]D. Baatar,N. Boland,S. Brand,andP. \nStuckey.CPandIP approaches to cancer radiotherapydelivery optimization. Constraints, 2011. [2]D.BrownandW.R. \nCook. Monadic memoization mixins.Technical Report TR-07-11, The UniversityofTexas, 2007. [3] P. Cenciarelli \nand E. Moggi. A syntactic approach to modularity in denotational semantics. In CCTCS 93: Proceedings \nof the Conference on Category Theory and Computer Science, 1993. [4] W. R. Cook. A Denotational Semantics \nof Inheritance. PhD thesis, Brown University, 1989. [5] L. Duponcheel. Writing modular interpreters using \ncatamorphisms, subtypes and monad transformers. Technical report, Utrecht Univer\u00adsity, 1995. [6] A. Filinski. \nRepresenting layered monads. In Proceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of \nprogramming languages, POPL 99, pages 175 188, 1999. [7] A. Filinski. On the relations between monadic \nsemantics. Theor. Comput. Sci., 375:41 75, April 2007. [8] A. Filinski. Monads in action. In Proceedings \nof the 37th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages, POPL 10, pages \n483 494, 2010. [9] G. Huet. Functional Pearl: The Zipper. Journal of Functional Pro\u00adgramming, 7(5):549 \n554, September 1997. [10] M. Jaskelio.. Monatron: An extensible monad transformer library. In IFL 08: \nSymposium on Implementation and Application of Functional Languages, 2008. [11]M.P.JonesandL. Duponcheel. \nComposing monads. ResearchReport YALEU/DCS/RR-1004, Yale University, New Haven, Connecticut, USA, December \n1993. [12] O. Kiselyov, R.L\u00a8 ammel, and K. Schupke. Strongly typed heteroge\u00adneous collections. In Haskell \n04: Proceedings of theACM SIGPLAN workshop on Haskell, pages 96 107, 2004. [13] S. Liang,P. Hudak, and \nM. Jones. Monad transformers and modular interpreters. In POPL 95, 1995. [14] J. M. Lucassen and D. K. \nGi.ord. Polymorphic e.ect systems. In Proceedingsofthe15thACM SIGPLAN-SIGACT symposiumonPrin\u00adciples of \nprogramming languages, POPL 88, pages 47 57, 1988. [15]E.Moggi.An abstractviewof programming languages.TechnicalRe\u00adport \nECS-LFCS-90-113, Edinburgh University, Department of Com\u00adputer Science, June 1989. [16]B.C.d.S.Oliveira,A.Moors,andM.Odersky.Type \nclassesasobjects and implicits. In OOPSLA 10:Proceedings of theACM international conference on Object \noriented programming systems languages and applications, pages 341 360, 2010. [17] B. C. d. S. Oliveira,T. \nSchrijvers, andW. R. Cook. E.ectiveadvice: Disciplined advice with explicit e.ects. In AOSD 10: ACM SIG \nProceedings of the 9th International Conference on Aspect-Oriented Software Development, 2010. [18] S. \nPeyton Jones et al. The Haskell 98 language and libraries: The revised report. Journal of Functional \nProgramming, 13(1):0 255, Jan 2003. [19] D. Piponi. Tagging monad transformer layers, 2010. http://blog. \nsigfpe.com/2010/02/tagging-monad-transformer-layers. html. [20] C. Prehofer. Flexible construction of \nsoftware components:Afeature oriented approach. Habilitation Thesis,Fakult\u00a8atf\u00a8ur Informatik der Technischen \nUniversit\u00a8atM\u00a8unchen, 1999. [21] J. C. Reynolds. Types, abstraction, and parametric polymorphism. Information \nProcessing, 83:513 523, 1983. [22] T. Schrijvers and B. C. d. S. Oliveira. Modular components with monadic \ne.ects. In Preproceedings of the 22nd Symposium on Im\u00adplementation and Application of Functional Languages \n(IFL 2010), number UU-CS-2010-020, pages 264 277, 2010. [23] T. Schrijvers and B. C. d. S. Oliveira. \nThe monad zipper. Report CW 595, Dept. of Computer Science, K.U.Leuven, 2010. [24] T. Schrijvers, G. \nTack, P. Wuille, H. Samulowitz, and P. Stuckey. Search combinators. In Proceedings of the 17th International \nCon\u00adference on Principles and Practice of Constraint Programming, 2011. [25] M. Snyder andP. Alexander. \nMonadfactory:Type-indexed monads. In TFP 2010: Preproceedings ofTrends in Functional Programming, pages \n106 120, 2010. [26]G.L. Steele,Jr. Building interpretersbycomposing monads.In POPL 94: Proceedings of \nthe 21stACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 472 492, 1994. [27] \nW. Swierstra. Data types ` a la carte. J. Funct. Program., 18(4):423 436, 2008. [28] P. Wadler. Views: \na way for pattern matching to cohabit with data abstraction. In POPL 87, pages 307 313, 1987. [29]P.Wadler. \nTheoremsfor free!In Functional Programming Languages and Computer Architecture, pages 347 359. 1989. \n[30]P.Wadler. Monadsfor functional programming.In Proceedings of the Marktoberdorf Summer School on Program \nDesign Calculi, August 1992. [31] P. Wadler. The essence of functional programming. In POPL 92: Principles \nof Programming Languages, pages 1 14, 1992. [32]P.WadlerandS. Blott. Howtomake ad-hoc polymorphism lessad \nhoc. In POPL 89: Proceedings of the 16thACM SIGPLAN-SIGACT symposium on Principles of programming languages, \npages 60 76, 1989. A. TWith Instances In this appendix, we provide the implementation of the overloaded \nstructure function as a set of .ve overlapping instances for the TWith class. Three instances cover the \nthree possible cases and two instances resolve overlaps between the three possible cases. Although the \nimplementation below may look daunting to the uninitiated, it relies only on folklore type-level programming \ntech\u00adniques. Moreover, the user is never directly confronted with these instance implementations. --[1] \ntag at the top instance (Monad m, m.n). TWith tag n (TT tag m)where structure = t --auxiliary clause, \nto resolve overlap between [1] and [3] instance (Monad m, m.tn, MonadTranst) . TWith tag m (TT tag (tn)) \nwhere structure = t --[2] tag in focus instance (Monad m, Monad n, MonadTranst, m.tn) . TWith tag m \n((t. TT tag)n)where  structure = case (mw :: MonadWitnesst (TT tag n)) of MW = _ -1 hmapt --auxiliary \nclause, to resolve overlap between [2] and [3] instance (Monad (t ' n), Monad m, Monad n, MonadTranst, \nm (((t. TT tag). t ')n), MonadTranst') . TWith tag m ((t. TT tag)(t ' n)) where structure = case (mw \n:: MonadWitnesst' n)of MW = _ --[3] shift focus down instance (Monad (t0 (t1 n)), Monad m, Monad n, \nTWith tag m ((t0 . t1)n), MonadTrans t0, MonadTranst1) . TWith tag m (t0 (t1 n)) where structure tag \n= case (mw :: MonadWitnesst1 n)of MW = case (mw :: MonadWitness t0 (t1 n)) of MW = _ structure tag \nThe above instances make use of the following auxiliary functions: t:: View(). m TT tag m t = view TT \nrunTT _ -1 = view .~      \n\t\t\t", "proc_id": "2034773", "abstract": "<p>We make monadic components more reusable and robust to changes by employing two new techniques for <i>virtualizing</i> the monad stack: the <i>monad zipper</i> and <i>monad views</i>. The <i>monad zipper</i> is a higher-order monad transformer that creates <i>virtual</i> monad stacks by ignoring particular layers in a concrete stack. <i>Monad views</i> provide a general framework for monad stack virtualization: they take the monad zipper one step further and integrate it with a wide range of other virtualizations. For instance, particular views allow restricted access to monads in the stack. Furthermore, monad views provide components with a <i>call-by-reference</i>-like mechanism for accessing particular layers of the monad stack.</p> <p>With our two new mechanisms, the monadic effects required by components no longer need to be literally reflected in the concrete monad stack. This makes these components more reusable and robust to changes.</p>", "authors": [{"name": "Tom Schrijvers", "author_profile_id": "81100049265", "affiliation": "Universiteit Gent, Gent, Belgium", "person_id": "P2801368", "email_address": "tom.schrijvers@ugent.be", "orcid_id": ""}, {"name": "Bruno C.d.S. Oliveira", "author_profile_id": "81310493622", "affiliation": "Seoul National University, Seoul, South Korea", "person_id": "P2801369", "email_address": "bruno@ropas.snu.ac.kr", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034781", "year": "2011", "article_id": "2034781", "conference": "ICFP", "title": "Monads, zippers and views: virtualizing the monad stack", "url": "http://dl.acm.org/citation.cfm?id=2034781"}