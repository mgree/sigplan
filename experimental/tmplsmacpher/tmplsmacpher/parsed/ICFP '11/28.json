{"article_publication_date": "09-19-2011", "fulltext": "\n Making Standard ML a Practical Database Programming Language* Atsushi Ohori Katsuhiro Ueno Research \nInstitute of Electrical Communication Tohoku University {ohori, katsu}@riec.tohoku.ac.jp Abstract Integrating \na database query language into a programming lan\u00adguage is becoming increasingly important in recently \nemerging high-level cloud computing and other applications, where ef.cient and sophisticated data manipulation \nis required during computa\u00adtion. This paper reports on seamless integration of SQL into SML# anextensionof \nStandardML.Intheintegrated language,thetype system always infers a principal type for anytype consistent \nSQL expression. This makes SQL queries .rst-class citizens, which can be freely combined with anyother \nlanguage constructs de.nable in StandardML.Fora programinvolvingSQL queries,the compiler separates SQL \nqueries and delegates their evaluation to a database server, e.g. PostgreSQL or MySQL in the currently \nimplemented version. The type system of our language is largely based on Machi\u00adavelli, which demonstrates \nthat ML with record polymorphism can represent type structureof SQL.In ordertodevelopa practical lan\u00adguage, \nhowever, a number of technical challenges have to be over\u00adcome, including static enforcement of server \nconnection consis\u00adtency, proper treatment of overloaded SQL primitives, query com\u00adpilation, and runtime \nconnection management. This paper describes the necessary extensions to the type system and compilation, \nand reports on the details of its implementation. Categories and Subject Descriptors H.2.3[Database Manage\u00adment]: \nLanguages Database (persistent) programming languages General Terms Design, Languages Keywords SQL, Polymorphism, \nType System, Interoperability, SML# 1. Introduction Smooth integration of a database query language into \na program\u00adming language is essential for anyhigh-level applications that re\u00adquire ef.cient processing \nof large amount of data. The need of this * The authors were partially supported by the Japan Society \nfor the Promo\u00adtion of Science Grant-in-Aid for Basic Research (C) grant no. 22500023. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page.To copyotherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 11, September 19 21, \n2011,Tokyo, Japan. Copyright c &#38;#169; 2011ACM 978-1-4503-0865-6/11/09... $10.00 integration will \nbecome particularly important in recently emerg\u00ading high-level cloud computing, where sophisticated data \nmanipu\u00adlation beyond simple data aggregation will be required. Query lan\u00adguage integration will also \nmake currently wide-spreadWeb pro\u00adgramming through various meta-level framework such as Ruby on Rails \nmuch more reliable. The need of proper integration of a database query language anda programming language \nhas been recognized andinvestigated in database programming community for more than two decades. See \n[4] for an early survey in this area. Since then a number of query language bindings and embeddings in \ngeneral purpose pro\u00adgramming languages have been proposed and implemented. Ex\u00adamples include SQLJ [13] \nand more recent LINQ [23] and Ferry [16] middle-ware. Compared with SQL command string interface to database \nservers, these database binding frameworks certainly increase .exibility and ease of use in accessing \ndatabases from pro\u00adgramming languages. However, theystill do not achieve seamless integration of a database \nquery language into a host language type system. Existing database bindings either restrict full functionality \nand generality provided by their target database servers, or theydo not treat database queries as .rst-class \ncitizens in the type systems of the host programming languages. There have also been a number of proposals \nfor high-level database programming languages that integrate declarative queries in their type systems. \nSome notable examples include GemStone (OPAL) [11], Machiavelli [30], O2 [19], and Fibonacci [2] to nameafew.Whilethese \napproachesprovide uniformintegrationof database queries in a programming language, it remains to be seen \nwhether or not some of these approaches would become a practi\u00adcal alternative to SQL. Based on long and \nintensive research and development of the relational data model [8], relational database systems have \nrealized highly optimized data manipulation for large amount of data with various practical supports \nsuch as transaction management and network access. All of these features are made available through SQL, \nwhich is the well established and stan\u00addardized query language for relational database systems. Perhaps \ndue to this reason, most of applications that require both ef.cient database manipulation and programming \nstill use general purpose programming languages such as C or Java with SQL command string interface to \na relational database server. This situation indicates that an impedance mismatch [22] betweenadatabase \nsystem andaprogramming language stillexists in practice. To eliminate this mismatch, we must develop \na high-level pro\u00adgramming language that seamlessly integrates SQL in such a way that SQL queries are \n.rst-class citizens in the language type sys\u00adtem and that they are evaluated by a practical database \nserver. This paper reports on one such integration, where SQL is seamlessly in\u00adtegrated in SML# [32], \nan extension of Standard ML [24]. In our development, we adopt polymorphic typing of Machiavelli [30], \nwhere the authors suggested that the programming language ML can be extended with an SQL-style declarative \nquery language. The language proposed in [30] is, however, conceptual one focus\u00ading only on typing issues; \nno implementation strategy is considered or developed. As outlined in the next section, a number of techni\u00adcal \nchallenges have to be overcome before a practical language can become a reality. In the present paper, \nwe have solved those prob\u00adlemsandhavedevelopedacompilerforSML#extendedwithSQL. In this extended language, \nSQL queries are .rst-class expressions directly de.nable in the language type system, and are evaluated \nbyanexternal database server. Thankstothis feature, StandardML programmers can readily enjoyef.cient \nand practical database pro\u00adgramming in their Standard ML code.  In addition to solving technical problems \nin language design and typing, we have also developed an implementation technique for connecting static \nsemantics of SQL in the host language type system,andits dynamic semantics realizedbyanexternal database \nserver. This should be useful for extending a typed higher-order language with various domain speci.c \nlanguages, not restricted to SQL. All the results reported in this paper has been implemented in our \nSML# compiler. Most of them have already been made available in SML# version 0.60 or later releases [32]. \n 1.1 Related works Before presenting our technical development, we compare our ap\u00adproach with some more \nrelated works. The conventional and still widely used approach to database programming is to construct \nSQL command strings directly and send them to a database server using low-level database server interfaces \nsuch as SQL/CLI and JDBC. Embedded SQL such as ECPG of PostgreSQL and SQLJ [13] supports a form of macro \nSQL statements that are expanded by a preprocessor to those low\u00adlevel database library calls. Both of \nthem are unsatisfactory in many ways; type-checking is far from adequate, and the interac\u00adtion with the \nhost language construct is rather limited. In order to improve type safety and host language interface \nof preprocessor\u00adbased approach, several domain speci.c embedded languages [18] havebeen proposed and \nimplemented. HaskellDB [20] implements a set of monadic term constructors corresponding to relational \nop\u00aderators. A RARAT [14] provides C++ template for composing SQL queries. Ur/Web [7] provides a meta-programming \nframework for the programmer to generate type-consistent SQL queries through type computation. LINQ [23] \nand Ferry [16] attempt to provide a language independent layer for querying various data structures including \nrelational database. DHS [15] implements a combina\u00adtor library for generic manipulation of collection \ntypes that are to be compiled to Ferry. While these approaches provide high-level database access, theydo \nnot fully achieve seamless integration of SQL into a general purpose programming language to the extent \nwe wish to achieve. We note that SQL is an algebraic language based on the rela\u00adtional algebra.In this \nlanguage, relation-valuedexpressions includ\u00ading SELECT expressions can be used to construct another query \nex\u00adpression. This properly makes SQL an elegant and powerful data al\u00adgebra for relations. Seamlessly \nintegrating SQL in a programming language must at least mean that relations are .rst-class citizens and \ntheir operations are freely combined with other language con\u00adstructs in the host programming language. \nThis is a common-sense knowledgein functional programming.Forexample, consider the case of integrating \nan algebra of lists in ML. Everyone unanimously expects that lists are .rst-class citizens and associated \noperators to construct and manipulate lists can be freely combined with any other language constructs. \nSQL should be given the same status, without scarifying its features speci.ed in the standardized lan\u00adguage \nde.nition and its ef.ciency realized by a matured external database server. Unfortunately,however, there \ndoes not seemtoex\u00adist any implemented general purpose programming language that achieves this status \nfor SQL. This is the property we attempt to achieve in SML#. Since relations are well-de.ned mathematical \nobjects, it should be possibletoextendatype theoryof programming languages with data algebra on relations. \nBased on this general observation, several database programming languages have been proposed, including \nGemStone [11], Machiavelli [30], Napier88 [26], Iris [3], Fibonacci [2], and Kleisli [34]. All of those \nlanguages, by their construc\u00adtion, seamlessly integrate advanced database queries in their type systems \nand evaluation models. See [33] for various typing issues in database queries, and [21] for a survey \non various approaches to database and language integration. However, it is non-trivial to make those \nlanguages practical database programming languages that can handle hundreds of millions of tuples ef.ciently. \nCom\u00adpared with the high maturity of optimization and implementation techniques of relational database \nsystems, optimization and imple\u00admentation techniques for advanced data models realized in those new database \nprogramming languages do not seem to have been well developed. The goal of the present paper is to make \nthe SQL itself seam\u00adlessly available in a practical general purpose programming lan\u00adguage.Forthis purpose,we \nmust .rstextendthetype systemofthe host programming language so that SQL statements can be repre\u00adsentable \nas typed expressions. An extension of ML type inference for generalized relational algebra presented \nin [29] is perhaps the .rst such example. This type system and its re.nement [28] were the basis of the \ntype system of Machiavelli [6, 30].We design our type system largely based on this approach. However, \nin this pa\u00adper, instead of uniformly integrating generalized relational algebra in its type system and \nevaluation model, we develop a type system that precisely represents polymorphic typing of the SQL language \nitselfas de.nedinits language standard,anddevelopacompilation method to delegate their evaluation to \nan external database server. This requires careful design and development beyond the language design \nreported in [6, 30]. Another approach to integrate database queries and program\u00adming constructs is to \ncompile high-level expressions into SQL [9]. Links [10] takes this approach in designing a Web programming \nsystem. The type system sketched in [10] appears to be based on the observation similar to [6, 30] it \nuses sorted row variables [31] in\u00adsteadof kinded typing[28,29],but thesetwo formalismson record polymorphism \nare equivalent for typing query expressions. Links compiles relation-valued expressions, possibly involving \nfunction applications and other language constructs, into SQL. The resulting system achieves integration \nof database queries and programming language constructs,butthisisonlytotheextentthatthe language constructs \ncan be compiled to SQL commands. While this compile-to-SQL approach would be useful for some target areas \nsuch as Web programming, it is not obvious that this approach scales up to large and complex application \ndevelopment that requires a general purpose programming language and the full functionality of SQL. We \nnote that any practical general purpose programming lan\u00adguage involves a number of advanced features \nto form a complex system whose semantics can (at least under the current state-of-the\u00adart) only be realized \nby a sophisticated compiler. This is true for Standard ML. SML# compiler, for example, contains more \nthan 0.3 million lines of code. The SQL language itself also contains various features such as grouping \nand duplicate controls in SELECT lists, and transaction management in data manipulation. All these features \nare indispensable for serious application development. Our major technical contribution is to design \na type system that can precisely represent the SQL language in Standard ML, to develop a compilation \nmethod that seamlessly combines the dynamic se\u00admantics of Standard ML expressions realized by a Standard \nML compiler and the semantics of SQL queries realized by an exter\u00adnal database server, and to implement \nit in the SML# compiler that compiles the full set of Standard ML.  1.2 Paper organization The rest \nof this paper is organized as follows. Section2discusses the problemstobeovercome and outlines our strategy. \nSection3 describes the language and its type system. Section4describes the details of its implementation. \nSection5 concludes the paper with suggestions for further investigations. 2. Problems and our strategy \nWehavechosen Standard ML as the base language for our database extension. This is not accidental. In \nthis section, we review the re\u00adquirements and problems in achieving our goal of seamless inte\u00adgration, \nand outline our development. 2.1 Expressions and typing of SQL We begin by reviewing the basic properties \nof SQL in the perspec\u00adtive of programming languages. SQL can be characterized as a impure functional \nlanguage. Its main components, i.,e. SELECT statements, are relation-valued expressions that can be freely \ncomposed asfar as each sub-phrase is type consistent.Forexample,a query such as SELECT name, age FROM \npeople (Q) WHERE age >= 25 is an expression denoting a set of tuples of name and age and can be used \nas a source relation in any other queries. SQL program\u00adming consists of composing those relation-valued \nexpressions. In addition to those functional expressions, SQL also contains im\u00adperative features such \nas those for updating the database state and transaction management, which assumes sequentialevaluation.To \nrepresent those expressions, eager functional programming is the most appropriate framework. Moreover, \nsince SQL programming involves manipulation of record structures across multiple tables, it is essential \nto enforce type discipline that statically checks com\u00adplex queries before sending them to a remote database \nserver. As observed in [30], SQL expressions are inherently polymorphic in the structures theymanipulates.Forexample, \nthe abovevery sim\u00adple query is polymorphic in several ways: this query can be issued against anydatabase \nthat contains at leasta people table having at least name .eld of anytype and age .eld of numerical type. \nThis indicate thatalanguage containingSQL shouldhaveapolymorphic type system preferably with type inference. \nBaseon these observations,a basic strategyofextendingMLto represent SQL-style database queries was proposed \nin [29, 30]. In their approach, a query expression is considered as a polymorphic function acting on \nan appropriate structure composed of labeled record and set data types.Forexample, the query Q above \nwould begivena polymorphictypeofthefollowingform(inthe notations we use in this paper): Q : [ a, b#{name: \na, age:int}, c#{people: b}. c db -> b relation] This is the type c db -> b relation in prenex form where \nthe set of bound type variables are explicitly listed in its pre\u00ad.x a, b#{name: a, age:int}, c#{people: \nb}. Notation b#{name: a, age:int} represents a type variable b with a kind constraint #{name: a, age:int} \nindicating the fact that anyinstance of b must be a labeled record (tuple) type that con\u00adtains at least \nname: a and age:int .elds. By this polymorphic typing with record kind constraints, their approach represents \nthe precise polymorphic nature of Q,i.e.itisaquery that canbeevalu\u00adatedagainstanydatabase that containsat \nleasta people table each of whose tuples contains at least integer-valued age column and name column \nof anytype. We roughly follow this approach. Among the ML family of languages, we consider Standard ML \nthe most appropriate one for the following reasons. Its eager functional semantics with imperative features \nmake an ideal framework for integrating relation-valued query expres\u00adsions with imperative features such \nas transactions.  Its type system and operational semantics has been rigorously speci.ed and their details \nare well documented [24].  The type theory and implementation method for extending Standard ML with \nrecord polymorphism has been well estab\u00adlished [28, 31].  We base our development on SML#, which is \nan extension of Standard ML with record polymorphism [28] and interoperability with C language. These \ntwo features provide suf.cient basis for seamless extension of Standard ML with SQL.  2.2 The remaining \nproblems The solutions sofar proposed in the literature are, however, only partial for extending Standard \nML with SQL. There are a number of problems that have to be worked out before realizing a practical language \nthat achieves truly seamless integration of SQL. Among them, the following are major technical challenges. \n1. Extensions of the type system. Record polymorphism is useful in achieving the integrationbut adding \nthis alone to Standard ML type system does not yieldatype system for SQL.We need to construct typing \nmechanisms for the following. (a) Server typing and typechecking. We need to develop a typ\u00ading mechanism \nto declare a database schema on a database server, and to type check its correctness against actual con\u00adtents \nof the server. (b) Server connection typing and its consistency enforcement. Since an SQL command needs \nto be sent to a database server,all the query components consisting of the command must only reference \nto a unique server connection. With higher-order functions, enforcing this requirement turns out to be \na subtle typing problem. (c) A proper treatment of null values. Since a column may contain null values, \nwe cannot simply infer a typing of the form a::{age:int} for expression age >= 25. (d) Overloaded operator \nand constants. Literals such as 25 above play double roles; one for a constant of the host lan\u00adguage, \nand one that denotes the same constant in a remote database server. These two have different representations. \nEven worse, 25 in an SQL query represents not only an in\u00adtegerbut alsoa .oating-point number.In addition, \noperator such as > for comparison is overloaded with several atomic types. In Standard ML de.nition, \noverloading is resolved statically. If we simply adopt the same strategy, then the .exibility of SQL \nexpressions would be severely limited. Again,developingaprecise typing mechanismto treat these overloading \nrequires delicate development.  2. Compilation and evaluation. Expressions in a functional lan\u00adguage \nis compiled to a code and executed with a runtime sys\u00adtem with a specialized memory management. It is \nrelatively straightforward to add compilation rules for their own query constructs andexecute themin \ntheirown runtime system.For this purpose, it is suf.cient to de.ne a data structure for tu\u00adples and relations \nand evaluation strategy for each primitive operations in the relational algebra. Newly designed database \nprogramming languages usually adopt this strategy. Our pur\u00adpose is different. Instead of developing a \nquery execution en\u00adgine inside of the language runtime system, we need to call anexisting SQL database \nserver.For this purpose, we need to develop both a compilation method and a runtime mechanism for delegating \nevaluation of SQL query expressions to a remote database server. Since StandardMLisahigher-order functional \nlanguage, seamless integration of SQL implies that SQL queries are intermixed with function de.nitions \nand function applica\u00adtions. This requires us to carefully design the compilation algo\u00adrithm so that it \nseparates SQL query expressions appearing in a given expression.  2.3 Summary of our development We \nhave worked out these problems, have developed compilation algorithms and have implemented a new generation \nof Standard ML that seamlessly integrates SQL by extending our SML# com\u00adpiler. The extension to Standard \nML syntax is carefully designed so that it maintains backward compatibility with the De.nition of Standard \nML. In our development, we have used PostgreSQL and MySQL for our target database servers, considering \ntheir wide availability; other DBMS should equally be possible, as described later in section 4.6. In \nSML# with our extension, the query Q is written as follows. val Q = _sql db => select #person.name as \nname, #person.age as age from #db.people as person where SQL.>= (#person.age, 25) where SQL.>= is the \ngreater-or-equal comparison for SQL values. Onecanseethattheaboveexpressionisadirect representationof(a \nverbose version of) the query Q. Similar expressions may be pos\u00adsible in some programming languages with \nembedded SQL com\u00admands, which are translated to a sequence of primitive statements. Different from those \nsyntactic shorthands, this is an expression in the language. The extended SML# compiler type checks this \nand infers the following polymorphic type. val Q = fn : [ a#{people: b}, b#{age: int, name: d}, c, d::{int, \nword, char, string, real, e option}, e::{int, word, char, bool, string, real}. ( a, c) SQL.db -> {age:int, \nname: d} SQL.query] This type indicates that Q isafunctionthattakesadatabaseoftype ( a, c) SQL.db whose \ncontents is of type a#{people: b}, and returns a query of type {age:int,name: d}. The extra pa\u00adrameter \nc to a database type a#{people: b} is there to en\u00adsure the consistent usage of connection and will be \nexplained later. d::{\u00b7 \u00b7 \u00b7} constrains that d can be instantiated only with a type shared among ML and \nSQL. It should be intuitively clear that the inferred type represents the precise polymorphic nature \nof the query Q, and indeed it is a principal type for Q. In an ML-style type system, the fact that a \nprincipal type is inferred for this expression immediately means that this expression can be freely combined \nwith anyother language constructs asfar as its usageis type consistent. Figure1 showsexample programs \nto de.nea database server,to connectit,to insert tuples,toexecute query Q, and to fetch the results as \na list of SML# records. It shows an actual interactivesession in SML#. The lines starting with prompt \n# and ending with delimiter ; are user input, which are followedbya system response. 3. SML# extended \nwith SQL This section presents the language we develop.We .rst introduce SML#, and develop necessary \nextensions in syntax, typing mech\u00adanisms, and operational semantics.We then showa programming example \ndemonstrating the bene.t of seamless integration of SQL into SML#. 3.1 SML#: Standard ML with record \npolymorphism and interoperability withC SML# embodies record polymorphism and infers a polymorphic type \nfor record operations as seen in the following example: # fun getName x = #Name x; val getName = fn : \n[ a#{Name: b}, b. a -> b] where #l selects the l .eld from a record. getName takes a record and returns \nits Name .eld. This record polymorphism provides a basis to extend Standard ML with SQL expressions. \nIn addition, SML# supports interoperability with theClanguage through its natural data representation \n[27]. Under this scheme, internal data representations in SML# and C have the following correspondence: \natomic types including int and real are the same as int and double in C; t array has the same representation \nas a pointer to an array of t in C; and a labeled record type {l1:t1,..., ln:tn} has the same representation \nas a pointer to a structure inC that contains the elements of types {t1,...,tn}in the lexicographical \norder of their labels {l1,...,ln}. Based on these properties, SML# allows the programmer to declare an \nexternal library function de.nedinCand useit as an ordinaryML function. The followingexample code importsC \nlibrary function sin: # val sin = dlsym (dlopen \"/usr/lib/libm.so\", \"sin\") : _import real -> real; val \nsin = fn : real -> real; # sin 1.0; val it = 0.841470984807 : real where dlopen and dlsym arebuilt-in \nlibrary functions that open and .nd a pointer to the named dynamically linked library func\u00adtion. After \nthis declaration, sin is used as an ordinary ML expres\u00adsion of type real -> real,but application of sin \ndirectly calls theClibrary function without anydata conversion.In ourdevelop\u00adment, we use this feature \nto bind database server library functions provided for C. ThesyntaxofSML#isthatof StandardML.Fortheexplanation \npurpose in this paper we consider the following subset of its core language. e ::= x | fn x => e | ee \n|{l1=e1,...,ln =en}| #le x rangesoverthe setofvariables. fn x => e de.nesa(.rst-class) function. {l1=e1,...,ln \n=en} constructs a labeled record. Other features are mostly orthogonal to our SQL extension and can be \nused without anyproblem. In examples, we also use the following syntax. val x = e binds a variable x \nto an expression e.  SQL.x is a variable x de.ned in the module named SQL. In our implementation, which \nwe shall describe in Section 4, most   # val server = _sqlserver \"host=127.0.0.1 dbname=test\" : {people: \n{name: string, age: int}}; val server = \"host=127.0.0.1 dbname=test\" : {people: {age: int, name: string}} \nSQL.server # val db = SQL.connect server; val db = <conn> : {people: {age: int, name: string}} SQL.conn \n#val q = _sql db => insert into #db.people (name, age) values (\"Alice\", 24); valq = fn : [ a#{people: \n{age: int, name: string}}, b. ( a, b) SQL.db -> SQL.command] # val r = _sqlexec q db; valr= (): unit \n#val q = _sql db => insert into #db.people (name, age) values (\"Bob\", 25); valq= fn : [ a#{people: {age: \nint, name: string}}, b. ( a, b) SQL.db -> SQL.command] # val r = _sqlexec q db; valr= (): unit #valQ \n= _sql db => select #person.name as name, #person.age as age from #db.people as person where SQL.>= (#person.age, \n25); valQ = fn : [ a#{people: b}, b#{age:int, name: d}, c, d::{int, word, char, string, real, e option}, \ne::{int, word, char, bool, string, real}. ( a, c) SQL.db -> {age: int, name: d} SQL.query] # val r = \n_sqleval Q db; val r = <rel> : {age: int, name: string} SQL.rel # val x = SQL.fetchAll r; val x = [{age \n= 25, name = \"Bob\"}] : {age: int, name: string} list Figure 1. Example Program in SML# resources (functions \nand types) for the SQL extension are orga\u00adnized into the SQL module, and theyare referenced through this \nnotation. Its type system is that of Standard ML extended with record kinds on typevariables.We let C \nrange over type constructors such as list or array. Sometimes we use option type constructor to represent \nvalues possibly containing null. We use the following syntax for types. The set of monomorphic types \n(ranged over by t)is given by the following syntax t := b | t -> t ' |{l1:t1,...,ln:tn}| tC where b ranges \nover atomic base types such as int;t -> t ' is a function type; {l1:t1,...,ln:tn} is a labeled record \ntype; and tC is a constructor type such as int list. a, b,... are typevariables (rangedoverby t).  \n[t1#k1,...,tn#kn.t ] isa polymorphic typeof t with bound type variables t1,...,tn. Each ti is constrained \nwith a kind ki. A kind k is either empty indicating no constraint or a record kind {l1:t1,...,ln:tn} \ndenoting all possible records that contain at least the speci.ed .elds.   3.2 Syntax extensionfor SQL \nTo represent SQL, we need to introduce the following. Aserver de.nition on which SQL is run.  SQL commands \n. Among them a SELECT command is an algebraic (functional) expression that returns a relation. The others \nare those that change the server state.  Our aim is to represent SQL queries as directly as possible, \nand allow them as .rst-class citizens in the language. The important step to achieve this goal is to \nidentify all the syntactic elements that are implicit in a SELECT command and introducing them as expressions \nin SML#. Introduction of a server de.nition and other SQL commands are relatively straightforward. To \nidentify those implicit syntactic shorthands, let us examine the following simple SELECT command. SELECT \nname FROM people WHERE age >= 25 This implicitly assumes the following. 1. Field names name and age in \nSELECT and WHERE clauses denote the results of the corresponding .eld selections from a tuple in the \ntable given in FROM clause. 2. SELECT phrase creates a tuple whose labels are inherited from the .eld \nnames. 3. This query is executed against a given database connection. This implies that the table name \npeople in FROM clause rep\u00adresents the selection of the people table from a database con\u00adsisting of a \nnamed collection of tables.  The .rst two points are made explicit by the following more ver\u00adbose version \nof the same SQL command SELECT person.name AS name, person.age AS age FROM people AS person WHERE (person.age \n>= 25) where a variable person is bound to a representative tuple, from which the mentioned .elds are \nextracted. To represent the third point, we represent a query expression as a function that explicitly \ntakes a database connection db as a parameter and selects the referenced table people from db. This analysis \nyield the example expression wegavein Section2.  e ::= ... (SML# expressions) | _sqlserver [string]: \nt (server de.nition) | _sql x => sql (SQL expressions) | _sqleval e (query evaluation) | _sqlexec e (command \nexecution) | #x.l (selection) sql ::= select | insert | update | begin | commit | rollback select ::= \nselect e [ as l ] ... e [ as l ] [ from e as x ... e as x ] [ where e ] \u00b7\u00b7\u00b7 (other clauses) insert ::= \ninsert into #x.l (l, ..., l) values ( {e|default}, ..., {e|default}) update ::= update #x.l [ as x ] \nset (l, ..., l)=(e, ..., e) [ from e as x ... e as x ] [ where e ] delete ::= delete from #x.l [ as x \n] [ where e ] Figure 2. The syntax of SQL extension in SML# We also need to introduce syntax for executing \nan SQL query command against a database connection. There should be two forms, one for SELECT, which \nreturns a relation, and the other for all the other commands which do not return anyvalue. Based on these \nanalyses, we de.ne the syntax extension to SML# as shown in Figure 2. In this de.nition, note that e \nranges overany expressions including thoseof SML#. Thosewho arefa\u00admiliar with SQL should immediately \nrecognize that these exten\u00adsions are direct representation of (a subset of) SQL. SQL contains more features, \nwhich can be added without anyproblem, as we dis\u00adcuss later.  3.3 Typing extensionfor SQL Weshould emphasize \nthat theseSQLexpressions are not macrobut theyarealllegalexpressionsthatcanbefreely combinedwithother \nSML# expressions. Moreover, each sub-expression e appearing in those SQL syntax can be any expression \nde.nable in SML#. Of course not all syntactically well-formed expressions are legal; the set of expressions \nthat have well-de.ned meaning are those that have a type inferredby the type system. Our goal is to extend \nthe type system of SML# so that it always infers a most general type for anylegal SQL expression. Since \nthe type system guarantees that any typable expression can be freely combined asfar as its type is consistent, \nthis achieves our goal of seamless integration of SQL into Standard ML. Thetypesystemis de.nedthroughasetoftypingrulestoderive \ntyping judgments in the style of [24]. We have worked out the details of the typing rules for the above \nSQL extension. In this section, rather than giving a formal typing derivation system, we present the \ntype system by explaining the meanings of new type constructors and the behavior of the associated typing \nrules. 3.3.1 The set of new type constructors The set of types of SML# is extended with the following \nnew type constructors for the SQL extension. t := \u00b7\u00b7\u00b7 | t server | t conn | t query | command | t rel \n'' ' | (t, t ) db | (t, t ) table | (t, t ) row | (t, t ' ) value Intuitive meanings of these types are \nthe following; their precise meaning will become clear when we explain typing properties of associated \noperations. t server denotes a server of a database of type t by which SQL expressions are evaluated. \nIn what fol\u00adlows, we call such a server as an SQL server. t conn represents an established connection \nto an SQL server of type t server. t query represents an SQL SELECT command that return a re\u00adlation of \ntype t . command is the type of the other SQL commands such as insert and rollback, which cause some \nside effects to the SQL server state. t rel represents a relation containing tu\u00adples of type t returned \nfrom an SQL server as a result of query evaluation. The other four types (t1, t2) db, (t1, t2) table, \n(t1, t2) row, and (t1, t2) value are used to type expressions inside of SQL queries and commands. Theyrespectively \ndenote an active database connection of type t1, a table of type t1 in an ac\u00adtive database connection, \na tuple of type t1 in an active database connection, and an atomic value of type t1 in an active database \nconnection. t1 of type value is either an atomic base type b forval\u00adues without null or b option for \nvalues possibly containing null. The extra second type parameter t2 in these types is introduced to ensure \nthe consistencyof database connections in SQL queries we shall explain below. Using these types, we represent \nlegal SQL expressions through SQL constructs. In the following, we introduce SQL constructs and explain \ntheir typing relations. 3.3.2 SQL servers A server expression _sqlserver [string]: t declares that there \nis an SQL server of type t at the location speci.edby string. This string may also contain some extra \ninformation to estab\u00adlish a connection to the server. In our current version, the location speci.cation \nstring is designed so that it is expressive enough for PostgreSQL or MySQL servers. t speci.es the set \nof tables in the database as a form of record type. This expression is al\u00adways well typed with type t \nserver. Note that giving a type to servers makes them .rst-class values. This feature gives .exibility \nto database programming.Forexample,a function cantake listof servers with additional information such \nas their capacities and can dynamically choose appropriate one at runtime. Aruntimevalueofaserverexpressionisaserver \nobject consist\u00ading of the server information including its location and a runtime representation of its \ntype t. The only operation on a server object is the primitive function SQL.connect : [ a. a server -> \na conn]. This primitive attempts to connect the SML# runtime system to the SQL server using the location \ninformation stored in the server ob\u00adject of type t server. If the attempt succeeds, then it dynamically \nchecks that the connected server has indeed the type t stored in the server object. This typechecking \nis done by retrieving database schema information from the remote SQL server. If the typecheck succeeds, \nthen the primitive succeeds and returns a connection ob\u00adject of type t conn, which can be used to issue \nSQL commands. If either the connection attempt or the typecheckfails then this prim\u00aditive raises a runtime \nexception.  3.3.3 Consistency of database connection Adistinguishing features of our language is that \nall the components of SQL are given types so that they are treated as .rst class val\u00adues. This achieves \npowerful SQL programming using higher-order functions. As we noted above, in our system, database servers \nand the corresponding database connections areall .rst-classvalues.As a consequence, one can write a \nprogram that manipulates multiple database connections to different database servers. This .exibility \nraises one subtle issue in ensuring well-de.nedness of SQL query execution.Astraightforward combinationof \nhigher-order functions and .rst-class database connections would inadvertently admit an SQL query that \ninvolves multiple database connections. However, anSQL query needstobeevaluatedbyasingleSQL server through \na single database connection.To see the problem, consider the fol\u00adlowing example.  funfdb1 = _sql db2 \n=> select #r1.c1, #r2.c2 from #db1.t1 as r1, #db2.t2 as r2 The function f generates an SQL SELECT command \nfor a database connection db2, but it uses another database connection db1 re\u00adceived as a parameter. \nThis function de.nition is valid only when db1 and db2 denote the identical connection. The following \nexam\u00adple is an invalid use of f. val conn1 = SQL.connect (_selserver \"DB1\"); val conn2 = SQL.connect \n(_selserver \"DB2\"); _sqleval (_sql db => select \u00b7\u00b7\u00b7 from \u00b7\u00b7\u00b7 where \u00b7\u00b7\u00b7 (_sqleval f db conn1) \u00b7\u00b7\u00b7) conn2 \nThis results in sending to an SQL server \"DB1\" a query that in\u00advolves a reference to another database \nserver \"DB2\".Asound inte\u00adgration of SQL into SML# type system requires that the extended type system \nshould statically detect this form of inconsistencydue to multiple database connections in one SQL query. \nWe solve this problem using existential types proposed in [25]. The idea is to consider a database connection \nof type t1 conn as an abstract package of type t1 conn = .t2.(t1, t2) db where t2 is an abstract witness \nrepresenting a unique connection established for a particular connection to a database. Since exis\u00adtential \ntypes are second-order types, general introduction of this mechanism is beyond the power of ML typing \non which SML# is based. So we introduce this mechanism only for the expressions _sqleval and _sqlexec \nthat useadatabase connection. Theseex\u00adpressions temporally opens the package by generating a unique t2 \nand convertinga database connection type t1 conn intoa database type (t1, t2) db. All the database components \n(tables and val\u00adues) that forms an argument to the same _sqleval or _sqlexec are typed with the same \nunique witness type t2. This ensures the consistent use of connection without introducing ad-hoc restriction \non the usage of .rst-class SQL constructs. The second type pa\u00adrameter t2 in (t1, t2) db, (t1, t2) table, \n(t1, t2) row, and (t1, t2) value are introduced for this purpose. The precise typ\u00ading rule is rather \ninvolved,but it is a standard application of ex\u00adistential types. As we shall describe below, our implementation \nachieves an ef.cient and simple type inference method specialized for _sqleval and _sqlexec.  3.3.4 \nComponent selection expression The select expressions and other SQL commands contains com\u00adponent selection \nexpressions of the form #x.l, which denotes the l componentofthevalue denotedby x. The value may be a \ndatabase or a tuple, both of which have a labeled record structure. Correctly inferringthe most generaltypeofthis \nconstructisakeyto achiev\u00ading seamless integration of SQL into SML#. For this expression, the type inference \nsystem performs the following. Infer a type of x. The result should be either a database type (t1, t2) \ndb or a tuple type (t1, t2) row. In these types, t1 is a record type representing their structure, and \nt2 represents a unique database connection. It uni.es t1 with a fresh type variable with a record kind \na#{l: b}.  If uni.cation succeed, then the type inference system computes an instance of the component \ntype b. Let the result be t3. The type inference system returns ( b, t3) table if #x.l appears in a context \nthat requires a table, otherwise it returns ( b, t3) value.  3.3.5 SQL SELECT command With these extensions, \nSQL SELECT command can be typed. Its syntax in our extension has the following form. _sql db => select \ne1 as l1 ... en as ln 11 kk from e as x ... e as x where ew For this expression, the typechecker performs \nthe following. Infer a type t for ew and unify t with (bool, t0) value.  For eache i, infer types t \ni and unify t i with (t i ' , t0) table,  i and add the bindings {x : (t i ' , t0) row} to the typing \nenvironment. Under the extended typing environment, infer types t1,...,tn for e1,...,en.  If all the \ninference steps succeed, then it returns the type {l1 : t1,...,ln : tn} query as a result.  3.3.6 Sub \nqueries SQL allows arbitrary nesting of SELECT commandsby treating the result of a SELECT command as \na table. This is simply done by the introduction of the following typed primitive. SQL.subquery : [ a, \nb. (( a, b) db -> a query) -> ( a, b) db -> ( a, b) table The .rst parameter is a select expression, \nand the second param\u00adeter is the current database connection. This converts the select expression to \na virtual table on that connection.  3.3.7 Overloaded operators In additiontothe mechanismabove, one \nmoreextensionis required to inferadesired polymorphictypeforSQLexpressions.Toexplain this, we note that \nan SQL expression is not only polymorphic in the database structures it manipulates but it also implicitly \nuses overloaded operators such as comparison >. Since conventional SQL commands areexecuted undera.xed \nmonomorphic database, all theoverloading are resolvedbythe server without anyproblems. However, if we \ntreat a query as a .rst-class value, then we need to represent theoverloaded operators as .rst-classvalues \nas well.To see the need, consider the following query. fun f x = _sql db => select #person.name as name \nfrom #db.people as person where SQL.> (#person.age, x) There are multiple possible types for age and \naccordingly there are possible multiple instances of SQL.>. Since SML# is a typed lan\u00adguage, we must \ninfer a polymorphic type of this function. Instead of introducing a general mechanism for overloading \nsuch as type classes [17], which would signi.cantly complicate the underlying type system of Standard \nML, our solution is to introduce a new kinded type variable of the form a::{t1,...,tn} representing thefact \nthat typevariable a is an overloaded type whose instance is restricted to one of its list t1,...,tn. \nThe type of the parameter x intheabovefunctionistypevariable a with the following kinding:  a::{int, \nword, char, string, real, b option}, b::{int, word, char, bool, string, real} The listed types are atomic \ntypes shared among ML and SQL. Since the age column in the actual database may contain null, the set \nof instances must contain int option as well as int etc. Thus, the set of all possible instances of a \nis {int, word, char,string,real,int option,word option,char option, bool option, string option, real \noption} which is the standard set of types allowed for the age .eld in an SQL database. The same restriction \napplies to the result value of a column selec\u00adtion expression such as #person.name. Combining all the \ntyping mechanisms, our type system always infersa principaltypeforanytype-correctSQLexpression.Forthe \nabove f, for example, the following type is inferred. val it = fn : [ a::{int, word, char, string, real, \nb option}, b::{int, word, char, bool, string, real}, c. ( a, c) SQL.value -> [ d#{people: e}, e#{age: \na, name: f}, f::{int, word, char, string, real, g option}, g::{int, word, char, bool, string, real}. \n( d, c) SQL.db -> {name: f} SQL.query]] Although the inferred type is notationally involved, it is not \nhard to see that this is exactly the constraint imposed by the above SQL query. It is this precise typing \nthat achieves seamless integration of SQL into a typed polymorphic high-order functional language.  \n 3.4 The operational semantics Once we have worked out the typing structures of all the compo\u00adnents of \nSQL, the next step is to develop an evaluation model for the SQL extension and to combine it in the compilation \nsteps in SML#. An expression in a functional language is compiled to a code that generates a value denoted \nby the expression. In order to seamlessly integrate SQL in this general model, we adopt the fol\u00adlowing \nstrategy.ForvariousSQL components that appear insideof SQL expressions, we de.ne their values to be the \nsyntax tree rep\u00adresenting the component whose leaves may contain atomic SML# values, and represent the \nruntime value of each primitive functions operating on SQL components as a function that combines abstract \nsyntax trees. SQL construct _sql x => sql is compiled to a code that takes a database connection and \nreturns an abstract syntax tree representing the corresponding SQL command to be sent to the server through \nthe connection. _sqleval and _sqlexec are im\u00adplemented as functions that take an abstract syntax tree, \ngenerate an SQL string from the tree, and sends it to the server. In actual im\u00adplementation, we do not \nexplicitly generate an abstract syntax tree but generate its string representation on the .y. In the \ncase of _sqleval, it must perform additional task of converting the returned result to the SML# runtime \nvalues. We solve this problem by associating _sqleval with a function that generates SML# values from \nthe server s result. The runtime representation of t rel is a value containing such a function. SQL.fetchAll \n: t rel -> t list converts a query result to an SML# listof recordsbyinvoking the conversion function. \n 3.5 Other SQL features and examples The syntax of SQL contains additional components other than those \nde.nedin the syntaxextensionin section 3.2.Forexample, SELECT command has many clauses other than FROM \nand WHERE such as ORDER BY. Some of those additional components require extension to the syntax, and \nothers are realizedby adding primitive functions. In this section, we take ORDER BY clause of SELECT \ncommand as an example for the former, and logical operators including EXISTS predicate for the latter. \nOther components can be introduced similarly to one of these two. The ORDER BY clause of SQL sorts tuples \nin the query result according to columns in the select list as well as those of the tables appearing \nin FROM clause. Original ORDER BY clause refers the select listin anonymousway.Torealize this behaviorin \nour syntax, we needtoexplicitly introduceavariable whichis boundtoaresult tuple.Weuse into keyword for \nthis binding. The syntax ofselect command is re.ned as follows. select ::= select e [ as l ] ... e [ \nas l ] into x \u00b7\u00b7\u00b7 order by e [{asc|desc}] \u00b7\u00b7\u00b7 e [{asc|desc}] The type of x following into is (t1, t2) \nrow where t1 isarecord type representing the type of the result tuple. This x can be seen from sub-expressions \nin the order by clause and is used to refer to the select list. Some of primitive operations in SQL expressions \ncan be repre\u00adsented as typed primitive functions. The following typed primitives represent SQL logical \noperators. SQL.andAlso : [ a. (bool, a) value * (bool, a) value -> (bool, a) value] SQL.orElse : [ a. \n(bool, a) value * (bool, a) value -> (bool, a) value] EXISTS subquery expression can be introduced by \nthe following typed primitive, similar to SQL.subquery. SQL.exists : [ a, b. (( a, b) db -> a query) \n-> ( a, b) db -> (bool, b) value] Using those features, the programmer can enjoydatabase pro\u00adgramming \nwith full spectrum of SQL directly in Standard ML. Fig\u00adure3shows anexample that retrieves employee information \nfrom an employment database and constructs a nested list of employ\u00adees for each department. employees \nis a polymorphic query that receives a condition for where clause and returns a list of pairs of an employee \ns name and his/her salary in descending order of salary. employees is another polymorphic query obtained \nfrom employees by applying it to a partial condition. depts holds the list of pairs of a department name \nand its ID. The map function in the de.nition of forEachDept performs iteration over the depart\u00adment \nlist and constructs and emits a query for each department. l1 and l2 hold resulting employee lists under \ndifferent conditions. 4. Implementation We have implemented the presented extension in SML# compiler. \nThrough our effort of modular and systematic extension of a com\u00adplex system of SML# compiler, we have \ndeveloped an implemen\u00adtation technique for connecting static semantics of SQL in the host language, SML#, \nand its dynamic semantics realizedbyanexternal SQL server. This technique should be useful for extending \na com\u00adpiler with a domain speci.c language. In the next subsection, we discussthe probleminextendinganexisting \ncompilerand describe  val db = _sqlserver \"dbname=employment\" : {employee: {name:string, age:int, salary:int, \ndeptId:int}, department: {id:int, name:string}} val conn = SQL.connect db fun employees condFn = _sql \ndb => select #r.name, #r.salary from #db.employee as r where condFn r order by #r.salary desc fun employees \ncondFn deptId = employees (fn r => SQL.andAlso (SQL.== (#r.deptId, deptId), condFn r)) val depts = SQL.fetchAll \n(_sqleval (_sql db => select #r.name as deptName, #r.id as deptId from #db.department as r order by #r.name) \nconn) fun forEachDept queryFn = map (fn {deptId, deptName} => {deptName = deptName, employees = SQL.fetchAll \n(queryFn deptId) conn}) depts; val q1 = employees (fn r => SQL.> (#r.salary, 5000)) val l1 = forEachDept \n(fn i => _sqleval (q1 i)); val q2 = employees (fn r => SQL.> (#r.age, 50)) val l2 = forEachDept (fn i \n=> _sqleval (q2 i)); Figure 3. example of combination of ML and SQL the implementation technique wehavedeveloped.We \nthen reports the details of the implementation in the subsequent subsections. 4.1 Implementation strategy \nAnatural way of extending a compiler with SQL would be to add its syntax and the corresponding intermediate \nrepresentations, and then to add to each compilation phase the cases that process the new components \nin such a way that the added SQL components achieve the intended typing and runtime behavior. This approach \nrequires detailed analysis on interaction between the existing sys\u00adtem and new components, and is dif.cult \nfor a large and complex languagesuchasacompilerof StandardML includingSML# com\u00adpiler, which contains \nmore than 300K line of code organized in more than 20 compilation phases. This natural strategy would \nalso be problematic in extensibility and maintenance, since the added extensions will become tightly \nbuilt-in the core of the compiler. In order to extend the SML# compiler ef.ciently and reliably, we should \nlocalize the extensions and minimize the modi.cations of the core of the compiler. Our basic strategy \nfor achieving this goal is to use the compiler s functions asfar as possible. Extending a typed language \nwith some new constructs requires to implement their static semantics, which infers types and prop\u00aderly \npropagates them to the rest of the language, and their dynamic semantics, which realizes the desired \nruntime effect. In our imple\u00admentation, we have successfully organized the SQL extension in suchaway \nthat both static and dynamicevaluation are realized sys\u00adtematically using the existing functionality \nof the SML# compiler. This is based on our following observations. Components of SQL expressions including \ndatabases , ta\u00adbles , and rows are all labeled record structures combined with a type constructor for \ncollections (relations). These components can be represented in the type system of SML#, which supports \nrecord polymorphism.We can then directly implement anySQLexpres\u00adsion as a source program in SML#. This \nwould yield a toy imple\u00admentation of SQL in SML#. Of course, such a toyimplementation is not what we \nreally want. Our goal is to seamlessly extend SML# with SQL in such a way that the SQL part is evaluated \nby an ef\u00ad.cient practical database server. However, asfar as typing is con\u00adcerned, such a toyimplementation \nis good enough; for each SQL expression, we can generate a toyprogram whose type is the same as that \nof the SQL expression. This means that we can obtain the desired static semantics of an SQL expression \nby constructing an appropriate toy source program that corresponds to the SQL ex\u00adpression. Moreover, \ntypes are only used for static enforcement of legal combination of SQL expressions with other language \ncon\u00adstructs,and arenot neededat runtime.Adynamic semanticsofan SQL expression is realized by generating \nan SQL command string and sending them to an SQL server without using type informa\u00adtion. This process \nis also easily represented by an SML# program. The desired SQL extension can then be realized by connecting \nthe static semantics realized by a toyimplementation and the dynamic semantics realizedbya database server. \nThe above observation leads us to the following implementa\u00adtion strategy. The compiler .rst translates \nan SQL expression to a source program that computes a pair of a toyimplementation and a target SQL command \nstring. Each primitive operation of SQL is translated to a source program that simultaneously composes \nboth the toy implementation and the target SQL command string. It is not hard to de.ne a data type for \nthe source program so that the type of the toyimplementation becomes the type of the entire re\u00adsult. \nThe value of the translated program is a pair of the toyimple\u00admentation and the target SQL command string. \nSo the remaining thing for the compiler to achieve the desired dynamic semantics is to compile _sqleval \nand _sqlexec to a source program that takes the source program generated from an SQL expression, runs \nthe program to obtain a pair, throws away the .rst component, and sends SQL command string stored in \nthe second component to the database server. The .rst major phase of the SML# compiler is elaboration, \nwhich translates a given abstract syntax to a basic source program, called a core ML program, by expanding \nderived forms (sugared syntax). Since most of the above process are de.nable in the core ML language, \nthe major part of SQL compilation can be imple\u00admented by extending the elaboration phase of the SML# \ncompiler so that it translates SQL expressions to appropriate core ML pro\u00adgrams described above. In order \nto carry out the implementation based on this strategy, we have to develop the following components and \nintegrate them in the SML# compiler. 1. Extension to the SML# type system. Although most of SQL type \nstructures can be representable in the core ML language of SML#, a complete representation of actual \nSQL expressions requires some extensions to its type system. The major one is the introductionofexistential \ntypes weexplainedin Section3 to ensure that all the components in one SQL expression refer to the same \ndatabase connection. Introduction of this feature requirestoextendthetyped intermediate languageoftheSML# \ncompiler and its type inference system.  2. SQL type de.nitions. Under our strategy, the compiler gener\u00adatesa \ncoreML programthatachievesthe static semanticsofthe original SQL program. Those generated programs need \nto ref\u00aderence types of SQL component such as tables and rows . This means that these types should be \nprede.ned and loaded before the compilation. 3. Core ML program generation. After the preparation of \nthe above two steps, the compiler generates a core ML program from a given SQL expression. 4. Connection \nmanagement. In addition to compile SQL expres\u00adsions, the compiler and runtime system must also manage \nserver connection. An important additional role beside making server connection is to dynamically check \ntype conformance of the sever database against the declared server type. Since types are static entities \nthat onlyexists during compilation,aspecial com\u00adpiler support is necessary for this purpose. 5. SQL \nserver binding. To communicate with an SQL server pro\u00adcess, we need primitive functions to access an \nSQL server. Modern SQL servers usually provide such features as their ownlow-level APIs.To make our implementation \nindependent of particular SQL server as much as possible, we introduce a server binding module to abstract \nthe low-level communication.  The following .ve subsections explain these major components.  4.2 Extension \nto the SML# type system New typing mechanisms necessary for SQL expressions include overloading and existential \ntypes. 4.2.1 Overloading compilationfor SQL primitives As we have explained in 3.3.7, we need to represent \nconstant literals and primitives in SQL expressions. For this purpose, we have introduced a simple .rst-class \noverloading mechanism based on polymorphic record compilation. Compared with type classes in Haskell \n[17], the modi.cation to SML# type system is simple, and it can be implemented by small modi.cation to \nthe existing mechanism for record compilation. Here, we outline the necessary extension to SML# type \nsystem and the implementation. For the sake of explanation, we consider an overloaded primitive O whose \ninstances is represented by a polymorphic type of the form O : .t :: {b1,...,bn}.t where {b1,...,bn} \nisa setof base types.For this simpli.ed set\u00adting, each of instance functions of O is identi.ed by a base \ntype b listed in the kind, which we write Ob. To deal with overloading speci.ed in the de.nition of Standard \nML, the original SML# type system already contains overloaded kind of free type variables of the form \nt :: {b1,...,bn}. where b1,...,bn are distinct base types. If these type variables remain free at the \ntop-level, they are not generalizedbut are instantiated with the .rst component b1 of the list of types \n{b1,...,bn}. To extend the type inference system with .rst-class overloading, we have only to allow these \ntype variables with overloaded kind to be generalized. The kinded type system of SML# correctly propagates \nand resolves overloaded instance types. The above modi.ed type inference system of course does not re.ectthe \ndynamic semanticsofoverloaded primitive O. The com\u00adpiler needsto resolveoverloadingby selecting appropriate \ninstance Ob according to an instance b of t. For this purpose, we apply the idea of polymorphic record \ncompilation and compile a term with of overloaded primitive O to a higher-order function that takes an \nappropriate overloaded instance as an extra parameter. For this purpose, in the target language, an overload \nkind is ex\u00adtended to be a pair ({O1,...,Om}, {b1,...,bn}) by including the set {O1,...,Om} of overloaded \nprimitives involved. When type variables with overloaded kinds are uni.ed, the type system takes the \nintersection of instance sets and the union of the primi\u00adtive sets. When polymorphic generalization is \nperformed on those overloaded variables, extra bound variable for each Oi is intro\u00adduced, and when polymorphic \ninstantiation is performed, the ac\u00adtual instance primitive is passed as an additional parameter.With \nthis preparation, the compilation process is essentially the same as thatof polymorphic record compilation.Forexample,a \nfunction val f = fn x => +(x,*(x,x)) : [ a::{int, real}. a -> a] is compiled to the following term: \nval f = fn I+ => fnI* => fn x => I+(x,I*(x,x)) : [ a::({+,*},{int, real}). Inst(+, a) -> Inst(*, a) -> \na -> a] where Inst(+, a) is the singleton type that denotes the primitive + for the type a. In our actual \nextension, we allow each overloaded instance type bi to take another overloaded type variable as its \ntype parameter to represent nested overloaded instances. By allowing the nesting, we can de.neoverloaded \nprimitives not onlyover base typesbut also over constructed types. This is needed to represent the set \nof types shared among ML and SQL as described in section 3.3.7. For example, in our SQL extension, the \ntype ofSQL.>, which is a comparison primitive for SQL queries, is declared as follows: [ a, b::{int, \nword, char, bool, string, real}, c::{int, word, char, string, real, b option}. ( c, a) SQL.value * ( \nc, a) SQL.value -> (bool option, a) SQL.value ] Overloaded type variable c in thisexample refersto anotherover\u00adloaded \ntype variable b to form a nested instance set, which repre\u00adsents the set of types for which comparison \noperation is de.ned in SQL. The necessary extension to the SML# compiler is small and modular.  4.2.2 \nExistential typesfor database connections In order for an SQL expression _sql db => sql to have well\u00adde.ned \nmeaning, anycomponent in sql must reference to the same server connection. As we have pointed out, one \nway to ensure this restriction is to consider the database connection db as an ab\u00adstract package having \nan existential type .t.s providing the ca\u00adpability of accessing its component tables and columns therein. \nThe resulting type system yields sound typing for SQL expres\u00adsions, successfullyexcluding anomalous terms \nsuch as theexample shown in Section 3.3.3. However, introduction of existential types in their general \nform makes the type inference system of ML in\u00adcomplete. Our solution is to restrict existential types \nto the com\u00adbination of _sql db => sql and _sqleval (or _sqlexec.) Here we only explain the case for _sqleval. \nThe case for _sqlexec is the same. The basic role of the construct _sqleval (_sql db => sql) conn is \nto bind db to a connection denoted by conn. In addition, the type system generatesaunique witness type \nand prop\u00adagated through all the db component in sql.Torepresent this effect, the type system treats this \napplication specially. When typecheck\u00ading the above application, the type system generates a new type \na dbi,uni.es the type ofdb,infers the application, and .nally checks that the newly generated typevariable \na does not occur in both the type environment and the type judgment. This .nal check ensures that all \nthe elements in sql reference to the same server connection denotedby conn.   4.3 SQL type de.nitions \nOur strategy is to translate SQL expressions to core ML programs of SML#. This requires that all the \ntypes of SQL component such as database and tables used in the generated programs should have been de.ned.For \nthis purpose, weextend the setofbuilt-in types of SML# with the following types. datatype ( a, b) db \n= DB of a * b dbi datatype ( a, b) table = TABLE of a * string * b dbi datatype ( a, b) row = ROW of \na * string * b dbi datatype ( a, b) value = VALUE of a * string * b dbi The .rst type argument a of \ndb, table, row, and value is the type of the toy program. The second type parameter b is used to propagate \na unique connection type explained above. The string component in the implementations of table,row,andvalue \nholds the (partially constructed) target SQL command string. 4.4 Core ML program generation Using these \ntypes and their data constructors, the compiler gener\u00adates core ML programs of SML# from SQL expressions. \nThis is done by adding a case for each of SQL expression syntax to the SML# elaboration phase, which \nrecursively traverseagiven source program. Each case is largely mechanical with a special care of ensuring \nthat a unique connection type should be properly propa\u00adgated.Asasimpleexample, component selection,#x.l,inasource \nprogram is translated to the following core ML program. case x of DB (y, {l=z,...}) => TABLE (\"l\", y, \nz) In this program, \"l\" is a string literal to appear in the SQL com\u00admand string being generated, the \npart {l=z,...} => z is the toy implementation that generates polymorphic typing of this selection, and \ny => y isforpropagatingaunique connectiontype.EachSQL operation is translated to a program that composes \nthe toy parts, concatenates the SQL command strings, and propagates the unique connection type. Since \nsome of SQL components only concatenate the SQL command strings, connection types need to be propagated \nthrough SQL command string concatenation. For this purpose, we intro\u00adduce a special string concatenation \nfunction concatQuery of type (string * a dbi) list -> string, and passes component strings together with \nconnection witnesses to this function. This function concatenates a list of string with the typing effect \nof uni\u00adfying all their connection types to the same type. This achieves the desired typing effect. There \nis one more subtlety that should be take care of in achiev\u00ading seamless integration of SQL into SML#.We \nhave sofar iden\u00adti.ed SQL rows (tuples) with Standard ML labeled records. This identi.cation works .ne \nfor component selection and its typing. However, internal representations of SQL rows returned from an \nSQL server are different from those of ML record representation. This implies that a row fetched from \nthe result of an SQL expres\u00adsion returned from a server should be converted to the internal rep\u00adresentation \nof Standard ML. Under our strategy, this requires to generate a core ML program that performs such conversion. \nMore\u00adover, we need to generate such a conversion function for each SQL query using its type information. \nThis is best done at the time of translating a query expression, when all the necessary type infor\u00admationisavailable.Our \nsourcelevel translator generatesacoreML Source program: _sql db => select #person.name as name from #db.people \nas person Translated core ML terms: fn db as DB (dbi, _) => let val (tabname, person) = case (case \ndb of DB (i, {people = w, ...}) => TABLE ((\"people\", i), w)) of TABLE (t as (_, i), w) => (t, ROW ((\"person\", \ni), w)) val VALUE (nameExp, nameW) = case person of ROW (n, {name = w, ...}) => VALUE (concatDot (n, \n\"name\"), w) val witness = {name = nameW} in QUERY (concatQuery [(\"SELECT \", DBI), nameExp, (\" AS name \nFROM \", DBI), tabname, (\" AS person\", DBI)], witness, fn RESULT result => {name = fromSQL (0, result, \n#name witness)}) end Figure 4. example of query translation program that performs this conversion just \nafter an entire query is constructed. The resultof our translationof anSQL queryis thena core ML program \nhaving the following type. datatype a query = QUERY of string * a * (result -> a) The .rst component \nis an SQL command string to be sent to a server,the second componentisatoyimplementation,andthe third \ncomponent is the conversion function. Figure 4 shows an example of translating a query expression into \na core ML program.  4.5 Connection management The remaining component of our extension is connection \nmanage\u00adment. This is responsible for de.ning a server, establishing a con\u00adnection, and sending a query \nover connection. Among them, the third one is a simple source level library function that calls one of \nCAPI providedby the database server through SML#Cfunction interface described earlier. Server de.nition \nand connection estab\u00adlishment need to perform runtime typechecking to ensure the type safety of SQL expressions. \nWe have developed a typing machinery to infer a most general type for anylegal SQL query expression. \nThis inferred type should be checkedagainstthetypeofadatabase storedinadatabase server to be connected. \nSince a database server is external to SML# pro\u00adgrams, we model a database server as an object of type \ndynamic as proposed in [1]. In this formalism, an expression having a type dynamic is used with an explicit \ntype annotation. Its runtime rep\u00adresentation is a pair of its value and its runtime type information. \nThis runtime type information is checked against the explicit type annotation only once when this object \nis loaded (linked) in a pro\u00adgram.  In our language, this model is implemented by checking that the internal \ntype of the connected database server is the same as the static type speci.ed in _sqlserver expression \nwhen a database serveris connectedby SQL.connect primitive. This is done as fol\u00adlows. _sqlserver expression \nis translated to a core ML code that generates a string representation of the annotated type t together \nwith the location information of the server. SQL.connect primi\u00adtive is implemented as a core ML function. \nThis function takes a server object of type t server containing a server location and type information, \nopens a connection using the server location in\u00adformation, and issues a query to the database to obtain \nits scheme information, and then it checks that the connected database has the type t using its string \nrepresentation and the obtained scheme in\u00adformation. If the type check succeeds then SQL.connect succeeds \nand yields a value of type t conn, otherwise it raises runtime ex\u00adception. After this connection, a database \nis safely used with typed .rst-class SQL query expressions.  4.6 SQL server bindings SincetheSQL syntaxof \nour languageis(a subsetof)the standard\u00adized SQL language, our language should be independent of anypar\u00adticularSQL \nserver implementation.However,CAPIs neededtoim\u00adplement the connection management are varied with SQL \nservers. For our system to work with anyserver that conform to the SQL standard, we introduce a server \nbinding module and its interface which absorbs the difference of low-levelCAPIs. Any user-level primitive \nfeatures of SQL extentions, such as SQL.fetchAll and SQL.connect functions, are implemented by using \nthis binding module. The server binding interface requires the binding module imple\u00admentator to provide \nthe following functions. 1. Low-level connection management functions through abstract connection handles, \nand string-based query execution func\u00adtions. 2. A function to obtain schema information for runtime \ntype\u00adchecking. 3. A mapping of type names from database types to ML types, and the corresponding set \nof conversion functions from query results to ML values.  With the functionality provided by anymodern \nSQL database sys\u00adtems, it is routine to implement these functions by writing a small amount of code. \nOn the requirement 1, database systems usually offer such a string-based low-level query interface, as \ndiscussed in section 1.1. The requirement 2 can be easily realized by a se\u00adries of SQL queries issued \nthrough the low-level query interface since database systems usually implement system catalogs as ta\u00adbles \nwhich is accessible to an ordinary SELECT command. The re\u00adquirement3 canbe implementedby composinglow-level \nmethods to retrieve tuples and .elds from the query result and representa\u00adtion conversion functions. \nThisis also streightforwardexcept thata little care is needed to de.ne the type name mapping. We have \nimplemented binding modules for PostgreSQL and MySQL. Any other database systems can be supported just \nby writing a binding module for the database. 5. Conclusions and FutureWorks We have presented a new \ngeneration of Standard ML that seam\u00adlessly integrates SQL. In this language, a legal SQL expression is \na polymorphically typed .rst-class citizen that are freely combined with anyfeatures of Standard ML, \nincluding high-order functions, data type de.nition, and its module system. The distinguishing fea\u00adtureof \nour languageis that thoseSQLexpressions are notevaluated in the ML language runtime, but they are sent \nto a real database server. This makes ef.cient practical database programming di\u00adrectlyavailableinahigh-leveland \nreliable functional programming language. We have solved a number of typing and implementation issues \nand have implemented the language. The implementation is done byextendingthe compilerofSML#, whichisanextensionof \nStan\u00addard ML with record polymorphism. Since the only crucial techni\u00adcal typing device we have used is \nrecord polymorphism presented in [28], we also expect that our method can be transferred to any other \nML-style language asfar as its type system containsa typ\u00ading mechanism that is at least as powerful as \nrecord polymorphism such as OCaml objects based on Remy srecord polymorphism [31] or Haskell type classes \n[17]. This is a step toward making practical database programming seamlessly available in a typed high-level \nprogramming language. Anumberof interesting future issues remaintobeinvestigated.We brie.y mention some \nof them below. As mentioned in Section 1.1, there are several proposals for high-level query languages \nfor advanced applications. One way of making these approaches practical and scalable would be to implement \nthose advanced data models on top of SQL running on an ef.cient database server. The idea would be to \nmake SQL relations as basic data structures to implement those high-level data model primitives. Since \nin our language various components in SQL databases are .rst-class values that are freely and directly \nmanipulated by programs, our language should serve as an ideal basis for those applications. Web programming \nframework is also a promising applica\u00adtion area of our language. Interoperation between languages and \ndatabases are crucial inWeb programming, and most of practical Web application framework such as Ruby \non Rails providesvarious database access supports. Seamless integration of SQL with higher\u00adorder functional \nlanguagewould openup high-levelWeb applica\u00adtion framework supporting various features such as mashup \nof variety of data sources and services. Another interesting future work is to design a large scale dis\u00adtributed \ndata manipulation system based on our language. Such a system would provide high-level and powerful alternative \nto map\u00adreduce model [12]. As observed in [5], many future cloud appli\u00adcations would be bene.ted from \ndatabase capability such as the ability to join various data sources. References [1] M. Abadi, L. Cardelli, \nB. Pierce, and G. Plotkin. Dynamic typing in a statically-typed language. ACM Trans. Program. Lang. Syst., \n13(2):207 268, 1991. [2] A. Albano, G. Ghelli, and R. Orsini. Fibonacci: a programming language for object \ndatabases. The VLDB Journal, 4(3):403 444, 1995. [3] J. Annevelink. Database programming languages: a \nfunctional ap\u00adproach. In Proceedings of theACM SIGMOD International Confer\u00adence on Management of Data, \npages 318 327, 1991. [4] M.P. Atkinson and O.P. Buneman. Types and persistence in database programming \nlanguages. ACM Computing Surveys, 1987. [5] S. Blanas,J.M.Patel,V. Ercegovac,J. Rao,E.J. Shekita, andY.Tian. \nA comparison of join algorithms for log processing in mapreduce. In Proceedings of the ACM SIGMOD International \nConference on Management of Data, pages 975 986, 2010.ACM. [6]P. Buneman,S. Naqvi,V.Tannen, andL.Wong. \nPrinciplesof pro\u00adgramming with complex objects and collection types. Theor. Comput. Sci., 149(1):3 48, \n1995. [7] A. Chlipala. Ur: statically-typed metaprogramming with type-level record computation. In ProceedingsoftheACM \nSIGPLAN Conference  on Programming Language Design and Implementation, pages 122 133, 2010. [8] E.F. \nCodd.Arelational model for large shared databank. Communi\u00adcationsof theACM, 13(6):377 387, 1970. [9] \nE. Cooper. The script-writer s dream: How to write great SQL in your own language, and be sure it will \nsucceed. In Proceedings of the International Symposium on Database Programming Languages, pages 36 51, \nSpringer-Verlag, 2009. [10] E. Cooper, S. Lindley,P.Wadler, and J.Yallop. Links: web program\u00adming without \ntiers. In Proceedings of the International Conference on Formal Methods for Components and Objects, pages \n266 296, Springer-Verlag, 2007. [11] G. Copeland and D. Maier. Making smalltalk a database system. In \nProceedings of the ACM SIGMOD International Conference on Management of Data, pages 316 325, 1984. [12] \nJ. Dean and S. Ghemawat. Mapreduce: simpli.ed data processing on large clusters. Commun.ACM, 51(1):107 \n113, 2008. [13] A. Eisenbergand J. Melton. SQLJ part 0, now known as SQL/OLB (object-language bindings). \nSIGMOD Rec., 27(4):94 100, 1998. [14] J. Gil and K. Lenz. Simple and safe SQL queries with C++ templates. \nScience of Computer Programming, 75(7):573 595, 2010. [15] G. Giorgidze,T. Grust,T. Schreiber, and J.Weijers. \nHaskell boards the Ferry: Database-supported program execution for Haskell. In Proceedings of the 22nd \ninternational symposium on Implementation and Application of Functional Languages, to appear. [16]T. \nGrust,M.Mayr,J. Rittinger,andT. Schreiber. FERRY: database\u00adsupported programexecution.In Proceedings \nof the SIGMOD Interna\u00adtional Conference on Management of Data, pages 1063 1066, 2009. [17]C.V. Hall,K. \nHammond,S.L.Peyton Jones,andP.L.Wadler.Type classes in haskell. ACMTrans. Program. Lang. Syst., 18(2):109 \n138, 1996. [18]P. Hudak. Building domain-speci.c embedded languages. ACM Comput. Surv., page 196, 1996. \n[19] C.L\u00b4ecluse andP. Richard. TheO2 database programming language. In Proceedings of the International \nConference onVery Large Data Bases, pages 423 432, Morgan Kaufmann Publishers Inc, 1989. [20] D. Leijen \nand E. Meijer. Domain speci.c embedded compilers. In Proceedings of the 2nd USENIX Conference on Domain \nSpeci.c Lan\u00adguages, pages 109 122, 1999. \u00a8 oriented database programming languages. ACM Comput. Surv., \n34(4):409 449, 2002. [21]Y. Leontiev,M.T. Ozsu,andD. Szafron.Ontype systemsfor object\u00ad [22] D. Maier. \nWhy database languages area bad idea. InF. Bancilhon andP. Buneman, editors, Proceedings of the InternationalWorkshop \non Database Programming Languages, Addison-Wesley, 1989. [23] E. Meijer, B. Beckman, and G. Bierman. \nLINQ: Reconciling object, relations and XML in the .NET framework. In Proceedings of the ACM SIGMOD International \nConference on Management of Data, pages 706 706, 2006. [24] R. Milner, M.Tofte, R. Harper, and D. MacQueen. \nThe De.nition of StandardML. The MIT Press, revised edition, 1997. [25] J.C. Mitchell and G.D. Plotkin. \nAbstract types have existential type. ACMTrans.Program. Lang. Syst., 10(3):470 502, 1988. [26] R. Morrison,F. \nBrown,R. Connor,Q. Cutts,A. Dearle,G. Kirby, and D. Munro. Napier88 reference manual. Technical report, \nUniversity of St. Andrews, 1996. [27] H-D. Nguyen and A. Ohori. Compiling ml polymporphism with explicit \nlayout bitmap. In Proceedings of the ACM Conference on Principles and Practice of Declarative Programming, \npages 237 248, 2006. [28] A. Ohori. Apolymorphic record calculus and its compilation. ACM Trans. Program. \nLang. Syst., 17(6):844 895, 1995. A preliminary summaryappearedatACMPOPL,1992underthetitle Acompilation \nmethod for ML-style polymorphic record calculi . [29] A. Ohori andP. Buneman.Type inferenceina database \nprogramming language. In Proceedingsof theACM Conference on LISP and Func\u00adtional Programming, pages 174 \n183, 1988. [30] A. Ohori,P. Buneman, andV. Breazu-Tannen. Database programming in Machiavelli a polymorphic \nlanguage with static type inference. In Proceedings of the ACM SIGMOD International Conference on Management \nof Data, pages 46 57, 1989. [31] D. Remy. Typechecking records and variants in a natural extension of \nML. In Proceedings of the ACM Symposium on Principles of Programming Languages, pages 242 249, 1989. \n[32] SML#. http://www.riec.tohoku.ac.jp/smlsharp/. [33] J. Bussche, D. Van Gucht, and S. Vansummeren. \nA crash course on database queries. In Proceedings of theACM SIGMOD-SIGACT-SIGART Symposium on Principles \nof Database Systems, pages 143 154, 2007. [34] Limsoon Wong. Kleisli, a functional query system. J. Funct. \nPro\u00adgram., 10(1):19 56, 2000.    \n\t\t\t", "proc_id": "2034773", "abstract": "<p>Integrating a database query language into a programming language is becoming increasingly important in recently emerging high-level cloud computing and other applications, where efficient and sophisticated data manipulation is required during computation. This paper reports on seamless integration of SQL into SML# - an extension of Standard ML. In the integrated language, the type system always infers a principal type for any type consistent SQL expression. This makes SQL queries first-class citizens, which can be freely combined with any other language constructs definable in Standard ML. For a program involving SQL queries, the compiler separates SQL queries and delegates their evaluation to a database server, e.g. PostgreSQL or MySQL in the currently implemented version.</p> <p>The type system of our language is largely based on Machiavelli, which demonstrates that ML with record polymorphism can represent type structure of SQL. In order to develop a practical language, however, a number of technical challenges have to be overcome, including static enforcement of server connection consistency, proper treatment of overloaded SQL primitives, query compilation, and runtime connection management. This paper describes the necessary extensions to the type system and compilation, and reports on the details of its implementation.</p>", "authors": [{"name": "Atsushi Ohori", "author_profile_id": "81100168829", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P2801435", "email_address": "ohori@riec.tohoku.ac.jp", "orcid_id": ""}, {"name": "Katsuhiro Ueno", "author_profile_id": "81488652229", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P2801436", "email_address": "katsu@riec.tohoku.ac.jp", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034815", "year": "2011", "article_id": "2034815", "conference": "ICFP", "title": "Making standard ML a practical database programming language", "url": "http://dl.acm.org/citation.cfm?id=2034815"}