{"article_publication_date": "09-19-2011", "fulltext": "\n Set-theoretic Foundation of Parametric Polymorphism and Subtyping Giuseppe Castagna1 Zhiwu Xu1,2 * \n1CNRS, Laboratoire Preuves, Programmes et Syst`emes, Univ Paris Diderot, Sorbonne Paris Cit\u00b4e, Paris, \nFrance. 2State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Science, \nBeijing, China Abstract. We de.ne and study parametric polymorphism for a type system with recursive, \nproduct, union, intersection, negation, and function types. We .rst recall why the de.nition of such \na sys\u00adtem was considered hard when not impossible and then present the main ideas at the basis of our \nsolution. In particular, we intro\u00adduce the notion of convexity on which our solution is built up and \ndiscuss its connections with parametricity as de.ned by Reynolds to whose study our work sheds new light. \nCategories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features Polymorphism; \nData types and structure; F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs type \nstructure General Terms Theory, Languages Keywords Types, subtyping, polymorphism, parametricity, XML \n1. Introduction The standard approach to de.ning subtyping is to de.ne a collec\u00adtion of syntax-driven \nsubtyping rules that relate types with similar syntactic structure. However the presence of logical operators, \nsuch as unions and intersections, makes a syntactic characterization dif\u00ad.cult, which is why a semantic \napproach is used instead: type t is a subtype of type s if the set of values denoted by t is a subset \nof the set of values denoted by s. The goal of this study is to extend this approach to parametric types. \nSince such type systems are at the heart of functional languages manipulating XML data, our study directly \napplies to them. Parametric polymorphism has repeatedly been requested to and discussed in various working \ngroups of stan\u00addards (eg, RELAX NG [5] and XQuery [6]) since it would bring not only the well-known advantages \nalready demonstrated in ex\u00adisting functional languages, but also new usages peculiar to XML. A typical \nexample is SOAP [21] that provides XML envelopes to wrap generic content. Functions manipulating SOAP \nenvelopes are thus working on polymorphically typed objects encapsulated in XML structures. Polymorphic \nhigher-order functions are also * This author was partially supported by the National Natural Science \nFoun\u00addation of China under Grant No. 61070038 and by a joint training program by CNRS and the Chinese \nAcademy of Science. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. ICFP 11, September 19 21, 2011, Tokyo, Japan. Copyright c &#38;#169; 2011 ACM 978-1-4503-0865-6/11/09. \n. . $10.00 needed, as shown by our practice of Ocsigen [1], a framework to develop dynamic web sites \nwhere web-site paths (uri) are associ\u00adated to functions that take the uri parameters the so-called query \nstrings [7] and return a Xhtml page. The core of the dynamic part of Ocsigen system is the function register \nnew service whose (moral) type is: .X<:Params.(Path \u00d7 (X . Xhtml)) . unit That is, it is a function that \nregisters the association of its two parameters: a path in the site hierarchy and a function that fed \nwith a query string that matches the description X (Params being the XML type of all possible query strings) \nreturns an Xhtml page. Unfortunately, this kind of polymorphism is not available and the current implementation \nof register new service must bypass the type system (of OCaml, OCamlDuce [9], and/or CDuce [2]), losing \nall the advantages of static veri.cation. So why despite all this interest and motivations does no satis\u00adfactory \nsolution exist yet? The crux of the problem is that, despite several efforts (eg, [15, 20]), it was not \nknown how to de.ne and a fortiori how to decide the subtyping relation for XML types in the presence \nof type variables. Actually, a purely semantic subtyp\u00ading approach to polymorphism was believed to be \nimpossible. In this paper we focus on this problem and though, hence\u00adforth we will seldom mention XML \nsolve it. The solution which is more broadly applicable than just to an XML processing setting is based \non some strong intuitions and a lot of technical work. We follow this dichotomy for our presentation \nand organize it in two parts: an informal description of the main ideas and in\u00adtuitions underlying the \napproach and the formal description of the technical development. More precisely, in Section 2 we .rst \nex\u00adamine why this problem is deemed unfeasible or unpractical and simple solutions do not work (\u00a72.1-2.3). \nThen we present the in\u00adtuition underlying our solution (\u00a72.4) and outline, in an informal way, the main \nproperties that make the de.nition of subtyping pos\u00adsible (\u00a72.5) as well as the key technical details \nof the algorithm that decides it (\u00a72.6). We conclude this .rst part by giving some ex\u00adamples of the subtyping \nrelation (\u00a72.7) and discussing related work (\u00a72.8). In Section 3 we present the key steps of the formal \ntreatment to support the claims of Section 2 in particular the soundness and completeness of the algorithm \nand the decidability of the subtyp\u00ading relation. We conclude our presentation with Section 4 where we \ndiscuss at length the connections between parametricity and our solution, as well as the new perspectives \nof research that our work opens. It may seem odd that we focus on a subtyping relation without de.ning \nany calculus to use it. De.ning the polymorphic subtyping relation and de.ning a polymorphic calculus \nare distinct problems (though the latter depends on the former), and there is no doubt that the former \nis the very harder one. Once the subtyping relation is de.ned, it can be immediately applied to simple \npoly\u00admorphic calculi (eg, an extension with higher-order functions of the language in [15]) but the de.nition \nof calculi that fully exploit the expressiveness of these types and of algorithms that (even partially) \ninfer type annotations are different and very dif.cult problems that we leave for future work.  2. The \nkey ideas 2.1 Regular types XML types are essentially regular tree languages: an XML type is the set \nof all XML documents that match the type. As such they can be encoded by product types (for concatenation), \nunion types (for regexp unions) and recursive types (for Kleene s star). To type higher order functions \nwe need arrow types and we also need intersection and negation types since in the presence of arrows \nthey can no longer be encoded. Therefore, studying polymorphism for XML types is equivalent to studying \nit for the types that are coinductively (for recursion) produced by the following grammar: t ::= b | \nt \u00d7 t | t . t | t . t | t . t |\u00act | 0 | 1 where b ranges over basic types (eg, Bool, Real, Int, ...), \nand 0 and 1 respectively denote the empty (ie, that contains no value) and top (ie, that contains all \nvalues) types. In other terms, types are nothing but a propositional logic (with standard logical con\u00adnectives: \n., ., \u00ac) whose atoms are 0, 1, basic, product, and arrow types. We use T to denote the set of all types. \nIn order to preserve the semantics of XML types as sets of doc\u00aduments (but also to give programmers a \nvery intuitive interpreta\u00adtion of types) it is advisable to interpret a type as the set of all values \nthat have that type. Accordingly, Int is interpreted as the set that contains the values 0, 1, -1, 2, \n...; Bool is interpreted as the set the contains the values true and false; and so on. In particular, \nthen, unions, intersections, and negations (ie, type con\u00adnectives) must have a set-theoretic semantics. \nFormally, this corre\u00adsponds to de.ne an interpretation function from types to the sets of some domain \nD (for simplicity the reader can think of D as the set of all values of the language), that is [] : T. \nP(D), such that (i) [t1 . t2] = [t1] . [t2],(ii) [t1 . t2] = [t1] n [t2], (iii) [\u00act] = D\\ [t],(iv) [0] \n= \u00d8, and (v) [1] = D. Once we have de.ned such an interpretation, then the subtyping relation is naturally \nde.ned in terms of it: def t1 = t2 .. [t1] . [t2] which, restricted to XML types, corresponds to the \nusual interpre\u00adtation of subtyping as language containment. 2.2 Higher-order functions All de.nitions \nabove run quite smoothly as long as basic and product types are the only atoms we consider (ie, the setting \nstudied by Hosoya and Pierce [16]). But as soon as we add higher-order functions, that is, arrow types, \nthe de.nitions above no longer work: 1. If we take as D the set of all values, then this must include \nalso .-abstractions. Therefore, to de.ne the semantic interpretation of types we need to de.ne the type \nof .-abstractions (in partic\u00adular of the applications that may occur in their bodies) which needs the \nsubtyping relation, which needs the semantic inter\u00adpretation. We fall on a circularity. 2. If we take \nas D some mathematical domain, then we must interpret t1 . t2 as the set of functions from [t1] to [t2]. \nFor instance if we consider functions as binary relations, then [t1 . t2] could be the set  { f .D2 \n| (d1,d2).f and d1.[t1] implies d2.[t2] } (1) or, compactly, P([t1]\u00d7[t2]), where the S denotes the com\u00adplement \nof the set S within the appropriate universe (in words, these are the sets of pairs in which it is not \ntrue that the .rst pro\u00adjection belongs to [t1] and the second does not belong to [t2]). But here the \nproblem is not circularity but cardinality, since this would require D to contain P(D2), which is impossible. \nThe solution to both problems is given by the theory of semantic subtyping [10], and relies on the observation \nthat in order to use types in a programming language we do not need to know what types are, but just \nhow they are related (by subtyping). In other terms, we do not require the semantic interpretation to \nmap arrow types into the set in (1), but just to map them into sets that induce the same subtyping relation \nas (1) do. Roughly speaking, this turns out to require that for all s1, s2, t1, t2, the function [.] \nsatis.es the property: [s1.s2] . [t1.t2] .. P([s1]\u00d7[s2]) . P([t1]\u00d7[t2]) (2) whatever the sets denoted \nby s1.s2 and t1.t2 are. Equation (2) above covers only the case in which we compare two single arrow \ntypes. But, of course, a similar restriction must be imposed also when comparing arbitrary Boolean combinations \nof arrows. For\u00admally, this can be enforced as follows. Let [.] be a mapping from T to P(D), we de.ne \na new mapping E[.1 as follows (henceforth we omit the [.] subscript from E[.1): E(0)=\u00d8 E(1)=D E(\u00act)=D\\ \nE(t) E(b)=[b] E(t1 . t2)=E(t1) . E(t2) E(t1 \u00d7 t2)=[t1] \u00d7 [t2] E(t1 . t2)=E(t1) n E(t2) E(t1 . t2)=P([t1]\u00d7[t2]) \nThen [.] and D form a set-theoretic model of types if, besides the properties (i-v) for the type connectives \nwe stated in \u00a72.1, the function [.] also satis.es the following property: .. E(t1) . E(t2) (3) [t1] . \n[t2] which clearly implies (2). All these de.nitions yield a subtyping re\u00adlation with all the desired \nproperties: type connectives (ie, unions, intersections, and negations) have a set-theoretic semantics, \ntype constructors (ie, products and arrows) behave as set-theoretic prod\u00aducts and function spaces, and \n(with some care in de.ning the lan\u00adguage and its typing relation) a type can be interpreted as the set \nof values that have that type. All that remains to do is: 1. show that a model exists1 (easy) and 2. \nshow how to decide the subtyping relation (dif.cult).  Both points are solved in [10] and the resulting \ntype system is at the core of the programming language CDuce [2].  2.3 The problem and a naive (wrong) \nsolution The problem we want to solve in this paper is how to extend the approach described above when \nwe add type variables (in bold): t ::= a | b | t \u00d7 t | t . t | t . t | t . t |\u00act | 0 | 1 where a ranges \nover a countable set of type variables V. We did not include any explicit quanti.cation for type variables: \nin this work (as well as, all works in the domain we are aware of, foremost [15, 20]) we focus on prenex \nparametric polymorphism where type quanti.cation is meta-theoretic. Once more, the crux of the problem \nis how to de.ne the subtyping relation between two types that contain type variables. Since we know how \nto subtype closed types (ie, types without variables), then a naive solution is to reuse this relation \nby considering all possible ground instances of types with variables. Let s denote a ground substitution, \nthat is 1 We do not need to look for a particular model, since all models induce essentially the same \nsubtyping relation: see [8] for details.  a substitution from type variables to closed types. Then according \nto our naive de.nition two types are in subtyping relation if so are their ground instances: def t1 = \nt2 .. .s. [t1s] . [t2s] (4) (provided that the domain of s contains all the variables occurring in t1 \nand t2). This closely matches the syntactic intuition of sub\u00adtyping for prenex polymorphism according \nto which the statement t1 = t2 is to be intended as .a1...an(t1 = t2), where a1...an are all the variables \noccurring in t1 or t2. Clearly, the containment on the right hand side of (4) is a necessary condition \nfor subtyping. Unfortunately, considering it also as necessary and, thus, using (4) to de.ne subtyping \nyields a subtyping relation that suffers too many problems to be useful. The .rst obstacle is that, as \nconjectured by Hosoya in [15], if the subtyping relation de.ned by (4) is decidable (which is an open \nproblem), then deciding it is at least as hard as the satis.ability problem for set constraint systems \nwith negative constraints, which is NEXPTIME-complete and for which, so far, no practical algo\u00adrithm \nis known. But even if the subtyping relation de.ned by (4) were decidable and Hosoya s conjecture wrong, \nde.nition (4) yields a subtyping relation that misses the intuitiveness of the relation on ground types. \nThis can be shown by an example drawn from [15]. For the sake of the example, imagine that our system \nincludes singleton types, that is types that contain just one value, for every value of the language, \nand consider the following subtyping statement: t \u00d7 a = (t \u00d7\u00act) . (a \u00d7 t) (5) where t is a closed type. \nAccording to (4) the statement holds if and only if t \u00d7 s = (t \u00d7\u00act) .(s \u00d7t) holds for every closed type \ns. It is easy to see that the latter holds if and only if t is a singleton type. This follows from the \nset theoretic property that if S is a singleton, then for every set X, either S . X or X . S. By using \nthis property on the singleton type t, we deduce that for every ground substitution of a either a =\u00act \n(therefore t\u00d7a = t\u00d7\u00act, whence (5) follows) or t = a (therefore t \u00d7 a =(t \u00d7 a\\t) . (t \u00d7 t) and the latter \nis contained component-wise in (t \u00d7\u00act) . (a \u00d7 t), whence (5) holds again). Vice versa, if t contains \nat least two values, then substituting a by any singleton containing a value of t disproves the containment. \nMore generally, (5) holds if and only if t is an indivisible type, that is, a non-empty type whose only \nproper subtype is the empty type. Singleton types are just an example of indivisible types, but in the \nabsence of singleton types, basic types that are pairwise disjoint are indivisible as well. Therefore, \nwhile the case of singleton types is evocative, the same problem occurs in a language with just the Int \ntype, too. Equation (5) is pivotal in our work. It gives us two reasons to think that the subtyping relation \nde.ned by (4) is un.t to be used in practice. First, it tells us that in such a system deciding subtyp\u00ading \nis at least as dif.cult as deciding the indivisibility of a type. This is a very hard problem (see [3] \nfor an instance of this problem in a simpler setting) that makes us believe more in the undecid\u00adability \nof the relation, than in its decidability. Second, and much worse, it completely breaks parametricity \nyielding a completely non-intuitive subtyping relation. Indeed notice that in the two types in (5) the \ntype variable a occurs on the right of a product in one type and on the left of a product in the other. \nThe idea of parametricity is that a function cannot explore arguments whose type is a type vari\u00adable, \nit can just discard them, pass them to another function or copy them into the result. Now if (4) holds \nit means that by a simple sub\u00adsumption a function that is parametric in its second argument can be considered \nparametric in its .rst argument instead. Understanding the intuition underlying this subtyping relation \nfor type variables (where the same type variable may appear in unrelated positions in two related types) \nseems out of reach of even theoretically-oriented programmers. This is why a semantic approach for subtyping \npoly\u00admorphic types has been deemed unfeasible and discarded in favor of partial or syntactic solutions \n(see related works in \u00a72.8).  2.4 Ideas for a solution Although the problems we pointed out in [15] \nare substantial, they do not preclude a semantic approach to parametric polymorphism. Furthermore the \nshortcomings caused by the absence of this ap\u00adproach make the study well worth of trying. Here we show \nthat paraphrasing a famous article by John Reynolds [19] subtyping of polymorphism is set-theoretic. \nThe conjecture that we have been following since we discovered the problem of [15], and that is at the \nbasis of all this work, is that the loss of parametricity is only due to the behavior of indivisible \ntypes, all the rest works (more or less) smoothly. The crux of the problem is that for an indivisible \ntype t the validity of the formula t = a or a =\u00act (6) can stutter from one subformula to the other (according \nto the as\u00adsignment of a) losing in this way the uniformity typical of para\u00admetricity. If we can give \na semantic characterization of models in which stuttering is absent, we believed this would have yielded \na subtyping relation that is (i) semantic, (ii) intuitive for the pro\u00adgrammer,2 and (iii) decidable. \nThe problem with indivisible types is that they are either completely inside or completely outside any \nother type. What we need, then, is to make indivisible types split\u00adtable , so that type variables can \nrange over strict subsets of any type, indivisible ones included. Since this is impossible at a syn\u00adtactic \nlevel, we shall do it at a semantic level. First, we replace ground substitutions with semantic (set) \nassignments of type vari\u00adables, . : V. P(D), and add to interpretation functions a se\u00admantic assignment \nas a further parameter (as is customary in deno\u00adtational semantics): [.] : T. P(D)V . P(D) Such an interpretation \n(actually, the pair ([.], D) ) is then a set\u00adtheoretic model if and only if for all assignments . it \nsatis.es the following conditions (in bold the condition that shows the role of the assignment parameter \n.): [a]. = .(a) [\u00act. = D\\[t]. 0 . = \u00d8 t1 . t2 . = t1 . . t2 . = D = [ 1] . [ t1 . t2] . [ t1] . n [ t2] \n. .. E(t1). . E(t2). [t1]. . [t2]. (where E() is extended in the obvious way to cope with semantic assignments). \nThen the subtyping relation is de.ned as follows: def. [t1]. . [t2]. t1 = t2 .. ...P(D)V (7) In this \nsetting, every type t that denotes a set of at least two elements of D can be split by an assignment. \nThat is, it is possible to de.ne an assignment for which a type variable a denotes a subset of D that \nis neither completely inside nor completely outside the interpretation of t. Therefore for such a type \nt, neither equation (6) nor, a fortiori, equation (5) hold. It is then clear that the stuttering of (6) \nis absent in every set-theoretic model in which all non-empty types indivisible types included denote \nin.nite subsets of D. In.nite denotations for non-empty types look as a possible, though 2 For instance, \ntype variables can only be subsumed to themselves and according to whether they occur in a covariant \nor contravariant position, to 1 and to unions in which they explicitly appear or to 0 and intersections \nin which they explicitly appear, respectively. De Morgan s laws can be used to reduce other cases to \none of these.  speci.c, solution to the problem of indivisible types. But what we are looking for is \nnot a particular solution. We are looking for a semantic characterization of the uniformity that characterizes \nparametricity, in order to de.ne a subtyping relation that is, we repeat, semantic, intuitive, and decidable. \nThis characterization is provided by the property of convexity.  2.5 Convexity A set theoretic model \n([.], D) is convex if and only if for every .nite set of types t1,. . . , tn it satis.es the following \nproperty: ...([t1].=\u00d8 or \u00b7\u00b7\u00b7 or [tn].=\u00d8) .. (8) (...[t1].=\u00d8) or \u00b7\u00b7\u00b7 or (...[tn].=\u00d8) This property is \nthe cornerstone of our approach. As such it de\u00adserves detailed comments. It states that, given any .nite \nset of types, if every assignment makes some of these types empty, then it is so because there exists \none particular type that is empty for all pos\u00adsible assignments.3 Therefore convexity forces the interpretation \nfunction to behave uniformly on its zeros (ie, on types whose in\u00adterpretation is the empty set). Now, \nthe zeros of the interpretation function play a crucial role in the theory of semantic subtyping, since \nthey completely characterize the subtyping relation. Indeed s = t . [s] . [t] . [s] n [t] . \u00d8 . [s .\u00act] \n= \u00d8. Conse\u00adquently, checking whether s = t is equivalent to checking whether the type s .\u00act is empty; \nlikewise, equation (3) in \u00a72.2 is equiva\u00adlent to requiring that for all t it satis.es [t] = \u00d8 .. E(t)= \n\u00d8. We deduce that convexity forces the subtyping relation to have a uniform behavior and, ergo, rules \nout non-intuitive relations such as the one in (5). This is so because convexity prevents stuttering, \ninsofar as in every convex model ([t.\u00aca].=\u00d8 or [t.a].=\u00d8) holds for all assignments . if and only if t \nis empty. Convexity is the property we seek. The resulting subtyping rela\u00adtion is semantically de.ned \nand preserves the set-theoretic seman\u00adtics of type connectives (union, intersection, negation) and the \ncon\u00adtainment behavior of set-theoretic interpretations of type construc\u00adtors (set-theoretic products \nfor product types and set-theoretic func\u00adtion spaces for arrow types). Furthermore, the subtyping relation \nis not only semantic but also intuitive. First, it excludes non-intuitive relations by imposing a uniform \nbehavior distinctive of the para\u00admetricity ` a la Reynolds: as we discuss at length in the conclusion, \nwe push the analogy much farther since we believe that parametric\u00adity and convexity are connected, despite \nthe fact that the former is de.ned in terms of transformations of related terms while the lat\u00adter deals \nonly with (subtyping) relations. Second, it is very easy to explain the intuition of type variables to \na programmer: For what concerns subtyping, a type variable can be consid\u00adered as a special new user-de.ned \nbasic type that is unre\u00adlated to any other atom but 0 and 1 and itself.4 Type vari\u00adables are special \nbecause their intersection with any ground type may be non-empty, whatever this type is. 3 We dubbed \nthis property convexity after convex formulas: a formula is convex if whenever it entails a disjunction \nof formulas, then it entails one of them. The . direction of (8) (the other direction is trivial) states \nthe convexity of assignments with respect to emptiness: . . P(D)V . W i.I [ti]. = \u00d8implies that there \nexists h . I such that . . P(D)V . [th]. = \u00d8. 4 This holds true even for languages with bounded quanti.cation \nwhich, as it is well known, de.nes the subtyping relation for type variables. Bounded quanti.cation does \nnot require any modi.cation to our system, since it can be encoded by intersections: a type variable \na bounded by a type t can be encoded by a fresh (unbounded) variable \u00df by replacing \u00df.t for every occurrence \nof a. We can do even more, since by using intersections we can impose different bounds to different occurrences \nof the same variable. Of course, neither in the theoretical development nor in the sub\u00adtyping algorithm \ntype variables are dealt with as basic types. They need very subtle and elaborated techniques that form \nthe core of our work. But this complexity is completely transparent to the pro\u00adgrammer which can thus \nrely on a very simple intuition. All that remains to do is (i) to prove the convexity property is not \ntoo restrictive, that is, that there exists at least one convex set-theoretic model and (ii) to show \nan algorithm that checks the subtyping relation. Contrary to the ground case, both problems are dif.cult. \nWhile their solutions require a lot of technical results (see Section 3), the intuition underlying them \nis relatively simple. For what concerns the existence of a convex set-theoretic model, the intuition \ncan be grasped by considering just the logical fragment of our types, that is, the types in which 0 and \n1 are the only atoms. This corresponds to the (classical) propositional logic where the two atoms represent, \nrespectively, false and true. Next, consider the instance of the convexity property given for just two \ntypes, t1 and t2. It is possible to prove that every non-degenerate Boolean algebra (ie, every Boolean \nalgebra with more than two elements) satis.es it. Reasoning by induction it is possible to prove that \nconvexity for n types is satis.ed by any Boolean algebra containing at least n + 1! elements and from \nthere deduce that all in.nite Boolean algebras satisfy convexity. It is then possible to extend the proof \nto the case that includes basic, product, and arrow types and deduce the following result: Every set-theoretic \nmodel of closed types in which non\u00ad empty types denote in.nite sets is a convex set-theoretic model for \nthe polymorphic types. Therefore, not only do we have a large class of convex models, but also we recover \nour initial intuition that models with in.nite denotations was the way to go. All that remains to explain \nis the subtype checking algorithm. We do it in the next section, but before we want to address the possible \ndoubts of a reader about what the denotation of a .nite type like Bool is in such models. In particular, \nsince this denotation contains not only (the denotations of) true and false but in.nitely many other \nelements, then the reader can rightly wonder what these other elements are and whether they carry any \nintuitive meaning. In order to explain this point, let us .rst reexamine what convexity does for in.nite \ntypes. Convexity is a condition that makes the interpretation of subtyping in some sense independent \nfrom the particular syntax of types. Imagine that the syntax of types includes just one basic type: Int. \nThen Int is an indivisible type and therefore there exist non-convex models in which the following relation \n(which is an instance of equation (5) of Section 2.3) holds. Int \u00d7 a = (Int \u00d7\u00acInt) . (a \u00d7 Int) (9) (eg, \na model where Int is interpreted by a singleton set: in a non\u00adconvex model nothing prevents such an interpretation). \nNow imag\u00adine to add the type Odd, subtype of Int, to the type system: then (9) no longer holds (precisely, \nthe interpretation at issue no longer is a model) since the substitution of a by Odd disproves it. Should \nthe presence of Odd change the containment relation between Int and the other types? Semantically this \nshould not happen. A relation as (9) should have the same meaning independently from whether Odd is included \nin the syntax of types or not. In other terms we want the addition of Odd to yield a conservative extension \nof the subtyping relation. Therefore, all models in which (9) is valid must be discarded. Convexity does \nit. The point is that convexity pushes this idea to all types, so that their interpretation is independent \nfrom the possible syntactic sub\u00adtypes they may have. It is as if the interpretation of subtyping as\u00adsumed \nthat every type has at least one (actually, in.nitely many) stricter non empty subtype(s). So what could \nthe denotation of type Bool be in such a model, then? A possible choice is to interpret Bool into a set \ncontaining labeled versions of true and false, where labels are drawn from an in.nite set of labels (a \nsimilar inter\u00adpretation was .rst introduced by Gesbert et al. [14]: see Section 2.8 on related work). \nHere the singleton type {true} is interpreted as an in.nite set containing differently labeled versions \nof the single element true. Does this labeling carry any intuitive meaning? One can think of it as representing \nname subtyping: these labels are the names of subtypes of the singleton type {true} for which the sub\u00adtyping \nrelation is de.ned by name subtyping. As we do not want the subtyping relation for Int to change (non \nconservatively) when adding to the system the type Odd, so for the same reason we do not want the subtyping \nrelation for singleton types to change when adding by name subtyping new subtypes, even when these subtypes \nare subtypes of a singleton type. So convexity makes the subtyping relation insensitive to possible extensions \nby name subtyping.  2.6 Subtyping algorithm The subtyping algorithm for the relation induced by convex \nmodels can be decomposed in 6 elementary steps. Let us explain the intu\u00adition underlying each of them: \nall missing details can be found in Section 3. First of all, we already said that deciding t1 = t2 ie, \nwhether for all ., [t1]. . [t2]. is equivalent to decide the emptiness of the type t1.\u00act2 ie, whether \nfor all ., [t1.\u00act2].=\u00d8 . So the .rst step of the algorithm is to transform the problem t1 = t2 into the \nproblem t1.\u00act2 = 0: Step 1: transform the subtyping problem into an emptiness deci\u00adsion problem. Our \ntypes are just a propositional logic whose atoms are type variables, 0, 1, basic, product, and arrow \ntypes. We use a to range over atoms and, following the logic nomenclature, call literal, ranged over \nby e, an atom or its negation: a ::= b | t \u00d7 t | t . t | 0 | 1 | ae ::= a |\u00aca By using the laws of propositional \nlogic we can transform every type into a disjunctive normal form, that is, into a union of inter\u00adsections \nof literals: _^ eij i.Ij.J Since the interpretation function preserves the set-theoretic seman\u00adtics of \ntype connectives, then every type is empty if and only if its disjunctive normal form is empty. So the \nsecond step of our algo\u00adrithm consists of transforming the type t1.\u00act2 whose emptiness was to be checked, \ninto a disjunctive normal form: Step 2: put the type whose emptiness is to be decided in a disjunc\u00adtive \nnormal form. Next, we have to decide when a normal form, that is, a union of intersections, is empty. \nA union is empty if and only if every mem\u00adber of the union is empty. Therefore the problem reduces to \ndecid- V ing emptiness of an intersection of literals: i.I ei. Intersections of literals can be straightforwardly \nsimpli.ed. Every occurrence of the literal 1 can be erased since it does not change the result of the \nintersection. If either any of the literals is 0 or two literals are a vari\u00adable and its negation, then \nwe do not have to perform further checks since the intersection is surely empty. An intersection can \nbe sim\u00adpli.ed also when two literals with different constructors occur in it: if in the intersections \nthere are two atoms of different constructors, say, t1\u00d7t2 and t1.t2, then their intersection is empty \nand so is the whole intersection; if one of the two atoms is negated, say, t1\u00d7t2 and \u00ac(t1.t2), then it \ncan be eliminated since it contains the one that is not negated; if both atoms are negated, then the \nintersection can also be simpli.ed (with some more work: cf. the formal devel\u00adopment in Section 3). Therefore \nthe third step of the algorithm is to perform these simpli.cations so that the problem is reduced to \ndeciding emptiness of intersections that are formed by literals that are (possible negations of) either \ntype variables or atoms all of the same constructor (all basic, all product, or all arrow types): Step \n3: simplify mixed intersections. At this stage we have to decide emptiness of intersections of VV VV \nj the form ai .\u00acaj . ah .\u00ac\u00dfk where all i.Ij.Jh.Hk.K j the ai s and aj s are atoms with the same constructor, \nand where {ah}h.H and {\u00dfk}k.K are disjoint sets of type variables: we just reordered literals so that \nnegated variables and the other negated atoms are grouped together. In this step we want to get rid of \nthe rightmost group in the intersection, that is, the one with negated type variables. In other terms, \nwe want to reduce our problem to deciding the emptiness of an intersections as the above, but where all \ntop-level occurrences of type variables are positive. This is quite easy, and stems from the observation \nthat if a type with a type variable a is empty for every possible assignment of a, then it will be empty \nalso if one replaces \u00aca for a in it: exactly the same checks will be performed since the denotation of \nthe .rst type for a . S .D will be equal to the denotation of the second type for a . S .D. That is to \nsay, ...[t]. = \u00d8 if and only if ...[t{\u00aca/a}]. = \u00d8 (where t{tj/a} denotes the substitution in t of tj \nfor a). So all the negations of the group of toplevel negated variables can be eliminated by substituting \n\u00ac\u00dfk for \u00dfk in the ai s j and aj s: Step 4: eliminate toplevel negative variables. Next comes what probably \nis the trickiest step of the algo\u00adrithm. We have to prove emptiness of intersections of atoms ai and \nj negated atoms aj all on the same constructors and of positive vari\u00adables ak. To lighten the presentation \nlet us consider just the case in which atoms are all product types (the case for arrow types is sim\u00adilar \nthough trickier, while the case for basic types is trivial since it reduces to the case for basic types \nwithout variables). By using De Morgan s laws we can move negated atoms on the right hand-side of the \nrelation so that we have to check the following containment ^ ^ t1\u00d7t2 . ah = _ tj1\u00d7tj2 (10) t1\u00d7t2.P h.H \nt;1\u00d7t;2.N where P and N respectively denote the sets of positive and neg\u00adative atoms. Our goal is to \neliminate all top-level occurrences of variables (the ah s) so that the problem is reduced to checking \nemptiness of product literals. To that end observe that each ah is intersected with other products. Therefore \nwhatever the interpre\u00adtation of ah is, the only part of its denotation that matters is the one that intersects \nD2. Ergo, it is useless, at least at top-level, to check all possible assignments for ah, since those \ncontained in D2 will suf.ce. These can be checked by replacing .h1\u00d7.h 2 for ah, where .h 1, , .h 2 are \nfresh type variables. Of course the above reason\u00ading holds for the top-level variables, but nothing tells \nus that the non top-level occurrences of ah will intersect any product. So re\u00adplacing them with just \n.h1\u00d7.h 2 would yield a sound but incomplete check. We rather replace every non toplevel occurrence of \nah by (.h1\u00d7.h2) . ah. This still is a sound substitution since if (10) holds, then it must also hold \nfor the case where (.h1\u00d7.h2) . ah is substi\u00adtuted for ah (with the .ah part useless for toplevel occurrences). \nRather surprisingly, at least at .rst sight, this substitution is also complete, that is (10) holds if \nand only if the following holds: ^^ _ 12 jj t1. \u00d7 t2. . .h \u00d7 .h = t1. \u00d7 t2. ;; t1\u00d7t2.Ph.Ht1\u00d7t2.N  \u00d7.2 \nwhere . is the substitution {(.h1 h) . ah/ah}h.H .5 As an aside, we signal that this transformation holds \nonly because ah s are posi\u00adtive: the application of Step 4 is thus a necessary precondition to the application \nof this one. We thus succeeded to eliminate all toplevel occurrences of type variables and, thus, we \nreduced the initial prob\u00adlem to the problem of deciding emptiness of intersections in which all literals \nare products or negations of products (and similarly for arrows): Step 5: eliminate toplevel variables. \nThe .nal step of our algorithm must decompose the type con\u00adstructors occurring at toplevel in order to \nrecurse or stop. To that end it will use set-theoretic properties to deconstruct atom types and, above \nall, the convexity property to decompose the emptiness problem into a set of emptiness subproblems (this \nis where convex\u00adity plays an irreplaceable role: without convexity the de.nition of an algorithm seems \nto be out of our reach). Let us continue with our example with products. At this stage all it remains \nto solve is to de\u00adcide a containment of the following form (we included the products of fresh variables \ninto P ): ^_ jj t1\u00d7t2 = t1\u00d7t2 (11) t1\u00d7t2.Pt1;\u00d7t;2.N Using the set-theoretic properties of the interpretation \nfunction and our de.nition of subtyping, we can prove (see Lemma 6.4 in [10] for details) that (11) holds \nif and only if for all Nj.N, 01 ^^ ^^ ... @[ t1 .\u00actj1].=\u00d8 or [ t2 .\u00actj2].=\u00d8A t1\u00d7t2.Pt1;\u00d7t;2.N; t1\u00d7t2.Pt1;\u00d7t;2.N\\N; \nWe can now apply the convexity property and distribute the quan\u00adti.cation on . on each subformula of \nthe or. This is equivalent to state that we have to check the emptiness for each type that oc\u00adcurs as \nargument of the interpretation function. Playing a little more with De Morgan s laws and applying the \nde.nition of subtyping we can thus prove that (11) holds if and only if 010 1 ^_ ^_ j@ j@ jA .N.N. t1 \n= t1 A or t2 = t2 t1\u00d7t2.Pt;1\u00d7t2;.N; t1\u00d7t2.Pt;1\u00d7t;2.N\\N; To understand the rationale of this transformation \nthe reader can consider the case in which both P and N contain just one atom, jj namely, the case for \nt1\u00d7t2 = t1\u00d7t2. There are just two cases to check (Nj=\u00d8and Nj=N) and it is not dif.cult to see that the \ncon\u00ad jj dition above becomes: (t1=0) or (t2=0) or (t1=t1 and t2=t2), as expected. The important point \nhowever is that we were able to express the problem of (11) in terms of subproblems that rest on strict \nsubterms (there is a similar decomposition rule for arrow types). Remember that our types are possibly \nin.nite trees since they were coinductively generated by the grammar in \u00a72.1. We do not consider every \npossible coinductively generated tree, but only those that are regular (ie, that have a .nite number \nof distinct subtrees) and in which every in.nite branch contains in.nitely many occurrences of type constructors \n(ie, products and arrows). The last condition rules out meaningless terms (such as t = \u00act) as well as \nin.nite unions and intersections. It also provides a well-founded order that allows us to use recursion. \nTherefore, we memoize the relation in (11) and recursively call the algorithm from Step 1 on the subterms \nwe obtained from decomposing the toplevel constructors: 5 Note that the result of this substitution is \nequivalent to using the substitu\u00adtion {(.h1\u00d7.h2) . .h3/ah}h.H where .3 is also a fresh variable: we just \nh spare a new variable by reusing ah which would be no longer used (actually this arti.ce makes proofs \nmuch easier). Step 6: eliminate toplevel constructors, memoize, and recurse. The algorithm is sound and \ncomplete with respect to the subtyping relation de.ned by (7) and terminates on all types (which implies \nthe decidability of the subtyping relation).  2.7 Examples The purpose of this subsection is twofold: \n.rst, we want to give some examples to convey the idea that the subtyping relation is intuitive; second \nwe present some cases that justify the subtler and more technical aspects of the subtyping algorithm \nwe exposed in the previous subsection. All the examples below can be tested in our prototype subtype-checker. \nIn what follows we will use x, y, z to range over recursion variables and the notation \u00b5x.t to denote \nrecursive types. This should suf.ce to avoid confusion with free type variables that are ranged over \nby a, \u00df, and .. As a .rst example we show how to use type variables to inter\u00adnalize meta-properties. \nFor instance, for all ground types t1, t2, and t3 the relation (t1 . t3) . (t2 . t3) = (t1.t2) . t3 and \nits con\u00adverse hold. This meta-theoretic property can be expressed in our type system since the following \nrelation holds: (a . .) . (\u00df . .) ~ (a.\u00df) . . (where ~ denotes that both = and = hold). Of course we \ncan apply this generalization to any relation that holds for generic types. For instance, we can prove \ncommon distributive laws such as ((a.\u00df) \u00d7 .) ~ (a\u00d7.) . (\u00df\u00d7.) (12) and combine it with the previous relation \nand the covariance of arrow on codomains to deduce (a\u00d7. . d1) . (\u00df\u00d7. . d2) = ((a.\u00df) \u00d7 .) . d1 . d2 Similarly \nwe can prove that the set of lists whose elements have type a, that is, a list = \u00b5x.(a\u00d7x) . nil, contains \nboth the a-lists with an even number of elements \u00b5x.(a\u00d7(a\u00d7x)) . nil = \u00b5x.(a\u00d7x) . nil (where nil denotes \nthe singleton type containing just the value nil) and the a-lists with an odd number of elements \u00b5x.(a\u00d7(a\u00d7x)) \n. (a\u00d7nil) = \u00b5x.(a\u00d7x) . nil and it is itself contained in the union of the two, that is: a list ~ (\u00b5x.(a\u00d7(a\u00d7x)).nil) \n. (\u00b5x.(a\u00d7(a\u00d7x)).(a\u00d7nil)) We said that the intuition for subtyping type variables is to consider them \nas basic types. But type variables are not basic types. As an example, if t is a non-empty type, then \nwe have that: a . (a \u00d7 t) = t1 . t2 which implies that a . (a \u00d7 t) is not empty. This is correct because \nif for instance we substitute the type t . (t \u00d7 t) for a, then (by the distributivity law stated in (12) \n) the intersection is equal to (t \u00d7 t), which is non-empty. However, note that if a were a basic type, \nthen the intersection a . (a \u00d7 t) would be empty. Furthermore, since the following relation holds a . \n(a \u00d7 t) = a then, this last containment is an example of non-trivial containment (in the sense that the \nleft hand-side is not empty) involving type variables. For an example of non-trivial containment involving \narrows the reader can check 1 . 0 = a . \u00df = 0 . 1 which states that 1 . 0, the set of all functions that \ndiverge on all arguments, is contained in all arrow types a . \u00df (whatever types a and \u00df are) and that \nthe latter are contained in 0 . 1, which is the set of all function values.  Type connectives implement \nclassic proposition logic. If we use a . \u00df to denote \u00aca . \u00df, that is logical implication, then the following \nsubtyping relation is a proof of Pierce s law: 1 = ((a . \u00df) . a) . a since being a supertype of 1 logically \ncorresponds to being equiv\u00adalent to true (note that arrow types do not represent logical impli\u00adcation; \nfor instance, 0.1 is not empty: it contains all function val\u00adues). Similarly, the system captures the \nfundamental property that for all non-empty sets \u00df the set (\u00df.a) . (\u00df.\u00aca) is never empty: (\u00df . a) . (\u00df \n.\u00aca) ~ \u00df from which we can derive 1 = ( ((\u00df.a) . (\u00df.\u00aca)) . 0 ) . (\u00df . 0) This last relation can be read \nas follows: if (\u00df.a) . (\u00df.\u00aca) is empty, then \u00df is empty. But the property above will never show a stuttering \nvalidity since the algorithm returns false when asked to prove nil \u00d7 a = (nil \u00d7\u00acnil) . (a \u00d7 nil) even \nfor a singleton type as nil. The subtyping relation has some simple form of introspection since t1=t2 \nif and only if 1 = t1.t2 (ie, by negating both types and reversing the subtyping relation, t1.\u00act2 = 0). \nHowever, the introspection capability is very limited insofar as it is possible to state interesting \nproperties only when atoms are type variables: although we can characterize the subtyping relation =, \nwe have no idea about how to characterize its negation =.6 The necessity for the tricky substitution \na . (.1\u00d7.2).a per\u00adformed at Step 5 of the algorithm can be understood by considering the following example \nwhere t is any non-empty type: (a \u00d7 t) . a = ((1 \u00d7 1) \u00d7 t). If in order to check the relation above we \nsubstituted just .1 \u00d7 .2 for a, then this would yield a positive result, which is wrong: if we replace \na by b . (b\u00d7t), where b is any basic type, then the in\u00adtersection on the left becomes (b\u00d7t) and b is \nneither contained in 1 \u00d7 1 nor empty. Our algorithm correctly disproves the contain\u00adment, since it checks \nalso the substitution of (.1 \u00d7 .2) . a for the .rst occurrence of a, which captures the above counterexample. \nFinally, the system also proves subtler relations whose meaning is not clear at .rst sight, such as: \na1 . \u00df1 = ((a1.a2).(\u00df1.\u00df2)) .\u00ac(a2.(\u00df2.\u00ac\u00df1)) (13) In order to prove it, the subtyping algorithm .rst moves \nthe occur\u00adrence of a2 . (\u00df2.\u00ac\u00df1) from the right of the subtyping relation to its left: (a1.\u00df1).(a2.(\u00df2.\u00ac\u00df1)) \n= ((a1.a2).(\u00df1.\u00df2)); then following the decomposition rules for arrows the algorithm checks the four \nfollowing cases (Step 6 of the algorithm), which 8 >>>< >>>: hold straightforwardly: a1.a2 = 0 or \u00df1 \n. (\u00df2 .\u00ac\u00df1) = \u00df1 . \u00df2 a1.a2 = a1 or (\u00df2 .\u00ac\u00df1) = \u00df1 . \u00df2 a1.a2 = a2 or \u00df1 = \u00df1 . \u00df2 a1.a2 = a1 . a2 Notice \nthat relation (13) is quite subtle insofar as neither a1 . \u00df1 = (a1.a2) . (\u00df1.\u00df2) nor a1 . \u00df1 =\u00ac(a2 . \n(\u00df2.\u00ac\u00df1)) hold: the type on left hand-side of (13) is contained in the union of the two types on the \nright hand-side of (13) without being completely contained in either of them.  2.8 Related work This \nwork extends the work on semantic subtyping [10], as such the two works share the same approach and common \ndevelopments. Since convex models of our theory can be derived from the models of [10], then several \ntechniques we used in our subtyping algorithm (in particular the decomposition of toplevel type constructors) \nare directly issued from the research in [10]. This work starts precisely from where [10] stopped, that \nis the monomorphic case, and adds prenex parametric polymorphism to it. The most advanced work on polymorphism \nfor XML types, thus far, is the Hosoya, Frisch, and Castagna s approach described in [15], whose extended \nabstract was .rst presented at POPL 05. Together with [10], the paper by Hosoya, Frisch, and Castagna \nconstitutes the starting point of this work. A starting point that, so far, was rather considered to \nestablish a (negative) .nal point. As a matter of fact, although the polymorphic system in [15] is the \none used to de.ne the polymorphic extension of XDuce [16] (incorporated from version 0.5.0 of the language), \nthe three authors of [15] agree that the main interest of their work does not reside in its type system, \nbut rather in the negative results that motivate it. In particular, the pivotal example of our work, \nequation (5), was .rst presented in [15], and used there to corroborate the idea that a purely semantic \napproach for polymorphism of regular tree types was an hopeless quest. At that time, this seemed so more \nhopeless that the equation (5) did not involve arrow types: a semantically de.ned polymorphic subtyping \nlooked out of reach even in the restrictive setting of Hosoya and Pierce seminal work [16], which did \nnot account for higher-order functions. This is why [15] falls back on a syntactic approach that, even \nif it retains some .avors of semantic subtyping, it cannot be extended to higher-order functions (a lack \nthat nevertheless .ts XDuce). Our works shows that the negative results of [15] were not so insurmountable \nas it had been thought. Hitherto, the only work that blends polymorphic regular types and arrow types \nis J\u00b4er ome Vouillon s work that was presented at POPL 06 [20]. His approach, however, is very different \nfrom ours insofar as it is intrinsically syntactic. Vouillon starts from a particu\u00adlar language (actually, \na peculiar pattern algebra) and coinductively builds up on it the subtyping relation by a set of inference \nrules. The type algebra includes only the union connective (negation and in\u00adtersection are missing) and \na semantic interpretation of subtyping is given a posteriori by showing that a pattern (types are special \ncases of patterns) can be considered as the set of values that match the pattern. Nevertheless, this \ninterpretation is still syntactic in na\u00adture since it relies on the de.nition of matching and containment, \nyielding a system tailored for the peculiar language of the paper. This allows Vouillon to state impressive \nand elegant results such as the translation of the calculus into a non-explicitly-typed one, or the interpretation \nof open types containment as in our equation (4) (according to Vouillon this last result is made possible \nin his system by the absence of intersection types, although the critical example 6 For instance, it \nwould be nice to prove something like: (\u00ac\u00df1 . ((\u00df1.a1) . (a2.\u00df2))) ~ (a1.a2 . \u00df1.\u00df2) since it seems to \nprovide a complete characterization of the subtyping relation between two arrow types. Unfortunately \nthe equivalence is false since \u00df1 = a1 does not imply \u00df1 .\u00aca1 = 1 but just \u00df1 .\u00aca1 = 0. This property \ncan be stated only at meta level, that is: a1.a2 = \u00df1.\u00df2 if and only if (\u00df1 = 0 or (\u00df1=a1 and a2=\u00df2)). \nin (5) does not involve any intersection). But the price to pay is a system that lacks naturalness (eg, \nthe wild-card pattern has different meanings according to whether it occurs in the right or in left type \nof a subtyping relation) and, even more, it lacks the generality of our approach (we did not state our \nsubtype system for any speci.c language while Vouillon s system is inherently tied to a particular language \nwhose semantics it completely relies on). The semantics of Vouillon s patterns is so different from ours \nthat typing Vouil\u00adlon s language with our types seems quite dif.cult.  Other works less related to ours \nare those in which XML and polymorphism are loosely coupled. This is the case of OCaml-Duce [9] where \nML-polymorphism and XML types and patterns are merged together without mixing: the main limitation of \nthis ap\u00adproach is that it does not allow parametric polymorphism for XML types, which is the whole point \nof our (and Vouillon s) work(s). A similar remark can be done for Xtatic [11] that merges C# name subtyping \nwith the XDuce set-theoretic subtyping and for XHaskell [17] whose main focus is to implement XML subtyping \nusing Haskell s type-classes. A more thorough comparison of these approaches can be found in [9, 15]. \nPolymorphism can be attained by adopting the so-called data\u00adbinding approach which consists in encoding \nXML types and val\u00adues into the structures of an existing polymorphic programming language. This is the \napproach followed by HaXML [23]. While the polymorphism is inherited from the target language, the rigid \nencoding of XML data into .xed structures loses all .exibility of the XML type equivalences so as, for \ninstance, (t\u00d7s1) . (t\u00d7s2) and (t\u00d7s1.s2) are different (and even unrelated) types. Our work already has \na follow-up. In a paper included in these same proceedings [14] Gesbert, Genev`es, and Laya\u00a8ida use the \nframework we de.ne here to give a different decision procedure for our subtyping relation. More precisely, \nthey take a speci.c model for the monomorphic type system (ie, the model de.ned by Frisch et al. [10] \nand used by the language CDuce), they encode the sub\u00adtyping relation induced by this model into a tree \nlogic, and use a sat\u00adis.ability solver to ef.ciently decide it. Next, they extend the type system with \ntype variables and they obtain a convex model by inter\u00adpreting non-empty types as in.nite sets using \na labeling technique similar to the one we outlined at the end of Section 2.5: they label values by (.nite \nsets of) type variables and every non empty ground type is, thus, interpreted as an in.nite set containing \nthe in.nitely many labelings of its values. Again the satis.ability solver provides a decision procedure \nfor the subtyping relation. Their technique is interesting in several respects. First it provides a very \nelegant so\u00adlution to the problem of deciding our subtyping relation, solution that is completely different \nfrom the one given here. Second, their technique shows that the decision problem is EXPTIME, (while here \nwe only prove the decidability of the problem by showing the termination of our algorithm). Finally, \ntheir logical encoding paves the way to extending types (and subtyping) with more expressive logical \nconstraints representable by their tree logic. In contrast, our algorithm is interesting for quite different \nreasons: .rst, it is de.ned for generic interpretations rather than for a .xed model; second, it shows \nhow convexity is used in practice (see in particular Step 6 of the algorithm); and, .nally, our algorithm \nis a straightforward modi.cation of the algorithm used in CDuce and, as such, can ben\u00ade.t of the technology \nand optimizations used there.7 We expect the integration of this subtyping relation in the CDuce to be \navailable in the near future. Finally, we signal the work on polymorphic iterators for XML presented \nin [4]. It introduces a very simple strongly normalizing calculus fashioned to de.ne tree iterators. \nThese iterators are lightly checked at the moment of their de.nition: the compiler does not complain \nunless they are irremediably .awed. This optimistic typ\u00ading, combined with the relatively limited expressive \npower of the calculus, makes it possible to type iterator applications in a very precise way (essentially, \nby performing an abstract execution of the iterator on the types) yielding a kind of polymorphism that \n7 Alain Frisch s PhD. thesis [8] describes two algorithms that improve over the simple saturation-based \nstrategy described in Section 3.4. They are used both in CDuce compiler and in the prototype we implemented \nto check the subtyping relation presented in this work. is out of reach of parametric or subtype polymorphism \n(for in\u00adstance it can precisely type the reverse function applied to hetero\u00adgeneous lists and thus deduce \nthat the application of reverse to a list of type, say, [ Int Bool* Char+ ] yields a result of type [ \nChar+ Bool* Int ]). As such it is orthogonal to the kind of polymorphism presented here, and both can \nand should coexist in a same language. 3. Formal development In this section we describe the technical \ndevelopment that supports the results we exposed in the previous section. We (strongly) sug\u00adgest readers \nto skip this section on .rst reading and directly jump to the conclusions in Section 4. For space reasons \nall proofs are omitted. They can be found in the extended version available from the .rst author s web \npage together with a link to the source code of our subtype checker prototype. The prose is reduced to \nthe strict necessary, and limited to explain points that were not dealt with in the previous section. \n3.1 Types De.nition 3.1. (Types) Consider a countable set of type variables V ranged over by a and a \n.nite set of basic (or constant) types ranged over by b.A type is a regular tree coinductively produced \nby the following grammar t ::= a | b | t \u00d7 t | t . t | t . t |\u00act | 0 and in which every in.nite branch \ncontains in.nitely many occur\u00adrences of atoms (ie, either a type variable or the immediate appli\u00adcation \nof a type constructor: basic, product, arrow) We write t1\\t2, t1.t2, and 1 respectively as abbreviation \nfor t1.\u00act2, \u00ac(\u00act1.\u00act2), and \u00ac0. The condition on in.nite branches bars out ill-formed types such as t \n= t . t (which does not carry any information about the set denoted by the type) or t = \u00act (which cannot \nrepresent any set). It also ensures that the binary relation c.T 2 de.ned by t1 . t2 c ti, \u00act c t is \nNoetherian (that is, strongly normalizing). This gives an induction principle on T that we will use without \nany further explicit reference to the relation. Notation. Let t be a type. We use var(t) to denote the \nset of type variables occurring in t and by tlv(t) (toplevel variables) all the variables of t that have \nat least one occurrence not under a constructor, that is: tlv(a)= {a}, tlv(\u00act)= tlv(t), tlv(t . s)= tlv(t) \n. tlv(s), and tlv(t)= \u00d8 otherwise. We say that t is ground or closed if and only if var(t) is empty. \n 3.2 Subtyping De.nition 3.2 (Set-Theoretic Interpretation). A set-theoretic in\u00adterpretation of T is \ngiven by a set D and a function [] : T. P(D)V . P(D) such that, for all t1,t2,t .T , a .V and . . P(D)V \n: [t1 . t2]. == D\\ [t]., [a]. = .(a), and [0]. = \u00d8. [t1]. . [t2]., [\u00act]. De.nition 3.3. (Subtyping Relation) \nLet [] : T. P(D)V . P(D) be a set-theoretic interpretation. We de.ne the subtyping relation =[1.T 2 as \nfollows: t = [1 s ... . P(D)V . [t]. . [s]. We write t = s when the interpretation [] is clear from the \ncontext. For each basic type b, we assume there is a .xed set of constants B(b) . C whose elements are \ncalled constants of type b. For two basic types b1, b2, the sets B(bi) can have a non-empty intersection. \nIf, as suggested in Section 2, we interpret extensionally an arrow t1.t2 as P([t1]\u00d7[t2]) (precisely as \nP(D2\\([t1]\u00d7(D\\[t2])))),  then every function type is a subtype of 1.1. We do not want such a property \nto hold because, otherwise, we could subsume every function to a function that accepts every value and, \ntherefore, every application of a well-typed function to a well-typed argument would be well-typed, independently \nfrom the types of the function and of the argument. For example, if, say, succ: Int.Int, then we could \ndeduce succ: 1.1 and then succ(true) would have type 1. To avoid this problem we introduce an explicit \ntype error O and use it to de.ne function spaces: De.nition 3.4. If D is a set and X, Y are subsets of \nD, we write DO for D + {O} and de.ne X . Y as: def X . Y = {f . D \u00d7 DO |.(d, dj) . f. d . X . dj . Y \n} This is used in the de.nition of the extensional interpretation: De.nition 3.5 (Extensional Interpretation). \nLet [] : T. P(D)V . P(D) be a set-theoretic interpretation. Its associated extensional interpretation \nis the unique function E() : T. P(D)V . P(ED) where ED = D+D2 +P(D\u00d7DO), de.ned as follows: E(a). = .(a) \n.D E(b). = B(b) .D E(t1 \u00d7 t2). = t1 . \u00d7 [t2]. .D2 E(t1 . t2). = [ t1] . . [t2]. . P(D\u00d7DO) E(0). = \u00d8 E(t1 \n. t2). = E(t1). . E(t2). E(\u00act). = ED\\ E(t). The de.nition of set-theoretic model is then as expected: \nDe.nition 3.6 (Foundation, Convexity, and Models). Let [] : T. P(D)V . P(D) be a set-theoretic interpretation. \nIt is 1. convex if it satis.es equation (8) for all .nite choices of types t1, ..., tn; 2. structural \nif D2 .D, [t1\u00d7t2].=[t1].\u00d7[t2]. and the relation on D induced by (d1,d2) . di is Noetherian; 3. a model \nif it induces the same subtyping relation as its associ\u00adated extensional interpretation, that is: .t \n.T . .. . P(D)V . [t].=\u00d8 .. E(t).=\u00d8. A model is convex if its set-theoretic interpretation is convex; \nit is well-founded if it induces the same subtyping relation as a structural set-theoretic interpretation. \n From now on we consider only well-founded convex models. We already explained the necessity of the \nnotion of convexity we introduced in \u00a72.5. The notion of well-founded model was introduced in \u00a74.3 of \n[10]. Intuitively, well-founded models are models that contain only values that are .nite (eg, in a well-founded \nmodel the type \u00b5x.(x\u00d7x) ie, the type that should contain all and only in.nite binary trees is empty). \nThis .ts the practical motivations of this paper, since XML documents ie, values are .nite trees.  3.3 \nProperties of the subtyping relation We write Afun for atoms of the form t1 . t2, Aprod for atoms of \nthe form t1 \u00d7 t2, Abasic for basic types, and A for Afun . Aprod . Abasic. Therefore V. A .{0, 1} denotes \nthe set of all atoms. Henceforth, we will disregard the atoms 0 and 1 since they can be straightforwardly \neliminated during the algorithmic treatment of subtyping. De.nition 3.7. (Normal Form) A (disjunctive) \nnormal form t is a .nite set of pairs of .nite sets of atoms, that is, an element of Pf (Pf (A .V) \u00d7 \nPf (A .V)) (where Pf (.) denotes the .nite powerset). Moreover, we call an element of Pf (A .V)\u00d7Pf (A \n. V) a single normal form. If [] : T. P(D)V . P(D) is an arbitrary set-theoretic interpretation, t a \nnormal form and . an assignment, we de.ne [t]. as: [\\ \\ [t ]. = [a]. n (D\\ [a].) (P,N).ta.Pa.N (with \nthe convention that an intersection over an empty set is taken to be D). For every type t there exists \na normal form N (t) that has the same interpretation, and vice versa. For instance, consider the type \nt = a1 . (a3 .\u00aca2) where a1, a2, and a3 are any atoms. Then N (t)= {({a1,a3}, \u00d8), ({a1}, {a2})}. This \ncorresponds to the fact that for every set-theoretic interpretation and semantic assignment N (t), t, \nand (a1.a3) . (a1.\u00aca2) have the same denotation. For these reasons henceforth we will often confound \nthe notions of types and normal forms, and often speak of the type t, taking the latter as a canonical \nrepresentation of all the types in N -1(t ). Let [] be a set-theoretic interpretation. Given a normal \nform t , we are interested in comparing the assertions ...P(D)V . E(t). = \u00d8 and ...P(D)V = \u00d8. Clearly, \nthe equation .. . . [t]. P(D)V . E(t). = \u00d8is equivalent to: \\[ .. . P(D)V . .(P, N) . t. E(a). . E(a). \n(14) a.Pa.N Let us write EbasicD = SD, EprodD = D2 and EfunD = P(D\u00d7DO). Then we have ED = EuD where U \n= {basic, prod, fun}. u.U Thus we can rewrite Inequality (14) as: .. . P(D)V . .u . U. .(P, N) . t. \\[ \n(15) (E(a). n EuD) . (E(a). n EuD) a.Pa.N For an atom a . A , we have E(a). n EuD = \u00d8 if a ./Au and E(a). \nn EuD = E(a). if a . Au. Then we can rewrite Inequality (15) as: .. . P(D)V . .u . U. .(P, N) . t. (P \n. Au .V) . \\\\ E(a). n (.(a) n EuD) . a.P nAu a.P nV (16) [[ E(a). . (.(a) n EuD) a.NnAu a.NnV (where \nthe intersection is taken to be ED when P = \u00d8). Further\u00admore, if the same variable occurs both in P and \nin N, then (16) is trivially satis.ed. So we can suppose that P nN nV = \u00d8. This jus\u00adti.es the simpli.cations \nmade in Step 3 of the subtyping algorithm, that is the simpli.cation of mixed single normal forms. Step \n4, the elimination of negated toplevel variables, is justi.ed by the following lemma: Lemma 3.8. Let \nP, N be two .nite subsets of atoms and a an arbitrary type variable, then we have \\[ .. . P(D)V . E(a). \n. E(a). . .(a) . a.Pa.N \\[ V E(. \u00ac\u00df E(. \u00ac\u00df .. . P(D). a (a)). n .(\u00df) . a (a)). a.Pa.N where \u00df is a fresh \nvariable and . \u00ac\u00df (a)= a{\u00ac\u00df/a} a Note that Lemma 3.8 only deals with one type variable, but it is trivial \nto generalize this lemma to multiple type variables (the same holds for Lemmas 3.9 and 3.10).  Using \nLemma 3.8, we can rewrite Inequality (16) as: Lemma 3.12. Let (D, [.]) be a convex set-theoretic interpretation \nV and P, N be two .nite subsets of Afun. Then: .. . P(D). .u . U. .(P, N) . t. (P . Au .V) . a.N a.NnAu \n[ \\ [ \\ \\ ... E(a). . E(a). . (17) E(a). n (.(a) n EuD) . E(a). a.P a.P nAu a.P nV 8 >>>>>< W t.s.P ; \nt)]. = \u00d8 since we can assume N nV = \u00d8. Next, we justify Step 5 of the algorithm, that is the elimination \n of the toplevel variables. In (17) this corresponds to eliminating .(t0.s0).N. .P j ...[t0 \\ ( . = P \nj 8 >< .P. P >: >>>>>: the variables in P nV. When u = basic this can be easily done . since all variables \n(which can appear only at top-level) can be V ...[( t.s.P \\P ; s) \\ s0]. = \u00d8 a.\u00d8 E(a). = EfunD) straightforwardly \nremoved. Indeed, notice that if s and t are closed types then s . a = t if and only if s = t. The justi.cation \nof Step 5 for u = prod is given by Lemma 3.9. T (with the convention  3.4 Algorithm Lemma 3.9. Let \n(D, [.]) be a well-founded model, P, N two .nite subsets of Aprod and a an arbitrary type variable. The \nformalization of the subtyping algorithm is done via notion a.N a.N [[ \\ of simulation that we borrow \nfrom [10] and extend to account V E(a). n (.(a) n Eprod . for type variables and type instantiation. \nWe use . to range over ...P(D) D) . E(a). . (syntactic) substitutions, that is, partial functions from \nV to T a.P \\ (we reserve the meta-variable s we introduced in Section 2 for E(.\u00d7 V . a (a)). n E(a1\u00d7a2). \n. E(.\u00d7 a (a)). ...P(D) ground substitutions). The application of a substitution to a type a.P is straightforwardly \nhomomorphically de.ned (notice that there is where .\u00d7 a (a)= a{(a1\u00d7a2).a/a} and a1, a2 are fresh variables. \nThe case for u = fun is trickier because 1 . 0 is contained in every arrow type, and therefore sets of \narrows that do not contain it must be explicitly checked. If, analogously to u = prod, we used just {(a1.a2) \n. a/a}, then the subtypes of 0 . 1 that do not contain 1 . 0 would never be assigned to a by the algorithm \nand, thus, never checked. Therefore, {((a1.a2) \\ (1 . 0)) . a/a}must be checked, as well. Lemma 3.10. \nno binder). This de.nition is naturally extended to normal forms by applying the substitution to each \ntype in the sets that form the normal form. It is then used to de.ne the set of instances of a type. \nDe.nition 3.13 (Instances). Given a type t .T , we de.ne [t] , the set of instances of t as: def [t] \n= {s |.. : V.T . t. = s} De.nition 3.14 (Simulation). Let S be an arbitrary set of normal forms. We de.ne \nanother set of normal forms ES as P,NnAu {t |.s.[t ] . .u.U. .(P, N).N (s). (P .Au . Cu )} [[ Let (D, \n[.]) be a well-founded model, P, N two .nite subsets of Afun and a an arbitrary type variable. Then a.N \na.N \\ where: V E(a). n (.(a) n Efun ...P(D). D) . E(a). . \\ P,N def = B(b) .B(b) C a.P basic b.P \\ V. \na (a)). n E(a1.a2). . . a (a)). ...P(D) E(.E(. . 8 >< V [V b.NnAbasic N ( t1 .\u00act1) . S t1\u00d7t2.Pt1\u00d7t2.N; \na.P \\ ; def = .N and ...P(D) V j P,N E(.a (a)). n E((a1.a2) \\ (1 . 0)). .N. . C. prod V V >: N ( t2 .\u00act2) \n. S t1\u00d7t2.Pt1\u00d7t2.N\\N; a.P [ a.N where a1, a2 are fresh variables, .. = a{(a1.a2) . a/a}, a (a) and .; \na (a)= a{((a1.a2) \\ (1 . 0)) . a/a}. ; a (a)). . E(. CP,N def fun = .t0 . s0 . N. .P j . P. 8 >>>>>< \nV N (t0 .\u00act) . S t.s.P ; 8 ><>>>>>: . = P j As an aside notice that both lemmas above would not hold \nif the variable a in their statements occurred negated at toplevel, whence the necessity of Step 4. P \n. V >: N ((\u00acs0) . t.s.P \\P ; s) . S Finally, Step 6 is justi.ed by the two following lemmas in whose \nproofs the hypothesis of convexity plays a crucial role: We say that S is a simulation if: [ \\ Lemma \n3.11. Let (D, [.]) be a convex set-theoretic interpretation and P, N two .nite subsets of Aprod. Then: \nS . ES a.N The notion of simulation is at the basis of our subtyping al\u00ad ... E(a). . E(a). . gorithm. \nIn what follows we show that simulations soundly and a.P completely characterize the set of empty types \nof a well-founded 8 >< V V convex model. More precisely, we show that every type in a simu\u00ad \u00act1]. = \n\u00d8 \u00act2]. = \u00d8 t1\u00d7t2.N\\N; ...[. t1 . t1\u00d7t2.N; lation is empty (soundness) and that the set of all empty \ntypes is a t1\u00d7t2.P .N j . N. simulation (completeness), actually, the largest simulation. V V >: t2 \n. t1\u00d7t2.P Lemma 3.15. Let [] : T. P(D)V . P(D) be a set-theoretic interpretation and t a type. If .. \n. P(D)V . = \u00d8, then .. : V.T . .. . P(D)V . [t.]. = \u00d8 [t]. T a.\u00d8 E(a). = EprodD). ...[ (with the convention \n Lemma 3.15 shows that if a type is empty, then all its syntac\u00adtic instances are empty. In particular \nif a type is empty we can rename all its type variables without changing any property. So when working \nwith empty types or, equivalently, with subtyping relations, types can be considered equivalent modulo \na-renaming (ie, the renaming of type variables). The .rst result we prove is that every simulation contains \nonly empty types. Theorem 3.16 (Soundness). Let [] : T. P(D)V . P(D) be a convex structural interpretation \nand S a simulation. Then for all t . S , we have .. . P(D)V . [t ]. = \u00d8 The intuition of the simulation \nis that if we consider the state\u00adments of Lemmas 3.11 and 3.12 as if they were rewriting rules (from \nright to left), then ES contains all the types that we can de\u00adduce to be empty in one step reduction \nwhen we suppose that the types in S are empty. A simulation is thus a set that is already saturated with \nrespect to such a rewriting. In particular, if we con\u00adsider the statements of Lemmas 3.11 and 3.12 as \ninference rules for determining when a type is equal to 0, then ES is the set of immediate consequences \nof S , and a simulation is a self-justifying set, that is a co-inductive proof of the fact that all its \nelements are equal to 0. Completeness derives straightforwardly from the construction of simulation and \nthe lemmas we proved about it. Theorem 3.17. Let [] : T. P(D)V . P(D) be a convex set-theoretic interpretation. \nWe de.ne a set of normal forms S by: def V S = {t |.. . P(D) . [t ]. = \u00d8} Then: ES = {t |.. . P(D)V . \nE(t ). = \u00d8} Corollary 3.18. Let [] : T. P(D)V . P(D) be a convex structural interpretation. De.ne as \nabove S = {t |.. . P(D)V . E(t). = \u00d8}. Then [] is a model if and only if S = ES . This corollary has \ntwo implications: .rst, that the condition for a set-theoretic interpretation to be a model depends only \non the subtyping relation it induces; second, that the simulation that contains all the empty types is \nthe largest simulation. In particular this second implication entails the following corollary. Corollary \n3.19 (Completeness). Let [] : T. P(D)V . P(D) be a well-formed convex model and s and t two types. Then \ns=t if and only if there exists a simulation S such that N (s.\u00act) . S . The corollary states that to \ncheck whether s=t we have to check whether there exists a simulation that contains the normal form, denoted \nby t0, of s.\u00act. Thus a simple subtyping algorithm is to use De.nition 3.14 as a set of saturation rules: \nwe start from t0 and try to saturate it. At each step of saturation we add just the normal forms in which \nwe eliminated top-level variables according to Lemmas 3.8, 3.9, and 3.10. Because of the presence of \nor in the de.nition, the algorithm follows different branches until it reaches a simulation (in which \ncase it stops with success) or it adds a non\u00adempty type (in which case the whole branch is abandoned). \nAll results we stated so far have never used the regularity of types. The theory holds also for non regular \ntypes and the algorithm described above is a sound and complete procedure to check their inclusion. The \nonly result that needs regularity is decidability.  3.5 Decidability As anticipated in the related work \nsection, the subtyping relation on polymorphic regular types is decidable in EXPTIME. We prove decidability \nbut the result on complexity is due to Gesbert et al. [14] who, as we already hinted, gave a linear encoding \nof the relation presented here in their variant of the \u00b5-calculus, for which they have an EXPTIME solver \n[13], thus obtaining a subtyping decision algorithm that is EXPTIME 8 (in doing so they also spotted \na subtle error in the original de.nition of our subtyping algorithm). To prove decidability we just prove \nthat our algorithm termi\u00adnates. We do so by .rst showing that it terminates on .nite trees (which is \nthe crux of the problem since the only potential source of loop are the substitutions of free variables \nperformed in Step 5) and then show that when we switch to regular trees the algorithm always ends up \non memoized terms (see the extended version).  3.6 Convex Models The last step of our development is \nto prove that there exists at least one set-theoretical model that is convex. From a practical point \nof view this step is not necessary since one can always take the work we did so far as a syntactic de.nition \nof the subtyping relation. However, the mathematical support makes our theory general and applicable \nto several different domains (eg, Gesbert et al s starting point and early attempts relied on this result), \nso .nding a model is not done just for the sake of the theory. As it turns out, there actu\u00adally exist \na lot of convex models since every model for ground types with in.nite denotations is convex. So to de.ne \na convex model it just suf.ces to take any model de.ned in [10] and straightforwardly modify the interpretation \nof basic and singleton types (more gener\u00adally, of all indivisible types9) so they have in.nite denotations. \nDe.nition 3.20 (In.nite support). A model (D, []) is with in.nite support if for every ground type t \nand assignment ., if [t]. = \u00d8, then [t]. is an in.nite set. What we want to prove then is the following \ntheorem. Theorem 3.21. Every well-founded model with in.nite support is convex. The proof of this theorem \nis quite technical it is the proof that required us most effort and proceeds in three logical steps. \nFirst, we prove that the theorem holds when all types at issue do not contain any product or arrow type. \nIn other words, we prove that equation (8) holds for [.] with in.nite support and where all ti s are \nBoolean combinations of type variables and basic types. This is the key step in which we use the hypothesis \nof in.nite support, since in the proof done by contradiction we need to pick an unbounded number of elements \nfrom our basic types in order to build a counterexample that proves the result. Second, we extend the \nprevious proof to any type ti that contains .nitely many applications of the product constructor. In \nother terms, we prove the result for any (possibly in.nite) type, provided that recursion traverses just \narrow types, but not product types. As in the .rst case, the proof builds some particular elements of \nthe domain. In the presence of type constructors the elements are built inductively. This is possible \nsince products are not recursive, while for arrows it is always possible to pick a fresh appropriate \nelement that resides in that arrow since every arrow type contains the (indivisible) closed type 1 . \n0. Third, and last, we use the previous result and the well-foundedness of the model to show that the \nresult holds for all types, that is, also for types in which recursion traverses a product type. More \nprecisely, we prove that if we assume that the result 8 This is also a lower bound for the complexity \nsince the subtyping prob\u00adlem for ground regular types (without arrows) is known to be EXPTIME\u00adcomplete. \n9 Our system has a very peculiar indivisible type: 1.0, the type of the functions that diverge on all \narguments. This can be handled by adding a .xed in.nite set of fresh elements of the domain to the interpretation \nof every arrow type (cf. the proof of Corollary 3.26 in the extended version).  does not hold for some \nin.nite product type then it is possible to build a .nite product type (actually, a .nite expansion of \nthe in.nite type) that disproves equation (8), contradicting what is stated in our second step. Well-foundedness \nof the model allows us to build this .nite type by induction on the elements denoted by the in.nite one. \nMore precisely, we proceed as follows. De.nition 3.22. We use T fp to denote the set of types with .nite \nproducts, that is, the set of all types in which every in.nite branch contains a .nite number of occurrences \nof the \u00d7 constructor. The .rst two steps of our proof are proved simultaneously in the following lemma. \nLemma 3.23. Let (D, []) be a model with in.nite support, and ti .T fp for i . [1..n]. Then ... t1 . = \n\u00d8. ... . [tn]. = \u00d8 . ... [ t1] . = \u00d8. ... .... [tn]. = \u00d8 Finally, it just remains to prove Theorem 3.21, \nthat is to say, that Lemma 3.23 above holds also for ti s with recursive products. This result requires \nthe following preliminary lemma. Lemma 3.24. Let [] be a well-founded model with in.nite support and \nt a type (which may thus contain in.nite product types). If there exists a value d and an assignment \n. such that d . [t]., then there exists a type tfp .T fp such that d . [tfp]. and for all assignment \n. if [t]. = \u00d8, then [tfp]. = \u00d8. While the statement of the previous lemma may, at .rst sight, seem obscure, \nits meaning is rather obvious. It states that in a well-founded model (ie, a model in which all the values \nare .nite) whenever a recursive (product) type contains some value, then we can .nd a .nite expansion \nof this type that contains the same value; furthermore, if the recursive type is empty in a given assignment, \nthen also its .nite expansion is empty in that assignment. This immediately yields our .nal result. Lemma \n3.25. Let (D, []) be a well-founded model with in.nite support, and ti for i . [1..n]. Then ... t1 . \n= \u00d8. ... . [tn]. = \u00d8 . ... [ t1] . = \u00d8. ... .... [tn]. = \u00d8 Corollary 3.26 (Convex model). There exists \na convex model. 4. Conclusion This work constitutes the .rst solution to the problem of de.ning a semantic \nsubtyping relation for a polymorphic extension of regu\u00adlar tree types. This problem, despite its important \npractical interest and potential fallouts, has been somehow neglected by most recent research since it \nwas considered untreatable or unfeasible. Our so\u00adlution not only has immediate application to the de.nition \nof pro\u00adgramming languages for XML, but also opens several new research directions that we brie.y discuss \nbelow. The .rst direction concerns the de.nition of extensions of the type system itself. Among the possible \nextensions the most inter\u00adesting (and dif.cult) one seems to be the extension of types with explicit \nsecond order quanti.cations. Currently, we consider prenex polymorphism, thus quanti.cation on types \nis performed only at meta-level. But since this work proved the feasibility of a semantic subtyping approach \nfor polymorphic types, we are eager to check whether it can be further extended to impredicative second \norder types, by adding explicit type quanti.cation. This would be in\u00adteresting not only from a programming \nlanguage perspective, but also from a logic viewpoint since it would remove some of the limitations to \nthe introspection capabilities we pointed out in Sec\u00adtion 2.7. This may move our type system closer to \nbeing an expres\u00adsive logic for subtyping. On the model side, it would be interesting to check whether \nthe in.nite support property (De.nition 3.20) is not only a suf.cient but also a necessary condition \nfor convexity. This seems likely to the extent that the result holds for the type sys\u00adtem restricted \nto basic type constructors (ie, without products and arrows). However, this is just a weak conjecture \nsince the proof of suf.ciency heavily relies (in the case for product types) on the well-foundedness \nproperty. Therefore, there may even exist non\u00adwell-founded models (non-well-founded models exist in the \nground case: see [8, 10]) that are with in.nite support but not convex. Nev\u00adertheless, an equivalent \ncharacterization of convexity whether it were in.nite support or some other characterization would pro\u00advide \nus a different angle of attack to study the connections between convexity and parametricity (see later \non). The second direction is to explore the de.nition of new lan\u00adguages to take advantage of the new \ncapabilities of our system. A .rst natural test will be to see how to add overloaded (typed by in\u00adtersection \ntypes) and higher-order (typed by arrow types) functions to the language de.ned in [15]. This already \nlooks as quite a chal\u00adlenging problem since it needs local type inference for both sub\u00adtyping and instantiation,10 \nand we are actively working on it. But the overall design space for a programming language that can ex\u00adploit \nthe advanced features of our types is rather large since a lot of possible variations can be considered \n(eg, the use of type variables in pattern matching) and even more features can be encoded (eg, as explained \nin Footnote 4, bounded quanti.cation can not only be encoded via intersection types but, thanks to them, \nalso made more general since intersections allow the programmer to specify bounds on a per-occurrence \nbasis). While exploring this design space it will be interesting to check whether our polymorphic union \ntypes can encode advanced type features such as polymorphic variants [12] and GADTs [24]. In our opinion, \nthe de.nition of convexity is the most impor\u00adtant and promising contribution of our work especially in \nview of its potential implications on the study of parametricity. As a mat\u00adter of fact, there are strong \nconnections between parametricity and convexity. We have already seen that convexity removes the stutter\u00ading \nbehavior that clashes with parametricity, as equation (5) clearly illustrates. More generally, both convexity \nand parametricity de\u00adscribe or enforce uniformity of behavior. Parametricity imposes to functions a uniform \nbehavior on parameters typed by type vari\u00adables, since the latter cannot be deconstructed. This allows \nWadler to deduce theorems for free : the uniformity imposed by para\u00admetricity (actually, imposed by the \nproperty of being de.nable in second order .-calculus) dramatically restricts the choice of pos\u00adsible \nbehaviors of parametric functions to a point that it is easy to deduce theorems about a function just \nby considering its type [22]. In a similar way convexity imposes a uniform behavior to the zeros of the \nsemantic interpretation, which is equivalent to imposing uni\u00adformity to the subtyping relation. An example \nof this uniformity is given by product types: in our framework a product (t1 \u00d7 ... \u00d7 tn) is empty (ie, \nit is empty for every possible assignment of its vari\u00adables) if and only if there exists a particular \nti that is empty (for 10 To have some .avor of the problem, consider an overloaded function even for \nthe domain 1 that when applied to an integer returns whether it is even or not, while it returns arguments \nof any other type unchanged. Its type is (Int . Bool) . (a\\Int . a\\Int). If we apply a curri.ed map :(\u00df \n. .) . \u00df*. .* to odd, then we want to deduce map(even): (Int*. Bool*) . ((a\\Int)*. (a\\Int)*) . ((a . \nInt)*. ((a\\Int) . Bool)*). That is, when we apply map(even) to a list of integers it returns a list of \nbooleans; when we apply it to a list that does not contain integers, then it returns a list of the same \ntype; when the list contains some integers (eg, a list of reals), then it replaces integer elements by \nboolean ones. This is not an instance of the output type of map.  all possible assignments). We recover \na property typical of closed types. We conjecture the connection to be much deeper than described above. \nThis can be clearly perceived by rereading the original Reynolds paper on parametricity [18] in the light \nof our results. Reynolds tries to characterize parametricity or abstraction in Reynolds terminology in \na set-theoretic setting since, in Reynolds words, if types denote speci.c subsets of a universe then \ntheir unions and intersections are well de.ned , which in Reynolds opin\u00adion is the very idea of abstraction. \nThis can be rephrased as the fact that the operations for some types are well de.ned independently from \nthe representation used for each type (Reynolds speaks of ab\u00adstraction and representation since he sees \nthe abstraction property as a result about change of representation). The underlying idea of parametricity \naccording to Reynolds is that meanings of an ex\u00adpression in related environments will be related [18]. \nBut as he points out few lines later while the relation for each type variable is arbitrary, the relation \nfor compound type expressions [ie, type constructors] must be induced in a speci.ed way. We must specify \nhow an assignment of relations to type variables is extended to type expressions [18]. Reynolds formalizes \nthis extension by de.ning a relation semantics for type constructors and, as Wadler bril\u00adliantly explains \n[22], this corresponds to regard types as relations. In particular pairs are related if their corresponding \ncomponents are related and functions are related if they take related arguments into related results: \nthere is a precise correspondence with the exten\u00adsional interpretation of type constructors we gave in \nDe.nition 3.5 and, more generally, between the framework used to state para\u00admetricity and the one in \nour work. Parametricity holds for terms written in the Girard/Reynolds second order typed lambda calculus \n(also known as pure polymor\u00adphic lambda calculus or System F). The property of being de.nable in the \nsecond-order typed lambda-calculus is the condition that har\u00adnesses expressions and forces them to behave \nuniformly. Convexity, instead, does not require any de.nability property. It semantically harnesses the \ndenotations of expressions and forces them to behave uniformly. Therefore all seems to suggest that convexity \nmay be a semantic characterization of what in Reynolds approach is the de.nability in the second-order \ntyped lambda-calculus, which is a syntactic property. Or, to put it otherwise, convexity states para\u00admetricity \nfor (or transposes it to) models rather than languages. Although we have this strong intuition about \nthe connection be\u00adtween convexity and parametricity, we do not know how to express this connection in \na formal way, yet. We believe that the answer may come from the study of the calculus associated to our \nsubtyp\u00ading relation. We do not speak here of some language that can take advantage of our subtyping relation \nand whose design space we dis\u00adcussed earlier in this conclusion. What we are speaking of is every calculus \nwhose model of values (ie, the model obtained by associ\u00adating each type to the set of values that have \nthat type) induces the same subtyping relation as the one devised here. Indeed, as para\u00admetricity leaves \nlittle freedom to the de.nition of transformations, so the semantic subtyping framework leaves little \nfreedom to the de.nition of a language whose model of values induces the same subtyping relation as the \nrelation used to type its values. If we could prove that every such language must automatically satisfy \nReynolds abstraction theorem (and, even more, prove also the converse), then we would have a formal and \nstrong connection between convexity and parametricity, the former being a purely semantic (in the sense \nthat it does not rely on any language or calculus) characterization of the latter. But this is a long \nterm and ambitious goal that goes well beyond the scope of the present work. Acknowledgments. We were \ngiven a decisive help by Nino Sal\u00adibra, who showed us how to prove that all powersets of in.nite sets \nare convex models of the propositional logic. Pietro Abate implemented an early version of our prototype \nsubtype checker. Bow-Yaw Wang drew our attention to the connection with con\u00advex theories. Claude Benzaken \npointed out several useful results in combinatorics to us. Nils Gesbert spotted a subtle mistake in our \nsubtyping algorithm. Many persons discussed the contents of this work with us and gave precious suggestions. \nAmong them we are particularly grateful to V\u00b4 eronique Benzaken, Mariangiola Dezani-Ciancaglini, Kim \nNguyen, Daniele Varacca, and Philip Wadler. References [1] V. Balat, J. Vouillon, and B. Yakobowski. \nExperience report: Ocsigen, a web programming framework. In ICFP 09. ACM Press, 2009. [2] V. Benzaken, \nG. Castagna, and A. Frisch. CDuce: an XML-friendly general purpose language. In ICFP 03. ACM Press, 2003. \n[3] G. Castagna, R. De Nicola, and D. Varacca. Semantic subtyping for the p-calculus. Theor. Comput. \nSci., 398(1-3):217 242, 2008. [4] G. Castagna and K. Nguyen. Typed iterators for XML. In ICFP 08, pages \n15 26. ACM Press, 2008. [5] J. Clark and M. Murata. Relax-NG, 2001. www.relaxng.org. [6] D. Draper et \nal. XQuery 1.0 and XPath 2.0 Formal Semantics, 2007. http://www.w3.org/TR/query-semantics/. [7] T. Berners-Lee \net al. Uniform Resource Identi.er, January 2005. RFC 3986, STD 66. [8] A. Frisch. Th\u00b4ealisation d un \nlangage de pro\u00ad eorie, conception et r\u00b4grammation fonctionnel adapt\u00b4e `a XML. PhD thesis, Universit\u00b4e \nParis 7, December 2004. [9] A. Frisch. OCaml + XDuce. In ICFP 06. ACM Press, 2006. [10] A. Frisch, G. \nCastagna, and V. Benzaken. Semantic subtyping: dealing set-theoretically with function, union, intersection, \nand negation types. The Journal of ACM, 55(4):1 64, 2008. [11] V. Gapeyev, M.Y. Levin, B.C. Pierce, and \nA. Schmitt. The Xtatic compiler and runtime system, 2005. http://www.cis.upenn.edu/ ~bcpierce/xtatic. \n[12] J. Garrigue. Programming with polymorphic variants. In Proc. of ML Workshop, 1998. [13] P. Genev`es, \nN. Laya\u00a8ida, and A. Schmitt. Ef.cient static analysis of XML paths and types. In PLDI 07. ACM Press, \n2007. [14] N. Gesbert, P. Geneves, and N. Laya`\u00a8ida. Parametric Polymorphism and Semantic Subtyping: \nthe Logical Connection. In ICFP 11, 2011. [15] H. Hosoya, A. Frisch, and G. Castagna. Parametric polymorphism \nfor XML. ACM TOPLAS, 32(1):1 56, 2009. [16] H. Hosoya and B. Pierce. XDuce: A statically typed XML processing \nlanguage. ACM TOIT, 3(2):117 148, 2003. [17] K. Zhuo Ming Lu and M. Sulzmann. An implementation of subtyping \namong regular expression types. In Proc. of APLAS 04, volume 3302 of LNCS, pages 57 73. Springer, 2004. \n[18] J.C. Reynolds. Types, abstraction and parametric polymorphism. In Information Processing, pages \n513 523. Elsevier, 1983. [19] J.C. Reynolds. Polymorphism is not set-theoretic. In Semantics of Data \nTypes, volume 173 of LNCS, pages 145 156. Springer, 1984. [20] J. Vouillon. Polymorphic regular tree \ntypes and patterns. In POPL 06, pages 103 114, 2006. [21] W3C. SOAP Version 1.2. http://www.w3.org/TR/soap. \n[22] P. Wadler. Theorems for free! In Functional Programming Languages and Computer Architecture, pages \n347 359. ACM Press, 1989. [23] C. Wallace and C. Runciman. Haskell and XML: Generic combinators or type \nbased translation? In ICFP 99, pages 148 159, 1999. [24] H. Xi, C. Chen, and G. Chen. Guarded recursive \ndatatype constructors. In POPL 03, pages 224 235. ACM Press, 2003.   \n\t\t\t", "proc_id": "2034773", "abstract": "<p>We define and study parametric polymorphism for a type system with recursive, product, union, intersection, negation, and function types. We first recall why the definition of such a system was considered hard \"when not impossible\" and then present the main ideas at the basis of our solution. In particular, we introduce the notion of \"convexity\" on which our solution is built up and discuss its connections with parametricity as defined by Reynolds to whose study our work sheds new light.</p>", "authors": [{"name": "Giuseppe Castagna", "author_profile_id": "81100388576", "affiliation": "Universit&#233; Paris Diderot, Sorbonne Paris Cit&#233;, Paris, France", "person_id": "P2801378", "email_address": "Giuseppe.Castagna@pps.jussieu.fr", "orcid_id": ""}, {"name": "Zhiwu Xu", "author_profile_id": "81488654364", "affiliation": "Universit&#233; Paris Diderot, Sorbonne Paris Cit&#233;, Paris, France &#38; Chinese Academy of Sciences, Beijing, China", "person_id": "P2801379", "email_address": "Zhiwu.Xu@pps.jussieu.fr", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034788", "year": "2011", "article_id": "2034788", "conference": "ICFP", "title": "Set-theoretic foundation of parametric polymorphism and subtyping", "url": "http://dl.acm.org/citation.cfm?id=2034788"}