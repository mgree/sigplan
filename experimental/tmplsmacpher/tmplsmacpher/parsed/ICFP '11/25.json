{"article_publication_date": "09-19-2011", "fulltext": "\n Secure Distributed Programming with Value-Dependent Types Nikhil Swamy1 Juan Chen1 edric Fournet1 Karthikeyan \nBhargavan3 Jean Yang4 C\u00b4Pierre-Yves Strub2 Microsoft Research1 MSR-INRIA2 INRIA3 MIT4 Abstract Distributed \napplications are dif.cult to program reliably and se\u00adcurely. Dependently typed functional languages promise \nto prevent broad classes of errors and vulnerabilities, and to enable program veri.cation to proceed \nside-by-side with development. However, as recursion, effects, and rich libraries are added, using types \nto reason about programs, speci.cations, and proofs becomes challenging. We present F*, a full-.edged \ndesign and implementation of a new dependently typed language for secure distributed program\u00adming. Unlike \nprior languages, F* provides arbitrary recursion while maintaining a logically consistent core; it enables \nmodular reason\u00ading about state and other effects using af.ne types; and it supports proofs of re.nement \nproperties using a mixture of cryptographic evidence and logical proof terms. The key mechanism is a \nnew kind system that tracks several sub-languages within F* and con\u00adtrols their interaction. F* subsumes \ntwo previous languages, F7 and Fine. We prove type soundness (with proofs mechanized in Coq) and logical \nconsistency for F*. We have implemented a compiler that translates F* to .NET bytecode, based on a prototype \nfor Fine. F* provides access to libraries for concurrency, networking, cryptography, and interop\u00aderability \nwith C#, F#, and the other .NET languages. The compiler produces veri.able binaries with 60% code size \noverhead for proofs and types, as much as a 45x improvement over the Fine compiler, while still enabling \nef.cient bytecode veri.cation. To date, we have programmed and veri.ed more than 20,000 lines of F* including \n(1) new schemes for multi-party sessions; (2) a zero-knowledge privacy-preserving payment protocol; (3) \na provenance-aware curated database; (4) a suite of 17 web-browser extensions veri.ed for authorization \nproperties; and (5) a cloud\u00adhosted multi-tier web application with a veri.ed reference monitor. Categories \nand Subject Descriptors D.3.1 [Formal De.nitions and Theory]: Syntax and Semantics General Terms Security, \nVeri.cation, Languages, Theory Keywords Security type systems, re.nement types 1. Introduction Distributed \napplications are dif.cult to program reliably and se\u00adcurely. To address this problem, researchers have \ndesigned new languages with security veri.cation in mind. Early work in this space developed ad hoc type \nsystems targeting veri.cation of spe\u00adci.c security idioms, including systems for information .ow con- \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n11, September 19 21, 2011, Tokyo, Japan. Copyright c &#38;#169; 2011 ACM 978-1-4503-0865-6/11/09. . . \n$10.00 trols, starting with Volpano et al. (1996); for proving authentication properties in cryptographic \nprotocols (Gordon and Jeffrey 2003); and, more recently, for protocols that use zero-knowledge proofs \n(Backes et al. 2008). More general type systems for security veri\u00ad.cation have also been proposed, e.g., \nFable (Swamy et al. 2008), F7 (Bengtson et al. 2008; Bhargavan et al. 2010), Aura (Jia and Zdancewic \n2009; Jia et al. 2008; Vaughan et al. 2008), Fine (Chen et al. 2010; Swamy et al. 2010), and PCML5 (Avijit \net al. 2010). All these languages use various forms of dependent types to rea\u00adson about security, following \na long tradition of dependent typing for general-purpose theorem proving and program veri.cation, e.g., \nCoq (Bertot and Cast\u00b4 eran 2004) and Agda (Norell 2007). Although these languages are successful in many \naspects, for large-scale distributed programming, we desire languages that (1) feature general programming \nconstructs like effects and re\u00adcursion, which, while invaluable for building real systems, make it hard \nto formally reason about programs, speci.cations, and proofs; (2) support various styles of proofs and \nevidence, ranging from cryptographic signatures to logical proof terms; (3) produce proofs that can be \nef.ciently communicated between agents in the system.  This paper presents F*, a full-.edged design \nand implementa\u00adtion of a new dependently-typed programming language that ad\u00addresses all these challenges. \nF* subsumes both F7 and Fine. Unlike prior languages, F* provides arbitrary recursion while maintain\u00ading \na logically consistent core, resolving the tension between pro\u00adgrammability and consistency by restricting \nthe use of recursion in speci.cations and proofs; it enables modular reasoning about state and other \neffects and allows specifying re.nement properties on af.ne values; it supports proofs of re.nement properties \nusing a mixture of cryptography and logical proof terms; and it allows se\u00adlective erasure and reconstruction \nof proofs to reduce the overhead of communicating proofs. By compiling to veri.able .NET bytecode, F* \nprovides access to libraries for concurrency, networking, cryptography, and interop\u00aderability with C#, \nF#, and other .NET languages. We have formal\u00adized the metatheory of F*, and mechanized a signi.cant part \nof the metatheory in Coq. We have developed a prototype compiler for F* (35,000 lines of F#), and used \nF* to program and verify more than 20,000 lines of code. We believe F* is the .rst language of its kind \nwith such a scale of implementation and evaluation. Next, we give an overview of F* and our main contributions. \nA novel kind system. A central feature of F* is its kind system, which tracks several sub-languages for \nterms, proofs, af.ne re\u00adsources, and speci.cations. This kind system controls the interac\u00adtion between \nthose, while still providing a single uni.ed language to specify, program, verify, and deploy secure \ndistributed systems. We use kinds * for program terms and P for proofs. Program terms that may be effectful \nand divergent reside in the universe of * types. Within *, P identi.es a universe of pure, total functions; \nP terms are used (mainly) in the construction of proof terms. Addi\u00adtionally, we use A, the kind of af.ne \n(used-at-most-once), stateful resources, to model and reason about effects in a modular style. Fi\u00adnally, \nthe kind E is for types that may have no inhabitants at all. We use E to control the selective erasure \nof proof terms, when these proofs are either impossible to construct in a distributed setting (e.g., \ndue to cryptography or due to the design of legacy libraries); when the presence of a proof term would \ncurtail expressiveness (e.g., when speaking of properties of af.ne values); or when proof terms would \nbe too voluminous to construct. As such, E identi.es a sub-language that plays a purely speci.cational \nrole. To improve code reuse, we provide a sub-kinding relation, P <: *<: E, with A unrelated to the others. \n Two .avors of re.nements. Re.nement types are commonly used to specify program properties. In contrast \nwith prior languages, F* features both concrete and ghost re.nements; \u00a72 illustrates the need for both \nfor secure distributed programming. To reason about the security of distributed applications, with minimal \ntrust between components, explicit proofs of security sometimes need to be communicated and checked at \nruntime. Concrete re.nements are pairs representing a value and a proof term serving as a logical evidence \nof the re.nement property, sim\u00adilar to those in Coq and Fine. One novelty of F* is that it assigns a \nspecial kind P for proof terms, and restricts types and proof terms in the P universe to guarantee logical \nconsistency. Ghost re.nements are used to state speci.cations for which proof terms are not maintained \nat run time. Ghost re.nements have the form x:t{f } where x is a value variable, t is a type, and f is \na logical formula, itself represented as a type that must have kind E and may depend on x and other in-scope \nvariables. Ghost re.nements are similar to those of F7; they are smoothly integrated in F* using the \nE kind. Ghost re.nements provide the following bene.ts: (1) they enable precise symbolic models for many \ncryptographic patterns and primitives, and evidence for ghost re.nement properties can be constructed \nand communicated using cryptographic constructions, such as digital signatures; (2) they bene.t from \na powerful subtyping relation: x:t{f } is a subtype of t; this structural subtyping is convenient to \nwrite and verify higher-order programs; (3) they provide precise speci.cation to legacy code without \nrequiring any modi.cations; and (4) when used in conjunction with concrete re.nements, they support selective \nerasure and dynamic reconstruction of evidence, enabling a variety of new applications and greatly reducing \nthe performance penalty for runtime proofs. Re.nements on af.ne state. Prior work has shown the useful\u00adness \nof af.ne types in reasoning about programs that use mutable state (Borgstrom et al. 2011; Lahiri et al. \n2011). Relying on its kind system, F* freely allows the use of af.ne values within its speci.ca\u00adtions \nfragment, while still guaranteeing that af.ne values are used at most once elsewhere in the code. In \n\u00a74, we exploit this feature ex\u00adtensively in implementing a new, .exible approach (Deni\u00b4elou and Yoshida \n2011) to enforce protocols on multi-party session types. Prior systems that integrate substructural and \ndependent types (e.g., Fine and Linear LF by Cervesato and Pfenning 2002) disallow re\u00ad.nements to speak \ndirectly about af.ne values, and have to rely instead on various encodings to work around this limitation, \nwhich is unsuitable for source programming. Automation and logic parametricity. Proof automation is critical \nfor developing large-scale programs. F* is carefully designed to be parametric in the logic used to describe \nprogramming proper\u00adties and their proofs. \u00a72.5 shows examples with a simple modal authorization logic \nand an ad hoc logic for database provenance. Logic parametricity enables working with custom authorization \nlogics and, importantly, makes it easy to integrate F* with SMT solvers for logics extended with speci.c \ntheories. Thus, program veri.cation in F* bene.ts from signi.cant automation our imple\u00admentation uses \nthe Z3 SMT solver (de Moura and Bj\u00f8rner 2008) and scales up to large programs and speci.cations. Languages \nlike Aura, PCML5, Coq, and Agda commit to a speci.c logic, limiting their .exibility. This limitation \nis signi.cant since diverse logics are used and even designed when reasoning about security policies \nand properties see Chapin et al. (2008) for a recent survey. Metatheory. We establish several properties \nof F*. First, we prove the soundness of F* in terms of progress and preservation. From this, we derive \na safety property for ghost re.nements called global deducibility. Next, we show that the P-fragment \nof F* is consistent by giving a typed embedding of this fragment into CiC and proving that the translation \nis a simulation. We also give a typed embedding of a core subset of RCF (the core calculus of F7) into \nF*. The subject reduction result (modulo the admission of a few standard lemma) has been mechanized in \nCoq we plan to continue to develop our Coq formalization to include the other results. Since our P-fragment \nis strongly normalizing, one might imag\u00adine extending F* to permit arbitrary P-terms to index types. \nHow\u00adever, term reduction in types, particularly with dynamic assump\u00adtions and af.nity, poses a signi.cant \nchallenge for the metathe\u00adory. We remain with value dependency in F*, while acknowledging that it is \nless expressive than having expressions in types. However, value dependency is a practical design choice \nthat has not hindered the construction and veri.cation of the programs we have built. Compiler implementation. \nWe have implemented a compiler for F* based on our prior work on a compiler for Fine. The F* com\u00adpiler \naccepts both Fine and F7 programs as input. To validate this feature, we typecheck and compile a large \nF7 library implementing symbolic cryptography (Bhargavan et al. 2010). Our compiler translates F* to \nRDCIL, a dependently typed di\u00adalect of .NET bytecode. This translation is considerably more ef.\u00adcient \nthan the one we used for Fine. Due to the use of ghost re.ne\u00adments and the availability of polymorphic \nkinds, bytecode emitted by the F* compiler is an order of magnitude (in some cases 45x) smaller than \nthe bytecode emitted by the Fine compiler. Experimental evaluation on a large suite of examples. We have \nimplemented several libraries and applications in F*, verifying a large corpus of code for various properties. \nProminent among our examples are (1) secure implementations of multi-party ses\u00adsions protocols; (2) a \nprototype of a new zero-knowledge privacy scheme; (3) a provenance-aware curated database; (4) a suite \nof 17 web-browser extensions veri.ed for authorization properties; and (5) an Azure-hosted multi-tier \nweb application with a reference monitor veri.ed for stateful authorization properties. Due to space \nconstraints, we leave the complete semantics of F*, manual proofs of the metatheory, and additional examples \nto a technical report, which, along with the compiler source code, the Coq development, and all our example \nprograms, can be found at http://research.microsoft.com/fstar. 2. F* by example This section introduces \nF* informally. The syntax of F* is based loosely on OCaml, F# and related languages in the ML family \nnotations speci.c to F* are primarily in support of its more expres\u00adsive type and kind language. The \ndynamic semantics is also in the spirit of ML, in call by value, but the static semantics is signi.\u00adcantly \nmore complex. The examples in this section, together with those in \u00a74, are intended to motivate and exercise \nits main features. We organize our presentation around the new kind system of F* . We start with simple \nprograms that use P-kind and F* s sub\u00adlanguage of total functions to construct proof terms for concrete \nre.nements. Next, we discuss E-kind and its use in two different scenarios with ghost re.nements .rst, \nwhen giving speci.cations to legacy libraries where the construction of explicit proof terms is impractical; \nand, second, when verifying implementations of cryptographic protocols, where the construction of proof \nterms is simply impossible. We then turn to A-kind, which, in conjunction with E-kind, can specify and \nverify properties of stateful compu\u00adtations. We conclude the section with an example that exploits the \ninteraction between P-kind and E-kind, via the sub-kinding rela\u00adtion P <: *<: E, to construct a model \nof a high-integrity database with precise data-provenance properties.  2.1 Concrete re.nement types \nand total proof terms Consider a partial speci.cation for a very simple program, tail, that returns the \ntail of a list: val tail: .a ::*. l1:list a .{l2:list a | .x. Mem x l2 =. Mem x l1} This type is polymorphic, \nof the form .a ::k. t where k is the kind of the abstracted type variable kinds are ascribed to types \nusing double colons. Here, a has kind *, the kind given to types that admit arbitrary recursion and effects, \ni.e., the standard kind of fully\u00adapplied types in an ML-like system. Following ML, by default we omit \nexplicit quanti.ers for prenex-quanti.ed type variables, and omit type applications when they can be \ndetermined by the context. The rest of the type of tail shows a dependent function, of the form x:t .t \nwhere the formal parameter x of type t is named, and is in scope in t . When the function is not dependent, \nwe simply write t .t . The range type of tail shows our syntax for concrete re.nements, {x:t | f }, where \nf is itself a type representing a logical formula, in which the name x is bound. Here, the formula states \nthat the tail l2 contains at most the elements of l1. Concrete re.nements and constructive proofs. Also \ncalled subset types or S-types (Sozeau 2007), concrete re.nements in F* are desugared into dependent \npairs (as is usual in, say, Coq). The type below shows this desugaring, where the type x:t * t denotes \na dependent pair, where x names the t-typed .rst component and is bound in t , the type of the second \ncomponent. val tail: l1:list a .(l2:list a * (x:a .Mem x l2 .Mem x l1)) When desugaring formulas, quanti.ers \nare desugared to dependent functions, and implications to non-dependent functions. The predi\u00adcate Mem \nx l2 is itself a type, which we show below. As such, con\u00adcrete re.nements are represented as pairs of \nthe underlying value, and a proof term witnessing the validity of the re.nement formula. A total sub-language \nfor proof terms. We must be careful when representing quanti.ers and implication with function arrows. \nFor logical consistency, we require the function arrows that represent the type of proof terms to be \ntotal, whereas arrows used in the rest of the program (where we certainly want to use arbitrary recursion) \ncan be partial. Thus, we need to ensure that potential divergence in the program never leaks into fragments \nof a program used for building proof terms. We achieve this by introducing a kind P,a subkind of * , \nwhere types residing in P are guaranteed to be total. Using P -kind, we de.ne Mem, an inductive type \nthat axioma\u00adtizes list membership in constructive style. Its kind is of the form a ::k . k , where a \nbinds a k-kinded formal type parameter in the kind k of the constructed type. Type constructors can also \nbe ap\u00adplied to values; such constructors have kinds of the form x:t . k where x names the formal argument, \na value of type t, and is in scope in k. Below, the kind of Mem says that it is a dependent type constructor \nthat constructs a type of kind P from a type a , a value x of type a , and a value l of type list a . \n(When x:a , we write Mem x l instead of Mem a xl.) type Mem :: a ::* . a . list a . P = | Mem hd : x:a \n.tl:list a .Mem x (Cons x tl) | Mem tl : x:a .y:a .tl:list a .Mem y tl .Mem y (Cons x tl) Inductive types \nde.ned in P-kind are required to be strictly positive, and we place other restrictions (\u00a73.2) on the \nelimination rules for P -kinded types to ensure totality. A function type x:t .t inherits the kind of \nits range type it has P kind and is a total function when t ::P. Theorem 2 (Logical consistency of P) \nprovides a well-typed embedding of terms residing in the P -fragment into CiC, ensuring that terms in \nthe P -fragment are valid proof terms. Non-constructive proofs, automation, and logic parametricity. \nProgramming explicitly with proof terms for non-trivial program properties quickly becomes impractical. \nThe F* implementation provides automation by calling Z3, an SMT solver, to try to decide re.nement properties, \nand then constructing proof terms from the deduction traces reported by Z3. However, since Z3 (and many \nother automated provers) use classical logics, the proof terms pro\u00adduced in this manner are not constructive. \nTo support non-constructive proof terms (and more generally, to permit custom logics), F* allows to de.ne \ncustom proof kernels. A speci.c proof kernel (the type pf below), is de.ned in the stan\u00addard library \nof F* and axiomatizes a classical logic, extended with axioms for commonly used data types such as list. \ntype pf :: P. P = | Exc middle: pf (Or a (Not a )) | Not elim: pf (Not a ) .pf a .pf \u00df | Not in nil: \nx:a .pf (Not (Mem x Nil)) | ... (* many constructors omitted *) | Unit pf: a .pf a | Bind pf: pf a .(a \n.pf \u00df ) .pf \u00df Each constructor in this kernel is an axiom in the logic, such as the excluded middle; \nintroduction and elimination forms for the stan\u00addard logical connectives (where Or, Not etc. are also \ntype construc\u00adtors); and axioms like Not in nil, which are necessary for reason\u00ading in a non-constructive \nsetting, where exhaustiveness arguments for inductive types are inapplicable. The pf kernel also includes \nconstructors Unit pf and Bind pf that allow proofs to be composed monadically. This is particularly useful \nsince F* is a call-by-value language Bind pf lets us compose proofs simply by constructor application, \nwithout triggering evaluation. Using this approach, F* translates the type of tail to the type be\u00adlow. \nRelying on automated proof extraction from Z3, programmers write the code shown below, and the F* compiler \ninlines the proof term and compiles (while carrying proofs) to RDCIL (\u00a75), our de\u00adpendently typed .NET \nbytecode. Concrete re.nements in this form are based on a similar construct in Fine. Through the use \nof P -kind (which Fine lacks), F* proof terms are logically consistent evidence of re.nement properties. \nval tail: l1:list a .(l2:list a * pf (x:a .pf (Mem x l2) .pf (Mem x l1))) let tail = function [] .[] \n| hd::tl .tl  2.2 Ghost re.nements for lightweight speci.cations Concrete re.nements have a long tradition \nand a well-understood theory. However, as discussed below, we .nd them inappropriate for use in some \nscenarios. As an alternative, F* also provides ghost re.nements, based on a construct of F7, and integrates \nthem with the other features of the system, notably higher kinding, quanti.ca\u00adtion over predicates, and \nre.nements for substructural state. We illustrate the use of ghost re.nements for the problem of verifying \nclients of libraries, where the libraries are authored sep\u00adarately and are unmodi.able. In recent work, \nGuha et al. (2011) consider programming secure web browser extensions using F* . For this scenario, we \nuse ghost re.nement types to specify pre-and post-conditions on the interface provided by the browser, \nand use the speci.cations to verify access control properties of extensions. The listing below illustrates \nthis approach on a tiny program \u00a75 reports new results for compiling a suite of 17 such extensions in \na type-preserving style to .NET bytecode. We aim to enforce a policy that untrusted extensions (line \n10) only read data from the header of a web page and not the body.  This policy is speci.ed using an \nassumption at line 8, which states, informally, that extensions hold the CanRead e privilege on DOM nodes \ne, for which the property EltTagName e \"head\" is derivable. Unlike the Mem predicate in \u00a72.1 (which has \nP kind), EltTagName and CanRead construct erasable, or E -kinded, types. Erasable types are generally \nuninhabited and have no constructors. Instead, we use them for speci.cations, as in the types of innerText \nand tagName. 1 (* Fragment of DOM API *) 2 type elt 3 type EltTagName :: elt . string . E 4 type CanRead \n:: elt . E 5 val innerText: e:elt{CanRead e} .string 6 val tagName: e:elt .t:string{EltTagName e t} 7 \n(* Extension policy *) 8 assume .e. EltTagName e \"head\" =. CanRead e 9 (* Extension code (untrusted) \n*) 10 let read e = if tagName e = \"head\" then innerText e else \"\" The type of innerText has the form \nx:t{f } .t , where the for\u00admula f is a ghost re.nement applied to the formal parameter x:t, and x is \nin scope in both f and t . The re.nement CanRead e is a pre-condition indicating that clients must hold \nthe CanRead e privi\u00adlege before calling the function. Analogously, the post-condition of tagName relates \nthe returned string t to the argument e, and clients may derive facts using this property and any other \nassumption (e.g., the policy assumption at line 8). For example, at the call to innerText in the then-branch \nat line 10, the F* checker (and Z3) uses the property that, for the value t returned by tagName e, we \nhave EltTagName e t from the post-condition; t=\"head\" from the equal\u00adity test; and using the policy assumption, \nwe can derive CanRead e, the pre-condition of innerText and authorize the call. Using this ap\u00adproach, \nonce type checked, untrusted extension code need not be examined only the policy (and the annotations \non the DOM API) are trusted. Two key properties of ghost re.nements make them well-suited for use in \nour scenario. We discuss these below. Ghost re.nements and erasure. The type x:t{f } is a subtype of \nt and the values of these two types have the same representation. This makes speci.cations using ghost \nre.nements lightweight, since they do not require modi.cations to underlying code and data. For example, \nwe did not need to modify or even wrap the DOM implementation in order to verify code in this style. \nFurthermore, the subtyping relation lifts naturally into the structure of function types, promoting reuse \nin higher order libraries. Semantics of ghost re.nement derivability. For every value v:t that inhabits \nx:t{f } our type system ensures that the formula f [v/x] is derivable. The de.nition of derivability \nis subtle and is made pre\u00ad cise in \u00a73. However, intuitively, derivability is a logical entailment relation \nde.ned relative to a context of dynamic assumptions A . We think of A as a monotonically increasing log \nof events and for\u00ad mulas that are assumed during evaluation of the program. Formally, a call to tagName \ne reduces to t and has the effect of adding the for\u00ad mula EltTagName e t to the log. For values given \nghost re.nement types, there may be no concrete proof at run time to witness the derivability of the \nre.nement formula. Indeed, when working with libraries like the DOM, explicit proof terms witnessing \nDOM in\u00ad variants seem both infeasible and undesirable (as they may be very voluminous); ghost re.nements \n.t the bill nicely. Proof-irrelevance and P vs. E-kind. The distinction between P and E-kinds in F* may, \nat .rst, seem reminiscent of the distinc\u00adtion between Type and Prop in a system like Coq. The proof terms \nfor concrete re.nements in Coq are often from the Prop universe, indicating that they are computationally \nirrelevant (and so can be erased during code extraction). In contrast, concrete re.nements in F* are \naccompanied by P-kinded proof terms, which are compu\u00adtationally relevant. We view proofs as useful runtime \nentities that carry important information. We choose to make proofs explicit and useful \u00a72.5 demonstrates \na novel way of using concrete proof terms to construct precise provenance trails in a curated database. \nAs such P-kind is closer to Coq s Type. Indeed, our embedding of F* s P fragment in CiC translates P-kinded \ntypes to types that reside in Coq s Type universe. E-kind in F* plays a role more similar to proof irrelevance \nin Coq. However, the semantics of E-kinded types and ghost re.ne\u00adments is considerably different. Not \nonly are proofs for ghost re\u00ad.nements irrelevant, these proofs may not be constructible at all and E-kinded \ntypes may be uninhabited. Instead, the log-based se\u00admantics of ghost re.nements makes trust assumptions \nin external code formal and explicit, and allows the de.nition of security prop\u00aderties for code that \nare robust even when code is composed with arbitrary attacker code. For example, Guha et al. (2011) used \nthe log-based semantics to prove a robust safety property that ensures that veri.ed extensions are authorization-safe \neven when composed with arbitrary untrusted JavaScript on a web page.  2.3 Ghost re.nements and indexed \ntypes for cryptography Re.nement types (in the style of ghost re.nements) have been used in F7 to verify \nimplementations of cryptographic protocols. This section presents a small fragment of a library for public \nkey cryptography implemented in a new style (see our website for a more complete library together with \nseveral client programs that use cryptography). This style is enabled by features of F* not available \nin F7, speci.cally, the integration of re.nements with higher-kinded and indexed types. This example \nalso illustrates the need for ghost re.nements. As we will see, it is infeasible to construct concrete \nproof terms (whether constructive or not) to justify the soundness of cryptographic evidence. The listing \nbelow shows the signature of a module Crypto that provides an interface to work with public key signatures. \nInfor\u00admally, signatures provide a means for a party in a protocol to com\u00admunicate a value and a property \nof its local environment to a re\u00admote party. For example, Alice can sign a message m and send it to Bob, \nand, if Bob trusts Alice, Bob can conclude that the message originated with Alice. Additionally, given \na prior agreement on the usage of keys, Alice can convince Bob of some additional property Pred of the \nmessage m, e.g., that the message originated in Alice s .le system. The property Pred need not be an \nintrinsic property of the contents of m a constructive proof of Pred m in this setting may be nonsensical. \nmodule Crypto type dsig = bytes (* type of digital signatures *) type prin (* name of a principal *) \ntype sk :: prin . a ::* . (a . E ) . * val rsa sign : .a ::* , \u00df ::a . E . p:prin .sk p a\u00df .x:a {\u00df x} \n.dsig type pk :: prin . a ::* . (a . E ) . * type Says :: prin . E . E val rsa verify : .a ::*,\u00df ::a \n. E . p:prin .pk p a\u00df .x:a .dsig .r:bool{r=true =. Says p (\u00df x)} Crypto provides a type dsig for digital \nsignatures, here just an alias for bytes. It also exposes an abstract type prin for principal identi.ers, \nand the type constructors sk and pk are for secret keys and public keys respectively. A private key of \ntype sk Alice a Pred belongs to the principal Alice:prin, who can use it to sign values m of type a that \nsatisfy Pred m. The function rsa sign allows clients to construct a dsig value by signing a message x:a \n, where the ghost re.nement guarantees that the formula \u00df x is derivable when rsa sign is called. Public \nkeys are complementary: rsa verify veri.es a signature using the public key pk p a\u00df and, if it succeeds, \nthe caller knows that Says p (\u00df x) is derivable. The predicate Says p f is the usual lifting of a proposition \nf into a modality Says, similar to forms used in a variety of modal authorization logics (Chapin et al. \n2008). Intuitively, Says p f is weaker than f , and the two coincide when principal p is trusted.  As \nin F7, an abstract implementation of the Crypto library can be veri.ed against the speci.cation shown \nabove, and can be proved correct with respect to a Dolev-Yao adversary. However, in F7, types cannot \nbe parametrized by predicates, so predicate parame\u00adters are instead simulated through a level of indirection. \nInstead of the F* type sk p a Pred, private keys in F7 are given a type of the form sk p a usage, and \nthe predicate Pred is replaced by a global predicate SignSays, indexed by p and usage. Veri.cation relies \non a programming convention that each key usage must be unambiguously de.ned by recording an assumption \nof the form .p,usage,v, SignSays p usage v .. Pred v. This convention is not enforced automatically in \nF7, and hence this style can lead to logi\u00adcal inconsistencies. In contrast, F* types are more concise, \nand re\u00adquire fewer dynamic assumptions and no programming discipline beyond typing.  2.4 Ghost re.nements \nand af.ne-indexed types for state F* is designed to enable reasoning about effectful programs, whether \nthe effects be in the form of non-termination, state, or I/O. We have seen how P-kind serves to control \nnon-termination and we consider I/O in \u00a74. This section looks at how F* uses af.ne types, in combination \nwith E-kinded types, to reason about state. One innovation of F* is that it permits indexing types with \naf.ne values, allowing properties to be stated about af.ne values without having them be consumed immediately. \nWe illustrate this feature by showing how to program with linear maps, a data type pro\u00adposed by Lahiri \net al. (2011) to verify heap-manipulating programs. For space reasons, we do not show a client program \nusing linear maps a complete example is available in the F* distribution. Linear maps are a data structure \nthat equips a Floyd-Hoare logic (using a classical assertion logic) with a form of local reasoning in \nthe style of separation logic. Instead of modeling the heap of a program as a single monolithic map H:map \na\u00df from a -typed locations to \u00df -typed values, the linear maps methodology advocates partitioning the \nheap H into several fragments H1, ..., Hn where the Hi have disjoint domains. Each Hi is a linear map \nof type lin a\u00df , and the disjoint domain condition ensures that modi.cations to Hi leave all the other \nHj unmodi.ed. This allows to formulate a kind of frame rule for programs that use linear maps. Since \nthe assertion logic remains classical, linear map programs can be automatically veri.ed using classical \nprovers and SMT solvers. type lin :: *. * . A type Select :: a ::* . \u00df ::* . lin a\u00df . a . \u00df . E type \nUpdate :: a ::* . \u00df ::* . lin a\u00df . a . \u00df . lin a\u00df . E type InDomain :: a ::* . \u00df ::* . a . lin a\u00df . E \nThe listing above de.nes an abstract type of linear maps and several predicates to model their properties. \nThe kind of lin:: *. * . A introduces the fourth base kind in F*: the kind A of af.ne types. To enforce \nthe disjoint domains invariant on linear maps, Lahiri et al. require that linear maps be neither copied \nnor aliased. This corresponds directly to the use of af.nity in F*: values of af.ne type can be used \nat most once. The types Select and Update correspond to standard predicates implemented by SMT solvers \nlike Z3: Select l x y states that the map l at the location x contains the value y; Update l x y m states \nthat m is like the map l, except at the location x where it contains the value y. We omit the standard \naxiomatization of these predicates. Linear maps are partial maps and include a domain. The predicate \nInDomain x l has the obvious meaning. Two operations to read and write locations in maps are shown below. \n(Other operations are omitted). The read function reads a location x out of a map m1 (when InDomain x \nm1), and returns the value y:\u00df stored at x. Since m1 is af.ne, read threads m1 back to the caller as \nm2, where the re.nement on m2 shows that it is un\u00adchanged. The write function is similar, and in both \ncases the Select and Update predicates specify the appropriate post-conditions. val read: x:a .m1:lin \na\u00df {InDomain x m1} .(y:\u00df * (m2:lin a\u00df {m1=m2 &#38;&#38; Select m1 x y})) val write: x:a .y:\u00df .m1:lin \na\u00df {InDomain x m1} .(m2:lin a\u00df {Update m1 x y m2}) Predicates on af.ne values. While seemingly unremarkable, \nby re.ning af.ne values, the types shown above are a signi.cant ad\u00advance over prior languages that have \nincluded substructural and dependent types. For example, in systems like Fine and Linear LF (Cervesato \nand Pfenning 2002), types are required to be free of af.ne (or linear) indices, i.e., type constructors \nof kind t . k, where t::A are forbidden. There are several reasons for this restric\u00adtion in prior systems. \nMost prominently, expressing properties of af.ne values using concrete re.nements requires constructing \nproof terms where, simply by using an af.ne resource in a proof term, the resource is consumed. While \nthere are ways to work around this re\u00adstriction (Borgstrom et al. 2011), they involve relatively complex \nwhole-program transformations. A key innovation of F* is to use the E -kind to allow stating properties \non af.ne values directly. Speci.cally, since E -kinded predicates have no runtime signi.cance, indexing \nthese predicates with af.ne values does not consume them in F*, kinds of the form t . E are permitted, \neven when t::A. In our example, we use af.ne indexes on E -kinded types to state pre-and post-conditions \nusing ghost re.nements. However, when modeling linear maps programs, the dynamic log of assumptions (unlike \nwhen modeling DOM programs and cryptography) is constant, so F* s metatheory guarantees that re.nement \nformulas in pre-and post-conditions are derivable from the axiomatization of linear maps alone. We defer \nfurther discussion of af.ne indexed types until \u00a74, where we use af.ne indexes with higher-rank E -kinded \ntypes to model concurrent, message passing programs.  2.5 Selective erasure using concrete and ghost \nre.nements The preceding discussion of ghost re.nements may lead the reader to believe that they are \nalways to be preferred to re.nements with concrete proof terms. This section illustrates that concrete \nproof terms are useful too, particularly when one is allowed to compute over these terms, to store them, \nand to communicate them over the network. The example discussed here is an excerpt from a larger program \nthat models a database of scienti.c experiments, where each record contains a proof term indicating the \nprovenance of the experiment and its validity , according to some custom notion of validity. The full \nexample brings together several elements, includ\u00ading the use of cryptography with a simple modal logic \nto authen\u00adticate experimental observations. For brevity, we focus just on one aspect: selective erasure \nand reconstruction of proofs, which may be implemented for both ef.ciency and con.dentiality reasons. \nEach experiment record in our database is given the type exp b (for some boolean parameter b, explained \nshortly). The record con\u00adtains an optional primary key .eld xid; a .eld r:expsetup that de.nes what ingredients \nwere used in the experiment; and, importantly, a proof term of type proof b (Valid r), where the proof \nterm contains evidence recording the relationship of this experiment to other ex\u00adperiments in the database, \ni.e., the proof term re.ects the prove\u00adnance of the experiment. type expsetup = list {reagent:string; \nquantity:int} type Valid :: expsetup . E type exp (b:bool)=(xid:option int * r:expsetup * proof b (Valid \nr)) The type proof b t represents a value from a proof kernel de.n\u00ading a custom logic tailored to this \nspeci.c application another ex\u00adample of F* s logic parametricity. We show a selection of the con\u00adstructors \nfrom this kernel below.  let full, partial = true, false type proof :: bool . E . P= | AndIntro: ... \n| AndElim1 : ... | ... | ChemicalVolcano: proof full (Valid[{reagent=\"(NH4)2Cr2O7\"; ...}]) | Combine: \nr1:expsetup .r2:expsetup .r3:expsetup .b:bool .proof b (And (Union r1 r2 r3)(And (Valid r1)(Valid r2))) \n.proof b (Valid r3) | Prune: r:expsetup{Valid r} .xid:int .proof partial (Valid r) The interplay between \nghost and concrete proof terms is central in this example it enables proof terms to be selectively erased \nand later reconstructed. This allows us to maintain compact, yet detailed and reliable provenance trails. \nThe type proof full (Valid r) represents a fully explicated proof of Valid r, with no selective erasure \napplied. In contrast, values of type proof partial (Valid r) may have been partially erased these values \nare not guaranteed to carry a complete provenance for the experiment setup r. The constructors in the \nkernel include axioms for basic connec\u00adtives and axioms like ChemicalVolcano which state validity of \nsome well-known experiments. Axioms like Combine allow new valid ex\u00adperiments to be constructed from \nother valid ones. The most inter\u00adesting constructor is Prune, which allows a ghost re.nement of the validity \nof an experiment (r:expsetup{Valid r}) to be traded for a concrete proof term for the validity. To allow \nproofs to be recon\u00adstructed, Prune takes an extra argument, xid:int, the primary key of a record in the \ndatabase that holds the complete provenance for r. Now we can give a typed interface to our database \n(below). The database db is simply a list of experiments with full proofs. It supports operations to \ninsert new experiments (returning an auto\u00adgenerated private key); to lookup using the primary keys; and \nto look up just the provenance trail of a particular experiment setup, using a primary key for the experiment. \ntype db = list (exp full) val insert: exp full .int val lookup: xid .option (exp full) val lookupProof: \nr:expsetup .xid:int .option (proof full (Valid r)) We implement a client-facing interface to the database \nthat wraps the basic lookup and insert operations. On outbound request, we lookup an experiment by its \nprimary key. But, rather than com\u00admunicate a (potentially large) proof term with explicit provenance \nto the requestor, we erase the proof (using Prune) and send only a partial proof to the caller, recording \nthe primary key xid in the proof term for later reconstruction. In our full implementation, rather than \nsimply sending a Prune node, we send an authenticated proof term, signed under a key for the database, \nso that the requestor can con\u00adclude that the returned experiment is indeed valid. (* Erasing outbound \nproofs *) assume .(b:bool)(r:expsetup)(pf:proof b (Valid r)). b=full =. Valid r let readExp xid : option \n(exp partial)= match lookup xid with | Some (xid, r, pf) .Some (xid, r, Prune r xid) | None .None To \nuse the Prune constructor, we have to prove that r has the type r:expsetup{Valid r}. Although pf is full \nproof of Valid r, we cannot use pf directly to derive ghost re.nement formulas. To connect con\u00adcrete \nand ghost re.nements, we introduce the assumption above. Given the soundness of the proof kernel, this \nassumption is admis\u00adsible, and the type of Prune ensures that the database program never introduces partial \nproofs for experiments that do not have a valid provenance trail. Despite the fact that the Valid r type \nhas no inhab\u00aditants, the introduction of this assumption does not lead to logical inconsistency. Formally, \nassumptions are simply recorded as effects in the log, and do not produce values that can be destructed, \nsay, via pattern matching. Finally, on requests to insert new records in the database, we can reconstruct \nproofs. The function expand below traverses the structure of a proof tree, and expands Prune nodes by \nlooking them up in the database. The database maintains an invariant that each record in the database \nhas a full proof and thus a fully explicated provenance trail, ensured via type soundness. (* Reconstructing \nproof terms on inbound requests *) let rec expand (c:bool)(pf:proof c a ): option (proof full a )= if \nc=full then Some pf else match pf with | Prune r xid .lookupProof r xid | AndElim1 c1 pf .(match expand \nc1 pf with | Some pf .Some (AndElim1 full pf ) | .None) | ... (* Inserting a new record in the DB *) \nlet insertExp (r:expsetup)(c:bool)(pf: proof c (Valid r)) = match (expand c pf) with | Some pf .Some \n(insert (None, r, pf )) | .None The function expand is, in effect, a partial, effectful proof-search \nprocedure. Despite the use of non-termination and effects, the type system guarantees that if this function \nterminates and returns Some pf, then pf is indeed a valid full proof in the P-fragment, F* s logically \nconsistent fragment of total functions. 3. Formalizing F* This section presents the syntax and the semantics \nof F*. We focus on .ve main themes: (1) the strati.cation into expressions, types and kinds with the \nability to describe functional dependences at each level; (2) the use of kinds to isolate sub-languages \nfor proofs, speci.cations, and af.nity; (3) relating logical effects described us\u00ading ghost re.nements \nto propositions witnessed by proof terms; (4) logic parametricity, allowing us to plug-in proof kernels \nand au\u00adtomated decision procedures for the logics they de.ne; and (5) the consistency of a core universe \nof propositions, via strong normal\u00adization, and the ability to program over its values, to support appli\u00adcations \nwith mobile proofs and selective erasure. 3.1 Syntax The syntax of F* is shown below. Values include \nvariables, lambda abstractions over values and types, and fully applied n-ary data con\u00adstructors. The \nvalue ve is a technical device used to prove the sound\u00adness of af.ne typing e is an identi.er drawn from \na class of names distinct from term and type names. We use the notation a to stand for a .nite sequence \nof elements a1,...,an, for arbitrary n; (a)k is a sequence a1,...,ak-1. We adopt a (partially) let-normalized \nview of the expression language e, in particular requiring function argu\u00adments to always be values this \nis convenient when using value\u00addependent types, since it ensures that expressions never escape into the \nlevel of types. The only other non-standard expression form is assume f , which has the effect of adding \na formula to the log and is explained in \u00a73.3. Types are ranged over by meta-variables t and f we use \nf for types that stand for logical formulas. Types include vari\u00adables a, constants T , dependent functions \nranging over values whose domain may be values (x:t . t') or types (.a::..t, writ\u00adten a::k -> t in the \nconcrete syntax), types applied to values (tv) and to types (tt'), type-level functions from values to \ntypes (. x:t.t', concretely written fun (x:t) -> t ), ghost re.nements x:t{f }, and .nally coercions \nto af.ne types \u00a1t. This modal oper\u00adator serves to qualify the type of a closure that captures an af.ne \nassumption; we include \u00a1t in the formalism to avoid duplicating  Syntax: expressions, types, kinds, \nsignatures, environments v ::= x | . x:t.e | .a::..e | Dt\u00af v\u00af| ve values ' e ::= v | ev | et | assume \nf | let x = e in e terms ' | match x with D a\u00afx\u00af. e else e f ,t ::= a | T | x:t . t '|.a::..t | tv | \ntt ' types | . x:t.t '| x:t{f}| \u00a1t c ::= * | P | A concrete kinds b ::= c | E base kinds ' . ::= b | \nx:t . . | a::. . .kinds S ::= \u00b7| T ::.{D:t}| S, S' signature G ::= \u00b7| x:t | a::. | v1 = v2 | t1 = t2 \n| G,G' type env. ' A ::= \u00b7| f | e | e | A ,A dynamic log the rules for function arrows, but concretely \nwe write af.ne func\u00adtions as x:t >> t and a::k >> t instead of \u00a1(x:t . t ') and \u00a1(.a::..t). Kinds . include \nthe four base kinds *, P, A, and E we distin\u00adguish the .rst three of these as concrete kinds, since they \nclassify inhabitable types. As at the type level, we have kinds for dependent function spaces whose range \nare types and whose domain may be either values (x:t . .) or types (a::. . .'). Stratifying the lan\u00adguage \ninto terms, types, and kinds allows us to place key restric\u00adtions (discussed below) that facilitate automated \nveri.cation, and to compile ef.ciently to .NET. However, strati.cation does come at a cost several pieces \nof technical machinery are replicated across the levels. Signatures S are .nite lists of inductively \nde.ned types. Each inductive de.nition T ::.{D:t} introduces a type constructor T of kind . and all its \nconstructors D1:t1, ..., Dn:tn. For simplicity, we do not include mutually inductive types, although \nthese are sup\u00adported by our implementation and their addition to the formalism poses no signi.cant dif.culties. \nWe do not need a .xpoint form in the expression language since inductive types allow us to en\u00adcode recursive \nfunctions. To show that terms given P-kinded types are strongly normalizing, a well-formedness condition \non signa\u00adtures imposes a positivity constraint on inductive de.nitions for P\u00adkinded types. An additional \nconstraint on signatures is that they must contain a declaration unit:: * {():unit} for the unit type \nand its one value (). Finally, typing environments G track in-scope value variables (x with type t), \ntype variables (a with kind .), and equiv\u00adalences between values (v1 = v2) and types (t1 = t2) introduced \nwhen checking match expressions. We discuss the log A in con\u00adjunction with the dynamic semantics in \u00a73.3. \nBrie.y, A maintains a set of facts introduced by the dynamic assumption of ghost re\u00ad.nements, and also \na set of names e used to track af.ne values.  3.2 The F* type system Figure 1 shows key rules from each \njudgment in the type system. Well-formedness of kinds. The judgment S; Gf . ok(b) states that . is well-formed \nand produces types of base kind b (when . = b) or type constructors for b-kinded types. The rule (OK-TK) \nshows a key enhancement of F* over prior languages, e.g., Fine or Linear LF. Types can be constructed \nfrom af.ne values (b1 = A), so long as the type constructed is purely speci.cational (b2 = E). As illus\u00adtrated \nin \u00a72.4 and \u00a74, this improves the expressiveness of af.ne typ\u00ading signi.cantly, enabling re.nements on \naf.ne state. (OK-KK) is also an enhancement over Fine to allow dependences and to ensure that types parameterized \nby af.ne types are themselves af.ne. Al\u00adthough our formalism allows higher-kinds like (* . *) . *, such \nkinds cannot be compiled to the type system of the .NET bytecode language and are currently rejected \nby our compiler. However, re\u00ad targeting F* to a platform with a more .exible typing discipline would \nlift this restriction. Kinding for value-indexed and af.ne types. The judgment S;G f t :: . states that \ntype t has kind .. The rules shown here reveal a few subtle aspects of the type system, starting with \naf.ne typing and af.ne-value indexing. The rule (K-A) shows how the modal operator coerces the kind of \na type. (K-Tv) allows a type function t to be applied to a value v; these type functions are introduced \neither using (K-Fun) or as type constructors T in the signature. Next, recall that we wish to allow af.ne \nvalues to be freely used at the type level, since speci.cations should not consume af.ne resources. For \nthis reason, unlike prior languages, the values passed to type functions may use af.ne assumptions in \nthe context G the restrictions imposed by (OK-TK) ensure that such uses of af.ne assumptions at the type \nlevel cannot in.uence term-level reduction. The second premise of (K-Tv) uses the expression typing judgment, \ndiscussed shortly. This judgment has two modes (m ::= \u00b7| e) indicated on the turnstile. When the mode \nis e (indicating that the term being typed occurs at the type-level, effectively as an index of an E-kinded \ntype), af.ne assumptions in the context can be freely duplicated without resulting in their consumption. \nWe discuss how this works shortly, in the context of the (T-X) rule. Ghost re.nements, total functions, \nand sub-kinding. (K-f) re\u00adquires that formulas in ghost re.nements be erasable (E-kinded). Formulas in \nghost re.nements are erased at runtime and re.ne\u00adments apply only to types given concrete kinds c (the \n.rst premise of (K-f)), i.e., inhabitable types. (K-Arr) handles dependent func\u00adtion arrows, which (as \nseen in \u00a72.1) can be used to represent both quanti.ed formulas in the logic as well as term-level func\u00adtion \nabstractions. A function arrow is P-kinded if its range type is P-kinded. Finally, (K-Sub) uses a sub-kinding \njudgment in its premise. Sub-kinding in F* is de.ned by the judgment S;G f .1 <: .2. Sub-kinding is based \non the relation P <: *<: E, among base kinds, with A <: A only. These base relations are lifted into \nthe structure of arrow kinds, with co-and contravariance as usual. (K-Sub) includes premises to ensure \nthat sub-kinding preserves well\u00adformedness of kinds. We conjecture that these premises can be eliminated \nin favor of lemmas establishing that sub-kinding never introduces ill-formed kinds. We have yet to prove \nit, so we include these premises to facilitate our formal proof of well-formedness of kinds produced \nby derivations. Expression typing. The judgment S; G; X fme : t states that expres\u00adsion e has type t, \nunder signature S, environment G, and an af.ne environment X ::= \u00b7| e | x | X,X', where X,X' denotes \ndisjoint union of sets of names. A well-formedness condition on contexts requires all variables x . X \nto also be bound in G. The context X represents a set of available af.ne assumptions, and usual context \nsplitting rules apply to X when typing the sub-terms of an expression. (As in Fine, we choose not to \nsplit G itself, since this complicates well\u00adformedness of contexts in the presence of dependent types.) \nFinally, as mentioned above, expression typing comes in two modes, indi\u00adcated on the turnstile. Af.ne \ntyping in two modes. (T-XA) is typical of af.ne typing sys\u00adtems. To use an af.ne assumption x, we require \nx to be present in the af.ne environment X. In addition, (T-X) provides two excep\u00adtions to (T-XA): .rst, \nas is standard, we can use non-af.ne assump\u00adtions without requiring them to be present in X. Second, \nwhen the mode is e, we are typing a term at the level of types; since this does not consume the af.ne \nresource, we are free to use it even when X is empty. (T-WknX) provides weakening for the af.ne context. \nFinally, (T-Abs) is a standard rule with one subtlety that the in\u00adtroduced function type is tagged with \nthe af.ne modality (using Q(X,x:t . t ')) if the function closure captures an af.ne assump\u00adtion. ((T-e) \nis also related to af.ne typing, but, values ve are used solely to state our type soundness result we \ndiscuss this rule in conjunction with the dynamic semantics.) Ghost re.nements and subtyping. The rules \n(T-As), (T-V), and the subtyping judgments introduce ghost re.nement types. (T-As) in\u00ad  b2 = E if b1 \n= Ab2 .{A,E} if b1 = A S;G f t::b1 S; G, x:t f . ok(b2) S; G f .1 ok(b1) S;G,a::.1 f .2 ok(b2) S;G f \n. ok(b) OK-b OK-TK OK-KK S; G f b ok(b) S; G f x:t . . ok(b2) S;G f a::.1 . .2 ok(b2) S; G f t :: * \nS;G f t :: (x:t '. .) S; G; . fe v : t ' S;G f t :: bS;G,x:t f t ' :: .S;G f t :: . K-A K-Tv K-Fun S;G \nf \u00a1t :: AS;G f tv :: .[v/x] S; G f . x:t.t ' :: x:t . . S; G f t :: cS;G,x:t f t ' :: c ' S;G f t :: \n. S; G f . <: .' S; G f t :: cS;G,x:t f f :: Eb = P if c ' = P and * o.w. S;G f . ok(b) S;G f .' ok(b) \n K-f K-Arr K-Sub S; G f x:t{f} :: cS;G f x:t . t ' :: bS;G f t :: .' S;G f . = .' SK-Re. SK-PStar SK-StarES;G \nf .1 <: .2 ' S;G f . <: .S;G f P <: * S;G f *<: E ' ' S;G f t ' <: tS;G,x:t 'f . <: .' S;G f .1 ' <: \n.1 S;G,a::.1 'f .2 <: .S;G f . <: .1 S;G f .1 <: . 2 SK-Prod SK-ProdK SK-Trans '' S;G f (x:t . .) <: \n(x:t '. .') S; G f (a::.1 . .2) <: (a::.1 '. .2) S;G f . <: .' ' S;G f t = t ' S;G,x:t f . = .S;G f \n.1 = .S; G, a::.1 f .2 = .' 12 S;G f . = .' KE-Re. KE-Prod KE-ProdK '' S;G f . = . S;G f x:t . . = \nx:t '. .S;G f a::.1 . .2 = a::.1 . .' 2 S; G f G(x)::bS; G f t::c S;G f G(x) :: Am = e if b = AS; G;X \nfme : tS;G,x:t;X,x fme : t ' S;G;X fme : t T-XA T-X T-WknX T-Abs S;G;x f x : G(x) S; G; . fmx : G(x) \nS;G;X,X'fme : tS; G; X fm .x:t.e : Q(X,x:t . t ') S;G;X fmv : tS;G f t :: cS;G;X1 fme1: t1 S; G, x:t1;X2,x \nfme2: t2 S;G f f :: Et = x:unit{f} S;G, x:t,x = v |= f S;G,x:t f f :: E .i.S;G f ti :: .i .2 = P . .1 \n= P T-As T-V T-Let S;G;\u00b7fm assume f : tS;G; X fmv : x:t{f} S; G;X1,X2 fm let x = e1 in e2: t2 S;G;X1 \nfmv : tv S;G f tv :: .v G' = G, a::., x:t f S;G'wf S; G';\u00afx fmD a\u00afx\u00af: tp FV (tv,tp)= \u00df\u00af, y\u00aftv. = tp.. \n=[t\u00af/\u00df\u00af,v\u00af/y\u00af] S; G' ,\u00df = t,y = v,v = D a\u00afx\u00af; X2, x\u00affme1: tS;G;X2 fme2: tS; G f t :: .b .b = P . .v = \nP T-Match S; G; X1,X2 fm match v with D a\u00afx\u00af. e1 else e2: t = e . X' = e v : tQ(\u00b7,t) m S;G;X fmS;G;X \nf e : t ' S; G f t ' <: tS;G f t ' :: cS; G f t :: c = t T-e T-Sub where \u00a1t S;G;X,X'fmve : tS;G;X f e \n: tQ(X,t)= ' S;G f t = t ' S; G f t <: t ' S;G,x:t |= fS;G f t1 ' <: t1 S;G,x:t1 'f t2 <: t ' 2 S;G f \nt <: t ' S-Re. S-fI S-fE S-Arr S;G f t <: t ' S;G f t <: x:t '{f'} S; G f x:t{f} <: tS; G f x:t1 . t2 \n<: x:t1 '. t ' 2 t1 = t2 . G v1 = v2 . G S;G f v = v ' S;G f t = t ' EQ-T EQ-V EQ-\u00df EQ-VApp1 S;G f \nv = v ' S;G f t1 = t2 S;G f v1 = v2 S;G f (.x:t.t ')v = t '[v/x] S;G f tv = tv ' S;\u00b7f . ok(c) .i.S,T \n::.{}; (a::.)i f .i ok(bi) . j.S,T ::.{};a:.,(x:t) j f tj :: cj (c ' = A . c = A) t ' S,T ::.{};a:.,x:t \nf T \u00afv\u00af' :: c . j.apos(c, T,tj::cj ) c = P ..1 = i < n.T . FTC(ti) f S ok WFS-D S f T ::.{D:.a::..x:t \n. Tt\u00af' v\u00af'} ok apos(c, T, ((x : t1 . ... . tn)::c ')) Figure 1. Selected static semantics of F* troduces \na unit re.ned with the assumed formula f no logical evidence is produced for f . To justify this rule, \nthe dynamic seman\u00adtics of this expression adds a formula to the dynamic log A . (T-V) allows value v \nto be re.ned with the formula f when f is deriv\u00adable: S;G'|= f. The context G' includes bindings x:t,x \n= v which allow the derivability relation to use information about v; however, for kind-correctness, \nwe require the kinding of the introduced for\u00admula to not rely on the introduced equality. Ghost re.nements \nhave no impact on the representation of values, so they admit structural subtyping. The subtyping rules \ninclude (S-fI), like (T-V), an in\u00adtroduction form for ghost re.nements and (S-fE), an elimination form. \n(S-Arr) lifts the relation into the structure of function types omitted rules do the same for other constructions. \nIn contrast, con\u00adcrete re.nements (i.e., the dependent pairs of Coq, Fine etc.) do not enjoy this structural \nsubtyping relation. Instead, via a systematic translation to insert coercions (called dere.nement) inherited \nfrom Fine, F* provides programmers with a weaker, non-structural sub\u00adtyping relation on concrete re.nements. \nSubtyping also includes type conversion, an equivalence relation according to the judgment S;G f t1 = \nt2. This relation, discussed brie.y in conjunction with (T-Match), converts types using equations that \nappear in the con\u00adtext, and is available everywhere within the structure of types. Logic parametricity \nis embodied by (T-V) and (S-f I): various def\u00adinitions of the derivability relation (S;G |= f ) can be \nplugged in to the type system, as long as the relation meets a few important admissibility constraints. \nAdmissible relations must at least be the identity on re.ned assumptions (S;x : (x:t{f }) |= f); be closed \nun\u00adder substitution of free variables in G; be allowed to use structural rules such as weakening, duplication \nand permutation; and be in\u00adsensitive to the presence of derivable equality assumptions in the context \n(S;G,v = v |= f .. S;G |= f). Pragmatically, we often plug in a decision procedure for .rst order logic \nwith additional theories, as implemented by the Z3 theorem prover the ability to use structural rules \n(e.g., weakening) in the logic, enabled by our re\u00adstrictions on the use of af.ne indices in types, makes \nit easy to sup\u00adport automation. Formally, we also exploit logic parametricity to provide an embedding \nof F7 s formal core, RCF, into F*, plugging into (T-V) RCF s entailment relation (which, unlike F*, includes \nthe basic .rst-order connectives and equality, each satisfying their usual introduction and elimination \nforms).  Consistency of the P-universe requires placing restrictions in var\u00adious parts of the type system. \nFor an expression e to reside in P, e must be free of non-P expressions, since those may diverge the \nlast premise of (T-Let) enforces this property. We disallow discriminating on values that reside in * \nor A when construct\u00ading propositions in the branches of a match the last premise of (T-Match) shows this. \nWe also have constraints on the well\u00adformedness of inductive type T (recall that we use (a::.)i to mean \na1::.1,...,ai-1::.i-1). In (WFS-D), the .rst premise ensures that the kind . of T is well-formed; the \nsecond and third premises en\u00adsure that the arguments of D are well-formed; the fourth premise ensures \nthat the constructed type matches the kind expected for T ; and the .nal premise imposes two key restrictions: \n(1) construc\u00adtors with af.ne arguments must construct af.ne results this is unrelated to totality of \nP-functions; (2) a positivity constraint on inductive P-kinded types. We use a relatively simple version \nof positivity, excluding the constructed type T in negative position in any argument of D. These constraints \nare similar to those imposed by Aura on its Prop universe to our knowledge, Aura is the only other language \nthat embeds a strongly normalizing core within a language with ar\u00adbitrary recursion. However, there are \nseveral important differences. First, Aura (like Coq) insists on Prop terms being computationally irrelevant, \nso its match rule forbids cross-universe elimination Prop terms cannot be eliminated to construct values \nin Type. We explicitly wish to program over proofs, so F* permits P-to-* elimi\u00adnation. Next, Aura does \nnot allow the branches of a match expres\u00adsion to use equality assumptions between the pattern and the \nscru\u00adtinized term. This makes it impossible to program on proof terms, as shown in \u00a72.5, which make essential \nuse of GADT-style pro\u00adgramming patterns. In contrast, (T-Match) checks the then-branch e1 in a context \nthat includes equality assumptions induced by uni\u00adfying the type of the pattern with the type of the \nscrutinee (the .rst three premises on the second line). These equality assumptions are used in S;G f \nt = t ' to allow typing derivations to freely re.ne both type and value indices within types. This feature \ncomplicates the consistency proof of F* s P-fragment. We discuss this aspect when presenting the metatheory \nof F* .  3.3 Dynamic semantics: logical effects and af.ne names The dynamic semantics of F* is a small-step \nreduction relation for a call-by-value language. It has the form (A ;e) .S (A ;e ') where the signature \nS is unvarying. The interesting part of this relation is the log A , a non-decreasing set of logical \nfacts f and names e for af.ne values. As mentioned in \u00a72.2, the set of facts in A is used in the de.nition \nof ghost re.nement derivability. Facts are added to the log using the assume f form, which reduces as \nbelow. E-Log (A ;assume f) .S (A ,f;()) Foreshadowing our safety condition for ghost re.nements (Corollary \n1), we show that, when a well-typed program e : x:t{f}reduces to a value, that is (\u00b7; e) .* (A ;v), its \nre.nement formula f s is derivable from the signature and all the accumulated logical ef\u00adfects: S; Facts(A \n) |= f[v/x]. This is in contrast to our soundness result for proof terms, expressions that reside in \nthe P-fragment, for which we obtain a more traditional logical consistency property. In a distributed \nprogram, the log is an idealized global view of the logical state of all participants. Ghost re.nements \naccompanied by cryptographic evidence (in the form of digital signatures) enable speaking about this \ndistributed state. The log also tracks af.ne values. We aim to show that well\u00adtyped programs destruct \naf.ne values at most once. For this pur\u00adpose, we instrument the dynamic semantics to tag an af.ne value \nv with a fresh name when it is introduced, recording the name in the log (E-Newe). Names held in the \nlog come in two variants: names e are live , while names e are dead . When v appears in a destruct position \n(the context E in (E-Kille), which includes the function position of a \u00df redex, and the scrutinee position \nof a match), we require the name e to be live in the log for reduction to not get stuck, kill the name \nin A , and then proceed. This instrumentation serves as our speci.cation of the use-at-most-once property. \nS;Facts(A ) f t :: A fresh e S; Facts(A );LiveNames(A ) f v : t E-Newe (A ;v) .S (A ,e;ve) E-Kille (A1,e,A2; \nE[ve]) .s (A1,e, A2; E[v])  3.4 Metatheory of F* Our .rst theorem is a type soundness result, stated \nin terms of standard progress and preservation lemmas. In addition to well\u00adtyped programs not getting \nstuck, this result ensures that af.nely typed values are destructed at most once, and can thus be soundly \nimplemented using destructive reads and mutation. (The theorem relies on an auxiliary judgment S f A \n=. G; X which obtains a context G; X from the dynamic log, where G includes the logical assumptions accumulated \nin A , and live names in A recorded in X.) THEOREM 1 (Type soundness). For all S, A , G, X, X', e, and \nt such that (1) S f A =. G;X, (2) f S;G;X wf, and (3) S; G;X'f e : t where X'. X, '' ''  either e \nis a value, or there exist A ,e , G', and Xsuch that '' (1) S f A ' =. G' ;X, (2) X'' =(X'\\ DeadNames(A \n')) . LiveNames(A '\\ A ), (3) .G'' .G' = G, G'', and '' f e (4) S; G' ;X' : t. From type soundness, we \nobtain our main safety property for ghost re.nements: their formulas are derivable from the logical effects \naccumulated in the log. COROLLARY 1 (Safety for ghost re.nements). For all S, A , G, e, ' f, t, A , G', \nand v such that f S ok, S f A =. G;X, S;G;X f e : x:t{f }, and (A ;e) .* S (A ' ;v), there exists G' \nsuch that S f A . ' =G' ; and S;G'|= f[v/x]. Theorem 2 (Logical consistency of P) shows logical consistency \nof the P-fragment, by translating P-terms into CiC (The Coq De\u00advelopment Team 2010), which is widely \nbelieved to be strongly normalizing. Intuitively, the theorem states that the translation of F* s P-fragment \ninto CiC is a (weak) simulation, with regard to F* and CiC s reduction relations. Since in CiC, all reduction \nsequences are presumed to be .nite, this guarantees the absence of in.nite re\u00adduction sequences for F* \ns P-terms. A direct proof of strong nor\u00admalization of F* s P-fragment is likely to be challenging since \nit involves inductive types like CiC. Our proof strategy borrows ideas from a proof of a related property \nin Aura. However, unlike Aura, F* supports implicit type conversions using equalities introduced by pattern \nmatching we .nd this essential for programming over proof terms. We translate this to CiC through the \nuse of explicit, equality-witnessing conversions in CiC. \n\t\t\t", "proc_id": "2034773", "abstract": "<p>Distributed applications are difficult to program reliably and securely. Dependently typed functional languages promise to prevent broad classes of errors and vulnerabilities, and to enable program verification to proceed side-by-side with development. However, as recursion, effects, and rich libraries are added, using types to reason about programs, specifications, and proofs becomes challenging.</p> <p>We present F*, a full-fledged design and implementation of a new dependently typed language for secure distributed programming. Unlike prior languages, F* provides arbitrary recursion while maintaining a logically consistent core; it enables modular reasoning about state and other effects using affine types; and it supports proofs of refinement properties using a mixture of cryptographic evidence and logical proof terms. The key mechanism is a new kind system that tracks several sub-languages within F* and controls their interaction. F* subsumes two previous languages, F7 and Fine. We prove type soundness (with proofs mechanized in Coq) and logical consistency for F*.</p> <p>We have implemented a compiler that translates F* to .NET bytecode, based on a prototype for Fine. F* provides access to libraries for concurrency, networking, cryptography, and interoperability with C#, F#, and the other .NET languages. The compiler produces verifiable binaries with 60% code size overhead for proofs and types, as much as a 45x improvement over the Fine compiler, while still enabling efficient bytecode verification.</p> <p>To date, we have programmed and verified more than 20,000 lines of F* including (1) new schemes for multi-party sessions; (2) a zero-knowledge privacy-preserving payment protocol; (3) a provenance-aware curated database; (4) a suite of 17 web-browser extensions verified for authorization properties; and (5) a cloud-hosted multi-tier web application with a verified reference monitor.</p>", "authors": [{"name": "Nikhil Swamy", "author_profile_id": "81342513197", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2801418", "email_address": "nswamy@microsoft.com", "orcid_id": ""}, {"name": "Juan Chen", "author_profile_id": "81100119052", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2801419", "email_address": "juanchen@microsoft.com", "orcid_id": ""}, {"name": "C&#233;dric Fournet", "author_profile_id": "81100547450", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P2801420", "email_address": "fournet@microsoft.com", "orcid_id": ""}, {"name": "Pierre-Yves Strub", "author_profile_id": "81488661455", "affiliation": "INRIA-Microsoft Research Joint Centre, Orsay, France", "person_id": "P2801421", "email_address": "pierre-yves.strub@inria.fr", "orcid_id": ""}, {"name": "Karthikeyan Bhargavan", "author_profile_id": "81100070918", "affiliation": "INRIA, Paris, France", "person_id": "P2801422", "email_address": "karthikeyan.bhargavan@inria.fr", "orcid_id": ""}, {"name": "Jean Yang", "author_profile_id": "81464641126", "affiliation": "Massachusettes Institute of Technology, Cambridge, MA, USA", "person_id": "P2801423", "email_address": "jeanyang@csail.mit.edu", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034811", "year": "2011", "article_id": "2034811", "conference": "ICFP", "title": "Secure distributed programming with value-dependent types", "url": "http://dl.acm.org/citation.cfm?id=2034811"}