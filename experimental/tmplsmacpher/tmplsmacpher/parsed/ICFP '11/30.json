{"article_publication_date": "09-19-2011", "fulltext": "\n Binders Unbound Stephanie Weirich Brent A. Yorgey Tim Sheard University of Pennsylvania Portland State \nUniversity {sweirich,byorgey}@cis.upenn.edu sheard@cs.pdx.edu Abstract Implementors of compilers, program \nrefactorers, theorem provers, proof checkers, and other systems that manipulate syntax know that dealing \nwith name binding is dif.cult to do well. Operations such as a-equivalence and capture-avoiding substitution \nseem simple, yet subtle bugs often go undetected. Furthermore, their implementa\u00adtions are tedious, requiring \nboilerplate code that must be updated whenever the object language de.nition changes. Many researchers \nhave therefore sought to specify binding syn\u00adtax declaratively, so that tools can correctly handle the \ndetails be\u00adhind the scenes. This idea has been the inspiration for many new systems (such as Beluga, \nDelphin, FreshML, FreshOCaml, Caml, FreshLib, and Ott) but there is still room for improvement in ex\u00adpressivity, \nsimplicity and convenience. In this paper, we present a new domain-speci.c language, UN-BOUND, for specifying \nbinding structure. Our language is particu\u00adlarly expressive it supports multiple atom types, pattern \nbinders, type annotations, recursive binders, and nested binding (necessary for telescopes, a feature \nfound in dependently-typed languages). However, our speci.cation language is also simple, consisting \nof just .ve basic combinators. We provide a formal semantics for this language derived from a locally \nnameless representation and prove that it satis.es a number of desirable properties. We also present \nan implementation of our binding speci.cation language as a GHC Haskell library implementing an embedded \ndo\u00admain speci.c language (EDSL). By using Haskell type constructors to represent binding combinators, \nwe implement the EDSL suc\u00adcinctly using datatype-generic programming. Our implementation supports a number \nof features necessary for practical programming, including .exibility in the treatment of user-de.ned \ntypes, best\u00adeffort name preservation (for error messages), and integration with Haskell s monad transformer \nlibrary. Categories and Subject Descriptors D.2.3 [Coding Tools and Techniques]; D.1.1 [Applicative (Functional) \nProgramming]; E.1 [Data Structures] General Terms Algorithms, Languages. Keywords generic programming, \nHaskell, name binding, patterns Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 11, September 19 21, 2011, Tokyo, Japan. Copyright &#38;#169; 2011 \nACM 978-1-4503-0865-6/11/09. . . $10.00 1. Introduction Name binding is one of the most annoying parts \nof language imple\u00admentations. Although functional programming languages such as Haskell and ML excel \nat the implementation of type checkers, com\u00adpilers, and interpreters, there is an impedance mismatch \nbetween the free structure provided by algebraic datatypes and the syntax identi.ed up to a-equivalence \nthat we actually want to model. Al\u00adthough there are many techniques for implementing name binding, they \nrequire subtle invariants that pervade the system. Implemen\u00adtation .aws cause bugs that are dif.cult \nto track down. Further\u00admore, the implementations themselves are tedious, requiring boiler\u00adplate that \nmust be maintained as the implemented language evolves. While such boilerplate is straightforward, it \ncauses friction for de\u00advelopers who just want to get the job done. And all this work is for something \nso obvious that it is often elided from language de.nitions! There has been much research towards solving \nthis problem. Recently introduced languages and tools provide primitive support for variable-binding, \nbased on .rst-order [6, 21, 30, 31] and higher\u00adorder representations [18, 20]. These tools handle the \ndetails behind the scenes, relieving programmers of the tedium and subtle bugs de\u00adscribed above. However, \nthese tools must also satisfy the practical needs of programmers, and here they fall short: Expressiveness: \nThese tools provide binding speci.cation lan\u00adguages that specify what variables are bound where. As unary \nlex\u00adical scoping (binding a single variable in a single location) is not suf.cient for many applications, \nmany of these tools support a lan\u00adguage for patterns in binding speci.cations. Despite this .exibility, \nit is still not enough there are patterns that we would like to use that cannot be de.ned by existing \nspeci.cation languages. Availability: Programmers want to write code in their language, and they want \nto do it directly. Tools that are wrappers for existing languages are preferred to completely new systems, \nbut such tools still require update with each new version of the language. Libraries are more stable \nand have the added bene.t of simple distribution, some degree of portability and familiar syntax. Choice \nof implementations: These tools each provide only one implementation for any given binding speci.cation. \nHow\u00adever, name binding involves a number of different operations and some implementations may favor one \nover the other. Programmers should be able to swap out implementations (or write their own) if they .nd \none that works better with their application. In this paper, we present a new domain-speci.c language, \nUN-BOUND, for specifying binding structure that addresses these is\u00adsues. Concretely, our contributions \nare as follows: We describe a small, compositional set of abstract combinators which form the entire \nbasis for UNBOUND. This interface suc\u00adcinctly characterizes our speci.cation language.  We show, via \nexamples (\u00a7 2, \u00a7 3), that UNBOUND is nonethe\u00adless expressive. In particular, it supports multiple atom \ntypes,   pattern binders, type annotations, recursive binders, and nested binders. The last are necessary \nto model telescopes and are not supported by any existing speci.cation language. We give a formal semantics \nfor our speci.cation language (\u00a7 4) based on a locally nameless representation and prove its cor\u00adrectness \n(\u00a7 5). Our choice of representation leads to a simple semantics and straightforward metatheory. Alternative \nmean\u00adings are also possible; the simplicity of ours makes it a good reference for more sophisticated \nimplementations.  We have implemented our framework as a Haskell library (\u00a7 6), using Haskell s generic \nprogramming support to automatically derive standard operations. Our library is available for down\u00adload \nfrom Hackage,1 along with extensive documentation and examples. (Note GHC 7 is required.)  Although \nUNBOUND is designed for object language implemen\u00adtation, this speci.cation language and semantics are \nalso appropri\u00adate for formal object language reasoning. That application is be\u00adyond the scope of this \npaper; we discuss the connections to mecha\u00adnized metatheory in \u00a7 8 and \u00a7 9. 2. The UNBOUND Speci.cation \nLanguage We begin with a simple UNBOUND speci.cation.2 Functional pro\u00adgrammers are accustomed to using \nalgebraic datatypes to specify the abstract syntax of a programming language. UNBOUND intro\u00adduces type \ncombinators that encode binding structure into the alge\u00adbraic datatype itself. For example, to represent \nthe untyped lambda calculus, we use the E datatype below: type N = Name E data E = Var N | Lam (Bind \nNE) | AppE E The abstract type Name (provided by UNBOUND) represents variables, and is indexed by the \ntype of values which can be substi\u00adtuted for them (here, E). For convenience, we de.ne N as a syn\u00adonym \nfor Name E. Lambda abstractions are represented using the type Bind NE, indicating a name paired with \nan expression in which the name is bound. Application does not involve binding, so it is simply a pair \nof E values as expected. UNBOUND uses this datatype de.nition to derive standard oper\u00adations for working \nwith syntax, such as a-equivalence, free variable calculation, and capture-avoiding substitution. For \nexample, sup\u00adpose we want to implement parallel reduction for untyped lambda calculus terms. This operation \nlooks throughout a term for \u00df-and .-reductions, even under lambda abstractions, transforming it into \na simpler form. An implementation is shown in Figure 1. The sig\u00adnatures for the UNBOUND-derived operations \nthat this code relies on are at the top of the .gure. All of these functions are automati\u00adcally derived \nby UNBOUND. The function red has three cases. (Note that the Fresh constraint on m also implies a Monad \nconstraint, enabling the use of do\u00adnotation.) The Var case is trivial. The Lam case must handle the possibility \nof .-reduction, so we must break the lambda into its two constituent parts its bound variable, and its \nbody. Note that the type Bind NE type is abstract, so we cannot use pattern matching to extract its components. \nInstead, the monadic unbind operation decomposes the binding, ensuring that the name x does not con.ict \nwith other names currently in scope. 1 http://hackage.haskell.org/package/unbound/ 2 While our examples \nare presented in Haskell, using our Haskell library, the examples themselves are language neutral. UNBOUND \noperations used in this example: bind :: N . E . (Bind NE) unbind :: Fresh m . (Bind NE) . m (N , E) \nfv :: E . Set N subst :: N . E . E Parallel reduction: red :: Fresh m . E . mE red (Var x)= return (Var \nx) red (Lam b)= do (x, e) . unbind b \" e. red e \" case eof --.-reduction: (. x.e x) = e App e\"\" (Var \ny) | x = y .\u00ac (x . fv e\"\" ) . return e\"\" . return (Lam (bind x e\" )) red (App e1 e2)= do \" e1 . red \ne1 \" e2 . red e2 \" case e1 of --\u00df-reduction: (. x.e) t = e[t/x] Lam b . do \" (x, e) . unbind b return \n(subst x e2\"e\" ) \" . return (App e1\"e2) Figure 1. Parallel reduction for E T . T Name T Names for T s \nR Regular datatype containing only terms Bind P T Bind pattern P in body T P . P Name T Single binding \nname RP Regular datatype containing only patterns Embed T Embedded term (\u00a7 3.1) Rebind P P Nested binding \npattern (\u00a7 3.2) Rec P Recursive binding pattern (\u00a7 3.3) Figure 2. UNBOUND type combinators Once the \nbody of the lambda expression has been reduced, the code checks to see if it can do an .-reduction. This \nis possible when \"\" the body is exactly the application of some other term eto the variable x, where \nx does not appear free in e\"\" . If an .-reduction is not possible, the binding is reformed using the \nbind constructor for the Bind NE type. A similar unbinding occurs in the application case, when a \u00df-reduction \nhas been detected, followed by an invoca\u00adtion of a capture-avoiding substitution operation also provided \nby UNBOUND. At this point, one may ask: Where do these operations come from? What do they mean? How do \nwe know that the code given for red correctly implements parallel reduction for the lambda calculus? \nThe .rst question we answer in \u00a7 6 where we discuss the Haskell implementation of UNBOUND. The other \nquestions motivate our semantics (\u00a7 4) and the theorems we choose to prove about it (\u00a7 5). 3. Beyond \nsingle binding A key feature of UNBOUND is that programmers are not lim\u00adited to binding a single variable \nat a time. Instead, the bind con\u00adstructor takes a pattern containing variables and abstracts over all \nof them. A large class of types may be used as patterns. As a simple example, lists of names are patterns. \nIf we wanted to al\u00adlow the syntax .xyz . ... as a convenient shorthand for .x . .y . .z . ..., where \nx, y, and z are distinct names,3 we could change our de.nition of E to the following:  data E = Var \nN | Lam (Bind [N ] E) | AppE E In general, UNBOUND uses two sorts of types: those that may be used as \npatterns, where names are binding occurrences, and those that are terms, where names are references to \nbinding sites. Figure 2 summarizes these two classes, written P and T respectively. The Bind type combinator \ntakes a pattern type as its .rst argument and a term type as its second argument and returns a term type. \nOther term types include Name (representing free variables) and regular datatypes those built using unit, \nbase types, sums, products, and least .xpoint that contain only term types. By convention, we use the \nmetavariable P for pattern types and T for term types. The expressiveness of UNBOUND is determined by \nP, the col\u00adlection of types that can be used as patterns. These types include Names, of course, as well \nas regular datatypes that contain only other pattern types. This mean that some types, such as Int and \nString, can be used as both terms and patterns. We describe the three remaining UNBOUND pattern combinators \n(Embed, Rebind and Rec) in more detail in the next subsections. As a more sophisticated example of pattern \nbinding, consider adding pattern matching to the E language with a case statement. Each branch is encoded \nas Bind Pat E, where Pat is a new datatype representing object-language patterns. Every name occur\u00adring \nin a Pat will be bound in the respective body. data Pat = PVar N | PCon String [Pat ] data E = ... | \nCon String [E ] --data constructors | Case E [Bind Pat E ] --pattern matching It is not hard to check \nthat Pat is a valid pattern type (since it contains only Names and Strings), justifying its use as the \n.rst argument to Bind. 3.1 Embedding terms in patterns In many situations it is convenient to be able \nto embed terms within patterns. Such embedded terms do not bind variables along with the rest of the \npattern. For example, suppose we wanted to extend our E language with simple let-binding, let x=e1 in \ne2. Here x is bound in e2 but not in e1. A semantically correct encoding puts the e1 in the abstract \nsyntax before binding x in e2, lifting e1 outside the binding so it does not participate. type E1 = E \ntype E2 = E data E = ... | Let E1 (Bind NE2) (We use the type synonyms E1 and E2 to indicate which sub-terms \nof Let correspond to e1 and e2.) However, this encoding forces us to write the terms in an unnatural \norder; moreover, it fails to express the relationship between the name being let-bound and its de.nition. \nWe can craft a more satisfying solution using the embedding combinator Embed provided by UNBOUND: 3Although \nUNBOUND supports shadowing, a single pattern must be linear (i.e. not contain repeated variables). data \nE = ... | Let (Bind (N , Embed E1) E2) Embed may only occur within pattern types, where it serves as \nan escape hatch for embedding terms which do not bind any names. Note that a term type within an Embed \nmay itself contain pattern types (inside the left-hand side of Bind) which may contain Embedded term \ntypes, and so on. This formulation with Embed also enables us to extend our let expressions to multiple \nbindings, by using a pattern list: data E = ... | Let (Bind [(N , Embed E)] E) Without Embed, we could \nencode this binding speci.cation by unzipping the list of name-de.nition pairs and lifting the de.\u00adnitions \noutside of the Bind: data E = ... | Let [E ](Bind [N ] E) But this example is even worse than the corresponding \nencoding of let with a single binding. Not only does it force us to use an unnatural order and fail to \nencode the relationship between names and their respective de.nitions, it also admits junk terms with \nlists of different lengths. Embed enables an encoding where names and their de.nitions are paired, as \nthey should be.  3.2 Nested binding Consider now a let* construct, let* x1=e1,...,xn =en in e, where \neach xi is bound in e and also in all the ej with j>i. One way to encode this pattern is by iterating \nthe encoding for single let bindings discussed above: data LetList = Body E | Binding (Bind (N , Embed \nE) LetList) data E = ... | LetStar LetList This succeeds in capturing the binding structure of let*, \nand may be suf.cient for some purposes. However, it does have one major drawback: in order to extract \nthe body of the let* expression, we must .rst recurse through all the bindings. It is more convenient \nto encode a let* expression by pairing a list of bindings and a body, so the body can be accessed without \n.rst processing the bindings. As a .rst try, we could write data E = ... | LetStar (Bind [(N , Embed \nE)] E) but this is just the multiple binding example from the previous subsection. With this speci.cation, \nthe xi are bound only in the body of the let*, not in the de.nitions of subsequent variables. We evidently \nwant a way to nest additional binding structure within the pattern of the outermost Bind. UNBOUND provides \na novel rebinding pattern combinator for precisely this purpose. Rebind P1 P2 acts like the pattern type \n(P1, P2), except that P1 also scopes over P2, so the binders in P1 may be referred to by terms embedded \nwithin P2. (The fact that P1 scopes over P2 in this way has no effect on the pattern portion of P2.) \nFor example, consider the speci.cation type N1 = Name E type N2 = Name E Bind (Rebind N1 (N2, Embed E1)) \nE2 Here N1 and N2 are bound in E2, and additionally N1 is also bound within E1. Using rebinding, we can \nfaithfully encode the binding structure of let* as follows:  data Lets = Nil | Cons (Rebind (N , Embed \nE) Lets) data E = ... | LetStar (Bind Lets E) All the names within the sequence of de.nitions are bound \nin the body of the let*-expression (Bind Lets E); additionally, each name (paired with its de.nition \nas an embedded term) is bound within any Embeds occurring in the remainder of the sequence that is, within \nthe de.nitions of subsequent names. Telescopes A particularly important example of a binding pattern \nthat requires Rebind is a telescope. Telescopes were invented by de Bruijn [9] to model dependently-type \nsystems. They are used fre\u00adquently in speci.cations of dependently-typed languages, including Epigram \n[15] and Agda [17]. A telescope, ., is a sequence of variables paired with their types: x1 : A1,...,xn \n: An. However, each variable scopes over the types that occur later in the telescope. For example, here \nx1 may occur in A2, A3, and so on. The name telescope comes from the optical device, which is built as \nas a sequence of segments that slide into one another. Telescopes are used for aggregate binding . For \nexample, con\u00adsider the following (very simple) fragment of a dependently-typed language. In this language, \nfunctions can take multiple parameters and be applied to multiple arguments. However, because of depen\u00addent \ntypes, the type of each parameter is allowed to mention earlier parameters. A, B, M, N ::= x | ...B | \n...M | M (N1 ...Nn) Telescopes gather together all of the parameters of the function in both its de.nition \n(...M) and its type (...B). Because tele\u00adscopes are essentially typing contexts, the typing rule for \nabstrac\u00adtions merely appends the telescope to the current typing context: G, . f M : B G f ...M : ...B \n Type checking the multi-applications requires an auxiliary judg\u00adment that determines if the vector of \narguments .ts into the tele\u00adscope. G f N1 : A G f N2 .. Nn : .[x . N1] G f : . G f N1 N2 .. Nn :(x : \nA, .) This judgment veri.es that all of the arguments have the right types. Computing the result type \nof the application requires substituting all of the arguments for each binding variable in the telescope. \nG f M : ...A G f N1 .. Nn :. dom (.) = x1 .. xn G f M (N1 .. Nn ): B[x1 .. xn . N1 .. Nn ] This fragment \ndemonstrates the important features of telescopes. Sometimes they are used as binding patterns and sometimes \nthey are used as the types of vectors, independent of binding. Imple\u00admenting this language using traditional \nunary binding would be tiresome because one would have to traverse the entire telescope to see the body \nof the function or the body of the dependent type. That is not so much of an issue in this simple example, \nbut the se\u00admantics of features like inductive families (with eliminators based on induction principles \nor dependent pattern matching) is greatly simpli.ed by the aggregate binding that telescopes provide. \nIn UNBOUND, we can represent the language fragment above using Rebind: data E = Var N | Pi (Bind Tele \nE) | Lam (Bind Tele E) | App E [E ] data Tele = Empty | Rebind (N , Embed E) Tele Furthermore, UNBOUND \nautomatically provides all of the machin\u00adery necessary for working with telescopes, including calculation \nof their binding variables, multiple substitution in terms, and substitu\u00adtion through the telescopes. \n 3.3 Recursive binding Our E language is looking nice, but what if we want to add some recursion? We \ncan try to encode a letrec construct, letrec x1=e1,...,xn =en in e, where this time, the xi are bound \nin e as well as all the ei. This is straightforward if we are willing to lift all the xi out to the front: \ndata E = ... | Letrec (Bind [N ] ([E ], E)) However, the problems with this sort of encoding have already \nbeen discussed. We would like to encode letrec in such a way that names and de.nitions are paired. Rebind \ndoesn t help, because it forces us to separate binders from the terms over which they scope, just like \nBind. We need a way to freely mix patterns and terms bound by the patterns in the same data structure. \nUNBOUND provides the Rec combinator for this purpose. In Rec P, names in the pattern P scope recursively \nover any terms embedded in P itself. However, Rec P itself is also a pattern, so names in P also scope \nexternally over any term that binds Rec P. Intuitively, Rec is just a recursive version of Rebind. An \nappropriate encoding of letrec is therefore: data E = ... | Letrec (Bind (Rec [(N , Embed E)]) E) Here \nthe pattern [(N , Embed E)] scopes over itself hence all the names are bound in all the de.nitions as \nwell as over the body of the letrec. 4. Semantics In the previous section, we gave a number of examples \nof spec\u00adifying different sorts of binding patterns found in programming languages. However, we have been \nfairly vague about what those speci.cations actually mean. In this section, we .ll in the details by \ngiving it a semantics. Our semantics comes in two parts. We .rst de.ne the represen\u00adtation of syntax \nwith binders, and specify smart constructors and destructors that work with this representation. Second, \nwe de.ne the action of UNBOUND operations (a-equivalence, free variable calculation and substitution) \nin terms of this representation. Once we have formally de.ned this semantics, we prove that it satis.es \nthe properties we expect (\u00a7 5) and discuss the correspondence be\u00adtween it and our concrete Haskell implementation \n(\u00a7 6). 4.1 Representation For simplicity, we use a locally nameless representation of terms with binding \nstructure. This representation provides a straightfor\u00adward semantics for UNBOUND, one that is both simple \nto imple\u00adment and simple to reason about. Using a locally nameless repre\u00adsentation is an old idea we \ngive more details about its history later \u00a7 8. A locally nameless representation of terms with binding \nstruc\u00adture separates bound variables, represented by de Bruijn indices, from free variables, represented \nby atoms. (Atoms are often taken to be strings, but any countably in.nite set with decidable equality \n A ::= {x, y, z,... } b ::= j@k t ::= x | b | K t1 ...tn | Bind pt p ::= -x | K p1 ...pn | Rebind pp \n| Embed t | Rec p Figure 3. Syntax of atoms, indices, terms, and patterns will do.) This representation \nhas the advantage that a-equivalence is simply structural equality. Distinguishing bound variables from \nfree variables in this way also means that we do not need to keep track of the current scope of a free \nvariable and shift it as we move from one scope to another, as we would with a purely de Bruijn\u00adindexed \nrepresentation. The locally nameless syntax we use to represent terms with binding structure is shown \nin Figure 3. As in Figure 2, we separate terms from patterns. Terms t have term types T , whereas patterns \nhave pattern types P . Names that appear in terms can either be free names, x, or bound names, b. Free \nnames are drawn from the set Aof atoms. (In the in\u00adterest of simplicity, the semantics we describe here \nonly includes a single sort for atoms; extending to multiple atom sorts is straight\u00adforward.) Terms also \ninclude applications of constructor constants K to zero or more subterms. Note that constructor application \ncov\u00aders all terms with some regular type R; in the semantics they are all handled in precisely the same \nway. Indeed, thanks to generic programming, this is actually a faithful re.ection of our Haskell implementation, \nwhich handles all data constructors other than the special UNBOUND combinators uniformly. Like terms, \npatterns can be formed by the application of con\u00adstructors to subpatterns. Names inside patterns are \nbinders, writ\u00adten -x, which represent binding occurrences of names. We denote binders with special syntax \nto emphasize that we should think of them as placeholders with an associated name. The astute reader \nmay note that we are punning a bit with our syntax: in earlier examples, Bind and friends showed up as \ntypes, whereas here they are playing the role of data. The resolution of the apparent inconsistency is \nthat Bind, Embed, Rebind, and Rec are all singleton types with eponymous constructors. For example, we \ncan de.ne an operation that lists all of the atoms that a pattern will bind as shown below. binders :: \nP . [A] binders -x =[x ] binders (K p1 ... pn)= binders p1 + ... + binders pn binders (Rebind p1 p2)= \nbinders p1 + binders p2 binders (Embed t)= \u00d8 binders (Rec p)= binders p Note that even though we are \nusing Haskell-like syntax, this de.\u00adnition is type-directed. It works for any pattern of any pattern \ntype; the type of binders, P . [A], is an abbreviation for . P : P, P . [A]. In our Haskell implementation, \nto be discussed in more detail in \u00a7 6, each clause of a de.nition such as this one corresponds to a method \nde.nition in a type class instance.  4.2 Names, indices and patterns Bound names b consist of two natural \nnumber indices, j@k. The .rst index j references a pattern, counting outwards from zero; the second index \nk is an offset. It references a particular binder within the given pattern, counting from left to right, \nalso starting from zero. For example, in Bind (-x, -y, -z)(Bind -q 1@2) the bound variable 1@2 refers \nto -z, the index-2 binder within the index-1 enclosing pattern. Therefore, an important part of this \nrepresentation is the connec\u00adtion between patterns and offsets. We make this connection precise with \nthe operations nth and .nd (although we omit their de.ni\u00adtions in the interest of space): nth :: P . \nN . Maybe A .nd :: P . A . Maybe N nth takes a pattern and a natural number n and .nds the nth name bound \nin that pattern, failing if there are not enough binders. .nd takes a pattern and a name and .nds the \n.rst index of that name in the pattern, failing if the name does not occur. 4.3 Close and open The two \nmost important operations for the locally nameless repre\u00adsentation are close and open. The former is \nused for binding terms: it converts atoms (i.e. free names) to indices (i.e. bound names). The latter \ndoes the reverse, replacing indices that resolve to a par\u00adticular binding location by free names. We \ncall the .rst operation close, as we are closing the term with respect to the free names listed in a \npattern. Likewise, we call the inverse operation open, as we may use it to open up a binder in order \nto recurse through its subcomponents. These two operations are standard components for working with a \nlocally nameless representation [2, 11]. Here we modify them to close and open terms with respect to \na pattern instead of a single variable, and also to close and open the terms embedded inside patterns. \nThe close operation is de.ned in Figure 4. It takes as input a natural number level, a pattern, and a \nterm, and returns a new term where free variables matching binders in the pattern have been replaced \nby bound variables at the given level. In the free variable case, it uses .nd to look for a matching \nbinder and generate the appropriate index if one is found. We also de.ne a version of close for patterns, \ncloseP, whose job is to recurse through patterns looking for Embedded terms to which close can be applied. \nWhen recursing under a binder (Bind, Rebind, or Rec), both close and closeP increment the current level. \nThe open operation is also de.ned in Figure 4. It takes a natural number level, a pattern, and a term, \nand opens the term by interpreting bound variables at the given level as references into the pattern, \nreplacing them by the free variable attached to the referenced binder.4 Similarly to close, open is mutually \nde.ned with a pattern version openP. In the case where a bound variable is found which matches the current \nlevel, open uses nth to index into the pattern and pick out the free variable associated with the referenced \nbinder. We use close p t and open p t as convenient synonyms for close 0 pt and open 0 pt, respectively. \n 4.4 Constructing terms and patterns Figure 5 lists the smart constructors and destructors that are \npart of the interface to the type combinators exported by UNBOUND. In 4 In the locally nameless literature, \nopen is sometimes de.ned as bound\u00advariable substitution and generalized to replace bound variables with \nterms instead of with free variables. Such de.nitions save effort, since the next step after opening \nis often to substitute for the new free variable. In that case, the de.nition of open is a little more \ncomplex than what is presented here in order to deal with substituting terms with dangling bound variable \nreferences. We prefer our reference semantics to be as simple as possible so we avoid such complications. \n close :: N . P . T . T close l pb = b close l p x = case .nd p x of Just i . l@i Nothing . x close \nl p (K t1 ... tn)= K (close l pt1) ... (close l ptn) close l p (Bind p \" t)= Bind (closeP lpp \" ) (close \n(l + 1) pt) closeP :: N . P . P . P closeP lp -x = -x closeP lp (K p1 ... pn)= K (closeP lpp1) ... (closeP \nlppn) closeP lp (Rebind p1 p2)= Rebind (closeP lpp1) (closeP (l + 1) pp2) closeP lp (Embed t)= Embed \n(close l p t) closeP lp (Rec p \" )= Rec (closeP (l + 1) pp \" ) open :: N . P . T . T open l p (j @k) \n| j = l = case nth pk of Just x . x Nothing . j @k open l p x = x open l p (K t1 ... tn)= K (open l pt1) \n... (open l ptn) open l p (Bind p \" t)= Bind (openP lpp \" ) (open (l + 1) pt) openP :: N . P . P . P \nopenP lp (K p1 ... pn)= K (openP lpp1) ... (openP lppn) openP lp -x = -x openP lp (Rebind p1 p2)= Rebind \n(openP lpp1) (openP (l + 1) pp2) openP lp (Embed t)= Embed (open l pt) openP lp (Rec p \" )= Rec (openP \n(l + 1) pp \" ) Figure 4. close and open the next two subsections, we discuss the implementations of these \noperations. We use close to de.ne the constructors for binding abstractions. Closing a term with respect \nto the pattern binds the pattern variables in the term. bind pt = Bind p (close p t) Effectively, this \nreplaces all free occurrences of variables that ap\u00adpear in the pattern with indices. For example, binding \na pair of vari\u00adables in a term that references both variables will produce indices that refer to the \nsame pattern, but at different offsets. In contrast, nesting the binders produces indices that refer \nto the different bind\u00ading locations, but each one at the same offset (the zeroth variable in the pattern). \nbind (-x, -y)(x, y)= Bind (-x, -y) (0@0, 0@1) bind -x (bind -y (x, y)) = Bind -x (Bind -y (1@0, 0@0)) \nLikewise, for pattern combinators that introduce internal bind\u00ading, we also use close to replace occurrences \nof the bound variable with indices. Note that in the case of recursive binding, we close the pattern \nwith respect to itself. string2Name :: String . Name T name2String :: Name T . String bind :: P . T . \nBind P T unbind :: Fresh m . Bind P T . m (P, T ) rebind :: P1 . P2 . Rebind P1 P2 unrebind :: Rebind \nP1 P2 . (P1, P2) rec :: P . Rec P unrec :: Rec P . P embed :: T . Embed T unembed :: Embed T . T Figure \n5. Constructors and destructors rebind p1 p2 = Rebind p1 (closeP p1 p2) rec p = Rec (closeP pp) Finally, \nembed does not need to do any closing, and merely ap\u00adplies the Embed constructor to the given term. Likewise, \nunembed merely returns the nested term. embed t = Embed t unembed (Embed t)= t  4.5 Freshening and unbinding \nUnbinding is not quite as straightforward as binding. Given a term Bind pt, it is only safe to call open \np t if none of the binding variables of p clash with existing free variables in t. Therefore, before \nopening, we must .rst freshen p by assigning suitably fresh names to its binders. At this point, we leave \nthe precise meaning of suitably fresh open to interpretation; some concrete alternatives are discussed \nin \u00a7 6.4. We omit the formal de.nition of freshening since it is straightforward: it simply walks over \na pattern, assigning a suitably fresh name to each binder encountered, and stopping at occurrences of \nEmbed, since these are not part of the pattern. In our implementation, freshening also returns a permutation \nwhich describes how the variables were renamed, but we omit that here. We can now de.ne unbind as the \noperation that freshens the binding variables in the pattern and then opens the body of the binder with \nthe new pattern. unbind (Bind pt)= do p \" . freshen p return (p \" , open p \" t) In contrast, the destructors \nfor Rebind and Rec do not freshen before opening the rest of the pattern. Instead, they use the preex\u00adisting \nnames: unrebind (Rebind p1 p2)=(p1, openP p1 p2) unrec (Rec p)= openP pp One might wonder: why the difference? \nWhen opening a Bind, we must generate fresh names for its binders. However, by the time we come to opening \na nested bind\u00ading, fresh names will have already been chosen for its binders when the enclosing Bind \nwas opened. Hence there is no need to choose new names. In fact, we must not choose fresh names, since \nthere may exist corresponding free variables over which we have no con\u00adtrol. For example, consider the \nterm Bind (Rebind p1 p2) t, in which t may contain references to binders in p1. If we use unbind \"\" \" \nto take it apart into Rebind p1 p2 and t , there will now be free vari\u00ad \" \"\" ables in t which match the \nnames on binders in p1. Freshening p1 again when opening the Rebind would destroy this connection, and \nin particular would mean that we could not reassemble the original term using rebind and bind. This is \nalso why we must have Bind and Rebind as distinct combinators: if we used Bind everywhere, unbind would \nhave no way of knowing whether it was opening a top-level Bind (which must .rst be freshened) or a nested \none (which must not be).  4.6 Free variables, a-equivalence and substitution Now we come to the real \npayoff of our representation, as we specify the basic UNBOUND operations of a-equivalence, free variable \ncal\u00adculation, and capture-avoiding substitution, all shown in Figure 6. Their speci.cations are entirely \nstraightforward and, as described in the next section, reasoning about them is not much harder! The a-equivalence \nrelation on terms is de.ned mutually with a notion of equivalence for patterns which ignores binders \nand checks that embedded terms are a-equivalent. This a-equivalence relation is essentially structural \nequality the only reason it is not precisely structural equality is that name annotations on binders \nare ignored in PEQ BINDER. Computing free variables is equally straightforward. Since free and bound \nvariables are distinguished syntactically, we need only recurse through terms and patterns collecting \nall the free variables we .nd. Finally, we de.ne substitution into terms and patterns. If we see the \nfree variable we are substituting for, we replace it with the term being substituted; otherwise we simply \nrecurse. We need do noth\u00ading special when recursing through binders: since free and bound variables are \ndistinguished syntactically, we are in no danger of mistaking a bound variable for a free variable we \nshould substitute for, or of accidentally capturing any free variables in the substituted term. 5. Metatheory \nWe ve now de.ned a simple semantics for our pattern speci.cation language in terms of a locally nameless \nrepresentation. But how can we know whether this semantics is at all meaningful? Well, we prove stuff, \nof course! In the previous section, we noted how straightforward the de.\u00adnitions of various operations \nwere. Likewise, most of the proofs re\u00adgarding these operations are also straightforward (but full of \n.ddly details). We therefore omit most of the proofs and give only brief sketches of a few. The fact \nthat the proofs are straightforward is a testament to the elegance of the locally nameless representation. \nThere is already a lot of work to draw on from the metatheory of locally nameless representations in \nthe single binder case [1, 2]; much of the metatheory here can be seen as an extension of that prior \nwork. 5.1 Local closure One important property of the locally nameless representation is that only some \nterms are good representations. In particular, there is some junk in our representation, and we would \nlike to know that we (and users of our library) never need to deal with it. The lo\u00adcal closure relation \nin Figure 7 is an invariant for our representation which excludes terms with dangling bound variables. \nFor exam\u00adple, the term 0@0, a bound variable with no surrounding binder, is not locally closed.5 By making \nthe type combinators of our library abstract, we can demonstrate a central property of our interface: \nusers of the library can only construct locally closed patterns and terms. 5 This relation is an extension \nof McKinna and Pollack s VClosed rela\u00adtion [16]. ::T . T . Bool x y = x = y b1 b2 = b1 = b2 (K s1 ... \nsn) (K t1 ... tn)= s1 t1 . ... . sn tn (Bind p1 t1) (Bind p2 t2)= p1 P p2 . t1 t2 P ::P . P . Bool \n-x P -y = True (K p1 ... pn) P (K q1 ... qn)= p1 P q1 . ... . pn P qn (Rebind p1 p2) P (Rebind q1 q2)= \np1 P q1 . p2 P q2 (Embed t1) P (Embed t2)= t1 t2 (Rec p1) P (Rec p2)= p1 P p2 fv :: T . Set A fv x = \n{x}fv b = \u00d8 fv (K t1 ... tn)= fv t1 .\u00b7 \u00b7\u00b7. fv tn fv (Bind pt)= fvP p . fv t fvP :: P . Set A fvP -x = \n\u00d8 fvP (K p1 ... pn)= fvP p1 .\u00b7 \u00b7\u00b7. fvP pn fvP (Rebind p1 p2)= fvP p1 . fvP p2 fvP (Embed t)= fv t fvP \n(Rec p)= fvP p subst :: A . T . T . T subst x s y | x = y = s | otherwise = y subst x sb = b subst x \ns (K t1 ... tn)= K (subst x st1) ... (subst x stn) subst x s (Bind pt)= Bind (substP x sp)(subst x st) \nsubstP :: A . T . P . P substP x s -y = -y substP x s (K p1 ... pn)= K (substP x sp1) ... (substP x spn) \nsubstP x s (Rebind p1 p2)= Rebind (substP x sp1) (substP x sp2) substP x s (Embed t)= Embed (subst x \nst) substP x s (Rec p)= Rec (substP x sp) Figure 6. a-equivalence, free variables, and substitution Theorem \n1 (Constructors and destructors preserve local closure). All exported term and pattern constructors and \ndestructors pre\u00adserve local closure. Proof. Requires considering the action of each constructor and destructor \nindividually, appealing to a number of properties about the interaction of local closure, open and close. \nTheorem 2 (Substitution preserves local closure). If LC t and LC t \" then LC subst x tt \" .  If LC \nt and LC p then LC substP x tp.  Proof. Straightforward induction using a generalized version of local \nclosure.  LC t t is locally closed LC FREE LC x LC t1 .. LC tn LC CON LC K t1 .. tn LC p LC (open p \nt) LC BIND LC Bind pt LC p p is locally closed LCP BINDER LC -x LC p1 .. LC pn LCP CON LC K p1 .. \npn LC p1 LC (openP p1 p2) LCP REBIND LC Rebind p1 p2 LC t LCP EMBED LC Embed t LC (openP pp) LCP REC \nLC Rec p Figure 7. Local closure of terms and patterns Lemma 3 (Freshening preserves local closure). \nIf LC p and freshen p . p \", then LC p \" . Proof. Easy induction; freshening only changes names on binders, \nwhich the LC relation ignores. Next, we show that a-equivalence is an equivalence relation that is respected \nby the operations of our library. Theorem 4. - - is an equivalence. Proof. Re.exivity, symmetry, and \ntransitivity can each be estab\u00adlished by straightforward induction. Theorem 5 (fv respects a-equivalence). \nIf t1 t2, then fv t1 = fv t2. Proof. Straightforward induction on fv t1 along with a similar proof for \nfvP. Theorem 6 (Substitution respects a-equivalence). If t1 t2 and s1 s2, then [x . s1]t1 [x . s2]t2. \nProof. Straightforward induction on the derivation of t1 t2, along with a similar proof for pattern \nsubstitution. We next specify how the operations of a-equivalence, free vari\u00adable calculation, and substitution \ninteract with Bind. The proofs of these remaining theorems rely on properties about the interactions \nbetween close and each of the operations. The .rst theorem states the interaction between binding and \na\u00adequivalence. It states that two bindings are a-equivalent when we can freshen two patterns to the same \nnew result, and then show that their bodies are a-equivalent under a consistent renaming. Below, p1 and \np2 are the permutations returned by freshen and p1 \u00b7 t1 is the application of a permutation to a term. \ntype N = Name E data E = Var N | AppE E | Lam (Bind NE) deriving Show $(derive [ E ]) instance Alpha \nE instance Subst E E where isvar (Var n)= Just (SubstName n) isvar = Nothing Figure 8. Representing the \nuntyped lambda calculus Theorem 7. If freshen p1 . p,p1 and freshen p2 . p,p2 and p1 \u00b7 t1 p2 \u00b7 t2 then \nbind p1 t1 bind p2 t2. The second theorem speci.es the behavior of fv for binders. Theorem 8. fv (bind \npt)= fvP p . (fv t - binders p). Finally, we specify the conditions when substitutions are per\u00admitted \nto commute through bindings. Theorem 9. If {x}. fv t is disjoint from binders p, then subst x t (bind \npt \" )= bind (substP xtp)(subst x t t \" ). 6. Implementation The UNBOUND speci.cation language is implemented \nas an em\u00adbedded domain speci.c language (EDSL) in GHC Haskell, includ\u00ading all of the functionality described \nabove and more. Terms and patterns are normal Haskell datatypes, and combinators such as Name, Bind and \nRebind are abstract types provided by our li\u00adbrary. The implementation of UNBOUND closely follows the \nse\u00admantics that we presented in the previous section, with UNBOUND operations such as fv, subst and \u00b7 \n\u00b7 provided for user-de.ned datatypes via generic programming. Below, we give an overview of our library, \n.rst by giving a short example of how it may be used in a Haskell program, and then discussing the implementation \ndetails. Figure 9 summarizes the important UNBOUND operations that we discuss in this section. Figure \n8 shows a de.nition of the untyped lambda calculus using UNBOUND. The .rst part of the .gure is the same \nas in \u00a7 2. The rest of the .gure includes the small amount of boilerplate necessary to use UNBOUND with \nthe type E. We implement UNBOUND using the REPLIB generic program\u00adming library [35]. REPLIB works by \nproducing generic represen\u00adtation instances for each type. Roughly, a representation instance records \nthe structure of a datatype by analyzing its data dec\u00adlaration. In this case, the call $(derive [ E \n]) uses Template Haskell [29] to generate the generic representation for E. This structure information \nis used to automatically generate particular functions over E on demand. The following line in the .gure \ndeclares E to be an instance of the Alpha type class, which governs a-equality, free variable and freshening \noperations. Happily, default implementations for the methods of Alpha are de.ned generically. Guided \nby the occur\u00adrences of Bind and Name in the de.nition of E, the default de.\u00adnitions of these methods \nbehave exactly like their speci.cations in the semantics section. Capture-avoiding substitution is governed \nby the Subst class, and requires a tiny bit of work on our part: we must indicate where variables are \nlocated in datatypes. Beyond that, the generic default implementation suf.ces. In general, the type of \nsubst declares that values of type b may be substituted for free variables occurring in \u00b7 \u00b7 :: Alpha \na . a . a . Bool --alpha equivalence  acompare :: Alpha a . a . a . Ordering --alpha-respecting comparison \nfv :: (Alpha a, Rep b, Collection c) . a . c (Name b) --free names (single sort) fvAny :: (Alpha a, Collection \nc) . a . c AnyName --free names (all) fvP :: (Alpha a, Rep b, Collection c) . a . c (Name b) --free names \nin annotations (single) fvPAny :: (Alpha a, Collection c) . a . c AnyName --free names in annotations \n(all) binders :: (Alpha a, Rep b, Collection c) . a . c (Name b) --binding names (single sort) bindersAny \n:: (Alpha a, Collection c) . a . c AnyName --binding names (all) freshen :: (Alpha a, Fresh m) . a . \nm (a, Perm AnyName) --rename with fresh variables (returns a permutation) swaps :: Alpha a . Perm AnyName \n. a . a --permute variables subst :: Subst b a . Name b . b . a . a --single substitution substs :: Subst \nb a . [(Name b, b)] . a . a --simultaneous substitution Figure 9. Overview of selected UNBOUND operations \nvalues of type a, so the Subst E E instance shown declares that E values may be substituted for Vars \nin other E values. By making Subst a multiparameter type class we have .exibil\u00adity and safety. Imagine \na different declaration of the type E which contains both variables abstracting E, and type variables \nabstract\u00ading Typ. An instance Subst E E declares that E variables can be replaced with Es, and another \ninstance Subst Typ E would de\u00adclare that Typ variables can be replaced with Typs inside Es. In the latter \ncase, we would use the default de.nition of isvar as there is no way to replace Typ variables with Typs \nan get an E. In fact, the type indices of Name and SubstName would not allow us to give a de.nition of \nisvar that would confuse Typ and E variables. The operations fv, bind, unbind and subst are implemented \nin terms of the Alpha and Subst type classes. Therefore, Figure 8 provides all the necessary de.nitions \nfor the parallel reduction example in Figure 1 (which is valid Haskell code). 6.1 Multi-sorted names \nand AnyName Instead of a single homogeneous set of atomic names, UNBOUND has multisorted names. Consider \nthe type declarations in Figure 9. Names are indexed by a type, and the type of subst ensures that only \nthings of type t may be substituted for t-indexed names. The fv, fvP, and binders functions are also \npolymorphic in their re\u00adsult type, ignoring names whose type index does not match the re\u00adquested result \ntype. In this way, one may calculate, say, just the free term variables or just the free type variables \nfrom an expres\u00adsion. These functions are overloaded, so type inference determines precisely what sort \nof names will be calculated, and what sort of data structure (list, set, etc.) will be used to collect \nthem. However, sometimes we would like to know all free names, no matter what their sort. Therefore, \nUNBOUND also provides the type AnyName, which existentially hides the type index on a name, and the functions \nfvAny and bindersAny which return all appropriate names wrapped in AnyName constructors. 6.2 The Alpha \ntype class One way in which our implementation differs from our seman\u00adtics is that while the semantics \nstatically differentiates between terms and patterns, the implementation does not. Due to limita\u00adtions \nof REPLIB, instead of having two type classes Term a and Pattern a we must have a single type class Alpha \na which serves both purposes. This con.ation means that our implemen\u00adtation cannot statically prevent \nmeaningless types which use a pat\u00ad tern as a term (e.g. Embed (Embed N )) or a term as a pattern (e.g. \nBind (Bind NE) E).6 However, this con.ation does have an advantage. Many of the methods of the Alpha \nclass are parameterized by a mode which determines whether the type is being used as a term or a pattern. \nFor example, the a-equivalence method, called aeq \", is declared as: aeq \" :: AlphaCtx . a . a . Bool \naeq \" = aeqR1 rep1 The .rst argument, of type AlphaCtx, speci.es whether alpha\u00adequivalence should operate \nin term or pattern mode, generalizing the and P functions shown in Figure 6. The second line of the \ndeclaration is the default de.nition, which calls the datatype\u00adgeneric function aeqR1 (not shown) with \nthe type representation rep1 (derived with Template Haskell). Instances of Alpha can override this generic \nimplementation. For example, in the Name instance, the mode determines whether the names should be com\u00adpared \nor always considered equivalent. instance Alpha Name where ... aeq \" cxy | mode c = Term = x = y aeq \n\" c | mode c = Pat = True Many types (such as products and sums) are parametric in the mode and use the \nsame behavior in both cases. Overall, the Alpha type class includes mode-generalized ver\u00adsions of the \noperations shown in Figure 9, the predicates for dis\u00adtinguishing between terms and patterns, and the \nnecessary machin\u00adery for the locally nameless representation (open, close, .nd and nth).  6.3 Speci.c \ninstances for Alpha Default implementations for all Alpha methods are de.ned via generic programming, \nbut they may be overridden for greater con\u00adtrol or customization. This capability is necessary in practical \nuses of UNBOUND for speci.c types.7 For example, suppose we would like to tag variables with source position \ninformation in our abstract syntax: 6 We do, however, provide dynamic checks isPat and isTerm that can \nbe used to ensure the invariants are maintained. 7 This capability for overriding generic functions is \ninspired by the SYB3 library [14].  class Monad m . Fresh m where fresh :: Name a . m (Name a) class \nMonad m . LFresh m where lfresh :: Rep a . Name a . m (Name a) avoid :: [AnyName ] . ma . ma Figure 10. \nThe Fresh and LFresh type classes data E = ... | Var SourcePos N To make E an instance of Alpha, we \nneed SourcePos to also be an instance of Alpha, because it appears inside the E type. If we would like \na-equivalence to ignore source positions, we can simply override the default de.nition of a-equivalence \nfor SourcePos. By identifying all source positions as equivalent, we ensure that expressions appearing \nin different positions can still be determined to be a-equivalent. instance Alpha SourcePos where aeq \n\" = True  6.4 Freshness monads Since the freshen operation relies on the generation of fresh names, \noperations which make use of it (such as unbind) must execute within a monad. The Fresh type class, shown \nin Figure 10, governs those monads which can be used for this purpose, and is used to avoid tying users \ndown to one particular concrete monad. The Fresh class is quite simple: it requires only a single op\u00aderation \nfresh, which takes a name as input and generates a new name (based on the given name) which is guaranteed \nto be glob\u00adally fresh in some appropriate sense. For example, a simple con\u00adcrete implementation might \nkeep track of a global counter which is incremented every time fresh is called, appending the new counter \nvalue to the given base variable name. However, this is unsatisfactory in many instances. For example, \nconsider the simple pretty-printer for the untyped lambda calcu\u00adlus shown in Figure 11. If we pass it \nthe term . -x . -y . -z 2@0 (1@00@0), it produces \\x. \\y1. \\z2-> x(y1z2). We can see perfectly well that \nthe numeric suf.xes on y and z are un\u00adnecessary, since the existing names do not clash, but the fresh \nop\u00aderation does not have enough information to make this assessment. For this reason, we also provide \nthe more sophisticated LFresh type class for monads which can generate locally fresh names. lfresh works \nmuch like fresh, but it has more to go on: avoid ns m allows us to specify that the names ns should be \navoided by calls to lfresh in the subcomputation m. Unlike fresh, lfresh is not guaranteed to pick globally \nfresh names; it only guarantees not to pick names proscribed by an enclosing call to avoid. The intention \nis that it will return its argument unchanged when that name is not speci.cally to be avoided. Using \nLFresh, we can rewrite the pretty-printer so that names are chosen fresh with respect to exactly those \nnames currently in scope. To accomplish this we need only use LFresh instead of Fresh and lunbind instead \nof unbind; lunbind generates names for the binder using lfresh, then hands the body to a continuation \nwrapped in a call to avoid. UNBOUND providesseveral concreteimplementationsfor Fresh and LFresh, including \ntransformer versions for adding fresh name generation capabilities to existing monads, and instances \nallow\u00ad type N = Name E data E = Var N | Lam (Bind NE) | AppE E ppr :: Fresh m . E . m String ppr = ppr \n\" 0 where ppr \" (Var x)= return (show x) ppr \" p (Lam b)= do (x, e) . unbind b e \" . ppr \" 0 e return \n$ parens (p > 0) (\"\\\\\" + show x + \". \" + e \" ) ppr \" p (App e1 e2)= do e1 \" . ppr \" 1 e1 e2 \" . ppr \" \n2 e2 return $ parens (p > 1) (e1 \" + \"\" + e2\" ) parens True x = \"(\" + x + \")\" parens x = x Figure 11. \nA pretty-printer for the untyped lambda calculus ing their use with all the standard monad transformers \nin the transformers package.8  6.5 Simultaneous unbinding Up to now, we have seen only examples of opening \na single abstrac\u00adtion with arbitrary fresh names. However, some situations require simultaneously opening \ntwo or more abstractions with the same fresh names. For example, in order to check the convertibility \nof two LF .-types, we must open them with the same fresh name and recursively check the convertibility \nof the bodies. In order to simultaneously open two abstractions Bind p1 t1 and Bind p2 t2, we require \nonly that p1 and p2 have the same number of binders. Requiring a stronger match between p1 and p2 would \nbe unnecessarily limiting. For example, continuing our LF checking example, p1 and p2 might contain type \nannotations which are convertible but not a-equivalent. Therefore, UNBOUND provides a function unbind2 \nthat simul\u00adtaneously opens two related bindings. unbind2 :: (Fresh m, Alpha p1, Alpha p2, Alpha t1, Alpha \nt2) . Bind p1 t1 . Bind p2 t2 . m (Maybe (p1, t1, p2, t2)) unbind2 (Bp1 t1)(Bp2 t2)= do case mkPerm (bindersAny \np1)(bindersAny p2) of Just p . do (p1\" ,p \" ) . freshen p1 return (Just (p1\" , open p1 \" t1, swaps (p \n\" . p) p2, open p1 \" t2)) Nothing . return Nothing This function works by .rst matching the binding variables \nof the two patterns together to create a permutation p. This operation will fail if the patterns bind \ndifferent numbers of variables. Next, it freshens the .rst pattern p1 and uses the result to open t1 \nand t2. Finally, it must compose the permutation from freshening p1 with that from the match, and use \nthe new permutation to rename the second pattern. 8 http://hackage.haskell.org/package/transformers \n 7. Discussion 7.1 Nominal semantics We have presented a semantics for the UNBOUND speci.cation lan\u00adguage \nin terms of a locally nameless representation, but this is not our only possible choice. UNBOUND could \nalso be speci.ed via an equivalent nominal semantics [19], and we are working in parallel on a nominal-style \nHaskell implementation. Such an alternative se\u00admantics would provide differences in running time/space, \nbut oth\u00aderwise would behave identically to the locally nameless version. In future work, we plan to formalize \nthe precise connection between the two formulations and prove their equivalence with respect to the abstract \ninterface provided by the library. Although a nominal semantics might appear more natural to think about, \nin our experience the locally nameless semantics is far easier to understand when it comes to generalized \nbinding patterns, especially with nesting. Therefore, an important contribution of this work is the identi.cation \nof a simple semantics for pattern binding. 7.2 Caml-style speci.cations Franc\u00b8ois Pottier s Caml system \n[21] features a single-argument ab\u00adstraction constructor, inside which patterns and terms (both bound \nand unbound) can be mixed. Directly inside an abstraction is a pat\u00adtern, with terms embedded via outer \n(indicating a term outside the scope of the pattern) or inner (indicating that the pattern binds names \nin the term). Caml s abstraction constructor (p) is easily de.nable with UNBOUND as Bind (Rec p) (). \nWithin that pattern, occurrences of Embed are analogous to occurrences of inner in Caml. To account for \nCaml s outer scope speci.cation, we gener\u00adalize the Embed combinator by adding a natural number subscript. \nWhen encountering Embedn while doing an open or close oper\u00adation, we decrement the level by n. Hence, \nEmbed0 corresponds to the original Embed, and Embed1 corresponds to Caml s outer construct, since it \nshifts the scope of an embedded term out to the next enclosing level. In UNBOUND we implement indexed \nembedding by adding a new type combinator Shift P. This type increments the index of its argument, so \nShift (Embed T ) corresponds to Embed1 T , and Shift (Shift (Embed T )) is Embed2 T . Operationally, \nall Shift does is decrement the binding level when the pattern is opened or closed so that variables \nwill resolve to an outer scope.  7.3 UNBOUND in practice We have been using UNBOUND in the TRELLYS project, \nin the context of type checking and evaluation of an experimental dependently-typed language. In this \ncontext, UNBOUND support for telescopes is essential. Our experience with TRELLYS has al\u00adlowed us to \n.nd and correct a few bugs in our implementation of UNBOUND, but for the most part the use of UNBOUND \nhas been unremarkable, in the sense that it seems to just work . The only drawback to using UNBOUND is \nthe lack of pattern matching for the abstract type Bind. TRELLYS is an ideal client for UNBOUND, in that \nit is a prototype language with a greater emphasis on semantics than performance. Because UNBOUND is \nimplemented using generic programming, it will be slower than a hand-coded implementa\u00adtion [25]. If necessary, \nwe could easily replace the generic de.\u00adnitions with hand-coded operations by overriding the Alpha type \nclass instances. The locally nameless representation does have some perfor\u00admance concerns with respect \nto its use of open and close. While the standard operations fv, subst, and \u00b7 \u00b7 are linear in the size \nof terms, operations that are de.ned in the freshness monad must open and close the terms for each binding \nlevel, which could be expensive. Although we have not had any dif.culties of this sort in TRELLYS (our \nexperiments are still small) it is possible that with larger programs and deeper binding depths, these \noperations could dominate. To mitigate this dif.culty, UNBOUND supports an experts-only interface, where \ncritical operations can be written directly over the terms (in a manner similar to our implementations \nof fv, subst and \u00b7 \u00b7). We have not explored the interaction of UNBOUND with stan\u00addard optimizations [28]. \nFor example, by caching free names, an implementation of substitution could stop early if the name be\u00ading \nsubstituted for is not cached. If we remove names from bound patterns (which are preserved only for error \nmessages) the locally nameless representation interacts nicely with hash-consing, as all a-equivalent \nterms have the same representation. We are also working on bringing our nominal implementation of UNBOUND \nup to date with our reference locally nameless im\u00adplementation. Both implementations provide the same \ninterface to clients. When using the LFresh monad, the nominal implementa\u00adtion could avoid freshening \nwhen unbinding patterns if the patterns were already suf.ciently fresh. However, there are trade-offs \nin\u00advolved; for example, a-equivalence can be more expensive with the nominal version. One important contribution \nof UNBOUND is that it provides an abstract interface to name binding. Clients can write their code against \nthis interface, and, depending on their particular applica\u00adtion, choose the most appropriate implementation. \nImportantly, our locally nameless implementation provides a simple reference se\u00admantics for this interface, \nand alternative implementations may use this semantics to prove their correctness. 8. Related Work Locally \nnameless representation The locally nameless represen\u00adtation dates back to the introduction of de Bruijn \nindices, and is mentioned in the conclusion of de Bruijn s paper [8]. The key idea is even older. It \nrests on the separation of names into two distinct classes: variables (for locally bound variables) and \nparameters (for free, or globally bound variables) and goes back to Kleene [13], Prawitz [24] and Gentzen \n[10]. The full history of the locally name\u00adless representation is outside the scope of this paper, but \nwe refer to Aydemir et al [2] and Chargu\u00b4eraud [4] which discusses it in detail. Instead, we focus on \nthe interaction between this representation, generic programming and binding speci.cations. Chargu\u00b4eraud \ns paper [4] also gives several examples of locally\u00adnameless representations of languages with speci.c \nbinding forms, including binding a list of variables, pattern matching (with embed\u00added terms), and recursive \nbindings. However, he does not consider a compositional framework for describing generalized binding. \nZappa Nardelli s locally nameless backend [36] for the OTT tool [27] automatically generates de.nitions \nfor the Coq proof as\u00adsistent given a speci.cation of a language (with single binding only). These de.nitions \ninclude a locally nameless representation of the syntax, open and close operations, a-equivalence, substitu\u00adtion, \nand free variable calculation. The LNgen tool of Aydemir and Weirich [1] augments this output with generic \nproofs about this representation, including many of the properties of \u00a7 5. Tools for general bindings \nCirstea et al. [7] de.ne the .-calculus, a .-calculus-like system for expressing rewriting strategies, \nwhich features generic binders represented by any term. Herman and Wand de.ne a speci.cation language \nfor binding structure in the service of a-converting Scheme programs contain\u00ading macros [12]. Although \nit only allows single variables as bind\u00ading patterns, it is .exible about the subterms in which each \nvariable should be bound. The OTT tool provides an expressive speci.cation language for generalized binding \nin programming languages. In conjunction with a speci.cation of the abstract syntax, OTT allows the de.ni\u00adtion \nof bindspecs: functions that arbitrarily select the binding vari\u00adables that appear in terms and bind \nthem elsewhere in the abstract syntax. They give a semantics of this speci.cation language using a representation \nwith concrete variable names [26] and show that under appropriate conditions, their concrete substitution \nfunctions respect a-equivalence and coincide with capture-avoiding substitu\u00adtion.  Inspired by the OTT \nspeci.cation language, Urban and Kaliszyk recently extended the Nominal Isabelle proof assistant with \nsup\u00adport for general bindings [34]. Their system works by using the OTT binding speci.cations (with some \nrestrictions) to de.ne a\u00adequivalence classes of syntax with binders which they use to model nominal-logic \nspeci.cations. While a direct comparison is dif.\u00adcult, their restrictions prevent variables from being \nbound by two different bindspecs, which seems necessary for telescopes. On the other hand, they also \nadd two forms of set bindings to their speci\u00ad.cations, allowing binders to be equivalent up to permutation \nand weakening of their patterns. As discussed in \u00a7 7.2, there is a close connection between UN-BOUND \nand Francois Pottier s Caml system [21], based on a nom\u00adinal semantics for binding. One major difference \nis that Caml ex\u00adplicitly does not include support for nested binders. Another differ\u00adence is that Caml \nis an external tool that performs a preprocessing step, whereas UNBOUND is a library. However, this is \nnot a fun\u00addamental difference; Caml could be made into a library as well if OCaml had better support \nfor generic programming (likewise, UN-BOUND could be ported to languages without support for generic \nprogramming by making it into an external tool). Cheney s FreshLib [6] is a Haskell library which served \nas an inspiration for UNBOUND. Like UNBOUND, it uses generic pro\u00adgramming to automatically de.ne a-equivalence \nand substitution functions (although FreshLib is based on a nominal semantics for name binding, so the \ngeneric operations that establish its semantics are different). FreshLib also supports some forms of \ngeneralized binding, but does not give a generic treatment of patterns. Other tools based on nominal \nlogic include FreshML [31] and FreshOCaml [30]. However, they support limited forms of binding patterns \nwhich do not include embeddings, recursive or nested bindings. Likewise, the Haskell Nominal Toolkit \n[3] is a library that supports single binding for a .xed term structure. 9. Future work Although we believe \nUNBOUND is useful in its current state, there are several directions in which we would like to extend \nit. Other forms of exotic binding Cheney [5] gives a catalogue of exotic binding, renaming, and structural \ncongruence situations. Although UNBOUND can express many of these examples, we hope to extend UNBOUND \nwith better support for global binding, such as that used for objects and modules. Furthermore, we would \nalso like to add support for set binding similar to Nominal Isabelle [34]. However, implementing unbind2 \nin the presence of such bindings is a nontrivial task. Better static distinction between names and patterns \nAs dis\u00adcussed in \u00a7 6.2, an infelicity of our current design is the ability to get terms and patterns \nmixed up. UNBOUND inherits this limita\u00adtion from REPLIB; it is possible that an alternative framework \nfor generic programming would perform better in this respect. Scoping UNBOUND does not keep track of \nthe scope of names once they have been unbound. While this laxity leads to a familiar and .exible interface, \nit does not rule out bugs that could occur from names escaping their scope. Pottier et al. have made \nprogress in this respect [22, 23], and we would like to explore a variant interface for UNBOUND that \nprovides this tighter control. Mechanized metatheory The UNBOUND speci.cation language seems ideal for \nincorporation into tools like Ott, LNgen and Nom\u00adinal Isabelle that assist in the formalization of programming \nlan\u00adguage metatheory. Indeed, locally nameless representations have already proved useful for that sort \nof reasoning. However, in the context of formal reasoning, we must be more careful about scoping. Allowing \nbound names to escape their scope can lead to unsoundness (see Urban [32]). Such functions violate the \nFreshness Condition for Binders , a side condition required for all function de.nitions in Nominal Isabelle \n[33]. Adapting UN-BOUND to mechanized reasoning would require a similar side con\u00addition for function \nde.nitions. 10. Conclusion UNBOUND is an expressive speci.cation language for generalized binding structures, \nde.ned with a simple compositional semantics, proven correct, and immediately available to the GHC user \ncom\u00admunity. Because it supports the rapid development of typecheckers, compilers, and interpreters, it \nis a valuable tool for exploration in programming language design. Furthermore, we hope that the de\u00adsign \nof UNBOUND itself will be a model for future work on library support for expressive binding structure. \nAcknowledgments Chris Casinghino, Vilhelm Sj\u00a8 oberg and the rest of the TRELLYS team provided valuable \nfeedback on this work. Thanks are also due to the Penn PLClub for feedback on an early draft of this \npaper. Finally, we thank the anonymous referees for their many helpful corrections, comments, and suggestions. \nThis material is based upon work supported by the National Science Foundation under grant 0910500. References \n[1] B. Aydemir and S. Weirich. LNgen: Tool support for locally name\u00adless representations. Technical Report \nMS-CIS-10-24, Computer and Information Science, University of Pennsylvania, June 2010. [2] B. Aydemir, \nA. Chargu\u00b4eraud, B. C. Pierce, R. Pollack, and S. Weirich. Engineering formal metatheory. In ACM SIGPLAN-SIGACT \nSympo\u00adsium on Principles of Programming Languages (POPL), pages 3 15, Jan. 2008. [3] C. Calv`es. A Haskell \nnominal toolkit. http://www.inf.kcl.ac. uk/pg/calves/hnt/, Jan. 2009. [4] A. Chargu\u00b4eraud. The locally \nnameless representation. Journal of Automated Reasoning, Special Issue on the POPLmark Challenge, 2011. \nTo appear. [5] J. Cheney. Toward a general theory of names: binding and scope. In Proceedings of the \n3rd ACM SIGPLAN workshop on Mechanized rea\u00adsoning about languages with variable binding, MERLIN 05, pages \n33 40, New York, NY, USA, 2005. ACM. [6] J. Cheney. Scrap your nameplate: (functional pearl). In Proceedings \nof the tenth ACM SIGPLAN international conference on Functional programming, ICFP 05, pages 180 191, \nNew York, NY, USA, 2005. ACM. ISBN 1-59593-064-7. [7] H. Cirstea, C. Kirchner, L. Liquori, and B. Wack. \nRewrite strategies in the rewriting calculus. In B. Gramlich and S. Lucas, editors, Proceed\u00adings of the \nThird International Workshop on Reduction Strategies in Rewriting and Programming , Valencia, Spain, \nJune 2003. Electronic Notes in Theoretical Computer Science. [8] N. G. de Bruijn. Lambda calculus notation \nwith nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser \ntheorem. Indagationes Mathematicae, 34(5):381 392, 1972.  [9] N. G. de Bruijn. Telescopic mappings in \ntyped lambda calculus. Information and Computation, 91(2):189 204, 1991. [10] G. Gentzen. The Collected \nPapers of Gerhard Gentzen. North-Holland, 1969. Edited by Mandred Szabo. [11] A. D. Gordon. A mechanisation \nof name-carrying syntax up to alpha\u00adconversion. In J. Joyce and C. Seger, editors, Higher-order Logic \nTheorem Proving And Its Applications, Proceedings, 1993, volume 780 of Lecture Notes in Computer Science, \npages 414 426. Springer, 1994. [12] D. Herman and M. Wand. A theory of hygienic macros. In ESOP 08: Proceedings \nof the Seventeenth European Symposium On Program\u00adming, Mar. 2008. [13] S. Kleene. Introduction to Metamathematics. \nban Nostrand Rhein\u00adhold, Princeton, USA, 1952. [14] R. L\u00a8ammel and S. Peyton Jones. Scrap your boilerplate \nwith class: extensible generic functions. In Proceedings of the ACM SIGPLAN International Conference \non Functional Programming (ICFP 2005), pages 204 215. ACM Press, Sept. 2005. [15] C. McBride. Dependently \nTyped Functional Programs and their Proofs. PhD thesis, University of Edinburgh, 1999. Available from \nhttp://www.lfcs.informatics.ed.ac.uk/reports/00/ ECS-LFCS-00-419/. [16] J. McKinna and R. Pollack. Some \nlambda calculus and type theory formalized. Journal of Automated Reasoning, 23(3 4):373 409, 1999. [17] \nU. Norell. Towards a practical programming language based on dependent type theory. PhD thesis, Department \nof Computer Sci\u00adence and Engineering, Chalmers University of Technology, SE-412 96 G\u00a8oteborg, Sweden, \nSeptember 2007. [18] B. Pientka and J. Dun.eld. Beluga: A framework for programming and reasoning with \ndeductive systems (system description). In J. Giesl and R. H\u00a8ahnle, editors, IJCAR, volume 6173 of Lecture \nNotes in Computer Science, pages 15 21. Springer, 2010. [19] A. M. Pitts. Nominal logic, a .rst order \ntheory of names and binding. Information and Computation, 186:165 193, 2003. [20] A. Poswolsky and C. \nSch\u00a8urmann. System description: Delphin a functional programming language for deductive systems. Electron. \nNotes Theor. Comput. Sci., 228:113 120, January 2009. [21] F. Pottier. An overview of Caml. In ACM Workshop \non ML, pages 27 52, Mar. 2006. [22] F. Pottier. Static name control for FreshML. In In IEEE Symposium \non Logic in Computer Science, pages 356 365, 2007. [23] N. Pouillard and F. Pottier. A fresh look at \nprogramming with names and binders. In Proceedings of the 15th ACM SIGPLAN international conference on \nFunctional programming, ICFP 10, pages 217 228, New York, NY, USA, 2010. ACM. ISBN 978-1-60558-794-3. \n[24] D. Prawitz. Natural Deduction: Proof Theoretical Study. Almquist and Wiksell, Stockholm, 1965. [25] \nA. Rodriguez, J. Jeuring, P. Jansson, A. Gerdes, O. Kiselyov, and B. C. d. S. Oliveira. Comparing libraries \nfor generic programming in Haskell. SIGPLAN Not., 44:111 122, September 2008. [26] S. Sarkar, P. Sewell, \nand F. Zappa Nardelli. Binding and substitution. www.cl.cam.ac.uk/~pes20/ott/bind-doc.pdf, Oct. 2007. \n[27] P. Sewell, F. Z. Nardelli, S. Owens, G. Peskine, T. Ridge, S. Sarkar, and R. Strnisa. Ott: Effective \ntool support for the working semanticist.. Journal of Functional Programming, 20(1):71 122, 2010. [28] \nZ. Shao. Implementing typed intermediate language. In Proc. 1998 ACM SIGPLAN International Conference \non Functional Program\u00adming (ICFP 98), pages 313 323, Baltimore, Maryland, September 1998. [29] T. Sheard \nand S. P. Jones. Template meta-programming for Haskell. SIGPLAN Not., 37:60 75, December 2002. [30] M. \nShinwell and A. Pitts. Fresh Objective Caml User Manual. Cam\u00adbridge University Computer Laboratory, Feb. \n2005. [31] M. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: Program\u00adming with binders made simple. \nIn Eighth ACM SIGPLAN Inter\u00adnational Conference on Functional Programming (ICFP 2003), Up\u00adpsala, Sweden, \npages 263 274. ACM Press, Aug. 2003. [32] C. Urban. How to prove false using the variable convention. \nAppears as a poster at TTVSI, 1 page, mar 2008. [33] C. Urban. Nominal techniques in Isabelle/HOL. Journal \nof Automated Reasoning, 40:327 356, 2008. ISSN 0168-7433. URL http://dx. doi.org/10.1007/s10817-008-9097-2. \n[34] C. Urban and C. Kaliszyk. General bindings and alpha-equivalence in Nominal Isabelle. In G. Barthe, \neditor, Programming Languages and Systems, volume 6602 of Lecture Notes in Computer Science, pages 480 \n500. Springer Berlin / Heidelberg, 2011. URL http: //dx.doi.org/10.1007/978-3-642-19718-5_25. [35] S. \nWeirich. RepLib: A library for derivable type classes. In Haskell Workshop, pages 1 12, Portland, OR, \nUSA, Sept. 2006. [36] F. Zappa Nardelli. A locally-nameless backend for Ott. moscova. inria.fr/~zappa/projects/ln_ott/, \n2009.    \n\t\t\t", "proc_id": "2034773", "abstract": "<p>Implementors of compilers, program refactorers, theorem provers, proof checkers, and other systems that manipulate syntax know that dealing with name binding is difficult to do well. Operations such as &#945;-equivalence and capture-avoiding substitution seem simple, yet subtle bugs often go undetected. Furthermore, their implementations are tedious, requiring \"boilerplate\" code that must be updated whenever the object language definition changes.</p> <p>Many researchers have therefore sought to specify binding syntax declaratively, so that tools can correctly handle the details behind the scenes. This idea has been the inspiration for many new systems (such as Beluga, Delphin, FreshML, FreshOCaml, C&#945;ml, FreshLib, and Ott) but there is still room for improvement in expressivity, simplicity and convenience.</p> <p>In this paper, we present a new domain-specific language, <b>Unbound</b>, for specifying binding structure. Our language is particularly expressive - it supports multiple atom types, pattern binders, type annotations, recursive binders, and nested binding (necessary for telescopes, a feature found in dependently-typed languages). However, our specification language is also simple, consisting of just five basic combinators. We provide a formal semantics for this language derived from a locally nameless representation and prove that it satisfies a number of desirable properties.</p> <p>We also present an implementation of our binding specification language as a GHC Haskell library implementing an embedded domain specific language (EDSL). By using Haskell type constructors to represent binding combinators, we implement the EDSL succinctly using datatype-generic programming. Our implementation supports a number of features necessary for practical programming, including flexibility in the treatment of user-defined types, best-effort name preservation (for error messages), and integration with Haskell's monad transformer library.</p>", "authors": [{"name": "Stephanie Weirich", "author_profile_id": "81100093135", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2801438", "email_address": "sweirich@cis.upenn.edu", "orcid_id": ""}, {"name": "Brent A. Yorgey", "author_profile_id": "81470652913", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2801439", "email_address": "byorgey@cis.upenn.edu", "orcid_id": ""}, {"name": "Tim Sheard", "author_profile_id": "81331504269", "affiliation": "Portland State University, Portland, OR, USA", "person_id": "P2801440", "email_address": "sheard@cs.pdx.edu", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034818", "year": "2011", "article_id": "2034818", "conference": "ICFP", "title": "Binders unbound", "url": "http://dl.acm.org/citation.cfm?id=2034818"}