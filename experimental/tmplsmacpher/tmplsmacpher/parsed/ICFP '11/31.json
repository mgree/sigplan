{"article_publication_date": "09-19-2011", "fulltext": "\n Recursion principles for syntax with bindings and substitution Andrei Popescu Elsa L. Gunter Technical \nUniversity Munich University of Illinois at Urbana-Champaign University of Illinois at Urbana-Champaign \negunter@uiuc.eduInstitute of Mathematics Simion Stoilow of the Romanian Academy uuomul@yahoo.com Abstract \nWe characterize the data type of terms with bindings, freshness and substitution, as an initial model \nin a suitable Horn theory. This characterization yields a convenient recursive de.nition principle, which \nwe have formalized in Isabelle/HOL and employed in a series of case studies taken from the .-calculus \nliterature. Categories and Subject Descriptors F.3.1 [Specifying and Verify\u00ading and Reasoning about Programs]: \nMechanical veri.cation General Terms Languages, Veri.cation Keywords Syntax with bindings, Recursion, \nLambda calculus, Substitution 1. Introduction Bindings and substitution, i.e., the notions of binding \na variable in a term and substituting a term or value for a variable in a term, re\u00adspectively, are pervasive \nin logic and programming languages. For\u00admal/rigorous reasoning about syntax with bindings is notoriously \nhard, as observed by many authors (e.g., [8, 11, 14, 19, 22, 28, 32, 39, 45]). In particular, basic lemmas \nabout composing and commut\u00ading substitutions turn out, in practice, to be problematic. In this paper, \nwe introduce a recursor for terms with bindings with built-in substitution, which ensures, in exchange \nfor checking a few conditions on the target domain, both the correctness of the de.nition and compositionality \nw.r.t. freshness and substitution. Our contribution is formalized in the Isabelle theorem prover [26], \nand is in general guided by formalization goals. Apart from this introduction and Section 8 which draws \nconclu\u00adsions and discusses related work, this paper has two main parts. The .rst part, consisting of \nSections 2, 3, 4, and 5, motivates, presents and illustrates our mathematical contribution. In Section \n2, we discuss two standard situations occurring in formal reason\u00ading: de.ning a semantic domain interpretation \nmap and a Higher-Order Abstract Syntax (HOAS) representation map. In order to go through, these de.nitions \ntraditionally require a tedious treatment of bindings and a-equivalence. Moreover, later development \nusu\u00adally requires that the involved interpretation/representation maps be shown to preserve freshness \nand be compositional w.r.t. to substitu\u00adtion. These basic , low-level facts require serious effort from \nthe Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n11, September 19 21, 2011, Tokyo, Japan. Copyright c &#38;#169; 2011 ACM 978-1-4503-0865-6/11/09. . . \n$10.00 developer, which contrasts with their highly intuitive character; and this discrepancy is of course \neven more dramatic if one is interested in a formal development (in a theorem prover). All the above \nmoti\u00advate our approach, described in Section 3. The main idea is to inte\u00adgrate freshness and substitution \nin the de.nition (of the desired map from terms to another set), resolving at de.nition time , both the \nissue of well-de.nedness (i.e., compatibility with a-equivalence) and that of substitution compositionality. \nMathematically, this is based on a characterization of the term model as initial in a suit\u00adable Horn \ntheory in the .rst-order language of the term-constructor, freshness and substitution operators. We show \nhow our approach handles the aforementioned two situations e.g., for HOAS, both the de.nition of the \nmap and its so-called adequacy are established during the de.nition. Our thesis is that many situations \nfrom for\u00admal reasoning about syntax with bindings fall under the scope of this substitution-based de.nition \nprinciple. In Section 4, we bring evidence for this thesis by means of other examples taken from the \n.-calculus literature. We also discuss cases where our principle does not apply. Finally, in Section \n5, we explore the notion of in\u00adferring more facts about the maps de.ned by our methodology. It turns \nout that this is indeed possible (and, as witnessed by exam\u00adples, useful). In particular, we obtain an \ninternal characterization of the term model, expressed solely in terms of the basic operators: syntactic \nconstructs, freshness and substitution. The second part, consisting of Sections 6 and 7, deals with for\u00admalization \naspects. Indeed, the main goal of our theoretical con\u00adtribution is facilitating rigorous, and indeed \nformal, de.nitions of substitution-compositional maps on terms with bindings. There\u00adfore, formalizing \nour results and applying them in actual formal developments is an important test for their relevance. \nIn Section 6, we discuss the formal resolution in Isabelle/HOL [26] of one of our motivating problems, \nnamely, adequate HOAS representa\u00adtion. In Section 7, we employ our characterization from Section 5 to \nrelate by isomorphisms our formalization with other Isabelle formalizations of .-calculus terms: Nominal \n[42], Hybrid [8] and locally named [38]. Indeed, our characterizations of terms as an ab\u00adstract data \ntype (ADT) is up to isomorphism any model satisfying our properties yields an isomorphism to our own \nmodel (and to any correct model). We propose this methodology (of establishing such ADT isomorphisms) \nas a basis for certifying formalizations and transporting results across different formalizations. The \nappendix contains more details on the Isabelle formaliza\u00adtion of this paper s results and examples (made \navailable at [4] for the interested reader). An extended version of the material pre\u00adsented in this paper, \nincluding technical details and explanations, can be found in [36] (as the largely self-contained chapter \n2 from there). Conventions and notations. We employ the standard symbols for functional and logical connectives \nand quanti.ers (. for functional abstraction, . for conjunction, =. for implication, . for the uni\u00adversal \nquanti.er), only in the meta-language of this paper, and not in the various formal languages that we \ndiscuss.  We .x a countable set var of variables, ranged over by x, y, z, and consider the set term, \nof terms, ranged over by X, Y, Z, to be generated by the following grammar: X ::= Var x | App XY | Lm \nxX where, within Lm xX, any occurrence of x in X is assumed bound. Thus, we use lower cases for variables \nand upper cases for terms. Var x is the variable x regarded as a term, App XY is an appli\u00adcation, X applied \nto Y , and Lm xX is a .-abstraction, of x in X. We usually omit spelling the variable-injection operator \nVar, writing x instead of Var x. Terms are identi.ed modulo the notion of a-equivalence standardly induced \nby the above bindings. The freshness and substitution operators, -fresh : var . term . bool and -[ / \n]: term . term . var . term, are the standard ones, namely: fresh xX holds iff the variable x is fresh \nfor (i.e., does not appear free in) the term X; X[Y/y] is the term obtained from X by substituting, in \na capture-free manner, all occurrences of y with Y . We refer to the above type, term with the syntactic \nconstruc\u00adtors (C), freshness (F) and substitution (S), as termC,F,S . Besides syntactic constructs and \nsubstitution, we occasionally consider the swapping operator, [ . ]: term . var . var . term, where X[x \n. y] is obtained from X by swapping (interchanging) all oc\u00adcurrences of x and y. 2. Two problems of rigorous/formal \nreasoning We next recall two typical situations arising in formal reasoning on syntax with bindings \nsemantic domain interpretation and Higher Order Abstract Syntax (HOAS) representation as motivation \nfor the desire to have convenient (conceptual and formal) tools for recursive de.nitions sensible to \nthe mechanisms of binding and substitution. 2.1 Problem I Interpretation of syntax in semantic domains \nSuppose we want to interpret terms in a semantic domain D (ranged over by d) endowed with operators APP \n: D . D . D and LM :(D . D) . D, by matching the syntactic App and Lm with the semantic APP and LM, mapping \nsyntactic binders to functional binders. For this, we need the collection of valuations (of variables \ninto the domain), val =(var . D), ranged over by .. Then, the de.nition of the interpretation, [ ]: term \n. val . D, needs to proceed recursively on the structure of terms: (1) [x] . = .x, (2) [App XY ] . = \nAPP ([X] .) ([Y ] .), (3) [Lm xX] . = LM (.d : D. [X](.[x . d])), where .[x . d] is the valuation . updated \nat x with d. Moreover, we usually wish to prove the following: -Obliviousness of the interpretation to \nthe variables fresh for the represented term: (4) fresh xX . . = x .' =. [X] . =[X] .', where . = x .', \nread . equals .' everywhere but in x , is de.ned to be .y y. = x. . y = .' -Compositionality of substitution \nw.r.t. environment update, a.k.a. the substitution lemma: (5) [Y [X/x]] . =[Y ](.[x . [X] .]). Parenthesis. \nThe above recursive de.nition and facts to be proved follow a canonical pattern of interpreting syntax \nin denotational semantics and formal logic. To give another well-known example, the semantics of FOL \nformulas . is typically given as a relation M |=. ., read M satis.es . for the valuation . : var . M \n; and the clause for the universal quanti.er, which we denote by All, is the following: M |=. All x. \niff .m . M. M |= .[x.m] .. Despite the different notation, this clause is of the same nature as that \nfor Lm, in that the syntactic variable binding is captured in both cases by a semantic abstraction (functional \nin one case, universal in the other) in conjunction with environment update. Moreover, here (in FOL) \nwe also wish to prove that the interpretation does not depend on the fresh variables and that the substitution \nlemma holds. In fact, most of the basic properties of FOL, including those necessary for the proof of \nthe completeness theorem, rely on these two. The solution discussed below also applies to this FOL example \nand to many others in the same category. End of parenthesis. The problem with the above de.nition of \n[] is that, at the Lm-clause, we have to show the choice of the representatives x and X in Lm xX immaterial. \nIn other words, this clause pro\u00adceeds as if Lm were a free construct on terms, while it is not ' (since \nthere exist x, X, x',X' such that (x, X) =(x,X') and ' Lm xX = Lm xX'). Here is another way to express \nthe prob\u00adlem. Let us call quasi-terms the absolutely free data type gen\u00aderated by the constructors Var, \nApp and Lm, without factoring to a-equivalence. What we called terms are thus quasi-terms fac\u00adtored by \na, i.e., a-classes of quasi-terms. Now, the above is a valid de.nition if regarded on quasi-terms; however, \nto lift this to an op\u00aderator on terms, we need to prove that it preserves a-equivalence. This problem \nis typically by-passed in informal texts, relying on folklore , but needs to be faced and solved within \na formalization. This folklore problem is more challenging than it may look at .rst. We urge the reader \nto try to solve it before reading our solution. (A proof of compatibility with a does not go through \nby induction directly; other auxiliary facts need to be discovered and proved in parallel; and care is \nrequired for the choice of these facts.)  2.2 Problem II Compositional HOAS representation HOAS [22, \n31] prescribes the representation of formal systems of interest, referred to as the object systems, into \na .xed, but customiz\u00adable logical framework, a.k.a. the meta system, by capturing object\u00adlevel features \nsuch as binding mechanisms directly as correspond\u00ading meta-level features. While logical frameworks in \ncurrent use are typically more complex (LF [22], intuitionistic HOL [30], etc.), here we restrict ourselves \nto the .-calculus augmented with con\u00adstants as the logical framework (as in [7, 8, 25]). But our discussion \nalso applies to the above more complex frameworks. To augment the .-calculus with constants, we .x const, \nranged over by c, a set of constants. We extend the syntax of .-calculus with these constants as usual, \nso that the new terms, which we call const-terms and whose set we denote by term(const), are now: either \n(injections of) variables x, or applications App XY , or .-abstractions Lm xX (as before), or injections \nof constants, Ct c. Constants do not participate in bindings and are unaffected by substitution. Just \nlike for variables, we usually omit the constant\u00adinjection Ct, writing c instead of Ct c. We take term(const) \nas our logical framework. (A complete logical framework, of course, also has judgment mechanisms, typ\u00adically \ngiven by a type system in combination with a reduction rela\u00adtion; for instance, in our case, reduction \nmay be \u00df or \u00df.-reduction. Here, we ignore the largely orthogonal judgment aspect of HOAS and consider \nthe syntax representation aspect only.) Say our ob\u00adject system is the .-calculus itself (without constants). \nIts natural HOAS representation into term(const) proceeds as follows: -Instantiate const to a two-element \nset, {APP, LM}, to match the two syntactic constructors App and Lm. (Note that one does not represent \nobject-level variables and their injection into terms ex\u00adplicitly, as they will be captured directly \nby the meta-level items.) -De.ne the representation map rep : term . term({APP, LM}) recursively on the \nstructure of terms: (1) rep x = x; (2) rep(App XY )= App (App APP (rep X)) (rep Y ); (3) rep(Lm xX)= \nApp LM (Lm x (rep X)).  Much of what makes HOAS encodings so convenient is substi\u00adtution compositionality: \n(4) rep(Y [X/x]) = (rep Y )[(rep X)/x], and indeed this is the main fact that is typically proved informally, \nby pen-and-paper , about a HOAS representation. Preservation of freshness is another fact that turns \nout to be useful (see, e.g., [21], page 657), even though this is seldom acknowledged explicitly:  (5) \nfresh xX =. fresh x (rep X). As before, the problem with the de.nition of rep and with the (customary) \ninformal proof of compositionality is the non-rigorous treatment of the Lm-case. 3. Horn-based recursion \nwith built-in substitution In this section, we show that we can regard termC,F,S as an or\u00addinary data \ntype, of the same kind with, say, .nite sets or bags; namely, we can regard it as the initial model of \na suitable Horn the\u00adory. But in order to explain the intuition behind this view, we .rst recall how ordinary \ndata type recursion is standardly obtained and how the initial model of a Horn theory is constructed. \n3.1 Ordinary data types To de.ne a function H (primitively) recursively from an inductive data type, \nsay, IN, to another set A, H : IN . A, one needs to express the behavior of H w.r.t. the number constructors, \n0 and Suc, i.e., write equations of the forms (1) H 0=0A and (2) H (Suc n)= SucA (Hn), where 0A . A and \nSucA : A . A. In other words, one needs to endow A with number-like operations, 0A and SucA, i.e., organize \nA as a model for the signature having a constant symbol, 0, and a unary operation symbol, Suc. The above \nsimple recipe is valid for de.ning functions from an absolutely free data type such as IN. When the constructors \nare not free, simply de.ning on the target domain operations match\u00ading these constructors may not suf.ce \nfor properly de.ning a func\u00adtion. For example, consider the data type Pf (U) of .nite sets with elements \nin a .xed universe U (ranged over by u), with the sin\u00adgleton and the union constructors. To de.ne a function \nH from Pf (U) to aset A, it does not suf.ce to endow A with opera\u00adtions {}A : U . A and .A : A . A . \nA, and state (3) H {x} = {x}A and (4) H (S . T )=(HS) .A (HT ). Indeed, an H satisfying (3) and (4) may \nnot exist. However, we know that Pf (U) is a data type speci.able by equations: if we start with for\u00admal \nexpressions E given by the grammar E ::= {u}| E1 . E2 (where {} and . do not have any set-theoretic meaning, \nbut are just free constructors) and then factor these expressions by all equalities deducible from associativity, \ncommutativity and idem\u00adpotence (ACI), we obtain a data type isomorphic to Pf (U). A use\u00adful consequence \nof this is that the clauses (3) and (4) do yield a valid de.nition of a function H provided the ACI properties \nhold for {}A. (In other words, Pf (U) is the initial ACI model.) In this sense, Pf (U) is an ordinary \ndata type, i.e., one freely generated by some constructors modulo some equations.  3.2 Terms as an ordinary \ndata type So is termC,F,S also ordinary ? To answer this question, we .rst remark that, due to the freshness \noperator, which is better regarded as a relation, we need to slightly relax our notion of ordinary data \ntype, accepting not only operations, but also relations, and not only equations, but more generally Horn \nclauses fortunately, this relaxation is unproblematic (w.r.t. our goal of obtaining a recursion principle), \nsince Horn theories also admit initial models. Next, we recall the way in which the initial model of \na given Horn theory H is constructed: start, as before, with formal ex\u00adpressions built using the involved \noperation symbols, and then pro\u00adceed to de.ne the equality relation (by which one will need to fac\u00adtor \nto obtain the end-product type) as well as the other relations (corresponding to the relation symbols) \nminimally, as containing just what can be inferred from H; therefore, the construction of the initial \nHorn model proceeds as if de.ning equality and all the relations mutually recursively. By contrast, term \nequality, i.e., a\u00adequivalence, and substitution (main components of termC,F,S ) are traditionally de.ned \nin a rather cumbersome manner: .rst substitu\u00adtion is de.ned on quasi-terms (i.e., raw terms, not yet \nfactored to a) via an auxiliary pick fresh operator, then a is de.ned using substitution (or sometimes \nswapping) on quasi-terms, and .nally substitution is shown to not depend on the choice made by pick fresh \nand to be compatible with a. Such traditional de.nitions are hardly exciting as a basis for a useful \nHorn speci.cation (hence a useful recursion principle), due to the immaterial presence of pick fresh \n. Therefore, our original question becomes: can we have simple (yet complete) mutually recursive de.nitions \nof a-equivalence, freshness and substitution? It turns out the answer is positive,1 if we renounce the \nambition of having substitution fully speci.ed on quasi-terms. Namely, in the Lm-case, when variable \ncapture occurs, instead of eagerly picking fresh in order for substitution to go under Lm, as in (Lm \nxX)[Z/z]= Lm x ' (X[x ' /x][Z/z]) where x ' = pickFresh {z, Z} (as is customarily done), we choose to \nlazily de.ne substitution only when interaction with Lm is smooth, namely, x = z . fresh xZ =. (Lm xX)[Z/z]= \nLm x (X[Z/z]); for the rest of the cases, an a-renaming clause, x = y . fresh yX =. Lm y (X[y/x]) = Lm \nxX, will eventually make way for substitution under Lm. (The latter two clauses are re.ected in the de.nition \nof FSb-models below, as S4 and A.) These observations lead to a simple Horn characterization of termC,F,S \nand to a corresponding recursion principle; the latter states that, given a model of this Horn theory, \nthere exists a (unique) constructor-, freshness-and substitution-compositional map from the term model \nto it. We think of such models as containing gener\u00adalized terms, i.e., items with term-like operations \non them (which we later refer to as generalized constructor, freshness and sub\u00adstitution operators) satisfying \nterm-like properties (Horn clauses) hence the pre.x g in the notations below. A fresh-substitution-model \n(FSb-model) consists of a set A (ranged over by gX, gY, gZ) together with operations and relation gVar \n: var . A, gApp : A . A . A, gLm : var . A . A, [ / ]g : A . A . var . A, gFresh : var . A . bool, satisfying \nthe following properties: F1: x = z =. gFresh z (gVar x), F2: gFresh z gX . gFresh z gY =. gFresh z (gApp \ngX gY), F3: gFresh z (gLm z gX), F4: gFresh z gX =. gFresh z (gLm x gX), S1: (gVar z)[gZ/z]g = gZ, S2: \nx = z =. (gVar x)[gZ/z]g = gVar x, S3: (gApp gX gY)[gZ/z]g = gApp (gX[gZ/z]g)(gY[gZ/z]g), S4: x =z.gFresh \nx gZ =.(gLm x gX)[gZ/z]g = gLm x (gX[gZ/z]g), A: x = y . gFresh y gX =. gLm y (gX[(gVar y)/x]g)= gLm \nx gX. Note that, indeed, the above properties, F1-F4, S1-S4 and A, form an (in.nitary) Horn theory H \nover the .rst-order language having: -a binary operation symbol for application; -for each variable x: \n a constant symbol for the x-injection as a term,  a unary operation symbol for .x-abstraction,  a \nbinary operation symbol for substitution for x,  a binary relation symbol for freshness of x. (Note \nthat negative conditions such as x = z are not part of the H clauses, but are meta-level conditions \nthus, e.g., F1 represents an in.nite collection of Horn clauses, one for each pair of variables (x, z) \nwith x = z.)  1 Interestingly, the answer becomes negative if we remove any of the three this is further \nevidence for the suitability of taking freshness and substitu\u00adtion as built-ins in the syntax.  Terms \nform of course a model of H, since the latter consists of well-known properties of terms;2 and the next \ntheorem says this model is initial in H: THEOREM 1. Let A be an FSb-model. Then there exists a unique \nmap H : term . A commuting with the constructors, i.e.: (a) Hx = gVar x, (b) H (App XY )= gApp (HX)(HY \n), (c) H (Lm xX)= gLm x (HX). Additionally, H commutes with substitution and preserves fresh\u00adness, i.e.: \n(d) H (Y [X/x]) = (HY )[(HX)/x]g, (e) fresh xX =. gFresh x (HX). Proof sketch. Existence: First, note \nthat, if H : term . A is an (Var, App, Lm)-morphism, i.e., if it commutes with the indicated three operators, \nthen it also commutes with substitution and pre\u00adserves freshness. This can be proved by induction on \nterms, using F1-F4, S1-S4, and the fact that term itself satis.es the correspond\u00ading clauses. This fact \nallows us to focus on the simpler task of .nd\u00ading a (Var, App, Lm)-morphism between term and A. Next, \nrecall that term consists of terms up to a i.e., of a\u00adequivalence classes. We call quasi-terms the items \nnot yet fac\u00adtored by a and let qVar, qApp, qLm, qFresh and [ . ]q be the corresponding operarors (variable \ninjection, application, abstrac\u00adtion, and swapping) on quasi-terms. Let F : qTerm . A be the unique (Var, \nApp, Lm)-morphism given by the absolute initiality of qTerm. I.e., F is de.ned by standard recursion: \n-F (qVar x)= gVar x; -F (qApp PQ)= gApp (FP )(FQ); -F (qLm xP )= gLm x (FP ). Using F1-F4, one can show \nby induction on quasi-terms that F preserves freshness, namely: (1) qFresh xP =. gFresh x (FP ). Next, \nusing (1), S1-S4, F1-F4 and A, one can show by induction on quasi-terms that, under an appropriate freshness \nassumption, F commutes with swapping versus substitution, namely: (2) qFresh y1 P =. F (P [y1 . y]q)=(FP \n)[(gVar y1)/y]g. (Above, considering swapping on the left-hand side of the equality is much more convenient \nthan considering variable-for-variable substitution, as the latter is not well-behaved on quasi-terms.) \nNext, using (1), (2), S1-S4, F1-F4 and A, one can show by induction on quasi-terms that F respects a-equivalence, \ni.e., (3) P .a Q implies FP = FQ. Finally, (3), together with the de.nitional clauses of F and the fact \nthat a is a congruence on quasi-terms imply standardly (by the universal property of quotient FOL models) \nthe existence of a (Var, App, Lm)-morphism H : term . A, as desired. Uniqueness: By an easy induction \non terms. D We call a map H as in Thm. 1 an FSb-morphism. Thus, Thm. 1 provides the following recursion \nprinciple: if one de.nes an FSb\u00admodel on the desired target domain (and thus discharges the re\u00adsulted \nproof obligations, namely, F1-F4, S-S4 and A), then one ob\u00adtains a compositional map between terms and \nthe target domain, i.e., an FSb-morphism. Note that the particular implementation of this FSb-morphism \nis completely irrelevant (and is hidden in the proof of Thm. 1), since its abstract properties (a)-(c) \ncharac\u00adterize it uniquely, and, together with (d) and (e), form a convenient basis for working with it. \nWe are now ready to present the promised solutions to the problems from Section 2.  3.3 Solution to \nProblem I We let A, the set of semantic values, ranged over by s, t, be val . D. We organize A as an \nFSb-model. The desired recursive 2 Note also that clauses S1-S4 coincide with the usual Nominal Logic \nde.nition of substitution, which also exploits the aforementioned idea of lazy clauses, however not with \nthe purpose of obtaining a substitution\u00adcompositional recursor as we do here see also Section 8. equations \nfrom Section 2 leave us no choice about the generalized constructor operators on A: -gVar x = ... . x; \n-gApp st = ... APP (s.)(t.); -gLm xs = ... LM (.d. s (.[x . d])). Moreover, the desired freshness obliviousness \nproperty imposes that generalized freshness on A be at least as strong as the follow\u00ading relation, and \nwe choose to de.ne it as precisely this relation: gFresh xs =(.., . ' .. = x . ' =. s. = s. ' ). Finally, \nthe desired substitution compositionality leaves us no choice about the de.nition of generalized substitution \non A: s[t/x]g = ... s (.[x . t.]). Thus, saying that the clauses and desired facts listed in Section \n2 hold is the same as saying that the map [] is an FSb-morphism. For instance, substitution compositionality, \ni.e., .xY X.. [Y [X/x]] . =[Y ](.[x . [X] .]) means .xY X. [Y [X/x]] = . .. [Y ](.[x . [X] .]), which \nmeans .xY X. [Y [X/x]] = [Y ] [[X]/x]g, which means: [] commutes with substitution. According to Thm. \n1, what remains to do in order to have Problem I resolved is checking that A with the above structure \nis indeed an FSb-model, i.e., satis.es the clauses F1-F4, S1-S4 and A. It turns out that here, as well \nas in most of the examples we consider later, checking these facts is trivial (and usually automatically \ndischarged in Isabelle see Section 6). For instance, the most complex of them, A, here requires that \n. .1 .2..1 = y .2 =. s.1 = s.2 implies s(.[y . d][x . d]) = s(.[x . d]), which can be discharged immediately. \n 3.4 Solution to Problem II We take A to be term({APP, LM}) (the set of .-terms with two constants). \nWe organize A as an FSb-model. Again, the generalized constructor operators, the weakest notion of freshness, \nand the generalized substitution on A are all pre\u00addetermined by the desired recursive equations: (1) \ngVar x = x; (2) gApp XY = App (App APP X) Y ; (3) gLm xX = App LM (Lm xX); (4) [ / ]g =[ / ]; (5) gFresh \n= fresh.  Notice that gApp and gLm are different from App and Lm, while, to the contrary, gFresh and \n[ / ]g are just regular freshness and substitution indeed, a main point of HOAS is the reuse of substitution. \nAgain, it is immediate to check that A is an FSb\u00admodel, yielding, by Thm. 1, the existence of a map rep \n: term . term({APP, LM}) satisfying the desired recursive equations and in addition preserving freshness \nand substitution.  3.5 Bottom line to our solutions There are two advantages in employing the described \nrecursors in\u00adstead of directly attempting a representative-independent de.nition (perhaps proved to be \nso, dynamically, at de.nition-time): (I) clear a priori picture of what needs to be proved; (II) extra \nbuilt-in com\u00adpositionality results. 4. More examples Our Horn-based principle is surprisingly general. \nWe could not .nd in the literature any example of a syntactic map supposed to feature compositionality \n(of some kind) w.r.t. substitution and not falling in the scope of this principle. In this section we \ngive more examples. As seen in the solutions for Problems I and II, listing all the desired clauses \nthose for the term constructors, the weakest one for freshness, and the one for substitution determines \na model. Therefore, when discussing the next examples, we only spell out the clauses, leaving implicit \nthe construction of the corresponding model.  4.1 The number of free occurrences of a variable in a \nterm Given a variable z, the intended de.nitional clauses of the map no z : term . IN , taking any term \nX to the number of free occurrences of z in X, are the following: -no z x = if x = z then 1 else 0; -no \nz(App XY )=(no z X)+(no z Y ); -no z(Lm xX)= if x = z then 0 else no z X. To make them into a rigorous \nde.nition, we need to ask: what is the desired/necessary relationship between no z and freshness on one \nhand and no z and substitution on the other. (In fact, an employment of this map in larger developments \nwould typically need to ask these questions anyway.) The answer to the the .rst question is the simpler \none: z -fresh zX =. no X =0. To the substitution question however, we cannot answer for a .xed z, but \nneed to consider all no z s at the same time, obtaining: o z (noy X) * (no z Y ), if y = z -no (X[Y/y]) \n= z yz (no X)+(noX) * (no Y ), otherwise This of course suggests considering the simultaneous version \nof the map, no : term . (var . IN), where no Xz now denotes what used to be no z X. We obtain: -no xz \n= if x = z then 1 else 0; -no (App XY ) z =(no Xz)+(no Yz); -no (Lm xX) z = if x = z then 0 else no Xz. \n-fresh zX =. no Xz =0; o (no Xy) * (no Yz), if y = z -no (X[Y/y]) z = (no Xz)+(no Xy) * (no Yz), otherwise, \nwhich do work as a de.nition of no by our method, in that our method yields the existence of a (unique) \nfunction no such that the above 5 facts hold. (Discharging the resulted proof goals is trivial arithmetic.) \n 4.2 CPS transformation Consider the task of de.ning the call-by-value to call-by-name continuation passing-style \n(CPS) transformation discussed in [34] in the context of .-calculus. The transformation goes recursively \nby the following clauses on the syntax of terms: -cps x = Lm k (App kx), for some k = x; -cps(Lm xX)= \nLm k (App k (Lm x (cps X))), for fresh k . var; -cps (App XY )= Lm k (App (cps X) (Lm x (App (cps Y \n) (Lm y (App (App xy) k))))), for fresh distinct variables k, x, y. (Above, the most speci.c clause is \nthe one for App, which fol\u00adlows the usual sequential interpretation of CPS. Namely, let X ' and Y ' be \ncps X and cps Y , i.e., the CPS-transformed versions of X and Y . Then, given any continuation k, cps \n(App XY ) is evaluated as follows: -X ' is evaluated and the result is passed, as x, to the continuation \nstarting with Lm x , -which in turn evaluates Y ' and passes the result, as y, to the con\u00adtinuation starting \nwith Lm y , -which in turn evaluates App xy and .nally passes the result to the original continuation, \nk. Consequently, call-by-value behavior is achieved with call-by\u00adname mechanisms.) As before, the problem \nis making the above de.nition rigor\u00adous. Now, trying to approach this directly using our Horn machin\u00adery \nfor the term syntax does not work for the following reason: the desired transformation does not commute \nwith arbitrary sub\u00adstitution, but only with substitution of values for variables, where a value is a \nterm which is either a variable or a Lm-abstraction. I.e., as shown in [34] (Lemma 1 on page 149), cps \n(X[Yvl/y]) = (cps X) [(cps Yvl)/y] does hold for all values Yvl, but not for ar\u00adbitrary terms. Interestingly, \nthe solution lays here in recognizing the proper granularity of the syntax suggested above. Indeed, the \naforementioned restricted substitution compositionality, as well as all the rest of the call-by-value \ntheory developed in [34], requires that, under call-by-value, the syntactic categories emphasize value \nterms. Namely, we are better off if we work with the following vari\u00adation of term, split in two syntactic \ncategories: term., of full terms, ranged over by X, Y , and termvl, of value terms, (or, simply, val\u00adues), \nranged over by Xvl, Yvl, de.ned mutually recursively by: X ::= InVl Xvl | App XY Xvl ::= x | Lm xX Thus, \n(term., termvl) is term with values singled out as a sep\u00adarate category (InVl being the injection of \nvalues into full terms). Here, only substitution of values for variables makes sense, in\u00adstitutionalizing \nthe following semantic remark from [34] on page 135: free variables should be thought of as ranging over \nvalues and not arbitrary terms . In this two-sorted context, the corresponding version of our recursion \nprinciple does the job of de.ning the mu\u00adtually recursive maps cps : term. . term and cpsvl : termvl \n. term, together with the (proved) statements of their freshness and substitution preservation, by the \nclauses: (1) cpsvl x = x; (2) cpsvl (Lm xX)= Lm x (cps X); (3) cps(InVl Xvl)= Lm k (App k (cpsvl Xvl)), \nfor a fresh k . var;  (4) cps(App XY )= (same as before) (5) fresh yX =. fresh y (cps X); (6) fresh \ny Xvl =. fresh y (cpsvl Xvl);  (7) cpsvl (Xvl [Yvl/y]) = (cpsvl Xvl) [(cpsvl Yvl)/y]; (8) cps (X[Yvl/y]) \n= (cps X) [(cps Yvl)/y].  Note that the originally intended behavior for variables and Lm\u00adabstractions \nnow follows by inlining cpsvl, for InVl-wrapped values: (a) cps (InVl x)= Lm k (App kx); (b) cps (InVl \n(Lm xX)) = Lm k (App k (Lm x (cps X))). Checking the clauses necessary for the de.nition to work (i.e., \nthe clauses de.ning FSb-models for the considered two-sorted syn\u00adtax (term., termvl)) is again routine, \nprovided several basic prop\u00aderties of freshness and substitution are available. There is of course the \nquestion whether it is worth storing call-by-value .-calculus in a different data type from standard \n.-calculus, or should one rather de.ne values inside standard .-calculus and work with these. This is \nan engineering, not a mathematical question. But if one opts for a different data type, then the isomorphism \nbetween term. and term is yet another (trivial) application of our recursion principle. 4.3 Other examples \nThese include the classic de Bruijn interpretation map from [12], the CPS transformation in the opposite \ndirection (from call-by\u00adname to call-by-value) from [34] and the translation of the LF syntax into untyped \n.-calculus (meant to be subsequently Curry\u00adstyle typed) employed in the proof of strong normalization \nfor the LF reduction [22]. The reader is invited to try our method on his/her own examples pertaining \nto syntax with bindings again, we believe it is very likely to work provided a substitution lemma of \nsome kind is in sight.  4.4 Non-examples Of course, not everything one wants to de.ne is compositional \nw.r.t. substitution. Such cases fall out of the scope of our de.nitional principle. These include, e.g., \nthe depth operator an immediate symptom showing why our principle cannot handle this example is the \nfact that we cannot compute the depth of X[Y/y] based on the depths of X and Y ; in other words, we cannot \nanswer the substitu\u00adtion question. So this example is problematic because it is, in some sense, syntactically \nunder-speci.ed, as it ignores substitution. An example problematic because of a somewhat opposite reason \nis the so-called complete development, cdev : term . term, introduced in [41] as a means to simplify \nthe proof of the Church-Rosser the\u00adorem (and of other results):  (1) cdev x = x; (2) cdev (Lm xX)= Lm \nx (cdev X); (3) cdev (App XY )= App (cdev X)(cdev Y ), if App XY is not a \u00df-redex (i.e., if X does not \nhave the form Lm yZ); (3 ) cdev (App (Lm yX) Y )=(cdev X)[(cdev Y )/y]. cdev reduces all the (arbitrarily-nested) \n\u00df-redexes in a term. It does not commute with substitution, mainly because it is not a purely syntactic \nmap, but includes some operational semantics . Note however that, even if the codomain consists of terms, \nour method does not require that substitution on the domain of terms be mapped to standard substitution \non the codomain, but to any well\u00adbehaved notion of generalized substitution . We therefore could de.ne \na non-standard substitution (on standard terms) that will eventually yield preservation of substitution, \nbut this would be un\u00adnecessarily complicated and arti.cial. Our principle is not intended to have its \nusers work hard to have their de.nitions go through; rather, it is aimed at situations where the issues \nof preservation of freshness and substitution appear naturally as further desired prop\u00aderties. In our \nformalization, we have incorporated a work-around that handles the cdev operator by a variation of our \napproach that renounces the substitution compositionality goal, replacing it with the less ambitious \none of swapping compositionality (see Appendix A). 5. Pushing the Horn approach even further Besides \nhaving the up to a de.nitions go through, our Horn ap\u00adproach infers some extra information about the \nde.ned maps: com\u00adpositionality w.r.t. freshness and substitution. Can we infer even more? The answer \nis: yes, if we prove more facts about the con\u00adstructed model. Next we state criteria for three commonly \nencoun\u00adtered properties: freshness re.ection, injectiveness, surjectiveness. An FSb-model is said to \nbe: -fresh-reversing, if the following facts (converse to F1-F4 from Section 3), hold for it: (a) gFresh \nz (gVar x)=. x = z, (b) gFresh z (gApp gX gY)=. (gFresh z gX . gFresh z gY), (c) gFresh z (gLm x gX)=. \n(z = x . gFresh z gX);  -constructor-injective, if its constructor operators are mutually injective, \ni.e.: (a) gVar x, gApp XY and gLm zZ are mutually distinct; (b) gVar, gApp (regarded as an uncurried \nbinary operation) and gLm x are injective; -inductive, if the following induction principle is true: \nfor all predicates ., .gX.. gX holds provided the following hold: (a) .x. . (gVar x), (b) . gX gY.. gX \n. . gY =. . (gApp gX gY), (c) . x gX.. gX =. . (gLm x gX). The next theorem follows easily by structural \ninduction on terms: THEOREM 2. Let A be an FSb-model and let H be the map from Thm. 1. Then, if A is \nfresh-reversing (construct-injective, induc\u00adtive), then H is, respectively, fresh-re.ecting (injective, \nsurjective), where fresh-re.ecting means: fresh x (HX)=. fresh xX. The above result integrates even more \nfacts as built-ins of the recursive de.nition. E.g.: the HOAS operator from Section 2 is freshness-re.ective \nand injective; the number of free occurrences operator from Section 4.1 is freshness-re.ecting; the CPS \noperator from Section 4.2 is freshness-re.ective and injective. Putting to\u00adgether these 3 criteria, we \nobtain the following characterization: THEOREM 3. If an FSb-model A is fresh-reversing, constructor\u00adinjective \nand inductive, then the map H from Thm. 1 is an iso\u00admorphism of FSb-models (where isomorphism of FSb-models \nis the usual notion from .rst-order model theory, namely: bijection preserving the constructors and substitution \nand preserving and re\u00ad.ecting freshness ). This characterization of the term model is internal, in that \nit does not rely on things from outside the model itself (such as morphisms and other models), as does \nthe characterization as initial Horn model. Although such an internal characterization is not the .rst \none from the literature (see, e.g., [19], [28]), it appears to be the .rst expressed in terms of essential \ningredients only syntactic constructors, freshness and substitution and also the .rst to be formalized \nand put to use (see Section 7). 6. Isabelle formalization Above, we have presented our results for the \nsyntax of .-calculus terms. However, one can see that similar results hold for any other (possibly multiple-sorted) \nsyntax with bindings, such as, e.g., that of LF [22]. For the sake of generality and reusability, we \nchose to formalize these results parameterizing by an arbitrary binding signature, within a theory of \nsyntax consisting of: -a wide collection of basic facts on freshness, substitution and swapping; -customized \ninduction principles, including fresh induction in the style of [32, 45]; -customized recursion principles \n(the topic of this paper). Moreover, we have formalized all the examples discussed in this paper, in \ntheir particular syntaxes instantiated from the aforemen\u00adtioned general theory. We have also employed \nthese examples in larger development, notably the formalization of a large part of Plotkin s classic \npaper [34]. A detailed presentation of our formal development, available at [4], falls outside the scope \nof this paper (but the appendix offers a few details for the interested reader). Here, we illustrate \nour approach by presenting the Isabelle formalization of Problem II from Sections 2.2 and 3.4 (contained \nin theory HOAS from [4]). In order to relate the formal scripts described below to the mathematical notations \nfrom Sections 2.1 and 3.4, we note the following: -(1) Unlike in the paper, in the formalization we distinguish \nterms from abstractions, an abstraction being essentially a pair (vari\u00adable,term) up to a. We write Abs \nfor the abstraction constructor (taking a variable and a term and returning an abstraction). In this \nsetting, a binding operator such as . no longer takes a variable and a term, but takes an abstraction \n(and returns a term); we write Lam for this operator. (Thus, our operator Lm from the paper can be obtained \nas Lm xX = Lam (Abs xX); the latter is actually de\u00ad.ned as an abbreviation in our scripts.) This setting \nis re.ected in the notion of an FSb-model too, where we have both generalized terms and generalized abstractions \n(and corresponding gener\u00adalized operators ). -(2) In the formalization we use a more general notion of \nFSb\u00admodel than in the paper, supporting not merely iteration, but full (primitive) recursion. This is \nre.ected in the presence of extra ar\u00adguments for the model operations, which take not only general\u00adized \nterms (corresponding to the recursively computed result), but also genuine syntactic terms (corresponding \nto the original input at recursion time). -(3) In the formalization, the problem setting is itself slightly \nmore general than that in the paper. Namely, let us write term(const) for the syntax of the .-calculus \nover a set of constants const. Then the object syntax is term(const), and the meta syntax is term(metaConst), \nwhere the set metaConst, of meta-constants, consists of copies Const c of elements c . const and of the \nnew constants APP and LM. We use the pre.xes Obj and Meta for operators pertaining to the object syntax \nand to the meta syntax, respectively. Moreover, we write [ /o ] and [ /m ] for the object level and meta \nlevel substitutions, respectively. The Isabelle de.nition of the desired FSb-model, called rep MOD, is \nthe following:  definition rep_MOD :: ( const, const metaConst term, const metaConst abs)model where \nrep_MOD == gVar_vlm = Meta_Var, gAbs_lm_lm = . y X mX. Meta_Abs y mX, gCt = . c. Meta.Ct (Const c), \ngApp = . X mX Y mY. Meta.App (Meta.App (Meta.Ct APP) mX) mY, gLam = . A mA. Meta.App (Meta.Ct LM) (Meta.Lam \nmA), gFresh_vlm_lm = . y X mX. Meta_fresh y mX, gFresh_vlm_lm_lm = . y A mA. Meta_freshAbs y mA, gSubst_vlm_lm \n= . Y mYy XmX.mX[mY /my], gSubst_vlm_lm_lm = . Y mY y A mA. mA [mY /m y] Above, the type of rep MOD (on \nthe .rst 2 lines) is the record type of (FSb-)models for the term(const) syntax , hence the .rst parameter \nconst; the other two parameters from this type represent the carriers of the model, which are the meta-terms \nand meta\u00adabstractions. Then there are de.ned the record components, i.e., the generalized operators on \nthe model X, Y and A range over object terms and abstractions, and mX, mY and mA over meta terms and \nabstractions. The lm and vlm suf.xes from the operators names are a reminiscence of our many-sorted setting: \nthey refer to the only variable sort (vlm) and term sort (lm) for the syntax term(const). Modulo these \nexplanations, the reader should now recognize the de.nition from our resolution of Problem II in Section \n3.4. E.g., the above de.nition of gAbs lm lm corresponds to the HOAS-speci.c recursive clause repAbs \n(Obj.Abs xX)= Meta.Abs x (rep X), where rep denotes, as in Sections 2.1 and 3.4, the representation map \non terms, and repAbs is its abstraction counterpart. For each of the Isabelle lemmas listed below, after \nthe keyword lemma comes the name of the lemma, followed by a colon, followed by the stated fact in double \nquotes. We omit their formal proofs. (Each of the proofs has at most 2 lines and proceeds by merely unfolding \nde.nitions and calling the automatic simpli.er tool.) Once the model has been de.ned, we need to check \nthat it is indeed a well-structured FSb-model (expressed as the Isabelle predicate wlsFSb), i.e., that \nit satis.es the involved clauses for freshness and substitution (F1-F4, S1-S4 and A) in this case, these \ngoals are discharged automatically: lemma wlsFSb_rep_MOD: \"wlsFSb rep_MOD\" This is all we needed to check \nto have our recursive de.nition go through. However, we wish to infer some further facts for our morphism, \nin this case freshness re.ection and injectiveness. For these, the .rst 2 points of Thm. 2 tell us that \nit suf.ces that the reversed fresh clauses hold (expressed by the Isabelle predicate gFresh cls rev) \nand that the generalized constructors be injective (expressed by the Isabelle predicate gCons inj). The \nlatter facts can again be proved automatically: lemma gFresh_cls_rev_rep_MOD:\"gFresh_cls_rev rep_MOD\" \nlemma gCons_inj_rep_MOD: \"gCons_inj rep_MOD\" This concludes the creative part of the HOAS development. \nThe rest is bureaucracy , and goes the same way for all recursive de.nitions, as it relies on our general \ntheory. Parenthesis: Our Isabelle formalization of the recursion theorem Thm. 1 takes advantage of the \nHilbert choice operator, building the constant rec lm out of the exists unique statement from Thm. 1 \n(and the corresponding constant rec lm lm for abstractions) i.e., given any FSb-model M, rec lm M and \nrec lm lm M cor\u00adrespond to the function H from Thm. 1. Then theorem wlsFSb rec term FSb morph , which \nis the Isabelle version of Thm. 1, says that, if M is an FSb-model, then rec lm M and rec lm lm M form \nan FSb-morphism from terms to M . (All these are presented and illustrated in detail in the commented \ntheory L from [4].) Back to the HOAS development, we let rep and repAbs de\u00adnote the recursive functions \nassociated to the particular model rep MOD, thus mapping object terms and abstractions to meta terms \nand abstractions: definitions rep where \"rep X = rec_lm rep_MOD X\" and repAbs where \"repAbs A = rec_lm_lm \nrep_MOD A\" We now apply the aforementioned recursion theorem, wlsFSb rec term FSb morph , obtaining that \n(rep, repAbs) is an FSb-morphism: lemma term_FSb_morph_rep: \"term_FSb_morph rep repAbs rep_MOD\" Unfolding \nde.nitions, we see the morphism property in familiar format (similar to the one from Section 2.2): lemma \nrep_simps: \"rep (Obj_Var x) = Meta_Var x\" \"rep (Obj.Ct c) = Meta.Ct (Const c)\" \"rep (Obj.App X Y) = \nMeta.App (Meta.App (Meta.Ct APP) (rep X)) (rep Y)\" \"rep (Obj_Lm y X) = Meta.App (Meta.Ct LM) (Meta_Lm \ny (rep X))\" lemma rep_subst: \"rep (X [Y /o y]) = (rep X) [(rep Y) /m y]\" lemma rep_preserves_fresh: \n\"Obj_fresh y X ==> Meta_fresh y (rep X)\" Thus, Lemmas rep simps, rep subst and rep preserves fresh correspond \nto clauses (1)-(3), (4), and (5), respectively, from Sec\u00adtion 2.2. Additionally, we use (the Isabelle \nformalization of) the .rst 2 points of Thm. 2, to infer that this morphism is additionally freshness \nre.ecting and injective: lemma refl_freshAll_rep: \"refl_freshAll rep repAbs rep_MOD\" lemma is_injAll_rep: \n\"is_injAll rep repAbs\" And again, by unfolding de.nitions, we obtain more readable versions of these \nresults: lemma rep_reflects_fresh: \"Meta_fresh y (rep X) ==> Obj_fresh y X\" lemma rep_inj: \"(repX =repY) \n=(X=Y)\" This concludes the de.nition of the HOAS representation map and the proof of its syntactic adequacy. \nNotice the high degree of automation of the development, as the proof goals generated by the FSb-model \nrequirement are automatically discharged this is the case for most applications of Thm. 1 and Thm. 2 \nthroughout our formal development. 7. Certifying and relating formalizations of terms The literature \non .-calculus theory and theorem proving abounds in approaches to representing syntax with bindings, \nsuch as a-classes, de Bruijn levels [13], de Bruijn indexes [13], locally nameless [8, 9, 18, 19], locally \nnamed [35, 38], proper weak-HOAS functions [14, 20], partial functions [42] (to list only a few; see \n[29] for an overview of several of these and others). These representations have various merits: of being \nmore ef\u00ad.cient, more insightful w.r.t. de.nition and proof principles, etc.  However, all these approaches \nare aimed at capturing the same Platonic notion of syntax. So what makes them correct? Typically, work \nproposing such a new implementation/representation justi.es its correctness by showing it isomorphic \nto a more standard repre\u00adsentation, or to one that has been used many times and has a high degree of \ntrustability. E.g., in [42], the new partial-function based representation of .-terms from the Nominal \npackage is proved iso\u00admorphic to the a-class-based one; in [35], the locally named repre\u00adsentation is \nproved isomorphic to the nominal representation. Our Thm. 3 provides a common formal basis for establishing \nsuch isomorphisms, and, in general, for proving a novel repre\u00adsentation to be correct, namely, by showing \nthat it forms a fresh\u00adreversing, constructor-injective and inductive FSb-model (as the latter notion \nis unique up to fresh [preserving and re.ecting] and substitution preserving isomorphism). Following \nthis methodology, we have established in Isabelle formal isomorphisms between our representation and \neach of the following: -(1) the Nominal representation [42]; -(2) the locally nameless representation \nunderlying the Hybrid sys\u00adtem [8, 15, 24, 25]; -(3) the locally named representation [35, 38]. (1) The \nconnection with Nominal is formalized in the theory C Nominal from [4]. We connect the .-terms from the \ntheory Lam funs (located in the Nominal directory in the Isabelle dis\u00adtribution) with our pure .-terms. \nThe latter are .-terms without constants, de.ned in our theory Pure. (We use pure terms here, since the \nterms in the aforementioned Nominal theory happen to not include constants.) First, we establish a bijection \ntoNA, read to Nominal atom between our variables and the Nominal atoms, called names here this is immediate, \nsince both collections are countable. Then we proceed to organize the Nominal terms as an FSb-model with \nthe required additional properties, yielding an iso\u00admorphism toN, read to Nominal , between our pure \nterms and their terms. Checking the facts necessary for obtaining this iso\u00admorphism was immediate, given \nthat Lam funs and the underly\u00ading Nominal package provide a rich pool of basic facts. To give an example \nof the potential usefulness of the above isomorphism, for both parties: -our rich theory of substitution \nis now available for this Nominal theory;3 -advanced Nominal techniques pertaining to rule induction \nare now available in our .-calculus theory. (2) For the connection with the Hybrid terms, we imported \nthe theory Expr from the Hybrid scripts (http://hybrid.dsi.unimi.it). On top of Expr, Hybrid has several \nother HOAS layers however, we were only interested in this very basic implementation layer. The connection, \ndeveloped in our theory C Hybrid (from [4]), took a little more work, given that the Hybrid representation \nis HOAS\u00adoriented, hence it lacks a .rst-order binding operator, which we had to add ourselves. Then the \nHybrid terms were organized as an FSb\u00admodel, yielding an isomorphism between our terms with constants \nand their terms with constants. (3) The locally named representation from [35] is based on a distinction \nbetween parameters (or global variables), and (local) variables, only the latter being allowed (and required) \nto be bound. As mentioned, this representation has already been proved isomor\u00adphic to the Nominal one \ndiscussed above, by de.ning a relation and showing it to be total and deterministic, yielding a function \n note that a main motivation of our approach is to avoid the round\u00adabout route of de.ning a function \n.rst as a relation. The connection  3 Substitution is of course de.nable with the Nominal package, but \nits many relevant properties of interaction with the other operators, including, e.g., the very recursion \nprinciples proposed in this paper, do not come with this de.nition, but would need to be established \nindividually. is developed in our theory C Sato Pollack from [4] (named after the two authors of the \napproach), importing a couple of theories from the scripts associated to the paper [35], available from \nthe .rst author s home page: http://homepages.inf.ed.ac.uk/rpollack. Simi\u00adlarly to before, we de.ne a \nbijection toP between our variables and their parameters, and then organize their terms as an FSb-model, \nyielding an isomorphism between our pure terms and their terms. 8. Conclusions and related work Next \nwe discuss other approaches to the main contribution of this paper convenient recursion principles for \nterms with bindings. (See Section 2.10 in [36] for much more details.) Nominal Logic is originally a \nnon-standard logic, parameterized by various categories of atoms (a.k.a. names, or variables); there \nare built-in notions of swapping (primitive) and freshness of an atom for an object (derived) and an \nunderlying assumption of .nite support, essentially saying that, for each object, all but a .nite number \nof atoms are fresh for it; all the expressible predicates have a property called equivariance (invariance \nunder swapping). This non-standard logic is discussed, e.g., in [17]. However, the nominal approach can \nalso be developed in a standard logic such as classic HOL, as shown by the Isabelle/HOL Nominal Package \n[42, 43, 45]. The Nominal recursor [33, 42] on terms with bindings employs the syntactic constructors \nVar, App and Lm, as well as a notion of permutation swapping. All the operators involved in the recursive \nclauses in a presumptive de.nition with target domain A (assumed to have a permutation swapping operator \non it), in our notation gVar : var . A, gApp : term . A . term . A . A and gLm : var . term . A . A, \nare required to have .\u00adnite support. Moreover, a technical condition, Freshness Condition for Binders \n(FCB) (a form of freshness preservation for gLm), is required to hold. Under the above conditions, one \nobtains an op\u00aderator H : term . A which is almost a morphism w.r.t. the syntactic constructors, in that \nit commutes with Var and App in the usual sense and commutes with Lm for fresh names only, namely: H \n(Lm xX)= gLm xX (HX) provided gFresh x gVar, gFresh x gApp and gFresh x gLm hold. Compared to our main \nsubstitution-based recursion combina\u00adtor (henceforth abbreviated SRC), the above Nominal recursion combinator \n(henceforth abbreviated NRC) has the advantage of uniformity and economy of structure (only swapping \nis primitive, and everything is based on it). Moreover, the consideration of the aforementioned almost \nmorphisms as targets of de.nitions, w.r.t. which freshness for parameters may be assumed, provides extra \ngenerality to the NRC. On the other hand, the conditions that SRC requires to be checked by the user \nare simpler than those required by NRC, the latter involving a certain quanti.er complexity, no\u00adtably \nwhen considering the support of functions (although, like ours, often these conditions can be checked \nautomatically, as shown by the various examples considered by work using the Nominal Package). Moreover, \nthere is some bene.t in staying .rst-order as in our Horn approach, and not getting into the second-order \nissue of .niteness of support. E.g., as soon as one deals with more semantic situations, such as our \nsemantic-domain interpretation in Section 2, the .nite support conditions are no longer satis.ed, but \na complex combination of induction and recursion is needed to have a Nom\u00adinal de.nition eventually go \nthrough, as shown in [33] (on page 492) for this very example. Another difference between NRC and SRC \nis of course the presence in SRC of built-in compositionality, which relates to the user as both an obligation \nand a reward. Michael Norrish s work. [27] introduces a recursor for .-calculus involving swapping and \nthe free-variable operator FV, and also considers parameters ` a la Nominal. If we ignore the largely \nor\u00adthogonal extra generality of [27] w.r.t. parameters, and replace the use of FV : term . Pf (var) with \nthe (complementary) use of fresh : var . term . bool, we .nd that [27] did in fact pro\u00adpose a Horn-like \nrecursive principle for syntax with bindings. In\u00adterestingly, [27] also contemplates considering substitution, \nbut re\u00adnounces in favor of swapping because permutations move around terms much more readily than substitution \n([27], page 248). How\u00adever, as we show in this paper, the (indeed harder) task of having substitution \nmove around terms results in a recursion principle which is not harder to apply (from the user s perspective), \nwhile bringing the convenience of substitution compositionality.  Non-standard-model approaches to syntax, \nbased on functor cat\u00adegories [7, 16, 23]. These approaches add more structure to terms, regarding them \nas terms in contexts this is inspired by the method of de Bruijn levels [13], and consists conceptually \nin turning the free-variable function FV : term . P(var) into extra structure on terms ([16], page 3). \nHere, there is no single set of terms, but rather terms form a family of sets indexed by the contexts \n, with additional categorical structure (i.e., as presheaves). The .exibility of moving between different \ncontexts allows one to overcome the typical problems with recursive de.nitions on syntax. Compared to \nthe more elementary settings discussed previously (which include our own), the non-standard model approach \nhas the advantage of syntactic purity (as only the term constructors are involved) and mathematical elegance, \nbut does have a couple of disadvantages too. Thus, it is harder to formalize in a standard theorem prover, \ndue to the fancy category theory involved (although this is more of a (solvable) problem for the implementor, \nnot for the user). More im\u00adportantly, it seems rather tedious to employ in order to de.ne con\u00adcrete operators. \nIndeed, the target domain would have to be orga\u00adnized each time as an algebra for a suitable functor \non presheaves, which means that a lot of structure and veri.cations would need to be provided and performed \nby the user. On the other hand, a cate\u00adgory theorist may argue that all this effort would not go in vain, \nas the extra structure will be helpful later in proofs and this is much like our argument in favor of \nbuilt-in substitution made in this pa\u00adper. Concerning the latter, both [23] and [16] show how to de.ne \nsubstitution using their iterator. Moreover, [16] goes further and in\u00adtegrates substitution in the algebraic \nstructure, inferring a version of recursion with a built-in substitution lemma, which is essentially \nwhat we do in this paper in a more standard setting. Formalizations and case studies. Norrish has formalized \nhis swapping-based recursion principle for the syntax of untyped .\u00adcalculus and has included it in the \ndistribution of the HOL4 system [6]. The Nominal package [46] has been used in several formal de\u00advelopments, \nincluding proofs of Church-Rosser and Standardiza\u00adtion for .-calculus the latter classic result, presented, \ne.g., in Barendregt, is different than the call-by-name and call-by-value standardization theorems from \n[34] that we have formalized, in that the latter deals with more programming-oriented strategies, not \nal\u00adlowing rewrites under .-abstractions. Recent work at the Nomi\u00adnal Package [44] allows syntax with \nmultiple (concurrent) binders, while our notion of binding signature allows only one binder at a time. \nHOAS versus FOAS. In this paper, we took a .rst-order abstract syntax (FOAS) view of syntax with bindings, \nwhere variables are bound in terms by .rst-order operators such as Lm. By contrast, HOAS [22, 31] employs \nhigher-order types for the binding opera\u00adtors. HOAS-based theorem proving and programming is currently \na topic of intensive research, e.g., [1 3, 10]. HOAS recursion prin\u00adciples can be found, e.g., in [14, \n19, 37, 40]. (See Section 3.7 in [36] for details.) While HOAS is often more elegant than FOAS, it is \nnot al\u00adways an alternative to FOAS. For instance, the very foundations of HOAS, consisting of the de.nition \nof the meta and object logics and the associated adequacy proof, rely on (some form of) FOAS. In spite \nof the extensive and growing interest in HOAS and its meta-theory, our formal HOAS adequacy proof discussed \nin Sec\u00adtion 6 seems to be the .rst reported in the literature. Even though it is performed for a fairly \nsimple (albeit standard) logical frame\u00adwork, .-calculus with constants, the actual proof technique works \nfor more complex frameworks such as LF too. An important part of the meta-theory of LF has been formalized \nusing the Nominal package, but we are not aware of actual representations and ade\u00adquacy proofs performed \nin this setting. Acknowledgments. We are indebted to the referees for helpful comments and suggestions. \nThis work was supported in part by the National Science Foundation (NSF) Award number 0917218. The content \nis solely the responsibility of the authors and does not necessarily represent the of.cial views of the \nNSF. References [1] Bedwyr. http://slimmer.gforge.inria.fr/bedwyr. [2] Beluga. http://www.cs.mcgill.ca/~complogic/beluga. \n[3] Delphin. http://cs-www.cs.yale.edu/homes/carsten/delphin. [4] http://www4.in.tum.de/~popescua/Scripts.zip. \n[5] The Twelf Project, 2009. http://twelf.plparty.org. [6] The HOL4 Theorem prover, 2010. http://hol.sourceforge.net/. \n[7] S. J. Ambler, Roy L. Crole, and Alberto Momigliano. A de.nitional approach to primitive recursion \nover Higher Order Abstract Syntax. In MERLIN, 2003. [8] Simon Ambler, Roy L. Crole, and Alberto Momigliano. \nCombin\u00ading Higher Order Abstract Syntax with tactical theorem proving and (co)induction. In TPHOLs, pages \n13 30, 2002. [9] Brian E. Aydemir, Arthur Chargu\u00b4eraud, Benjamin C. Pierce, Randy Pollack, and Stephanie \nWeirich. Engineering formal metatheory. In POPL, pages 3 15, 2008. [10] Jacques Carette, Oleg Kiselyov, \nand Chung chieh Shan. Finally tag\u00adless, partially evaluated. In APLAS, pages 222 238, 2007. [11] Adam \nJ. Chlipala. Parametric higher-order abstract syntax for mecha\u00adnized semantics. In ICFP, pages 143 156, \n2008. [12] Pierre-Louis Curien. Categorical combinators. Information and Con\u00adtrol, 69(1-3):188 254, 1986. \n[13] N. de Bruijn. .-calculus notation with nameless dummies, a tool for automatic formula manipulation, \nwith application to the Church-Rosser theorem. Indag. Math, 34(5):381 392, 1972. [14] Jo\u00a8 e Hirschowitz. \nelle Despeyroux, Amy P. Felty, and Andr\u00b4Higher\u00adorder abstract syntax in Coq. In TLCA, pages 124 138, \n1995. [15] Amy P. Felty and Alberto Momigliano. Hybrid: A de.nitional two-level approach to reasoning \nwith Higher-Order Abstract Syntax. CoRR, abs/0811.4367, 2008. [16] Marcelo Fiore, Gordon Plotkin, and \nDaniele Turi. Abstract syntax and variable binding (extended abstract). In LICS, pages 193 202, 1999. \n[17] M. J. Gabbay. A theory of inductive de.nitions with a-equivalence. Ph.D. thesis. University of Cambridge, \n2001. [18] Andrew D. Gordon. A mechanisation of name-carrying syntax up to alpha-conversion. In HUG, \npages 413 425, 1994. ISBN 3-540-57826\u00ad 9. [19] Andrew D. Gordon and Thomas F. Melham. Five axioms of \nalpha\u00adconversion. In TPHOLs, pages 173 190, 1996. [20] Elsa L. Gunter, Christopher J. Osborn, and Andrei \nPopescu. Theory support for weak Higher Order Abstract Syntax in Isabelle/HOL. In LFMTP, pages 12 20, \n2009. [21] Robert Harper and Daniel R. Licata. Mechanizing metatheory in a logical framework. J. Funct. \nProgram., 17(4-5):613 673, 2007.  [22] Robert Harper, Furio Honsell, and Gordon Plotkin. A framework \nfor de.ning logics. In LICS, pages 194 204. IEEE, Computer Society Press, 1987. [23] Martin Hofmann. \nSemantical analysis of higher-order abstract syntax. In LICS, page 204, 1999. [24] Alberto Momigliano \nand Simon Ambler. Multi-level meta-reasoning with higher-order abstract syntax. In FoSSaCS, pages 375 \n391, 2003. [25] Alberto Momigliano, Alan J. Martin, and Amy P. Felty. Two-level Hybrid: A system for \nreasoning using Higher-Order Abstract Syntax. Electron. Notes Theor. Comput. Sci., 196:85 93, 2008. [26] \nTobias Nipkow, Lawrence C. Paulson, and Markus Wenzel. Is\u00adabelle/HOL: A Proof Assistant for Higher-order \nLogic. Springer, 2002. [27] Michael Norrish. Recursive function de.nition for types with binders. In \nTPHOLs, pages 241 256, 2004. [28] Michael Norrish. Mechanising lambda-calculus using a classical .rst \norder theory of terms with permutations. Higher-Order and Symbolic Computation, 19(2-3):169 195, 2006. \n[29] Michael Norrish and Ren\u00b4e Vestergaard. Proof pearl: De Bruijn terms really do work. In TPHOLs, pages \n207 222, 2007. [30] L. C. Paulson. The foundation of a generic theorem prover. J. Autom. Reason., 5(3), \n1989. [31] F. Pfenning and C. Elliot. Higher-order abstract syntax. In PLDI, pages 199 208, 1988. [32] \nAndrew M. Pitts. Nominal logic: A .rst order theory of names and binding. In TACS, pages 219 242, 2001. \n[33] Andrew M. Pitts. Alpha-structural recursion and induction. J. ACM, 53(3), 2006. [34] Gordon D. Plotkin. \nCall-by-name, call-by-value and the lambda\u00adcalculus. Theor. Comput. Sci., 1(2):125 159, 1975. [35] Robert \nPollack and Masahiko Sato. A canonical locally named repre\u00adsentation of binding. To appear in Journal \nof Automated Reasoning. [36] Andrei Popescu. Contributions to the theory of syntax with bindings and \nto process algebra. Ph.D. Thesis, Univ. of Illinois, 2010. Available at http://hdl.handle.net/2142/18477. \n[37] Andrei Popescu, Elsa L. Gunter, and Christopher J. Osborn. Strong normalization of System F by HOAS \non top of FOAS. In LICS, pages 31 40, 2010. [38] Masahiko Sato and Robert Pollack. External and internal \nsyntax of the lambda-calculus. Journal of Symbolic Computation, 45:598 616, 2010. [39] Carsten Schurmann \nand Frank Pfenning. Automated theorem proving in a simple meta-logic for LF. In CADE, pages 286 300, \n1998. [40] Carsten Schurmann, Joelle Despeyroux, and Frank Pfenning. Primi\u00adtive recursion for higher-order \nabstract syntax. Theor. Comput. Sci., 266(1-2):1 57, 2001. [41] Masako Takahashi. Parallel reductions \nin lambda-calculus. Inf. Com\u00adput., 118(1):120 127, 1995. [42] Christian Urban. Nominal techniques in \nIsabelle/HOL. J. Autom. Reason., 40(4):327 356, 2008. [43] Christian Urban and Stefan Berghofer. A recursion \ncombinator for nominal datatypes implemented in Isabelle/HOL. In IJCAR, pages 498 512, 2006. [44] Christian \nUrban and Cezary Kaliszyk. General bindings and alpha\u00adequivalence in Nominal Isabelle. In ESOP, pages \n480 500, 2011. [45] Christian Urban and Christine Tasson. Nominal techniques in Is\u00adabelle/HOL. In CADE, \npages 38 53, 2005. [46] Christian Urban, James Cheney, and Stefan Berghofer. Mechanizing the metatheory \nof LF. In LICS, pages 45 56, 2008. [47] Makarius Wenzel, Lawrence C. Paulson, and Tobias Nipkow. The \nisabelle framework. In TPHOLs, pages 33 38, 2008.   APPENDIX In this appendix, we give more details \non the Isabelle formalization of our results and examples from this paper. The Isabelle scripts presented \nin pdf, html and native (runnable) Isabelle format can be found at [4]. These scripts are well docu\u00admented \nby text inserted at the beginning of each theory/section and often at the beginning of subsections too. \nNext we give a brief out\u00adline of the part of this formalization which is relevant to the topic of this \npaper much more details are given in Section 2.9 from [36]. A. Formalization of a general theory of \nsyntax As mentioned, we have formalized our recursion principles not only for the particular syntax of \n.-calculus, but for an arbitrary syntax with bindings. In other words, we work with terms (modulo a) \nover a .xed, but arbitrary binding signature. Our notion of binding signature is similar to, e.g., that \nof [16] it is essentially an algebraic signature, where the operation sym\u00adbols have associated sorts \nand arities, just that arities consider not only free, but also bound arguments. In our formalization, \nwe also distinguish between terms and abstractions, the latter being pairs variable-term, up to a. Thus, \na binding operator such as Lm takes an abstraction as argument, while a non-binding operator such as \nApp takes terms as arguments. More precisely, we .x an in.nite set of variables, var, ranged over by \nx, y, z. Given any two sets I and A, we let Input(I,A) be the set of partial functions from I to A, which \nwe call I-indexed A-inputs; elements of Input(I, term) (for some suf.ciently large set I) will be used \nas inputs (i.e., families of arguments) to the operations of the binding signature. Given f . Input(I,A) \nand g . Input(I,B), we write sameDom fg, read f and g have the same domain , for . i . I. (fi de.ned \n) .. (gi de.ned ). A binding signature S is then a tuple (index, bindex, varSort, sort, opSym, asSort, \narOf, barOf), where: -index, ranged over by i, j, is the set of indexes (meant to be used for building \nfamilies of free arguments for the operators); -bindex, also ranged over by i, j, is the set of binding \nindexes (bindexes for short) (meant to be used for building families of bound arguments for the operators); \n-varSort, ranged over by xs, is the set of variable sorts (varsorts for short) (representing the various \nsyntactic categories of vari\u00adables); -sort, ranged over by s, is the set of sorts (representing the various \nsyntactic categories of terms); -opSym, ranged over by d, is the set of operation symbols; -asSort : \nvarSort . sort is an injective map (this is the inclu\u00adsion/injection of varsorts as (term) sorts thus, \nfor each sort of variables, we have precisely one sort of terms that can substitute them); -stOf : opSym \n. sort, read the (result) sort of ; -arOf : opSym . Input(index, sort), read the (free) arity of ; -barOf \n: opSym . Input(bindex, varSort \u00d7 sort), read the bound arity of ( barity of , for short). We work with \na .xed (but arbitrary) binding signature in an Isabelle locale, for which we .rst de.ne many-sorted quasi-terms \nand quasi-abstractions (not yet factored to a), and then terms and abstractions as a-classes of quasi-terms \nand quasi-abstractions. Thus, we have: -for each sort s, a collection term(S)s of s-terms; -for each \nvarsort xs and sort s, a collection abs(S)(xs,s) of (xs,s)\u00adabstractions, binding xs variables in s-terms. \nFor instance, the binding signature S of the untyped .-calculus is obtained as follows: -since we have \nonly one syntactic category of variables and one of terms,  varSort is a singleton set, say {vlm}; \n sort is a singleton set, say {lm};  asSort : varSort . sort maps vlm to lm; -opSym is taken to contain \nsymbols for application and .\u00adabstraction, namely, opSym = {app, lam}; -index is taken to contain slots \nfor each sort in the arity of each operation symbol, here index = {Iapp1, Iapp2}; -bindex is taken to \ncontain slots for each pair varsort-sort in the barity of each operation symbol, here bindex = {Ilam}; \n-stOf : opSym . sort is de.ned by:  stOf app = lm; stOf lam = lm; -arOf : opSym . Input(index, sort) \nis de.ned by: arOf app i = lm; arOf lam i = unde.ned; -barOf : opSym . Input(bindex, varSort \u00d7 sort) \nis de.ned by:  barOf app i = unde.ned;  barOf lam i = lm.  Now, term(S)lm and abs(S)(vlm,lm) are precisely \nthe terms and abstractions for the untyped .-calculus (with Op app being precisely App, etc.) (See Section \n2.9.1 from [36] for much more details.) Recursion principles. The theories Iteration and Recursion (from \n[4]) formalize the arbitrary-syntax generalization of the results pertaining to Horn-based recursion \nfrom Sections 3 and 5, as well as a couple of variations of these results employing swapping instead \nof substitution. (NB: What we called recursion in Section 3 is in fact iteration, i.e., a restricted \nform of (primitive) recursion, where in the de.ning equations one is able to use the recursively computed \nresult, but not the recursive argument itself see Sections 1.4.2 in [36] for details. We also formalized \nthe general version.) Next we discuss theory Recursion. Just like in Section 3, we use the pre.x g for \ngeneralized items (here, not only generalized terms, but, as discussed in Section 6, also generalized \nabstrac\u00adtions). We have 4 kinds of models: FSb-models (formalizing the concept described in Section 3), \nand FSw-models, FSbSw-models and FSwSb-models, formalizing the aforementioned swapping\u00adbased variations. \nFor economy reasons, all these kinds of models share a common Isabelle record type, featuring operators \nfor the syntactic construc\u00adtors, freshness, swapping and substitution such a record is called a raw \nmodel. The involved clauses, such as F1-F4, S1-S4 and A for FSb-models, stated as predicates on raw models, \nmake such a raw model a speci.c model of one of the 4 kinds; if a certain fea\u00adture is not needed for \na certain kind of model (such as swapping for FSb-models), the corresponding operator is left unde.ned. \nThen the four types of models are introduced by the predicates wlsFSb, wlsFSw, wlsFSbSw, wlsFSbSw, read \nwell-structured FSb\u00admodel etc., which are conjunctions of the necessary clauses. We only discuss here \nFSb-models. Given a raw model MOD, wlsFSb MOD is de.ned to be essentially a conjunction of 3 predi\u00adcates: \n-gFreshCls MOD, stating the fresh clauses (F1-F4 from Section 3); -gSubstCls MOD, stating the substitution \nclauses (S1-S4 from Section 3); -gAbsRen MOD, stating the abstraction-renaming clause (A from Section \n3). The expected notions of morphism from the term model to an\u00adother FSb-model (generalizing the notion \nof FSb-morphism from Section 3) is given by the predicate termFSbMorph, stating preser\u00advation of freshness \nand substitution. Given a FSb-model MOD as above, the associated recursive morphism from the term model \ncomes as two maps rec MOD : term . gTerm and recAbs MOD : abs . gAbs. The recursion theorem (Thm. 1) \nis stated, split in two: (a) existence, as theo\u00adrem wlsFSb recAll termFSbMorph (note that H from Thm. \n1 is written in the scripts as rec MOD and recAbs MOD); (b) unique\u00adness, as theorem wlsFSb recAll unique \npresCons (saying that (rec MOD, recAbs MOD) is the only pair of constructor-preserving maps from terms \nand abstractions to the target model). The 3 criteria for extra morphism properties from Section 5, namely, \nThm. 2, have also been formalized, as theorems wlsFSb recAll re.FreshAll, wlsFSb recAll isInjAll and \nwlsFSb recAll isSurjAll. B. Formalized examples and larger developments All the examples listed explicitly \nin this paper have been formal\u00adized. Our .rst example, namely, semantic interpretation (Problem I) has \nbeen included as a built-in in the general theory. The rest of the examples are formalized in roughly \nthe same syntax in which they were presented in this paper (usually in a slightly more gen\u00aderal format, \nallowing an unspeci.ed number of constants too be\u00adsides variables, application and .-abstraction). Many \nof the exam\u00adples appear in the formal scripts as parts of larger developments, the largest one being \na formalization of a signi.cant part of Plotkin s classic paper [34]. In all such cases, we claim that \nthe overall de\u00advelopment bene.ts highly from the possibility to de.ne the map with the desired properties \nand move on, provided by our recursion principles, as opposed to trying to make the de.nition work by \nad hoc bases.4 Semantic-domain interpretation. Due to its importance and gen\u00aderality, the semantic interpretation \nexample (or, rather, class of ex\u00adamples) discussed as motivational Problem I has also been included in \nthe general development (for an arbitrary syntax) this is the topic of theory Semantic Domains. A well-structured \nsemantic domain (predicate wlsSEM) consists essentially of a type sTerm, of semantic values (called semantic \nterms in the scripts comments), and of an interpretation of the operation symbols from a signa\u00adture, \nwhere abstractions are treated as functions (thus the operations have second-order arguments to match \nbindings in the syntax, as for LM versus Lm at Problem I). A compositional interpretation map (predicate \ncompInt) is a map, via valuations, of syntax to the seman\u00adtic domain which is compositional with the \nsyntactic constructors and with substitution and oblivious to freshness, as is [] in Problem I. The main \ntheorem, semIntAll compInt, states that, for any given semantic domain SEM, the pair (semInt SEM, semIntAbs \nSEM) is indeed such a compositional interpretation map. Instances of the general theory for particular \nsyntaxes. So far, we have considered the following two instances: (I) The syntax of the untyped .-calculus \nwith constants, with terms X, Y, Z . term and abstractions A, B . abs: X ::= Var x | Ct c | App XY | \nLam AA ::= Abs xX (II) The two-sorted value-based variation of the above (as at the CPS example in Section \n4), with full terms X, Y, Z . term., value terms Xvl, Yvl, Zvl . termvl and abstractions (of value variables \nin full terms) A, B . abs(vl,.): X ::= InVl Xvl | App XY Xvl ::= Var x | Ct c | Lam AA ::= Abs xX where \nInVl is the injection of value terms into full terms. For both syntaxes, we recover the notation from \nthis paper s previous sections by letting Lm xX be an abbreviation for Lam (Abs xX).  Theories L1 and \nL are performing the instantiation of the gen\u00aderal theory to the above syntax (I) (and LV1 and LV do \nthe same for (II)). The instantiation process is performed in a completely uni\u00adform manner and will eventually \nbe automated, but currently it is done by hand. Theories L1 and L most of the facts one needs to 4 But \nsee Section 8 from the main paper for a discussion of other means for handling such de.nitions uniformly. \n know about the .-calculus instance of the theory, including: (1) ba\u00adsic facts about freshness, substitution \nand swapping; (2) induction principles; (3) the Horn-based recursion principles. All these facts, especially \nthose pertaining to (3) (present in L1), are documented and illustrated by comments inserted in between \nthe formal scripts. The theory of call-by-name .-calculus. This is the content of the\u00adories CBN, CBN \nCR and CBN Std, following Section 5 of [34]. In theory CBN, we introduce all the necessary relations \npertaining to \u00dfd-reduction (where d refers to the presence of the so-called d rules for reducing constants \napplication.) one-step left reduction, one-step reduction, parallel reduction, their re.exive-transitive \nclo\u00adsures, the associated CBN equational theory, etc. as inductive def\u00adinitions, and then prove several \nbasic facts about them, such as fresh induction and inversion rules. The number-of-free-occurrences op\u00aderator \nno : term . var . IN discussed in Section 4 plays an important role in the development, where a measure \nbased on it needs to be assigned to parallel reduction (this measure roughly indicates the number of \nredexes available in parallel in one step). In CBN CR, we prove the call-by-name Church-Rosser theorem \n(a prerequisite for [34]). In CBN Std, we prove the call-by-name standardization theorem, (stated as \nThm. 1 on page 146 in [34]) and its corollaries. HOAS representation of .-calculus into itself. This \nis the content of the theory HOAS. The .rst part of this theory deals with the representation of syntax, \nand has been described in Section 6 of the main paper. As operational semantics for the object system \nwe have cho\u00adsen the call-by-name big-step reduction (as de.ned, e.g., in [34] on page 145, using the \nfunction EvalN ) this is de.ned in our theory CBN as the relation Bredn : Obj.term . Obj.term . bool, \nwith concrete syntax ==>n , where the index n is not a num\u00adber, but a reminder of the by name style of \nreduction. (The choice was not important, we could have chosen any other re\u00adduction relation.) This relation \nis represented in the usual HOAS, LF-style fashion. The difference from LF though is that the sim\u00adple \nlogical framework considered here, term(metaConst), does not have judgement mechanisms of its own, and \ntherefore we use the inductive mechanism of Isabelle, which is here the meta-meta level . Thus, we represent \nBredn by an inductively de.ned relation MetaBredn : Meta.term . Meta.term . bool, with concrete syntax \n==>nM , where the index nM stands for by name, Meta . E.g., the \u00df-clause in the de.nition of Bredn, namely, \nX ==>n Obj.Lm yZ ' Z ' [Y/y] ==>n U '' '' Obj.App XY ==>n U is captured by the clause ' mX ==>nM Meta.App \nLM mV ' Meta.nf (Meta.App mVmY) ==>nM mU'' Meta.App (Meta.App APP mX) mY ==>nM mU'' where, as usual, \nwe omitted spelling the meta-constant injection operator, Meta.Ct, and where Meta.nf : Meta.term . Meta.term \nassociates to each meta-level term its \u00dfd-normal form if such a normal form exists and is unde.ned otherwise. \nNotice that the meta-level rule does not involve any bindings this was the whole purpose, to capture \nthe involved bindings implicitly, by the meta-level mechanisms. The object-level action of substituting \nin Z ' a previously bound variable (as Z ' [Y/y]) is matched by meta-level application Meta.App mV' mY \nin conjunc\u00adtion with normalization since in this correspondence Meta.App LM ' '' mVwill be the representation \nof Obj.Lm yZ , mVwill itself be a (meta-level) Lm-abstraction; the purpose of normalizing Meta.App mV' \nmY is therefore taking care of the resulting meta\u00adlevel \u00df-redex. For this sample representation, we have \nchosen to normalize on the .y , since this matches most faithfully the practice of logical frameworks. \n(For instance, in (generic) Isabelle [47], (. x. X) Y is a volatile entity, being instantaneously replaced \nby X[Y/y], the latter being what the user sees.) Another approach would be not normalizing (i.e., not \nincluding Meta.nf in the above rule), but then stating the adequacy referring to normal forms the latter \nis more common in the LF literature on adequacy [5, 22]. Yet another, newer approach, surveyed in [21], \nis to normalize at substitution time, via a notion of hereditary substitution. These approaches are equivalent, \nand they re.ect the semantic intuition that the \u00df (or \u00dfd, \u00df., etc.) equational theory is acting as the \nmeta-level equality. The semantic adequacy of the representation is stated as two theorems: -rep preserves \nBredn: If X ==>n X ', then rep X ==>nM ' rep X . -rep re.ects Bredn: If rep X ==>n mX', then there exists \nX ' such that X ==>n X ' and rep X ' = mX' . In particular, these theorems imply: -corollary rep Bredn \ni.: rep X ==>nM rep X ' holds iff X ==>n X ' holds. CPS transformation of call-by-value to call-by-name. \nThis is the content of the theory CPS. It includes formalization of the discus\u00adsion from Section 4.2. \nCPS imports the theory Embed, where the two-sorted value-based syntax is embedded in the (single-sorted) \nstandard syntax. We de.ned two combinators, combIC : term . term, read the identity-continuation combinator \n, and combAC : term . term . term, read the application-continuation com\u00adbinator , corresponding to the \nright-hand sides of clauses (3) and (4) from Section 4.2, by making choices of fresh variables (via the \nIsabelle Hilbert choice) and then showing that these choices are irrelevant. Thus, the aforementioned \nclauses appear in the scripts (in lemma cps simps) as cps (InVl Xvl)= combIC (cpsvl Xvl)) and cps (App \nXY )= combAC (cps X)(cps Y ). The built-in fresh\u00adness re.ection and injectiveness of the morphism are \nalso formal\u00adized, as lemmas cps re.ects fresh and cps inj. A more technically involved example connection \nwith the de Bruijn representation. This example has not been described in the main body of the paper, \nso we enter more details here. We use the following references: -[a] P.-L. Curien, Categorical combinators. \nInformation and Con\u00adtrol, 69(1-3):188 254, 1986. -[b] H. Ohtsuka. A proof of the substitution lemma in \nde Bruijn s notation. Inf. Process. Lett., 46(2):63 66, 1993. De Bruijn indexes are a standard way to \nrepresent .-calculus for ef.cient manipulation / implementation purposes. The set dB, of de Bruijn terms, \nranged over by K, L, M, is de.ned by the following grammar, where n ranges over IN: K ::= VAR n | APP \nKL | LM K There are no variable bindings involved rather, the index n of a de Bruijn variable VAR n \nindicates the distance between the given occurrence and its LM-binder (if any), i.e., the number of LM\u00adoperators \ninterposed between that occurrence and its binder. Thus, e.g., the .-term Lm x (Lm y (App yx)) corresponds \nto the de Bruijn term LM (LM (APP (VAR 0) (VAR 1))). As it stands, this correspondence is not perfect, \nsince, on one hand, there are .-terms with free variables, and, on the other, there are de Bruijn terms \nwith dangling indexes, i.e., indexes that fail to point to a valid binder (e.g., VAR 0, or LM (VAR 1)). \nA more serious discrepancy is that the processes of binding variables in terms are different: using Lm, \none can choose any variable x to be bound, while using LM one binds the default de Bruijn variables waiting \nto be bound, namely, those with dangling level 0.  A closer mathematical connection, allowing one to \nactually relate de Bruijn versions of standard results with the of.cial .\u00adversions (as is done, e.g., \nin [b]) can be achieved via parameterizing by variable orderings, as discussed in [a]. We model such \norderings as injective valuations of variables into numbers, i.e., injective elements of val =(var . \nIN). Let sem, the set of semantic values, ranged over by s, be {. . val. inj .}. dB, where inj : val \n. bool is the predicate stating that a valuation is injective. Then .-terms are interpreted as de Bruijn \nterms by a map toDB : term . sem, read to de Bruijn as follows. The clauses for variables and application \nare the obvious ones: -(1) toDB x = ... VAR(.x); -(2) toDB XY = ... APP (toDB X.)(toDB Y.). To interpret \n.-abstraction, we .rst de.ne mkFst : var . val . val, read make .rst : -mkFst x. = . y. if y = x then \n0 else (.y + 1). (Thus, x is made .rst by assigning it the .rst position, 0, in ., and by making room \nfor it through shifting the values of all the other variables.) Now, we set -(3) toDB (Lm xX)= ... LM(toDB \nX (mkFst x.)). (Thus, in order to map (Lm x)-abstractions to LM-abstractions, x is initially made .rst \n, i.e., mapped to 0, the only value which LM knows how to bind.) The above clauses are essentially De.nition \n2.3 on page 192 in [a] (under a slightly different notation). There are some similarities between these \nclauses and those from Problem I, but there are also some major differences, notably the interpretation \nof .-abstractions and the restricted space of valuations here, which prevent us from reducing one problem \nto the other. As usual, to make the de.nition rigorous, we ask the freshness and substitution questions. \nWhat can we infer about x versus toDB X if we know that x is fresh for X? The answer to this is similar \nto that from Problem I: we can infer obliviousness to x of the interpretation: -(4) fresh xX =. (. .. \n' .. = x . ' =. toDB X. = toDB X. ' ). As for the substitution question, the answer is given by a lemma \nstated in loc. cit.: -(5) toDB (X[Y/y]) = ... (toDB X)(mkFst y.) [(toDB Y.)/0]b , where [ / ]b : dB . \ndB . IN . dB is de Bruijn substitution (i.e, plain FO-substitution): (VAR n)[M/m]b = if n = m then M \nelse VAR n,  (APP KL)[M/m]b = APP (K[M/m]b)(L[M/m]b),  (LM K)[M/m]b = LM (K[M/m]b). (Thus, the toDB \ntreatment of substitution is similar to that of .\u00adabstraction: x is 0-indexed and then 0 is de Bruijn-substituted.) \n  Again, to have clauses (1)-(3) rigorously justi.ed and clauses (4), (5) proved, one needs to check \nthat the resulted model is an FSb-model. Unlike in the previous examples, here there are some complications, \nin that some of the FSb-model clauses simply do not hold on the whole space sem. Fortunately however, \na technical closure condition .xes this problem. Namely, if we take sem ' = {s . sem. .s : IN . IN, . \n. val. inj s . inj . =. s (s . .)= Gs (toDB X.)}, where G :(IN . IN) . dB . dB is a map whose de.nition \nwe give below, then sem ', with the FSb-structure given by clauses (1)-(5), indeed turns out to be an \nFSb-model checking this is relatively easy, but does rely on some de Bruijn arithmetic. The de.nition \nof G (having little importance beyond its techni\u00adcal role in the invariant that helps de.ning toDB), \ngoes as follows: -GsK = vmapDB (cut s)0 K, where -vmapDB :(IN . IN . IN) . IN . dB . dB, read variable \nmap , is the natural de Bruijn analogue of, say, list map (also taking into account, like any natural \nde Bruijn function, the LM-depth, recursively): vmapDB sn (VAR i)= VAR (sni),  vmapDB sn (APP KL)= \nAPP (vmapDB sK)(vmapDB sL);  vmapDB s (LM K)= LM (vmapDB s (n + 1) K); -and cut :(IN . IN) . IN . (IN \n. IN) is de.ned by cut sni = if i<n then i else s (i - n)+ n. We conjecture that the dif.culty we encountered \nwith construct\u00ading an FSb-model for this example would be matched by a cor\u00adresponding dif.culty in making \nthe de.nitions go through in an ad-hoc approach, where one would eventually have to discover a similar \ninvariant (again, compared to our approach, with the disad\u00advantage of having to do this discovery by \nrepeated trial and error in the middle of inductive proofs, not knowing in advance what prop\u00aderties need \nto hold). Unfortunately, we have no way of testing this conjecture, as ours seems to be the .rst rigorous \n(let alone formal) treatment of this construction from the literature. In [a], one em\u00adploys quasi-terms \nrather than terms, and a-equivalence is not even de.ned until after de.ning the above de Bruijn interpretation, \nand then its de.nition is non-standard: a-equivalence is taken to be the very kernel of this interpretation. \nMoreover, the substitution lemma is stated in [a] without a proof. This example has been formalized as \nthe theory C deBruijn from [4]. The scripts follow quite closely the notations we used above. We import \ntheory Lambda, the existing formalization of the de Bruijn representation from the Isabelle library. \nThen we develop some de Bruijn arithmetics facts, after which we proceed with the interpretation map \ntoDB by means of the model toDB MOD. (This naming convention, having the name of the model be the name \nof the desired map followed by MOD is observed in all our formal\u00adized examples.) This time, since there \nare some nontrivial compu\u00adtations involved in the veri.cation of the clauses, we prefer to .rst de.ne \nthe model components separately (operators ggWls, ggVar etc. in the scripts). Lemmas toDB simps, toDB \npreserves fresh and toDB subst are the end-products of the de.nition, i.e. corre\u00adspond to clauses (1)-(5). \n(For these end-products, we also observe the same naming pattern, as seen here and in the HOAS case, \nfor all our examples.)   \n\t\t\t", "proc_id": "2034773", "abstract": "<p>We characterize the data type of terms with bindings, freshness and substitution, as an initial model in a suitable Horn theory. This characterization yields a convenient recursive definition principle, which we have formalized in Isabelle/HOL and employed in a series of case studies taken from the &#955;-calculus literature.</p>", "authors": [{"name": "Andrei Popescu", "author_profile_id": "81435602099", "affiliation": "Technical University Munich, Munich, Germany &#38; University of Illinois at Urbana-Champaign, Urbana-Champaign, IL, USA &#38; Romanian Academy, Bucharest, Romania", "person_id": "P2801441", "email_address": "uuomul@yahoo.com", "orcid_id": ""}, {"name": "Elsa L. Gunter", "author_profile_id": "81100274275", "affiliation": "University of Illinois, Urbana-Champaign, IL, USA", "person_id": "P2801442", "email_address": "egunter@uiuc.edu", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034819", "year": "2011", "article_id": "2034819", "conference": "ICFP", "title": "Recursion principles for syntax with bindings and substitution", "url": "http://dl.acm.org/citation.cfm?id=2034819"}