{"article_publication_date": "09-19-2011", "fulltext": "\n Parametric Polymorphism and Semantic Subtyping: the Logical Connection Nils Gesbert Pierre Genev\u00e8s \nNabil Laya\u00efda INRIA CNRS INRIA nils.gesbert@inria.fr pierre.geneves@inria.fr nabil.layaida@inria.fr \nAbstract We consider a type algebra equipped with recursive, product, func\u00adtion, intersection, union, \nand complement types together with type variables and implicit universal quanti.cation over them. We \ncon\u00adsider the subtyping relation recently de.ned by Castagna and Xu over such type expressions and show \nhow this relation can be de\u00adcided in EXPTIME, answering an open question. The novelty, orig\u00adinality and \nstrength of our solution reside in introducing a logical modeling for the semantic subtyping framework. \nWe model seman\u00adtic subtyping in a tree logic and use a satis.ability-testing algorithm in order to decide \nsubtyping. We report on practical experiments made with a full implementation of the system. This provides \na powerful polymorphic type system aiming at maintaining full static type-safety of functional programs \nthat manipulate trees, even with higher-order functions, which is particularly useful in the context \nof XML. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features \nPolymorphism; F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs Type structure General \nTerms Algorithms, Design, Languages, Theory, Veri.\u00adcation Keywords Type-system, Polymorphism, subtyping \n1. Introduction This paper studies parametric polymorphism for type systems aim\u00ading at maintaining full \nstatic type-safety of functional programs that manipulate linked structures such as trees, potentially \nwith higher\u00adorder functions. We consider a type algebra equipped with recur\u00adsive, product, function (arrow), \nintersection, union, and comple\u00adment types. We .rst show how the subtyping relation between such type \nexpressions can be decided through a logical approach. Our main result solves an open problem: we prove \nthe decidability of the subtyping relation when this type algebra is extended with type variables. This \nprovides a powerful polymorphic type system (us\u00ading ML-style prenex polymorphism, where variables are \nimplicitly universally quanti.ed at toplevel), for which de.ning the subtyp\u00ading relation is not obvious, \nas pointed out in [5] and discussed in Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 11, September 19 21, 2011, Tokyo, Japan. Copyright c &#38;#169; \n2011 ACM 978-1-4503-0865-6/11/09. . . $10.00 Section 5.1, and for which no candidate de.nition of subtyping \nhad been proved decidable before. The novelty, originality and strength of our solution reside in introducing \na logical modeling for the se\u00admantic subtyping framework. Speci.cally, we model semantic sub\u00adtyping in \na mu-calculus over .nite trees and rely on a satis.ability solver in order to decide subtyping in practice. \nWe obtain an EXP-TIME complexity bound as well as an ef.cient implementation in practice. 1.1 The Need \nfor Polymorphism and Subtyping Subtyping makes it possible to prove that term substitution in a program \nsource code preserves type-safety. For example, let us consider a simple property relating polymorphic \ntypes of functions that manipulate lists. We consider a type a, and denote by [a] the type of a-lists \n(lists whose elements are of type a). The type t of functions that process an a-list and return a boolean \nis written as follows: t =[a] . Bool where Bool = {true, false} is the type containing only the two values \ntrue and false Now let us consider functions that distinguish a-lists of even length from a-lists of \nodd length: such a function returns true for lists with an even number of elements of type a, and returns \nfalse for lists with an odd number of elements of type a. One may represent the set of these functions \nby a type t ' written as follows: even[a] .{true}. odd[a] .{false} where {true} and {false} are singleton \ntypes (containing just one value). If we make explicit the parametric types even[a] and odd[a], t ' becomes: \nt ' = \u00b5v.(a \u00d7 (a \u00d7 v)) . nil .{true}. \u00b5v.(a \u00d7 (a \u00d7 v)) . (a \u00d7 nil) .{false} where \u00d7 denotes the cartesian \nproduct, \u00b5 binds the variable v for denoting a recursive type, and nil is a singleton type. Obviously, \na particular function of type t' can also be seen as a less-speci.c function of type t. In other terms, \nfrom a practical point of view, a function of type t can be replaced by a more speci.c function of type \nt ' while preserving type-safety (however the converse is not true). This is further formalized by the \nnotion of subtyping; in that case we write: t' t (1) where denotes a subtyping relation that can be de.ned \nin two fundamentally different ways in the literature: either syntactically or semantically. In this \npaper, we de.ne as a semantic subtyping relation by adopting a set-theoretic interpretation in the manner \nof [9], in contrast with more traditional subtyping through direct syntactic rules. As a main contribution, \nwe show how to decide this relation.  This work is motivated by a growing need for polymorphic type \nsystems for programming languages that manipulate XML data. For instance, XQuery [4] is the standard \nquery and functional lan\u00ad guage designed for querying collections of XML data. The support of higher-order \nfunctions, currently missing from XQuery, appears in the requirements for the forthcoming XQuery 3.0 \nlanguage [8]. This results in an increasing demand in algorithms for proving or disproving statements \nsuch as the one of the example (1) with poly\u00ad morphic types, but also with types of higher-order functions \n(like the traditional map and fold functions), or more generally, state\u00adments involving the subtyping \nrelation over a type algebra with recursive, product, function, intersection, union, and complement types \ntogether with type variables and universal quanti.cation over them.  1.2 Semantic Subtyping with Logical \nSolvers During the last few years, a growing interest has been seen in the use of logical solvers such \nas satis.ability solver and satis.ability\u00admodulo solvers in the context of functional programming and \nstatic type checking [1, 3]. In particular, solvers for tree logics [7, 10] are used as basic building \nblocks for type systems for XQuery. The main idea in this paper is a type-checking algorithm for polymorphic \ntypes based on deciding subtyping through a logical solver. To decide whether t is a subtype of type \nt ', we .rst con\u00adstruct equivalent logical formulas .t and .t! and then check the validity of the formula \n. = .t . .t! by testing the unsatis.\u00adability of \u00ac. using the satis.ability-testing solver. This technique \ncorresponds to semantic subtyping [9] since the underlying logic is inherently tied to a set-theoretic \ninterpretation. Semantic subtyping has been applied to a wide variety of types including re.nement types \n[3] and types for XML such as regular tree types [12], func\u00ad tion types [2], and XPath [6] expressions \n[10]. This fruitful connection between logics, their decision proce\u00addures, and programming languages \npermitted to equip the latter with rich type systems for sophisticated programming constructs such as \nexpressive pattern-matching and querying techniques. The potential bene.ts of this interconnection crucially \ndepend on the expressivity of the underlying logics. Therefore, there is an increas\u00ading demand for more \nand more expressiveness. For example, in the context of XML: SMT solvers like [7] offer an expressive \npower that corresponds to a fragment of .rst-order logic in order to solve the intersec\u00adtion problem \nbetween two queries [1];  full .rst-order logic solvers over .nite trees [10] solve contain\u00ad ment and \nequivalence of XPath expressions;  monadic second-order logic solvers over trees, and equivalent yet \nmuch more effective satis.ability-solvers for \u00b5-calculus over trees [10] are used to solve query containment \nproblems in the presence of type constraints.  1.3 Contributions of the Paper To the best of our knowledge, \nnovelty of our work is threefold. It is the .rst work that: proves the decidability of semantic subtyping \nfor polymorphic types with function, product, intersection, union, and comple\u00adment types, as de.ned by \nCastagna and Xu [5], and gives a pre\u00ad cise complexity upper-bound: 2(n), where n is the size of types \nbeing checked. Decidability was only conjectured by Castagna and Xu before our result, although they \nhave now proved it in\u00addependently; our result on complexity is still the only one. In addition, we provide \nan effective implementation of the deci\u00adsion procedure. produces counterexamples whenever subtyping \ndoes not hold. These counterexamples are valuable for programmers as they represent evidence that the \nrelation does not hold.  pushes the integration between programming languages and logical solvers to \na very high level. The logic in use is not only capable to range over higher order functions, but it \nis also capable of expressing values from semantic domains that correspond to monadic second-order logic \nsuch as XML tree types [10]. This shows that such solvers can become the core of XML-centric functional \nlanguages type-checkers such as those used in CDuce [2] or XDuce [11].   1.4 Structure of the Paper \nWe introduce the semantic subtyping framework in Section 2 where we start with the monomorphic type algebra \n(without type vari\u00adables). We present the tree logic in which we model semantic sub\u00adtyping in Section \n3. We detail the logical encoding of types in Sec\u00ad tion 4. Then, in Section 5 we extend the type algebra \nwith type variables, and state the main result of the paper: we show how to decide the subtyping relation \nfor the polymorphic case in exponen\u00adtial time. We report on practical experiments using the implemen\u00adtation \nin Section 6. Finally, we discuss related work in Section 7 before concluding in Section 8. 2. Semantic \nSubtyping Framework In this section, we present the type algebra we consider: we in\u00adtroduce its syntax \nand de.ne its semantics in terms of semantic domains. This framework is the one described at length in \n[9]; we do not discuss its properties here but just give the necessary de.ni\u00adtions, that we will then \nextend with type variables in Section 5. 2.1 Types Type terms are de.ned using the following grammar: \nt ::= b basic type | t \u00d7 t product type | t . t function type | t . t union type |\u00act complement type \n| 0 empty type | v recursion variable | \u00b5v.t recursive type We consider \u00b5 as a binder and de.ne the notions \nof free and bound variables and closed terms as standard. A type is a closed type term which is well-formed \nin the sense that: the negation operator only occurs in front of closed types;  every occurrence of \na recursion variable is separated from its binder by at least one occurrence of the product or arrow \ncon\u00adstructor.  So, for example, \u00b5v.0 . v is not well-formed, nor is \u00b5v.0 .\u00acv. Additionally, the following \nabbreviations are de.ned: def t1 . t2 = \u00ac(\u00act1 .\u00act2) and 1 = \u00ac0  2.2 Semantic domain Consider an arbitrary \nset C of constants. From it, we de.ne the semantic domain D as the set of ds generated by the following \ngrammar, where c ranges over constants in C :  d ::= domain element c base constant d ' ||::= (d, d) \npair {(d, d ' ), . . . , (d, d ' )} function extended domain element d | O error The function terms \nare .nite sets of pairs representing nonde\u00adterministic partial functions from D to D.{O}: each pair (d, \nd ' ) in the set means that, when given d as an argument, the function may yield d ' as a result. If \nd does not appear as the .rst element of any pair, the operational interpretation is that the function \ncan still accept d as an argument but will not yield a result: this represents a computation which does \nnot terminate. A pair of the form (d, O) is used to represent a function rejecting d as an argument: \nwhen given d, it yields an error. This grammar is only able to represent functions which diverge but \non a .nite number of possible arguments. However it is shown in [9] (Lemma 6.32) that considering only \nthose functions does not affect the subtyping relation.  2.3 Interpretation We suppose we have an interpretation \nB[\u00b7] of basic types b as subsets of C . The predicate (d ' : t ) where d ' is an element of D or O and \nt is a type is de.ned recursively in the following way: (O : t )= false (c : b)= c . B[b] ((d1,d2): t1 \n\u00d7 t2)=(d1 : t1) . (d2 : t2) '' ' ({(d1,d 1),..., (dn,d n)} : t1 . t2)= .i, (di : t1) . (di : t2) (d : \nt1 . t2)=(d : t1) . (d : t2) (d : \u00act )= \u00ac(d : t) (d : \u00b5v.t )=(d : t{\u00b5v.t/v}) (d : t )= false in any other \ncase To prove this de.nition is well-founded, we .rst de.ne the shallow depth of a type term as the longest \npath, in its syntactic tree, starting from the root and consisting only of \u00b5, ., and \u00ac nodes. We then \nuse the following ordering on pairs (d ' ,t) : d ' 1 d ' 2 if d ' 1 is a subterm of d ' 2  t1 t2 if \nthe shallow depth of t1 is less than the shallow depth of t2  pairs are ordered lexicographically, i. \ne. (d ' 1,t1)(d2' ,t2) if either d ' 1 <d 2 ' or d1 ' = d2 ' and t1 t2.  Now we can see that all occurrences \nof the predicate on the right\u00adhand side of the de.nition are for pairs strictly smaller than the one \non the left (in the case of \u00b5v.t, this is due to the well-formedness constraint: the variable being substituted \ncan only appear below a \u00d7 or . node). Because all terms and types are .nite, this makes the de.nition \nwell-founded. The interpretation of types as parts of D is then de.ned as = {d | (d : t)}. Note that \nO is not part of any type, as [t] expected. In this framework, we consider XML types as regular tree \nlan\u00adguages. An XML tree type is interpreted as the set of documents that match the type.  2.4 Subtyping \nThe subtyping relation is de.ned as t1 t2 . [t1] . [t2], or, equivalently, [t1 .\u00act2] = \u00d8. 3. Tree logic \nframework In this section we introduce the logic in which we model the semantic subtyping framework. \nThis logic is a subset of the one proposed in [10]: a variant of \u00b5-calculus whose models are .nite trees. \nWe .rst introduce below the syntax and semantics of the logic, before tuning it for representing types. \n3.1 Formulas Formulas are de.ned thus: ., . ::= formula T true | s |\u00acs atomic proposition (negated) | \nX variable | . . . disjunction | . . . conjunction |(a) . | \u00ac(a)T existential (negated) | \u00b5(Xi = .i)i.I \nin . (least) n-ary .xpoint where a .{1, 2} are programs, and I is a .nite set. Atomic propositions s \ncorrespond to labels from a countable set S. Addi\u00adtionnally, we use the abbreviation \u00b5X.. for \u00b5(X = .) \nin ..  3.2 Semantic domain The semantic domain is the set F of focused trees de.ned by the following \nsyntax, where we have an alphabet S of labels, ranged over by s: t ::= s[tl] tree tl ::= list of trees \nf empty list | t :: tl cons cell c ::= context (tl, Top, tl) root of the tree | (tl,c[s], tl) context \nnode f ::= (t, c) focused tree A focused tree (t, c) is a pair consisting of a tree t and its context \nc. The context (tl,c[s], tl) comprises three components: a list of trees at the left of the current tree \nin reverse order (the .rst element of the list is the tree immediately to the left of the current tree), \nthe context above the tree, and a list of trees at the right of the current tree. The context above the \ntree may be Top if the current tree is at the root, otherwise it is of the form c[s] where s is the label \nof the enclosing element and c is the context in which the enclosing element occurs. The name of a focused \ntree is de.ned as nm(s[tl],c)= s. We now describe how to navigate focused trees, in binary style. There \nare four directions, or modalities, that can be followed: for a focused tree f, f (1) changes the focus \nto the .rst child of the current tree, f (2) changes the focus to the next sibling of the p current tree, \nf1 changes the focus to the parent of the tree if p the current tree is a leftmost sibling, and f2 changes \nthe focus to the previous sibling. Formally, we have: (s[t :: tl],c) (1) def =(t, (f, c[s], tl)) ' :: \ntlr)) (2) def ' (t, (tll,c[s],t =(t, (t :: tll,c[s], tlr)) p def (t, (f, c[s], tl))1 =(s[t :: tl],c) \n ' p def' (t, (t :: tll,c[s], tlr))2 =(t, (tll,c[s],t :: tlr))  When the focused tree does not have \nthe required shape, these operations are not de.ned.  3.3 Interpretation Formulas are interpreted as \nsubsets of F in the following way, where V is a mapping from variables to formulas: def def = F = {f \n| nm(f)= s} [T]V [s]V def def = V (X)= {f | nm(f)= s} [X]V [\u00acs]V def def [. . .]V = [.]V . [.]V [. . \n.]V = [.]V n [.]V [(a) .]V def = {f (a)| f . [.]V . f (a) de.ned} def [\u00ac(a)T]V = {f | f (a) unde.ned} \ndef [\u00b5(Xi = .i)i.I in .]V = let S = {(Ti) .P(F)I |.j . I, [.j ]V [Ti/Xi] . Tj } in I let (Uj )=Tj in \n(Ti).Sj.I [.]V [Ui/Xi] where V [Ti/Xi](X)= V (X) if X .{Xi} and Ti if X = Xi. The lemma 4.2 of [10] says \nthat the interpretation of a .xpoint formula is equal to the union of the interpretations of all its \n.nite unfoldings (where unfolding is de.ned as usual). A consequence (detailed in [10]) is that the logic \nis closed under negation, i. e. for any closed ., \u00ac. can be expressed in the syntax using De Morgan s \nrelations and this de.nition: def \u00ac(a) . = \u00ac(a)T.(a)\u00ac. def \u00ac\u00b5(Xi = .i) in . = \u00b5(Xi = \u00ac.i{Xi/\u00acXi }) in \n\u00ac.{Xi/\u00acXi } In the following, we consider only closed formulas and write [.] for [.]\u00d8. 4. Logical Encoding \nIn the context of the present paper, we want .nite tree models of the logic to correspond to types introduced \nin section 2. Thus, we .rst extend the alphabet of node labels to be able to reason with type constructors. \nThen, we present the translation of a type into a logical formula. 4.1 Representation of domain elements \nLet T be the set of (unfocused) trees. Set C = {B[tl] | tl .T * }, where B is a label not in S : the \nset of trees with a distinguished root B. Let Text be the set of trees obtained by extending S with the \nfour extra labels (.), (\u00d7), B and O. Then DO can straightfor\u00adwardly be embedded into Text in the following \nway: tree(c)= c tree(O) = O[f] tree(d, d ' )=(\u00d7)[tree(d) :: tree(d ' ) :: f] tree({(d1,d 1' ),..., (dn,d \nn' )})= (.)[tree(d1,d ' 1) :: ... :: tree(dn,d ' ) :: f] n In the following we consider this embedding \nimplicitly done, so DO .Text.  4.2 Translation of types First of all, we can de.ne basic types b, which \nare to represent sets of trees with no special nodes but the distinguished root B, as the (closed) base \nformulas of the logic. The full interpretation of formulas uses sets of focused trees, but note that \na toplevel formula cannot contain any constraint on what is above or to the left of the node at focus, \nso it can be considered as describing just a list of trees. The interpretation of a base type will then \nbe a Broot whose list of children is described by the formula. Formally: def B[.] = {B[t :: tl2] | (t, \n(tl1,c[s], tl2)) . [.]} Note how the only part of the context taken into account in de.ning the semantics \nis the list of following siblings of the current node. Then, we translate the types into extended formulas \nobtained (as for extended trees) by adding to S the labels (\u00d7), (.), O and B. Straightforwardly these \nformulas denote lists of trees in Text. First de.ne the following formulas: isbase = \u00b5X.((\u00ac(1)T.(1) X) \n. (\u00ac(2)T.(2) X) .\u00acB.\u00ac(.) .\u00ac(\u00d7) .\u00acO) error =O .\u00ac (1)T isd = \u00b5X.( (B.(1) isbase). ((\u00d7) .(1) (X .(2) (X \n.\u00ac (2)T))). ((.) . (\u00ac(1) T. (1) \u00b5Y.((\u00ac(2)T.(2) Y ). (\u00d7) .(1) (X .(2) ((X . error) .\u00ac (2)T)) )))) isbase \nselects all tree lists which do not contain any of the special labels (the .xpoint is for selecting all \nthe nodes). error is straightforward. isd selects all elements of D (actually, all tree lists whose .rst \nelement is in D): either they are a constant (a B node with a base list as children), or a pair (a (\u00d7) \nnode with exactly two children each of which is itself in D), or a function: a (.) node with either no \nchildren at all or a list of children (described by Y) all of which are pairs whose second element may \nbe error. We now associate to every type t the formula fullform(t)= isd . form(t ), with form(t) de.ned \nas follows, where Xv is a different variable for every v and is also different from X: form(b)= B.(1) \nb form(t1 \u00d7 t2)=(\u00d7) .(1) (form(t1) .(2) form(t2)) form(t1 . t2)=(.) . (\u00ac(1) T. (1) \u00b5X.((\u00ac(2)T.(2) X) \n.(1) (\u00acform(t1) .(2) form(t2))) ) form(t1 . t2)= form(t1) . form(t2) form(\u00act)= \u00acform(t) form(0)= \u00acT form(v)= \nXv form(\u00b5v.t)= \u00b5Xv.form(t ) Recall that basic types b are themselves formulas, but that their interpretation \nas a type is different from their interpretation as a formula (see the .rst paragraph of Section 4.2 \nand the de.nition of B[.], the interpretation as a type, in terms of [.], the interpretation as a formula). \nThis explains why the translation of b contains b itself. The translation of product types is simple: \nit describes a (\u00d7) node whose .rst child is described by form(t1) and has a following sibling described \nby form(t2). The translation of arrow types has a structure similar to what appeared in isd: it describes \na (.) node with either no children or a list of children recursively described by X (each node has either \nno following sibling or a following sibling itself described by X). Each of these nodes must have a .rst \nchild which either is not of type t1 or has a next sibling of type t2 this means that these nodes represent \npairs (di,d ' i) such that (di : t1) . (d ' i : t2). The attentive reader may notice that the formula \nform(t1 . t2) does not enforce in itself that all children of the (.) node are actually pairs; the reason \nfor that is that isd already enforces it.  We can see that the formulas in the translation do not contain \nany (2) at toplevel (i. e. not under (1)), nor does isd. This means they describe a single tree (they \nsay nothing on its siblings), or in other words that in their interpretation as focused trees, the context \nis completely arbitrary, as it is not constrained in any way. Formally, we thus de.ne the restricted \ninterpretation of extended formulas as follows: def F[.] = {t | (t, c) . [.]} That is, we drop the context \ncompletely. Then we have F[fullform(t )] = [t ]. This is a particular case of the property for polymorphic \ntypes which will be proved in the following section. The main consequence of this property is that a \ntype t is empty if and only if the interpretation of the corresponding formula is empty which is equivalent \nto the formula being unsatis.able. Because their exists a satis.ability-checking algorithm for this tree \nlogic [10], this means this translation gives an alternative way to decide the classical semantic subtyping \nrelation as de.ned in [9]. More interestingly, it yields a decision procedure for the subtyping relation \nin the polymorphic case as well, as we will explain in the next section. 5. Polymorphism: Supporting \nType Variables So far we have described a new, logic-based approach to a question semantic subtyping \nin the presence of intersection, negation and arrow types which had already been studied. We now show \nhow this new approach allows us, in a very natural way, to encompass the latest work by adding polymorphism \nto the types along the lines of [5]. We add to the syntax of types variables, a, \u00df, . taken from a countable \nset V. If t is a polymorphic type, we write var(t) the set of variables it contains and call ground type \na type with no variable. We sometimes write t(a) to indicate that var(t ) is included in a. 5.1 Subtyping \nin the polymorphic case: a problem of de.nition The intuition of subtyping in the presence of type variables \nis that t1(a) t2(a) should hold true whenever, independently of the variables a, any value of type t1 \nhas type t2 as well. However the correct de.nition of independently is not obvious. It should look like \nthis: .a, [t1(a)] . [t2(a)] but because variables are abstractions, it is not completely clear over what \nto quantify them. As mentioned in [13], a candidate naive de.nition would use ground substitutions, \nthat is, if the inclusion of interpretations always holds when variables are replaced with ground types, \nthen the subtyping relation holds: t1(a) t2(a) ..t ground types, [t1(t/a)] . [t2(t/a)] (2) Obviously \nthe condition on the right must be necessary for sub\u00adtyping to hold. But deciding that it is suf.cient \nas well makes the relation unsatisfactory and somehow counterintuitive, as remarked in [13]. Indeed, \nsuppose int is an indivisible type, that is, that it has no subtype beside 0 and itself. Then the following \nwould hold: int \u00d7 a (int \u00d7\u00acint) . (a \u00d7 int) (3) This relation abuses the de.nition by taking advantage \nof the fact that for any ground type t, either [int] . [t] or [t ] . [\u00acint]. In the .rst case, because \n[t ] . ([\u00acint] . [int]), we have [int \u00d7 t ] . [int \u00d7\u00acint] . [int \u00d7 int] and then the second member of \nthe union is included in [t \u00d7 int]. In the second case, we directly have [int \u00d7 t ] . [int \u00d7\u00acint]. This \ntrick, which only works with indivisible ground types, not only shows that candidate de.nition (2) yields \nbizarre relations where a variable occurs in unrelated positions on both sides. It also means the candidate \nde.nition is very sensitive to the precise semantics of base types, since it distinguishes indivisible \ntypes from others. More precisely, it means that re.ning the collection of base types, for example by \nadding types even and odd, can break subtyping relations which held true without these new types this \nis simply due to the fact that it increases the set over which t is quanti.ed in (2), making the relation \nstricter. This could hardly be considered a nice feature of the subtyping relation. The conclusion is \nthus that the types in (3) should be considered related by chance rather than by necessity, hence not \nin the subtyp\u00ading relation, and that quantifying over all possible ground types is not enough; in other \nwords, candidate de.nition (2) is too weak and does not properly re.ect the intuition of independently \nof the vari\u00adables . Indeed, (3) is in fact dependent on the variable as we saw, the point being that \nthere are only two cases and that the convoluted right-hand type is crafted so that the relation holds \nin both of them, though for different reasons. In order to restrict the de.nition of subtyping, [13], \nwhich concentrates on XML types, uses a notion of marking: some parts of a value can be marked (using \npaths) as corresponding to a variable, and the relation a value has a type is changed into a marked value \nmatches a type , so the semantics of a type is not a set of values but of pairs of a value and a marking. \nThis is designed so that it integrates well in the XDuce language, which has pattern\u00admatching but no \nhigher-order functions (hence no arrow types), so their system is tied to the operational semantics of \nmatching and provides only a partial solution. The question of .nding the correct de.nition of semantic \nsub\u00adtyping in the polymorphic case was .nally settled very recently by Castagna and Xu [5]. Their de.nition \ndoes, in the same way as (2), follow the idea of a universal quanti.cation over possible meanings of \nvariables but solves the problem raised by (3) by using a much larger set of possible meanings thus \nyielding a stricter relation. More precisely, variables are allowed to represent not just ground types \nbut any arbitrary part of the semantic domain; furthermore, the semantic domain itself must be large \nenough, which is em\u00adbodied by the notion of convexity. We refer the reader to [5] for a detailed discussion \nof this property and its relation to the notion of parametricity studied by Reynolds in [14]; we will \nhere limit ourselves to introducing the de.nitions strictly necessary for the discussion at hand. In \nthis work, we do not use this de.nition with its universal quanti.cation directly. Rather, we retain \nfrom [13] the idea of tag\u00ad ging (pieces of) values which correspond to variables, but do so in a more \nabstract way, by extending the semantic domain, and de.ne a .xed interpretation of polymorphic types \nin this extended domain as a straightforward extension of the monomorphic framework. We then show how \nto build a set-theoretic model of polymorphic types, in the sense of [5], based on this domain, and prove \nthat the inclu\u00ad sion relation on .xed interpretations is equivalent to the full sub\u00adtyping relation induced \nby this model. Finally, we explain brie.y the notion of convexity and show that this model is convex, \nim\u00adplying that this relation is, in fact, the semantic subtyping relation on polymorphic types, as de.ned \nin [5]. These steps are formally detailed in the following section.  5.2 Interpretation of polymorphic \ntypes Let . be an in.nite set of optional labels, and . an injective func\u00adtion from V to .. (It would \nbe possible to set .= V, but for clarity we prefer to distinguish labels which tag elements of the semantic \ndomain from variables which occur in types.) We extend the gram\u00admar of (extended) trees by allowing any \nnode to bear, in addition to its single s label from S .{(.), (\u00d7), B, O}, any (.nite) number of labels \nfrom .. We write it sL[tl] where L is a .nite part of .. We extend C and D accordingly. When using the \nnon-tree form of types, for instance (d1,d2), we indicate the set of root labels on the bottom right \nlike this: (d1,d2)L (here L is the set of labels borne by the (\u00d7) node constituting the root of the pair \ntree).  We then extend the predicate de.ning the interpretation of types given in Section 2.3 with the \nfollowing additional case: (sL[tl]: a)= .(a) . L In other words, the interpretation of a type variable \nis the set of all trees whose root bears the label corresponding to that variable. The other cases are \nunchanged, except that the semantic domain is now much larger. This means that the same de.nition leads \nto larger interpretations; in particular, the interpretation of a (nonempty) ground type is always an \nin.nite set which contains all possible labellings for each of its trees. Subtyping over polymorphic \ntypes is then de.ned, as before, as set inclusion between interpretations: t1(a) t2(a) . [t1(a)] . [t2(a)] \n(4) It may seem strange to give type variables a .xed interpretation, and on the other hand it may seem \nsurprising that this de.nition of subtyping does not actually contain any quanti.cation and is nevertheless \nstronger than (2) which contains one. The keypoint is that a form of universal quanti.cation is implicit \nin the extension of the semantic domain: in some sense, the interpretation of a variable represents all \npossible values of the variable at once. Indeed, for any variable a and any tree d in the domain, there \nalways exist both an in.nity of copies of d which are in the interpretation of a and another in.nity \nof copies which are not. From the point of view of logical satis.ability, this makes the domain big enough \nto contain all possible cases. In order to show that, despite the appearances, De.nition (4) ac\u00ad curately \nrepresents a relation that holds independently of the vari\u00adables, we rely, as discussed above, on the \nformal framework devel\u00adoped by Castagna and Xu [5]. For this, we .rst introduce assign\u00adments .: functions \nfrom V to P(D) (where D is the extended se\u00admantic domain with labels). Thus an assignment attributes \nto each variable an arbitrary set of elements from the semantic domain. We then de.ne the interpretation \nof a type relative to an as\u00adsignment in the following way: the predicate (d ' :. t ) is de.ned inductively \nin the same way as the (d ' : t) of Section 2.3 but with the additional clause: (d :. a)= d . .(a). The \ninterpretation of the polymorphic type t relative to the assign\u00adment . is then [t ]. = {d | (d :. t)}. \nThis de.nes an in.nity of possible interpretations for a type, depending on the actual values assigned \nto the variables, and constitutes a set-theoretic model of types in the sense of [5]. The subtyping relation \ninduced by this model is the following: t1(a) t2(a) ... .P(D)V (5) , [t1(a)]. . [t2(a)]. which we can \nmore easily compare to the candidate de.nition (2): it does in the same way quantify over possible meanings \nof the variables but uses a much larger set of possible meanings, yielding a stricter relation. We will \nnow prove that this relation is, for our particular model, actually equivalent to (4). For this, let \nus .rst de.ne the canonical assignment .. as fol\u00adlows: def ..(a)= {sL[tl] .D| .(a) . L}. Then it is easily \nseen that the .xed interpretation [t ] of a polymor\u00adphic type is the same as its interpretation relative \nto the canonical assignment, [t ]... What we would like to prove is that the canon\u00adical assignment is \nsomehow representative of all possible assign\u00adments, making the .xed interpretation suf.cient for the \npurpose of de.ning subtyping. This is done by the following lemma and corol\u00adlary. LEMMA 5.1. Let V be \na .nite part of V. Let . be an assignment. Let T be the set of all types t such that var(t) . V . Then \nthere exists a function FV. : D.D such that: .t . T, .d .D,d . [t ]. . FV. (d) . [t ]... Proof: For d \nin D, let L(d)= {.(a) | a . V . d . .(a)}. Since V is .nite, L(d) is .nite as well. We de.ne FV. (d) \ninductively as follows: if d = BL[tl] then FV. (d)= BL(d)[tl] . ..  if d =(d1,d2)L then F (d)=(F (d1),F \n(d2))L(d)  V VV FV. (O) = O  if d = {(d1,d ' 1),..., (dn,d ' )}L then  . .. .. F (d)= {(F (d1),F \n(d1' n)),..., (F (dn),F (d ' ))}L(d) nV VV VV So FV. preserves the structure but changes the labels so \nthat the root node of FV. (d) is labelled with L(d) and so on inductively for its subterms. Let P(d, \nt )= d . [t]. . F . (d) . [t]... We prove that it V holds for all pairs (d, t ) such that t is in T by \ninduction on those pairs, using the ordering relation on them de.ned in Section 2.3, noticing that t \n. T implies that all subterms (and unfoldings) of t are in T as well. The base cases are: if t is a \nvariable. Then it is in V by hypothesis and P(d, t ) is true by de.nition of L(d).  if it is a base \ntype. Then P(d, t) is true because the interpreta\u00adtion of t is independent of assignments and labellings. \n For the inductive cases, we suppose the property true for all strictly smaller pairs (d, t ) such that \nt is in T . For the arrow and product cases, the inductive de.nition of FV. makes the result straightforward. \n For the negation and disjunction cases, the result is immediate from the induction hypothesis.  For \n\u00b5v.t , recall that the well-formedness constraint on types implies that the type s unfolding has a strictly \nsmaller shallow depth than the original type, hence we can use the induction hypothesis on the unfolding \nand conclude.  COROLLARY 5.2. Let t be a type. [t ]. = \u00d8 if and only if = \u00d8. ..P(D)V [t ].. Proof: \nIf the union is not empty, there exists . and d such that d . [t ].. From the previous lemma we then \nhave F . (d) . [t]... var(t) This corollary shows that the canonical assignment is represen\u00adtative of \nall possible assignments and implies that the subtyping relation de.ned by (4) is equivalent to the one \nde.ned by (5). Convexity of the model. De.nition (5) corresponds to semantic subtyping as de.ned in [5], \nbut only on the condition that the underlying model of types be convex. Indeed, we can see that this \nde.nition is dependent on the set of possible assignments, which itself depends on the chosen (abstract) \nsemantic domain, so it is reasonable to think that increasing the semantic domain could restrict the \nrelation further. In other words, for the de.nition to be correct, the domain must be large enough to \ncover all cases. Castagna and Xu s convexity characterises this notion of large enough . The property \nis the following: a set-theoretic model of types is convex if, whenever a .nite collection of types t1 \nto tn each possess a nonempty interpretation relative to some assignment, then there exists a common \nassignment making all interpretations nonempty at once. This re.ects the idea that there are enough elements \nin the domain to witness all the cases.  In our case, it comes as no surprise that the extended model \nof types is convex since any nonempty ground type has an in.nite in\u00adterpretation, which, as proved in \n[5], is a suf.cient condition. But we need not even rely on this result since Corollary 5.2 proves a \nproperty even stronger than convexity: having a nonempty interpre\u00adtation relative to some assignment \nis the same as having a nonempty interpretation relative to the common canonical assignment. This stronger \nproperty makes the apparently weaker relation de.ned by (4) equivalent, in our particular model, to the \nfull semantic sub\u00adtyping relation Castagna and Xu de.ned. This allows us to reduce the problem of deciding \ntheir relation to a question of inclusion be\u00adtween .xed interpretations, making the addition of polymorphism \na mostly straightforward extension to the logical encoding we pre\u00adsented for the monomorphic case. Interestingly, \nin [5] the authors suggest that convexity constrains the relation enough that it should allow reasoning \non types, simi\u00adlarly to the way parametricity allowed Wadler [16] to deduce the\u00ad orems for free from \ntyping information. The fact that our logical reasoning approach very naturally has this convexity property \n indeed, it is dif.cult to think of a logical representation of variables which would not have it seems \nto corroborate their intuition, al\u00adthough reasoning on types beyond deciding subtyping is currently left \nas future work. We now show how this extension of the type system is encoded in our logic.  5.3 Logical \nencoding of variables We extend the logic with atomic propositions a which behave simi\u00adlarly as s except \nthey are not mutually exclusive. The interpretation of these propositions is de.ned as: [a] = {(sL[tl],c) \n| .(a) . L} [\u00aca] = {(sL[tl],c) | .(a) . L}The translation form(t) of types into formulas is extended \nin the obvious way by form(a)= a. THEOREM 5.3. With these extended de.nitions, F[fullform(t )] = [t]. \nProof (sketch): Preliminary remark: whenever . does not contain any (2) at toplevel (which is the case \nof the formulas representing types), then [.] = F[.] \u00d7 C where C is the set of all possible contexts. \nHence, when considering such formulas, set-theoretic relations between full interpretations are equivalent \nto the same relations between .rst components. First we check that F[isd] = D and reformulate the statement \nas Dn F[form(t)] = [t ]. We make the embedding function tree explicit for greater clar\u00adity. What we have \nto show is that, for any d in D, we have (d : t) if and only if (tree(d),c) is in [form(t )] for some \n(or, equivalently, for any) c. The property is proved by induction on the pair (d, t ), following the \nde.nition of the predicate: for (c : b) it holds by de.nition.  for ((d1,d2)L : t1 \u00d7 t2), let f =(tree((d1,d2)L),c). \nf is in [form(t1 \u00d7 t2)] if and only if f (1) is in [form(t1)] and f (1)(2) is in [form(t2)]. (We already \nknow that the node name is (\u00d7) by the structure of d.) Just see that the tree rooted at f (1) is tree(d1) \nand the one at f (1)(2) is tree(d2).  for functions, use the .nite unfolding property and the fact \nthe set of pairs is .nite, then see, similarly as above, that the correct properties are enforced when \nnavigating the tree.  for union, negation and empty types, use the preliminary re\u00admark.  for (d : a), \njust see that d . .(a) and d . F[a] both mean that the root node of d, which is the node at focus in \nthe formula, bears the label .(a).  for (d : \u00b5v.t ), use the property that the interpretation of a .xpoint \nformula and its unfolding are the same (lemma 4.2 of [10]).  COROLLARY 5.4. t1 t2 holds if and only \nif fullform(t1 .\u00act2), or alternatively isd . form(t1) .\u00acform(t2), is unsatis.able.  5.4 Complexity LEMMA \n5.5. Provided two types t1 and t2, the subtyping relation t1 t2 can be decided in time 2O(|t1|+|t2|) \nwhere |ti| is the size of ti. Proof (sketch): The logical translation of types performed by the function \nform(\u00b7) does not involve duplication of subformulas of variable size, therefore form(t ) is of linear \nsize with respect to |t|. Since isd has constant size, the whole translation fullform(t) is linear in \nterms of |t |. For testing satis.ability of the logical for\u00admula, we use the satis.ability-checking algorithm \npresented in [10] whose time complexity is 2O(n) in terms of the formula size n. 6. Practical Experiments \nIn this section we report on some interesting lessons learned from practical experiments with the implementation \nof the system in order to prove relations in the type algebra. 6.1 Implementation The algorithm for \ndeciding the subtyping relation has been fully implemented on top of the satis.ability solver introduced \nin [10]. Our implementation is publicly available. Interaction with the sys\u00adtem is offered through a \nuser interface in a web browser. The system is available online at: http://wam.inrialpes.fr/websolver/ \n A screenshot of the interface is given in Figure 1. The user can either enter a formula through area \n(1) of Figure 1 or select from pre-loaded analysis tasks offered in area (4) of Figure 1. The level of \ndetails displayed by the solver can be adjusted in area (2) of Figure 1 and makes it possible to inspect \nlogical translations and statistics on problem size and the different operation costs. The results of \nthe analysis are displayed in area (3) of Figure 1 together with counter-examples. In the polymorphic \nsetting, a counter-example, that is, a model satisfying a formula, is in principle, according to the \nextended se\u00admantics, a labelled tree. However, as mentioned in Section 5.2, whenever a formula is satis.able \nthere always exists an in.nity of possible labellings which satisfy it. Therefore, rather than propos\u00ading \njust one labelled tree, the solver gives a minimal tree together with labelling constraints representing \nall labellings which make that particular tree a counter-example. Namely, for each variable a, every \nnode will be labelled with a to indicate that it must be labelled with a for the formula to be satis.ed, \nwith \u00aca to indi\u00adcate that it must not be, or with nothing if label a is irrelevant for that particular \nnode. This allows an easier interpretation of the counter-example in terms of assignments: the subtyping \nrelation fails whenever the assignment for each variable a contains all the trees whose root is marked \nwith a and none of those whose root is marked with \u00aca.  Figure 1. Screenshot of the Interface. 6.2 \nConcrete Syntax for Type Algebra All the examples in the subsection that follows can be tested in our \nonline prototype. For this purpose, the following table gives the correspondence between the syntax used \nin the paper and the syntax that must be used in the implementation. Additionally, the embedding of a \nbase formula of the logic into a base type is provided by curly braces: {.} is an abbreviation for isbase.(1) \n.. Paper Syntax Implementation Syntax Type variables a, \u00df, . _a, _b, _g Type constructors \u00d7, . *, -> \nRecursive types \u00b5v.t let $v = t in $v Basic types 0, 1 F, T Logical connectives ., ., \u00ac, . &#38;, |, \n, => Subtyping \u00ac(t1 t2) nsubtype(t1,t2)  6.3 Examples and Discussion The goal of this subsection is \nto illustrate through some examples how our logical setting is natural and intuitive for proving subtyp\u00ading \nrelations. For example, one can prove simple properties such as the one below: (a . .) . (\u00df . .)(a . \n\u00df) . . (6) This is formulated as follows: nsubtype((_a -> _g) &#38; (_b -> _g), (_a | _b) -> _g) which \nis automatically compiled into the logical formula shown on Figure 2 and given to the satis.ability solver \nthat returns: Formula is unsatisfiable [16 ms]. which means that no satisfying tree was found for the \nformula, or, in other terms, that the negation of the formula is valid. The  (mu X8.((( (let_mu X5=(((BASE \n&#38; <1>(mu X4.(((~(<1>T) | <1>X4) &#38; (~(<2>T) | <2>X4)) &#38; (~(ERROR) &#38; ~(BASE) &#38; ~(FUNCTION) \n&#38; ~(PAIR))))) | (PAIR &#38; <1>(X5 &#38; <2>(X5 &#38; ~(<2>T))))) | (FUNCTION &#38; (~(<1>T) | <1>X6))), \nX6=(((~(<2>T) | <2>X6) &#38; PAIR) &#38; <1>(X5 &#38; <2>((X5 | (ERROR &#38; ~(<1>T))) &#38; ~(<2>T)))) \nin X5) &#38; ((FUNCTION &#38; (~(<1>T) | <1>(mu X1.((~(<2>T) | <2>X1) &#38; <1>(~(_a) | <2>_g))))) &#38; \n(FUNCTION &#38; (~(<1>T) | <1>(mu X2.((~(<2>T) | <2>X2) &#38; <1>(~(_b) | <2>_g))))))) &#38; (~(FUNCTION) \n| (<1>T &#38; (~(<1>T) | <1>(mu X7.((<2>T &#38; (~(<2>T) | <2>X7)) | (~(<1>T) | <1>((_a | _b) &#38; (~(<2>T) \n| <2>~(_g)))))))))) | (<1>X8 | <2>X8))) Figure 2. Logical translation tested for satis.ability. satis.ability \nsolver is seen as a theorem prover since its run built a formal proof that property (6) holds. Jer\u00f4me \nVouillon [15] uses simple examples with lists to illus\u00ad trate polymorphism with recursive types. For \ninstance, consider the type of lists of elements of type a: tlist = \u00b5v.(a \u00d7 v) . nil where nil is a singleton \ntype. The type of lists of an even number of such elements can be written as: teven = \u00b5v.(a \u00d7 (a \u00d7 v)) \n. nil By giving the following formula to the solver : nsubtype(let $v = (_a * _a * $v) | {nil} in $v, \nlet $w= (_a * $w) | {nil} in $w ) which is found unsatis.able, we prove that teven tlist If we now consider \nthe type of lists of an odd number of elements of type a: todd = \u00b5v.(a \u00d7 (a \u00d7 v)) . (a \u00d7 nil) we can \ncheck additional properties in a similar manner, like: (teven . todd tlist) . (tlist teven . todd) The \nfollowing formula corresponds to the example (1) of the intro\u00ad duction: bool() = {true|false}; list() \n= let $l = (_a * $l) | {nil} in $l; odd() =let$o =(_a* _a*$o)|(_a *{nil})in$o; even() = let $e = (_a \n* _a * $e) | {nil} in $e; nsubtype ( (odd() -> {true}) &#38; (even() -> {false}), list() -> bool() ) \nThis formula is found unsatis.able by the solver, which proves the validity of the subtyping statement \n(1). Giuseppe Castagna (see section 2.7 of [5]) gives some examples of non-trivial relations that hold \nin the type algebra. For instance, the reader can check that the types 1 . 0 and 0 . 1 can be seen as \nextrema among the function types: 1 . 0 a . \u00df and a . \u00df 0 . 1 Our system also permitted to detect an \nerror in [5] and provided some helpful information to the authors of [5] in order to .nd the origin of \nthe error and make corrections. Speci.cally, in a former version of [5], the following relation was considered: \n(\u00aca . \u00df) ((1 . 0) . \u00df) . a (7) Authors explained how this relation was proved by their algorithm. However, \nby encoding the relation in our system we found that this relation actually does not hold. Speci.cally, \nthis is formulated as follows in our system: nsubtype (~_a -> _b, ((T -> F) -> _b) | _a) The satis.ability \nsolver, when fed this formula, returns the follow\u00ading counter-example: FUNCTION ~_a (PAIR(FUNCTION _a \n(#, ~_b ERROR), #), #) FUNCTION represents (.) and PAIR represents (\u00d7). This is a binary tree representation \nof the n-ary tree (.)\u00aca[(\u00d7)[(.)a[f] :: O :: f] :: f] which corresponds to the domain element {({}a, O)}\u00aca. \nThe inner (.) node has no children and thus represents the function which always diverges: {}. More precisely, \nit represents a copy f of this function that belongs to the interpretation of a. The root (.) node then \nrepresents a function which is not in [a] and which to f associates an error, while diverging on any \nother input. Now, why is it a counter-example to (7)? As the function di\u00ad verges but on one input f and \nthat input is in [a], it is vacuously true that on all inputs in [\u00aca] for which it returns a result, \nthis result is in [\u00df]. Thus it does have the type on the left-hand side. However, it does not have type \na, nor does it have type ((1 . 0) . \u00df). In\u00addeed, f does have type 1 . 0 and our counter-example function \nassociates to it an error, which is not in [\u00df]. 7. Related Work We review below related works while recalling \nhow the introduc\u00adtion of XML progressively renewed the interests in parametric polymorphism. The seminal \nwork by Hosoya, Vouillon and Pierce on a type system for XML [12] applied the theory of regular expression \ntypes and .nite tree automata in the context of XML. The resulting lan\u00adguage XDuce [11] is a strongly \ntyped language featuring recursive, product, intersection, union, and complement types. The subtyping \nrelation is decided through a reduction to containment of .nite tree automata, which is known to be in \nEXPTIME. This work does not support function types nor polymorphism, but provided a ground for further \nresearch. In particular, Frisch, Castagna and Benzaken provide a gen\u00adtle introduction to semantic subtyping \nin [9]. Semantic subtyping focuses on a set-theoretic interpretation, as opposed to traditional subtyping \nthrough direct syntactic rules. Our logical modeling pre\u00adsented in Section 4 naturally follows the semantic \nsubtyping ap\u00ad proach as the underlying logic has a set-theoretic semantics. Frisch, Castagna and Benzaken \nadded function types to the semantic sub\u00adtyping performed by XDuce s type system. This notably resulted \nin the CDuce language [2]. However, CDuce does not support type variables and thus lacks polymorphism. \nVouillon studied polymorphism in the context of regular types with arrow types in [15]. Speci.cally, \nhe introduced a pattern alge\u00ad bra and a subtyping relation de.ned by a set of syntactic inference rules. \nA semantic interpretation of subtyping is given by ground substitution of variables in patterns. The \ntype algebra has the union connective but lacks negation and intersection. The resulting type system \nis thus less general than ours.  Polymorphism was also the focus of the later work found in [13]. In \n[5], it is explained that at that time a semantically de.ned polymorphic subtyping looked out of reach, \neven in the restrictive setting of [11], which did not account for higher-order functions. This is why \n[13] fell back on a somewhat syntactic approach linked to pattern-matching that seemed dif.cult to extend \nto higher-order functions. Our work shows however that such an extension was possible using similar basic \nideas, only slightly more abstract. The most closely related work is the one found in [5], in the same \nproceedings as the current paper, which solves the problem of de.ning subtyping semantically in the polymorphic \ncase for the .rst time, and addresses the problem of its decision through an ad\u00adhoc and multi-step algorithm, \nwhich was only recently proved to terminate in all cases. Our approach also addresses the problem of \ndeciding their subtyping relation and solves it through a more direct, generic, natural and extensible \napproach since our solution relies on a modeling into a well-known modal logic (the \u00b5-calculus) and on \nusing a satis.ability solver such as the one proposed in [10]. This logical connection also opens the \nway for extending polymorphic types with several features found in modal logics. The work of [3] follows \nthe same spirit than ours: typecheck\u00ad ing is subcontracted to an external logical solver. An SMT-solver \nis used to extend a type-checker for the language Dminor (a core di\u00adalect for M) with re.nement type \nand type-tests. The type-checking relies on a semantic subtyping interpretation but neither function \ntypes nor polymorphism are considered. Therefore, their work is incomparable to ours. The present work \nheavily relies on the work presented in [10] since we repurpose the satis.ability-checking algorithm \nof [10] for deciding the subtyping relation. The goal pursued in [10] was very different in spirit: the \ngoal was to decide containment of XPath queries in the presence of regular tree types. To this end, the \ndecidability of a logic with converse for .nite ordered trees is proved in a time complexity which is \na simple exponential of the size of the formula. The present work builds on these results for solving \nsemantic subtyping in the polymorphic case. 8. Conclusion The main contribution of this paper is to de.ne \na logical encoding of the subtyping relation de.ned in [5], yielding a decision algo\u00ad rithm for it. We \nprove that this relation is decidable with an upper\u00adbound time complexity of 2(n), where n is the size \nof types being checked. In addition, we provide an effective implementation of the decision procedure \nthat works well in practice. This work illustrates a tight integration between a functional language \ntype-checker and a logical solver. The type-checker uses the logical solver for deciding subtyping, which \nin turn provides counter-examples (whenever subtyping does not hold) to the type\u00adchecker. These counterexamples \nare valuable for programmers as they represent evidence that the relation does not hold. As a result, \nour solver represents a very attractive back-end for functional pro\u00adgramming languages type-checkers. \nThis result pushes the integration between programming lan\u00adguages and logical solvers to an advanced \nlevel. The proposed log\u00adical approach is not only capable of modeling higher order func\u00adtions, but it \nis also capable of expressing values from semantic domains that correspond to monadic second-order logics \nsuch as XML tree types. This shows that such logical solvers can become the core of XML-centric functional \nlanguages type-checkers such as those used in CDuce or XDuce. Acknowledgments. We are thankful to Giuseppe \nCastagna for bringing our attention to the problem of subtyping with arrow types in the polymorphic case. \nHe gave us precious insights for the pre\u00adcise formulation of the problem, that he also addressed in a \npaper published in the current proceedings. Several people also discussed or exchanged with us about \nsubtyping and polymorphism: Zhiwu Xu, V\u00e9ronique Benzaken and Kim Nguyen. References [1] M. Benedikt and \nJ. Cheney. Destabilizers and independence of XML updates. Proceedings of the VLDB Endowment, 3(1):906 \n917, 2010. [2] V. Benzaken, G. Castagna, and A. Frisch. CDuce: an XML-centric general-purpose language. \nIn Proceedings of the 8th international conference on functional programming (ICFP 03), pages 51 63, \nUp\u00adpsala, Sweden, 2003. http://doi.acm.org/10.1145/944705. 944711. [3] G. M. Bierman, A. D. Gordon, C. \nHri\u00b8tcu, and D. Langworthy. Se\u00admantic subtyping with an SMT solver. In Proceedings of the 15th in\u00adternational \nconference on functional programming (ICFP 10), pages 105 116, Baltimore, MD, USA, 2010. http://doi.acm.org/10. \n1145/1863543.1863560. [4] S. Boag, D. Chamberlin, M. F. Fern\u00e1ndez, D. Florescu, J. Robie, and J. Sim\u00e9on. \nXQuery 1.0: An XML query language, W3C recommen\u00addation, 2007. [5] G. Castagna and Z. Xu. Set-theoretic \nfoundation of parametric poly\u00admorphism and subtyping. In Proceedings of the 16th international conference \non functional programming (ICFP 11), Tokyo, 2011. [6] J. Clark and S. DeRose. XML path language (XPath) \nversion 1.0, W3C recommendation, 1999. http://www.w3.org/TR/1999/ REC-xpath-19991116. [7] L. M. de Moura \nand N. Bj\u00f8rner. Z3: An ef.cient SMT solver. In Proceedings of the 14th international conference on tools \nand al\u00adgorithms for the construction and analysis of systems (TACAS 08), pages 337 340, Budapest, 2008. \nhttp://dx.doi.org/10.1007/ 978-3-540-78800-3_24. [8] D. Engovatov and J. Robie. XQuery 3.0 requirements, \nW3C working draft, 2010. http://www.w3.org/TR/xquery-30-requirements [9] A. Frisch, G. Castagna, and \nV. Benzaken. Semantic subtyping: dealing set-theoretically with function, union, intersection, and negation \ntypes. Journal of the ACM, 55(4):1 64, 2008. [10] P. Genev\u00e8s, N. Laya\u00efda, and A. Schmitt. Ef.cient static \nanalysis of XML paths and types. In Proceedings of the 28th conference on programming language design \nand implementation (PLDI 07), pages 342 351, San Diego, CA, USA, 2007. http://doi.acm.org/10. 1145/1250734.1250773. \n[11] H. Hosoya and B. C. Pierce. XDuce: A statically typed XML process\u00ading language. ACM Transactions \non Internet Technology, 3(2):117 148, 2003. http://doi.acm.org/10.1145/767193.767195. [12] H. Hosoya, \nJ. Vouillon, and B. C. Pierce. Regular expression types for XML. ACM Transactions on Programming Languages \nand Sys\u00adtems, 27:46 90, 2005. http://doi.acm.org/10.1145/1053468. 1053470. [13] H. Hosoya, A. Frisch, \nand G. Castagna. Parametric polymorphism for XML. ACM Transactions on Programming Languages and Systems, \n32(1):1 56, 2009. [14] J. C. Reynolds. Types, abstraction and parametric polymorphism. In IFIP Congress, \npages 513 523, 1983. [15] J. Vouillon. Polymorphic regular tree types and patterns. In Pro\u00adceedings of \nthe 33rd symposium on principles of programming lan\u00adguages (POPL 06), pages 103 114, Charleston, SC, \nUSA, 2006. http://doi.acm.org/10.1145/1111037.1111047. [16] P. Wadler. Theorems for free! In Proceedings \nof the 4th interna\u00adtional conference on functional programming languages and com\u00adputer architecture (FPCA \n89), pages 347 359, London, 1989. http: //doi.acm.org/10.1145/99370.99404.     \n\t\t\t", "proc_id": "2034773", "abstract": "<p>We consider a type algebra equipped with recursive, product, function, intersection, union, and complement types together with type variables and implicit universal quantification over them. We consider the subtyping relation recently defined by Castagna and Xu over such type expressions and show how this relation can be decided in EXPTIME, answering an open question. The novelty, originality and strength of our solution reside in introducing a logical modeling for the semantic subtyping framework. We model semantic subtyping in a tree logic and use a satisfiability-testing algorithm in order to decide subtyping. We report on practical experiments made with a full implementation of the system. This provides a powerful polymorphic type system aiming at maintaining full static type-safety of functional programs that manipulate trees, even with higher-order functions, which is particularly useful in the context of XML.</p>", "authors": [{"name": "Nils Gesbert", "author_profile_id": "81436593623", "affiliation": "INRIA, Montbonnot Saint-Martin, France", "person_id": "P2801380", "email_address": "nils.gesbert@inria.fr", "orcid_id": ""}, {"name": "Pierre Genev&#232;s", "author_profile_id": "81331492783", "affiliation": "CNRS, Montbonnot Saint-Martin, France", "person_id": "P2801381", "email_address": "pierre.geneves@inria.fr", "orcid_id": ""}, {"name": "Nabil Laya&#239;da", "author_profile_id": "81100149392", "affiliation": "INRIA, Montbonnot Saint-Martin, France", "person_id": "P2801382", "email_address": "nabil.layaida@inria.fr", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034789", "year": "2011", "article_id": "2034789", "conference": "ICFP", "title": "Parametric polymorphism and semantic subtyping: the logical connection", "url": "http://dl.acm.org/citation.cfm?id=2034789"}