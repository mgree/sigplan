{"article_publication_date": "09-19-2011", "fulltext": "\n Proving the Unique Fixed-Point Principle Correct An Adventure with Category Theory Ralf Hinze Daniel \nW. H. James Department of Computer Science, University of Oxford, Wolfson Building, Parks Road, Oxford, \nOX1 3QD, England {ralf.hinze, daniel.james}@cs.ox.ac.uk Abstract Say you want to prove something about \nan in.nite data-structure, such as a stream or an in.nite tree, but you would rather not subject yourself \nto coinduction. The unique .xed-point principle is an easy\u00adto-use, calculational alternative. The proof \ntechnique rests on the fact that certain recursion equations have unique solutions; if two elements of \na coinductive type satisfy the same equation of this kind, then they are equal. In this paper we precisely \ncharacterize the conditions that guarantee a unique solution. Signi.cantly, we do so not with a syntactic \ncriterion, but with a semantic one that stems from the categorical notion of naturality. Our development \nis based on distributive laws and bialgebras, and draws heavily on Turi and Plotkin s pioneering work \non mathematical operational semantics. Along the way, we break down the design space in two dimensions, \nleading to a total of nine points. Each gives rise to varying degrees of expressiveness, and we will \ndiscuss three in depth. Furthermore, our development is generic in the syntax of equations and in the \nbehaviour they encode we are not caged in the world of streams. Categories and Subject Descriptors D.2.4 \n[Software/ Program Veri.cation]: correctness proofs, formal methods; F.3.1 [Logics and Meanings of Programs]: \nSpecifying and Verifying and Rea\u00adsoning about Programs speci.cation techniques General Terms Languages, \nTheory, Veri.cation Keywords unique .xed-points, bialgebras, distributive laws 1. Introduction Whence \ncometh this? Our aim is to provide an elegant proof of correctness for an elegant proof principle. Elegance \ncomes, in large part, through simplicity, and speci.cally we value the simplicity af\u00adforded by the notion \nof naturality and initial/.nal algebra/coalgebra semantics. The key component for correctness of the \nunique .xed\u00adpoint principle is a sound characterization of what gives a recursion equation a unique solution. \nWhy does uniqueness matter? Uniqueness has two complemen\u00adtary perspectives: programs and proofs. When \nread as a program, the unique solution implies that it is well-de.ned. When the unicity is utilized in \na proof, we are able to show that two given solutions are equal the unique .xed-point principle (UFP). \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n11, September 19 21, 2011, Tokyo, Japan. Copyright c &#38;#169; 2011 ACM 978-1-4503-0865-6/11/09. . . \n$10.00 1/1 1/2 2/1 2/3 1/33/1  3/53/41/42/55/24/14/35/3 5/84/74/55/72/71/53/73/88/37/35/17/27/55/47/48/5 \n Figure 1. The Bird tree Why not a syntactic criterion? In prior work [10] a simple syntactic criterion, \nspeci.c to stream equations, was proffered, but this is unsatisfactory. A criterion must exclude all \nbad things and accept as many good things as possible. As criteria are complicated to accept more good \nthings, so is the understanding and trust. Their syntactic nature makes them intrinsically fragile. Just \nas it is often easy to satisfy a criterion by a program transformation, it is just as easy to lose the \nsatisfaction. Category complex Our theoretical underpinnings, distributive laws and bialgebras, draw \non Turi and Plotkin s mathematical op\u00aderational semantics [21], and just as in theirs, the following \npages contain plenty of category theory. However, our concern throughout is making the theory accessible. \nWe do so by grounding it in an ap\u00adplication, and targeting the categorical parlance to readers who are \nfamiliar with the Algebra of Programming [5]. This is the holy trin\u00adity of categories, functors and natural \ntransformations, along with algebras and coalgebras, which we will summarize. For the cate\u00adgorically \nenlightened, we will note the more direct reasoning. Interpretation of categorical structures We will \nintroduce a se\u00adlection of categorical structures and discuss their interpretation in this domain. It \nis well known that free monads can been seen as terms with variables and cofree comonads as labelled \ntrees, but we will see how these and two other structures in.uence the expressiv\u00adity of recursion equations, \nby the language features they induce. These features are positioned in two dimensions. We will focus \non just one, and we give a fuller account in the extended paper [11]. As a small exception, we will consider \nwhat Niqui and Rutten [16] calls sampling functions, and what we would more loosely describe as stream \noperators that consume more than they produce. Beauty and Elegance We hope to showcase the beauty of \nthe unique .xed-point principle. Its elegance is due, in no small part, to its calculational style, a \nstyle that proofs will follow throughout. 2. The Unique Fixed-Point Principle 2.1 In.nite Trees In Figure \n1 we can see the .rst .ve levels of the Bird Tree [9], an in.nite tree in which you can .nd every positive \nrational number exactly once. It has several remarkable properties that come from its nature as a fractal \nobject its subtrees are similar to the whole tree. The tree can be transformed into its left subtree \nby increment\u00ading and then taking the reciprocal of every element; the right sub\u00adtree is obtained by swapping \nthese operations. This description can be nicely captured by a corecursive de.nition (we will use Haskell \nas a meta-language for the category of sets and total functions):  bird = Node 1 (1 / (bird + 1)) ((1 \n/ bird) + 1) . The picture suggests that taking the reciprocal of each element is the same as mirroring \nthe tree, mirror bird =1 / bird, and this is indeed the case. We shall see that we can prove this effortlessly \nusing the unique .xed-point principle. Before we get to the proof, we must introduce some de.nitions. \ndata Tree x = Node {root :: x, left :: Tree x, right :: Tree x} The type Tree x is a so-called coinductive \ndatatype. Its de.ni\u00adtion is similar to the textbook de.nition of binary trees, except that there are \nno leaves, so we cannot build a .nite tree. And without leaves, mirror is a one-liner: mirror (Node x \nl r)= Node x (mirror r)(mirror l) . The de.nition of bird uses + and / lifted to trees. We obtain these \nliftings for free as Tree is a so-called idiom [14]: class Idiom f where pure :: x -fx (0) :: f (x -y) \n-(fx -fy) instance Idiom Tree where pure x = t where t = Node x t t t 0 u = Node (root t $ root u) (left \nt 0 left u)(right t 0 right u) . The call pure x constructs an in.nite tree of xs; idiomatic applica\u00adtion \n0 takes a tree of functions and a tree of arguments to a tree of results. Using pure and 0, we can lift \narithmetic operations generi\u00adcally to idioms. instance (Idiom f, Num x) . Num (fx) where fromInteger \nn = pure (fromInteger n) negate u = pure negate 0 u u + v = pure (+) 0 u 0 v ... Since the operations \nare de.ned pointwise, the familiar arith\u00admetic laws also hold for trees. Mirroring a tree preserves the \nid\u00adiomatic structure, the function mirror is an idiom homomorphism: mirror (pure x)= pure x and mirror \n(x 0 y)= mirror x 0 mirror y. This implies, for instance, that mirror (u+v)= mirror u+mirror v. Let us \nreturn to the promised proof and the unique .xed-point principle. Consider the recursion equation x = \nNode y l r, where l and r possibly contain the variable x, but not the expressions root x, left x or \nright x. Equations in this syntactic form possess a unique solution. Uniqueness can be exploited to prove \nthat two in.nite trees are equal: if they satisfy the same equation, then they are. mirror bird = { de.nitions \nof mirror and bird }Node 1(mirror ((1 / bird) + 1))(mirror (1 / (bird + 1))) = { mirror is an idiom homomorphism \n}Node 1 ((1 / mirror bird) + 1)(1 / (mirror bird + 1)) .{ x = Node 1 ((1 / x) + 1)(1 / (x + 1)) has a \nunique sol. }Node 1 ((1 / (1 / bird)) + 1)(1 / ((1 / bird) + 1)) = { arithmetic } 1 / Node 1 (1 / (bird \n+ 1)) ((1 / bird) + 1) = { de.nition of bird } 1 / bird The link . indicates that the proof rests on \nthe unique .xed\u00adpoint principle; the recursion equation is given within the curly braces. The upper part \nshows that mirror bird satis.es the equation x = Node 1 ((1 / x) + 1)(1 / (x + 1)); the lower part establishes \nthat 1 / bird satis.es the same equation. The symbol . links the two parts, effectively proving the equality \nof both expressions. We mentioned that the Bird Tree contains every positive rational exactly once. A \nproof that exclusively builds on the unique .xed\u00adpoint principle can be found in Hinze [9].  2.2 Streams \nLet us consider a second coinductive type, one that will accompany us for the rest of the paper: the \ntype of streams, in.nite sequences of elements. data Stream x = Cons {head :: x, tail :: Stream x} (-) \n:: x -Stream x -Stream x x -s = Cons x s Like the type of in.nite trees, Stream is an idiom. instance \nIdiom Stream where pure x = s where s = x -s s 0 t =(head s $ head t) -(tail s 0 tail t) Using this vocabulary, \nwe can de.ne, for instance, the stream of Fibonacci numbers. .b =0 -.b .b =1 -.b + .b The Fibonacci numbers \nsatisfy a myriad of properties. For example, if we form the stream of their partial sums and increment \nthe result, we obtain .b . Again, we shall see that the UFP allows for a concise proof. But .rst, we \nhave to capture summation as a stream operator. S s =0 -s + S s Turning to the proof of S .b +1 = .b \n, we can either show that S .b +1 satis.es the de.ning equation of .b , or that .b - 1 satis.es the recursion \nequation of S .b. Both approaches work, the calculations are left as really (!) easy exercises to the \nreader. A related property is the following: if we sum the Fibonacci numbers at odd positions, we obtain \nthe Fibonacci numbers at even positions. The so-called sampling functions [16] even and odd enjoy simple \ncorecursive de.nitions. even s = head s -odd (tail s) odd s = even (tail s) Turning to the proof of S \n(odd .b)= even .b, we reason: S (odd .b) = { de.nition of S } 0 -odd .b + S (odd .b) = { de.nition of \nodd } 0 -even .b + S (odd .b) .{ x =0 -even .b + x } 0 -even .b + even .b = { even is an idiom homomorphism \nand arithmetic } 0 -even (.b + .b ) = { de.nitions of .b and odd } 0 -odd .b = { de.nitions of .b and \neven } even .b . This completes our short survey. The UFP is not only easy\u00adto-use, but also surprisingly \npowerful: in prior work [10] we have shown how to redevelop the theory of recurrences, .nite calculus \nand generating functions using streams and stream operators, build\u00ading solely on the cornerstone of unique \nsolutions.  What remains to be done? We have been somewhat vague about the syntactic conditions that \nguarantee uniqueness. We shall see that systems of recursion equations can be classi.ed along two di\u00admensions, \nleading to a total of nine different points of interest. The system for .b falls into one ( consume one \nelement, produce one ), the system for even into another ( consume many, but don t nest calls ). When \nde.ning streams we cannot mix styles. For instance, the equation x =0 -even x has in.nitely many solutions. \nWe shall see that we can capture the conditions that guarantee unicity semantically, using the categorical \nconcept of naturality. Furthermore, we abstract away from the type of in.nite trees and streams. The \ndevelopment is generic both in the syntax and in the behaviour which operations are de.ned and over which \ncoin\u00adductive type. An appropriate setting is provided by the categorical notion of algebras and coalgebras \nwhich we introduce next. The re\u00adsulting proofs are not only more general, they are also shorter than \nspeci.c instances that have appeared in the literature [17, 19]. 3. Initial Algebras and Final Coalgebras \nWe hope the reader has encountered the material of this section be\u00adfore, but we will reiterate it here \nas it serves as a simple demonstra\u00adtion of the power of duality. We will invoke the power to construct \nthe opposite thing time and time again. Let F : CC be an endofunctor. An F-algebra is a pair (A, a) - \nconsisting of an object A : C and an arrow a : F AA : C . We say - that A is the carrier and a is the \naction of the algebra; however, we often refer to the algebra simply by a as it determines the carrier. \nAn F-homomorphism between algebras (A, a) and (B, b) is an arrow h : A B : C such that h \u00b7 a = b \u00b7 F \nh. - A characteristic of functors is that they preserve identity and com\u00adposition; this entails that \nF-homomorphisms compose and have an identity. Consequently, F-algebras and F-homomorphisms form a category, \ncalled F-Alg(C ). If this category has an initial object, it is called the initial F-algebra (\u00b5F, in). \nInitiality implies that it has a unique F-homomorphism to any F-algebra (A, a), which is written ((a)) \nand called fold. It satis.es the uniqueness property h = ((a)) .. h \u00b7 in = a \u00b7 F h . (3.1) We will now \nseize the opportunity to dualize these constructions to the opposite things: F-coalgebras and unfolds. \nAn F-coalgebra is a pair (C, c) of an object C : C and an arrow c : C F C : C . - An F-homomorphism between \ncoalgebras (C, c) and (D, d) is an arrow h : CD : C such that F h \u00b7 c = d \u00b7 h. In the same - way, we \ncan form a category F-Coalg(C ). If this category has a .nal object, it is called the .nal F-coalgebra \n(.F, out). Being the .nal object, it has a unique F-homomorphism to it from any F\u00adcoalgebra (C, c), which \nis written [(c)] and called unfold. It satis.es the following uniqueness property. h = [(c)] .. F h \u00b7 \nc = out \u00b7 h (3.2) In case you were wondering, .nal algebras and initial coalge\u00adbras are unexciting, although \nwe will .nd a use for them. The .nal algebra is (1, !F 1), and the initial coalgebra is (0, \u00a1F 0). Let \nF, G : CC be endofunctors, and a : F ..G a natural - transformation. We can turn a into a functor a-Alg \n: F-Alg - G-Alg between the categories of F-and G-algebras. (We use ..to highlight the contravariance \nbetween a and a-Alg.) a-Alg (X, a : F XX) = (X, a \u00b7 a X : G XX) a-Alg h = h That a-Alg is a functor follows \nfrom a more general construction given in Appendix B. We will see various instantiations of a-Alg later \non, where its functor properties will come in handy. 4. Meet Iniga and Finn Once upon a time a teacher \nhad a pair of bright and capable students, who, for better or worse, were hooked on category theory. \nThe .rst, Iniga, was a go-getting student with plenty of initiative. Interestingly, this was in stark \ncontrast to Finn, a reserved character who perceived the world with a sense of .nality. The teacher posed \nthem the problem of demonstrating that a system of stream equations has a unique solution. Owing to their \npolar opposite outlooks, Iniga and Finn took divergent approaches to tackling the problem, but as we \nwill discover, their approaches turned out to be two sides of the same coin. The teacher started with \na minimalistic example, asking them to consider the following stream equations. one =1 -one plus (Cons \nm s, Cons n t)=(m + n) -plus (s, t) Streams of natural numbers are the resultant behaviour of these equations, \nso the teacher provided the functor B X = N \u00d7 X as the behaviour functor. We can give this a Haskell \nrendering: data B x = Cons (N, x) . For simplicity, the teacher .xed the element type of streams. An \nelement of .B, the carrier of the .nal coalgebra of the behaviour functor, is a stream of natural numbers: \n.B ~ = Stream N. The stream constant one and the stream operator plus in the example stream equations \nare also modelled categorically with the functor S X =1+ X \u00d7 X as the syntax functor. data S x = One \n| Plus (x, x) An element of \u00b5S, the initial algebra carrier of the syntax functor, is a .nite, closed \nterm, built from the syntax constructors of S. Iniga (taking the initiative): Ok, given these de.nitions \nwe can model the stream equations by a simple function. . (One)= Cons (1, One) . (Plus (Cons (m, s), \nCons (n, t))) = Cons (m + n, Plus (s, t)) Teacher: Observe that . is really a natural transformation \nof type S.B ..B.S. This is crucial: the syntactic requirements on stream equations to ensure uniqueness \nof solutions are captured by the naturality requirement on .. Its type can be seen as a promise that \nonly the head of the incoming stream will be inspected and that an element of the outgoing stream will \nbe constructed. Can you see how the slogan consume one, produce one translates? Iniga: Yes! An interpretation \nof the syntax is then given by an S-algebra a : S (.B) .B whose carrier is the .nal B-coalgebra - (.B, \nout). The algebra a takes a level of syntax over a stream and turns it into a stream. Teacher: How do \nwe model that a respects the stream equations captured by .? Your algebra a has to satisfy the following \nlaw: out \u00b7 a = B a \u00b7 . (.B) \u00b7 S out : S (.B) B (.B) . (4.1) - The law states that unrolling the result \nof a is the same as un\u00adrolling the arguments of the syntax, S out, applying the stream equations . (.B), \nand then interpreting the tail, B a. Iniga: Great, for our example I will rearrange the law to ob\u00adserve \nthe Haskell convention of de.nition by pattern matching, a \u00b7 S out. = out. \u00b7 B a \u00b7 . (.B). If I instantiate \nthis law to our running example, I obtain a de.nition of the algebra a:  a One = Out. (Cons (1, a One)) \na (Plus (Out. (Cons (m, s)), Out. (Cons (n, t)))) = Out. (Cons (m + n, a (Plus (s, t)))) . With a, I \ncan now de.ne the semantic counterparts of One and Plus, the stream constant one and the stream operator \nplus, underlined to emphasize that they are semantic entities: one = a One plus (s, t)= a (Plus (s, t)) \n. Teacher (interrupting): You are actually building upon the isomorphism S XX ~(1 X) \u00d7 (X \u00d7 XX) here: \nthe pair of = functions, one and plus, is just another way of writing the algebra a. Iniga: Using a -s \nas a shorthand for Out. (Cons (a, s)), the de.nition of a is the same as, one =1 -one plus (Cons m s, \nCons n t)= m + n -plus (s, t) , that is one and plus satisfy the original stream equations. Again, the \nnotation makes clear that we have to read the stream operators semantically one and plus are the entities \nde.ned by the system. Teacher: We can wrap this up by showing that the law (4.1) uniquely determines \na: out \u00b7 a = B a \u00b7 . (.B) \u00b7 S out .. { uniqueness of unfold (3.2) } a = [(. (.B) \u00b7 S out)] So [(. (.B) \n\u00b7 S out)] is the unique solution of the stream equations. Furthermore, the fold ((a)) : \u00b5S .B takes syntax \nto behaviour by - evaluating a term. Finn, what are your thoughts? Finn: To start with, I would write \nthe stream equations differ\u00adently. I .nd them too Haskell-like, and I prefer what Jan Rutten calls behavioural \ndifferential equations [17]. head one =1 tail one = one head (plus (s, t)) = head s + head t tail (plus \n(s, t)) = plus (tail s, tail t) A semantics is given by a B-coalgebra c : \u00b5SB (\u00b5S) whose - carrier is \nthe initial S-algebra (\u00b5S, in). The coalgebra c takes a term and produces the .rst number of the de.ned \nstream, and a term to generate the rest of the stream. Teacher: Just as for Iniga, your coalgebra c has \nto satisfy the following law: c \u00b7 in = B in \u00b7 . (\u00b5S) \u00b7 S c : S (\u00b5S) B (\u00b5S) . (4.2) - The law states that \nbuilding a term and applying c is the same as giving a semantics to the subterms, S c, applying the stream \nequations . (\u00b5S), and building a term in the tail of a stream, B in. Finn: I will follow Iniga s lead \nand specialize the law to our example, obtaining a de.nition of c: c (In One) = Cons (1, In One) c (In \n(Plus (s, t))) = Cons (head (cs)+ head (ct), In (Plus (tail (cs), tail (ct)))) , where head (Cons (a, \ns)) = a and tail (Cons (a, s)) = s. Given a stream program, my c gives the head of the stream and a stream \nprogram for the tail of the stream. I can now de.ne the semantic counterparts of head and tail: head \ns = head (cs) tail s = tail (cs) . Teacher: You are building upon the isomorphism X B X ~ = - (XN)\u00d7(XX) \nhere: head and tail is just another way of writing c. Finn: Using one as a shorthand for In One and plus \n(s, t) for In (Plus (s, t)), the de.nition of c is the same as, head one =1 tail one = one head (plus \n(s, t)) = head s + head t tail (plus (s, t)) = plus (tail s, tail t) , that is, head and tail satisfy \nthe original stream equations. The notation emphasizes that we have to read the stream selectors semantically \nhead and tail are the entities de.ned by the system. Teacher: Again, we can show that the law (4.2) determines \nc: c \u00b7 in = B in \u00b7 . (\u00b5S) \u00b7 S c .. { uniqueness of fold (3.1) } c = ((B in \u00b7 . (\u00b5S))) So ((B in \u00b7 . (\u00b5S))) \nis the unique solution of your stream equations. And the unfold [(c)] : \u00b5S.B takes syntax to behaviour \nby unrolling - a complete stream. Iniga and Finn, you should reconcile your two viewpoints. Your semantic \nfunctions are of type \u00b5S .B, so is the fold of Iniga s - algebra the same as the unfold of Finn s coalgebra: \n((a)) =[(c)]? Did you notice that we made use of the naturality of .: Iniga used . at type .B, while \nFinn required the \u00b5S instance? For now, we have only discussed a minimalistic example, and we are not \nimmediately able to model stream equations such as the ones that de.ne the Fibonacci stream: there is \nmore to this story. Epilogue Now that we have met Iniga and Finn and got a taste for the problem that \ntheir teacher posed to them, we will move on to introduce the infrastructure that is needed for the reconciliation. \n5. Bialgebras Let S, B : CC be functors. A bialgebra is a triple (X, a, c) - consisting of an object \nX : C , an arrow a : S XX : C , - and an arrow c : X B X : C . It is an S-algebra and a B\u00ad - coalgebra \nwith a common carrier. Let (X, a, c) and (Y, b, d) be bialgebras and h : XY : C an arrow. Then h is a \nbialgebra - homomorphism if it is both an S-algebra homomorphism and a B\u00adcoalgebra homomorphism. S X \nS h ' S Y a l X h b l ' Y c l B X B h d l ' B Y Identity is a bialgebra homomorphism and homomorphisms \ncom\u00adpose. Consequently, bialgebras and their homomorphisms form a category, called Bialg(C ). We are \nconcerned with .-bialgebras, which are bialgebras equipped with a so-called distributive law . : S.B \n..B.S. This extra structure imposes a coherence condition on bialgebras. c \u00b7 a = B a \u00b7 . X \u00b7 S c (5.1) \n The condition is also called the pentagonal law. S X (5.2) a S (B X) l X . X l B (S X) l B a B X \nThe category of bialgebras that satisfy the pentagonal law (5.2) is denoted .-Bialg(C ). It is a full \nsubcategory of Bialg(C ). 6. Iniga and Finn with Bialgebraic-tinted Glasses We will now use .-bialgebras \nto explicate Iniga and Finn s conver\u00adsation with their teacher, and begin to reconcile their solutions. \nLet S, B : CC be functors, and . : S.B ..B.S be a natural - transformation. We will read these to imply \nsyntax and behaviour functors, and a distributive law modelling a set of equations. Using .-bialgebras, \nwe will characterize the semantic function from syn\u00adtax to behaviour the arrow from the least .xed-point \nof S to the greatest .xed-point of B. The algebra (\u00b5F, in) is the initial object in F-Alg. We will now \nshow that from this we can form the initial object in .-Bialg. If the carrier has been .xed as \u00b5S, then \nthe coalgebra will have type \u00b5SB (\u00b5S). This is exactly Finn s coalgebra, and his teacher has - derived \nit: ((B in \u00b7 . (\u00b5S))) . As one might guess, the laws the teacher provided came from .-bialgebras. Let \nus take a step back to re\u00adexamine . and the pentagonal law. 6.1 Lifting Endofunctors to Algebras The \npentagonal law confers a useful property both on the algebra and the coalgebra component of a .-bialgebra. \nLet us illustrate this .rst for the coalgebra component by redrawing diagram (5.2). B. a Here we can \nsee that c is not only a B-coalgebra, but also an S\u00adalgebra homomorphism from (X, a) to (B X, B a \u00b7 . \nX). We can characterize this situation as lifting the endofunctor B : CC to a functor on S-algebras; \nwe will give it the name - B. : S-Alg(C ) -S-Alg(C ), and de.ne it as, B. (X, a : S X -X) = (B X, B a \n\u00b7 . X : S (B X) -B X) , (6.1) B. h = B h . (6.2) For notational simplicity, we shall employ lifted functors \nsynec\u00addochically: by B. a we mean B. (X, a), a is used pars pro toto, and in certain contexts, B. a is \nused totum pro parte for the arrow of the resultant algebra, B a \u00b7 . X. That B. is a functor follows \nfrom a more general construction given in Appendix B. For reference, we record that it preserves S-algebra \nhomomorphisms. B h : B. a B. b : S-Alg .= h : ab : S-Alg (6.3) Therefore, we can give c, viewed as an \nalgebra homomorphism, the more succinct type c : a B. a : S-Alg. - Dually, a is both an S-algebra and \na B-coalgebra homomorph\u00adism, with the type a : S. cc : B-Coalg, where the lifted functor - S. : B-Coalg(C \n) B-Coalg(C ) is de.ned as, - S. (X, c : X B X) = (S X, . X \u00b7 S c : S X B (S X)) , (6.4) S. h = S h . \n(6.5) By duality, S. is functorial, as well.  6.2 Initial and Final Objects Our initial .-bialgebra \nwill be (\u00b5S, in, ((B. in)) ), as depicted below. S ((a)) ' S (\u00b5S) S X a in @ l ((a)) l C ' \u00b5S X c ((B. \nin)) @ ll ' B (\u00b5S) B X B ((a)) We have three proof obligations. First we must show that the triple (\u00b5S, \nin, ((B. in)) ) is indeed a .-bialgebra (C) it has the right types, but it must also satisfy (5.1). ((B. \nin)) \u00b7 in = { fold computation (\u00a7A) } B. in \u00b7 S ((B. in)) = { de.nition of B. (6.1) } B in \u00b7 . (\u00b5S) \u00b7 \nS ((B. in)) The second obligation, that ((a)) is an S-algebra homomorphism is by construction the top \nhalf of the diagram commutes (@). Moreover, the uniqueness of this arrow comes for free. Finally, we \nmust show that ((a)) is also a B-coalgebra homomorphism that the bottom half of the diagram commutes \n(@). c \u00b7 ((a)) = B ((a)) \u00b7 ((B. in)) .. { fold fusion (\u00a7A) with c : a B. a : S-Alg } - ((B. a)) = B ((a)) \n\u00b7 ((B. in)) .= { fold fusion (\u00a7A) } B ((a)) : B. in B. a : S-Alg - .= { B. functor (6.3) } ((a)) : in \na : S-Alg - We can dualize the results above. We have just used Finn s coalgebra to construct the initial \n.-bialgebra, so naturally we will use Iniga s algebra to construct the .nal .-bialgebra. Indeed, (.B, \n[(S. out)], out) is the .nal .-bialgebra; and [(c)] is the unique homo\u00admorphism from any .-bialgebra \n(X, a, c) to the .nal .-bialgebra. The duality extends to the satisfaction of the proof obligations. \nWe have de.ned the initial and .nal .-bialgebras, and we are now in a position to state the homomorphism \nbetween them the semantic function from syntax to behaviour \u00b5S .B. - ' S (\u00b5S) S (.B) in [(S. out)] l \n(([(S. out)])) l \u00b5S I ' .B [(((B. in)) )] ((B. in)) out l l ' B (\u00b5S) B (.B)  The semantic arrow is \nunique, and we can give two justi.cations for it being so: namely that it is the unique homomorphism \nboth from the initial .-bialgebra and to the .nal .-bialgebra. For the same two reasons, we can give \ntwo de.nitions of this arrow, and by uniqueness they are equal. And just like that, we have the basic \nresolution of Iniga and Finn s seemingly opposing points of view. In a manner of speaking, Iniga and \nFinn s personalities would appear to be entwined. Iniga thought in terms of initial algebras and folds, \nbut ended up constructing the .nal .-bialgebra, and vice versa for Finn. This is not a coincidence as \nthe category of .\u00adbialgebras is isomorphic to a category of algebras over coalgebras. (X, a, c) : .-Bialg(C \n) .. { de.nition of .-bialgebra } c \u00b7 a = B a \u00b7 . X \u00b7 S c .. { de.nition of S. (6.4) } c \u00b7 a = B a \u00b7 \nS. c .. { de.nition of B-coalgebra homomorphism } a : S. (X, c)(X, c) : B-Coalg(C ) - .. { de.nition \nof an S.-algebra } ((X, c), a) : S. -Alg(B-Coalg(C )) The proof shows that the objects are in one-to-one \ncorrespondence. A similar calculation establishes a bijection between arrows. h : (X1, a1, c1)(X2, a2, \nc2) - .. { de.nition of .-bialgebra homomorphism } h \u00b7 a1 = a2 \u00b7 S h . B h \u00b7 c1 = c2 \u00b7 h .. { de.nition \nof B-coalgebra homomorphism } h \u00b7 a1 = a2 \u00b7 S h . h : (X1, c1)(X2, c2) : B-Coalg(C ) - .. { de.nition \nof S.-algebra homomorphism } h : ((X1, c1), a1) ((X2, c2), a2) : S. -Alg(B-Coalg(C )) - As a summary \nof our construction above, for the categorically enlightened, the .nal .-bialgebra is determined by the \n.nal S.\u00adalgebra. Recall that the .nal S-algebra is (1, !S 1). Consequently, the .nal S.-algebra is (1, \n!S. 1) = ((.B, out), [(S. out)]) as (.B, out)is the .nal object in B-Coalg(C ). Dually, we can view a \nbialgebra as a coalgebra over algebras. S. -Alg(B-Coalg(C )) .-Bialg(C ) ~(6.6) = B. -Coalg(S-Alg(C \n)) The double isomorphism says that there are actually two ways to determine initial and .nal objects \nin .-Bialg(C ). The reader is encouraged to work out the details. 7. A Step along the Categorical Brick \nRoad. . . Distributive laws of type S.B..B.S are not suf.ciently expressive to model the recursion equations \nfor bird and .b as their right-hand sides consist of more than one layer of syntax. In general, we need \nterms, elements of the free monad for the syntax functor. However, rather than making a beeline for free \nmonads, we will visit pointed functors as a stepping stone. This is an adventure with category theory \nafter all, and the fun is in the journey. Example 7.1. Suspend your disbelief and suppose that you need \nthe identity operator on streams, de.ned by the equation, id (Cons m s)= m -s . A system containing this \nequation cannot be turned into a distribu\u00adtive law . : S.B ..B.S as the stream s is not an element of \nthe syntax functor S. To solve this, we can allow for variables or con\u00adstructors of S. data P x = Var \nx | Con (S x) data S x = Id x | One | ... A system of recursion equations is now captured by a natural \ntransformation . of type S.B ..B.P. . (Id (Cons (m, s))) = Cons (m, Var s) . (One)= Cons (1, Con One) \n... Note that we have only replaced S on the right-hand side, where there is a need. We shall later restore \nsymmetry and show how to turn . into a distributive law (Section 7.3). Furthermore, this is a very limited \nintroduction of variables: one can either have a variable, or a constructor, but no variables as arguments. \nThe Haskell type P is the so-called free pointed functor of S [13]. We will discuss pointed functors \nin general and then return to the free construction in Section 7.1. De.nition 7.2. We say that an endofunctor \nT : CC is pointed - if it is equipped with a natural transformation . : Id ..T. We are going to build \non the picture we laid out in the previous section by replacing the plain endofunctor with a pointed \nfunctor. The extra structure that we have introduced with . has two impli\u00adcations: .rst with regards \nto the distributive law . and second with regards to constructing algebras of pointed functors. Condition \n7.3. A distributive law . : T.B ..B.T for a pointed functor T has an additional coherence condition to \nsatisfy: . \u00b7 ..B = B.. . (7.1) Condition 7.4. If we construct an algebra (X, a : T XX) of a - pointed \nfunctor T, then it must respect .: a \u00b7 .X = idX . (7.2) For full speci.city we will say that (T, .)-Alg(C \n) is the cate\u00adgory of T-algebras that respect .. This is a full subcategory of T\u00adAlg(C ). Henceforth, \nwe will be working with .-bialgebras based on (T, .)-algebras and B-coalgebras. The double isomorphism \n(6.6) succinctly tells the story of initial and .nal objects in .-Bialg. In a sense, Conditions 7.3 and \n7.4 ensure that we can establish an analogous isomorphism for pointed functors. The following two properties \nprepare the ground. Property 7.5. Let c : X B X be a B-coalgebra, then - .X : c T. c : B-Coalg(C ) , \n(7.3) - is the lifting of . to a B-coalgebra homomorphism. Proof. T. c \u00b7 .X = { de.nition of T. (6.4) \n} . X \u00b7 T c \u00b7 .X = { . : Id ..T is natural } . X \u00b7 .(B X) \u00b7 c = { coherence of . with . (7.1) } B (.X) \n\u00b7 c In other words, the lifted functor T. is pointed as well and we can form (T. , .)-Alg(B-Coalg(C )). \nProperty 7.6. The functor B. preserves respect for .. B. a \u00b7 .(B X)= idB X .= a \u00b7 .X = idX (7.4)  Proof. \nB. a \u00b7 .(B X) = { de.nition of B. (6.1) } B a \u00b7 . X \u00b7 .(B X) = { coherence of . with . (7.1) } B a \u00b7 \nB (.X) = { B functor and assumption a \u00b7 .X = idX }idB X In other words, B. is an endofunctor on (T, .)-Alg(C \n) and we can form B. -Coalg((T, .)-Alg(C )). Summary Properties 7.5 and 7.6 imply that the double isomorphism \n(6.6) carries over to the new setting. (T. , .)-Alg(B-Coalg(C )) .-Bialg(C ) ~(7.5) = B. -Coalg((T, .)-Alg(C \n)) 7.1 Free Pointed Functor Let S : CC be an endofunctor. There is a canonical pointed - functor, with \npleasant properties, that we can construct from S. This is the free pointed functor of S [13], the categorical \nversion of the Haskell type P we saw in Example 7.1, P X = X + S X . (7.6) The natural transformation \n. : Id ..P that equips the free pointed functor is simply . = inl. Our .-bialgebras now have P-algebras, \nbut what about all the S-algebras that we have used previously? All is not lost, in fact far from it. \nTheorem 7.1. The category of algebras for the free pointed functor is isomorphic to the category of S-algebras: \n(P, .)-Alg(C ) ~. = S-Alg(C ) The following de.nitions are the witnesses to this isomorphism. l(X, a \n: S XX)l = (X, idX v a : P XX)lhl = h (7.7) L(X, b : P XX)J = (X, b \u00b7 inr : S XX)LhJ = h (7.8) In particular, \nl-l preserves and re.ects homomorphisms. h : lallbl :(P, .)-Alg(C ) .. h : ab : S-Alg(C ) (7.9) Proof. \n(i) Given an S-algebra a, we can cast it up to a P-algebra lal. Likewise, we can cast a P-algebra b down \nto an S-algebra LbJ. The following proves both directions of the isomorphism. LlalJ lLbJl = { de.nition \nof l-l } = { defs. of L-J and l-l } LidX v aJ idX v b \u00b7 inr = { de.nition of L-J } = { b respects . (7.2) \n} (idX v a) \u00b7 inr b \u00b7 inl v b \u00b7 inr = { join comp. (\u00a7A) } = { join fusion and re.. (\u00a7A) } ab (ii) L-J \nis functorial as inr : S ..P and L-J = inr-Alg (cf. \u00a73). (iii) l-l maps S-homomorphisms to P-homomorphisms. \nFor the proof we refer to the full paper [11]. (iv) Finally, l(X, a)l has to be an algebra for the pointed \nfunctor. That lal respects . (7.2), unfolds to (id v a) \u00b7 inl = id, and this is just an instance of the \njoin computation law (\u00a7A). 7.2 Initial and Final Objects The double isomorphism (7.5) immediately suggests \nhow to de.ne initial and .nal objects in the new setting. Nonetheless, we will slow down a bit and go \nthrough the construction step by step. In Section 6 we explored .-bialgebras over S and B, the functors \nrepresenting syntax and behaviour, respectively. Despite the fact that we are now using the free pointed \nfunctor of S, the carrier of the initial .-bialgebra will remain the same, as we are not changing our \nobjects of syntax. Instead, we are generalizing the evaluation of our syntax. The initial .-bialgebra \nwill be (\u00b5S, a : P (\u00b5S) \u00b5S, - c : \u00b5SB (\u00b5S)), for some a and c that we will now determine. - Previously \nthe algebra component of the initial .-bialgebra was simply in : S (\u00b5S) \u00b5S. This can no longer be the \ncase; we need - an algebra a : P (\u00b5S) \u00b5S. However, now that we can freely cast - between S and (P, .)-algebras, \nwe can use linl : P (\u00b5S) \u00b5S. - The previous coalgebra component was ((B. in)) , and this also no longer \nhas the right type, as our . has changed. Now B. lifts the functor B to a functor on (P, .)-algebras, \nnot S-algebras; ((-)) expects an S-algebra, and in is an S-algebra. We can satisfy these expectations \nwith selective usage of casting: we can cast in up to a (P, .)-algebra so that we can apply B., and furthermore, \nwe can cast the image of B. linl down so that it is an S-algebra that we can fold. The claim is that \n(\u00b5S, linl, (L( B. linlJ)) ) is the initial .-bialgebra and (L( aJ)) is the unique homomorphism to any \n.-bialgebra (X, a, c). There are the three usual proof obligations we must satisfy. For reasons that \nwill become clear, we will start by showing that (L( aJ)) is (P, .)-algebra homomorphism. (L( aJ)) : \nlinl a :(P, .)-Alg (7.10) - This is a direct consequence of Theorem 7.1. (L( aJ)) : linl a :(P, .)-Alg \n- .. { isomorphism (P, .)-Alg ~ = S-Alg (7.9) } (L( aJ)) : in LaJ : S-Alg - Next we will show that (\u00b5S, \nlinl, (L( B. linlJ)) ) is indeed a .\u00adbialgebra, in that it satis.es the pentagonal law (5.1). (L( B. \nlinlJ)) \u00b7linl = { (L( B. linlJ)) : linl B. linl :(P, .)-Alg (7.10) } - B. linl\u00b7 P (L( B. linlJ)) = { \nde.nition of B. (6.1) } B linl\u00b7 . (\u00b5S) \u00b7 P (L( B. linlJ)) Furthermore, (7.2) is satis.ed since l-l creates \nsuch an algebra. Finally, we will show that (L( aJ)) is a B-coalgebra homomorph\u00adism. We know from the \npentagonal law that c is a (P, .)-algebra homomorphism, c : a B. a :(P, .)-Alg. By (7.9) c is also an \nS\u00ad - algebra homomorphism, c : LaJLB. aJ : S-Alg, and as a direct - consequence of fold fusion (\u00a7A), \nc \u00b7 (L( aJ)) =(L( B. aJ)) . c \u00b7 (L( aJ)) = B (L( aJ)) \u00b7 (L( B. linlJ)) .. { fold fusion (\u00a7A) with c : \nLaJLB. aJ : S-Alg } - (L( B. aJ)) = B (L( aJ)) \u00b7 (L( B. linlJ)) .= { fold fusion (\u00a7A) } B (L( aJ)) : \nLB. linlJ LB. aJ : S-Alg - .. { isomorphism (P, .)-Alg ~= S-Alg (7.9) } B (L( aJ)) : B. linl B. a :(P, \n.)-Alg - .= { B. functor (6.3) } (L( aJ)) : linl a :(P, .)-Alg - We have already shown that the last \nstatement holds (7.10).  As before, the .nal .-bialgebra is (.B, [(P. out)], out). The unique .-bialgebra \nhomomorphism to the .nal .-bialgebra from any .-bialgebra (X, a, c) is [(c)]. There is one .nal proof \nobligation: we have to show that [(P. out)] respects . (7.2). [(P. out)] \u00b7 .(.B)= id.B .. { unfold re.ection \n(\u00a7A) } [(P. out)] \u00b7 .(.B) = [(out)] .= { unfold fusion (\u00a7A) } .(.B): out out P. - The last statement \nholds as P. is pointed (7.3). Putting things together, we can give a new statement of the semantic function \n\u00b5S .B. - ' P (\u00b5S) P (.B) linl [(P. out)] l ((L[(P. out)]J)) l ' \u00b5S I .B [(((LB. linlJ)) )] ((LB. linlJ)) \nout ll ' B (\u00b5S) B (.B) We are in a more expressive setting, yet thanks to Theorem 7.1, we can hold on \nto our resolution of Iniga and Finn s viewpoints.  7.3 Constructing a Distributive Law In Section 6 \nwe modelled a stream program by a distributive law of type S.B ..B.S. With the introduction of the free \npointed functor, stream equations have become slightly more expressive. A program, such as in Example \n7.1, now gives rise to a natural transformation . : S.B ..B.P. The pointed functor appears only on the \nright. On the left we keep S, as a stream equation de.nes a constructor of S, not a variable. From . \n: S.B ..B.P we seek to construct a distributive law . : P.B ..B.P such that c \u00b7lal = B lal\u00b7 . X \u00b7 P c \n.. c \u00b7 a = B lal\u00b7 . X \u00b7 S c . (7.11) Since P is a coproduct, . has to be de.ned by a case analysis. Though \nobvious, we will calculate . from the speci.cation above as this will serve nicely as a blueprint for \nlater sections. c \u00b7 a = B lal\u00b7 . X \u00b7 S c .. { equality of joins } c v c \u00b7 a = c v B lal\u00b7 . X \u00b7 S c .. \n{lal respects . (7.2) and B functor } c v c \u00b7 a = B lal\u00b7 B (.X) \u00b7 c v B lal\u00b7 . X \u00b7 S c .. { join fusion \nand functor fusion (\u00a7A) } c \u00b7 (id v a)= B lal\u00b7 (B (.X) v . X) \u00b7 (c + S c) .. { de.nitions of l-l (7.7) \nand P (7.6) } c \u00b7lal = B lal\u00b7 (B (.X) v . X) \u00b7 P c The speci.cation (7.11) can be satis.ed if we set \n. = B.. v ., which is easily seen to satisfy the coherence condition (7.1). 8. ...to Monad City With \npointed functors we made a limited introduction of variables. The next step is to allow constructors \nto be nested. In this section we are going to build on our picture of .-bialgebras again, aug\u00admenting \npointed functors to monads. Example 8.1. Let us look at an example comparable to those of Section 2. \nHere is a stream equation for the natural numbers. nat =0 -nat +1 We need more than a single syntax constructor \nto represent nat +1. To solve this, we build terms with variables and constructors of S. data M x = Var \nx | Com (S (M x)) data S x = One | Plus (x, x) | Nat A system of recursion equations is now captured \nby a natural transformation . of type S.B ..B.M. . One = Cons (1, Com One) . (Plus (Cons (m, s), Cons \n(n, t))) = Cons (m + n, Com (Plus (Var s, Var t))) . Nat = Cons (0, Com (Plus (Com Nat, Com One))) Note \nthat we only have terms on the right-hand side. Arguments of Cons on the left can be embedded into variables \non the right, and as shown in the case of Nat, we can use more than one level of syntax. Again, we shall \nrestore symmetry later, showing how to derive a distributive law from . (Section 8.3). The Haskell type \nM is the so-called free monad of S. We will discuss monads in general and then return to the free construction \nin Section 8.1. De.nition 8.2. We say that T : CC is a monad if there are - natural transformations . \n: Id ..T and \u00b5 : T.T ..T such that \u00b5 \u00b7 ..T = idT , (8.1a) \u00b5 \u00b7 T.. = idT , (8.1b) \u00b5 \u00b7 \u00b5.T = \u00b5 \u00b7 T.\u00b5 . \n(8.1c) A monad extends a pointed functor with a second natural trans\u00adformation \u00b5 : T.T..T. In the previous \nsection we saw that . must be respected when constructing algebras and also by the distribu\u00adtive law \nof the .-bialgebra; these same conditions extend to \u00b5. Condition 8.3. The following are the necessary \ncoherence condi\u00adtions for a distributive law . : T.B ..B.T over a monad T: . \u00b7 ..B = B.. , (8.2a) . \u00b7 \n\u00b5.B = B.\u00b5 \u00b7 ..T \u00b7 T.. . (8.2b) Condition 8.4. If we construct an algebra (X, a : T XX) of a - monad T, \nthen it must respect both . and \u00b5. a \u00b7 .X = idX , (8.3a) a \u00b7 \u00b5X = a \u00b7 T a . (8.3b) In the same manner \nas for pointed functors, we will say that (T, ., \u00b5)-Alg(C ) is the category of T-algebras that respect \n. and \u00b5, a full subcategory of T-Alg(C ). Henceforth, we will be working with .-bialgebras based on (T, \n., \u00b5)-algebras and B\u00adcoalgebras. As in Section 7, the additional conditions ensure that the double isomorphism \n(6.6) is maintained. We have shown previously that . can be lifted to a B-coalgebra homomorphism (7.3). \nThere is an analogous property for \u00b5: Property 8.5. Let c : X B X be a B-coalgebra, then - \u00b5X : T. (T. \nc) S. c : B-Coalg(C ) , (8.4) - is the lifting of \u00b5 to a B-coalgebra homomorphism.  Proof. T. c \u00b7 \u00b5X \n= { de.nition of T. (6.4) } . X \u00b7 T c \u00b7 \u00b5X = { \u00b5 : T.T ..T is natural } . X \u00b7 \u00b5(B X) \u00b7 T (T c) = { coherence \nof . with \u00b5 (8.2b) } B (\u00b5X) \u00b7 . (T X) \u00b7 T (. X) \u00b7 T (T c) = { T functor and de.nition of T. (6.4) } B \n(\u00b5X) \u00b7 T. (T. c) In other words, the lifted functor T. is a monad as well and we can form (T. , ., \u00b5)-Alg(B-Coalg(C \n)). We also have shown that B. preserves respect for . (7.4). Again, there is an analogous property for \n\u00b5: Property 8.6. The lifted functor B. preserves respect for \u00b5. B. a \u00b7 \u00b5(B X)= B. a \u00b7 T (B. a) .= a \u00b7 \n\u00b5X = a \u00b7 T a (8.5) Proof. B. a \u00b7 \u00b5(B X) = { de.nition of B. (6.1) } B a \u00b7 . X \u00b7 \u00b5(B X) = { coherence \nof . with \u00b5 (8.2b) } B a \u00b7 B (\u00b5X) \u00b7 . (T X) \u00b7 T (. X) = { B functor and assumption a \u00b7 \u00b5X = a \u00b7 T a } \nB a \u00b7 B (T a) \u00b7 . (T X) \u00b7 T (. X) = { . : T.B ..B.T is natural } B a \u00b7 . X \u00b7 T (B a) \u00b7 T (. X) = { T \nfunctor and de.nition of B. (6.1) } B. a \u00b7 T (B. a) Thus, B. is an endofunctor on (T, ., \u00b5)-Alg(C ) and \nwe can form B. -Coalg((T, ., \u00b5)-Alg(C )). Summary As before the category of bialgebras can be seen as \na category of algebras over coalgebras or as a category of coalgebras over algebras. (T. , ., \u00b5)-Alg(B-Coalg(C \n)) .-Bialg(C ) ~(8.6) = B. -Coalg((T, ., \u00b5)-Alg(C )) 8.1 Free Monad Let S : CC be an endofunctor representing \nour syntax. There is - a canonical monad, with pleasant properties, that we can construct from S. To \ndo so we will .rst de.ne the free S-algebra. The free S-algebra over X is an algebra (M X, com) equipped \nwith an arrow var : X M X. We think of elements of M X as terms - built from our syntax functor S and \nvariables drawn from X. There are two ways to construct a term: var embeds a variable into a term; and \ncom : S (M X) M X constructs a composite term from a level - of syntax over subterms. If we have an algebra \na : S XX, we can evaluate a term with - ( a) : M XX (pronounce eval ). Given an arrow g : YX to evaluate \nvariables and an S-algebra a to evaluate composites, evaluation of terms is characterized by the uniqueness \nproperty, f =( a) \u00b7 M g .. f \u00b7 var = g . f \u00b7 com = a \u00b7 S f , (8.7) for all f : M YX. The equivalence \nstates that a compositional - evaluation of a term, second conjunct, is uniquely de.ned by an evaluation \nof variables, .rst conjunct. (For the clued-in reader, all of this information comes from the adjunction \nof the free and forgetful functors between S-Alg(C ) and C .) The initial algebra emerges as a special \ncase: \u00b5S ~M 0. It = represents the closed terms. Modulo this isomorphism, we have in = com0 and ((a))= \n( a) \u00b7 M \u00a1A. (Again, this relation is induced by the aforementioned adjunction.) There are two simple \nconsequences of the uniqueness property. If we set the evaluation of variables to the identity (g = id), \nwe get the computation laws: ( a) \u00b7 var = id , (8.8a) ( a) \u00b7 com = a \u00b7 S ( a) . (8.8b)  As var and \ncom are the constructors of terms, we can read these as de.ning equations of ( -) . The uniqueness property \nalso implies that var and com are natural in X and that ( -) preserves naturality. The free monad of \nthe functor S is (M, ., \u00b5), where . = var and \u00b5 =( com) . The \u00b5 : M.M ..M of the monad .attens a term \nwhose variables are terms. It does so by evaluating the term with the composite constructor the action \nof the free algebra. Theorem 8.1. The category of algebras for the free monad of S is isomorphic to the \ncategory of S-algebras: (M, ., \u00b5)-Alg(C ) ~. = S-Alg(C ) The following de.nitions are the witnesses to \nthis isomorphism. l(X, a : S XX)l = (X, ( a) : M XX)lhl = h , (8.9) L(X, b : M XX)J = (X, b \u00b7 .X : S \nXX)LhJ = h , (8.10) where . = com \u00b7 S.. : S ..M, which turns a level of syntax into a term. The map l-l \npreserves and re.ects homomorphisms. h : lallbl :(M, ., \u00b5)-Alg(C ) - .. h : ab : S-Alg(C ) (8.11) - Proof. \n(i) Ll(X, a)lJ = (X, a): LlalJ = { de.nitions of l-l (8.9) and L-J (8.10) } ( a) \u00b7 com \u00b7 S (.X) = { eval \ncomputation (8.8b) and S functor } a \u00b7 S (( a) \u00b7 .X) = { eval computation (8.8a) and S functor } a An \ninstance of this property is com = LlcomlJ = \u00b5X \u00b7 .(M X). In the opposite direction, lL(X, b)Jl = (X, \nb): lLbJl = b .. { de.nitions of l-l (8.9) and L-J (8.10) } ( b \u00b7 .X) = b .. { uniqueness of eval (8.7) \n} b \u00b7 .X = id . b \u00b7 com = b \u00b7 .X \u00b7 S b The .rst conjunct follows from the fact that b respects . (8.3a). \nFor the second conjunct we reason: b \u00b7 .X \u00b7 S b = { . : S ..M is natural } b \u00b7 M b \u00b7 .(M X) = { b respects \n\u00b5 (8.3b) }  b \u00b7 \u00b5X \u00b7 .(M X) = { \u00b5X \u00b7 .(M X)= com, see above } b \u00b7 com . (ii) L-J is functorial as . \n: S ..M is natural and L-J = .-Alg. (iii) l-l maps S-homomorphisms to M-homomorphisms. h \u00b7 ( a) = ( b) \n\u00b7 M h .. { uniqueness of eval (8.7) }h \u00b7 ( a) \u00b7 .X = h . h \u00b7 ( a) \u00b7 com = b \u00b7 S (h \u00b7 ( a) ) The .rst \nconjunct is a direct consequence of computation (8.8a). For the second conjunct we reason: h \u00b7 ( a) \u00b7 \ncom = { eval computation (8.8b) }h \u00b7 a \u00b7 S ( a) = { assumption h : ab : S-Alg and S functor } - b \u00b7 S \n(h \u00b7 ( a) ) (iv) Finally, l(A, a)l is an algebra for the monad. That lal re\u00adspects . (8.3a), unfolds \nto, ( a) \u00b7 .X = id, which is the .rst computation law (8.8a). That lal respects \u00b5 (8.3b), unfolds to, \n( a) \u00b7 \u00b5X =( a) \u00b7 M ( a) , and this follows from part (iii) ( a) \u00b7 \u00b5X =( a) \u00b7 M ( a) .= { l-l maps S-to \nM-homomorphisms and \u00b5 =( com) } ( a) \u00b7 com = a \u00b7 S ( a) and the second computation law (8.8b).  8.2 \nInitial and Final Objects Now that we have completed another round of generalization, from free pointed \nfunctors to free monads, it is appropriate to examine what the new initial and .nal .-bialgebras are. \nAgain, they can be derived from the double isomorphism (8.6), and again, we will highlight the salient \ndetails. Super.cially, the initial .-bialgebra has not changed: it re\u00ad mains (\u00b5S, linl, ((LB. linlJ)) \n). What has changed are the de.ni\u00ad tions of l-l and L-J. The usual three proof obligations are all discharged \nby the proofs provided in previous section. All of the proof steps have analogues in this section in \nparticular, Theorem 7.1 has been succeeded by Theorem 8.1. The .nal .-bialgebra is (.B, [(M. out)], out); \nthe single change is replacing P. with M.. The unique .-bialgebra homomorphism to the .nal .-bialgebra \nfrom any .-bialgebra (X, a, C) is still [(c)]. Just as in Section 7.2, there is one .nal proof obligation: \nwe have to show that [(M. out)] is an algebra for M. Previously we showed that [(P. out)] respects ., \nand this proof suf.ces to show the same of [(M. out)] (8.3a). It remains to show that \u00b5 is respected \n(8.3b): [(M. out)] \u00b7 \u00b5(.B) = [(M. out)] \u00b7 M [(M. Finally, we can give another statement of the semantic \nfunction \u00b5S .B, in the setting of . : M.B ..B.M. - ' M (\u00b5S) M (.B) linl l ((L[(M. out)]J)) l [(M. out)] \n\u00b5S I ' .B ((LB. linlJ)) [(((LB. linlJ)) )] out l l ' B (\u00b5S) B (.B) We have upgraded pointed functors \nto monads and Theorem 8.1 ensures that Iniga and Finn still see eye to eye. However, we will need to \nrepeat the exercise of Section 7.3.  8.3 Constructing a Distributive Law Given a program that is modelled \nby a natural transformation of type . : S.B ..B.M, we seek to derive a distributive law . : M.B ..B.M \nsuch that c \u00b7lal = B lal\u00b7. X\u00b7M c .. c \u00b7a = B lal\u00b7. X \u00b7S c . (8.12) Let us calculate. c \u00b7 a = B lal\u00b7 . \nX \u00b7 S c .. { isomorphism (M, ., \u00b5)-Alg ~= S-Alg (8.11) } c \u00b7lal = lB lal\u00b7 . Xl\u00b7 M c .. { see below } \nc \u00b7lal = B. lal\u00b7 M c .. { de.nition of B. (6.1) } c \u00b7lal = B lal\u00b7 . X \u00b7 M c The speci.cation (8.12) holds \nif B. lal = lB lal\u00b7 . Xl. To turn this property into a de.nition for ., we have to delve a bit deeper \ninto the theory. Applegate [3] discovered that distributive laws . : M.B ..B.M are in one-to-one correspondence \nto lifted functors B\u00af:(M, ., \u00b5)-Alg (M, ., \u00b5)-Alg, where a functor B\u00afis - a lifting of B if its action \non carriers and homomorphisms is given by B. It is useful to make explicit what it means for B\u00afto preserve \nalgebra homomorphisms (as before, B\u00afa is synecdochic, see \u00a76.1). \u00af\u00af B h \u00b7 B a = B b \u00b7 M (B h) .= h \u00b7 \na = b \u00b7 M h (8.13) This property immediately implies that B\u00aftakes natural algebras of type M.F ..F to \nnatural algebras of type M.B.F ..B.F. Looking back, we note that we have already made extensive use of \nthe correspondence in one direction, turning a distributive law into a lifting B.; now we need the opposite \ndirection. Given a lift\u00ading B\u00af, we can construct a distributive law as follows. The unique\u00adness property \n(8.7) states that homomorphisms of type M XA are - in one-to-one correspondence to arrows of type XA. \nWe aim to - construct . : M.B ..B.M, so we need a natural transformation of type B ..B.M. The composition \nB.. will do nicely. We obtain: \u00af (8.14) out)] . = B \u00b5 \u00b7 M.B.. , \u00afB .. { unfold fusion (\u00a7A) with \u00b5(.B): \nM. (M. where B\u00af\u00b5 : M.B.M..B.M is the M-algebra for the carrier B.M. We must show that . \u00afB coheres with \n. and \u00b5 per equations (8.2a) and (8.2b). For the proof we refer to the full paper [11]. The mappings \n. . B. and B\u00af . . \u00afB then establish the one-to\u00ad out) M. out (8.4) } - [(M. (M. out))] =[(M. out)] \u00b7 \nM [(M. out)] one correspondence between distributive laws and lifted functors. .= { unfold fusion (\u00a7A) \n} Returning to the task at hand, constructing a distributive law M [(M. out)] : M. (M. out) M. out from \n., we use the property B. lal = lB lal\u00b7 . Xl to de.ne: - \u00af .= { M. functor } B (X, b : M XX) = (B X, \nlB b \u00b7 . Xl : M (B X) B X) , \u00af [(M. out)] : M. out out . B h = B h . -  This de.nes a lifting because \nl-l =( -) is one that lifts S (B X) - B X to M (B X) B X. Putting things together, the distributive law \n- . = .B\u00afexpressed as a composition of natural transformations is: . =( B.\u00b5 \u00b7 ..M) \u00b7 M.B.. . (8.15) \n 8.4 Distributive Laws \u00e0 la Carte Distributive laws can be constructed modularly from a system of recursion \nequations. In this modular development we will have dif\u00adferent syntax functors S and we need to construct \nthe free monad for each, so we will replace the notation M by the more informa\u00adtive S *. The mapping \n(-) * is actually a higher-order functor whose arrow part takes a natural transformation a : S ..T to \na natural transformation a * : S * ..T *. Think of a * as a term converter. First let us consider an \nalternative de.nition of .b (cf. \u00a72.2). .b =0 -(1 -.b)+ .b Note that there is a nested occurrence of \n-. We can support nested stream constructors if we embed the behaviour into the syntax. The new syntax-with-behaviour \nfunctor is T X = B X + S X. Given a system of recursion equations . : S.B ..B.T * , we can construct \na symmetric system s as, s = B.inl* \u00b7 B..B v . = B.(.T \u00b7 inl) v . : T.B ..B.T * , where inl : B ..T and \n.F : F ..F *. A distributive law . : T * .B ..B.T * can then be constructed by Section 8.3. Embedding \nbehaviour into syntax is a special case of extending a system of recursion equations. Speci.cally, given \na base system .1 : S1.B ..B.S * 1 and an extension .2 : S2.B ..B.S *, where S X = S1 X + S2 X, we can \nform a combined system as follows: . = B.inl* \u00b7 .1 v .2 : S.B ..B.S * . The idea is that .2 can use the \noperators of S1 and S2 to de.ne the operators of S2. Compare this with Example 8.1: we can model One \nand Plus with an S1 and .1, and Nat with an S2 and .2, where Nat is de.ned in terms of itself as well \nas One and Plus. Returning to the embedding of behaviour into syntax, by setting S1 = B and .1 = B..B, \nthe embedding emerges as a special case. A minor variation is the merge of two independent systems of \nre\u00adcursion equations, . = B.inl* \u00b7 .1 v B.inr* \u00b7 .2 , where .1 : S1.B ..B.S1 * and .2 : S2.B ..B.S2* \n. We can further modularize our modelling of Example 8.1 as the recursion equa\u00adtions for One and Plus \nare independent. It is clear that we can de\u00advelop distributive laws modularly: if we have a collection \nof re\u00adcursion equations with acyclic dependencies, then we can combine them into a single system using \nthe two techniques described above. In the same fashion as Swierstra s Data types \u00e0 la carte [20], we \ncan create distributive laws \u00e0 la carte. There is one .nal thing to be said on this topic. The embedding \nof behaviour makes the constructors of B available in the syntax. Often, one also wishes to embed an \nelement of .B: consider the equation x =0 -even .b + x from Section 2. The stream even .b is de.ned by \na previous system, in fact, two systems; we wish to reuse it at this point. This can be accommodated \nby setting S1 X = .B and .1 = B.com \u00b7 out. Here S1 is a constant functor elements of .B are embedded \nas constants. It is important to note that merging the systems for .b , even and x is not an option as \neven uses a different de.nitional style and, as we have pointed out, we cannot mix styles. Of course, \nwe have to show that even is uniquely de.ned and this is what we do in Section 9.  8.5 Proving the Unique \nFixed-Point Principle Correct Let us now return to our original problem of proving the unique .xed-point \nprinciple correct. Also, a brief summary is perhaps not amiss. A system of recursion equations is modelled \nby a natural transformation . : S.B ..B.S *, where S is the syntax functor and B the behaviour functor. \nThe type of . captures the slogan consume at most one, produce at least one. Using the trick of embedding \nbehaviour into syntax we can consume nothing (the argument is reassembled on the right) and we can produce \nmore than one. Systems of this form are quite liberal; most, but not all of the examples in the literature \nsatisfy the restrictions. We will get back to this point in Section 9. A solution of a system modelled \nby . consists of an S-algebra and a B-coalgebra over a common carrier that satis.es: c \u00b7 a = B lal\u00b7 . \nX \u00b7 S c . We can now replay the calculations of Section 4. If the coalgebra is .nal, then a is uniquely \ndetermined, which establishes the UFP: out \u00b7 a = B lal\u00b7 . (.B) \u00b7 S out .. { . given by (8.15) which satis.es \n(8.12) } out \u00b7lal = B lal\u00b7 . (.B) \u00b7 M out .. { de.nition of M. and uniqueness of unfold (3.2) } lal = \n[(M. out)] .. { isomorphism (M, ., \u00b5)-Alg ~= S-Alg (8.1) } a = L[(M. out)]J . Conversely, if the algebra \nis initial, then c is .xed: c = ((LB. linlJ)) . Since the data de.nes initial and .nal objects in .-Bialg(C \n), we can furthermore conclude that the two ways of de.ning the semantic function of type \u00b5S .B coincide: \n((a)) =[(c)]. - 9. Echoes from the Second Dimension Thus far, we have been living in a single dimension: \nwe have incrementally augmented the syntax functor S, .rst to P, the free pointed functor of S, and then \nto M, the free monad of S. A second dimension arises as the dual of the .rst; just as we replaced S with \nP, we can do so dually with B and C, the cofree copointed functor of B. Of course, the progression continues \npredictably on to N, the cofree comonad of B. The developments of C and N are the duals of Sections 7 \nand 8, respectively; the details are spelled out in [11]. Let us take a moment to characterize the natural \ntransformations with which we are modelling recursion equations: they take the general form of . : S.lhs \n..B.rhs. In Section 6 we took the simplest case, where lhs = B, rhs = S, and thus . was exactly our distributive \nlaw .. The duality of the dimensions can be seen in how they affect the expressive power of these natural \ntransformations. The .rst dimension, the one we have focused on hitherto, corre\u00adsponds to the sophistication \nwith which we can build syntax on the right-hand side of equations; the progression .rst replaced a con\u00adstructor \nby a constructor or a variable, and then by terms, nested constructors with variables. This culminated \nin a . where lhs = B, rhs = M, and . is de.ned in terms of . using the structure of M. The second dimension \ncorresponds to the left-hand side of equa\u00adtions, and rather than constructing syntax, this is about destructing \nor patterning matching on behaviour. The cofree copointed func\u00adtor C, de.ned as C X = X \u00d7 B X, gives \na categorical modelling of Haskell s as-patterns, where var@pat gives the name var to the value being \nmatched by pat B represents a level of behaviour and C gives a label to that level. Therefore, a ., where \nlhs = C, mod\u00adels an equation that consumes at most one, rather than strictly one. This can also be achieved, \nalbeit in an indirect way, by embedding behaviour in syntax, as described in Section 8.4. For example, \ncon\u00adsider the stream operator that interleaves two streams: interleave (Cons m s)(Cons n t)= m -interleave \n(n -t) s .  The result of interleave (0 2 4 ..) (1 3 5 ..) is 0123 .., the natural numbers. In this \nde.nition we are unnecessarily deconstructing the second parameter into its head and tail, we simply \nneed the whole stream. A more natural de.nition is: interleave (Cons m s) t = m -interleave t s . Sometimes \nwe want the head, tail, and the whole stream. Consider the stream operator that performs an ordered merge \nof two streams: merge s@(Cons m s') t@(Cons n t') = if m . n then m -merge s' t else n -merge s t' . \nFrom this we are able to construct a natural transformation . : S.C ..B.S to model interleave and merge \nwithout the need to reconstruct behaviour on the right-hand side. data C x = As x (B x) . (Interleave \n(As (Cons (m, s)), As t )) = Cons (m, Interleave (t, s)) ' . (Merge (As s (Cons (m, s)), As t (Cons \n(n, t')))) = if m . n then ' Cons (m, Merge (s, t)) else Cons (n, Merge (t, t')) Finally, the cofree \ncomonad permits the inspection of behaviour to an arbitrary depth unlimited consumption. This is exactly \nwhat we need to model the equations that consume more than they pro\u00adduce, such as the stream operator \neven, which we saw in Section 2. even (Cons m (Cons n u)) = m -even u We can render the cofree comonad \nin Haskell as, data N x = Root x (B (N x)) , and even is captured by a natural transformation . : S.N \n..B.S, . (Even (Root s (Cons (m, Root t (Cons (n, Root u )))))) = Cons (m, Even u) . We can form a distributive \nlaw . : S.N..N.S from ., by following the dual of the derivation outlined in Section 8.3. There are three \npoints in each dimension, leading to a total of nine different instantiations of . : S.lhs ..B.rhs, which \ncorre\u00adspond to nine combinations of expressive power. A natural trans\u00adformation . : S.N ..B.M is the \nmost general: it captures recur\u00adsion equations that have an arbitrary depth of pattern matching on the \nleft-hand side, with an arbitrary term on the right-hand side. And in some sense it is too general, as \nit unclear how to derive the corresponding distributive law . : M.N ..N.M, or if there should be such \na derivation. We leave this determination as future work. The sweet spot of expressivity is . : S.C ..B.M, \nwhere M is the free monad of syntax with embedded behaviour, which captures the slogan mentioned in Section \n8.5: consume at most one, produce at least one. The use of C makes the nature of the consumption more \nexplicit. Let us showcase this sweet spot. There is a sequence of numbers called the Hamming numbers, \nwhich can be characterized as the numbers that only have 2, 3 or 5 as prime factors. They are named after \nthe Turing award winner Richard Hamming, who posed the problem of generating these numbers in ascending \norder. Dijkstra [6] presented a solution in SASL, attributed to J. L. A. van de Snepscheut, and proved \nits correctness. Here we will replicate the same solution, which is in fact a slightly simpli.ed version \nfor numbers that only have 2 and 3 as prime factors. The stream is, ham =1 -merge (times 2 ham, times \n3 ham) , where the de.nition of merge is given above and times is, times n (Cons m s)= n \u00d7 m -times n \ns . Again, we can capture the recursion equations merge, times and ham by a natural transformation . \n: S.C ..B.M: ' . (Merge (As s (Cons (m, s)), As t (Cons (n, t')))) = if m . n then Cons (m, Com (Merge \n(Var s', Var t))) else Cons (n, Com (Merge (Var t, Var t'))) . (Times n (As (Cons (m, s)))) = Cons (n \n\u00d7 m, Com (Times n (Var s))) . Ham = Cons (1, Com (Merge (Com (Times 2(Com Ham)), Com (Times 3(Com Ham))))) \n. The details of the construction of the distributive law . : M.C ..C.M can be found in Hinze and James \n[11]. By the naturality of . and thus the constructed ., we have a proof (as an alternative to Dijkstra \ns) that ham uniquely de.nes a stream. 10. Related Work The theoretical foundations of our work exist \nin the literature, originally in Turi and Plotkin [21] and re.ned in Lenisa et al. [13]. We see our work \nas an application of, and an exercise in, this theory. The work that is closest in spirit to ours is \nBartels [4]. It is centered around the coinduction proof principle, in contrast to the UFP. Bartels looks \nat two out of the nine points that we have identi.ed, the simplest . : S.B ..B.S, and our sweet spot \n. : M.C..C.M, but for space reasons does not explore any others. Bartels introduces a construction homomorphism \nup-to, which is a homomorphism from a coalgebra to a bialgebra, and uses it as a de.nitional principle. \nWe simply use bialgebra homomorphisms, following the original theory of Turi and Plotkin [21], which \nnicely exhibits the duality of Iniga and Finn s viewpoints. Rutten and Silva have presented two coinductive \ncalculi, one for streams [17] and one for binary trees [19], also using coinduction as a proof principle. \nThey have a uniqueness proof for each: The\u00adorem 3.1 and Appendix A in Rutten [17]; and Theorem 2 in Silva \nand Rutten [19]. Our approach treats streams and in.nite trees, and behaviour in general, in a datatype \ngeneric way the same proofs apply, only varying in the chosen functors for syntax and behaviour. Moreover, \nwe emphasize a compositional, functional style. Our task of determining that a recursion equation has \na unique solution is related to the task of determining that corecursive def\u00adinitions are productive \n[18]. This is crucial in dependently typed programming and proof languages, where the logical consistency \nof the system requires it. In Coq this is enforced by the guardedness condition [8], which is particularly \nconservative: it has no means to propagate information through function calls, so corecursive calls are \nforbidden to appear anywhere other than as a direct argument of a constructor. Compositionality is the \n.rst casualty. The situation is similar in Agda [2]. Hughes et al. [12] were the .rst to talk about the \nnotion of sized\u00adtypes, and used it as part of a type-based analysis that guarantees termination and liveness \nof embedded functional programs. Fol\u00adlowing this, there have been a whole host of proposed type sys\u00adtems \nincorporating size annotations. MiniAgda [1, 15] is a tangible implementation of a dependently typed \ncore language with sized types, able to track the productivity of corecursive de.nitions. Type signatures \nare mandatory and contain sizes explicitly, which is in contrast to our . functions, the naturality of \nwhich is easy to infer. Speci.c to streams, Endrullis et al. [7] introduce what they call data-oblivious \nproductivity: productivity that can be decided with\u00adout inspecting the stream elements. They present \nthree classes of stream speci.cations. Their analysis is provably optimal for the .at class, where stream \nfunctions cannot contain nested function appli\u00adcations. Our slogan consume at most one, produce at least \none corresponds to their friendly nesting class. A competing approach appears in Zantema [22], who reduces \nthe determination of unique\u00adness to the termination of a term rewriting system (TRS). A stream speci.cation \nhas a unique solution if its observational variant TRS is terminating, a TRS that is very like Rutten \ns stream de.nitions.  Acknowledgements Ralf would like to thank Jan Rutten for pointing him to distributive \nlaws and bialgebras. Daniel is funded by a DTA Studentship from the Engineering and Physical Sciences \nResearch Council. References [1] A. Abel. MiniAgda: Integrating Sized and Dependent Types. Elec\u00adtronic \nProceedings in Theoretical Computer Science, 43:14 28, 2010. [2] A. Abel and T. Altenkirch. A predicative \nanalysis of structural recur\u00adsion. JFP, 12(1):1 41, 2002. [3] H. Applegate. Acyclic models and resolvent \nfunctors. PhD thesis, Columbia University, 1965. [4] F. Bartels. Generalised coinduction. Mathematical \nStructures in Computer Science, 13(2):321 348, 2003. [5] R. S. Bird and O. De Moor. Algebra of Programming, \nvolume 100 of International Series in Computing Science. Prentice Hall, 1997. [6] E. W. Dijkstra. Hamming \ns exercise in SASL. Personal Note EWD792, 1981. [7] J. Endrullis, C. Grabmayer, and D. Hendriks. Data-oblivious \nstream productivity. In Logic for Programming, Arti.cial Intelligence, and Reasoning, volume 5330 of \nLNCS, pages 79 96. Springer, 2008. [8] E. Gim\u00e9nez. Codifying guarded de.nitions with recursive schemes. \nIn Types for Proofs and Programs, volume 996 of LNCS, pages 39 59. Springer, 1995. [9] R. Hinze. The \nBird tree. JFP, 19(5):491 508, 2009. [10] R. Hinze. Concrete stream calculus an extended study. JFP, \n20(5 6):463 535, 2010. [11] R. Hinze and D. W. H. James. Proving the Unique-Fixed Point Prin\u00adciple Correct. \nTechnical Report RR-11-03, Department of Computer Science, University of Oxford, 2011. [12] J. Hughes, \nL. Pareto, and A. Sabry. Proving the correctness of reactive systems using sized types. In POPL, pages \n410 423. ACM, 1996. [13] M. Lenisa, J. Power, and H. Watanabe. Distributivity for endofunctors, pointed \nand co-pointed endofunctors, monads and comonads. Elec\u00adtronic Notes in Theoretical Computer Science, \n33:230 260, 2000. [14] C. McBride and R. Paterson. Applicative programming with effects. JFP, 18(1):1 \n13, 2008. [15] K. Mehltretter. Termination checking for a dependently typed lan\u00adguage. Master s thesis, \nLMU Munich, 2007. [16] M. Niqui and J. J. M. M. Rutten. Sampling, splitting and merging in coinductive \nstream calculus. In MPC, volume 6120 of LNCS, pages 310 330. Springer, 2010. [17] J. J. M. M. Rutten. \nFundamental study: Behavioural differential equations: A coinductive calculus of streams, automata, and \npower series. Theoretical Computer Science, 308:1 53, 2003. [18] B. A. Sijtsma. On the productivity of \nrecursive list de.nitions. ACM Trans. Program. Lang. Syst., 11(4):633 649, 1989. [19] A. Silva and J. \nJ. M. M. Rutten. A coinductive calculus of binary trees. Information and Computation, 208:578 593, 2010. \n[20] W. Swierstra. Data types \u00e0 la carte. JFP, 18(04):423 436, 2008. [21] D. Turi and G. Plotkin. Towards \na mathematical operational semantics. In Logic in Computer Science, pages 280 291. IEEE, 1997. [22] H. \nZantema. Well-de.nedness of streams by transformation and ter\u00admination. Logical Methods in Computer Science, \n6(3:21), 2010. A. Miscellaneous Laws id = inl v inr join re.ection (g1 v g2) \u00b7 inl = g1 join computation \n(g1 v g2) \u00b7 inr = g2 join computation k \u00b7 (g1 v g2)= k \u00b7 g1 v k \u00b7 g2 join fusion (g1 v g2) \u00b7 (h1 + h2)= \ng1 \u00b7 h1 v g2 \u00b7 h2 join functor fusion ((a)) \u00b7 in = a \u00b7 F ((a)) fold computation h \u00b7 ((a)) =((b)) .= h \n\u00b7 a = b \u00b7 F h fold fusion [(out)] = id unfold re.ection [(d)] =[(c)] \u00b7 h .= F h \u00b7 d = c \u00b7 h unfold fusion \nB. Lifting The underlying or forgetful functor U : F-Alg(C ) C is de.ned - U (A, a) = A , U h = h . A \nfunctor H\u00af: F-Alg(C ) G-Alg(D) is a lifting of H : CD if U.H\u00af= H.U. H\u00af ' F-Alg(C ) G-Alg(D) U U l l ' \nCD H Given a natural transformation . : G.H ..H.F, we can de.ne a lifting H. : F-Alg(C ) G-Alg(D) of \nH as follows: - H. (X, a : F XX) = (H X, H a \u00b7 . X : G (H X) H X) , (B.1) H. h = H h . (B.2) Since H. \ns action on carriers and homomorphisms is given by H, it preserves identity and composition. It remains \nto show that it takes F-homomorphisms to G-homomorphisms. H h : H. a H. b : G-Alg(D) .= h : ab : F-Alg(C \n) , where a : F XX and b : F YY. (As throughout this paper, and as explained in Section 6.1, we use lifted \nfunctors synecdochically.) We reason H h \u00b7 H. a = { de.nition of H. (B.1) } H h \u00b7 H a \u00b7 . X = { H functor \nand assumption h : ab : F-Alg(C ) } - H b \u00b7 H (F h) \u00b7 . X = { . : G.H ..H.F is natural } H b \u00b7 . Y \u00b7 \nG (H h) = { de.nition of H. (B.1) } H. b \u00b7 G (H h) . The functor a-Alg emerges as a special case with \nH = Id and . = a. Also, S. is an instance of the scheme with F = G, which consequently restricts H to \nendofunctors. The construction dualizes to categories of coalgebras.    \n\t\t\t", "proc_id": "2034773", "abstract": "<p>Say you want to prove something about an infinite data-structure, such as a stream or an infinite tree, but you would rather not subject yourself to coinduction. The unique fixed-point principle is an easy-to-use, calculational alternative. The proof technique rests on the fact that certain recursion equations have unique solutions; if two elements of a coinductive type satisfy the same equation of this kind, then they are equal. In this paper we precisely characterize the conditions that guarantee a unique solution. Significantly, we do so not with a syntactic criterion, but with a semantic one that stems from the categorical notion of naturality. Our development is based on distributive laws and bialgebras, and draws heavily on Turi and Plotkin's pioneering work on mathematical operational semantics. Along the way, we break down the design space in two dimensions, leading to a total of nine points. Each gives rise to varying degrees of expressiveness, and we will discuss three in depth. Furthermore, our development is generic in the syntax of equations and in the behaviour they encode - we are not caged in the world of streams.</p>", "authors": [{"name": "Ralf Hinze", "author_profile_id": "81332504302", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P2801443", "email_address": "ralf.hinze@cs.ox.ac.uk", "orcid_id": ""}, {"name": "Daniel W.H. James", "author_profile_id": "81453618588", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P2801444", "email_address": "daniel.james@cs.ox.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034821", "year": "2011", "article_id": "2034821", "conference": "ICFP", "title": "Proving the unique fixed-point principle correct: an adventure with category theory", "url": "http://dl.acm.org/citation.cfm?id=2034821"}