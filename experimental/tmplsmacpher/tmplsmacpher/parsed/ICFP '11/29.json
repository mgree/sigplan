{"article_publication_date": "09-19-2011", "fulltext": "\n Nameless, Painless Nicolas Pouillard INRIA Nicolas.Pouillard@inria.fr Abstract De Bruijn indices are \na well known technique for programming with names and binders. They provide a representation that is \nboth simple and canonical. However, programming errors tend to be really easy to make. We propose a safer \nprogramming interface implemented as a li\u00adbrary. Whereas indexing the types of names and terms by a nu\u00admerical \nbound is a famous technique, we index them by worlds, a different notion of index that is both .ner and \nmore abstract. While being more .nely typed, our approach incurs no loss of expressive\u00adness or ef.ciency. \nVia parametricity we obtain properties about functions poly\u00admorphic on worlds. For instance, well-typed \nworld-polymorphic functions over open .-terms commute with any renaming of the free variables. Our whole \ndevelopment is conducted within Agda, from the code of the library, to its soundness proof and the properties \nof external functions. The soundness of our library is demonstrated via the construction of a logical \nrelations argument. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs \nand Features Data types and struc\u00adtures; Polymorphism General Terms Design, Languages, Theory Keywords \nnames, binders, meta-programming, name abstraction, de Bruijn indices 1. Introduction It is quite common \nin the programming realm to deal with the mun\u00addane business of data structures with names and binders. \nCompil\u00aders, code generators, static analysers, theorem provers, and type\u00adcheckers have this in common. \nThey manipulate programs, formu\u00adlae, proofs, and types. When seen as pieces of data, there is a com\u00admon \ndif.culty: the representation of variables (names and binders). One traditional approach is to represent \nall the occurrences of a bound variable identically by using character strings or integers. While being \nthe most obvious representation it is known to cause a lot of trouble when dealing with operations like \nsubstitution. In particular we name it the capture-avoiding substitution because it has to rename some \nvariables to avoid accidental changes called captures. Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. ICFP 11, September 19 21, 2011, Tokyo, Japan. Copyright c &#38;#169; \n2011 ACM 978-1-4503-0865-6/11/09. . . $10.00 In this article we focus on a different kind of representation, \nnamely de Bruijn indices [6]. This representation is said to be nameless because variables are no longer \nidenti.ed by a name but a notion of distance to the binding point. De Bruijn indices are the most famous \nnameless representation and in the following we will use the term nameless as a synonym for de Bruijn \nindices . The nameless approach solves part of the problem by providing a canonical representation. More \nprecisely binding occurrences are no longer named (we now use .. instead of .x.). Then bound variables \nare represented by the distance to the binding .. This distance is the number of .s to cross in order \nto reach the binding .. A major issue with this nameless representation is its arithmetic .avor. Indeed \nproperties about names and binders are turned into arithmetic formulae. The result can be harder to understand, \nand worse, easier to get wrong. To remedy this, several techniques have been proposed to give .ner grained \ntypes to these representations [1, 2, 5, 7]. We continue further in this direction by providing a safer \nsystem to program with a nameless representation. 1.1 Contributions In a previous paper [10] we developed \nan abstract interface to pro\u00ad gram with names and binders. The interface can be both imple\u00admented in \na named or a nameless style. Here by focusing on a nameless representation we greatly simplify the programming \nin\u00adterface needed to achieve our safety goals. This is at the expense of some loss of abstraction. However \nwhile the goals are less am\u00adbitious, the results are signi.cantly more applicable since simpler and closer \nto a concrete representation. Our previous nameless implementation was relying on the Fin approach (described \nin section 1.4.3). The notion of worlds pre\u00ad sented here (in section 2.3) is signi.cantly more precise \nthan Fin. However the worlds were already abstract to the programmer and they still are. Indeed abstraction \nis necessary to retain the para\u00admetricity properties we want from world-polymorphic functions. While \na fair amount of proofs were already mechanized in [10], the logical relation argument was still largely \non paper. Here we not only .nished these mechanized proofs but have every part well connected in one \nsingle setup. The code and proofs are accessible online at [9] and we encourage the reader to have a \nlook for reference on technical details and applications.  1.2 Outline of the paper This paper is organized \nas follows. In the remainder of this section we present several nameless techniques to represent data \nstructures with bindings. In section 2 we detail our approach to the problem. In section 3 we give some \nexamples and advanced operations. In section 4 we develop a logical relation construction which ensures \nthe soundness properties we want, and we show how to exploit these properties on concrete examples. All \nthe construction is built in the AGDA language, our system is an AGDA library and its soundness proof \nis done in AGDA as well.  1.3 A brief introduction to AGDA notation Throughout the paper, our de.nitions \nare presented in the syn\u00adtax of AGDA. In AGDA, Set (or Set0) is the type of small types like Bool, Maybe \n(List Bool), or N. Set1 is the type of Set, Set . Bool, or N . Set. The function space is written A . \nB, while the dependent function space is written (x:A) . B or . (x:A) . B. An implicit parameter, introduced \nvia .{x:A}. B, can be omitted at a call site if its value can be inferred from the context. There are \nshortcuts for introducing mul\u00adtiple arguments at once or for omitting a type annotation, as in .{A}{ij:A} \nx . e. There is no speci.c sort for proposi\u00adtions in AGDA, everything is in Set e for some e. The unit \ntype is a record type with no .elds named T, it also represents the True proposition. The empty type \nis an (inductive) data type with no constructors named ., it also represents the False proposition. The \nnegation \u00ac A is de.ned as A ... The same name can be used for different data constructors. AGDA makes \nuse of type annotations to resolve ambiguities. As in Haskell, a de.nition consists of a type signature \nand a se\u00adquence of de.ning equations, which may involve pattern-matching. The with construct extends \na pattern-matching-based de.nition with new columns. An ellipsis ... is used to elide a redundant equation \npre.x. AGDA is strict about whitespace: x=y is an identi.er, whereas x = y is an application. This allows \nnaming a variable after its type (deprived of any whitespace). We use mix.x declarations, such as _._. \nWe use some de.nitions from AGDA s standard library: natural numbers, booleans, lists, and applicative \nfunctors (pure, _._). For the sake of conciseness, the code fragments presented in the paper are sometimes \nnot perfectly self-contained. However, a complete AGDA development is available online [9].  1.4 Related \nwork: nameless representations Various techniques have been discovered to build a nameless rep\u00adresentation. \nWe have chosen a few of them which gradually setup the stage. 1.4.1 bare: The original approach We call \nthis one bare, because it solely relies on natural numbers. To make things more concrete here is an example \nof its use when de.ning the untyped .-calculus with local bindings (let). Our naming convention is as \nfollows: we call Tm the type of .-terms, V is the data constructor for variables, _\u00b7_ is for the application, \nn is for the .-abstraction, and .nally Let is for local bindings. data Tm : Set where V : (x : N) . Tm \n_ \u00b7_ : (t u : Tm ) . Tm n : (t : Tm ) . Tm Let : (t u : Tm) . Tm From the point of view of the binding \nstructure, it is striking that no difference appears between the constructors of the data type. It is \ncompletely up to the programmer to manage the scoping difference introduced by n and Let. This is even \nmore worrying in the Let case since we have no clue of difference between the arguments. Here is an example \nusing this representation to build the .-term for .f..x.f x. appTm : Tm appTm = n (n (V1 \u00b7 V0)) The main \nadvantages of this approach are its simplicity and its expressiveness. The expressiveness is almost maximal \nsince no restriction is put on the usage of variables. Actually expressiveness is really maximal only \nin partial languages where all types are inhabited by a looping term. Indeed the absence of restrictions \non data can be constraining when receiving data as argument. In a total language all cases have to be \ncovered, even those we consider as impossible. For instance a function accepting only closed terms will \nhave to provide a return value for the variable case anyway. Sometimes the return type is so constrained \nthat the type is actually empty in this case, and so no dummy value can be returned. However, even in \na partial language the expressiveness is maximal if we are willing to live in an error monad. 1.4.2 \nMaybe: The nested data type approach The nested data type approach [2, 3, 5] is a .rst step towards better \nproperties about the binding structure of terms. Let us start with the de.nition of Tm with this approach: \ndata Tm (A : Set ) : Set where V : (x : A) . Tm A _ \u00b7_ : (t u : Tm A ) . Tm A n : (t : Tm (Maybe A ) \n) . Tm A Let : (t : Tm A ) (u : Tm (Maybe A) ) . Tm A There are three points to look at. The Tm type \nis parameterized by another type called A, so we can look at it as a kind of container. Note also that \nthe variable case V does not hold a N but an A. Last but not least the n case holds a term whose parameter \nis not simply an A but a Maybe A. This last point makes the Tm type a nested data type, also called a \nnon-regular type. This has the consequence of requiring polymorphic recursion to write recursive functions \non such a type. To understand why this is an adequate representation of .-terms one has to look a bit \nmore at the meaning of Maybe. If types are seen as sets, then Maybe takes a set and returns a set with \none extra element. So each time we cross a n, there is one extra element in the set of allowed variables, \nexactly capturing the fact we are introducing a variable. To see the difference with the previous approach, \nhere is the appTm .-term again: appTm : Tm . appTm = n (n (V (just nothing ) \u00b7 V nothing )) Note the \nuse of the empty type . to state the closedness of the appTm term. Stating this kind of properties was \nimpossible to do with the previous approach, without resorting to logical properties on the side.  1.4.3 \nThe Fin approach Another approach already described and used in [1, 7] is to index everything (terms \nfor example) by a bound. This bound is the maximum number of distinct free variables allowed in the value. \nThis rule is enforced in two parts: variables have to be strictly lower than their bound, and the bound \nis incremented by one when crossing a name abstraction (a .-abstraction for instance, called n here). \nThe Fin n type is used for variables and represents natural numbers strictly lower than n. The name Fin \nn comes from the fact that it de.nes .nite sets of size n. We call this approach Fin for its use of this \ntype. The de.nition found in AGDA standard library is the following:  data Fin : N . Set where zero \n: {n: N}. Fin (suc n ) suc : {n: N} (i :Finn ) . Fin (suc n ) Given this Fin type, one can de.ne the \nTm data type using this approach: data Tm n : Set where V: (x: Fin n) . Tm n _ \u00b7_: (tu :Tmn ) . Tm n \nn : (t: Tm (suc n)) . Tm n Let : (t: Tmn)(u : Tm (suc n )) . Tm n As the previous approach, this representation \nhelps enforcing some wellformedness properties, for instance Tm 0 is the type of closed .-terms. Here \nis the appTm .-term in this approach: appTm : Tm 0 appTm = n (n (V (suc zero ) \u00b7 V zero)) We can easily \ndraw a link with the Maybe approach. Indeed, the Fin (suc n) type has exactly one more element than the \nFin n type. Although they are not equivalent for at least two rea\u00adsons. The Maybe approach can accept \nany type to represent vari\u00adables. This makes the structure more like a container and this can be particularly \nhelpful to de.ne the substitution as the composi\u00adtion of mapTm : .{AB}. (A . B) . Tm A . Tm B and joinTm \n: .{A}. Tm (Tm A) . Tm A as in [2, 5]. The Fin approach has advantages as well, the representation is \nconcrete and simpler since closer to the bare approach. However this apparent simplicity comes at a cost, \nwe will see that its concrete representa\u00adtion is one root of the problem. 2. NAPA, a safer nameless representation \n2.1 Motivation While these nameless approaches easily guarantee wellformedness of terms, nothing is said \nabout functions manipulating terms. How are the inputs of a function related to its output? What should \na function be able to do given unknown free variables? We claim that free variables should be kept abstract. \nMore precisely a function f operating on terms should commute with a renaming F of free variables, namely \nf .F=F.f. By renaming we mean a permutation of the free variables (more precisely an injective function). \nIn fact this is a bit more .exible, depending on the type of the function f this property will be enforced \nor not, as we will see in section 4.5. The goal is to catch some programming errors by having .ner types \nfor the manipulated values and for the functions manipulating values. We will show later that this is \nnot a restriction by itself since the types do not force the programmer to be precise everywhere. One \ncommon kind of programming error with these nameless representations is to forget to shift the free variables \nhere and there. While these errors are already caught by the Maybe and the Fin approaches, in these approaches \nthe programmer is provided with means to workaround the type error. In complex situations making the \ndistinction between a valid coercion and a wrong one can be challenging. With .ner types, the mistakes \nwill result in more informative type errors.  2.2 A data de.nition kit The three previous approaches \nare closely related. Just a few de\u00adtails change each time. We can capture all of them with a single abstraction: \na triple (World, Name, _.1) where World is the index bareKit bareKit : = DataKit \\ T , . _ . N , id ) \nmaybeKit maybeKit : = DataKit \\ Set , id , Maybe ) finKit finKit : = DataKit \\ N , Fin , suc ) Figure \n1. DataKits for the three previous approaches of types like Tm, Name is the type for names (indexed by \nworlds) as used in the V constructor, and .nally _.1 is an operation to shift a world by one as used \nin the n constructor. In AGDA, this triple can be de.ned with a record type named DataKit. This type \nis made universe polymorphic to accept the nested data types approach. record DataKit {e} : Set (suc \ne) where constructor \\_,_,_ ) field World : Set e Name : World . Set _.1 : World . World The three previous \napproaches are summed up in .gure 1 by de.ning their DataKit. Note that for the bare approach the index \ntype is the unit type. In the Maybe approach the index type is Set and the type for names is directly \nthe index so we use the identity function. We can now give a single de.nition of Tm generalizing the \nthree previous ones. To this end, we simply take a DataKit as argument and use it to de.ne the type Tm. \nmodule DataTm {e} (kit : DataKit {e}) where open DataKit kit data Tm a : Set e where V: (x : Name a) \n. Tm a _ \u00b7_: (t u:Tm a) . Tm a n : (t : Tm (a .1)) . Tm a Let : (t : Tm a)(u : Tm (a .1 )) . Tm a We \nclaim that nothing more is required from the kit. As complex binding structures can be de.ned in the \noriginal nameless represen\u00adtation (bare), they can also be de.ned using this kit. In particular having \nan empty world or making an induction over a world is not necessary. Translation between data types using \ndifferent kits can be done modularly as we do in the AGDA development. In any direction (any pair of \nkits k1 k2) one can de.ne a function of type .{a1 a2} . (Name k1 a1 . Name k2 a2) . Tm k1 a1 . Tm k2 \na2. This function takes a mapping for free variables and lifts this mapping to terms. Whereas using these \ntranslations is .ne in many cases, when going from bare to a more precise representation, an issue arises. \nSince AGDA is a total language, the initial mapping must be a total function. The bare approach ensuring \nnothing about free variables, one cannot supply the initial mapping to go to a closed term. One has to \nkeep at least one free variable and then dynamically check for occurrences of the free variable in a \nsecond transformation. We will now build on this DataKit abstraction to introduce our own solution. \n World : Set \u00d8 : World _+1 : World . World _.1 : World . World Name : World . Set _ . _ : World . World \n. Set napaKit : DataKit napaKit = \\ World , Name , _.1 ) Figure 2. Core types of NAPA  2.3 NAPA types \nWe call our approach NAPA as in Nameless, Painless. At the level of types, NAPA exposes the interface \nshown in .gure 2. This is a superset of the DataKit, featuring an empty world, a _+1 operation on worlds \ndescribed later on, and a notion of world inclusion. If we look closely at the notion of worlds in the \nFin approach, we see that it gives us too much information. Indeed a function could look at the given \nworld (by pattern-matching or induction) and behave differently for some values of the world. On the \nother hand, Fin worlds are too coarse: a single number e is used to represent a set, namely the complete \ninterval [0..e-1]. In NAPA, a world denotes a subset of Nbut is kept abstract (no pattern-matching nor \ninduction). Only the empty world \u00d8 and two operations are given, namely _+1 and _.1. Semantically a +1 \nis de.ned by {x + 1 | x . a} and a . 1 by {0}. (a +1). Internally we represent worlds by lists of Boolean \nvalues. Hav\u00ading true at the n th position of the list means that n is in the world. Here are the AGDA \nde.nitions: World : Set World = List Bool \u00d8 : World \u00d8 = [] _+1 : World . World a +1 = false :: a _.1 \n: World . World a .1 = true :: a These one step de.nitions _+1 and _.1 are extended to any number to \nproduce _+W _ and _._ of type World . N . World. To the best of our knowledge, making the distinction \nbetween two forms of shifting operations for worlds has never been investi\u00adgated in the context of representing \nnames and binders. In NAPA the type for names is a re.nement of N, kept abstract by not exporting its \nde.nition. From a set point of view, inhabitants of Name a are members of a. However we want worlds to \nform static information only and to be able to erase them before running the programs. To do so we will \nuse a pair of a natural number and a proof it belongs to its world. Here is the membership predicate \nand the record de.nition for names: zero N : .{a}. Name (a .1 ) addN : .{a} k . Name a . Name (a +W k) \nsubtractN : .{a} k . Name (a +W k ) . Name a cmp N : .{a} e . Name (a . e)  . Name (\u00d8. e) l Name (a \n+W e) _== N _: .{a} (x y : Name a) . Bool coerce N : .{a\u00df}. a . \u00df . Name a . Name \u00df \u00ac Name\u00d8 : \u00ac (Name \n\u00d8) syntax addN kx=x+N k syntax subtractN kx=x-N k syntax cmp N e x=x<N e Figure 3. Core operations on \nnames _._: N . World . Set _ . [] = . zero . (false :: _ ) = . zero . (true :: _ ) = T suc n . (_ :: \nxs ) =n . xs record Name a : Set where constructor _,_ field name : N name.a : name . a Thanks to our \nde.nition of world membership which is canoni\u00adcal, equality of the name .eld implies equality on whole \nName val\u00adues. This means we get provable proof-irrelevance for the Name type without requiring an additional \naxiom.  2.4 Operations on names The core operations on names are given in .gure 3. The simplest name \nis zero N , it represents 0 and lives in any world shifted by one. One can add any constant to a name \nin any world with addN , the resulting world clearly shows that this function (if parametric in a) does \nexactly its job. One can do the opposite operation with subtractN . Thanks to its precise type this function \nis total and the inverse of addN . Figure 4 depict the core operations we have on names. Starting from \nthe bottom, worlds of the form \u00d8. k are names which are de.nitely bound. There value is completely known \nas stated by arrows with the Fin k type. Above we have names that may be bound or free (Name (a . k)), \na dynamic test (cmp N ) can tell whether it is bound or not. Above we have names that are known to be \ngreater than k (Name (a +W k)), apart from that they are free names. Above we have free names (Name a). \nOn the top we have impossible names since they are said to belong to an empty world. From them we can \nderive everything. Given any world a, a name in the world a . e is either strictly lower than e (and \nso also lives in \u00d8. e), or greater or equal to e (thus also lives in a +W e). This is exactly what the \ncmp N function is about. Given a name, it returns a disjoint sum of names which can be read in two parts. \nIt .rst gives which side of the disjoint sum it stands, and second it gives a re.ned version of the input \nname. The coerce N function will be described in length in the next sub-section. The only way left to \nextract information from a name in an arbitrary world is to compare it with another name for equality \n Name (\u00d8 +W k) N coerce _ Name \u00d8 \u00acName\u00d8. coerce N _ Name a addN k  subtractN k Name (a +W k) N (if \n=k) coerce _ N Name (a . k) cmp N (if <k) Name (\u00d8. k) coerce _ Fin k Figure 4. Operations on names \nwith _== N _. Finally \u00acName\u00d8 asserts that no name lives in the empty world. In a total language this \nis of great use to tackle impossible cases. These primitives are enough to show an isomorphism between \nFin n and Name (\u00d8. n). From this, every program involving Fin can be translated into our system. This \nmeans that our system does not restrict the programmer more than the Fin approach. However as soon as \none uses .ner types than Name (\u00d8. n), then fewer wrong programs type-check and more properties hold as \nwe will see later.  2.5 A type for world inclusion witnesses Having .ner types also implies being able \nto give more types to the same value. Then cheaply moving from different types is a must. We call a function \nwhich has an output type different from the input type and behaves as the identity a coercion. To capture \na great deal of coercions from a world a to a world \u00df we focus on the case where a is included in \u00df. \nIn NAPA a type _._ is introduced to witness the inclusion between two worlds. Then the coerce N function \nturns a a . \u00df into an identity function of type Name a . Name \u00df. Here is the coerce N function and its \nalias _\\-because_-) which is useful to keep the code separated from the typing/proof, in particular what \nis between the angle brackets can be safely skipped. coerce N : .{a\u00df}. a . \u00df . Name a . Name \u00df coerce \nN a.\u00df (x,x.a) = (x, . -sound a.\u00df xx.a) infix 0 _ \\-because_-) _ \\-because_-) : .{a\u00df}. Name a . a . \u00df \n. Name \u00df _ \\-because_-) n pf = coerce N pf n The inclusion relation also expresses the emptiness of a \nworld a by using a .\u00d8. We use this de.nition of emptiness as opposed to an equality with the empty world \nfor two reasons. First \u00d8 is not the only empty world (\u00d8 +1 is empty as well). Second hav\u00ading world equalities \nwould require new de.nitions and would be heavy in comparison to the use of inclusions. Combining coerce \nN and \u00acName\u00d8 turns any contradiction on names into an inclusion problem, reusing any automation done \non this side. \u00ac Name : .{a}. a .\u00d8. \u00ac (Name a) \u00ac Name a.\u00d8 = \u00ac Name\u00d8. coerce N a.\u00d8 .-refl : .{a}. a . a \n.-trans : .{a\u00df.}. a . \u00df . \u00df . . . a . . .-\u00d8 : .{a}.\u00d8 . a .-\u00d8+1 : \u00d8 +1 .\u00d8 .-.1-.1: .{a\u00df}. a . \u00df . a .1 \n. \u00df .1 .-+1-+1 : .{a\u00df}. a . \u00df . a +1 . \u00df +1 .-+1-.1: .{a}. a +1 . a .1 Figure 5. Rules for world inclusion \nWe expose the inclusion relation with a set of rules given in .gure 5. This states that the inclusion \nrelation is re.exive, transi\u00ad tive, and has the empty world as lowest element. The .-\u00d8+1 rule states \nthat \u00d8 +1 is empty. The inclusion is preserved both ways by the contexts _.1 and _+1. Finally _+1 can \nbe weakened in _.1. This accounts for the fact that a .1 means {0}. (a +1) and so is a superset of a \n+1. This set of rules has been shown sound according to a semantic de.nition of inclusion, namely . x \n. x . a . x . \u00df. On top of these base rules, we de\u00adrived others that we omit to de.ne here but some are \nused in the code. Sometimes one has to build complex inclusion witnesses. While inference would be of \ngreat effect here, we propose a modest syn\u00adtactic tool to build them, namely the .-Reasoning module. \nIt gives access to the transitivity .-trans in a style which focuses more on the intermediate states \nof the reasoning rather than the steps. The syntax is a list of worlds interleaved by inclusion wit\u00adnesses, \nwith two around the last world. There is one example of its use in the following section. The code for \n.-Reasoning is given below for reference and can be safely skipped. module . -Reasoning where infix 2 \nfinally infixr 2 _ .\\_)_ _ .\\_ )_: . x {yz}. x . y . y . z . x . z _ .\\ x .y ) y .z= .-trans x . yy .z \nfinally : . xy . x . y . x . y finally _ _ x . y=x .y syntax finally x y x .y=x .\\ x .y ) y  2.6 Singleton \nworlds! We said that our worlds denote .nite subsets of N and are more precise than in the Fin approach. \nActually they can be as precise as we wish, since any subset of N can be described by our operations \non worlds (\u00d8, _+1, and _.1). In particular they can be singleton worlds. From singleton worlds we build \nsingleton types for names:  Worlds : N . World Worlds n= \u00d8.1+W n Names : N . Set Names = Name . Worlds \n _ s : . n . Names n s NN _ n =zero +n Singleton worlds not only exist, they are also preserved by our \ntwo updating operations, namely addN and subtractN . adds : .{n} k . Names n . Names (k+ N n ) adds {n} \nkx =addN kx \\-because .-assoc-+ . -refl n k -) subtracts : .{n} k . Names (k+ N n ) . Names n subtracts \n{n} k x = subtractN kx \\-because .-assoc-+l .-refl nk-) 3. Using NAPA: examples and advanced operations \n3.1 Some convenience functions Here are a few functions built on top of the interface (without using \nthe concrete representation of names). suc N is addN 1 and suc N . is a variant that includes a coercion \nfrom a +1 to a .1. The function _ N turns a number n into a name that inhabits any world with at least \nn+1 consecutive binders. suc N : .{a}. Name a . Name (a +1 ) suc N = addN 1 suc N. : .{a}. Name a . \nName (a .1 ) suc = coerce N .-+1.1 . suc N N. _ N : .{a} n . Name (a . suc n) N NN _ {a} n=zero +n \\-because \na .1+W n .\\ .-+-. n )a .1 . n .\\ .-exch-.-. 1n )a . sucn -) where open . -Reasoning We call e-bound, \na name bound somewhere in the scope of e binders. We call e-free, a name free for all e binders. In other \nwords, a de Bruijn index is e-bound if it is strictly less than e; it is e-free otherwise. The exportName \nfunction tells whether a given name is e\u00adbound or e-free. In case the name is free, an exported version \nof it is returned. This function forms the base case of exporting functions like exportTm explained later \non. --Partial functions from A to B A .?B=A . Maybe B exportName : .{a} e . Name (a . e) .? Name a exportName \ne x N with x <e ... | inj1 _ = nothing ll N ... | inj2 x= just (x-e) The function shiftName e k pf \nshifts its argument by k if this name is e-free, otherwise it leaves the e-bound name un\u00adtouched. This \nfunction makes use of cmp N and coerces the outputs to the required type. It also perform a coercion \non the .y, giving extra .exibility for free. shiftName : .{a} e k . (a +W k ) . \u00df . Name (a . e) . Name \n(\u00df . e) shiftName e kpf x N withx <e ... | inj1 x l =x l \\-because pf1 -) l l N ... | inj2 x =x+k \\-because \npf2 -) where pf1 = .-cong-.. -\u00d8 e pf2 = .-trans ( . -exch-+-+ . -refl e k) ( . -ctx-+. pf e) The protect. \nfunction shifts a name transformer. Let f be a function from names to names. The function protect. e \nf is a version of f that is applicable under e binders. Let x be a name under e binders. When x is e-bound, \nit is left untouched by protect.. When x is e-free, we can subtract e to x, give it to f, and then add \ne to get the result. By combining protect. and addN one obtain an alternative implementation of shiftName \ncalled shiftNamel. However shiftName is more ef.cient since it avoids to subtracting e to add it back \nafter adding k. protect. : .{a\u00df} e . (Name a . Name \u00df) . (Name (a . e ) . Name (\u00df . e )) protect. e fx \nN withx < e l l ... | inj1 x=x\\-because . -cong-..-\u00d8 e -) ll NN ... | inj2 x =f (x-e ) +e \\-because . \n-+-. e -) shiftNamel : .{a\u00df} e k . (a +W k ) . \u00df . Name (a . e) . Name (\u00df . e) shiftNamel e k pf = protect. \n(coerce N pf . addN k ) e  3.2 Building terms Building terms in NAPA is as easy as building them in \nthe other nameless approaches we have seen. The structure is exactly the same, and the variables are \nmade of numbers (of type N) using _ N . Below we de.ne the representation of the identity function as \nidTm, the application operator as appTm and .nally the composi\u00adtion function as compTm: idTm : .{a}. \nTm a idTm = n(V (0 N)) appTm : .{a}. Tm a appTm = n(n(V (1 N) \u00b7 V (0 N ))) compTm : .{a}. Tm a compTm \n= n(n(n(V (2 N )) \u00b7 (V (1 N) \u00b7 V (0 N )))))   3.3 Computing free variables Our .rst example of functions \nover terms simply computes the list of free variables in the input term. The fv function below, while \nstraightforward, has the subtle cases of binding constructs (n and Let). In these cases we have to remove \nthe bound variable from the list of free variables given by the recursive call. In this name\u00adless representation \nthis amounts to removing occurrences of 0 and subtract 1 to other name occurrences. This is done by the \nfunction rm0| which calls {agda|exportName 1 on each element of the list and merges the results. Note \nthat forgetting to remove the bound variable will result in a type error. In the same vein the typing \nof fv ensures that all returned variables do appear free in the given term. rm0 : .{a}. List (Name (a \n.1)) . List (Name a) rm0 [] = [] rm0 (x :: xs) with exportName 1 x ... | justx =x ::rm0 xs ... | nothing \n= rm0 xs fv : .{a}. Tm a . List (Name a) fv (Vx ) =[x] fv (fct \u00b7 arg ) = fv fct ++ fv arg fv (n t ) \n= rm0 (fv t ) fv (Let t u ) = fvt ++rm0 (fv u )  3.4 Generic traversal In order to build multiple traversal \nfunctions at once, we .rst de.ne a generic function based on ideas from [8]. It is essentially a map/subst \nfunction where the free variables are transformed by a user-supplied function. Moreover a class of effects \n(an applicative functor) is allowed during the traversal. An applicative functor is halfway between a \nfunctor and a monad. Like a monad, an applicative functor has a unit called pure. It allows to embed \nany pure value as a potentially effectful one. The second operation called _._ is an effectful application, \ntaking both an effectful function and argument and resulting in an effectful result. module TraverseTm \n{E} (E-app : Applicative E ) {a\u00df} (trName : . e . Name (a . e ) . E (Tm (\u00df . e))) where open Applicative \nE-app tr : . e . Tm (a . e) . E (Tm (\u00df . e )) tr e (Vx) = trName e x tr e (t \u00b7 u ) = pure _ \u00b7_ . tr e \nt . tr e u tr e (n t) = pure n . tr (suc e) t tr e (Let t u ) = pure Let . tr e t . tr (suc e) u trTm \n: Tm a . E (Tm \u00df) trTm =tr 0 To put this traversal at work we successively instantiate some of its arguments. \nFor instance you may have noticed the special case we made for variables. Mapping names to terms will \nbring us capture avoiding substitution almost for free. However, in the mean time we build trTml which \nmaps names to names. It does so by applying pure V to the name to name function: open TraverseTm trTml \n: .{E} (E-app : Applicative E ) {a\u00df}(trName : . e . Name (a . e) . E (Name (\u00df . e ))) . Tm a . E (Tm \n\u00df) trTml E-app trName = trTm E-app (.e x . pure V . trName e x ) where open Applicative E-app Renaming \nfunctions In many functions over terms the han\u00addling of variables shares a common part. Given a variable \nunder e binders, we test if the variable is e-bound. If so we leave it un\u00adtouched, otherwise we subtract \ne and go on a speci.c process\u00ading after which we add e again to the free variables of the result. The \ntraversal function is augmented by this processing of bound variables to build renameTmA. Then by picking \neither the identity functor (id-app), or the Maybe one we build two functions (a total and a partial \none) to perform renamings, namely renameTm and renameTm?: renameTmA : .{E} (E-app : Applicative E ) {a\u00df} \n(. : Name a . E (Name \u00df)) . Tm a . E (Tm \u00df) renameTmA E-app . = trTml E-app (protect.A E-app .) renameTm \n: .{a\u00df}. (Name a . Name \u00df) . Tm a . Tm \u00df renameTm . = trTml id-app (protect. .) --or --renameTm = renameTmA \nid-app renameTm? : .{a\u00df}. (Name a .? Name \u00df) . Tm a .? Tm \u00df renameTm? = renameTmA Maybe.applicative \n Lifting name functions Any operation on names can now be lifted to terms: addTm : .{a} k . Tm a . Tm \n(a +W k) addTm = renameTm . addN subtractTm : .{a} k . Tm (a +W k) . Tm a subtractTm = renameTm . subtractN \nexportTm? : .{a} e . Tm (a . e ) .? Tm a exportTm? = renameTm? . exportName While coerce N can be lifted \nto terms in the same way, using trTml directly enables to by-pass the protect. dynamic tests and directly \nprotect the inclusion witness with an appropriate inclusion rule. coerceTm : .{a\u00df}. a . \u00df . Tm a . Tm \n\u00df coerceTm pf = trTml id-app (coerce N .. -cong-. pf ) --or less efficiently: --coerceTm = renameTm . \ncoerce N  Lifting addN to terms can be done more ef.ciently (than using protect.) as well. Here the \ndynamic test performed by protect. is necessary. However when the name is e-free we subtract e to add \nit back after adding k. The function shiftName avoids this extra computation, hence the following shiftTm: \nshiftTm : .{a\u00df} k . (a +W k ) . \u00df . Tm a . Tm \u00df shiftTm k p = trTml id-app (.e . shiftName e kp ) --or \nless efficiently: --shiftTm k pf = renameTm (coerce N pf . addN k) A special case of renameTm? is the \nso-called closeTm?. This function takes a term in any world and checks if the term is closed. If so, \nthe same term is returned in the empty world. Otherwise the function fails by returning nothing: closeTm? \n: .{a}. Tm a .? Tm \u00d8 closeTm? = renameTm? (const nothing ) Capture avoiding substitution To implement \ncapture avoiding substitution for the Tm type we solely need a speci.c trName function for trTm. Here \nsubstitutions are represented as functions from names to terms. The function substVarTm handles the case \nfor variables. This function is very close to protect. but extended to functions returning terms. substVarTm \n: .{a\u00df}. (Name a . Tm \u00df) . . e . Name (a . e) . Tm (\u00df . e ) substVarTm f e x N with x <e ... | inj1 x \nl =V (x l \\-because .-cong-..-\u00d8 e -) ) ll N ... | inj2 x = shiftTm e ( .-+-. e)(f (x-e )) The main function \nsubstTm instantiates trTm with the identity applicative functor and substVarTm: substTm : .{a\u00df}. (Name \na . Tm \u00df) . Tm a . Tm \u00df substTm = trTm id-app . substVarTm As an illustration, the function \u00df-red takes \nthe body of a .\u00adabstraction and calls substTm with the substitution that replaces 0 with a received replacement \nterm: \u00df-red : .{a}. Tm (a .1 ) . Tm a . Tm a \u00df-red {a} f a = substTm (f . exportName 1 ) f where f : \nMaybe (Name a) . Tm a f (just x ) =Vx f nothing = a  3.5 Deciding term a-equivalence Our next example \nfocuses on comparison of terms. We .rst de.ne aEq, where aEq F is the type of functions comparing F structures. \naEq : (F : World . Set)(a\u00df : World ) . Set aEq F a\u00df =F a . F \u00df . Bool We show that all the subtle work \nis done at the level of names in a separate and reusable function called aeqName. This function takes \na function that compares two free names and builds one that compares two names under e bindings. It does \nso by comparing both of them to e. If they are both bound they can be safely compared using _== N _ since \nthey now are of the same type. If they are both free, they can be compared using the function received \nas argument. Otherwise they are different. aeqName : .{a\u00df} e . aEq Name a\u00df . aEq Name (a . e )(\u00df . e) \n aeqName e G x y with x <N e |y<N e l ll N l ... | inj1 x | inj1 y =x==y l ll N l N ... | inj2 x | inj2 \ny= G(x-e)(y-e) ...|_ |_ =false The aeqTm function structurally compares two terms in a sim\u00adple way, only \nkeeping track of the number of traversed binders and calling aeqName at variables. aeqTm : .{a\u00df}. aEq \nName a\u00df . aEq Tm a\u00df aeqTm {a}{\u00df} G = go 0 where go : . e . aEq Tm (a . e)(\u00df . e) go e (Vx )(Vy) = aeqName \ne G xy go e (t \u00b7 u)(v \u00b7 w ) = go e tv . go e uw go e (n t )(n u) = go (suc e) tu go e (Let tu )(Let v \nw) = go e tv . go (suc e) uw go___ =false 4. Soundness using logical relations Since our library is written \nin a type-safe language, one may won\u00adder what soundness properties are to be proved. Moreover our names \nare indexed by worlds and hold membership proofs. The functions over names are given precise types and \nhave been shown to be type-safe. However we still wish to show that our library re\u00adspects a model of \ngood behavior with respect to names and binders. Our model is based on logical relations indexed/directed \nby types. This technique [4] is independent of this work and enables to de.ne a notion of program equivalence. \nWe use this technique to capture good behavior of functions involving names and binders. Using this technique, \nthe set of speci.c de.nitions is kept to a minimum of one per introduced type (World, Name, and _._). \nOne proof per value introduced has to be done, which keeps the development modular and forward-compatible \nto the addition of more features. This section is organized as follows. First we recall the basics of \nlogical relations. Then we give a toy example to practice a bit. Then relations for worlds, names, and \nworld inclusions are given. Finally we make use of the construction to obtain free theorems [12] about \nworld-polymorphic functions over the Tm type. 4.1 Recap of the framework A relation is said to be type-directed \nwhen it is recursively de.ned on the structure of types. Let R be such a type-directed relation, and \nlet t be a type. Then, Rt is a relation on values of type t , namely Rt : t . t . Set. Recall that Set \nis also the type of propositions in AGDA. A type-directed relation is called logical when the case for \nfunctions is de.ned extensionally. Here extensionally means that two functions are related when they \nproduce related results out of related arguments. Let Ar be a relation for the arguments and Br a relation \nfor results. Two functions f1 and f2 are related if and only if for every pair of arguments (x1,x2) related \nby Ar, the results f1 x1 and f2 x2 are related by Br. This de.nition can be given in AGDA as well: RelatedFunctions \nAr Br f1 f2 = .{x1 x2}. Ar x1 x2 . Br (f1 x1)(f2 x2)  We say that a program or a value .ts a logical \nrelation when it is related to itself by the relation indexed by its type. We say that a logical relation \nis universal if every well-typed program .ts the logical relation. This notion of universality was originally \ncoined by John Reynolds as the Abstraction Theorem [11]. We call the AGDA logical relation the one de.ned \nby Bernardy et al. [4] for a PT S (pure type system) and naturally extended as they suggest to other \nfeatures of AGDA. While no complete mechanized proof has been done for this we will consider the AGDA \nlogical relation as universal. To simplify matters, the de.nitions shown here are not universe polymorphic. \nYou can .nd universe-polymorphic de.nitions in our complete AGDA development [9]. To formally de.ne a \nlogical relation indexed by types, a com\u00admon technique is to .rst inductively de.ne the structure of \ntypes. This is known as a universe of codes U. Then one de.nes a function called El from codes to types. \nFinally one de.nes by in\u00adduction a function called [_] from codes to relations on elements of type described \nby the given code. In AGDA the [_] function has the following type:(t :U) . El t . El t . Set. Be\u00adcause, \nwhen types contain variables, a good deal of complexity is added to this scheme, we opt for a lighter \nscheme. We do not de.ne U, El, and [_]. Instead, for each type constructor ., we de.ne a relation [.] \nFor the function type constructor the RelatedFunctions de.nition above is a good start. Actually this \nis a .ne de.\u00adnition for non-dependent functions. The dependent version of RelatedFunctions, called [.] \nhere, passes the relation argu\u00adment Ar x1 x2 called xr to the relation for results Br. In short the relation \nfor results now depends on the relation for arguments. Here is the de.nition in AGDA: Ar Br f1 f2 = .{x1 \nx2} (xr :Ar x1 x2) [.] . Br xr (f1 x1)(f2 x2) Note that this de.nition generalizes the case of non-dependent \nfunctions and universal quanti.cations as well. For non-dependent functions we simply provide a relation \nfor results which ignores its .rst argument (equivalent to RelatedFunctions and noted _[.]_ from now \non). For universal quanti.cations, since the ar\u00adguments are types, all we need is a relation for types \n(members of Set0) themselves. Following our convention we call this relation [Set0], its de.nition is \nthe set of relations between its arguments: [Set0 ] : Set0 . Set0 . Set1 [Set0 ] A1 A2 =A1 . A2 . Set0 \n For reference, full de.nitions for core type theory are given in .gure 6. We now have all the building \nblocks of the meta-function [function manually. To this end it suf.ces to replace each construc-_] and \nwe will not materialize it more here. We will apply the [_] tor . by [.], each non dependent arrow by \n[.], each dependent arrow (x:A) . B by \\ xr : [ A ]. By conven\u00ad ] )[.][ B tion we subscript the variables \nby r. Applications are translated to applications. Because of dependent types, this translation has to \nbe extended to all terms but we will not do it here. Finally here are a few examples of the manual use \nof the [_] function: N . N . Bool = [ ] [ N][.][ N][.][Bool] = . f1 f2 . .{x1 x2} (xr :x1 x2) [ N] {y1 \ny2} (yr :y1 y2) [ N] . [Bool] (f1 x1 y1)(f2 x2 y2) data : [Set0 ] .. --no constructors [.] data [Bool] \n: [Set0 ] Bool Bool where [true] : [Bool] true true [false] : [Bool] false false data : [Set0 ] NN where \n[ N] [zero] : zero zero [ N] [suc] : suc suc ( [ N][.][ N] ) [ l ] data__ {A1 A2 B1 B2} (Ar : [Set0 ] \nA1 A2) (Br : [Set0 ] B1 B2) : A1 l B1 . A2 l B2 . Set0 where [inj1] : (Ar . Ar Br) inj1 inj1 [ l ] [inj2] \n: (Br . Ar Br) inj2 inj2 [ l ] Figure 7. Logical relations for data types [ (A : Set0 ) . A . A= ] . \nAr = [.][Set0 ] (. Ar [.] Ar) . f1 f2 . .{A1 A2} (Ar :A1 . A2 . Set0 ) {x1 x2} (xr :Ar x1 x2) . Ar (f1 \nA1 x1)(f2 A2 x2) --Using the notation instead of [ (A : Set0 ) . ListA = \\ Ar : [Set0 ] )[.][List]] Ar \n= [.]: . l1 l2 . .{A1 A2} (Ar :A1 . A2 . Set0 ) . [List] Ar (l1 A1)(l2 A2) We now have the de.nition \nof the AGDA logical relation for the core type theory part. It extends nicely to inductive data types \nand records. The process is as follows: for each constructor . of type t , declare a new constructor \n[.] whose type is [ t ] ... This process applies to type constructors and data constructors of data types, \nand type constructors and .elds of record types. For reference, the logical relations for data types \nwe use in this development are in .gure 7.  4.2 An example: booleans represented by numbers We wish \nto explain how logical relations can help build a safe in\u00adterface to an abstract type. To do so we introduce \na tiny example about booleans represented using natural numbers. We want 0 to represent false and any \nother number to represent true. There\u00adfore the boolean disjunction can be implemented using addition. \nWe show that logical relations help build a model, ensure that a given implementation respects this model, \nand .nally show that a client that uses only the interface will also respect the model. Note however \nthat this is a toy example in several ways. There are no polymorphic functions in the interface, so no \ninteresting free theorems are to be expected. While we could prove the safety by de.ning a representation \npredicate in unary style, the logical relations approach is different. It relies on comparing concrete \ndata as opposed to mapping to abstract data. The unary construction would allow for a simpler construction, \nhowever this oversimpli.es the problem here and would be no longer useful for proving NAPA. Our tiny \nimplementation of booleans using natural numbers is given below. It contains a type B that we want to \nkeep abstract. It contains obvious de.nitions for true, false, and the disjunction  Set0 : . (A1 A2[ \nSet0 ] A1 A2 =A1 Set1 : . (A1 A2[ Set1] A1 A2 =A1 __: A2 : Set0 ) . Set1 . A2 . Set0 : Set1) . Set2 . \nA2 . Set1 [.].{A1 B1 B2}. [Set0 ] A1 A2 . [Set0 ] B1 B2 . [Set0 ] (A1 . B1)(A2 . B2) Ar Br = . f1 f2 \n..{x1 x2}. Ar x1 x2 . Br (f1 x1)(f2 x2) [.] infixr0__ [.] : .{A1 A2} (Ar [.] {B1 B2} (Br . ((x:A1) Ar \nBr = . f1 f2 [.]syntax Ar (. : [Set0 ] A1 A2) : (Ar B1 B2) [.][Set0 ] ) . B1 x ) . ((x:A2) . B2 x ) \n. Set1 :Ar x1 x2) . Br xr (f1 x1)(f2 x2) ..{x1 x2} (xr xr . f ) = \\ xr : Ar f [.] )[.] [.] : .{A1 A2} \n(Ar : [Set0 ] A1 A2) {B1 B2} (Br :B1 B2) ( [Set0 ][.][Set0 ] ) . [Set1] ({x:A1}. B1 x)({x:A2}. B2 x) \nAr Br = . f1 f2 ..{x1 x2} (xr :Ar x1 x2) . Br xr [.] syntax Ar (. xr . f ) = .\\ xr : Ar f [.] )[.] (f1 \n{x1})(f2 {x2}) Figure 6. Logical relations for core types _._. It intentionally has a dubious function \nis42? which breaks our still informal expectations from such a module. B : Set B= N false : B false \n= 0 true :B true =1 _ . _:B . B . B m . n=m+n is42? : B . B is42? 42 = true is42? _ = false The next \nstep is to de.ne our expectations. To do so, we give a binary relation which tells when two B values \nhave the same meaning. We do so with an (inductive) data type named [B] which states that 0 is related \nonly with itself, and that any two non zero numbers are related: data :B . B . Set where [B] [false] \n: [B] 00 [true] : .{mn}. [B] (suc m)(suc n) When plugged into the machinery of logical relations this \nsin\u00adgle de.nition suf.ces to de.ne a complete model of well-typed programs. However, the plumbing requires \nsome care. While the AGDA logical relation is universal, we have no such guarantee about the AGDA logical \nrelation where the relation for B is no longer [N] but [B]. Fortunately changing the relation at a given \ntype (B here) can be done safely. All we have to do is to consider programs abstracted away from B and \nits operations: true, false and _._. This can be done either through a mechanism for abstract types, \nor by requiring the client to be a function taking the imple\u00admentation for B and its operations as argument. \nHowever to use [B] as the relation for B, we have to show that the de.nitions which make use of the representation \nof B actually .t the relation. Since [true] and [false] are obvious witnesses for true and false, only \n_._ and is42? are left to be proved. Each time the goal to prove is mechanical on each constructor and \nput the name of the function twice to state : wrap the type with [\u00b7]we want it to be related to itself. \nHere is the de.nition for _[.]_: __: _ . __ . _ [ . ]( [B][.][B][.][B] ) The type of _[.]_ means that \ngiven inputs related in the model, the results are related in the model as well. Once unfolded the type \nlooks like: _ _: .{x1 x2} (xr :Bx1 x2) [ . ] {y1 y2} (yr :y1 y2) . [B] (x1 [ B] . y1)(x2 . y2) The fact \nthat input arguments come as implicit arguments will greatly shorten de.nitions. Now, thanks to the inductive \nde.nition of _+_, simply pattern-matching on the .rst relation suf.ces to reduce the goal, and allows \nthis nice looking de.nition where we see the usual lazy de.nition of the left biased disjunction: false] \n. x=x [ true ][ . ] _= [true] Let us now consider a proof for the is42? function. Fortunately there is \nno such proof since this function gladly breaks the intended abstraction. Instead we simply prove its \nnegation by exhibiting that given two related inputs (42 and 27) we get non related outputs (is42? 42 \n= 1 and is42? 27 = 0).  \u00ac is42? : is42? is42? ) \u00ac (([B][.][B] ) \u00ac [ is42?] [is42?] with [is42?] {42}{27} \n[true] ... | () --absurd Note that is42? is rejected by our model with no considerations about the other \nexported functions. Indeed with another implemen\u00adtation of _._ there would be no way to produce 42 and \nso no way to expose the wrong behavior of is42? using the interface. Using a model provides a better \nforward compatibility and enables proofs to be done in a modular way.  4.3 Relations for NAPA For NAPA, \nwe apply the same process as with booleans. We de.ne our expectations, by de.ning relations for introduced \ntypes (worlds, names, and inclusions). Finally we prove that each value/function exported .ts the relation. \n4.3.1 Relations for NAPA types Valid names are those which belong to their worlds, names with the same \nmeaning are those related by the relation between their worlds. What matters is not just the fact that \ntwo worlds are related, but how they are related. Indeed this will dictate when two names are related. \nWe need to de.ne a set of valid relations between worlds. The more relations are accepted, the more power \nit gives to the free theorems of world-polymorphic functions. However we want the equality test on names \nto be accepted. Thus we at least need the relation to preserve name equalities across the relation in \nboth directions. We require these relations to be functional and injective: FunctionalAndInjective R \n= . x1 y1 x2 y2 .R x1 x2 .R y1 y2 . x1 = y1 . x2 = y2 The relation [World] between two worlds a1 and \na2 is the set of functional and injective relations between Name a1 and Name a2. Then, two names x (in \na1) and y (in a2) are related by [Name] ar if and only if they are related by the ar relation. For the \n_[.]_ relation, we exploit the fact there is only one way to use an inclusion witness, namely coerce \nN . Thus, for the pur\u00adpose of building the model, we identify inclusions with their use in coerce N . \nPut differently, whatever the representation for inclusions is, the model takes them as functions from \nnames to names. Yet an\u00adother way to look at it is from the perspective of relation inclusions. A relation \nR1 is included in a relation R2 if and only if all pairs related by R1 are related by R2 as well. The \ncoerce N function be\u00adhaving like the identity function all these de.nitions coincide. For instance if \nwe expand the de.nitions for [Name] and [.], we get the de.nition for relation inclusion modulo the coercions: \n__ ar \u00dfr p1 p2 [ . ] = .{x1 x2}. (x1 ,x2) . ar . (coerce N p1 x1 , coerce N p2 x2) . \u00dfr We now have to \nde.ne operations on worlds that .t the log\u00adical relation. The case for [\u00d8] is trivial. Then ar [+1] is \nde\u00ad.ned by { (x+1, y+1) | (x, y) . ar } and ar [.1] is de.ned by {(0, 0)}. ar [+1] . We shown that both \noperations preserve functionality and injectiveness. Here are the signatures that these operations .t \nthe relation: record [World] a1 a2 : Set where constructor _,_ field R : Name a1 . Name a2 . Set R-fun-inj \n: FunctionalAndInjective R [Name] : ( [World ][.][Set0 ] ) Name Name [Name] (R ,_) x1 x2 = R x1 x2 _[ \n. ]_: ( [World ][.][World][.][Set0 ] ) _ . __ ._ __ ar \u00dfr a1.\u00df1 a2.\u00df2 N [= . ]( [Name] ar [.][Name] \u00dfr)(coerce \na1.\u00df1) (coerce N a2.\u00df2) Figure 8. Relations for NAPA types [\u00d8] : [World] \u00d8\u00d8 _ [+1] : ( [World][.][World \n] ) _+1 _+1 _ [.1] : ( [World][.][World ] ) _.1_.1  4.3.2 NAPA values .t the relation We now give a \nshort overview of the proofs needed to show that our functions .t the relation. Thanks to the de.nition \nof _[.1], zero N .ts the relation by de.nition. Thanks to the de.nition of _[+1], addN 1 and subtractN \n1 .t the relation as well. These two are later extended to addN k and subtractN k by an induction on \nk. Since [\u00acName\u00d8] receives names in the empty world, it trivially holds. Here is for instance the type \nsignature for [addN ]: [addN] : (.\\ ar : World ] ). \\ kr : [ N] )[ .] Name ar [.] [ Name] (ar [+W] kr)) \naddN addN For _[== N ]_, once unfolded, the statement tells that the equality test commutes with a renaming. \nThis means that the result of the equality test does not change when its inputs are consistently renamed. \nThe proof for _[== N ]_ is done in two parts. First, we have to relate the Boolean-valued function _== \nN _ to the fact it decides equality on names. Second, we make use of the two properties (functionality \nand injectiveness) of the relation between the two worlds. The de.nition of cmp N is not a simple induction \non its .rst argument. It calls _<=_ (which does an induction) and returns a Boolean value. Based on this \nBoolean value, the function cmp N returns either inj1 or inj2 (the constructors of _l_) with the same \nname (with a different proof). To prove _[cmp N ]_ we show the equivalence with a simpler inductive function \nand show that this simpler function is in the relation. Thanks to the extensionality of the logical relation, \nno additional axiom is required to show that cmp N .ts the relation. Thanks to the de.nition of _[.]_, \nthe proof that coerce N .ts the relation is a simple application of the hypotheses. Then the real job \nis to show that all the inclusion rules .t the relation. This means that they all behave as the identity \nfunction. All eleven rules stated in .gure 5 have been shown to .t the relation.   4.4 On the strength \nof free theorems Every well-typed function comes with a free theorem [12]. How\u00adever depending on the \ntype of the function the strength of the the\u00adorem varies a lot. For instance at type Int . Bool it says \nno more than the function is deterministic. At type .{A : Set}. A . A it says that the function behaves \nlike the identity function, which is much stronger. We now give a few elements of what can affect the \nstrength of free theorems in our context. We will continue to use our Tm type to represent some data \nstructures with names and binders but it could be any other. Various term types The weakest type we can \ngive to a value with names and binders is Tm (\u00d8. e) for a given e. Such a term can have a statically \nunknown number of distinct free variables, but we know that these variables are comprised in the interval \n[0 .. e-1]. The free theorem of .{e}. Tm (\u00d8. e) . Tm (\u00d8. e) says no more than the function is deterministic \n. We also know because of typing that the resulting term cannot have e-free occurrences. A stronger type \nis to use any world instead of the empty world, but still have a known amount of bindings. A function \nof type .{ae}. Tm (a . e) . Tm (a . e) has a stronger free the\u00adorem. It says that the function commutes \nwith a renaming of the variables in the world a (section 4.5). This is a common type to deal with open \nterms under a partial environment: .{ae}. Vec Info e . Tm (a . e) . Tm (a . e). The strongest type for \nterms is to make no assumptions on their free variables. This can be done by quantifying by an arbi\u00ad \nunprotectedAdd : .{a} e k . Name (a . e ) . Name (a . k . e) unprotectedAdd e k = coerce N ( . -exch-.-.l \ne k ) . addN. k In our previous work [10] we had only the . operation. Our function shiftName (protectedAdd \nin this example) was de.ned with the unprotectedAdd behavior. It took us a long time to discover this \nmistake, since we thought that our logical relation argument was enough. In summary we want to emphasis \nthat all the logical relations proofs have to be taken with great care. A weaker function type than expected \ncan ruin the intended informal properties.  4.5 Using logical relations and parametricity To formally \nshow that a world-polymorphic function f of type .{a}. Tm a . Tm a commutes with a renaming of the free \nvariables, we proceed as follows. First we recall the natural de.ni\u00adtion of logical relation on the type \nTm. Second we present the type Ren of renamings as injective functions. Third renaming is shown equivalent \nto being related at the type Tm. Finally we prove our commutation lemma by using the free-theorem associated \nto the function f. The logical relation for the type Tm is mechanical. It states that two terms are related \nif they have the same structure and related free variables: [Tm] {a1 Tm : .{x1 a1 : }a(a2r . Tm x2} (xr \n(V aName[]:r [World] a1 a2 . Set where x1)(Vx2) a2) data trary world. The free theorem associated with \nthe type .{a}. Tm a . Tm a says that the function commutes with renamings : x2) of the free variables. \nThis particular type is studied in detail in the [V] section 4.5. _ \u00b7 [ Extra arguments Note that adding \nextra arguments to a func\u00ad x1 (aTmtrr . aTmr[] .{t1 t2 u1 u2}_: ] t2): t1 (ur u2): u1 (t1 \u00b7 u1)(t2 \u00b7 \nu2) tion can drastically affect the strength of its free theorem. An ex\u00ad aTm[ ] r . aTmr[]r .{t1 t2} \n(tr (n : [.1] ) t1 t2) : [n][Let] treme example is the type .{a}. (a =\u00d8) . Tm a . Tm a, which is ruined \nby its a =\u00d8 argument. While the above exam\u00adple is extreme, this is an important point to watch out for \nwhen (aTm[]r t1)(n t2) (aTmtrr . [Tm] a.{t1 t2 u1 u2} : t1 t2): adding extra arguments to a function. \nAnother example is the type .{a\u00df}. Tm a . Tm \u00df . Tm \u00df versus .{a\u00df}. (Name a . Name \u00dfa . Tm \u00df . Tm \u00df, \nthe . Bool) . Tm .rst one cannot compare the free variables of the two given terms while the second can \napply a user-supplied function to do so. Shifting versus adding Last but not least using +W instead of \n. signi.cantly improves the strength of the associated free theorem. Consider the function: protectedAdd \n: .{a} e k . Name (a . e) . Name (a +W k . e ) protectedAdd e k = protect. e (addN k ) Consider now a \nweaker type, namely: protectedAdd. : .{a} e k . Name (a . e ) . Name (a . k . e) protectedAdd. e k = \nprotect. e (addN. k ) We simply replaced the occurrence of +W by .. The conse\u00adquences of this change \nare disastrous: this type allows more be\u00adhaviors for its functions. Indeed the addN k function can be \ngiven the latter type (but not the former) when using the appropriate in\u00adclusion witness to exploit the \ncommutativity of .: [.1] ) t1 u1)(Let (ur : u2)u1 (aTm[ ] r(Let r u2)t2 . [Tm] a Then we need a notion \nof renaming. We choose to use injec\u00adtive functions over names. The type for a renaming is Ren, and the \nfunctions \\_) and \\\\_)) respectively convert a renaming to a func\u00adtion over names, and to a relation \nover worlds: Ren : (a\u00df : World ) . Set \\_ ) : .{a\u00df}. Ren a\u00df . Tm a . Tm \u00df \\\\_)) : .{a\u00df}. Ren a\u00df . [World] \na\u00df We now observe that given a renaming F, it is equivalent for two terms t1 and t2 to be related by \n[Tm] \\\\ F )) and for t2 to be equal to t1 renamed with F. [Tm ].rename : .{a\u00df} (F : Ren a\u00df) {t1 t2} . \n[Tm] \\\\ F )) t1 t2 . ( \\ F ) t1) = t2  Finally given a function f and a proof fr that f is in the logical \nrelation, we can show that any renaming F commutes with the function f. To prove so we apply our [Tm].rename \nlemma in both directions and use fr with the renaming F lifted as a [World]. ren-comm : (f: .{a}. Tm \na . Tm a) (fr:(.\\ ar : [World] )[.][Tm] ar [.][Tm] ar)ff) ..{a\u00df} (F : Ren a\u00df) .\\ F ). f . f .\\ F )ren-comm \nf fr F t = [Tm].rename F (fr \\\\ F )) (rename.[Tm] F =.refl )) 5. Conclusion and future work We have \nshown a new approach for a safer nameless programming interface. Our work relies on a different notion \nof worlds both .ner and more abstract. The type of names while being represented as a natural number \nis kept abstract as well. Only a few functions are required from the interface to get complete expressiveness. \nIndeed while our worlds are more precise, nothing forces the programmer to be precise with them. Thus \nthere is no loss of expressiveness compared to the Fin approach. Through concrete examples we have shown \nhow we can program in this system using classical examples like capture avoiding substitution. However \nthe most challenging result comes from the solid mechanized development we have made in AGDA. This development \nnot only demonstrates the soundness of our approach but allows to derive properties of functions using \nthe system. This way we have shown that world\u00adpolymorphic functions over terms commute with renamings \nof free variables. These soundness results are shown in a modular way and reuse the solid foundations \nof logical relations. As future work we would like to explore more properties of this system. We have \nalso seen that a major convenience problem in our system was to build world inclusion witnesses. We would \nlike to address this problem through a witness inference system built within AGDA, using the recent re.ection \nmechanism. Another time-consuming task was to apply the AGDA logical relations to types and operations, \nso we would like to explore the integration of inspection primitives and meta-programming facilities \nfor AGDA, namely TEMPLATE AGDA. Finally we would like to investigate how this system could scale to representations \nof well-typed terms. Acknowledgements Thanks to Franc\u00b8ois Pottier, Jean-Philippe Bernardy, Alexandre \nPilkiewicz, and the anonymous reviewers for providing us with very valuable feedback. References [1] \nThorsten Altenkirch. A formalization of the strong normalization proof for System F in LEGO. In J.F. \nGroote M. Bezem, editor, Typed Lambda Calculi and Applications, LNCS 664, pages 13 28, 1993. [2] Thorsten \nAltenkirch and Bernhard Reus. Monadic presentations of lambda terms using generalized inductive types. \nIn Computer Science Logic, volume 1683 of Lecture Notes in Computer Science, pages 453 468. Springer, \n1999. [3] Franc\u00b8oise Bellegarde and James Hook. Substitution: A formal meth\u00adods case study using monads \nand transformations. Sci. Comput. Pro\u00adgram., 23(2-3):287 311, 1994. [4] Jean-Philippe Bernardy, Patrik \nJansson, and Ross Paterson. Para\u00admetricity and dependent types. In Proceedings of the 15th ACM SIG-PLAN \ninternational conference on Functional programming, ICFP 10, pages 345 356, New York, NY, USA, 2010. \nACM. [5] Richard Bird and Ross Paterson. de Bruijn notation as a nested datatype. Journal of Functional \nProgramming, 9(1):77 91, January 1999. [6] Nicolaas G. de Bruijn. Lambda-calculus notation with nameless \ndum\u00admies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. Indag. \nMath., 34(5):381 392, 1972. [7] Conor McBride and James McKinna. The view from the left. J. Funct. Program., \n14:69 111, January 2004. [8] Conor McBride and Ross Paterson. Applicative programming with effects. Journal \nof Functional Programming, 18(1):1 13, 2008. [9] Nicolas Pouillard. Nameless, painless (Agda code), 2011. \nhttp: //tiny.nicolaspouillard.fr/NaPa.agda. [10] Nicolas Pouillard and Franc\u00b8ois Pottier. A fresh look \nat programming with names and binders. In Proceedings of the 15th ACM SIGPLAN in\u00adternational conference \non Functional programming, ICFP 10, pages 217 228, New York, NY, USA, September 2010. ACM. [11] John \nC. Reynolds. Types, abstraction and parametric polymorphism. In Information Processing 83, pages 513 \n523. Elsevier Science, 1983. [12] Philip Wadler. Theorems for free! In Conference on Functional Programming \nLanguages and Computer Architecture (FPCA), pages 347 359, September 1989.    \n\t\t\t", "proc_id": "2034773", "abstract": "<p>De Bruijn indices are a well known technique for programming with names and binders. They provide a representation that is both simple and canonical.</p> <p>However, programming errors tend to be really easy to make. We propose a safer programming interface implemented as a library. Whereas indexing the types of names and terms by a numerical bound is a famous technique, we index them by worlds, a different notion of index that is both finer and more abstract. While being more finely typed, our approach incurs no loss of expressiveness or efficiency.</p> <p>Via parametricity we obtain properties about functions polymorphic on worlds. For instance, well-typed world-polymorphic functions over open &#955;-terms commute with any renaming of the free variables.</p> <p>Our whole development is conducted within Agda, from the code of the library, to its soundness proof and the properties of external functions. The soundness of our library is demonstrated via the construction of a logical relations argument.</p>", "authors": [{"name": "Nicolas Pouillard", "author_profile_id": "81470654166", "affiliation": "INRIA, Paris, France", "person_id": "P2801437", "email_address": "nicolas.pouillard@inria.fr", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034817", "year": "2011", "article_id": "2034817", "conference": "ICFP", "title": "Nameless, painless", "url": "http://dl.acm.org/citation.cfm?id=2034817"}