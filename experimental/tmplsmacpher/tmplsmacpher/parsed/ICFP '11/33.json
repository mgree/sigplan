{"article_publication_date": "09-19-2011", "fulltext": "\n Linearity and PCF: a Semantic Insight! Marco Gaboardi Luca Paolini Mauro Piccolo Dip. di Scienze dell \nInformazione, Dipartimento di Informatica, Universit`a Dipartimento di Informatica, Universit`a Universit`a \ndiBologna, INRIAFocus degli Studi di Torino -Corso Svizzera degli Studi di Torino -Corso Svizzera Team, \nMura Anteo Zamboni 7, 40127 185, 10149 Torino, Italy 185, 10149 Torino, Italy Bologna, Italy paolini@di.unito.it \npiccolo@di.unito.it gaboardi@cs.unibo.it Abstract Linearity is a multi-faceted and ubiquitous notion \nin the analysis andthedevelopment ofprogramminglanguage concepts.We study linearityin adenotationalperspectivebypicking \noutprograms that correspond tolinearfunctionsbetween coherence spaces. We introduce a language, named \nSlPCF., that increases the higher-order expressivity of a linear core of PCF by means of new operators \nrelatedto exceptionhandling andparallel evaluation. SlPCF. allows us to program all the .nite elements \nof the model and, consequently, it entails afull abstraction result that makes the reasoning on the equivalencebetweenprograms \nsimpler. Denotationallinearityprovides alsocrucialinformationforthe operational evaluation of programs. \nWe formalize two evaluation machineries for the language. The .rst one is an abstract and concise operational \nsemantics designed with the aim of explaining the new operators, and is based on an in.nite-branching \nsearch of the evaluation space.The second oneis more concrete anditprunes such a space,by exploiting \nthelinear assumptions.This can alsobe regarded as abasefor animplementation. Categories and Subject Descriptors \nD.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory Semantics, Syntax; D.3.3 [Programming Languages]: \nLanguage Constructs and Features Control structures; F.3.2[Logicsand meanings ofpro\u00adgrams]: Semantics \nof programming languages Denotational se\u00admantics,Operational semantics General Terms Languages,Theory,Design \nKeywords PCF, Linear Logic, Denotational Semantics, Opera\u00adtionalSemantics 1. Introduction Linearity \nis a key tool in order to support a conscious use of re\u00adsources in programming languages. A non-exhaustive \nlist of its uses includes garbage collection, memory management and alias\u00ading control, description of \ndigital circuits, process channels and messages management, languages for quantum computations, etc. \nA survey of several variants oflinear type systemsproposed inlit-eratureis[34].Thisbroad spectrum of \napplicationshighlightsthe Permission to make digital or hard copies of all or part of this work for personal \nor classroomuseisgranted withoutfeeprovided that copiesarenot madeordistributed forpro.tor commercial \nadvantage andthat copiesbearthis notice andthefull citation onthe .rstpage.Tocopy otherwise,torepublish,topostonservers \nortoredistribute tolists, requiresprior speci.cpermission and/or afee. ICFP 11, September19 21,2011,Tokyo,Japan. \nCopyright c &#38;#169; 2011ACM978-1-4503-0865-6/11/09. . .$10.00 fact that linearity is a multifaceted \nabstract concept which can be considered in different perspectives. For instance, notions of syn\u00adtactical \nlinearity can be considered when variables are used once (insuitablesenses), e.g.[4,21].Ontheotherhand,ifredexescan\u00adnotbediscarded \norduplicatedduring reduction[21] then akind of operational linearity is achieved. This is related to \nthe notion of simple term [24]in .-calculus which suggests a kind of linearity on reductions, unrelatedfrom \na speci.c strategy. Although some ideas that can be tracked to linearity have been implicitly used in \nprogramming languages for many years, the in\u00adtroduction of linear logic [19] is a redoubtable milestone \nin this setting.Linearlogic arisesfrom a sharp semantic analysis of stable domains where stable functions \nhave been decomposed into linear functions andexponentialdomain constructors.Such adecomposi\u00adtionispatently \nre.ectedinthe syntax oflinearlogic.Moreover,it suggests a new approach to linearity: denotational linearity.In \na programmingperspective,denotationallinearitysaysthatprograms (i.e., closedterms) should correspond \nvia a suitable interpretation to linear function on some speci.c domains, e.g. the linear mod\u00adelsintroduced \nin[13,14,19,22].By tackling this correspondence minutely some important contributions to the theory of \nprogram\u00adming can be obtained. If the considered domain includes all the computablefunctions(usually, \ntheydoit), then the analysispro\u00advides Turing-complete languages with weak syntactic linear con\u00adstraints \non variables, and newlinear operators that,in ahigher-type computabilityperspective[25, 27]increase the \nexpressivity of lin\u00adearlanguages. To advance in this research line, we aim to pick out all and only(recursive)linear \nfunctions in a linear model built as the full subcategory of coherence spaces andlinearfunctions[19] \nidenti\u00ad.ed by the type structure of numerals and arrows. The language SlPCF proposedin[30] iscorrectforthislinearmodel, \nsoitis denotationally linear. Moreover, it grasps a limited completeness, namely SlPCF is suf.cient to \nassure the de.nability of all the to\u00adkens( prime elements indomainterms)ofthelinear model.From thisfollows \na restrictedfullabstraction resultforterms withoutfree stable variables(i.e.variables usedfor recursion).A \nmoregeneral result was erroneously claimedin[30,Corollary3]; seeSection3 for moredetails. In thispaper \nwepropose SlPCF. alanguage extending SlPCF bythe operatorlet-lor.This operatorprovides alinear counterpart \nof the gor operator introduced in [29], and increases the non\u00addeterministic expressiveness ofthelanguage.Indeed,this \nextension allowsustogaina .nitede.nability result[15],i.e.thede.nability of all the .nite cliques of \nthe considered linear model. In fact, a crucial role in the proof of our .nite de.nability result is \nplayed not only by the let-lor operator but also by the SlPCF operator which?. In [30], the which? operator \nhas been proposed as an example of interesting higher-order linear operator providing run\u00adtime information, \nin order to give a .avor of our research line. However, it was not necessary for the token-de.nability \nand the limited full abstraction results. Here, we show how to use which? (together withthe newlet-lor \noperator)inordertoreachthe .nite de.nability.  By using the .nite de.nability, we prove that SlPCF. \nis fully abstract with respect to the considered linear model. That is, the operational equivalence coincides \nwith the denotational equiva\u00adlence. This result allows us to reason on programs in a composi\u00adtionalway.Thisisimportantbecause \nevenifthe operationalequiv\u00adalence is de.ned for closed ground contexts, since it relies on the operational \nformal machine evaluating programs, sometimes one wantsjustto replace a subterm with another one andpreservethe \nequivalence.So, we needto consider also open sub-terms thatform ourprograms.In our case,tacklingthe equivalence \nalso whenterms contain open variables is particularly challenging due to the pres\u00adence of stable variables, \nused for recursion. Besides, we prove the coincidence ofthreedifferentde.nitions ofoperationalequivalence \nthat make simpler the reasoning on the equivalence between pro\u00adgramsbypermittingto consider onlycontexts \nofa restrictedshape. Moreover, the proof of this result uses non-trivial syntactical and denotationalargumentsthat \nareto ourknowledge new andofwider interest. WeremarkthatSlPCF. isneither syntacticallylinear nor opera\u00adtionallylinearinatight \nsense,albeitits .nitaryfragment(theset of programs which does not involve recursion) enjoys some syntac\u00adtical \nand operational forms of linearity. For instance, it is syntac\u00adtically linear for slices, and when only \nslices are considered it can be evaluatedwithoutduplicatingredexes.Besides, we conclude the paperbygivingan \noperationalsemanticsinducingan ef.cient eval\u00aduation of SlPCF. terms.This operational semantics traces \nout and records linear information to drastically prune the in.nite branch\u00adingsearch tree of the evaluation \nof SlPCF.. Outline InSection2weintroducein aninformal waythe contri\u00adbutions that will be technically \npresented in the rest of the paper. InSection3weintroduce thebackground neededto understandthe technical \nresults of this paper. In Section 4 we show that SlPCF lacks the full abstraction. In Section 5 we introduce \nthe language SlPCF. andwegive someprogrammingexamples.InSection6we provethe .nitede.nability and thefull \nabstractionfor SlPCF..In Section 7 we show the coincidence of the three operational equiv\u00adalence introduced. \nIn Section 8 we give an abstract machine for SlPCF. that traces thelinear use of terms and itprovides \nthe base for an ef.cientimplementation of ourlanguage.  2. Contributions:AnInformalAccount Inthispaper, \nwepropose an extension of thelanguage SlPCF in\u00adtroducedin[30]. SlPCFis aPCF-likelanguage enriched withthe \nwhich? operator, that is correct for the considered linear model. In particular, linearity is obtained \nby means of some constraints on clever variable management. SlPCF is based on three kinds of .st variables:ground \nx and stable variables , that canbe weak\u00adenedandcontracted, andlinear ones fst that cannot.Groundand \nlinear variables canbe.-abstracted, stable variables cannot.Stable variables canbeboundby adedicatedbinder(the \n\u00b5-abstraction) andtheyare usedtode.ne recursivefunctions.In SlPCF, an argu\u00adment Nsuppliedto .x.Mis evaluatedbyusinga \ncall-by-valuepolicy in case x isground, acall-by-namepolicy otherwise.Moredetails canbefoundinSection3.2. \n Thedenotationalinsights The basic components of the model are tokens. A token is a tuple of natural \nnumbers that complies with the structure of types. For instance ((. . .). .). (. . .). . ( ((0 , 1) , \n2) , (3 , 4) , 5) The second row of the formula above describes a token belonging tothecoherencespacecorrespondingtothetypewritteninthe \n.rst row(clearly, .is the type of natural numbers while .is thelinear arrow). SlPCF is able to de.ne \nall the tokens which belong to coherence spaces corresponding to the types[30].Forinstance, the followingtermde.nes \nthe token written above: (((. ). ). ) .f..g.lif f.x.lif (x = 0)1O= 2and (g3 = 4)5O. Toprogram a token \nmeans to verify that each input coincides with the one described by the token, in the example there are \ntwo input (i.e.((0,1),2)and (3,4)). The elements of the linear model as usual in coherence spaces are \ncliques, i.e. sets of coherent tokens. The coherence relation ensures that cliques describes only traces \nof functions(where the trace is an economic way to describe the graph of a function). In particular, \ncoherence establishes when two tokens can coexists in thetrace ofafunction.Consider asimple clique ofalinearfunction: \n.. ( (0,0), ((5,7), 0), 0) .. ( (2,0), ((3,9), 1), 1) . ( (2,1), ((3,9), 1), 2) . Above three tokenshave \ntwoinput arguments, respectively of type . . . and (. . .) . .. Coherence ensures that, for each pair \nof tokens, there exists an input argument allowing to decide what is the unique token being (eventually) \ninvolved in the computa\u00adtion. For instance, by applying the .rst argument to 2 we can dis\u00adtinguish between \nthe second and the third token, in fact the sub\u00adtokens (2,0)and (2,1)are incoherent indeed they cannot \ncoexist in the same function. Likewise, by applying the second argument .. to .x ..lif (x = 5)7 (lif \n(x = 3)9O), we can distinguish the .rst token from both the second and the third. Indeed ((3,9),1) and \n((5,7),0)are incoherent and they cannot coexist in the same function. Theseproperties are importantin \norder toprogram linearfunc\u00adtions, however, linearity gives no information about how to locate such observations. \nIn particular, when higher-order types are con\u00adsidered thisbecomesquite tricky, andparallelismis necessary. \nIsSlPCFabletoprogram(atleast)all the .nitecliques? Anticipating, we say immediately that the answer is \nnegative: SlPCFallowsustoprogramsome .nitecliquesbutnot allofthem. Theextensionweproposeinthispaperhowever \n.llsthisgap.That is, SlPCF. permitsonetoprogramallthe .nitecliques. Letus nowgoin moredetails. SlPCFisTuring-complete.This \nmeans that it is able to program all the .rst order (computable) cliques. For instance denoting with \n* the multiplication between numerals, thefollowingterm . \u00b5..x.lif (x = 0)1 (x * ((px .))) de.nes the \nclique {(n,factorial(n))|n . N}. So at the .rst order, SlPCF is able to program not only all the .nite \ncliques but all the computable in.nite ones. When higher-order functions are considered, however, the \nsituation becomes more dif.cult. For instance,ifwe want tode.ne thefollowing clique {} ( ((0,3), 0), \n1) ( ((1,4), 0), 2) we cannot discriminate the twogiven tokensjustby looking at the result of the evaluation \nof the argument applied to the term N = .. .x.lif (x = 0)3 (lif (x = 1)4O), because it corresponds to \n0 forboth tokens.Inordertodiscriminatethem, we need tograsp someintensional aspect of theaboveevaluation, \nmorespeci.cally, we need to identify the value passed to N (i.e.0 in the .rst token and 1 in the second). \nInformation like this can be retrieved by an appropriate use of the which? operator, introduced in [30]. \nThe which?operator corresponds to aprimitiveform of exception handling:itallows to obtainbesides the \nresult ofan evaluation also theinformation on whathasbeen usedduringthat evaluation.More examples areinSection5.1. \n Thewhich?operatorincreasesthe expressivityofthelanguage. However, there are still some .nite cliques \nthat cannot be pro\u00ad grammed inSlPCF. For instance, . . ( (0,0), (1,0), (0,1), 0) . . ( (0,1), (0,0), \n(1,0), 1) (1) . ( (1,0), (0,1), (0,0), 2) . The reasonisthatwe cannotidentifyapriori whichisthe observa\u00adtionthat \nshouldbedone. Inparticular,wearenotabletodetermine which argument we should observe .rst and what is \nthe value we should supply toit.Suppose we want to realize theprogramde.n\u00adingthe cliqueinEquation1, writinga \nterm ofthefollowing shape (. (. )) .f1..f2..f3..x.lif (x = 0)P1 lif (x = 1)P2 P3 (f10) This means that \nwe start the observation from the .rst argument f1 and we apply 0 to it. This term diverges if we supply \nas .rst argument a term de.ning (1,0)and any other term as second and thirdargument.However,thisbehavior \ncanbe admittedbythethird token. Something similar happens if we start the observation from an other argument \nand/orifwe choose to apply1 instead of 0 toit. Such abehavior wouldbe notdesirable. To solve this circularity, \nwe need to make available a parallel operator.Thiskind ofparallelismis wellknownin stabledomains, where \nso calledGustave sfunctions exists[6,8].Following[29], we could add a gustave-or operator where linearity \nis carefully forced.Thatis, agustave-or typed asfollows: G . M1 : . G . M2 : . G . M3 : . G .Gor (M1,M2,M3): \n. withtheprovision thatthebasis Gdoes notcontainlinear variables. This operator can thenbe equipped bythefollowing \nsemantics: M1 . 0M2 . n + 1M2 . 0M3 . n + 1M3 . 0M1 . n + 1 Gor (M1,M2,M3). n Gor (M1,M2,M3). n Gor (M1,M2,M3). \nn AddingittoSlPCFhoweveris notsuf.cient toprogram the clique de.ned in Equation 1(actually, to extend \nSlPCF by Gor does not add any linear function!). We need something enabling a limited form of contraction \non linear variable to permit parallel observa\u00adtions of the same linear variable on different arguments. \nOne way to do this is by introducing a further control operator, that can be described as a let-like \noperator: G . N : s . t . : s . t,. . M : . G,. . let st = N in M : . where the variable . can be weakened \nand contracted, i.e. it does not respect any occurrence constraint. The operational meaning of this let-like \noperator canbedescribedby thefollowingrule: [P] = {a}.[N] M[P/]. nM[O/]. let st = N in M . n Such anoperatorappearstohavethe \n.avorof theco-derelictionof DifferentialLinearLogic[16].Theidea motivating theabove rule is that: Denotational \nlinearity allow several observations of a clique, aslongas theyareperformed on the same token. Following \nthis intuition, the side condition [P] = {a}. [N] says that Pisinterpretedasthe uniquetoken ofNthat canbe \nso observed several time in evaluating M[P/]. The third condition M[O/]. insteadisherejust to ensure \nthat the tokenis actually reallyused. A clever combination of the two above operators allows to program \nthe cliquedescribedinEquation1(suchcombination will bedetailedinSection5.1).We remark somedrawbacks of \nlet. 1. Its operational rule given above is not effective, due to the presence ofthe thirdcondition M[O/].. \n 2. Itlimitstheunderstandingoftheprogramcontrol.ow.It canbe checkedonlyatrun-timethatthe sametokenhasbeen \nobserved.  The .rst drawback can be solved by designing an ad-hoc opera\u00adtionalsemantics, the second \noneis moreproblematic sinceit could make the understanding of programs really problematic. For these \ntwo reasons, we extend SlPCF by a single operator, combining together Gor and let.The let-lor (consideringonlyalinear \nvari\u00adable f)is typedasfollows: G . N : s f : s,. . M1 : . f : s,. . M2 : . f : s,. . M3 : . G,. . let \nfs = N inlor M1 M2 M3 : . again with the provision that the basis . does not contain linear variables.Notethat \nnowthe let-boundedvariable fislinear, albeit used in three program-branches. The let-lor evaluation can \nnow bedescribed using rules asfollows: M1[P/f]. 0M2[P/f]. n +1 [P] = {a}.[N] let fst = N inlor M1 M2 \nM3 . n (we give just one rule, the other two are analogous). Thanks to a generalized let-lor operator, \nthe resulting language SlPCF. permits to program all the .nite cliques. So, the full abstraction follows. \n The operationalInsights Thefull abstraction result mentioned above ensures as usual that a compositional \ntheory ofprogramequivalence canbede.ned.That is, program equivalence is a congruence. Concretely, the \nfull ab\u00adstractionisproved withrespect to a non-standard notion ofcontex\u00adtual equivalence ~, named .x-point \nequivalence de.ned as: Ps/FPs/F M ~ N iff C[M[Fs]]. n .. C[N[Fs]]. n si where all the Pi are closed terms. \nThis notion of equivalence makes explicit the fact that for reasoning in a compositional way about programs \nwe need to permit to substitute general terms to stable variables, even if such variables are only used \nfor dealing with recursion. It is exactly to program the Pi that the de.nability ofallthe .nitecliquesisneededinordertogetfullabstraction.In\u00addeed,in[30]afull \nabstraction resultfor terms without open stable variables was proved. Anyway, the de.nition of .x-point \nequiva\u00adlence seems ad-hoc with respect to the usual notion of contextual equivalence: M N iff C[M]. \nn .. C[N]. n So,itis natural to consider thefollowingquestion: Do the relations ~and coincide? Anticipating, \nthe answer to this question is positive. Although, proving this result is quite technical. Intuitively, \nthe reason is that stable variables can only be \u00b5-abstracted.Moreprecisely, suppose M ~ N and suppose \nthey have a free stable variable . of type s1 . ... . sk . .. We have that there is a context C and a \nterm P such that C[M[P/]] . n and C[N[P/]] . n. Intuitively, to prove that also M N holds, one could \nthink tobuild a(pseudo)\u00adcontext C ' = C[(..[])P]  such that C ' [M] . n and C ' [N] . n. Unfortunately, \nthis context cannot be built since the stable variable . cannot be .-abstracted butcan only \u00b5-abstracted.So, \nthebest that one canhope togetis a context C '' = C1[\u00b5.C2[]] acting similarlyto C ' .We willshowinSection7howtobuild \na such context.Here, wepropose an example.Suppose that M and N canbe distinguishedinthe emptycontext \n[.],by using P(for simplicity, we assume ,P typed . . ., and [P] = {(n,m)}with n =0). So, we consider \na term P ' : . . .de.ning the clique {(0,0),(n,m)}. We cande.ne C '' as ((.. (. ))' ) \u00b5..y..x .lif (x \n= 0)[.]lif (x = m)m O(Py) '' [N]0 Therefore, this context can be used to build the terms C '' [M]0. '' \n[N]/] and C After one recursion step, the terms N[C and '' [N] M[C '' [M]/]are obtained.However,in the \nnext recursive step C and C '' [M]willbehave exactly as P and so the two terms canbedis\u00adtinguished. One \ncan doubt that this construction cannot be always done.However,thepropertiesofthelinearmodel ensurethat \n.nite cliques are never maximal with respect to the set theoreticalinclu\u00adsion.Thisforinstancedoes nothappenin \nstable models ingeneral. This means that given a .nite clique x one can always .nd a new coherenttoken \nthatcanbe addedtoit andthat canbe usedto control the recursion.Theproofjustgeneralizes this example. \nBesides the equivalence of programs, linearity provides also crucial information for the operational \nevaluation of programs. As instance, the side condition [P] = {a}. [N] in the rule of let-lor above assumes \nthe existence of such a P, but it does not give any hints on its search. If we face a concrete implementation \nof SlPCF. then this could be a problem. An exhaustive search of such atoken a isintrinsicallyinef.cient.So,itis \nnaturalto consider thefollowingquestion: Is there a reasonable way todrive the evaluation of SlPCF. programs? \nThe answertothisquestion as we willshowinSection8ispositive, and again linearity comes in our help. It \nensures two important properties: .rst that such a token a exists, and second that it is unique.Fromtheseproperties \nwe candevise a .nerimplementation of thelanguage.Consider again the rule M1[P/f]. 0M2[P/f]. n + 1 [P] \n= {a}.[N] let fst = N inlor M1 M2 M3 . n Instead of evaluating Mi[P/f] one can think to evaluate Mi in \nan environment e storing the information about variables. So, we associate f to the term N. When the \nterm N is used, we record its observed token a (convenientlyencodedby aterm P).Inparticular, the above \nlet-lor rulebecomes, roughly: (M1|e0[f:=N]).T (0|e1[f:=P])(M2|e1[f:=P]).T (m|e2) (let f = Ninlor M1 M2 \nM3|e0).T (m|e2) Note that the above reasoning relies on an effective tracing of all evaluated terms.Forinstance \nan evaluation of the term (.x . .M)Qis done using a rule as (Q|e0).T (m|e1)(M|e1[x :=m]).T (n|e2) (fQ|e0[f:=.x \n. .M.]).T (n|e2[f:=(m,n)]) that traces theinformation of the used token, i.e.itputs (m,n)into the environment. \nA tracing evaluation of SlPCF. programs will be devised in Section 8. Note that this kind of evaluation \ncan be considered akind oflinear call-by-need evaluation where only one evaluationisdone and wherefurther \nobservations are usedto check the consistency of theinformation.  Synopsis In summary, thekey contributions \nof thispaper are: The de.nition of a new linear operator let-lor (De.nition 13) thatpermitstoestablish \nabridgebetweendenotational and syn\u00adtacticallinearity through afull abstraction result(Corollary2).  \nA .nitede.nability result(Theorem6).Itgivesevidencethat SlPCF. is able to program a broader class of \nlinear programs than otherlinearprogramminglanguages.  The coincidence ofdifferentoperational equivalences(Corollary \n5).This makes simplerthe reasoningonthe equivalencebetween linearprograms.  An ef.cient reduction semantics \nexploiting linear properties in order to provide a concrete running evaluation of SlPCF. that avoids \nexhaustive evaluation searches, by tracing and recording explicitly thelinear use of subterms.   3. \nBackground 3.1 CoherenceSpaces Coherence spaces are a simple framework for Berry s stable func\u00adtions[7],developed \nbyGirard[19].Moredetails arein[20]. Acoherence space X is apair(|X|,. .X)where |X|is a setof tokens called \nthe web ofX and . .X is a re.exive and symmetric relationbetween tokens of |X|called the coherence relation \nonX. The strictincoherence .X is the complementary relation of . .X; the incoherence .=;thestrict .X \nisthe union ofrelations .X and coherence .X is the complementary relation of . .X.A clique x of X is \na subset of |X|containing pairwise coherent tokens. The set of cliques of X isdenoted Cl(X), while the \nset of.nite cliques isdenoted Clfin(X). Thebasisofourmodelisthein.nite .atdomain.Let N denotes the space \nof natural numbers, namely (|N|,.= .N)such that |N| . and m.n ifand onlyif mn,for all m,n .|N|. .N = \nDe.nition 1. Let X and Y be coherence spaces and f : Cl(X)-.Cl(Y)be a monotonefunction.Then, f islinearwhen\u00adever \n.x .Cl(X),.b . f(x).!a . x s.t. b . f({a}). Linearfunctions canbe represented as cliques. De.nition 2. \nLet X and Y be coherence spaces. X . Y is the coherence space having |X . Y| = |X|\u00d7|Y|as web, while (a,b).XY \n(a ' ,b ' )iff a \u00a8X a ' implies b .Y b ' . The trace of a linearfunction f : Cl(X).Cl(Y)is Tr(f)= {(a,b) \n| a .|X|,b . f({a})}. Given t .Cl(X . Y)and x .Cl(X),let usde.ne the map F(t): Cl(X).Cl(Y)as F(t)(x)= \n{b .|Y||.a . x, (a,b). t} (2) Lemma 1. If f : Cl(X) .Cl(Y) is a linear function then Tr(f).Cl(X . Y). \nIf t .Cl(X . Y)then F(t): Cl(X). Cl(Y)is alinearfunction. De.nition 3 (Linear Model). The Linear Model \nL is the type structuregeneratedby thecoherence space N and the arrow ..  3.2 Thelanguage SlPCF SlPCF \nhas been introduced in[17,30] to be the syntactical coun\u00adterpart of the above mentionedlinear model. \nDe.nition4. The set . of linear types isde.ned by thegrammar: s,t ::= .|s . t , where .is the only ground \ntype. For the sake of clearness weintroduce threekinds of variables, in order to remark theirdifferent \nexplicit use. De.nition 5. Let Vars be numerable sets of variables of type s. Let SVars (s = .) be numerable \nsets of variables disjoint from  (z) (s) (p) (v) (w) s . . 0 : . . s : . . . . p : . . . . : s . which? \n:((. . .). .). . . . G . M : t G,x1 . ,x2 M : t G,x s . M : t Gn.=\u00d8 G . M : . . . L : . . . R : . (gw) \n(gc) s (.) (lif) . . . . G,xM : t G,xM[x/x1,x2]: t G . .x .M : s . t G,. . lif M L R : . ss s . G . \nM : t G,1,2 . M : t G,M : s G.l = \u00d8 Gn.=\u00d8 G . M : s . t . . N : s (sw) (sc) (\u00b5) (ap) s . s . G,M : t \nG,M[/1,2]: t G . \u00b5.M : s G,. . MN : t M . nM . s nM . 0 L . mM . s(n) R . mM[N/f]P1 \u00b7\u00b7\u00b7 Pi . v (0) (s) \n(p) (i.) (ifr) (.) 0 . 0s M . s n p M . n lif M L R . m lif M L R . m (.fst .M)NP1 \u00b7\u00b7\u00b7 Pi . v . .  \nM[\u00b5.M/]P1 \u00b7\u00b7\u00b7 Pi . vN . mM[m/x]P1 \u00b7\u00b7\u00b7 Pi . vM(.x .lif(p ... p x)k (p0)). n . (w) (\u00b5) (.) (\u00b5.M)P1 \u00b7\u00b7\u00b7 \nPi . v (.x . .M)NP1 \u00b7\u00b7\u00b7 Pi . v which?M(..). ..n,k. [0.]. = {0} [s ..]. = {(n,n +1) |n . .} [p ..]. = \n{(0,0)}.{(n,n -1)|n . . .n> 0} [x s]. = {.(x s)} sts s [s]. = .(s) [MNs]. = F([M].)[N]. [.x .Mt]. = {(a0,b) \n.|[s . t]||b . [M].[x := a0]} .. ..... [(lifMNL). ]. = {n . . |[M]. = {0}.[N]. = {n}}.{n . . |[M]. = \n{m +1}.[L]. = {n},m . .} [(\u00b5s .Ms)s]. = fix(.x .Cl([s]). [M].[. := x ' ]) [which?]. = {(((n,n),r),.r,n.)|n,r \n. .} x ' .finx Table1. (a)Type system,(b)operational semantics and(c)linearinterpretationfor SlPCF Vars. \nVariables in Var. are named ground variables. Variables in lVar = Varst are named linear variables. \nVariables in s,t.. SVar = s SVars are named stable variables. =. Note that there are no stable variables \nof type .. Latin letters sss x ,y ,f,... denote variables in Vars. We use types to explic\u00aditly distinguish \nbetween ground, e.g. x ., and linear variables, e.g. stsss x .Moreover, 0,1,2,... denote stable variables. \nLast, . is a wild-cardfor all the variables. Wede.neterms(De.nition7) asthepre-terms(De.nition6) that \ncanbe typed using the type systeminTable1.a. De.nition6. Pre-termsarede.ned by thegrammar: M ::= . t \n|0 |s |p |lif M M M |(MM)|(.x s .M)|\u00b5.M | which? We write n for s(\u00b7\u00b7\u00b7 (s0)\u00b7\u00b7\u00b7 )where s is applied n-times \nto 0, and wedenote N = {0,..., n,...}the set of numerals. Weconsidertypingjudgments of the shape G . \nM : s where M is apre-term, s is a linear type and G is a basis,thatisa .nitelist of variables in Var, \nwhere each variable appears at most once. We denoteG.S (respG.., G.l)the restriction ofthebasisGcontaining \nonly variables in SVar (resp. inVar. , lVar). We denoteG,. and Gn.the union and theintersection of twobasis \nrespectively.We can nowde.ne SlPCFterms. De.nition 7. The terms of SlPCF are the pre-terms typable by \nusing the type systeminTable1.a. Sometimes, we write Ms when, for some G, we have G . M : s. Free variables \nof any kind (FV), free linear variables (lFV), free stable variables(SFV), closedand open terms are de.ned \nas expected. Wedenote P = {MSlPCF |FV(M.)= \u00d8} the set of . . programs.As usual, M[N/]denotesthe capture-free \nsubstitution of allfree occurrences of . in M by N. s . Lemma 2 (Substitution). Let Mt ,NSlPCF. If lFV(Mt)nlFV(Ns)= \n\u00d8 and x s . lVar then Mt[Ns/x s]. SlPCF.  If lFV(Nt)= \u00d8then Mt[Ns/s]. SlPCF.  If lFV(Nt)= \u00d8then M[N/1,..., \nN/n]. SlPCF.  Pairing (i.e. mapping pair of numerals on one numeral) and projections function willbe \nused everywhere in thepaper. We will denote with.n,m.the numeral kencodingthe orderedpair of n and m \nand we write p1(k)for the numeral n and p2(k)for the numeral m. SlPCF-termsde.ning them canbefoundin[30].We \navoided to explicitly use theproduct-types in syntax and semanticsjust for sake of simplicity, albeit \na such extension canbepursued. De.nition 8. The evaluation relation .. P \u00d7N is the smallest relation \ninductively satisfying the rules of Table 1.b. If there exists a numeral n such that M . n then we say \nthat M converges, and we write M ., otherwise we say that it diverges, and we write M .. Remarkthatp \nis apartialoperator, namely p0 diverges.Moreover, note that as stressedinSection2, the result of the \nevaluation of the operator which?applied to a term M consists of apair .n,k.where n is the result of \nthe evaluation of M(.x . .x)while k is the unique (thanks tolinearity)numeral that M gives as argument \nto.x . .x. The set of s-context Ctxs isde.ned as: C[s] ::= [s]|t |0 |s |p |lif C[s]C[s]C[s] | which? \n|(C[s]C[s])|(.x s .C[s])|\u00b5.C[s] C[Ns]denotes the result obtained by replacing all the occurrences of \n[s]inthe contextC[s]bythetermNs andby allowingthe capture ofitsfree variables. De.nition 9 (Standard \nOperational Equivalence). Let Ms ,Ns . SlPCF. M .s N whenever,for all C[s]s.t. C[M],C[N]. P, if C[M]. \nn then C[N]. n.  M s N if and onlyif M .s N and N .s M.  We areinterestedin alanguage for which thelinear \nmodel Lis fullyabstract under a standardinterpretation [-],i.e.ground types areinterpreted on .atposets(see[33]).Thestandardinterpretation \nis such that [.] = N and [s . t] = [s] . [t]. An environment . . Env is a partial function mapping a \nvariable x s in a token a .|[s]| and a stable variable s in a .nite clique x .Clfin([s]). The set of \nenvironments is denoted by Env. Let Fa be a sequence of tokens of a coherence space, let Fx be a sequence \nof non-stable variables of the same length of Fa; .[Fx := Fa]is the environment such that .[Fx := Fa](x \n' )= ai in case x ' is the i-th element of Fx, otherwise .[Fx := Fa](x ' )= .(x ' ).If Fx is a sequence \nof .nite cliques and F  . is a sequence of stable variables of the samelength then .[Fx]isde.nedlikewise. \n. := F de.nableinSlPCF, sinceitis not strongly stable[12].We use this function tode.ne two termshavingfree \noccurrences ofstable vari\u00adables which are operationally equivalent, albeitthey areinterpreted into twodifferentlinearfunctions. \n4.1 Token enumeration De.nition 10. Let Ms ,Ns . SlPCF and . . Env. The linear interpretation [Ms] : \nEnv .Cl([s])is de.ned in Table 1.c using F as de.ned in Equation 2 and fix which is the least .x point \noperator.  3.3 StableClosedFullAbstraction We recall the main properties of SlPCF [30, 32]. First, the \nlinear interpretationis adequate and correct. . . s . Theorem1 ([30]). Let MP and Ns ,LSlPCF. . . Adequacy: \nMn .. [M.] = [n]. Correctness: [Ns] = [Ls] . N s L In SlPCF all the tokens of the linear model L can \nbe de.ned. Moreover, as shown in [30], this can be done without using the which?operator. Theorem2 (TokenDe.nability). \nIf u .|[s]| then there exists a closed Ms . SlPCF such that [M] = {u}. Tokende.nabilitypermitstode.nethe \nseparatingterms usedin the nextlemma.Thisin contrast to whathappensin[29,33] where a .nitede.nabilityisneeded. \nLemma 3 (Separability). Let s . .. For all distinct f,g . Cl([s])there exists a closed term Ps. such \nthat F([P])(f)= F([P])(g). Fromthisfollowsthatfullabstractionholdsfor allthetermsthat do notcontainfree \nstable variables.We stressthat such a result was erroneously claimedin[30] tobe of moregenerality.Indeed, \nwe showin the next section that the unrestrictedfull abstractionfails. Theorem 3 (Stable Closed Completeness). \nLet Ms ,Ns . SlPCF and SFV(Ms)= SFV(Ns)= \u00d8.Then: M s N . [M] = [N] Proof. Letusprovethe contrapositive.Let \nus assume [M]. = [N]., for an environment .. By Separability Lemma 3, there exists a closed Ps. such \nthat F([P].)([M].)= n1 = F([P])([N].). Moreover,byTokenDe.nabilityTheorem2we canbuild a context C[.]such \nthat [PM]. = [C[PM]]\u00d8and [PN]. = [C[PN]]\u00d8where \u00d8 istheempty environment.So,by adequacy wehave (C[PM]). \nn1 and (C[PN]). n1.So M s N. Note that,in the aboveproof theTokenDe.nabilityTheorem2 allows us to build \nthe context C[.]only because we have assumed that the two termshave no stable variables. In the next \nsection, we prove that in order to relax this constraint the language must to be extended. Corollary \n1 (Stable Closed Full Abstraction). Let Ms ,Ns . SlPCFand SFV(Ms)= SFV(Ns)= \u00d8. Then: M s N .. [M] = [N] \n  4. Lack ofFull abstraction SlPCFdoes not enjoy the unrestrictedfull abstraction.In this sec\u00adtion, \nwe showthat theCorollary1 cannotbe extended totermshav\u00ading free occurrences of stable variables, since \nthey are interpreted in .nite cliques. We prove that SlPCF is not able to de.ne all .\u00adnite cliques of \nthe modelbypresenting alinearfunction thatis not First, we introduce some abbreviations that are useful \nin or\u00adder to simplify the rest of the paper. We use (MandN) to abbreviate (lif M (lif N 0 1)1). The equivalence \namong nu\u00ad . merals, denoted = used in in.x notation, is encoded as .....() \u00b5..x ..y .lif x (lify01) lify \n1 ((px)(py)). Moreover, we de.ne a family of diverging terms by induction on types, O. = p0 and, if s0 \n= \u00b51 . ... . \u00b5m . . for some m . . s0...sn. then Ois s0 sn ts1 sn \u00b51 \u00b51 \u00b5m ) .x0 ... xn .lif(Ox1 ... \nxn )(x0O... O\u00b5m )(x0O... O s1...sn.s1 sn s1 sn Clearly,OM1 ... Mn .for each M1 ,..., Mn . We cande.ne \nan encoding .-. : |[s]|.. from tokens ofthe coherence space [s] to natural numbers as: .n. = n ifs = \n.;  .(a1,a2). = ..a1.,.a2..ifs = t1 . t2.  Itprovides an enumeration ofthetokens ofour model.Remarkthat \nthe Theorem 2 implies that there is a family of terms Sgln s : s (short for singleton) being an enumeration \nof terms that can be interpreted on(single) tokens.Concretely, wede.ne Sgln s : s by (s) mutualinduction \nwithterms Chkn : s . .that checks whether a tokenisincludedin the operationalbehavior of a term typed \ns. s (s) De.nition11. ThetermsSgln : sand Chkn : s . .arede.ned by mutualinduction on s. . (.) . . If \ns = ., Sgln = n and Chkn = .y ..lif (n = y)0O. If s = s1 . s2, let s2 = t1 . ... . tk . . for some k, \nwithoutloss ofgenerality, then Sgln s is s1.g t1 tk (s1) s2 s2 .f....g .lif(Chkf)(Sglg1 ... gk)(Og1 \n... gk) 1k p1(n)p2(n) (s) s(s2)(s1) . and Chkn is .f.lif (Chk(fSgl))0O. p2(n)p1(n) In Chkn (s) we use \n(s)as a short for s . .. As an instance, if n = .n1,n2. then the term Sgln .. is operationally equivalent \n.. . (..) to the term .x .lif (x = n1)n2 O, while the term Chkn is . operationally equivalent to the \nterm .f..lif (fn1 = n2)0O. . Lemma4. Let us .x a type s.If a .|[s]|and n = .a., then: 1. [Sgln (s)]. \n= {a},for all .; 2. if [Chkn (s) N]. = [0].then a . [N].,for all ..  4.2 Fix-pointoperational equivalence \nIn order to simplify the reasoning about programs, we introduce a non-standard notion of operational \nequivalence. De.nition 12. Let assume Ms ,Ns be terms of SlPCF, such that s1 sn SFV(M),SFV(N).{1 ,..., \nn }. s1 sn M .s N whenever, for all P1 ,... Pn , for all C[s] s.t. C[M[P1/1,..., Pn/n]],C[N[P1/1,..., \nPn/n]]. P if C[M[P1/1,..., Pn/n]]. n . C[N[P1/1,..., Pn/n]]. n.  M ~s N if and onlyif M .s N and N .s \nM  It is easy to verify that .s is a preorder and ~s is an equiva\u00adlence. Note that the comparison between \nthe .x-point operational equivalence andthe standard oneis notimmediate.Indeed,proving that the two coincide \ncorresponds to prove that ~s is also a con\u00adgruence. For instance, let us assume that both M. ,N. containjust \nonefree variable s.If M ~s N thenitis not easy tobuild contexts C[s]and \u00b5.C ' [s](dependingfrom the common \nsubstitution to ) such that C[\u00b5.C ' [M]].and C[\u00b5.C ' [N]].,i.e. M s N.  The standard interpretation \nis correct with respect to the .x\u00adpointoperational equivalence too. Proposition1. Let Ms ,Ns . SlPCF. \n[M] = [N] . M ~s N. For clarity, we anticipate that the .x-pointequivalence coincide with the standard \ncontextual equivalence(seeSection7).  4.3 FullAbstractionCounterexample 2 We use the second-order gustave-or \noperator Gor:(. . .) . (. . .). (. . .). .,introducedin[30],and equipped with thefollowingevaluation. \nP00 . 0 P11 . 0 P20 . 1 P00 . 1 P10 . 0 P21 . 0   (G0) (G1) G2L G2L or P0P1P2 . 0 or P0P1P2 . 1 P01 \n. 0 P10 . 1 P20 . 0 P01 . 1 P11 . 1 P21 . 1   (G2) (G3) L L G2 G2 or P0P1P2 . 2 or P0P1P2 . 3 2 \n The operatorGor, non-deterministicallyprovidesinputs toitsthree branches anditlooksfortheir outputs(ex-ante,itis \nnotpossible to choose inputs). As soon as the evaluation terminates by using a rule, the other rules \ncannot terminate anywise, i.e. ex-post the evaluationdetermines a unique rule whichconverges.The operator \n2 Gor is the operational counterpart of thefollowingclique . .. ( (0,0), (1,0), (0,1), 0)  . .. each \nsubterm lif P M0 M1 of M is replaced by, either (.z . .M0)P or (.z . .M1)P where z is afresh variable; \n each subterm letf1 = N1,...,fk = Nk inlor M1 M2 M3 is replaced by, (.f1 ... fk.Mi)N1 ... Nk where 1 \n= i = 3.  Morally, a slice of a term chooses one branch of each lif and one branch of let-lor. Indeed, \na slice contains neither lif nor let-lor. It is easy to verify that each linear variable fst occurs in \na slice ofaterm M at most once.This saysthat SlPCF. is syntac\u00adtically linear by slices. However, as expected, \na term containing n lifandmlet-lor has2n3m slices whichcan eventuallycoincide. In order to deal with \nthe let-lor operator without violating the semantic linearity we need a careful evaluation of terms, \nthis s (s) is described using the terms Sgln and Chkn introduced in the previous section. De.nition 15. \nThe evaluation relation .. P \u00d7N for SlPCF. programs is the smallest relation satisfying the rules in \nTable 1.b extended by the rulesinTable2.b. The evaluation rules for let-lor are patterns for in.nite \nrules, likewise the rule for which? (see previous sections) and for . in [33]. The evaluation of thelet-lor \noperator is obtained by three distinct rules that explore pairwisely the let-lor branches. The evaluation \nof a let-lor can beperformed only in the case two be\u00adtween M1,M2 and M3 evaluate to the values 0 and \nm + 1 respectively ( (0,1), (0,0), (1,0), 1) by using a single tuple(i.e., atoken)of thetracesinthe \nlet-lor\u00ad (3) g = ( (1,0), (0,1), (0,0), 2) ( (1,1), (1,1), (1,1), 3) argument Ni,for i = k.Forinstance,the \n(1lgor)canbe appliedin .... the case M1[N1/f1,...,Nk/fk]. 0 and M2[N1/f1,...,Nk/fk]. sm and the same \nsingle information of each Nj coded on numerals nj is usedinboth evaluations.The check ofthis constraintsis \nthe mo- Thefollowingresulthasbeenprovedin[30]. 2 s (s) Theorem4. Gor is not SlPCF-de.nable tivation \nfor introducing the terms Sgln and Chkn above. Albeit ex-ante we don t know what is the right pair of \nlet-lor branches Basedonthe statement above, we canbuildthedesiredcounter\u00adto evaluate,theyare establishedduringthe \ncourse ofthe evaluation, example. Here we make use of .x-point operational equivalence. so ex-post only \none ofthe three rules can converge. Theinterpreta\u00ad O..O..O.. LetM = and tion of the let-lor operatorfollows \ntheseideas. . . . ...... (Sgl.0,0.)(Sgl.1,0.)(Sgl.0,1.)= 0 and De.nition 16. Let Ms ,Ns . SlPCF. and \n. . Env. The linear . ...... (Sgl.0,1.)(Sgl.0,0.)(Sgl.1,0.)= 1 and ... ... . interpretation [Ms] : \nEnv .Cl([s])is de.ned by the equations N = lif 7 O . ...... (Sgl.1,0.)(Sgl.0,1.)(Sgl.0,0.)= 2 and inTable1.c \nextendedbythe onesfor the let-lor operatorinTable . ...... (Sgl)(Sgl)(Sgl)= 3 .1,1..1,1..1,1. 2.c. \nbe SlPCF terms such that (..)(..)(..). . M,N : .. It is easy to see that [M]. = [N]., by taking .()= \ng as de.ned in Equation 3. Instead, M ~. N since to separate the two terms a 2 term behaving like Gor \nis necessary. However, such a term is not de.nableinSlPCFas shownbyTheorem4.  5. Theextendedlanguage \nTorecovertheproblempresentedintheprevious section, SlPCF. extends the SlPCFlanguage bymeans ofa new let-lor \noperator. De.nition13. TheSlPCF. pre-termsarede.nedbyextendingthe grammar ofpre-terms asfollows: s1t1 \nsktk M ::= \u00b7 \u00b7 \u00b7| letf1 = M,...,fk = Minlor MMM The terms of SlPCF. are the pre-terms typable by using \nthe type systeminTable1.a extended by the rulesinTable2.a. The let-lor generalizes the behavior of the \nG2 or operator pre\u00adsented in the previous section by forcing a linear evaluation. It is worth noticing \nthat the contexts of the terms Mi in the (let-lor) rule are managedin an additive way, contractingcommon(ground, \nlinear and stable)variables.However, note that a let-lor binds all the linear variables in its three \nbranches. So, a form of syntactic linearity(by slice [19])forlinear variablesispreserved. De.nition14. \nA slice of a term M is a new term where: Itis notdif.cultto seethatthe correctness w.r.t.thelinear model \n(Theorem1)stillholdsfor SlPCF.. 5.1 SlPCF. program examples We show how to use the let-lor operator \nin order to program in 2 SlPCF. the operator Gor presented in Section 4. This should so suggesthow to \nrecover the counterexample tofullabstraction. Infact, we show something more.Wedescribehow toprogram \n2 afamily of terms Gor L thatgeneralize the behavior of the operator 22 Gor. The terms Gor L, are parametrized \nover an ordered list L of four numerals k0,k1,k2,k3 representing the output returned in the case the \nassumptions of one of the rule (G0), (G1), (G2) or 22 (G3)respectively, are satis.ed. So, in particular \nGor L =Gor when L = {0,1,2,3}is considered. In order to proceed in a modular way, we introduce also a \nnotation in order to consider restrictions 2 of Gor L which use only a subset of the four rules. Precisely, \na in the list L is used to denote the operator obtained omitting the 2 L0 corresponding rules. For \ninstance, Gor where L0 = 0,2, , is de.ned as .f..f..f.. . (123 . (.. )) .w.lif w = 0lif (f21 = 0 and \nf30 = 1) 0O. (. .. ) (f10) lif w = 1(lif (f20 = 0 and f31 = 0) 2O. ) O. 2 Allthe Gor L de.nedbyjust \ntwo rules,i.e.forL containing two oc\u00ad2 L1 currences of , canbede.nedlikewise.Thus, Gor withparameter \n s1 sk Gn.= \u00d8 ..l = f1 ,..., fk G1 . N1 : s1 ... Gk . Nk : sk . . Mi : .(1=i=3) (let-lor) ..S,...,G1,..., \nGk . let f1 = N1,..., fk = Nk inlor M1 M2 M3 : . s1 sk s1 sk (sk) n1nk n1nk nj M1[Sgl/f1,..., Sgl/fk]. \n0M2[Sgl/f1,..., Sgl/fk]. sm ChkNj . 0 (j.{1,...,k}) (1lgor) s1 sk let f1 = N1,..., fk = Nk inlor M1 \nM2 M3 . m s1 sk s1 sk (sk) M2[Sgl/f1,..., Sgl/fk]. 0M3[Sgl/f1,..., Sgl/fk]. sm ChkNj . 0 (j.{1,...,k}) \nn1nk n1nk nj (2lgor) s1 sk let f1 = N1,..., fk = Nk inlor M1 M2 M3 . m s1 sk s1 sk (sk) M3[Sgl/f1,..., \nSgl/fk]. 0M1[Sgl/f1,..., Sgl/fk]. sm ChkNj . 0 (j.{1,...,k}) n1nk n1nk nj (3lgor) s1 sk let f1 = N1,..., \nfk = Nk inlor M1 M2 M3 . m Table2. (a)Type system,(b)operational semantics and(c)linearinterpretationfor \nthe let-lor operator. {}{} -- . [M3].[Ff := F [N]. --. [M1].[Ff := F {0}. {0}. a]a] = = [letFf = FNinlor \nM1 M2 M3]. n . .Fa . . n . .Fa . [N]. = . .  [M1].[Ff := F[M2].[Ff := F {n +1}{n +1} a]a] = = {} \n--. [M2].[Ff := Fa]= {0}. [N]. . n . .Fa . .  [M3].[Ff := Fa]= {n +1} L1 = 1, ,0,0 canbede.ned using \nthe let-lor operator as .f1f2f3.let g1 = f1, g2 = f2, g3 = f3 inlor 0, ,1, 2, , ,0 , ,0,1 (G2 or g1g2g3)(G2 \ng1g2g3)(G2 or or g1g2g3)  2 L2 and Gor withparameter L2 = ,0,3,4 canbede.ned as .f1f2f3.let g1 = f1, \ng2 = f2, g3 = f3 inlor ,0,4, ,1, ,0 , ,0,5 (G2 or g1g2g3)(G2 g1g2g3)(G2 or or g1g2g3)  2 L3 Finally, \nGor withparameter L3 = 0,1,2,3 canbede.ned as .f..f..f.. l.et g1 = f1, g2 = f2, g3 = f3 123 L0 L1 L2 \n inlor(Gor 2 g1g2g3)(G2 g1g2g3)(G2 g1g2g3) or or 2 For every parameter L, all the Gor L can be built \nanalogously. As expected, the let-lor operator is fundamental for the above con\u00adstruction. We give here \nalso a .avor on how to use the which? operator to de.ne programming constructs useful to collect run-time \ninformation. These programming constructs (called @wh?st ) are a generalization of the operators introduced \nin [30, Sec\u00adtion 3.1] and will be used in the next Section to prove the Finite De.nability Theorem 6. \nLet us introduce the operators @wh?st :(s . t) . s . t, with the following operational semantics: st(s)(s) \n(MSglm )P1 ... Pk . n Chkm N . 0 sts (@wh?st MN)P1 ... Pk ..n,m. Observe that (@wh? MN)P1 ... Pk . if \nand only if MNP1 ... Pk .. This control operator gives back the result n of the evaluation of MN P1 ... \nPk together with the numeral m encoding the part of the trace of Nusedforthe evaluation.Thisinformation \nwillbe essential in theproof of theFiniteDe.nabilityTheorem6. @wh? canbeprogrammed in SlPCF. using which?. \nTheorem5. @wh?st is SlPCF. programmable. Proof. The proof is by structural induction on s. The base case \nis simple observing that the term .t.t1 tk .. .f.x .g1 ,..., gk . which?(.h.f(hx)g1 ... gk) behaves as \n@wh?.t, with t = t1 . ... . tk . .. The inductive case is a bit more complicated. The idea is to generalize \nthe behavior of the term above where the variable h acts like an observer which retrieves the used trace. \n  6. FiniteDe.nability andFullAbstraction In this section we prove that the linear model L is fully \nabstract with respect to SlPCF.. This result relies on the completeness of the linear interpretation \nwith respect to the operational semantics and on the de.nability of allthe .nitecliquesby meansof SlPCF. \nterms. In particular, we prove the completeness with respect to theFix-Point equivalence. In the next \nsection(Proposition2 and Theorem 8) we then prove that the Fix-Point and the Standard operational equivalences \ncoincide.From this,full abstractionholds also with respect to thelatter. Finite de.nability asserts that \nall .nite cliques can be de.ned by means of SlPCF. terms. Our proof follows a standard scheme forproofs \nofthiskind, e.g.[33],[29].Non trivial uses of @wh? and let-lor constructors are needed in theinductivehigh-order \nsteps. De.nition 17. Let u be a .nite clique of a coherence space in L. A term M de.nes u if and only \nif [M] = u. The class of closed terms having u as interpretation is denoted by .u. 1, hence .u. = {M \n| [M] = u}. By abuse of notation, in the following wedenote .x.a term M such that M = .x.. Toprovede.nability, \nwe use thefollowing auxiliarylemma. Lemma 5. Let (a0,...,an,a),(b0,...,bn,b) .|[t0 . \u00b7\u00b7\u00b7 . tn . .]|.Then: \n1. (a0,...,an,a). (b0,...,bn,b)iff.k = n: ak . bk. 2. (a0,...,an,a)\u00b0 (b0,...,bn,b)iff.k = n: ak \u00a8 bk. \n Some measures are needed in the next theorem: the cardinality of a clique u isdenotedIuI;the RK of \natypeisinductivelyde.ned as: RK(.)=1; RK(s . t)= RK(s)+RK(t). Theorem 6 (Finite De.nability). If u .Clfin([s]) \nthen there exists a closed M . SlPCF. such that M = .u.. Proof. Let s = t1 . \u00b7\u00b7\u00b7 . tk . . for some k \n= 0. The proof is by induction on the triple (RK(s), k, IuI)ordered in a lexicographic way. Consider \nRK(s) =1, then s = . and [s] = N. Thus, O. and numerals de.ne all possible .nite cliques, since Clfin(N)= \n{\u00d8}.{{n}/n.|.|}. 11 1Ingeneral, weuse .a,...,ak. as an abbreviation for .{a,...,ak}..  Consider RK(s)=2, \nthen s = . . .. them.Thusthetermde.ning u is thefollowing -IfIuI =0then u = \u00d8isde.nedbyO.. . ' -If IuI= \n1, then u = u .{(a,b)} for a,b . By .. induction hypothesis wehave .u ' .,hence .u. = .z.lif (z = \u00b7 .a.).b. \n(.u ' .z). Consider RK(s) = 3 and k =1, then s = t . . with t = s1 . \u00b7\u00b7\u00b7 sr . .. -IfIuI =0then u = \u00d8isde.nedbyOt. \n. -IfIuI =1, then u = {(a,b)}for a . [t] and b . ..Suppose a =(a1,...,ar,c)where ai . [si] and c . . \n(1= i = r). By induction hypothesis we have .a1.,...,.ar.,.c. and .b., hence: .u. = .f.lif (f.a1.\u00b7 \u00b7 \n\u00b7.ar. = \u00b7 .c.).b. O. . -If IuI > 1, then u = {(a 0,b0),...,(a m,bm)}for a i . [t] ii ii and bi . . (0 \n= i = m). Suppose a =(a1,...,ar,c ) where aji . [sj] and c i . . (1= j = r).ByLemma5.1, we hk hk have \na .a (0= h = k = m), sobyLemma5.2 a .a j . j (1= j = r).Hence, take vj = {a ij |1 = i = m}.Moreover, \nfor sake of simplicity, we writejust aji inplace of aji ,i.e. the natural number encoding aji . Byinductionhypothesis \nwehave .vj., .c i.for every 0 = i = m, 1 = j= r and 1 = k = s.So, we cande.ne: ( .u. = .F t ..z i . \n\u00b7 0 \u00b7 0 \u00b7 00 lif (p r 1(z)= c andp r1 -1(p 2(z))= a1 ... p 2(z)= ar)b \u00b7 1 \u00b7 1 \u00b7 11 lif (p r 1(z)= c andp \nr1 -1(p 2(z))= a1 ... p 2(z)= ar)b . . . \u00b7 m \u00b7 m \u00b7 m m lif (p r 1(z)= c andp r1 -1(p 2(z))= a1 ... p \n2(z)= ar)b )(sr s1 ) )\u00b7\u00b7\u00b7 @wh?. (... (@wh?s2\u00b7\u00b7\u00b7sr.(F)(.v1.))...)(.vr.) Consider RK(s)= 3and k> 1. t1 \n\u00b7\u00b7\u00b7tk. -IfIuI =0, then u = \u00d8isde.nedbyO. -If IuI =1, then u = {(a1,...ak,b)} where ai . [ti] (1= i = \nk)and b . ..Thus, .u. = .f1 ... fk. (s1)(sk) . lif ((Chkf1)and\u00b7\u00b7\u00b7 and (Chkfk)).b. O a1 ak 11 22 -if \nIuI =2 then u = {(a1,...,ak,b1),(a1,...,ak,b2)}. We know that there is i . [1,k]such that a 1 i . ai2 \n. If ti = . then a11 and ai 2 are two different numbers: thus the term de.ning u is thefollowing ( . \n1(s1) .u. = .f1.... fk.lif(fi = .ai.)lif(Chk1 f1)and\u00b7\u00b7\u00b7 a 1 (sk)1)((. 2 and (Chka1 fk).b.Olif(fi = \n.ai.)and k (s1)(s1) )2) (Chka2 f1)and\u00b7\u00b7\u00b7 and ((Chka2 fk).b.O1k If t = .1 . ....l . . then we have that \nai 1 = 111222212 (e1,...,el ,c )and a =(e1,...,el ,c ).Since ai . ai , we i have thatfor all j. [1,l]the \nsets {ej1 ,ej2}are cliques oflower rank. Thus by inductive hypothesis we have terms Nj de.ning (( .. \n1 . 1 .u. = .f1.... fk..x .lifp 1l x = c andp l1 -1(p 2x)= e1 . 1 )(((t1) and...p 2x = el lifChk1 f1 \nand ... a 1 (ti-1)(ti+1)(tk) )1)Chk1 fi-1 and Chk1 fi+1 and ... Chk1 fk.b .O aa a i-1i+1k ((l . 2 \nl-1 . 2 . 2 lifp 1x = c andp 1 (p 2x)= e1 and...p 2x = el and (t1)(ti-1) Chk2 f1 and ... Chk2 fi-1 and \naa 1i-1 (ti+1)(tk) )2)Chk2 fi+1 and... Chk2 fk.b .O aa i+1k )() .l .1 @wh?. (... (@wh?.2....l.(fi)(N1))...)Nl \n-If IuI > 2, then u = {d1 ,...,dm} where dj = jjj (a1,...,ak,bj), ai . [ti] and bj . . (1= j = m, 1 = \ni = k). We denote by dj[b]the token (aj 1,...,ajk,b). By Lemma 5.1 there exists 1 = h = k such that ah \n1 .ah2 , so we canbuild thefollowing.nitecliques: w1 = {d1[0],d2[b2 +1]} w2 = {d1[b1 +1]}.{dr[0]|2 <r \n= m } w3 = {d2[0]}.{dr[br +1]|2 <r = m } Note that IwsI < IuI for s =1,2,3. So, by induction hypothesis \nwehave .w1.,.w2.and .w3..Hence: .u. = .f1 ... fk.letg1 = f1,...,gk = fk ()()() inlor .w1.g1 \u00b7\u00b7\u00b7 gk.w2.g1 \n\u00b7\u00b7\u00b7 gk.w3.g1 \u00b7\u00b7\u00b7 gk and this concludes theproof. Thede.nability of .nitecliquesisthekey ingredienttoextend \nthe Stable Closed Completeness Theorem 3 to all the terms of SlPCF. asfollows. s . Theorem7 (Completeness). \nLet Ms ,NSlPCF.. M ~s N . [M] = [N] t1 tn Proof. Let G . M,N : s with G.S = {1 ,...,n } and G.l,G.. = \n{x1 s1 ,...,xm sm }. Assume [M] = [N], then there exists . such that [M]. = [N].. By the Sepa\u00adrability \nLemma 3, there exists a closed term Ps. such that F([P])([M].)= F([P])([N].). By the Finite De.nability \nThe\u00adorem 6, for all i in G.S there is a term Pi = ..(i). and for all xi in G.l,G.. there is a term Ni \n= ..(xi).. So, we s1 sm s can build C = P(.x1 ... xm .[\u00b7 ]N1 \u00b7\u00b7\u00b7 Nm). Without loss of generality, let \nus assume F([P])([M].)= {k}. By adequacy C[M[P1/1,...,Pn/n]] . k but C[N[P1/1,...,Pn/n]] . k. This concludes \ntheproof. Bysoundness and completeness thefull abstractionfollows. s . Corollary2 (FullAbstraction). \nLet Ms ,NSlPCF.. M ~s N .. [M] = [N]  7. Coincidence of operational equivalences In this section we \nprove the coincidence between the standard operationalequivalence(De.nition9)andthe .x-point operational \nequivalence (De.nition 12). Therefore, the full abstraction holds also for the standard operational equivalence \nand a compositional theoryofprogram equivalence canbe effectivelyde.ned.  The .x-pointequivalence coincides \nwiththedenotational equiv\u00adalence by Corollary 2. The proof follows of the next proposition directly by \nthe correctness of the denotational semantics w.r.t the standard operational equivalence. s . Proposition2. \nLet Ms ,NSlPCF.. M ~s N . M s N. The opposite direction is more dif.cult and it requires a se\u00admantic \nreasoning.First,weprove an auxiliary resultclaiming that in a coherence space X .L (i.e in our type structure) \ndifferent from N, .nite cliques are never maximal w.r.t. set-theoretical in\u00adclusion(Corollary3)2.Then, \nwe usethisfact,together withAde\u00adquacy(Theorem1) andFiniteDe.nability(Theorem6) toprove the resultin theground \ncase(Lemma8), whichimplies thegeneral result(Theorem8). Thefactthat .nitecliquesinacoherencespaceX .Ldifferent \nfrom N are never maximal w.r.t. set-theoretical inclusion follows from the nextlemmas. Lemma 6. 1. Letx \nbeanon-empty.nitesetoftokensin |[s]|s.t. .a . x.b . x.a \u00b0 b.Then .a ' . x.b . x.a ' . b. 2. Let x be \na non-empty .nite set of tokens in |[s]|(s = .)s.t. .a . x.b . x.a \u00a8 b.Then .a ' . x..b . x.a . b. Corollary \n3. Let x .Clfin([s]), with s = .. Then there is a .|[s]|such that a . x and x .{a}.Cl([s]). Given an \nenvironment ., a term M, a stable variable s and an in.nite clique x .Cl([s]), with a slight abuse of \nnotation in the sequel we write [M].[. := x]to denote [M].[. := y]. y.finx The next auxiliarylemma willbe \nusefulin whatfollows. st st Lemma 7. Let M,N. SlPCF. and . . Env. If M[N/] . st t SlPCF., then [M[N/]]. \n= [M].[:= x] x.fin[N]. Now, we show that by using .xpoints it is possible to build contexts that allow \nus to discriminate as much as we can do by using substitutions. Lemma 8. If G . M,N : .with G.l = \u00d8. \nM . N . M ~. N. s1 sn Proof. We prove the contrapositive. Let 1 ,..., n be such that SFV(M),SFV(N).{1,..., \nn}.Let C[\u00b7 .]be a context and FP be closed terms such that C[M[F]]. P/F P/Fn and C[N[F]]. n.We ' '' prove \nby induction on n that there is a C such that C [M]. n and C ' [M]. n ' . Base case. Since n =0 the two \nterms have no free occurrence of stable variables, thus we can take C ' = C. Inductive case. The .x-point \n(in)equivalence implies that there is a context C[. .] and there are closed terms s s1 n+1 P1,..., Pn+1, \nsuch that C[M[P1/1 ,..., Pn+1/. n+1 ]] . k s s1 n+1 but C[N[P1/1 ,..., Pn+1/. n+1 ]] . k. Thus, by Correctness, \nthere exists a .such that s1 n+1 [M].[. := [P1].,. . ., . s:= [Pn+1].]= 1 n+1 s1 n+1 [N].[. := [P1].,. \n. ., . s:= [Pn+1].] 1 n+1 s1 sn In the following, we de.ne .1 = .[1 := [P1].,. . ., n := n+1 [Pn].]. \nLet us observe that both [M].1[. s:= [Pn+1].] and n+1 [N].1[. sn+1 := [Pn+1].]are .nitesets(inparticular,theyhaveat \nn+1 most one element and they cannot be both empty). Thus, without loss of generality, we assume that \n[M].1[. sn+1 := [Pn+1].]= n+1 2Observe that this fact is not true in the general case of stable functions: \nfor example in the coherence space !N . N, the .nite clique {(\u00d8, 0)} is maximal. {k}.SobyLemma7 there \nexists x .fin [Pn+1].such that [M].1[n+1 := [Pn+1].]= [M].1[n+1 := x]= [N].1[n+1 := x]. [N].1[n+1 := \n[Pn+1].] Since stable variables are never of ground type, we can let sn+1 = t1 . ... . tm . . and m = \n1. Let x = 11 p i {(a1,...,a m,h1),..., (a1p ,...,am,hp)}with p = 0 and a1 . |[t1]|,...,a i .|[tm]|,hi \n. . for all i . [1,p]. Furthermore, m by Corollary 3 there is a token (a1* ,...,a * ,h * ) . x such that \nm * ** x = x.{(a1,...,a m,h * )}is stilla clique.Observe thatitis not restrictiveto assume h * .{h1,...,hp}, \nsince changing of outputs preserves the coherence oftokens.ByFiniteDe.nability,thereis a term P de.ning \nthe clique x * .Now,let us consider the context ( t1 tm . D = \u00b5n+1..f1 ... fm ..x . . lif (x = h * )[\u00b7 \n.] . lif (x = h1) h1 . . . )() . lif (x = hp) hp O.Pf1 ... fm Observe that D[M],D[N] . SlPCF. because \nwe hypothe\u00adsized that M,N have no free occurrences of linear variables. If q1 = a1 * ,...,qm = am * , \nit is not dif.cult to see that (t1)(tm) [D[M]Sglq1 ... Sglqm ].1 = [M].1[n+1 := [Pn+1].]= {k} (t1)(tm) \nand [D[N] Sglq1 ... Sglqm ].1 . [N].1[n+1 := [Pn+1].] whichis either empty oritis a singleton {k ' }differentfrom \nk. By Lemma 7, adequacy and de.nition of .x-point equivalence we (t1)(tm)(t1)(tm) have D[M]Sglq1 ... \nSglqm ~. D[N]Sglq1 ... Sglqm .Thus, we can applyinductivehypothesis(since the number offree stable variableshasdecreased), \nto conclude theproof. The abovelemma canbe used toprove thegeneral case. s . Theorem8. Let Ms ,NSlPCF.. \nM s N . M ~s N. s1 sn Proof. We prove the contrapositive statement. Let 1 ,..., n be suchthatSFV(M),SFV(N).{1,..., \nn}.Let Cbe a context and FP be closed terms such that C[M[F]]n and C[N[F]] P/F. P/F . n for some numeral \nn. In particular, observe that C[M] ~. C[N], by de.nition ofFix-PointOperationalEquivalence.Moreover,bycon\u00adstruction \nC[M]and C[N]have no free occurrence of linear variables. Thus, by Lemma 8 there is a context D such that \nD[C[M]] . m and D[C[M]]. m.So, theproofisdone. Corollary4. The equivalence ~s is a congruence. 7.1 ApplicativeOperationalEquivalence \nWe conclude the section by de.ning an applicative operational equivalence obtainedby considering only \nspecialkinds of contexts (ApplicativeContexts)to test the equality of terms. s . s1 sn De.nition18(ApplicativeOperationalEquivalence). \nLetMs ,N SlPCF. such that SFV(M),SFV(N).{1 ,..., n }. M s A N whenever,for all context C of theform (.Ff.[\u00b7 \ns])P1 ... Pm and for all closed terms L1 s1 ,..., Ln L/F. n then s1 , if C[M[F]] C[N[FL/F ]]. n M ~A \ns N iffM s A N and N s A M. Theorem9. Let Ms ,Ns . SlPCF.. M ~A s N . [M] = [N]. Proof. Just by observing \nthat the context used in the proof of Theorem7is an applicative context. The applicative equivalence \nstill coincides with the previous ones, soitprovides a convenient toolfor reasoning onprograms.  s . \nCorollary 5 (EquivalencesCoincidence). Let Ms ,NSlPCF.. M ~s N .. M s N .. M ~A s N   8. ATracingEvaluationSemantics \nThe operational semantics of SlPCF. presented in the previous sections is effective, but quite inef.cient. \nIndeed, the rules for which? and let-lor non-deterministically face a potentially in.\u00adnite number of \nevaluation branches. Consequently, its bovine im\u00adplementation should try an exhaustive search of the \nright branch amongthein.niteones.Inthis section, weintroduce a tracing eval\u00aduation semantics which is \nable to drastically prune such in.nite\u00adbranching search tree. Roughly, denotational linearityprovides \nthe certainty that each termis appliedto a unique sequence of arguments.Thatis, only one token ofthe \ncorresponding trace is used.So, an ef.cientevaluation can be obtained by storing an argument N in an \nenvironment e , and when the evaluation of N is done, by replacing the term in the environmentbyitstrace.This \nway of evaluatingprogramsis akind ofhigher-order call-by-need evaluation where the trace of the term \nis stored instead of the value. In order to simplify the evaluation of the new operators, we record such \nsequence-information along theevaluationtree.Theideais torecursively trace thearguments supplied tofunctions.Theso-obtainedpruned \nsearch-treeis .nite\u00adbranching anditinduces a clever and more ef.cient evaluation. Akey role in order \nto trace all theinformation isplayed by the environment. De.nition19. An environment e is a function \nfrom a .nite set of variables(ground orlinear) to either aterm(named subject)or a numeral(named trace). \nLet x s be a variable in the domain of e . If s = . then e (x) is always the trace. If s is an arrow \nthen either e (x)is a term typed s (the subject)oritis the trace typed .. We note e [z :=M]the new environment \ne ' such that e ' (z)= M and e ' (y)= e (y), for each y = z. Last, we note e .{x} the restricted environment \nobtained bydeleting the variable x. Note that, the environments associate terms to type union, i.e. a \nvariable could refer either to a term or to a numeral(encoding thetrace).Moreover,inthecaseof aground \nvariable wejust need to store a numeral because of the call-by-value policy that makes subjects and traces \ncoincide. The use ofan environmentto manage substitutions andthepres\u00adence of a recursion operator raise \nthe issue of clashes between variable-names. For sake of simplicity, we do not introduce clo\u00adsures. We \novercame clashes by assuming a whole bunch of fresh variables and by doing the appropriate renaming at \nrun-time in the reduction rules. Another reason for following that approach is thatfresh variables are \nanyway necessary to trace the evaluation of We note . the empty environment, so if M is a ground closed \nterm then we can obtainits evaluation,by supplying the state (M|.) to the tracing machine. De.nition \n20. The tracing evaluation .T is the effective relation from states(ground termsin environments) to states(numeralsin \nenvironments) de.ned by the rules of Table 3. If (M|.).T (n|e1) then we say that M converges, and we \nwrite simply M .T, otherwise we say thatit diverges, and we write M .T. We emphasize that allthe statesin \nrules of table3 aredrivenby thehead of aground term.In order tofacilitate the comprehension of the tracing \nmachine we have devised its rules in two parts. The rulesinthehigherPart(a) takeintoaccount allpossible \nshapes of thehead of terms, except the case of ahead variable thatis tackled by the rulesin thelowerPart(b). \nThe rules in the higher part are quite easy to understand, so we comment only the rules involving non-standard \noperators. The rule (w)extends the incoming environment e0 by a fresh variable h associated to the term \nM that we plan to trace, and evaluates h applied to the identity I = .x.x (recall that if which?(M) converges, \nby rules in the Table 1.c, then MI also converges). The result of this evaluation gives back a state \n(n|e1)where e1 reports the observed trace of M. From this, the result is built. Likewise, the three let-lor \nrules start by evaluating a branch. If such a branch converges, the reported traces are used in order \nto start the evaluation of the other branch. In this case we supply as subjects of theinvolved variables \ntermshaving(exactly) thebehavior of the reported trace(recall theLemma4).Therefore, a rule converges \nonly in case the two branches do the same observations on the list of arguments supplied to alinear variable. \nThe lower part of Table 3 is a bit more complex. All the rules fetch head-variables, so the discriminating \nfactor that drives their behavior is found in the shape of the subject associated in the environment \ntothehead variableitself.Indeed,itis easy to see that there is one rule for all possible shape of the \nhead-subject . We remark that let-lor isnottakenintoaccount, sinceatermhaving a let-lor as head is certainly \ntyped ground and ground terms are evaluated before to be stored in the environment (because of the call-by-valuepolicy). \nThe rule (Hgvar) is easy.(Hvar) considersthe case wherethe subject associated to the head variable is \nanother variable-name, it forwardsthe evaluationbyusingthe subject.(Happ)is akey rule.It appliesinthecasethesubjectassociated \ntothehead variableisan application MN.Inthis case,it shifts Nintheterm ofthe statedriving the rules.Such \napproach allows us to collect suf.cientinformation to reportthe needed traces.The rules(Hs),(Hp)and(H\u00b5)arequite \nsimple. Likewise to the rule (w)presented above,the rule(Hw)is interesting: it uses the information collected \nby the fresh variable h to produce the right outcome and the trace of the which? itself (sinceitis a \nsubjectoftheincoming environment).Finally,the rules ....(H),(H. )consider the cases arising from which?arguments. \nAs expected, the rules of our machine will be driven by states (i.e.termin environment);they aredenotedby \n(M|e ).Given a state, the environment contains as usual the subterms tobe substituted to allthefreevariables \nand, sometimes, also some additional variables recording traces. Indeed, during the evaluation, sometimes \nan op\u00ad erational rule fetches anhead redexand extendstheenvironment with afresh variable associated to \na new subject.When arguments are supplied, the operational rules carefully substitute the subject bythe \nconvenient numeral encoding thetrace.Inthis way,if a vari\u00adable x contains atrace then,ithas recorded \nthe usedoneduring the evaluation of the subjectinitially associated to the variable x itself. For sake \nof clarity, we explicitly remove not used variables from environments.  ),(H.. )and(H.an head variable \nassociated to an abstraction in the environment. There are four rules depending from two types, i.e. \nthe type of the body of the abstraction and the type of the abstracted variable; mnemonically, the rule \ns names use as superscript the type of the variable and as subscript the type of the body. The rules \n(H...) ) need .rst to evaluate the ground argument in order ..and(H to comply the call-by-value policy. \nAll the rules compose the sub\u00adtracesinformationinthe rule-premisesto obtainthetracesthatthey mustprovidein \nthe rule-conclusion. We now prove that the trace evaluation machine is correct and complete with respect \nto the evaluation semantics presented in Table1andTable2.Itis easyto checkbyinductionthatthe rules of \nTable3preservethefollowingproperty:ifFV(M)= {1,..., n} for some n = 0 then such variables are in the \ndomain of e .  ' (M|e0).T (n|e1)(M|e0).T (s n|e1) f fresh, (M[f ' /f]P1 ... Pk|e0[f ' :=N]).T (n|e1) \n(0) (s) (p) st (.) (0|e ).T (0|e )(s M|e0).T (s n|e1)(p M|e0).T (n|e1)((.f.M)NP1 ... Pk|e0).T (n|e1.{f \n' }) (M|e0).T (0|e1)(L|e1).T (m|e2)(M|e0).T (sn|e1)(R|e1).T (m|e2)(M[\u00b5.M/]P1 ... Pk|e0).T (n|e1) (i.) \n(ifr) (\u00b5) (lif M L R|e0).T (m|e2)(lif M L R|e0).T (m|e2)((\u00b5.M)P1 ... Pk|e0).T (n|e1) ' '' x ' fresh, \n(N|e0).T (n ' |e1)(M[x /x]P1 ... Pk|e1[x :=n ]).T (n|e2) h(..). fresh, (hI|e0[h:=M]).T (n|e1) k = p1p1e1(h) \n(..)(w) ((.x . .M)NP1 ... Pk|e0).T (n|e2.{x ' })(which?M(..).|e0).T (.n,k.|e1.{h}) ''' ' (M1[f1/f1,..., \nfk/fk]|e0[f1 :=N1,..., fk :=Nk]).T (0|e1) ' '' s1 ' sk ' f fresh (1=i=k), (M2[f /f1,..., f /fk]|e1[f1 \n:=Sgl,..., fk :=Sgl]).T (sm|e2) i 1ke1(f ' )e1(f ' ) 1k (1lgor) s1 sk (let f1 = N1,..., fk = Nk inlor \nM1 M2 M3|e0).T (m|e2.{f ' ,...,f ' }) 1k  ''' ' (M2[f1/f1,..., fk/fk]|e0[f1 :=N1,..., fk :=Nk]).T (0|e1) \n' '' s1 ' sk ' f fresh (1=i=k), (M3[f /f1,..., f /fk]|e1[f1 :=Sgl,..., fk :=Sgl]).T (sm|e2) i 1ke1(f \n' )e1(f ' ) 1k (2lgor) s1 sk (let f1 = N1,..., fk = Nk inlor M1 M2 M3|e0).T (m|e2.{f ' ,...,f ' }) \n1k  ''' ' (M3[f1/f1,..., fk/fk]|e0[f1 :=N1,..., fk :=Nk]).T (0|e1) ' '' s1 ' sk ' fi fresh (1=i=k), \n(M1[f1/f1,..., fk/fk]|e1[f1 :=Sgl,..., fk :=Sgl]).T (sm|e2) e1(f ' )e1(f ' ) 1k (3lgor) s1 sk (let \nf1 = N1,..., fk = Nk inlor M1 M2 M3|e0).T (m|e2.{f ' ,...,f ' }) 1k  e (x)= n (hP1 ... Pk|e0.{f}).T \n(n|e1) h fresh , (hNP1 ... Pk|e0[h:=M].{f}).T (n|e1) (Hgvar) (Hvar) (Happ) (x .|e ).T (n|e )(fP1 ... \nPk|e0[f:=h]).T (n|e1[f:=e1(h)])(fP1 ... Pk|e0[f:=MstN]).T (n|e1[f:=(p2e1(h))].{h}) (M|e0.{f}).T (n|e1)(M|e0.{f}).T \n(s n|e1) (Hs) (Hp) .... (fM|e0[f:=s]).T (sn|e1[f:=.n,sn.])(fM|e0[f:=p]).T (n|e1[f:=.sn,n.]) (fP1 ... \nPk|e0[f:=(M[\u00b5.M/])]).T (n|e1) h fresh, (hI|e0[h:=M].{f}).T (n|e1) k = p1p1e1(h) (H\u00b5) (Hw) (fP1 ... Pk|e0[f:=(\u00b5.M)]).T \n(n|e1)(fM|e0[f:=which?]).T (.n,k.|e1[f:=...k,k.,n.,.n,k..].{h}) z fresh , h,z fresh , (P|e0.{f}).T (m|e1)(M[z/x]|e1[z \n:=m]).T (n|e2)(P1|e0.{f}).T (n|e1)(hP2 ... Pk|e1[z :=n,h:=M[z/x]]).T (n|e2) (H..) (H.. ) (fP|e0[f:=.x \n. .M.]).T (n|e2[f:=.m,n.].{z}) .(fP1 ... Pk|e0[f:=.x . .Mst]).T (n|e2[f:=.e2(z),e2(h).].{z,h}) '' ' g \n' fresh , (M[g /g]|e0[g :=P].{f}).T (n|e1) h,g fresh , (hP2 ... Pk|e1[g ' :=P1,h:=M[g ' /g]].{f}).T (n|e2) \n. . (H.) (H.) ' st.' . ss ' tt ' (fP|e0[f:=.g .M]).T (n|e1[f:=.e1(g ),n.].{g ' })(fP1 ... Pk|e0[f:=.g \n.M]).T (n|e2[f:=.e2(g ),e2(h).].{h,g ' }) Table3. TracingSemantics Note that e associates to a variable \n. a term N that can contain variables which are also in the domain of e . We show that we can avoid the \nuse of cyclic environments. Let e0 be an environment such that dom(e0)= {1,..., n}, let (M|e ) be a state, \nlet N be M[e (1)/1,..., e (n)/n]. We de.ne T to be the function from state to state, de.ned as follows: \nT((M|e ))= (N|e .{FV(N)}). We plan to transform a state (M|e ) in a closed ground term by iterating T \nuntil the environmentsbecomes(eventually) empty.If suchprocedureis terminating then the stateis said \nacyclic. Lemma9. The evaluation ofacyclic states only uses acyclic states. Proof. Since we add only fresh \nvariables to the environments and theenvironmentsisalways .nite. From now on, we consider only acyclic \nstates. Since (M|.)is trivially acyclic, we can de.ne T8((M|e ))to be the closed ground term obtainedbyiterating \nT untilthe environmentbecomes empty. Lemma 10. Let t = s1 . ... . sk . .. If (ftP1 ... Pk|e0).T (n|e1) \nthen Chk(t) (e0(f)) . 0 and e1(f)(Sgle1(f)P1 ... Pk|e0).T (n|e1.{f}) Proof. Easybyinduction on the tracing \nreduction rules. We can prove the trace evaluation machine to be correct and complete,by using thepreviouslemmas. \nTheorem10. Let T8((M|e0))= P. Correctness. If (M|e0).T (n|e1)then P . n. Completeness. If P . n then \n(M|e0).T (n|e1). -Part(a) andPart(b). Note that the tracing evaluation machineis a concreteimprove\u00adment \nwith respect to the evaluation machine presented in Table 1 andTable2,inthe sense thatitprunes thein.nitebranching \nsearch trees of the evaluation rulesfor which? and let-lor.So,it can be regarded as aguidelinefor a reasonableimplementation. \nExample Let us see the effectiveness of the tracing machine, by showing the evaluation of the term which?(.f.. \n.s(f3)). In the following, wedenote withe the environment .[f ' = I]. . . . (Hgvar) (3|e).T (3|e)(z|e[z \n= 3]).T (3|e[z = 3]) (H..) (f ' 3|e).T (3|.[f ' = .3,3.]) . (s) (s(f ' 3)|e).T (4|.[f ' = .3,3.]) (H.) \n(hI|.[h = .f.s(f3)]).T (3,.[h = ..3,3.,4.]) . (w) (which?(.f.. .s(f3))|.).T (.4,3.|.) Itcanbe notedherethatthe \nrules(H.. . )and(H...)are crucial to trace out the use of terms being substituted to the fresh head vari\u00adables \nh and f ' .The rule(H.. . )tracesthe term.f.s(f3)applied to I.The rule(H...)traces the term I applied \nto 3.  9. Related works The study of the relationsbetweenlanguages and modelsis a clas\u00adsicthemeindenotational \nsemantics[15,28].Thefull abstraction forPCFhasledtothedevelopment of very sophisticated semantics techniques \n(as [2, 23]) and revealed relevant programming prin\u00adciples and operational constructions. In particular, \nseveral works have studied how to extend PCF by different operators in order to achieve full abstraction \ncompared to some classical models. For example,this approachhasbeenfollowedbyPlotkin[33] forthe continuousScott \nmodel,byBerry andCurien[9]for the sequential algorithms model,byAbramsky andMcCusker[1] for aparticu\u00adlargame \nmodel,byLongley[26]for the strongly stable model and byPaolini[29] forthe stable model.Remarkthat allhigher-type \noperatorsintroducedinthe works above[9,26,29,33] cannotbe directly interpreted in the linear model. This \nmotivates our search for new operators.  Manylinearlanguages withdifferentgoalshavebeenproposed sofarin \ntheliterature.Recently,in the studies of syntacticallinear\u00adity, Alves et al. have proposed several syntactical \nlinear languages in order to characterize different classes of computable functions [3 5].Suchlanguages \nare syntacticallylinearbutdo nothave extra operators that arekeyingredients of SlPCF.. TwoPCF-likelanguages \nembeddinglinearitynotionshavebeen proposedin[10,11].Theselanguages are notdenotationallylinear, in the \nsense that not all their closed terms are in correspondence withlinearfunctions of a suitabledomain.Inparticular,they \ncannot beinterpretedinthelinear modelconsideredhere.Despitethisfact, the authors of[10,11]give someinteresting \nresults onthe relations between several forms of operational reasoning, in the context of the linear \ndecomposition. Our results on the coincidence of three operational equivalences can be viewed as further \ncontributions in those topics. 10. ConclusionsandFutureWorks The results presented in this paper are \npart of a wider project (startedwiththe works[17,30]) aiming to extend the expressive power oflinearprogramminglanguages.Our \naimisto studypartic\u00adular denotational models embedding a notion of linearity, in order to extract programming \nlanguages that are fully abstract or fully complete(universal) with respecttothe model, and thathave \nnew interestingoperationalfeatures.Our studyis also related tohigher\u00adtype computability[25,27], since \nthehigher-type of new operators arisingfrom these analysis. A .rst interesting direction is to extend \nthe results obtained in thispaperin ordertoprove the universality of SlPCF. with respect to the linear \nmodel, i.e. to .nd the language able to de.ne all the recursive cliques of the model. Another interesting \ndirectionis the study of SlPCF. semantics with respect to other model notions.In particular, we wouldpursue \nthe studystartedin[31] about a model forSlPCF. based onlinearprocesses.Moreover, we wouldpursue the study \nabout categorical modelsfor SlPCF. [18]. Last, weguess thatan even more ef.cient evaluation of SlPCF \nis possible. In particular, it would be interesting to study a new evaluation machine having an optimized \nmemory management. That is, an evaluation machine that does not need neither fresh variables nor closures \nand where the heap will be used only for trace out sub-programs.   References [1] S. Abramsky and G. \nMcCusker. Linearity, sharing and state: a fully abstract game semantics for idealized algol with active \nexpressions. ENTCS,3,1996. [2] S. Abramsky, P. Malacaria, and R. Jagadeesan. Full abstraction for PCF. \nI&#38;C,163(2):409 470, 2000. [3] S. Alves,M. Fern\u00b4andez,M.Florido,andI. Mackie. Thepowerof linear functions. \nIn LNCS 4207,pages119 134.2006. [4] S.Alves,M.Fern\u00b4andez,M.Florido, andI.Mackie. Linear recursive functions. \nIn LNCS 4600,pages182 195.2007. [5] S. Alves, M. Fernndez, M. Florido, and I. Mackie. Gdel s system t \nrevisited. TCS,411(11-13):1484 1500,2010. [6] R. Amadio and P. L. Curien. Domains and Lambda-Calculi \nCam\u00adbridge University Press,1998. [7] G.Berry.Stablemodelsoftyped .-calculi. In LNCS 62,pages72 89. 1978. \n[8] G.Berry. Mod`eles completement adequats et stabledulambda-calcul typ\u00b4e. PhDthesis, Universit\u00b4e deParisVII,France, \n1979. [9] G. Berry and P. L. Curien. Sequential algorithms on concrete data structures. TCS,20:265 321,1982. \n[10] G.M.Bierman. Programequivalenceinalinearfunctionallanguage. JFP,10(2):167 190, 2000. [11] G. M. \nBierman, A. M. Pitts, and C. V. Russo. Operational properties oflily, apolymorphiclinearlambda calculus \nwith recursion. ENTCS, 41(3), 2000. [12] A. Bucciarelli and T. Ehrhard. Sequentiality and strong stability. \nIn Proc. LICS 91,pages138 145,1991. [13] A.Bucciarelli andT.Ehrhard.Atheory of sequentiality. TCS,113(2): \n273 291, 7June1993. [14] A. Bucciarelli, A. Carraro, T. Ehrhard, and A. Salibra. On linear information \nsystems. In EPTCS 22,pages38 48,2010. [15] P.L.Curien. De.nability andfull abstraction. ENTCS,172:301 \n310, 2007. [16] T.Ehrhard andL.Regnier. Differentialinteraction nets. TCS,364(2): 166 195, 2006. [17] \nM.Gaboardi andL.Paolini.Syntactical, operational anddenotational linearity. In Workshop LOGIC.2007. [18] \nM. Gaboardi and M. Piccolo. Categorical models for a semantically linear .-calculus. In EPTCS 22,pages1 \n13,2010. [19] J.Y.Girard. Linearlogic. TCS,50:1 102, 1987. [20] J. Y. Girard, Y. Lafont, and P. Taylor. \nProofs and Types. Cambridge University Press,1989. [21] J.R.Hindley. BCK-combinators andlinear .-termshave \ntypes. TCS, 64:97 105, 1989. [22] M.Huth. Lineardomainsandlinear maps. In LNCS 802,pages438 453.1993. \n[23] J. M. E. Hyland and L. C.-H. Ong. On full abstraction for PCF: I, II, andIII. I&#38;C,163(2):285 \n408, 2000. [24] J. W. Klop. New .x point combinators from old. In Re.ections on Type Theory. RadboudUniversity \nNijmegen, 2007. [25] J. R. Longley. Notions of computability at higher types I. In Lecture Notes in Logic,pages32 \n142.2000. [26] J. R. Longley. The sequentially realizable functionals. APAL, 117: 1 93, 2002. [27] D. \nNormann. Computing with functionals -computability theory or computer science? Bulletin ofSymbolicLogic, \n12(1):43 59, 2006. [28] C.-H. Luke Ong. Correspondence between operational and denota\u00adtional semantics: \nthe full abstraction for PCF. In Handbook of Logic in Computer Science pages269 356.OxfordUniversity \nPress,1995. [29] L. Paolini. A stable programming language. I&#38;C, 204(3):339 375, 2006. [30] L. Paolini \nand M. Piccolo. Semantically linear programming lan\u00adguages. In PPDP 08,pages97 107.ACM,2008. [31] L. \nPaolini and M. Piccolo. A process-model for linear programs. In LNCS 5497,pages289 305.2009. [32] M. \nPiccolo. Linearity and Beyond in Denotational Semantics. PhD thesis, Universit\u00b4a diTorino/Universit\u00b4e \ndeParisVII,2009. [33] G. D. Plotkin. LCF considerd as a programming language. TCS, 5: 225 255, 1977. \n[34] D. Walker. Advanced Topics in Types and Programming Languages, chapter Substructural TypeSystems. \nTheMITPress,2005.  \n\t\t\t", "proc_id": "2034773", "abstract": "<p>Linearity is a multi-faceted and ubiquitous notion in the analysis and the development of programming language concepts. We study linearity in a denotational perspective by picking out programs that correspond to linear functions between coherence spaces.</p> <p>We introduce a language, named <i>Sl</i>PCF<sub>*</sub>, that increases the higher-order expressivity of a linear core of PCF by means of new operators related to exception handling and parallel evaluation. <i>Sl</i>PCF<sub>*</sub> allows us to program all the finite elements of the model and, consequently, it entails a full abstraction result that makes the reasoning on the equivalence between programs simpler.</p> <p>Denotational linearity provides also crucial information for the operational evaluation of programs. We formalize two evaluation machineries for the language. The first one is an abstract and concise operational semantics designed with the aim of explaining the new operators, and is based on an infinite-branching search of the evaluation space. The second one is more concrete and it prunes such a space, by exploiting the linear assumptions. This can also be regarded as a base for an implementation.</p>", "authors": [{"name": "Marco Gaboardi", "author_profile_id": "81367593990", "affiliation": "Universit&#224; degli Studi di Bologna, Bologna, Italy", "person_id": "P2801445", "email_address": "gaboardi@cs.unibo.it", "orcid_id": ""}, {"name": "Luca Paolini", "author_profile_id": "81100441807", "affiliation": "Universit&#224; degli Studi di Torino, Torino, Italy", "person_id": "P2801446", "email_address": "paolini@di.unito.it", "orcid_id": ""}, {"name": "Mauro Piccolo", "author_profile_id": "81333490688", "affiliation": "Universit&#224; degli Studi di Torino, Torino, Italy", "person_id": "P2801447", "email_address": "piccolo@di.unito.it", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034822", "year": "2011", "article_id": "2034822", "conference": "ICFP", "title": "Linearity and PCF: a semantic insight!", "url": "http://dl.acm.org/citation.cfm?id=2034822"}