{"article_publication_date": "09-19-2011", "fulltext": "\n Subtyping Delimited Continuations Marek Materzok Institute of Computer Science University of Wroclaw \nWroclaw, Poland tilk@tilk.eu Abstract We present a type system with subtyping for .rst-class delimited \ncontinuations that generalizes Danvy and Filinski s type system for shift and reset by maintaining explicit \ninformation about the types of contexts in the metacontext. We exploit this generalization by considering \nthe control operators known as shift0 and reset0 that can access arbitrary contexts in the metacontext. \nWe use subtyping to control the level of information about the metacontext the ex\u00adpression actually requires \nand in particular to coerce pure expres\u00adsions into effectful ones. For this type system we prove strong \ntype soundness and termination of evaluation and we present a provably correct type reconstruction algorithm. \nWe also introduce two CPS translations for shift0 and reset0: one targeting the untyped lambda calculus, \nand another type-directed targeting the simply-typed lambda calculus. The latter translation preserves \ntypability and is selective in that it keeps pure expressions in direct style. Categories and Subject \nDescriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features Control structures; F.3.3 \n[Logics and Meanings of Programs]: Studies of Program Con\u00adstructs General Terms Languages, Theory Keywords \nDelimited Continuation, Continuation-Passing Style, Type System, Subtyping 1. Introduction Control operators \nfor .rst-class delimited continuations, introduced independently by Felleisen [17] and by Danvy and Filinski \n[13, 14], serve to abstract control in functional programming languages by reifying the current continuation \nas a .rst-class value. However, in contrast to the well-known abortive control operator call/cc present \nin Scheme [23] and SML/NJ [20], delimited-control oper\u00adators model composition of delimited (partial) \ncontinuations rather than jumps to undelimited continuations. In particular, while call/cc offers the \nprogrammer the power of the continuation-passing style (CPS) in direct style, Danvy and Filinski s shift \nand reset offer the power of the continuation-composing style (CCS) characteris\u00adtic of the success-failure \ncontinuation model of backtracking [14]. It has been shown by Filinski that shift and reset play an impor- \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n11, September 19 21, 2011, Tokyo, Japan. Copyright c &#38;#169; 2011 ACM 978-1-4503-0865-6/11/09. . . \n$10.00 Dariusz Biernacki Institute of Computer Science University of Wroclaw Wroclaw, Poland dabi@cs.uni.wroc.pl \ntant role among the most fundamental concepts in the landscape of functional programming a language equipped \nwith shift and reset is monadically complete, i.e., any computational monad can be represented in direct \nstyle with the aid of these control op\u00aderators [18, 19]. A long list of non-trivial applications of delim\u00adited \ncontinuations includes normalization by evaluation and partial evaluation [3, 12, 15], mobile computing \n[33], linguistics [4], and operating systems [25] to name but a few. The intuitive semantics of delimited-control \noperators such as shift (S) and reset (()) can be explained as follows. When the ex\u00adpression Sk.e is \nevaluated, the current delimited by the nearest dynamically-enclosing reset continuation is captured, \ni.e., it is re\u00admoved and the variable k is bound to it. When later k is applied to a value, the then-current \ncontinuation is composed with the captured continuation. For example, the following expression (where \n++ is string concatenation): Alice ++ ( has ++ (Sk.(k a dog ) ++ and the dog ++ (k a cat. ))) evaluates \nto the string Alice has a dog and the dog has a cat. In their .rst article on delimited continuations \n[13], Danvy and Filinski brie.y described a variant of shift and reset, known as shift0 (S0) and reset0, \nwhere the operational semantics of the con\u00adtrol delimiter reset0 coincides with that of reset, but shift0, \nwhen capturing a continuation, instead of resetting it, replaces it with the inner-most delimited continuation \npending on the metacontin\u00aduation. In other words, in contrast to shift, shift0 removes the con\u00adtrol delimiter \nalong with the captured continuation, which makes it possible to use shift0 to access continuations arbitrarily \ndeep in the metacontinuation by repeatedly shifting continuations. For exam\u00adple, the following expression: \n( Alice ++ ( has ++ (S0k1.S0k2. A cat ++ (k1(k2 . )))) evaluates to the string A cat has Alice. , since \nthe second shifting has access to the continuation that prepends the string Alice to a given string. \nThe ability to access arbitrary contexts (a .rst\u00adorder representation of continuations [9]) in the metacontext \n(a .rst order representation of the metacontinuation [9])) makes S0 a particularly interesting and powerful \ncontrol operator. In the untyped setting, shift0 and reset0 have been investigated by Shan [32], who \npresented a CPS translation for shift0 and reset0 that conservatively extends Plotkin s call-by-value \nCPS transla\u00adtion [28] and that leads to a simulation of shift0 and reset0 in terms of shift and reset. \nThis CPS translation and simulation hinge on the requirement that the continuations be represented by \nrecursive functions taking a list of continuations as one of their arguments. (The converse simulation \nis trivial one simply resets the body of each shift0 expression.) In a typed setting, Kiselyov and Shan \n[26] introduced a sub\u00adstructural type system for shift0 and reset0 that abstractly interprets (in the \nsense of abstract interpretation of Cousot and Cousot [11]) small-step reduction semantics of the language. \nTheir type system allows for continuation answer type modi.cations and, in a sense, extends Danvy and \nFilinski s type system which is the most ex\u00adpressive of the known monomorphic type systems for shift \nand re\u00adset. Judgments in Danvy and Filinski s type system have the form G; B f e : A; C, with the interpretation \nthat expression e can be plugged into a context expecting a value of type A and produc\u00ading a value of \ntype B, and a metacontext expecting a value of type C, where B and C can be different types. Hence, expressions \nare allowed to change the answer type of the context in which they are embedded. For example, the expression \n(1+ Sk. true) is well typed in this type system. The typing rules of Danvy and Filinski s type system \nhave been derived from a left-to-right call-by-value evaluator in continuation-passing style [13].  \nIn this article we present a new type-and-effect system for shift0 and reset0 that generalizes Danvy \nand Filinski s original type system for shift and reset. To this end, we .rst introduce a new CPS translation \nfor shift0 and reset0 which conservatively extends Plotkin s call-by-value CPS translation and which \nturns out to be close to a curried version of Shan s CPS translation [32]. From this CPS translation, \nwe derive an abstract machine and a type\u00adand-effect system ` a la Danvy and Filinski which we re.ne by \nal\u00adlowing for subtyping of types and effect annotations. We show that the type system with subtyping \nwe present satis.es several cru\u00adcial properties such as strong type soundness and termination of evaluation, \nand we describe and prove correct a type inference al\u00adgorithm for this type system. Compared to Kiselyov \nand Shan s type system [26], the one presented here is more conventional, it corresponds directly to \nthe CPS translation it has been obtained from, and it heavily relies on subtyping built in the system. \nFur\u00adthermore, we take advantage of the fact that our type system dis\u00adtinguishes between pure and effectful \nexpressions and we present a selective type-directed CPS translation from the language with shift0 and \nreset0 to the simply-typed .-calculus that transforms to CPS only effectful expressions, leaving pure \nones in direct style. We also show that Danvy and Filinski s original type system for shift and reset \ncan naturally be embedded into our type system, and that when restricted, our type system gives rise \nto a type system `a la Danvy and Filinski with subtyping for shift and reset. Similarly, the CPS translations \nfor shift0 and reset0 that we present induce new CPS translations for shift and reset. It is worth stressing \nthat the subtyping mechanism of our type system addresses one of the subtle limitations of Danvy and \nFil\u00adinski s type system concerning the typing rules for shift and .\u00adabstraction: G,f : A F - . F B; E \nf e : E; C G; B fSf.e : B; C G,x : A; C f e : B; D G; B f .x.e : A C - . DB; C According to the above \nrule for shift, the type system assigns the captured continuation a functional type with a single, chosen \nup\u00adfront answer type (F ), which prevents it from being resumed in contexts with a different answer type. \nBut the continuations cap\u00adtured by shift do not modify the context of their resumption, and therefore \nthey should be applicable in any context. One way to deal with this shortcoming is to introduce polymorphism \ninto the lan\u00adguage, as in Asai and Kameyama s work [2]. In their type system, the continuation captured \nby shift is assigned a functional type with polymorphic answer type. Another approach is to distinguish \nbe\u00adtween continuations and functions in such a way that a captured continuation is given a type which \ndoes not mention the answer type [6]. In this approach, additional syntactic construct a con\u00adtinuation \napplication, distinct from function application has to be added to the language. Unfortunately, in this \ntype system, functions without control effects (when C and D are the same arbitrary type in the rule \nfor .-abstraction) still have an answer type chosen up\u00adfront and are subject to the same restrictions \nas described above. In a way, one can treat the continuation types from [6] as more general than function \ntypes continuations can be applied in any context, whereas functions can only be applied in contexts \nwith matching answer types. The type system of this article removes the syntactic distinction between \ncontinuations and functions by the means of subtyping of effect annotations. The subtyping rela\u00adtion \nallows functions to be called when more is known about the types of the contexts in the metacontext than \nthe function actually requires. In particular, a pure function, possibly representing a cap\u00adtured continuation, \ncan be arbitrarily coerced into an effectful one. The rest of this article is structured as follows. \nIn Section 2.1, we introduce the syntax and reduction semantics for the call-by\u00advalue .-calculus with \nshift0 and reset0. In Section 2.2, we present a CPS translation for the language and we relate it to \nthe reduc\u00adtion semantics. In Section 2.3, we derive a type-and-effect system ` a la Danvy and Filinski \nfrom the CPS. In Sections 3.1 and 3.2, we introduce subtyping to the type system and we prove several \nstan\u00addard properties for the system, including strong type soundness. In Section 3.3, we use a context-based \nmethod of reducibility pred\u00adicates to prove termination of evaluation of well-typed programs. In Section \n3.4, we present and prove correct a type inference al\u00adgorithm for our type system. In Section 3.5, we \npresent a selective type-directed CPS translation for the language. In Section 4, we consider some practical \napplications of the presented language. In Section 5, we show how the type system for shift0 and reset0 \ncan be restricted to Danvy and Filinski s type system for shift and reset, and we discuss the CPS translations \nfor shift and reset induced by the presented CPS translations for shift0 and reset0. In Sections 6 and \n7, we discuss related and future work and we conclude in Sec\u00adtion 8. The article is accompanied by a \nHaskell implementation of the presented programming language and by a Twelf formalization of its metatheory, \nboth available at http://www.tilk.eu/shift0/. 2. The language .S0 2.1 Syntax and semantics In this subsection, \nwe de.ne the language we will be working with. The language, which we call .S0 , is the call-by-value \n.-calculus extended with the two control operators shift0 (S0) and reset0 (().). We introduce three syntactic \ncategories of terms, evaluation contexts and trails (i.e., stacks of evaluation contexts): values v ::= \n.x.e | x terms e ::= v | ee |(e)|S0f.e contexts K ::= | Ke | vK trails T ::= D | K \u00b7 T We use the notation \nT \u00b7 T ' for trail concatenation, de.ned as follows: D \u00b7 T = T (K \u00b7 T ) \u00b7 T ' = K \u00b7 (T \u00b7 T ') Contexts \nand trails are represented inside-out, which is formalized by the following de.nition of the plugging \nof a term inside a context: [e]= e D[e]= e (Ke')[e]= K[ee'](K \u00b7 T )[e]= T [(K[e])] (vK)[e]= K[ve]  Environments: \n. ::= .init | .[x . v] Values: v ::= [x, e, .] | k Contexts: k ::= End | Arg(e, ., k) | Fun(v, k) Metacontexts: \nmk ::= [ ] | k : mk Initial con.gurations: (e, .init, End :[])eval Final con.gurations: (End, v, [])cont \n (x, ., k : mk)eval (.x.e, ., k : mk)eval (e1e2, ., k : mk)eval (S0f.e, ., k : mk)eval ((e), ., mk)eval \n(End, v, k : mk)cont (Arg(e, ., k), v, mk)cont (Fun(k ' ,k), v, mk)cont (Fun([x, e, .],k), v, mk)cont \n. (k, .(x), mk)cont . (k, [x, e, .], mk)cont . (e1, ., Arg(e2, ., k): mk)eval . (e, .[f . k], mk)eval \n . (e, ., End : mk)eval . (k, v, mk)cont . (e, ., Fun(v, k): mk)eval . (k ' , v, k : mk)cont . (e, \n.[x . v],k : mk)eval  Figure 1. Abstract machine for .S0 = .k.k x [x][.x.e] = .k.k (.x.[e]) [e1e2] \n= .k.[e1](.f.[e2](.x.f xk)) [(e)] = [e](.x..k.k x) [S0f.e] = .f.[e] Figure 2. Untyped CPS translation \nfor .S0 There are three contraction rules: (.x.e)v e[x/v] (v) v (K[S0f.e]) e[f/.x.(K[x])] where e[x/e \n' ] stands for the usual capture-avoiding substitution of e ' for x in e. A term matching the left-hand \nside of a contraction rule is called a redex. The reduction rule for shift0 differs from the rule for \nshift (K[Sf.e]) (e[f/.x.(K[x])]) in that it removes the reset0 at the root of the redex. This small difference \nenables the shift0 operator to inspect the entire context stack, where shift has access only to the topmost \ncontext. This feature has a big impact on the type systems that we present later in the article. Finally, \nwe de.ne the reduction relation on terms representing programs (i.e., triples (e, T, K)): K[T [e]] -' \n]] if e e ' . K[T [e where any closed non-value term can be uniquely represented as K[T [e]]. The context \nK (at the bottom of the stack) is the only one not delimited by a reset0. As we shall see later, having \nthis last context distinguished from the others is important from the viewpoint of the type system, because \nit can be assigned a simpler type than the other contexts. A trail T along with the distinguished evaluation \ncontext K will be called a metacontext.  2.2 CPS translation The shift0 control operator allows access \nto every context in the trail. What is more, unlike with shift, control effects in a captured context \nare not isolated the captured context, when applied, can capture contexts present at the invocation site. \nThis ability must be re.ected in the CPS translation for the shift0 operator. In the trans\u00adlation presented \nby Shan [32], the trail is represented explicitly as a list of contexts which must be passed to every \ncontinuation. In our approach, the contexts below the current one are captured by additional lambda abstractions. \nThe translation for the shift0 oper\u00adator captures a context using a lambda abstraction, and the trans\u00ad \n[x]@ = .l(k : ks).k x @ ks [.x.e]@ = .l(k : ks).k (.x.[e]@)@ ks [e1e2]@ = .l(k : ks).[e1]@ @ ((.f..lks \n' .[e2]@ @ ((.x..lks '' .f x @(k : ks '' )) : ks ' )) : ks) [(e)]@ = .lks.[e]@ @ ((.x..l(k : ks ' ).k \nx @ ks ' ): ks) [S0f.e]@ = .l(f : ks).[e]@ @ ks Figure 3. Untyped uncurried CPS translation for .S0 lation \nfor reset0 introduces a new context represented by the CPS\u00adtranslated identity continuation. Hence, just \nlike in Shan s work, our CPS accounting for shift0 relies on continuations accepting continuations as \nparameters. The entire CPS translation is shown in Figure 2. Evaluating a well-delimited (i.e., with \nno dangling shift0 s) CPS-translated program requires an initial continuation .x.x. The translation preserves \nthe semantics: . * Theorem 1. If e1 -e2 in .S0 , then [e1] = \u00df. [e2] in ... For reference, and to make \nit possible for the reader to compare the evaluation model encoded in our initial CPS translation with \nthe existing ones [10, 16, 32], we brie.y discuss possible modi.\u00adcations of the CPS translation. First \nof all, the translation can be modi.ed so that every translated term takes all its continuation pa\u00adrameters \nin one list parameter. Figure 3 presents such an uncurried CPS translation that targets the untyped lambda-calculus \nextended with a separate syntactic category of lists and two new kinds of expressions: list abstraction \n.l and list application @. The trans\u00adlation underlies a continuation-passing style interpreter that, \nwhen defunctionalized [1, 29], gives rise to the abstract machine of Fig\u00adure 1. This abstract machine \ncan be seen to be equivalent with the abstract machine for shift0/reset0 described by Biernacki et al. \n[10]. (An alternative way to obtain an abstract machine for the language we consider would be to follow \nBiernacka and Danvy s syntactic correspondence between context-based reduction semantics with explicit \nsubstitutions and abstract machines [7, 8].) Had we decided to translate terms in such a way that the \nhead and tail of the continu\u00adation list are passed as separate arguments, we would have obtained a CPS \ntranslation that coincides with Shan s [32] and which corre\u00adsponds exactly to the abstract machine of \nBiernacki et al. [10].  2.3 From CPS translation to a type system With the CPS translation de.ned, one \ncan use the approach of Danvy and Filinski [13] and build a type system based on this translation. Let \nus thus limit our attention to those terms of .S0 , whose translations are well-typed terms in ... One \ncan then easily see that the types for variables, lambda abstractions and application must have the same \nform as in the type system of Danvy and  G,x : t1 f e : t2 s VAR sABS G,x : tx f x : tx [ts] ts G f \n.x.e : t1 -. t2 [ts ' ] ts ' [t. s1] t. s3'' '' 13 G f f : t1 - ------. t2 [t4 s4] t2 s2 G f e : t1 \n[t3 s3] t4 s4 APP G f fe : t2 [t1 ' s1] t2 ' s2 s1' ' '''' '''' G,f : t1 -. t2 f e : t3 s2 G f e : t \n[t [ts ] ts ] ts SHIFT0 RESET0 G fS0f.e : t1 [t2 s1] t3 s2 G f(e) : ts Figure 4. Type system for .S0 \nwithout subtyping Filinski. And what types should we assign to shift0 and reset0? Suppose that [e] has \ntype t, then [S0f.e] = .f.[e] must have the type t ' -' is the type of the captured continuation. For \n. t , where t reset0, for [(e)] = [e] (.x..k.kx) to have type t , [e] has to have '' ) -'' ) - a type \nof the form (t ' -' -. t . t . Thus every use of . (t . t shift0 introduces a new function arrow into \nthe type, and every use of reset0 removes one. This leads us to a recursive de.nition of effect annotations, \nwhich in a sense remembers the number of nested uses of shift0 inside a term. We now introduce the syntactic \ncategories of types and effect annotations: s types t ::= a | t -. t annotations s ::= E | [ts] ts The \nresulting type system for .S0 is shown in Figure 4. The type annotations require some explanation. Their \nmeaning is best understood together with types they annotate. The typing judgment G f e : t1 ' [t1 s1] \nt2 ' ... [tn sn] t (we omit E for brevity) can be read as follows: the term e in a typing context G may \nevaluate to a value of type t when plugged in a trail of contexts ' s1' sn of types t1 -. t1,...,tn - \n. tn . As a special case, G f e : t means: the term e in a typing context G may evaluate to a value of \ntype t without observable control effects. Function types also have effect annotations, which can be \nthought to be associated with the return type. This type system preserves types as stated in Theorem \n2 below, where translations on types and annotated types are de.ned as follows: = a [a [t1 -s= [t1] - \n. t2] . [t2 s] [tE = t [t [t1 s1] t2 s2] =([t ] -. [t2 s2] . [t1 s1]) - Theorem 2. If G f e : ts, then \n[G] f [e] : [ts] in ... While interesting, this type system is very restrictive. For ex\u00adample, the term \n.x.S0f.f (fx) is translated (with administrative redexes reduced for clarity) to .k.k (.x..f..k.(.k.f \nxk)(.x..k.k x)(.x.f xk)) This term cannot be given a type in the simply typed lambda calculus. The reason \nis that the type of functions restricts their use to only those locations in a term, where the number \nand types of contexts match exactly. This is an unnecessary restriction a function which requires the \ntop k contexts to be of some type can obviously be run safely when more contexts are present, if the \nother contexts can be composed together and accept the function s return value. This observation leads \nus to another, much more expressive type system, which we present in the next section. 3. The type system \nwith subtyping 3.1 The type system .S0 = The type system with subtyping for .S0 , called .S0 , is shown \nin = Figure 5. In this type system, the term .x.S0f.f (fx), which could not be typed before, is well \ntyped and can be assigned the type a [a] a - -. a. We de.ne three subtyping relations: one de.ned on \ntypes, one on effect annotations, and (for convenience) one on pairs of types and effect annotations. \nLemma 1. The subtyping relations are partial orders they are re.exive, transitive and weakly antisymmetric. \nAll subtyping rules are rather straightforward, except the rule for E = [ts] ts, which seems non-intuitive. \nTo get some under\u00adstanding of what this rule means, let us consider an effect-annotated type where the \ncontexts are effect-free: t1 [t1' ] t2 ...tn [tn' ] tf . For a pure t to be a subtype of this type, it \nis required by the rule for E = [ts] ts that tk ' = tk+1 for all k; in other words, that the contexts \ncan be composed. The type system has two distinct rules for function application: one for pure expressions \n(i.e., those without control effects), and one for impure expressions. The rule for pure application \nseems not strictly necessary, but its removal reduces the expressiveness of the type system for example, \nthe following term (.f..y.(.z.((.v..w.y)(fy))) (fy))(.x.(.x.x) x) can no longer be typed without this \nrule. The reason is that the function application inside the subterm .x.(.x.x) x would then force it \ninto impure typing, which makes the typing fail in the left part of the term because of answer type incompatibility. \nTheorem 3 (Subject reduction). If f e : ts and e -' for some . e e ', then f e ' : ts. Theorem 4 (Progress). \nIf f e : ts, then e is a value, e -' for . e some e ' , or e = K[S0f.e]. If s = E, the third case cannot \noccur.  Theorem 5 (Unique decomposition). If f e : t and e -' for . e some e ', then e = K[T [r]] for \nexactly one context K, trail T and redex r.  3.2 Typing contexts and trails Even though it is not strictly \nnecessary, it is useful to have sepa\u00adrate typing rules for contexts and trails as a proof device and \nfor improving the understanding of the system. We .rst have to introduce a different way of looking at \nthe types of expressions. In the type system shown in Figure 5, we put emphasis on the argument type \nof the .rst context on the trail (or of the bottom context, if the trail is empty). In the current, alternative \napproach, the .nal answer type will be emphasized.  '' '''' ts = ts t2 s2 = t1 s1 t1 s1 = t2 s2 '' '''' \nE = EE = [ts] ts [t1 s1] t1 s1 = [t2 s2] t2 s2 '' '' t = ts = st2 = t1 t1 s1 = t2 s2 '' ' s1' s2 ts = \nts a = at1 -. t1 = t2 -. t2 G f e : ts ts = t ' s ' VAR SUB G,x : t f x : t G f e : t ' s ' G,x : t1 \nf e : t2 s G f f : t1 -G f e : t1 . t2 sABS APP-PURE G f .x.e : t1 -. t2 G f fe : t2 [ts1] ts3'' '' \n13 G f f : t1 - ------. t2 [t4 s4] t2 s2 G f e : t1 [t3 s3] t4 s4 APP G f fe : t2 [t1 ' s1] t2 ' s2 \ns1'' G,f : t1 -. t2 f e : t3 s2 G f e : t [t ] ts SHIFT0 RESET0 G fS0f.e : t1 [t2 s1] t3 s2 G f(e) : \nts Figure 5. Type system for .S0 with subtyping (.S0 ) = Let us introduce the syntactic category of trail \ntypes (which are just sequences of function types): s* p ::= (t -. t ) We use . to denote the empty trail \ntype, and we use juxtaposition for trail type concatenation. We de.ne three functions: -.ts, which extracts \nthe trail type, .(ts) which extracts the answer type, and the composition p(ts), which appends a trail \ntype to an effect-annotated type. These func\u00ad tions are de.ned as follows: - . t --------. t1 ' [t1 s1] \nts .t .(t1 ' [t1 s1] ts) . (ts) s1 p (t1 ' -. t1)(ts) = . ' s1-. =(t1 -. t1) ts = t = .(ts) = ts = p \n(t1 ' [t1 s1] ts) We will omit the parentheses when there is no confusion about the meaning of the given \nexpression. -. Property 1. For any t and s, we have ts = ts .ts. Property 2. For any p, p ' , t and s \nwe have (p ' p)ts = p ' (pts). The typing rules for contexts and trails are shown in Figure 6. Contexts \nare assigned function types, and the types of trails are just lists of context types. We can relate these \ntypings to the typing relation for terms: ' s Lemma 2 (Typing contexts). G f K : t -. t if and only if \n' s G f .x.(K[x]) : t -. t . Lemma 3 (Typing trails). G f T : p is derivable if and only if for every \ne, t, s such that G f e : pts one can derive G f T [e]: ts. Additionally, we introduce the notion of \npure contexts, which are not allowed to have occurrences of the shift0 operator not sur\u00adrounded by a \nreset0. For this typing relation the following lemma holds: ' -G f .x.K[x]: t . t. Lemma 4 (Typing pure \ncontexts). G fP K : t . t if and only if ' - Pure typing of contexts is a restricted version of the impure \ntyping, in the sense that even when considering only contexts with a pure type (i.e., of the form t -'), \nthere are strictly fewer pure . t contexts than impure ones. For example, we have y : a f .x.(x (S0f.y)) \n:(a [a] a . a - -. a) - but it is not a valid typing for .x.x (S0f.y). However, every pure context is \nan impure one: ' -then G f K : t . t . Lemma 5 (Impure typing of pure contexts). If G fP K : t . t , \n' - We can now introduce the typing relation for programs. As witnessed by the unique-decomposition theorem, \nwe can view a program as composed of three parts: an expression, a trail, and a pure context at the bottom. \nThe following theorem establishes the correctness of the rule PROG: Lemma 6 (Typing programs). G f(e, \nT, K) : t if and only if G f K[T [e]] : t . Next, we formally introduce the notion of metacontexts, which \nwill play a role in proving termination. A metacontext in our system is a pair of a trail TM , typed \nG f TM : p for some p, and a pure '' -'' context K, typed G fP K : t . t for some t and t '', and where \nfor some t we have t = pt ''. The intuitive meaning of this restriction is that the contexts in the trail \ncannot access contexts outside of it and they can be composed, so that when given a value of type t, \nthey produce a value of type t '', which can be put into the pure context at the bottom. Lemma 7 (Typing \nmetacontexts). G f(TM ,K) : t . t ' if and only if G,x : t f K[TM [x]] : t ' . Finally, we introduce \na different notion of program decomposi\u00adtion. In a well-typed program, the trail can be split into two \nparts: the top part, which is accessible by the expression inside, and the bottom part, which is guaranteed \nby the type of the expression to be inaccessible. This bottom part of the trail, together with the pure \ncontext at the very bottom, form a metacontext. This is made formal by the following theorem:  Contexts \ns1' G f K : t -. t1 G f e : t [t2 s2] t3 s3 APPLEMPTY ' [t1 s1] t2 s2s3 G f : t -. t G f Ke :(t - ------. \nt ) -. t3 s' '' s1' [t1 s1] t2 s2 G f K : t1 . t2 t1 = t1 t2 s = t2 s G f K : t -. t1 G f v : t - ------. \nt - SUB APPR ' s2' s' G f vK : t -. t2 G f K : t1 -. t2 Pure contexts G fP K : t1 -G f e : t3 . t2 \n EMPTY APPL G fP : t -. t G fP Ke :(t3 -. t2 . t1) -G fP K : t1 -G f v : t3 -G fP K : t1 -t1 ' = t12 \n' . t2 . t1 . t2 t2 = t APPR SUB G fP vK : t3 -G fP K : t ' . t ' . t21 -2 Trails ' s G f K : t -. t \nG f M : p EMPTY sCONS G f D : . G f K \u00b7 M : t ' -. tp Subtyping for trail types s' s'' t1 -. t2 = t1 \n-. t2 p = p . = . 2 p ' s' s' t1 -. t2 p = t1 -. t Metacontexts, programs ''' '' -.' G f TM : pK : \nt . tt = pt G f e : ts G f T : ts K : .ts - G fP -G fP . t META PROG G f(TM ,K) : t -' G f(e, T, K) : \nt ' . t Figure 6. Typing rules for contexts and trails in .S0 = Theorem 6. If G f e : ts and G f(e, \nT, K) : t ', then there -. exist T1 and TM such that T = T1 \u00b7 TM , G f T1 : ts, and G f(TM ,K) : .ts \n-' . . t  3.3 Termination We now prove termination of evaluation of closed well-typed ex\u00adpressions using \na variant of the method described in [5, 6]. We be\u00adlieve that it is instructive to see the proof in full \ndetail. First, the proof reveals otherwise hidden nuances of how the reduction se\u00admantics and the type \nsystem interact. Second, it contains explicit information on how well-typed terms in our language are \nevalu\u00adated: each case of the proof of Lemma 12 corresponds exactly to a clause of an evaluator which \ncan be extracted from this proof [5, 6]. Let us start by de.ning three families of mutually inductive \npredicates. The families are de.ned by induction on types: Rt is de.ned on well-typed values and is indexed \nby their types, T p is de.ned on well-typed trails and is indexed by trail types, and .nally Mt is de.ned \non metacontexts and is indexed by their argument types. We also de.ne a predicate N (e, T, K) de.ned \non well\u00adtyped programs, which means that the evaluation of this program terminates, i.e., that K[T [e]] \n-* v for some value v. . Ra(v) := T Rt s-. t(v) := .v ' , T, TM , K.Rt (v ' ) . T -.t s(T ) . M.t s(TM \n, K) ' . N (v v , T \u00b7 TM , K) T .() := T T t s-. t p(K \u00b7 T ) := Rt s-. t(.x.(K[x])) . T p(T ) Mt(TM , \nK) := .v.Rt(v) . N (v, TM , K) For the proof, we need several lemmas about the subtyping rela\u00adtion and \nits connection to the typing rules and the above predicates. Lemma 8. If t = pt1, G f T : p, G f(TM ,K) \n: t1 - . t2, then G f(T \u00b7 TM ,K) : t - . t2. Proof. From G f(TM ,K) : t1 -. t2 for some t ' , p ' we \nhave G f TM : p ' , G fP K : t . t2 and t1 = p ' t '. So G f T \u00b7 TM : pp ' . ' -From t1 = p ' t ' we \nhave pt1 = pp ' t ', by transitivity from the assumption t = pt1 we have t = pp ' t ' . Lemma 9. 1. The \npredicates respect the subtyping relations: R. If t = t ' and Rt(v), then Rt (v). T. If p = p ' and T \np(T ), then T p (T ). M. If t ' = t and Mt(TM ,K), then Mt (TM ,K). 2. If t ' s ' = ts, T -.ts(T ) and \nM.ts(TM ,K), then for some ''- -. ' T , TM we have T ts (T ' ), M.ts (TM ,K) and T \u00b7 TM = '' T \u00b7 TM . \nProof. Proof by simultaneous induction. The proofs refer to other cases of the lemma with smaller subtyping \nderivations. The only exception is a reference from (1M) to (1R), but since it does not introduce a cycle, \nthe induction is justi.ed. s'' s'' 1R. t = t1 -. t2, t = t1 -. t2. We have t1 = t1 and - -. t2 s = t2 \n' s '. Let v, T , TM , K be such that Rt1(v), T t2 s (T ), M.t2 s (TM ,K). By induction hypothesis for \ncase (2) we '' '' -'' have T and TMt2 .s(T M ,K) and such that T -), M.t2 s(T T \u00b7 TM = T \u00b7 TM . Thus \nfrom the assumption Rt(v) follows the thesis. s 1T. The case p = p ' = . is trivial. Let p = t1 -. t2 \np1 and p ' = ' s' s' s' t1 -. t2p1' . Then we have t1 -. t2 = t1 -. t2, p1 = p1' , T = K \u00b7 T1, Rt1 s(.x.(K[x])) \nand T p1(T1). By induction hy\u00ad -. t2 pothesis for case (1R) and (1T) we get Rt1 s(.x.(K[x])) -. t2 and \nT p1(T1), which give us the thesis.  1M. Let v be such that Rt (v). By case (1R) we have Rt(v), with \nMt(TM ,K) this gives us N (v, TM ,K). 2. Induction on the subtyping derivation. s ' = E, s = E. Then \nT = D, t ' = t, Mt(TM ,K). '' Let T = D, TM = TM . We thus need to show that Mt (TM ,K), but that follows \nfrom case (1M). s ' = E, s =[t1 s1]t2 s2. Then t ' = t, t1 s1 = t2s2 , T = \u00b7 T ' , T t s1(K1), T ---.(T \n' ), M.t2 s2(TM ,K). K1 -. t1t2 s2 '' Let T = D, TM = T \u00b7 TM . Trivially we have T .(D), we need to show \nthat Mt (T \u00b7 TM ,K). The metacontext (T \u00b7 TM ,K) is well-typed by Lemma 8. Let v be such that Rt (v), \nI will show that N (v, T \u00b7 TM ,K). From case (1T) s2s2 we have T t -. t2(K1), by de.nition of T t -. \nt2 we have Rt s2(.x.(K1[x])). t2 s2(T ' ) --. -. t2With Rt (v), T - and M.t2 s2(TM ,K) we have N ((.x.(K1[x])) \nv, T ' \u00b7 TM ,K). Because (.x.(K1[x])) v reduces in single step to (K1[v]), we have N ((K1[v]),T ' \u00b7 TM \n,K), which is equivalent to N (v, K1 \u00b7 T ' \u00b7 TM ,K), which we wanted to prove. ' s '' s ' s ' =[t11] \nt22, s =[t1 s1] t2 s2. Then T = K1 \u00b7 T1, T t s1(K1), T -(T1), M.t2 s2(TM ,K), --. -. t1t2 s2 t ' = t \nand t2 ' s2 ' = t2 s2. By induction hypothesis we ' ' --.' ' have T1, T such that T -(T1), M.t2 s2(TM \n,K) and Mt2 s2 '' ' T1 \u00b7 TM = T1 \u00b7 TM . From M.t2 s2(TM ,K) we have ''' ' M.ts (TM ,,K). Let T = K1 \u00b7 \nT1. From t1 s1 = t1 s1' , t ' = t, T t s1(K1) and the induction hypothesis for -. t1 s--. ' 1 case (1T) \nwe have T t -. t1(K1). With T -t2 s2(T1) we - -. ' have T ts (K1 \u00b7 T1). Lemma 10. For every type t, T \nt -. t( ) holds. Proof. By the de.nition of T t -it is suf.cient to prove that . t Rt -Let be such that \nRt(v) and . t(.x.(x)). v, TM , and K Mt(TM ,K). We have to show that N ((.x.(x)) v, TM ,K). The expression \n(.x.(x)) v reduces in two steps to v, so it suf.ces to prove N (v, TM ,K), which follows from Rt(v). \n Lemma 11. For every type t, Mt(D, ) holds. Proof. Let v be a value of type t, then N (v, D, ) is trivially \ntrue. We now state the main lemma: Lemma 12. Let G f e : ts, where G= x1 : t1,...,xn : tn. Assume that \nvv is a sequence of values of length n such that for every i, Rti(vi) holds. Then for every trail T such \nthat T -ts(T ) holds, . and for every metacontext (TM ,K) such that M.ts(TM , K,) holds, N (e{vx/vv},T \n\u00b7 TM ,K) holds. Proof. Induction on the structure of the typing derivation D of e. ' '' D = SUB(D ' ,t \ns ' = ts). From Lemma 9 we have T , TM - -.' ' '' such that T ts (T ), M.ts (TM ,K) and T \u00b7 TM = T \u00b7 \nTM . The conclusion follows from the induction hypothesis. D = VAR, e = xi. So we have e{vx/vv} = vi, \nt = ti, s = E ,T = D, Mti(TM ,K). By assumption Rti(vi) and the de.nition of Mti we have N (vi,TM ,K). \n'' -' D = ABS(D ' ), e = .x.e '. So t = t . s ' t , s = E, T = D, Mt(TM ,K). As in the previous case, \nto show that N ((.x.e ' ){vx/vv},TM ,K) we need Rt(.x.e ' {vx/vv}). - -. Let v, T , TM , K be such that \nwe have Rt (v), T ts (T ) and M.ts (TM ,K). We need to show that N ((.x.e ' {vx/vv}) v, T \u00b7 TM ,K). Because \n(.x.e ' {vx/vv}) v reduces in one step to e ' {vx/vv}{x/v}, it suf.ces to show N (e ' {vx/vv}{x/v},T \n\u00b7 TM ,K), which follows from the induction hypothesis. D = APP(D1,D2), e = e1 e2. Then s =[tA sA] tD \nsD, ' sA' T = \u00b7 T - --.(T ), G f : K1 , T t - . tA(K1), T tB sBe1 ' [tA sA] tB sB ' t ---------. t [tC \nsC ] tD sD, G f e2 : t [tB sB] tC sC . '' '' Let e1 = e1{vx/vv} and e2 = {vx/vv}. To show that N (e1 \ne2,K1\u00b7 ' ''' T \u00b7 TM ,K), we can show instead that N (e1,K1 e2 \u00b7 T \u00b7 TM ,K) using the induction hypothesis \nfor D1, providing [tA sA] tBsB sC' that T (t (K1 e To show that, let ---------. t) - . tC 2). us unfold \nthe de.nitions. Let vL, TL, TKL and ML sat\u00ad [tA sA] tB sB isfy the appropriate predicates, i.e., Rt ---------. \nt(vL), T - --.(TL) and (TKL,ML). Then we have to tC sC M.tC sC show that N ((.x.(K1[xe2])) vL,TL \u00b7 TKL,ML). \nBecause (.x.(K1[xe2])) vL reduces in one step to (K1[vL e2]), we can show instead that N ((K1[vL e2]),TL \n\u00b7 TKL,ML). We will show instead that N (e2,vL K1 \u00b7 TL \u00b7 TKL,ML). This follows for the induction hypothesis \nfor D2, providing that T t s- B. tB(vL K1). To show that, let us unfold the de.ni\u00adtions again. Let vR, \nTR, TKR and MR be such that Rt (vR), . T -( tB sB(TR) and M.tB sB(TKR,MR). We have to show that N ((.x.(K1[vL \nx])) vR,TR \u00b7TKR,MR). Using analogous reasoning as before, it is suf.cient to show that N (vL vR,K1 \u00b7 \n[tA sA] tB sB TR \u00b7TKR,MR), which follows from Rt ---------. t(vL). D = APP-PURE(D1,D2), e = e1 e2. The \nproof is similar to the case for APP. ' s ' '' s '' D = SHIFT0(D ' ), e = S0f.e '. So s =[t ]t , T = \nK1 \u00b7 ' s- -. ' T , Rt -. t (.x.(K1[x])), T ts (T ) and M.ts (TM ,K). We want to show N (S0f.e{vx/vv},K1 \n\u00b7 T ' \u00b7 TM ,K), which is equivalent to N ((K1[S0f.e{vx/vv}]),T ' \u00b7 TM ,K). Because (K1[S0f.e{vx/vv}]) \nreduces to e{vx/vv}{f/.x.(K[x]}, it suf\u00ad.ces to show that N (e{vx/vv}{f/.x.(K[x]},T ' \u00b7 TM ,K), which \nfollows from the induction hypothesis. D = RESET0(D ' ), e = (e ' ). Then for some t ' we have ' '' G \nf e : t [t ] ts. From Lemma 10 have T t . t ( ), - - -----. and thus T t [t ] ts( \u00b7 T ). The induction \nhypothesis gives us N (e ' {vx/vv}, \u00b7 T \u00b7 TM ,K), which is equivalent to the thesis, N ((e ' ){vx/vv}, \n\u00b7T \u00b7 TM ,K). Theorem 7 (Termination). If f e : t , then the evaluation of e terminates, i.e., N (e, D, \n) holds. Proof. We have T .(D) and from Lemma 11 we have Mt(D, ), thus the theorem follows from Lemma \n12.  3.4 Type inference Type inference in .S0 is decidable. For the purpose of type infer\u00ad = ence, we \nreplace the rules APP and APP-IND with the following (equivalent) rule: s3 G f f : t ' -. ts1 G f e : \nt ' s2 s \u00ab s1 s2 s3 APP-COMP, G f fe : ts where the relation \u00ab is de.ned as follows: E \u00ab [ts] ts \u00ab E \n\u00ab vs [tf sf ] t2 s2 \u00ab vs E \u00ab E vs [tf sf ] t1 s1 \u00ab [t2 s2] t1 s1 vs Expressions of the form s =? s will \nbe called subtyping constraints, and expressions of the form s \u00ab? vs will be called  = a [a s. [t2 \ns] [t1 -. t2] = [t1] - [tE = [t] [t [t1 s1] t2 s2] = . [t1 s1]) - ([t ] -. [t2 s2][a = a = .x.x ' s1' \ns2'' [t1 -. t1 = t2 -. t2] = .f..x.[t1 s1 = t2 s2](f([t2 = t1]x)) [tE = t ' E = [t = t ' ] [tE = t ' \n[t1 s1] t2 s2 = .x..f.[t1 s1 = t2 s2](f([t = t ' ]x)) '''' ' [t [t1 s1] t1 s1 ' = t ' [t2 s2] t2 s2' \n] = .f..g.[t1 s1 ' = t2 s2' ](f(.x.[t2 s2 = t1 s1](g([t = t ]x)))) [x]VAR = x ' s ' [e]SUB(D,t s=ts \n) = [ts = t [.x.e]ABS(D) = .x.[e]D ][e]D [fe]APP-PURE(D1,D2) = [f]D1 [e]D2 [fe]APP(D1,D2) = .k. f]D1 \n(.f.[e]D2 (.e.fek)) [S0f.e]SHIFT0(D) = .f.[ e]D [(e)]RESET0(D) = [e]D(.x.x) S0 Figure 7. Type-directed \nCPS translation for .= composition constraints. Inside the constraints, the syntax of effect annotations \nis extended by annotation variables d. We will be using substitutions de.ned on both the type variables \nand annotation variables. We call a substitution s-grounding, if its values do not contain any annotation \nvariables. We say that a substitution s solves a constraint s1 =? s2 (s1 \u00ab ? vs) if and only if s(s1) \n= s(s2) (s(s1) \u00ab s(vs)) is derivable. Theorem 8 (Principal types). For every term e and typing environ\u00adment \nG there exist: a, d, a set of ts-subtyping constraints S, and a set of composition constraints C, such \nthat: 1. For every s-grounding substitution s which solves S and C we have G f e : s(a) s(d). 2. For \nevery t , s satisfying G f e : ts there exists a s-grounding substitution s such that s(a)= t , s(d)= \ns and s solves S and  C. The type inference algorithm .nds the principal type (along with the unsolved \nconstraints) in polynomial time and it also gener\u00adates a typing derivation skeleton, where subtyping \nderivations have to be .lled in. In order to check if the term is actually well-typed (and to obtain \na concrete typing derivation), one has to .nd a s\u00adgrounding substitution which solves the inequalities. \n 3.5 Type-directed CPS translation Having extended the type system with subtyping, we can derive from \nit a type-directed CPS translation, which takes into account the additional information given by the \nsubtyping. This translation, de.ned in Figure 7, targets the simply-typed lambda calculus, and as the \nCPS translation of Figure 2, it preserves types: Theorem 9 (Type preservation). If D is a typing derivation \nof G f e : ts in .S0 , then [G] f [e]D : [ts] in ... = The derivations of the subtyping relation are \ntranslated to coer\u00adcion functions, which are typed as expected: ' '' s ' s ' '' Lemma 13. If ts = ts \n', then f [ts = t ] : [ts] - in ... If t = t ', then f [t = t . [t ] in ... . [t ] ] : [t] - Another \ninteresting property of the translation is that it keeps terms annotated as pure in direct style. This \nis similar to the selec\u00adtive translations presented in [24], [27], and recently in [31], which also use \neffect annotations to distinguish pure terms from effectful ones. The property suggests that the translation \npresented here may be useful in implementing shift0/reset0 in functional programming languages. Unfortunately, \nthe translation does not preserve reductions. For example, let us consider the term (S0f.f). We have \nf (S0f.f) : t . t and (S0f.f). .x.(x). For the simplest derivation D, we have [(S0f.f )]D =(.f.f)(.x.x) \nand for the simplest derivation D ', we have [.x.(x)]D = .x.(.x..k.(.x.x)(k ((.x.x) x))) x (.x.x). So \nwe cannot \u00df-reduce [(S0f.f)]D to [.x.(x)]D , although they are \u00df-equal. For this reason, this CPS translation \ncould not be used as-is for proving termination of evaluation of well-typed terms in .S0 = . 4. Programming \nexamples 4.1 Prototype implementation In order to study the applications of the type system .S0 to practical \n= programming, we have developed its prototype implementation. The implementation adds some standard \nsyntactic sugar to the language and extends it with integers, algebraic data types and recursion. We \nextend the syntax as follows: e ::= ... | true | false | if e then e else e | nil | cons(e, e) | case \ne {nil -. e} . e; cons(x1,x2) - | k | e . e | e . e | .xx.e t ::= ... | int | bool | list(t ) The typing \nrules for new expressions introduced above are given in Figure 8. In the implementation language, the \nstring @f.e means S0f.e, and <e> means (e). The rest of the syntax used is ML-like.  TRUE FALSE G f \ntrue : bool G f false : bool G f b : bool s1 G f e1 : ts2 G f e2 : ts2 s \u00ab s1 s2 IF G f if b then e1 \nelse e2 : ts INT G f k : int G f k1 : int s1 G f k2 : int s2 s \u00ab s1 s2 ARITH G f k1 . k2 : int s G f \nk1 : int s1 G f k2 : int s2 s \u00ab s1 s2 REL G f k1 k2 : bool s G f nil : list(t ) NIL G f h : ts1 G f t \n: list(t ) s2 s \u00ab s1 s2 G f cons(h, t): list(t) s CONS G f e : list(tl) s1 G f e1 : ts2 G,h : tl,t : \nlist(tl) f e2 : ts2 s \u00ab s1 s2 CASE G f case e{nil -. e2} : ts . e1; cons(h, t) -G,x : t f e : t FIX \nG f .x x.e : t Figure 8. Typing rules for booleans, integers, lists and recursion  4.2 Example pre.xes \nThe pre.xes example shown in Figure 9 has been considered in [2] and in [6]. The function prefixes lists \npre.xes of a given list, e.g., prefixes [1,2,3] yields [[1],[1,2],[1,2,3]]. This example cannot be typed \nin the original type system of Danvy and Filinski, because the captured continuation is applied in con\u00adtexts \nwith different answer types. In our type system, this prob\u00adlem is taken care of by the subtyping relation. \nIn the .rst oc\u00adcurrence (k []) the continuation is simply given the pure type list(int) -. list(int). \nIn the second (k (w xs)), it is given a more complex type list(int) [list(int)] list(int) - ------. list(int). \n 4.3 Example partition The pre.xes example does not take advantage of the semantics of shift0, because \nit can be typed with .at effect annotations. This is not the case for partition, shown in Figure 10. \nThis program partitions a list of integers into three parts: the ones less than, equal, and greater than \na number given as a parameter, maintain\u00ading the original order between the integers in each group, e.g., \npartition 3 [4,1,3,5,2,3] yields [1,2,3,3,4,5]. The idea behind this example is that the two reset0 s \nare used as markers for the positions in the result where we insert new elements, and shift0 is used \nto reach those markers. The inner function part is given the following type: list(int) [list(int)] list(int)[list(int)] \nlist(int) ---------------. list(int) Hence, it requires two contexts, both of the type list(int) - . \nlist(int), and returns a .nal value of type list(int). These contexts are the accumulators for the elements \nless than and equal to the given value. let prefixes xs = let w l = case l { Nil -> @k. Nil | Cons(x, \nxs) -> Cons(x, @k. <Cons(k [], <k (w xs)>)>) } in <w xs> Figure 9. Example program pre.xes let partition \na l = letpart l=case l{ Nil -> [] | Cons(h,t) -> if h>a then Cons(h, part t) elseif h==a then @f. Cons(h, \n<f (part t)>) else @f g. Cons(h, <g <f (part t)>>) } in <<part l>> Figure 10. Example program partition \nThe subtyping relation is crucial for typing this example. In particular, in the non-recursive Nil case, \nthe following subtyping is used: list(int) = list(int)[list(int)] list(int)[list(int)] list(int), where \nthe subtyping derivation for the effect annotations is as follows: list(int) = list(int) E = E list(int) \n= list(int) E = [list(int)] list(int) E = [list(int)] list(int)[list(int)] list(int) Using the translation \nfrom Figure 7 we obtain the following coer\u00adcion function (reduced to normal form for clarity): .x..k1..k2.k2 \n(k1 x) We can see that in the translated term the composition of the accumulator contexts after traversing \nthe entire input list is done by the coercion function. 5. Relation to shift/reset The shift operator \ncan be de.ned with shift0 and reset0 by putting a reset0 inside a shift0: Sf.e = S0f.(e); reset0 then \nbehaves just like reset. Using this de.nition, one can check how the type system presented here relates \nto the type system for shift/reset introduced by Danvy and Filinski [14] (let us call their system .S \n.). First, S0 we de.ne a translation from .S= on terms and types (the . to .syntactic forms not mentioned \nbelow translate homomorphically): t = t [t3] t4 -= t1 t3 . t4 t2 t1 - --. t2 Sf.e = S0f.(e) The translation \non typing derivations is shown in Figure 11. Using this translation, one can prove the following result: \nTheorem 10. If G; t1 f e : t; t2 in .S ., then G f e : t [t1] t2 in .S0 = . One can also consider the \nCPS translations in both systems .S . S0 and .= . First, we notice that the CPS translations of the typing \nderivations resulting from the translation in Figure 11 are \u00df-equal  VAR G,x : t ; t ' f x : t; t ' \nG,x : t; t1 f e : t ' ; t2 ABS '' ''' G; t f .x.e :(t t1 . t2 t ); t - G; t4 ' f f :(t1 t. tt2); t2 ' \n- G; t3 ' f e 1 : t2; t 3 4 ' APP G; t1 ' f fe : t2; t2 ' G,f :(t t -t1); t3 f e : t3; t2 . t SHIFT G; \nt1 fSf.e : t; t2 G; t1 f e : t1; t RESET G; t ' f(e) : t ; t ' ... VAR G,x : t f x : tt = t [t ' ] t \n' SUB G,x : t f x : t [t ' ] t ' G,x : t f e : t ' [t1] t2 ... ABS [t1] t2' [t1] t2' [t1] t2' '' '' \nG f .x.e : t - --. tt - --. t = t - --. t [t ] t SUB [t1] t2' '' '' G f .x.e : t - --. t [t ] t [t] \nt'' '' 13 G f f : t1 - --. t2 [t4] t2 G f e : t1 [t3] t4 APP G f fe : t2 [t1' ] t2 ' [t ] t G,f : t \n- --. t1 f e : t3 [t3] t2 RESET0 [t ] t G,f : t - --. t1 f(e) : t2 ... SHIFT0 '' '' G fS0f.(e) : t \n[t1 [t ] t ] t2 t [t1 [t ] t ] t2 = t [t1] t2 G fS0f.(e) : t [t1] t2 G f e : t1 [t1] t ... RESET0 G f(e) \n: tt = t [t ' ] t ' SUB G f(e) : t [t ' ] t ' Figure 11. Embedding of Danvy and Filinski s type system \n.S= . into .S0 SUB to the standard CPS translations [14]. In order to formalize this observation we introduce \nthe following notation. If D is a typing derivation in .S ., then D is the corresponding typing derivation \nin .S0 = , obtained using the translation inductively de.ned in Figure 11. Lemma 14. Let De be a typing \nderivation for the term e in .S .. Then the following equalities hold: [Sf.e]DSf.e = \u00df .k.[e]De {f/.x..k \n' .k ' (kx)}(.x.x)  [(e)]D.= \u00df .k.k([e]De (.x.x))  e. As a corollary, we can prove the following theorem \nby straight\u00adforward induction: Theorem 11. Let e be a well-typed term in .S ., and let D be its typing \nderivation. Then [e] = \u00df [e]D. The untyped CPS translations of Section 2.2 also induce a CPS translation \nfor shift and reset. For instance, the curried CPS translation of Figure 2 yields: [Sf.e = .f.[e] (.x..k.k \nx) [(e)] = [e](.x..k.k x) It is interesting to observe that although this CPS translation validates the \nstandard reduction semantics of shift and reset: (v) v (K[Sf.e])(e[f/.x.(K[x])]) it generates a different \nequational theory than the one of the stan\u00addard CPS translation for shift and reset [22]. For example, \nthe equa\u00adtion ((e)) = (e) is not sound with respect to the presented CPS translation. So in a sense, \nby using the CPS translation for shift0 and reset0 we have obtained a variant of shift and reset. However, \nwhen considered in the type system with subtyping, shift0 and reset0 give rise to the standard shift \nand reset, as demonstrated by Lemma 14. Each of the CPS translations of Section 2.2 determines a de.ni\u00adtion \nof shift0 and reset0 in the corresponding continuation monad. Since we can represent arbitrary computational \nmonads in direct style using shift and reset [18], we obtain two static simulations of shift0 and reset0. \nThe simulation obtained from the uncurried trans\u00adlation of Figure 3 is similar to the one presented by \nShan [32], but the one obtained from the translation of Figure 2 is novel: S0f.e := Sk..c.(.f.((.x..k.k \nx) e)) (.x.Sk ' ..c ' .k xc (.x ' .k ' x ' c ' )) (e)0 := Sk..c.((.x..k.k x) e) (.x..k.k x)(.x.k xc) \nrunS0 e := ((.x..k.k x) e) (.x.x) We can also consider the type system of [6], which we call .S Again, \nwe .rst de.ne a translation on terms, types and context types (as before, syntactic forms not mentioned \nbelow are trans\u00adlated homomorphically): b = tb [t3] t4 t1 t3 -t2 = t1 . t2 . t4 - --t1 t2 = . t2 t1 - \nk .pe = ke Sk.e = S0k.(e) Next, we can write a translation on typing derivations, which satis.es the \nfollowing theorem: Theorem 12. If G, .; t1 f e in .Se : : t ; t2 ., then G . . f t [t1] t2 in .S0 = . \nFor both type systems for shift considered here, there exist terms which are not well-typed in those \nsystems, but their translation to S0 .= is well-typed. In particular, the following term: (.f..y.(.z.((.v..w.y)(fy))) \n(fy))(.x.x) is a valid term and cannot be typed in neither of the two systems. S0 However, it translates \nwithout changes to .= , where it is well  ' '' t = tt2 = t1 t1 = t2 ' '' E = EE = [t ] t [t1] t1 = [t2] \nt2 '' '' t = ts = st2 = t1 t1 s1 = t2 s2 '' ' s1' s2 ts = ts a = at1 -. t1 = t2 -. t2 G f e : ts ts = \nt ' s ' VAR SUB G,x : t f x : t G f e : t ' s ' G,x : t1 f e : t2 s G f f : t1 -G f e : t1 . t2 sABS \nAPP-PURE G f .x.e : t1 -. t2 G f fe : t2 [t] t'' '' 13 G f f : t1 - --. t2 [t4] t2 G f e : t1 [t3] t4 \nAPP G f fe : t2 [t1' ] t2 ' G,f : t1 -G f e : t ' [t ' ] t . t2 f e : t3 SHIFT0 RESET0 G fS0f.e : \nt1 [t2] t3 G f(e) : t Figure 12. Type system for .S0 typed (for example, it can be assigned the type \na -. a)). In . (\u00df -this sense, the type system presented here is strictly more expres\u00adsive than the other \nsystems. An interesting feature of both translations is that a non-empty type annotation never occurs \ninside another type annotation the annotations are .at. Thus one can consider a variant of the .S0 type \nsystem, which enforces this restriction syntactically: = s t ::= a | t -. t s ::= E | [t] t The typing \nrules for this system (called .S =) are shown in Figure 12. In this type system shift0 is forbidden from \nbeing used inside another shift0 without a corresponding control delimiter and, there\u00adfore, only the \ntop context of the stack can be accessed by control operations. It follows that in this type system shift0 \nhas the seman\u00adtics of shift. We can thus view this type system as an exotic type system for the shift \noperator (that is why we call it .S =). 6. Related work 6.1 Relation to the Scala implementation The \ntype system and the selective CPS-translation presented here resemble strongly those presented by Rompf \net al. in [31] for the programming language Scala. The presentation in [31] is based on Scala and is \nsomewhat informal, so the exact comparison is not possible, but still one can see the following similarities: \n Our annotations (from the type system .S =) correspond to @cps annotations. For example, our type a \n[\u00df] . corresponds to A @cps[B, C] in Scala.  The type system of Scala distinguishes pure and impure \nexpres\u00adsions as our type system does. In particular, as in our restricted system with .at annotations, \nthe expression inside a shift must have a pure type, the entire expression has an impure type, and the \ncaptured continuation has a pure function type.  Scala s Shift class used for implementing delimited \ncontrol, which implements the continuation monad, is constructed by shift and consumed by reset, in the \nsame way that in our transla\u00ad  with .at effect annotations (.S =) tion shift0 introduces a lambda abstraction \nand reset0 eliminates it. Our annotation composition relation \u00ab introduced in Sec\u00adtion 3.4 corresponds \nto the comp control effect composition operation. The type system in [31] does not allow shift to be \nused inside another shift it has to be put inside a new reset. This is what happens with the shift0 operator \nwith .at effect annotations in our type system. This reinforces our opinion that Scala implements the \nrestricted shift0/reset0 operators, which only happen to coincide with shift/reset.  6.2 Substructural \ntype system of Kiselyov and Shan The type system for shift0/reset0 introduced by Kiselyov and Shan [26] \nshares many properties with the type system presented in this work in particular, strong type soundness \nand termination. In their work, expressions and evaluation contexts are treated as structure in linear \nlogic, where structural rules play a vital role. Moreover, their type system abstractly interprets (in \nthe sense of abstract interpretation of Cousot and Cousot [11]) small-step re\u00adduction semantics of the \nlanguage and it does not require effect annotations in judgments and arrow types. Instead these annota\u00adtions \noccur in types and cotypes assigned to terms and coterms, respectively. In terms of presentation, our \nsystem is very close to the well-known type system by Danvy and Filinski and seems more conventional \nthan Kiselyov and Shan s. Both type systems allow for answer type modi.cations and for exploring the \nstack of con\u00adtexts beyond the nearest control delimiter. While in our type system subtyping is built \nin and plays a major role, leading to a clever CPS translation, in Kiselyov and Shan s work it is just \nan entailment of the type system. Our type system can be embedded in the type system of Kise\u00adlyov and \nShan. A converse translation appears to be impossible be\u00adcause their language is richer: it includes \nan operator $, which is a generalization of reset0 and, in a sense, the inverse of the shift0 op\u00aderator. \nBecause our language does not differentiate between func\u00adtions and contexts, it is currently not clear \nhow to include this op\u00aderator in it, so the subject requires further study.  7. Future work The type \nsystem presented here is monomorphic. We are planning to explore how adding polymorphism (let-polymorphism, \nsystem F-like explicit polymorphism) affects the system. We expect that, as in the polymorphic type system \nof Asai and Kameyama presented in [2], it should be safe to generalize the types of pure terms. Also, \nbecause of the presence of subtyping, we will need to store constraints about generalized variables in \nthe polymorphic types, as in [21]. Because of the similarities of the system presented here to the Scala \nimplementation of delimited continuations [31], we are going to investigate whether it would be possible \nto implement our sys\u00adtem in Scala. Our type annotations translate to Scala by nesting the @cps annotations \nalready used by the current implementation of de\u00adlimited control. For example, the effect-annotated type \na[a]a[a]a would translate to Scala s type A @cps[A, A @cps[A, A]]. Another important aspect of this work \nthat has not been re\u00adsearched yet are equational theories of shift0 and reset0 in the un\u00adtyped and typed \nsettings as well as of the variant of shift and reset in the untyped setting, described in Section 5. \nIn particular, it seems vital to understand the role of the subtyping relation in the equa\u00adtional theories \nof the typed control operators. 8. Conclusion We have presented a new type system for the delimited-control \nop\u00aderators shift0 and reset0 that has been derived from a CPS transla\u00adtion for these control operators \nand that generalizes Danvy and Fil\u00adinski s type system for shift and reset. The type system is equipped \nwith two subtyping relations: one on types and the other one on effect annotations describing a stack \nof contexts in which a given expression can be embedded. The subtyping mechanism makes it possible to \ncoerce pure expressions into effectful ones. The effect annotations and the corresponding subtyping relation \nare used to guide a selective CPS translation that precisely takes into account the information about \nthe contexts surrounding a trans\u00adlated expression. In particular, it leaves pure expressions in direct \nstyle. Such a translation seems promising, if one would like to im\u00adplement full-.edged shift0 and reset0, \ne.g., in Scala (instead of their .at version that accidentally coincides with shift and reset [31]). \nAs shown in Section 4, the full power of shift0 and reset0 can be very useful and we believe that there \nare other interesting applications of these operators waiting to be discovered. The present article also \ndemonstrates the effectiveness of the context-based method of reducibility predicates [5, 6] that has \nturned out to be the right way to tackle the non-trivial problem of termination of evaluation for the \ncase of the type-and-effect system with subtyping considered here. It can be observed (and remains to \nbe veri.ed, e.g., in Coq) that the computational content of this con\u00adstructive proof takes the form of \na type-directed evaluator in CPS that corresponds to the type-directed CPS translation presented in this \nwork. Acknowledgments First of all, we would like to thank Malgorzata Biernacka for numerous comments \non the presentation of this work as well as for helping us to get the proof of termination of evaluation \nunder control. We also thank the anonymous referees and the PC members of ICFP 11 for their valuable \ncomments on the presentation and contents of this article. Hugo Herbelin made the observation about the \ndifference between the standard equational theory for shift and reset and the one induced by the untyped \nCPS translation of Section 2.2. This work has been partially supported by the MNiSW grant number N N206 \n357436, 2009-2011. References [1] M. S. Ager, D. Biernacki, O. Danvy, and J. Midtgaard. A func\u00adtional \ncorrespondence between evaluators and abstract machines. In D. Miller, editor, Proceedings of the Fifth \nACM-SIGPLAN Interna\u00adtional Conference on Principles and Practice of Declarative Program\u00adming (PPDP 03), \npages 8 19, Uppsala, Sweden, Aug. 2003. ACM Press. [2] K. Asai and Y. Kameyama. Polymorphic delimited \ncontinuations. In Proceedings of the Fifth Asian symposium on Programming Lan\u00adguages and Systems, APLAS \n07, number 4807 in Lecture Notes in Computer Science, pages 239 254, Singapore, Dec. 2007. [3] V. Balat \nand O. Danvy. Memoization in type-directed partial evalu\u00adation. In D. Batory, C. Consel, and W. Taha, \neditors, Proceedings of the 2002 ACM SIGPLAN/SIGSOFT Conference on Generative Pro\u00adgramming and Component \nEngineering, GPCE 2002, number 2487 in Lecture Notes in Computer Science, pages 78 92, Pittsburgh, Penn\u00adsylvania, \nOct. 2002. Springer-Verlag. [4] C. Barker. Continuations in natural language. In H. Thielecke, editor, \nProceedings of the Fourth ACM SIGPLAN Workshop on Continua\u00adtions (CW 04), Technical report CSR-04-1, \nDepartment of Computer Science, Queen Mary s College, pages 1 11, Venice, Italy, Jan. 2004. [5] M. Biernacka \nand D. Biernacki. A context-based approach to proving termination of evaluation. In Proceedings of the \n25th Annual Confer\u00adence on Mathematical Foundations of Programming Semantics(MFPS XXV), Oxford, UK, Apr. \n2009. [6] M. Biernacka and D. Biernacki. Context-based proofs of termination for typed delimited-control \noperators. In F. J. L\u00b4opez-Fraguas, editor, Proceedings of the 11th ACM-SIGPLAN International Conference \non Principles and Practice of Declarative Programming (PPDP 09), Coimbra, Portugal, Sept. 2009. ACM Press. \n[7] M. Biernacka and O. Danvy. A syntactic correspondence between context-sensitive calculi and abstract \nmachines. Theoretical Computer Science, 375(1-3):76 108, 2007. [8] M. Biernacka and O. Danvy. A concrete \nframework for environment machines. ACM Transactions on Computational Logic, 9(1):1 30, 2007. [9] M. \nBiernacka, D. Biernacki, and O. Danvy. An operational foundation for delimited continuations in the CPS \nhierarchy. Logical Methods in Computer Science, 1(2:5):1 39, Nov. 2005. A preliminary version was presented \nat the Fourth ACM SIGPLAN Workshop on Continuations (CW 04). [10] D. Biernacki, O. Danvy, and K. Millikin. \nA dynamic continuation\u00adpassing style for dynamic delimited continuations. Technical Report BRICS RS-05-16, \nDAIMI, Department of Computer Science, Aarhus University, Aarhus, Denmark, May 2005. [11] P. Cousot and \nR. Cousot. Abstract interpretation: a uni.ed lattice model for static analysis of programs by construction \nor approxima\u00adtion of .xpoints. In R. Sethi, editor, Proceedings of the Fourth Annual ACM Symposium on \nPrinciples of Programming Languages, pages 238 252, Los Angeles, California, Jan. 1977. ACM Press. [12] \nO. Danvy. Type-directed partial evaluation. In G. L. Steele Jr., editor, Proceedings of the Twenty-Third \nAnnual ACM Symposium on Principles of Programming Languages, pages 242 257, St. Petersburg Beach, Florida, \nJan. 1996. ACM Press. [13] O. Danvy and A. Filinski. A functional abstraction of typed contexts. DIKU \nRapport 89/12, DIKU, Computer Science Department, Univer\u00adsity of Copenhagen, Copenhagen, Denmark, July \n1989. [14] O. Danvy and A. Filinski. Abstracting control. In M. Wand, editor, Proceedings of the 1990 \nACM Conference on Lisp and Functional Programming, pages 151 160, Nice, France, June 1990. ACM Press. \n[15] P. Dybjer and A. Filinski. Normalization and partial evaluation. In G. Barthe, P. Dybjer, L. Pinto, \nand J. Saraiva, editors, Applied Seman\u00adtics Advanced Lectures, number 2395 in Lecture Notes in Computer \nScience, pages 137 192, Caminha, Portugal, Sept. 2000. Springer-Verlag.  [16] R. K. Dybvig, S. Peyton-Jones, \nand A. Sabry. A monadic framework for delimited continuations. Journal of Functional Programming, 17 \n(6):687 730, 2007. [17] M. Felleisen. The theory and practice of .rst-class prompts. In J. Ferrante and \nP. Mager, editors, Proceedings of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, \npages 180 190, San Diego, California, Jan. 1988. ACM Press. [18] A. Filinski. Representing monads. In \nH.-J. Boehm, editor, Proceed\u00adings of the Twenty-First Annual ACM Symposium on Principles of Pro\u00adgramming \nLanguages, pages 446 457, Portland, Oregon, Jan. 1994. ACM Press. [19] A. Filinski. Representing layered \nmonads. In A. Aiken, editor, Pro\u00adceedings of the Twenty-Sixth Annual ACM Symposium on Principles of Programming \nLanguages, pages 175 188, San Antonio, Texas, Jan. 1999. ACM Press. [20] R. Harper, B. F. Duba, and D. \nMacQueen. Typing .rst-class continua\u00adtions in ML. Journal of Functional Programming, 3(4):465 484, Oct. \n1993. A preliminary version was presented at the Eighteenth Annual ACM Symposium on Principles of Programming \nLanguages (POPL 1991). [21] F. Henglein. Syntactic properties of polymorphic subtyping. Tech\u00adnical Report \nSemantics Report D-293, DIKU, Computer Science De\u00adpartment, University of Copenhagen, May 1996. [22] \nY. Kameyama and M. Hasegawa. A sound and complete axiomati\u00adzation of delimited continuations. In O. Shivers, \neditor, Proceedings of the 2003 ACM SIGPLAN International Conference on Functional Programming (ICFP \n03), SIGPLAN Notices, Vol. 38, No. 9, pages 177 188, Uppsala, Sweden, Aug. 2003. ACM Press. [23] R. Kelsey, \nW. Clinger, and J. Rees, editors. Revised5 report on the algorithmic language Scheme. Higher-Order and \nSymbolic Computa\u00adtion, 11(1):7 105, 1998. [24] J. Kim, K. Yi, and O. Danvy. Assessing the overhead of \nML exceptions by selective CPS transformation. In G. Morrisett, editor, Record of the 1998 ACM SIGPLAN \nWorkshop on ML and its Applications, Baltimore, Maryland, Sept. 1998. [25] O. Kiselyov and C. Shan. Delimited \ncontinuations in operating sys\u00adtems. In B. Kokinov, D. C. Richardson, T. R. Roth-Berghofer, and L. Vieu, \neditors, Modeling and Using Context, 6th International and Interdisciplinary Conference, CONTEXT 2007, \nnumber 4635 in Lec\u00adture Notes in Arti.cial Intelligence, pages 291 302, Roskilde, Den\u00admark, Aug. 2007. \nSpringer. [26] O. Kiselyov and C. Shan. A substructural type system for delimited continuations. In S. \nR. D. Rocca, editor, Typed Lambda Calculi and Applications, 8th International Conference, TLCA 2007, \nnumber 4583 in Lecture Notes in Computer Science, pages 223 239, Paris, France, June 2007. Springer-Verlag. \n[27] L. R. Nielsen. A selective CPS transformation. In S. Brookes and M. Mislove, editors, Proceedings \nof the 17th Annual Conference on Mathematical Foundations of Programming Semantics, volume 45 of Electronic \nNotes in Theoretical Computer Science, pages 201 222, Aarhus, Denmark, May 2001. Elsevier Science Publishers. \n[28] G. D. Plotkin. Call-by-name, call-by-value and the .-calculus. Theo\u00adretical Computer Science, 1:125 \n159, 1975. [29] J. C. Reynolds. De.nitional interpreters for higher-order program\u00adming languages. In \nProceedings of 25th ACM National Conference, pages 717 740, Boston, Massachusetts, 1972. Reprinted in \nHigher-Order and Symbolic Computation 11(4):363 397, 1998, with a fore\u00adword [30]. [30] J. C. Reynolds. \nDe.nitional interpreters revisited. Higher-Order and Symbolic Computation, 11(4):355 361, 1998. [31] \nT. Rompf, I. Maier, and M. Odersky. Implementing .rst-class polymorphic delimited continuations by a \ntype-directed selective cps-transform. In A. Tolmach, editor, Proceedings of the 2009 ACM SIGPLAN International \nConference on Functional Program\u00adming (ICFP 09), pages 317 328, Edinburgh, UK, Aug. 2009. ACM Press. \n[32] C. Shan. A static simulation of dynamic delimited control. Higher-Order and Symbolic Computation, \n20(4):371 401, 2007. [33] E. Sumii. An implementation of transparent migration on standard Scheme. In \nM. Felleisen, editor, Proceedings of the Workshop on Scheme and Functional Programming, Technical Report \n00-368, Rice University, pages 61 64, Montr\u00b4 eal, Canada, Sept. 2000.    \n\t\t\t", "proc_id": "2034773", "abstract": "<p>We present a type system with subtyping for first-class delimited continuations that generalizes Danvy and Filinski's type system for <i>shift</i> and <i>reset</i> by maintaining explicit information about the types of contexts in the metacontext. We exploit this generalization by considering the control operators known as <i>shift</i><sub>0</sub> and <i>reset</i><sub>0</sub> that can access arbitrary contexts in the metacontext. We use subtyping to control the level of information about the metacontext the expression actually requires and in particular to coerce pure expressions into effectful ones. For this type system we prove strong type soundness and termination of evaluation and we present a provably correct type reconstruction algorithm. We also introduce two CPS translations for <i>shift</i><sub>0</sub> and <i>reset</i><sub>0</sub>: one targeting the untyped lambda calculus, and another - type-directed - targeting the simply-typed lambda calculus. The latter translation preserves typability and is selective in that it keeps pure expressions in direct style.</p>", "authors": [{"name": "Marek Materzok", "author_profile_id": "81488671181", "affiliation": "University of Wroc&#322;aw, Wroc&#322;aw, Poland", "person_id": "P2801376", "email_address": "tilk@tilk.eu", "orcid_id": ""}, {"name": "Dariusz Biernacki", "author_profile_id": "81309492801", "affiliation": "University of Wroc&#322;aw, Wroc&#322;aw, Poland", "person_id": "P2801377", "email_address": "dabi@cs.uni.wroc.pl", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034786", "year": "2011", "article_id": "2034786", "conference": "ICFP", "title": "Subtyping delimited continuations", "url": "http://dl.acm.org/citation.cfm?id=2034786"}