{"article_publication_date": "09-19-2011", "fulltext": "\n Generalising and Dualising the Third List-Homomorphism Theorem Functional Pearl Shin-Cheng Mu Academia \nSinica,Taiwan scm@iis.sinica.edu.tw Abstract The third list-homomorphism theorem says that a function \nis a list homomorphism if it can be described as an instance of both a foldr and a foldl. We prove a \ndual theorem for unfolds and generalise both theorems to trees: if a function generating a list can be \ndescribed both as an unfoldr and an unfoldl, the list can be generated from the middle, and a function \nthat processes or builds a tree both upwards and downwards may independently process/build a subtree \nand its one-hole context. The point-free, relational formalism helps to reveal the beautiful symmetry \nhidden in the theorem. Categories and Subject Descriptors D.1.1[Programming Tech\u00adniques]: Applicative \n(Functional) Programming; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Rea\u00adsoning \nabout Programs General Terms Algorithms, Theory Keywords program derivation, third list homomorphism \ntheorem 1. Introduction As multicore hardware has become standard in recent years, par\u00adallel programming \nrekindles as an important potential application of functional programming. The skeletal parallel programming \n[3] paradigm proposes the idea of developing parallel programs by combining parallel skeletons functions \nthat capture useful paral\u00adlel programming patterns. Among the important parallel skeletons is list homomorphism \n[1], one that satis.es the equation h (xs + ys)=h xs 0h ys, which says that to compute h, one may arbitrarily \nsplit the input list into xs + ys, compute h on them recursively in parallel, and combine the results \nusing an associative operator (0). Awell-knownthird list-homomorphism theorem [6] says that a functionisalist \nhomomorphismifitcanbe describedasan instance of both foldr and foldl.For example, since sum = foldr (+) \n0 = foldl (+) 0, there exists some (0) such that sum (xs + ys)= sum xs 0sum ys, for this simple example, \n(0) happens to be Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page.To copyotherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. ICFP 11, September 19 21, 2011,Tokyo, Japan. Copyright&#38;#169;2011ACM 978-1-4503-0865-6/11/09...$10.00 \nAkimasa Morihata Tohoku University, Japan morihata@riec.tohoku.ac.jp (+)as well. One naturally wonders \nwhether (0)can be mechani\u00adcally constructed.Such methodshavebeen proposed[5,9,11],and even generalised \nto trees [10]. Less noticed, however, is that the theorem and its proof dualise very well to unfolds \non lists. Consider the functionfromTo (x, y)= [x, x +1 ...y]. One may imagine three possible implementations: \ngenerating the list from the left, from the right, and from some ar\u00adbitrary point in the middle. Is it \ntrue that anyfunction that can be de.ned as both an unfoldr and an unfoldl can be written as one that \ngenerates the list from the middle? We show in this pearl that the answer is positive. This is not onlyof \ntheoretical interestbut could alsohavea practical impact. First, there are several ef.cient algorithms \nthat are based on divide\u00adand-conquer sequence generation, such as Quicksort. Moreover, the performance \nbottleneck in distributed parallel computing often lies in data distribution. Being able to generate \nthe list anywhere allows us to distribute seeds of sublists and simultaneously generate from them, and \nthereby reduce communication costs and increase parallelism. List homomorphisms and the third list-homomorphism \ntheorem are reviewed in Section 2, before we present a dualised theorem in Section3andapplyit,in Section4,toexamples \nincluding sorting and parallel scan. In Section 5, the results are further generalised to trees, before \nwe conclude in Section 6. 2. The Third List-Homomorphism Theorem As is well known, in the world of sets \nand total functions, the equations h [] =e h (x :xs)=f. (x, h xs), (1) where e ::b and f. ::(a \u00d7b).b, \nhave a unique solution for h :: [a].b, denoted by foldr f. e.We deviate from the standard and let f. \nbe uncurried since it is more convenient in point-free style, where programs are described by function \ncomposition rather than application. In fact, we will also introduce uncurried constructor cons (x, xs)= \nx :xs, and let (f \u00d7g)(x, y)=(f x,gy), which satis.esalaw (f \u00d7g)(h \u00d7k)=(f h \u00d7g k), which we will refer \nto as product functor . Thus (1) can be written h . cons =f.. (id \u00d7h). We de.ne a variation offoldr that \ntakes the base case as an extra argument, foldrr :: ((a \u00d7b).b).([a],b).b foldrr f. ([],e)= e foldrr f. \n(x :xs,e)= f. (x, foldrr f. (xs,e)),  It can be seen as a resumed version of foldr (hence the suf.x \nr in the name), that is, if h = foldr f. e, one can easily show by induction on xs that h (xs + ys)=foldrr \nf. (xs,h ys). (2) Let cat (xs, ys)=xs + ys, (2) can be written point-free as h . cat =foldrr f.. (id \n\u00d7h). (3) Symmetrically, let snoc (xs,x)= xs + [x]. It is known that foldl f. e is the unique solution \nfor h ::[a].b in h [] =e h . snoc =f.. (h \u00d7id), where f. ::(b \u00d7a).b. De.ning resumable foldl as foldlr \n:: ((b \u00d7a).b).(b, [a]).b foldlr f. (e, []) = e foldlr f. (e, xs + [x]) = f. (foldlr f. (e, xs),x), we \nhave, if h =foldl f. e, that h . cat =foldlr f.. (h \u00d7id). (4) Afunctionh::[a].b isalist homomorphism \nif thereexist e::b, k ::a .b, and f ::(b \u00d7b).b such that h [] = e h [x]= kx h (xs + ys)= f (h xs,h ys). \nIn such a case we denote h by hom fke. The equations imply that f is associative, on the range of h, \nwith unit e.To compute a list homomorphism h, one may split the input list arbitrarily into two parts, \nrecursively compute h on both parts, and combine the results using f, implying a potential for parallel \ncomputation. If f and k are constant-time operations, a list homomorphism can be evaluated in time O(n/p \n+log p), where n is the length of the input list and p the number of processors, and we get almost linear \nspeedups with respect to p. Some famous theorems relate foldr, foldl and list homomor\u00adphisms. Firstly, \nsince the input list can be split arbitrarily, we may of course choose a biased split, reducing a list \nhomomorphism to a foldr or a foldl. Theorem 1 (the 2nd list-hom. theorem [1]). If h = hom fke then h \n= foldr f. e =foldl f. e, where f. (x, v)=f (k x,v)and f. (v, x)=f (v,k x). Somewhat surprisingly,ifa \nfunction canbe computed bothbya foldr and a foldl, it is a list homomorphism. Theorem 2 (the 3rd list-hom. \ntheorem [6]). h = foldr f. e = foldl f. e implies h =hom fke for some f and k. Proof. The only possible \nchoice for k is kx =h [x]. The aim is to .nd f such that hcat =f (h\u00d7h).Afunction f-1 is calledaright \ninverse of f if for all y in the range of f, we have f (f-1 y)= y. Equivalently, f . f-1 . f = f. In \na set-theoretical model, a right inversealwaysexistsbutmay notbe unique. While a semantical proof was \ngiven by Gibbons [6], we will providea proofhavinga more equational .avour.We reason: h . cat ={ (3) \n} foldrr f.. (id \u00d7h) ={ h =h . h-1 . h, product functor } foldrr f.. (id \u00d7h). (id \u00d7h-1). (id \u00d7h) ={ (3) \nbackwards, and (4) } foldlr f.. (h \u00d7id). (id \u00d7h-1). (id \u00d7h) ={ h =h . h-1 . h, product functor } foldlr \nf.. (h \u00d7id). (h-1 \u00d7h-1). (h \u00d7h) ={ (4) backwards } h . cat . (h-1 \u00d7h-1). (h \u00d7h). Thus the theorem holds \nif we pick f =h . cat . (h-1 \u00d7h-1). Theorem2 infact provides hints how to construct list homomor\u00adphisms. \nFor example, since sum = foldr (+) 0 = foldl (+) 0, Theorem2 states that sum can be written as sum = \nhom fk 0 where kx = sum [x]= x and f (v, w)= sum (gv + gw) for anyright inverse g of sum. One may simply \npick gx =[x], and f (v, w)simpli.es to v +w. Readers might have noticed something odd in the proof: the \nproperty much talked about, that h being both a foldr and a foldl, could be weakened properties (3) \nand (4) were merely used to push h to the right. Infact, h . cat is never expanded in the proof. One \nthuswonders whether thereis something more generalwaiting to be discovered, which is indeed what we will \nsee in the follow\u00ading sections. The syntactical approach makes such generalisations much easier to spot. \n3. Dual of Third List-Homomorphism Theorem The function unfoldr, a dual of foldr that generates a list \nfrom left to right, may be de.ned as follows. 1 unfoldr :: (b .(a, b)).(b .Bool).b .[a] unfoldr g. pv \n| pv =[]|(x, v ').g. v =x :unfoldr g. pv ' . Symmetrically, the function unfoldl is de.ned by unfoldl \n:: (b .(b, a)).(b .Bool).b .[a] unfoldl g. pv | pv =[] '' + [x]. |(v ,x).g. v =unfoldl g. pv Typically, \nunfolds are de.ned for coinductive, possibly in.nite lists. Since we want the unfolded lists to have \nboth a left end and a right end, and for another important technical reason to be mentioned later, our \nunfolds in this pearl return inductive, .nite lists and require separate proofs that all successive applications \nof g. and g. eventually reaches some v for which pv is true. Due to space constraints, however, the proof \nof termination is usually treated informally. Finally, we denote a function k ::b .[a]by unhom gf pq \nif it satis.es kv | pv =[]| qv =[fv]|(v1,v2).gv =kv1 + kv2. 1The pattern guard (x, v ').g. v matches \nthe result of g. in the guard.  We also demand that successive applications ofg eventually pro\u00adduce \nseeds for which either p or q is true, and thus k generates .nite lists. Regrettably, Theorem1does not \ndualise to unfolds. Lemma 3. There exists h such that h =unhom gf pq for which there exist neither g. \nsatisfying h =unfoldr g. p nor g. satisfying h =unfoldl g. p. Proof. Let exp :: Int .[Int] generate a \nlist of 1 s of length 2n for given n. It can be de.ned by unhom gf pq where f 0 = 1, q =(0 ==), p =(0 \n>), and g (1 +n)=(n, n), but not by an unfoldr or unfoldl. An intuitive reason is that there is not always \nan m such that 2n -1 =2m. One may use the theories of Gibbons et al. [7] for a proof. Does Theorem2have \nan unfold counterpart?To establish that ' k = unhom gfp q given k = unfoldr g. p = unfoldl g. p, we ' \ncan pick p =p, q =psnd g., and f =fst g.. The challenge is to construct g.To do so, we introduce some \nconcepts dual to those for folds. While foldrr and foldlr resume a partially computed fold, their duals \npause during generation of lists. During the generation of a list there are manyplaces where we may pause. \nThe following functions unfoldrp and unfoldlp ( p for pause) return, in a list, all intermediate lists \nand seeds during list generation: unfoldrp :: (b .(a, b)).(b .Bool).b .[([a],b)] unfoldrp g. pv = iter. \n([],v) where iter. (xs,v)|pv =[(xs,v)]|(x, v ').g. v =(xs,v):iter. (xs + [x],v '), unfoldlp :: (b .(b, \na)).(b .Bool).b .[(b, [a])] unfoldlp g. pv = iter. (v, []) where iter. (v, xs)|pv =[(v, xs)]|(v ' ,x).g. \nv =iter. (v ' ,x :xs)+ [(v, xs)]. We may think of them as returning the traces of unfolding.For example, \nunfoldrp g. pv0 yields the list [([],v0), ([x1],v1),([x1,x2],v2)...], etc, if (xi+1,vi+1)=g. vi. A crucial \nproperty relating unfoldr and unfoldrp is that if k =unfoldr g. p we have splits . k =map (id \u00d7k). unfoldrp \ng. p, (5) where splits ::[a].([a], [a])returns all the splits of thegiven list (e.g. splits [1, 2]=[([], \n[1, 2]), ([1], [2]), ([1, 2], [])]). Sim\u00adilarly, we have that splits . k =map (k \u00d7id). unfoldlp g. p, \n(6) if k = unfoldl g. p. Notice how theyroughly resemble the con\u00adverses of (3) and (4): functions next \nto the composition () are swapped; instead of f cat we have splits k on the left hand sides of the equalities; \n(id \u00d7k)in (5) is on the lefthand side of (), and is lifted to lists by map due to the type, etc. A relational \nperspective We could have proceeded from (5) and (6) to construct g and thereby prove the dual theorem. \nHowever, we would like to take a bold approach and ask the readers to see paused unfolding as a relation. \nFunctional programmers appear to regard relations as an arcane creation, which is an unfortunate misunderstanding. \nDijkstra argued that, for program derivation, non-determinism should be the norm and determinism a special \ncase [4], and this pearl is indeed a case where one has to bring up relations to appreciate the nice \nduality between the theorems for folding and unfolding. For this pearl we need only a one-paragraph introduction \nto relations.Afunction f ::a .b isasubsetof (b\u00d7a)where (y, x).f means that x is mapped to y by f, or \ny is a result to which f maps the argument x, with the constraint that (y, x).f and (y ' ,x). f implies \ny =y ' . The constraint is relaxed for relations, allowing x to be mapped to multiple ys. Composition \nof relations is de.ned by (z, x).(R . S) = (.y ::(z, y).R .(y, x).S). Given R ::a .b, its converse R. \n::b .a is de.ned by (x, y). R. =(y, x). R. We have (R.). = R, id. = id, and that converse distributes \ncovariantly over product, and contravariantly over composition: (R \u00d7S). =(R. \u00d7S.), (R . S). =S. . R. \n. In this pearl we view unfolds as the relational converse of folds, which is another reason whywe restrict \nourselves to .nite lists our unfolds are actually converses of folds in disguise, and an unhom is the \nrelational converse of a list homomorphism. Let the relation mem :: [a]. a relate a list to any of its \nmembers, and let unfr g. p =mem . unfoldrp g. p, un. g. p =mem . unfoldlp g. p. While unfoldrp and unfoldlp \ngenerate the entire trace, unfr and un. map the input seed to one arbitrary intermediate state. That \nis, unfr g. p maps v0 to each of ([],v0), ([x1],v1), ([x1,x2],v2), etc., if (xi+1,vi+1)= g. vi. The equality \n(5) can be expressed relationally if k =unfoldr g. p we have cat . . k =(id \u00d7k). unfr g. p. (7) Both \nsides relate the input seed, say v, toa pair of lists. On the left hand side, the list returned by kv \nis arbitrarily split into (xs, ys). The equation says that xs + ys = kv if and only if xs can be generated \nby unfr g. p and ys can be generated by k starting from where unfr g. p left off.For k = unfoldl g. p, \na symmetric property holds: cat . . k =(k \u00d7id). un. g. p. (8) Recall that our aim is to construct g. \nIt suf.ces to .nd a g such that cat . . k =(k \u00d7k). g. That is, kv = xs + ys if and only if xs and ys \ncan be generated from seeds produced by gv. Notice thatby applying the converse operator (). to both \nsides of (7) and (8), we get equations that are almost (3) and (4) apart from having converses of k and \nunfolds in the formulae: k. . cat =(unfr g. p). . (id \u00d7k.), k. . cat =(un. g. p). . (k. \u00d7id). The proof \nof Theorem 2, however, proceeds the same way even if the components are not functions! In the realm of \nrelations, part of the proofof Theorem2canbe generalised to: Theorem 4. If R . cat = S.. (id \u00d7 R)= S.. \n(R \u00d7 id) and RR ' R =R for some R ' ,thenRcat =Rcat(R.\u00d7R.)(R\u00d7R). Proof. The same as that of Theorem 2. \nWe will prove a more general Theorem7later. The desired dual theorem thus follows: Corollary 5. If k \n= unhom gfpq for some g, f, and q, then k =unfoldr g. p =unfoldl g. p. Proof. We have talked about f \nand q, and now we aim to .nd g such that cat. . k =(k \u00d7k). g. Using (7) and (8) as antecedents of Theorem \n4, we get cat . . k =(k \u00d7k). (k. \u00d7k.). cat . . k, thus g can be anyfunctional subset of (k. \u00d7k.). cat. \n. k.  Figure 1. Depicting ((k.\u00d7id)unfr g. p)n((id \u00d7k.)un. g. p). Calculating g Theexpression (k.\u00d7k.)cat.k, \nhowever, is not easy to simplify.To calculate g we often usea lemma that,ifk = unfoldr g. p =unfoldl \ng. p, we can re.ne (k. \u00d7k.). cat. . k to ((k. \u00d7id). unfr g. p)n((id \u00d7k.). un. g. p). For readers who \nare notfamiliar with intersection and converses, Figure 1 offers some intuition. Given a seed v, unfr \ng. p and un. g. p non-deterministically pause somewhere and respectively generate (xs,v2) and (v1, ys). \nThe intersection means that they stop when they meet in the middle , that is, when kv1 = xs and kv2 =ys. \nThe new pair of seeds, a possible result of g, is (v1,v2). The lemma has a functional formulation that \nmay be more friendly to readers. Writing the list membership predicate elem :: a .[a]. Bool in the Haskell \nStandard Prelude in in.x position as (.), we have, Lemma 6. Assume that k = unfoldr g. p = unfoldl g. \np. A function g is a subset of (k. \u00d7 k.) . cat. . k if, for all v, gv =(v1,v2)where v1 and v2 satisfy \n(kv1,v2).unfoldrp g. pv and (v1,k v2).unfoldlp g. p. From now on we will use Lemma 6 and restrict ourselves \nto functions when we calculate g. 4. Generating Sequences from Middle In this section we look at two \nexamples using the dual theorem for list generation. 4.1 Quicksort While Gibbons [6] demonstrated how \nto derive merge sort from insertion sort using the third list homomorphism theorem, we use the dual theorem \nto derive quicksort from selection sort. 2 We regard the input as a set and denote disjoint union by \n.. One may come up with two de.nitions of selection sort: sort = unfoldr g. p =unfoldl g. p, where p \n=null and g. zs |zs =/\u00d8,x .min zs =(x, zs -{x}), g. zs |zs =/\u00d8,x .max zs =(zs -{x},x). Let xs =.ys =(.x \n.xs,y .ys ::x =y). One can see that (sort xs, ys).unfoldrp g. p zs, (xs, sort ys).unfoldlp g. p zs, if \nxs .ys = zs and xs =.ys.We show only the proof of the .rst membership, for which we show that (ws + sort \nxs, ys).iter. (ws, zs).xs .ys =zs .xs =.ys. (9) Property (9) can be proved by induction on the size of \nzs. For zs =\u00d8 the property trivially holds. The nonempty case is shown in Figure 2. By Lemma 6 we may \nthus choose g zs =(xs, ys) for any xs .ys = zs .xs =.ys. That is, we split the set zs into two, such \nthat all elements in one set are no larger than any element in the 2What we derive here, however, is \nthe toy Quicksort well-known among functional programmers. It is arguable that the essence of real Quicksort \nis the algorithm for partition, which is not addressed here. (ws + sort xs, ys).iter. (ws, zs) ={ zs \n=/\u00d8, let z =min zs } (ws + sort xs, ys)=(ws, zs). (ws + sort xs, ys).iter. (ws + [z], zs -{z}) . { for \nnon-empty xs, let x =min xs } (xs =\u00d8.ys =zs). (ws + [x]+ sort (xs -{x}), ys).iter. (ws + [z], zs -{z}) \n . { induction } (xs =\u00d8.ys =zs). ((xs -{x}.ys =zs -{z}.xs =.ys .x =z)  = xs .ys =zs .xs =.ys. (ws + \ns (e, xs), (e .r xs, ys)).iter. (ws, (e, z :zs)) =(ws + s (e, xs), (e .r xs, ys))=(ws, (e, z :zs)). (ws \n+ s (e, xs), (e .r xs, ys)).iter. (ws + [e], (e .z, zs)) ' . { let xs =x :xs for the non-empty case } \n(xs =[].ys =z :zs). ' (ws + [e]+ s (e .x, xs '), (e .x .r xs , ys)). iter. (ws + [e], (e .z, zs)) .{ \ninduction } (xs =[].ys =z :zs).(xs ' + ys =zs .x =z) = xs + ys =z :zs. Figure 2. Proofs of properties \n(9) and (10). In the latter proof, scan and reduce are respectively abbreviated to s and r. other set, \nand sort them recursively. Thatgives rise to the equation, sort (xs .ys)|xs =.ys = sort xs + sort ys. \nDespite being valid, the equation does not form a de.nition as a program sort might not terminate since, \nfor example, xs could be empty and the size of ys equals that of zs.For this example, one may come up \nwith a terminating de.nition by enforcing that the neither xs nor ys is empty.We thus have sort = unhom \ngf pq where g zs =(xs, ys) for some non-empty xs and ys such that xs .ys =zs .xs =.ys, f {x}=x, p xs \n=xs =\u00d8, and q xs holds if xs is singleton. By unfolding sort by one step we come up with the de.nition \nsort \u00d8 =[] sort (xs .{x}.ys)| xs =.{x}=.ys = sort xs + [x]+ sort ys.  4.2 Parallel Scan It is known \nthat the Haskell prelude function scanl (.) e, when (.)is associative and e =i., the unit of (.), is \nboth a foldr and a foldl. Geser and Gorlatch[5]infact showedhow the following list homomorphism can be \nderived using the third list homomorphism theorem: scanl (.)i. (xs + ys)| xs ' + [x].scanl (.)i. xs = \nxs ' + [x]+ map (x.)(scanl (.)i. ys). Inan actual implementation,however, onewouldliketoavoidhav\u00ading \nto perform map (x.). Here we demonstrate that an attention to unfolds leadstoafaster program. Fora concise \npresentationweagain considera slightlydifferent variation. The following scan discards the right-most \nelement of the input list:  scan (e, []) =[] scan (e, x :xs)= e :scan (e .x, xs). Forexample,scan (e, \n[1, 2, 3])=[e, e.1,e.1.2]. It is not hard to showthat scan (e, xs + [x]) = scan (e, xs)+ [e .reduce xs], \n where reduce =hom (.)id i..Wethus havescan =unfoldr g. p = unfoldl g. p, where p =null . snd and g. \n(e, x :xs) =(e, (e .x, xs)), g. (e, xs + [ ]) = ((e, xs),e .reduce xs), where the domains of g. and g. \nare pairs whose second components are non-empty. To constructg, we show that for xs + ys =zs we have \n(scan (e, xs), (e .reduce xs, ys)).unfoldrp g. p (e, zs), ((e, xs), scan (e .reduce xs, ys)).unfoldlp \ng. p (e, zs). Again we prove only the .rst property, for which we need to prove a slight generalisation, \n(ws + scan (e, xs), (e .reduce xs, ys)).iter. (ws, (e, zs)), (10) if xs + ys =zs. The proof is an uninteresting \ninduction on zs, and the inductive case is shown in Figure 2. Thus we pick g (e, zs) = ((e, xs), (e . \nreduce xs, ys)) for some xs + ys = zs.For termination we want xs and ys to be both non-empty, which gives \nrise to the de.nition scan (e, []) =[] scan (e, [x]) =[e] scan (e, xs + ys)| xs =/[].ys =/[] = scan (e, \nxs)+ scan (e .reduce xs, ys). Thisisnotyetanef.cient implementation.Toavoid repeated calls to reduce, \none typically performs a tupling. Let sr (e, xs)=(scan (e, xs), reduce xs). One may calculate a de.nition \nfor sr: sr (e, []) = ([],i.) sr (e, [x]) =([e],x) sr (e, xs + ys)| xs =/[].ys =/[] = let (s1,r1)=sr (e, \nxs)(s2,r2)=sr (e .r1, ys) in (s1 + s2,r1 .r2). However, the second call to sr in the xs + ys case demands \nthe value ofr1, whichisaresultofthe .rstcallto sr. This prevents the two calls to sr from being executed \nin parallel. Instead, we compute scan in two phases: all the r s are .rst computed and cached, which \nare then used in the second phase to compute scan. For that we need a data structure storing the r s. \nConsider the following binary tree, with a function val extracting the value at the root, data Tree a \n=L a |N (Tree a)a (Tree a), val (L n)=n val (N n )=n. The following functionbuildsa tree outofa non-empty \nlist, with the invariant that val (build xs)=reduce xs: build [x]= L x build (xs + ys)| xs =/[].ys =/[] \n= let t =build xs; u =build ys in N t (val t .val u)u. Thekeyto construct an ef.cient implementation \nof scan is to perform build in a separate phase and use only the results stored in the tree. That is, \nwe wish to construct some function f such that scan (e, xs)=f (e, build xs). The singleton case is easy: \nf (e, L x)=[e].For inputs of length at least two, we calculate (for non-empty xs and ys): scan (e, xs \n+ ys) = scan (e, xs)+ scan (e .reduce xs, ys) ={ since val (build xs)=reduce xs } scan (e, xs)+ scan \n(e .val (build xs), ys) ={ induction: scan (e, xs)=f (e, build xs)} f (e, build xs)+ f (e .val (build \nxs), build ys) ={ let N tvu =build (xs + ys)} f (e, t)+ f (e .val t, u) ={ let f (e, N tu)=f (e, t)+ \nf (e .val t, u)} f (e, build (xs + ys)). We renamef to acc since it accumulates the result: scan (e, \n[]) =[] scan (e, xs)= acc (e, build xs), acc (e, L x) =[e] acc (e, N tu)= acc (e, t)+ acc (e .val t, \nu). By constructing a balanced binary tree, the evaluation can be per\u00adformed in O(log n) time given a \nsuf.cient number of processors, or in O(n/p + log p) time if p \u00ab n where p is the number of processors. \nWe have in fact reconstructed a well-known ef.cient implementation of scan recorded by, for example, \nBlelloch [2]. 5. Generalising to Trees As mentioned earlier, when looking at the proof of Theorem2in \ndetail, one notices that further generalisation is possible. Indeed, the presence of R cat in Theorem4is \nsuper.cial,andthe theorem can still be generalised. Theorem 7. R =U . (id \u00d7S)=V . (T \u00d7id), S . S. . S \n=S, and T . T . . T =T imply R =R . (T . \u00d7S.). (T \u00d7S). Proof. R = U . (id \u00d7S) = U . (id \u00d7S). (id \u00d7S.). \n(id \u00d7S) = R . (id \u00d7S.). (id \u00d7S) = V . (T \u00d7id). (id \u00d7S.). (id \u00d7S) = V . (T \u00d7id). (T . \u00d7S.). (T \u00d7S) = R \n. (T . \u00d7S.). (T \u00d7S). However, the conclusion of the theorem, that R = R . (T . \u00d7 S.). (T \u00d7S), does not \nhave much structure hinting at how this theorem can be useful. The use-cases we found are when S is a \nsub-expression of R (for example, to prove Corollary 5, we used R =k. . cat and S =T =k..We do not require \nS =T in general), and we use Theorem 7 to establish recursive equations about S, hoping to construct \na terminating de.nition of S. 5.1 Third Homomorphism Theorem on Trees Revisited Consider the Tree datatype \nde.ned in Section 4.2 and assume that we wish to ef.ciently compute a function on trees by distributing \nthe work to multiple processors. One slight annoyance is that split\u00ading a tree into two at an arbitrary \npoint yields not two trees, but one tree and a context containing a single hole that can be .lled by \na tree. The concept of contexts of a datatype was proposed by Huet [8] as the zipper. In particular, \nthe context for Tree can be modelled by  type Cxt a =[Za], data Za = Nl a (Tree a)| Nr (Tree a)a, with \na function .ll ::(Cxt a, Tree a). Tree a that .lls the hole of the contextbya tree: .ll ([],t)= t .ll \n(Nl xu :xs,t)= .ll (xs, N txu) .ll (Nr tx :xs,u)= .ll (xs, N txu). For example, consider the tree t =N \n(N (L 1)2 (L 3))4 (N (N (L 5)6 (L 7))8 (L 9)). What remains after taking out the subtree u =N (L 5)6 \n(L 7)is cx =[Nl 8 (L 9), Nr (N (L 1)2 (L 3))4], with .ll (cx,u)=t. To parallelise a function f :: Tree \na . b, we must have a variation f ' :: Cxt a . b de.ned on contexts. Instantiating R, ' S, and T in Theorem7 \nrespectively to f . .ll, f, and f , we see ' that ft can be computed in terms of f cx and fu, ' f . .ll \n=f . .ll . (f '. \u00d7f.). (f \u00d7f), if there exist U and V such that f . .ll =U . (id \u00d7f). (11) f . .ll =V \n. (f ' \u00d7id). (12) Equation (11) basically says that f is outwards f (.ll (cx,u)) can be computed from \ncx and fu, while (12) says that f is also inwards f (.ll (cx,u)) can be computed from f ' cx and u. \nThis is another way to view the previous work of Morihata et al. [10].  5.2 Generating Trees from the \nMiddle One naturally wonders whether the result can also be dualised to generating trees rather than \nconsuming them. Again the answer is yes: if a tree can be generated both upwards and downwards, it can \nbe generated from the middle. We will formalise what we mean below. Let b bethetypeof seeds. Unfoldingatreedownwardsfromthe \nroot using a function g. ::b .(b, a, b)is relativelyfamiliar: unf. :: (b .(b, a, b),b .a, b .Bool).b \n.Tree a unf. (fs@(g.,f.,p))v |pv = L (f. v) |(v1, x, v2).g. v = N (unf. fs v1)x (unf. fs v2). As in the \ncase of lists, our unfolds are actually converses of folds in disguise and are well-de.ned only if theyterminate \nand produce .nite trees.Weconsider pausedversionsof unfolding, which yields(Cxt a, b), a context and \na seed. The function unfp. returns a list containing all such pairs of contexts and seeds: unfp. :: (b \n.(b, a, b),b .a, b .Bool).b .[(Cxt a, b)] unfp. (fs@(g.,f.,p))v = iter. ([],v), where iter. (xs,v)|pv \n=[(xs,v)]|(v1, x, v2).g. v = (xs,v):iter. (Nl x (unf. fs v2):xs,v1)+ iter. (Nr (unf. fs v1)x :xs,v2). \nWith the de.nition we have, fork =unf. (g.,f.,p), that .ll. . k =(id \u00d7k). mem . unfp. (g.,f.,p). (13) \nBygeneratingatree fromthemiddle wemeanto.nd g ::b . (b, b)and k ' ::b .Cxt a such that kv |pv =L (f. \nv)|(v.,v.).gv =.ll (k ' v.)(kv.). That is, the tree returned by k, if not a leaf, can be split into a \ncontextanda subtreethat canbe generated separatelyfromthetwo ' seeds returned by g. It suf.ces for g \nand k to satisfy .ll. . k =(k ' \u00d7k). g. Generating a tree upwards intuitively means to start from a leafand.ndthepathbacktothe \nroot.With applicationof Theorem 7inmind,wewantto comeupwithafunctionunfp. (g.,f.)::b . [(b, Tree a)]that \nsatis.es, for some k ' , .ll. . k =(k ' \u00d7id). mem . unfp. (g.,f.), (14) thus each of (13) and (14) matches \none antecedent of Theorem 7. To growa tree upwards froma leaf, we usea functiong. having type G. ab = \nb . [(b, (a, b)+(b, a))] (where data a + b = Lt a | Rt b). If g. v is empty, we have reached the root. \nIf it contains (v ' , Lt (x, vr)), we go up by using the current tree as ' the left child, vr the seed \nfor the right child, and v the seed going up. Similarly with Rt. We could have grown a Tree a. To reuse \nthe function later, however, we grow a context instead. De.ne cxtp. g. ::b .[(b, Cxt a)]that generates \nall (seed, context) pairs when one goes upwards: cxtp. g. v =iter. (v, []), where iter. (v, cx)=(v, cx):[y \n|(v ' , lr).g. v, y .iter. (v ' , cx + [up lr])], up (Lt (x, vr))=Nl x (kvr) up (Rt (vl,x))=Nr (kvl)x. \nTo generate all the splits, we need to be able to start from anyleaf. Thus we let f. ::b .[(b, a)]return \nthe list of values on each leaf, paired witha seedtogoup with.Wemay then de.ne unfp. by unfp. :: (G. \na b,b .[(b, a)]).b .[(b, Tree a)] unfp. (g.,f.)v =[(v '' , .ll (cx, L x))|(v ' ,x).f. v, (v '' , cx).cxtp. \ng. v ']. While cxtp. and unfp. return the entire history of upwards tree generation, their non-pausing \nversion, cxt. and unf., keep only completed contexts and trees (those which have reached the root): cxt. \ng. v =[cx |(v ' , cx).cxtp. g. v, null (pv ')], unf. (g.,f.)v =[t |(v ' , t).unfp. (g.,f.)v, null (pv \n')]. Equation (14) is satis.able if k =mem unf. (g.,f.)isa function (that is, all routes from leaves \nto the root yields the same tree), and ' k =mem . cxt. g. v. With (13) and (14), we therefore obtain \nfrom Theorem7that ' .ll. . k =(k \u00d7k). (k '. \u00d7k.). .ll. . k, if k = unf. (g.,f.,p)= mem . unf. (g.,f.) \nand k ' = mem . cxt. g. v.To compute k from the middle , we may pick g to be a subset of (k '. \u00d7k.). \n.ll. . k. 6. Conclusions By formulating the third list homomorphism theorem in point-free, relational \nstyle, we have dualised the theorem to unfolds, as well as generalised the theorem to both folds and \nunfolds for trees. While the original theorem establishes a connection between insertion sort and merge \nsort, the dual theorem shows a similar connection between selection sort and quicksort. We have also \nderived an ef.cient parallel algorithm for scan based on unfolds.To the best of the authors knowledge, \nwhile there has been many studies on parallel programming based on structural recursion, none have considered \nthe dual list generation in the form of unhom.  The theorem generalises nicely to trees: if a function \nprocesses or generatesa tree bothdownwardsandupwards,itmay processor generate the tree from the middle. \nFinally, we have also presented an example that shows how a relational view may shed new light on an \nold topic by revealing its hidden symmetry. The authors believe that relational methods deserve to be \nappreciated more among functional programmers. As a remark, in practice, for both list and tree generation \none might need different types of seeds for left/right or inwards/outwards unfolding. That is, we have \nk =unfoldr g. pi1 =unfoldl g. pi2 or k =unf. fs. . i1 =unf. fs. . i2, for some i1 and i2 that initialise \nthe seeds. Thisis alsocoveredby Theorem7.Weleaveittothe readers to work out the details. Acknowledgements \nThe authorswouldliketothankJeremyGib\u00adbons, Jos\u00b4ander for comments on e Nuno Oliveira, and JanisVoigtl\u00a8earlier \ndrafts,andtothe anonymous refereesfor theirvaluable com\u00adments. This pearlwas inspiredbyaquestion proposedbyZhenjiang \nHu, who also cooperated with the authors throughout the develop\u00adment of this paper and made plenty of \nimportant technical contri\u00adbutions. References [1] R. S. Bird. An introduction to the theory of lists. \nIn M. Broy, editor, Logic of Programming and Calculi of Discrete Design, volume 36 of NATO ASI Series \nF, pages 3 42. Springer-Verlag, NewYork, NY, USA, 1987. Technical Monograph PRG-56. [2] G. E. Blelloch. \nPre.x sums and their applications. In J. E. Reif, editor, Synthesis of Parallel Algorithms. Morgan Kaufmann \nPublishers Inc., San Francisco, CA, USA, 1993. [3] M. I. Cole. Algorithmic Skeletons: Structural Management \nof Parallel Computation. MIT Press, 1989. [4] E. W. Dijkstra. A Discipline of Programming. Prentice Hall \nPTR, 1976. [5] A. Geser andS. Gorlatch.Parallelizing functional programsby gener\u00adalization. Journal of \nFunctional Programming, 9(6):649 673, 1999. [6] J. Gibbons. The third homomorphism theorem. Journal of \nFunctional Programming, 6(4):657 665, 1996. [7] J. Gibbons,G. Hutton, andT. Altenkirch. Whenisa functiona \nfold or an unfold? Electr. Notes Theor. Comput. Sci., 44(1), 2001. [8] G.P. Huet. The zipper. Journal \nof Functional Programming, 7(5): 549 554, 1997. [9] A. Morihata, K. Matsuzaki, Z. Hu, and M.Takeichi. \nProgram paral\u00adlelizationbycandidate generation and conformity testing. IPSJ Trans\u00adaction on Programming, \n2(2):132 143, 2009. (In Japanese). [10]A. Morihata,K. Matsuzaki,Z.Hu,andM.Takeichi. The third homo\u00admorphism \ntheoremon trees:Downward&#38;upwardleadtodivide-and\u00adconquer. In Proceedings of the 36th ACM SIGPLAN-SIGACT \nSym\u00adposium on Principles of Programming Languages, POPL 2009, Sa\u00advannah, Georgia, USA, January 21-23, \n2009, pages 177 185.ACM, 2009. [11] K. Morita, A. Morihata, K. Matsuzaki, Z. Hu, and M.Takeichi. Au\u00adtomatic \ninversion generates divide-and-conquer parallel programs. In J. Ferrante and K. S. McKinley, editors, \nProceedings of the ACM SIG-PLAN 2007 Conference on Programming Language Design and Im\u00adplementation, San \nDiego, California, USA, June 10-13, 2007, pages 146 155.ACM, 2007.   \n\t\t\t", "proc_id": "2034773", "abstract": "<p>The third list-homomorphism theorem says that a function is a list homomorphism if it can be described as an instance of both a <i>foldr</i> and a <i>foldl</i>. We prove a dual theorem for unfolds and generalise both theorems to trees: if a function generating a list can be described both as an <i>unfoldr</i> and an <i>unfoldl</i>, the list can be generated from the middle, and a function that processes or builds a tree both upwards and downwards may independently process/build a subtree and its one-hole context. The point-free, relational formalism helps to reveal the beautiful symmetry hidden in the theorem.</p>", "authors": [{"name": "Shin-Cheng Mu", "author_profile_id": "81100208164", "affiliation": "Academia Sinica, Taipei, Taiwan Roc", "person_id": "P2801448", "email_address": "scm@iis.sinica.edu.tw", "orcid_id": ""}, {"name": "Akimasa Morihata", "author_profile_id": "81372591868", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P2801449", "email_address": "morihata@riec.tohoku.ac.jp", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034824", "year": "2011", "article_id": "2034824", "conference": "ICFP", "title": "Generalising and dualising the third list-homomorphism theorem: functional pearl", "url": "http://dl.acm.org/citation.cfm?id=2034824"}