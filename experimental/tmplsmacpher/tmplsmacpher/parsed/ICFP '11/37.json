{"article_publication_date": "09-19-2011", "fulltext": "\n CharacteristicFormulaefor the Veri.cation of Imperative Programs Arthur Chargu\u00e9raud Max Planck Institute \nfor Software Systems (MPI-SWS) charguer@mpi-sws.org Abstract In previous work, we introduced an approach \nto program veri.\u00adcation based on characteristic formulae. The approach consists of generating a higher-order \nlogic formula from the source code of a program. This characteristic formula is constructed in such a \nway that it gives a sound and complete description of the semantics of that program. The formula can \nthus be exploited in an interactive proof assistant to formally verify that the program satis.es a par\u00adticular \nspeci.cation. This previous work was, however, only concerned with purely\u00adfunctional programs. In the \npresent paper, we describe the gener\u00adalization of characteristic formulae to an imperative programming \nlanguage. In this setting, characteristic formulae involve speci.ca\u00adtions expressed in the style of Separation \nLogic. They also inte\u00adgrate the frame rule, which enables local reasoning.We have im\u00adplementeda tool \nbased on characteristic formulae. This tool, called CFML, supports the veri.cation of imperative Caml \nprograms us\u00ading the Coq proof assistant. Using CFML, we have formally ver\u00adi.ed nontrivial imperative \nalgorithms, as well as CPS functions, higher-order iterators, and programs involving higher-order stores. \nCategories and Subject Descriptors D.2.4 [Software/Program Veri.cation]:Formal methods GeneralTerms Veri.cation \n1. Introduction This paper addresses the problemofbuilding formal proofsof cor\u00adrectness for higher-order \nimperative programs. It describes an ef\u00adfective technique for verifying that a program satis.es a speci.ca\u00adtion, \nand for proving termination of that program. This technique supports the veri.cation of arbitrarily-complex \nproperties, thanks to the use of an interactive proof assistant based on higher-order logic. The work \ndescribed in this paper is based on the notion of characteristic formula ofa program.Acharacteristic \nformulaisa higher-order logic formula that fully characterizes the semantics of a program, and may thus \nbe used to prove properties about the be\u00adhavior of that program. Inpreviouswork,wehaveshownhowtobuildandexploit \nchar\u00adacteristic formulae for purely-functional programs [9]. In this pa\u00adper, we extend those results \nto an imperative programming lan- Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. ICFP 11, September 19 21, 2011,Tokyo, Japan. Copyright&#38;#169;2011ACM 978-1-4503-0865-6/11/09... \n$10.00 guage. Let [t] denote the characteristic formula of a imperative term t. The application of the \npredicate [t] toapre-condition H and to a post-condition Q yields the proposition [t] HQ. By construc\u00adtion \nof characteristic formulae, this proposition is true if and only if the term t admits H as pre-condition \nand Q as post-condition. The proposition [t] HQ may be established through interactive proofs, using \na combination of general-purpose tactics and tactics special\u00adized for the manipulation of characteristic \nformulae. Characteristic formulae are designed to be easily readable and easily manipulable from inside \nan interactive proof assistant. A characteristic formula has a size linear in that of the program it \ndescribes. Moreover, a characteristic formula can be displayed in a way that closely resembles the source \ncode that it describes, thanks to the use of an appropriate system of notation.With this notation system, \nthe proof obligation [t] HQ stating that the term t admits H as pre-condition and Q as post-condition \nis displayed in a way that reads as tHQ . This display feature makes it easy to relate proof obligations \nto the piece of code they arose from. The notion of characteristic formulae originates in process cal\u00adculi. \nIn this context, two processes are behaviorally equivalent if and only if their characteristic formulae \nare logically equiva\u00adlent [16]. An algorithm forbuilding the characteristic formula of anyprocess was \nproposed in the 80 s [14]. More recently, Honda, Berger andYoshida adapted this idea from process logics \nto pro\u00adgram logics [18]. Theygave an algorithm forbuilding the pair of the weakest pre-condition and \nof the strongest post-condition of any PCF program. Note that their algorithm differs from weak\u00adest pre-condition \ncalculus in that the PCF program considered is not assumed to be annotated with anyinvariant. Honda et \nal sug\u00adgested that characteristic formulae could be used in program ver\u00adi.cation. However, they did not \n.nd a way to encode the ad-hoc logic that they were using for stating speci.cations into a standard logic. \nSince the construction of a theorem prover dedicated to this logic would have required a tremendous effort, \nHonda et al s work remained theoretical and did not result in an effective program ver\u00adi.cation tool. \nIn prior work [9], we showed how to construct characteristic formulae that areexpressedina standard higher-order \nlogic. More\u00adover, we showed that characteristic formulae can be made of linear size and that they can \nbe pretty-printed like the source code they describe. Those formulae are therefore suitable for manipulation \ninsideanexistingproof assistantsuchasCoq[11].Wehaveim\u00adplemented a tool, called CFML (short for CharacteristicFormulae \nfor ML)that parses a Caml program [24] and produces its charac\u00adteristic formula in the form of a Coq \nstatement. Using CFML, we were able to verify more than half of the content of Okasaki s ref\u00aderence book \nPurely Functional Data Structures [37]. Since then, we have generalized characteristic formulae to support \nreasoning about mutable state, and have updated CFML accordingly. In the present paper, we report on \nthis generalization, making the follow\u00ading contributions.  We show that characteristic formulae for \nimperative programs can still be pretty printed in a way that closely resambles the sourcecodetheydescribe,inspiteofthefactthattheir \nsemantics nowinvolvesamemory store thatis implicitly threaded through\u00adout the execution of the program. \n In order to support local reasoning, we adapt characteristic for\u00admulae to handle speci.cations stated \nin the style of Separation Logic [39], and we introduce a predicate transformer for inte\u00adgrating the \nframe rule into characteristic formulae.  We accompanythe de.nition of characteristic formulae not only \nwith a proof of soundness, but also with a proof of complete\u00adness. Completeness ensures that anycorrect \nspeci.cation can be established using characteristic formulae.  We report on the veri.cation of a nontrivial \nimperative algo\u00adrithm, Dijkstra s shortest path algorithm.We also demonstrate the ability of CFML to \nreason about interactions between .rst\u00adclass functions and mutable state.  The content of this paper \nis organized in three main parts. Sec\u00adtion 2 describes the key ideas involved in the construction, the \npretty-printing and the manipulation of characteristic formulae for imperativeprograms. Section3gives \ndetailsonthe formalizationof memory states, on the algorithm for generating characteristic for\u00admulae \nand on the soundness and completeness theorems. Section4 contains a presentation of several examples \nthat were speci.ed and formalized using CFML. Due to space limitations, several aspects of CFML could \nonly be summarized. All the details can be found in the author s PhD dissertation [8], and all the Coq \nproofs mentioned in this paper can be found online.1 2. Overview 2.1 Veri.cation through characteristicformulae \nThe characteristic formula of a term t, written [t], relates a de\u00adscription of the input heap in which \nthe term t is executed with a description of the output value and a description of the output heap produced \nby the execution of t. Characteristic formulae are hence closely related to Hoare triples [17], and, \nmore precisely, to total correctness Hoare triples, which also account for termination.Ato\u00adtal correctness \nHoare triple {H} t {Q} asserts that, whenexecuted in a heap satisfying the predicate H, the term t terminates \nand re\u00adturnsavalue v inaheap satisfying Qv. Note that the post-condition Q is used to specify both the \noutput heap and the output value. When t has type t , the pre-condition H has type Heap . Prop and the \npost-condition Q has type .t.. Heap . Prop, where Heap is the type of a heap and where .t . is the Coq \ntype that cor\u00adresponds to the ML type t . The characteristic formula [t] is a predicate such that [t] \nHQ captures exactly the same proposition as the triple {H} t {Q}. There is however a fundamental difference \nbetween Hoare triples and characteristic formulae.AHoare triple {H} t {Q} is a three\u00adplace relation, \nwhose second argument is a representation of the syntax of the term t. On the contrary, [t] HQ is a logical \nproposi\u00adtion,expressedin termsof standard higher-order logic connectives, such as ., ., . and .. Importantly, \nthis proposition does not refer to the syntax of the term t. Whereas Hoare-triples need to be es\u00adtablished \nby application of derivation rules speci.c to Hoare logic, characteristic formulae can be proved using \nonly basic higher-order logic reasoning, without involving external derivation rules. 1http://arthur.chargueraud.org/research/2011/cfml/ \nWe have used characteristic formulae for building CFML, a tool that supports the veri.cation of imperative \nCaml programs using the Coq proof assistant. CFML takes as input source code written in a large subset \nof Caml, and it produces as output a set of Coq axioms that correspond to the characteristic formulae \nof each top-level de.nition. It is worth noting that CFML generates characteristic formulae without knowledge \nof the speci.cation nor of the invariants of the source code. The speci.cation of each top\u00adlevel de.nition \nis instead provided by the user, in the form of the statement of a Coq theorem. The user may prove such \na theorem by exploiting the axiom generated by CFML for that de.nition, and he is to provide information \nsuch as loop invariants during the interactive proof. When reasoning about a program through its characteristic \nfor\u00admula,a proof obligation typically takes the form [t] HQ, asserting that the piece of code t admits \nH as pre-condition and Q as post\u00adcondition.The usercanmake progressintheproofbyinvokingthe custom tactics \nprovided by CFML. Proof obligations thereby get decomposed into simpler subgoals, following the structure \nof the code. When reaching a leaf of the source code, some facts need to be established in order to justify \nthe correctness of the program. Thosefacts, whichno longer containanyreferenceto characteristic formulae, \ncan be proved using general-purpose Coq tactics, includ\u00ading calls to decision procedures and to proof-search \nalgorithms. The rest of this section presents thekey ideas involved in the construction of characteristic \nformulae, covering the treatment of let bindings, the frame rule and functions.  2.2 Characteristicformulaofa \nlet-binding Toevaluatea termoftheform let x = t1 in t2 , one .rstevaluates the subterm t1 and then computes \nthe result of the evaluation of t2, in which x denotes the result produced by t1. To prove that the expression \nlet x = t1 in t2 admits H as pre-condition and Q as post-condition, one thus needs to .nd a valid post-condition \nQ ' for t1. This post-condition, when applied to the result x produced by t1, describes the state of \nmemory after the execution of t1 and before the execution of t2. So, Q ' x denotes the pre-condition \nfor t2. The corresponding Hoare-logic rule for reasoning on let\u00adbindings is: {H} t1 {Q ' }.x. {Q ' x} \nt2 {Q} LET {H} (let x = t1 in t2) {Q} The characteristic formula fora let-bindingisbuilt as follows: \n[let x = t1 in t2] = .H. .Q. .Q ' . [t1] HQ ' ..x. [t2] (Q ' x) Q This formula closely resembles the \ncorresponding Hoare-logic rule. The only real difference is that, in the characteristic formula, the \nintermediate post-condition Q ' is explicitly introduced with an ex\u00adistential quanti.er, whereas this \nquanti.cation is implicit in the Hoare-logic derivation rule. The existential quanti.cation of un\u00adknown \nspeci.cations, which is made possible by the strength of higher-order logic, plays a central role here. \nThis existential quan\u00adti.cation of speci.cations contrasts with traditional program ver\u00adi.cation approaches \nwhere intermediate speci.cations, including loop invariants, have to be included in the source code. \nNext, we introduce a notation system for pretty-printing char\u00adacteristic formulae. The aim is to make \nproof obligations easily readable and closely related to the source code.For let-bindings, the piece \nof notation de.ned is: (let x = F1 in F2) = .H. .Q. .Q ' . F1 HQ ' ..x. F2 (Q ' x) Q Hereafter, boldkeywords \ncorrespondto notation for logical for\u00admulae, whereasplainkeywords correspondto constructorsfromthe programming \nlanguage syntax. The de.nition of the characteristic formula of a let-binding can now be reformulated \nas:  [let x = t1 in t2] = (let x = [t1] in [t2]) The generation of characteristic formulae, which is \na translation from program syntax to higher-order logic, therefore boils down to a re-interpretationof \nthe programming languagekeywords. Notation for characteristic formulae can be de.ned in a simi\u00adlarfashion \nfor all the other constructions of the programming lan\u00adguage. It follows that characteristic formulae \nmay be pretty-printed exactly like the source code theydescribe. Hence, during the ver\u00adi.cation of a \nprogram, a proof-obligation appears to the user as a piece of source code followed with its pre-condition \nand its post\u00adcondition. Note that this convenient display applies not only to a top-level program de.nition \nt but also to all of the subterms of t involved during the veri.cation of t. CFMLprovidesasetof tacticsformaking \nprogressintheanaly\u00adsisofa characteristic formula.Forexample,the tactic xlet applies to a goal of the \nform (let x = F1 in F2) HQ . It introduces a uni.cationvariable, callit Q ', and produces twosubgoals. \nThe .rst one is F1 HQ '. The second one is F2 (Q ' x) Q, under a context extended with a fresh variable \nnamed x. The intermediate speci.\u00adcation Q ' introduced here typically gets instantiated through uni.\u00adcation \nwhen solving the .rst subgoal. The pre-condition for F2 is thus known when starting to reason about the \nsecond subgoal. The instantiation of Q ' may also be provided by the user explicitly, as argument of \nthe tactic xlet. More generally, CFML provides one such x-tactic for each language construction.Asa result, \none can verify a program using characteristic formulae even without any knowledge about the construction \nof characteristic formulae.  2.3 Integration of the frame rule Localreasoning [36] referstotheabilitytoverifyapieceofcodeby \nreasoningonly aboutthe memory cells that areinvolvedintheexe\u00adcutionof that code.With local reasoning, \nall the memory cells that are not explicitly mentioned are implicitly assumed to remain un\u00adchanged. The \nconcept of local reasoning is very elegantly captured bythe frame rule , which originates in Separation \nLogic [39]. The framerule statesthatifa programexpression transformsaheapde\u00adscribed by a predicate H1 \ninto heap described by a predicate H1' , then, for anyheap predicate H2, the same program expression \nalso transforms a heap of the form H1 * H2 into a state of the form H1 ' * H2. The star symbol, called \nseparating conjunction, captures a disjoint union of two pieces of heap. The frame rule can be for\u00admulated \nin terms of Hoare triples as shown next. {H1} t {Q1} FRAME {H1 * H2} t {Q1 .H2} Above, the symbol (.) \nis like (*) except that it extends a post\u00adcondition witha pieceof heap.Technically, Q1 .H2 is de.ned \nas .x. (Q1 x) * H2 , where the variable x denotes the output value and Q1 x describes the output heap. \nTo integrate the frame rule in characteristic formulae, we rely on a predicate called local. This predicate \nis de.ned in such a way that, to prove the proposition local [t] HQ , it suf.ces to .nd a decomposition \nof H of the form H1 * H2,a decomposition of Q of the form Q1 .H2,and to prove[t] H1 Q1. Intuitively,the \npredicate local can be de.ned as follows. local F= .H. .Q. .H1. .H2. .Q1. H = H1 * H2 .F H1 Q1 . Q = \nQ1 .H2 The frame rule is not syntax-directed, meaning that one cannot guess from the shape of the term \nt when the frame rule needs to be applied.Yet, our goal is to generate characteristic formulae in a systematic \nmanner from the syntax of the source code. Since we do not know where to insert applications of the predicate \nlocal, we may simply insert applications of this predicate at every node of characteristic formulae.Forexample, \nthe previous de.nition for let-bindings gets updated as follows. (let x = F1 in F2) = local (.H. .Q. \n.Q ' . F1 HQ ' ..x. F2 (Q ' x) Q) This aggressivestrategy allows us to apply the frame rule at any time \nduring program veri.cation. If there is no need to apply the frame rule, then the local predicate may \nbe simply ignored. Indeed, given a formula F, the proposition F HQ is always a suf.cient condition for \nproving local F HQ . (It suf.ces to instantiate H2 as the speci.cation of the empty heap.) We will later \ngeneralize the approach described here for handling the frame rule so as to also handle applications \nof the rule of consequence, which is used to strengthen pre-conditions and weaken post-conditions, and \nto enable the discarding of memory cells, for simulatinggarbage collection.  2.4 Translation of types \nHigher-order logic can naturally be used to state properties about basic values such as purely-functional \nlists. Indeed, the list data structure de.ned in Coq perfectly matches the list data structure from Caml. \nHowever, particular care is required when specifying and reasoning about program functions. Indeed, programming \nlan\u00adguage functions cannot be directly represented as logical functions, becauseofa mismatch betweenthetwo: \nprogram functionsmaybe partial, whereas logical functions mustalwaysbe total.To address this issue, we \nintroduce a new data type, called Func, used to rep\u00adresent functions. To the user of characteristic formulae, \nthe type Func is presented as an abstract data type. In the proof of sound\u00adness, however, a value of \ntype Func is interpreted as the syntax of the source code of a function. Another particularity of the \nre.ection of program values into Coq values is the treatment of pointers. When reasoning through characteristic \nformulae, the type and the contents of memory cells are describedexplicitlythroughheap predicates,sothereisnoneed \nfor pointers to carry the type of the memory cell theypoint to. All pointers are therefore described \nin the logic through an abstract data type called Loc. In the proof of soundness, a value of type Loc \nis interpreted as a store location. The translation of Caml types into Coq types is formalized through \nan operator, written .\u00b7., that maps all arrow types to the type Func and maps all reference types to \nthe type Loc.A Caml value of type t is thus represented as a Coq value of type .t ..For simplicity, program \nintegers are idealized and are simply mapped toCoqvaluesof type Z.However,itwouldalsobe possibletomap \nthe type int to the Coq type int64 for reasoning about over.ows. The de.nition of the operator .\u00b7. can \nbe summarized as follows. .int.= Z .t1 \u00d7 t2. =.t1.\u00d7.t2. .t1 + t2. =.t1. + .t2. .t1 . t2.= Func .reft.= \nLoc The translation from Caml types to Coq types is in fact con\u00adductedintwo steps.Awell-typedMLprogramgets \n.rst translated intoa well-typed weak-ML program, and this weak-ML program is then fed to the characteristic \nformula generator.Weak-ML corre\u00adspondstoa relaxedversionofMLthatdoesnotkeep trackofthe type of pointers \nnor of the type of functions. Moreover, weak-ML does not impose anyconstraint on the typing of applications \nnor on the typing of dereferencing.  Since weak-ML imposes strictly fewer constraints than ML, any program \nwell-typed inMLis also well-typed in weak-ML.Weak-ML nevertheless enforces strong enough invariants to \njustify the soundness of characteristic formulae. So, although memory safety is not obtained by weak-ML, \nit is guaranteed by the proofs of correctness established using a characteristic formula generated from \na well-typed weak-ML program. Although it is possible to generate characteristic formulae di\u00adrectly from \nML programs, the use of weak-ML as an intermedi\u00adate type system serves three important purposes. First, \nweak-ML helps simplifying the de.nition of the characteristic formula gen\u00aderation algorithm. Second, \nit enables the veri.cation of programs that are well-typed in weak-MLbut not in ML, such as programs \nexploiting SystemFfunctions, null pointers, or strong updates (i.e., type-varying updates of a reference \ncell). Third, weak-ML plays a crucial role in proving the soundness and completeness of charac\u00adteristic \nformulae. This latter aspect of weak-ML is not discussed in this paper, however it is described in author \ns PhD dissertation [8].  2.5 Reasoning about functions To specify the behavior of functions, we rely \non a predicate, called App, which also appears to the user as an abstract predicate. Intu\u00aditively, the \nproposition App fvHQ asserts that the application of the function f to v in a heap satisfying H terminates \nand re\u00adturns a value v ' in a heap satisfying Qv '. The predicates H and Q correspond to the pre-and \npost-conditions of the application of the function f to the argument v. It follows that the characteristic \nfor\u00admula for an application of a function f to a value v is simplybuilt as the partial application of \nApp to f and v. [fv] = App fv The function f is viewed in the logic as a value of type Func. If f takes \nas argument a value v described in Coq at type A and returns a value described in Coq at type B, then \nthe pre-condition H has type Hprop, a shorthand for Heap . Prop, and the post\u00adcondition Q has type B \n. Hprop. So, the predicate App has type: .A B. Func . A . Hprop . (B . Hprop) . Prop For example, the \nspeci.cation of the function incr, which incre\u00adments the content of a memory cell containing an integer, \ntakes the form of a theorem stated in terms of the predicate App: .r. .n. App incr r (r.. n)(._. r.. \nn + 1) Above, the heap predicate (r.. n) describes the memory state expectedbythe function:it consistsofasinglememorycell \nlocated at address r and whose content is the value n. Similarly, the heap predicate (r.. n + 1) describes \nthe memory state posterior to the functionexecution. The abstraction ._. is used to discard the unit \nvalue returnedby the function incr. By construction, a statement of the form App fvHQ de\u00adscribes the \nbehavior of an application. As we have just seen, App can be used to write speci.cations. It remains \nto explain where assumptions of the form App fvHQ can be obtained from. Such assumptions are provided \nby characteristic formulae associ\u00adated with function de.nitions. If a function f is de.ned as the ab\u00adstraction \n.x. t , then, given a particular argument v, one can de\u00adrive an instance of App fvHQ simplyby proving \nthat the body t, in which x is instantiated with v, admits the pre-condition H and the post-condition \nQ. Inwhatfollows,weexplainhowtobuild characteristic formula for local functions and then for top-level \nfunction. For a local function de.nition, the characteristic formula is as follows: [let rec f = .x. \nt in t ' ] = .H. .Q. .f. H. [t ' ] HQ ' Q '' Q '' Q ' where H= (.xH . [t] H . App f xH ) For a top-level \nfunction de.nition of the form let rec f = .x. t , CFML generates two Coq axioms. The .rst one has name \nf and type Func. ThisCoqvariable f corresponds to the Caml function f. The second axiom describes the \nsemantics of f,through the follow\u00ading statement: .xH Q. [t] HQ . App f xHQ . Note that the soundness \ntheorem proved for characteristic formulae ensures that adding this axiom does not introduce anylogical \ninconsistency. For example, consider the top-level function de.nition let f = .r. (incr r ; incr r) , \nwhich expects a reference and increments its content twice. This function may be speci.ed through a theorem \nwhose statement is .rn. App fr (r.. n)(._. r.. n + 2) .To establish this theorem, the .rst step consists \nin applying the second axiom generated for the function f. The resulting proof obligation is (app incr \nr ;app incr r)(r.. n)(._. r.. n + 2) , where app and ; correspond to the pieces of notation de.ned for \nthe characteristic formulae of applications and of sequences, respec\u00adtively. This proof obligation can \nbe discharged with help of the tac\u00adtic xseq, for reasoning about the sequence, and of the tactic xapp, \nfor reasoningaboutthetwo applications.Infact,forsuchasimple function, one may establish correctness through \na simple invoca\u00adtionofa tactic called xgo,which repeatedly applies the appropriate x-tactic until some \ninformation is required from the user. Twoobservations areworth making aboutthe treatmentof func\u00adtions. \nFirst, characteristic formulae do not involve any speci.c treatment of recursivity. Indeed, to prove \nthat a recursive function satis.esagiven speci.cation,itsuf.cesto conductaproofthatthe function satis.es \nthat speci.cationbyinduction. The induction may be conductedona measureorona well-founded relation,usingthe \ninductionfacility from the interactive theorem prover being used. So, characteristic formulae for recursive \nfunctions do not need to include any inductionhypothesis.A similar observationwas also madeby Honda et \nal in their work on program logics [18]. The second observation concerns .rst-class functions. As ex\u00adplained \nthrough this section, a function f is speci.ed with a state\u00adment of the form App fvHQ . Because this \nstatement is a proposition like any other (it has type Prop), it may appear in\u00adside the pre-condition \nor the post-condition of anyanother function (thanks to the impredicativity of Prop).This statement may \nalso ap\u00adpearinthe speci.cationofthe contentofa memory cell.The predi\u00adcate App therefore supports reasoning \nabout higher-order functions (functions taking functions as arguments) and higher-order stores (memory \nstores containing functions). 3. Characteristicformula generation This sectionofthe paperexplainsin more \ndetailshowcharacteristic formulae are constructed. It presents weak-ML types, the source language, the \ntranslation of Caml values into Coq values, and the predicates used to describe heaps. It then describes \nthe algorithm used to generated characteristic formulae. Note that it is safe to read Section 4, which \nis concerned with examples, before this one. 3.1 FromMLtypestoWeak-MLtypesandCoqtypes In what follows, \nwe describe the grammar of ML types and weak-ML types, and then formalize the translation from ML types \nto weak-ML types, and the translation from weak-ML types to Coq types. Hereafter, A denotes a type variable, \nC denotes the type constructor for an algebraic data type, t denotes an ML type, and s denotes a ML type \nscheme. Furthermore, the overbar notation denotes a list of items. The grammar of ML types is: t := A \n| int | Ct | t . t | ref t | \u00b5A.t s := .A.t Note that sum types, product types, the boolean type and \nthe unit type can be de.ned as algebraic data types.  .A.= A .int.= int .Ct .= C .t . .t1 . t2.= func \n.ref t.= loc ..A. t . =.B. .t . where B = A n fv(.t .)  .t . if A .. .t. .\u00b5A.t .= program rejected \notherwise Figure 1. Translation from ML types to weak-ML types Weak-MLtypesare obtainedfromMLtypesbymappingallar\u00adrow \ntypes to a constant type called func and mapping all reference types to the constant type called loc. \nLet T denote a weak-ML type and S denote a weak-ML type scheme. The grammar of weak-ML types is as follows: \nT := A | int | CT | func | loc S := .A.T The translation of an ML type t into the corresponding weak-ML \ntype, written .t ., appears in Figure 1. The treatment of poly\u00admorphism and of recursive types is explained \nnext. When translat\u00adinga type scheme, the listof quanti.edvariables might shrink.For example, the ML \ntype scheme .AB. A +(B . B) is mapped to .A. A + func , which no longer involves the type variable B. \nWeak-ML includes algebraic data types,but does not support gen\u00aderal equi-recursive types. Nevertheless, \nsome recursive ML types can be translated into weak-ML, because the recursion involved mightvanish when \nerasing arrow types.Forexample, the recursive ML type \u00b5A.(A \u00d7 int) does not have anycounterpart in weak-ML, \nhowever the recursive ML type \u00b5A.(A . B) gets mapped to the weak-ML type func. The veri.cation approach \ndescribed in the present paper therefore supports reasoning about functions with an equi-recursivetype. \nWhen building the characteristic formula of a weak-ML pro\u00adgram, weak-ML types get translated into Coq \ntypes. This trans\u00adlation is almost the identity, because every type constructor from weak-ML is directly \nmapped to the corresponding Coq type con\u00adstructor. Algebraic type de.nitions are translated into correspond\u00ading \nCoq inductive de.nitions. Note that the positivity requirement associated with Coq inductive types is \nnot a problem here: since there is no arrow type in weak-ML, the translation from weak-ML types to Coq \ntypes never produces a negative occurrence of an in\u00adductive type in its own de.nition. In summary, the \nCoq translation of a weak-ML type T , written T 1, is de.ned as follows. int1 = Z A1 = A loc1 = Loc CT \n1 = C T 1 func1 = Func .A.T 1 =.A. T 1  3.2 Typed sourcelanguage Before generating characteristic formulae, \nprograms .rst need to beputin an administrative normal form. Through this process, programs are arranged \nso that all intermediate results and all func\u00adtions become bound by a let-de.nition. One notable exception \nis the application of simple total functions such as addition and sub\u00adtraction. For example, the application \nf (v1 + v2) is consid\u00adered to be in normal form although f (gv1 v2) is not in normal form in general. \nThe normalization process, which is similar to A\u00adnormalization [13], preserves the semantics and greatly \nsimpli.es formally reasoning about programs. Moreover, it is straightforward to implement. Similar transformations \nhave appeared in previous workon programveri.cation(e.g.,[18,38]).Inthispaper,weomit a formal description \nof the normalization process and only show the grammar of terms in normal form. The characteristic formula \ngenerator expects a program in ad\u00administrative normal form. It moreover expects this program to be typed, \nin the sense that all its subterms should be annotated with their weak-ML type.Toformally de.ne characteristic \nformulae, we therefore need to introduce the syntax of typed programs in normal forms. This syntax is \nformalized as follows, where t ranges over typed term and v ranges over typed values. v := n | xT | DT \n( v, . . . , v ) | ref | get | set | cmp | null t := v | ( vv ) | crash | if v then t else t | let x \n= t in t | let x =AA. v in t | t ; t | let rec f =AA..x.t in t Note that locations and function closures \ndo not exist in source programs, so they are not included in the above grammar. The letter n denotes \nan integer a memory location. The functions ref, get and set are used to allocate, read and write reference \ncells, respectively, and the function cmp enables comparison of two memory locations. The null pointer, \nwritten null, is a particular location that never gets allocated. Typed programs carry explicit information \nabout generalized type variables, so a polymorphic function de.nition takes the form let rec f =AA..x.t \n1 in t 2 and apolymorphic let-binding takes the form let x =AA. v in t . Due to the value restriction, \nthe general form let x =AA. t 1 in t 2 is notallowed.Thesyntaxoftyped programsalsokeepstrackoftype applications, \nwhich take place either on a polymorphic variable x, written xT , or on a polymorphic data constructor \nD, written DT . For-loops and while-loops are discussed later on (\u00a73.7).  3.3 Re.ection of values in \nthe logic Constructing characteristic formulae requires a translation of all the Caml values that appear \nin the program source code into the corresponding Coq values. This translation, called decoding, and \nwritten .v ., transforms a weak-ML value v of type T into the corresponding Coq value, which has type \nT 1. The de.nition of .v . is shown below. Values on the left-hand side are well-typed weak-ML values \nwhereas values on the right-hand side are (well\u00adtyped) Coq values. .n.= n .xT .= x T 1 .DT ( v1,..., \nv 2).= D T 1 (.v 1.,..., .v 2.) .AA. v .= .A. .v . Above,aprogram integer n is mapped to the corresponding \nCoq integer. If x isanon-polymorphicvariable, thenitis simply mapped to itself. However, if x is a polymorphic \nvariable applied to some types T , then this occurrence is translated as the application of x to the \ntranslations of each of the types from the list T .Aprogram data constructor D is mapped to the corresponding \nCoq inductive constructor, and if the constructor is polymorphic then its type arguments get translated \ninto Coq types. The primitive functions for manipulating references (e.g., get)are mapped to corresponding \nabstract Coq values of type Func. The decoding of a polymorphic value AA. v is a Coq func\u00adtion that expects \nsome types A and returns the decoding of the value v . For example, the polymorphic pair (nil, nil) has \ntype .A. .B. list A \u00d7 listB . The Coq translation of this value is fun A B : Type => (@nil A, @nil B) \n, where the pre.x @ indicates that type arguments are given explicitly. The Coq expert might feel sceptical \nabout thefact that the typevariables A and B get assigned the kind Type. Sincea weak-ML typevariableistobe \ninstantiated with a weak-ML type T , a Coq type variable occuring in a characteristic formula should \npresumably be instantiated only with a Coq type of the form T 1. Nevertheless, we have proved that it \nis not needed to consider the kind de.ned as the image of the operator \u00b71, because it remains sound to \nassign the kind Type to the type variables quanti.ed in characteristic formulae. The proof can be found \nin [8], Section 6.4.  3.4 Heap predicates This section explains how heaps are represented, how operations \nonheaps are de.ned,andhowheap predicates arebuiltinthestyle of Separation Logic. Note that all the operations \nand predicates on heaps are completely formalized in Coq. The semantics of a source program involves \na memory store, which is a .nite map from locations to program values. The Coq object that correspondstoamemory \nstoreis calledaheap. The type Heap is de.ned in Coq as the type of .nite maps from locations to dependent \npairs, where a dependent pair is a pair of a Coq type T and ofa Coqvalue V of type T .With this de.nition, \nthe set of Coq values of type Heap is isomorphic to the set of well-typed memory stores. Operations on \nheaps are de.ned in terms of operations on maps. The empty heap, written \u00d8, is a heap built on the empty \nmap. Similarly, a singleton heap, written l .T V , is a heap built on a singleton map binding a location \nl to a dependent pair made of a type T and a value V of type T . Two heaps are said to be disjoint, written \nh1 . h2,when their underlying maps havedisjoint domains. The union of two heaps, written h1 + h2, returns \nthe union of the two underlying .nite maps. We are only concerned with disjoint unions here, so it does \nnot matter how the map union operator is de.ned for maps with overlapping domains. Using those basic \noperations on heaps, one can de.ne predicates for specifying heaps in the style of Separation Logic, \nas is done for example in Ynot [10]. Heap predicates are simply predicates over values of type Heap, \nso theyhave the type Heap . Prop, abbre\u00adviated as Hprop.Asingleton heap that binds a non-null location \nl to a value V of type T is characterized by the predicate l..T V , which is de.ned as .h. l .= null \n. h =(l .T V ). The heap predicate H1 * H2 holdsofa disjoint unionofaheap satisfying H1 and of a heap \nsatisfying H2. It is de.ned as .h. .h1 h2.h1 . h2 . h = h1 + h2 . H1 h1 . H2 h2. In order to describe \nlocal invariants of data structures, propo\u00adsitions are lifted as heap predicates. More precisely, the \npredicate [P] holds of an empty heap if the proposition P is true. So, [P] is de.ned as .h. P. h = \u00d8. \nIn particular, the empty heap is char\u00adacterized by the predicate [], which is short for [True]. Similarly, \nexistential quanti.ers are lifted: . x. H holds of a heap h if there exists a value x such that H holds \nof that heap2. The presentwork ignores the disjunction construct(H1 . H2). To reason on the content of \nthe heap by case analysis, we instead rely on heap predicates of the form if P then H1 else H2 , which \nare de.ned using the builtin conditional construct from classical logic. The present work also does not \nmake use of non-separating conjunction(H1 . H2). It therefore does not include the rule of conjunction, \nwhich can be found in a number of formalizations of Separation Logic. From a pratical perspective, we \nnever felt the need for the conjunction rule. From a theoretical perspective, the conjunction rule is \nnot needed for characteristic formulae to achieve 2The formal de.nition for existentials properly handles \nbinders. It actually takes the form hexists J, where J isa predicate.Formally: hexists (A : Type)(J : \nA -Hprop) = A(h : Heap). :(x : A).J xh. completeness. (It is not yet known whether characteristic formulae \nwould be able to accomodate the conjunction rule or not.) Reasoning about heaps is generally conducted \nin terms of an entailment relation, written H1 . H2, which asserts that anyheap satisfying H1 also satis.es \nH2. It is de.ned as .h. H1 h . H2 h. Similarly, an entailment relation is provided for post-conditions. \nIt is written Q1 . Q2 and de.ned as .x. Q1 x . Q2 x.Anumber of lemmas (not shown) allowreasoning about \nheap entailment without having to unfold the de.nition of this relation. Moreover, several tactics are \nprovided to automate the application of these lemmas. As a result, apart from the setting up of the core \nde.nition and lemmas in the CFML library, the proofs never refer to objects of type Heap directly: program \nveri.cation is carried out solely in terms of heap predicates of type Hprop (like done, e.g., in Ynot \n[10]). Observethat the Separation Logic used here is not intuitionistic. In general, the entailment H1 \n* H2 . H1 isfalse. (It only holds when H2 describes an empty heap.)With an intuitionistic Separa\u00adtion \nLogic, one may discard pieces of heap at anytime during the reasoning on heap entailment. Here,garbage \ncollection is instead modelledbyhavinganexplicitgarbageheap mentionedinthedef\u00adinition of the predicate \nlocal, as described next.  3.5 Local predicates In the introduction, we suggested how to de.ne the predicate \ntrans\u00adformer local to account for applications of the frame rule. We now present the general de.nition \nof this predicate, a de.nition that also accounts for the rule of consequence and for the rule of garbage \ncollection. Moreover, it supports the extraction of propo\u00adsitions and existentially-quanti.ed variables \nfrom pre-conditions. We also introduce a predicate, called islocal , that is useful for manipulating \nformulae of the form local F . The predicate local applies to a formula F with a type of the form Hprop \n. (A . Hprop) . Prop, for some type A. Its de.nition is: local F= .H Q. .h. Hh ..H1 H2 H3 Q1. (H1 * H2) \nh .F H1 Q1 . Q1 .H2 . Q.H3 where H describes the initial heap, H1 corresponds to the part of the heap \nwith which the formula F is concerned, H2 corresponds to the part of the heap that is being framed out, \nH3 corresponds to the part of the heap that gets discarded, Q describes the .nal result and .nal heap, \nand Q1 is such that Q is equivalent to Q1 .H2. (Recall that the latter is de.ned as .x. Q1 x * H2.) Note \nthat the de.nition of the predicate local shows some similarities with the de.nition of the STsep monad \nfrom HoareType Theory [32], in the sense that both aim at baking the Separation Logic frame condition \ninto a system originally de.ned in terms of heaps describing the whole memory. One can prove that the \npredicate local may be safely discarded during reasoning, in the sense that F HQ is a suf.cient con\u00addition \nfor proving local F HQ . Another useful property of the predicate local is its idempotence: for anypredicate \nF, the pred\u00adicate local F is equivalent to the predicate local (local F) . Other properties of local \ncan be expressed in terms of a predicate called islocal, de.ned as: islocal F= (F = local F) This de.nition \nasserts that the predicate F is extensionally equiv\u00adalent to local F . In such a case, the formula F \nis called a local formula. Note that islocal (local F) is true for anyF. Now, assuming that F isa local \nformula, all the reasoning rules shownin Figure2canbeexploited. The interestof introducing the predicates \nislocal is that it conveniently allows us to apply anyof the reasoning rules from Figure 2, an arbitrary \nnumber of times,  FRAME : F HQ .F (H * H ' )(Q.H ' ) GC-PRE : F HQ .F (H * H ' ) Q GC-POST : F H (Q.H \n' ) .F HQ '' CONSEQUENCE-PRE : F HQ . H . H .F HQ CONSEQUENCE-POST : F HQ . QQ ' .F HQ ' EXTRACT-PROP \n:(P.F HQ) .F ([P] * H) Q EXTRACT-EXISTS :(.x. F HQ) .F (. x. H) Q Figure 2. Reasoning rules applicable \nto a local formula F [v ] = local (.HQ. H . Q .v .) [v 1 v 2] = local (.HQ. App .v 1..v 2. HQ) [let x \n= t 1 in t 2] = local (.HQ. .Q ' . [t 1] HQ ' ..x. [t 2] (Q ' x) Q) [t 1 ; t 2] = local (.HQ. .Q ' . \n[t 1] HQ ' . [t 2] (Q ' tt) Q) [let rec f =AA..x.t 1 in t 2] = local (.HQ. .f. H. [t 2] HQ) '' ' Q ' \nQ ' Q ' with H=.AxH . [t 1] H . App f xH [if v then t 1 else t 2] = local (.HQ. (.v . = true . [t 1] \nHQ) . (.v . = false . [t 2] HQ)) [crash] = local (.HQ. False) [let x =AA. v in t ] = local (.HQ. .x. \nx = .A..v .. [t ] HQ) Figure 3. Generation of characteristic formulae and in anyorder. Moreover, the \npredicate islocal playsakeyrolein the characteristic formulae of for-loops and while-loops (see \u00a73.7). \n 3.6 Characteristicformula construction We are now ready to describe the algorithm for constructing \nchar\u00adacteristic formulae. The characteristic formula of a typed term t is written [t ]. If t admits the \nweak-ML type T , then the formula [t ]has type Hprop . ( T 1 . Hprop) . Prop. Recall that Hprop is an \nabbreviation for Heap . Prop. The rules for constructing characteristic formulae appear in Figure 3. \nBefore describing each rule individually, two observations are worth making about the .g\u00adure.First,every \nde.nition startswithan applicationofthe predicate local. The presence of this predicate at every node \nof a character\u00adistic formula enables us to apply any of the reasoning rules from Figure2atanypointduringtheveri.cationofa \nprogram. Second, all the program values get translated into Coq values. This is done through applications \nof the decoding operator, written .v .. The .rst rule from Figure3states thatavalue v admits a pre\u00adcondition \nH and a post-condition Q if the current heap, which is described by H, also satis.es the predicate Q \n.v .. The character\u00adistic formula of an application is obtained directly by applying the special predicate \nApp. The treatment of let-bindings has already beenexplainedinthe introduction.The caseofa sequenceisaspe\u00adcialized \nversion of that of let-bindings, where the result of the .rst term is always the unit value (written \ntt). The treatment of functions has also already been explained, exceptforthe treatmentof polymorphism.Apolymorphic \nfunction is written let rec f =AA..x.t 1 , where A denotes the list of type variables involved in the \ntype-checking of the body of the function. The type variables from the list A are quanti.ed in thehypothesis \nH provided by the characteristic formula for reasoning about the body of the function. Here again, the \ntype variables are given the kind Type in Coq. Note that, in weak-ML, a polymorphic function admits the \ntype func, just like anyother function. So, the variable f admits in Coq the type Func. To show that \na conditional of the form if v then t1 else t2 admits a given speci.cation, one needs to prove that \nt1 admits that speci.cation when v is true and that t2 admits that same speci.cation when v is false. \nThe de.nition of the characteristic formula of the instruction crash, which corresponds to a dead branch \nin the code, requires the programmer to provethat this point in the code can never be reached. This is \nequivalent to showing that the set of assumptions accumulated before reaching this point contains a logical \ninconsistency, i.e., that False is derivable. The last de.nition from Figure3is slightly more technical.A \npolymorphic let-binding takes the form let x =AA. v in t ,where v is a polymorphic value with free type \nvariables A. If v has type T , then the program variable x has type .A.T . The characteristic formula \nassociated with this let-binding quanti.es over a Coq vari\u00adable x of type .A. T 1, and it provides the \nassumption that x is the Coq value that corresponds to the program value v . This assump\u00adtion is stated \nthrough an extensional equality, written x = .A..v .. This equality implies that, for any list of weak-ML \ntypes U, the application xU1 yields the Coq value that corresponds to the program value [A . U] v. This \ncompletes the description of Figure 3. The characteristic formulae of loops are explained in the next \nsection. The treat\u00adment of n-ary functions, mutually-recursive functions, assertions and pattern matching \ncould not be described in this paper due to space limitations. This material can be found in the author \ns disser\u00adtation [8]. For each construction of the programming language, a custom Coq notationis de.nedfor \npretty-printingitinawaythat resembles the source code.Wehavealready seenhowto pretty-print formulae for \nlet-bindings. Additional examples concerning values, applica\u00adtions and function de.nitions are shown \nbelow. (ret V ) = local (.HQ. H . QV ) (app V1 V2) = local (.HQ. AppV1V2HQ) (let recf =(fun Ax := F1) \nin F2) = local (.HQ. ' Q '' Q '' Q ' .f. (.AxH . F1 H . App f xH ) .F2 HQ) Finally, consider the speci.cation \nof the functions for manipu\u00adlating references: .A v. App ref v [](.r. r..A v) .A r v. App get r (r..A \nv)(.x. [x = v] * r..A v) .AA ' rvv ' . App set (r, v)(r..A ' v ' )(._. r..A v) '' ' .rr . App cmp (r, \nr )[](.x. [x = true . r = r ]) Above, the functions being speci.ed have type Func, v has type A, v ' \nhas type A ', and r and r ' have type Loc. Observe that the speci.cation of set allows for strong updates, \nthat is, for changes in the type of the content of a reference cell.  3.7 Characteristicformulaefor \nloops Since the source language already contains recursive functions, there is, from a theoretical perspective, \nno need do discuss the treatment of loops. That said, loops admit direct characteristic formulae whose \nuse greatly shortens veri.cation proof scripts in practice.To understandthe characteristic formulaofa \nwhileloop, it is useful to .rst study an example.  Consider the term while (get r> 0) do (decr r ; incr \ns) , and call this term t. Let us provethat, for anynon-negativeinteger n and anyinteger m,the termt \nadmits the pre-condition (r.. n)*(s.. m) and the post-condition (r.. 0) * (s.. m + n) .We can prove this \nstatementby induction on n. According to the semantics of a while loop, the term t admits the same semantics \nas the term if (get r> 0) then (decr r ; incr s ; t) else tt . If the content of r is zero, then n is \nequal to zero, and it is straightforward to check that the pre-condition matches the post-condition. \nOtherwise, the decrement and increment functions are called, and the state after their execution is described \nas (r.. n - 1) * (s.. m + 1) . At this point, we need to reason about the nested occurrence of t, that \nis, about the subsequent iterations of the loop. To that end, we invoke the inductionhypothesis and derive \nthe post-condition (r.. 0) * (s.. (m + 1) + (n - 1)) , which matches the required post-condition. Thisexample \nillustrateshowthe reasoning abouta whileloopis equivalent to the reasoning about a conditional whose \n.rst branch ends with a call to the same while loop. The characteristic formula of while t1 do t2 builds \nupon this idea. It involves a quanti.ca\u00adtionover an abstractvariable R,which denotes the semantics of \nthe ' Q ' while loop, in the sense that RH holds if and only if the loop admits H ' as pre-condition \nand Q ' as post-condition. The main as\u00adsumption provided about R states that, to establish the proposition \nRH ' Q ' foraparticular H ' and Q ',it suf.ces to provethat the term if t1 then (t2 ; while t1 do t2) \nelse tt admits H ' as pre-condition and Q ' as post-condition. This latter statement is expressed with \nthe help of the notation introduced for pretty-printing characteristic formulae. The characteristic formula \nfor while loops is therefore as follows. (The role of thehypothesis islocal R is explained after\u00adwards.) \n[while t 1 do t 2] = local (.HQ. .R. islocal R .H. RHQ) ' Q ' with H=.H. (if [t 1] then ([t 2] ;R) else \nret tt) H ' . RH ' Q ' Q ' With the characteristic formula shown above, the veri.cation of a while-loop \ncanbe conductedby induction on anywell-founded re\u00adlation. CFML also provides tactics to address the typical \ncase where theproofis conductedusingaloopinvariantandatermination mea\u00adsure. To re.ect thefact that the \npredicateR supports application of the frame rule as if it were a characteristic formula, the de.nition \nshown above provides the assumption that R is a local formula. For example, this assumption would be \nuseful for reasoning about the traversal of an imperative list using a while-loop. At every iteration \nof this loop, one cell is traversed. This cell may be framed out from the reasoning about the subsequent \niterations, thanks to the assumption islocal R . Such an application of the frame rule makes it possible \nto verify the list trasversal using only the simple list representation predicate, avoiding the need \nto involve the list\u00adsegment representation predicate.Asimilar observation about the usefulnessof applyingtheframeruleduringtheexecutionofaloop \nwas also recently madebyTuerk [41]. The characteristic formula of a for-loop is somewhat similar to that \nof a while-loop. The main difference is that the predicate R is replaced with a predicate S which takes \nas extra argument the current value of the loop counter, here named i. The de.nition is: [for i = v 1 \nto v 2 do t ] = local (.HQ. .S. (.i. islocal (Si)) .H. S .v 1. HQ) ' Q ' with H=.iH . ' Q '' Q ' (if \ni =.v 2. then ([t ] ;S (i + 1)) else ret tt) H . SiH 3.8 Soundness and completeness  Characteristic \nformulae are both sound and complete. The sound\u00adness theorem states that if the characteristic formula \nof a pro\u00adgram holds of some speci.cation, then this program indeed satis.es that speci.cation. More precisely, \nif the characteristic formula of a term t holds of a pre-condition H and a post-condition Q, then the \nexecution of t, starting from a state h satisfying the pre-condition H, terminates and produces a value \nv in a .nal state h ' such that the post-condition Q holds of v and h '. The semantics judgment involved \nhere is written t /h . v /h ' . The formal statement shown below also takes into account thefact the \n.nal heap may contain somegarbagevalues, which aregatheredina sub-heap called h '' . Theorem 3.1 (Soundness) \nLet t be a well-typed, closed weak-ML term. Let H and Q beapre-andapost-condition,and h beaheap. [ t \n] HQ . Hh .. h '' .v/(h ' +h '' ) . v. h ' vh ' t/h . Q . Above, H has type Heap . Prop and Q has type \n T 1 . Heap . Prop , where T is the type of t . The completeness theorem asserts that, reciprocally, \nif a pro\u00adgram admits a given speci.cation, then it is possible to prove that the characteristic formula \nof this program holds of that speci.ca\u00adtion. This completeness statement is, of course, relative to the \nex\u00adpressiveness power of the logic of Coq. More precisely, the state\u00adment of completeness states the \nfollowing: if one is able to estab\u00adlish, with respect to a deep embedding of the source language in Coq, \nthat a given program terminates and produces a value satis\u00adfying a given post-condition, then it is possible \nto establish in Coq that the characteristic formula of this program holds of the given post-condition. \nDue to space limitations, the present paper does not include the general statement of the completeness \ntheorem, which involves the notionof most-general speci.cationandthatoftyped reduction,but onlyaspecializedversionforthe \ncaseofanML program producing an integer result. This simpli.ed statement reads as follows: if t is a \nclosed ML program whose execution produces an integer n, then the characteristic formula of t holds of \na pre-condition that characterizes the empty heap and of a post-condition asserting that the output value \nis exactly equal to n. Theorem 3.2 (Completeness particular case) Let t beaclosed ML term, and let t \ndenote the corresponding weak-ML term. Let n be an integer and let h be a memory state. Then, t/\u00d8 . n/h \n. [ t ] [] (.x. [x = n]) The completeness theorem is relative to the expressive power of Coq because \nthehypothesis t/\u00d8 . n/h is interpreted as the state\u00adment of a fact provable in Coq. More precisely, this \nhypothesis assertstheexistenceofaCoqproof term witnessingthefactthat the con.guration t/\u00d8 is related \nto the con.guration n/h by the inductively-de.nedevaluation judgment(.). The proofs of the soundness \nand completeness theorems are quite involved. Theyamounts to about 30 pages of the author sPhD dissertation \n[8]. In addition to those paper-and-pencil proofs, we considered a simple imperative programming language \n(including whileloopsbutno functions)and mechanizedthetheoryof charac\u00adteristic formulae for this language. \nMore precisely, we formalized the syntax and semantics of this language, de.ned a characteristic formula \ngenerator for it, and then proved in Coq that the formulae producedby this generator are both sound and \ncomplete. 4. Examples This section describes four examples. The .rst one is Dijsktra s shortest path \nalgorithm. It illustrates how CFML supports the rea\u00adsoning about modular code involving complexinvariants. \nThe other examples focus on the treatment of imperative .rst-class functions, covering a counter function \nwith an abstract local state, Reynold s CPS-append function, and an iterator on imperative lists.  Conducting \nproofs using CFML involves two additional ingre\u00addients that havenot yet been described. The .rst one \nis the predicate Appn, which generalizes the predicate App to n-ary applications. For example, App2 f \nxyHQ asserts that the application of f to x and y admits H and Q as pre-and post-conditions. The predicate \nApp1 is the same as App, and the predicates Appn can be de.ned in terms of App1. The secondkeyingredientisthe \nnotionofarepresentationpred-icate.Aheap predicate of the form v . TV is used to relate the mutable data \nstructure found at location v with the mathematical value V that it represents. Here, T is a representation \npredicate: it characterizes the relationship between v, V and the piece of mem\u00adorystate spannedbythedata \nstructure under consideration.Infact, v . TV is simply de.ned as TV v, where T can be any pred\u00adicate \nof type A . B . Hprop. This section contains examples showing how to use and how to de.ne representation \npredicates. 4.1 Dijkstra s shortest path Inthis .rstexample, describe the speci.cationandveri.cationofa \nparticular implementation of Dijkstra s algorithm. This implemen\u00adtation uses a priority queue that does \nnot support the decrease-key operation. Using such a queue makes the proofs slightly more in\u00advolved, \nbecause the invariants need to account for thefact that the queuemay contain supersededvalues.The algorithminvolves \nthree mutable data structures: v, an array of boolean used to mark the nodes for which the best distance \nis already known; b, an array of distances used to store the best know distance for every node (distances \nmay be in.nite); and q, a priority queue for ef.ciently identifying the next nodes to be visited. The \nCaml source code is 20 lines long, and it is organized around a main while-loop. Inside the loop, the \nhigher-order func\u00adtion List.iter is used for traversing an adjacency list. The imple\u00admentation of the \npriority queue is left abstract: the source code is implemented as a Caml functor, whose argument corresponds \nto a priority queue module. Similarly, the veri.cation script is imple\u00admented as a Coq functor. This \nfunctor expects two arguments: a module representing the implementation of the priority queue, and a \nmodule representing the proofs of correctness of that queue im\u00adplementation. This strategy allows us \nto achieve modular veri.ca\u00adtion of modular code. The speci.cation of the function dijkstra is as follows: \n.gxyG. nonnegative edges G . x . nodes G . y . nodes G . App3 dijkstra gxy (g . GraphAdjList G) (.d. \n[d = dist Gxy] * (g . GraphAdjList G)) It states that if g is the location of a data structure that represents \na mathematical graph G through adjacencylists, if the edges in G all have nonnegative weights, and if \nx and y are indices of two nodes from that graph, then the application of the function dijkstra to g, \nx and y returns a value d that is equal to the length of the shortest path between x and y in the graph \nG. Moreover, the above speci.cation asserts that the structure of the graph is not modi.ed by the execution \nof the function. The representation predicate GraphAdjList is used to relate a mathematical graph with \nits representation as an array of lists of pairs. It is de.ned as: GraphAdjList Gg =. N. (g . Array N) \n* [.x. x . nodes G . x . dom N] * [.x . nodes. .yw. (x, y, w) . edges G . mem(y, w) N[x]] Above, g denotes \na value of type Loc, G denotes a mathematical graph whose nodes are indexed by integers and whose edges \nhave integer weight, and N is a .nite map from integers to lists of pairs of integers. The de.nition \nasserts that x is an indexin N if and only if it is the index of a node in G, and that a pair (y, w) \nbelongs to the list N[x] if and only if the graph G has an edge of weight w between the nodes x and y. \nThe invariant of the main loop of Dijkstra s algorithm, written hinv V BQ describes the state of the \ndata structures in terms of three data structures: V is a .nite map describing the array v, B is a .nite \nmap describing the array b, and Q is a multiset of pairs describing the priority queue q. Several logical \ninvariants enforce constraints ocharacteristic formulae.n the content of V , B and Q. Those invariants \nare captured by a record of propositions, written inv V BQ .The de.nitionofthis recordisnotshownherebut,for \nexample, the .rst .eld of this record ensures that if V [z] contains the value true then B[z] contains \nexactly the length of the shortest path between the source x and the node z in the graph G. The heap \ndescription specifying the memory state at each iteration of the main loop therefore takes the following \nform. hinv V BQ = (g . GraphAdjList G) * (v . Array V ) * (b . Array B) * (q . Pqueue Q) * [inv V BQ] \nThe proof that the function dijkstra satis.es its speci.cation consists of two parts. The .rst part is \nconcerned with a number of mathematical theorems that justify the method used by Dijkstra s algorithm \nfor computing shortest paths. This part, which amounts to 180 lines of Coq scripts, is totally independent \nof characteristic formulae and would presumably be needed in anyapproach to pro\u00adgram veri.cation. The \nsecond part consists of one theorem, whose statementisthe speci.cationgiven earlieron,and whose purposeis \nto establish that the source code correctly implements Dijkstra sal\u00adgorithm. The proof of this theorem \nfollows the structure of the char\u00adacteristic formula generated, and therefore also follows the struc\u00adture \nof the source code. Figure 4 show the beginning of the proof script for this ver\u00adi.cation theorem. The \nscript contains three kind of tactics. First, x-tactics are used to make progress through the characteristic \nfor\u00admula.Forexample, the tactic xwhile inv is used to provide the loop invariant and the termination \nrelation. Here, termination is jus\u00adti.ed by a lexicographical order whose .rst component is the size \nof the number of node treated (this number increases from zero up to the total number of nodes) and whose \nsecond component is the size of the priority queue. Second, general-purpose Coq tac\u00adtics (all those whose \nname does not start with the letter x ) are typically used to name variables, unfold invariants, and \ndischarge simple side-conditions. Third, the proof script contains invocations of the mathematical theorems \nmentioned earlier on.Forexample, the script containsareferencetothe lemma inv start,which jus\u00adti.es that \nthe loop invariant holds at the .rst iteration of the loop. Overall, this veri.cation proof contains \na total of 48 lines, includ\u00ading8linesof statementoftheinvariants,andCoqisabletoverify the proofin8seconds \nona3GHz machine. Figure5gives anexampleofa proof obligation that arises dur\u00ading the veri.cation of the \nfunction dijkstra. The set ofhypotheses appears above the dashed line. Observe that all thehypotheses \nare short and well-named. Those names are provided explicitly in the proof script. Providing names is \nnot mandatory, however it gener\u00adally helps to increase readability and robustness. The proof obliga\u00adtion \nappears below the dashed line. It consists of a characteristic formula being applied to a pre-condition \nand to a post-condition. Note that, in Coq, characteristic formula are pretty-printed using capitalizedkeywords \ninstead of boldkeywords and the sequence operator is written ;; .  xcf. introv Pos Ns De. unfold GraphAdjList \nat 1. hdata simpl. xextract as N Neg Adj. xapp. intros Ln. rewrite <-Ln in Neg. xapps. xapps. xapps. \nxapps-. xapps. set (data := fun B V Q => g -> Array N \\* v -> Array V \\* b -> Array B \\* q -> Heap Q). \nset (hinv := fun VQ => let '(V,Q) := VQ in Hexists B, dataBVQ \\* [invGnsVBQ (crossingGsV)]). xseq (fun \n=> Hexists V, hinv (V,\\)). set (W := lexico2 (binary map (count (= true)) (upto n)) (binary map card \n(downto 0))). xwhile inv W hinv. (* --initial state satisfies the invariant --*) refine (ex intro' ( \n, )). unfold hinv,data. hsimpl. applys eq-inv start 2. permut simpl. (* --verification of the loop --*) \nintros [V Q]. unfold hinv. xextract as B Inv. xwhilebody. Figure 4. Beginning of the proof script for \nDijkstra s algorithm Pos : nonnegative edges G Ns:s \\innodes G Ne:e \\innodes G Neg : nodes index G n \nAdj :forall x y w: int, x \\in nodes G -> Mem (y, w) (N\\(x)) = has edge G x y w Nx:x \\innodesG Vx : V\\(x) \n-Dx:Finitedx =distGs x Inv:invGnsV' BQ (new crossingGsxL' V) EQ :N\\(x) =rev L' ++ (y, w) :: L Ew:has \nedge G x y w Ny:y \\innodesG (1/6) (Letdy := Ret (dx + w) in Letfy := Appml array get b y ; in If Match \n(Case fy = Finite d [d] Then Ret (dy < d) Else (Case fy = Infinite Then Ret true Else Done)) Then (App \nml array set b y (Finite dy) ;) ;; App push (y, dy) h ; Else (Ret tt)) (q-> Pqueue Q \\* b -> Array B \n\\* v -> Array V' \\* g -> Array N) (fun :unit => hinv' L) Figure 5. Example of a proof obligation  4.2 \nCounter function This example illustrates the treatment of functions with an abstract local state. A \ncounter function is a function that, every time it is called, returns the successor of the integer that \nit returned on the previous call. The function create constructs a new counter function. It allocates \na fresh reference r with initial contents 0, and buildsa function whose body incrementsr and returns \nits contents. create = ._. let r = ref 0 in (._. (incr r ; get r)) To specify the function create in \nan abstract manner, we use a representation predicate, called Cntr. The heap predicate f Cntr n asserts \nthat f isa counter function whose last call returned the value n. The de.nition of Cntr involves an existential \nquanti.\u00adcation over a predicate I of type int . Hprop , as shown below: Cntr nf =. I. (In) * [.m. App1 \nf tt (Im)(.x. [x = m + 1] * I (m + 1))] The existential quanti.cation of I allows us to state that a \ncall to the counter function f takes the counter from a state Im toa state I (m + 1) and returns the \nvalue m +1, without revealing anydetails of the implementation of this counter function. The function \ncreate is then speci.ed as producing a function f that is a counter with internal state 0. App create \ntt [](.f. f Cntr 0) This speci.cation is suf.cient for reasoning about all the calls to a counter function \nproduced by the function create. That said, we can go even further in terms of abstraction. Instead of \nforcing the client of the function create to manipulate the de.nition of Cntr, we can make the de.nition \nof the predicate Cntr completely abstract and instead provide a direct lemma for reasoning about calls \nto counter functions. This lemma takes the following form: .fn. App f tt (f Cntr n)(.x. [x = n+1]*f Cntr \n(n+1)) This example illustrates how the abstract local state of a function can be entirely packed into \na representation predicate. 4.3 Continuations The CPS-append function has been proposed asaveri.cation \nchal\u00adlengebyReynolds[39],for testingthe abilityto specifyand reason about continuations that are used \nin a nontrivial way. The CPS\u00adappend function takes as an argument two lists x and y, as well as an initial \ncontinuation k. In the end, the function calls the con\u00adtinuation k on the concatenation of this lists \nx and y. What makes this function nontrivial is that it does notbuild the list x+ y ex\u00adplicitly. Instead, \nthe function calls itself recursively using a differ\u00adent continuation at every iteration. The nested \nexecution of those continuations starts from the list y and eventually produces the list x+ y. This list \nis then passed as an argument to the original con\u00adtinuation k. The code of the CPS-append function is: \nlet rec cpsapp (x y:'a list) (k:'a list->'b) : 'b = match x with I [] -> ky I v::x' -> cpsapp x' y (fun \nz -> k (v::z)) Its speci.cation is as follows, where k has type Func, x and y have type listA , and + \ndenotes the concatenation of two Coq lists: .AxykHQ. App1 k (x+ y) HQ . App3 cpsapp xykHQ Slightly more \nchallenging is the veri.cation of the imperative counterpart of the CPS-append function. It is based \non the same principle as the purely-functional version, except that x and y are now pointers to mutable \nlists and that the continuations mutate pointers in the list x in order tobuild the concatenation of \nthe two lists in place. The speci.cation of this imperative version is: .AxykLMHQ. (.z. App1 kz (H * \n(z Mlist (L+ M))) Q) . App3 cpsapp' xyk (H * (x Mlist L) * (y Mlist M)) Q Above, the pre-condition asserts \nthat the locations x and y (of type Loc)correspond to lists calledL and M, respectively. The pre-condition \nalso mentions an abstract heap predicate H, which is needed because the frame rule usually does not apply \nwhen reasoning about CPS functions. Indeed, the entire heap needs to be passed on to the continuation3. \nThe continuation k is ultimately called onalocation z that corresponds to the list L+ M. The proof that \nthe imperative CPS-append function satis.es its speci.cation is conducted by induction on L.Itisonly8lines \nlong.  4.4 Imperative list iterator This last example requires a generalized version of the representa\u00adtion \npredicate for lists.Sofar, wehave used heap predicatesof the form m Mlist L. This works well when the \nvalues in the list are of some base type, however in general the values stored in the list 3Thielecke \n[40] suggested that answer-type polymorphism could be used to design reasoning rules that would save \nthe need for quantifying over the heap H passed on to the continuation. However, his technique has limitations, \nin particular it does not support recursion through the store.  need to be described using their own \nrepresentation predicate, call it T .To that end, we use a more general parametric representation predicate, \nwritten Mlistof T . (The predicate Mlist usedsofar canbe obtained as the application of Mlistof to the \nidentity representation predicate, which is de.ned as .X. .x. [x = X] .)For example, we will later use \nthe heap predicate m Mlistof Cntr L to de\u00adscribe a mutable list that starts at location m and contains \na list of counter functions whose internal states are describedby the integer values from the Coq list \nL. We are now ready to describe the speci.cation of an higher\u00adorder iterator on mutable lists. This iterator, \ncalled iter, is imple\u00admented using a while loop. The execution of iter fm results in the function f beingappliedtoallthevalues \nstoredinthelistwhose head is located as address m. This execution may result in two ef\u00adfects. First, \nit may modify the values stored in the list. Second, it may affect the state of other mutable data structures. \nThus, if the initial state is described as H * (m Mlistof TL), then the .nal state generally takes the \nform H ' * (m Mlistof TL ' ), where H and H ' are two heap descriptions and L and L ' are two Coq lists. \nTo introduce some abstraction, we use a predicate calledI. The in\u00adtention is that the proposition ILL \n' HH ' captures thefact that, for any m, the term iter fm admits the pre-condition H * (m Mlistof TL) \nand the post-condition ._.H ' *(m Mlistof TL ' ). Two assumptions are provided for reasoning about the \npredi\u00adcate I. The .rst one concerns the case where the list is empty. In this case, both L and L ' are \nempty, and H ' must match H. The sec\u00adondone concernsthecasewherethelistisnotempty.Inthiscase,a call to \nf is .rst performed and then a recursive call to the function iter is made. The initial state of the \nlist is then of the form X :: L and the .nal state is of the form X ' :: L '. The values X and X ' are \nrelatedbythe speci.cationofthe function f. This speci.cation also relates the input state H with an intermediate \nstate H '', which corresponds to the state after the call to f and before the recursive call to iter. \nThe formal statement of the assumptions about I are: H1 =.H. I nil nil HH ' ''' H2 =.XX LL ' HH H . '' \n* x (.x. App1 fx (H * x TX)(H TX ' )) ''' '' . ILL ' HH . I (X :: L)(X :: L ' ) HH Above, L and L ' have \ntype listA, f has type Func, X has type A, x has type B, and T has type A . B . Hprop. To establish that \nthe term iter fm admits the pre-condition H * (m Mlistof TL) and the post-condition ._.H ' * (m Mlistof \nTL ' ), it suf.ces to prove the proposition ILL ' HH ' , where I is an abstract predicate for which only \nthe assumptions H1 and H2 areprovided.This resultis capturedbythe speci.cationof iter shown next: .ABT \nfmLL ' HH ' . (.I. H1 .H2 . ILL ' HH ' ) . App2 iter fm (H * (m Mlistof TL)) (._.H ' * (m Mlistof TL \n' )) To check the usability of this speci.cation, we describe an example, which involves a list m of \ndistinct counter functions (as de.nedin\u00a74.2).Theideaistomakeacalltoeachofthose counters. The results \nof those calls are simply ignored. What matters here is that every counter sees its current state incremented \nby one. The function steps implements this scenario. steps = .m. iter (.f. ignore (f tt)) m The heap \npredicate m Mlistof Cntr L asserts that the mutable list starting at location m containsa listof counter \nfunctions whose internal states are described by the integer values from the Coq list L. A call to the \nfunction steps on the list m increments the internal state of every counter, so the the .nal state is \ndescribed by the heap predicate m Mlistof Cntr L ' , where L ' is obtained by adding one to all the elements \nin L. Thus, steps is speci.ed as: .mL. App1 steps m (m Mlistof Cntr L) (._.m Mlistof Cntr (map (+1) L)) \n This example demonstrates the ability of CFML to formally verify the application of a polymorphic higher-order \niterator to an imperative list of .rst-class functions with abstract local state. 5. Related work Program \nlogics Aprogram logic consists of a speci.cation lan\u00adguage and of a set of reasoning rules that can be \nused to establish that a program satis.es a speci.cation. Program logics do not di\u00adrectlyprovideaneffective \nprogramveri.cation tool,buttheymay serve as a basis for justifying the correctness of such a tool. Hoare \nlogic [17] is probably the most well-known program logic. Sepa\u00adration Logic [39] is an extension of Hoare \nlogic that supports lo\u00adcal reasoning.Anumberofveri.cation toolshave beenbuilt upon ideas from Separation \nLogic, forexample Smallfoot [5]. Separation Logic frequently been exploited inside standard interactive \nproof assistants (e.g., [1, 10, 26, 27, 30]), including the present paper. Dy\u00adnamic Logic [15] is another \nprogram logic. In this modal logic, the formula H1 ..t. H2 asserts that, in anyheap satisfying H1,the \nsequence of commands t terminates and producesa heap satisfying H2. Dynamic Logic serves as the foundation \nof theKeY system [4], which targets the veri.cation of Java programs. One problem with Dynamic Logics \nis that theydepart from standard mathemati\u00adcal logic, precluding the use of a standard proof assistant. \nThe aforementioned logics usually do not support reasoning about higher-order functions.Aprogram logic \nsupporting them has beendevelopedby Honda,BergerandYoshida[6].The speci.ca\u00adtion language of Honda et \nal s logic is a nonstandard .rst-order logic, which features an ad-hoc construction, called evaluation \nfor\u00admula and written {H} v v ' . x {H ' }. This proposition asserts that under a heap satisfying H, \nthe application of the value v to the value v ' produces a result named x in a heap satisfying H ' . \nThis evaluation formula plays a similar role as that of the predi\u00adcate App. Another speci.city of the \nspeci.cation language is that its values are the values of the programming language, including non-terminating \nfunctions. This use of such a nonstandard speci\u00ad.cation language prevented Honda et al frombuildinga \npractical veri.cation tool on top of an existing theorem prover. In contrast, the characteristic formulae \nthat we generate are expressed in terms of a standard higher-order logic predicates. Veri.cation condition \ngenerators AVeri.cation Condition Gen\u00aderator(VCG)isatoolthat,givenaprogram annotatedwithitsspec\u00adi.cation \nand its invariants, extracts a set of proof obligations that entails the correctness of the program. \nA large number of VCGs targeting various programming languages have been implemented in the last decades.Forexample, \nthe Spec-# tool[2] parses anno\u00adtated C# programs, and then produces proof obligations that can then be \nsent to an SMT solver. Because most SMT solvers can only cope with .rst-order logic, the speci.cation \nlanguage is usually re\u00adstricted to this fragment, and therefore does not bene.t from the expressiveness, \nmodularity, and elegance of higher-order logic. A few tools support higher-order logic. One notable example \nis the tool Why [12]. When the proof obligations produced by Why cannot be veri.ed automatically by at \nan SMT solver, they can be discharged using an interactive proof assistant such as Coq. Recent work has \nfocused on trying to extend Whywith support for higher-order functions [20],building upon ideas developed \nfor the tool Pangolin [38]. Another tool that supports higher-order logic is Jahob [42], which targets \nthe veri.cation of programs written in a subset of Java. For discharging proof obligations, Jahob relies \non a translation from (a subset of) higher-order logic into .rst order logic, as well as on automated \ntheorem proversextended with specialized decision procedures for reasoning on lists, trees, sets and \nmaps.Akeyfeature of Jahob is its integrated proof language, which allows the user to include proof hints \ndirectly inside the source code. Those hints are intended to guide automated theorem provers, in particular \nby indicating how to instantiate existential variables. When trying to verify complex programs, the central \ndif.culty is to come up with the correct invariants, a process that usually requiresagreat numberof iterations.WithaVCGtoolsuch \nas Why or Jahob, if the user changes, say, a local loop invariant, then he needs to run the VCG tool, \nwait for the SMT solvers to try and discharge the proof obligations, and then read the remaining obligations. \nOn the contrary, with characteristic formulae, the user works in an interactive setting that provides \nnearly-instantaneous feedback on changes to the invariants.  Shallow embeddings The shallow embedding \napproach to pro\u00adgramveri.cation aimsat relatingasource programtoacorrespond\u00ading logical de.nition. The \nrelationship can take three forms. First, one can write a logical de.nition and use an extraction mechanism \n(e.g., [25]) to translate the code into a conventional programming language. For example, Leroy s certi.ed \nC com\u00adpiler [23] is developed in this way. Also based on extraction is the tool Ynot [10], which implements \nHoareType Theory (HTT) [33], by axiomatically extending the Coq language with a monad for encapsulating \nside effects and partial functions. HTT was also later re-implemented by Nanevski et al [34] without \nusing any ax\u00adioms, yet at the expense of loosing the ability to reason on higher\u00adorder stores. In HTT, \nthe monad involved has a type of the form STsep PQ , and it correponds to a partial-correctness speci.ca\u00adtion \nwith pre-condition P and post-condition Q.Veri.cation proofs take the form of Coq typing derivations \nfor the source code. So, program veri.cation is done at the same time as type-checking the source code. \nThis is a signi.cant difference with characteristic for\u00admulae, which allow verifying programs after theyhave \nbeen writ\u00adten, without requiring the source code to be modi.ed in any way. Moreover,characteristic formulae \nare ableto targetanexisting pro\u00adgramming language, whereas the Ynot programming language has to .t into \nthe logicitis implemented in.Forexample, supporting handy features such as alias-patterns and when-clauses \nwould be a real challenge for Ynot. (Pattern matching is so deeply hard-wired in Coq that it would be \nvery hard to modify it.) Another technicaldif.cultyfacedbyHTTisthe treatmentof auxiliaryvariables.Aspeci.cationofthe \nform STsep PQ does not naturally allow for auxiliary variables to be used for sharing in\u00adformation between \nthe pre-and the post-condition. Indeed, if P and Q both refer to a auxiliary variable x quanti.ed outside \nof the type STsep PQ , then x is considered as a computationally-relevant value and thus it will appear \nin the extracted code. Ynot [10] re\u00adliesonahackfor simulatingthe Implicit Calculusof Constructions [3], \nin which computationally-irrelevant value are tagged explic\u00aditly.Adangerofthis approachisthatforgettingtotagavariableas \nauxiliary does not produce any warning yet results in the extracted code being inef.cient. Other implementation \nof HTT have taken a different approach by relying on post-conditions that may also re\u00adfer not only to \nthe output heapbut also to the input heap [33, 34]. The use of such binary post-conditions makes it possible \nto elimi\u00adnate auxiliary variables by duplicating the pre-condition inside the post-condition.Typically, \nin informal notation, .x. STsep PQ gets encoded as STsep (.x.P )(.x. P . Q) . HTT [34] then provides \ntactics to try and avoid the duplication of proof obliga\u00adtions. However, duplication typically remains \nvisible in speci.ca\u00adtions, which is problematic. Indeed, speci.cations are part of the trusted base, \nso their statement should be as simple as possible. The second way of relating a source program to a \nlogical de.\u00adnition consists in decompiling a piece of conventional source code into a set of logical \nde.nitions. This approach is used in the LOOP compiler [19] and also in Myreen and Gordon s work [31]. \nThe LOOP compiler takes Java programs and compiles them into PVS de.nitions. The proof tactics rely on \na weakest-precondition cal\u00adculus to achieve a high degree of automation. However, interactive proofs \nrequire a lot of expertise: LOOP requires the user to un\u00adderstand the compilation scheme involved [19]. \nBy contrast, the tactics manipulating characteristic formulae allow conducting in\u00adteractive proofs of \ncorrectness without detailed knowledge on the construction of those formulae. Myreen and Gordon showed \nhow to decompile machine code into HOL4 functions [31]. The lem\u00admas proved interactively about the generated \nHOL4 functions can then be automatically transformed into lemmas about the behav\u00adior of the corresponding \npieces of machine code.Importantly, the translation into HOL4 is possible only because the functional \ntrans\u00adlation of a while loop is a tail-recursive function, and because tail\u00adrecursive functions can be \naccepted as logical de.nitions in HOL4 without compromising the soundness of the logic even when the \nfunctionis non-terminating.Withoutexploiting this peculiarityof tail-recursive functions, the automated \ntranslation of source code into HOL4would notbe possible.For this reason,it seems hardto applythis decompilation-based \napproachtotheveri.cationofcode featuring general recursion and higher-order functions. Athird approachto \nusingashallow embedding consistsin writ\u00ading the program to be veri.ed twice, once as a program de.ni\u00adtion \nand once as a logical de.nition, and then proving that the two are related. This approach has been employed \nin the veri.cation of a microkernel as part of the Sel4 project [22]. Compared with Myreen and Gordon \ns work [29, 31], the main difference is that thelow-level codeis not decompiled automaticallybut instead \nde\u00adcompiledbyhand,andthatthis decompilationphaseisthenproved correct using semi-automated tactics. The \nSel4 approach thus al\u00adlows for more .exibility in the choice of the logical de.nitions, yet at the expense \nof a bigger investment from the user. Moreover, like in Myreenand Gordon swork, general recursionis problematic:all \nthe code of the Sel4 microkernel written in the shallow embedding had to avoid anyform of nontrivial \nrecursion [21]. In summary, all approaches based on shallow embedding share one central dif.culty: the \nneed to overcome the discrepancies be\u00adtween the programming language and the logical language, in par\u00adticular \nwith respect to the treatment of imperative functions, partial functions, and recursive functions. In \ncontrast, characteristic for\u00admulae rely on the .rst-order data type Func for representing func\u00adtions. \nAs established by the completeness theorem, this approach supports reasoning about all forms of .rst-class \nfunctions. Deep embeddings Adeep embedding consists of describing the syntax and the semantics of a programming \nlanguage in the logic of a proof assistant, using inductive de.nitions. In theory, a deep embedding can \nbe used to verify programs written in anyprogram\u00adming language, without anyrestrictions in terms of expressiveness \n(apart from those of the proof assistant). Mehta and Nipkow [28] have set up the .rst proof-of-concept \nby formalizing a basic pro\u00adcedural language in Isabelle/HOL and proving Hoare-style reason\u00ading rules \ncorrect with respect to the semantics of that language. More recently, Shao et al have developed the \nframeworks such as XCAP [35] for reasoning in Coq about shortbut complex assem\u00adbly routines. In previous \nwork [7], the author has worked on a deep embedding of the pure fragment of Caml inside the Coq proof \nas\u00adsistant. This work then lead to the development of characteristic formulae,whichcanbeviewedasan abstractlayerbuiltontopofa \ndeep embedding: characteristic formulae hide the technical details associatedwiththeexplicit representationofsyntaxwhile \nretaining the high expressiveness of that approach. In particular, characteris\u00adtic formulae avoid the \nexplicit representation of syntax, which is associated with manytechnical dif.culties (including the \nrepresen\u00adtation of binders). Moreover, when moving to characteristic formu\u00adlae, speci.cations canbegreatly \nsimpli.ed because programvalues such as tuples and functional lists become directly represented with \ntheir logical counterpart.  6. Conclusion Inthispaper, wehaveexplainedhowtobuild characteristic formu\u00adlae \nfor imperative programs, and we have shown how to use those formulaein practiceto formallyverify programsinvolving \nnontriv\u00adial interactions between .rst-class functions and mutable state. References [1] AndrewW. Appel. \nTactics for separation logic. Unpublished draft, http://www.cs.princeton.edu/appel/papers/septacs.pdf, \n2006. [2] Mike Barnett, Rob DeLine, Manuel F\u00e4hndrich, K. Rustan M. Leino, andWolfram Schulte. Veri.cation \nof object-oriented programs with invariants. Journalof ObjectTechnology, 3(6), 2004. [3] Bruno Barras \nand Bruno Bernardo. The implicit calculus of construc\u00adtions as a programming language with dependent \ntypes. In FoSSaCS, volume 4962 of LNCS, pages 365 379. Springer, 2008. [4] Bernhard Beckert, Reiner H\u00e4hnle, \nand Peter H. Schmitt. Veri.cation of Object-Oriented Software: TheKeY Approach,volume 4334 of LNCS. Springer-Verlag, \nBerlin, 2007. [5] Josh Berdine, Cristiano Calcagno, and PeterW. O Hearn. Smallfoot: Modular automatic \nassertion checking with separation logic. In Inter\u00adnational Symposium onFormal Methods for Components \nand Objects, volume 4111 of LNCS, pages 115 137. Springer, 2005. [6] Martin Berger,Kohei Honda, and NobukoYoshida.Alogical \nanalysis of aliasing in imperative higher-order functions. In ICFP, pages 280 293, 2005. [7] Arthur Chargu\u00e9raud. \nVeri.cation of call-by-value functional programs through a deep embedding. 2009. Unpublished. http://arthur.chargueraud.org/research/2009/deep/. \n[8] Arthur Chargu\u00e9raud. Characteristic Formulae for Mechanized Pro\u00adgramVeri.cation. PhD thesis, Universit\u00e9Paris-Diderot, \n2010. [9] Arthur Chargu\u00e9raud. Programveri.cation through characteristic for\u00admulae. In ICFP, pages 321 \n332.ACM, 2010. [10] Adam Chlipala, Gregory Malecha, GregMorrisett,Avraham Shinnar, and Ryan Wisnesky. \nEffective interactive proofs for higher-order imperative programs. In ICFP, 2009. [11] The Coq Development \nTeam. The Coq Proof Assistant Reference Manual,Version 8.2, 2009. [12] Jean-Christophe Filli\u00e2tre.Veri.cationof \nnon-functional programs us\u00ading interpretations in type theory. Journal of Functional Program\u00adming, 13(4):709 \n745, 2003. [13] Cormac Flanagan, Amr Sabry, BruceF. Duba, and Matthias Felleisen. The essence of compiling \nwith continuations. In PLDI, pages 237 247, 1993. [14] Susanne Graf and Joseph Sifakis. Amodal characterization \nof obser\u00advational congruence on .nite terms of CCS. Information and Control, 68(1-3):125 145, 1986. [15] \nDavid Harel, DexterKozen, and JerzyTiuryn. Dynamic Logic. The MIT Press, Cambridge, Massachusetts, 2000. \n[16] Matthew Hennessy and Robin Milner. On observing nondeterminism and concurrency. In ICALP, volume \n85 of LNCS, pages 299 309. Springer-Verlag, 1980. [17] C. A. R. Hoare. An axiomatic basis for computer \nprogramming. Communicationsof theACM, 12(10):576 580, 583, 1969. [18]Kohei Honda, Martin Berger, and \nNobukoYoshida. Descriptive and relative completeness of logics for higher-order functions. In ICALP, \nvolume 4052 of LNCS. Springer, 2006. [19] Bart Jacobs and Erik Poll. Java program veri.cation at nijmegen: \nDevelopments and perspective. In ISSS, volume 3233 of LNCS, pages 134 153. Springer, 2003. [20] Johannes \nKanig and Jean-Christophe Filli\u00e2tre. Who: a veri.er for effectful higher-order programs. In ML 09: Proceedings \nof the 2009 ACM SIGPLAN workshop on ML, pages 39 48.ACM, 2009. [21] Gerwin Klein, Philip Derrin, and \nKevin Elphinstone. Experience report: seL4: formally verifying a high-performance microkernel. In ICFP, \npages 91 96.ACM, 2009. [22] Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock, \nPhilip Derrin, Dhammika Elkaduwe, Kai Engelhardt, RafalKolanski, Michael Norrish, Thomas Sewell, HarveyTuch, \nand SimonWinwood. seL4:Formal veri.cationof anOSkernel. In Proceedings of the 22nd Symposium on Operating \nSystems Principles (SOSP), Operating Systems Review (OSR), pages 207 220, Big Sky, MT, 2009.ACM SIGOPS. \n[23] Xavier Leroy. Formal certi.cation of a compiler back-end or: pro\u00adgramming a compiler with a proof \nassistant. In POPL, pages 42 54, 2006. [24] Xavier Leroy, Damien Doligez, Jacques Garrigue, Didier R\u00e9my, \nand J\u00e9r\u00f4meVouillon. The Objective Caml system, 2005. [25] Pierre Letouzey. Programmation fonctionnelle \ncerti.\u00e9e l extraction de programmes dans l assistant Coq. PhD thesis, Universit\u00e9Paris 11, 2004. [26] \nNicolas Marti, Reynald Affeldt, and Akinori Yonezawa. Towards formalveri.cationof memory properties using \nseparation logic, 2005. [27] AndrewMcCreight. Practical tactics for separation logic. In TPHOLs, volume \n5674 of LNCS, pages 343 358. Springer, 2009. [28] Farhad Mehta and Tobias Nipkow. Proving pointer programs \nin higher-order logic. Information and Computation, 199(1 2), 2005. [29] Magnus O. Myreen. FormalVeri.cationof \nMachine-CodePrograms. PhD thesis, University of Cambridge, 2008. [30] Magnus O. Myreen. Separation logic \nadapted for proofs by rewriting. In Interactive Theorem Proving (ITP), volume 6172 of LNCS, pages 485 \n489. Springer, 2010. [31] Magnus O. Myreen and Michael J. C. Gordon. Veri.ed LISP imple\u00admentations on \nARM, x86 and powerPC. In TPHOLs, volume 5674 of LNCS, pages 359 374. Springer, 2009. [32] Aleksandar \nNanevski and GregMorrisett. Dependent type theory of stateful higher-order functions. Technical Report \nTR-24-05, Harvard University, 2005. [33] Aleksandar Nanevski, J. Gregory Morrisett, and Lars Birkedal. \nHoare type theory, polymorphism and separation. Journal of Functional Programming, 18(5-6):865 911, 2008. \n[34] Aleksandar Nanevski,ViktorVafeiadis, and Josh Berdine. Structuring theveri.cationof heap-manipulating \nprograms.In POPL, pages 261 274.ACM, 2010. [35] Zhaozhong Ni and Zhong Shao. Certi.ed assembly programming \nwith embedded code pointers. In POPL, 2006. [36] Peter O Hearn, JohnReynolds, and HongseokYang. Local \nreasoning about programs that alter data structures. In CSL, volume 2142 of LNCS, pages 1 19, Berlin, \n2001. Springer-Verlag. [37] Chris Okasaki. Purely Functional Data Structures. Cambridge Uni\u00adversity Press, \n1999. [38] Yann R\u00e9gis-Gianas and Fran\u00e7ois Pottier. AHoare logic for call-by\u00advalue functional programs. \nIn MPC, 2008. [39] John C. Reynolds. Separation logic:Alogic for shared mutable data structures. In LICS, \npages 55 74, 2002. [40] Hayo Thielecke. Frame rules from answer types for code pointers. In POPL, pages \n309 319, 2006. [41] ThomasTuerk. Local reasoning about while-loops. In VSTTE LNCS, 2010. [42] KarenZee,ViktorKuncak,and \nMartinC. Rinard.Anintegratedproof language for imperative programs. In PLDI, pages 338 351.ACM, 2009. \n   \n\t\t\t", "proc_id": "2034773", "abstract": "<p>In previous work, we introduced an approach to program verification based on characteristic formulae. The approach consists of generating a higher-order logic formula from the source code of a program. This characteristic formula is constructed in such a way that it gives a sound and complete description of the semantics of that program. The formula can thus be exploited in an interactive proof assistant to formally verify that the program satisfies a particular specification.</p> <p>This previous work was, however, only concerned with purely-functional programs. In the present paper, we describe the generalization of characteristic formulae to an imperative programming language. In this setting, characteristic formulae involve specifications expressed in the style of Separation Logic. They also integrate the frame rule, which enables local reasoning. We have implemented a tool based on characteristic formulae. This tool, called CFML, supports the verification of imperative Caml programs using the Coq proof assistant. Using CFML, we have formally verified nontrivial imperative algorithms, as well as CPS functions, higher-order iterators, and programs involving higher-order stores.</p>", "authors": [{"name": "Arthur Chargu&#233;raud", "author_profile_id": "81372592434", "affiliation": "Max Planck Institute for Software Systems, Kaiserslautern, Germany", "person_id": "P2801455", "email_address": "charguer@mpi-sws.org", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034828", "year": "2011", "article_id": "2034828", "conference": "ICFP", "title": "Characteristic formulae for the verification of imperative programs", "url": "http://dl.acm.org/citation.cfm?id=2034828"}