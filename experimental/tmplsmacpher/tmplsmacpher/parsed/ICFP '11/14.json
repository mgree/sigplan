{"article_publication_date": "09-19-2011", "fulltext": "\n On the Bright Side of Type Classes: Instance Arguments in Agda Dominique Devriese Frank Piessens KULeuven \n {daminique.devriese,frank.piessens} s.kuieuven.be Abstract We present instance arguments: an alternative \nto type classes and related features in the dependently typed, purely functional pro\u00adgramming language/proof \nassistant Agda. They are a new, general type of function arguments, resolved from call-site scope in \na type\u00addirected way. The mechanism is inspired by both Scala s implicits and Agda s existing implicit \narguments, but differs from both in important ways. Our mechanism is designed and implemented for Agda, \nbut our design choices can be applied to other programming languages as well. Like Scala s implicits, \nwe do not provide a separate structure for type classes and their instances, but instead rely on Agda \ns standard dependently typed records, so that standard language mechanisms provide features that are \nmissing or expensive in other proposals. Like Scala, we support the equivalent of local instances. Unlike \nScala, functions taking our new arguments are .rst-class citizens and can be abstracted over and manipulated \nin standard ways. Compared to other proposals, we avoid the pitfall of introducing a separate type-level \ncomputational model through the instance search mechanism. All values in scope are automatically candidates \nfor instance resolution. A .nal novelty of our approach is that existing Agda libraries using records \ngain the bene.ts of type classes without any modi.cation. We discuss our implementation in Agda (to be \npart of Agda 2.2.12) and we use monads as an example to show how it allows existing concepts in the Agda \nstandard library to be used in a similar way as corresponding Haskell code using type classes. We also \ndemonstrate and discuss equivalents and alternatives to some advanced type class-related patterns from \nthe literature and some new patterns speci.c to our system. Categories and Subject Descriptors D.3.3 \n[Programming Lan\u00adguages]: Language Constructs and Features General Terms Languages Keywords Agda, instance \narguments, type classes, ad hoc poly\u00admorphism Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. ICFP 11, September 19 21, 2011, Tokyo, Japan. Copyright c &#38;#169; \n2011 ACM 978-1-4503-0865-6/11/09. . . $10.00 1. Introduction 1.1 Type Classes In 1998, a group of scholars \non the Haskell Committee were fac\u00ading the problem of .xing the types of the numeric and equal\u00adity operators \nin the emerging Haskell programming language [8]. These operators feature a natural requirement for overloading \nor ad hoc polymorphism. For example, the == operator, of type t. t. Baai, should only be de.ned for certain \ntypes t(e.g. Bool, Integer) and not for others (e.g. function types). Addition\u00adally, different implementations \nare required for different types t. The committee at the time recognized the issue as an instance of \na more general problem in need of a general solution and adopted Wadler s proposal for what is now known \nas the Haskell type class system. For the == operator, the solution is based on a type class Eqt, with \ninstances for appropriate types t. To avoid troubling this section with notations for in.x operators, \nwe write equaifor ==. class Eqtwhere equai:: t. t. Baai instance EqBaaiwhere equai= primEqBaai instance \nEqIntegerwhere equai= primEqInteger neq:: Eqt. t. t. Baai neqab= not (equaiab) test:: Baai test= equai(5 \n:: Integer)5 Subclasses can also be de.ned: data Ordering= LT| EQ| GT class Eqt. Ordtwhere ampare:: t. \nt. Ordering An essential requirement for type classes to work is that func\u00adtions like neqwhich use the \nequaioperator for an abstract type tdeclare this in their type. The compiler can then check that the \nrequired instances are de.ned when tis instantiated to a concrete type: when equaiis called on two Integervalues \nin the de.nition of test, it looks for an Integerinstance of the type class in scope and uses that instance \ns implementation of the equaioperator. Before we continue, we want to make it clear that when talk\u00ading \nabout Haskell, we will amalgamate the type class concept in Haskell proper with common and uncontroversial \nextensions like FiexibieCantexts, FiexibieInstanes, MuitiParamTypeCiasses, TypeFamiiiesand RankNTypes. \nNote also that when we mention ad hoc polymorphism, we mean open ad hoc polymorphism. This means that \nadditional in\u00adstances of abstract concepts can be added independently by users of functions that require \nthe concept. If openness is not required, Agda supports other solutions based on the de.nition of a universe \nrepresenting the complete set of types that satisfy the concept.  1.2 The downsides of an extra structuring \nconcept A disadvantage of Haskell s type class system is that classes and instances form a separate, \nspecial-purpose structuring concept, in addition to the more standard algebraic data types (ADTs). Because \nof this duplication of functionality, many of the features that have in the past been introduced as extensions \nof type classes duplicate features that already existed for ADTs. Constraint families [18] (al\u00adlowing \nclasses to have abstract constraints on type class parame\u00adters) and associated type families [23] (allowing \nclasses to specify abstract types) both roughly correspond to how generalized alge\u00adbraic data type [21] \nvalues can carry types or type functors that are not parameters of the data type. In the area of generic \nprogram\u00adming, succesful techniques existed for ADTs [19], but these have had to be adapted for type classes \n[12, 27]. Another example is how higher-rank types [22] have long al\u00adlowed ADTs to be abstracted over. \nHowever, in a paper about a datatype-generic programming technique [12], L\u00e4mmel and Peyton Jones note \nthat this is not possible for type classes. In the follow\u00ading pseudo-code, they wanted to abstract over \na type class xt(the meaning of these type classes is not important here): --Pseudo-Haskell class (Typeabiea, \nxta) . Dataxtawhere gmapQ:: (faraiib.Dataxtb. b. r) . a. [r] instance DataSizet. Sizetwhere gsizet=1+ \nsum(gmapQgsizet) This pseudo-code is not legal Haskell so L\u00e4mmel and Peyton Jones provide a solution \nbased on a generic type class Satparame\u00adterised by the type of a dictionary record that it should carry: \nclass Satawhere dit:: a We .nd this a clever solution, but it amounts to replacing a type class with \nan ADT for which the desired feature (abstracting over one) is available. 1.3 Dictionary Translation \nA well-known model of type classes using standard ADTs is known as dictionary translation [26]. This \ntranslation is often used as an implementation strategy, but also gives an accurate semantic model of \nthe type class concept. A type class is modelled as a dictionary record type, with the type class operations \nas record .elds. Instances become record values with as .elds the de.nitions in the instance. The above \ncode translates to the following: data Eqt= EqDit{equai:: t. t. Baai} data Ordt= OrdDit{eqDit:: Eqt , \nampare:: t. t. Ordering} baaiEq:: EqBaai baaiEq= EqDitprimEqBaai intEq:: EqInteger intEq= EqDitprimEqInteger \nneq:: Eqt. t. t. Baai neqditab= not (equaiditab) test:: Baai test= equaiintEq55 Striking about this translation \nis that the resulting code is not actually that far from the original. Apart from the additional naming \nof instances (which has also been proposed for Haskell [10]), the translation only produces extra verbiage \nin the implementation of functions that use the type class s operations. In the neqfunction, the dictionary \nof type Eqtis now passed around explicitly where this was implicitly done for us before. Additionally, \nin the de.nition of test, we need to explicitly specify the intEqdictionary as an extra parameter whereas \nit was inferred by the compiler before. Apart from the automatic inference of instances, the dictionary \nmodel has many advantages over the standard type class system. All the power of normal language record \nmechanisms is available, and they can be de.ned, manipulated and abstracted over in stan\u00addard ways. 1.4 \nInstance search An aspect of type classes we have not yet touched upon is instance search. Haskell allows \ninstance de.nitions like the following: instance Eqa. Eq[a] where equai[] [] = True equai(a: as)(b: bs)= \nequaiab. equaiasbs equai= Faise With this instance, Haskell will resolve constraints of the form Eq[a] \nby recursively resolving the constraint Eqaand then using the above de.nition of equai. This mechanism \nmakes the instance search algorithm a lot more powerful and complex and a set of restrictions is enforced \non the structure of the types involved in instance contexts to ensure that the instance search remains \ndecidable. Two widely used Haskell extensions (associated type families [23] and functional dependencies \n[9]) introduce further complexity by adding what are essentially decidable type-level computation primitives, \nwhich can be triggered during the instance search process. As a reviewer notes, these extensions effectively \nexpose an interpreter for a simple logic programming language (no backtracking) which can reason about \nHaskell types. In a non-dependently typed language like Haskell, type-level computation is not directly \navailable in the base language. There\u00adfore, the type-level computation primitives provided by these prim\u00aditives \n.ll a certain gap in the language and various people have demonstrated the surprising amount of power \nthat these extensions offer [11, 14]. However, the computational model for these prim\u00aditives differs \nstrongly from the standard Haskell model: a form of structural recursion is used instead of non-structural \n(although many compilers provide an option to change this), pattern matching is open instead of closed \nand the syntactic order of pattern matching and recursive calls is reversed. 1.5 Scala Implicits The \nScala programming language features an alternative feature to type classes called implicits that avoids \nthe introduction of a new structuring mechanism [2, 17]. Powerful mechanisms like existen\u00adtial types \n[17, \u00a73.2.10] and abstract type declarations [17, \u00a74.3] can be used to model features that would have \nto be speci.cally de.ned and implemented for type classes. Our running equaiexample can be encoded in \nScala as follows: trait Eq[A] {def equai(x:A, y:A): Baaiean} def equai[A](x:A, y:A)(implicit eqA: Eq[A]) \n= eqA.equai(x, y) implicit abjetbaaiEqextendsEq[Baaiean] {def equai(x:Baaiean, y:Baaiean): Baaiean= x== \ny} implicit abjetintEqextendsEq[Int] {def equai(x:Int, y:Int): Baaiean= x== y} def neq[A](x:A, y:A)(implicit \neqA: Eq[A]) = ! equai(x, y) val test= equai(1, 3) . equai(true, faise) The type class Eqis modelled as \na dictionary trait Eq[A]. Traits are a general object-oriented structuring concept provided by Scala, \nsimilar (for our purposes) to records. Two dictionary objects intEqand baaiEqare introduced and annotated \nwith the implicit modi.er. The equaifunction is de.ned to accept an argument eqAof type EqAthat is marked \nas implicit, with the effect that when the function is called, and the implicit arguments are not explicitly \nprovided, values are inferred. Candidate values are searched from a precisely de.ned set of candidates, \nwhich includes all de.nitions that were annotated with the implicit modi.er and are either accessible \nat the call-site without a pre.x, or were de.ned in companion modules of the implicit argument s type \nor its components. A function can accept several implicit arguments, but they have to come after all \nother function arguments.  Unfortunately, functions with implicit arguments are not .rst\u00adclass citizens \nin Scala, mostly due to syntax-technical problems. Some important features of Scala s standard functions \n(currying, partial application, lambda expressions) either require non-trivial encodings or are not available \nfor implicits. More concretely, Scala implicits have the following restrictions. In the .rst place, implicit \narguments are restricted to occur after all the other arguments. Abstracting over functions taking implicit \nar\u00adguments is not syntactically possible but requires such functions to be encoded as objects with an \napply method taking an implicit ar\u00adgument or .rst converted by the caller to normal functions. There \nis no user syntax for the type of a function accepting implicit argu\u00adments. Anonymous functions cannot \naccept implicit arguments1. Full and tight control on the insertion of implicit arguments does not seem \nto be available and it does not seem possible to partially apply a given function with implicit arguments \nto any chosen subset of its (implicit and ordinary) arguments (while keeping the implicit arguments implicit). \nScala also uses a certain search algorithm to infer a value for implicit arguments that are not explicitly \nprovided. This algorithm is similar to Haskell s instance search. To resolve an implicit argu\u00adment of \ntype T, Scala will consider candidate values that have been marked implicit and which are accessible \n(can be named without apre.x)orin the implicit scope of type T(de.ned in a module related in a speci.c \nway [17, \u00a77.2 pp. 104 107] to type T). It will consider values of type T, but also functions that themselves \ntake only implicit arguments and return a value of type T. This makes the instance search recursive, \nlike Haskell s instance search. To en\u00adsure decidability of the search, Scala keeps track of the call \nstack of instance searches and detects in.nite loops using a certain crite\u00adrion [17, \u00a77.2 p. 106]. Like \nHaskell s instance search, Scala s implicit search can also be exploited as a type-level computation \nprimitive. Oliveira et al. demonstrate [2] an encoding of session types, an arity-polymorphic zipWithfunction \nand a form of generalized constraints. However, this computation primitive presents a computational model \nlike Haskell s instance search, different from Scala s standard model. 1.6 Agda implicit function arguments \nA .nal language feature we want to present before introducing our proposal, can be found in our target \nlanguage itself: Agda s implicit or hidden arguments [15]. Agda allows function arguments to be marked \nas implicit , indicating that they do not need to be pro\u00advided explicitly at the call site. For example, \nan Agda polymorphic identity function can be de.ned as follows. id: {A: Set}.A.A idv= v 1 The Scala syntax \n(implicit .. .) de.nes an anonymous function that takes a normal argument .,but makes .eligible for implicit \nresolution in the function body [17, \u00a76.23]. When type checking the expression idtrue, Agda silently \nin\u00adserts a meta-variable (as if the expression was id{} true), and Agda s uni.er will instantiate this \nmeta-variable to Baai. The argument can optionally be speci.ed explicitly, by writing id{Baai}true. Implicit \narguments are pervasive in most Agda code, and Agda would arguably be nearly unusable without it. Unfortunately, \nAgda s implicit arguments are of no help for passing around and inferring type class dictionaries in \nthe back\u00adground. This is because Agda will only infer implicit arguments if it can statically decide \nthat only a single value2 exists of the re\u00adquired type. This makes the feature unsuitable for passing \nour type class dictionaries, because for a type t, many values of type Eqt can typically be de.ned. For \nexample, even for a simple type like Baai, we can de.ne a trivial equality operator equai= true in addition \nto the standard one. However, unlike for Scala s implicit arguments, functions tak\u00ading an implicit argument \nin Agda are .rst-class citizens. They can be abstracted over, their types can be spelled out, anonymous \nfunc\u00adtions with hidden arguments are no problem and syntax is available to keep a tight control over \nwhether or not implicit arguments are inferred or not. In some cases this requires writing for example \n. {A}.id{A}instead of idto make sure that Agda does not try to infer the hidden argument. 1.7 Contributions \nIn this paper, we propose and study instance arguments:a new language feature that is an alternative \nto type classes, with an implementation in Agda. Our proposal is inspired by Scala s and Agda s implicit \nargument mechanisms. It does not introduce a separate structuring concept, but our ad hoc polymorphic \nfunctions are .rst-class citizens. Our proposal can work with less or more powerful types of instance \nresolution, but we choose a simple one that avoids the introduction of a separate computational model. \nTo the best of our knowledge, no other proposal in the litera\u00adture offers equivalents to all of the following \nfeatures: associated type families and constraint families, multi-parameter type classes, local instances, \nabstraction over type classes and .rst-class ad hoc polymorphic functions (although Coq, Haskell and \nScala each have almost all of them). No other proposal has explored an alternative to type classes without \nintroducing a separate computational model in the language. No other proposal did not require instances \nto be somehow marked eligible for implicit resolution. Finally, no other proposal has an equivalent to \nthe way that we automatically bring the bene.ts of type classes to unmodi.ed records. We formally de.ne \nthe workings of our feature, and discuss our design choices. We demonstrate the use of monads and present \n(often simpler) encodings of some type class based patterns from the literature. We also present some \nnovel patterns of our own.  2. Instance arguments The feature we propose in this text is inspired by \nboth Agda s im\u00adplicit arguments and Scala s implicits. It is a new kind of function arguments, which \nwe call instance arguments. These arguments can be inferred by the compiler even if multiple possible \nvalues exist with the expected type, provided only a single de.nition of such a value is in scope at \nthe call site (more details in section A.3). We do not require values to be marked in a speci.c way to \nbe eligi\u00adble for this resolution. Like for Agda s existing implicit arguments, functions with the new \narguments are .rst class citizens and there are no limitations on the location of the implicit arguments. \nWe take care to limit the computational power of our instance search algorithm so that we do not unwantedly \nintroduce an alternative computational model. 2 In a dependently typed language like Agda, types are \nvalues too.  2.1 By example Let us consider our running example equai, and de.ne a stan\u00addard Agda record \ncalled Eqrepresenting the Eqtype class dic\u00adtionary, and instances for the N and Baaitype from the Agda \nstandard library [3]. These two types correspond (for our purposes) to Haskell s Integerand Baai. reordEq(t:Set):Setwhere \nfeldequai:t.t.Baai eqBaai:EqBaai eqBaai=reord{equai=primEqBaai} eqNat:EqN eqNat=reord{equai=primEqNat} \nAll of this is standard Agda code. Our modi.ed version of Agda allows us to de.ne the following: equai:{t:Set}.{ \neqT:Eqt}}.t.t.Baai This type signature says that the function equaitakes a Set(type) as its .rst (standard) \nimplicit argument t. The double braces mark the function s second argument eqTof type Eqtas an instance \nargument. Next, the function takes two standard arguments of type tand returns a Baai.In equai s de.nition, \nwe simply take the implicitly passed dictionary and return the equaifunction contained in it: equai{ \neqT} =Eq.equaieqT With this type signature, we can now use equaias if it were de\u00ad.ned in a Haskell type \nclass. The following de.nition for example, normalises to the expected value faise(assuming standard \nde.ni\u00adtions of primEqBaaiand primEqNat). test=equai53.equaitruefaise What happens underneath, for example \nfor the application equai53, is that the Agda type-checker notices that in order to pass the non\u00adhidden \nargument 5 to function equai, it .rst needs to infer the two implicit arguments (tand eqT). It will assign \na new meta-variable [16] to both, but for the second argument, a constraint will addi\u00adtionally be registered \nindicating that that meta-variable needs to be resolved as an instance argument. The argument 5 will \nthen be passed to equaias the third argument, and Agda will unify the .rst meta-variable with value N. \nAgda will now notice that there is only one value of type EqN in scope (eqNat) and assign it to the second \nmetavariable. Like for implicit arguments, it is also possible to provide the instance arguments explicitly, \nshould this be necessary: test2=equai{ eqNat} 53.equai{ eqBaai} truefaise Our version of neqlooks nice: \nlike equai, it accepts a dictionary of type Eqtas an instance argument: neq:.{t}.{ eqT:Eqt}}.t.t.Baai \nneq{ eqT} ab=\u00ac(equai{ eqT} ab) In the de.nition, we explicitly accept the dictionary argument and pass \nit to the equaifunction, but in fact this is not necessary. If we leave out the dictionaries in the de.nition, \nAgda will silently insert an unnamed instance argument in the left-hand side and will silently infer \nequai s instance argument to that unnamed value: neqab=\u00ac(equaiab) Notice how the mechanism is strikingly \nsimilar to Agda s exist\u00ading implicit arguments in many respects. Only the resolution of the instance \nvalue is different. 2.2 Native support code for records An important and novel feature of our proposed \nsystem is that we can automatically bring its bene.ts to unmodi.ed libraries that use standard dependently-typed \nrecords. In the above example, it is the function equaiof type equai:.{t}.{ eqT:Eqt}}.t.t.Baai which \nallows us to use the Eqrecord in a more convenient, type\u00adclass-like way. The similarity to the standard \nprojection operator Eq.equaiwhich Agda generates in the background [15, 4.3 pp.82 83] is striking: Eq.equai:.{t}.(eqT:Eqt).t.t.Baai \nFrom this observation, it is not a big leap to automatically generate new versions of the projection \nfunctions which (like our equai) take the record as an instance argument instead of as a standard one. \nIn fact, it is even easier and more powerful to generate an Agda module application like the following: \nmoduleEqInst{t}{{eqT:Eqt} =EqeqT Module applications are part of Agda s module system. They al\u00adlow to \nmanipulate in certain ways the contents of a module. This module application will create a new module \nEqInstcontaining all the de.nitions in the right-hand-side module Eq, abstracted on the left-hand-side \narguments {t}and { eqT: Eqt} andappliedto the right-hand-side argument eqT. This makes not only the projec\u00adtion \nfunctions available in the new module, but also other functions de.ned in the scope of the record (more \ndetails in section 2.4). For the above example, we could have omitted the de.nition of func\u00adtion equai, \ninstead just importing equaifrom a new type of module application, written Eq{ ...} : openEq{ ...} using(equai) \nThe function equaiin these modules is identical to our custom de.nition above. Our monads case study \nin section 3 demonstrate that these de.nitions expose an interface that is very similar to the equivalent \nwith type classes. 2.3 Subclasses In dictionary models of type classes, a subclass dictionary typi\u00adcally \ncarries a superclass dictionary as one of its .elds. The Agda standard library for example uses such \na model. In the context of a dependently typed language, there is actually another possible model for \nsubclasses, known as Pebble-style structuring, which is recommended by Sozeau et al. [24, \u00a74.1]. In this \nstyle, subclass dictionaries carry superclass dictionaries as parameters instead of .elds. Both models \ncan be expressed with our system. Each has some speci.c advantages, e.g. a requirement to explicitly \nbring in scope superclass dictionaries or the need for an extra implicit superclass dictionary parameter \nin functions with a subclass constraint. In this section, we demonstrate a Pebble-style model of an Ordsubclass \nof our previously de.ned Eq: reordOrd{A:Set}(eqA:EqA):Setwhere feld < :A.A.Baai Let s now suppose that \nwe have values of type EqN, OrdN and EqBaaiin scope, but no instance of type OrdBaai. We can then still \nopen the Eq{ ...} and Ord{ ...} modules and use the appropriate methods on N and Baais, with the correct \ndictionaries being resolved in the background. openOrd{ ...} openEq{ ...} test1 =5<3 test2 = eq53 \n test3 = eqtruefaise An ad-hoc polymorphic function . now looks as follows: _ ._ : {A: Set}.{eqA: EqA}. \n{ ardA: OrdeqA}}. A. A. Baai a. b= a<b.eqab Note how the Pebble-style subclass model requires us to \nexplic\u00aditly mention a superclass constraint in the type signature of _ . _. This argument eqA: EqAis \naccepted as an implicit argument, not an instance, because it can typically be inferred from the pa\u00adrameters \nof the chosen ardAparameter. Because we require the superclass dictionary as an argument, it is automatically \nin scope for resolution inside the method. The above shows that our mechanism does not impose a choice \nas to how subclasses are to be modelled by the programmer. We think this demonstrates that our instance \narguments are a funda\u00admental mechanism, giving the programmer the freedom to make his or her own design \nchoices. 2.4 Native support code for records A novel feature of our instance arguments is the fact that \nwe can automatically bring its bene.ts to existing record based code, as demonstrated in the introduction. \nLet us assume we have a dependently-typed record de.nition of the following form: reordR.: Setwhere feld \n x1 : A1 x2 : A2 [x1 ] ... x.: A.[x1 \u00b7\u00b7\u00b7xn-1 ] y1 : B1 [x1 \u00b7\u00b7\u00b7 x.] y1 = v1 [x1 \u00b7\u00b7\u00b7 x.] \u00b7\u00b7\u00b7 y.: B1 [x1 \n\u00b7\u00b7\u00b7 x., y1 \u00b7\u00b7\u00b7 yn-1 ] y=[x1 \u00b7\u00b7\u00b7 x., y1 \u00b7\u00b7\u00b7 y] . v.n-1 Agda will automatically generate a module of the \nfollowing form: x moduleR{.} (r: R.) where x1 : A1 x1 = \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 x.: A.[x1 \u00b7\u00b7\u00b7 xn-1 ] . = \u00b7\u00b7\u00b7 y1 : B1 \n[x1 \u00b7\u00b7\u00b7 x.] y1 = v1 [x1 \u00b7\u00b7\u00b7 x.] \u00b7\u00b7\u00b7 y.: B[x1 \u00b7\u00b7\u00b7 x., y1 \u00b7\u00b7\u00b7 yn-1 ] y= v.[x1 \u00b7\u00b7\u00b7 x., y1 \u00b7\u00b7\u00b7 y] . n-1 \nThis module is parameterised on a record value r, and the functions in the module are implemented using \nits .eld values. We now allow a new form of module application: openR{ ...} Like for Agda s standard \nmodule applications, the modi.ers publi, using, renamingand hidingcan be used to control precisely what \nis imported. This new module application is equivalent to the fol\u00adlowing older-style notation (except \nthat it doesn t name the RInst module): openmoduleRInst{.}{{r: R.} = R{.} r In this new module, all the \nde.nitions from module R, including the .eld projections x1 \u00b7\u00b7\u00b7 and additional declarations y1 \u00b7\u00b7\u00b7 y, \nx . . are available in a form that accepts the record value ras a instance argument. As we have demonstrated \nin the introduction, these def\u00adinitions allow them to be used in a type-class-like way. Technically, \nthis new type of section applications can in fact be applied to any module taking at least one argument, \nturning the last (normal or hidden) argument into an instance argument. This allows the mechanism to \nalso be used for situations like in section 3, where the Agda standard library s monad concept is not \nde.ned as a record directly, but as a special case of an indexed monad. 2.5 Considerations for instance \narguments in other languages An important question about our proposed instance arguments is how Agda-speci.c \nthey are. We believe that the mechanism is widely applicable, and that many variations on our design \nchoices are possible. Let us consider the different modi.cations that we have made. A .rst step is the \nintroduction of a new, specially annotated type of arguments to functions, which is likely unproblematic \nin many pro\u00adgramming languages. Clearly, in non-dependently typed languages, the arguments type must \nbe restricted to not depend on earlier non\u00adtype arguments values, but this re.ects the rules for normal \nargu\u00adments in those languages. However, care must be taken that func\u00adtions with the new type of arguments \nare fully .rst-class on the one hand and that the programmer can tightly control the introduction of \nvalues for implicit arguments on the other hand. To the best of our knowledge, Agda was the .rst language \nto demonstrate that these two requirements can be combined with a natural syntax through a careful balancing \nin the type checking rules which govern function applications, lambda expressions, and the implicit insertion \nof implicit lambda s. The rules in section A.1 and A.2 for our instance arguments are simply adaptations \nof the corresponding rules for Agda s existing implicit arguments [15]. We think that a similar type \nof function arguments and similar rules can be introduced for any language which has some form of partial \nfunction application and lambda expressions. The choice of the algorithm by which not explicitly provided \ninstance arguments are inferred is in fact orthogonal to the rest of our design. We clearly choose a \nrelatively low-power one (more explanation in section 4), but we think that other choices can also be \ncombined with the rest of our design, ranging from our rela\u00adtively low-power inference (see section 4) \nto a full-power auto\u00admated proof-search like Coq s [24]. An advantage of our algorithm is that we do \nnot require values in scope to be specially annotated to be eligible for this inference, but an annotation \nsimilar to Scala implicit annotations can be used to limit the complexity of a more powerful inference. \nAnother advantage of our low-power inference algorithm is that it does not introduce a separate type-level \ncompu\u00adtational model in the language. 2.6 Formal Developments In appendix A, we formally develop instance \narguments, based on the formalism that Norell uses to present the Agda language [15]. We formally de.ne \nfunctions with instance arguments, how values for them are type-checked, when values for instance arguments \nare inferred and the rules for this resolution. We discuss various technical points and present a soundness \nresult. 2.7 Implementation We have implemented the above proposal in Agda. Our implemen\u00adtation is surprisingly \ncheap, with a non-context-diff of about 750 lines. It s hard to compare line-counts between different \nprogram\u00adming languages (Agda is implemented in Haskell, Coq in OCaml), but for what it s worth: the initial \ndiff of Sozeau s Coq type classes [24] was ~2k lines long. Our implementation has been incorpo\u00adrated \nin the development version of Agda3, and will be part of Agda  2.2.12 when it is released.  3. Monads \ncase study Our instance arguments provide an alternative for type classes. They lift some of the limitations \nof type classes but our inference algorithm is less powerful than Haskell s. To demonstrate that our \nmechanism is at least powerful enough for many common use cases of type classes, we take a look at a \ntypical type class example: monads. In this section, we demonstrate that with our instance arguments, \nwe can use the Agda standard library s RawManad s in similar ways to Haskell s monads. The closest equivalent \nof Haskell s Manadtype class in Agda s standard library is the RawManadconcept in the Categary.Manad \nmodule. Unlike its Haskell relative, it is de.ned as a special kind of indexed monad, a concept that \nis de.ned as RawIManadin module Categary.Manad.Indexed4. We copy the most important parts of the de.nitions \nhere: RawManad: .{f}.(Setf.Setf) .Set RawManadM= RawIManad{I= T}(. .M) reordRawIManad{if}{I: Seti}(M: \nIFunIf): Set(iUsuf)where infxl1_> =__> _ feld return: forall{iA}.A.MiiA _> =_ : forall{ijkAB}.MijA. (A.MjkB) \n.MikB _> _ : .{ijkAB}. MijA.MjkB.MikB m1 > m2 = m1 > = . .m2 We see that RawMonad is de.ned as an indexed \nmonad which just ignores its indices. An indexed monad contains the essen\u00adtial monadic operators returnand \n_> =_ as .elds and provides the _> _ operation. In order to highlight correspondence with Haskell s monads, \nwe slightly modify the RawIMonad record mod\u00adule to additionally include a syntax de.nition (a form of \nrestricted macro) for a form of do-notation. This addition is orthogonal to the use of instance arguments. \nbind: .{ijkAB}. MijA.(A.MjkB) .MikB bind{i}{j}{k}{A}{B} = _> =_ {i}{j}{k}{A}{B} syntaxbindm(. x.)= dax.mthen \n We can bring in scope some monad instances from the Agda standard library. We bring in scope a state \nmonad with mutable state variable of .xed type N, a partiality monad (de.ning a form of par\u00adtial or possibly \nnon-terminating computations) and the list monad (de.ning monadic operations over the Listtype constructor): \nopenimportCategary.Manad.Stateusing(StateManad) stateManad= StateManadN openimportCategary.Manad.Partiaiityusing() \nrenaming(manadtapartiaiityManad) pmanad= partiaiityManad openimportData.Listusing(List; ::;[]) 3 Use \nthe command darsgethttp://ode.haskell.org/Agdato download the latest source code. 4 The de.nitions are \ncalled raw because they do not contain proofs of the monad laws. renaming(manadtaiistManad) imanad= \niistManad There is a technical reason, related to the universe polymorphism of these monad instances, \nwhy we need to provide the apparently trivial de.nitions of pmanadand imanad. We will come back to this \nin section 4. In current Agda, the most convenient way to use these monad instances , is to apply the \nRawManadmodule to the correct monad instance at the location where it is used. test1: N .N . test1k= \nletopenRawManadpartiaiityManadin dax.returnkthen if(equaix4)thenreturn10eisenever This code does not \nlook too bad actually. Opening a monad in\u00adstance s module brings in scope just the de.nitions of the \nmonadic operations we need. However, it becomes more dif.cult if we de\u00adcide that we need to use for example \nthe monadic bind operator on a list, requiring monadic operations from two different monad instances \n. In this case, current Agda requires us to rename one: postulatenTaList: N .ListN test2 : N .(ListN) \n. test2 k= letopenRawManadpartiaiityManad openRawManadimanadusing() renaming(_> =_ ta_> = l _)in dax.return[k] \nthen if(equaik4)thenreturn(x> = l nTaList)eisenever We can improve upon this situation using instance \narguments. First, we bring the de.nitions from the RawManad{ ...} mod\u00adule application in scope. We have \nto de.ne it ourselves because RawManadis not directly de.ned as a record, but it is general and could \nbe added to Agda s standard library. We can then de.ne our examples in a simpler way and let Agda infer \nthe correct values for the instance arguments. openRawManad{ ...} test1 : N .N . test1 k= dax.returnkthen \nif(equaix4)thenreturn10eisenever test2 : N .(ListN) . test2 k= dax.return[k] then if(equaik4)thenreturn(x> \n= nTaList)eisenever In the case of test1, one could argue that we don t actually gain all that much. \nAgda now automatically chooses the correct monad instance from the values in scope instead of requiring \nthe pro\u00adgrammer to make this choice. However, the second example shows that in a case where we use monadic \noperations from different monad instances , instance arguments effectively spare us some uninteresting \nbookkeeping, by inferring appropriate instances in the background.  4. No automated proof search Our \nresolution algorithm is only a restricted analog to Haskell s instance search. The mechanism is designed \nso that only one type\u00addirected scope-based resolution will be done per not explicitly pro\u00advided instance \nargument in the program (see section A.3). This lim\u00aditation is a deliberate choice, intended to avoid \nintroducing a sepa\u00adrate computational model through the instance search mechanism, as for Scala implicits \nor Haskell and Coq type classes. However, this decision does unavoidably limit the functionality of our \nmech\u00adanism. For example, for the Eqtype introduced in section 2, we could have a de.nition like the following: \n iistEq: {A: Set}.EqA.Eq(ListA) iistEq{A}eqA= reord{equai= eq'}where eq': ListA.ListA.Baai eq'[][] = \ntrue eq'(a::as)(b::bs)= and(equaieqAab)(eq'asbs) eq'= faise Now, with the eqBaaivalue from section 2 \nin scope, you might expect an instance of Eq(ListBaai)to be automatically inferred as iistEqeqBaai. However, \nin our system, this is not the case: in such a situation, we require the user to explicitly construct \na value of the correct type himself. It suf.ces to bring this value in scope at the call site, for example \nby placing it in a local whereblock. test= equai(true::faise::true::[])(true::faise::[]) whereiistBaaiEq= \niistEqeqBaai We encountered another interesting case of this problem in the previous section, where we \nhad to provide seemingly trivial de.nitions for values pmanadand imanad. The reason that these were needed \nis that the de.nitions were not actually trivial. The types of the values involved are as follows: partiaiityManad: \n{i: Levei}.RawManad(_.{i}) pmanad: RawManad(_.{ }) iistManad: {i: Levei}.RawManad(List{i}) imanad: RawManad(List{}) \nThis is an example of Agda s universe polymorphism. The value _.is not a functor of type Set.Set, but \ninstead, for any level i, _.{l}is a functor of type Seti. Seti. This means that partial computations \ncan be de.ned producing values (Set 0), types (Set 1), kinds (Set 2), and for each of these types of \npartial computations, a monad instance is provided as partiaiityManad{i}. The monadic computations and \nlists we used before all pro\u00adduced or contained values, so our pmanadand imanadare de.ned as monad instances \nfor resp. partial computations and lists working with values. Note that we did not need to specify level \n0 explicitly for this. Because we just omit the level argument, Agda inserts an underscore implicitly \nand infers its value when it resolves pmanad and imanadas values for the instance arguments. 4.1 But \nwhy not? So, in both of the above examples, our resolution search was not smart enough to automatically \ninfer certain instance arguments that one might expect it to. In both cases, help from the programmer \nis required to make it .nd the correct value. The extra information is limited (placing the required \nvalue in scope) and does not require explicitly passing the instance arguments everywhere they are used. \nWe actually believe that a smarter resolution algorithm can be de.ned for our mechanism. Extensions can \nbe imagined where functions like iistEqare annotated somehow to make the resolution consider them. Such \nan extension would be largely orthogonal to the rest of our design. However, introducing such an extension \nmakes the instance search recursive. Even if it can still be kept decidable with restrictions on the \nfunctions considered, it would inevitably expose an additional computational model, similar to Haskell \ns, Scala s or Coq s instance search. Because our implementation is in Agda, we are extra sensitive to \nthis point. Any instance search that can automatically infer for example the value of iistBaaiEqabove, \nmust somehow perform a reasonably powerful automated proof search. This is an area where up to now, the \nAgda language designers have taken a very prin\u00adcipled approach. Agda does provide such a mechanism (dubbed \nauta), but only in the interactive proving/programming environ\u00adment, not in the language. Agda has also \nrefrained from introduc\u00ading an equivalent to Coq s untyped, imperative meta-programming facility (Coq \ntactics ), instead developing a more principled mech\u00adanism through the quateGaaiconstruct. This construct \nis intended to allow Agda to function in a sense as its own tactic language , although it is currently \nstill limited because no access to the context or scope is available to the meta-programs. We believe \nthat Agda s approach in this area is very promising, and the limited power of our inference algorithm \navoids compromising Agda s principled design choices in these areas by introducing a parallel computa\u00adtional \nmodel which could be exploited as a meta-programming con\u00adstruct, as has happened in other languages. \n4.2 Advantages Note also that our simple resolution scheme has some advantages of its own. We have used \nit for all of the examples in section 3 and 5 and the resolution has proven practical, predictable, intuitive \nand suf.cient. Also, we do not need to limit resolution complex\u00adity by requiring candidate values to \nbe annotated specially, instead considering all values in scope. This lowers the impact of our fea\u00adture \non users code and makes for example the ellipsis in section 5 more widely usable. Its intuitive meaning \nalso changes from Fill in this value from an annotated value in scope to Fill in this value from the \nscope , which feels more natural to us. Note that because the entire scope is considered for resolution, \nit is up to the programmer to make sure that only a single value of a correct type is in scope. Instance \narguments should only be used on types which are informative enough so that they typically identify values \nuniquely. If there still is a con.ict, existing features in Agda s module system (e.g. hidingand usingmodi.ers) \ncan be used to control the scope. Note also that values that are not directly in scope but via a named \nmodule are not considered for instance resolution, but they can still be accessed explicitly. In our \nexperiments, we .nd that instance arguments provide a solution (ad hoc overloading) for many of the name \ncon.icts that arise in typical ? use of Agda s standard library (e.g. = in Data.Nat, Data.Baai etc.) \nand that type con.icts for reasonably typed instance arguments occur seldom.  5. Some advanced patterns \nIt turns out that our relatively simple extension of Agda can support analogs or variants of many features \nwhich have required important implementation efforts in Haskell, as well as some new patterns of its \nown. In this section, we discuss a selection of such topics. 5.1 Standing on the shoulders of records \nWe discussed in the introduction how modelling type classes us\u00ading an existing powerful record mechanism \nsuch as Agda s depen\u00addently typed records makes certain features available for free that require separate \nextensions for Haskell type classes. Sozeau et al. and Oliveira et al. have previously demonstrated this \nobservation for Coq type classes (which are Coq dependently typed records un\u00adderneath [24]) and Scala \nimplicits (where type classes are typically modelled as Scala traits [2]). One such feature is the equivalent \nof Haskell s associated type families [23]. An associated type family is essentially a type class member \nthat is a type or type functor. Using a dictionary model of a type class in a dependently typed language, \nthere is nothing special about records with members that are not just values and we essentially get associated \ntype families for free. Another feature which we get for free is known as constraint families for Haskell \n[18]. A constraint (synonym) family in Haskell is a member of a type class that represents a class constraint \non a type class s parameters and/or other types. Using a dictionary model of type classes, this concept \nactually reduces to type fami\u00adlies. Orchard and Schrijvers example of constrained functors (pos\u00aditive \ntype functors whose fmapfunction is restricted to types in a certain type class) can be modelled as follows: \n reordCanstrainedFuntar(F:Set.Set):Setwhere feldCanstraint:Set.Set fmap:.{AB:Set}.CanstraintA. CanstraintB.(A.B).FA.FB \niistCanstrainedFuntar:CanstrainedFuntarList iistCanstrainedFuntar=reord{ Canstraint=. .T , fmap=. .List.map} \nsetCanstrainedFuntar:CanstrainedFuntarSet setCanstraintedFuntar=reord{ Canstraint=Ord, fmap=Set.map} \n5.2 Multi-parameter type classes and functional dependencies A multi-parameter type class in Haskell \nis (obviously) a type class with more than one parameter. The equivalent in our approach would be instance \narguments of a record type with more than one parameter, and this is clearly allowed in our system. Functional \ndependencies in a multi-parameter type class are annotations which indicate that certain parameters of \na type class can be deduced from (a subset of) the others [9]. Such an annotation cannot directly be \nprovided in our framework. However, in this section, we highlight certain behaviour of our system, which \nis reminiscent of functional dependencies, even though it works differently under the hood. Consider \nthe following code, which uses the IsDeEquivaiene record from module Reiatian.Binaryin the Agda standard \nlibrary. We use explicit usingdeclarations to avoid certain name clashes, but also to make it more clear \nwhat is happening under the hood. openimportReiatian.Binaryusing(moduleDeSetaid; moduleIsDeEquivaiene) \nopenimportData.Baaiusing(faise;true;deSetaid) openDeSetaiddeSetaidusing(isDeEquivaiene) ? openIsDeEquivaiene{ \n...} using(=) ? test =faise=true The IsDeEquivaienet record is semantically a more de\u00adveloped version \nof the record Eqfrom the introduction, containing ? essentially an equality decision procedure = for \na binary pred\u00adicate on type t(as well as proof that is an equivalence ? relation). The .eld = has the \nfollowing type: ? = :(a:t).(b:t).De(a b) A value of type De(a b)contains either a proof that a bor a \nproof that a b. We can bring a value of type IsDeEquivaieneBaai= in scope by importing Data.Baai and \nopening the deSetaidrecord (this would be more convenient if isEquivaienewere exported directly by the \nData.Baaimodule). Finally, we bring the new record .eld projection operator (taking the record as a instance \nargument) into scope by importing it from the IsDeEquivaiene{ ...} module application (see section 2.4). \n? From that point on, we can transparently use the function = on Bools, as demonstrated in the de.nition \nof test. A .rst thing to note is that the IsDeEquivaienerecord takes two arguments, making it the equivalent \nof a multi-parameter type class. It is interesting to consider what happens when type-checking ? the \nde.nition of test. The function = has the following type (ignoring universe polymorphism): ? =:{A:Set}.{ \n :A.A.Set}.{ isDE:IsDeEquivaieneA }}.(a:A).(b:B).De(a b) ? When faise= trueis type checked, Agda infers \nthat A= ? Baaifrom the arguments of = . It then infers the instance argument isDEfrom the local scope. \nThe only candidate value in scope is isEquivaiene, typed IsDeEquivaieneBaai= . From unifying the type \nof this value with the expected type of isDE, Agda infers that the implicit argument must be the binary \npredicate = . In this case, we see that one argument of the IsDeEquivaiene type constructor already uniquely \ndetermines the value to be used from the scope. Its other arguments can then be inferred from this value, \nproducing an effect similar to a hypothetical situation where IsDeEquivaienewere a multi-parameter type \nclass with a functional dependency from type Ato binary predicate . Nevertheless, our mechanism works \nvery differently from Haskell type classes with functional dependencies. First of all, nowhere have we \ndeclared any functional dependencies between arguments of the IsDeEquivaienerecord type, and these de\u00adpendencies \nwere not checked when we brought values of type IsDeEquivaieneinto scope. Only when we actually needed \nto in\u00adfer an instance argument, it was checked that only a single suitably\u00adtyped value was in scope. \nSemantically, declaring the equivalent of a functional depen\u00addency on the arguments of the IsDeEquivaienerecord \ntype cor\u00adresponds to an assertion that only one decidable equality predicate can exist for any given \ntype A. This assertion is semantically wrong here and can cause problems in scenarios where multiple \nsuch pred\u00adicates are used together. Our system manages to infer the value of the predicate without such \na dependency, because only one value of type IsDeEquivaieneBaai is in scope at the call ? site of = , \nwhich is semantically a much weaker requirement. Note .nally that it is a value, not a type, that is \nbeing inferred in a functional dependencies-like way. In fact, our mechanism does not make any fundamental \ndistinction between types or values, as one might expect in a dependently-typed language like Agda. The \nmechanism will even happily infer types from values, which is not possible in Haskell. 5.3 Implicit Con.gurations \nOne pattern implemented in the context of type classes which is rendered almost trivial in the context \nof our proposal is Kiselyov and Shan s implicit con.gurations [11]. The authors discuss a solu\u00adtion to \nwhat they call the con.gurations problem: propagating run\u00adtime preferences throughout a program, allowing \nmultiple concur\u00adrent con.guration sets to coexist safely under statically guaranteed separation. Their \nmain example concerns modular arithmetic: they want to be able to build expressions in modular arithmetic \nwhich are parameterised over a concrete modulus but without the need to pass the modulus around explicitly. \nThey also want static assurance that the same modulus is used for all operations in such an expres\u00adsion. \nKiselyov and Shan s solution is based on a mix of phantom types, type classes and type-level computation. \nWe demonstrate that a simpler encoding is possible in our system, and that we can even fully avoid one \nof the main dif.culties in their work: the re.ection at type-level of run-time values. Let us suppose \nthat we have a signature like the following: we assume an Integrai dictionary record and add, muiand \nabjoperations taking such a dictionary as a instance argument. We also assume we have a type Ncontaining \nvalues zera, ane, twaand threeand a dictionary nInt of type IntegraiN.  postulate Integrai:Set.Set add:.{A}{{intA:IntegraiA}}.A.A.A \nmui:.{A}{{intA:IntegraiA}}.A.A.A mad:.{A}{{intA:IntegraiA}}.A.A.A N:Set zeraanetwathree:N nInt:IntegraiN \n Like Kiselyov and Shan, we de.ne a wrapper data type MsA parameterised by phantom token s(in our case \nnot a type but a value of opaque type Taken) and type A. This wrapper represents a value of type A that \nis being considered under an unspeci.ed modulus. We also de.ne a dictionary record MaduiussA(also parameterised \nby a token s and type A). privatepostulateTaken:Set reordMaduius(s:Taken)(A:Set):Setwhere feldmaduius:A \n dataM(s:Taken)(A:Set):Setwhere MkM:A.MsA unMkM:.{sA}.MsA.A unMkM(MkMa)=a Our withMaduiusfunction is \nsimpler than Kiselyov and Shan s because we don t have to bother with constructing a type for which the \nModulus instance returns a certain value, but instead just pass the desired dictionary explicitly. privatepostulatetheOniyTaken:Taken \nwithMaduius: .{A}.{ intA:IntegraiA}}.(maduius:A). (.{s}.{ mad:MaduiussA}}.MsA).A withMaduiusmaduiusf=unMkM$ \nf{theOniyTaken}{{reord{maduius=maduius}}} Our addition and multiplication become pretty similar to Kise\u00adlyov \nand Shan s version: narmaiize:.{sA}{{intA:IntegraiA} { mad:MaduiussA}}.A.MsA narmaiizea=MkM$madmaduiusa \n+:.{sA}{{intA:IntegraiA} { mad:MaduiussA}}.MsA.MsA.MsA (MkMa)+(MkMb)=narmaiize$addab *:.{sA}{{intA:IntegraiA} \n { mad:MaduiussA}}.MsA.MsA.MsA (MkMa)*(MkMb)=narmaiize$muiab These operators are used similarly to Kiselyov \nand Shan s: test1 :N test1 =withMaduiustwa$ leta=MkManein(a+a)*(a+a) testExpr:.{s}.{ mad:MaduiussN}}.MsN \ntestExpr=leta=MkMane;t=MkMtwa in(a+t)*t test2 :N test2 =withMaduiusthreetestExpr With this, our encoding \nof Kiselyov and Shan s implicit con\u00ad.gurations is done. We believe that we achieve the same goals as \nKiselyov and Shan, but we avoid their threading of values into types (through an involved type-level \nre.ection of values) and back again (through a form of type-level computation), which seems un\u00adneeded, \nvery complex and possibly inef.cient (depending on what optimisations the compiler can perform). Interestingly, \nthe fact that we don t need to re.ect values at the type level is not (as one might expect) a consequence \nof Agda s dependently typed nature. Instead, it is the value-level representation of dictionaries which \nallows this greater simplicity. More concretely, in the de.nition of withMaduiusabove, we can construct \nthe dictionary as a value and pass it explicitly to the computation, whereas Kiselyov and Shan need to \njump through a lot of hoops to construct a type for which the correct instance will be inferred. Kiselyov \nand Shan instead pro\u00adposed adding a form of local instances to Haskell, of which we also support an equivalent \n(see section 5.5). 5.4 Implicit Proof Obligations In the context of Agda, we believe that instance arguments \nare useful for a pattern which is (to the best of our knowledge) novel: implicit proof obligations. Consider \nthe integer division operator in module Data.Nat.DivMadin Agda s standard library: div:(dividenddivisar:N) \n? {=0:Faise(divisar=0)}.N This division operator requires a guarantee that the provided divisor is non-zero. \nHowever, instead of requiring a normal argument of type divisar= 0,the divoperator cleverly accepts a \nvalue ? of type Faise(divisar=0). This type contains a single value if and only if divisaris non-zero, \nbut additionally, this value can be automatically inferred if Agda knows that divisaris of the form sunfor \nsome n. For example, if we write 5div3, then Agda will infer the non-zeroness proof obligation. This \npattern has been described by Norell [15, 3.7.1 p.71], and critically depends on the fact that the property \nin question (non-zeroness) can be decided. Proof obligations modelled using this pattern are not passed \non implicitly to other methods that require it. Finally, the div operator becomes somewhat clumsy to \nuse in a situation where only a normal proof divisar=0is available. We propose an additional operator \ndiv'which takes the proof obligation as an instance argument (we omit the de.nition in terms of the above \ndiv). This operator does not have the limitations of the divoperator discussed above, but does have some \nlimitations of its own: for example in the call 5div' 3, Agda can only infer the implicit argument of \nour operator if a value of type 3=0is in scope. divMad' :(dividenddivisar:N) { =0:divisar=0}}.N \u00d7N divMad' \n= --omitted div' :(dividenddivisar:N){ =0:divisar=0}}.N ' adivbwithadivMad' b adiv' b| (q, )=q postulate \nd:N d=0:d=0 test:N test=5div'd Note how in the de.nition of div' , the proof obligation is im\u00adplicitly \npassed on to the divMad' function, which also requires it. We believe that this example shows that our \nproposed instance arguments have uses that go beyond those of type classes. Not only dictionary records \ncan be usefully passed around implicitly but also other values which are uniquely identi.ed by their \ntype in call-site scopes. In a dependently typed language like Agda, implicit proof obligations are a \nclear example of such values.  5.5 Local instances A feature that is not supported by Haskell type classes \nare local type class instances. Consider the following two equality functions on Strings: the .rst represents \nstandard equality and the second only compares the strings lengths. The .rst de.nition uses the standard \nstring equality decision procedure and the second applies the EqInst.eqoperator after .rst applying a \nstring length function to its two arguments. Note that we assume a single, standard value of type EqN \nin scope. eqString1 : String.String.Baai ? eqString1 s1 s2 = Ls1 = s2 J eqString2 : String.String.Baai \neqString2 = eqaniength Now suppose that we have a function whose behaviour depends on a con.guration \nargument, determining which type of equality it should use throughout a series of calculations. We can \nsupport this by de.ning the equivalent of a local instance eqLaaiof the Eqtype class, which uses the \ncorrect string equality operator, depending on the con.guration parameter. test: Baai.Baai testiengthEq= \nifeq.....then...eise... ..... whereeqLaai= reord{eq= ifiengthEqtheneqString2 eiseeqString1 } The value \neqLaaifunctions as a local type class instance, something which is also supported by Scala implicits, \nbut not by Haskell or Coq type classes, where type class instances are always global. 5.6 Two .nal examples \nAs a small encore in this section, we can t resist discussing two code snippets using instance arguments. \nThe .rst is an example of a function abstracting over functions with implicit arguments. It demonstrates \nthe .rst-class nature of our new type of arguments: functions with instance arguments can be abstracted \nover, their types can be written out etc. expiiitize: .{A: Set}{B: A.Set}. ({ x: A}}. Bx) .(x: A) .Bx \nexpiiitizefx= f{ x} Our .nal example is small, but very useful: it is an analog of Agda s standard underscore \nconstruct for instance arguments, similar to Scala s impiiitiyor 7. Like in Scala, we don t need to introduce \nspecial syntax for this: the following de.nition suf.ces. This ellipsis can be used as a shorthand in \nany situation where only a single type-correct value is in scope. Because our resolution algorithm does \nnot require candidates to be specially annotated to be eligible, our ellipsis is more generally useful \nthan Scala s impiiitiy. \u00b7\u00b7\u00b7 : {A: Set}.{ a: A}}. A \u00b7\u00b7\u00b7 { a} = a  6. Related Work There exists a lot \nof literature about type classes, extensions of them and alternatives to them [2, 5, 6, 9, 10, 18, 20, \n23, 24, 26, 27]. We have already discussed Haskell type classes and Scala implicits in the introduction \nand we do not repeat this here. We do not further discuss implicit parameters as implemented in Hugs \nand GHC [13], as these use a name-based resolution, instead of the type-based resolution of our design \nand are thus not suited for our use cases. 6.1 Coq Type Classes Sozeau and Oury have recently presented \nCoq type classes [24]. Coq is a dependently typed, purely functional programming lan\u00adguage/proof assistant \nlike Agda, with a longer history and a larger user base. Unlike Agda, it has a very principled core lan\u00adguage \nand associated type-checker. On top of that, there is a variety of arguably less principled language \nfeatures and meta\u00adprogramming/proof automation facilities. The authors introduce type classes as essentially \na new way to de.ne dependently typed record types. If a function has an implicit argument of such a record \ntype, and its value cannot be inferred through Coq s standard uni.cation, then Coq will try to infer \na value through an instance search. This instance search is imple\u00admented as an automated proof search \nusing a special-purpose port of the .....tactic. It performs a bounded breadth-or depth-.rst search using \nthe type class s instances as lemma s. This can include both direct instances (objects of the record \ntype) and parameterized instances (functions which take certain arguments and return such an object). \nSozeau and Oury go on to discuss some super.cial syntax extensions and relatively straightforward models \nof superclasses and substructures and then provide a discussion of various aspects of their system, most \nimportantly their instance search tactic. They think their current instance search tactic is not suf.cient \nin the context of multi-parameter type classes and arbitrary instances (which their system currently \nallows). They state the algorithm s non-determinism and impredictability as problems which they hope \nto address in the future by restricting the shape of allowed instances and using a more predictable algorithm. \nIn addition to these problems, we believe that Sozeau et al. s instance search procedure is currently \nat least as powerful as Haskell s or Scala s instance/implicit search and exposes the same kind of separate \ncomputational model (see section 4). Also, if we understand Sozeau and Oury s text correctly, a given \nimplicit func\u00adtion argument can sometimes behave as a type class constraint and sometimes as a normal \nimplicit argument, if its type depends on the value of previous arguments. Our resolution algorithm is \nless powerful than Sozeau et al. s, but it is predictable, deterministic and does not expose an alternate \ncomputational model. Sozeau and Oury s mechanism is limited to record types that were de.ned as a type \nclass, so existing libraries need to be adapted to bene.t from it. Type class instances can be de.ned \nlocally (see section 5.5), but it seems that the local instance will not be considered for automatic \nresolution. 6.2 Coq Canonical Structures Coq features another type system concept which can be exploited \nas an alternative to type classes: canonical structures [1,25].This fea\u00adture allows certain values of \na record type to be marked as canoni\u00adcal structures. Such values are then automatically considered when \nthe Coq type inferencer tries to infer a value of the record type from the value of one of its .elds. \nCanonical structures have existed for some time in Coq, but have recently attracted the attention of \nau\u00adthors looking to provide easy to use libraries of complex concepts, exploiting canonical structures \nas a powerful meta-programming feature that can be implicitly triggered to resolve values in the back\u00adground. \nThere are some similarities in the design to ours, as it does not introduce a separate type of structure \nand does a form of im\u00adplicit resolution from call-site scope. However, because the resolu\u00adtion is keyed \non values instead of types, the idea is not suitable for non-dependently typed languages, where we can \nonly reason about types at compile time.  However, the entire design of the feature seems very pragmatic. \nWe have not been able to .nd a detailed (formal?) description of the exact workings of the system. From \nwhat we understand, it is deeply coupled to Coq s type inference engine and uses certain syntactic criteria, \nbehaving differently for semantically equivalent values. There seems to be a certain interaction with \na form of back\u00adtracking in Coq s type inference engine, which can be exploited for encoding backtracking \nin the speci.cation of how values should be inferred. All of this leads to a meta-programming model that \nseems even more powerful than Haskell s instance resolution, hard to un\u00adderstand and strongly different \nfrom Coq s standard computational model(s). 6.3 Explicit Haskell In an unpublished technical report, \nDijkstra and Swierstra describe an implicit arguments system which they have implemented in a Haskell \nvariant called Explicit Haskell [4]. Their main motivation is that Haskell does not provide a way to \noverride the automatic reso\u00adlution of instances (dictionaries) for functions with a type class con\u00adstraint. \nThey extend Haskell with named instances, local instances, and a way to explicitly provide an instance \nto a function with a type class constraint, either by naming the instance or by lifting a value of a \nrecord type corresponding to the type class. They also allow type class constraints to appear anywhere \nin a type, not just at the beginning. For resolving type class constraints, they use a resolu\u00adtion close \nto Haskell s. The only difference is that instances can be annotated to not take part in this resolution \n(in which case they can only be used by name). In the same text, Dijkstra and Swierstra discuss a system \nfor partial type signatures, which seems to have independent value. The system allows the user to partially \nspecify types for values and leave the rest to be inferred. This design has many similarities to our \nsystem. Their exten\u00adsions to the concept of type class constraints effectively transforms them into a \nspecial form of function arguments similar to our in\u00adstance arguments. Their design offers some of the \nsame bene.ts as ours (e.g. local instances, named instances), and they discuss some of the same examples \nas we do in section 5. However, they make some different choices than we do: their constraints remain \nlimited to arguments whose type was de.ned as a type class instance and their resolution is similar to \nHaskell s. They do not fully unify type classes with their associated record types, so that some of the \nadvantages we can offer are not available (e.g. abstracting over a type class). 6.4 Modular Type Classes \nDreyer et al. discuss an alternative to type classes in the context of ML [5]. They share our view that \nHaskell type classes dupli\u00adcate functionality by introducing a separate structuring concept, and they \nargue that ML modules already provide functionality akin to associated type families and type class inheritance \n(like we do for ADT s). They propose to model single-parameter type classes as class signatures: module \nsignatures with a single abstract type named t. Instances become modules and functors. Their primitive \noverload funfrom sigreturns a version of function funfrom class signature sigthat will resolve the appropriate \nmodule imple\u00admenting sigfrom call-site scope. Another primitive anan(sig) resolves and returns this module. \nResolution of such a module takes into account modules and functors that have been annotated in the current \nscope with a using declaration. Since functors are considered, the instance search is recursive, and \ncan likely be exploited as a type-level programming primitive similar to Haskell s instance search, even \nthough Dreyer et al do not discuss this. Their proposal does not support the equiv\u00adalent of multi-parameter \ntype classes. It is not clear to us if and how their type class modules can be abstracted over.  Acknowledgments \nThis research is partially funded by the Interuniversity Attraction Poles Programme Belgian State, Belgian \nScience Policy, and by the Research Fund K.U.Leuven. Dominique Devriese holds a Ph. D. fellowship of \nthe Research Foundation -Flanders (FWO). The au\u00adthors thank Adriaan Moors (EPFL) for providing valuable \nfeedback on a draft of this text, as well as clarifying various points about Scala implicits. We thank \nthe anonymous reviewers for many valu\u00adable comments and PC Chair Olivier Danvy for suggesting the .nal \ntitle.  References [1] Y. Bertot, G. Gonthier, S. Ould Biha, and I. Pasca. Canonical big operators. \nIn TPHOLs, 2008. [2] B. C. d. S. Oliveira, A. Moors, and M. Odersky. Type classes as objects and implicits. \nIn OOPSLA, 2010. [3] N. Danielsson, U. Norell, S. Mu, S. Bronson, D. Doel, P. Jansson, and L. Chen. The \nAgda standard library, 2009. [4] A. Dijkstra and S. D. Swierstra. Making implicit parameters explicit. \nTechnical Report UU-CS-2005-032, Dept. ICS, Utrecht University, 2005. [5] D. Dreyer, R. Harper, M. M. \nT. Chakravarty, and G. Keller. Modular type classes. In POPL, 2007. [6] D. Duggan and J. Ophel. Type-checking \nmulti-parameter type classes. Journal of Functional Programming, 12(02):133 158, 2002. [7] B. Heeren, \nJ. Hage, and S. Swierstra. Scripting the type inference process. In ACM SIGPLAN Notices, volume 38, 2003. \n[8] P. Hudak, J. Hughes, S. Peyton Jones, and P. Wadler. A history of haskell: being lazy with class. \nIn History of Programming Languages, 2007. [9] M. Jones. Type classes with functional dependencies. PLAS, \npages 230 244, 2003. [10] W. Kahl and J. Scheffczyk. Named instances for Haskell type classes. In HASKELL, \n2001. [11] O. Kiselyov and C.-c. Shan. Functional pearl: Implicit con.gurations. In HASKELL, 2004. [12] \nR. L\u00e4mmel and S. Peyton Jones. Scrap your boilerplate with class: extensible generic functions. In ICFP, \npages 204 215, 2005. [13] J. Lewis, J. Launchbury, E. Meijer, and M. Shields. Implicit param\u00adeters: Dynamic \nscoping with static types. In POPL, pages 108 118, 2000. [14] C. McBride. Faking it: Simulating dependent \ntypes in haskell. Journal of Functional Programming, 12(4&#38;5), 2002. [15] U. Norell. Towards a practical \nprogramming language based on de\u00adpendent type theory. PhD thesis, Chalmers University of Technology, \n2007. [16] U. Norell and C. Coquand. Type checking in the presence of meta-variables. Unpublished draft., \n2007. URL http://www.se. halmers.se/-ulfn/papers/meta-variables.html. [17] M. Odersky. The Scala language \nspeci.cation, version 2.8. on\u00adline, 2010. URL http://www.sala-lang.org/dou/files/ SalaReferene.pdf. [18] \nD. Orchard and T. Schrijvers. Haskell type constraints unleashed. In FLOPS, 2010. [19] S. Peyton Jones \nand R. L\u00e4mmel. Scrap your boilerplate. In APLAS, page 357, 2003. [20] S. Peyton Jones, M. Jones, and \nE. Meijer. Type classes: an exploration of the design space. In HASKELL, 1997. [21] S. Peyton Jones, \nD. Vytiniotis, S. Weirich, and G. Washburn. Simple uni.cation-based type inference for GADTs. In ICFP, \n2006. [22] S. Peyton Jones, D. Vytiniotis, S. Weirich, and M. Shields. Practical type inference for arbitrary-rank \ntypes. Journal of Functional Pro\u00adgramming, 17(1), 2007.  [23] T. Schrijvers, S. Peyton Jones, M. Chakravarty, \nand M. Sulzmann. Type checking with open type functions. In ICFP, 2008. [24] M. Sozeau and N. Oury. First-class \ntype classes. In TPHOLs, 2008. [25] The Coq development team. The Coq reference manual. online, 2010. \nURL http://oq.inria.fr/refman/. v8.3. [26] P. Wadler and S. Blott. How to make ad-hoc polymorphism less \nad hoc. In POPL, 1989. [27] S. Weirich. Replib: a library for derivable type classes. In HASKELL, 2006. \n A. Under the hood In this appendix, we discuss the precise changes we make in more detail. The de.nitions \nin this section are extensions and adaptations of Norell s rules for current Agda type-checking and standard \nim\u00adplicit arguments [15, 3.5 pp. 69 70, 5.1.5 pp. 99 100]. They should be read in the context of Norell \ns developments and may not be fully clear without them. A.1 Implicit lambdas We add another implicit \nfunction space { x: A}}. Bin addition to the existing {x: A}. Band (x: A) . B.Like the existing implicit \nfunctions, the new functions are semantically equivalent to the corresponding ordinary functions. Values \nof type { x: A}}. Bcan be introduced as (typed or untyped) lambda values . { x}}. eor . { x: A}}. eor \nthey can be de.ned as constants (at the top-level or in where-clauses). For type-checking values of this \ntype, we extend the rules for Agda s standard implicit arguments [15, 3.5 pp. 69 70] as follows. If a \nvalue does not explicitly mention an instance argument from the type it is checked against, rule (2) \ninfers implicit lambda s, like for normal implicit arguments. G,x : A fe .B . s G f.{ x} .e .{{x : A}}.B \n. .{ x} .s (1) G,x : A fe .B . se = .{ x} .e ' (2)G fe .{{x : A}}.B . .{ x} .s A.2 Instance arguments \nNext, we need to determine when instance arguments of a function are not provided explicitly and should \nbe inferred. This mechanism is governed by the inference rules for argument checking judge\u00adments of the \nform G fA @\u00afe .B . s\u00af. Such a judgement means that the values e\u00afcan be passed as arguments to a value \nof type A, producing a value of type B. The full list of arguments to be applied to the function (including \nimplicitly inserted ones) is returned in s\u00af. We extend the corresponding rules for implicit arguments \n[15, 3.5 p. 70] as follows. For a non-provided instance argument, we do not just insert a meta-variable \na, but we additionally add a constraint FindInScope a. This is a special kind of constraint that indicates \nthat a should be resolved as an instance argument. To do this, we need to extend the form of argument \nchecking judgements to additionally return a set of constraints C: G fA @\u00afe .B . \u00af. s, CThis adapted \nform actually corresponds more closely to Agda s existing implementation of the rules. Existing rules \nin the old form of the judgement should now be read as simply producing no constraints or simply pass \ngenerated constraints through if they recurse. G fe .A . s G fB[x := s]@\u00afe .B ' . s,\u00afC G f{{x : A}}.B \n@ { e} ;\u00afe .B ' . s;\u00afs, C (3) AddMeta(a :G .A) e\u00af= { e} ;\u00afe ' G f{{x : A}}.B @ { a} ;\u00afe .B ' . \u00af s, C \nG f{{x : A}}.B @\u00afe .B ' s, C.{FindInScope a} (4) We change the last rule on [15, p. 70] to the following: \nA = { x : A1}}.A2 A = {x : A1}.A2 G fA @ E .A . E, {} (5) A somewhat technical point here is that at \nthe moment, we do not allow meta-variables introduced for instance arguments to be .-expanded, as this \nis done for Agda s normal implicit arguments. We take a conservative approach because we currently do \nnot have a good understanding of possible interactions between .-expansion and instance resolution. During \nour experiments, we have estab\u00adlished that all of them (see section 3 and 5) have worked well with\u00adout \n.-expansion. It is future work to get a better understanding of the issues involved. A.3 Resolution algorithm \nThe resolution of a constraint FindInScope a in context G and scope S with G f a : A tries to infer a \nvalue from either the values in the current context G or the constants in scope S. If only one candidate \nis found in both sets, it is selected. If there is more than one candidate, resolution of the constraint \nis postponed in the hope that more type information will become available further on, reducing the set \nof candidates further. If the constraint is not resolved when type checking .nishes, this is reported \nto the user. If there are no candidates, then the constraint cannot be solved and this is also reported. \nTo formalise these rules, we need some extra information about meta variables introduced through inference \nrule (4) above: the context and scopes at the point where they were de.ned. We do not make this change \nexplicit because the context is actually already implicitly being maintained throughout Norell s development \n[15], and because both the scope and the context are already being kept in the Agda implementation. For \na meta variable a, we write MScp a and MCtx a for the scope resp. the context in which a meta variable \na was introduced. With these nuances, we can formally de.ne how we solve con\u00adstraints FindInScope a as \nfollows: Lookup(a : A) Candidates(MCtx(a), MScp(a),a, A)= {(n, An)} G fA .An . C a := n (6) G fFindInScope \na . C This de.nition says that if we have a meta-variable a typed A, that is to be inferred as an instance \nargument, then it is resolved if there is a unique solution. In this case, we require convertibility \nof the types and assign the value to the meta-variable. The set of candidates in context G and scope \nS, for meta-variable a, of type A is de.ned by predicate Candidates: Candidates(G,S, a,A)= {(n, An) \n|Cand(G,S,n,An) and ValidCand(a, A, n, An)} (7) The candidates are those terms n, of type An, that are \npotential candidates in the current context and scope (predicate Cand below) and are valid with respect \nto the current meta-variable and its type. This last property is de.ned by the ValidCand predicate. (S)CheckCand(a, \nA, n ' ,A ' ) . C=.(S ') (8) (S)ValidCand(a, A, n ' ,A ' )=.(S) In the de.nition of this predicate, we \nperform a check, but if this check makes changes to the current signature, we do not yet carry them through \nhere. This is formalised using the explicit notation of the signatures in the judgements [15, 3.3.1 p. \n54].  A ' .C .C: C = FindInScope a ' .\u00ac(Y C C ' ) G fA C a := n CurrentConstraints(C) CheckCand(a, A, \nn ' ,A ' ) C (9) The check that a certain term is valid for a certain meta-variable consists of two parts. \nFirst, the term s type must be convertible to the required type. Second, if we assign the value to the \nmeta\u00advariable, no other constraint must be immediately invalidated. For this last check, we do not recursively \nconsider other FindInScope constraints, since this would introduce recursion in the instance search. \nThis check is necessarily incomplete: in Norell s words, the type checker will give one of three answers \n[15, Note p. 65]: yes it is type correct , no it is not correct or it might be correct if the metavariables \nare instantiated properly . Only if we get the second answer, we reject the candidate under scrutiny. \nRule (9) strikes a .ne balance. On the one hand, the resolution algorithm needs to be powerful enough \nto be usable, but we avoid making it too powerful (see discussion in section 4). The intuition behind \nthe criterion above is that we consider any value that is type-correct in the sense that it has the correct \ntype, but also in the sense that it does not immediately invalidate constraints. The criterion has proven \nsuf.cient for all use cases discussed in this text, but also necessary: without the check for invalidated \nconstraints, monad instances for example are often not resolved. Note that we have used a new CurrentConstraints \noperation, which works on the signature that is implicit in the typing judgements: (S) CurrentConstraints(C)=.(S)where \nC= {C |C .S} (10) We still need to de.ne the potential candidates in a given context and scope. The Cand \nproperty formalises this: G= G1; n : A;G2 Cand(G,S,n, A) (11) Visiblepri(n, S) Lookup(n : A) Cand(G,S,n, \nA) (12) The somewhat technical predicate Visiblep(n, S) asserts that name n is publicly or privately \n(de.ned by p) in scope S: Visiblepub(n, S) (13) Visiblea(n, S . s) VisibleNSa(n, s) .VisibleNSpub(n, \ns) (14) Visiblea(n, S . s) n .nsa(cn) (15) VisibleNSa(n, (M, nspub,nspri)) From rules (6) and (9) above, \nit is clear that resolution of con\u00adstraints FindInScope a only compares types that have already been \ntype checked, and does not trigger extra type checking. There\u00adfore, only one constraint FindInScope a \nwill be resolved per oc\u00adcurence in the user s code of a function taking an instance argument without \na value being provided explicitly. This means that, contrary to other proposals, the computational power \nof our resolution algo\u00adrithm is fundamentally limited, in the sense that it does not allow any form of \nrecursion, looping or backtracking. It therefore does not introduce a separate computational model in \nthe language (see section 4). A.4 Soundness Intuitively, soundness of the rules above is easily guaranteed, \nbe\u00adcause all we do is assign terms of the correct type to meta-variables. The following lemma re.ects \nthis intuition, supplementing Norell s Lemma 3.5.13: Lemma 1 (Instance resolution preserves consistency). \nIf G f|S|valid, S is consistent and (S)G fFindInScope a =.(S ' ) then S ' is consistent. Proof. A consequence \nof Norell s Lemma 3.5.12 (Re.nement pre\u00adserves consistent signatures), together with the observation \nthat rule (6) will only ever perform a type correct assignment of a meta\u00advariable (a signature re.nement). \nThis lemma suf.ces to establish that Norell s Lemma 3.5.14 (Constraint solving is sound) stays valid \nin the context of our new kind of constraints, as well as the main result, Theorem 3.5.18 (Soundness \nof type checking). Like Norell for normal implicit arguments, we provide formal rules for the insertion \nof instance arguments and the insertion of instance lambda s, but do not prove any formal results about \nthem. Some of the rules above may give the impression that this res\u00adolution algorithm is sensitive to \nthe order in which type-checking is interleaved with constraint solving. However, this sensitivity ac\u00adtually \nonly exists for error reporting. Remember that during type\u00adchecking, constraints will only be added and \nsolved (after a correct meta-variable assignment), but they cannot otherwise be removed. As a consequence \nof this, the candidates set for a given instance ar\u00adgument meta-variable a, de.ned by rule (7) above, \nform a descend\u00ading series during type-checking: later sets are subsets of previous ones. Furthermore, \nif a value in scope can be assigned to a such that the entire Agda expression succesfully type checks, \nthen this value will be contained in all of these candidate sets. All non-valid candidates will eventually \nbe removed. Therefore, if no other valid candidates are available, the valid value will inevitably be \nchosen. For erroneous programs, the order of constraint solving may determine the kind of error message \nthat is generated. Depending on whether a constraint C is registered after a certain instance argument \nis already resolved, or before, an error will be reported for the FindInScope constraint or the constraint \nC. This in.uence of type-checking on error reporting also exists for standard Hindley-Milner type inferencing \n[7], so we consider it acceptable. One extension of the current resolution scheme that we have considered \nin detail is based on a prioritisation of candidates, e.g. by giving precedence to values de.ned closer \nto the call site. How\u00adever, contrary to our current resolution algorithm, such a prioritisa\u00adtion does \nmake the result of instance resolution depend on the order of constraint resolution. Suppose there is \na value in the highest pri\u00adority set which is valid except for a constraint produced late during type \nchecking and suppose this is the only candidate at the highest priority, but a lower priority candidate \nis also valid, and does not invalidate the late constraint. Since we don t know upfront which constraints \nwill be produced during the rest of type-checking, we have to decide at some point which value to use. \nIf the late con\u00adstraint has then not yet been produced, the highest priority candi\u00addate will be selected \nand a type error will be reported when the late constraint is .nally encountered. However, if the resolution \noccurs after the production of the late constraint, the valid low-priority candidate is chosen instead \nof the invalid high-priority one, and all goes well. We currently do not see a solution for this problem, \nso we keep the introduction of a prioritised resolution algorithm as future work. Our experiments (see \nsection 3 and 5) show that the current non\u00adprioritised resolution scheme suf.ces for real use.   \n\t\t\t", "proc_id": "2034773", "abstract": "<p>We present instance arguments: an alternative to type classes and related features in the dependently typed, purely functional programming language/proof assistant Agda. They are a new, general type of function arguments, resolved from call-site scope in a type-directed way. The mechanism is inspired by both Scala's implicits and Agda's existing implicit arguments, but differs from both in important ways. Our mechanism is designed and implemented for Agda, but our design choices can be applied to other programming languages as well.</p> <p>Like Scala's implicits, we do not provide a separate structure for type classes and their instances, but instead rely on Agda's standard dependently typed records, so that standard language mechanisms provide features that are missing or expensive in other proposals. Like Scala, we support the equivalent of local instances. Unlike Scala, functions taking our new arguments are first-class citizens and can be abstracted over and manipulated in standard ways. Compared to other proposals, we avoid the pitfall of introducing a separate type-level computational model through the instance search mechanism. All values in scope are automatically candidates for instance resolution. A final novelty of our approach is that existing Agda libraries using records gain the benefits of type classes without any modification.</p> <p>We discuss our implementation in Agda (to be part of Agda 2.2.12) and we use monads as an example to show how it allows existing concepts in the Agda standard library to be used in a similar way as corresponding Haskell code using type classes. We also demonstrate and discuss equivalents and alternatives to some advanced type class-related patterns from the literature and some new patterns specific to our system.</p>", "authors": [{"name": "Dominique Devriese", "author_profile_id": "81467668211", "affiliation": "KULeuven, Heverlee, Belgium", "person_id": "P2801390", "email_address": "dominique.devriese@cs.kuleuven.be", "orcid_id": ""}, {"name": "Frank Piessens", "author_profile_id": "81100110352", "affiliation": "KULeuven, Heverlee, Belgium", "person_id": "P2801391", "email_address": "frank.piessens@cs.kuleuven.be", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034796", "year": "2011", "article_id": "2034796", "conference": "ICFP", "title": "On the bright side of type classes: instance arguments in Agda", "url": "http://dl.acm.org/citation.cfm?id=2034796"}