{"article_publication_date": "09-19-2011", "fulltext": "\n A Hierarchy of Mendler style Recursion Combinators * Taming Inductive Datatypes with Negative Occurrences \nKi Yung Ahn Tim Sheard Portland State University {kya,sheard}@cs.pdx.edu Abstract The Mendler style \ncatamorphism (which corresponds to weak in\u00adduction) always terminates even for negative inductive datatypes. \nThe Mendler style histomorphism (which corresponds to strong in\u00adduction) is known to terminate for positive \ninductive datatypes. To our knowledge, the literature is silent on its termination properties for negative \ndatatypes. In this paper, we prove that histomorphisms do not always termintate by showing a counter-example. \nWe also enrich the Mendler collection of recursion combinators by de.n\u00ading a new form of Mendler style \ncatamorphism (msfcata), which terminates for all inductive datatypes, that is more expressive than the \noriginal. We organize the collection of combinators by placing them into a hierarchy of ever increasing \ngenerality, and describing the termination properties of each point on the hierarchy. We also provide \nmany examples (including a case study on a negative in\u00adductive datatype), which illustrate both the expressive \npower and beauty of the Mendler style. One lesson we learn from this work is that weak induction applies \nto negative inductive datatypes but strong induction is problematic. We provide a proof of weak in\u00adduction \nby exhibiting an embedding of our new combinator into F.. We pose the open question: Is there a safe \nway to apply strong induction to negative inductive datatypes? Categories and Subject Descriptors D.3.3 \n[Programming Lan\u00adguages]: Langauge Constructs and Features abstract data types, polymorphism, control \nstructure, recursion; F.3.3 [Logics and Meanings of Programs]: Study of Program Constructs control primitives, \nfunctional constructs, program and recursion schemes, type structure; F.4.1 [Mathematical Logic and Formal \nLanguages]: Mathematical Logic lambda calculus and related systems General Terms Languages Keywords catamorphism, \nhistomorphism, higher-order abstract syntax, parametric polymorphism, parametricity, recursion schemes, \nrecursion combinators, termination, totality 1. Introduction This paper explores a family of terminating \nrecursion combinators over a wide class of inductive datatypes. The functional program\u00ad * work supported \nby the National Science Foundation under grant 0910500. Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. ICFP 11, September 19 21, 2011, Tokyo, Japan Copyright \n&#38;#169; 2011 ACM 978-1-4503-0865-6/11/09. . . $10.00 ming community has traditionally focused on families \nof combina\u00adtors that work well in Hindley-Milner languages, characterized by folds and catamorphisms. \nThis paper explores a more expressive family called Mendler style combinators. The Mendler style com\u00adbinators \nwere originally developed in the context of the Nuprl [8] type system. Nuprl made extensive use of dependent \ntypes. General type checking in Nuprl was done by interactive theorem proving not by type inference. \nThe Mendler style combinators are consid\u00aderably more expressive than the conventional Squiggol [5] school. \nRecently, Mendler style combinators have been studied in the context of modern functional languages with \nadvanced type sys\u00adtem features, including higher-rank polymorphism and generalized algebraic data types. \nThis paper extends that analysis by Illustrating that the Mendler style approach applies to useful examples \nof negative datatypes, through the case study of the HOAS formatting function (\u00a74). *Extending the Mendler \nstyle catamorphism by using the inverse trick .rst described by Fegaras and Sheard [13], and later re\u00ad.ned \nby Washburn and Weirich [37] (\u00a74). Providing an intuitive explanation of why the Mendler style catamorphism \nensures termination (\u00a73.3) even for negative datatypes (\u00a73.8). We illustrate a semi-formal proof of termi\u00adnation \nby encoding the extended catamorphism in the F. frag\u00adment in Haskell (Figure 6, \u00a78) *Providing an intuitive \nexplanation of why the Mendler style histomorphism terminates for positive datatypes (\u00a73.4), but may \nfail to terminate for negative datatypes (\u00a73.8) by showing a counter-example to termination. Organizing \na large class of Mendler style recursion combinators into an intuitive hierarchy, of increasing generality, \nthat is ex\u00adpressive enough to cover regular dataypes (\u00a73.1, \u00a73.4), nested datatypes (\u00a73.5), indexed datatypes \n(GADTs) (\u00a73.6), mutually recursive datatypes (\u00a73.7), and negative datatypes (\u00a73.8, \u00a74).  Providing a \ndetailed set of examples, all written in Haskell, in both the conventional and Mendler style, that illustrate \nmost points in the hierarchy.  The *-items are original contributions, and the others are collec\u00adtive \nobservations of common patterns arising from the study of both the previously known combinators and our \nnew combinators. We demonstrate the Mendler style combinators in the Glasgow Haskell Compiler [31] (GHC) \ndialect of Haskell. However, this demonstration depends on a set of conventions. We assert that all our \ncode fragments conform with our conventions. The conventions include: (1) all values of algebraic data \ntypes are inductive (.nite), (2) certain conventions of data abstraction not enforced by Haskell, and \n(3) we can control or delineate other sources of nontermination. The motivation for this investigation \nis the design of Trellys, a full-featured language with dependent types being developed by a cooperative \nproject of Portland State University, the University of Iowa, and the University of Pennsylvania. A design \ngoal of Trellys is to develop an inference mechanism which determines what terms of the language are \nsafe to use as a logic, and what terms can only be used as programs. We call this analysis logicality \ninference. The intent is that logical values can be interpreted as proof objects by a Curry-Howard style \ninterpretation, while programmatic val\u00adues are allowed to express arbitrary computations (including non\u00adtermination). \nThe usability of Trellys requires that it be as expres\u00adsive as possible over natural forms of inductive \nand recursive argu\u00adment. Hence our motivation to fully understand the Mendler style recursion combinators. \nIt is our intention that the three conventions discussed in the previous paragraph will be enforced in \nthe Trellys system, and our use of Haskell to illustrate the Mendler style, will soon be unnecessary. \n The use of Mendler style combinators is characterized by split\u00adting the de.nition of a recursive type \ninto a generating functor (or a base datatype) and an explicit application of the appropriate datatype \n.xpoint operator. There exists an in.nite series of datatype .xpoint operators, each of a different rank, \nin this paper we illus\u00adtrate only the .rst two ranks. The rank of a datatype depends upon the kind of \nits type indexes (as opposed to its type parameters).1 2. Background -Termination and Negativity Mendler \n[23] showed that diverging computations can be expressed using inductive datatypes with negative occurrences \nof the datatype being de.ned. No explicit recursion at the value level is required to elicit non-termination. \nWe can illustrate this in Haskell as follows: data T = C (T . ()) w (Cw) p :: T . (T . ()) (p (Cw)) (Cw)) \np (Cf )= f w (Cw) w :: T . () (p (Cw)) (Cw)) wx =(px) x \u00b7\u00b7\u00b7 On the left is a data de.nition of the negative \ndatatatpe T , and the non-recursive functions p and q. On the right is a diverging computation ( denotes \na reduction step). Note, the term w (Cw)::T diverges even though the functions p and w are non-recursive. \nThe cause of this divergence can be attributed to the hidden self application in the term w (Cw)::T . \nThe negative occurrence of T in the datatype de.nition of T is what enables this self application to \nbe well typed. For this reason, many systems (e.g., Hagino s CPL [14], and Coq [26]) supporting inductive \ndatatypes require all datatypes to be positive (or covariant) in order to ensure normalization. Uustalu \nand Vene [33] call this style, limiting datatypes to positive occurrences, the conventional style, in \ncontrast to what they name the Mendler style [24]. In the Mendler style, datatypes are not limited to \ninduct over positive occurrences, yet functions expressible via catamorphism always terminate. This was \n.rst reported by Uustalu [32] and Matthes [19], but the search for exciting examples of negative datatypes \nwas postponed until another time (considering it may have a theoretical value only [33]). Subsequent \nwork [1, 2, 35, 36], that pioneered the Mendler style in practical functional program\u00adming, also failed \nto produce good examples that make use of nega\u00adtive datatypes in the Mendler style. In the functional \nprogramming community, there are both well\u00adknown and useful examples of negative and mixed datatypes \n(e.g., 1 In general, we de.ne a .xpoint \u00b5. for each kind .. For example, \u00b5* is \u00b50 and \u00b5*.* is \u00b51. There \nare multiple .xpoints for each rank higher than rank 0. For example, another rank 1 .xpoint with two \nindices can be de.ned as data \u00b5*.*.* fij = In*.*.* {out*.*.* :: f (\u00b5*.*.* f ) ij }. delimited control[29]2). \nOne of the classic examples is Higher-Order Abstract Syntax (HOAS) [7, 27]. A non-standard de.nition \nof HOAS in Haskell is:3 data Exp = Lam (Exp . Exp) | App Exp Exp | Var String We can de.ne a function \nshowExp :: Exp . String that formats an HOAS expression into a string. For example, showExp (Lam (.x \n. x)) \"(\\a->a)\" showExp (Lam (.x . Appx x)) \"(\\a->(a a))\" The function showExp is total, provided the \nfunction values em\u00adbedded in the Lam data constructor are total (which is one of the things the Trellys \nlogicality inference provides). This paper illustrates that this example (a negative datatype), and many \noth\u00aders examples including non-regular datatypes and mutually recur\u00adsive datatypes can all be easily \nwritten as Mendler style recursion, whose termination properties are known. 3. A Tour of the Mendler \nstyle Approach In this section we give a tour of the Mendler style approach, to orient the reader, before \ndiving into our case study on HOAS for\u00admatting in \u00a74. First, we introduce both the catamorphism (\u00a73.3) \nand histomorpism (\u00a73.4) combinators of rank 0 for regular datatypes. Second, we provide intuition why \nMendler style recursion combi\u00adnators ensure termination for positive datatypes. Third, we move our focus \nfrom regular datatypes to more expressive datatypes which need rank 1 recursion combinators. These include \nnested datatypes (\u00a73.5), indexed datatypes(GADTs) (\u00a73.6), and mutu\u00adally recursive datatypes (\u00a73.7). Fourth, \nwe give intuition why the Mendler style catamorphism ensures termination even for negative datatypes \n(\u00a73.8). Finally, we present the case study focusing on HOAS in \u00a74. All of our results are summarized \nin Figures 2, 3, and 4. In Figure 2, we de.ne the Mendler style datatype .xpoint operators (i.e. \u00b50 and \n\u00b51). These are datatype de.nitions in Haskell that take type constructors as arguments. They are used \nto tie the recursive knot through the generating functor (or base datatype) that they take as an argument. \nIn Figure 3, we provide the types of 8 Mendler style combina\u00adtors distributed over the two ranks that \nwe consider, along with the type of a conventional catamorphism for comparison. The combi\u00adnators can \nbe organized into a hierarchy of increasing generality, and juxtaposing the types of the combinators \nmakes it clear where in the hierarchy each combinator appears, and how each is related to the others. \nIn Figure 4, we de.ne the combinators themselves, again dis\u00adtributed over two ranks. The de.nition of \nthe corresponding com\u00adbinators in the two ranks are textually identical, although they must be given \ndifferent types in each rank. In Figures 7, 8, and 9, 10, and 11, we provide examples4 selected for each \nof the combinators mcata0, mhist0, mcata1, and mhist1. We discuss the remaining combinators of the inverse \naugmented .xpoints in \u00a74, where we culminate with the HOAS formatting example. We have structured each \nof the examples into two, side by side, parts. On the left, we provide a general recursive encoding, \nand on the right, a Mendler style encoding. 2 A Haskell datatype de.nition for this can be found at http://lists.seas.upenn.edu/pipermail/types-list/2004/000267.html \n3 The standard de.nition of HOAS, which omits the Var constructor, makes it more challenging to de.ne \nshowExp, as we shall see in \u00a74. 4 Some of the examples (Figures 7, 8, and 9) are adopted from [1, 2, \n35, 36].  newtype \u00b50 (f :: * .* )= In0 {out0 :: f (\u00b50 f ) } data \u00b5.0 (f :: * .* ) a = I.n0 {.out0 :: \nf (.\u00b50 fa) }| Inverse0 a newtype \u00b51 (f :: (*.*) . (*.*)) i = In1 {out1 :: f (\u00b51 f ) i } \u00b51 (f :: (*.*) \n. (*.*)) ai n1 {.\u00b51 f data .= I.out1 :: f (.a) i }| Inverse1 a Figure 2. Standard (left) and inverse \naugmented (right) datatype.xpoints for rank 0 (.rst line) and rank 1 (second line) abstract inverse abstract \nunroll abstract recursive call combining function input value answer cata :: Functor f . ((fa . a )) \n. \u00b50 f . a mcata0 :: (.r. ( r . a ) . (fr . a )) . \u00b50 f . a mcata1 :: (.ri. (.i.ri . ai) . (f ri . ai)) \n. \u00b51 fi . ai mhist0 :: (.r. ( r . fr ) . ( r . a ) . (fr . a )) . \u00b50 f . a mhist1 :: (.ri. (.i. ri . \nf ri ) . (.i.ri . ai) . (f ri . ai)) . \u00b51 fi . ai msfcata0 :: (.r. ( a . ra ) . ( ra . a ) . (f (ra) \n. a )) . (.a.\u00b5.0 fa ) . a msfcata1 :: (.ri.(.i.ai . r (ai) i) . (.i.r (ai) i . ai) . (f (r (ai)) i . \nai)) . (.a.\u00b5.1 f (ai) i) . ai msfhist0 :: (.r. ( a . ra ) . (.a. ra . f (ra)) . ( ra . a ) . (f (ra) \n. a )) . (.a.\u00b5.0 fa ) . a msfhist1 :: (.ri.(.i.ai . r (ai) i) . (.ai.r (ai) i . f (r (ai)) i) . (.i.r \n(ai) i . ai) . (f (r (ai)) i . ai)) . (.a.\u00b5.1 f (ai) i) . ai  Figure 3. Type signatures of recursive \ncombinators. Note the heavy use of higher-rank types. cata s (In0 x)= s (fmap (cata s) x) msfhist0 . \nr = msfhist . r where mcata0 . (In0 x)= . (mcata0 .) x msfhist :: (.r.(a . ra) mcata1 . (In1 x)= . (mcata1 \n.) x . (.a.ra . f (ra)) mhist0 . (In0 x)= . out0 (mhist0 .) x . (ra . a) mhist1 . (In1 x)= . out1 (mhist1 \n.) x . (f (ra) . a)) . \u00b5.0 fa . a msfhist . (I.n0 x)= . Inverse0 out.0 (msfhist .) x msfcata0 . r = msfcata \n. r where msfhist . (Inverse0 z)= z msfcata . (I.n0 x)= . Inverse0 (msfcata .) x msfcata . (Inverse0 \nz )= z msfhist1 . r = msfhist . r where msfhist :: (.ri.(.i.ai . r (ai) i) msfcata1 . r = msfcata . \nr where . (.ai.r (ai) i . f (r (ai)) i) msfcata :: (.ri.(.i.ai . r (ai) i) . (.i.r (ai) i . ai) . (.i.r \n(ai) i . ai) . (f (r (ai)) i . ai)) . \u00b5.1 f (ai) i . ai . (f (r (ai)) i . ai)) . \u00b5.1 f (ai) i . ai msfhist \n. (I.n1 x)= . Inverse1 out.1 (msfhist .) x msfcata . (I.n1 x)= . Inverse1 (msfcata .) x msfhist . (Inverse1 \nz)= z msfcata . (Inverse1 z )= z Figure 4. De.nitions of recursive combinators. Note identical textual \nde.nitions for the same operators at different ranks, but with types specialized for that rank. type \n\u00b50 f = .a.(.r.(r . a) . fr . a) . a mcata0 . r = mhist0 (const .) r mcata0 :: (.r.(r . a) . fr . a) . \n\u00b50 f . a mcata1 . r = mhist1 (const .) r mcata0 . r = r . msfcata0 . r = msfhist0 (.inv . . inv) r in0 \n:: f (\u00b50 f ) . \u00b50 f msfcata1 . r = msfhist1 (.inv . . inv) r in0 r . = . (mcata0 .) r Figure 5. Alternative \nde.nition of catamorphism via histomorphism. Figure 6. F. encoding of \u00b50 and mcata0 in Haskell 3.1 De.ning \nrecursive regular datatypes In the Mendler style approach, we de.ne Mendler style inductive datatypes \nas .xpoints of non-recursive base datatypes. For exam\u00adple, the following are de.nitions of the natural \nnumber type in the general recursion style (left) and in the Mendler style (right). data Nr = Z | Sr \ndata Nat type Nat = \u00b50 N = Z zero = In0 Z | S Nat succ n = In0 (Sn) Note, in Mendler style, we de.ne \nNat by applying the .xpoint \u00b50 to the base N . The type argument r in the base N is intended to denote \nthe points of recursion in the inductive type. Here, we have only one point of recursion at S, the successor \ndata constructor. Then, we de.ne the shorthand constructors zero and succ (on the right), which correspond \nto the data constructors Z and S of the natural number datatype in the general recursive encoding (on \nthe left). We can express the number 2 as S (SZ ) in the general recur\u00adsive encoding, and succ (succ \nzero) or In0 (S (In0 (S (In0 Z )))) in the Mendler style encoding. We can also de.ne parameterized datatypes, \nsuch as lists, in the Mendler style, using the same datatype .xpoint \u00b50, provided that we consistently \norder the parameter arguments (p) to come before the type argument that denotes the recursion points \n(r) in the base datatype de.nition (Lpr): data Lpr = N | C pr data List p type List p = \u00b50 (Lp) = N nil \n= In0 N | Cp (List p) cons x xs = In0 (C xxs) Note, we de.ne List p as \u00b50 (Lp), which is the .xpoint \nof the partial application of the base L to the parameter p. We can express the integer list with two \nelements 1 and 2 as C 1(C 2 N ) in the general recursive encoding, and cons 1(cons 2 nil) or In0 (C 1(In0 \n(C 2(In0 N )))) in the Mendler style encoding. 3.2 Conventional Catamorphism for regular datatypes The \nconventional catamorphism5 is de.ned on the very same .x\u00adpoint, \u00b50, as is used in the Mendler style, \nprovided that the base datatype f is a functor. This, more widely known approach [14], was developed \nindependently, and at about the same time, as the Mendler style. The additional requirement, that the \nbase datatype (f ) is a func\u00adtor, shows up as a type class constraint (Functor f ) in the type signature \nof the conventional catamorphism combinator cata: cata :: Functor f . (fa . a) . \u00b50 f . a (Figure 3). \nThis is necessary because cata is de.ned in terms of fmap (a method of the Functor class): cata . (In0 \nx)= . (fmap (cata .) x) (Figure 4). The combinator cata takes a combining function . :: fa . a, which \nassumes the recursive subcomponents (e.g., tail of the list) have already been turned into a value of \nanswer type (a) and com\u00adbines the overall result. A typical example of catamorphism is the list length \nfunction. We can de.ne the list length function lenc in conventional style, which corresponds to the \nlist length function len in the general recursion style in the left-hand side of Figure 7, as follows: \nlenc :: List p . Int lenc = cata . where . N =0 . (C x xslen)=1+ xslen 5 In Haskell-ish words, foldr \non lists generalized to other dataypes We need the functor instance for the base Lp, which properly de.nes \nfmap, to complete the de.nition: instance Functor (Lp) where fmapf N = N fmap f (C xxs)= Cx (f xs) The \nconventional catamorphism is widely known, especially on the list type, as foldr. The conventional catamorphism \nis more often used than the Mendler catamorphism, but it does not generalize eas\u00adily to more exotic datatypes \nsuch as GADTs, or nested datatypes.  3.3 Mendler style Catamorphism for regular datatypes The Mendler \ncatamorphism mcata0 lifts the restriction that the base type be a functor, but still maintains the strict \ntermination behavior of cata. This restriction is lifted by using two devices. The combining function \n. becomes a function of 2 arguments rather than 1. The .rst argument is a function that represents a \nrecursive placeholder, and the second is the base structure that must be combined into an answer. The \nrecursive placeholder allows the programmer to direct where recursive calls must be made. The Functor \nclass requirement is lifted, because no call to fmap is required in the de.nition of mcata0: mcata0 . \n(In0 x)= . (mcata0 .) x The second device is the use of higher-rank polymorphism to insist that the recursive \nplaceholder, with type (r . a), and the base structure, with type (fr), work over an abstract type, denoted \nby (r). mcata0 :: (.r.(r . a) . (fr . a)) . \u00b50 f . a Under what conditions do mcata0 calls always terminate? \nAl\u00adthough we de.ned \u00b50 as a newtype and mcata0 as a function in Haskell, you should consider them as \nan information hiding ab\u00adstraction. The rules of the game (which will be enforced in Trellys) require \nprogrammers to construct values using the In0 constructor (as in zero, succ, nil and cons), but forbid \nprogrammers from de\u00adconstructing those values by pattern matching against In0 (or, by using the selector \nfunction out0). These operations are hidden by the abstraction boundary (or in the case of Trellys logicality \nin\u00adference, lead to classifying a term as programatic, rather than as logical). To remain in the logical \n(terminating) classi.cation, when\u00adever you need to decompose values of inductive datatypes you must do \nit via mcata0 (or, any of the other terminating Mendler style combinators). To conform to these rules, \nall functions over posi\u00adtive inductive datatypes, except the trivial ones such as identity and constant \nfunctions (which don t inspect their structure), need to be implemented in terms of the combinators described \nin Figure 3. For negative inductive datatypes only the combinators in the catamor\u00adphism family ensure \ntermination. The intuitive reasoning behind the termination property of mcata0 for all positive inductive \ndatatypes is that (1) mcata0 strips off one In0 constructor each time it is called, and (2) mcata0 only \nrecurses on the direct subcomponents (e.g., tail of a list) of its argument (because the type of the \nrecursive placeholder won t al\u00adlow it to be applied to anything else). Once we observe these two properties, \nit is obvious that mcata0 always terminates since those properties imply that every recursive call to \nmcata0 decreases the number of In0 constructors in its argument.6 The .rst property is easy to observe \nfrom the de.nition of mcata0 in Figure 4, in particular, the pattern matching of the 6 We assume that \nthe values of inductive types are always .nite. We can construct in.nite values (or, co-inductive values) \nin Haskell exploiting lazy\u00adness, but we exclude such in.nite values from our discussion in this work, \nand this property is a fundamental design decision in Trellys.  data Lpr = N | C pr data List p type \nList p = \u00b50 (Lp) = N nil = In0 N | Cp (List p) cons x xs = In0 (C xxs) lenm :: List p . Int len :: List \np . Int lenm = mcata0 . where len N =0 . len N =0 len (C xxs)=1+ len xs . len (C xxs)=1+ len xs Figure \n7. mcata0 example: list length function second argument with (In0 x). The second property is enforced \nby the parametricity in the type of the combining function . of the mcata0 combinator as shown in Figure \n3, In Figure 7, we rede.ne the length function (lenm on the right), this time, using a Mendler style \ncatamorphism. In the de.nition of lenm, we name the .rst argument of ., the recursive placeholder, to \nbe len. We use this len exactly where we would recursively call the recursive function in the general \nrecursion style (len on the left). However, unlike the general recursion style, it is not possible to \ncall len :: r . Int on anything other than the tail xs :: r. Using general recursion, we could easily \nerr (by mistake or by design) causing length to diverge, if we wrote its second equation as follows: \nlen (C xxs)=1+ len (C xxs). We cannot encode such diverging recursion in Mendler style because len ::r \n. Int requires its argument to have the parametric type r, while (C xxs) :: Lpr has more speci.c type \nthan r. The parametricity enforces weak structural induction. The scheme of having the combining function \n. abstract over the recursive placeholder len is a powerful one. We will reuse this strategy, generalizing \n. to abstract over additional arguments, in order to generalize mcata0 to become more expressive.  3.4 \nMendler style Histomorphism for regular datatypes Some computations are not easily expressible by a catamorphism, \nsince a catamorphism only recurses on the direct subcomponents (e.g., tail of a list). Recursing on deeper \nsubcomponents (e.g., tail of tail of a list) requires complex encodings in the conventional setting. \nUnfortunately, functional programmers often write simple recursive functions using nested pattern matching \nthat recurse on deep subcomponents exposed by the nested patterns. A typical example is the Fibonacci \nfunction: .b Z =0 .b (SZ ) =1 .b (S (Sm)) = .b (Sm)+ .b m Note, in the third equation .b recurses on \nboth the predecessor (Sm), which is a direct subcomponent of the argument, and the predecessor of the \npredecessor m, which is a deeper subcomponent of the argument. The Histomorphism [34] captures such patterns \nof recursion often called a course-of-values recursion. In the conventional style, histomorphisms are \nde.ned through co-algebraic construction of an intermediate stream data structure that pairs up the current \nargument and the results from the previous steps. There are two ways of implementing this. One is a memoiz\u00ading \nbottom-up version, and the other is a non-memoizing version that repeats the computation of the previous \nsteps. We are not go\u00ading to show or discuss those implementations here, but the point we want to make \nis that both versions need to be implemented through co-algebraic construction [35, 36]. Course-of-values \nrecursion ex\u00adpressed in terms of this co-algebraic style will look very different from its equivalent \nin general recursion style. One needs to extract both the original arguments and the deep result values \nfrom the stream explicitly calling on stream-head and stream-tail operations. data Nr = Z | Sr type Nat \n= \u00b50 N data Nat zero = In0 Z = Z succ n = In0 (Sn) | S Nat .bm = mhist0 . where . out .b Z =0 .b Z =0 \n. out .b (Sn)= .b (Sn)= case out n of case n of Z . 1 Z . 1 Sn' . .b n + .b n' Sn' . .b n + .b n' Figure \n8. mhist0 example: Fibonacci function However, in Mendler style, we do not need such co-algebraic con\u00adstruction \nat the user level7. In the Mendler style Histomorphism, we play the same trick we played in the Mendler \nstyle Catamorphism. We arrange for the combining function to take additional arguments (Figures 3 and \n4). The combining function . now becomes a function of 3 ar\u00adguments. The .rst argument is a function \nthat represents an abstract unrolling function that projects out the value embed\u00added inside the data \nconstructor In0 by accessing the projection function out0 given in the de.nition. As in mcata0, the next \nargument represents a recursive placeholder, and the last argu\u00adment represents the base structure that \nmust be combined into an answer. mhist0 . (In0 x)= . out0 (mhist0 .) x Again we use higher-rank polymorphism \nto insist that the ab\u00adstract unrolling function, with type (r . fr), the recursive placeholder function, \nwith type (r . a), and the base struc\u00adture, with type (fr), only work over an abstract type, denoted \nby (r). mhist0 :: (.r.(a . fa) . (r . a) . (fr . a)) . \u00b7 \u00b7\u00b7 The Mendler style histomorphism is much handier \nwhen ex\u00adpressing course-of-values recursion than the conventional histo\u00admorphism [35]. For example, in \nFigure 8, the de.nition for the Fi\u00adbonacci function in general recursion style (left) and the de.nition \nin Mendler style (right) look almost identical. Particularly, when we have unrolled the nested pattern \nmatching in the general recursive de.nition into a case expression. The only difference between the two, \nis that in the Mendler style (left), we pattern match over out n in the case expression, in the Traditional-style \n(right) we pattern match over n. Let us visually relate the de.nition of mhist0 with the second equation \nof . in the de.nition of the Fibonocci function as follows: mhist0 . (In0 x)= . out0 (mhist0 .) x . . \n. . . . . . . . out .b (S n) = case out n of Z . 1 Sn' . .b n + .b n' The abstract unrolling function \nout and the recursive placeholder .b stand for the actual arguments out0 and (mhist0 .), but the higher-rank \ntype of the combining function . ensures that they are only used in a safe manner. The abstract unrolling \nfunction out enables us to discharge In0 as many times as we want inside .. 7 The Mendler style histormophism \ncombinators implemented here are the non-memoizing ones. Vene [36] suggests how to implement a memoizing \nMendler style histomorphism, which uses co-algebraic construction.  From the programmers perspective, \nout0 is a hidden primitive, hidden by the histomorphism abstraction. But, inside the de.nition of the \ncombining function ., the programmer can actually access the functionality of out0 through the abstract \nunrolling function out. The higher-rank types limit the use of this abstract unrolling function out to \nvalues of type r. In a positive inductive datatype, the only functions with domain r are the abstract \nunroller, and the recursive placeholder. The pro\u00adgrammer can only whittle down the r values inside the \nbase struc\u00adture, of type (fr), into smaller structures, of type (fr). The pro\u00adgrammer can then decompose \nthese into even smaller r values by pattern matching against the data constructors of the base f . How\u00adever, \nthere is no way to combine any of these decomposed r val\u00adues to build up larger r values. The only possible \nuse of the de\u00adcomposed r values is to call the recursive placeholder, with type (r . a). For example, \nin Figure 8, we pattern match over (out n), discharging the hidden In0 constructor of n. Note the types \ninside the (Sn ' ) pattern matching branch: n :: r; (out n) :: (Nr); and n ' :: r. What can we possibly \ndo with n and n ', of type r? The only possible computation is to call .b :: r . Int on n and n ' , as \nwe do in .b n + .b n '. It is a type error to call .b :: r . Int on either (Sn) :: Nr or (Sn ' ) :: Nr. \nThis is why the termination property of mhist0 continues to hold for positive datatypes. For negative \ndatatypes, however, we have additional functions with domain r. Inside the . function passed to mhist0, \nthe embed\u00added functions with negative occurrences, will have type r as their domain. These can be problematic. \nThe counter-example to termi\u00adnation of mhist0 is in Figure 13, which will discussed in more detail in \n\u00a73.8.  3.5 Nested datatypes The datatypes Nat and List, de.ned in \u00a73.1, are regular datatypes. Non-recursive \ndatatypes (e.g., Bool) and recursive (or inductive) datatypes without any type arguments (e.g., Nat) \nare always reg\u00adular. Among the recursive datatypes with type arguments, those datatypes where all of \nthe recursive occurrence on the right-hand side have exactly the same type argument as the left-hand \nside (in the same order) are considered regular. For example, the list datatype data List p = N | Cp \n(List p) is regular since (List p) appearing on right-hand side takes exactly the same argu\u00adment p as \nthe (List p) in the left-hand side (data List p = ...). Note, every concrete instantiation of the list \ndatatype has an equivalent non-parameterized datatype de.nition. For instance, List Bool is equivalent \nto the following datatype: data ListBool = NBool | CBool Bool ListBool This em instantiation property \ndoes not hold for nested datatypes. Type arguments that never change in any recursive occurrences in \na datatype de.nition are called type parameters. Type arguments that do change are called type indices. \nDatatypes with only type pa\u00adrameters are always regular. Nested datatypes [3] are non-regular datatypes \nwhere type arguments in some of the recursive occur\u00adrences in the recursive datatype equation differ \nfrom the left-hand side of the datatype equation. Such types can be expressed in Haskell and ML without \nusing GADT extensions. We introduce a well-known example of the bush datatype, and a function that sums \nup the elements of bush (Figure 9). Nested datatypes require us to move from rank 0 Mendler combinators \nto rank 1 Mendler combinators. The bush datatype is de.ned as follows (also in Figure 9): data Bush i \n= NB | CB i (Bush (Bush i)) The type argument i for Bush is a type index, since the type argument (Bush \ni) occurring on the right-hand side is different from i appearing on the left-hand side. What is intriguing \nabout Bush is that the variation on the type index involves itself. Matthes [20] calls such datatypes, \nlike Bush, truly nested datatypes. Here are some examples of bush values: bs = CB 1 bs ' :: Bush Int \nbs ' = CB (CB 2 NB ) bs '' :: Bush (Bush Int) bs '' :: Bush (Bush (Bush Int)) bs '' = CB (CB (CB 3 NB \n)(CB (CB (CB 4 NB) NB ) NB )) NB The tail of bs is bs ', and the tail of bs ' is bs ''. We can observe \nthat the shape of the elements becomes more deeply nested as we move towards latter elements. We can \nde.ne a function that sums up all the nested elements in a bush. Let us .rst take a look at the function \nbsum in the general recursion style, on the left-hand side of Figure 9. This function takes 2 parameters: \na bush to sum up and a function that turns elements into integers. The key part in the de.nition of bsum \nis constructing the function (.ys . bsum ys f ) :: Bush i . Int. We must construct this function, on \nthe .y, in order to make the recursive call of bsum on its tail xs :: Bush (Bush i). Without this function, \nthe recursive call wouldn t know how to sum up bushed elements. We can specialize bsum, for instance, \nfor integer bushes as follows by supplying the identity function: sumB :: Bush Int . Int sumB xs = bsum \nxs id Using sumB, we can sum up bs de.ned above: sumB bs 10. Before discussing the Mendler style version, \nlet us take a look at yet another general recursive version of the function bsum ', which explicitly \nwraps up the answer values of type (i . Int) . Int inside the newtype Ret i. The relations between the \nplain vanilla version and the wrapped up version are simply: bsum = unRet . bsum ' Ret . bsum = bsum \n' The wrapped up version bsum ' has the same structure as the Mendler style version bsumm found on the \nright-hand side of Fig\u00adure 9. The wrapping of the answer type is for purely technical reasons: to avoid \nthe need for higher-order uni.cation. If we were to work with the unwrapped answer type in the Mendler \nstyle, the type system would need to unify (ai) with ((i . Int) . Int), which is a higher-order uni.cation, \nwhereas unifying (ai) with the wrapped answer type (Ret i) is .rst-order. The type inference algorithm \nof Haskell (and most other languages) does not support higher-order uni.cation.8 Finally, let us discuss \nthe summation function for bushes using the Mendler style, found on the right-hand side in Figure 9. \nFirst, we give Mendler style datatype de.nitions for bushes. As usual, we de.ne the datatype Bush as \na .xpoint of the base BushF . However, an important difference that readers should notice is the use \nof .xpoint \u00b51 for rank 1 bases, instead of \u00b50, for the rank 0 bases inducing regular datatypes. That \nthe type argument i in Bush i is a type index that forces us to choose the rank 1 .xpoint (and its related \nrecursion combi\u00adnators). Note, in the de.nition of the base type BushF , we place the index i after the \ntype argument r for the recursion points. This is the convention we use. We always write parameters (p), \nbefore the recursion point arugment (r), followed by indices (i). Figure 10, which we will shortly discuss \nin \u00a73.6, contains an example where there are both type parameters and type indices in a datype (Vec p \ni). Getting back to the right-hand side of Figure 9, since we used \u00b51 to de.ne the inductive datatypes, \nwe use mcata1, the Mendler style catamorphism combinator for rank 1, to de.ne the functions. The 8 We \nmay avoid higher-order uni.cation, either by making the Mendler style combinators language constructs \n(rather than functions) so that the type system treats them with specialized typing rules; or by providing \na version of the combinators with syntactic Kan-extension as in [2].  data BushF r i = NB | CB i (r \n(ri)) data Bush i = NB | CB i (Bush (Bush i)) type Bush i = \u00b51 BushF i nilB = In1 NB bsum :: Bush i . \n(i . Int) . Int consB x xs = In1 (CB x xs) bsum NB =(.f . 0) bsum :: Bush i . (i . Int) . Int bsum (CB \nx xs)=(.f . bsum = unRet . bsumm fx + bsum xs (.ys . bsum ys f )) bsumm :: Bush i . Ret i newtype Ret \ni = Ret {unRet :: (i . Int) . Int } bsumm = mcata1 . where ' '' bsum ' :: Bush i . Ret i . :: .ri .(.i.ri \n. Ret i) . BushF r i . Ret i bsum ' NB = Ret (.f . 0) . bsum ' NB = Ret (.f . 0) bsum ' (CB x xs)= Ret \n(.f . . bsum ' (CB x xs)= Ret (.f . '' '''' '' fx + bsum xs (.ys . bsum ys f )) fx + bsum xs (.ys . \nbsum ys f )) where bsum '' :: Bush i . (i . Int) . Int where bsum '' :: ri . (i . Int) . Int bsum '' \n= unRet . bsum ' bsum '' = unRet . bsum ' Figure 9. Summing up a bush (Bush), a recursively nested datatype, \nexpressed in terms of mcata1. beauty of the Mendler style approach is that the implementation of the \nrecursion combinators for higher-ranks are exactly the same as their rank 0 counterparts. The de.nitions \ndiffer only in their type signatures. As you can see in Figures 3 and 4, mcata1 has a richer type than \nmcata0, but their implementations are exactly the same! This is not the case for the conventional approach. \nThe de.nition of cata won t generalize to nested datatypes in a trivial way. There has been several approaches \n[4, 15, 18] to extend folds or catamorphisms for nested datatypes in the conventional setting.  3.6 \nIndexed datatypes (GADTs) A recent, popular extension to the GHC Haskell compiler is gener\u00adalized algebraic \ndatatypes (GADTs) [30]. In our nested examples, the variation of type indices always occurred in the \narguments of the data constructors. GADTs are indexed datatypes, where the in\u00addex may vary in the result \ntypes of the data constructors. Haskell s normal data declaration, which uses an equation syntax, makes \nthe assumption that the result types of every constructor is the same type with no variation. GHC s GADT \ndatatype extension is more expressive than the recursive data declaration. The GHC compiler extends the \ndatatype syntax, so that each datatype con\u00adstructor is given its full type. The datatype de.nition for \nvectors (or size indexed lists) is a prime example: data Vec p i where NV :: Vec p Z CV :: p . Vec p \ni . Vec p (Si) Note, the indices9 vary in the result types of the data constructors: Z in the type of \nNV and (Si) in the type of CV . Nested datatypes, which we discussed earlier, are a special case of indexed \ndatatypes that happened to be expressible within the recursive type equation syntax of Haskell, because \nthe indices only vary in the recursive arguments of the data constructors, but not in the result type. \nFor a clearer comparison, we express the bush datatype in GADT syntax as follows: 10 data Bush i where \nNB :: Bush i CB :: i . Bush (Bush i) . Bush i Note, the type argument varies in second argument of CB, \nwhich is Bush (Bush i), but both the result type of NP and CP are Bush i. 9 The Z and S used in Vec are \ntype level representations of natural num\u00adbers, which are empty types that are not inhabited by any value. \nThey are only intend to be used as indices. 10 We can translate any recursive type equation into a de.nition \nusing the GADT syntax since GADTs are indeed generalized algebraic datatypes. In Figure 10, we de.ne \nthe vector datatype Vec as \u00b51 (Vp) i, in the Mendler style. That is, we apply \u00b51 to the partial applica\u00adtion \nof the base V to the parameter p, and then apply the resulting .xpoint to the index i. The base datatype \nVpri is a GADT with a parameter p and an index i. Recall that by convention we place the parameter p \nbefore the type argument r for recursion points, followed by the index i. We can express the copy function \nthat traverses a given vector and reconstructs that vector with the same elements, in Mendler style, \nusing the rank 1 Mendler catamor\u00adphism combinator mcata1. We can express the switch2 function that switches \nevery two elements of the given vector, in Mendler style, using the rank 1 histomorphism combinator mhist1. \nThe def\u00adinitions for mcata1 and mhist1 are exactly the same as the de.ni\u00adtions for mcata0 and mhist0, \nexcept that mcata1 and mhist1 have richer type signatures (see Figures 3 and 4). Thus, de.ning func\u00adtions \nusing mcata1 and mhist1 is no more complicated than de.n\u00ading the functions for regluar datatypes using \nmcata0 and mhist0. The one proviso to this statement is that we need to give explicit type signatures \nfor . because GHC does not support type infer\u00adence for higher rank types (i.e., types with inner .s that \nare not top-level). Again, in a language where the Mendler style combina\u00adtors were language constructs \nrather than functions, we believe this annoying burden could be lifted.  3.7 Mutually recursive datatypes \nWe can express mutual recursion over mutually recursive datatypes in Mendler style using an indexed base \ndataype. The context exten\u00adsion function extend and the expression evaluation function eval in Figure \n11 are mutually recursive functions over the mutually recursive datatypes of declaration Dec and expression \nExp. The general recursive version on left-hand side of Figure 11 is a self\u00adexplanatory standard evaluator \nimplementation for the expression. To express this in Mender-style (right), we .rst de.ne the com\u00admon \nbase DecExpF which is indexed by D and E. Note, the data constructors of DecExpF include both the data \nconstructors of dec\u00adlarations (Def ) and expressions (Var, Val, Add, and Let). The data constructor for \ndeclaration is indexed by D, and the other data constructors for expressions are indexed by E in their \nresult types. Then, we can de.ne Dec as \u00b51 DecExpF D and Exp as \u00b51 DecExpF E. We wrap up the return types \nof the eval and extend functions with the data family Ret, for reasons similar to the return types of \nthe summation functions in \u00a73.5. We also de\u00ad.ne the projection functions pD :: Ret D . (Env . Env) and \npE :: Ret E . (Env . Int) to open up the return type. Then, we can express the mutually recursive functions, \nboth eval and  data Z data Si data Vec p i where NV :: Vec p Z CV :: p . Vec p i . Vec p (Si) copy :: \nVec p i . Vec p i copy NV = NV copy (CV x xs)= CV x (copy xs) switch2 :: Vec p i . Vec p i switch2 NV \n= NV switch2 (CV x xs)= case xs of NV . CV xNV CV y ys . CV y (CV x (switch2 ys)) data V pri where NV \n:: V prZ CV :: p . ri . V pr (Si) type Vec p i = \u00b51 (Vp) i nilV = In1 NV consV x xs = In1 (CV x xs) copy \n:: Vec p i . Vec p i copy = mcata1 . where . :: (.i.ri . Vec p i) . V pri . Vec p i . cp NV = nilV . \ncp (CV x xs)= consV x (cp xs) switch2 :: Vec p i . Vec p i switch2 = mhist1 . where . :: (.i.ri . V pri) \n. (.i.ri . Vec p i) . V pri . Vec p i . out sw2 NV = nilV . out sw2 (CV x xs)= case out xs of NV . consV \nx nilV CV y ys . consV y (consV x (sw2 ys)) Figure 10. Recursion (copy) and course-of-values recursion \n(switch2 ) over size indexed lists (Vec) expressed in terms of mcata1 and mhist1. type Name = String \ntype Env = [(Name, Int)] data Dec = Def Name Exp data Exp = Var Name | Val Int | Add Exp Exp | Let Dec \nExp extend :: Dec . Env . Env extend (Def xe)= .s . (x, eval e s): s eval :: Exp . Env . Int eval (Var \nx)= .s . fromJust (lookup x s) eval (Val v)= .s . v eval (Add e1 e2)= .s . eval e1 s + eval e2 s data \nD data E data DecExpF (r :: *.*)(i :: *) where Def :: Name . rE . DecExpF r D Var :: Name . DecExpF r \nE Val :: Int . DecExpF r E Add :: rE . rE . DecExpF r E Let :: rD . rE . DecExpF r E type Dec = \u00b51 DecExpF \nD type Exp = \u00b51 DecExpF E data family Ret i :: * newtype instance Ret D = RetD (Env . Env) newtype instance \nRet E = RetE (Env . Int) pD f = .x . case fx of RetD fD . fD pE f = .x . case fx of RetE fE . fE extev \n:: \u00b51 DecExpF i . Ret i extev = mcata1 . where . :: (.i.ri . Ret i) . DecExpF r i . Ret i . f (Def xe)= \nRetD $ .s . (x, ev e s): s where ev = pE f . f (Var x)= RetE $ .s . fromJust (lookup x s) . f (Val v)= \nRetE $ .s . v . f (Add e1 e2)= RetE $ .s . ev e1 s + ev e2 s where ev = pE f extend :: Dec . Env . Env \nextend = pD extev eval :: Exp . Env . Int eval = pE extev Figure 11. Mutual recursion (extend and eval \nover Dec and Exp) expressed in terms of mcata1 over an indexed datatype DecExpF extend, combined in \none function de.nition extev using mcata1. You can observe that the de.nition of . is very close to the \nde.\u00adnitions of the general recursive version of extend and eval on the left. The difference is that we \nproject out ev from f , which is the handle for combined mutually recursive function, when we need to \ncall the evaluation function for the recursion. Once we have de.ned the combined function extev, we can \nproject out extend and eval using pD and pE .  3.8 Negative datatypes, a second look Let us revisit \nthe negative inductive datatype T (from \u00a72) from which we constructed a diverging computation. We can \nde.ne a Mendler style version of T , called Tm, as follows: data TBase r = Cm (r . ()) type Tm = \u00b50 TBase \nIf we can write two functions pm :: Tm . (Tm . ()), and wm :: Tm . (), corresponding to p and w from \n\u00a72, we can reconstruct the same diverging computation. The function wm x =(pm x) x is easy. The function \npm is problematic. By the rules of the game, we cannot pattern match on In0 (or use out0) so we must \nresort to using one of the combinators, such as mcata0. However, it is not possible to write pm in terms \nof mcata0. Here is an attempt (seemingly the only one possible) that fails: pm :: Tm . (Tm . ()) pm = \nmcata0 . where . :: (r . (Tm . ())) . TBase r . (Tm . ()) . (Cm f )= f We write the explicit type signature \nfor the combining function . (even though the type can be inferred from the type of mcata0), to make \nit clear why this attempt fails to type check. The combining function . take two arguments. The recursive \nplaceholder (for which we have used the pattern , since we don t intend to call it) and the base structure \n(Cm f ), from which we can extract the function f :: r . (). Note that r is an abstract (universally \nquanti.ed) type, and the result type of . requires f :: Tm . (). The types r and Tm can never match, \nif r is to remain abstract. Thus, pm fails to type check. There is a function, with the right type, that \nyou can de.ne: pconst :: Tm . (Tm . ()) pconst = mcata0 . where . g (Cf )= const () Not surprisingly, \ngiven the abstract pieces composed of the recur\u00adsive placeholder g :: r . (), the base structure (Cf \n) :: TBase r, and the function we can extract from the base structure f :: r . (), the only function \nthat returns a unit value (modulo extensional equivalence) is, in fact, the constant function returning \nthe unit value. This illustrates the essence of how Mendler catamorphism guar\u00adantees normalization even \nin the presence of negative occurrences in the inductive type de.nition. By quantifying over the recursive \ntype parameter of the base datatype (e.g. r in TBase r), it prevents an embedded function with a negative \noccurrence from .owing into any outside terms (especially terms embedding that function). Given these \nrestrictions, the astute reader may ask, are types with embedded function with negative occurrences good \nfor any\u00adthing at all? Can we ever call such functions? A simple exam\u00adple which uses an embedded function \ninside a negative inductive datatype is illustrated in Figure 13. The datatype Foo (de.ned as a .xpoint \nof FooF) is a list-like data structure with two data con\u00adstructors Noo and Coo. The data constructor \nNoo is like the nil and Coo is like the cons. Interestingly, the element (with type Foo . Foo) contained \nin Coo is a function that transforms a Foo value into another Foo value. The function lenFoo, de.ned \nwith mcata0, is a length like function, but it recurses on the trans\u00adformed tail, (f xs), instead of \nthe original tail xs. The intuition data FooF r = Noo | Coo (r . r) r type Foo = \u00b50 FooF noo = In0 Noo \ncoof xs = In0 (Coof xs) lenFoo :: Foo . Int lenFoo = mcata0 . where . len Noo =0 . len (Coof xs)=1+ len \n(f xs) loopFoo :: Foo . Int loopFoo = mhist0 . where . out len Noo =0 . out len (Coof xs)= case out xs \nof Noo Coo f ' . 1 + len (f xs) . 1 + len (f ' xs) foo :: Foo --loops for loopFoo foo = coo0 (coo1 noo) \nwhere coo0 = coo id coo1 = coo coo0 Figure 13. An example of a total function lenFoo over a nega\u00adtive \ndatatype Foo de.ned with mcata0, and a counter-example loopFoo illustrating that mhist0 can diverge for \nnegative datatypes. behind the termination of mcata0 for this negative datatype Foo is similar to the \nintuition for positive dataypes. The embedded func\u00adtion f :: r . r can only apply to the direct subcomponent \nof its parent, or to its sibling, xs and its transformed values (e.g. f xs, f (f xs), ...), but no larger \nvalues that contains f itself. We illus\u00adtrate a general proof on termination of mcata0 in Figure 6. While \nall functions written in terms of mcata0 are total, the same cannot be said of function written in terms \nof mhist0. The function loopFoo de.ned with mhist0 is a counter-example to to\u00adtality, which shows that \nMendler style histomorphisms do not al\u00adways terminate. Try evaluating loopFoo foo. It will loop. This \nfunction loopFoo is similar to lenFoo, but has an additional twist. At the very end of the function de.nition, \nwe recurse on the trans\u00adformed tail (f ' xs), when we have more than two elements where the .rst and \nsecond elements are named f and f ', respectively. Note, f ' is an element embedded inside the tail xs. \nThus, (f ' xs) is dangerous since it applies f ' to a larger value xs, which contains f '. The abstract \ntype of the unrolling function (out :: r . fr), prevents the recursive placeholder from being applied \nto a larger value, but it does not preclude the risk of embedded functions, with negative domains, being \napplied to larger values which contain the embedded function itself. 4. Formatting Higher-Order Abstract \nSyntax To lead up to the Mendler style solution to formatting HOAS, we .rst review some earlier work \non turning expressions, expressed in Higher-Order Abstract Syntax (HOAS)[7, 27], into strings. This solution \nwas suggested by Fegaras and Sheard [13]. They were studying yet another abstract recursion scheme described \nby Pater\u00adson [25] and Meijer and Hutton [22] that could only be used if the combining function had a \ntrue inverse. This seemed a bit limiting, so Fegaras and Sheard introduced the idea of a syntactic inverse. \nThe syntactic inverse was realized by augmenting the \u00b50 type with a second constructor. This augmented \n\u00b50 had the same structure as \u00b5.0 in Figure 2, but with a different type. The algorithm worked, but, the \naugmentation introduces junk. Washburn and Weirich [37] eliminated the junk by exploiting para\u00admetricity. \nIt is a coincidence that Mendler style recursion combina\u00adtors also use the same technique, parametricity, \nfor a different pur\u00ad  data Exp= Lamg (Exp. Exp) | AppExpExp| Varg String g g gggg showExpg :: Expg . \nString '' '' showExpg e = show e vars where show (Appg xy)= .vs . \"(\" + show x vs + \"\" + show y vs + \n\")\" show ' (Lamg z)= .(v : vs) . \"(\\\\\" + v + \"->\" + show ' (z (Varg v)) vs + \")\" show ' (Varg v)= .vs \n. v data ExpF r = Lam (r . r) | Appr r type Exp ' a = \u00b5.0 ExpF a type Exp = .a.Exp ' a lam e = I.n0 (Lam \ne) appf e = I.n0 (Appf e) showExp :: Exp . String showExp e = msfcata0 . e vars where . :: (([String \n] . String) . r) . (r . ([String ] . String)) . ExpF r . ([String ] . String) ' '' . inv show (Appx y)= \n.vs . \"(\" + show x vs + \"\" + show y vs + \")\" . inv show ' (Lam z)= .(v : vs) . \"(\\\\\" + v + \"->\" + show \n' (z (inv (const v))) vs + \")\" vars = [[i ] | i . [ a .. z ]] + [i : show j | j . [1 ..], i . [ a .. \nz ]] :: [String ] Figure 14. msfcata0 example: String formatting function for Higher-Order Abstract Syntax \n(HOAS) pose, to guarantee termination. Fortunately, these two approaches work together without getting \nin each other s way. 4.1 A general recursive implementation for open HOAS The recursive datatype Expg \nin Figure 14 is an open HOAS. By open, we express that Expg has a data constructor Varg, which enables \nus to introduce free variables. The constructor Lamg holds an embedded function of type (Expg . Expg). \nThis is called a shallow embedding, since we use functions in the host language, Haskell, to represent \nlambda abstractions in the object language Expg. For example, using the Haskell lambda expressions, we \ncan construct some Expg representing lambda expressions as follows: kg = Lamg (.x . Lamg (.y . x)) sg \n= Lamg (.x . Lamg (.y . Lamg (.z . App(Appxz)(Appyz)))) gg g wg = Lamg (.x . Appg xx) Since we can \nbuild any untyped lambda expressions with Expg, even the problematic self application expression wg, \nit is not pos\u00adsible to write a terminating evaluation function for Expg. However, there are many functions \nthat recurse over the structure of Expg, and when they terminate produce something useful. One of them \nis the string formatting function showExpg de.ned in Figure 14. Given an expression (Expg) and a list \nof fresh variable names ([String ]), the function show ' (de.ned in the where clause of showExpg) returns \na string (String) that represents the given ex\u00adpression. To format an application expression (Appg xy), \nwe sim\u00adply recurse over each of the subexpressions x and y. To format a lambda expression, we take a \nfresh name v to represent the binder and we recurse over (z (Varg v)), which is the application of the \nembedded function (z :: Expg . Expg) to a variable expression (Varg v :: Expg) constructed from the fresh \nname. Note, we had to create a new variable expression to format the function body since we cannot look \ninside the function values of Haskell. To format a variable expression (Varg v), we only need to return \nits name v. The local function show ' (and hence also showExpg), are total as long as the function values \nembedded in the Lamg constructors are total. We can use showExpg to print out the terms as follows: > \nputStrLn (showExpg kg) (\\a->(\\b->a)) > putStrLn (showExpg sg) (\\a->(\\b->(\\c->((a c) (b c))))) > putStrLn \n(showExpg wg) (\\a->(a a)) Note that show ' is not structurally inductive in the Lamg case. The recursive \nargument (z (Varg v)), in particular Varg v, is not a subexpression of (Lamg z). Thus the recursive call \nto show ' may not terminate. This function terminated only because the embed\u00added function z was well \nbehaved, and the argument we passed to z , (Varg v), was well behaved. If we had applied z to the expression \n(Lamg (.x . x)) in place of Varg v, or z itself had been diver\u00adgent, the recursive call would have diverged. \nIf z is divergent, then obviously show ' (zx) diverges for all x. More interestingly, sup\u00adpose z is not \ndivergent (perhaps something as simple as the identity function) and show ' was written to recurse on \n(Lamg (.x . x)), then what happens? show ' (Lamg z)(v : vs)= \"(\\\\\" + v + \"->\" + show ' (z (Lamg (.x . \nx)) vs + \")\" The function is no longer total. To format (z (Lamg (.x . x))) in the recursive call, it \nloops back to the Lamg case again, unless z is a function that ignores its argument. This will form an \nin.nite recursion, since this altered show ' forms yet another new Lamg (.x . x) expression and keeps \non recursing.  4.2 A Mendler style solution for closed HOAS Our exploration of the code in Figure 14 \nillustrates three potential problems with the general recursive approach. The embedded functions may \nnot terminate.  In a recursive call, the arguments to an embedded function may introduce a constructor \nwith another embedded function, leading to a non terminating cycle.  We got lucky, in that the answer \nwe required was a String, and we happened to have a constructor Varg :: String . Expg. In general we \nmay not be so lucky.  In Figure 14, we de.ned Expg in anticipation of our need to write a function showExpg \n:: Expg . String, by including a con\u00adstructor Varg :: String . Expg. Had we anticipated another func\u00adtion \nf :: Expg . Int we would have needed another constructor C :: Int . Expg. Clearly we need a better solution. \nThe solution is to generalize the kind of the datatype from Expg ::* to Exp::*.*, and add a universal \ninverse.  data Exp a = App (Exp a)(Exp a) | Lam (Exp a . Exp a) | Inv a countLam :: Exp Int . Int countLam \n(Inv n)= n countLam (Appx y)= countLam x + countLam y countLam (Lam f )= countLam (f (Inv 1)) Generalizing \nfrom countLam we can de.ne a function from Exp to any type. How do we lift this kind of solution to the \nMendler style? Fegaras and Sheard [13] proposed moving the gen\u00aderal inverse from the Base type to the \ndatatype .xpoint. Later this approach was re.ned by Washburn and Weirich [37] to re\u00admove the junk introduced \nby that augmentation (i.e. things like App (Inv 1) (Inv 1)). We use the same inverse augmented datatype \n.xpoint appear\u00ading in Washburn and Weirich [37]. Here, we call it \u00b5.0 (see Figure 2). The inverse augmented \ndatatype .xpoint \u00b5.0 is similar to the standard datatype .xpoint \u00b50. The difference is that \u00b5.0 has an \nad\u00additional type index a and an additional data constructor Inverse0 :: a . \u00b5.0 ai, corresponding to \nthe universal inverse. The data con\u00adstructor I.n0 and the projection function . out0 correspond to In0 \nand out0 of the normal .xpoint \u00b50. As usual we restrict the use of . out0, or pattern matching against \nI.n0. We illustrate this in the second part of Figure 14. As usual, we de.ne Exp ' a as a .xpoint of \nthe base datatype ExpF and de.ne shorthand constructors lam and app. Using the shorthand constructor \nfunctions, we can de.ne some lambda expressions: k = lam (.x . lam (.y . x)) s = lam (.x . lam (.y . \nlam (.z . app (appx z)(appy z)))) w = lam (.x . appx x) However, there is another way to construct Exp \n' values that is prob\u00adlematic. Using the constructor Inverse0, we can turn values of ar\u00adbitrary type \nt into values of Exp ' t. For example, Inverse0 True :: Exp ' Bool. This value is junk, since it does \nnot coorespond to any lambda term. By design, we wish to hide Inverse0 behind an abstraction boundary. \nWe should never allow the user to construct expressions such as Inverse0 True, except for using them \nas place\u00adholders for intermediate results during computation. We can distinguish pure expressions that \nare inverse-free from expressions that contain inverse values by exploiting parametric\u00adity. The expressions \nthat do not contain inverses have a fully poly\u00admorphic type. For instance, k, s and w are of type (Exp \n' a). The expressions that contain Inverse0 have more speci.c type (e.g., (Inverse0 True) :: (Exp ' Bool)). \nTherefore, we de.ne the type of Exp to be .a.Exp ' a. Then, expressions of type Exp are guar\u00adanteed to \nbe be inverse-free. Using parametricity to sort out junk introduced by the inverse is the key idea of \nWashburn and Weirich [37], and the inverse augmented .xpoint \u00b50 is the key idea of Fe\u00adgaras and Sheard \n[13]. The contribution we make in this work is putting together these ideas in Mender-style setting. \nBy doing so, we are able de.ne recursion combinators over types with nega\u00adtive occurrences, which have \nwell understood termination prop\u00aderties enforced by parametricity. We de.ne 4 such combinators: msfcata0, \nmsfhist0, msfcata1, and msfhist1. The combinator msfcata0 is the simplest, to de.ne it we generalize \nover mcata0 by using the same device we used earlier, we abstract the combining function over an additional \nargument, this time an abstract inverse. The combining function . becomes a function of 3 arguments. \nAn abstract inverse, an recursive placeholder, and a base struc\u00adture. msfcata . (I.n0 x)= . Inverse0 \n(msfcata .) x msfcata . (Inverse0 z)= z For inverse values, return the value inside Inverse0 as it is. \n We use higher-rank polymorphism to insist that the abstract in\u00adverse function, with type (a . ra), \nthe recursive placeholder function, with type (ra . a), and the base structure, with type (f (ra)), only \nwork over an abstract type constructor, denoted by (r).  msfcata0 :: (.r.(a . ra) . (ra . a) . (f (ra) \n. a)) . (.a.\u00b5.0 fa) . a Note, the abstract recursive type r is parameterized by the answer type a because \nthe augmented datatype .xpoint \u00b5.0 is parameterized by the answer type a. Also, note, the second argument \nof msfcata0, the object being operated on, has the higher-rank type (.a.\u00b5.0 fa), insisting the input \nvalue to be inverse-free by enforcing a to be abstract. In Figure 14, using msfcata0, it is easy to de.ne \nshowExp, the string formatting function for Exp, as in Figure 14. The App case is similar to the general \nrecursive implementation. The body of . is almost textually identical to the body of show ' in the general \nrecursive solution, except we use the inverse expression inv (const v) to create an abstract r value \nto pass to the embedded function z. Note, const v plays exactly the same roll as (Varg v) in show ' . \nDoes msfcata0 really guarantee termination? To prove this we need to address the .rst two of the three \npotential problems de\u00adscribed at the beginning of Section 4.2. The .rst problem (embed\u00added functions \nmay be partial) is addressed using logicality analy\u00adsis. The second problem (cyclic use of constructors \nas arguments to embedded functions) is addressed by the same argument we used in Section 3.8. The abstract \ntype of the inverse doesn t allow it to be applied to constructors, they re not abstract enough. Just \nas we couldn t de.ne pm (in Section 3.8) we can t apply z to things like (Lam (.x . x)). In \u00a75 we provide \nan embedding of msfcata, along with several examples (including the HOAS formatting ex\u00adample), into the \nstrongly normalizing language F.. This consti\u00adtutes a proof that msfcata terminates for all inductive \ndatatypes, even those with negative occurrences.  4.3 A graph datatype with cycles and sharing Another \nexample of negative datatype is a graph with cycles and sharing. Due to the space limitation, we only \ngive its implementa\u00adtion in Figure 15. For further details, see Fegaras and Sheard [13].  4.4 Additional \ngeneralization The combinator msfhist0 generalizes mhist0 by adding an abstract inverse to a combinator \nthat already has an abstract unroller. The combining function . becomes a function of 4 arguments: an \nab\u00adstract inverse, an abstract unroll, a recursive placeholder, and a base structure. The rank 1 combinators \nmsfcata1 and msfhist1 generalize the rank 0 combinators msfcata0 and msfhist0 to combinators on types \nwith an index. The pattern of generalization is quite evident in Figures 3, and 4, and the reader is \nencouraged to study those Figures for a complete understanding of the results of this paper. We believe \nmsfcata1 would be useful for writing functions over negative datatypes with type indices. The combinator, \nmsfhist1, like its rank 0 counterpart msfhist0, may not terminate given ill\u00adbehaved . functions that \nextract embedded functions, and then apply them to parts of the tree which contain those functions. Yet, \nthey are nevertheless useful functions.  data Gpr = Np [r ] | R (r . r) | S (r . r) r type Graph p = \n.a.\u00b5.0 (Gp) a node v gs = I.n0 (N vgs) rec f = I.n0 (Rf ) share f g = I.n0 (Sf g) .atG :: Graph a . \n[a ] .atG = msfcata0 . where . inv .at (N vgs)= v : concatMap .at gs . inv .at (Rf )= .at (f (inv [ ])) \n. inv .at (Sf g)= .at (fg) sumG :: Graph Int . Int sumG = msfcata0 . where . inv sumg (N ngs)= n + sum \n(map sumg gs) . inv sumg (Rf )= sumg (f (inv 0)) . inv sumg (Sf g)= sumg (fg) data ExpF x = Appx x | \nLam (x . x) type Exp ' a = \u00b5.0 ExpF Id a type Exp = .a.Exp ' a app :: Exp ' a . Exp ' a . Exp ' a appx \ny = inR (.h . h unId (App (lift h x)(lift h y))) lam :: (Exp ' a . Exp ' a) . Exp ' a lam f = inR (.h \n. h unId (Lam (.x . lift h (f (inL x))))) showExp :: Exp . String showExp e = msfcata . e vars where \n. inv show ' (Appx y)= .vs . \"(\" + show ' x vs + \"\" + show ' y vs + \")\" . inv show ' (Lam z )= .(v : \nvs) . \"(\\\\\" + v + \"->\" + show ' (z (inv (const v))) vs + \")\" Figure 17. HOAS string formatting example \nin F.. x 0  y2 llll lllllll l y y2 1  tion. In the F. encoding, they could be omitted (i.e., case+ \nxfgg0 :: Graph Int simpli.es to xf g). But, we choose to write in terms of case+ to .atG [0, 2, 1, 2] \nmake the de.nitions easier to read. l t sumG 5 In Figure 17, we de.ne both an inductive datatype for \nHOAS  y2 ll lll (Exp), and the string formatting function (showExp), with these 2 zF. encodings, just \nas we did in \u00a74.2. We can de.ne simple expres\u00adsions using the shorthand constructors and print out those \nexpres\u00ad g0 = rec (.x . sions using showExp. For example, share (.z . node 0[z , rec (.y . node 1[y, \nz ])]) (node 2[x ])) Figure 15. A graph datatype with cycles and sharing [13] type \u00b5.0 f ra =(ra) + \n(((ra . a) . f (ra) . a) . a) newtype Id x = Id {unId :: x } msfcata :: (.r.(a . ra) . (ra . a) . f (ra) \n. a) . (.a.\u00b5.0 f Ida) . a msfcata . x = case+ x unId (.f . f (. Id)) lift :: ((Id a . a) . f (Id a) \n. a) . \u00b5.0 f Ida . Id a lift h x = case+ x id (.x . Id (xh)) type a + b = .c.(a . c) . (b . c) . c inL \n:: a . (a + b) inL a = .fg . fa inR :: b . (a + b) inR b = .fg . gb case+ :: (a + b) . (a . c) . (b . \nc) . c case+ xf g = xf g Figure 16. F. encoding of \u00b5.0, msfcata0, and the sum type (+). 5. F. encoding \nof \u00b5.0 and msfcata0 Figure 16 is the F. encoding of the inverse augmented datatype \u00b5.0 and its catamorphism \nmsfcata0. We use the sum type to encode \u00b5.0 since it consists of two constructors, one for the inverse \nand the other for the recursion. The newtype Id wraps answer values inside the inverse. The catamorphism \ncombinator msfcata0 unwraps the result (unIn) when x is an inverse. Otherwise, msfcata0 runs the combining \nfunction . over the recursive structure (.f . f (. Id)). The utility function lift abstracts a common \npattern, useful when we de.ne the shorthand constructors (lam and app). Figure 16 also contains the F. \nencoding of the sum type (+) and its constructors (or injection functions) inL and inR. The case expression \ncase+ for the sum type is just binary function applica\u00ad > putStrLn (showExp (lam (.x . lam (.y . x)))) \n(\\a->(\\b->a)) 6. Limitations While the Mendler style is quite expressive, there are functions we have \nnot been able to express easily. The .rst class are functions that transform their subcomponents before \nmaking a recursive call. For example: length (x : xs) = 1+ length (reverse xs). It is also known that \nthe parallel reduction is not expressible[12]. Neither mcata nor cata can express constant time predecessor \nfunction. Crary and Weirich [9] de.ned an interesting variation of a Mendler style recursion combinator \n(de.ned as a language con\u00adstruct), which allows constant time predecessor function for posi\u00adtive datatypes, \nbut its termination properties for negative datatype has not been studied. 7. Related Work Matthes [21] \nformalized a version of Mendler style calculi in Coq to prove properties on map fusion for nested datatypes. \nOn the conventional side, Hinze [16] tries to unify various morphisms us\u00ading the concept he calls adjoint \nfolds. But, it remains to be seen whether more exotic species of combinators, such as histomor\u00adphisms, \ncan be subsumed by this framework. Since most formal proof systems such as Coq do not support induction \nover negative datatypes, work on HOAS in such systems (e.g. [6]) are often based on Weak HOAS[11, 17] \nto avoid negative occurrences. Despeyroux et al. [12] introduced a primitive recursion for HOAS in a \nmodal .\u00adcalculus, and later tried to extended it to dependent types[10]. 8. Conclusion and Future Work \nWe have described a hierarchy of Mendler style recursion combi\u00adnators, gave examples of their use, and \ndiscussed their termination properties. We summarize our results in the table below. For each combinator \nwe provide evidence of the termination behavior for that combinator over both positive and negative inductive \ntypes, plus pointers to examples that illustrate the use of that combinator.  positive negative example \ncata proof [14] unde.ned len \u00a73.2 mcata0 proof Fig. 6 proof Fig. 6 len Fig. 7 mhist0 proof [36] no .b \nFig. 8 msfcata0 proof \u00a75 proof \u00a75 showExp Fig. 14 msfhist0 argument \u00a73.4 no loopFoo Fig. 13 mcata1 proof \n[2] proof [2] bsum Fig. 9 extev Fig. 11 mhist1 ? no switch2 Fig. 10 msfcata1 similar \u00a75 similar \u00a75 msfhist1 \n? no The proof in Figure 6 for mcata0 is a translation from Abel et al. [2], who also discuss the applicability \nof such proofs to arbitrary ranks. The proof is an embedding of \u00b50 and mcata0 into F.. It is a proof \nof termination provided that F. extended with non-recursive datatypes is normalizing. Section 5 is an \nextension of this proof to msfcata0. Figure 5 illustrates the well known fact that catamorphism is a \nspecial case of histomorphism. Although we do not have a formal argument, it seems quite evident that \nwe can simulate all the stan\u00addard combinators (e.g., mcata0) via its inverse augmented coun\u00adterparts \n(e.g., msfcata0). We pose the open question whether there is a safe way to apply strong induction (or \nhistomorphism) to negative inductive datatypes. We only have preliminary thoughts that there may be a \nway of ramifying [28] the abstract type r in histomorphism combi\u00adnators to prevent embedded functions \nfrom being applied to a larger term. We are also looking for interesting functional programming examples, \nwhich can show practical use of the histomorphism fam\u00adily of combinators for negative inductive datatypes. \nAcknowledgments This work was supported by the NSF grant 0910500. Thanks to Nathan Collins and Jim Hook \nfor discussion and feedback. References [1] A. Abel, R. Matthes, and T. Uustalu. Generalized iteration \nand coiter\u00adation for higher-order nested datatypes. In FoSSaCS, volume 2620 of LNCS, pages 54 69. Springer, \n2003. [2] A. Abel, R. Matthes, and T. Uustalu. Iteration and coiteration schemes for higher-order and \nnested datatypes. Theoretical Computer Science, 333(1-2):3 66, 2005. ISSN 0304-3975. [3] Bird and Meertens. \nNested datatypes. In MPC: 4th International Con\u00adference on Mathematics of Program Construction. LNCS, \nSpringer-Verlag, 1998. [4] R. Bird and R. Paterson. Generalised folds for nested datatypes. Formal Aspects \nof Computing, 11:11 2, 1999. [5] R. S. Bird and O. de Moor. Algebra of Programming. Prentice-Hall, 1997. \n[6] A. Chlipala. Parametric higher-order abstract syntax for mechanized semantics. ICFP 08, pages 143 \n156. ACM, 2008. [7] A. Church. A formulation of the simple theory of types. Journal of Symbolic Logic, \n5(1):56 68, 1940. [8] R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F. Cremer, R. \nW. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. F. Smith. Implementing \nmathe\u00admatics with the Nuprl proof development system. Prentice-Hall, Inc., Upper Saddle River, NJ, USA, \n1986. ISBN 0-13-451832-2. [9] K. Crary and S. Weirich. Flexible type analysis. In ICFP, pages 233 248, \n1999. [10] J. Despeyroux and P. Leleu. Primitive recursion for higher-order abstract syntax with dependant \ntypes. In Informal proceedings of the FLoC 99 IMLA, June 1999. [11] J. Despeyroux, A. P. Felty, and A. \nHirschowitz. Higher-order abstract syntax in coq. In Proceedings of the Second International Conference \non Typed Lambda Calculi and Applications, pages 124 138, London, UK, 1995. Springer-Verlag. [12] J. Despeyroux, \nF. Pfenning, and C. Sch\u00a8urmann. Primitive recursion for higher-order abstract syntax. In P. de Groote, \neditor, TLCA, volume 1210 of LNCS, pages 147 163. Springer, 1997. ISBN 3-540-62688-3. [13] L. Fegaras \nand T. Sheard. Revisiting catamorphisms over datatypes with embedded functions (or, programs from outer \nspace). POPL 96, pages 284 294. ACM, 1996. [14] T. Hagino. A Categorical Programming Language. PhD thesis, \nUniversity of Edinburgh, 1987. [15] R. Hinze. Ef.cient generalized folds. In J. Jeuring, editor, Proc. \nof 2nd Workshop on Generic Programming. July 2000. [16] R. Hinze. Adjoint folds and unfolds. In C. Bolduc, \nJ. Desharnais, and B. Ktari, editors, Mathematics of Program Construction, volume 6120 of LNCS, pages \n195 228. Springer Berlin / Heidelberg, 2010. [17] Honsell, Miculan, and Scagnetto. An axiomatic approach \nto metarea\u00adsoning on nominal algebras in HOAS. In ICALP: Annual International Colloquium on Automata, \nLanguages and Programming, 2001. [18] C. E. Martin, J. Gibbons, and I. Bayley. Disciplined, ef.cient, \ngen\u00aderalised folds for nested datatypes. Formal Aspects of Computing, 16 (1):19 35, 2004. [19] R. Matthes. \nExtensions of System F by Iteration and Primitive Recur\u00adsion on Monotone Inductive Types. PhD thesis, \nLudwig-Maximilians Universit\u00a8at, May 1998. [20] R. Matthes. An induction principle for nested datatypes \nin intensional type theory. Journal of Functional Programming, 19(3-4):439 468, June 2009. [21] R. Matthes. \nMap fusion for nested datatypes in intensional type theory. Sci. Comput. Program., 76:204 224, March \n2011. [22] E. Meijer and G. Hutton. Bananas in space: extending fold and unfold to exponential types. \nFPCA 95, pages 324 333. ACM, 1995. [23] N. P. Mendler. Recursive types and type constraints in second-order \nlambda calculus. In LICS, pages 30 36. IEEE Computer Society, 1987. [24] N. P. Mendler. Inductive types \nand type constraints in the second-order lambda calculus. Ann. Pure Appl. Logic, 51(1-2):159 172, 1991. \n[25] R. Paterson. Control structures from types. Unpublished draft, 1993. [26] C. Paulin-Mohring. Inductive \nde.nitions in the system Coq -rules and properties. In M. Bezem and J. F. Groote, editors, TLCA, volume \n664 of LNCS, pages 328 345. Springer, 1993. [27] F. Pfenning and C. Elliot. Higher-order abstract syntax. \nPLDI 88, pages 199 208. ACM, 1988. [28] B. Russell. Mathematical logic as based on the theory of types. \nAmerican Journal of Mathematics, 30:222 262, 1908. [29] C.-C. Shan. A static simulation of dynamic delimited \ncontrol. Higher Order Symbol. Comput., 20:371 401, December 2007. [30] T. Sheard. Putting curry-howard \nto work. In Proceedings of the 2005 ACM SIGPLAN workshop on Haskell, pages 74 85. ACM, 2005. [31] The \nGHC Team. The Glorious Glasgow Haskell Compilation System User s Guide, Version 7.0.1, 2010. [32] T. \nUustalu. Natural Deduction for Intuitionistic Least and Greatest Fixedpoint Logics, with an Application \nto Program Construction. PhD thesis, Dept. of Teleinformatics, Royal Inst. of Technology, Stock\u00adholm, \nMay 1998. [33] T. Uustalu and V. Vene. Mendler-style inductive types, categorically. Nordic Journal of \nComputing, 6(3):343 361, 1999. [34] T. Uustalu and V. Vene. Primitive (co)recursion and course-of-value \n(co)iteration, categorically. Informatica, Lith. Acad. Sci, 10(1):5 26, 1999. [35] T. Uustalu and V. \nVene. Coding recursion a la Mendler (extended `abstract). In J. Jeuring, editor, Proc. of 2nd Workshop \non Generic Programming, pages 69 85. 2000. [36] V. Vene. Categorical Programming with Inductive and Coinductive \nTypes. PhD thesis, Dept. of Computer Science, Univ. of Tartu, 2000. [37] G. Washburn and S. Weirich. \nBoxes go bananas: encoding higher\u00adorder abstract syntax with parametric polymorphism. ICFP 03, pages \n249 262. ACM, 2003.   \n\t\t\t", "proc_id": "2034773", "abstract": "<p>The Mendler style catamorphism (which corresponds to weak induction) always terminates even for negative inductive datatypes. The Mendler style histomorphism (which corresponds to strong induction) is known to terminate for positive inductive datatypes. To our knowledge, the literature is silent on its termination properties for negative datatypes. In this paper, we prove that histomorphisms do not always termintate by showing a counter-example. We also enrich the Mendler collection of recursion combinators by defining a new form of Mendler style catamorphism (<i>msfcata</i>), which terminates for all inductive datatypes, that is more expressive than the original. We organize the collection of combinators by placing them into a hierarchy of ever increasing generality, and describing the termination properties of each point on the hierarchy. We also provide many examples (including a case study on a negative inductive datatype), which illustrate both the expressive power and beauty of the Mendler style. One lesson we learn from this work is that weak induction applies to negative inductive datatypes but strong induction is problematic. We provide a proof of weak induction by exhibiting an embedding of our new combinator into <i>F<sub>&#969;</sub></i>. We pose the open question: Is there a safe way to apply strong induction to negative inductive datatypes?</p>", "authors": [{"name": "Ki Yung Ahn", "author_profile_id": "81435597635", "affiliation": "Portland State University, Portland, OR, USA", "person_id": "P2801412", "email_address": "kya@cs.pdx.edu", "orcid_id": ""}, {"name": "Tim Sheard", "author_profile_id": "81331504269", "affiliation": "Portland State University, Portland, OR, USA", "person_id": "P2801413", "email_address": "sheard@cs.pdx.edu", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034807", "year": "2011", "article_id": "2034807", "conference": "ICFP", "title": "A hierarchy of mendler style recursion combinators: taming inductive datatypes with negative occurrences", "url": "http://dl.acm.org/citation.cfm?id=2034807"}