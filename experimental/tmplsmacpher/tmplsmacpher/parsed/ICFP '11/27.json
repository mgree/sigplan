{"article_publication_date": "09-19-2011", "fulltext": "\n Forest: A Language and Toolkit for Programming with Filestores Kathleen Fisher Nate Foster David Walker \nKenny Q. Zhu Tufts University Cornell University Princeton University Shanghai Jiao Tong University Abstract \nA .lestore is a structured collection of data .les housed in a conven\u00adtional hierarchical .le system. \nMany applications use .lestores as a poor-man s database, and the correct execution of these applica\u00adtions \nrequires that the collection of .les, directories, and symbolic links stored on disk satisfy a variety \nof precise invariants. More\u00adover, all of these structures must have acceptable ownership, per\u00admission, \nand timestamp attributes. Unfortunately, current program\u00adming languages do not provide support for documenting \nassump\u00adtions about .lestores, detecting errors in them, or safely loading from and storing to them. This \npaper describes the design, implementation, and semantics of Forest, a new domain-speci.c language for \ndescribing .lestores. The language uses a type-based metaphor to specify the expected structure, attributes, \nand invariants of .lestores. Forest generates loading and storing functions that make it easy to connect \ndata on disk to an isomorphic representation in memory that can be manipulated as if it were any other \ndata structure. Forest also generates metadata that describes the degree to which the structures on the \ndisk conform to the speci.cation, making error detection easy. In a nutshell, Forest extends the rigorous \ndiscipline of typed programming languages to the untyped world of .le systems. We have implemented Forest \nas an embedded domain-speci.c language in Haskell. In addition to generating infrastructure for reading, \nwriting and checking .le systems, our implementation generates type class instances that make it easy \nto build generic tools that operate over arbitrary .lestores. We illustrate the utility of this infrastructure \nby building a .le system visualizer, a .le access checker, a generic query interface, description-directed \nvariants of several standard UNIX shell tools and (circularly) a simple Forest description inference \nengine. Finally, we formalize a core fragment of Forest in a semantics inspired by classical tree logics \nand prove round-tripping laws showing that the loading and storing functions behave sensibly. Categories \nand Subject Descriptors D.3.2 [Programming Lan\u00adguages]: Language Classi.cations Specialized application \nlan\u00adguages General Terms Languages, Design, Theory Keywords Data description languages, .le systems, \n.lestores, domain-speci.c languages, ad hoc data, Haskell, bidirectional transformations, generic programming \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n11, September 19 21, 2011, Tokyo, Japan. Copyright c &#38;#169; 2011 ACM 978-1-4503-0865-6/11/09. . . \n$10.00 1. Introduction Databases are an effective, time-tested technology for storing struc\u00adtured and \nsemi-structured data. Nevertheless, many computer users eschew the bene.ts of structured databases and \nstore important semi-structured information in collections of .les and directories in a conventional \n.le system instead. For example, the Princeton Computer Science Department stores records of undergraduate \nstu\u00addent grades in a structured set of directories and uses scripts to com\u00adpute averages and study grading \ntrends. Similarly, Michael Freed\u00adman collects sets of log .les from CoralCDN, a distributed content distribution \nnetwork [11, 12]. The logs are organized in hierarchical directory structures based on machine name, \ntime and date. Freed\u00adman mines the logs for information on system security and perfor\u00admance. At Harvard, \nphysics professor Vinothan Manoharan stores his experimental data in sets of .les and extracts information \nusing python scripts. At AT&#38;T, vast structured repositories contain net\u00adwork monitoring information, \nphone call records, and billing data. Many software code bases, including Haskell and its associated \nCa\u00adbal libraries, require that speci.c .les exist in particular formats at precise locations described \nin other .les. Similarly, version control systems like cvs utilize the .le system to store revision informa\u00adtion. \nWeb sites require various types of .les to exist in particular directories according to content type, \nand security considerations often require particular permissions on these .les. Many other ex\u00adamples \nexist across the computational sciences and social sciences, in computer systems research, in computer \nsystems administration and in industry. Users choose to implement ad hoc databases in this manner for \na number of reasons. A key factor is that using databases often requires paying substantial up-front \ncosts such as: (1) .nding and evaluating the appropriate database software (and possibly paying for it); \n(2) learning how to load data into the database; (3) writing programs to transform the raw data for loading \ninto the database; (4) learning how to access the data once it is in the database; and (5) interfacing \nthe database with a conventional programming language to support applications that use the data. Finally, \nit may be the case that the database optimizes for a pattern of use not suited to the actual application, \nwhich makes the overhead of the database system even less desirable. Rather than paying these costs, \nprogrammers often store data in the .le system, using a combination of directory structure, .le names, \n.le contents, and symbolic links to organize the data. We call such a data representation a .lestore. \nThe query language for a .lestore is often a shell script or conventional programming language. Unfortunately, \ndespite their initial convenience, using .lestores can have a number of negative consequences. First, \nthere is gener\u00adally no documentation, which means it can be hard to understand the data and its organization. \nNew users struggle to learn the struc\u00adture, and if the system administrator leaves, knowledge of the \ndata organization may be lost. Second, the structure of the .lestore tends to evolve: new elements are \nadded and old formats are changed, sometimes accidentally. Such evolution can cause hacked-up data processing \ntools to break or return erroneous results; it also further complicates understanding the data. Third, \nthere is often no sys\u00adtematic means for detecting errors even though data errors can be immensely important. \nFor example, for .lestores containing moni\u00adtoring information, errors can signal that some portion of \nthe mon\u00aditored system is broken. Fourth, analyses tend to be built from scratch. There is no auxiliary \nquery or tool support and no help with debugging. Tools tend to be one-off efforts that are not reuseable. \nFifth, dealing with large data sets, which are common in this set\u00adting, imposes extra dif.culties. For \nexample, standard shell tools such as ls fail when more than 256 .les appear on the command line. Hence, \nprogrammers must break up their data and process it in smaller sets, a tedious task. We propose a better \nway: A type-based speci.cation language, programming environment and toolkit for describing and manag\u00ading \n.lestores. This language, called Forest, is implemented as an embedded domain-speci.c language in Haskell. \nForest allows pro\u00adgrammers to describe the expected shape of a .lestore and to ma\u00adterialize it as typed, \nformat-speci.c Haskell data structures. Con\u00adversely, given data structures with the appropriate type, \nForest makes it straightforward to dematerialize these structures and write them out to disk. The .rst \nbene.t of the Forest system is that Forest descrip\u00adtions provide executable documentation that can be \nused to check whether a given .lestore conforms to its speci.cation. For exam\u00adple, Unix .le systems should \nbe laid out according to the informal standard set forth by the Filesystem Hierarchy Standard Group [3], \nwhich requires, among other things, that certain directories only contain certain .les, presumably for \nsecurity reasons. Forest pro\u00advides a language for expressing standards precisely and for check\u00ading that \ngiven .le systems conform to them. As another example, the Pads website [25] contains a complex set of \nscripts and data .les to implement an online demo. Unless all of the required data .les, directories, \nand symbolic links are con.gured correctly, the web demo fails with an inscrutable error message. Forest \nallows the Pads webmaster to precisely document all of these requirements and to detect speci.cation \nviolations, making it easy to .nd and re\u00adpair errors. And, of course, if the current webmaster were to \nleave her post, her successor could use the Forest description to help un\u00adderstand the system. As well \nas serving as executable documentation, Forest pro\u00advides substantial additional support for programmers. \nThe goal is for programmers to obtain a whole range bene.ts by writing one simple, compact .le system \nspeci.cation. The automatically gen\u00aderated auxiliary support includes: (1) a set of type declarations \nto represent the .lestore in memory; (2) a set of type declarations that capture errors and .le system \nattributes for the .lestore; (3) a load\u00ading function to populate these in-memory structures; (4) a storing \nfunction to push possibly updated structures back out to disk; (5) type class instance declarations that \nmake it possible for program\u00admers to query, analyze, and transform .lestore data using generic functions; \nand (6) a set of useful generic functions/scripts that op\u00aderate over instances of these type classes. \nThe main contribution of this work is conceptual: We propose the idea of extending a modern programming \nlanguage with tightly integrated linguistic features for describing and manipulating .le\u00adstores. To demonstrate \nthe potential of this idea, the following sec\u00adtions .esh out our proposal in greater depth: Section 2 \nbegins with two concrete motivating examples, drawn from the authors day-to-day experience managing computer \nsystems. While there are just two central examples in this paper, the Forest web site [9] contains a \nnumber of further examples and case studies. Section 3 describes a concrete language design. The design \nis characterized by a simple, intuitive and compositional syntax that is tightly integrated with Haskell, \nour host language. The design is also tightly integrated with Pads/Haskell, a domain\u00adspeci.c language \nfor describing individual .les (as opposed to entire .lestores), inspired by past work on related data \ndescrip\u00adtion languages [5, 6, 7, 22]. This tight integration was a crucial design goal as it allows programmers \nto transition seamlessly between ordinary Haskell data structures, .le internals and .le collections, \nall in a uniform syntax.  Section 4 explains how to write Haskell programs that operate over .lestores \ndescribed in Forest. The goal of this section is to provide a sense of how easy it is to write simple \n.lestore scripts or queries.  Section 5 shows that it is possible to use Forest to make the management \nof .lestores even easier by developing generic tools capable of operating over any .lestore. We have \ndeveloped several such tools including a generic query interface, a .le sys\u00adtem visualization tool, an \naccess-control permission checker, and a series of UNIX-like scripting tools. We have also built a simple \ndescription-inference tool to help users write a new description for an existing .le system. These tools \nare interest\u00ading in their own right and also as case studies of putting generic programming techniques \ninto practice. In addition, they pro\u00advide evidence that our design is effectively integrated into the \nHaskell ecosystem.  Section 6 explains our implementation, which is complete and may be downloaded at \nthe Forest web site [9]. In addition to delivering a useful tool, our engineering work has the auxiliary \nbene.t of serving as a case study in domain-speci.c language implementation. In fact, it has already \nhad signi.cant impact as such: the Haskell team modi.ed and extended Haskell s quasiquoting mechanism \nin response to our needs.  Section 7 describes the formal semantics for core Forest and states theorems \ndemonstrating that the mappings between the .lestore and in-memory structures behave correctly. These \ntheorems are inspired by the round-tripping laws for well\u00adbehaved lenses [10], but are signi.cantly more \ncomplicated as the load and store functions have to deal with inconsistencies stemming from dependencies, \nduplication, and invalid data.  Section 8 contains a discussion of related work. There has been much \npast work on domain-speci.c languages for describing, parsing and printing individual data .les. Examples \ninclude Lex, Yacc, Antlr [26], Parsec [19] and Pads [7], to name just a few. However, Forest differs \nsubstantially from any of these systems because it focuses on technology for describing entire .lestores. \nA key difference is that simple .lestores are trees and complex ones with symbolic links are graphs, \nwhereas .les are sequences (of characters or tokens). Consequently, the language design, formal systems, \nsemantic issues, and underlying imple\u00admentation technology are all entirely different.  2. Example \nFilestores In this section, we present two example .lestores. We use these examples to motivate and explain \nthe design of Forest. The .rst .lestore contains information about students in Prince\u00adton s undergraduate \ncomputer science program. The faculty use the information to decide on undergraduate awards and to track \ngrading trends. Its format has changed over time something that is typical for ad hoc .lestores. Naturally, \nany description needs to cope with the variations introduced as formats evolve. Figure 1 shows a snippet \nof the (anonymized) student .le\u00ad store designed to illustrate its structure. At the top level, there \nare Figure 1. Anonymized snippet of Princeton computer science un\u00addergraduate data. A shaded node denotes \ndenotes an error; in this case, missing .les.  three directories: classof11 (seniors), classof12 (juniors) \nand graduates (students who have graduated). There is also a README .le containing a collection of notes. \nInside graduates, there is set of directories named classofYY where YY dates back to 92. Inside each \nclassofYY directory, there are at least the two degree subdirectories ABYY and BSEYY as the computer \nscience department gives out both Arts and Science (AB) and Engineering (BSE) degrees. Optionally, there \nare also subdirectories for students who withdrew from Princeton or transferred to another program. Within \nany degree subdirectory, there is one text .le per student that records the courses taken and the corresponding \ngrades. Each degree directory may also contain a template .le named sss.txt or sxx.txt for creating new \nstudents. The second .lestore contains log .les for CoralCDN [11, 12]. To monitor the performance and \nsecurity of the system, the hosts participating in CoralCDN periodically send usage statistics back to \na central server. These statistics are collected in a .lestore sim\u00adilar to the one depicted in Figure \n2. The .lestore has a top-level directory named dat, which contains a set of subdirectories, one for \neach host. Each of those directories contain another set of direc\u00adtories, labeled by date and time. Finally, \neach of the date/time direc\u00adtories contain one or more compressed log .les. For the purposes of this \nexample, we will focus on the coralwebsrv.log.gz log .le, which contains detailed information about the \nweb requests made on the host during the preceding time period. In addition to exploring this primary \n.lestore, we also explore a secondary, de\u00adrived .lestore. This secondary store, named stats, contains \n.les that store statistics generated by Forest/Haskell scripts that analyze and summarize the raw CoralCDN \nserver data. These system-wide summaries are representative of the statistics reported by Freedman in \nhis CoralCDN report [11].  Figure 2. Coral system log data. 3. Forest Design Data stored in .lestores \nshares many characteristics of data stored in ordinary, in-memory data structures. Consequently, Forest \nuses the same sort of language to describe .lestores as one uses to de\u00adscribe ordinary data structures \n the language of types. Simple base types describe individual .le system objects1 and more com\u00adplex types \ndescribe organized collections of .le system objects. This idea forms the basis for our design. Embedding \nForest in Haskell. In order to write lightweight scripts, programmers must be able to manipulate and \ntransform .le system objects side-by-side with ordinary data structures. Con\u00adsequently, a language like \nForest must be embedded within a more general host programming language. We chose Haskell as the host \nlanguage primarily because of its rich support for type-directed programming, which facilitates the construction \nof generic tools that can operate over any Forest description. As a bonus, Haskell s quasiquoting mechanism \n[21] proved a useful way to implement Forest. It enabled tight integration of the two languages while \nad\u00admitting .ne-grained control over Forest syntax. To introduce new Forest declarations within a Haskell \npro\u00adgram, the programmer simply opens the Forest sublanguage using quasiquoting notation: [forest| ... \nforest declarations ... |] When processing such a quasiquote, the Haskell compiler invokes the Forest \ncompiler, which converts the given Forest declarations into a sequence of plain Haskell declarations \nthat collectively im\u00adplement the Forest declarations. Forest Structure and Interpretations. Once within \nthe Forest sublanguage, the programmer writes declarations that resemble extended Haskell type declarations. \nEach such type declaration has three primary semantic interpretations: 1. An interpretation as an expected \non-disk shape of a .le system fragment. 2. An interpretation as an ordinary Haskell type for the in-memory \nrepresentation that will be constructed when the .le system fragment is loaded into a Haskell program. \n 3. An interpretation as an ordinary Haskell type for the in-memory metadata that will be generated when \nthe .le system fragment is loaded.  All three interpretations are used by the tool that loads data \nfrom the .lestore into memory as speci.ed by a Forest description. When 1 We use the term .le system \nobject or more simply object to denote either a .le, a directory, or a symbolic link. supplied with \na current path, the loader uses the .rst interpretation to validate that the .lestore rooted at that \npath has the correct shape. If the expected shape is complicated, possibly involving several nested subshapes \n(and hence traversal through several subdirecto\u00adries), the semantics of Forest dictates how the loader \nshould adjust the current path as it goes. When validation (also called matching) succeeds, we say the \n.lestore fragment matches the description. The second interpretation is used when the loader lazily pulls \nthe on-disk data into memory. The in-memory data structure is guar\u00adanteed to have the Haskell type given \nby the second interpretation. The third interpretation provides a type for the metadata structure generated \nby the loader. Such metadata includes error information (missing .le, insuf.cient permissions, etc.) \nas well as .le system attributes (owner, size, etc.). The effectiveness of the Forest language comes \nin part from the fact that these three interpretations all arise from a single com\u00adpact description. \nMoreover, to aid the programmer in navigating between interpretations, we align the syntax of Forest \nwith the syn\u00adtax of Haskell where possible. For example, if the Haskell types for the in-memory representation \nand metadata are record types, then the Forest syntax is designed to look similar to a Haskell record \ntype. Likewise, if the Haskell types for the in-memory representa\u00adtion and metadata are Maybe types then \nthe Forest syntax is de\u00adsigned to look similar to a Haskell Maybe type. Many of these high-level design \nconsiderations were adopted from earlier work on Pads [5, 7, 22], although the semantics of Forest (which \noper\u00ad ates over graph-based .lestores) is substantially different from the semantics of Pads (which operates \nover sequence-based strings). Errors. As with Pads [5, 7, 22], we do not assume that a given .lestore \nconforms perfectly to its associated Forest description. Instead, when loading data, we check that a \n.lestore conforms and mark discrepencies in the metadata. This design allows users to respond in application-speci.c \nways to errors. It also allows Forest to check the arbitrarily complex conditions that may be speci.ed \nby Forest s dependent types.2 Because Forest loads data lazily, this choice means errors will not be \ndetected unless the user program needs to touch the portion of the .lestore with the error. The user \ncan force a complete conformance check by accessing the top\u00adlevel error count. It is possible for the \n.lestore to change during or after this check. For the .lestores we have seen in practice, there are \nextra-linguistic procedures in place to prevent such concurrent modi.cations; we leave to future work \nthe possibility of using operating system support to monitor and/or prevent such changes automatically. \nOnward. In the remainder of this section, we discuss the speci.c type constructors that constitute the \nForest language and illustrate their use in our running examples. 3.1 Base Types: Files Forest provides \na small collection of base types for describing indi\u00advidual .les: TextFile for ASCII .les, BinaryFile \nfor binary .les, and AnyFile for arbitrary .les. As with all Forest types, each of these types speci.es \na representation type, a metadata type, and loading and storing functions. For all three .le types, the \nrepre\u00adsentation type is a ByteString. Similarly all three share a meta\u00addata type, which pairs .le-system \nmetadata with metadata describ\u00ading properties of the .le contents. The .le-system metadata has 2 Validation \nthat a .lestore obeys a Forest speci.cation is akin to type checking. However, it is akin to type checking \nclosed, zero-order values (trees and graphs) as opposed to type checking parameterized, higher-order \nvalues (functions). Consequently, even though Forest has dependent types, type checking is not algorithmically \nchallenging. For example, Forest does not have to decide equivalence of expressions with free variables \nas one must do when type checking a dependent lambda calculus. data Forest_md = Forest_md { numErrors \n:: Int , errorMsg :: Maybe ErrMsg , fileInfo :: FileInfo } data FileInfo = FileInfo { fullpath :: FilePath \n, owner :: String , group :: String , size :: COff , access_time :: EpochTime , mod_time :: EpochTime \n, read_time :: EpochTime , mode :: FileMode , isSymLink :: Bool , kind :: FileType } Figure 3. Forest \nmetadata types. type Forest_md, shown in Figure 3. This structure stores two kinds of information: 1. \nthe number and kind of any errors that occurred during loading 2. the attributes associated with the \n.le (fileInfo)  File-content metadata describes errors within the .le. For these three .le types, there \nis no meaningful content metadata and so this type is the unit type. Leveraging Haskell s laziness, the \nloading functions create the in-memory representations and set the meta\u00addata on demand. The storing functions, \nwhich are described in more detail in Section 4, do the inverse. Although useful, these three base types \nare not suf.cient for de\u00adscribing the wide range of .les used in practice, including XML documents, Make.les, \nsource .les in various languages, shell scripts, etc. The appropriate representation and content metadata \ntypes for each such .le varies. To support such .les, Forest pro\u00advides a plug-in architecture, allowing \nthird-party users to de.ne new .le types by specifying a representation type, a metadata type, and corresponding \nloading and storing functions. A common class of .les are ad hoc data .les containing semi-structured \ninformation, an example of which is the Prince\u00adton student record .le format. In such cases, Forest can \nleverage the Pads/Haskell [8] data description language to de.ne format\u00ad speci.c in-memory representations, \ncontent metadata, and loading and storing functions. Pads/Haskell is a recently developed version of \nPads [5, 7, 22]. Like Forest, Pads/Haskell is embedded in Haskell using quasiquotation. For example, \nthe following code snippet be\u00adgins the Pads speci.cation of the Princeton student record format: [pads| \ndata Student(name::String) = Student { person :: Line (Person name) , Header , courses :: [Line Course] \n, Trailer } ... |] This description is parameterized by the name of the student whose data is in the \n.le; the complete description appears in the compan\u00adion technical report [4]. From this speci.cation, \nthe Pads compiler generates an in-memory representation type Student, a content metadata type Student_md, \nand parsing and printing functions. Forest provides the File type constructor to lift Pads types to Forest \n.le types. For example, the declaration [forest| type SFile(n::String) = File(Student n) |] introduces \na new .le type named SFile whose format is given by the Pads type Student. As with the Pads type, SFile \nis parameterized by the name of the student. Using Pads/Haskell descriptions in Forest not only helps \nspec\u00adify the structure of ad hoc data .les, but it also generates a struc\u00adtured in-memory representation \nof the data, allowing Haskell pro\u00adgrammers to traverse, query and otherwise manipulate such data. We \ndesigned Pads/Haskell and Forest to work seamlessly together. From the perspective of the Haskell programmer \ntraversing a re\u00adsulting in-memory data structure, there is effectively no difference between iterating \nover .les in a directory or structured sequences of lines or tokens within a .le. While Pads/Haskell \nis independently interesting, this paper fo\u00adcuses on Forest. Henceforth, any unadorned declarations occur \nwithin the Forest scope [forest|...|] unless otherwise noted. Any declarations pre.xed by > are ordinary \nHaskell declarations.  3.2 Base Type: Symbolic Links When symbolic links occur in a described .lestore, \nForest follows the symbolic link to its target, mimicking standard shell behavior. However, Forest allows \nprogrammers to specify explicitly that a particular .le is a symbolic link using the base type SymLink. \nThe in-memory representation for an explicit symbolic link is the path that is the target of the link. \nIt is possible to use constraints (Section 3.6) to specify desired properties of the link target, such \nas requiring it to be to a speci.c .le. In Forest, any .le system object may be described in multiple \nways. Hence, in the case of a symbolic link, it is possible to use one declaration to specify that the \nobject is a symbolic link and a second to specify the type of the link target. We will see an example \nof such a speci.cation in Section 3.4 3.3 Maybe: Optional File System Objects Sometimes, a given .le \n(or directory or symbolic link) may or may not be present in the .le system, and either case is valid. \nTo handle this situation, we leverage the idea of an option type by providing a Forest-level Maybe type \nconstructor that maps the optional .le system object to a Maybe type in Haskell. In particular, if T \nis a Forest type, then Maybe T is the Forest type denoting an optional T. The type Maybe T succeeds and \nreturns representation None when the current path does not exist in the .le system. Maybe T also succeeds \nand returns Just v for some v of type T when the current path exists and matches T. Maybe T registers \nan error in the metadata when the current path exists but the corresponding object does not match T. \n 3.4 Records: Directories Forest directories are record-like datatype constructors that allow users \nto specify directory structures. For example, to specify the root directory of the student repository \nin Figure 1, we might use the following declaration. This declaration assumes that we have already de.ned \nClass y, a parameterized description that speci.es the structure of a directory holding data for the \nclass of year y, and Grads, a description that speci.es the structure of the directory holding all graduated \nclasses. type PrincetonCS_1 = Directory { notes is \"README\" :: TextFile , seniors is \"classof11\" :: Class \n11 , juniors is \"classof12\" :: Class 12 , grads is \"graduates\" :: Grads } Each .eld of the record describes \na single .le system object. It has three components: (1) an internal name (e.g., notes or seniors) that \nmust be a valid Haskell record label, (2) an exter\u00adnal name speci.ed as a value of type String (e.g., \n\"README\" or \"classof11\") that gives the name of the object on disk, and (3) a Forest description of the \nobject (e.g., TextFile or Class 11). When the external name is itself a valid Haskell label, users may \nomit it, in which case Forest uses the label as the on-disk name: type PrincetonCS_2 = Directory { notes \nis \"README\" :: TextFile , classof11 :: Class 11 , classof12 :: Class 12 , graduates :: Grads } We could \nnot abbreviate the notes .eld because labels must start with a lowercase letter in Haskell. Matching. \nFor a .le system object to match a directory descrip\u00adtion, the object must be a directory and each .eld \nof the record must match. A .eld f matches when the object whose path is the con\u00adcatenation of the current \npath and the external name of f matches the type of f. It is possible for the same .le system object \nto match multiple .elds in a directory description at the same time. For example, if \"README\" were actually \na symbolic link, it is possible to docu\u00adment that fact by mentioning it twice in the directory description, \nonce as a text .le and once as a symbolic link: type PrincetonCS_3 = Directory { link is \"README\" :: \nSymLink , notes is \"README\" :: TextFile , ... } It is also possible for a directory to contain objects \nthat are unmatched by a description. We allow extra items because it is common for directories to contain \nobjects that users do not care about. For example, a directory structure may contain extra .les or directories \nrelated to a version control system, and a description writer may not want to clutter the Forest speci.cation \nwith that information. We will see shortly that it is possible to specify the absence of .le system objects \nusing constraints. As suggested by the syntax, the in-memory representation of a directory is a Haskell \nrecord with the corresponding labels. The type of each .eld is the representation type of the Forest \ntype for the .eld. The metadata has a similar structure. The metadata for each .eld has two components: \n.le-system attribute information of type Forest_md and .eld-speci.c metadata whose type is derived from \nthe Forest type for the .eld. In addition, the direc\u00adtory metadata contains an additional value of type \nForest_md that summarizes the errors occurring in directory components and stores the FileInfo structure \nfor the directory itself. When load\u00ading a directory, Forest constructs the appropriate in-memory rep\u00adresentation \nfor each .eld that matches and puts the corresponding metadata in the metadata structure. For .elds that \ndo not match, Forest constructs default values and marks the metadata with suit\u00adable error information. \nComputed Paths The above descriptions are a good start for our application, but they are not ideal. Every \nyear, the directory for graduating seniors (i.e., classof11) is moved into the graduates directory, the \njuniors are promoted to seniors and a new junior class is created. As it stands, we would have to edit \nthe description every year. An alternative is to parameterize the description with the current year and \nto construct the appropriate .le names using Haskell functions: > toStrN i n = (replicate(n -length(show \ni)) 0 ) > ++ (show i) > mkClass y = \"classof\" ++ (toStrN y 2) type PrincetonCS (y::Integer) = Directory \n{ notes is \"README\" :: TextFile , seniors is <|mkClass y |> :: Class y , juniors is <|mkclass (y+1)|> \n:: Class <|y+1|> , graduates :: Grads } The bracket syntax <|...|> provides an escape so that we may \nuse Haskell within Forest code to specify arbitrary computations. When an expression is a constant or \nvariable, it may be supplied directly. When an argument is more complex, however, it must be written \nin brackets to escape to Haskell. This example also illus\u00adtrates abstraction: any Forest declaration \nmay be parameterized by specifying a legal Haskell pattern and its type. The types of the .elds for seniors \nand juniors illustrate the use of parameter\u00adized descriptions. Approximate Paths As .lestores evolve, \nnaming conventions may change. Additionally, directory structures with multiple in\u00adstances may have minor \nvariations in the names of individual .les across instances. For example, in each Princeton class directory, \nthere may (or may not) be some number of students that have with\u00addrawn from the program, transferred \nto a different program, or gone on leave. Over the years, slightly different directory names have been \nused to represent these situations. To accommodate this variation, Forest includes the matching construct \nto approximate .le names. We can use this mechanism to describe the class directory: > transRE = RE \"TRANSFER|Transfer\" \n> leaveRE = RE \"LEAVE|Leave\" > wdRE = RE \"WITHDRAWN|WITHDRAWAL|Withdrawn\" type Class (y::Integer) = \nDirectory { bse is <|\"BSE\" ++ (toString y)|> :: Major , ab is <|\"AB\" ++ (toString y)|> :: Major , trans \nmatches transRE :: Maybe Major , withd matches wdRE :: Maybe Major , leave matches leaveRE :: Maybe Major \n} A .eld with the form <label> matches <regexp> :: T .nds the set of paths in the .les system that match \ncurrentPath/ <regexp>. If there are zero or one such .les, the matches form acts just as the is form. \nIf more than one .le matches, one of the matches is selected non-deterministically, a multiple match \nerror is registered in the metadata, and matching continues as it would with the is form. In addition \nto regular expressions, the matching construct also allows glob patterns,(i.e., patterns such as *.txt), \nto specify the names of .les on disk. An example appears in the next subsection.  3.5 Lists Just as \nHaskell has both records and lists, so too does Forest. Records allow programmers to specify a .xed number \nof .le sys\u00adtem objects, each with its own type. Lists, on the other hand, allow programmers to specify \nan arbitrary number of .le system objects, each with the same type. As an example, we can use a list \nto specify the Grads directory from Figure 1. We borrow Haskell s notation for list comprehensions to \nspecify the names of the .le system ob\u00adjects: > getYear s = > toInteger $ reverse $ take 2 $ reverse \ns > cRE = RE \"classof[0-9][0-9]\" type Grads = [c :: Class <|getYear c|> | c <-matches cRE] In this speci.cation, \nGrads is a directory fragment containing a number of Class subdirectories with names c that match the \nregular expression cRE. The Haskell function getYear extracts the last two digits from the name of the \ndirectory, converts the string digits to an integer year, and passes the year to the underlying Class \nspeci.cation. More generally, Forest lists have the form [path :: T | id <-gen, pred] where id is bound \nin turn to each of the .le names generated by gen, which may be a matches clause (used to match against \nthe .les at the current path as in the previous section) or a list computed in Haskell. These generated \nids are .ltered by the optional predicate pred. For each such legal id, there is a corresponding expression \npath, which Forest interprets as extending the current path. The object at each such path should have \nthe Forest type T. The identi.er id is in scope in pred, path, and T. The in-memory representation of \na Forest list is a Haskell list containing pairs of the name of a matching object and its represen\u00adtation. \nThe metadata is a list of the metadata of the matching objects paired with a summary metadata structure \nof type Forest_md. Representation Transformations. Although the list representa\u00adtion for comprehensions \nis useful, it can be desirable to use a more sophisticated data structure to represent such collections. \nTo sup\u00adport this usage, Forest allows programmers to pre.x a list compre\u00adhension with any type constructor \nthat belongs to a Forest-de.ned container type class. This type class contains functions that specify \nhow to convert between the list representation and the desired con\u00adtainer representation. We have provided \nsuch instance declarations for Haskell s Map and Set type constructors. As an example, consider the speci.cation \nof the Major direc\u00adtory. Each such directory contains a list of student .les and an ad\u00additional template \n.le named either sss.txt or sxx.txt. The declaration below speci.es the collection of student .les by \nmatch\u00ading with a glob pattern and .ltering to exclude template .les. It uses the Map type constructor \nto specify that the data and metadata should be collected in a Map rather than a list. > template s = \ns elem [\"sss.txt\", \"sxx.txt\"] > txt = GL \"*.txt\" type Major = Map [ s :: File (Student <|dropExtension \ns|>) | s <-matches txt, <|not (template s)|>]  3.6 Dependent Types: Attributes and Constraints Every \n.le system object has a number of attributes associated with it, such as its owner, group, permissions, \nand size. In general, if a Forest identi.er id refers to a path, then the identi.er id_att refers to \nthe corresponding attributes. This attribute identi.er has type Forest_md, shown in Figure 3. Forest \nde.nes helper func\u00ad tions to access these attributes, some of which are listed in Figure 4. Constrained \ntypes are a simple form of dependent types that allow users to specify required attributes. For example, \nthe type PrivateFile speci.es a text .le accessible only by its owner. type PrivateFile = TextFile where \n<|get_modes this_att == \"-rw-------\"|> The keyword where introduces a constraint on the underlying type. \nThe load function for the type PrivateFile checks this constraint during loading. If the constraint is \nfalse, it records that fact in the metadata. Within constraints, the special identi.er this refers to \nthe representation of the underlying object, this_att refers to its attributes and this_md to its complete \nmetadata. Using attributes, we can write a universal directory description, which is suf.ciently general \nto describe any directory: type Universal = Directory { asc is [ f :: TextFile | f <-matches <| GL \"*\" \n|>, <| get_kind f_att == AsciiK |> ] , bin is [ b :: BinaryFile | b <-matches <| GL \"*\" |>, <| get_kind \nb_att == BinaryK |> ] , dir is [ d :: Universal | d <-matches <| GL \"*\" |>, <| get_kind d_att == DirectoryK \n|> ] , sym is [ s :: SymLink | s <-matches <| GL \"*\" |>, <| isJust (get_symLink s_att) |> ] } function \nname information get_group object group get_kind the sort of .le or directory get_modes permission string \nget_owner object owner get_size object size Figure 4. Selected .le attribute functions. When a directory \nis loaded using the Universal description, all the ASCII .les will end up the in asc .eld, all the binary \n.les in bin, all the directories in dir, and all the symbolic links in sym. Note that the description \nuses recursion to describe nested directories. In the case that a symbolic link creates a cycle in the \n.le system by pointing to a parent directory, the Haskell in\u00admemory representation is a (lazy) in.nite \ndata structure. We view the fact that it is possible to write such a universal description in Forest \nas evidence that the language is appropriately expressive. This description also serves as an example \nof how to describe a .lestore by its structure rather than its names. We can also use constraints to \nspecify that certain .les do not appear in certain places. As an example, we might want to require that \nno binaries appear in a directory given to an untrusted user as scratch space. The description below \n.ags an error during loading if a binary .le exists in the directory. type NoBin = [ b :: BinaryFile \n| b <-matches <| GL \"*\" |>, <| get_kind b_att == BinaryK |> ] where <|length this == 0|>  3.7 Specialized \nConstructors: Gzip and Tar Some .les need to be processed before they can be used. A typ\u00adical example \nis a compressed .le such as the gzipped log .les in CoralCDN. Forest provides processing-speci.c type \nconstructors to describe such .les. For example, if CoralLog is a Pads/Haskell description of a CoralCDN \nlog .le then type Info = Gzip (File CoralLog) describes a gzipped log .le. Likewise, suppose logs.tar.gz \nis a gzipped tar .le and that the type ManyLogs describes the directory of log .les that logs.tar expands \nto when untarred. Such a situation can be described using a combination of the Tar and Gzip type constructors: \ntype MoreInfo = Gzip (Tar ManyLogs)  3.8 Putting it all together The preceding subsections give an overview \nof Forest s design. Fig\u00adures 5 and 6 give the speci.cations for the two running examples, minus the associated \nPads/Haskell and Haskell declarations. The complete descriptions of these .lestores and additional descriptions \nare available in a technical report [4], including descriptions of the Pads website, a Gene Ontology \n.lestore, and CVS repositories. 4. Programming with Forest Many Forest programs work in two phases. In \nthe .rst phase they use Forest to load relevant portions of the .le system into memory, and in the second \nphase they use an ordinary Haskell function to traverse the in-memory representation of the data (or \nits associated metadata) and compute the desired result. Some Forest programs add a third phase in which \nthey store updated structures back to the .lestore. [forest| data PrincetonCS (y::Integer) = Directory \n{ notes is \"README\" :: TextFile , seniors is <|mkClass y |> :: Class y , juniors is <|mkclass (y+1)|> \n:: Class <|y+1|> , graduates :: Grads } data Class (y::Integer) = Directory { bse is <|\"BSE\" ++ (toString \ny)|> :: Major , ab is <|\"AB\" ++ (toString y)|> :: Major , trans matches transRE :: Maybe Major , withd \nmatches wdRE :: Maybe Major , leave matches leaveRE :: Maybe Major } type Grads = [c :: Class <|getYear \nc|> | c <-matches cRE] type Major = Map [ s :: File (Student <|dropExtension s|>) | s <-matches txt, \n<|not (template s)|>] |] Figure 5. Forest description of Princeton .lestore. [forest| type Stats = Directory \n{ last :: File Last, topk :: File Topk } type Dat =[s::Site|s<-matches site ] type Site =[d::Log |d<-matches \ntime ] data Log = Directory { log is coralwebsrv :: Gzip (File CoralLog) } |] Figure 6. Forest description \nof CoralCDN .lestore. Representation Types: newtype Stats = Stats {last :: Last, topk :: Topk} newtype \nDat = Dat [(String, Site)] newtype Site = Site [(String, Log)] data Log = Log {log :: CoralLog} Metadata \nTypes: type Stats_md = (Forest_md, Stats_inner_md) data Stats_inner_md = Stats_inner_md {last_md :: (Forest_md, \nLast_md), topk_md :: (Forest_md, Topk_md)} type Dat_md = (Forest_md, [(String, Site_md)]) type Site_md \n= (Forest_md, [(String, Log_md)]) type Log_md = (Forest_md, Log_inner_md) data Log_inner_md = Log_inner_md \n{log_md :: (Forest_md, CoralLog_md)} Load Functions: stats_load :: FilePath -> IO (Stats, Stats_md) \ndat_load :: FilePath -> IO (Dat, Dat_md) site_load :: FilePath -> IO (Site, Site_md) log_load :: FilePath \n-> IO (Log, Log_md) Store Functions: stats_manifest :: (Stats, Stats_md) -> IO Manifest dat_manifest \n:: (Dat, Dat_md) -> IO Manifest site_manifest :: (Site, Site_md) -> IO Manifest log_manifest :: (Log, \nLog_md) -> IO Manifest storeAt :: FilePath -> Manifest -> IO () store :: Manifest -> IO () Figure 7. \nArtifacts generated from the CoralCND description.  To facilitate this style of programming, the Forest \ncompiler gen\u00aderates several Haskell types and functions from every Forest decla\u00adration. Collectively, \nthese types and functions de.ne an instance of the Forest type class: class (Data rep, ForestMD md) => \nForest rep md | rep -> md where load :: FilePath -> IO(rep, md) manifest :: (rep,md) -> IO Manifest ... \nIn this type class, the type rep is the generated in-memory rep\u00adresentation type of the corresponding \non-disk data. The type md is the generated type for the associated metadata. The ForestMD type class \nprovides operations for manipulating Forest metadata; all generated metadata types belong to this type \nclass. The generated load function lazily traverses the .le system and reads the .les, directories, and \nsymbolic links mentioned in the de\u00adscription into a pair of the in-memory representation and its meta\u00addata. \nTo reverse the process of reading data in to memory, Forest also generates a manifest function, which \nreads an in-memory data structure, writes its contents out to disk in a temporary space, and prepares \na manifest log. The manifest log records inconsistencies detected during this process as well as the \nsequence of operations necessary to move data from the temporary space to its .nal resting point. Inconsistences \ncan arise when a programmer creates an er\u00adroneous in-memory representation of a .lestore. The dependencies \nthat may be present in Forest descriptions mean that not all such inconsistencies can be detected statically \nby the Haskell type sys\u00adtem. After creating a manifest, a programmer may analyze it and decide whether \nto execute the generic store or storeAt func\u00adtions, which move a manifest (inconsistencies and all) to \nits rightful position on disk. Details concerning the semantics of storing, espe\u00adcially where it concerns \ninconsistencies, are explained in further depth in Section 7. As an example, consider the CoralCDN logs \ndescribed in Fig\u00adure 6. The corresponding load and store functions, the represen\u00ad tation types, and the \nmetadata types appear in Figure 7.3 Note that the structure of each of these artifacts mirrors the structure \nof the Forest description that generated them. This close correspon\u00addence makes it easy for programmers \nto write programs using these Forest-generated artifacts. For instance, consider the Dat description \nin Figure 6. The dat_load function takes a path as an argument and produces the representation and metadata \nobtained by loading each of the site directories contained in the directory at that path: (rep,md) <-dat_load \n\"/var/log/coral/dat\" Because Dat is a Forest list, the rep is a Haskell list. More speci.cally, rep has \nthe form Coral [(\"planetab2.eecs.wsu.edu\", Site [...]), (\"planetlab3.williams.edu\",Site [...]),...] where \nthe list contains pairs of names of subdirectories and repre\u00adsentations for the data loaded from those \ndirectories. The metadata is a pair consisting of a generic header of type Forest_md and a list of pairs \nof names of subdirectories and their associated meta\u00addata. The header collects information about errors \nencountered dur\u00ading loading and it stores the .le system attributes of each .le, direc\u00adtory, or symbolic \nlink loaded from the .le system. The following is the pretty-printed version of such a structure: 3 In \nthe following examples, for the sake of clarity, we use type-speci.c names such as dat_load and dat_manifest, \nrather than the over\u00adloaded names load and manifest. Forest_md { numErrors = 0, errorMsg = Nothing, \nfileInfo = FileInfo { fullpath = /var/log/coral/dat, owner = alice, group = staff, size = 102, access_time \n= Fri Nov 19 01:47:09 2010, mod_time = Thu Nov 18 20:42:37 2010, read_time = Fri Nov 19 01:47:28 2010, \nmode = drwxr-xr-x, isSymLink = False, kind = Directory } }, [(\"planetlab2.eecs.wsu.edu\", Forest_md {...}), \n(\"planetlab3.williams.edu\", Forest_md {...}), ...] Using these functions and types, it is easy to formulate \nmany useful queries as simple Haskell programs. For instance, to count the number of sites we can simply \ncompute the length of the nested list in rep: num_sites = case rep of Dat l -> List.length l More interestingly, \nsince the internals of the web log are speci.ed using Pads/Haskell (see the technical report [4] for \ndetails), it is straightforward to dig in to the .le data and combine it with .le metadata or attributes \nin queries. For example, to calculate the time when statistics were last reported for each site, we can \nzip the lists in rep and md together and project out the site name and the mod_time .eld from each element \nin the resulting list of pairs: get_site = fst get_mod (_,(f,_)) = mod_time . fileInfo $ f sites_mod \n() = case (rep,md) of (Dat rs, (_,ms)) -> map (get_site *** get_mod) (zip rs ms) As this example shows, \nForest blurs the distinction between data represented on disk and in memory. After writing a suitable \nForest description, programmers can write programs that work on .le system data as if it were in memory. \nMoreover, because Forest uses Haskell s lazy I/O operations, many simple programs do not require constructing \nan explicit representation of the entire directory being loaded in memory a good thing as the directory \nof CoralCDN logs contains approximately 1GB of data! Instead, the load functions only read the portions \nof the .le system that are needed to compute the result in this case, only the site directories and not \nthe gzipped log .les contained within them. As a .nal analysis example, consider a program that computes \nthe top-k requested URLs from all CoralCDN nodes by size. The CoralCDN administrators compute this statistic \nperiodically to help monitor and tune the performance of the system [11]. We de.ne the analogous function \nin Haskell using helper functions such as get_sites to project out components of rep: topk k = take k \n$ sortBy descBytes $ toList $ fromListWith (+) [ (get_url e, get_total e) | (site,sdir) <-get_sites rep, \n(datetime,ldir) <-get_dates sdir, e <-get_entries ldir, is_incoming e ] Reading this program inside-out, \nwe see that it .rst uses a list com\u00adprehension to iterate through rep, collecting the individual log \nen\u00adtries corresponding to incoming requests using the is_incoming predicate. It then projects out the \nURL requested and the total size of the request. It then sums the sizes of all requests for the same \nURL using the fromListWith function from the Data.Map module. Next, it sorts the entries in descending \norder. Finally, it returns the .rst k entries of the list as the .nal result. Having implemented these \nanalyses, a programmer may wish to store their results. She may do so via the following code, which uses \nstats_manifest to generate a manifest and store to copy it over to the stats directory. In addition, \nthe code uses stats_defaultMd, a function that constructs default metadata for stats structures (a useful \nfunction in situations that require storing newly constructed data). let result = Stats { last = sites_mod \n() , topk = topk 10 } manifest <-stats_manifest ( result , stats_defaultMd result \"/var/log/coral/stats\" \n) store manifest Overall, the main thing to take away from this section is how Forest and its tight integration \nwith Haskell facilitates exploratory data analysis, enabling remarkably terse queries over the combina\u00adtion \nof .le contents, .le attributes and directory structures. 5. Generic Tools Third-party developers can \nuse generic programming [18] to gen\u00ad erate tools that will work for any .lestore that has a Forest descrip\u00adtion. \nAn advantage of these tools compared to tools that work di\u00adrectly on the untyped .le system is that they \nare speci.c to the fragment of the .le system relevant to the .lestore. This fragment can be dif.cult \nto specify when using conventional tools since it can rely on the contents of con.guration .les, .le \nnaming conven\u00adtions, .le system attributes, etc. It is precisely these relationships that Forest descriptions \ncapture concisely; tools written to use For\u00adest speci.cations can leverage that information. As a proof \nof concept, we have written a number of such tools, which we describe in this section. 5.1 Generic Querying \nOne simple application of generic programming is querying meta\u00addata to .nd .les with a particular collection \nof attributes. The findFiles function findFiles :: (ForestMD md) => md -> (FileInfo -> Bool) -> [FilePath] \ntakes as input any Forest metadata value (i.e., any value of type md where md belongs to the Forest metadata \nclass ForestMD) and a predicate on FileInfo structures, and returns the list of all FilePaths anywhere \nin the input metadata whose associated FileInfo satis.es the predicate. For example, if cs_md is the \nmetadata associated with the Princeton computer science depart\u00adment .lestore, then the code dirs = findFiles \ncs_md (\\(r::FileInfo) -> (kind r) == DirectoryK) other = findFiles cs_md (\\(r::FileInfo) -> (owner r) \n/= \"bwk\") binds dirs to the list of all directories in the data set and other to all the directories \nand .les not owned by user \"bwk\". To implement the findFiles function, we use the generic Haskell function \nlistify: findFiles md pred = map fullpath (listify pred md) The return type of the polymorphic listify \nfunction is instan\u00adtiated to match the argument type of its predicate argument. We map the fullpath function \nover the resulting list of FileInfo structures to return only the FilePaths.  5.2 File System Visualization \nForestGraph generates a graphical representation of any direc\u00adtory structure that matches a Forest speci.cation. \nWe generated the graphs in Figures 1 and 2 using this tool. In the default con.gu\u00ad ration, ForestGraph \nuses boxes to denote directories and ovals to denote .les. Borders of varying thickness distinguish between \nASCII and binary .les. Dashed node boundaries indicate symbolic links and shaded nodes .ag errors. The \ncore functionality of ForestGraph lies in the Haskell function mdToPDF: mdToPDF :: ForestMD md => md \n-> FilePath -> IO (Maybe String) The function takes as input any metadata value and a .lepath that speci.es \nwhere to put the generated PDF .le. It optionally returns a string (Maybe String); if the option is present, \nthe string contains an error message. The IO type constructor indicates that there can be side effects \nduring the execution of the function. A use of this function to generate the graph for the Princeton \ncomputer science department .lestore looks like: do { (cs_rep,cs_md) <-CS_load \"facadm\" ; mdToPDF cs_md \n\"Output/CS.pdf\" }  Note that this code needs only the metadata to generate the graph; laziness means \nForest will not load the representation in this case. The related function mdToPDFWithParams takes an \naddi\u00adtional argument that allows the user to specify how to draw the nodes and edges in the output graph. \nAmong other things, this pa\u00adrameter speci.es how to map a value of type Forest_md into GRAPHVIZ [13, \n14] attributes. By appropriately setting the pa\u00ad rameter, a user can customize the formatting of each \nnode ac\u00adcording to its owner, group, or permissions, etc., as well as spec\u00adify global properties of the \ngraph such as its orientation and size. ForestGraph uses the Haskell binding of the GRAPHVIZ library \nto lay out and render the graphs, so all customizations provided by GRAPHVIZ are available. The listify \nfunction is at the heart of the implementation of this tool; we use it to convert the input metadata \nto the list of FileInfos in the metadata. We then convert this list into a graph data structure suitable \nfor use with the GRAPHVIZ library. 5.3 Permission Checker The permission tool is designed to check the \npermissions on the .les and directories in a Forest description on a multi-user machine. In particular, \nit enables one user to determine which .les a second user can read, write, or execute. If the second \nuser cannot access a .le in a particular way, the tool also reports the names of the .les and directories \nwhose permissions have to change to allow the ac\u00adcess. The tool is useful when trying to share .les with \na colleague. It helps the .rst user ensure that all the necessary permissions have been set properly \nto allow the second user access. The key to the implementation of this tool is again applying the listify \nfunc\u00adtion to the metadata for the Forest description. 5.4 Shell Tools We have implemented analogs of \nmany shell tools that work over a .le system fragment de.ned by a Forest description: ls :: (ForestMD \nmd) => md -> String -> IO String grep :: (ForestMD md) => md -> String -> IO String tar :: (ForestMD \nmd) => md -> FilePath -> IO () cp :: (ForestMD md) => md -> FilePath -> IO () All of these functions \nwork by extracting the relevant .le names from the argument metadata structure using listify and then \ncalling out to a shell tool to do the work. For ls, the second argu\u00adment gives the command-line arguments \nto pass to the shell version of ls, and the result is the resulting output. The implementation uses xarg \nto lift the restriction on the number of .les that can be passed to ls. For grep, the second argument \nis the search string and result is the output of the shell version of grep. For tar, the second argument \nspeci.es the location for the resulting tarball. The implementation uses a .le manifest to allow tar \nto work regard\u00adless of the number of .les involved. The cp tool uses the tar tool to move the .les mentioned \nin the metadata to the location speci.ed by the second argument while retaining the same directory struc\u00adture. \nThe module that implements these tools is approximately 80 lines of Haskell code.  5.5 Description Inference \nTool This tool allows the user to generate a Forest description from the contents of the .le system. \nThe function getDesc :: FilePath -> IO String takes as an argument the path to the root of the directory \nstructure to infer. It returns a string containing the generated representation. For example, below we \nshow a fragment of the results when getDesc is invoked on the classof11 directory: data classof11 = Directory \n{ aB11 is \"AB11\" :: aB11, bSE11 is \"BSE11\" :: bSE11, tRANSFER is \"TRANSFER\" :: tRANSFER, wITHDREW is \n\"WITHDREW\" :: wITHDREW } data tRANSFER = Directory { bEAUCHEMINtxt is \"BEAUCHEMIN.txt\" :: File Text, \nvERSTEEGtxt is \"VERSTEEG.txt\" :: File Text } ... The description is not perfect: the label names are \ngenerated from the .le name, for example. Nevertheless, the tool improves pro\u00adgrammer productivity as \nit is easier for a programmer to edit a gen\u00aderated description than to start from scratch. Our .rst tool \nin this vein is simple; a more sophisticated variant would collapse records of .les into lists when a \nwidth limit was exceeded or other criteria were met. Another variant might collapse deeply nested directories \ninto a universal directory description when a depth limit was ex\u00adceeded. The getDesc function works by \nusing the universal de\u00adscription to load the contents of the .le system starting from the supplied path. \nIt then walks over the resulting metadata to generate a Forest parse tree, which it then pretty prints. \n6. Implementation The current implementation of Forest is available from the project web site: forestproj.org. \nHaskell provides powerful language features and libraries that greatly facilitated implementation of \nForest. The most obvious of these features is the quasiquotation mechanism [21] that we used to embed \nForest into Haskell. This mechanism provided the bene.ts of being an embedded domain-speci.c language \nwithout having to sacri.ce the .exibility of de.ning our own syntax. To use quasiquoting, we de.ned a \nHaskell value forest of type QuasiQuoter which speci.es how to convert an input string representing a \nsequence of Forest declarations into the Template Haskell [27] data structures that represent the syntax \nof the corre\u00ad sponding collection of Haskell declarations. The Haskell compiler calls the forest compilation \nfunction during the compilation of any Haskell source .le containing a Forest quasiquotation. The quasiquoted \nsyntax [forest| <input> |] is legal anywhere the identi.er forest is in scope. When the Haskell compiler \npro\u00adcesses this declaration, it .rst passes <input> as a string to the forest quasiquoter, and then it \ncompiles the resulting Template Haskell data structures as if the corresponding Haskell code had appeared \nin the input at the location of the quasiquote. Early ver\u00adsions of quasiquoting supported quoting only \nexpression and pat\u00adtern forms. Simon Peyton Jones extended the mechanism to permit declaration and type \nquasiquoting partly to enable the Forest imple\u00admentation. We used this same approach to implement Pads/Haskell, \nwhich we built concomitantly. Note that in implementing Forest, we had to use Template Haskell rather \nthan any of the other libraries that support generic programming, both because that is what the quasiquote \nlibrary ex\u00adpects and because we need to generate type and datatype decla\u00adrations (and to do so at compile \ntime). Other available generic li\u00adbraries do not support the latter functionality. Parsing. We used the \nparsec 3.1.0 parser combinator library [19] to implement the Forest parser. One key element of the Forest \nde\u00adsign is to allow arbitrary Haskell expressions in various places in\u00adside Forest descriptions. We did \nnot want to reimplement the gram\u00admar for Haskell expressions, which is quite complicated. Instead, we \nstructured the Forest grammar so we could always determine the extent of any embedded Haskell code. We \nthen used the Haskell Source Extension package [15] to parse these fragments. The data structure that \nthis library returns is unfortunately not the data struc\u00adture that Template Haskell requires, so we used \nyet another library, the Haskell Source Meta package [16], that does this translation. Type checking. \nWe would like to give users high-quality error messages if there are type errors in their Forest declarations. \nAt the moment, typechecking occurs, but only after the Forest declarations have been expanded to the \ncorresponding Haskell code. Although these error messages can be quite informative, it is sub-optimal \nto report errors in terms of generated code. Type checking the Forest source is complicated by the embedded \nfragments of Haskell. As with the syntax, we do not want to reimplement the Haskell type\u00adchecker! There \nis an active proposal [29] to extend the Template Haskell infrastructure with functions that would enable \nus to ask the native Haskell typechecker for the types of embedded expres\u00adsions and to extend the current \ntype environment with type bindings for new identi.ers. With this combination of features, we would be \nable to type check Forest sources directly. Runtime. Although Forest facilitates treating the .le system \nas a persistent store, it does not provide the ACID guarantees familiar from databases. None of the .lestores \nwe have encountered in prac\u00adtice are implemented in a system that provides such support; users instead \nhave extra-linguistic mechanisms to make sure they do not corrupt their data with ill-timed concurrent \nreads and writes. That said, the Forest language does not preclude an implementation from providing such \nguarantees. We consider this issue very interesting future work. Forest uses Haskell s unsafeInterleaveIO \nto load each portion of a .lestore only when needed by an application program. We have not systematically \nmeasured the performance overhead of using Forest. However, we have used our mostly-unoptimized implementation \nto manipulate .lestores on the order of many giga\u00adbytes and found the performance acceptable for many \napplications. The running time of storing operations is proportional to the footprint of the described \n.lestore. However, the Forest compiler generates load and manifest functions for each named type in a \ndescription. Thus, updates may be made at any granularity for which there is a named type, which is typically \nat the level of in\u00addividual .les. We plan to investigate better support for incremental updates in future \nwork. 7. Core Calculus This section presents a core calculus for Forest, which formalizes the essential \nfeatures of the language in a simple setting. The calculus is based on classical (i.e., not separating, \nsubstructural, or ambient) unordered tree logics, but has a number of features tailored to .le systems. \nWe used it to study various features of Forest as we were developing it, and to prove key theorems like \nthe round-tripping properties described at the end of the section. Basic de.nitions Integers n . Z Strings \nu . S * Values v ::= n | u | r | True | False | () | (v1,v2) | Just v | Nothing | [v1, .., vn] Types \nt ::= String | Int | Path | Bool | () | (t1,t2) | Maybe t | [t] Environments E ::= \u00d8|E,x . v Expressions \ne ::= x | .x. e | e1 e2 | ... Forest de.nitions Paths r ::= \u00b7| r / u Attributes a ::= v Contents T ::= \nFile u | Link r | Dir {u1, .., un}File systems F ::= {|r1 . (a1,T1), .., rn . (ak,Tn) |}Speci.cations \ns ::= kt2 | e::s |(x:s1,s2)| [s | x . e] | P(e) | s? t1 Figure 8. Forest calculus syntax. 7.1 Data Model \nForest calculus speci.cations manipulate instances of a simple .le system model, which is given in Figure \n8. A path r is a sequence of strings u,4 and a .le system F is a .nite map from paths to pairs (a,T ) \nof attributes a and .le system contents T . We do not specify the syntax of attributes precisely, but \nexpect that they will contain the usual .elds including owner, group, permissions, modi.cation date and \ntime, etc. A special attribute adefault contains default values for all .elds. The contents T of a node \nin the .le system is either a .le File u, where u is the string contents of the .le; a symbolic link \nLink r, where r is the path pointed to by the link; or a directory Dir {u1, .., un}, where u1 to un are \nthe names of the elements of the .le system located below the node. We write dom(F ) for the set of paths \nF is de.ned on, F (r) for the contents at r, F (r)= . when r is not in dom(F ), and F [r := (a,T )] or \nF [r := .] for the .le systems obtained from F by overwriting the mapping for r to (a,T ) or deleting \nthe mapping for r respectively. A .le system F is well-formed if it encodes a tree with directo\u00adries \nat the internal nodes and .les and symbolic links at the leaves. More formally, F is well-formed if the \nfollowing conditions hold: dom(F ) is pre.x-closed,  F (r)=(a, Dir {u1, .., un}) implies r / ui . dom(F \n) for all i from 1 to n, and  F (r)=(a, File u) or F (r)=(a, Link r') implies r / u' . dom(F ) for all \nu'.  Note that although these conditions imply that the structure of a well-formed .le system F must \nbe tree-shaped, cycles can be expressed using symbolic links that point up in the .le system.  7.2 Speci.cations \nThe syntax of speci.cations s is given in Figure 8. The calculus models the most important features of \nthe full Forest language in the simplest possible way, using orthogonal, independent con\u00adstructs. The \nset of speci.cations is parameterized over a collection 4 For simplicity, we do not model special path \nelements such as .. and . . It would be easy to add these at the cost of complicating the semantics. \n of constants ktt12 , where t1 is the type of the generated representa\u00adtion and t2 is the type of the \ngenerated metadata. We omit the type annotations in examples. For the purpose of illustration, we will \nassume that constants for describing .les File, directories Dir, and symbolic links Link all exist, as \nwell as constants Adhoc(p) param\u00adeterized on Pads/Haskell descriptions p for describing the contents \nof .les in more detail. Path speci.cations e::s are parameterized on an expression e, which must evaluate \nto a string (to be appended to the current path), and a speci.cation s that describes the frag\u00adment of \nthe .le system at the extended path. We leave the syntax of expressions e abstract but assume that it \ncontains the features of a simple functional language (of course, in the full Forest lan\u00adguage, expressions \ncan be arbitrary fragments of Haskell code). We assume a semantic function [ e] E t that evaluates e \nin environ\u00adment E, yielding a value v of type t . Dependent pairs are written (x:s1,s2) where s1 and \ns2 are speci.cations that describe possibly overlapping fragments of the .le system. When a dependent \npair is evaluated, the variables x and xmd are bound to the value and metadata computed for s1 and may \nbe used in s2. Comprehensions are written [s | x . e], where e is an expression that evaluates to a set \nof values, and s is a speci.cation that describes a fragment of the .le system for each value of x. Predicates \nP(e) succeed when the expression e evaluates to True and fail when it evaluates to False under the current \nenvironment. Finally, the speci.cation s? describes either a .lesystem that is unde.ned at the current \npath, or a .le system containing the current path and satisfying s. To develop some intuitions about \nthese constructs, let us encode a few of the more complicated features of the full Forest language in \nthe calculus. In the full language, records and paths are speci.ed using a single construct: Directory \n{c is \"c.txt\" :: C, d is \"d.txt\" :: D c, e is \"e.bin\" :: E d } The calculus, however, only has dependent \npairs, not full-blown records, and has a separate construct for describing paths. Thus, to encode the \nspeci.cation above, we use the following speci.cation: (c :(\"c.txt\"::C) , (d :(\"d.txt\"::D c) , \"e.bin\"::E \nd)) Similarly, a comprehension written as [c :: C | c <-matches <| GL \"*\" |> ] in the full language \nis encoded in the calculus as (d:Dir , [ c::C | c . d ]) The value returned by the Dir constant is the \nset of names of the immediate children of the directory. Finally, in the full language, constraints are \nwritten as   s where e but are encoded in the calculus as a dependent pair and predicate: (this:s, \nP(e)) When evaluated, the predicate encodes the success or failure of the constraint expressed by e \nin the metadata for the second component of the pair. 7.3 Semantics The semantics of the Forest calculus \nis organized into four separate de.nitions, one for each of the major artifacts generated by the compiler. \nThese artifacts include a type for the representations, a type for metadata, a function load for loading \ndata from the .le system, and a function store for storing it back. They are carefully designed to .t \ntogether in a particular way e.g., the load and store functions manipulate representations and metadata \nof the appropriate type and are guaranteed (under certain precisely identi.ed circumstances) to preserve \ndata on round trips. Types. The de.nitions of the types for the representations (R[ s] ) and metadata \n(M[ s] ) generated for each speci.cation s appear in Figure 10. The representation type for constants \nktt12 is simply read off from t1. For other speci.cations, representation types are built out of the \ntypes for sub-speci.cations in the obvious way e.g., for pairs (x:s1,s2), the type is a product (R[ s1] \n, R[ s2]]). The types for metadata are more interesting. In the Forest calculus we represent metadata \nusing structured datatypes containing a boolean value at each level of structure. Intuitively, this value \nindicates whether there were any errors during loading. The Md constructor provides a uniform representation \nfor these structures, MdHeader = Bool Md t =(MdHeader,t), and the function valid(d) extracts the boolean \nvalue, returning True if there are no errors in the structure, and False otherwise. Each of the the load \nfunctions generated from speci.cations main\u00adtain the invariant that the the boolean value at each level \nof struc\u00adture is True if and only if all of the nested values are also True. Thus, one can test for errors \nduring loading simply by examining the top-level boolean value. Note that it would be simple to aug\u00adment \nthis structure with additional information, such as the number of errors, an optional error message, \nor .le system attributes, as in Figure 3; one would simply have to change the MdHeader type and the valid(d) \nfunction. Load Functions. The most common use of Forest is as a tool for loading data from the .le system \ninto an in-memory representation. The functions de.ned by the inference rules in Figure 10 (a) imple\u00adment \nthis task. Formally, the judgment E; r; s f load F c (v, d) holds if loading the speci.cation s from \nthe .le system F at path r in environment E yields a pair (v, d) of representation and meta\u00addata. This \njudgment may be seen as describing a total function from E, r, s and F to (v, d). The fact that the load \nfunction is total is useful it allows the programmer to explore fragments of the .le system that do not \nmatch s exactly. When F does not match s, the function puts default values in the representation v and \nrecords an error in the metadata d. Let us examine the inference rules that de.ne the load functions \nin detail. We assume that each constant ktt12 has an associated loadk function. For example, the load \nfunction for the File construct, which describes any .le (but not symbolic links or directories), takes \nan environment E, a .le system F , and a path r as arguments, and either returns the contents and attributes \nof the .le at path r, or  and default attributes if F (r) is unde.ned or not a .le. ( (u, (True, a)), \nifF (r)=(a, File u) loadFile (E, F, r)= ( , (False, adefault)), otherwise The load function for symbolic \nlinks is similar: ( (r ' , (True, a)), ifF (r)=(a, Link r ' ) loadLink (E, F, r)= (\u00b7, (False, adefault)), \notherwise Note that this function only returns the path r ' contained in the link and not the directory \nor .le pointed to by it. To access the contents of the .le system at r ', the programmer could bind the \npath value returned by Link to a variable, and use the path construct to navigate to that path, as in \nthe following speci.cation: (x : Link , (x::File) ) Alternatively, one could design another constant \nfor symbolic links that implements a deep lookup in the .le system. The load function for path speci.cations \ne::s evaluates the ex\u00adpression r/e to a path r ', and invokes the load function for s from r '. The load \nfunction for dependent pairs (x:s1,s2) .rst invokes the load function for s1, yielding a representation \nv1 and metadata d1, and then invokes the load function for s2 in an extended envi\u00adronment where x is \nbound to v1 and xmd to d1, yielding v2 and d2. It returns (v1,v2) and (valid(d1) . valid(d2), (d1,d2)) \nas the result. The load function for comprehensions [s | x . e] is similar. It evaluates the expression \ne to a list [w1, .., wn], invokes the load function for sn times, in a series of environments with x \nbound to each wi, and collects up the results into lists of representations [v1, .., vn] and metadata \n[d1, .., dn]. The load function for predicates P(e) tests whether the expres\u00adsion e is holds in the environment \nE. It returns () as the repre\u00adsentation and (b, ()) as the metadata, where b is [ e] E . The .nal bool \n load function, for options, s? is de.ned using two inference rules. The .rst handles the case where \nthe current path r exists in the .le system. It uses s s load function to obtain a representation and \nmetadata and injects both into the Maybe type using the Just con\u00adstructor. The second handles the case \nwhere r does not exist in the .le system. It returns Nothing for both the representation and metadata. \nStore Functions. Just as they can be used for loading from the .le system, Forest speci.cations can also \nbe used to store data back to the .le system. The inference rules in Figure 10 (b) de.ne the judgment \nE; r; s f store (F, v, d) c (F ' ,f ' ), which holds if storing (v, d) into F at r using speci.cation \ns with respect to E yields a modi.ed .le system F ' and a validator f '. This last element, the validator, \nis a predicate on .le systems that tests for inconsistencies during storing it will be described in \ngreater detail momentarily. As with load functions, the store judgment may be read as a total function; \nit maps E, r, s, F , and (v, d) to (F ' ,f ' ). Intuitively, it should be obvious that there are numerous \nways that storing data back to the .le system could go wrong. For ex\u00adample, the representation v and \nmetadata d might not be consistent with the existing information on the .le system, or with each other. \nEven worse, storing v and d back to F could involve overwriting the same .le (or link, or directory) \nwith multiple pieces of data a con.ict. Thus, to reliably use store functions to manipulate the .le system, \nwe need a way way to track the intricate constraints on the data in the representation, metadata, and \n.le system implied by the speci.cation. The validator f ' produced by the store function does exactly \nthis it keeps track of the conditions needed to ensure that storing the representation and metadata back \nto F will accurately re.ect all of the information they contain. As a simple example that shows why validators \nare necessary, consider a speci.cation s de.ned as (x:File, File) and suppose that we invoke s s load \nfunction with E, F , and r where F (r) is (a, File u). According to the semantics of the load functions \ndescribed above, the representation v will be a pair (u, u) containing two copies of the .le contents \nat r and the metadata d will also be a pair ((True, a), (True, a)) containing two copies of the attributes \nassociated to that .le. Now suppose that we change the representation to (u, u ' ), where u = u ', and \nstore the result back to the .le system. Because this new representation does not satisfy the dependency \nbetween the two components of the pair implied by s, the store function cannot produce a new .le system \ncontaining the information in both u and u '. It must store one of the strings and discard the other. \nThe validator f ' detects this inconsistency. In this case, the validator will be equivalent to the following \npredicate on .le systems: '' '' .F . (F (r)=(a, File u)) . (F (r)=(a, File u ), which is clearly not \nsatis.able unless u = u ' . The store functions also use validators to detect internal incon\u00adsistencies \nbetween the representation and metadata. For example, consider the speci.cation s de.ned as s1?, and \nsuppose that invok\u00ading s s load function with E, F , r where F (r) is unde.ned. The representation and \nmetadata will be Nothing and (True, Nothing) respectively. Now suppose that we change the representation \nto Just u ' , and invoke s s store function. Even though the pair (Just u ' , (True, Nothing)) would \nnever be produced by s s load function, the store function must still do something reasonable with it. \nA reasonable choice the one used in our semantics is to update the .le system contents by passing (File \nu ' , adefault) to s s store function, but produce a validator f ' = .F ' . False that records the inconsistency \nbetween the representation and metadata. This informs the programmer that if they invoke the load function \non the new .le system, the representation and metadata may not be preserved e.g., loading using s1 could \nresult in an error. Now let us examine the inference rules in detail. We assume that each constant de.nes \na storek function. The store function for File is de.ned as follows: s R[ s] M[ s] kt2 t1 t1 Md t2 e::s \nR[ s] M[ s] (x:s1, s2) (R[ s1] , R[ s2]]) Md (M[ s1] , M[ s2]]) [s | x . e] [R[ s]]] Md [M[ s]]] P(e) \n() Md () s? Maybe R[ s] Md (Maybe M[ s]]) Figure 9. Forest calculus representation and metadata types. \n function for options s1? is de.ned by three inference rules. The .rst handles the case where the representation \nis Just v1 and the metadata is Just d1 by simply unpacking the encapsulated values and invoking s1 s \nstore function. The second handles the case where the representation is Nothing. It deletes the .le and \nreturns a validator that checks whether the metadata d is also Nothing and the .le system is unde.ned \non the path r. The third rule handles storeFile (E, F, r, v, d)= (F [r := (a, File v)], .F ' . (F ' (r)=(a, \nFile v))) if d =(True, a) (F [r := .], .F ' . (v = . a = adefault . F ' (r)=( , File ))) if d =(False, \na) . F (r)=( , File ) (F, .F ' . (v = . a = adefault . F ' (r)=( , File ))) if d =(False, a) . F (r)=( \n, File ) 8 >>>>>>>>>>>>>< >>>>>>>>>>>>>: the case where the representation is Just v1 and the metadata \nis Nothing. It invokes s1 s store function on v1 and default metadata and returns a validator that always \nevaluates to False, re.ecting the inconsistency in the representation and metadata. 7.4 Formal Properties \nThe semantics of Forest calculus speci.cations is carefully de\u00adsigned to ensure some essential correctness \nproperties. The .rst is a basic type safety property, which states that the load function for speci.cations \ns generates representations and metadata belonging to R[ s] and M[ s] respectively. It overwrites the \ncontents of the .le system F at path r with (a, File v) if d is valid, deletes the contents of F at r \nif d is not valid but F (r) contains a .le, and returns F unchanged otherwise. The validator f ' also \nhas three cases: in the .rst, it tests whether F ' (r) is (a, File v); in the second and third cases \nit tests whether F ' (r) is not a .le and (v, a) is the default ( , adefault) generated by the load function. \nThese constraints are necessary to prove the round-tripping properties described at the end of this section. \nThe rule for path speci.cations e::s simply passes off control to the store function for s after replacing \nthe current path r with [ r / e] E path . The rule for dependent pairs (x:s1,s2) is more interest\u00ading. \nGiven a pair (v1,v2) as the representation and (b, (d1,d2)) as the metadata, it invokes the store function \nfor s1 on (v1,d1), yield\u00ading an updated .le system F1 ' and validator f ' 1, and then invokes the store \nfunction for s2 on (v2,d2) in an extended environment where x is bound to v1 and xmd is bound to d1, \nyielding another updated .le system F2 ' and validator f ' 2. It combines the updated .le systems using \nthe right-biased .le system concatenation opera\u00adtor de.ned as follows: Proposition 1 (Load Type Safety) \nIf E; r; s f load F c (v, d) and R[ s] = tR and M[ s] = tM then f v : tR and f d : tM, This property \ndemonstrates that our type de.nitions are properly aligned with the semantics of loading. To ensure that \nthe semantics of loading is aligned with the semantics of storing, we also prove the following pair of \nround\u00adtripping properties. Theorem 2 (LoadStore) Let E be an environment, F a .le system, r a path, s \na speci.cation, v a representation, and d metadata. If E; r; s f load F c (v, d) E; r; s f store (F, \nv, d) c (F ' ,f)  then F = F ' and f ' (F ' ). 8 >>>< (F1++F2)(r)= (a2, Dir (U1 . U2)) if F1(r)=(a1, \nDir U1) . Theorem 3 (StoreLoad) Let E be an environment, F and F ' .le systems, r a path, s a speci.cation, \nv a representation, d and d ' metadata, and f ' a F2(r)=(a2, Dir U2) validator. If F1(r) if F2(r)= . \n' f '' E; r; s f store (F, v, d) c (F ,f ' )(F ) F2(r) otherwise E; r; s f load F ' c (v ' ,d ' ) >>>: \nFinally, it conjoins the two validators f ' 1 and f ' 2. The result is a .le system that contains the \nconsistent changes made to the .le system by the store functions for s1 and s2 as well as a validator \nthat checks for the consistency of all the changes. The store function for comprehensions is similar. \nThe store function for predicates P(e) returns the input .le system F unchanged and a validator f ' that \nchecks whether e evaluates to b, the boolean value stored in the metadata. The store then (v ' ,d ' \n)=(v, d). The .rst theorem states that loading from a .le system F and im\u00admediately storing the resulting \nrepresentation and metadata yields the original .le system and, moreover, that this .le system will sat\u00adisfy \nthe validator produced by the store function. This guarantees that the store function will not disturb \ninformation in the .le system if possible, such as the information outside of the fragment of the E; \nr; s f store (F, v, d) c (F ' ,f ' ) E; r; s f load F c (v, d) E; r; kt2 f load F c (loadk(E, F, r)) \nt1 E;[ r / e] Path E ; s f load F c (v, d) E; r; e::s f load F c (v, d) E; r; s1 f load F c (v1,d1) \n(E,x . v1,xmd . d1); r; s2 f load F c (v2,d2) b = valid(d1) . valid(d2) E; r; (x:s1,s2)f load F c ((v1,v2), \n(b, (d1,d2))) [ e] [E t] =[w1, .., wk] .i .{1, .., k}. (E,x . wi); r; s f load F c (vi,di) Vk b = i \nvalid(di) vs =[v1, .., vk] ds =[d1, .., dk] E; r;[s | x . e] f load F c (vs, (b, ds)) E b =[ e] Bool \nE; r; P(e) f load F c ((), (b, ())) r . dom(F ) E; r; s1? f load F c (Nothing, (True, Nothing)) r . dom(F \n) E; r; s1 f load F c (v1,d1) E; r; s1? f load F c (Just v1 , (valid(d1), Just d1 )) E; r; kt2 f store \n(F, v, d) c (storek(E, F, r, v, d)) t1 E '' E;[ r / e] Path ; s f store (F, v, d) c (F ,f ) E; r; e::s \nf store (F, v, d) c (F ' ,f ' ) E; r; s1 f store (F, v1,d1) c (F1' ,f1' ) (E,x . v1,xmd . d1); r; s2 \nf store (F, v2,d2) c (F2' ,f ' 2) ' '' f ' = .F . (b = valid(d1) . valid(d2)) . f1' (F ) . f ' 2(F ) \n' '' E; r; (x:s1,s2)f store (F, (v1,v2), (b, (d1,d2))) c (F1++F2,f ) vs =[v1, .., vj ] ds =[d1, .., \ndl] [ e] E [t] =[w1, .., wm] k = min (j, l, m) .i .{1, .., k}. (E,x . wi); r; s f store (F, vi,di) c \n(Fi ' ,fi' ) '' Vk Vk f '' f = .F . (j = l = m) . (b = i valid(di)) . ( ii(F )) ' '' E; r;[s | x . e] \nf store (F, vs, (b, ds)) c (F1++..++Fk,f ) f '' [ e] E = .F . (b = Bool ) E; r; P(e) f store (F, (), \n(b, ())) c (F, f ' ) E; r; s1 f store (F, v1,d1) c (F ' ,f ' 1) ' '' f ' = .F . (b = valid(d1)) . (r \n. dom(F )) . f ' 1(F ) E; r; s1? f store (F, Just v1 , (b, Just d1 )) c (F ' ,f ' ) '' ' f = .F . (d \n= Nothing) . b . r . dom(F ) E; r; s1? f store (F, Nothing, (b, d)) c (F [r := .],f ' ) E; r; s1 f store \n(F, v1,ds1 ) c (F ' ,f ' 1) default f ' = .F ' . False E; r; s1? f store (F, Just v1 , (b, Nothing)) \nc (F ' ,f ' ) (a) (b) Figure 10. Forest calculus semantics for (a) loading and (b) storing. .le system \ndescribed by the speci.cation. It also establishes that the validator is not the trivial predicate on \n.le systems that always returns false. The second theorem states that storing an arbitrary representa\u00adtion \nand then loading the resulting .le system yields the same rep\u00adresentation and metadata, provided the \nstored .le system satis.es the validator. This theorem ensures that the store function re.ects all of \nthe information contained in the representation in the updated .le system. These properties are based \non the general correctness conditions that have been proposed for bidirectional transformations in the \ncontext of lenses [10], but are generalized here to accommodate the inconsistencies that can arise when \nworking with imperfect, ad hoc data. The proofs of these theorems can be found in the accompanying technical \nreport. 8. Related Work The work in this paper builds upon ideas developed in the Pads project [5, 7]. \nPads uses extended type declarations to describe the grammar of a document and simultaneously to generate \ntypes for parsed data and a suite of data-processing tools. The obvious difference between Pads (and \nother parser generators) and Forest is that Pads generates infrastructure for processing strings (the \ninsides of a single .le) whereas Forest generates infrastructure for processing entire .lestores. In \naddition, Forest (and Pads/Haskell) is architecturally superior to previous versions of Pads in the tight \nintegration with its host language and in its support for third-party generic programming and tool construction. \n More generally, Forest shares high-level goals with other sys\u00adtems that seek to make data-oriented programming \nsimpler and more productive. For example, Microsoft s LINQ [20] extends the .NET languages to enable \nquerying any data source that supports the IEnumerable interface using a simple, convenient syntax. LINQ \ndiffers from Forest in that it does not provide support for declaratively specifying the structure of, \nand then ingesting, .le\u00adstores. As a second example, Type Providers [28], an experimental feature of \nF#, help programmers materialize standard data sources equipped with prede.ned schemas (such as XML documents \nor databases) in memory in an F# program. Type Providers do not themselves provide a new means for describing \ndata sources (as Forest does). Several XML-based languages for specifying .le formats, .le organization \nand .le locations have been proposed. One example of such a language is XFiles [1]. XFiles uses RDF speci.cations \nto de\u00adscribe the location, permissions, ownership, and other attributes of .les, as well as the name \nof an application capable of parsing spe\u00adci.c .les. The key difference between XFiles and Forest is that \nFor\u00adest is tightly integrated into a general-purpose, conventional pro\u00adgramming language. Forest declarations \ngenerate types, functions and data structures that materialize the data within a surrounding Haskell \nprogram while XFiles does not interoperate directly with a conventional programming language. A recent \nMSc thesis by Ntzik proposes using an extension of context logic [2] to reason about the effects of updates \nmade to .le systems using standard POSIX commands [24]. The core goal of Ntzik s work is to create a \nnew kind of Hoare Logic, and consequently, it is quite different from Forest. The round-tripping properties \nthat core Forest programs obey are based on laws that have been proposed in the context of well\u00adbehaved \nbidirectional transformations, often called lenses [10]. As far as we are aware, lenses for .le systems \nhave not been developed but some of the same fundamental issues that arise in core Forest have been studied \nby Hu and his colleagues, including languages that handle data with internal dependencies [23] and ones \nthat handle graph structures [17]. 9. Conclusions In this paper, we propose the idea of extending a modern, \nhigh\u00adlevel programming language with tightly integrated features for processing coherent .le system fragments, \nwhich we call .lestores. To demonstrate the potential of this idea, we designed Forest, a domain-speci.c \nlanguage embedded in Haskell for describing and managing .lestores. The Forest design has been informed \nby both theoretical analy\u00adsis and practical experience. On the theoretical side, we developed a formal \ncalculus that models the core Forest functionality and we proved that our calculus obeys round-tripping \nlaws derived from previous work on bi-directional programming paradigms. On the practical side, we illustrated \nthe utility of our design by describing several example .lestores, and showing how to use these descrip\u00adtions \nto build simple Haskell scripts that query, analyze, and trans\u00adform the example data in useful ways. \nWe also provided evidence that Forest has effective support for building generic, description\u00addirected \ntools by implementing a number of such tools ourselves, including a .lestore visualizer, a generic query \ninterface, an access control checker, and (circularly) a simple description inference en\u00adgine. An ancillary \nbene.t of this engineering work is that it serves as an extensive case study in domain-speci.c language \ndesign, and, as such, inspired changes in the design of Template Haskell. For further information about \nForest, we direct readers to the Forest web site [9], where they may .nd our open source imple\u00ad mentation \nand a number of additional examples. Acknowledgments We wish to thank Simon Peyton Jones for extending \nHaskell s quasiquoting mechanism to support the Forest design and for as\u00adsisting us in its use, John \nLaunchbury for helping us design and implement Pads/Haskell, and the anonymous ICFP reviewers for many \ninsightful comments and suggestions. This work was supported in part by the NSF under grant CCF\u00ad1016937, \nthe ONR under grant N00014-09-1-0652, and the NSFC under grant 6103302. Any opinions, .ndings, and recommenda\u00adtions \nexpressed in this material are those of the authors and do not necessarily re.ect the views of these \nagencies. References [1] S.-C. Buraga. An XML-based semantic description of distributed .le systems. \nIn RoEduNet, pages 41 48, 2003. [2] C. Calcagno, P. Gardner, and U. Zarfaty. Context logic and tree update. \nIn POPL, pages 271 282, 2005. [3] Filesystem Hierarchy Standard Group. Filesystem hierarchy standard. \nhttp://www.pathname.com/fhs/, 2004. [4] K. Fisher, N. Foster, D. Walker, and K. Q. Zhu. Forest 1.0: A \nLanguage and Toolkit for Programming with Filestores. Technical Report TR\u00ad904-11, Princeton University, \nJune 2011. [5] K. Fisher and R. Gruber. PADS: A domain speci.c language for processing ad hoc data. In \nPLDI, pages 295 304, June 2005. [6] K. Fisher, Y. Mandelbaum, and D. Walker. The next 700 data descrip\u00adtion \nlanguages. In POPL, Jan. 2006. [7] K. Fisher, Y. Mandelbaum, and D. Walker. The next 700 data descrip\u00adtion \nlanguages. JACM, 57:10:1 10:51, February 2010. [8] K. Fisher and D. Walker. The PADS project: An overview. \nIn Pro\u00adceedings of the 14th International Conference on Database Theory, ICDT 11, pages 11 17, New York, \nNY, USA, 2011. ACM. [9] Forest: A language and toolkit for programming with .le system fragments. http://forestproj.org, \n2010. [10] J. N. Foster, M. B. Greenwald, J. T. Moore, B. C. Pierce, and A. Schmitt. Combinators for \nbidirectional tree transformations: A lin\u00adguistic approach to the view update problem. TOPLAS, 29(3), \nMay 2007. [11] M. J. Freedman. Experiences with CoralCDN: A .ve-year operational view. In NSDI, pages \n7 7, 2010. [12] M. J. Freedman, E. Freudenthal, and D. Mazieres. Democratizing content publication with \nCoral. In NSDI, pages 18 18, 2004. See also http://www.coralcdn.org/. [13] E. R. Gansner and S. C. North. \nAn open graph visualization system and its applications to software engineering. Softw. Pract. Exper., \n30:1203 1233, September 2000. [14] Haskell Graphviz Package. http://hackage.haskell.org/ package/graphviz. \n[15] Haskell Source Extensions Package. http://hackage. haskell.org/package/haskell-src-exts. [16] Haskell \nSource Meta Package. http://hackage.haskell. org/package/haskell-src-meta. [17] S. Hidaka, Z. Hu, K. \nInaba, H. Kato, K. Matsuda, and K. Nakano. Bidirectionalizing graph transformations. In ICFP, pages 205 \n216, 2010. [18] R. L\u00a8ammel and S. P. Jones. Scrap your boilerplate: A practical design pattern for generic \nprogramming. In TLDI, pages 26 37, 2003. [19] D. Leijen and E. Meijer. Parsec: Direct style monadic parser \ncombina\u00adtors for the real world. Technical Report UU-CS-2001-27, Department of Computer Science, Universiteit \nUtrecht, 2001. [20] LINQ: .NET language-integrated query. http://msdn. microsoft.com/library/bb308959.aspx, \nFeb. 2007. [21] G. Mainland. Why it s nice to be quoted: Quasiquoting for Haskell. In Haskell Workshop, \npages 73 82, 2007. [22] Y. Mandelbaum, K. Fisher, D. Walker, M. Fern\u00b4andez, and A. Gleyzer. PADS/ML: \nA functional data description language. In POPL, Jan. 2007. [23] S.-C. Mu, Z. Hu, and M. Takeichi. An \nalgebraic approach to bi\u00addirectional updating. In APLAS, pages 2 20, Nov. 2004. [24] G. Ntzik. Local \nreasoning for .lesystems. Master s thesis, Imperial College, Sept. 2010. [25] PADS project. http://www.padsproj.org/, \n2007. [26] T. J. Parr and R. W. Quong. ANTLR: A predicated LL(k) parser generator. Softw. Pract. Exper., \n25(7):789 810, July 1995. [27] T. Sheard and S. P. Jones. Template meta-programming for Haskell. In Haskell \nWorkshop, pages 1 16, 2002. [28] D. Syme. Looking Ahead with F#: Taming the Data Deluge. Presen\u00adtation \nat the Workshop on F# in Education, Nov. 2010. [29] Template Haskell Extension Proposal. hackage.haskell.org/ \ntrac/ghc/blog/Template%20Haskell%20Proposal.  \n\t\t\t", "proc_id": "2034773", "abstract": "<p>A <i>filestore</i> is a structured collection of data files housed in a conventional hierarchical file system. Many applications use filestores as a poor-man's database, and the correct execution of these applications requires that the collection of files, directories, and symbolic links stored on disk satisfy a variety of precise invariants. Moreover, all of these structures must have acceptable ownership, permission, and timestamp attributes. Unfortunately, current programming languages do not provide support for documenting assumptions about filestores, detecting errors in them, or safely loading from and storing to them.</p> <p>This paper describes the design, implementation, and semantics of Forest, a new domain-specific language for describing filestores. The language uses a type-based metaphor to specify the expected structure, attributes, and invariants of filestores. Forest generates loading and storing functions that make it easy to connect data on disk to an isomorphic representation in memory that can be manipulated as if it were any other data structure. Forest also generates metadata that describes the degree to which the structures on the disk conform to the specification, making error detection easy. In a nutshell, Forest extends the rigorous discipline of typed programming languages to the untyped world of file systems.</p> <p>We have implemented Forest as an embedded domain-specific language in Haskell. In addition to generating infrastructure for reading, writing and checking file systems, our implementation generates type class instances that make it easy to build generic tools that operate over arbitrary filestores. We illustrate the utility of this infrastructure by building a file system visualizer, a file access checker, a generic query interface, description-directed variants of several standard UNIX shell tools and (circularly) a simple Forest description inference engine. Finally, we formalize a core fragment of Forest in a semantics inspired by classical tree logics and prove round-tripping laws showing that the loading and storing functions behave sensibly.</p>", "authors": [{"name": "Kathleen Fisher", "author_profile_id": "81331492634", "affiliation": "Tufts University, Medford, MA, USA", "person_id": "P2801431", "email_address": "kfisher@eecs.tufts.edu", "orcid_id": ""}, {"name": "Nate Foster", "author_profile_id": "81444600818", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P2801432", "email_address": "jnfoster@cs.cornell.edu", "orcid_id": ""}, {"name": "David Walker", "author_profile_id": "81100426485", "affiliation": "Princeton University, Princeton, NJ, USA", "person_id": "P2801433", "email_address": "dpw@cs.princeton.edu", "orcid_id": ""}, {"name": "Kenny Q. Zhu", "author_profile_id": "81100413639", "affiliation": "Shanghai Jiao Tong University, Shanghai, China", "person_id": "P2801434", "email_address": "kzhu@cs.sjtu.edu.cn", "orcid_id": ""}], "doi_number": "10.1145/2034773.2034814", "year": "2011", "article_id": "2034814", "conference": "ICFP", "title": "Forest: a language and toolkit for programming with filestores", "url": "http://dl.acm.org/citation.cfm?id=2034814"}