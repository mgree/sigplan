{"article_publication_date": "01-07-2008", "fulltext": "\n Multiparty Asynchronous Session Types Kohei Honda Nobuko Yoshida Marco Carbone Queen Mary, University \nof London Imperial College London Queen Mary, University of London kohei@dcs.qmul.ac.uk yoshida@doc.ic.ac.uk \ncarbonem@dcs.qmul.ac.uk Abstract Communication is becoming one of the central elements in soft\u00adware \ndevelopment. As a potential typed foundation for structured communication-centred programming, session \ntypes have been studied over the last decade for a wide range of process calculi and programming languages, \nfocussing on binary (two-party) sessions. This work extends the foregoing theories of binary session \ntypes to multiparty, asynchronous sessions, which often arise in practical communication-centred applications. \nPresented as a typed calculus for mobile processes, the theory introduces a new notion of types in which \ninteractions involving multiple peers are directly abstracted as a global scenario. Global types retain \na friendly type syntax of binary session types while capturing complex causal chains of mul\u00adtiparty asynchronous \ninteractions. A global type plays the role of a shared agreement among communication peers, and is used \nas a ba\u00adsis of e.cient type checking through its projection onto individual peers. The fundamental properties \nof the session type discipline such as communication safety, progress and session .delity are established \nfor general n-party asynchronous interactions. Categories and Subject Descriptors D.3.1 [Programming \nLan\u00adguages]: Formal De.nitions and Theory; F.3.2 [Semantics of Pro\u00adgramming Languages]: Process models \nGeneral Terms Theory, Types, Design Keywords communications, multiparty, structured programming, session \ntypes, mobile processes, causality, choreography 1. Introduction Backgrounds Communication is becoming \none of the central elements in software development, ranging from web services to business protocols \nto parallel scienti.c computing to multi\u00adcore programming. As a potential typed foundation for struc\u00adtured \ncommunication-centred programming, session types have been studied in many contexts over the last decade, \nincluding calculi of mobile processes (Takeuchi et al. 1994; Gay and Hole 2005; Honda et al. 1998; Bonelli \nand Compagnoni 2008), higher\u00adorder processes (Mostrous and Yoshida 2007), Ambients (Gar\u00adralda et al. \n2006), multi-threaded ML (Vasconcelos et al. 2006), Haskell (Neubauer and Thiemann 2004b), F# (Corin \net al. 2007), operating systems (F\u00a8 ahndrich et al. 2006), Java (Dezani-Ciancaglini et al. 2006; Coppo \net al. 2007; Hu et al. 2007), and Web Ser- Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nvices (Carbone et al. 2006, 2007; WS-CDL; Sparkes 2006; Honda et al. 2007a). A basic observation underlying \nsession types is that a communication-centred application often exhibits a highly struc\u00adtured sequence \nof interactions involving, for example, branching and recursion, which as a whole form a natural unit \nof conversa\u00adtion, or session. The structure of a conversation is abstracted as a type through an intuitive \nsyntax, which is then used as a basis of validating programs through an associated type discipline. As \nan example, the following session type describes a simple business protocol between Buyer and Seller \nfrom Buyer s view\u00adpoint: Buyer sends the title of a book (a string), Seller sends a quote (an integer). \nIf Buyer is satis.ed by the quote, then sends his ad\u00address (a string) and Seller sends back the delivery \ndate (a date); otherwise it quits the conversation. !string;?int;.{ok :!string;?date;end, quit : end} \n(1) Above !t denotes an output of a value of type t, dually for ?t; . denotes a choice of the options; \nand end represents the termination of the conversation. Such explicit representation of conversation \nstructures helps us deal with one of the most common bugs in programming with com\u00admunication, the synchronisation \nbugs. A programmer expects that communicating programs should together realise a consistent con\u00adversation, \nbut they easily fail to handle a speci.c incoming mes\u00adsage or to send a message at the correct timing, \nwith no way to detect such errors before runtime. An explicit speci.cation as in (1) guides principled \nprogramming of communication behaviour and enables automatic protocol validation (WS-CDL; UNIFI; Hu et \nal. 2007). In addition, a clean separation between abstraction and implementation given by type-based \nabstraction and associated primitives leads to intelligible programs and .exible implementa\u00adtions (Hu \net al. 2007). Underlying these merits are the following central properties guaranteed by session types. \n1. Interactions within a session never incur a communication error (communication safety). 2. Channels \nfor a session are used linearly (linearity) and are deadlock-free in a single session (progress). 3. \nThe communication sequence in a session follows the scenario declared in the session type (session .delity, \npredictability).  Multiparty Asynchronous Sessions The foregoing studies on session types have focussed \non binary (two-party) sessions. While many conversation patterns can be captured through a composi\u00adtion \nof binary sessions, there are cases where binary session types are not powerful enough for describing \nand validating interactions which involve more than two parties. As an example, let us consider a simple \nre.nement of the above for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. POPL 08, January 7 12, 2008, San Francisco, California, \nUSA. Copyright &#38;#169;c2008 ACM 978-1-59593-689-9/08/0001. . . $5.00 Buyer-Seller protocol: consider \ntwo buyers, Buyer1 and Buyer2, wish to buy an expensive book from Seller by combining their money. Buyer1 \nsends the title of the book to Seller, Seller sends to both Buyer1 and Buyer2 its quote, Buyer1 tells \nBuyer2 how much she can pay, and Buyer2 either accepts the quote or receives the quote by notifying Seller. \nIt is extremely awkward (if logically possible) to decompose this scenario into three binary sessions, \nbe\u00adtween Buyer1 and Seller, between Buyer2 and Seller, and between Buyer1 and Buyer2. Abstracting this \nprotocol as three separate ses\u00adsion types also means that our type abstraction loses essential se\u00adquencing \ninformation in this interaction scenario. For validating this conversation scenario as a whole, therefore, \nthe conversation structure should be represented as a single session. Many existing business protocols \nincluding .nancial protocols are written as a collaboration of several peers. Typical message\u00adpassing \nparallel algorithms also frequently demand distribution of a request to, and collection of the results \nfrom, many peers. All these usecases are most naturally abstracted as a single session. Furthermore, \nmany of these applications are implemented with an asynchronous transport where the senders send the \nmessages with\u00adout being blocked (but often preserving their order), to avoid the heavy overhead of synchronisation. \nThe widely used network trans\u00adport, such as TCP, provides this mechanism through familiar APIs to alleviate \nthe latency problem. Thus we ask: can we generalise the foregoing binary session types to multiparty \nasynchronous sessions preserving clarity and their key formal properties? This question was repeatedly \nposed by not only researchers but also the members of a W3C working group (WS-CDL) through our collaboration \nas invited experts (Honda et al. 2007a; Carbone et al. 2006, 2007), be\u00adcause of urgent need for a theoretical \nbasis to validate a wide range of business protocols. Challenges of Multiparty Asynchronous Sessions \nTo answer this open question, we face two major technical di.culties. First, simplicity and tractability \nof the theory of binary sessions come from a notion of duality in interactions (Girard 1987). Consider \nthe binary session type given in (1) for Buyer. Not only Buyer s be\u00adhaviour can be checked against the \nsession type, but also the whole conversation structure is already represented in this single type, since \nthe interaction pattern of Seller is fully given as this type s dual (exchanging input and output and \nbranching and selection in the original type). When composing two parties, we only have to check they \nhave mutually dual types. This framework based on du\u00adality is no longer e.ective in multiparty sessions \nwhere the whole conversation cannot be constructed from only single behaviour. We need an e.ective means \nto abstract as a type a global scenario which a programmer wishes to realise through interacting programs \n(hence against which she would wish to check their correctness), and establish an e.ective method to \nensure composability. Second, linearity analysis of channels, which is the key to en\u00adsure safety and \nprogress, becomes highly involved under a com\u00adbination of asynchrony and multiparty since a con.ict of \nactions can arise more easily. This demands a precise causal analysis for correct sequencing of interactions \ndistributed among multi-peers. This Work. This paper presents a generalisation of binary session types \nto multiparty sessions for the p-calculus. We overcome the aforementioned challenges with the following \nthree technical ap\u00adparatus: 1. A new notion of types which can directly abstract intended con\u00adversation \nstructure among n-parties as global scenarios, retain\u00ading intuitive type syntax. 2. Consistency criteria \nfor a conversation structure given as a causality analysis of actions in global types, modularly artic\u00adulating \ndi.erent kinds of dependency. 3. A type discipline for individual processes (programs) which uses a \nglobal type through its projection onto individual local participants: the resulting local types are \ndirectly associated with individual processes for e.cient type checking.  The idea of type abstraction \nbased on a global view (Point 1) comes from an abstract version of choreography developed in a W3C web \nservices working group (Carbone et al. 2006; WS-CDL). Causality structures in asynchronous interactions \nare precisely and modularly captured in the abstract setting of global types, o.ering a foundation for \nthe type discipline (Point 2). Through the use of global types, we can stipulate a new e.ective method \nfor designing and type-checking multiparty sessions (Point 3). First, we design a global type G as an \nintended scenario. A team of programmers then develop code, one for each participant, incrementally validating \nits conformance to (the projection of) G. When programs are executed, their interactions automatically \nfollow the stipulated scenario. For materialising this design framework, we propose a type discipline \nwhich can validate whether a program is typable or not, given G (as shared agreement) and an individual \nprogram (as its local realiser). The resulting type discipline guarantees all the original key properties, \nsuch as communication error freedom, progress and .delity in a session among multiparty. In the remainder, \nSection 2 gives the syntax and semantics of the calculus, and motivates the key ideas through business \nand streaming protocol examples. Section 3 explains the global types. Section 4 describes the typing \nsystem. Section 5 establishes the main results. Section 6 gives extensions and related works. Section \n7 concludes with future issues. The omitted de.nitions, proofs and large size of examples are left in \n(Honda et al. 2007b). 2. Multiparty Asynchronous Sessions 2.1 Syntax for Multiparty Sessions Several \nversions of the p-calculi with session types are proposed in the literature; the paper (Yoshida and Vasconcelos \n2007) o.ers detailed discussions and analysis of their typing systems. We use a simple extension of the \noriginal language in (Honda et al. 1998; Takeuchi et al. 1994) to multiparty sessions. Informally, a \nsession is a series of interactions which serve as a unit of conversation. A session is established among \nmulti\u00adple parties via a shared name, which represents a public interac\u00adtion point. Then fresh session \nchannels are generated and shared through which a series of communication actions are performed. We use \nthe following base sets: shared names or names, ranged over by a,b,x,y,z,...; session channels or channels, \nranged over by s,t,...; labels, ranged over by l,l. ,...;and process variables, ranged over by X,Y,.... \nIn the syntax for hiding, we use n for either a single shared name or a vector of session channels. Then \nprocesses, ranged over by P,Q...,and expressions, ranged over by e,e. ,..., are given by the grammar \nin Figure 1. Except for the .rst two primitives for session initiation and the .nal message queue, all \nconstructs are from (Honda et al. 1998). The pre.x a[2..n]( s).P initiates a new session through a shared \ninteraction point a, by distributing a vector of freshly generated session channels s to the remaining \nn -1 participants, each of shape a[p]( s).Qp for 2 = p = n. All receive s, over which the actual session \ncommunications can now take place among the n parties. p, q,... range over natural numbers called participants \nof a session. Session communications are performed using the next three pairs of primitives: the sending \nand receiving, the session delega\u00adtion and reception (the former delegates to the latter the capability \nto participate in a session by passing the whole channels associ\u00adated with the session), and the selection \nand branching (the former chooses one of the branches o.ered by the latter). The next three (the conditional, \nparallel and inaction) are standard. (.a)P makes a local to P while (.s )P makes s local to P. The recursion \nand process call realise recursive behaviour. s : h isa message queue represent\u00ading ordered messages \nin transit h with destination s (which may be considered as a network pipe in a TCP-like transport). \n(.s )P and Figure 1 Syntax P ::= a[2..n]( s).P multicast session request | a[p]( s).P session acceptance \n| s!( e ) ; P value sending | s?( x); P value reception | s!(( s )) ; P session delegation | s?(( s)); \nP session reception | s < l; P label selection | s I { li : Pi} i. I label branching | if e then P else \nQ conditional branch | P | Q parallel composition | 0 inaction | (. n)P hiding | def D in P recursion \n| X( e s ) process call | s:h message queue e ::= v | e and e;| not e ... expressions v ::= a | true \n| false values h ::= l | v | s messages-in-transit D ::= { Xi( xis i) = Pi} i. I declaration for recursion \ns : h only appear at runtime. We often omit trailing 0 and write s! and s?.P, omitting the arguments \nif unnecessary. Binders are s in a[2..n]( s).P, a[p]( s).P and s?(( s)); P, x in s?( x); P, x s in X( \nxs ) = P, n in (. n)P and process variables in def D in P.The notions of bound and free identi.ers, channels, \nalpha equivalence = a and substitution are standard. fpv(P)and fn(P), respectively denote the sets of \nfree process variables and free identi.ers in P. dpv({ Xi( xis i) = Pi} i. I ) denotes the set of process \nvariables { Xi} i. I introduced in { Xi( xis i) = Pi} i. I . A sequence of parallel composition is written \n.iPi. 2.2 Operational Semantics Structural congruence is the smallest congruence relation on pro\u00adcesses \nthat includes the equations in Figure 2. The operational se\u00admantics is given by the reduction relation, \ndenoted P . Q,which is the smallest relation on processes generated by the rules in Fig\u00adure 3. In the \n.gure, e . v says that expression e evaluates to values v. [Link] describes a session initiation among \nn-parties through synchronisation, generating m fresh session channels and the asso\u00adciated m empty queues \n(\u00d8 denotes the empty string). As a result n participants now share the newly generated m channels, hence \ntheir queues. Note the number of threads (n) can be di.erent from that of session channels (m), giving \n.exibility in channel usage. [Send], [Deleg]and [Label] respectively enqueue values, chan\u00adnels and a \nlabel at the tail of the queue for s.[Recv], [SRec]1 and [Branch] dequeue, at the head of the queue, \nvalues, channels and a label. [Branch] further selects the corresponding branch. Since [Link] provides \na queue for each channel, these rules say that a sending action is never blocked (asynchrony) and that \ntwo mes\u00adsages from the same sender to the same channel arrive in the send\u00ading order (order preservation). \nOther rules are standard. 1 This delegation rule (which is from (Honda et al. 1998)) is chosen over the \nmore liberal one in (Gay and Vasconcelos 2007; Yoshida and Vasconcelos 2007) (which uses substitution \nas in [Recv]) for simpler presentation. The technical development does not depend on this choice, see \n\u00a7 6.2. Figure 2 Structural congruence. P | 0 = PP | Q = Q | P (P | Q) | R = P | (Q | R) def D in (def \nD; in P) = def D and D; in P if dpv(D) n dpv(D; ) = \u00d8 (. n)P | Q = (. n)(P | Q) if n r fn(Q) (. n)0 = \n0 def D in 0 = 0 (. nn; )P = (. nn)P; (. s1..sn).i si : \u00d8= 0 def D in (. n)P = (. n)def D in P if n r \nfn(D) (def D in P) | Q = def D in (P | Q) if dpv(D) n fpv(Q) = \u00d8  2.3 Examples Two Buyer Protocol We \ndescribe the two-buyers-protocol from the Introduction .rst by a sequence diagram, then by processes. \n First Buyer1 sends a book title to Seller, then Seller sends back a quote to Buyer1/2; Buyer1 now tells \nBuyer2 how much she can contribute, and Buyer2 noti.es Seller if it accepts the quote or not. We now \ndescribe the behaviour of Buyer1 as a process: def Buyer1 = a[2, 3](b1, b2, b;2, s). s!( War and Peace \n) ; b1?(quote); b;2!( quote div 2) ; P1 Channel b1 is for Buyer1 to receive messages: b2 and b;for Buyer2 \n2 and s for Seller (we discuss soon why Buyer2 needs two receiving channels). Buyer1 above is willing \nto contribute to half of the quote. In P1, Buyer1 may perform the remaining transactions with Seller \nand Buyer2. The remaining participants follow. def Buyer2 = a[2](b1, b2, b;2, s). b2?(quote); b;2?(contrib); \nif (quote - contrib = 99) then s < ok; s!( address) ;b2?(x); P2 else s < quit;0 def Seller = a[3](b1, \nb2, b2;, s). s?(title); b1, b2!( quote) ; s I { ok : s?(x);b2! ( date) ; Q, quit : 0} Above s1..sm!( \nv) ; P stands for s1!( v) ;..sm!( v) ; P, assuming s1..sm are pairwise distinct.2 We can now explain \nwhy Buyer2 needs to use two input channels, b2 and b;. The .rst input (for quote) is from 2Seller, while \nthe second one (for contrib) is from Buyer1. Hence there is no guarantee that they arrive in a .xed order, \nas can be easily seen by analysing reduction paths (this is Lamport s principle (Lamport 1978)). Thus \nif we were to use b2 for both actions, the two messages can be confused, losing linear usage of a channel. \nLater we shall show our type discipline can detect such an error. 2 Due to asynchrony there is in e.ect \nno order among the sending actions at s1..sm. Figure 3 Reduction a[2..n]( s).P1 |a[2]( s).P2 |\u00b7\u00b7\u00b7|a[n]( \ns).Pn [Link] . (. s )(P1 | P2 |... | Pn | s1:\u00d8|\u00b7\u00b7\u00b7| sm :\u00d8) s!(e ); P | s: h . P | s:h \u00b7v ( e .v ) [Send] \ns!((t )); P | s : h .P | s:h \u00b7t [Deleg] s < l; P | s : h .P | s:h \u00b7l [Label] s?( x); P | s : v \u00b7h . P[ \nv/x ] | s :h [Recv] s?((t )); P | s : t \u00b7h . P | s:h [SRec] s I {li : Pi}i.I | s:lj \u00b7h . Pj | s:h ( \nj .I) [Branch] if e then P else Q . P (e .true) [IfT] if e then P else Q . Q (e .false) [IfF] def D in \n(X(e s )| Q) . def D in (P[ v/x ] | Q) [Def] ( e .v ,X( xs ) = P . D) P .P;. (. n)P .(. n)P; [Scop] P \n. P;. P | Q . P;|Q [Par] P .P;. def D in P . def D in P; [Defin] P =P; and P;.Q; and Q;= Q . P .Q [Str] \nA Streaming Protocol We next consider a simple protocol for the standard stream cipher (Schneier 1993). \n Data Producer and Key Producer continuously send a data stream and a key stream respectively to Kernel. \nKernel calculates their XOR and sends the result to Consumer. Assuming streams are sent block by block \n(say as large arrays), we can realise this protocol as communicating processes. We only focus on communication \nbehaviour. The kernel initiates a session: def Kernel = def K(d,k,c) = d?(x); k?(y); c!(x xor y);K(d,k,c) \nin a[2,3,4](d,k,c).K(d,k,c) The channels d and k are used for Kernel to receive data and keys from Data \nProducer and Key Producer, respectively, while c is used for Consumer to receive the encrypted data from \nKernel. Data Producer and Consumer can be given as: def DataProducer = def P(d,k,c) = d!(data);P(d,k,c) \nin a[2](d,k,c).P(d,k,c)def Consumer = def C(d,k,c) = c?(data);C(d,k,c) in a[3](d,k,c).C(d,k,c) Key Producer \nis identical to Data Producer except it outputs at k instead of d. When three processes are composed, \nwe can verify that, although processes repeatedly send and receive data using the same channels, messages \nare always consumed in the order they are produced, an essential requirement for correctness of the protocol. \nThis is because each channel is used by exactly one sender. We shall show how this argument can be cleanly \nrepresented and validated through session types in the subsequent two sections. Figure 4 Syntax of Global \nTypes Global G ::= p .p;: k (U).G; values | p .p;: k {lj : Gj}j.J branching | G,G; parallel | \u00b5t.G recursive \n| t variable | end end Value U ::= S | T @p Sort S ::= bool | nat | ... |(G)   3. Global Types and \nCausal Analysis Developing programs for multiparty sessions demands a clear for\u00admal design as to how \nmultiple participants communicate and syn\u00adchronise with each other. To program individual participants \nwith\u00adout such a design and hope they somehow realise a meaningful and error-free conversation is hardly \npractical, especially for team pro\u00adgramming. In binary session types the type for an endpoint also served \nas the description of the whole conversation, but this is no longer possible for multiparty sessions. \nThis is why we need the type abstraction which describes global conversation scenarios of multiparty \nsessions, introduced in this section. 3.1 Session Types from a Global Viewpoint The grammar of global \nsession type,or global type, denoted G,G;,..., is given in Figure 4. Type p . p;: k (U).G; says that \nparticipant p sends a message of type U to channel k (represented as a .nite natural number) received \nby participant p;: and inter\u00adactions described in G; takes place. U,... range over value types, denoting \ntypes for message values. Each value type is a vector of types for shared names called sorts, written \nS,S ;,...,orofthose for session channels. Both of these types are discussed in detail in \u00a7 4.2. For understanding \nthis section, it su.ces to consider U as a single base type. Type p . p;: k {lj : Gj}j.J says participant \np sends one of the labels to channel k which is then received by participant p;.If lj is sent, interactions \ndescribed in Gj take place. Type G,G; represents concurrent run of interactions speci.ed by G and G;. \nType \u00b5t.G is a recursive type for recurring conver\u00adsation structures, assuming type variables (t,t;,...) \nare guarded in the standard way, i.e. type variables only appear under the pre.xes (hence contractive). \nWe take an equi-recursive view, not distin\u00adguishing between \u00b5t.G and its unfolding G[\u00b5t.G/t] (Pierce \n2002). We assume that (G) in the grammar of sorts is closed, i.e. without type variables.3 Type end represents \nthe termination of the session. We identify G,end and end,G with G. Definition 3.1 (pre.x). We say the \ninitial p . p; : k in p . p;: k (U).G; and p . p;: k {lj : Gj}j.J is a pre.x from p to p; at k over G; \nwhere in the former U is a carried type.If U is a carried type in a pre.x in G then U is also a carried \ntype in G. ; Conventions 3.2. We assume that in each pre.x from p to pwe have p . p;, i.e. we prohibit \nre.exive interaction. Henceforth we often regard a global type G as the acyclic directed graph given \nby its standard regular tree presentation (Pierce 2002). A basic ordering on its nodes is induced by \npre.xes. ; Definition 3.3 (pre.x ordering). Write n,n,.. for pre.xes occur\u00adring in a global type, say \nG (but not in its carried types), seen as nodes of G as a graph. We write n .G when n occurs in G.Then \n3 In the presence of the standard recursive sorts (Honda et al. 1998), which we omit for simpler presentation, \nwe allow sort variables to occur in (G). Figure 5 Causality Analysis (II) Good (II)Bad (IO) Good (IO)Bad \n(OO, II) Good (OI)Bad A .B : s A .B : s A .B : s A .B : s A .B : s A .B : s C .B : t C .B : s B .C : \nt B .C : s A .B : s C .A : s s! | s?;t? |t! s! | s?; s? | s! s! | s?; t! |t? s! | s?; s! | s? s!; s! \n| s?; s? s!; s? | s? | s! we write n1 .n2 .G when n1 directly or indirectly pre.xes n2 in G. Formally \n. is the least partial order including: n1 .n2 .p .p;: k (U).G; if n1 = p .p; : k, n2 .G; n1 .n2 .p .p;: \nk {lj : Gj}j.J if n1 = p .p; : k, .i .J. n2 .Gi as well set setting n1 .n2 .G if n1 .n2 .G; and G; occurs \nin G but not in its carried types. The pre.x ordering allows us to express intended sequencing in global \ntypes. To clarify its meaning is essential for its proper usage. Consider a global type: A .B : s (U). \nA .C : t (U;). end (2) The two pre.xes are ordered by .. In a synchronous interpre\u00adtation, this ordering \nwould mean: only after the .rst sending and receiving take place, the second sending and receiving take \nplace . This is a suitable reading when sending and receiving constitute a single atomic action, as in \nsynchronous calculi, but not with asyn\u00adchronous communication, where it is hard to impose this ordering \non (2), since messages to distinct channels may not arrive in order. Thus the present theory takes the \nmore liberal interpretation of ., imposing sequencing only on the actions of the same participant in \nordered pre.xes. For example, in (2), A s two sending actions are ordered, but B s and C s receiving \nactions are not. The remaining causal ordering comes from communication ` ala Lamport (Lamport 1978). \nLet us further illustrate this idea with examples.  3.2 Examples of Global Types The following is a \nglobal type of the two-buyer-protocol in \u00a72.3. We write principals and channels with legible symbols \nthough they are actually numbers: Bi = i, S = 3, b1 = 1, b2 = 2, b;2 = 3and s = 4. 1 B1 .S : s(string). \n2 S .B1 : b1(int). 3 S .B2 : b2(int). 4 B1 .B2 : b;(int). 2 5 B2 .S : s{ok : B2 .S : s (string).S .B2 \n: b2 (date).end, quit : end} The type gives a vantage view of the whole conversation scenario. We show \nseveral salient points in the interpretation of this type. Consider Lines 3 and 4. Since they have di.erent \nsenders, the sending actions are unordered in spite of their .-ordering. Hence if b2 = b2;two messages \ncan have a con.ict at s.Note this analysis echoes our operational argument in \u00a72.3.  Next we consider \nthe following causal chain of actions from Line 1 to Line 3 to Line 5:  B1 . S . S . B2 . B2 .S Above \n.denotes the ordering given by message delivery, while . is the pre.x ordering. Note in particular two \nsending actions by B1 (Line 1) and by B2 (Line 5), both done at s, are causally ordered. By focussing \non . from the .rst S (ofLine1)to the last S (of Line 5), the receiving actions in Lines 1 and 5 are also \nordered. Since both sending and receiving take place in strict temporal order, no con.ict occurs between \nthese two communications in spite of their use of a common channel s. Next we present the global type \nof the simple streaming protocol in \u00a72.3. Below we unfold its recursion once, and set: d = 1, k = 2, \nc = 3, K = 1, DP = 2, C = 3and KP = 4. 1 \u00b5t. DP .K : d (bool). 4 DP .K : d (bool). 2 KP .K : k (bool). \n5 KP .K : k (bool). 3 K .C : c (bool). 6 K .C : c (bool).t The following arguments hold for any n-fold \nunfoldings. Lines 1 and 2 are temporally unordered in sending: but this does not cause con.ict since \nchannels d and k are distinct.  Line 1 and its unfolding, Line 4, share d. But the two use the same \nsender and the same receiver, so each pair of actions are .-ordered, hence safe. Similarly for other \nunfolded actions.  3.3 Safety Principle for Global Types For a conversation in a session to proceed \nproperly, it is desirable that there is no con.ict (racing) at session channels. To ensure this, when \na common channel is used in two communications, their send\u00ading actions and their receiving actions should \nrespectively be or\u00addered temporally, so that no confusion arises at neither sending nor receiving. If \na global type satis.es this principle, then it speci.es a safe protocol, and can be used as a basis of \nguaranteeing safe process behaviours through type checking. Causality is induced in several ways in the \npresent asynchronous model. We summarise all essential cases in Figure 5, with concrete process instances \nfor illustration. IO denotes the causal ordering by .is from input (receiving) to output (sending), similarly \nfor II, OO and OI.In(II)-Bad, we demand A . C. We observe: The good and bad cases for II shows that \nII alone is safe only when two channels di.er. Similarly for IO.  In OO,II (the .fth case), two outputs \nhave the same sender and the same channel, so (by message order-preservation) outputs are ordered. Inputs \nare also ordered by . hence they are safe.  There is no ordering from output to input (due to asynchrony), \nso OI gives us no dependency.  These observations lead to the following e.ective causal rela\u00adtions on \nglobal types. Definition 3.4. (dependency relations) Fix G. The relation .f, with f .{II, IO, OO}, over \nits pre.xes is generated from: n1 .II n2 if n1 .n2 and ni = pi .p : ki (i = 1, 2) n1 .IO n2 if n1 .n2, \nn1 = p1 .p : k1 and n2 = p .p2 : k2. n1 .OO n2 if n1 .n2, ni = p .pi : k (i = 1, 2) An input dependency \nfrom n1 to n2 is a chain of the form n1 .f1 \u00b7\u00b7\u00b7.fn n2(n =0) such that fi .{II, IO} for 1 =i =n -1and \nfn = II. An output dependency from n1 to n2 is a chain n1 .f1 \u00b7\u00b7\u00b7 .fn n2 (n =1) such that fi .{OO, IO}. \nIn the input dependency, the last II-ordering is needed since if it ends with an IO-edge an input at \nn2 may not be suppressed. ; Definition 3.5. (linearity) G is linear if, whenever ni = pi .p: k (i = 1, \n2) are in G for some k and do not occur in di.erent branches of a branching, then both input and output \ndependencies exist from Figure 6 Syntax of Local Types Value U ::= S | T@p Sort S ::= bool | ... |(G)Local \nT ::= k!(U); T send | k?(U);T receive | k .{li : Ti}i.I selection | k&#38;{li : Ti}i.I branching | \u00b5t.T \n| t | end n1 to n2, or, if not, both exist from n2 to n1.If G carries other global types, we inductively \ndemand the same. We illustrate the condition on branching by an example: 1. A .B : t{ok : C .D : s.end \nA .B : t.(C .D : s.end, 2. quit : C .D : s.end } C .D : s.end) (a) branching (b) parallel The type (a) \nrepresents branching: since only one of two branches is selected, there is no con.ict between the two \npre.xes C .D : s in Lines 1 and 2. On the other hand, (b) means a concurrent execution of two independent \nC .D : s, so an input con.ict at D exists. Linearity and its violation can be detected algorithmically, \nwith\u00adout in.nite unfoldings. First we observe we do need to unfold once. \u00b5X.(A .B : s.end, B .A : t.X) \nThis is linear in its 0-th unfolding (i.e. we replace X with end): but when unfolded once, it becomes \nnon-linear, as follows: A .B : s.end, B .A : t.\u00b5X.(A .B : s.end, B .A : t.X) since the two pre.xes A \n. B : s appear in parallel. But in fact unfolding once turns out to be enough. Taking G as a syntax, \nlet us call the one-time unfolding of G the result of unfolding once for each recursion in G (but never \nin carried types), and replacing the remaining variable with end. Proposition 3.6. (1) A global type \nis linear i. its one-time unfold\u00ading is linear. (2) The linearity of a global type is decidable. (2) \nis an immediate corollary of (1). For (1), we show if one-time unfolding is linear then each n-th folding \nis linear by induction on n, using tail recursiveness of the present global types.  4. Type Discipline \nfor Multiparty Sessions 4.1 Programming Methodology for Multiparty Interactions Once given global types \nas our tool, we can consider the following development steps for programs with multiparty sessions. Step \n1 A programmer describes an intended interaction scenario as global type G, and checks that it is linear. \nStep 2 She develops code, one for each participant, incrementally validating its conformance to the projection \nof G onto each participant by e.cient type-checking. When programs are executed, their interactions are \nguaranteed to follow the stipulated scenario. The type speci.cation also serves as a basis for maintenance \nand upgrade. This section introduces the type discipline which materialises this framework. 4.2 Local \nTypes Syntax Local session types or local types, ranged over by T, T ;,.., are types for local behaviour \nof processes, acting as a link between global types and processes. The grammar is given in Figure 6 (the \ngrammars for U and S are repeated from Figure 4). All constructs come from the binary session types (Honda \net al. 1998) except for the following major changes for multiparty interactions. Since a process now \nuses multiple channels for addressing multiple parties, a session type records the identity (number) \nof a session channel it uses at each action type.  Since a type is inferred for each participant, we \nuse a notation T @p (called located type) representing a local type T assigned to participant p. A located \ntype is also used for delegation.  Type k?(U);T represents the behaviour of inputting values of type \nU at sk (assume s1...sn is shared at initialisation), then performing the actions represented by T. Similarly \nk!(U);T is for sending. Type k&#38;{li : Ti}i.I describes a branching: it waits with n options at k, \nand behave as type Ti if i-th label is selected; type k .{li : Ti}i.I represents the behaviour which \nselects one of the labels say li at k then behaves as Ti. The rest is the same as the global types, demanding \ntype variables occur guarded by a pre.x and taking an equi-recursive approach for recursive types. We \noften omit end. Note local type T does not contain parallel composition. In addition to the folding/unfolding \nof recursive types, local types are considered up to the following isomorphism (closed under all type \nconstructors). We assume k * k;, m .I and n . J. k!(U); k;! (U;);T k;!(U;);k! (U);T (3) k .{li :k;.{l;j \n:Tij}j.J }i.I k;.{l;j :k .{li :Tij}i.I }j.J (4) The equations permute two consecutive outputs with di.erent \nsub\u00adjects, capturing asynchrony in communication. The equation (4) specialises to permutation between \nselection and output by setting I or J a singleton: and to (3) when both are singletons. Projection and \nCoherence The following de.nes the projection of a global type to local types at each participant. Definition \n4.1 (Projection). Let G be linear. Then the projection of G onto p, written G dp, is inductively given \nas: (p1 .p2 : k (U).G;) dp = . . . k!(U).(G;dp)if p = p1 * p2 . . . . k?(U).(G;dp)if p = p2 * p1 . . \n. . (G;dp) if p * p2 and p * p1 (p1 .p2 : k {lj : Gj}j.J )dp = . . ..{lj :(Gj dp)}j.J if p = p1 * p2 \n. . . . .&#38;{lj :(Gj dp)}j.J if p . = p2 * p1 . . .(G1dp) if p * p2 and p * p1 . . . . . and .i, j \n.I.Gi dp = Gj dp (G1,G2)dp = { Gi dp if p .Gi and p r Gj, i * j .{1, 2} end if p r G1 and p r G2 (\u00b5t.G)dp \n= \u00b5t.(G dp), t dp = t,and end dp = end. When a side condition does not hold the map is unde.ned. The \nmapping is intuitive. We regard the map to act on the syntax of global types. In the branching, all projections \nshould generate an identical local type (otherwise unde.ned); and in parallel com\u00adposition, p should \nbe contained in at most a single type, ensuring each type is single-threaded. Below pid(G) denotes the \nset of par\u00adticipant numbers occurring in G (but not in carried types). In (2) Tp @p appeared at the beginning \nof \u00a74.2. Definition 4.2 (Coherence). (1) We say G is coherent if it is linear and G d p is well-de.ned \nfor each p . pid(G), similarly for each carried global type inductively. (2) {Tp @p}p.I is coherent if \nfor some coherent G s.t. I = pid(G), we have G dp = Tp for each p .I. Theorem 4.3. Coherence of G is \ndecidable. We also believe the coherence of {Tp @p}p is decidable but this is not necessary for the present \ntechnical development. Without projectability, a global type is not consistent. Linearity guarantees \nlinear channel usage including message-order preservation. The next examples demonstrate the need of \nthese conditions. Examples of Coherence The following global type is linear but not coherent because \nthe projection is unde.ned. A . B : k{ok : C . D : k;(bool), quit : C . D : k;(nat)} Intuitively, when \nwe project this type onto C or D, regardless of the choice made by A, they should behave in the same \nway: participants C and D should be independent threads. If we change the above nat to bool as: A . B \n: k{ok : C . D : k;(bool), quit : C . D : k;(bool)},we can de.ne the coherent projection as follows: \n{ k .{ok : end, quit : end}@A, k&#38;{ok : end, quit : end}@B k;!(bool)@C, k;?(bool)@D } As examples \nof local types which are not coherent, consider pro\u00adcesses in the second case of Figure 5: (II)Bad {s!()@A, \ns?(); s?()@B, s!()@C} This process is not coherent since the corresponding global type A . B : s.C . \nB : s is not linear. 4.3 Typing System The purpose of the typing system introduced below is to e.ciently \ntype behaviours which are built by programmers hence which do not include runtime elements such as queues. \nDefinition 4.4 (program phrase and program). A process P is a program phrase if P has no queues and no \n.-bound session chan\u00adnels. P is a program if P is a program phrase in which no free session channels \nand process variables occur. All of Buyer1, Buyer2, Seller, Data Producer, etc. in \u00a72.3 are programs, \nhence are also program phrases. Environments and Type Algebra The typing system uses a map from shared \nnames to their sorts (S, S ;,..). As given in Figure 6, other than atomic types, a sort has the shape \n(G) assuming G is coherent. Using these sorts we de.ne: G ::= \u00d8| G, u : S | G, X : S T . ::= \u00d8| ., s \n: {T @p}p.I A sorting (G, G;,..) is a .nite map from names to sorts and from process variables to sequences \nof sorts and types. Typing (., .;,..) records linear usage of session channels. In the binary sessions, \nit assigned a type to a single channel; now it assigns a family of located types to a vector of session \nchannels. sid(G) stands for the set of session channel numbers in G. We write s : T @p for a singleton \ntyping s : {T @p}. Below we de.ne a simple algebra of types for typing program phrases. Definition 4.5. \nA partial operator . is de.ned as: {Tp @p}p.I .{T ;; @p;}p;.J = {Tp @p}p.I .{T ;; @p;}p;.J p p if I n \nJ = \u00d8.Thenwesay .1 and .2 are compatible, written .1 \" .2, ifforall si . dom(.i) such that s1 n s 2 * \n\u00d8, s = s 1 = s 2 and .1( s) . .2( s) is de.ned. When .1 \" .2,the composition of .1 and .2, written .1 \n..2, is given as: .1 ..2 = {.1( s) ..2( s) |s . dom(.1) n dom(.2)}..1 \\dom(.2) . .2 \\ dom(.1) In brief \nthis algebra gives the disjoint union of located types which is unde.ned when disjointness is not satis.ed. \nFigure 7 Typing System for Expressions and Processes G f ei bool G, a : S f a: S G f true, false : bool \nG f e1or e2: bool [Name], [Bool], [Or] G f a: (G) G f P ., s :(G d1)@1 |s | = max(sid(G)) [Mcast] G f \na[2..n]( s).P . G f a : (G) G f P ., s :(G dp)@p |s | = max(sid(G)) [Macc] G f a[p]( s).P . . j. G f \nej : Sj G f P ., s : T @p [Send] G f sk!(e ); P ., s : k!(S ); T @p G, x: S f P ., s : T @p [Rcv] G f \nsk?( x); P ., s : k?(S );T @p G f P ., s : T @p [Deleg] G f sk!((t )); P ., s : k!(T ;@p;); T @p, t : \nT ;@p; ; G f P ., s : T @p, t : T ;@p [SRec] G f sk?((t )); P ., s : k?(T ;@p;);T@p G f P ., s : Tj@p \nj . I [Sel] G f sk < lj; P ., s : k .{li : Ti}i.I @p G f Pi ., s : Ti@p .i . I [Branch] G f sk I {li \n: Pi}i.I ., s : k &#38;{li : Ti}i.I @p G f P .G f Q .; . \" .; [Conc] G f P | Q . ..; G f e bool G f \nP .G f Q . [If] G f if e then P else Q . . end only G, a: (G)f P . [Inact],[NRes] G f 0 .G f (. a)P \n. G f e : S . end only [Var] G, X : S T f X(e s 1..s n) ., s 1 : T1@p1,.., s n : Tn@pn G, X : S T , \nx : S f P s 1 : T1@p1..s n : Tn@pn G, X : S T f Q . [Def] G f def X( xs 1..s n) = P in Q . Typing System \nThe type assignment system for processes is given in Figure 7. We use the judgement G f P . which reads: \nunder the environment G, process P has typing . . If we set |s | = 1and n = 2, and delete p from located \ntype, the shape of rules is essen\u00adtially identical with the original binary session typing (Yoshida and \nVasconcelos 2007). Below we only illustrate the rules. [Name],[Bool],[Or] are the rules for the expressions \nand identi\u00adcal with (Yoshida and Vasconcelos 2007). [Mcast] is the rule for the session request. The \ntype for s is the .rst projection of the declared global type for a in G.[Macc]isfor the session accept, \ntaking the p-th projection. The local type (G d p)@p means that the participant p has Gdp, which is the \nprojection of G onto p, as its local type. The condition |s | = max(sid(G)) ensures the number of session \nchannels meets those in G.The typing s : T @p (which stands for s : {T @p}) ensures each pre.x does not \ncontain parallel threads which share s. [Send]and [Rcv] are the rules for sending and receiving values. \nSince the k-th name sk of s is used as the subject, we record the number k. In both rules, p in T @p \nensures that P is (being in\u00adferred as) the behaviour for participant p, and its domain should be s . \nThen the relevant type pre.xes (k!(S ) for the output and k?(S ) for the input) are composed in the conclusion \ns session environment. [Deleg]and [SRec]are therules fordelegationofasession and its dual. Delegation \nof a multiparty session passes the whole capability to participate in a multiparty session: thus operationally \nwe send the whole vector of session channels. The carried type T ; is located, making sure that the behaviour \nby the receiver at the passed channels takes the role of a speci.c participant (here p;) in the delegated \nmultiparty session. The rest follows the standard delegation rule (Yoshida and Vasconcelos 2007), observing \n[Deleg] says that t : T ;@p; does not appear in P symmetrically to [SRec] which uses the channels in \nP. [Sel]and [Branch] are the rules for selection and branching, and identical with (Yoshida and Vasconcelos \n2007). [Conc]uses to ensure well-formedness of the session typing, taking a the disjoint union of each \nlocal type. [If], [Inact], [Var], and [Def] are standard. [NRes] is the restric\u00adtion rule for shared \nname a.In[Inact]and [Var], end only means .only contains end as session types. An annotated P is the \nresult of annotating P s bound names as e.g. (.a : (G))P and s?(x : (G))P. Assuming these annotations \nis natural from our design framework. For typing annotated processes we assume the obvious updates for \n[Rcv]and [NRes] in Fig. 7. Theorem 4.6. Assume given an annotated program phrase P and G. Then it is \ndecidable if there exists .such that Gf P .or not. If such .exists there is an algorithm to construct \none. Corollary 4.7 (typing for programs). Given an annotated pro\u00adgram P and G, it is decidable if Gf \nP \u00d8. 4.4 Typing Examples Two Buyer Protocol Write Buyer1 as a[2, 3](b1, b2, b;2, s).Q1 and Buyer2 as \na[2](b1, b2, b;2, s).Q2, both from \u00a72.3. Then Q1 and Q2 have the following typing under G={a : (G)} where \nG is given in the corresponding example in \u00a7 3.2, letting Bi =i, S =3, b1 =1, =2, b;=3and s =4 and assuming \nP1, P2, Q are 0: b22 Gf Q1 s : s!(string); b1? (int); b;!(int)@B1 2 Gf Q2 s : b2?(int);b;?(int); 2s \n.{ok : s!(string);b2?(date);end, quit : end}@B2 Similarly for Seller. After pre.xing at a, we can compose \nall three by [Conc]. Note these typings are calculable by Corollary 4.7. A Streaming Protocol We let \nG={a : (G;)} where G; is given in the corresponding example in \u00a7 3.2. Let d =1, k =2, c =3, K =1, DP \n=2, C =3and KP =4. Write R1, R2, R3 and R4 for the processes which are under the initial pre.x (at the \nshared name) of Kernel, DataProducer, Consumer and KeyProducer, respectively. Then we can type each agent \nas: Gf R1 dkc : \u00b5t.d?(bool);k?(bool);c! (bool);t@K Gf R2 dkc : \u00b5t.d!(bool); t@DP Gf R4 dkc : \u00b5t.c?(bool);t@C \n(R4 is similar as R2). Note these types correspond to the projec\u00adtion of G; onto respective participants: \nthus Kernel, DataProducer, Consumer and KeyProducer are typable programs, which can be composed to make \nthe initial con.guration. Delegation One source of the expressiveness of the session types comes from \na facility of delegation (often called higher-order ses\u00adsion passing). We will type and see the relationship \nwith global and local types. Consider the following three participants: def Alice = a[2](t1, t2).b[2, \n3](s1, s2).t1!((s1, s2));0 def Bob = a[2](t1, t2).b[1](s1, s2).t1?((s1, s2)); s1!(1); 0 def Carol = b[2](s1, \ns2).s1?(x); P where Alice delegates its capability to Bob. Since there are two multicasting, there are \ntwo global speci.cations, one for a and another for b as follows: Ga = A . B : t1 (s1! (int)@B).end Gb \n= B . C : s1 (int).end where the type s1!(int)@B means the capability to send an integer from participant \nB via channel s1. This capability is passed to B so that B behaves as A. However, since two speci.cations \nare indepen\u00addent, C does not have to know who would pass the capability. Let (Alice | Bob | Carol) .. \n(.t s )(A | B | C | R)where A, B,C are the processes of Alice, Bob and Carol after initial multicasting \nand R are the generated queues. Let s1 =1, t1 =1, A =1, B =2, C =3. These processes have the following \ntypings under Gwith P = 0: Gf At : t1!(s1! (int)@B)@A, s : s1! (int)@B Gf Bt : t1? (s1!(int)@B)@B Gf \nCs : s1?(int)@C where each local type re.ects the original global speci.cations (e.g. Carol does not \nknow Alice passed the capability to Bob). These types give projections of Ga and Gb.  5. Safety and \nProgress This section establishes the fundamental behavioural properties of typed processes. We follow \nthree technical steps: 1. We extend the typing rules to include those for runtime pro\u00adcesses which involve \nmessage queues. 2. We de.ne reduction over session typings which eliminates a pair of minimal complementary \nactions from local types. 3. We then relate the reduction of processes and that of typings: showing \nthe latter follows the former gives us subject reduc\u00adtion (Theorem 5.4), safety (Theorem 5.5) and session \n.delity (Corollary 5.6), while showing the former follows the latter un\u00adder a certain condition gives \nus progress (Theorem 5.12).  By the correspondence between local types and global types, these results \nguarantee that interactions between typed processes exactly follow the conversation scenario speci.ed \nin a global type. How to Type a Queue We .rst illustrate a key idea underlying our runtime typing using \nthe following example. s!(3); s!(true);0 | s:\u00d8| s?(x); s?(x);0 (5) We type the two processes with s :1!(nat);1!(bool);end@p \nand s :1?(nat);1?(bool);end@q. After a reduction, (5) changes into: s!(true);0 | s:3 | s?(x); s?(x);0 \n(6) Note that (6) is identical with (5) except that an output pre.x in (5) changes its place to the queue. \nThus we can go back from (6) to (5) by placing this message on the top of the process. A key idea in \nour runtime typing is to carry out this rollback of a message in typing, using a local type with a hole \n(a type context) for typing a queue. For example we type the queue in (6) as: s : { 1!(nat);[ ]@p, []@q \n} (7) where [ ] indicates a hole. Now we cover the type 1!(bool); end with the type context for p given \nabove, 1! (nat);[ ], obtaining the type 1!(nat);1!(bool); end for p, restoring the original typing. Labels \nin a queue are also typed using a type context. For example k : l1l2 can be typed with k .l1: k .l2 : \n[ ], omitting braces for a singleton selection. To do a rollback for selection types, we use the standard \nsession subtyping (Gay and Hole 2005; Carbone et al. 2007), denoted =sub, which is the maximal .xed point \nof Figure 8 Selected Typing Rules for Runtime Processes GfPt ..=.; .end only [Subs],[Qnil] GfPt .; Gfsk \n: \u00d8 s : {[]@p}p .. Gfvi : Si Gfsk : h ., s :({T@q}.R) R={Hp@p}p.I sk sk [Qval] Gf sk : h \u00b7v ., s :(T[k! \n(S );[ ]]@q}.R) sk Gfsk :h sk ., s : {T@q}.RR={Hp @p}p.I [Qsess] Gfsk : h \u00b7t ; sk ., s :(T[k!(T ;@p;);[ \n]]@q}.R, t ;: T ;@p; Gf sk : h ., s : {T@q}.RR ={Hp @p}p.I sk [Qsel] Gfsk : h \u00b7l ., s :(T[k .l :[ ]]@q}.R \nsk GfPt 1 .Gft 2 Q .; t 1 nt 2 =\u00d8 ..; [Conc] Gft 1\u00b7t 2 P |Qt 1\u00b7t 2 ...; GfPt ., s : {Tp @p}p.Is .t {Tp \n@p}p.I coherent [CRes]Gft \\s (. s )P . the function S that maps each binary relation R on local types \nas regular trees to S (R) given as: If T RT; then k!(U)TS (R)k!(U)T ; and k?(U)TS (R)k? (U)T;.  If \nTiRT ;for each i .I . J then .{li : Ti}i.IS (R) .{lj : T ;j}j.J  i and &#38;{lj : Tj}i.JS (R)&#38;{li \n: T ;}i.I . i For example we have k .{ok : T1}=sub k .{ok : T1, quit : T2}. Type Contexts The type contexts \n(T, T;,...) and the extended ses\u00adsion typing (., .;,... as before) are given as: T ::= [] | k!(U);T | \nk .li : T H ::= T | T . ::= \u00d8| ., s : {Hp }p.I The isomorphism on type contexts is generated from permuta\u00adtions \ngiven in \u00a74.2 (3, 4). Each assignment in .may contain both local types and type contexts. We extend .in \nDe.nition 4.5 as fol\u00adlows (sid(T) denotes the channel numbers in T). T .T =T .T =T[T ] T .T; =T[T;](sid(T) \nnsid(T;) =\u00d8) In the .rst rule, we place the output types of message queues on that of a process. In \nthe second, we compose the type contexts for two sets of messages from the mutually disjoint sets of \nqueues. Note T .T; is de.ned i. T;.T is de.ned and in which case we have T[T;] T;[T]. Note also T .T \n; is never de.ned. Composition of {Hp @p}p.I by . is given point-wise. The de.nition of .1 ..2 and .1 \n.2 stay the same as De.nition 4.5. Typing Rules for Runtime To guarantee that there is at most one queue \nfor each channel, we use the typing judgement re.ned as: GfPs . where s (regarded as a set) records the \nsession channels associated with the message queues. The typing rules for runtime are given in Figure \n8. [Subs] allows subsumption (=sub is extended pointwise fromtypes).[Qnil] starts from the empty hole \nfor each participant, recording the session channel in the judgement. [Qval]sayswhen we enqueue v, the \ntype for v is added at the tail. [Qsess]and [Qsel] are the corresponding rules for delegated channels \nand a label. [Conc] is re.ned to prohibit duplicated message queues. The rule does not use coherence \n(cf. Def.4.2 (2)) since coherence is meaningful only when all participants and queues are ready. In [CRes], \nsince we are hiding session channels, we now know no other participants can be added. Hence we check \nall message queues are composed and the given con.guration at s is coherent. The original typing rules \nin Figure 7 not appearing in Figure 8 are re.ned as follows: [Mcast], [Macc], [Rcv], [SRec], [Branch], \n[Def] replace GfP .with GfP \u00d8.and both [Def]and [NRes] replace GfP .by GfPs .. Using these typing rules, \nwe can check that the con.gurations at the beginning of this section, (5) and (6), are given an identical \ntyping by rolling back the type of the message in the queues. The typability in the original system in \n\u00a74 and the one in this system coincide for processes without runtime elements. Proposition 5.1. Let P \nbe a program phrase and . be without a type context. Then GfP .i. GfP \u00d8.without using [Subs]. Proposition \n5.2. If Gf Ps1..sm . then P has a unique queue at si (1 =i =m), no other queue at a free channel occurs \nin P, and no queue in P is under any pre.x. Type Reduction Next we introduce reduction over session typ\u00adings \nand global types, which abstractly represents interaction at session channels. Below we assume well-formedness \nof typing. k k! (U); H@p, k?(U); T @q .H@p, T @q [TR-Com] k k .{l : H,...}@p, k&#38;{l : T, ...}@q .H@p, \nT @q [TR-Bra] k .H; H1@p1, H2@p2 1@p1, H2;@p2 p1, p2 .I sk s : {H1@p1, H2@p2, ...}i.I , ..s : {H;@p1, \nH;@p2 , ...}i.I , . Then we write G .G; if [[G]] .[[G;]] where we set [[G]] to be the 1 2 [TR-Context] \nk k k family {(G d p)@p | p .pid(G)}.In G .G;,wetakeo.apre.x at k in G not suppressed by .II, .IO or \n.OO, to obtain G;. Proposition 5.3. Below .is coherent if .( s) is coherent for each s .dom(.). ss 1. \n.1 ..;and .1 .2 imply .;.2 and .1 ..2 ..;..2. 11 1 s 2. Let .be coherent. Then ...; implies .; is coherent. \nskk 3. Let . be coherent and .( s) =[[G]].Then .. .; i. G .G; with .;( s) =[[G;]]. Subject Reduction, \nCommunication Safety and Session Fidelity By the above proposition and the substitution lemma, we obtain: \nTheorem 5.4 (subject congruence and reduction). 1. GfPs .and P =P; imply GfP; s .. 2. GfPs .such that \n.is coherent and P .P; imply GfP; s .;  ; s where .=.; or ...; for some s;. 3. GfP \u00d8\u00d8and P .P; imply \nGfP; \u00d8\u00d8. Theorem 5.4 immediately entails the lack of the standard type errors in expressions (such as \ntrue +3). The type discipline also satis.es, as in the preceding session type disciplines (Honda et al. \n1998), communication error freedom, including linear usage of channels. We .rst introduce the reduction \ncontext E as follows: E ::= E |P | P|E | (.n)E | def D in E We also say and write: Apre.x is at s (resp. \nat a) if its subject (i.e. its initial channel) is s (resp. a). Further a pre.x is emitting if it is \nrequest, output, delegation or selection, otherwise it is receiving. A pre.x is active if it is not \nunder a pre.x or an if branch, after any unfoldings by [Def]. We write P(( s)) if P contains an active \nsubject at s after applying [Def], and P(( s!)) (resp. P(( s?)) )if P contains an emitting (resp. receiving) \nactive pre.x at s.  P has a redex at s if it has an active pre.x at s among its redexes.  The following \nresult decomposes the standard property for syn\u00adchronous session types (Takeuchi et al. 1994; Honda et \nal. 1998; Yoshida and Vasconcelos 2007) into the sending side and the re\u00adceiving side, due to the existence \nof queues. We assume the stan\u00addard bound name convention. Theorem 5.5 (communication safety). Suppose \nG f Pt . s.t. . is coherent and P has a redex at free s. Then: 1. (linearity) P = E[s:h ] such that either \n(a) P(( s?)) , s occurs exactly once in E and h * \u00d8 ;or (b) P(( s!)) and s occurs exactly once in E;or \n (c) P(( s?)) ,P(( s!)) , and s occurs exactly twice in E.  2. (error-freedom) if P = E[R] with R(( \ns?)) being a redex:  (a) IfR = s?( y); Qthen P = E; [s : v \u00b7 h] for some E; and | v | = | y | . (b) \nIfR = s?(( s)); Qthen P = E; [s : t \u00b7 h] for some E; and | s | = | t | . (c) IfR= s I { li : Qi} i. \nI then P= E;[s:lj\u00b7 h ] for some E; and j. I.  By Theorems 5.4 and 5.5, a typed process never goes wrong \nin the sense that its interaction at a multiparty session channel is always one-to-one and that each \ndelivered value matches the re\u00adceiving pre.x. As the corollary of Theorem 5.4(2) and Proposition 5.3(3), \nwe obtain session .delity: the interactions of a typable pro\u00adcess exactly follow the speci.cation described \nby its global type. Corollary 5.6 (session .delity). Assume G f Pt . such that . is coherent and .( s) \n= [[G]].If P . P; at the redex of sk,then k G f P; t .; with G . G; and [[G; ]] =.; ( s). Progress Communication \nsafety says that if a process ever does a reduction, it conforms to the typing and it is linear. If interactions \nwithin a session are not hindered by initialisation and communi\u00adcation of di.erent sessions, then the \nconverse holds: the reduction predicted by the typing surely takes place, the standard progress property \nin binary session types (Dezani-Ciancaglini et al. 2006; Honda et al. 1998). First we de.ne: Definition \n5.7. Let G f Ps ..Then P is queue-full when { s } coin\u00adcide with the set of session channels occurring \nin .. A process is queue-full when it has a queue for each session chan\u00adnel. The following precludes \ninterleaving of other sessions (includ\u00ading initialisations and communications) which can introduce dead\u00adlock. \nFor example, two session initialisations a[2](s).b[2](t).s?; t! and a[2](s).b[2](t).t?; s! cause deadlock. \nObserve, because we have multiparty sessions, there is less need to use interleaved sessions. Definition \n5.8 (simple). A process P is simple when it is typable with a type derivation where the session typing \nin the premise and the conclusion of each pre.x rule in Figure 7 is restricted to at most a singleton. \nThus each pre.xed subterm in a simple process has only a unique session. Another element which can hinder \nprogress is when inter\u00adactions at shared names cannot proceed. Definition 5.9 (well-linked). We say P \nis well-linked when for each P .* Q, whenever Q has an active pre.x whose subject is a (free or bound) \nshared name, then it is always part of a redex. Thus, in a simple well-linked P, each session is never \nhindered by other sessions nor by a name pre.xing. The key lemma for simple processes follows. Below \nwe safely confuse a channel in a typing and the corresponding free session channel of a process. Lemma \n5.10. Let G f Ps . and P is simple. If there is an active receiving (resp. active emitting) pre.x in \n. at s and none of pre.xes at s in P is under a pre.x at a shared name or under an if-branch, then P(( \ns?)) (resp. either P(( s!)) or the queue at s is not empty). Proposition 5.11. Let G f Ps ., . is coherent, \nP is simple, well\u00adlinked and queue-full. Then: 1. IfP .= 0 then P . P; for some P; . k  2. If .(t ) \n= [[G]] and G . G; ,then P . + P; at the redex at tk s. t. G f P; s .; with .; (t ) = [[G; ]].  (2) \nabove gives the converse of Corollary 5.6: if the global type has a reduction, then the process can always \nrealise it. Theorem 5.12 (progress). Let P be a simple and well-linked pro\u00adgram. Then P has the progress \nproperty in the sense that P .* P; implies either P;= 0 or P;. P;; for some P;; . A simple application \nof Theorems 5.4 (3), 5.5 and 5.12 for pro\u00adcesses from \u00a7 2.3 follow. Below communication mismatch stands \nfor the violation of the conditions given in Theorem 5.5 (2). Proposition 5.13 (properties of two protocols). \n1. Let Buyer1| Buyer2| Seller .* P. Then P is well-typed, simple and well-linked, P has no communication \nmismatch, and either P = 0 or P . P; for some P; . 2. Similarly for DataProducer| KeyProducer| Kernel| \nConsumer.  6. Extensions and Related Work 6.1 Extensions Graph-Based Global Types The syntax of global \ntypes uses the standard abstract syntax tree. We can further generalise this tree\u00adbased syntax to graph \nstructures to obtain a strictly more expres\u00adsive type language, enlarging typability. Consider the two \nend-point processes P = s!.t?and Q = t!.s?: their parallel composition does not introduce con.ict hence \nit is linear and safe. This situation how\u00adever cannot be represented in the current global types since \ntwo pre.xes criss-cross each other. Interestingly, our linearity con\u00additions in \u00a7 3.3, based on input/output \ndependencies, can directly capture the safety of this con.guration. All we need to do is to take the \ngraphs of pre.xes and II, IO and OO-edges (cf. Figure 5) under the linearity condition (precisely following \n\u00a7 3.3) as global types, augmented with an acyclicity condition on chains of these causal edges. All other \nde.nitions and results stay the same. Synchrony and Asynchrony Most of the session types currently studied \nare binary and synchronous (Honda et al. 1998). In some computing environments (e.g. tightly coupled \nSMP), synchrony would be more suitable. Adding synchrony means we have more causality: OO-dependency \nbetween di.erent names as well as the OI-dependency (i.e. the dependency from output to input, cf. Figure \n5), which in asynchrony never arises \u00a7 3.2. Adi.erent direction is to consider asynchronous message pass\u00ading \nwithout order-preservation (Honda and Tokoro 1991) which are also used in some computing environments \n(though in many environments we have e.cient order-preserving transport such as TCP). Again we can use \nour modular articulation, by taking o. OO-edges to obtain a consistent theory for pure asynchrony. Multicast \nPrimitives for Sessions Communication Two Buyer Protocol uses a multicasting pre.x notation s, t!( V) \n. The present work treats it as a macro for s!( V) ; t!( W) which has an essentially identical abstract \nsemantics. Having proper multicasting primitives for session communication is however useful especially \nin the case of sessions involving a large number of participants, using multicast protocols such as IP-multicast \nthrough APIs. It also enriches the type structures: we extend p . p; : k in the pre.x of global types \nto p . p1 ,.., pn : {k1,..., kn} (with a practical adaptation such as group addressing), representing \nthe multicast of a message to p1, .., pn via channels k1,..., kn by participant p, similarly we extend \nlocal session types to k !(U) from k!(U). Causality analysis remains the same by decomposing each multicasting \npre.x into its unicasting elements and considering causality for each of them. 6.2 Related Work Asynchronous \nSession Types Our multiparty session types are based on message-order preserving asynchronous communication. \nOperational semantics of binary sessions based on asynchronous communication was .rst considered by Neubauer \nand Thiemann (2004a). Recently Gay and Vasconcelos (2007) study the asyn\u00adchronous version of binary sessions \nfor an ML-like language based on (Vasconcelos et al. 2006). In (Gay and Vasconcelos 2007), a message \nqueue is given two endpoint channels and a direction. Coppo, Dezani-Ciancaglini, and Yoshida (2007) study \nthe asyn\u00adchronous binary session types for Java, extending the previous work in (Dezani-Ciancaglini et \nal. 2006), and prove the progress by introducing an e.ect system. The resulting system does not allow \ninterleaving sessions so that interactions involving more than two parties such as examples in \u00a7 2.3 \ncannot be represented. Our theo\u00adrem establishes the progress property on multiple session channels, signi.cantly \nenlarging the framework in (Coppo et al. 2007). Re\u00adcently Dezani-Ciancaglini, de Liguoro, and Yoshida \n(2008) pro\u00adpose a typing system for progress in binary synchronous inter\u00adleaving sessions. Typable processes \nthere obey the partial orders of shared and session channels inferred during type-checking. Be\u00adcause \nof a use of the global types, processes typed by our multiparty session typing do not have to follow \nsuch ordering. The system in (Dezani-Ciancaglini et al. 2008) does not include recursive agents or types, \nbut does not require the simpleness condition (De.nition 5.8). A combination of these two typing systems \nwill enlarge typa\u00adbility, guaranteeing the progress in many situations. The concurrent work done by Bonelli \nand Compagnoni (2008), which is independently conceived and developed, studies a multi\u00adparty session \ntyping for asynchronous communication. While treat\u00ading the common topic, the technical direction of their \nwork is dif\u00adferent from that of the present work. Instead of global types, they solely use what we call \n(recursion-free) local types. In type check\u00ading, local types are projected to each binary session, so \nthat type safety can be ensured using duality. Since we lose sequencing in\u00adformation in this way, the \nprogress property is not guaranteed. The use of global types in the present work leads to transparent \ntreat\u00adment of type structures such as recursion, the guarantee of stronger behavioural properties such \nas progress, and (arguably) more intel\u00adligible description of multiparty interaction structures. Global \nDescription of Session Types There are two recent works which studied global descriptions of sessions \nin the context of web services and business protocols, by the present authors (Car\u00adbone et al. 2007) \nand by Corin et al. (2007). Carbone, Honda, and Yoshida (2007) presented an executable language for directly \nde\u00adscribing Web interactions from a global viewpoint and provided the framework for projecting a description \nin the language to local processes. The use of global description for types and its associated theories \nhave not been developed in (Carbone et al. 2007). The type disciplines for the two (global and local) \ncalculi studied in (Carbone et al. 2007) are based on binary synchronous session types, hence safety \nand progress for multiparty interactions are not considered. Corin et al. (2007) investigates approaches \nto cryptographically protecting session execution from both external attackers in net\u00adworks and malicious \nsession principals. Their session speci.cation models an interaction sequence between two or more constituent \nroles, an abstraction of network peers. The description is given as a graph whose node represents a speci.c \nstate of a role in a ses\u00adsion, and whose edge denotes a dyadic communication and control .ow. The purpose \nof the message .ow graphs in (Corin et al. 2007) is more to serve as a model for systems and programs \nthan to of\u00adfer a type discipline for programming languages. First their work does not (aim to) present \ncompositional typing rules for processes. Secondly their .ow graphs do not (try to) represent such elements \nas local control .ow (e.g. pre.xing), channel-based communica\u00adtion and delegation. Third their operational \nstructures may not be oriented towards type abstractions: for example their choice struc\u00adtures are based \non transitions of .ow graphs than additive structures realisable by branching and selection. Semantics \nof Delegation The present work uses, for a simpler presentation, the operational semantics of delegation \nfrom (Honda et al. 1998) which demands that delegated channels do not occur in the receiver. This prevents \na process from acting as two or more participants in the same session, which usually deadlock. The duplication \ncheck is easily implementable in a way analogous to the standard mechanism of .rewalls. The more generous \nrule (Gay and Hole 2005; Yoshida and Vasconcelos 2007) allows substitution of session channels as in \n[Recv], which also satis.es type safety and progress through annotations on channels and types. With \nthis change the whole theories remain intact with exactly the same operational semantics and typing for \nprograms. Linear and Behavioural Types for Mobile Processes The ses\u00adsion type disciplines are related \nwith linear and IO-typed p\u00adcalculi with causality information. The causality analysis in global types \nis partly inspired by the graph-based linear types devel\u00adoped in (Yoshida 1996) where ordering among \nmultiple lin\u00adear names (which correspond to session channels) guarantees deadlock-freedom of typed processes. \nKobayashi and his col\u00adleagues (Kobayashi 2006; Igarashi and Kobayashi 2004; Kobayashi et al. 2000) study \ngeneralised forms of linear typing for guarantee\u00ading di.erent kinds of deadlock-freedom, incorporating \nsynchroni\u00adsations and locking, with a detailed type inference system. Amaindi.erence of session type \ndisciplines from these and other preceding works in this .eld is a notion of rigorously struc\u00adtured conversations \nand their direct type abstraction. By raising the level of abstraction through the use of structured \nprimitives such as separate session initiation, branching and recursion, session types can describe complex \ninteraction structures more intelligibly and enable e.cient type checking. These features would have \ndirect ap\u00adplicability for the design of programming languages with commu\u00adnication (Hu et al. 2007; Carbone \net al. 2007; Honda et al. 2007a). One of the novelties of the present work is the introduction of global \ndescription as types and a use of their projection for type-checking. They o.er a modular and systematic \ncausality anal\u00adysis rather than directly working on individual syntax and op\u00aderational semantics, with \nadaptations to asynchronous and syn\u00adchronous communications. Composability of multiple programs is transparent \nthrough projection of a common global type while com\u00adplex syntax of types and typing are required in \nthe traditional ap\u00adproach. To our knowledge, this method has not been investigated so far in the types \nof mobile processes. Our session types use a static participant information in the syntax and types. \nRecent advanced typing systems for location\u00adbased distributed processes (Hennessy 2007) use the similar \nnotion for types T @p, allowing dynamically instantiate locations into the capabilities using dependent \ntype techniques. Since our aim is to prove the simplest extension of the original session types to multi\u00adparty, \nthe static participants are enough even for delegations. It is a valuable further study to investigate \na dynamic change of partici\u00adpant numbers when session initialisation (without explicitly declar\u00ading p \nin the syntax) by using channel dependent types (Mostrous and Yoshida 2007) or polymorphism.  7. Conclusion \nOne of the main open problems of the session types is whether bi\u00adnary sessions can be extended to n-party \nsessions and, if they can, what is their additional expressiveness and bene.ts. This paper an\u00adswers the \nquestion a.rmatively. The present theory can guarantee stronger conformance to stipulated conversation \nstructures than bi\u00adnary sessions when a protocol involves more than two parties. The central technical \nunderpinning of the present work is the introduc\u00adtion of global types, which o.er an intuitive syntax \nfor describing multiparty conversation structures from a global viewpoint; and the use of their projection \nfor e.cient type-checking, proposing anew e.ective methodology for programming multiparty inter\u00adactions \nin distributed environments. Global types also o.er a ba\u00adsis of a clean modular causal analysis systematically \napplicable to both synchronous and asynchronous communications, ensuring the progress and session .delity. \nThere are several signi.cant future topics on the theory and ap\u00adplications of the proposed theory. We \nare currently starting to use this generalised session type structure as one of the formal foun\u00addations \nof the next version of a web service description language, WS-CDL from W3C (WS-CDL) and a message scheme \nfor .nan\u00adcial protocols, UNIFI from ISO (UNIFI). Another topic is the use of this theory as a basis of \ncommunication-centred extensions of general purpose programming languages (Hu et al. 2007). Others include \ntools assistance for the design and elaboration of global types; incorporation of typed exceptions to \nsessions; and integra\u00adtion of the type discipline with diverse speci.cation concerns in\u00adcluding security \nand assertional methods. Acknowledgements. We thank the reviewers for their useful comments and suggestions \nand our academic and industry col\u00adleagues for their stimulating conversations. The work is par\u00adtially \nsupported by EPSRC GR/T04236, GR/T04724, GR/T03208, GR/T03215, EP/F002114, EP/F003757 and IST2005-015905 \nMO-BIUS.  References Eduardo Bonelli and Adriana Compagnoni. Multipoint session types for a distributed \ncalculus. In TGC07, LNCS. Springer, 2008. To appear. Marco Carbone, Kohei Honda, Nobuko Yoshida, Robin \nMilner, Gary Brown, and Steve Ross-Talbot. A theoretical basis of communication\u00adcentred concurrent programming. \nTo be published by W3C. Available at www.dcs.qmul.ac.uk/ carbonem/cdlpaper, 2006. Marco Carbone, Kohei \nHonda, and Nobuko Yoshida. Structured Communication-Centred Programming for Web Services. In ESOP 07, \nvolume 4421 of LNCS, pages 2 17. Springer, 2007. Mario Coppo, Mariangiola Dezani-Ciancaglini, and Nobuko \nYoshida. Asynchronous Session Types and Progress for Object-Oriented Lan\u00ad guages. In FMOODS 07, volume \n4468 of LNCS, pages 1 31, 2007. Ricardo Corin, Pierre-Malo Denielou, Cedric Fournet, Karthikeyan Bhar\u00ad \ngavan, and James Leifer. Secure Implementations for Typed Session Abstractions. In CFS 07. IEEE-CS Press, \n2007. Mariangiola Dezani-Ciancaglini, Dimitris Mostrous, Nobuko Yoshida, and Sophia Drossopoulou. Session \nTypes for Object-Oriented Languages. In ECOOP 06, volume 4067 of LNCS, pages 328 352. Springer, 2006. \nMariangiola Dezani-Ciancaglini, Ugo de Liguoro, and Nobuko Yoshida. On Progress for Structured Communications. \nIn TGC07, LNCS. Springer, 2008. To appear. Manuel F\u00a8ahndrich, Mark Aiken, Chris Hawblitzel, Orion Hodson, \nGalen C. Hunt, James R. Larus, , and Steven Levi. Language Support for Fast and Reliable Message-based \nCommunication in Singularity OS. In EuroSys2006, ACM SIGOPS, pages 177 190. ACM Press, 2006. Pablo Garralda, \nAdriana Compagnoni, and Mariangiola Dezani-Ciancaglini. BASS: Boxed Ambients with Safe Sessions. In PPDP \n06, pages 61 72. ACM Press, 2006. Simon Gay and Malcolm Hole. Subtyping for Session Types in the Pi-Calculus. \nActa Informatica, 42(2/3):191 225, 2005. Simon Gay and Vasco T. Vasconcelos. Asynchronous functional \nsession types. TR 2007 251, University of Glasgow, may 2007. Jean-Yves Girard. Linear logic. TCS, 50:1 \n102, 1987. Matthew Hennessy. A Distributed Pi-Calculus. CUP, 2007. Kohei Honda and Mario Tokoro. An object \ncalculus for asynchronous communication. In Proceedings of ECOOP 91, 1991. Kohei Honda, Vasco T. Vasconcelos, \nand Makoto Kubo. Language primi\u00adtives and type disciplines for structured communication-based program\u00adming. \nIn ESOP 98, volume 1381 of LNCS, pages 22 138. Springer-Verlag, 1998. Kohei Honda, Nobuko Yoshida, and \nMarco Carbone. Web Services, Mobile Processes and Types. The Bulletin of the European Association for \nTheoretical Computer Science, February(91):165 185, 2007a. Kohei Honda, Nobuko Yoshida, and Marco Carbone. \nFull version of this paper. Technical Report 5, Imperial College London, 2007b. Raymond Hu, Nobuko Yoshida, \nand Kohei Honda. Type-safe Commu\u00adnication in Java with Session Types. http://www.doc.ic.ac.uk/ rh105/sessiondj.html, \nMarch 2007. Atsushi Igarashi and Naoki Kobayashi. A generic type system for the pi\u00adcalculus. Theoretical \nComputer Science, 311(1-3):121 163, 2004. Naoki Kobayashi. A new type system for deadlock-free processes. \nIn CONCUR 06, volume 4137 of LNCS, pages 233 247, 2006. Naoki Kobayashi, Shin Saito, and Eijiro Sumii. \nAn implicitly-typed deadlock-free process calculus. In CONCUR 00, volume 1877 of LNCS, pages 489 503, \n2000. Leslie Lamport. Time, clocks, and the ordering of events in a distributed system. Communications \nof the ACM, 21(7):558 564, July 1978. Dimitris Mostrous and Nobuko Yoshida. Two session typing systems \nfor higher-order mobile processes. In TLCA 07, volume 4583 of LNCS, pages 321 335. Springer, 2007. Matthias \nNeubauer and Peter Thiemann. Session Types for Asynchronous Communication. Universit\u00a8at Freiburg, 2004a. \nMatthias Neubauer and Peter Thiemann. An Implementation of Session Types. In PADL, volume 3057 of LNCS, \npages 56 70. Springer, 2004b. Benjamin C. Pierce. Types and Programming Languages. MIT Press, 2002. Bruce \nSchneier. Applied Cryptography: Protocols, Algorithms, and Source Code in C. John Wiley &#38; Sons, Inc., \n1993. Stephen Sparkes. Conversation with Steve Ross-Talbot. ACM Queue, 4(2), March 2006. Kaku Takeuchi, \nKohei Honda, and Makoto Kubo. An Interaction-based Language and its Typing System. In PARLE 94, volume \n817 of LNCS, pages 398 413. Springer-Verlag, 1994. UNIFI. International Organization for Standardization \nISO 20022 UNIver\u00adsal Financial Industry message scheme. http://www.iso20022.org. Vasco T. Vasconcelos, \nSimon Gay, and Ant\u00b4onio Ravara. Typechecking a multithreaded functional language with session types. \nTCS, 368(1 2): 64 87, 2006. WS-CDL. Web Services Choreography Working Group. http://www. w3.org/2002/ws/chor/. \nNobuko Yoshida. Graph types for monadic mobile processes. In FSTTCS, volume 1180 of LNCS, pages 371 386. \nSpringer, 1996. Nobuko Yoshida and Vasco Thudichum Vasconcelos. Language primitives and type discipline \nfor structured communication-based programming revisited: Two systems for higher-order session communication. \nElectr. Notes Theor. Comput. Sci., 171(4):73 93, 2007. \n\t\t\t", "proc_id": "1328438", "abstract": "<p>Communication is becoming one of the central elements in software development. As a potential typed foundation for structured communication-centred programming, session types have been studied over the last decade for a wide range of process calculi and programming languages, focussing on binary (two-party) sessions. This work extends the foregoing theories of binary session types to multiparty, asynchronous sessions, which often arise in practical communication-centred applications. Presented as a typed calculus for mobile processes, the theory introduces a new notion of types in which interactions involving multiple peers are directly abstracted as a global scenario. Global types retain a friendly type syntax of binary session types while capturing complex causal chains of multiparty asynchronous interactions. A global type plays the role of a shared agreement among communication peers, and is used as a basis of efficient type checking through its projection onto individual peers. The fundamental properties of the session type discipline such as communication safety, progress and session fidelity are established for generaln-party asynchronous interactions.</p>", "authors": [{"name": "Kohei Honda", "author_profile_id": "81100624236", "affiliation": "Queen Mary, London, United Kingdom", "person_id": "PP43125385", "email_address": "", "orcid_id": ""}, {"name": "Nobuko Yoshida", "author_profile_id": "81100632656", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "PP14217374", "email_address": "", "orcid_id": ""}, {"name": "Marco Carbone", "author_profile_id": "81331489911", "affiliation": "Queen Mary, London, United Kingdom", "person_id": "PP43125768", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328472", "year": "2008", "article_id": "1328472", "conference": "POPL", "title": "Multiparty asynchronous session types", "url": "http://dl.acm.org/citation.cfm?id=1328472"}