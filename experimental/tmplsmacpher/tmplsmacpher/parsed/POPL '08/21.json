{"article_publication_date": "01-07-2008", "fulltext": "\n A Theory of Contracts for Web Services Giuseppe Castagna Nils Gesbert Luca Padovani PPS (CNRS) LRI \n(CNRS) ISTI Universit\u00b4eParis 7 Universit\u00b4eParis-Sud Universit`a degli Studi di Urbino Paris, France Orsay, \nFrance Urbino, Italy Abstract Contracts are behavioural descriptions of Web services. We devise a theory \nof contracts that formalises the compatibility of a client to a service, and the safe replacement of \na service with another service. The use of contracts statically ensures the successful completion of \nevery possible interaction between compatible clients and services. The technical device that underlies \nthe theory is the de.nition of .lters, which are explicit coercions that prevent some possible be\u00adhaviours \nof services and, in doing so, they make services compati\u00adble with different usage scenarios. We show \nthat .lters can be seen as proofs of a sound and complete subcontracting deduction system which simultaneously \nre.nes and extends Hennessy s classical ax\u00adiomatisation of the must testing preorder. The relation is \ndecidable and the decision algorithm is obtained via a cut-elimination process that proves the coherence \nof subcontracting as a logical system. Despite the richness of the technical development, the resulting \napproach is based on simple ideas and basic intuitions. Remark\u00adably, its application is mostly independent \nof the language used to program the services or the clients. We also outline the possible practical impact \nof such a work and the perspectives of future re\u00adsearch it opens. Categories and Subject Descriptors \nF.1.2 [Computation by Ab\u00adstract Devices]: Modes of Computation Parallelism and con\u00adcurrency; F.3.3 [Logics \nand Meanings of Programs]: Studies of Program Constructs Type structure; H.3.5 [Information Storage and \nRetrieval]: Online Information Services Web-based services; H.5.3 [Information Interfaces and Presentation]: \nGroup and Orga\u00adnization Interfaces Theory and models, Web-based interaction General Terms Languages, \nStandardization, Theory Keywords Web services, contracts, concurrency theory, CCS, must testing, type \ntheory, subtyping, explicit coercions. 1. Introduction Web services are distributed components that clients \ncan connect to and communicate with by means of standard communication protocols and platform-neutral \nmessage formats. Remarkably, Web services are equipped with machine-understandable descriptions of their \ninterface. This aspect permits Web services to be discovered Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 08, January 7 12, 2008, San Francisco, \nCalifornia, USA. Copyright c &#38;#169; 2008 ACM 978-1-59593-689-9/08/0001. . . $5.00 according to the \ninformation encoded in their interface. Among the capabilities that can be used as search keys are the \noperations pro\u00advided by the service, the format or schema (Fallside and Walm\u00adsley 2004) of the exchanged \nmessages, and the contract required to interact successfully with the service. By contract we mean the \ndescription of the external, observable behaviour of a service. The Web Service Description Language \n(WSDL) (Chinnici et al. 2007a,b) is a standard technology for describing the interface ex\u00adposed by a \nservice. In WSDL, contracts are basically limited to one\u00adway (asynchronous) and request/response (synchronous) \ninterac\u00adtions. The Web Service Conversation Language (WSCL)(Banerji et al. 2002) extends WSDL contracts \nby allowing the description of arbitrary, possibly cyclic sequences of exchanged messages be\u00adtween communicating \nparties. Other languages, such as the Ab\u00adstract Web Service Business Execution Language (Alves et al. \n2007), provide even more detailed descriptions of services by de.n\u00ading the subprocess structure and more \nspeci.c details regarding the service s internals. Such descriptions, which are excessively con\u00adcrete \nand verbose to directly serve as interfaces, can be approxi\u00admated and compared in terms of contracts. \nStandard technologies are also available for building reposito\u00adries of Web services descriptions (Bellwood \net al. 2005), making it possible to perform queries for services according to their contract. Searching \nimmediately calls for a notion of contract equivalence to perform service discovery in the same way as, \nsay, type isomor\u00adphisms are used to perform library searches (Rittri 1993; Di Cosmo 1995). Without a \nformal characterisation of contracts, however, one is left with excessively demanding equivalences such \nas syntactical or structural equality. In fact, clients will be equally satis.ed to interact with services \nthat provide more capabilities than those ac\u00adtually required, so that it makes sense to relax the equivalence \ninto a subcontract preorder (denoted by . in this paper). In this work we develop a formal theory of \ncontracts that de.nes a very general subcontract preorder. Along the lines of (Carpineti et al. 2006) \nwe describe contracts by simple CCS-like terms built with just three operators: pre.xing, denoted by \na dot, and two in.x choice operators + (external choice) and . (internal choice). The contract a.s describes \na service that is capable of performing an action a, and then continues as s. The contract s + t describes \na service that lets the client decide whether to continue as s or as t . The contract s . t describes \na service that internally decides whether to continue as s or t . Following CCS notation, actions are \neither write or read actions, the former being topped by a bar, and one being the co-action of the other. \nActions can either represent operations or message types. As a matter of facts, contracts are behavioural \ntypes of processes that do not manifest internal moves and the parallel structure. Contracts are then \nto be used to ensure that interactions between clients and services will always succeed. Intuitively, \nthis happens if whenever a service offers some set of actions, the client either syn\u00adchronises with one \nof them (that is, it performs the corresponding co-action) or it terminates. The service contract will \nthen allow us to determine the set of clients that comply with it, that is that will successfully terminate \nany session of interaction with the service. Of course the client will probably be satis.ed to interact \nwith services that offer more than what the searched contract speci.es. Intuitively we want to de.ne \nan order relation on contracts st such that every client complying with services implementing s will \nalso comply with services of contract t . In particular, we would like the preorder to enjoy some basic \nproperties. The .rst one is that it should be safe to replace (the service exposing) a contract with \na more deterministic one. For instance, we expect a . b.c a, since every client that terminates with \na service that may offer either a or b.c will also terminate with a service that systematically offers \na. The second desirable property is that it should be safe to replace (the service exposing) a contract \nwith another one that offers more capabilities. For instance, we expect aa + b.d since a client that \nterminates with services that implement a will also terminate with services that leave the client the \nchoice between a and b.d. If taken together, these two examples show the main problem of this intuition: \nit is easy to see that a client that complies with a . b.c does not necessarily comply with a + b.d: \nif client and service synchronise on b, then the client will try to write on c while the service expects \nto read from d. Therefore, under this interpretation, looks as not being transitive:    a . b.c a \n. aa + b.d =. a . b.c a + b.d . The problem can be solved by resorting to the theory of explicit co\u00adercions \n(Bruce and Longo 1990; Chen 2004; Soloviev et al. 1996). The .awed assumption of the approach described \nso far, which is the one proposed in (Carpineti et al. 2006), is that services are used carelessly as \nthey are . Note indeed that what we are doing here is to use a service of type a + b.d wherea serviceof \ntype a . b.c is expected. The knowledgeable reader will have recog\u00adnised that we are using as an inverse \nsubtyping relation for ser\u00advices.1 If we denote by :> the subtyping relation for services, then a . b.c \n:> a + b.d and so what we implicitly did is to apply subsumption (Cardelli 1988) and consider that a \nservice that has type a + b.d has also type a . b.c. The problem is not that (or, equivalently, :>) is \nnot transitive. It rather resides in the use of sub\u00adsumption, since this corresponds to the use of implicit \ncoercions. Coercions have many distinct characterisations in the literature, but they all share the same \nunderlying intuition that coercions are func\u00adtions that embed objects of a smaller type into a larger \ntype with\u00adout adding new computation (Chen 2004). For instance it is well known that for record types \none has {a:s} :> {a:s; b:t}. Thisisso because the coercion function c = .x{a:s;b:t}.{a = x.a} embeds \nvalues of the smaller type into the larger one.2 In order to use a term of type {a:s; b:t} where one \nof type {a:s} is expected we .rst have to embed it in the right type by the coercion function c above, \nwhich erases (masks/shields) the b .eld so that it cannot interfere with the computation. Most programming \nlanguages do not require the pro\u00adgrammer to write coercions, either because they do not have any actual \neffect (as in the case of the function c since the type system   1 The inversion is due to the fact \nthat we are considering the client per\u00adspective: a contract can be interpreted as the set of clients \nthat comply with services implementing the contract. We decided to keep this notation rather than the \ninverse one for historical reasons, since it is the same sense as used by De Nicola and Hennessy for \nthe may and must preorders (De Nicola and Hennessy 1984). This inversion corresponds to the duality between \nsimula\u00adtion and subtyping, viz. between observers and observed behaviours. 2 In typed lambda calculus \ncoercions are formally characterised by the fact that their type erasure is .-equivalent to the identity \nfunction, but in general coercions may be different from the identity function (Chen 2004). already ensures \nthat the b .eld will never be used) or because they are inserted by the compiler (as when converting \nan integer into the corresponding .oat). In this case we speak of implicit coercions. However some programming \nlanguages (e.g. OCaml) resort to ex\u00adplicit coercions because they have a visible effect and, for instance, \nthey cannot be inferred by the compiler. Coercions for contracts have an observable effect, therefore \nwe develop their meta-theory in terms of explicit coercions. However, coercions can be inferred so they \ncan be kept implicit in the lan\u00adguage and automatically computed at static time. Coming back to our example, \nthe embedding of a service of type a into a.b.c is the identity, since we do not have to mask/shield \nany action of a service of the former type in order to use it in a context where a service of the latter \ntype is expected. On the contrary, to embed a service of type a + b.d into a we have to mask (at least) \nthe b action of the service. In order to use it in a context that expects a a service we apply to it \na .lter that will block all b messages. Transitivity being a logical cut, the coercion from a+b.d to \na.b.c is the composition of the two coercions, that is the .lter that blocks b messages. So if we have \na client that complies with a.b.c, then it can be used with a service that implements a + b.d by applying \nto this service the .lter that blocks its b messages. This .lter will make the previous problematic synchronisation \non b impossible, so the client can do nothing but terminate. Filters thus reconcile two requirements \nthat were hitherto in\u00adcompatible: On the one hand we wish to replace an old service by a new service \nthat offers more choices (that is width subtyping,e.g. s :> s + t ) and/or longer interaction patterns \n(that is depth subtyp\u00ading,e.g. a :> a.s) and/or is more deterministic (e.g. s . t :> s). On the other \nhand we want clients of the old service to seamlessly work with the new one. Two observations to conclude \nthis brief overview. First, the fact that we apply .lters to services rather than to clients is just \na presen\u00adtational convenience: the same effect can be obtained by applying client the .lter that blocks \nthe corresponding co-actions. Second, .lters must be more .ne grained in blocking actions than restriction \noperators as de.ned for CCS or p. These are permanent blocks, while .lters are required to be able to \nmodulate blocks along the computation. For instance the .lter that embeds (a.(a + b)) + b.c into a.b \nmust block b only at the .rst step of the interaction and a only at the second step of the interaction. \n1.1 Outline of the presentation We start by presenting the syntax of our contracts (\u00a72.1), by show\u00ading \nhow to use them to express WSDL and WSCL descriptions (\u00a72.2), and by de.ning their semantics (\u00a72.3). \nWe then characterise the set of all clients that are strongly compliant with a service that is, clients \nthat successfully complete every direct interaction ses\u00adsion with the service and argue that subcontract \nrelations whose de.nitions are naively based on strong compliance are either too strict or suffer the \naforementioned problem of transitivity (\u00a72.4). We argue that subcontracting should not be de.ned on all \npossi\u00adble interactions, but focus only on interactions based on actions that a client expects from the \nservices: all the other possible ac\u00adtions should not interfere with the interaction. We formalise this \nconcept by giving a coinductive de.nition of a subcontract relation that focuses on this kind of actions, \nwe study its properties and de\u00adscribe the relation with the must preorder (\u00a73.1). This subcontract relation \ninduces a notion of weak compliance which suggests that non-interference of unexpected actions can be \nensured by coercion functions, which we dub .lters. By shielding the actions at issue, a .lter embeds \na service into the world of its expected clients. We prove that our subcontract relation can be expressed \nin terms of .l\u00adters and of the must preorder and we provide a sound and complete deduction system for \nthe subcontract relation where .lters play the role of proofs (\u00a73.2). The subcontract relation is shown \nto be de\u00adcidable via the de.nition of a sound and complete algorithmic de\u00adduction system (\u00a73.3). Finally, \nwe relate our contract language with a suitably typed process language. The soundness of our theory of \ncontracts is proved by showing that a client that is weakly com\u00adpliant with a service via a given .lter \nwill successfully terminate every interaction with the service mediated by the .lter (\u00a73.4). A conclusion \nrecaps our work and hints at possible tracks of future research (\u00a74).     Proofs of lemmas and theorems \nhave been omitted because of space limits. They can be found in the full version of the paper available \nat the authors web pages. 1.2 Related work The contracts used in this presentation draw their inspiration \nfrom De Nicola and Hennessy s seminal work CCS without t s (De Nicola and Hennessy 1987), as well as \nfrom acceptance trees (Hen\u00adnessy 1985, 1988) of which they can be considered an alternative representation. \nThe works that are most closely related to ours are by Carpineti et al. (2006) and those on session types, \nespecially the one by Gay and Hole (2005). In (Carpineti et al. 2006) the subcon\u00adtract relation exhibits \nall of the desirable properties illustrated in the introduction, but subcontracting essentially stopped \nat the problem of transitivity. In that work compliance was a syntactic notion and contracts lacked a \nsemantic characterisation. Session types were introduced in the context of the p-calculus (Honda 1993; \nTakeuchi et al. 1994; Honda et al. 1998). These are used to type special channels through which several \ndifferent messages may be exchanged in sequence according to a given protocol. Such a session channel \ncan be seen as a client-service connection, and the session type is the analogous of our contract as \nit describes which actions the processes may perform through this channel. However, session types have \nthe important restriction, if compared with contracts, that only one part has the .oor at a given time: \nwhenever a process performs an internal choice it has to indicate explicitly which path of interaction \nit has chosen, and the other process has to be waiting for this indication. Thus there is no way of mixing \ninternal and external choices, and two processes like a+b and a+b do not interact successfully (because \nnobody has the .oor, so no communication can happen). Subtyping for the session types has been studied \nby Gay and Hole (2005), but because of the aforementioned restriction, the transitivity problem we address \nin this paper does not exist for them: internal and external choices can never be related, hence a . \nba + b does not hold. However, this looks like a reasonable relation, inasmuch as a . b models a scenario \nwhere exactly one of two resources a and b is available (and the client does not know which one), which \ncan be safely related with (and replaced by) a scenario where both a and b are available and the client \ncan choose whether to use a or b. Carbone et al. (2007a,b) describe choreographies of Web ser\u00advices by \nmeans of a global calculus, and descriptions of individ\u00adual processes are obtained as projections of \nthe global description. Both the global description and the projections are based on ses\u00adsion types. \nIn our approach, the typical application is searching for a service compatible with a given protocol \nfrom the client point of view: in particular, we want depth subtyping (a service that tries to pursue \nthe interaction after that the client has successfully termi\u00adnated is compatible with this client), which \ndoes not hold for ses\u00adsion types. We believe that our theory is more basic than the theory of session \ntypes and that it can be fruitfully used to enrich the latter. Fournet et al. (2004) de.ne a conformance \npreorder on CCS pro\u00adcesses with the property that a process is stuck-free (i.e., it success\u00adfully terminates) \nin every context in which smaller processes are stuck-free. The conformance relation of Fournet et al. \n(2004) re\u00adsembles our subcontract relation, with some important differences.  For example, in (Fournet \net al. 2004) a . 00,but a . 0 a. This essentially derives from the fact that stuck-free conformance is \nde.ned without using an explicit action (denoted by e in this work) expressing in an observationally \nvisible way the successful termination of a party, but instead by requiring that the party must eventually \nreduce to the idle process 0. Doing so prevents the spec\u00adi.cation of clients of the form e + a.e,which \nattempt to do an action, but that can succeed even if the action is not available. The lack of the explicit \naction e has overall important consequences on the precongruence properties of . A more important point \nis that the conformance relation of Fournet et al. is not complete with re\u00adspect to stuck-freedom, in \nthe sense that there are processes that are stuck-free exactly in the same contexts but are not related \nby conformance: for instance, a.(b . c) and a.b + a.c are stuck-free equivalent but are not conformance \nequivalent. In our theory the two processes above are equivalent and, more generally, our sub\u00adcontracting \nprovides, mutatis mutandis (cf. actions for successful termination), a complete characterisation of stuck-freedom. \nFinally, stuck-freedom does not allow either width or depth subtyping. Bravetti and Zavattaro (2007) \npropose a contract language equipped with a re.nement relation. The language is constrained so that output \nactions can only occur in the context of an internal choice. This restriction somehow resembles the design \nchoice of session types and, not surprisingly, the re.nement relation for this language allows width \nextensions of contracts without any inter\u00advening .ltering. However, the re.nement relation is determined \nin a symmetric way for all the participants of a system, whereas our notion of compliance is asymmetric \n(in favour of the client). This makes the re.nement relation more demanding than ours. In partic\u00adular, \nall the participants must successfully terminate, meaning that depth extensions are not entailed by re.nement. \nA preliminary version of this work was presented at PLAN-X 2007 workshop (Castagna et al. 2007). Although \nthe work\u00adshop has just informal proceedings, these are available on the web. Therefore it seems worth \ndiscussing the differences with PLAN-X version. While the overall presentation and structure of both \nworks is the same, this paper improves over the PLAN-X one in several points. Here we consider a slightly \ndifferent version of strong com\u00adpliance relation which now coincides with the must testing pre\u00adorder, \nwhile in PLAN-X strong compliance differed from must test\u00ading for some (uninteresting) pathological cases \nthat involved the empty contract. The deduction system has been reworked in favour of elegance and simplicity. \nThe resulting algebraic theory of .lters is also cleaner. We present better results for language neutrality. \nFi\u00adnally, an important part of this work is devoted to the study of the algorithmic version of the deduction \nsystem, of its logical interpre\u00adtation, and of the decidability of the containment relation, all topics \nthat were completely absent from the PLAN-X version. Starting from the PLAN-X work the third author and \nCosimo Laneve have recently proposed a simpli.cation where contracts are statically .ltered (Laneve and \nPadovani 2007): each contract is associated with a static interface (in the sense that it does not change \nover the time) declaring the only visible actions of the contract and blocks all the other ones whenever \nthey happen. As stated in (Laneve and Padovani 2007), the resulting approach is less general than ours \nand consequently it yields a stricter subcontract relation. For instance, the relation a.b (a.(a + b)) \n+ b.c,which we commentated in the previous page just before \u00a71.1, does not hold in the interface approach \n(for a practical example of relation that does not hold for interfaces see the contracts s and s' in \n\u00a72.2.2 and the explanation given at the end of \u00a73.2.1). On the other hand, interfaces allow for simpler \nalgorithmic treatment. Several works on the testing framework and (Laneve and Padovani 2007) itself have \nshown that the subcontract relation is not affected in its essence by recursion: the desirable properties \nwe mentioned in the introduction and formalised later in the deduction systems still hold. For the sake \nof brevity, in this paper we only consider .nite contracts without recursion, but the extension of our \ncontracts and .lters to the non-.nite case, although it involves signi.cant technicalities, is conceptually \nstraightforward.  2. Contracts 2.1 Syntax Let N be a set of names, we de.ne S to be the set of contracts \ngenerated by the following grammar. a ::= a |aa .N s ::= 0 |a.s | s .s |s + s where 0 is the contract \nof services that do not perform any action (the other constructions were already explained in the introduc\u00adtion). \nWe follow the standard convention of omitting trailing 0 s. 2.2 Examples In this section we relate our \ncontract language to existing technolo\u00adgies for specifying service protocols. 2.2.1 Message exchange \npatterns in WSDL The Web Service Description Language (Chinnici et al. 2007a,b) permits to describe and \npublish abstract and concrete descriptions of Web services. Such descriptions include the schema of messages \nexchanged between client and server, the name and type of opera\u00adtions thattheserviceexposes,aswellasthelocations \n(URLs)where the service can be contacted. In addition, it de.nes interaction pat\u00adterns (called message \nexchange patterns or MEPs in version 2.0 of WSDL) determining the order and direction of the exchanged \nmes\u00adsages. In particular, WSDL 2.0 prede.nes four message exchange patterns for describing services where \nthe interaction is initiated by clients. Let us shortly discuss how the informal plain English se\u00admantics \nof these patterns can be formally de.ned in our contract language. When the MEP is inOnly or robustInOnly, \ncommu\u00adnication is basically asynchronous: the client can only send an In message containing the request. \nIf the pattern is robustInOnly the service may optionally send back a Fault message indicating that an \nerror has occurred. When the MEP is inOut or inOptOut,com\u00admunication is basically synchronous: the client \nsends an In mes\u00adsage containing the request and the service sends back either an Out message containing \nthe response or a Fault message. If the pattern is inOptOut, then the Out message is optional. These \nfour patterns can be encoded in our contract language as follows: inOnly = In robustInOnly = In.(0 .Fault) \ninOut = In.(Out .Fault) inOptOut = In.(0 .Out .Fault) It is worth noticing that, intuitively, a client \nthat is capable of invoking a service whose MEP is robustInOnly will also interact successfully with \na service whose MEP is inOnly (depth subtyp\u00ading). Indeed, such client must be able to handle both a commu\u00adnication \nthat terminates and a Fault message. Similarly, a client that is capable of invoking a service whose \nMEP inOptOut will also interact successfully with services whose MEP is either inOut, or robustInOnly \n(since they are more deterministic), or even inOnly. On the other hand, a client that interacts with \na service whose MEP is inOut will not (always) interact successfully with a service whose MEP is inOptOut. \nThe client assumes that it will always receive either an Out or a Fault message, but inOptOut does not \ngive this guarantee. Figure 1. Contract of an e-commerce service as a WSCL diagram. 2.2.2 Conversations \nin WSCL The WSDL message exchange patterns cover only the simplest forms of interaction between a client \nand a service. More involved forms of interactions, in particular stateful interactions, cannot be captured \nif not as informal annotations within the WSDL interface. The Web service conversation language WSCL \n(Banerji et al. 2002) provides a more general speci.cation language for describing com\u00adplex conversations \nbetween two communicating parties, by means of an activity diagram. The diagram is basically made of \ninterac\u00adtions which are connected with each other by means of transitions. An interaction is a basic \none-way or two-way communication be\u00adtween the client and the server. Two-way communications are just \na shorthand for two sequential one-way interactions. Each interaction has a name and a list of document \ntypes that can be exchanged dur\u00ading its execution. A transition connects a source interaction with a \ndestination interaction. A transition may be labelled by a document type if it is active only when a \nmessage of that speci.c document type was exchanged during the previous interaction. Below we encode \nthe contract s of a simpli.ed e-commerce service (Figure 1) where the client is required to login before \nit can issue a query and thus receive a catalog. Then, the client can add an item from the catalog into \nthe shopping cart and subsequently buy the item using one of two payment methods, either with credit \ncard or with a bank transfer. At any time, the client can choose to logout and leave the store. In case \nof purchase, the service reports that the purchase was either valid or not. We can represent the contract \nof Figure 1 (without the dashed part, which represent an extension discussed later), as the following \nterm: def s = Login.(InvalidLogin .ValidLogin.Query. Catalog.(Logout + AddToCart.(Logout + Buy.( Logout \n+ CreditCard.(Valid .Invalid) + BankTransfer.(Valid .Invalid))))) Notice that unlabelled transitions \nin Figure 1 correspond to external choices in s, whereas labelled transitions correspond to internal \nchoices. Let us recast in this setting the three forms of subtyping we described in the introduction. \nFirst, it is clear that clients com\u00adpliant with the service above will always be happy with more deterministic \nservers that, for instance, never deny the access (InvalidLogin . ValidLogin ValidLogin) as well as with \nservers that offer longer interactions, such as the fact of proposing an invoice after the payment (Valid \nValid.Invoice). Now assume that the service is extended (by width subtyping) with 1-click ordering capability, \nso that after looking at the catalog the client may buy an item without adding it to the shopping cart \n(dashed part in Figure 1). The contract of the service would change to s ' as follows: s ' def = ... \nLogout +Buy.sB +AddToCart.(... ) It would be desirable for clients that are compliant with the former \nservice to be compliant with this service as well. After all, the ex\u00adtended service offers more than \nthe old one. However, the transitiv\u00adity problem we pointed out in the introduction might arise. Indeed, \nassume to have a client that does actually account for a Buy mes\u00adsage right after receiving a catalog \nfrom the service and that such a client is compliant with the former service for the simple reason that, \nsince the former service did not provide a 1-click ordering capability, whatever contract .B the client \nprovided after the Buy action was irrelevant to establish compliance. In the extended ser\u00advice this is \nno longer the case and, since the .B may be incompati\u00adble with sB, the client can safely interact with \nthe extended service only if the new Buy action is .ltered out (see \u00a7 3.2.1).  2.3 Semantics Contracts \ndescribe the behaviour of the processes that implement them. This behaviour is de.ned by describing the \nactions that are offered by a process and the way in which they are offered. This is formally stated \nby the two de.nitions given below. a DEFINITION 2.1 (TRANSITION). Let s -. be the least relation such \nthat: a 0 -. a -. if a =\u00df \u00df.s aaa s . t -.if s -. and t -. aaa s +t -.if s -. and t -. The transition \nrelation of contracts, noted a -. , is the least relation satisfying the rules: a a.s -. s aaaa s t -. \nt ' s t -. s ' -. s ' -. aa s +t ' s +t -. s ' -. s ' . t aaaa s t -. t ' s t -. s ' -. s ' -. aa s . \nt ' s . t -. s ' -. s ' . t and closed under mirror cases for the external and internal choices. aa We \nwrite s such that s -. s ' . -. if there exists s ' The relation a -. is different from standard transition \nrelations for CCS processes (Milner 1982). For example, there is always at most one contract s ' such \nthat s a -. s ' , while this is not the case in CCS (the process a.b +a.c has two different a-successor \nstates: b and c). This mismatch is due to the fact that contract transitions de.ne the evolution of conversation \nprotocols from the perspective of an external communicating party. Thus a.b +a.c a -. b . c because, \nonce the action a has been performed, the communicating party is not aware of which branch has been chosen. \nOn the contrary, CCS transitions de.ne the evolution of processes from the perspective of the process \nitself. NOTATION 2.2. We write s(a)for the unique continuation of s a after a, that is, the contract \ns ' such that s -. s ' . The labelled transition system above describes the actions offered by (a service \nimplementing) a contract, but does not show how these actions are offered. In particular the actions \noffered by an external choice are all available at once while the actions offered by different components \nof an internal choice are mutually exclusive. Such a description is given by the ready sets that are \nobservable for a given contract: DEFINITION 2.3 (OBSERVABLE READY SETS). Let P f (N.N ) be the set of \n.nite parts of N.N , called ready sets.Let also s . R be the least relation between contracts s in Sand \nready sets R in P f (N.N )such that: 0 .\u00d8 a.s .{ a}(s +t ). R . S if s . R and t . S (s . t ). R if either \ns . R or t . R NOTATION 2.4. We use the convention that the bar operation is an involution, a = a, and \nfor a given ready set R we de.ne its complementary ready set as co(R)={ a | a . R} . 2.4 The problem \nWe now possess all the technical instruments to formally state the problem we described in the introduction \nand recalled at the end of \u00a7 2.2. This .rst requires the precise de.nition of compliance. Recall that, \nintuitively, the behaviour of a client complies with the behaviour of a service if for every set of actions \nthat the service may offer, the client either synchronises with one of them, or it terminates successfully. \nThe behaviour of clients, as well as the one of services, is described by contracts. Therefore we need \nto de.ne when a contract . describing the behaviour of a client complies with a contract s describing \nthe behaviour of a service. For this we reserve a special action e (for end ) that can occur in client \ncontracts and that represents the ability of the client to successfully terminate. Then we require that, \nwhenever no further interaction is possible between the client and the service, the client be in a state \nwhere this action is available. DEFINITION 2.5 (STRONG COMPLIANCE). C is a strong compli\u00adance relation \nif (., s).C implies that: 1. . . R and s . S implies either e . R or co(R)n S =\u00d8 , and aa 2. . and s \n-. s ' implies (. ' ,s ' ).C . -. . ' We use -to denote the largest strong compliance relation. In words \nthe de.nition above states that a client of contract . is compliant with a service of contract s if (1) \nfor every possible combination S and R of the independent choices of the service and the client, either \nthere is an action in the client choice that can synchronise with an action among those offered by the \nservice (co(R)n S = \u00d8 ) or the client terminates successfully (e . R), and (2) whenever a synchronisation \nhappens, the continuation of the client after it is compliant with the continuation of the service ((. \n' ,s ' ).C ). Once we have such a de.nition it is natural to de.ne the subcon\u00adtract relation in terms \nof compliance. Intuitively, (client) contracts are seen as tests for comparing (service) contracts. Two \n(service) contracts are related if so are the sets of (client) contracts compliant with them (De Nicola \nand Hennessy 1984). DEFINITION 2.6 (STRONG SUBCONTRACT). The contract s is a strong subcontract of the \ncontract t , written s gt , if and only if for all . we have . -s implies . -t . We write s .t if s gt \nand t gs. This de.nition corresponds to giving a set theoretic semantics to service contracts which are \nthus interpreted as the set of their compliant clients. Thus gis interpreted as set-theoretic inclusion. \nAs usual with testing semantics, it is hard to establish a rela\u00adtionship between two contracts because \nthe set of clients that are strongly compliant is in.nite. A direct de.nition of the preorder is therefore \npreferred: DEFINITION 2.7. Sis a coinductive strong subcontract relation if (s, t ).Simplies that 1. \nt .R implies that there exists S .R such that s .S, and aa 2. t -.t ' implies s -.s ' and (s ' ,t ' ).S. \nTHEOREM 2.8. g is the largest coinductive strong subcontract relation. It turns out that the relation \ng is the must testing preorder as de.ned by De Nicola and Hennessy (1984) (a proof can be found in (Laneve \nand Padovani 2007), where a different albeit equivalent notion of strong compliance is used). This relation \nis well studied and it enjoys interesting properties, in particular it is a precongruence with respect \nto pre.xing, internal and external choices, and also a.b ga, which is one of the desirable properties \nfor , holds. However gis stronger than since, for example, a ga +b. Indeed a.e +b -a but a.e +b -a +b. \nIn general, the must preorder allows neither width nor depth extensions of contracts. In previous work \n(Carpineti et al. 2006) an attempt was made to directly relate two contracts s and t depending on their \nform, rather than on the sets of their clients. Let dual(s) denote the dual contract of s which, roughly, \nis obtained by replacing in s every action by its coaction, 0 by e, every internal choice by an external \none, and viceversa (the formal de.nition is slightly more involved and requires .rst to transform s into \nthe normal form of De.nition 3.10 and then apply the transformation described above; see (Carpineti et \nal. 2006) for details). Intuitively dual(s)denotes the contract of a canonical client complying with \ns services. Then one can de.ne a new relation on service contracts as: def s K t .. dual(s)-t (1) In \nwords, a contract s is a subcontract of t if and only if its canonical client complies with t . This \nrelation is nearly what we are looking for. For instance now we have a .b.c K a and a K a +b.d,since \ndual(a .b.c)= a.e +b.c. e -a and dual(a)=a.e -a +b.d. Unfortunately, K is not a preorder since transitivity \ndoes not hold: a.e +b.c. e -a +b.d implies that a .b.c K a +b.d. The reason for such a failure is essentially \ndue to the fact that in establishing a .b.c K a and a K a +b.d we are restricting compliance to conversations \nin which no synchronisation on the name b happens. While contracts account for non-determinism that is \ninternal to each process being it a client or a service , they cannot handle the system non-determinism \nthat springs from process synchronisation. In the example above, the failure results from the interaction \nof two external choices, a.e+b.c. e and a+b.d, which yields non-determinism at system level and which \ndoes not prevent apriori a synchronisation on the b name. By preventing the synchronisation on the name \nb, the client a.e +b.c.e can terminate successfully.  In summary, the strong subcontract relation implements \na safe substitutability relation for services that are compatible, but is ex\u00adcessively demanding because \nit takes into account every possible synchronisation. Our theory of contracts will de.ne a safe substi\u00adtutability \nrelation for services that can be made compatible.  3. A theory of contracts At the end of the previous \nsection we said that we wanted a sub\u00adcontract relation st such that a service with contract t can be \nmade compatible with a service with contract s. The keypoint of the discussion is the can be made . Of \ncourse we do not want to consider arbitrary transformations of the service, e.g. transformations that \nalter the semantics of the service. In fact, we cannot hope to affect in any way the internal non-determinism \nof a service as the service is typically considered as an unmodi.able black box. Instead we look for \ntransformations that embed a t service in a world of s clients so that such clients will perceive their \ninteraction as being carried over a service with contract s (or possibly a more deterministic one). Roughly \nspeak\u00ading we want to .lter out all behaviours of the t contract that do not belong to the possible behaviours \nof s world, and leave the others unchanged. This is, precisely, the characterisation of an explicit co\u00adercion \nfrom t to s (recall that the subcontract relation is the inverse of a service subtyping relation; cf. \nFootnote 1): an embedding func\u00adtion that maps possible behaviours of t into the same behaviours of s \n(thus, it does not add new computation). 3.1 Weak subcontract relation The idea is that st if there exists \nsome (possibly empty) set of actions belonging to the world of t that, if shielded, can make a t service \nappear as a s service. This is formalised by the following de.nition: DEFINITION 3.1 (WEAK SUBCONTRACT). \nW is a weak subcon\u00adtract relation if (s, t ).Wimplies that if t .R, then there exists SR . R such that \n(1) s . SR and (2) for all a . SR we have (s(a),t (a)).W. We denote by the largest weak subcontract relation. \nThe basic intuition about the weak subcontract relation is that a client that interacts successfully \nwith a service with contract s must be able to complete whatever ready set is chosen from s.If we want \nto replace the service with another one whose contract is t , we require that whatever ready set R is \nchosen from t there is a smaller one SR . R in s such that all of the continuations with respect to the \nactions in SR are in the weak subcontract relation. However, in order to avoid interferences we might \nneed to .lter out the actions in R \\SR. First of all notice that the weak subcontract relation includes \nthe strong one (condition (1) is essentially the same and condition (2) is weaker), so that, for example, \na .b.c a holds. Additionally, we also have aa +b.d since a service with contract a +b.d can be made to \nbehave as a service with contract a by .ltering out the b action. On the other hand, aa .b.c since there \nis no way to make a .b.c behave as a by simply .ltering out actions (.ltering out the b action from a \n.b.c yields a .0, not a). Finally, we also have a .b.c a +b.d, again by .ltering out the b action. In \nthis case, the .ltered service (a +b.d) is not made equivalent to the smaller service (a .b.c) but rather \nto one of its more deterministic behaviours (a). 3.1.1 Weak compliance In contrast with the strong case, \nfor the weak subcontract relation it was more intuitive to provide its coinductive characterisation .rst. \nWe now face the problem of understanding which notion of compliance induces the weak subcontract relation. \nAs we will see, this is an essential intermediate step as it provides the necessary insight for devising \nthe practical solution to the problems described in \u00a7 2.4. DEFINITION 3.2 (WEAK COMPLIANCE). D is a weak \ncompliance relation if (., s).D implies that there exists a .nite set of actions A .N . N such that: \n1. . . R and s . S implies e . R or co(R)n A n S =\u00d8 , and aa 2. a . A, . -. . ' and s -. s ' implies \n(. ' ,s ' ).D . We denote by - the largest weak compliance relation. Note how the existence of the set \nA in the above de.nition must be independent of the ready sets of the client and of the service. This \nre.ects the fact that the internal non-determinism of the interacting parties cannot be affected. The \nfollowing theorem proves that - is the compliance relation inducing . THEOREM 3.3. st if and only if \nfor all ., . - s implies . - t . 3.1.2 Comparison with other relations In \u00a7 2.4 we said that the relation \nK de.ned by equation (1) was nearly what we sought for, but for the lack of transitivity it was not a \npreorder. The following theorem shows that obviates this problem. THEOREM 3.4. The subcontract relation \nis the transitive clo\u00adsure of K. For what concerns the inclusion of the strong relation in the weak one \nnote that if we compare De.nition 3.1 with De.ni\u00adtion 2.7, we see that they differ on the set of a s \nconsidered in con\u00addition (2). The latter requires that whatever interaction may happen between a client \nand a server, the relation must be satis.ed by the continuations. The former instead requires this to \nhappen only for interactions on actions that are expected for the smaller contract. This means that with \nthe weak subcontract relation all the actions that are not expected by the smaller contract must not \ntake part in the client-server interaction. If we want to replace a server by a dif\u00adferent server with \na (weak) super-contract, then we must ensure that the client is shielded from these unexpected actions. \nThe technical instrument to ensure it are the .lters we de.ne next.  3.2 Filters A .lter is the speci.cation \nof a set of actions that are allowed at a certain time, along with the continuation .lters that are applied \nafter an action has occurred: f ::=a. A a.fa By convention we use 0 for denoting the empty .lter, that \nis the .lter that allows no action (A =\u00d8 ). Filters have a simple transition relation, as follows: \u00df \na. A a.fa -. f\u00df if \u00df . A aa As usual we write f -. if there is no f ' such that f -. f ' . The application \nof a .lter f to a contract s, written f(s), produces another contract where only the allowed actions \nare visible: f(0)= 0 a f(a.s)= 0 if f -. a f(a.s)= a.fa(s) if f -. fa f(s +t )= f(s)+f(t ) f(s . t )= \nf(s). f(t ) Filter application is monotone with respect to the strong sub\u00adcontract preorder. This property, \nwhich is fundamental in proving most of the results that follow, guarantees that equivalent contracts \nremain equivalent if .ltered in the same way. PROPOSITION 3.5. s g t implies f(s)g f(t ). Filters allow \nus to express the weak subcontract relation in terms of the strong one: THEOREM 3.6. st if and only if \nthere exists a .lter f such that s g f(t ). 3.2.1 Examples of .lters Let us consider again our example \nof a . b.c and a +b.d.These contracts are not related by the strong subcontract relation, but any client \ncomplying with the .rst one has to be ready to read on a and then terminate. Then, we see that the second \none can be made compliant with any such client, because it is ready to write on a: so we are sure that \nsynchronisation on a is possible, and that if it occurs the client will terminate. The point is then \nto ensure that this synchronisation will indeed occur and that the channel b will not be selected instead, \nwhich would lead to deadlock. This is done by applying to a +b.d the .lter f = a, which lets the sole \naction a pass. Formally, wehavethat f(a +b.d)= a,and a . b.c g a holds. We have already hinted in the \nintroduction that to prove an inclusion such as a.b (a.(a +b))+b.c .lters must be able to selectively \nblock along the computation, as b must be blocked only at the .rst step of the interaction and a only \nat the second step of the interaction. In this case the sought behaviour is obtained by the single-threaded \n.lter f =a.b which applied to the contract on the right yields the one on the left. It is worth noticing \nthat such .ne-grainedness of .lters is useful also in practice. Consider again the last example of \u00a7 \n2.2.2, where we extended the service by a 1\u00adclick ordering capability. We said that backward compatibility \ncan be obtained by .ltering out the newly added Buy action. But if we slightly expand the resulting contract \ns ' ...Catalog.(Logout+Buy.sB+AddToCart.(Logout+Buy.(...))) we notice that there is also a Buy action \nafter AddToCart.In order to make a service of contract s ' implement the contract s de.ned in \u00a7 2.2.2, \none must block the Buy action offered right after the Catalog action, but allow the old Buy action in \nthe continuation of AddToCart to pass through. This is performed by the .lter obtained from s by replacing \nfor every sum (either internal or external) occurring in it.  3.2.2 Deduction system for Filters can \nalso be used as proofs (in the sense of the Curry-Howard isomorphism) for the weak subcontract relation. \nMore speci.cally, the idea is to devise a deduction system within which a derivable judgement of the \nform f : s = t implies that st ,and f is a .lter that embeds services with contract t into the world \nof s\u00adcompliant clients. The de.nition of such deduction system requires a few auxiliary notions. First \nwe have to de.ne the identity .lter, that is the one that proves isomorphic (with respect to an interpretation \nof .lters as morphisms) contracts. DEFINITION 3.7. The identity .lter for a contract s, denoted by Is, \nis de.ned as def Is = aa.Is s -. s It is easy to see that Is(s)=s. Next, we de.ne two basic operations \nfor combining .lters. Intuitively, given a derivation tree for the judgement f : s = t , s +s =ss . \ns =s s +t =t +ss . t =t . s +s '' s . (s ' . s '' ). s '' s +(s ' )=(s +s ' )+s '' )=(s . s ' ). (s \n+s '' +s '' s +(s ' . s '' )=(s +s ' ) s . (s ' )=(s . s ' )+(s . s '' ) s +0 =s a.s +a.t =a.(s . t ) \na.s . a.t =a.(s . t ) (WEAKENING) (TRANSITIVITY) (MUST) (DEPTHEXT) = s '' f :s = tg . It . ff :s = s \n' g :s ' Is . It :s . t = s 0 :0 = s f . g :s = s '' f . g :s = t (PREFIX) (INTCHOICE) (EXTCHOICE) f \n:s = t f :s = s ' f :t = t ' f :s = s ' f :t = t ' a.f :a.s = a.t f :s . t = s ' . t ' f :s +t = s ' \n+t ' Table 1. Deduction system for the weak subcontract relation. such operations allow us to show how \nthe .lter f is built step-by\u00adstep, according to the structure of the derivation. DEFINITION 3.8. Let \nf and g denote the .lters a.fa and a.A a.B a.ga respectively. Then the conjunction and disjunction of \nf and g are respectively de.ned as follows: def f . g = a.(fa . ga) a.AnB 8 <fa . ga,a . A n B def f \n. g = a. fa,a . A \\ B a.A.B : ga,a . B \\ A Finally, we need a way for comparing .lters. Filters can be \ncom\u00adpared according to the actions that they let pass. In the deduction system the need for comparing \n.lters arises naturally in the weak\u00adening rule, where we want to replace a .lter with a larger one (a \n.lter that allows more actions). This can be done safely only if the larger .lter does not thwart the \nfunctionality of the original .lter by re-introducing actions that must be kept hidden. The .lter pre-order \nwill also be fundamental in \u00a7 3.3, in order to de.ne the best .lter that proves st . DEFINITION 3.9. \nThe ordering relation on .lters f . g is the least . relation such that a.fa \u00df.g\u00df implies A . B and a.A \n\u00df.B for every a . A, fa . ga. Filters can be seen as n-ary trees with edges labelled by actions, each \nnode having at most one outgoing edge labelled by a given ac\u00adtion. The ordering we just introduced is \nnothing but tree inclusion where we consider that all trees share the same root. It is useful to notice \nthat the syntactical conjunction and disjunction in Def\u00adinition 3.8 can be alternatively de.ned in a \nnatural way using the ordering: the conjunction of two .lters is the largest part common to both trees, \nthat is, their greatest lower bound: f1 ? g and f2 ? g .. (f1 . f2)? g (2) Similarly, the disjunction \nof two .lters is the tree obtained by merging the two initial trees, that is their least upper bound: \nf1 . g and f2 . g .. (f1 . f2). g (3) A further interpretation of .lters is as pre.x-closed regular lan\u00adguages \nof strings of actions. Then, .lter conjunction and disjunc\u00adtion correspond to language intersection and \nunion, respectively, whereas the .lter ordering is set inclusion (notice that the intersec\u00adtion and the \nunion of pre.x-closed sets is again pre.x-closed). Table 1 de.nes the deduction system for . In the table \nwe use a single axiom s =t as a shorthand for two axioms Is :s = t and It : t = s. The equalities and \nrule (MUST) are well known since they fully characterise the strong compliance relation, which coincides \nwith the must preorder (see (De Nicola and Hennessy 1984; Hennessy 1988)). Notice that in the rule (MUST) \nno action needs to be .ltered out. In fact, this is the only axiom for safely enlarging a contract without \nthe intervention of any .lter (which is expected since this axiom characterises strong compliance, where \n.lters are not needed). Rule (DEPTHEXT) formalises depth exten\u00adsion of contracts, where a contract can \nbe prolonged if no action is made visible from the continuation. Rule (WEAKENING)shows how to safely \nenlarge a .lter f to f . g: the premise g . It . f states that g may allow actions not allowed by f, \nprovided that such actions are not those that have been hidden for the purposes of proving f : s = t \n.Rule (TRANSITIVITY) is standard and the resulting .lter is the composition .lter. Three forms of (lim\u00adited) \npre-congruence follow. Rule (PREFIX) is standard and poses no constraints. Rules (INTCHOICE)and (EXTCHOICE) \nstate the limited precongruence property for internal and external choices, respectively. The fundamental \nconstraint is that two contracts com\u00adbined by means of . or +can be enlarged, provided that they can \nbe .ltered in the same way. This requirement has an intuitive ex\u00adplanation: the .lter that mediates the \ninteraction of a client with a service is unaware of the internal choices that have been taken by the \nparties at a branching point. So, it must be possible to use the same .lter that works equally well in \nall branches in order for the branches to be enlarged. By combining the rules (DEPTHEXT), (WEAKENING), \nand (EXTCHOICE) it is easy to derive a further rule, which formalises width extension of contracts: (WIDTHEXT) \nIs . It . 0 Is :s = s +t Basically (WIDTHEXT) states that a service can be extended so that it provides \nmore capabilities, provided that such capabilities are disjoint from those that were available before \nthe extension.  3.2.3 Properties The deduction system we devised in the previous section is sound and \ncomplete with respect to and the set of .lters, in the sense that it proves all and only the pairs of \ncontracts that are related according to De.nition 3.1, and for any such pair it deduces all and only \nthe .lters that validate the pair according to Theorem 3.6. While the soundness of the deduction system \ncan be easily established, its completeness is less immediate, but the proof of this fact follows a standard \npattern: completeness is proved for a restricted class of contracts which are said to be in some normal \nform and then it is shown that it is always possible to transform an arbitrary contract to an equivalent \none which is in normal form by using the axioms. Although in this version of the paper the proofs of \ntheorems are omitted, we nevertheless introduce here the normal form of contracts. The same normal form \nwill be necessary anyway in \u00a7 3.3 for de.ning the algorithmic version of the deduction system. As regards \nthe actual de.nition of the normal form, we can notice that it is always possible to add new ready sets \nto a given contract s without altering its semantics (according to ), so long as Is does not change and \nthe new ready sets contain older ones: for example, s . ts . t . (s + t ). Now we can see that, if we \nsaturate the set of ready sets of a contract by adding to it every possible ready set meeting the conditions \nabove, we can build a unique (up to commutativity and associativity) normal form for each equivalence \nclass. This normal form is de.ned as follows: DEFINITION 3.10 (NORMAL FORM (HENNESSY 1988)). For any \ncontract s, we de.ne its saturated set of ready sets: def S R (s)= { R . S |. S,s . S . S . R} s.S The \nnormal form of s is then de.ned up to associativity and commutativity of the choices by the following \nrecursive expression: def LP nf(s)= a.nf(s(a)) R.R(s) a.R the empty external choice being de.ned as 0 \n(it is not necessary to de.ne the empty internal choice, because any contract has at least one ready \nset). Normal forms can be used as the canonical representations of classes of the equivalence relation \n: PROPOSITION 3.11. s nf(s). The normal form enjoys also the following important properties: (1) In a \ngiven mix of internal and external choices (either at top\u00adlevel or under a given sequence of pre.xes), \na pre.x a is always followed by the exact same continuation. (2) If s and t are two normal form contracts \nsuch that s g t , condition (1) of the strong subcontract relation holds if and only if every ready set \nof t is also a ready set of s. These two properties lead to the fact that two equivalent normal forms \nare syntactically equal up to commutativity and associativity of the choice operators. We now possess \nall the technical tools to prove that the deduc\u00adtion system shown in Table 1 is sound and complete for \nand the sets of .lters that prove it. THEOREM 3.12. f : s = t if and only if s g f(t ). As we did for \nthe weak subcontract relation, the weak com\u00adpliance relation can be decomposed in terms of .lters and \nstrong relation: COROLLARY 3.13. . - s .. . t s,. -t (4) .. . f, . -f(s) (5) Finally .lters have an operational \nmeaning, since they allow us to state the soundness of our type system. This can be roughly expressed \nas the fact that given a service and a weakly compliant client, every interaction between them mediated \nby the .lter that proves the weak compliance (Corollary 3.13 (5)) will be successful (the client terminates). \nThis will be formally stated in \u00a7 3.4.  3.3 Algorithmic deduction system We introduced a device, .lters, \nthat allows us to transform a weak subcontract or compliance relation into a strong one by shielding \nthe incompatible actions. The next step is to infer .lters algorith\u00admically, so that the weak relations \ncan be used in practice. As usual the process of .nding a decision algorithm for a con\u00adtainment relation \ncorresponds to a cut-elimination process (the cut herebeingthe (TRANSITIVITY)ruleinTable1),whichamountsto \n.nding a canonical proof for each provable relation. In other terms, we have to associate every provable \nweak subcontracting relation with a canonical .lter that represents all other possible proofs. In order \nto choose a canonical .lter, we have to solve two potential problems. First, there usually are several \n.lters that work with a given relation. For example, to show that a . ba + b, we can either let pass \nonly a, only b, or both. The best solution here is to let pass both, because we do not want to shield \nout actions that cannot cause any harm. This example suggests the de.nition of a notion of better .lter \n, that is, of a partial order on .lters that determines which .lter is better to use, and such partial \norder is exactly (De.nition 3.9). The second problem is that in the example above a .lter that lets a, \nb, and, say, c pass will work as well. The intuition here is that the .lter that lets just a and b pass \nis better since allow\u00ading any action besides a and b to pass is useless. This suggests the de.nitions \nof a notion of .lter relevance , to single out .lters that do not contain useless actions. The subcontracting \nalgorithm will pick up, among all the possi\u00adble .lters for a given relation, the best relevant .lter \nthat proves it. 3.3.1 Filter relevance In order to determine the property of relevance we have to better \nunderstand the role played by the identity .lters. It may be noted that the identity .lter of a given \ncontract is exactly the tree of all possible sequences of actions that the contract can do before reducing \nto 0, without distinguishing between internal and external choices. This is embodied by the . operator \non .lters which is a unique choice operator representing both kinds of choice, as the following relation \nshows: Is.t = Is+t = Is . It (6) Note that if s and t share common actions in their outermost pre\u00ad.xes, \nthe continuations of both .lters after this action are correctly merged by the disjunction operator. \nThe tree of an identity .lter accurately represents the idea we mentioned in the introduction of a contract \ns world : the sets of actions the contract knows of at each step of an interaction. A .lter f : s = t \nembeds t services into the world of s:then the intuition is that to be relevant f must be de.ned (only) \non the world of t , world that is represented by It . Indeed, applying to t the .lter f or the .lter \nf . It give the same result, thus the part of f that is not in f . It is irrelevant (and this is why \nthere is no greatest .lter corresponding to a given relation in the absolute). Thus we will say that \na .lter f is relevant with respect to a relation st if it is smaller than It . Now if we restrict ourselves \nto relevant .lters we can have another interesting upper bound: if we look at condition (2) of the strong \nsubcontract relation, we see that, at each step, every action available to the greater contract has to \nbe available also to the smaller one. This exactly means that the greater contract has a smaller tree, \nand thus we have (by noticing that If(s) = f . Is): if s g f(t ) and fIt then fIs (7) Thus relevant .lters \nthat prove a relation have to be smaller than the identity .lters of both contracts. We now would like \nto .nd the greatest relevant .lter that proves a given relation. Note that projecting on Is . It itself \nis not necessarily enough to make the relation work, because of ready sets: it might be necessary to \nproject on something smaller to prevent a wrong branch to be taken, for example in a . b.(a +b) a +b.(a \n. b), the initial b has to be .ltered out even if the trees are the same, because its continuation in \nthe right contract has incompatible ready sets. However, the following important relation holds: if s \ng f(t )and s g g(t )then s g (f . g)(t ) (8) meaning that if we can make the relation work either by \nselecting some branches or by selecting some other branches, then it will still work if we take all these \nbranches at once. This shows that, if st holds, there will be a greatest subtree of t that makes the \nrelation work: even if there is no greatest .lter in the absolute, we can take the disjunction of all \n.lters less than It that work (there are a .nitely many). This .lter, which is the least upper bound \nof all relevant .lters that prove st , is the one we choose as canonical. 3.3.2 Algorithm The last step \nis to de.ne an algorithm for building the canonical .lter of a relation. The monotonicity of .lters (Proposition \n3.5) and the soundness and completeness of the deduction system (Theo\u00adrem 3.12) ensure that .lters prove \nsubcontracting modulo equiva\u00adlence, that is if f : s = t ,then f : s ' = t ' ,for any s ' s, t ' t . \nSince a contract is equivalent to its normal form (Propo\u00adsition 3.11), then the set of .lters that prove \nst is the same as the set of those that prove nf(s) nf(t ). Therefore in order to choose in this set \na canonical .lter for st , it suf.ces to choose it for their normal forms. Hence, we de.ne the following \nalgorithm: DEFINITION 3.14. We de.ne the ternary relation f : s t between a .lter and two contracts in \nnormal form by the inference rule SS A ={ a . ( R)n ( S)|. fa,fa :sa ta} R.R S.S A ={ A ' . A |. S .S \n, S n A ' .R} A =\u00d8 W LP LP a.fa : a.sa a.ta A .A a.AR.R a.RS.S a.S We then extend the relation to arbitrary \ncontracts by the follow\u00ading de.nition: def f :s t .. f :nf(s) nf(t ). Although it is not immediate, the \nde.nition above describes an algorithm to check whether two contracts are in relation: .rst the two contracts \nare put in normal form; then for every action a that can be immediately emitted by both normal forms, \nthe algorithm is recursively called on the two continuations of the action. The set A represents the \nlargest set of actions leading to continuations which are in the relation and the recursion basis occurs \nwhen A =\u00d8 .The set A contains the subsets A ' . A such that, by restricting each ready set of the larger \ncontract to the actions in A ' , thisisa ready set of the smaller contract (recall that for any two contracts \ns and t in normal form such that s g t , every ready set of t is also a ready set of s). If there is \nat least one such A ' set of actions (A =\u00d8 ), then s and t can be related. The .lter de.ned in the conclusion \nis the disjunction of the .lters corresponding to all these sets of actions: it uses Equation (8) to \ncompute the greatest relevant .lter. 3.3.3 Properties The algorithm described in De.nition 3.14 enjoys \nfundamental properties, namely (i)it proves only (soundness) and all (complete\u00adness) weak subcontract \nrelations, (ii)in case of success it returns the largest relevant .lter that proves the relation and \n(iii)it always terminates, which implies the decidability of the weak subcontract relation. LEMMA 3.15 \n(FILTER RELEVANCE). If f :s t ,then fIt . THEOREM 3.16 (SOUNDNESS). If f :s t then s g f(t ). THEOREM \n3.17 (COMPLETENESS). If s g g(t ), then there exists a .lter f such that f :s t , and f ? g . It . COROLLARY \n3.18. If s and t are two contracts, there exists at most one .lter f such that f :s t .Furthermore, if \nf :s t , then f =max{ gIt | s g g(t )} =max{ gIt | g :s = t } . The corollary above describes the logical \ninterpretation of the al\u00adgorithm as the result of a cut-elimination process. The cut in the system of \nTable 1 is given by the rule (TRANSITIVITY). This rule intersects .lters, that is it minimises the proofs: \ntherefore in order to eliminate cuts we have to .nd a proof with a maximum .lter. However we have also \nto avoid useless applications of the (WEAK-ENING) rule, which instead maximises proofs: therefore we \nhave to set an upper bound to .lter maximisation, upper bound embodied by the de.nition of relevance \n(therefore it would be more precise to speak of a cut-weakening-elimination process). PROPOSITION 3.19 \n(DECIDABILITY). Given two contracts s and t , we can decide whether there exists a .lter f such that \nf :s t and compute this .lter.  3.4 Language The .nal step of our investigation is to relate contracts \n(which are behavioural types) with processes that implement clients and services. We do not consider \nany particular process language, nor do we require that clients and services be implemented using the \nsame language. We just require that the observable behaviour of such language(s) be described by a labelled \ntransition system and abstracted by a static type system, so that we can reason about their programs. \nMore precisely we assume that a process language is equipped with a labelled transition system so that \n\u00b5 P -. P ' describes the evolution of a process P that performs a \u00b5 action thus becoming the process \nP ' . Here, \u00b5 can either be a visible action of the form a or a, which is meant to synchronise with the \ncorresponding co-action in the process P is interacting with, or it can be an internal, invisible action \nt (not to be confused with t that we used to range over contracts) that the process P \u00b5 executes autonomously. \nIt is understood that the relation -. is not necessarily deterministic. As usual, we let a range over \nvisible \u00b5\u00b5 actions and we write P -. if P -. P ' for some process P ' . DEFINITION 3.20 (STRONG PROCESS \nCOMPLIANCE). Let P I Q -. P ' I Q ' be the least relation de.ned by the rules: P t-. P ' Q t-. Q ' P \nI Q -. P ' I Q P I Q -. P I Q ' P a-. P ' Q a-. Q ' P I Q -. P ' I Q ' We write =. for the re.exive, \ntransitive closure of -. ; we write P I Q -. if P I Q -. P ' I Q ' for some P ' and Q ' ; we write P \nI Q -. if not P I Q -. . The client P is strongly compliant with the service Q, written e P -Q, if whenever \nP I Q =. P ' I Q ' -. we have P ' -. . The intuition of this de.nition is that P I Q represents a client \nP and a service Q interacting with each other. When P -Q every interaction between P and Q terminates \nwith P being able to emit e, denoting the successful completion of P s task. We also assume that a type \nsystem is given to check that a process P implements the contract s. This is expressed by the judgement \n. P :s While we do not give details on the particular typing rules, we require typing and the reduction \nrelation to satisfy some basic properties: essentially, contracts must describe the observational behaviour \nof processes and the reduction must decrease non\u00addeterminism (entropy must always increase). In this \nrespect, it makes sense to be able to apply the strong subcontract relation to client contracts too, \nwhere the action e is treated like any other action (recall that, according to Theorem 2.8, the relation \ng can be de.ned without any notion of successful action e). DEFINITION 3.21. Thetypesystem is consistent \nif, whenever . \u00b5 ' : s ' P : s and P -. P ' ,then . P and (1) if \u00b5 = t,then a s g s ' ;(2) if \u00b5 =a,then \ns -. and s(a)g s ' . The type system aa is informative if, whenever . P :s and s -. ,then P -. . Condition \n(1) states that a process performing internal actions can only make its contract more deterministic. \nCondition (2) states that if a process performs a visible action a, then its contract must account for \nthat action and the contract of the resulting process P ' is (more deterministic than) the contract s(a), \nwhich accounts for all the possible behaviours of P after a. An informative type system does not deduce \ncapabilities that a process does not have. The soundness of a consistent and informative type system \nis ensured by the following result, stating that if the contracts of two processes comply, the corresponding \nprocesses comply as well, guaranteeing termination on the client side. THEOREM 3.22. If . P :. and . \nQ :s and . -s then P -Q. Notice that the soundness theorem holds when the client s con\u00adtract and the \nservice s contract are strongly compliant. To be able to use a service for which we only have a weakly \ncompliant client, we need to shield potentially dangerous service actions by means of a .lter. Thus, \nwe enrich the process language with an operator f[P ] that applies a .lter f to a process P , the idea \nbeing that the .lter constraints the set of visible actions of P , that is its capabilities to interact \nwith the environment, still not altering its behaviour. The labelled transition system of the language \nis consequently enriched with the following two inference rules: (FILTER1) (FILTER2) aat '' ' P -. Pf \n-. fP -. P at '' ' f[P ]-. f [P ] f[P ]-. f[P ] The introduction of .lters into the process language \nhas conse\u00adquences on the type system as well. Since our discussion is para\u00admetric in the process language \nand in the type system, we only need to show that the typing rule (TYPEFILTER) . P :s . f[P ]:f(s) does \nnot jeopardise the type system. PROPOSITION 3.23. A consistent and informative type system en\u00adriched \nwith rule (TYPEFILTER) results in another consistent and informative type system. The following result \nsummarises the contribution of our work: the adoption of .lters enlarges the number of possible services \nthat can be used to let a client terminate. COROLLARY 3.24. If . P : ., . Q : s, and . -f(s),then P -f[Q]. \n  4. Conclusion and Future Work This paper provides a foundation for behavioural typing of Web services \nand it promotes service reuse and/or rede.nition by the introduction of a subcontract relation. Our approach \nreconciles two hitherto apparently incompatible requirements. On the one hand a subcontract relation \nmust allow a service to be replaced or upgraded by offering more operations (width subtyping), longer \ninteraction patterns (depth subtyping) and/or more deterministic ones. On the other hand this must be \ndone without disrupting the behaviour of clients. Filters provide the technical device that makes it \npossible. Al\u00adthough we initially de.ned .lters essentially as technical mecha\u00adnism to couple clients \nand services, .lters turn out to have an el\u00adegant logical justi.cation: they are explicit coercions between \nre\u00adlated contracts. Following the Curry-Howard isomorphism .lters can be interpreted as proofs of a sound \nand complete deduction system for the subcontract relation. Such deduction system simul\u00adtaneously re.nes \nand extends Hennessy s classical axiomatisation of the must testing preorder. Its algorithmic counterpart \nis obtained as a cut elimination process, which proves the coherence of subcon\u00adtracting as a logical \nsystem. The canonical proof, the one produced by the algorithmic deduction system, is characterised in \nterms of an order relation on .lters, and the algorithmic presentation allows us to show the decidability \nboth of the subcontracting relation and of .lter inference. The theory of subcontracting is independent \nof the language used to implement services and clients. We do not rely on a par\u00adticular language nor \non a particular paradigm (objects, process al\u00adgebrae, functions, ...). By de.ning some minimal requirements \non the language (in a nut-shell, the observable behaviour of its pro\u00adgrams must be faithfully captured \nby contracts), we establish the soundness of our contract system: clients always terminate interac\u00adtions \nwith any, possibly .ltered, compliant service. Filters thus play the double role of a proof tool and \nof pro\u00adgramming glue between clients and services. As an aside it is nice to notice that .lters can encode \nCCS and p-calculus restrictions: (.a)P =faP [P ]where a.faP . faP =a.(fn(P ).co(fn(P ))\\{a,a } Even \nif in this presentation we applied .lters to services, in prac\u00adtice it is the client s responsibility \nto apply them. A client searching for a service with a given contract will receive as answer to its query \nthe reference of a service together with a .lter that allows the client to use the service. Thus the \n.lter must be computed by the query engine, which is why the algorithmic inference of .lters is crucial \nfor a practical application. Actually, it is more realistic to imagine that a query will be answered \nwith several different contracts requiring .lters that may be unrelated one to each other. Therefore \na second use of .lters could be that of re.ning the search space, by specifying in a query a minimum \nacceptable .lter. In this way the client could specify which of the possible behaviours of its canon\u00adical \nservice are considered mandatory and not to be .ltered out. For instance when searching for services \nimplementing the behavior described in Figure 1 we can specify, along with the query, the .lter Login.ValidLogin.Query.Catalog.AddToCart. \n Buy.(CreditCard.Valid BankTransfer.Valid) thus obtain\u00ading only services that may complete a sale, avoiding \nuseless ser\u00advices such as those with contract Login.InvalidLogin. Several future research directions \nstem from this work. The following is a non-exhaustive list: Recursion and higher-order: The contracts \nand .lters we dis\u00adcussed in this work are .nite. The next step of this research is the introduction of \nrecursion both in contracts and, consequently, in .lters. Actually, most of the proofs (which are available \nin the full version) use coinduction and they can be applied with minor changes to the recursive case. \nAlso, for the time being synchroni\u00adsation does not carry any information. Thus a further natural step \nis the introduction of higher order channels ` ala p-calculus. Asymmetric choices: The choice operators \nare commutative. We could try to relax this property in order to give the summands different priorities, \nwhich is impossible with the current de.nitions. For instance, there is no way for a client that has \nto use a service with contract (a + b) . a to specify that it wants to connect with b if this action \nis available, and with a otherwise (in order to be compliant it must accept a possible synchronisation \nwith a). It is unclear to which extent such constructs would affect the preorder over contracts. Contract \nisomorphisms: The only morphisms between contracts we have considered are .lters. Since .lters are coercions, \nthen by de.nition they essentially do not alter the semantics of objects. One could try to consider more \nexpressive morphisms (e.g. renaming and/or reordering of actions) and to completely characterise the \nisomorphisms of contracts. This would allow us to perform service discovery modulo isomorphisms: when \nsearching for services of a given contract a client could be returned a service and two conver\u00adsion functions, \none to call the service, the other to convert results (see (Rittri 1993; Di Cosmo 1995)). This could \nlater be extended to richer query/discovery lan\u00adguages obtained by adding union, intersection and negation \ntypes on the basis of the set-theoretic interpretation presented here and of the work on semantic subtyping \n(Castagna and Frisch 2005). Relation with other formalisms: Finally, connection with other formalisms \nsuch as linear logic, session types, and game seman\u00adtics must surely be deeply investigated. In particular, \nas regards the semantic aspects, it is interesting to notice that clients and services introduce a notion \nof orthogonality which suggests that a realisabil\u00adity semantics for contracts is worth to be explored. \n References A. Alves, A. Arkin, S. Askary, C. Barreto, et al. Web Services Busi\u00adness Process Execution \nLanguage Version 2.0, April 2007. OA-SIS Standard, http://docs.oasis-open.org/wsbpel/2.0/OS/ wsbpel-v2.0-OS.html. \nA. Banerji, C. Bartolini, D. Beringer, V. Chopella, et al. Web Services Conversation Language (WSCL)1.0, \nMarch 2002. W3C Note, http: //www.w3.org/TR/2002/NOTE-wscl10-20020314. T. Bellwood, S. Capell, L. Clement, \nJ. Colgrave, et al. UDDI Version 3.0.2, 2005. OASIS Standard, http://uddi.org/pubs/uddi-v3.0. 2-20041019.htm. \nM. Bravetti and G. Zavattaro. Towards a unifying theory for choreography conformance and contract compliance. \nIn Proc. of the 6th Intl. Sympo\u00adsium on Software Composition. Springer, 2007. K. Bruce and G. Longo. \nA modest model of records, inheritance and bounded quanti.cation. Information and Computation, 87(1/2):196 \n240, 1990. M. Carbone, K. Honda, and N. Yoshida. A calculus of global interaction based on session types. \nElectronic Notes in Theoretical Computer Science, 171(3):127 151, 2007a. M. Carbone, K. Honda, and N. \nYoshida. Structured communication-centred programming for web services. In ESOP 07, 16th European Symposium \non Programming, LNCS 4421. Springer, 2007b. L. Cardelli. A semantics of multiple inheritance. Information \nand Compu\u00adtation, 76:138 164, 1988. S. Carpineti, G. Castagna, C. Laneve, and L. Padovani. A formal account \nof contracts for Web Services. In 3rd Int. Workshop on Web Services and Formal Methods, LNCS 4184. Springer, \n2006. G. Castagna and A. Frisch. A gentle introduction to semantic subtyping. In PPDP 05 ACM Press (full \nversion) and ICALP 05, LNCS 3580, Springer (summary), 2005. Joint ICALP-PPDP keynote talk. G. Castagna, \nN. Gesbert, and L. Padovani. A theory of contracts for web services. In PLAN-X 07, 5th ACM-SIGPLAN Workshop \non Program\u00adming Language Technologies for XML, 2007. G. Chen. Soundness of coercion in the calculus of \nconstructions. Journal of Logic and Computation, 14(3):405 427, 2004. R. Chinnici, J.-J. Moreau, A. Ryman, \nand S. Weerawarana. Web Services Description Language (WSDL) Version 2.0 Part 1: Core Language, June \n2007b. W3C Recommendation, http://www.w3.org/TR/wsdl20/. R. Chinnici, H. Haas, A.-A. Lewis, J.-J. Moreau, \net al. Web Ser\u00advices Description Language (WSDL) Version 2.0 Part 2: Adjuncts, June 2007a. W3C Recommendation, \nhttp://www.w3.org/TR/ wsdl20-adjuncts/. R. De Nicola and M. Hennessy. CCS without t s. In TAPSOFT/CAAP \n87, LNCS 249, pages 138 152. Springer, 1987. R. De Nicola and M. Hennessy. Testing equivalences for processes. \nTheo\u00adretical Computer Science, 34:83 133, 1984. R. Di Cosmo. Isomorphisms of Types: from Lambda Calculus \nto Informa\u00adtion Retrieval and Language Design.Birkh\u00a8auser, 1995. D. C. Fallside and P. Walmsley. XML \nSchema Part 0: Primer Second Edition, October 2004. W3C Recommendation, http://www.w3.org/ TR/xmlschema-0/. \nC. Fournet, C. A. R. Hoare, S. K. Rajamani, and J. Rehof. Stuck-free conformance. In CAV 04, LNCS 3114. \nSpringer, 2004. S. Gay and M. Hole. Subtyping for session types in the p-calculus. Acta Informatica, \n42(2-3):191 225, 2005. M. Hennessy. Algebraic Theory of Processes. Foundation of Computing. MIT Press, \n1988. M. Hennessy. Acceptance trees. Journal of the ACM, 32(4):896 928, 1985. K. Honda. Types for dyadic \ninteraction. In CONCUR 93, LNCS 715, pages 509 523. Springer, 1993. K. Honda, V. T. Vasconcelos, and \nM. Kubo. Language primitives and type discipline for structured communication-based programming. In European \nSymposium on Programming, LNCS 1381. Springer, 1998. C. Laneve and L. Padovani. The must preorder revisited \n An algebraic theory for web services contracts. In 18th International Conference on Concurrency Theory. \nLNCS 4703, Springer, 2007. R. Milner. A Calculus of Communicating Systems. Springer, 1982. M. Rittri. \nRetrieving library functions by unifying types modulo linear isomorphism. RAIRO Theoretical Informatics \nand Applications, 27(6): 523 540, 1993. S. Soloviev, A. Jones, and Z. Luo. Some Algorithmic and Proof-Theoretical \nAspects of Coercive Subtyping. In TYPES 96. LNCS 1512, 173 196, Springer, 1996. K. Takeuchi, K. Honda, \nand M. Kubo. An interaction-based language and its typing system. In Parallel Architectures and Languages \nEurope, pages 398 413, 1994. This work was partially supported by the French ACI project Transforma\u00adtion \nLanguages for XML: Logics and Applications (TraLaLA). \n\t\t\t", "proc_id": "1328438", "abstract": "<p>Contracts are behavioural descriptions of Web services. We devise a theory of contracts that formalises the compatibility of a client to a service, and the safe replacement of a service with another service. The use of contracts statically ensures the successful completion of every possible interaction between compatible clients and services.</p> <p>The technical device that underlies the theory is the definition of filters, which are explicit coercions that prevent some possible behaviours of services and, in doing so, they make services compatible with different usage scenarios. We show that filters can be seen as proofs of a sound and complete subcontracting deduction system which simultaneously refines and extends Hennessy's classical axiomatisation of the must testing preorder. The relation is decidable and the decision algorithm is obtained via a cut-elimination process that proves the coherence of subcontracting as a logical system.</p> <p>Despite the richness of the technical development, the resulting approach is based on simple ideas and basic intuitions. Remarkably, its application is mostly independent of the language used to program the services or the clients. We also outline the possible practical impact of such a work and the perspectives of future research it opens.</p>", "authors": [{"name": "Giuseppe Castagna", "author_profile_id": "81100388576", "affiliation": "Universit&#233; Paris 7, Paris, France", "person_id": "PP31040104", "email_address": "", "orcid_id": ""}, {"name": "Nils Gesbert", "author_profile_id": "81436593623", "affiliation": "Universit&#233; Paris-Sud, Paris, France", "person_id": "P925381", "email_address": "", "orcid_id": ""}, {"name": "Luca Padovani", "author_profile_id": "81100024516", "affiliation": "Universit&3224; di Urbino, Urbino, Italy", "person_id": "PP309022200", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328471", "year": "2008", "article_id": "1328471", "conference": "POPL", "title": "A theory of contracts for web services", "url": "http://dl.acm.org/citation.cfm?id=1328471"}