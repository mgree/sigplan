{"article_publication_date": "01-07-2008", "fulltext": "\n The Design and Implementation of Typed Scheme Sam Tobin-Hochstadt Matthias Felleisen PLT, Northeastern \nUniversity Boston, MA 02115 Abstract When scripts in untyped languages grow into large programs, main\u00adtaining \nthem becomes dif.cult. A lack of types in typical script\u00ading languages means that programmers must (re)discover \ncritical pieces of design information every time they wish to change a pro\u00adgram. This analysis step both \nslows down the maintenance process and may even introduce mistakes due to the violation of undiscov\u00adered \ninvariants. This paper presents Typed Scheme, an explicitly typed exten\u00adsion of an untyped scripting \nlanguage. Its type system is based on the novel notion of occurrence typing, which we formalize and me\u00adchanically \nprove sound. The implementation of Typed Scheme ad\u00additionally borrows elements from a range of approaches, \ninclud\u00ading recursive types, true unions and subtyping, plus polymorphism combined with a modicum of local \ninference. Initial experiments with the implementation suggest that Typed Scheme naturally ac\u00adcommodates \nthe programming style of the underlying scripting lan\u00adguage, at least for the .rst few thousand lines \nof ported code. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions \nand Theory; D.3.3 [Language Con\u00adstructs and Features]: Modules, Packages; D.3.m [Miscellaneous]: Cartesian \nClosed General Terms Languages, Design Keywords Type Systems, Scheme 1. Type Refactoring: From Scripts \nto Programs Recently, under the heading of scripting languages , a variety of new languages have become \npopular, and even pervasive, in web\u00adand systems-related .elds. Due to their popularity, programmers often \ncreate scripts that then grow into large applications. Most scripting languages are untyped and have \na .exible seman\u00adtics that makes programs concise. Many programmers .nd these attributes appealing and \nuse scripting languages for these reasons. Programmers are also beginning to notice, however, that untyped \nscripts are dif.cult to maintain over the long run. The lack of types means a loss of design information \nthat programmers must recover every time they wish to change existing code. Both the Perl com\u00admunity \n(Tang 2007) and the JavaScript community (ECMA Inter\u00adnational 2007) are implicitly acknowledging this \nproblem with the Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. POPL 08, January 7 12, 2008, San Francisco, California, USA. Copyright c &#38;#169; 2008 ACM 978-1-59593-689-9/08/0001. \n. . $5.00 addition of Common Lisp-style (Steele Jr. 1984) typing constructs to the upcoming releases \nof their respective languages. In the meantime, industry faces the problem of porting existing application \nsystems from untyped scripting languages to the typed world. Based on our own experience, we have proposed \na theoret\u00adical model for this conversion process and have shown that partial conversions can bene.t from \ntype-safety properties to the desired extent (Tobin-Hochstadt and Felleisen 2006). The key assumption \nbehind our work is the existence of an explicitly typed version of the scripting language, with the same \nsemantics as the original lan\u00adguage, so that values can freely .ow back and forth between typed and untyped \nmodules. In other words, we imagine that program\u00admers can simply add type annotations to a module and \nthus intro\u00adduce a certain amount of type-safety into the program. At .rst glance, such an assumption \nseems unrealistic. Program\u00admers in untyped languages often loosely mix and match reasoning from various \ntype disciplines when they write scripts. Worse, an inspection of code suggests they also include .ow-oriented \nreason\u00ading, distinguishing types for variables depending on prior opera\u00adtions. In short, untyped scripting \nlanguages permit programs that appear dif.cult to type-check with existing type systems. To demonstrate \nthe feasibility of our approach, we have de\u00adsigned and implemented Typed Scheme, an explicitly typed \nver\u00adsion of PLT Scheme. We have chosen PLT Scheme for two rea\u00adsons. On one hand, PLT Scheme is used as \na scripting language by a large number of users. It also comes with a large body of code, with contributions \nranging from scripts to libraries to large operating-system like programs. On the other hand, the language \ncomes with macros, a powerful extension mechanism (Flatt 2002). Macros place a signi.cant constraint \non the design and implemen\u00adtation of Typed Scheme, since supporting macros requires type\u00adchecking a language \nwith a user-de.ned set of syntactic forms. We are able to overcome this dif.culty by integrating the \ntype checker with the macro expander. Indeed, this approach ends up greatly facilitating the integration \nof typed and untyped modules. As envisioned (Tobin-Hochstadt and Felleisen 2006), this integra\u00adtion makes \nit easy to turn portions of a multi-module program into a partially typed yet still executable program. \nHere we report on the novel type system, which combines the idea of occurrence typing with subtyping, \nrecursive types, poly\u00admorphism and a modicum of inference. We .rst present a formal model of the key \naspects of occurrence typing and prove it to be type-sound. Later we describe how to scale this calculus \ninto a full\u00ad.edged, typed version of PLT Scheme and how to implement it. Finally, we give an account \nof our preliminary experience, adding types to thousands of lines of untyped Scheme code. Our experi\u00adments \nseem promising and suggest that converting untyped scripts into well-typed programs is feasible. 2. \nOverview of Typed Scheme The goal of the Typed Scheme project is to develop an explicit type system that \neasily accommodates a conventional Scheme program\u00adming style. Ideally, programming in Typed Scheme should \nfeel like programming in PLT Scheme, except for typed function and struc\u00adture signatures plus type de.nitions. \nFew other changes should be required when going from a Scheme program to a Typed Scheme program. Furthermore, \nthe addition of types should require a rela\u00adtively small effort, compared to the original program. This \nrequires that macros, both those used and de.ned in the typed program, must be supported as much as possible. \nSupporting this style of programming demands a signi.cant re\u00adthinking of type systems. Scheme programmers \nreason about their programs, but not with any conventional type system in mind. They superimpose on their \nuntyped syntax whatever type (or analysis) discipline is convenient. No existing type system could cover \nall of these varieties of reasoning. Consider the following function de.ntion:1 ;; data de.nition: a \nComplex is either ;; -a Number or ;; -(cons Number Number) ;; Complex . Number (de.ne (creal x) (cond \n[(number? x) x] [else (car x)])) As the informal data de.nition states, complex numbers are repre\u00adsented \nas either a single number, or a pair of numbers (cons). The de.nition illustrates several key elements \nof the way that Scheme programmers reason about their programs: ad-hoc type speci.cations, true union \ntypes, and predicates for type testing. No datatype speci.cation is needed to introduce a sum type on \nwhich the function operates. Instead there is just an informal data de.nition and contract (Felleisen \net al. 2001), which gives a name to a set of pre-existing data, without introducing new constructors. \nFurther, the function does not use pattern matching to dispatch on the union type. All it uses is a predicate \nthat distinguishes the two cases: the .rst cond clause, which deals with x as a number and the second \none, which treats it as a pair. Here is the corresponding Typed Scheme code:2 S (de.ne-type-alias Cplx \n(Number (cons Number Number))) (de.ne: (creal [x : Cplx]) : Number (cond [(number? x) x] [else (car x)])) \nThis version explicates both aspects of our informal reasoning. The type Cplx is an abbreviation for \nthe true union intended by the pro\u00adgrammer; naturally, it is unnecessary to introduce type abbrevia\u00adtions \nlike this one. Furthermore, the body of creal is not modi.ed at all; Typed Scheme type-checks each branch \nof the conditional appropriately. In short, only minimal type annotations are required to obtain a typed \nversion of the original code, in which the informal, unchecked comments become statically-checked design \nelements. More complex reasoning about the .ow of values in Scheme programs is also accomodated in our \ndesign: (foldl scene+rectangle empty-scene (.lter rectangle? list-of-shapes)) 1 Standards-conforming \nScheme implementations provide a complex num\u00ad ber datatype directly. This example serves only expository \npurposes. 2 In this paper, we typeset Typed Scheme code in a manner that differs slightly from what programmers \nenter into an editor. This code selects all the rectangles from a list of shapes, and then adds them \none by one to an initially-empty scene, perhaps being prepared for rendering to the screen. Even though \nthe initial list\u00adof-shapes may contain shapes that are not rectangles, those are removedbythe .lter function. \nThe resulting list contains only rectangles, and is an appropriate argument to scene+rectangle. This \nexample demonstrates a different mode of reasoning than the .rst; here, the Scheme programmer uses polymorphism \nand the argument-dependent invariants of .lter to ensure correctness. No changes to this code are required \nfor it to typecheck in Typed Scheme. The type system is able to accommodate both modes of reasoning the \nprogrammer uses with polymorphic functions and occurrence typing. In contrast, a more conventional type \nsystem would require the use of an intermediate data structure, such as an option type, to ensure conformance. \n2.1 Other Type System Features In order to support Scheme idioms and programming styles, Typed Scheme \nsupports a number of type system features that have been studied previously, but rarely found in a single, \nfull-.edged im\u00adplementation. Speci.cally, Typed Scheme supports true union types (Pierce 1991), as seen \nabove. It also provides .rst-class poly\u00admorphic functions, known as impredicative polymorphism, a fea\u00adture \nof the Glasgow Haskell Compiler (Vytiniotis et al. 2006). In addition, Typed Scheme allows programmers \nto explicitly specify recursive types, as well as constructors and accessors that manage the recursive \ntypes automatically. Finally, Typed Scheme provides a rich set of base types to match those of PLT Scheme. \n 2.2 S-expressions One of the primary Scheme data structures is the S-expression. We have already seen \nan example of this in the foregoing section, where we used pairs of numbers to represent complex numbers. \nOther uses of S-expressions abound in real Scheme code, including using lists as tuples, records, trees, \netc. Typed Scheme handles these features by representing lists explicitly as sequences of cons cells. \nTherefore, we can give an S-expression as precise a type as desired. For example, the expression (list \n123) is given the type (cons Number (cons Number (cons Number ()))), which is a subtype of (Listof Number). \nSometimes, however, Scheme programmers rely on invariants too subtle to be captured in our type system. \nFor example, S\u00adexpressions are often used to represent XML data, without .rst imposing any structure \non that data. In these cases, Typed Scheme allows programmers to leave the module dealing with XML in \nthe untyped world, communicating with the typed portions of the program just as other untyped libraries \ndo. 2.3 Other Important Scheme Features Scheme programmers also use numerous programming-language features \nthat are not present in typical typed languages. Examples of these include the apply function, which \napplies a function to a heterogeneous list of arguments; the multiple value return mecha\u00adnism in Scheme; \nthe use of variable-arity and multiple-arity func\u00adtions; and many others. All of these features are widely \nused in existing PLT Scheme programs, and supported by Typed Scheme. 2.4 Macros Handling macros well \nis key for any system that claims to allow typical Scheme practice. This involves handling macros de.ned \nin libraries or by the base language as well as macros de.ned in modules that are converted to Typed \nScheme. Further, since macros can be imported from arbitrary libraries, we cannot specify the typ\u00ading \nrules for all macros ahead of time. Therefore, we must expand macros before typechecking. This allows \nus to handle the majority d,e,... ::= x |(e1 e2) |(if e1 e2 e3) |v Expressions v ::= c |b |n |.x : t.e \nValues c ::= add1 |number? |boolean? |procedure? |not Primitive Operations E ::= [] |(Ee) |(vE) |(if \nEe2 e3) Evaluation Contexts f ::= t | Latent Predicates . ::= tx |x | true | false | Visible Predicate \nf S s,t ::= T| Number | true | false |(s .t) |(t...) Types Figure 1. Syntax T-APP T-VAR T-NUM T-CONST \nT-TRUE T-FALSE G f x:G(x); x G f n: Number; true G f c: dt(c); true G ftrue : Boolean; true G ffalse \n: Boolean; false T-ABS T-IF G,x: s fe: t; . 'T-APPPRED G fe1 : t1; .1 G fe1 : t; . ' ' G fe1 : t; . \nG+ .1 fe2 : t2; .2 G f.x : s.e :(s .t); true G fe2 : t; .G fe2 : t; x G -.1 fe3 : t3; .3ft<: t0 ft<: \nt0 T-ABSPRED ft2 <: t ft3 <: t fs '' ' G,x: s fe: t; sx ft<:(t0 .t1) ft<:(t0 .t1) . = combpred(.1,.2,.3) \ns' G f(e1 e2): t1; G f(e1 e2): t1; sx G f(if e1 e2 e3): t; . G f.x : s.e:(s .t); true Figure 2. Primary \nTyping Rules combpred(.',.,.) = . S combpred(tx,true,sx)=(ts)x combpred(true,.1,.2) = .1 combpred(false,.1,.2) \n= .2 combpred(.,true,false) = . combpred(.1,.2,.3) = dt(add1 )=(Number .Number) dt(not)=(T .Boolean) \n (..T) dt(procedure?) = (T. Boolean) Number dt(number?) = (T. Boolean) Boolean dt(boolean?) = (T. Boolean) \nFigure 3. Auxiliary Operations of existing macros without change, i.e., those for which we can in\u00adfer \nthe types of the generated variables. Further, macros de.ned in typed code require no changes. Unfortunately, \nthis approach does not scale to the largest and most complex macros, such as those de.ning a class system \n(Flatt et al. 2006), which rely on and en\u00adforce their own invariants that are not understood by the type \nsys\u00adtem. Handling such macros remains future work.  3. A Formal Model of Typed Scheme Following precedent, \nwe have distilled the novelty of our type system into a typed lambda calculus, .TS. While Typed Scheme \nincorporates many aspects of modern type systems, the calculus serves only as a model of occurrence typing, \nthe novel aspect of the type system, true union types, and subtyping. The latter directly interact with \nthe former; other features of the type system are mostly orthogonal to occurrence typing. This section \n.rst presents the syntax and dynamic semantics of the calculus, followed by the typing rules and a (mechanically \nveri.ed) soundness result. G + tx = G[x: restrict(G(x),t) ] G + x = G[x:remove(G(x),false) ] G + = G \nG -tx = G[x: remove(G(x),t) ] G -x = G[x: false ] G - = G restrict(s,t) = s when fs<: t SS restrict(s,(t...)) \n=(restrict(s,t) ...) restrict(s,t) = t otherwise remove(s,t) = .when fs<: t SS remove(s,(t...)) =(remove(s,t) \n...) remove(s,t) = s otherwise Figure 4. Environment Operations 3.1 Syntax and Operational Semantics \nFigure 1 speci.es the syntax of .TS programs. An expression is either a value, a variable, an application \nor a conditional. The set of values consists of abstractions, numbers, booleans and con\u00adstants. Binding \noccurrences of variables are explicitly annotated with types. Types are either T, function types, base \ntypes, or unions of some .nite collection of types. We refer to the decorations on function types as \nlatent predicates and explain them, along with visible predicates, below in conjunction with the typing \nrules. For SS brevity, we abbreviate (true false) as Boolean and () as .. The operational semantics \nis standard: see .gure 7. Following Scheme and Lisp tradition, any non-false value is treated as true. \n 3.2 Typing Rules Thekey featureof .TS is its support for assigning distinct types to distinct occurrences \nof a variable based on control .ow criteria. For example, to type the expression S (.(x : (Number Boolean)) \n(if (number? x)(= x 1)(not x))) the type system must use Number for x in the then branch of the conditional \nand Boolean in the else branch. If it can distinguish these occurrences and project out the proper component \nof the S declared type (Number Boolean), then the computed type of the function is con.rmed as [ ((Number \nBoolean) .Boolean). The type system for .TS accomplishes this; its presentation consists of two parts. \nThe .rst are those rules that the program\u00admer must know and that are used in the implementation of Typed \nScheme. The second set of rules are needed only to establish type soundness; indeed, we can prove that \nthose rules are unnecessary outside of the proof of the main theorem. Visible Predicates Judgments of \n.TS involve both types and visible predicates (see the production for . in .gure 1). The former are standard \nand need little explanation. The latter are used to accu\u00admulate information about expressions that affect \nthe .ow of control and thus demand a split for different branches of a conditional. Of course, a syntactic \nmatch would help little, because programmers of scripts tend to write their own predicates and compose \nlogical ex\u00adpressions with combinators. Also, programmer-de.ned datatypes extend the set of predicates. \nLatent Predicates In order to accommodate programmer\u00adde.ned functions that are used as predicates, the \ntype system of .TS uses latent predicate (see f in .gure 1) to annotate function types. Syntactically \nspeaking, a latent predicate is a single type f atop the arrow-type constructor that identi.es the function \nas a predicate for f. This latent predicate-annotation allows a uniform treatment of built-in and user-de.ned \npredicates. For example, Number number?:(Number . Boolean) says that number? is a discriminator for numbers. \nAn eta-expansion preserves this property: Number (. (x: Number)(number? x)) : (Number . Boolean). Thus \nfar, higher-order latent predicates are useful in just one case: procedure?. For uniformity, the syntax \naccommodates the general case. We intend to study an integration of latent predicates with higher-order \ncontracts (Findler and Felleisen 2002) and expect to .nd additional uses. The .TS calculus also accommodates \nlogical combinations of predicates. Thus, if a program contains a test expression such as: (or (number? \nx)(boolean? x)) then Typed Scheme computes the appropriate visible predicate for S this union, which \nis (Number Boolean)x. This information is propagated so that a programmer-de.ned function receives a \ncorre\u00adsponding latent predicate. That is, the bool-or-number function: (. (x :Any)(if (number? x) #t \n(boolean? x))) S (Number Boolean) acts like a predicate of type (Any . Boolean) and is used to split \ntypes in different branches of a conditional. Typing Rules Equipped with types and predicates, we turn \nto the typing rules. They derive judgements of the form G fe : t; .. It states that in type environment \nG, expression e has type t and visible predicate .. The latter is used to change the type environ\u00adment \nin conjunction with if expressions.3 The type system proper comprises the ten rules in .gure 2. 3 Other \ncontrol .ow constructs in Scheme are almost always macros that expand into if. S-FUN fs1 <: t1 ft2 <: \ns2 S-REFL f = f ' or f ' = ft<: t ' f f f(t1 .t2) <:(s1 .s2) S-UNIONSUPER S-UNIONSUB ft<: si 1 =i =n \nfti <: s for all 1 =i =n [[ ft<:(s1 \u00b7\u00b7\u00b7sn) f(t1 \u00b7\u00b7\u00b7tn) <: s Figure 5. Subtyping Relation The rule T-IF \nis the key part of the system, and shows how visible predicates are treated. To accommodate Scheme style, \nwe allow expressions with any type as tests. Most importantly, though, the rule uses the visible predicate \nof the test to modify the type environment for the veri.cation of the types in the two conditional branches. \nWhen a variable is used as the test, we know that it cannot be false in the then branch, and must be \nin the else branch. While many of the type-checking rules appear familiar, the pres\u00adence of visible predicate \ndistinguishes them from ordinary rules: T-VAR assigns a variable its type from the type environment \nand names the variable itself as the visible predicate.  Boolean constants have Boolean type and a visible \npredicate that depends on their truth value. Since numbers are always treated as true values, they have \nvisible predicate true.  When we abstract over a predicate, the abstraction should re\u00ad.ect the test \nbeing performed. This is accomplished with the T-ABSPRED rule, which gives an abstraction a latent predicate \nif the body of the abstraction has a visible predicate referring to the abstracted variable, as in the \nbool-or-number example. Otherwise, abstractions have their usual type; the visible pred\u00adicate of their \nbody is ignored. The visible predicate of an ab\u00adstraction is true, since abstractions are treated that \nway by if.  Checking the application of an expression to another expres\u00adsion that is not a variable \nproceeds as normal. The antecedents include latent predicates and visible predicates but those are ig\u00adnored \nin the consequent.  The T-APPPRED ruleshowshowthetypesystemexploitslatent predicates. The application \nof a function with latent predicate to a variable turns the latent predicate into a visible predicate \non the variable (sx). The proper interpretation of this visible predicate is that the application produces \ntrue if and only if x has a value of type s.  Figure 3 de.nes a number of auxiliary typing operations. \nThe mapping from constants to types is standard. The ternary COMBPRED metafunction combines the effects \nof the test, then and else branches of an if expression. The most interesting case is the second, which \nhandles expressions such as this: (if (number? x) #t (boolean? x)) This is (roughly) the expansion of \nan or expression. The combined S effect is (Number Boolean)x, as expected. The environment operations, \nspeci.ed in .gure 4, combine a visible predicate with a type environment, updating the type of the appropriate \nvariable. Here, restrict(s, t) is s restricted to be a subtype of t,and remove(s, t) is s without the \nportions that are subtypes of t. The only non-trivial cases are for union types. For the motivating example \nfrom the beginning of this section, S (. (x : (Number Boolean)) (if (number? x)(= x 1)(not x))) T-APPPREDFALSE \n' ' T-APPPREDTRUE Gf e1 :t ;. Gf v :t;. ' ' Gf e1 :t ;. Gf e2 :t;. f t<:t0 f t <:s v closed f t<:t0 \nf t<:s f t ' <:(t0 s. t1) Gf (e1 e2):t1;true f t ' <:(t0 s. t1) Gf (e1 v):t1;false T-IFTRUE Gf e1 :t1;true \nGf e2 :t2;.2 f t2 <:t T-IFFALSE Gf e1 :t1;false Gf e3 :t3;.3 f t3 <:t Gf (if e1 e2 e3):t; Gf (if e1 \ne2 e3):t; SE-REFL SE-NONE f .<:? . f .<:? SE-TRUE SE-FALSE . .=true =false f true <:? . f false <:? \n. Figure 6. Auxiliary Typing Rules E-DELTA d(c,v)=v ' E-BETA (cv) . v ' (.x :t.e v) . e[x/v] E-IFTRUE \nE-IFFALSE v =false (if false e2 e3) . e3 (if ve2 e3) . e2 L . R E[L]. E[R]  d(add1 ,n)=n +1 d(not,false)=true \nd(not,v)=false v= false d(number?,n)=true d(number?,v)=false d(boolean?,b)=true d(boolean?,v)=false \nd(procedure?,.x :t.e)=true d(procedure?,c)=true d(procedure?,v)=false otherwise Figure 7. Operational \nSemantics we can now see that the test of the if expression has type Boolean and visible predicate Numberx \n. Thus, the then branch is type\u00adchecked in an environment where x has type Number;in the else branch \nx is assigned Boolean. Subtyping The de.nition of subtyping is given in .gure 5. The rules are for the \nmost part standard. The rules for union types are adapted from Pierce s (Pierce 1991). One important \nconsequence of these rules is that . is below all other types. This type is useful for typing functions \nthat do not return to their continuation, as well as for de.ning a supertype of all function types. We \ndo not include a transitivity rule for the subtyping relation, but instead prove that the subtyping relation \nas given is transitive. This choice simpli.es the proof in a few key places. The rules for subtyping \nallow function types with latent predi\u00adcates, to be used in a context that expects a function that is \nnot a predicate. This is especially important for procedure?, which han\u00addles functions regardless of \nlatent predicate.  3.3 Proof-Theoretic Typing Rules The typing rules in .gure 2 do not suf.ce for the \nsoundness proof. To see why, consider the function from above, applied to the argu\u00adment #f.By the E-BETA \nrule, this reduces to (if (number? #f) (=#f 1) (not #f)) Unfortunately, this program is not well-typed \naccording the pri\u00admary typing rules, since =requires numeric arguments. Of course, this program reduces \nin just a few steps to #t, which is an appropri\u00adate value for the original type. To prove type soundness \nin the style of Wright and Felleisen (Wright and Felleisen 1994), however, ev\u00adery intermediate term must \nbe typeable. So our types system must know to ignore the then branch of our reduced term. To this end, \nwe extend the type system with the rules in .gure 6. This extension assigns the desired type to our reduced \nexpression, because (number? #f) has visible predicate false. Put differently, we can disregard the then \nbranch, using rule T-IFFALSE.4 In order to properly state the subject reduction lemma, we need to relate \nthe visible predicates of terms in a reduction sequence. Therefore, we de.ne a sub-predicate relation, \nwritten f .<:? . ' , for this purpose. The relation is de.ned in .gure 5. This relation is not used in \nthe subtyping or typing rules, and is only necessary for the soundness proof. We can now prove the traditional \nlemmas. Lemma 1 (Preservation). If Gf e :t;., e is closed, and e . e ' , '' ' then Gf e :t ' ;. where \nf t ' <:t and f .<:? .. Lemma 2 (Progress). If Gf e:t;. and e is closed, then either e is a value or \ne . e ' for some e ' . From these, soundness for the extended type system follows. Programs with untypable \nsubexpressions, however, are not use\u00adful in real programs. We only needed to consider them, as well as \nour additional rules, for our proof of soundness. Fortunately, we can also show that the additional, \nproof-theoretic, rules are needed only for the type soundness proof, not the result. Therefore, we obtain \nthe desired type soundness result. Theorem 1 (Soundness). If Gf e:t;., with e closed, using only the \nrules in .gure 2, and tis a base type, one of the following holds 1. e reduces forever, or 2. e . * \nv where f v:s;. ' and f s<:t and f . ' <:? ..  3.4 Mechanized Support We employed two mechanical systems \nfor the exploration of the model and the proof of the soundness theorem: Isabelle/HOL (Nip\u00adkow et al. \n2002) and PLT Redex (Matthews et al. 2004). Indeed, 4 The rules in .gure 6 are similar to rules used \nfor the same purpose in systems with a typecase construct, such as Crary et al. (1998). we freely moved \nback and forth between the two, and without do\u00ading so, we would not have been able to formalize the type \nsystem and verify its soundness in an adequate and timely manner. For the proof of type soundness, we \nused Isabelle/HOL together with the nominal-isabelle package (Urban and Tasson 2005). Ex\u00adpressing a type \nsystem in Isabelle/HOL is almost as easy as writing down the typing rules of .gures 2 and 6 (our formalization \nruns to 5000 lines). To represent the reduction semantics (from .gure 7) we turn evaluation contexts \ninto functions from expressions to ex\u00adpressions, which makes it relatively straightforward to state and \nprove lemmas about the connection between the type system and the semantics. Unfortunately, this design \nchoice prevents us from evaluating sample programs in Isabelle/HOL, which is especially important when \na proof attempt fails. Since we experienced such failures, we also used the PLT Redex system (Matthews \net al. 2004) to explore the semantics and the type system of Typed Scheme. PLT Redex programmers can \nwrite down a reduction semantics as easily as Isabelle/HOL programmers can write down typing rules. That \nis, each line in .gures 1 and 7 corresponds to one line in a Redex model. Our entire Redex model, with \nexamples, is less than 500 lines. Redex comes with visualiza\u00adtion tools for exploring the reduction of \nindividual programs in the object language. In support of subject reduction proofs, language designers \ncan request the execution of a predicate for each node in the reduction sequences (or graphs). Nodes \nand transitions that violate a subject reduction property are painted in distinct colors, facilitating \nexample-based exploration of type soundness proofs. Every time we were stuck in our Isabelle/HOL proof, \nwe would turn to Redex to develop more intuition about the type system and semantics. We would then change \nthe type system of the Redex model until the violations of subject reduction disappeared. At that point, \nwe would translate the changes in the Redex model into changes in our Isabelle/HOL model and restart \nour proof attempt. Switching back and forth in this manner helped us improve the primary typing rules \nand determine the shape of the auxiliary typing rules in .gure 6. Once we had those, pushing the proof \nthrough Isabelle/HOL was a labor-intensive mechanization of the standard proof technique for type soundness. \n5  4. From .TS To Typed Scheme In this day and age, it is easy to design a type system and it is rea\u00adsonably \nstraightforward to validate some theoretical property. The true proof of a type system is a pragmatic \nevaluation, however. To this end, it is imperative to integrate the novel ideas with an exist\u00ading programming \nlanguage. Otherwise it is dif.cult to demonstrate that the type system accommodates the kind of programming \nstyle that people .nd natural and that it serves its intended purpose. To evaluate occurrence typing \nrigorously, we have implemented Typed Scheme. Naturally, occurrence typing in the spirit of .TS makes \nup the core of this language, but we have also supplemented it with a number of important ingredients, \nboth at the level of types and at the level of large-structure programming. 4.1 Type System Extensions \nAs argued in the introduction, Scheme programmers borrow a num\u00adber of ideas from type systems to reason \nabout their programs. Chief among them is parametric polymorphism. Typed Scheme therefore allows programmers \nto de.ne and use explicitly polymor\u00adphic functions. For example, the map function is de.ned as follows: \n(de.ne: (ab)(map [f : (a . b)] [l : (Listof a)]) : (Listof B) (if (null? l) l (cons (f (car l)) (map \nf (cdr l))))) 5 The mechanised calculus does not currently handle or. The de.nition explicitly quanti.es \nover type variables a and b and then uses these variables in the type signature. The body of the de.nition, \nhowever, is identical to the one for untyped map;in particular, no type application is required for the \nrecursive call to map. Instead, the type system infers appropriate instantiations for a and b for the \nrecursive call. In addition to parametric polymorphism, Scheme programmers also exploit recursive subtypes \nof S-expressions to encode a wide range of information as data. To support arbitrary regular types over \nS-expressions as well as more conventional structures, Typed Scheme provides explicit recursive types \nthough the programmer need not manually fold and unfold instances of these types. For example, here is \nthe type of a binary tree over cons cells: S (de.ne-type-alias STree (\u00b5 t (Number (cons t t)))) A function \nfor summing the leaves of such a tree is straightforward: (de.ne: (sum-tree [s : STree]) : Number (cond \n[(number? s) s] [else (+ (sum-tree (car s)) (sum-tree (cdr s)))])) In this function, occurrence typing \nallows us to discriminate be\u00adtween the different branches of the union, and the (un)folding of the recursive \n(tree) type happens automatically. Finally, Typed Scheme supports a rich set of base types, includ\u00ading \nvectors, boxes, parameters, ports, and many others. It also pro\u00advides type aliasing, which greatly facilitates \ntype readability. 4.2 Type Inference In order to further relieve the annotation burden on programmers, \nTyped Scheme provides two simple forms what has been called local type inference (Pierce and Turner 2000).6 \nFirst, local non\u00adrecursive bindings do not require annotation. For example, the following fragment typechecks \nwithout annotations on the local bindings: (de.ne: (m [z : Number]) : Number (let* ([xz] [y (* xx)]) \n(- y 1))) since by examining the right-hand sides of the let*, the typechecker can determine that both \nx and y should have type Number.Note that the inference mechanism does not take into account the uses \nof these variables, only their initializing expressions. The use of internal de.nitions can complicate \nthis inference process. For example, the above code could be written as follows: (de.ne: (m [z : Number]) \n: Number (de.ne x 3) (de.ne y (* xx)) (- y 1)) This fragment is macro-expanded into a letrec; however, \nrecur\u00adsive binding is not required for typechecking this code. Therefore, the typechecker analyzes the \nletrec expression and determines if any of the bindings can be treated non-recursively. If so, the above \ninference method is applied. The second form of inference allows the type arguments to polymorphic functions \nto be omitted. For example, the following use of map does not require explicit annotation. (map (lambda: \n([x : Number]) (+ x 1)) (123)) To accommodate this form of inference, the typechecker .rst determines \nthe type of the argument expressions, in this case 6 This modicum of inference is similar to that in \nrecent releases of Java (Gosling et al. 2005). (Number .Number)and (Listof Number), as well as the op\u00aderator, \nhere (All (ab)((a .b)(Listof a) .(Listof b))). Then it matches the argument types against the body of \nthe operator type, generating a substitution. Finally, the substitution is applied to the function result \ntype to determine the type of the entire expression. For cases such as the above, this is quite straightforward. \nWhen subtyping is involved, however, the process is complex. Consider this, seemingly similar, example. \n(map (lambda: ([x :Any]) x) (123)) Again, the second operand has type (Listof Number), suggest\u00ading that \nmap s type variable b should substituted with Number,the .rst operand has type (Any .Any), suggesting \nthat both a and b should be Any. The solution is to .nd a common supertype of Number and Any, and use \nthat to substitute for a. Unfortunately, this process does not always succeed. Therefore, the programmer \nmust sometimes annotate the arguments or the function to enable the typechecker to .nd the correct substitution. \nFor example, this annotation instantiates foldl at Number and Any: #{foldl @ Number Any} In practice, \nwe have rarely needed these annotations.  4.3 Adapting Scheme Features Scheme in general, and PLT Scheme \nin particular, comes with nu\u00admerous constructs that need explicit support from the type system: The most \nimportant one is the structure system. A de.ne\u00adstruct de.nition is the fundamental method for constructing \nnew varieties of data in PLT Scheme. This form of de.nitions introduces constructors, predicates, .eld \nselectors, and .eld mutators. Typed Scheme includes a matching de.ne-typed\u00adstruct form. Thus the untyped \nde.nition (de.ne-struct A (xy)) which de.nes a structure A, with .elds x and y, becomes the following \nin Typed Scheme: (de.ne-typed-struct A ([x : Number][y :String])) Unsurprisingly, all .elds have type \nannotations. The de.ne-typed-struct form, like de.ne-struct, introduces the predicate A?. Scheme programmers \nuse this predicate to dis\u00adcriminate instances of A from other values, and the occurrence typing system \nmust therefore be aware of it. The de.ne-typed\u00adstruct de.nition facility can also automatically introduce \nrecur\u00ad sive types, similar to those introduced via ML s datatype con\u00adstruct. The PLT Scheme system also \nallows programmers to de.ne structures as extensions of an existing structure, similar to ex\u00adtensions \nof classes in object-oriented languages. An extended structure inherits all the .elds of its parent strucuture. \nFurther\u00admore, its parent predicate cannot discriminate instances of the parent structure from instances \nof the child structure. Hence, it is imperative to integrate structures with the type system at a fundamental \nlevel. Variable-arity functions also demand special attention from the type perspective. PLT Scheme supports \ntwo forms of variable\u00adarity functions: rest parameters, which bundle up extra argu\u00adments into a list; \nand case-lambda (Dybvig and Hieb 1990), which is roughly speaking numeric and dynamic overloading. Fortunately, \nthese constructs do not present new challenges to type system designers. A careful adaptation of the \nsolutions em\u00adployed for mainstream languages such as Java and C# suf.ces. Dually, Scheme supports multiple-value \nreturns, meaning a pro\u00adcedure may return multiple values simultaneously without .rst bundling them up \nin a tuple (or other compound values). Multi\u00adple values require special treatment in the type checker \nbecause the construct for returning multiple values is a primitive func\u00adtion (values), which can be used \nin higher-order contexts.  Finally, Scheme programmers use the apply function, especially in conjunction \nwith variable-arity functions. The apply function consumes a function, a number of values, plus a list \nof addi\u00adtional values; it then applies the function to all these values.  Because of its use in conjunction \nwith variable-arity functions, we type-check the application of apply specially and allow its use with \nvariable argument functions of the appropriate type. For example, the common Scheme idiom of applying \nthe func\u00adtion + to a list of numbers to sum them works in Typed Scheme: (apply + (list 1234)).  4.4 \nSpecial Scheme Functions A number of Scheme functions, either because of their special se\u00admantics or \ntheir particular roles in the reasoning process of Scheme programmers, are assigned types that demand \nsome explanation. Here we cover just two interesting examples: .lter and call/cc. An important Scheme \nfunction, as we saw in section 2, is .lter. When .lter is used, the programmer knows that every element \nof the resulting list answers true to the supplied predicate. The type system should have this knowledge \nas well, and in Typed Scheme it does: b .lter : (All (ab)((a .Boolean)(Listof a) .(Listof b)) b Here \nwe write (a .Boolean) for the type of functions from a to Boolean that are predicates for type b. Note \nhow its latent predicate becomes the type of the resulting elements. In the conventional type world, \nthis effect can only be achieved with dependent types. For an example, consider the following expression: \n (de.ne: the-numbers (Listof Number) (let ([lst (list a1 b2 c3)]) (map add1 (.lter number? lst)))) Here \nthe-numbers has type (Listof Number) even though it is the result of .ltering numbers from a list that \ncontains both symbols and numbers. Using Typed Scheme s type for .lter, type-checking this expression \nis now straightforward. The example again demon\u00adstrates type inference for local non-recursive bindings. \nThe type of call/cc must re.ect the fact that invoking a continu\u00adation aborts the local computation in \nprogress: call/cc : (All (a) (((a ..) .a) .a)) where . is the empty type, expressing the fact that the \nfunction cannot produce values. This type has the same logical interpretation as Peirce s law, the conventional \ntype for call/cc (Grif.n 1990) but works better with our type inference system. 4.5 Programming in the \nLarge PLT Scheme has a .rst-order module system (Flatt 2002) that al\u00adlows us to support multi-module \ntyped programs with no extra ef\u00adfort. In untyped PLT Scheme programs, a module consists of de.ni\u00adtions \nand expressions, along with declarations of dependencies on other modules, and of export speci.cations \nfor identi.ers. In Typed Scheme, the same module system is available, without changes. Both de.ned values \nand types can be imported or provided from other Typed Scheme modules, with no syntactic overhead. No \ndec\u00adlaration of the types of provided identi.ers is required. In the ex\u00adample in .gure 8, the type LoN \nand the function sum are provided by module m1 and can therefore be used in module m2. (module m1 typed-scheme \n(provide LoN sum) (de.ne-type-alias LoN (Listof Number)) (de.ne: (sum [l : LoN]) : Number (if (null? \nl) 0 (+ (car l)(sum (cdr l)))))) (module m2 typed-scheme (require m1) (de.ne: l : LoN (list 12345)) (display \n(sum l))) Figure 8. A Multi-Module Typed Scheme Program Additionally, a Typed Scheme module, like a PLT \nScheme mod\u00adule, may contain and export macro de.nitions that refer to identi\u00ad.ers or types de.ned in \nthe typed module.  4.6 Interoperating with Untyped Code Importing from the Untyped World When a typed \nmodule must import functions from an untyped module say PLT Scheme s ex\u00adtensive standard library Typed \nScheme requires dynamic checks at the module boundary. Those checks are the means to enforce type soundness \n(Tobin-Hochstadt and Felleisen 2006). In order to deter\u00admine the correct checks and in keeping with our \ndecision that only binding positions in typed modules come with type annotations, we have designed a \ntyped import facility. For example, (require/typed mzscheme add1 (Number . Number)) imports the add1 \nfunction from the mzscheme library, with the given type. The require/typed facility expands into contracts, \nwhich are enforced as values cross module boundaries (Findler and Felleisen 2002). An additional complication \narises when an untyped module provides an opaque data structure, i.e., when a module exports constructors \nand operators on data without exporting the structure de.nition. In these cases, we do not wish to expose \nthe structure merely for the purposes of type checking. Still, we must have a way to dynamically check \nthis type at the boundary between the typed and the untyped code and to check the typed module. In support \nof such situations, Typed Scheme includes support for opaque types, in which only the predicate for testing \nmember\u00adship is speci.ed. This predicate can be trivially turned into a con\u00adtract, but no operations on \nthe type are allowed, other than those imported with the appropriate type from the untyped portion of \nthe program. Of course, the predicate is naturally integrated into the oc\u00adcurrence type system, allowing \nmodules to discriminate precisely the elements of the opaque type. Here is a sample usage of the special \nform for importing a predicate and thus de.ning an opaque type: (require/opaque-type (lib \"xml.ss\"\"xml\") \nDoc document?) It imports the document? function from the (lib \"xml.ss\"\"xml\") library and uses it to \nde.ne the Doc type. The rest of the module can now import functions with require/typed that refer to \nDoc. Exporting to the Untyped World When a typed module is required by untyped code, other considerations \ncome into play. Again, the typed code must be protected (Tobin-Hochstadt and Felleisen 2006), but we \nalready know the necessary types. There\u00adfore, in untyped contexts, typed exports are automatically guarded \nby contracts, without additional effort or annotation by the pro\u00adgrammer. Unfortunately, because macros \nallow unchecked access to the internals of a module, macros de.ned in a typed module can\u00adnot currently \nbe imported into an untyped context.  5. Implementation We have implemented Typed Scheme as a language \nfor the DrScheme programming environment (Findler et al. 2002). It is available from the PLaneT software \nrepository (Matthews 2006). 7 Since Typed Scheme is intended for use by programmers devel\u00adoping real \napplications, a toy implementation was not an option. Fortunately, we were able to implement all of Typed \nScheme as a layer on top of PLT Scheme, giving us a full-featured language and standard library. In order \nto integrate with PLT Scheme, all of Typed Scheme is implemented using the PLT Scheme macro sys\u00adtem (Culpepper \net al. 2007). When the macro expander .nishes sucessfully, the program has been typechecked, and all \ntraces of Typed Scheme have been compiled away, leaving only executable PLT Scheme code remaining. The \nmodule can then be run just as any other Scheme program, or linked with existing modules. 5.1 Changing \nthe Language Our chosen implementation strategy requires an integration of the type checking and macro \nexpansion processes. The PLT Scheme macro system allows language designers to control the macro expansion \nprocess from the top-most AST node. Every PLT Scheme module takes the following form: (module m language \n...) where language can specify any library. The library is then used to provide all of the core Scheme \nforms. For our purposes, the key form is #%module-begin, which is wrapped around the entire con\u00adtents \nof the module, and expanded before any other expansion or evaluation occurs. Rede.ning this form gives \nus complete control over the expansion of a Typed Scheme program. At this point, we can type-check the \nprogram and signal an error at macro-expansion time if it is ill-typed. 5.2 Handling Macros One consequence \nof PLT Scheme s powerful macro system is that a large number of constructs that might be part of the \ncore language are instead implemented as macros. This includes pattern match\u00ading (Wright and Duba 1995), \nclass systems (Flatt et al. 2006) and component systems (Flatt and Felleisen 1998), as well as numerous \nvarieties of conditionals and even boolean operations such as and. Faced with this bewildering array \nof syntactic forms, we could not hope to add each one to our type system, especially since new ones can \nbe added by programmers in libraries or application code. Fur\u00adther, we cannot abandon macros they are \nused in virtually every PLT Scheme program, and we do not want to require such changes. Instead, we transform \nthem into simpler code. In support of such situations, the PLT Scheme macro system provides the local-expand \nprimitive, which expands a form in the current syntactic environment. This allows us to fully expand \nthe original program in our macro implementation of Typed Scheme, prior to type checking. We are then \nleft with only the MzScheme core forms, of which there are approximately a dozen. 5.3 Cross-Module Typing \nIn PLT Scheme programs are divided up into .rst-order modules. Each module explicitly speci.es the other \nmodules it imports, and the bindings it exports. In order for Typed Scheme to work with actual PLT Scheme \nprograms, it must be possible for programmers to split up their Typed Scheme programs into multiple modules. \nOur type-checking strategy requires that all type-checking take place during the expansion of a particular \nmodule. Therefore, the 7 The implementation consists of approximately 6000 lines of code and 2800 lines \nof tests. type environment constructed during the typechecking of one mod\u00adule disappears before any other \nmodule is considered. Instead, we turn the type environments into persistent code using Flatt s rei.cation \nstrategy (Flatt 2002). After typechecking each module, the type environment is rei.ed in the code of \nthe module as instructions for recreating that type environment when that module is expanded. Since every \ndependency of a module is visited during the expansion of that module, the appropriate type environment \nis recreated for each module that is typechecked. This implementation technique has the signi.cant bene.t \nthat it provides separate compilation and typechecking of modules for free. Further, our type environments \nare keyed by MzScheme identi\u00ad.ers, which maintain information on which module they were de\u00ad.ned in. Therefore, \nno special effort is required to use one typed module from another and standard DrScheme (Findler et \nal. 2002) tools for presenting binding structure work properly.  5.4 Limitations Our implementation \nhas two signi.cant limitations at present. First, we are unable to dynamically enforce polymorphic types \nusing the PLT contract system. Therefore, programmers cannot require polymorphically-typed functions \nfrom untyped libraries as such (only in instantiated form). We plan to address this dif.culty by providing \na comprehensive standard library of typed functions, based upon the PLT Scheme standard library. The \nsecond major limitation is that we cannot typecheck code that uses the most complex PLT Scheme macros, \nsuch as the unit and class systems. These macros radically alter the binding struc\u00adture of the program. \nIn order to typecheck them, our system would need to be extended to either infer this type structure \nfrom the re\u00adsults of macro expansion, or to understand units and classes na\u00adtively. Since these macros \nare widely used by PLT Scheme pro\u00adgrammers, we plan to investigate both possibilities.  6. Practical \nExperience To determine whether Typed Scheme is practical and whether con\u00adverting PLT Scheme programs \nis feasible, we conducted a series of experiments in porting existing Scheme programs of varying com\u00adplexity \nto Typed Scheme. Educational Code For smaller programs, which we expected to be written in a disciplined \nstyle that would be easy to type-check, we turned to educational code. Our preliminary investigations \nand type system design indicated that programs in the style of How to Design Programs (Felleisen et al. \n2001) would type-check success\u00adfully with our system, with only type annotations required. To see how \nmore traditional educational Scheme code would fare, we rewrote most programs from The Little Schemer \n(Fried\u00adman and Felleisen 1997) and The Seasoned Schemer (Friedman and Felleisen 1996) in Typed Scheme. \nConverting these 500 lines of code usually required nothing but the declaration of types for function \nheaders. The only dif.culty encountered was an inability to express in our type system some invariants \non S-expressions that the code relied on. Second, we ported 1,000 lines of educational code, which con\u00adsisted \nof the solutions to a number of exercises for an undergradu\u00adate programming languages course. Again, \nhanding S-expressions proved the greatest challenge, since the code used tests of the form (pair? (car \nx)), which does not provide useful information to the type system (formally, the visible predicate of \nthis expression is ). Typing such tests required adding new local bindings. This code also made use of \na non-standard datatype de.nition facility, which required adaptation to work with Typed Scheme. Libraries \nWe ported 500 lines of code implementing a variety of data structures from S\u00f8gaard s galore.plt library \npackage. While these data structures were originally designed for a typed functional (de.ne: (play-one-turn \n[player : Player] [deck : Cards] [stck : Cards] [fst:discs : Hand]) : (values Boolean RCard Hand Attacks \nFrom) (de.ne trn (create-turn (player-name player) deck stck fst:discs)) ;; goplay (de.ne res (player-take-turn \nplayer trn)) ;; the-return-card could be false (de.ne-values (the-end the-return-card) (cond [(ret? \nres)(values #f (ret-card res))] [(end? res)(values #t (end-card res))])) (de.ne discards:squadrons (done-discards \nres)) (de.ne attacks (done-attacks res)) (de.ne et (turn-end trn)) (values the-end the-return-card discards:squadrons \nattacks et)) Figure 9. A Excerpt from the Squadron Scramble Game language, the implementations were \nnot written with typing in mind. Two sorts of changes were required for typing this library. First, in \nseveral places the library failed to check for erroneous input, resulting in potentially surprising behavior. \nCorrecting this required adding tests for the erroneous cases. Second, in about a dozen places throughout \nthe code, polymorphic functions needed to be explicitly instantiated in order for typechecking to proceed. \nThese changes were, again, in addition to the annotation of bound variables. Applications Finally, a \nstudent ported two sizable applications under the direction of the .rst author. The .rst was a 2,700 \nline implementation of a game, written in 2007, and the second was a 500 line checkbook managing script, \nmaintained for 12 years. The game is a version of the multi-player card game Squadron Scramble.8 The \noriginal implementation consists of 10 PLT Scheme modules, totaling 2,700 lines of implementation code, \nincluding 500 lines of unit tests. A representative function de.nition from the game is given in .gure \n9. This function creates a turn object, and hands it to the appropriate player. It then checks whether \nthe game is over and if necessary, constructs the new state of the game and returns it. The changes to \nthis complex function are con.ned to the func\u00adtion header. We have converted the original de.ne to de.ne: \nand provided type annotations for each of the formal parameters as well as the return type. This function \nreturns multiple values, as is in\u00addicated by the return type. Other than the header, no changes are required. \nThe types of all the locally bound variables are inferred from their body of the individual de.nitions. \nStructure types are used extensively in this example, as they are in the entire implementation. In the \nde.nition of the variables the\u00adend and the-return-card, occurrence typing is used to distinguish between \nthe res and end structures. Some portions of the implementation required more effort to port to Typed \nScheme. For example, portions of the data used for the game is stored in external XML .les with a .xed \nformat, and the program relies upon the details of that format. However, since this invariant is neither \nchecked nor speci.ed in the program, the type system cannot verify it. Therefore, we moved the code handling \nthe XML .le into a separate, untyped module that the typed portion uses via require/typed. 8 Squadron \nScramble resembles Rummy; it is available from US Game Systems. Scripts The second application ported \nrequired similarly few changes. This script maintained .nancial records recorded in an S\u00adexpression stored \nin a .le. The major change made to the program was the addition of checks to ensure that data read from \nthe .le was in the correct format before using it to create the relevant internal data structures. This \nwas similar to the issue encountered with the Squadron Scramble game, but since the problem concerned \na single function, we added the necessary checks rather than creating a new module. The other semantic \nchange to the program was to maintain a typing invariant of a data structure by construction, rather \nthan after-the-fact mutation. As in the case of the Galore library, we consider this typechecker-mandated \nchange an improvement to the original program, even though it has already been used successfully for \nmany years.  7. Related Work The history of programming languages knows many attempts to add or to use \ntype information in conjunction with untyped lan\u00adguages. Starting with LISP (Steele Jr. 1984), language \ndesigners have tried to include type declarations in such languages, often to help compilers, sometimes \nto assist programmers. From the late 1980s until recently, people have studied soft typing (Cartwright \nand Fagan 1991; Aiken et al. 1994; Wright and Cartwright 1997; Henglein and Rehof 1995; Flanagan and \nFelleisen 1999; Meunier et al. 2006), a form of type inference to assist programmers debug their programs \nstatically. This work has mainly been in the con\u00adtext of Scheme but has also been applied to Python (Salib \n2004). Recently, the slogan of gradual typing has resurrected the LISP\u00adstyle annotation mechanisms and \nhas had a .rst impact with its tentative inclusion in Perl6 (Tang 2007). In this section, we survey this \nbody of work, starting with the soft-typing strand, because it is the closest relative of Typed Scheme. \n 7.1 Types for Scheme The goal of the soft typing research agenda is to provide an optional type checker \nfor programs in untyped languages. One key premise is that programmers shouldn t have to write down type \nde.nitions or type declarations. Soft typing should work via type inference only, just like ML. Another \npremise is that soft type systems should never prevent programmers from running any program. If the type \nchecker encounters such an ill-typed program, it should insert run\u00adtime checks that restore typability \nand ensure that the type system remains sound. Naturally, a soft type system should minimize these insertions \nof run-time checks. Furthermore, since these insertions represent potential failures of type invariants, \na good soft type system must allow programmer to inspect the sites of these run\u00adtime checks to determine \nwhether they represent genuine errors or weaknesses of the type system. Based on the experiences of the \nsecond author, soft systems are complex and brittle. On one hand, these systems may infer ex\u00adtremely \nlarge types for seemingly simple expressions, greatly con\u00adfusing the original programmer or the programmer \nwho has taken on old code. On the other hand, a small syntactic change to a pro\u00adgram without semantic \nconsequences can introduce vast changes into the types of both nearby and remote expressions. Experiments \nwith undergraduates representative of average programmers suggest that only the very best understood \nthe tools well enough to make sense of the inferred types and to exploit them for the as\u00adsigned tasks. \nFor the others, these tools turned into time sinks with little bene.t. Roughly speaking soft type systems \nfall into one of two classes, depending on the kind of underlying inference system. The .rst soft type \nsystems (Cartwright and Fagan 1991; Wright and Cartwright 1997; Henglein and Rehof 1995) used inference \nengines based on Hindley-Milner though with extensible record types. These systems are able to type many \nactual Scheme programs, including those using outlandish-looking recursive datatypes. Unfortunately, \nthese systems severely suffer from the general Hindley-Milner error\u00adrecovery problem. That is, when the \ntype system signals a type error, it is extremely dif.cult often impossible to decipher its meaning and \nto .x it. In response to this error-recovery problem, others built in\u00adference systems based on Shiver \ns control-.ow analyses (1991) and Aiken s and Heintze s set-based analyses (Aiken et al. 1994; Heintze \n1994). Roughly speaking, these soft typing systems intro\u00adduce sets-of-values constraints for atomic expressions \nand propa\u00adgate them via a generalized transitive-closure propagation (Aiken et al. 1994; Flanagan and \nFelleisen 1999). In this world, it is easy to communicate to a programmer how a values might .ow into \na par\u00adticular operation and violate a type invariant, thus eliminating one of the major problems of Hindley-Milner \nbased soft typing (Flana\u00adgan et al. 1996). Our experience and evaluation suggest that Typed Scheme works \nwell when compared to soft typing systems. First, program\u00admers can easily convert entire modules with \njust a few type dec\u00adlarations and annotations to function headers. Second, assigning explicit types and \nrejecting programs actually pinpoints errors bet\u00adter than soft typing systems, where programmers must \nalways keep in mind that the type inference system is conservative. Third, soft typing systems simply \ndo not support type abstractions. Starting from an explicit, static type system for an untyped language \nshould help introduce these features and deploy them as needed. The Rice University soft typing research \ninspired occurrence typing. These systems employed if-splitting rules that performed a case analysis \nfor types based on the syntactic predicates in the test expression. This idea was derived from Cartwright \n(1976) s typecase construct (also see below) and due to its usefulness inspired our generalization. The \nmajor advantage of soft typing over an explicitly typed Scheme is that it does not require any assistance \nfrom the programmer. In the future, we expect to borrow techniques from soft typing for automating some \nof the conversion process from untyped modules to typed modules. Shivers (1991) presented 0CFA, which \nalso uses .ow analy\u00adsis for Scheme programs, and extended it to account for the use of predicates and \nto distinguish different occurences of variables based on these predicates, as occurrence typing does. \n 7.2 Gradual Typing Recently, proposals for what is called gradual typing have be\u00adcome popular (Siek \nand Taha 2006; Herman et al. 2007). This work also intends to integrate typed and untyped programs, but \nat a much .ner granularity than we present. So far, this has prevented the proof of a type soundness \ntheorem for such calculi that prop\u00aderly assign blame for failures to the typed and untyped pieces of \nasystem.9 In contrast, our earlier work on Typed Scheme (Tobin-Hochstadt and Felleisen 2006) provides \nsuch a soundness theorem, which we believe scales to full Typed Scheme and PLT Scheme. The gradual typing \nproposals have also failed describe the em\u00adbedding of such systems into realistic type systems that are \nsuit\u00adable for writing signi.cant applications, whereas Typed Scheme has been used for the porting of \nthousands of lines of code. Bracha (2004) suggests pluggable typing systems, in which a programmer can \nchoose from a variety of type systems for each piece of code. Although Typed Scheme requires some annotation, \nit can be thought of as a step toward such a pluggable system, in which programmers can choose between \nthe standard PLT Scheme type system and Typed Scheme on a module-by-module basis. 9 Wadler and Findler \n(2007) s formulation eliminates this objection. 7.3 Type System Features Many of the type system features \nwe have incorporated into Typed Scheme have been extensively studied. Polymorphism in type sys\u00adtems dates \nto Reynolds (1983). Recursive types were studied by Amadio and Cardelli (1993), and union types by Pierce \n(1991), among many others. Intensional polymorphism appears in calculi by Harper and Morrisett (1995), \namong others. Our use of visible predicates and especially latent predicates was inspired by prior work \non effect systems (Gifford et al. 1987). Typing variables dif\u00adferently in different portions of a program \nwas discussed by Crary et al. (1998). However, occurrence typing as presented here has not been previously \nconsidered. 7.4 Dependent Types Some features similar to those we describe have appeared in the dependent \ntype literature. Cartwright (1976) describes Typed Lisp, which includes typecase expression that re.nes \nthe type of a vari\u00adable in the various cases; Crary et al. (1998) re-invent this construct in the context \nof a typed lambda calculus with intensional poly\u00admorphism. The typecase statement speci.ed the variable \nto be re.ned, and that variable was typed differently on the right-hand sides of the typecase expression. \nWhile this system is super.\u00adcially similar to our type system, the use of latent and visible predi\u00adcates \nallows us to handle cases other than simple uses of typecase. This is important in type-checking existing \nScheme code, which is not written with typecase constructs. Visible predicates can also be seen as a \nkind of dependent type, in that (number? e) could be thought of having type true when e has a value that \nis a number. In a system with singleton types, this relationship could be expressed as a dependent type. \nThis kind of combination typing would not cover the use of if to re.ne the types of variables in the \nbranches, however. 7.5 Type Systems for Untyped Languages Multiple previous efforts have attempted to \ntypecheck Scheme pro\u00adgrams. Wand (1984), Haynes (1995), and Leavens et al. (2005) de\u00adveloped typecheckers \nfor an ML-style type system, each of which handle polymorphism, structure de.nition and a number of Scheme \nfeatures. Wand s system integrated with untyped Scheme code via unchecked assertions. Haynes system also \nhandles variable-arity functions (Dzeng and Haynes 1994). However, none attempts to accommodate a traditional \nScheme programming style. Bracha and Griswold s Strongtalk (1993), like Typed Scheme, presents a type \nsystem designed for the needs of an untyped lan\u00adguage, in their case Smalltalk. Re.ecting the differing \nunderlying languages, the Strongtalk type system differs from ours, and does not describe a mechanism \nfor integrating with untyped code.  8. Conclusion Migrating programs from untyped language to typed \nones is an im\u00adportant problem. In this paper we have demonstrated one successful approach, based on the \ndevelopment of a type system that accom\u00admodates the idioms and programming styles of our scripting lan\u00adguage \nof choice. Our type system combines a simple new idea, occurrence typ\u00ading, with a range of previously \nstudied type system features, some used widely, some just studied in theory. Occurrence typing assigns \ndistinct subtypes of a parameter to distinct occurrences, depending on the control .ow of the program. \nWe introduced occurrence typ\u00ading because our past experience suggests that Scheme programmers combine \n.ow-oriented reasoning with typed-based reasoning. Building upon this design, we have implemented and \ndistributed Typed Scheme as a package for the PLT Scheme system. This implementation supports the key \ntype system features discussed here, as well as integration features necessary for interoperation with \nthe rest of the PLT Scheme system. Using Typed Scheme, we have evaluated our type system. We consider \nthe experiments of section 6 illustrative of existing code and believe that their success is a good predictor \nfor future experi\u00adments. We plan on porting PLT Scheme libraries to Typed Scheme and on exploring the \ntheory of occurrence typing in more depth. For a close look at Typed Scheme, including documentation \nand sources for its Isabelle/HOL and PLT Redex models, are available from the Typed Scheme web page: \nhttp://www.ccs.neu.edu/~samth/typed-scheme  Acknowledgments We thank Ryan Culpepper for invaluable \nassistance with the im\u00adplementation of Typed Scheme, Matthew Flatt for implementation advice, Ivan Gazeau \nfor his porting of existing PLT Scheme code, and the anonymous reviewers for their comments. References \nAlexander Aiken, Edward L. Wimmers, and T. K. Lakshman. Soft typ\u00ading with conditional types. In POPL \n94: Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages \n163 173, New York, NY, USA, 1994. ACM Press. Roberto Amadio and Luca Cardelli. Subtyping recursive types. \nIn ACM Transactions on Programming Languages and Systems, volume 15, pages 575 631, 1993. Gilad Bracha. \nPluggable type systems. In Revival of Dynamic Languages Workshop at OOPSLA 2004, October 2004. Gilad \nBracha and David Griswold. Strongtalk: typechecking Smalltalk in a production environment. In OOPSLA \n93: Proceedings of the Eighth Annual Conference on Object-Oriented Programming Systems, Languages, and \nApplications, pages 215 230, New York, NY, USA, 1993. ACM Press. R. Cartwright. User-de.ned data types \nas an aid to verifying lisp programs. In Third International Colloquium on Automata, Languages and Pro\u00adgramming, \npages 228 256, 1976. Robert Cartwright and Mike Fagan. Soft typing. In PLDI 91: Proceedings of the ACM \nSIGPLAN 1991 Conference on Programming Language Design and Implementation, pages 278 292, New York, NY, \nUSA, 1991. ACM Press. Karl Crary, Stephanie Weirich, and Greg Morrisett. Intensional polymor\u00adphism in \ntype-erasure semantics. In ICFP 98: Proceedings of the Third ACM SIGPLAN International Conference on \nFunctional Programming, pages 301 312, New York, NY, USA, 1998. ACM Press. ISBN 1-58113\u00ad024-4. doi: http://doi.acm.org/10.1145/289423.289459. \nRyan Culpepper, Sam Tobin-Hochstadt, and Matthew Flatt. Advanced Macrology and the Implementation of \nTyped Scheme. In Proceedings of the Eighth Workshop on Scheme and Functional Programming, 2007. R. Kent \nDybvig and Robert Hieb. A new approach to procedures with vari\u00adable arity. Lisp and Symbolic Computation: \nAn International Journal, 3 (3), 1990. Hsianlin Dzeng and Christopher T. Haynes. Type reconstruction \nfor variable-arity procedures. In LFP 94: Proceedings of the 1994 ACM conference on LISP and Functional \nProgramming, pages 239 249, New York, NY, USA, 1994. ACM Press. ECMA International. ECMAScript Edition \n4 group wiki, 2007. Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, and Shriram Kr\u00adishnamurthi. \nHow to Design Programs. MIT Press, 2001. URL http://www.htdp.org/. Robert Bruce Findler and Matthias \nFelleisen. Contracts for higher-order functions. In ICFP 02: ACM SIGPLAN International Conference on \nFunctional Programming, pages 48 59, 2002. Robert Bruce Findler, John Clements, Cormac Flanagan, Matthew \nFlatt, Shriram Krishnamurthi, Paul Steckler, and Matthias Felleisen. DrScheme: A programming environment \nfor Scheme. Journal of Func\u00adtional Programming, 12(2):159 182, 2002. Cormac Flanagan and Matthias Felleisen. \nComponential set-based analysis. ACM Trans. Program. Lang. Syst., 21(2):370 416, 1999. Cormac Flanagan, \nMatthew Flatt, Shriram Krishnamurthi, Stephanie Weirich, and Matthias Felleisen. Catching bugs in the \nweb of program invariants. In PLDI 96: ACM SIGPLAN Conference on Programming Language Design and Implementation, \npages 23 32, May 1996. Matthew Flatt. Composable and compilable macros: You want it when? In ICFP 02: \nACM SIGPLAN International Conference on Functional Programming, pages 72 83, 2002. Matthew Flatt and \nMatthias Felleisen. Units: Cool modules for HOT languages. In PLDI 98: ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, pages 236 248, June 1998. Matthew Flatt, Robert Bruce Findler, and \nMatthias Felleisen. Scheme with classes, mixins, and traits. In Asian Symposium on Programming Lan\u00adguages \nand Systems (APLAS) 2006, pages 270 289, November 2006. Daniel P. Friedman and Matthias Felleisen. The \nLittle Schemer, Fourth Edition. MIT Press, Cambridge, 1997. Daniel P. Friedman and Matthias Felleisen. \nThe Seasoned Schemer.MIT Press, Cambridge, 1996. David Gifford, Pierre Jouvelot, John Lucassen, and Mark \nSheldon. FX-87 Reference Manual. Technical Report MIT/LCS/TR-407, Massachusetts Institute of Technology, \nLaboratory for Computer Science, September 1987. J. Gosling, B. Joy, G. L.Steele, and G. Bracha. The \nJava Language Speci.\u00adcation, Third Edition. Addison-Welsley, 2005. Timothy G. Grif.n. The formulae-as-types \nnotion of control. In POPL 90: Conf. Record 17th Annual ACM Symp. on Principles of Programming Languages, \nJan 1990. Robert Harper and Greg Morrisett. Compiling polymorphism using inten\u00adsional type analysis. \nIn POPL 95: ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 130 141, 1995. \nChristopher T. Haynes. Infer: A statically-typed dialect of scheme. Techni\u00adcal Report 367, Indiana University, \n1995. Nevin Heintze. Set based analysis of ML programs. In LFP 94: ACM Sym\u00adposium on Lisp and Functional \nProgramming, pages 306 317, 1994. Fritz Henglein and Jakob Rehof. Safe polymorphic type inference for \na dynamically typed language: translating Scheme to ML. In FPCA 95: Proceedings of the Seventh International \nConference on Functional Programming Languages and Computer Architecture, pages 192 203, 1995. David \nHerman, Aaron Tomb, and Cormac Flanagan. Space-ef.cient grad\u00adual typing. In 8th Symposium on Trends in \nFunctional Programming, April 2007. Gary T. Leavens, Curtis Clifton, , and Brian Dorn. A Type Notation \nfor Scheme. Technical Report 05-18a, Iowa State University, August 2005. Jacob Matthews. Component deployment \nwith PLaneT: You want it where? In Proceedings of the Seventh Workshop on Scheme and Functional Programming, \nUniversity of Chicago, Technical Report TR-2006-06, 2006. Jacob Matthews, Robert Findler, Matthew Flatt, \nand Matthias Felleisen. A visual environment for developing context-sensitive term rewriting systems. \nIn RTA 2004: Rewriting Techniques and Applications, 15th International Conference, Aachen, Germany, June \n3-5, 2004, Proceed\u00adings, volume 3091 of Lecture Notes in Computer Science, pages 2 16. Springer-Verlag, \n2004. Philippe Meunier, Robert Bruce Findler, and Matthias Felleisen. Modular set-based analysis from \ncontracts. In POPL 06: Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Program\u00adming \nLanguages, pages 218 231, New York, NY, USA, 2006. ACM Press. Tobias Nipkow, Lawrence C. Paulson, and \nMarkus Wenzel. Isabelle/HOL A Proof Assistant for Higher-Order Logic, volume 2283 of LNCS. Springer, \n2002. Benjamin C. Pierce. Programming with intersection types, union types, and polymorphism. Technical \nReport CMU-CS-91-106, Carnegie Mellon University, February 1991. Benjamin C. Pierce and David N. Turner. \nLocal type inference. volume 22, pages 1 44, New York, NY, USA, 2000. ACM. John C. Reynolds. Types, abstraction, \nand parametric polymorphism. In R. E. A. Mason, editor, Information Processing 83, Paris, France, pages \n513 523. Elsevier, 1983. Michael Salib. Starkiller: A static type inferencer and compiler for Python. \nMaster s thesis, Massachusetts Institute of Technology, Cam\u00adbridge, Massachusetts, May 2004. Olin Shivers. \nControl-Flow Analysis of Higher-Order Languages or Taming Lambda. PhD thesis, Carnegie Mellon University, \nPittsburgh, Pennsyl\u00advania, May 1991. Jeremy G. Siek and Walid Taha. Gradual typing for functional languages. \nIn Scheme and Functional Programming Workshop, University of Chicago, Technical Report TR-2006-06, pages \n81 92, September 2006. Jens Axel S\u00f8gaard. Galore, 2006. http://planet.plt-scheme.org/. Guy Lewis Steele \nJr. Common Lisp The Language. Digital Press, 1984. Audrey Tang. Perl 6: reconciling the irreconcilable. \nIn POPL 07: Proceed\u00adings of the 34th annual ACM SIGPLAN-SIGACT symposium on Princi\u00adples of programming \nlanguages, pages 1 1, New York, NY, USA, 2007. ACM Press. http://pugscode.org. Sam Tobin-Hochstadt and \nMatthias Felleisen. Interlanguage migration: from scripts to programs. In OOPSLA 06: Companion to the \n21st ACM SIGPLAN Conference on Object-oriented Programming Systems, Languages, and Applications, pages \n964 974, New York, NY, USA, 2006. ACM Press. Christian Urban and Christine Tasson. Nominal Reasoning \nTechniques in Isabelle/HOL. In Proceedings of the 20th Conference on Automated Deduction (CADE 2005), \nvolume 3632 of Lecture Notes in Arti.cial Intelligence. Springer, 2005. Dimitrios Vytiniotis, Stephanie \nWeirich, and Simon Peyton Jones. Boxy types: inference for higher-rank types and impredicativity. In \nICFP 06: Proceedings of the Eleventh ACM SIGPLAN International Conference on Functional Programming, \npages 251 262, New York, NY, USA, 2006. ACM Press. Philip Wadler and Robert Bruce Findler. Well-typed \nprograms can t be blamed. In Proceedings of the Eighth Workshop on Scheme and Func\u00adtional Programming, \n2007. Mitchell Wand. A semantic prototyping system. In SIGPLAN 84: Pro\u00adceedings of the 1984 SIGPLAN Symposium \non Compiler Construction, pages 213 221, New York, NY, USA, 1984. ACM Press. A. Wright and B. Duba. Pattern \nmatching for Scheme. Technical report, Rice University, May 1995. Andrew Wright and Matthias Felleisen. \nA syntactic approach to type soundness. Information and Computation, pages 38 94, 1994. First appeared \nas Technical Report TR160, Rice University, 1991. Andrew K. Wright and Robert Cartwright. A practical \nsoft type system for scheme. ACM Trans. Program. Lang. Syst., 19(1):87 152, 1997. \n\t\t\t", "proc_id": "1328438", "abstract": "<p>When scripts in untyped languages grow into large programs, maintaining them becomes difficult. A lack of types in typical scripting languages means that programmers must (re)discover critical pieces of design information every time they wish to change a program. This analysis step both slows down the maintenance process and may even introduce mistakes due to the violation of undiscovered invariants.</p> <p>This paper presents Typed Scheme, an explicitly typed extension of an untyped scripting language. Its type system is based on the novel notion of <i>occurrence typing</i>, which we formalize and mechanically prove sound. The implementation of Typed Scheme additionally borrows elements from a range of approaches, including recursive types, true unions and subtyping, plus polymorphism combined with a modicum of local inference. Initial experiments with the implementation suggest that Typed Scheme naturally accommodates the programming style of the underlying scripting language, at least for the first few thousand lines of ported code.</p>", "authors": [{"name": "Sam Tobin-Hochstadt", "author_profile_id": "81319502825", "affiliation": "Northeastern University, Boston, MA", "person_id": "P821988", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University, Boston, MA", "person_id": "P194758", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328486", "year": "2008", "article_id": "1328486", "conference": "POPL", "title": "The design and implementation of typed scheme", "url": "http://dl.acm.org/citation.cfm?id=1328486"}