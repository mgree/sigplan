{"article_publication_date": "01-07-2008", "fulltext": "\n A Theory of Platform-Dependent Low-Level Software Marius Nita Dan Grossman Craig Chambers Departmentof \nComputer Science&#38;Engineering University ofWashington Seattle,WA98195-2350 {marius, djg, chambers}@cs.washington.edu \nAbstract TheClanguage de.nitionleavesthe sizesand layoutsof typespar\u00adtially unspeci.ed. When a C program \nmakes assumptions about type layout, its semantics is de.ned only on platforms (C com\u00adpilers and the \nunderlying hardware) on which those assumptions hold. Previous work on formalizing C-like languages has \nignored this issue, either by assuming that programs do not make such as\u00adsumptions or by assuming that \nall valid programs target only one platform. In the latter case, the platform s choices are hard-wired \nin the language semantics. In this paper, we present a practically-motivated model for a C-like language \nin which the memory layouts of types are left largely unspeci.ed. The dynamic semantics is parameterized \nby a platform s layout policy and makes manifest the consequence of platform-dependent (i.e., unspeci.ed) \nsteps.Atype-and-effect sys\u00adtem produces a layout constraint:a logic formula encoding layout conditionsunderwhichthe \nprogramis memory-safe.Weprovethat if a program type-checks, it is memory-safe on all platforms satis\u00adfying \nits constraint. Based on our theory, we have implemented a tool that discovers unportable layout assumptionsinCprograms.Our \napproach should generalize to other kinds of platform-dependent assumptions. Categories and Subject Descriptors \nF.3.2[Logics and Meanings of Programs]:Semantics of Programming Languages; D.3.3[Pro\u00adgramming Languages]: \nLanguage Constructs and Features; D.2.4 [Software Engineering]: Software/ProgramVeri.cation GeneralTerms \nLanguages,Veri.cation, Theory 1. Introduction In recent years, research has demonstrated many ways to \nimprove the quality of low-level software (typically written in C) by us\u00ading programming-language and \nprogram-analysis technology. Such work has detected safety violations (array-bounds errors, dangling\u00adpointer \ndereferences, uninitialized memory, etc.), enforced tempo\u00adral protocols, and provided new languages and \ncompilers that sup\u00adport reliable systems programming. The results are an important and practical success \nfor programming-language theory. However, there remains a crucial and complementary set of complications \nthat this paper begins to address: Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. POPL 08 January 7 12, 2008, San Francisco, California, USA. Copyright c &#38;#169; \n2008ACM 978-1-59593-689-9/08/0001... $5.00 The memory-safety of a C program often depends on assumptions \nthat hold for some but not all compilers and machines. Examples of assumptions include how struct values \nare laid out in memory (including padding), the size of values, and align\u00adment restrictions on memory \naccesses.To our knowledge,existing work on safe low-level code (see Section 6) either (1) checks or simply \nassumesfull layout portability (e.g., that the programis un\u00adaffected by structure padding) or (2) checks \nthe program assuming a particularCplatform, making no guarantee for other platforms. Requiring that code \nmakes no platform-dependent assumptions e.g.,byenforcing poorly understood and informally speci.ed(C \nStandard 1999) restrictions onCprograms is too strict because low-level code often has inherently non-portable \nparts. An imprac\u00adtical solution is to rewrite large legacyapplications in fully portable languages or \nto use libraries that abstract all platform dependencies. Such approachesignorelegacyissues,canbeapoormatchforlow\u00adlevel \ncode, and assume that language or library implementations are available for an ever-increasing number \nof platforms. Conversely, allowing implicit platform-dependent assumptions can lead to pernicious defects \nthat lie dormant until one uses a platform violating the assumptions. Whereas defects like dangling\u00adpointer \ndereferences are largely independent of the language im\u00adplementation, so testing or veri.cation on the \nold platform can .nd manyof them, defects like assuming two struct types have similar data layouts are \nnot. The results can be severe. Conceptu\u00adally simple tasks like porting an application from a 32-bit \nmachine to a 64-bit machine become expensive and error-prone. Software tested on widely available platforms \ncan break when run on novel hardware such as embedded systems.Widely used compilers can\u00adnot change data-representation \nstrategies without breaking legacy code that implicitly relies on undocumented behavior. Section 2.2 \ndiscusses some speci.c real-world examples. In practice,Cprogrammers identify and isolate platform depen\u00addencies \nmanually. Theymay retest on each platform or use ad hoc tool support, such as compiler .ags and lint-like \ntechnology, rely\u00ading on informal knowledge of how target platforms lay out data. In contrast, the work \npresented in this paper informs the develop\u00adment of a principled, fully automatic tool that discovers \nparticular unportable assumptionsinCcode. More generally, we develop a semantics for low-level software \nthat has an explicit and separable notion of a platform. Without suchanotion, formal models or language-based \ntools forCface the same dilemma as theCcode they are designedto help: either they apply only to fully \nportable code or theyassumeCimplementation details that do not hold on all platforms.With our approach, \none can plug in a platform description into a generic framework for the operational semantics.We advocate \nour general approach for making any work onC semantics (or semantics for anylanguage with some unspeci.ed \nbehavior) robust to platform dependencies. Moreover, we use logic formulas to describe a program s platform-dependent \nassumptions. Such descriptions give a formal de.nition to the idea of semi-portability a piece of software \nor an analysis may be correct given some assumptions, i.e., portable to those platforms on which the \nassumptions hold. Software and analyses could use these formulas as documentation for their as\u00adsumptions.In \nourwork, weextractthem automaticallybut conser\u00advatively fromCcode. 1.1 Overview of Our Approach The key \nto our formal model is isolating the notion of platform, which we can think of as an oracle that answers \nqueries about how types are laid out. In our model, a platform has two roles: (1) as a parameter to the \noperational semantics, and (2) as something we can describe witha layout constraint.Thekeyinsightis this:Given \naprogramP ,we canextractalayout constraintS from P and show that P is memory-safe on all platforms satisfying \nS. To see how platforms work as parameters to the operational se\u00admantics, suppose we have a pointer dereference \n*e. The number of bytes accessed depends on the size of the type of e, and this size is determined by \nthe platform. Therefore, our dynamic semantics has the form . f P . P ' where . is a platform and P is \na program state. Thatway,the dereference rule can use . to guide the memory access and become stuck if \n. deems the access misaligned. As for layout constraints, they are formulas in a .rst-order theoryin \nwhich platforms are models.Forexample,the constraint access(4, 8) . size(long) = 8 is modeled by any \nplatform in which values of type long occupy8 bytes and 8-byte loads of 4\u00adbyte aligned data are allowed.1 \nPer convention, we write . |= S when platform . models constraint S. Now given a program P we can try \nto .nd a constraint S such that if . |= S, then the abstract machine does not get stuck when running \nP given .. For our operational semantics, that means it will not treat an integer as a pointer, read \nbeyond the end of a struct value, perform an improperly aligned memory access, etc. Finding an S that \ndescribes exactly the set of platforms on which the program does not get stuck is trivially undecidable, \nso a sound approximation is warranted. In our theory, we take a very conservative approach: A type system \nfor source programs produces S using no .ow-sensitivity or alias information. Our tool uses points-to \ninformation,but thegeneral setup remains the same. Thekeymetatheoretic result is showing that the S our \nsystem produces is indeed sound, i.e., its only models are platforms on which the program does not get \nstuck.For the proof, we de.nea second type system for program states. This second type system, whichexistsonlytoshow \nsafety,is parameterizedbya . like the dynamic semantics. Our type-safety argument then has two parts: \n1. The second type system and operational semantics enjoy the conventional preservation and progress \nproperties. 2. If the .rst type system produces S given P , then P type-checks in the second type system \nfor any . such that . |= S.   1.2 Contributions and Caveats To our knowledge, this work is the .rst \nto consider describing a set of platforms on which a low-level program can run safely. At a more detailed \nlevel, our development clari.es several points: We can de.nea sound type system fora language with partially \nunspeci.ed type layouts. The soundness theorem is proved once and for all instead of once for each platform. \n Layout-portability questions are reduced to pointer-cast ques\u00adtions, namely, when canapointertoa t1 \nbe treatedasapointer  1This example constraint is slightly simpli.ed; see Section 3.4. to a t2? This \nquestion, clearly akin to subtyping, depends on the platform. Platform constraints canbe describedina \n.rst-order theoryand extracted statically from the program.  There should be a notion of sensible platform, \nmeaning plat\u00adforms on which every cast-free program cannot get stuck.  For tractability,the formal \nmodel considers onlyasmallexpres\u00adsion language inspired by C. It has manyrelevant features, includ\u00ading \nstructs,heap allocation,and takingthe addressof .elds,butwe omit some relevant features (e.g., bit-.elds), \nand many irrelevant ones (e.g., functions and goto). We also make some simplifying assumptions in our \nde.nition of platform. In particular, we assume all pointers have the same size and that alignment restrictions \nde\u00adpend on the size,but not the type, of data.We see no fundamental problems extending our model in these \ndirections. The formal model directly informs the implementation of an automatic tool we wrote to detect \nlayout-portability problems in C programs. In addition to producing a constraint describing the platforms \non which the program is portable, the tool checks the constraint against a set of platforms of interest \nand outputs infor\u00admative warnings when the constraint is violated. No access to the platforms of interest \nis needed. 1.3 Outline Section2 presents examples of platform-dependent code and the constraints describing \ntheir layout assumptions. Section3presents our core formal model, including the de.nition of platforms, \nour .rst-order theory,the dynamic and static semantics of our language, and our soundness theorem. Section4 \ndescribes importantexten\u00adsions to the base model. Section5describes our tool. The last two sections discuss \nrelated work and conclude. 2. Examples Section 2.1 presents several tiny examples of C code to explain \nissues of layout portability and relevant platform constraints. Sec\u00adtion 2.2 complements this tutorial \nwith actual platforms, systems, and coping strategies related to these concepts. 2.1 Small Code Fragments \nExample 1: Accessing Memory (*e).f Amemory access such as(*e).f reads or writes s bytes at some alignment \na. If e has type struct T* and the f .eld has type t, then s is the size of t and a is the greatest common \ndivisor of the alignment of struct T and the offset of f. Platforms choose sizes, alignments, and offsets \nsuch that cast\u00adfree programsdo notfail.Forexample,ifa machine prohibits8\u00adbyte accesseson4-byte alignments,acompilermightputpadbytes \nbefore f .elds or break 8-byte accesses into two4-byte accesses. In the latter case, the compiler supports \n8-byte accesses on 4-byte alignments. In this paper, we assume platforms include an access function of \ntype Int . Int . Bool,as well assize and alignment functions that map types to integers. Our example \n(*e).f therefore induces the constraint access(a, s) where a and s are de.ned above. How\u00adever, this constraint \nassumes e actually evaluates to a pointer with alignment a and a t at the right offset. The constraints \nfor cast ex\u00adpressions must ensure this. Example 2: Pre.x struct S1 { int* f1; int* f2; int* f3; }; struct \nD1 { int* g1; int* g2; }; Acast fromstruct S1* to struct D1* is safe if struct D1 has a less stringent \nalignment than struct S1, and for each .eld in struct D1 there is a .eld of compatible type in struct \nS1 at the same offset. Our formal model captures this requirement precisely. Example 3: Flattening and \nAlignment struct S2 { struct D2 { int* f1; int* g1; struct {int* f2; double f3;} f4; int* g2; }; }; Acast \nfromstruct S2* to struct D2* has similar constraints as in Example 2. However, in this case, some platforms \nmay put pad bytes before f4 because of alignment restrictions. Our system will generate constraints preventing \nsuch a representation mismatch if the program has this cast. Example 4: Suf.x struct S3 { struct D3 { \nint* f1; int* g1; int* f2; double g2; double f3; }; }; struct S3* x = ...; struct D3* y = (struct D3 \n*)(&#38;(x->f2)); The cast in the initializer for y aboveisasituation wherethe source and destination \ntypes both point to an int* followed by a double. However, a platform with 4-byte pointers, 8-byte doubles, \nand 8\u00adbyte alignment of doubles cannot support this cast because struct D3 has more padding. Platforms \nwithout padding can allow this cast, even though &#38;x->f2 has type int** in C. Example 5: Arrays struct \nS4 { int f1; short f2; }; struct D4 { int g1; }; struct S4 * x = ...; struct D4 y = ((struct D4 *)x)[7]; \n Previous examples implicitly assumed the destination pointer was not used as an array (i.e., it was \nused as a pointer to exactly one struct). On manyplatforms that add trailing padding after .eld f2, a \ncast from struct S4* to struct D4* is legal. However, the cast above is broken due to intermittent pad \nbytes in the layout pointed toby x. This issue is orthogonal to array-bounds violations; we must reject \nthe cast even if x points to more than7 elements. Section 4.1 extends our model to distinguish pointers \nto single\u00adobjects from pointers to arrays.  2.2 Practical Scenarios The scope of the platform dependency \nproblem is not precisely known because defects can lie dormant until one changes hardware or compiler. \nTherefore, like date bugs (such as the famous Y2K problem), offending code can be dif.cult to locate \nand .x. The LinuxARM project,aportof LinuxtotheARM embedded processor, provides compelling evidence that \ndefects are subtle and widespread. The ARM compiler gives all structs at least 4\u00adbyte alignment whereas \nthe original Linux implementation (gcc and x86) uses less alignment for structs containing only short \nand char .elds.To quote: (Aleph One Limited) At this point, several years of .xing alignment defects \nin Linux packages have reduced the problems in the most common packages.Packagesknowntohavehad alignment \nt ::= short | long | t*| N t ::= N{tf}e ::= s | l | x | e = e | e.f | (t *)e |*(t*)(e) | (t*)&#38;e.f \n| new t | e; e | if eee | while ee | tx; e Figure 1. Source-Language Syntax:Aprogram has the form t; \ne defects are: Linuxkernel; binutils; cpio; RPM; Orbit (part of Gnome);XWindows. This listis very incomplete.2 \n Theyalso note that defects sometimes lead to alignment traps,but sometimes lead to silent data corruption. \nKernel developers are basically told to, be careful (Love 2005). Portsto 64-bit platformsprovide anotherevidencesource. \nSome vendors do little more than suggest using lint-like technology, such as gcc s -Wpadded .ag for reporting \nwhen a struct type has padding (IBM 2004). However, others .nd that aggressive warning levels produce \nso much information for legacycode that they rec\u00adommend using multiple independent compilers and looking \nonly at lines for which theyall produce warnings (Martin et al. 2005). 3. Core Language This sectiondevelopsa \nformal model that canexplainexamples1 4from Section2.We de.ne an appropriate core language,a de.ni\u00adtion \nof platform,a dynamic semantics,a .rst-order theory that con\u00adstrains platforms, a type-and-effect system \nto produce constraints, andthe type-soundness result, acquiredviaalower-level, platform\u00addependent type \nsystem. Figure8on page8summarizes the model s judgments. 3.1 Idealized Syntax For source programs, we \nconsidera small subsetofC with some convenient syntactic changes, as de.ned in Figure 1. Most signif\u00adicantly, \nwe omit functions and make all termsexpressions.Apro\u00adgramisa sequenceof struct de.nitions(t)and anexpression(e) \nto be evaluated. (We consistently write x for a sequence of ele\u00adments from syntactic category x and \u00b7 \nfor the empty sequence.We also write x i for a length i sequence.)Type de.nitionshave global scope, allowing \nmutually recursive types. Typest include short and long (for two sizes of data), pointers (t *), and \nstruct types(N rather than the moreverbose struct N). As in C, all pointers (levels of indirection) are \nexplicit. A struct de.nition(t)names the type and gives a sequence of .elds. For simplicity, we assume \nall .eld names in a program are disjoint. Several expression forms are identical to C, including short \nand long constants (s and l; we leave their exact form unspeci.ed), variables(x), assignments(e = e), \n.eld access(e.f), and pointer casts((t *)e). For pointer dereference (*(t*)(e)) and pointing to a .eld \n((t *)&#38;e.f), it is a technical convenience to require a type anno\u00adtation in the syntax. (Our particular \nchoice happens to correspond toC s syntax.) DereferenceinC is type-directed (if e has type t *, then \n*e reads sizeof(t ) bytes); our type decoration makes this explicit. The castin address-of-.eld expressions \nhelps us support suf.x casts asin Example4of Section2. The remaining expression forms are for memory \nallocation or control .ow. new t heap-allocates uninitialized space to hold a t; it is less verbose than \nmalloc(sizeof(t )). (e; e) is sequence. (if eee) is a conditional, branching on whether the .rst subex\u00adpression \nis 0.To avoid distinguishing statements from expressions, 2Emphasis in original. i, a, o . N b w e v \n::= ::= ::= ::= 0 | 1 | . . . | 255 b | uninit | i+i . . . | w w a ::= [a, o] H ::= \u00b7 | H, i . v, a \nFigure 2. Syntax extensions for run-time behavior awhile-loopevaluatestoanumberifit terminates. Finally,(tx; \ne) creates a local variable x of type t bound in e. As de.nedin Section3.3, programevaluation dependsonaplat\u00adform \n. and modi.es a heap H. Because t does not change during evaluation, we write .; t f H; e . H ' ; e ' \nfor one evaluation step. Rather than de.nea translation (i.e.,a compiler) from e toa lower\u00adlevel platform-dependent \nlanguage, we extend e with new lower\u00adlevel forms. This equivalent approach of consulting the platform \nlazily (at run-time) simpli.es the metatheory while fully exposing the intricacies of platform dependencies. \nFigure 2 de.nes the syntactic extensions for run-time expres\u00adsions and heaps.Avalue v isasequenceof atomicvalues \nw, which can be initialized bytes b, unininitialized bytes uninit, or pointers i+i.A pointer is a label \ni and an offset i because the heap maps labels to value sequences, so a pointer into the middle of a \nvalue has a non-zero offset. This heap model is higher level than assem\u00adbly languagebut low enough for \nmiddle pointers, suf.x casts, etc. In other words, it is ideal for modeling layout dependencies. Heaps \nalso map labels to alignments.We model alignments as pairs [a, o] where o is an offset from alignment \na. Typically o is 0, e.g., [4, 0] describes 4-byte aligned pointers. Supporting offsets adds some precision, \ne.g.,ifweadd2bytestoa [4, 0] pointer we get [4, 2] and adding2more bytesgives [4, 4], which is isomorphic \nto [4, 0].Withoutoffsets, adding2bytestoa 4-byte aligned pointer would produce a 2-byte aligned pointer. \nSection 3.5 describes a subalignment relation precisely.  3.2 Platforms Before we show the semantics \nof our language, we need to intro\u00adducesaprecise notionof platform,as platformsplay central rolesin both \nthe dynamic and static semantics.Aplatform(.)isarecordof functions with the following components, summarized \nin Figure 3: Atranslationof types intoalower-level representation(s), de\u00adscribed below.We write ..xtype(t, \nt) for the s corresponding to the translation of a type t assuming type de.nitions t.  An alignment \nfunction(..align)returns the alignmenta used to allocate space for a t.  An offset function(..o.set)takes \na .eld f and returns the number of bytes from the beginning of the nearest enclosing struct to the .eld \nf.  An access function takes an alignment a andasize i and returns true if accessing i bytes at an alignment \na is not an error.  The sizeof pointers(..ptrsize)is a constanti.3  An xliteral function translates \ninteger literals into byte se\u00adquences.The layoutofvaluesin memoryis platform-dependent.  The access \nfunction is typically associated with hardware and the other components with compilers, but a platform \ncomprises all components. It is clear a sensible platform cannot de.ne its 3Thisisa slightsimpli.cation \nsinceaCimplementation could usedifferent sizes for different pointers. s ::= byte | pad[i] | ptra(s) \n| ptra(N) ..xtype(t, t)= s ..align(t, t)= a ..o.set(t, f)= i ..access(a, i)= {true, false}..ptrsize = \ni ..xliteral(s)= b ..xliteral(l)= b Figure 3. Platforms and low-level types components in isolation \n(e.g., the type translation must mind the access function); our constraint language will let us de.ne \nthese restrictions precisely. Low-level types (the target of ..xtype)are s, a sequence of s. Forexample,iflongisfourbytes,the \ntranslationisbyte4. The type pad[i] represents i bytes of padding. The type ptra(s) describes pointers \nto data described by s at alignment a. As a technical point, we disallow the type N for low-level types \nexcept for the form ptra(N). This restriction simpli.es type equalities without restricting platforms \nor disallowing recursive types. 3.3 Dynamic Semantics The dynamic semantics is a small-step rewrite \nsystem for expres\u00adsions, parameterizedbya platform anda sequenceof type declara\u00adtions. Figure4holds the \nfull de.nition for .; t f H; e . H ' ; e '. It is de.ned via evaluation contexts for conciseness. As \nin C, the left side of assignments (called left-expressions) are evaluated differ\u00adently from other expressions \n(called right-expressions). Therefore, we havetwosorts of contexts(L and R)de.nedbymutual induction lr \n anda different sortof primitive reduction( . and .)for each sort of context (Grossman 2003).In particular, \nR[e]r is a right-context R containing a right-hole .lled by e and R[e]l is a right-context R containinga \nleft-hole .lledby e. Each context containsexactly one right-hole orexactly one left-hole,but not both. \nMost primitive reductions depend on .,but let us .rst dispense with those that do not. D-CAST shows that \ncasts have no run-time effect. D-SEQ is typical. D-IFFandD-IFTare typicalexceptwe treat 0asfalse(asinC) \nand other byte-sequences as true. D-WHILE is a typical small-step unrolling; we make the arbitrary choice \nthat a terminating loop produces some s literal nondeterministically. D-NEW extends the heap with a new \nlabel holding uninitialized data. The platform determines the alignment and size of the new space, with \nthe latter computed by applying the auxiliary size functiontothe translationofthe allocated type.The \nresultingvalue i+0 is a pointer to the beginning of the space. The type system does not prevent getting \nstuck due to uninitialized data; this issue is orthogonal. D-LET has the samehypotheses as D-NEW. Because \nmemory management is not our concern, we use heap allocation even for local variables. We substitute \n*(t*)(i+0) for x in the resulting expression. D-DEREF reads data from the heap andthe resultingexpression \nis the data. In particular, it extracts a sequence from the middle of H(i). This sequence is from offset \nj (where the expression before the step is *(t*)(i + j))to j + k (where k is the size of the translation \nof t ). If it is not possible to carve up H(i) in this way, then the rule does not apply and the machine \nis stuck. As expected, we also use ..access to model alignment constraints on the memory access. D-ASSIGN \nhasexactlythe samehypothesesas D-DEREF plusthe requirement that the right-hand side be a value equal \nin size to the value being replaced in the heap. The resulting heap differs only from offset j to offset \nj + k of H(i). '' . H R ::= [\u00b7]r | L = e |*(t*)(i+i)= R | R.f |*(t *)(R) | (t *)R | R; e | (t *)&#38;R.f \n| if R ee '' D f H; R[e]r . H ; R[e ]rL ::= [\u00b7]l | L.f |*(t*)(R) r D f H; e ; e '' . H D f H; R[e]l . \nH ' ; R[e ' ]l D-CAST D-SEQ D-WHILE D f H; e ; e D ::= .; t . H; w . H; e . H; if e1 (e2; while e1 \ne2) s D-IFT r b1 ...bi . =0 rD-IFFi . H; e2 . H; e1 rr r D f H;(t *)w D f H;(v; e) D f H; while e1 e2 \nD f H; if 0i D f H; if (b1 ...bi) e1 e2e1 e2 D-NEW D-LET i .. Dom(H)..align(t, t )= ai .. Dom(H)..align(t, \nt )= a ..xtype(t, t )= s size(.,s)= i ..xtype(t, t )= s size(.,s)= i r . (H, i . uniniti. (H, i . uniniti \nr .; t f H; new t .; t f H; tx; e ,a); e{*(t *)(i+0)/x},a); i+0 r D-DEREF D-ASSIGN H(i)= w1w2w3, [a, \no] size(.,w1)= jH(i)= w1w2w3, [a, o] size(.,w1)= j ..xtype(t, t)= s size(.,w2) = size(.,s)= k ..xtype(t, \nt)= s size(.,w2) = size(.,s)= k ..access([a, o + j],k)..access([a, o + j],k) size(.,w)= k . H; w2 . (H, \ni . w1ww3,a); w r .; t f H; *(t *)(i+j) .; t f H;(*(t *)(i+j)) = w D-FADDR D-FETCHL '' . H; i+(j + j \nr N{...t2 f ...}. t..o.set(t, f)= j ..o.set(t, f)= j ' r lr . H; *(t2*)(i+(j + j D-FETCH N{...t f ...}. \nt ..o.set(t, f ) = size(.,w1) D-SHORT D-LONG r ..xtype(t, t )= s size(.,s) = size(.,w2)..xliteral(s)= \nb ..xliteral(l)= b . H; w2 . H; b . H; b ' .; t f H;(t*)&#38;(i+j).f ) .; t f H;(*(t1*)(i+j)).f )) .; \nt f H; w1w2w3.f .; t f H; s .; t f H; l 8 ><( 1 if s = byte 1 if w .{b, uninit}if w = i+i i if s = pad[i]size(.,s)= \nsize(.,w)= ..ptrsize >: ..ptrsize if s .{ptra(N), ptra(s)} P P size(.,s1 ...sn)= n size(.,si) size(.,w1 \n...wn)= n size(.,wi) i=1 i=1 Figure 4. Dynamic Semantics D-FADDR takes a pointer value and increases \nits offset by the offset of the .eld f, which is de.ned by .. D-FETCHL, the one primitive reduction in \nleft contexts, is similar,but we also have to change a type to re.ect that e.f refers to less memory \nthan e.A left-value (i.e., a terminal left-expression) looks like *(t *)(i+j). D-FETCH uses the offset \nand size information from . to project a subsequenceofavalue.Wedo not use the access function here because \nwe are not accessing the heap.4 Finally, D-SHORT andD-LONG use the platform to translate literals to \nbyte-sequences. Several of the rules require computing the size of a value w ora type s. Figure4includes \nthese platform-dependent functions. There are many ways to get stuck in the dynamic semantics, especiallyin \nthe presenceof arbitrary, unchecked pointer casts.To 4On actual machines, large values do not .t in registers \nso alignment re\u00admainsaconcern.Wecould model thisbytreating .eld access as an address\u00adof-.eld computation \nfollowed by a dereference. However, the computation that produced the v in v.f must have done a properly \naligned memory ac\u00adcess, so if v has the right type, then the more complicated treatment of .eld-access \nalsowould nothavefailed for anysensible platform. characterize memory-safe programs and the platforms \non which they will not become stuck, we need a way to write down the platform-dependent layout assumptions \nmade by a program and then a way to extract the assumptions from the program. The next two sections address \nthese issues. 3.4 Constraint Language To de.ne a sound type system for our language, we need to limit \nwhat platforms we consider. That is, P does not get stuck makes no sense,but P run on platform . does \nnot get stuck does.We use .rst-order logic to give a syntactic representation to a set of platforms; \na formula S represents the platforms that model it, i.e., the set {. | . |= S}. The syntax for formulas \nS is a .rst-order theory with (1) arith\u00admetic, (2) sorts for aspects of our language (including .elds \nf, types t , low-level types s, etc.), and (3) function symbols relevant to platform-dependencies. Figure \n5 de.nes the function symbols and their interpretations. The interpretations induce the full de.ni\u00adtion \nof . |= S (e.g., . |= S1 . S2 iff . |= S1 and . |= S2). syntax interpretation under . de.ned in xtype(t, \nt ) ..xtype(t, t ) Figure 3 align(t, t) ..align(t, t ) o.set(t, f) ..o.set(t, f) access(a, i) ..access(a, \ni) xliteral(s) ..xliteral(s) xliteral(l) ..xliteral(l) size(s) size(., s) Figure 4 size(w) size(., w) \nsubtype(t, s1, s2) .; t f s1 = s2 Figure 6 subalign(a1, a2) f a1 = a2 Figure 5. Function Symbols for \nthe First-Order Theory Consider two example formulas: .t, t. access(align(t, t ), size(xtype(t, t))) \n Let t0 abbreviate: N1{short f1 short f2 short f3} N2{short g1 short g2}  in the formula: subtype(t0, \nxtype(t0,N1*), xtype(t0,N2*)). The .rst formula says every type must have a size and alignment that allows \nmemorytobe accessed.Without this constraint,a pro\u00adgram like (tx; x = e) could get stuck because D-LET \nuses the alignment ..align(t, t) for the space allocated for x. The second formula requires a low-level \nsubtyping relationship between two pointer types. This is the constraint our static semantics generates \nfora cast likein Example2from Section2. These examples demonstrate the two .avors of formulas that arise \nin practice. First, there are constraints that every sensible platform would satisfy. We are not interested \nin other platforms, but stating these requirements as a constraint is much simpler than revisiting our \nde.nition of platforms. Second, there are constraints thatwedonotexpecteveryplatformtosatisfy.Ourstatic \nsemantics produces a formula for these extra assumptions that a particular program makes. The sensibility \nclauses we assume for type safety are straight\u00adforward to enumerate. We collect them in a constraint, \ncalled Ssensible , de.ned as the conjunction of the following formulas: 1. Size and alignment allows \naccess of all types: .t, t. access(align(t, t ), size(xtype(t, t))) 2. Translation of literals respects \nthe translation of their types: .s, l, t. size(xliteral(s)) = size(xtype(t, short)) . size(xliteral(l)) \n= size(xtype(t, long)) 3. Greater alignment does not restrict access: .a1,a2, i. (access(a1,i) . subalign(a1,a2)) \n. access(a2,i) 4. Translation of t* respects the alignment and translation of t: .t, t.subtype(t, ptralign(t,t)(xtype(t, \nt)), xtype(t, t*))  5. Struct translation respects the offset and alignment of each .eld:  .t, t, f, \ns, N. (N{...t f ... }. t . (xtype(t, t )= s) . (.s1,s2, a, o, o ' , i. xtype(t, N)= s1ss2 . size(s1) \n= o.set(t, f)= o ' . align(t, N)=[a, o] . subalign([a, o + o ' ], align(t, t )))) Thisgives risetoa precise \nnotionof sensible platform: DEFINITION 1. A platform . is sensible if . |= Ssensible. Thesensibility \nconstraintsare necessaryfor portablecodeinthe sense that without them, cast-free programs could get stuck. \nTheC standard also allows other assumptions that we can write in our logic but that our safety theorem \nneed not assume. Here are just two examples: The .rst .eld always has offset 0: .f, t, t, N. (N{t f \n... }. t) . o.set(t, f)=0 Fields are in order and do not overlap: .t1,f1,t2,f2,N. N{...t1 f1 ...t2 f2 \n... }. t}. (o.set(t, f1) + size(xtype(t, t1)) = o.set(t, f2))  3.5 Static Semantics and Constraint Generation \nWith constraints in hand, we can now de.ne a type-and-effect system where the main judgment t;G fr e \n: t; S gives a constraint S suitable for e. Because it is the pointer casts in e that give rise to the \nconstraints, this type system needs an expressive notion of pointer subtyping. Therefore, we consider \nsubtyping (Figure 6) before describing the typing judgments for expressions (Figure 7). Subtyping: Weusea \nsubtyping relationonlow-leveltypestofor\u00admalize when data described by s can also be described by s ', \nand hence when pointer casts are safe. This notion has been called phys\u00adical subtyping because it relies \non actual memory layouts. Because wetakeabyte-for-byteviewof memory,our notionofphysicalsub\u00adtypingis \nricherthan those de.nedinpriorwork (ChandraandReps 1999; Siffet al. 1999; Necula et al. 2005), which \nare at the level of groundCtypes insteadof bytes.Forexample, our de.nition allows casting a struct S{short \nx;short y}* to a struct D{long a;}* on many platforms, whereas prior de.nitions forbid it. The rules \nfor our judgment .; t f s1 = s2 appear in Figure 6. As expected in a language with mutation, pointer \ntypes have invariant subtyping (rule PTR). However, we do allow forgetting .elds under a pointer type \nas this corresponds to restricting access to a pre.x of the data previously accessible. This encodes \nthe core concept behind casts like Example2 in Section 2.We also allow assumingaless restrictivealignment.Forexample,a4-byte \naligned value can be safely treated as if it were 2-or 1-byte aligned. Although we allow sequence-shortening \nunder pointer types, it is not correct to allow shortening as a subtyping rule because a supertype shouldhavethe \nsamesizeasasubtype(we canproveour rules have this property by induction on a subtyping derivation). This \nfact may seem odd to readers not used to subtyping in a language withexplicit pointers.ItiswhyCcorrectly \ndisallows casts between struct types (as opposed to pointers to structs). Rules UNROLL and ROLL witness \nthe equivalence between a struct name and its de.nition. Recall we restrict a type N to occur under pointers. \nRules PAD and ADD let us forget about the form of data (not under a pointer) without forgetting its size. \nNote that we disallow .; t f pad[i + j] = pad[i]pad[j] to prohibit accessing part of a pointer , which \nwould cause the abstract machine to get stuck. Rule SEQ lifts subtyping to sequences. As usual, subsumption \nis sound for right-expressions but un\u00adsound for left-expressions. The static semantics enforces this \nre\u00adstriction by disallowing casts as left-expressions. Static Semantics: The static semantics is shown \nin Figure 7. The judgments t;G fr e : t; S and t;G fl e : t ; S (for right\u00adand left-expressions respectively) \nproduce types as usual,but also layout constraints S. This constraint is a conjunction of the lay\u00adout \nassumptions the program is making. An alternative approach could parameterize the typing judgment by \na platform instead of outputting a constraint, to essentially perform platform-dependent type-checking. \nThis approach can be recovered from ours: we can check the constraint against a platform. The interesting \nrules are S-CAST and S-FADDR because the con\u00adstraint Ssensible in Section 3.4 suf.ces to ensure other \nexpression PTR f a1 = a2 D f ptra1 (s1s2) = ptra2 (s1) ADD .; t f pad[i]pad[j] = pad[i + j] ALIGN-BASE \na1 = a2 \u00d7 i f [a1,o] = [a2,o] UNROLL ..xtype(t, N)= s .; t f ptra(N) = ptra(s) SEQ D f s1 = s2 D f \ns3 = s4 D f s1s3 = s2s4 ALIGN-OFFSET o1 = o2 mod a f [a, o1] = [a, o2] ROLL ..xtype(t, N) = s PAD size(., \ns) = i .; t f ptra(s) = ptra(N) .; t f s = pad[i] REFL TRANS  D f s1 = s2 D f s2 = s3 D f s = sD f s1 \n= s3 ALIGN-TRANS f a1 = a2 f a2 = a3 f a1 = a3 Figure 6. Physical Subtyping and Alignment Subtyping \nS-VAR S-SHORT S-LONG S-NEW G(x)= t t;G f(t *)(&#38;e . f): t*; S1 ..s1,s2, a, o. xtype(t, N*) = ptr[a,o](s1s2) \nt; G fr s : short; true t; G fr l : long; true t; G fr new t : t *; true t; G fr x : t; true S-ASSN S-FETCH \nS-SEQ ' t; G fl e1 : t ; S1 t; G fr e2 : t ; S2 t; G fr e1 = e2 : t; S1 . S2 t; G fr e : N; S t; G fr \nN{. . . t f . . .} . t e.f : t ; S t; G fr e1 : t t; G fr ; S1 t; G fr e2 : t ; S2 e1; e2 : t; S1 . S2 \nS-DEREF S-CAST t; G fr e : t*; S t; G fr e : t1*; S1 t; G fr *(t *)(e) : t ; S t; G fr (t*)e : t *; S1 \n. subtype(t, xtype(t, t1*), xtype(t, t *)) S-FADDR t; G fr e : N*; S1 N{. . . t1 f . . .} . t  r . \no.set(f) = size(s1) . subtype(ptr[a,o+o.set(f)](s2), xtype(t, t *)) S-IF S-WHILE S-DECL t;G fr e1 : long; \nS1 t;G fr e2 : t; S2 t;G fr e3 : t; S3 t;G fr e1 : long; S1 t;G fr e2 : t; S2 t;G,x : t1 fr e : t2; S \nt;G fr if e1 e2 e3 : t ; S1 . S2 . S3 t;G fr while e1 e2 : short; S1 . S2 t;G fr t1 x; e : t2; S S-VARL \nS-DEREFL S-FETCHL G(x)= tt;G fr e : t *; SN{...t f ...}. tt;G fl e : N; S t;G fl x : t ; true t;G fl \n*(t *)(e): t ; St;G fl e.f : t ; S Figure 7. Static Semantics (letting G ::= \u00b7| G,x:t) forms (such as \ndereferences and assignments) cannot fail due to a platform dependency. The constraints directly describe \nthe im\u00adplicit assumptions madein Examples2,3, and4in Section2. The key insight here is that we can allow \na pointer cast to assign an arbitrarytypetoanexpression,butthe castwillonlybe deemed legal on platforms \nthat model the associated layout constraint. Re\u00adcall subtype(t, s1,s2) is the logical formula corresponding \nto .; t f s1 = s2. The S-FADDR constraint is much more compli\u00adcated because it must state that there \nis some sequence of .elds starting at the offset of .eld f that can be viewed as a t . Absent from this \nformal type system is support for downcasts, which are obviously important in practice.To support safe \ndown\u00adcasts, we would just need to invert the direction of the subtyp\u00ading constraint generated by the \ncast and employ existing tech\u00adniques (Necula et al. 2005; Jim et al. 2002) to ensure that the casted \nvalue actually has the type dictatedby the cast.  3.6 Metatheory and Low-Level Static Semantics Safety: \nIdeally, our type-safety result would claim that running a well-typed program on a sensible platform \nthat also models the program s constraint would never lead to a stuck state. That is, given t; \u00b7fr e \n: t ; S, . is sensible, . |= S, and .; t f\u00b7; e . * H; e ' (where . * is the re.exive, transitive closure \nof .), either e ' ''' ' ''' is a value or there exists H ,e such that .; t f H; e . * H ; e . However, \nit is possible that the abstract machine can get stuck by accessing uninitialized data. Because preventing \nuninitialized accesses is not our focus, we relax our safety guarantee to admit that e ' might also be \nlegally stuck. An expression e is legally stuck if e is of the form R[ls]r or R[ls]l, where ls ::= if \n(w1 uninit w2) ee |*(t *)(uniniti) | (t *)&#38;uniniti .f Our memory-safety proof employs a low-level \ntype system that captures the relevantinvariants thatevaluation preserves. The main judgment of this \ntype system has the form .; t; .; G fr e : s where . gives a type to the heap.5 This system has implicit \nsubsumption, which is necessary for a step via D-CAST to preserve typing: .; t; .; G fr e : s1 .; t f \ns1 = s2 .; t; .; G fr e : s2 5. ::= \u00b7| ., . s, a Dynamic Semantics: .; t f H; e . H ' ; e ' small step \n.; t f H; e r. H ' ; e ' primitive right-step .; t f H; e l. H ' ; e ' primitive left-step High-Level \nStatic Semantics: . |= S platform . models formula S f a1 = a2 subtyping on alignments .; t f s1 = s2 \nplatform-dependent subtyping t; G fr e : t; S typing for right-expressions t; G fl e : t; S typing for \nleft-expressions Low-Level Static Semantics: Figure 8. Summary of Judgments Like in the source-level \ntype system, we also have a judgment for left-expressions(.; t; .; G fl e : s, a). This judgment does \nnot havea subsumption rule,but does produce an alignment a for the location to which e will evaluate. \nMany of the low-level typing rules havehypotheses that refer directly to the platform. For example, the \nrule for type-checking dereferences is: .; t; .; G fr e : ptra(s1s2) ..xtype(t, t )= s1 ..access(a, size(.,s1)) \n .; t; .; G fr *(t *)(e): s1 See the technical report (Nita et al. 2007) for the complete system, which \nincludes rules for run-time forms (such as w)and heaps. The dynamic semantics and low-level type system \nenjoy the usual type soundness property (modulo legally stuckstates), proven with the aid of the usual \nprogress and preservation lemmas. THEOREM 2. (Low-Level Type Soundness) If .; t; \u00b7; \u00b7fr e : s and ' '' \n.; t f\u00b7; e . * H ; e ', then H ; e is not stuck on .. The connection between the static semantics and \nthe low-level type system is concisely stated by this theorem: THEOREM 3. If t;G fr e : t; S, . is sensible, \n. |= S, and ..xtype(t, t )= s, then .; t; \u00b7;G fr e : s. The proof, by induction on the derivation of \nt;G fr e : t ; S, uses the de.nition of . |= S in many cases. For example, a source derivation ending \nin S-DEREF can produce a low-level derivation ending in the dereference rule above because sensible platforms \nmodel access(align(t, t), size(xtype(t, t ))). Indeed, the proof of Theorem3 ensures our de.nitionof \nSsensible is suf.cient. Lastbut not least, we state thekeytheorem that a program will not get stuck on \nanyplatform on which its layout assumptions hold: THEOREM 4. (Layout Portability) If t;G fr e : t ; S, \n. is sensible, ' '' . |= S, and .; t f\u00b7; e . * H ; e ', then H ; e is not stuck on .. Thisisa corollaryto \nTheorems2and3. Cast-FreePortability: The constraint produced by our type sys\u00adtemisfairlyexpressive, rulingoutonly \nplatformsfor which some castin the programwould make no sense. To make this intuition precise, we prove \nthat for the right de.nition of cast-free , a cast\u00adfree program does not get stuck on anysensible platform. \nDEFINITION 5. (Cast-Free) A program t; e is cast-free if: No expressions of the form (t*)e ' occur in \ne. For every expression of the form (t *)&#38;e ' . f in e, the type t is the type of f. That is, N{...t \nf ... }. t. The second point allows taking the addressofa .eldbut requires the resulting type to be \nthe type of the .eld (rather than allowing a platform-dependent suf.x cast). Thekeytheoremis as follows: \nTHEOREM 6. If t; e is cast-free and t; \u00b7fr e : t; S, then Ssensible . S. The intuition that only casts \nthreaten layout portability is captured bythe following theorem,a corollaryto Theorems4and6: THEOREM \n7. (Cast-Free Layout Portability) If t; e is cast-free, t; \u00b7fr e : t ; S, . is sensible, and .; t f\u00b7; \ne . * H ' ; e ', then H ' ; e ' is not stuck on .. 4. Extensions This section sketches how the core model \nwe have developed is .exible enough to be extended with some other relevant features ofC and its platforms.We \nfocus .rst onarrays because they are ubiquitous and require restricting our subtyping de.nition. 4.1 \nArrays As Example5demonstrates,asubtyping rule for pointers that drops a suf.x of pointed-to .elds (rule \nPTR in Figure 6) is unsound if the pointer may be used as a pointer to an array. Therefore, extending \nour model with arrays is important and requires some otherwise unnecessary restrictions. Figure9de.nes \nthisextension formally. Rather than conservatively assume all pointers may point to ar\u00adrays, the types \ndistinguish pointers to one object(t * as already de\u00ad.ned) from pointers to arrays(t *.;the. just distinguishes \nit from t *). This dichotomy is common in safe C-like languages (Necula et al. 2005; Jim et al. 2002), \ncan be approximated via static analy\u00adsis, and is necessary to identify what platform assumptions are \ndue onlyto arrays.Thelow-leveltypes(s)make the same distinction. We add two right-expression forms. First, \nnew t[e] creates a pointer to a heap-allocated array of length e. (Because e will evaluate to a byte-sequence \nb, a platform must interpret b as an integer; we use ..val for this conversion.) The dynamic rule D-NEWARR \nis exactly like D-NEW except it creates enough space at H(i) for the array. Our type system does not \nprevent new t [e] from being stuck if e has uninitialized bytes or e is negative.6 Second, &#38;((t*.)(e1))[e2] \nis more easily read as &#38;e1[e2];the size of t guides the dynamic semantics like it does with pointer \ndereferences. This form produces a pointer to one array element, which can be dereferenced or assigned \nthrough. The dynamic rule D-ARRELT produces the pointer i+(i + j \u00d7 k) where the array be\u00adgins at i+i, \nelements have size j, and e2 evaluates to k. How\u00adever, the twohypotheses on the right performa run-time \nbounds check; our type system does not prevent this check from fail\u00ading and therefore the machine being \nstuck.7 The bounds-check on &#38;((t*.)(e1))[e2] ensures an ensuing dereference can neverfail. With this \neconomical addition of arrays, we can design con\u00adstraints and subtyping such that the only failures are \nbounds\u00adchecks.Akeyissue is alignment: Given the alignment of e1, how can we know the alignment of &#38;((t*.)(e1))[e2] \nwithout statically constraining the value of e2?The solution taken by every sensible Cplatform is to \nensure the size oft is a multiple of its alignment; see Figure9for the formal constraint. Thatway, &#38;((t*.)(e1))[e2] \nis at least as aligned as e1. Assuming this constraint, the typing rules for the new expression forms \nadd nothing notable. 6In C, e is unsigned,but large allocations due to conversion from negative numbers \nare a well-known cause of defects. 7This check disallows pointing just past the end of the array, unlike \nC. Syntax: t ::= ... | t*. Platforms: ..val(b)= i e ::= ... | new t[e] | &#38;((t *.)(e))[e] R ::= ... \n| new t[R] | &#38;((t *.)(R))[e] | &#38;((t*.)(i+i))[R] s ::= ... | ptr.(s) | ptr.(N) aa Dynamic semantics: \n D-NEWARR D-ARRELT i .. Dom(H)..align(t, t)= a ..xtype(t, t)= sH(i)= w, a ..xtype(t, t )= s size(.,s)= \ni size(.,s)= j 0 = (i + j \u00d7 k) < size(.,w) ..val(b)= j = 0..val(b)= k r r .; t f H; new t [b] . H, i \n. uniniti\u00d7j ,a; i+0 .; t f H; &#38;((t*.)(i+i))[b] . H; i+(i + j \u00d7 k) Sensibility constraint: size is \na multiple of alignment .t, t..i, a, o. size(t, xtype(t, t )) = i \u00d7 a . align(t, t )=[a, o] Subtyping \nand static semantics: ARR S-NEWARR S-ARRELT s1 = s2 i f a1 = a2 t;G fr e : long; St;G fr e1 : t*. ; \nS1 t;G fr e2 : long; S2 .. .; t f ptra1 (s1) = ptra2 (s2) t;G fr new t[e]: t *. ; St;G fr &#38;((t *.)(e1))[e2]: \nt *; S1 . S2 Figure 9. Additions for Arrays Finallybut mostimportantly,we consider subtyping for pointer\u00adto-array \ntypes. Analogues of UNROLL and ROLL are sound for types . of the form ptra(s),but PTR mustbe replaced \nwitha more restric\u00adtiverule. Therefore, ARR requiresthe elementtypeofthe subtypeto be the element type \nof the supertype repeated i times. This is more lenientthan strictinvariance.Forexample,it supportsthe \nplatform\u00addependent idiom of treating an array of: struct { short i1; short i2; short i3; short i4;}; \nas an array of short.We have proven safety given this subtyping rule (Nita et al. 2007). The ARR rule \ndoes not support subtyping such as: . . D f ptra(byte byte byte) = ptra(byte byte).Acast requiring this \nsubtyping makes sense if the pointed-to-array has an element countdivisibleby6, elseitis memory-safebut \nprobablyabug since the target type will forget the last byte in the array.We have not extended our formal \nmodel with arrays of known size,but we see no problems doing so.Such arrays are commoninC, particularly \nwith multidimensional arrays (allbut one dimension have known size), which is whyCCured (Necula et al. \n2005) allows such casts.  4.2 Platform Selection In practice, programs written in low-level languages \ncan selectively runcodebasedon featuresofthe underlying platform.Forexample, in the following snippet, \nlb has type long*, ib points toabuffer .lled with integers, and the program needs to treat ib as if it \nwere an array of long: if (sizeof(int) == sizeof(long)) lb = (long*)ib; else lb = convert(ib); If the \nsize of int equals the size of long, thebuffer canbe directly used at type long*. Otherwise, the function \nconvert allocates a new long* buffer, copies the elements fromib into it, and assigns it into lb. The \ntest offers a common-case short path, avoiding a copyon manyplatforms while remaining portable. Figure \n10 shows the additions to our model to support this idiom. The pcase form has n branches, each guarded \nby a constraint. Given a platform ., pcase steps to a branch whose guard is true under . (shown in D-PCASE). \nThe output constraint in the high-level typing rule (S-PCASE) encodes two important properties. The .rst \nconjunct requires the constraint for each branch s body to hold only if the constraint guarding the branch \nholds. In particular, an implication e ::= ... | pcase S1 => e1 ...Sn => en D-PCASE . |= Sk r .; t f \n(pcase S1 => e1 ...Sn => en) . ek S-PCASE .1 = i = n. t;G fr eVi : t ; Si ' n ' n t;G fr pcase S1 => \ne1 ...Sn => en : t;(Si . Si) . Si i=1i=1 L-PCASE .1 = i = n. if . |= Si then .; t; .; G fr ei : s .1 \n= i = n. . |= Si .; t; .; G fr pcase S1 => e1 ...Sn => en : s Figure 10. Additions for Platform Selection \n holds vacuously on platforms not modeling the guard. The second conjunct demands that at least one of \nthe guards is true. The low\u00adlevel typing rule (L-PCASE)similarly demands that at leastone guard is true \nunder . and its correspondingexpression type-checks under .. Using pcase, the previous example can be \nwritten as: pcase size(xtype(int)) = size(xtype(long)) => lb=(long*)ib size(xtype(int)) . => = size(xtype(long)) \nlb=convert(ib) In addition to the idiom exempli.ed above, pcase effectively explains selective compilation, \nwhere the preprocessor is used to compile code on a platform-dependent basis. 4.3 Other Extensions Additional \ndiscussion of extensions, including support for read\u00adonly(const)pointers, for platforms that choose to \nskip pad bytes when copying values, and for proper recursive subtyping (Amadio and Cardelli 1993), can \nbe found in the companion technical re\u00adport (Nita et al. 2007). All these extensions permit more subtyping. \n5. Implementation Togive our theorya practical outlet,wehave implementedabug\u00ad.ndingtoolthatis directly \ninspiredbythe formal model.In general, W a tool based on the model shouldextractalayout constraint S \nfrom a program and present informative warnings based on S.We see severalwaysto achieve this.Forexample: \n Directly explain S to the user, simplifying it into a legible form and connecting it to relevant locations \nin the code.  Check S against a set of platforms. That is, the user chooses a set of platforms of interest \n.1,..., .n, and warnings are reported whenever .i .|= S, for 1 = i = n.  Our tool takes the latter approach; \nwe leave the former to future work. Implementing the formal model poses two main challenges: 1. The type \nsystem relies on syntactic types to produce constraints, using no .ow or alias information. While convenient \nfor the exposition and metatheory, such simplicity is too imprecise. 2. RealCprograms contain manydowncasts \nthat are safe at run\u00adtime.Ina simple implementationofthe model, thesedowncasts would result in spurious \nwarnings.  To address (1), our tool replaces the simple type system with a points-to analysis. Using \npoints-to information yields much more precise constraints and correctly handles round-trip casts through \nvoid*. For example, D*t=(D*)(void*)e, where e points to a value of type S*, is properly identi.ed as \na cast from S* to D*. To address (2), webuilt our tool assuminga standard scenario: The program was developed \nand tested on a platform called the host, and a programmer is now interested in porting it to some targets. \nWe assume that if a pointer cast is legal on the host, it should also be legal on a target. If a cast \nis illegal on both the host and a target, we do not report a warning. Our experience suggests that (a) \nif a cast is legal on the host and illegal on a target, it is highlylikelytobeabug,and(b)ifa castisillegalonboththehost \nand a target, then it is highly unlikely tobeabug. Thewarningis likely a result of imprecision in the \nstatic analysis. In essence, our host-target scenariois aneffectivefalse-positive .lter. While it remains \nfuture work to use the tool to investigate thoroughly the extent of layout-portability bugs in C software, \npreliminary experience suggests it is a valuable addition to the developer s toolset when porting or \nprogramming with portability in mind. The rest of this section describes the tool s architecture anda \ncase study that discovereda previously unknownbug. 5.1 Tool Overview The tool has two main components. \nThe cast gatherer is a static analysis that takesaCprogram and outputsa listof pointer casts that may \noccur at run-time. The cast analyzer inputs this list of casts, generates and checks their corresponding \nconstraints, and outputs a list of warnings with code locations. The castgatherer uses an interprocedural \npoints-to analysis8 to determine which memory layouts an expression may point to at run-time.A.rst pass \nanalyzes all malloc9 sites and records a map of associated program points and their allocation-time types \nin a type table. In addition to allocation sites, program points for local variables that participate \nin pointer casts are also entered in the type table. A second pass analyzes each pointer cast (t*)e. \nFor each entry (p,t *) in the type table, if e may-alias the allocation expression atprogram point p \n(hence e may point to memory with run-time type t *), a pointer cast from t * to t * is recorded. The \nlist of pointer casts outputby the castgatherer is passed to the cast analyzer along with a set of platform \ndescriptions cho\u00adsen by the user: one for the host and one or more for each tar\u00adget. A platform description \nis a module, written by us in Caml, 8We use the points-to analysis that ships with CIL (Necula et al. \n2002a). 9Acommand-line .ag allows specifying names of user-de.ned allocators. data_link.c:196: scat_element \n* ==> iovec * Host (Gcc/32-bit X86): Src: ptr_4(ptr_1(b) bbbb) Dest: ptr_4(ptr_1(b) bbbb) Target (Gcc/LP-64): \nSrc: ptr_8(ptr_1(b) bbbb----) Dest: ptr_8(ptr_1(b) bbbbbbbb) events.c:150: sp_time * ==> timeval * Host \n(Gcc/32-bit X86): Src: ptr_4(bbbb bbbb) Dest: ptr_4(bbbb bbbb) Target (Gcc/LP-64): Src: ptr_8(bbbbbbbb \nbbbbbbbb) Dest: ptr_8(bbbbbbbb bbbb----) Figure 11. Tool Output on Spread that implements a platform \ns layout policyby de.ning exactly the platform functions in our model (recall Figure 3).We have imple\u00admented \nmanysuch platform descriptions, most of which represent real platforms, and some of which implement imagined \nplatforms that are still within theClanguage speci.cation. For each pointer cast, the cast analyzer generates \nthe appropriate constraint. It then checks the constraint against the host descrip\u00adtion. If the constraint \nis true (i.e., the cast is legal on the host), it is checked against each target. If it isfalse for any \ntarget, the rel\u00adevantwarnings (described below) are output.We implemented the constraint checker manually \nand specialized it to our constraint lan\u00adguage.It queriesthephysical subtyping relation,forwhichwehave \nimplemented an algorithm, and the platform description functions. While a whole-program analysis is necessary \nfor soundness, the tool can be run on a subset of the program at the expense of coverage. Also, it is \neasy to plug in a different cast gatherer. For example, we have experimented with a dynamic analysis \nthat produces exact results per run. 5.2 Case Study We ran our tool on Spread10, a high-performance \nmessaging ser\u00advice intended for useby distributed applications.We chose Spread because(a)it containeda \nreported layout portabilitybug11, and(b) it is intended to be portable. Our tool issued two warnings, \none of whichwas the knownbug, and the othera newbug that to our knowledge has not been reported on the \ndeveloper mailing lists. No false positives were reported. Arelevant subset of the tool s output is given \nin Figure 11. The rest of the output was about these same casts at different locations inthe code.Thetwowarnings(the \n.rstof whichistheknownbug) are issuedinthe contextofaconventional Gccon 32-bitX86 host descriptionandaso-called \nLP-64 target,onwhichintegersare32 bits and long and pointers are 64 bits. Each warning lists the bad \npointer cast and its location, followed by the layouts of the source and destination type on each platform. \nThe layouts are displayed in an ASCII version of the language for s in Figure 3, where b stands for byte, \n- for pad[1], ptr_4(b) for ptr[4,0](byte), etc. In the .rst case, we learn that the two types are laid \nout identi\u00adcally on the host,but on the target, the source type has four bytes of trailing padding where \nthe destination type contains data bytes. The types involved in the cast are as follows: struct scat_element \n{ char *buf; int len; } struct iovec { char *buf; size_t len; } 10 http://www.spread.org 11 http://commedia.cnds.jhu.edu/pipermail/spread-users/2002\u00adNovember/001185.html \nThe cast makes an assumption that sizeof(int) is equal to sizeof(size_t). On LP-64 platforms, however, \nint is 4 bytes and size_t is8bytes, and the cast leads toa bigger-than-expected value in iovec s len \n.eld and hence out-of-bounds buf accesses. In the second warning, the target layout contains trailing \npadding where the host does not. The two types are: struct sp_time { long sec; long usec; } struct timeval \n{ time_t tv_sec; suseconds_t tv_usec; } On both the host and target, time_t is a type alias for long \nand suseconds_t is a type alias for int. The cast leads to truncation of the usec .eld, only half of \nthe bytes being visible through tv_usec. If the target machine is big-endian, most or all of the relevant \ndata is lost, being mapped to the sequence of padding. Thisbugis particularly interesting, becausein \nadditiontobeing impossibleto detectonthehostvia testing,itisalsoverydif.cultto detect on the target. \nSince the tv_usec .eldisoffby some number of nanoseconds, .nding thisbugby testing literally depends \non the time of day. Our tool detects it statically and without access to the target platform. 6. Previous \nWork To our knowledge, previous work considering platform-dependent layout assumptions or low-level type-safety \nhas taken one of the following approaches: Consider only one platform or one complete bit-by-bit data \ndescription.  Check thataCprogramis portable,givinga compile-time error orfail-stop run-time terminationifitis \nnot.  Assume thataC programis portable, i.e.,extend theC com\u00adpiler s viewthat behavior for unportable \nprograms is unde.ned.  The .rst approach is not helpful for writing code that works cor\u00adrectly on a \nset of platforms. The second approach suf.ces for ap\u00adplications that should be written in a higher-level \nlanguage. The third approach relegates some issues to work such as ours, much as we relegate some issues \nlike array-bounds errors to other work. 6.1 Assuming a Platform Most closely related is the work on \nphysical type-checking (Chan\u00addraandReps1999;Siffetal.1999),whichmotivatedourwork con\u00adsiderably. Their \ntool classi.esCcasts as upcasts , downcasts , or neither , reporting a warning for the last possibility. \nTheir notion of physical subtyping is at a higher level than ours (requiring that types, offsets, and \n.eld names match), and they neither parame\u00adterize their system by a platform nor produce descriptions \nof sets of platforms. Checking code against a new platform would require reveri.cation and changing their \ntool. Theypresent no metatheory validating their approach. CCured (Necula et al. 2005), a memory-safe \nC platform, in\u00adcludes physical type-checking to reduce the number of casts that require run-time checks. \nThatis, CCured permits casts thatworkin practicebut are not allowedby theCstandard. The allowed casts \nare safe under a padding strategy used by common C compilers for the x86 architecture, which covers some \nbut certainly not all platforms. An interesting avenue for future work is to reimplement the CCured type \nanalysis engine using our platform-as-parameter approach, thus making its memory-safety guarantee portable. \nWork on typed assembly language and proof-carrying code (Necula 1997; Morrisett et al. 1999; Crary 2003; \nChen et al. 2003; Hamidetal.2003) clearly needsalow-levelviewof memory.Such projects can establish that \ncertifying compilers produce code that cannot get stuck due to uninitialized memory, unaligned memory \naccess, segmentation faults, etc. In particular, work on allocation semantics (Petersen et al. 2003; \nAhmed and Walker 2003) has taken a lower-level view than our formalism by treating addresses as integers \nand exposing that pointer arithmetic can move between adjacent data objects. These approaches provide \nless help for writ\u00ading platform-dependent code because veri.cation of type-safety is repeated for each \nplatform. In practice, de.ning a new platform is an enormous amount of work. Various program analyses \nforC,such as theworkbyWilson and Lam (1995) and Min\u00b4 e (2006), have represented structs and unions withexplicitbytesandoffsetsbyassumingone \nparticular platform. 6.2 Safe C Memory-safe dialectsor implementationsofC,suchas CCured(Nec\u00adula et al. \n2005, 2002b; Condit et al. 2003), Deputy (Condit et al. 2007), SAFECode (Dhurjati et al. 2006), and Cyclone \n(Jim et al. 2002; Grossman et al. 2002; Grossman 2006), do not solve the platform dependencyproblem.Rather,theymay \nreject(at compile\u00adtime) or terminate (at run-time) programs that attempt platform\u00addependent operations, \nor theymay support only certain platforms. These approaches are .ne for fully portable code or code that \nis correct assuming particular compilers. Furthermore, the implementations of these systems include run\u00adtime \nsystems (automatic memory managers, type-tag checkers, etc.) that themselves make platform-dependent \nassumptions! For example, Cyclone assumes 32-bit integers and pointers, and mak\u00ading this code more portable \nis a top request from actual users. 6.3 Formalizing C Some recent work (Leroy 2006; Blazy et al. 2006) \nuses Coq to prove a C compiler correct. Their operational semantics for C distinguishes left and right \nexpressions much as we do. How\u00adever, their source language omits structs, avoiding many align\u00adment and \npadding issues, and their metatheory proves correctness only for correct source programs, presumably \nsaying nothing about platform-dependent code. The HOL formalizationofCby Norrish (1998) includes structs \nand usesaglobal namespace mapping struct namesto sequencesof typed .elds, like our work. However, he \npurposely omits padding and alignment from his formalism. He has no separable notion of a platform; instead \nhe models platform choices as nondeterminism. 6.4 Low-Level Code without C Our work has been C-centric, \nwhereas other projects have started with languages at higher levels of abstraction and added bit-level \nviews for low-level programming. See Bacon (2003) and Hallgren et al. (2005) for just two recent examples. \nWe believe this com\u00adplementary approachwould bene.t from our constraint-based view rather than choosing \njust between completely high-level types and completely low-level ones. C--(Ramsey et al. 2005) makes \ndata representation and align\u00adment explicit, but C--is not appropriate for writing platform\u00addependent \ncode. Rather, it is a low-level language designed as a targetforcompiling high-level languages.Ithasexplicit \npaddingon data (a compiler inserts bits where desired) and explicit alignment on all memory accesses.12 \nIncorrect alignment is an unchecked run-time error. The purpose of C--is to handle back-end code\u00adgeneration \nissues for a compiler; it is still expected that the front\u00adend compiler will generate different (but \nsimilar) code for each platform and provide a run-time system, probably written in C. 12 Syntactically, \nan omitted alignment is taken to be n for an n-byte access. 7. Conclusions and Future Work We developed \na formal description of platform dependencies in low-level code.Thekeyinsightisa semantic notionof platform \nthat directs a low-level operational semantics and models a syntac\u00adtic constraint that we can produce \nvia static analysis on a source program.Wehave proven soundness fora small core language and a simple \nstatic analysis. Giving platforms a clear identity in our framework clari.esa numberof poorly understoodissues.Thefor\u00admalmodel \ndirectly informsthe implementationofa usefultoolthat .nds and reports layout portability problemsinCprograms. \nThe technique of platform-as-parameter can apply broadly since high-level languages also have platform-de.ned \nbehavior. As ex\u00adamples, SML programs may depend on the size of int, Scheme programs may depend on evaluation \norder, and Java programs may depend onfair thread-scheduling. Inthe futurewehopetomovebeyond memory-safetybycheck\u00ading \nthataCprogramis observationally equivalent ona setof plat\u00adforms. This level of portability must account \nfor issues like endi\u00adanness, integerover.ow, and perhaps .oating-point roundoff.We believe the notion \nof platform selection described in Section 4.2 (pcase)is essentialinsuchanendeavor.Theideaisto translateaC \nprogram intoaversionofCwitha pcase primitive, where prepro\u00adcessor directives and if statements encoding \nplatform selection are translated to corresponding pcase statements. Then, we can extract from this program \nthe necessary proof obligations under which all pcase branches are equivalent whenexecuted under their \nrespective assumptions. Since pcase branches can be arbitrary code, equiva\u00adlence checking is undecidable.We \nenvision discharging the proof obligations in an interactive proof environment. Akeyfeatureoftheworkinthispaperisthatit \ndetectsarelevant subset of portability problems fully automatically. A portability checker requiring \ninteractive theorem proving is not accessible to mostCprogrammers. References Amal Ahmed and DavidWalker. \nThe logical approach to stack typing. In International Workshop on Types in Language Design and Implementa\u00adtion, \n2003. Aleph One Limited. The ARMLinux Book Online, Chapter 10. 2005. http://www.aleph1.co.uk/armlinux/book. \nRoberto M. Amadio and Luca Cardelli. Subtyping recursive types. ACM Transactions on Programming Languages \nand Systems, 15(4), 1993. David F. Bacon. Kava: a Java dialect with a uniform object model for lightweight \nclasses. Concurrency and Computation: Practice and Ex\u00adperience, 15(3 5), 2003. Sandrine Blazy, Zaynah \nDargaye, and Xavier Leroy. Formal veri.cation ofaCcompiler front-end. In 14th International Symposium \non Formal Methods, 2006. C Standard 1999. ISO/IEC 9899:1999, International Standard Programming Languages \nC. International Standards Organization, 1999. Satish Chandra andTom Reps. Physical type checking forC. \nIn Workshop on Program Analysis for Software Tools and Engineering, 1999. Juan Chen, Dinghao Wu, Andrew \nW. Appel, and Hai Fang. A provably soundTAL for back-end optimization. In ACM Conference on Program\u00adming \nLanguage Design and Implementation, 2003. Jeremy Condit, Matthew Harren, Scott McPeak, George Necula, \nandWest\u00adleyWeimer. CCuredintherealworld.In ACM Conference on Program\u00adming Language Design and Implementation, \n2003. Jeremy Condit, Matthew Harren, Zachary Anderson, David Gay, and George Necula. Dependent types \nfor low-level programming. In Eu\u00adropean Symposium on Programming, 2007. Karl Crary. Toward a foundational \ntyped assembly language. In 30th ACM Symposium on Principles of Programming Languages, 2003. Dinakar \nDhurjati, Sumant Kowshik, and Vikram Adve. SAFECode: En\u00adforcing alias analysis for weakly typed languages. \nIn ACM Conference on Programming Language Design and Implementation, 2006. Dan Grossman. Type-safe multithreading \nin Cyclone. In International Workshop on Types in Language Design and Implementation, 2003. Dan Grossman. \nQuanti.ed types in imperative languages. ACM Transac\u00adtions on Programming Languages and Systems, 28(3), \n2006. Dan Grossman, GregMorrisett,Trevor Jim, Michael Hicks,YanlingWang, and James Cheney. Region-based \nmemory management in Cyclone. In ACM Conference on Programming Language Design and Implementa\u00adtion, 2002. \n Thomas Hallgren, MarkP. Jones, Rebekah Leslie, and AndrewTolmach.A principled approach to operating \nsystem construction in Haskell. In 10th ACM International Conference on Functional Programming, 2005. \nNadeem A. Hamid, Zhong Shao, Valery Trifonov, Stefan Monnier, and Zhaozhong Ni. A syntactic approach \nto foundational proof-carrying code. Journal of Automated Reasoning, 31(3 4), 2003. IBM. Developing embedded \nsoftware for the IBM Pow\u00aderPC 970FX processor. Application Note 970, IBM, 2004. http://www.ibm.com/chips/techlib/. \nTrevor Jim, GregMorrisett, Dan Grossman, Michael Hicks, James Cheney, andYanlingWang. Cyclone:A safe \ndialect of C. In USENIX Annual Technical Conference, 2002. Xavier Leroy. Formal certi.cation of a compiler \nback-end. In 33rd ACM Symposium on Principles of Programming Languages, 2006. Robert Love. Linux Kernel \nDevelopment, Second Edition. Novell Press, 2005. Page 328. Brad Martin, Anita Rettinger, and Jasmit Singh. \nMultiplatform porting to 64 bits. Dr. Dobb s Journal, 2005. Antoine Min\u00b4e. Field-sensitive value analysis \nof embedded c programs with union types and pointer arithmetics. In Conference on Language, Compilers, \nand Tool Support for Embedded Systems, 2006. GregMorrisett, DavidWalker, Karl Crary, and Neal Glew. From \nSystem F to typed assembly language. ACM Transactions on Programming Languages and Systems, 21(3), 1999. \nGeorge Necula. Proof-carrying code. In 24th ACM Symposium on Princi\u00adples of Programming Languages, 1997. \nGeorge Necula, Scott McPeak, Shree Prakash Rahul, andWestleyWeimer. CIL: Intermediate language and tools \nfor analysis and transformation of Cprograms. InConference on Compiler Construction, 2002a. George Necula, \nScott McPeak, andWestleyWeimer. CCured:Type-safe retro.tting of legacy code. In 29th ACM Symposium on \nPrinciples of Programming Languages, 2002b. George Necula, Jeremy Condit, Matthew Harren, Scott McPeak, \nandWest\u00adleyWeimer. CCured:Type-safe retro.tting of legacy software. ACM Transactions on Programming Languages \nand Systems, 27(3), 2005. Marius Nita, Dan Grossman, and Craig Chambers. Atheory of platform\u00addependent \nlow-level software (extended version). 2007. Available at http://www.cs.washington.edu/homes/marius/papers/tpd/. \nMichael Norrish. C formalised in HOL. PhD thesis, University of Cam\u00adbridge, 1998. Leaf Petersen, Robert \nHarper, Karl Crary, and Frank Pfenning. A type theory for memory allocation and data layout. In 30th \nACM Symposium on Principles of Programming Languages, 2003. Norman Ramsey, Simon Peyton Jones, and Christian \nLindig. The C--language speci.cation version 2.0, 2005. http://www.cminusminus.org/extern/man2.pdf. Micahel \nSiff, Satish Chandra, Thomas Ball, KrishnaKunchithapadam, and Thomas Reps. Coping with type casts in \nC. In 7th European Software Engineering Conference 7th ACM Symposium on the Foundations of Software Engineering, \n1999. RobertP.Wilson and Monica S. Lam. Ef.cient context-sensitive pointer analysis for C programs. In \nACM Conference on Programming Lan\u00adguage Design and Implementation, 1995.    \n\t\t\t", "proc_id": "1328438", "abstract": "<p>The C language definition leaves the sizes and layouts of types partially unspecified. When a C program makes assumptions about type layout, its semantics is defined only on platforms (C compilers and the underlying hardware) on which those assumptions hold. Previous work on formalizing C-like languages has ignored this issue, either by assuming that programs do not make such assumptions or by assuming that all valid programs target only one platform. In the latter case, the platform's choices are hard-wired in the language semantics.</p> <p>In this paper, we present a practically-motivated model for a C-like language in which the memory layouts of types are left largely unspecified. The dynamic semantics is parameterized by a platform's layout policy and makes manifest the consequence of platform-dependent (i.e., unspecified) steps. A type-and-effect system produces a layout constraint: a logic formula encoding layout conditions under which the program is memory-safe. We prove that if a program type-checks, it is memory-safe on all platforms satisfying its constraint.</p> <p>Based on our theory, we have implemented a tool that discovers unportable layout assumptions in C programs. Our approach should generalize to other kinds of platform-dependent assumptions.</p>", "authors": [{"name": "Marius Nita", "author_profile_id": "81100010495", "affiliation": "University of Washington, Seattle, WA", "person_id": "P693062", "email_address": "", "orcid_id": ""}, {"name": "Dan Grossman", "author_profile_id": "81405594870", "affiliation": "University of Washington, Seattle, WA", "person_id": "PP43120333", "email_address": "", "orcid_id": ""}, {"name": "Craig Chambers", "author_profile_id": "81100528252", "affiliation": "University of Washington, Seattle, WA", "person_id": "PP43121715", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328465", "year": "2008", "article_id": "1328465", "conference": "POPL", "title": "A theory of platform-dependent low-level software", "url": "http://dl.acm.org/citation.cfm?id=1328465"}