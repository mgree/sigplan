{"article_publication_date": "01-07-2008", "fulltext": "\n Enhancing Modular OO Veri.cation with Separation Logic Wei-Ngan Chin1,2 Cristina David1 Huu Hai Nguyen1,2 \nShengchao Qin3 1 Department of Computer Science, National University of Singapore, Singapore 2 Computer \nScience Programme, Singapore-MIT Alliance, Singapore 3 Department of Computer Science, Durham University, \nUK { chinwn,davidcri,nguyenh2} @comp.nus.edu.sg shengchao.qin@durham.ac.uk Abstract Conventional speci.cations \nfor object-oriented (OO) programs must adhere to behavioral subtyping in support of class inheri\u00adtance \nand method overriding. However, this requirement inherently weakens the speci.cations of overridden methods \nin superclasses, leading to imprecision during program reasoning. To address this, we advocate a fresh \napproach to OO veri.cation that focuses on the distinction and relation between speci.cations that cater \nto calls with static dispatching from those for calls with dynamic dispatch\u00ading. We formulate a novel \nspeci.cation subsumption that can avoid code re-veri.cation, where possible. Using a predicate mechanism, \nwe propose a .exible scheme for supporting class invariant and lossless casting. Our aim is to lay the \nfoundation for a practical veri.cation system that is precise, concise and modular for sequen\u00adtial OO \nprograms. We exploit the separation logic formalism to achieve this. Categories and Subject Descriptors \nD.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; D.3.3 [Programming Lan\u00adguages]: Language \nConstruct and Features; F.3.1 [Logics and Meanings of Programs]: Specifying, Verifying and Reasoning \nabout Programs General Terms Languages, Theory, Veri.cation Keywords Automated Veri.cation, Enhanced \nSubsumption, Sep\u00adaration Logic, Lossless Casting, Static and Dynamic Speci.cations. 1. Introduction \nObject-based programs are hard to statically analyse mostly be\u00adcause of the need to track object mutations \nin the presence of aliases. Object-oriented (OO) programs are even harder, as we have to additionally \ndeal with class inheritance and method overriding. One major issue to consider when verifying OO programs \nis how to design speci.cation for a method that may be overridden by another method down the class hierarchy, \nsuch that it conforms to method subtyping. In addition, it is important to ensure that subtyp\u00ading is \nobserved for object types in the class hierarchy, including any class invariant that may be imposed. \nFrom the point of conformance to OO semantics, most analysis techniques uphold Liskov s Sub\u00adstitutivity \nPrinciple (Liskov 1988) on behavioral subtyping. Under Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 08, January 7 12, 2008, San Francisco, California, USA. Copyright \nc &#38;#169; 2008 ACM 978-1-59593-689-9/08/0001. . . $5.00 this principle, an object of a subclass can \nalways be passed to a location where an object of its superclass is expected, as the ob\u00adject from each \nsubclass must subsume the entire set of behaviors from its superclass. To enforce behavioral subtyping \nfor OO pro\u00adgrams, several past works (Dhara and Leavens 1996; Barnett et al. 2004; Kiniry et al. 2005) \nhave advocated for class invariants to be inherited by each subclass, and for pre/post speci.cations \nof the overriding methods of its subclasses to satisfy a speci.cation sub\u00adsumption (or subtyping) relation \nwith each overridden method of its superclass. Each speci.cation of a method (or a piece of code) is \ntypically given as a pair (pre, post) of precondition pre and postcondition post. We use an in.x notation \npre *. post to denote such a speci\u00ad.cation. A basic speci.cation subsumption mechanism was orig\u00adinally \nformulated as follows. Consider a method B.mn in class B with (preB *. postB ) as its pre/post speci.cation, \nand its overrid\u00ading method C.mn in subclass C, with a given pre/post speci.cation (preC *. postC ). The \nspeci.cation (preC *. postC ) is said to be a subtype of (preB *. postB ) in support of method overriding, \nif the following subsumption relation holds: preB . type(this)<:C =. preC postC =. postB (preC *. postC \n) <:C (preB *. postB ) The two conditions are to ensure contravariance of precondi\u00adtions, and covariance \non postconditions. They follow directly from the subtyping principle on methods speci.cations. As the \ntwo speci.cations are from different classes, we add the subtype con\u00adstraint type(this)<:C to allow the \nabove subsumption relation to be checked for the same C subclass. To re.ect this, we parameterize the \nsubsumption operator <:C with a C-class as its suf.x. The main purpose of using speci.cation subsumption \nis to sup\u00adport modular reasoning by avoiding the need to re-verify the code of overriding method C.mn \nwith the speci.cation (preB *. postB ) of its overridden method B.mn. In the case that speci.cation sub\u00adsumption \ndoes not hold, an alternative way to achieve behavioral subtyping is to use the speci.cation inheritance \ntechnique of Dhara and Leavens (1996) to strengthen the speci.cation of each over\u00adriding method with \nthe speci.cation of its overridden method, as follows: Consider a method B.mn in class B with (preB *. \npostB ) as its pre/post speci.cation, and its overriding method C.mn in subclass C, with pre/post speci.cation \n(preC *. postC ). To ensure speci.ca\u00adtion subsumption, we can strengthen the speci.cation of the over\u00adriding \nmethod via speci.cation inheritance with the intersection of their speci.cations, namely: . (preC *. \npostC )(preB . type(this)<:C *. postB ). Speci.cation inheritance requires the use of multiple speci.ca\u00adtions \n(or intersection type) to provide for a more expressive mech\u00adanism to describe each method. By inheriting \na new speci.cation for the overriding method, this technique uses code re-veri.cation itself to ensure \nthat a behavioral subtyping property would be en\u00adforced. We can generalise a de.nition of the subsumption \nrelation between two multiple speci.cations, as follows: DEFINITION 1.1 (Multi-Speci.cations Subsumption). \nGiven two .. multiple speci.cations, n specBj (for class B) and m specCi j=1i=1 (for subclass C), where \neach of specBj and specCi is a pre/post annotation of the form pre *. post. We say that they are in speci\u00ad \n.. .cation subsumption relation, ( m specCi ) <:C ( n specBj ), i=1j=1 if the following holds : . j. \n1..n . i. 1..m \u00b7 specCi <:C specBj . While modular reasoning can be supported by the above sub\u00adsumption \nrelations, the reasoning were originally formulated in the framework of Hoare logic. Recently, separation \nlogic has been pro\u00adposed as an extension to Hoare logic, providing precise and con\u00adcise reasoning for \npointer-based programs. A key principle fol\u00adlowed in separation logic is the use of local reasoning to \nfacilitate modular analysis/reasoning. An early work on applying separation logic to the OO paradigm \nwas introduced by Parkinson and Bier\u00adman (2005). In that work, two key concepts were identi.ed. Firstly, \nan abstract predicate family pt (v1 , .., vn ) was used to capture some program states for objects of \nclass hierarchy with type t. Each ab\u00adstract predicate has a visibility scope and is allowed to have a \ndif\u00adferent number of parameters, depending on the actual type of its root object. Moreover, each predicate \nfamily acts as an extensible predicate for which incremental speci.cation is given and veri.ed for each \nclass. Secondly, the concept of speci.cation compatibil\u00adity was introduced to capture the subsumption \nrelation soundly, as follows: A speci.cation preC *. postC is said to be compatible with preB *. postB \nunder all program contexts, if the following holds: .code \u00b7{preC }code{postC } =.{preB }code{postB }(preC \n*. postC ) <:(preB *. postB ) Speci.cation compatibility can be viewed as a more fundamen\u00adtal way to \ndescribe speci.cation subsumption in terms of Hoare logic triples. However, it cannot be directly implemented, \nsince its naive de.nition depends on exploring all possible program codes for compatibility. In this \npaper, we provide a practical alternative towards automated veri.cation of OO programs that can support \nbetter precision and avoid unnecessary code re-veri.cation. We use key principles of separation logic \nto achieve this. 1.1 Towards Better Precision and Reuse The focus on speci.cations that support method \noverriding has a potential drawback that these speci.cations are typically imprecise (or weaker) for \nmethods of superclasses. Such speci.cations typi\u00adcally have stronger preconditions (which restrict their \napplicability) and/or weaker postconditions (which lose precision). This draw\u00adback can cause imprecision \nfor OO veri.cation which has in turn spurred practical lessons on tips and tricks for speci.cation writers \n(Kiniry et al. 2005). Furthermore, mechanisms such as speci.cation inheritance may have unnecessary code \nre-veri.cation, especially when speci.cation subsumption holds. Let us consider the speci.cation of a \nsimple up-counter class in Figure 1. This Cnt class is accompanied by three possible sub\u00adclasses (i) \nFastCnt to support a faster tick operation, (ii) PosCnt which works only with positive numbers, (iii) \nTwoCnt which sup\u00adports an extra backup counter. Let us .rst design the speci.cations for instance methods \nof class Cnt without worrying about method overriding. A possible set of pre/post speci.cations is given \nbelow where this and res are variables denoting the receiver and result of each method. void Cnt.tick() \nstatic this::Cnt(n)*.this::Cnt(n+1) void Cnt.set(int x) static this::Cnt(n)*.this::Cnt(x) int Cnt.get() \nstatic this::Cnt(n)*.this::Cnt(n).res=n class Cnt { int val; Cnt(int v) { this.val:=v}void tick() { this.val:=this.val+1}int \nget() { this.val}void set(int x) { this.val:=x} } class FastCnt extends Cnt {FastCnt(int v) { this.val:=v}void \ntick() { this.val:=this.val+2} } class PosCnt extends Cnt inv this.val= 0 {PosCnt(int v) { this.val:=v}void \nset(int x) { if x= 0 then this.val:=x else error()} } class TwoCnt extends Cnt { int bak; TwoCnt(int \nv, int b) { this.val:=v; this.bak:=b}void set(int x) { this.bak:=this.val; this.val:=x}void switch(int \nx) { int i:=this.val; this.val:=this.bak; this.bak:=i} } Figure 1. Example: Cnt and its subclasses We \nrefer to these as static speci.cations and precede them with the static keyword. They can be very precise \nas they were considered statically on a per method basis without concern for method over\u00adriding, and \ncan be used whenever the actual type of the receiver is known. The notation y::c( v1 , .., vn ) denotes \nthat variable y is point\u00ading to an object with the actual type1 of c-class and where each .eld y.fi is \ndenoted by variable vi . For example, in this::Cnt( n) , the .eld this.val is denoted by variable n. \nThis format for objects is used primarily for static speci.cation. To describe an object type whose type \nis merely a subtype of the c-class, we shall use a differ\u00adent notation, namely y::c( v *) $, which implicitly \ncaptures an object extension with extra .elds from its subclass. If we take into account the possible \noverriding of the tick method by its corresponding method in the FastCnt subclass, we may have to weaken \nthe postcondition of Cnt.tick.Furthermore, to guarantee the invariant this.val= 0 of the PosCnt class, \nwe may have to strengthen the preconditions of methods Cnt.set, Cnt.tick and Cnt.get. These weakenings \nresult in the following dynamic speci.cations which are the usual ones being considered for dy\u00adnamically \ndispatched methods, where the type of the receiver is a subtype of its current class. void Cnt.tick() \ndynamic this::Cnt(n)$.n=0 *.this::Cnt(b)$.n+1=b=n+2 void Cnt.set(int x) dynamic this::Cnt(n)$.x=0 *.this::Cnt(x)$ \nint Cnt.get() dynamic this::Cnt(n)$.n=0 *.this::Cnt(n)$.res=n Such changes make the speci.cations of \nthe methods in super\u00adclasses less precise, and are carried out to ensure behavioral subtyp\u00ading. Furthermore, \nthese speci.cations must also cater to potential modi.cations that may occur in the extra .elds of the \nsubclasses by their overriding methods either directly or indirectly. Due to con\u00ad.icting requirements, \nwe advocate the co-existence of both static and dynamic speci.cations. The former is important for precision \nand shall be used primarily for code veri.cation, while the latter is needed to support method overriding \nand must be used for dynam\u00adically dispatched methods. Formally: 1 To make our static speci.cations more \nreusable through inherited meth\u00adods, we shall avoid the use of an explicit constraint, like type(this)=c, \non the actual type of the receiver. DEFINITION 1.2 (Static Pre/Post). A speci.cation is said to be static \nif it is meant to describe a single method declaration, and need not be used for subsequent overriding \nmethods. DEFINITION 1.3 (Dynamic Pre/Post). A speci.cation is said to be dynamic if it is meant for use \nby a method declaration and its subsequent overriding methods. Past works, such as America (1991); Dhara \nand Leavens (1996); Liskov and Wing (1994); Parkinson (2005); Barnett et al. (2004); Muller (2002), are \nbased primarily on dynamic speci.cations, though implicit static speci.cations via type(this)=c can also \nbe used in ESC/Java and Spec#, while JML uses code contract (Leav\u00adens et al. 2007, ch 15) as a form of \nstatic speci.cation. However, these proposals for static speci.cations are somewhat ad-hoc, as they do \nnot impose any relation between static and dynamic speci\u00ad.cations. In our approach, we emphasize static \nspeci.cations over dynamic speci.cations. Most importantly, we always ensure that the static speci.cation \nof a method from a given class is always a subtype of the dynamic speci.cation of the same method within \nthe same class. This principle is important for modular veri.cation, as we need only verify the code \nof each method once against its static speci.cation. It is unnecessary to verify the corresponding dynamic \nspeci.cation since the latter is a speci.cation supertype. Our pro\u00adposal uses the following principles \nfor OO veri.cation, achieving both precision and reuse. DEFINITION 1.4 (Principles for Enhanced OO Veri.cation). \n Static speci.cation is given for each new method declaration, and may be added for inherited methods \nto support new auxil\u00adiary calls and subclasses with new invariants.  Dynamic speci.cation is either \ngiven or derived. Whether given or derived, each dynamic speci.cation must satisfy two sub\u00adsumption properties. \nEach must be a :  speci.cation supertype of its static counterpart. This helps keep code re-veri.cation \nto a minimum.  speci.cation supertype of the dynamic speci.cation of each overriding method in its \nsubclasses. This helps ensure be\u00adhavioral subtyping.   Code veri.cation is only performed for static \nspeci.cations.   1.2 Our Contributions The main contributions of our paper are highlighted below: \nEnhanced Speci.cation Subsumption : We improve on a clas\u00adsical speci.cation subsumption relation. Apart \nfrom the usual checking for contravariance on preconditions and covariance on postconditions, we allow \npostcondition checking to be strength\u00adened with the residual heap state from precondition checking. This \nenhancement is courtesy of the frame rule from separation logic which can improve modularity.  Static \nand Dynamic Speci.cations : We advocate the coexis\u00adtence of static and dynamic speci.cations, with an \nemphasis on the former. We impose an important subsumption relation be\u00adtween them. This principle allows \nfor improved precision, while keeping code re-veri.cations to a minimum.  Lossless Casting : We use \na new object format that allows loss\u00adless casting to be performed. This format supports both partial \nviews and full views for objects of classes that are suitable for static and dynamic speci.cations, respectively. \n Statically-Inherited Methods : New speci.cations may be given for inherited methods but must typically \nbe re-veri.ed. To avoid the need for re-veri.cation, we propose for speci.ca\u00adtion subsumption to be checked \nbetween each new static speci\u00ad.cation of the inherited method in a subclass against the static  speci.cation \nof the original method in the superclass. We iden\u00adtify a special category of statically-inherited methods \nthat can safely avoid code re-veri.cation for static speci.cations. Deriving Speci.cations : We propose \ntechniques to derive dynamic speci.cations from static speci.cations, and show how re.nement can be carried \nout to ensure behavioral subtyping.  Prototype System and Correctness Proof : We have imple\u00admented a \nprototype system to validate our proposal, and formu\u00adlated a set of lemmas on its correctness.  The \nnext section provides more details of our approach in sup\u00adporting objects for class inheritance, and \nmethods via an enhanced speci.cation subsumption relation.  2. Our Approach Our approach to enhancing \nOO veri.cation is based on separation logic. We shall describe how we adapt separation logic for reason\u00ading \nabout objects from a class hierarchy and how to write precise speci.cations that avoid unnecessary code \nre-veri.cation. 2.1 Separation Logic and Aliasing Separation logic (Reynolds 2002; Isthiaq and O Hearn \n2001) ex\u00adtends Hoare logic to support reasoning about shared mutable data structures. It adds two more \nconnectives to classical logic: separat\u00ading conjunction *, and separating implication - *. h1 * h2 asserts \nthat two heaps described by h1 and h2 are domain-disjoint. h1- *h2 asserts that if the current heap is \nextended with a disjoint heap de\u00adscribed by h1,then h2 holds in the extended heap. In this paper we use \nonly separating conjunction. Existing formalisms from separation logic literature (e.g. Isthiaq and O \nHearn (2001); Reynolds (2002); Parkinson and Bierman (2005)) capture heap constraints (with an initial \nreference from p) using two different notations, namely : i) p ] to denote . [...a pointer p to a single \ndata object represented by [...], and ii) pred(p,..) for a pointer p to a set of linked objects in accordance \nto a predicate named pred. In order to express both notations in a uniform manner, we introduce the notation \np::c(..) where c is either a data object or a heap predicate. Aliasing can be locally speci.ed and captured \nin separation logic. For instance, the formula x::PosCnt(a)*y::PosCnt(b) speci\u00ad.es two distinct PosCnt \nobjects referenced respectively by x and y that are non-aliased. In contrast, the formula x::PosCnt(a).x=y \nspeci.es a single PosCnt object referenced by both x and its local alias y. There may be other aliases \nto an object of the heap formula but the ability to perform local reasoning in separation logic al\u00adlows \nus to ignore them. The following static method s speci.cation captures both scenarios using multiple \nspeci.cations of the form . n (prei *. posti ) below: i=1 void simTick(PosCnt x, PosCnt y) x::PosCnt(a)*y::PosCnt(b)*. \nx::PosCnt(a+1)*y::PosCnt(b+1) . x::PosCnt(a).x=y *. x::PosCnt(a+2){x.tick(); y.tick()} Note the effect \nof the method (speci.ed in the post-conditions) can be very different depending on whether x and y are \naliased, or not. We support a heap predicate mechanism that can be user\u00adspeci.ed to capture a group of \nrelated objects. As an example, we may use an ll predicate (or view) to capture a linear linked-list \nof n nodes, as follows: root::ll(n)= (root=null.n=0) . (.i, m, q \u00b7 root::node(i, q)*q::ll(m).n=m+1) inv \nn=0 class node {int val; node next; ..methods..} For convenience, we name the .rst parameter of each \npredicate with a default name, called root, that may be omitted in the LHS. Each predicate may also have \nother parameters, such as pointers, integers or even bags and lists. These parameters correspond to model \n.elds of some speci.cation languages (Barnett et al. 2004; Muller 2002). Existential quanti.ers may also \nbe omitted without ambiguity. These simpli.cations result in the following more con\u00adcise predicate de.nition: \nll(n)= (root=null.n=0). root::node(i, q)*q::ll(n-1) inv n=0 For simplicity, we shall also restrict our \nconstraint domain to support essential features such as pointers, class subtyping and integers. The above \nde.nition captures an equivalence between a predicate and a heap formula in separation logic. Whenever \nthe predicate holds, we can replace it by its heap formula. Similarly, whenever the formula holds, we \ncan replace it by its corresponding predicate. The .rst technique is known as unfolding (or unrolling), \nwhile the second technique is known as folding (or rolling). These reasonings are sound and can be automated, \nas shown in Nguyen et al. (2007). An important facet of separation logic is the frame rule: f{.} e {.1} \nmodi.es(e) n vars(.R)= \u00d8 f{.*.R} e {.1*.R} The side-condition says that the program e does not modify \nthe variables in .R. The frame rule captures the essence of local reasoning : to understand how a piece \nof code works it should only be necessary to reason about the memory it actually accesses. Ordinarily, \naliasing precludes such a possibility but the separation enforced by the * connective allows local reasoning \nto be captured by the above rule. Through this frame rule, a speci.cation of the heap beingusedby e can \nbe arbitrarily extended as long as free variables of the extended part are not modi.ed by e. To automate \nthe reasoning process, we have formalised in Nguyen et al. (2007) a procedure for entailment with frame \nin\u00adference capability : DEFINITION 2.1 (Entailment with Frame Capability). The entail\u00adment .Af.C * .R \nchecks that heap nodes in the antecedent .A are suf.ciently precise to cover all nodes from the consequent \n.C , and can return a residual heap state .R (from .A) that is not used. For example if we have .A = \nx::ll(n).n>5 and .C = x::node( ,y), the entailment process would succeed (via unfolding ll(n) in .A to \nmatch with the object node in .C ) and also return residual (or frame) .R = y::ll(n-1).n>5.That is: .A \n= x::ll(n).n>5 = x::node( , q)*q::ll(n-1).n>5 f .C * .R f (x::node( , y)) * .R f (x::node( , y)) * (y::ll(n-1).n>5) \n 2.2 Object View and Lossless Casting For separation logic to work with OO programs, one key problem \nthat we must address is a suitable format to capture the objects of classes. We should preferably also \naddress the problem of perform\u00ading upcast/downcast operations statically in accordance with the OO class \nhierarchy, and without loss of information where possi\u00adble. Consider two variables, x and y, which point \nto objects from Cnt class (with a single .eld) and TwoCnt class (with two .elds), re\u00adspectively. Intuitively, \nwe may represent the .rst object by x::Cnt(v)where v denotes its .eld, and the second object by y::TwoCnt(v,b)where \nv,b denote its two .elds. However, a fundamental problem that we must solve is how to cast the object \nof one class to that of its superclass, and vice-versa when needed. To do this without loss of information, \nwe provide two extra information : (i) a variable to capture the actual type of a given object and (ii) \na variable to cap\u00adture the object s record extension that contains extra .eld(s) of its subclass. When \na TwoCnt object is .rst created, we may capture its state using the formula : y::TwoCnt(t,v,b,p).t=TwoCnt.p=null \nThe above formula indicates that the actual type of the object is t=TwoCnt and that there is no need \nfor any record extension since p=null. With this object format, we can now perform an upcast to its parent \nCnt class by transforming it to: y::Cnt(t,v,q)*q::Ext(TwoCnt,b,p).t=TwoCnt.p=null Though this cast operation \nis viewing the object as a member of Cnt class, it is still a TwoCnt object as the type information t=TwoCnt \nindicates. Furthermore, we have created an extension record q::Ext(TwoCnt,b,p) that can capture the extra \nb .eld of the TwoCnt subclass. For simplicity, we currently use an implicit pointer q to capture the \nextension record. This model allows a sequence of upcast operations to be easily captured. Such an upcast \noperation is lossless as we have suf.cient information to perform the inverse downcast operation back \nto the original TwoCnt format. To allow lossless casting between Cnt and TwoCnt,we add an equivalence \nrule : TwoCnt(t,v,b,p)= root::Cnt(t,v,q)*q::Ext(TwoCnt,b,p)An unfold step (which replaces a term that \nmatches the LHS by RHS) corresponds to an upcast operation, while the fold step (which replaces a term \nthat matches the RHS by LHS) corresponds to a downcast operation. Such a rule can be derived from each \nsuperclass-subclass pairing. Formally: DEFINITION 2.2 (Lossless Casting). Givenaclass c(v *) with * ** \n .elds v and its immediate subclass d(v ,w *) where w denotes its extra .elds, we shall generate the \nfollowing casting rule that is coercible in either direction: ** ** root::d(t, v , w , p)= root::c(t, \nv , q)*q::Ext(d, w , p)Note that for any object view d(t,...) it is always the case that the subtype \nrelation t<:d holds as its invariant. Furthermore, the default root parameter on the LHS may be omitted \nfor brevity. Lossless casting is important for establishing the subsumption relation between each static \nspeci.cation and its dynamic counter\u00adpart, as the extension record can be preserved, if needed, by each \nstatic speci.cation. Lossless casting is also important for the static speci.cation of inherited methods \nwhich should preferably be in\u00adherited without the need for re-veri.cation. This can be achieved by exploiting \nlocal reasoning which allows us to assert that an ex\u00adtension record need not be modi.ed by each inherited \nmethod. There are also occasions when we are required to pass the full object with all its (extended) \n.elds. This occurs for dynamic speci.cations where subsequent overriding method may change the extra \n.elds of its subclass. To cater to this scenario, we introduce an ExtAll(t1 ,t2 ) view that can capture \nall the extension records from aclass t1 for an object with actual type t2 . This scenario occurs for \nthe dynamic speci.cation of Cnt.set method, as shown below: this::Cnt(t,, p)*p::ExtAll(Cnt, t).x=0 *. \nthis::Cnt(t, x, p)*p::ExtAll(Cnt, t) Such a dynamic speci.cation may be used with any subtype of Cnt. \nThe entire object view must be passed to support dynamic speci.cations which are expected to cater to \nthe current method and all subsequent overriding methods. The ExtAll predicate itself can be de.ned as \nfollows: ExtAll(t1 , t2 )= t1 =t2 .root=null . root::Ext(t3 , v * , q)*q::ExtAll(t3 , t2 ).t3 <t1 .t2 \n<:t3 inv t2 <:t1 The notation t3 <t1 denotes a class t3 and its immediate super\u00adclass t1 .The ExtAll \npredicate is used to generate all the ex\u00adtension records from class t1 to t2 . For example, expression \nx::ExtAll(Cnt, Cnt) yields x=null,and x::ExtAll(Cnt, TwoCnt)yields x::Ext(TwoCnt, b, null). Our format \nallows two kinds of object views to be supported: DEFINITION 2.3 (Full and Partial Views). We refer to \nthe use of formula x::c(t, v * , p)*p::ExtAll(c, t) as providing a full view for an object with actual \ntype t that is being treated as a c-class object, while x::c(t, v * , p) provides only a partial view \nwith no extension record. For brevity, full views are also written as x::c(v *)$, while partial views \nare coded using x::c(v *). This distinction between partial and full views (for objects) fol\u00adlows directly \nfrom our decision to distinguish static from dynamic speci.cations. Partial views are typically used \nfor the receiver ob\u00adject of static speci.cations, while full views are used by dynamic speci.cations. \nSome readers may contend that lossless casting of an object x from d(v * , w *) to c(v *) may also be \ncaptured with the help of separating implication by representing the extension record using x::c(v *)--* \nx::d(v * , w *). This approach works well for partial views, but cannot easily handle the ExtAll predicate \nrequired by full views. Moreover, by omitting separating implication, our cur\u00adrent approach to automated \nveri.cation is easier to build and prove.  2.3 Ensuring Class Invariants Ensuring that class invariants \nhold can be rather intricate, with the key problems being how and when to check for the invariants. Based \non the simplest assumption, one would expect object invari\u00adants to hold at all times. However, this assumption \nis impractical for mutable objects. One sensible solution is to expect invariants to hold based on visible \nstate semantics, which is typically aligned to the boundaries of public methods. Even this approach may \nnot be .exible enough. Thus, in Boogie (Barnet et al. 2004; Leino and M\u00a8uller 2004), programmers are \nalso allowed to use a spec\u00adi.cation .eld, called valid, that can indicate if the invariant for an object \nis being preserved or temporarily broken for mutation. Similarly, in (Middelkoop et al. 2006), programmers \nare allowed to indicate invariants that are inconsistent (not preserved) at some method boundary. We \naim for a similar level of .exibility but which still re\u00admains easy to use. To achieve this, we introduce \nthe concept of an invariant-enhanced view for each class with a non-trivial invariant, as follows: DEFINITION \n2.4 (Invariant-Enhanced View). Consider a class c with a non-trivial invariant dc (.* of the =true) over \nthe .elds v object. We shall de.ne a new view of the form c#I(v *) to capture its class invariant, as \n: c#I(v *)= root::c(v *)*dc .Furthermore, for each subclass d(v * , w *) with an extra invariant dd over \nthe .elds v * , w *, we expect its invariant to be dc *dd and shall provide a corresponding view : d#I(v \n* , w *)= root::d(v * , w *)*dc *dd . The use of separating conjunction to capture the class invariant \nallows a form of object ownership to be speci.ed for heap objects present in dc . Furthermore, invariant-enhanced \nview can easily and explicitly indicate when an invariant can be enforced and when it can be assumed. \nIf a c(v *) is being used, the class invariant is nei\u00adther enforced nor assumed. If a c#I(v *) is used \nin the precondi\u00adtion, its invariant must be enforced at each of its call sites, but can be assumed to \nhold at the beginning of its method declaration. If a c#I(v *) is used in the postcondition, its invariant \nmust be enforced at the end of its method declaration, but can be assumed to hold at the post-state of \neach of its call sites. With the help of invariant-enhanced views, we can provide pre/post speci.cations \nthat guarantee class invariants are always maintained by public methods. This can help ensure that all \nobjects created and manipulated by public methods are guaranteed to sat\u00adisfy their class invariants. \nAlternatively, it is also possible to allow some methods (typically private ones) to receive or produce \nobjects without the invariant property. This corresponds to situations where the class invariant is temporarily \nbroken. Our invariant-enhanced views can achieve this as they can be selectively and automatically enforced \nin pre/post annotations. For example, the invariant-enhanced view of PosCnt is: PosCnt#I(t, v, p)= root::PosCnt(t, \nv, p)*v=0 Two methods get and tick are being inherited from the Cnt super\u00adclass, while a third method \nset is re-de.ned to ensure the class in\u00advariant. We may provide new static speci.cations for these three \nre\u00adspective methods, to incorporate the invariant-enhanced view. Fig\u00adure 2 shows how this is done for \nour running example. It is suf\u00ad.cient to use a weaker precondition of the form this::PosCnt(v)for static-spec(PosCnt.set) \nwithout compromising its postcondition this::PosCnt#I(x). This corresponds to a temporary violation of \nthe class invariant of PosCnt. 2.4 Enhanced Speci.cation Subsumption With our use of more precise static \nspeci.cations, we can now leverage on a better speci.cation subsumption that can exploit the local reasoning \ncapability of separation logic. In particular, the extended .elds of objects that are not used should \nbe preserved by speci.cation subsumption. More formally, we de.ne the enhanced form of speci.cation subsumption, \nas follows: DEFINITION 2.5 (Enhanced Spec. Subsumption). A pre/post an\u00adnotation preB *. postB is said \nto be a subtype of another pre/post annotation preA *. postA if the following relation holds: preA f \npreB*. postB*. f postA (preB *. postB) <:(preA *. postA) Note that . captures the residual heap state \nfrom the contravariance check on preconditions that is carried forward to assist in the covariance check \non postconditions. As an example of its utility, consider the following speci.cation subsumption that \nis expected to hold for enhanced OO veri.cation. static-spec(Cnt.set) <: dynamic-spec(Cnt.set) For the \nabove to hold, we must prove: this::Cnt(t, v, p)*. this::Cnt(t, x, p)<: this::Cnt(t, v, q)*q::ExtAll(Cnt, \nt).x=0 *. this::Cnt(t, x, q)*q::ExtAll(Cnt, t) The above subtyping cannot be proven with the basic speci.ca\u00adtion \nsubsumption relation from Sec 1 (without the use of a residual heap state), but succeeds with our enhanced \nsubsumption relation. We .rst show the contravariance of the preconditions: this::Cnt(t, v, q)*q::ExtAll(Cnt, \nt).x=0 f this::Cnt(t, v, p)*. This succeeds with .=p::ExtAll(Cnt, t).x=0. We then prove covariance on \nthe postconditions using: this::Cnt(t, x, p)*. f this::Cnt(t, x, q)*q::ExtAll(Cnt, t) This is proven \nwith the help of residual heap state . (with an extension record) from the entailment of preconditions. \nOur preservation of residual heap state is inspired by the needs of static speci.cation. By the use of \na new object format (with loss\u00adless casting) and a novel speci.cation subsumption mechanism, we can now \nsupport a modular veri.cation process in which re\u00adveri.cation is always avoided for dynamic speci.cations. \nOur en\u00adhanced speci.cation subsumption can also be viewed as a practical class Cnt { int val; class PosCnt \nextends Cnt Cnt(int v) static true *. res::Cnt( v) inv this.val= 0 { { this.val:=v} PosCnt(int v) static \nv= 0 *. res::PosCnt#I( v) void tick() static this::Cnt( v)*. this::Cnt( v+1) ; { this.val:=v} dynamic \nthis::Cnt( v) $. v= 0 *. this::Cnt( w) $. v+1= w= v+2 void tick() static this::PosCnt#I( v)*. this::PosCnt#I( \nv+1) { this.val:=this.val+1} dynamic this::PosCnt#I( v) $ *. this::PosCnt#I( v+1) $ int get() static \nthis::Cnt( v)*. this::Cnt( v). res=v int get() static this::PosCnt#I( v)*. this::PosCnt#I( v). res=v \ndynamic this::Cnt( v) $. v= 0 *. this::Cnt( v) $ void set(int x) static this::PosCnt( v). x= 0 *. this::PosCnt#I( \nx) { this.val} dynamic this::PosCnt( v) $. x= 0 *. this::PosCnt#I( x) $ void set(int x) static this::Cnt( \nv)*. this::Cnt( x) ; { if x= 0 then this.val:=x else error()} dynamic this::Cnt( v) $. x= 0 *. this::Cnt( \nx) $ } { this.val:=x} class TwoCnt extends Cnt { int bak; }TwoCnt(int v, int b) static true *. res::TwoCnt( \nv, b)class FastCnt extends Cnt {{ this.val:=v; this.bak:=b} FastCnt(int v) static true *. res::FastCnt( \nv) void set(int x) static this::TwoCnt( v, )*. this::TwoCnt( x, v) { this.val:=v}{ this.bak:=this.val; \nthis.val:=x} void tick() static this::FastCnt( v)*. void switch(int x) static this::TwoCnt( v, b)*. this::TwoCnt( \nb, v) this::FastCnt( v+2){ this.val:=this.val+2}{ int i:=this.val; this.val:=this.bak; this.bak:=i}}} \n Figure 2. Static and Dynamic Speci.cations given for Cnt and its Subclasses algorithm for implementing \nParkinson s speci.cation compatibil\u00adity (Parkinson 2005). This link shall be formally proven later in \nLemma 6.1.  3. Conformance to the OO Paradigm We present mechanisms to ensure that method overriding \nand method inheritance are supported in accordance with the require\u00adments of the OO paradigm. 3.1 Behavioral \nSubtyping with Dynamic Speci.cations Dynamic speci.cations are meant for the methods of a given class \nand its subclasses. They must conform to the behavioral subtyping principle to support method overriding \n(and inheritance), as de.ned by the requirement below: DEFINITION 3.1 (Behavioral Subtyping Requirement). \nGiven a dynamic speci.cation preC *. postC in a method mn in class C and another dynamic speci.cation \npreD *. postD of the corre\u00adsponding method mn in a subclass D. We say that the two spec\u00adi.cations adhere \nto the behavioral subtyping requirement using (preD *. postD) <:D (preC *. postC), if the following subsumption \nholds : preD *. postD <:(preC. type(this)<:D *. postC). As shown above, we can use the enhanced speci.cation \nsub\u00adsumption relation to check for behavioral subtyping. For an exam\u00adple, consider the dynamic speci.cation \nof method Cnt.set and its overriding method PosCnt.set. Assuming that these dynamic spec\u00adi.cations are \ngiven, the behavioral subtyping requirement can be checked using: dynamic-spec(PosCnt.set) <:PosCnt dynamic-spec(Cnt.set) \nHence, we have: this::PosCnt() $. x= 0 *. this::PosCnt#I( x) $ <: this::Cnt( v) $. x= 0. (type(this)<:PosCnt) \n*. this::Cnt( x) $ By contravariance of preconditions, we successfully prove: this::Cnt( v) $. x= 0. \n(type(this)<:PosCnt) f this::PosCnt() $. x= 0 * . where . is derived to be x= 0. By covariance of postconditions, \nwe can prove: this::PosCnt#I( x) $* . f this::Cnt( x) $ Hence, the above two dynamic speci.cations of \nCnt.set and PosCnt.set conform to the behavioral subtyping requirement.  Dynamic speci.cations may \nalso be given (or derived) for in\u00adherited methods, especially when their static speci.cations have been \nmodi.ed. As with method overriding, we continue to expect that the behavioral subtyping requirement holds \nbetween a dynamic speci.cation (as supertype) for a method in a class and another dynamic speci.cation \n(as subtype) for the same inherited method in the subclass. Let us consider Cnt.tick and its inherited \nmethod PosCnt.tick. Though no method overriding is present, we must still ensure dynamic-spec(PosCnt.tick) \n<: PosCnt dynamic-spec(Cnt.tick). 3.2 Statically-Inherited Methods Under the OO paradigm, it is possible \nfor a method mn in a class C to be inherited into its subclass D without any overriding. Furthermore, \nthe user is free to add a new static/dynamic speci.cation to such an inherited method for each subclass. \nSuch a scenario may occur for a subclass with a strengthened invariant. For each inherited method of \nthis subclass, we anticipate a new static speci.cation possibly using its invariant-enhanced view. An \nimportant question to ask is if there is a need to re-verify this new static speci.cation against the \nbody of the inherited method. We shall .rst consider static speci.cation where the receiver is speci.ed \nusing partial view of form this::c( t, v * , p) . For this cat\u00adegory of static speci.cations, we are \nexpecting that each method invocation by this.mn(..) does not modify any .elds in the exten\u00adsion record \nand is the same as that in the original method prior to method inheritance. To support the inheritance \nof static spec\u00adi.cations which use partial views for their receivers, without re\u00adveri.cation, we identify \na category of inherited methods that is se\u00admantically equivalent (modulo the receiver) to the original \nmethod in the superclass. DEFINITION 3.2 (Statically-Inherited Methods). Given a method mn with body \ne from class A that is being inherited into a subclass B, we say that this method is statically-inherited, \nif the following conditions hold: it has not been overridden in the B subclass.  for all auxiliary \ncalls this.mn2(..) for which mn.  =mn2,itmustbe the case that B.mn2 is statically-inherited from A.mn2. \n We can show that each statically-inherited method is seman\u00adtically equivalent to the original method \nfrom its superclass. The above conditions ensure this by checking that the inherited method always invokes \nthe same sequence of semantically equivalent method calls, as that when executed with a receiver object \nfrom its superclass. With this classi.cation for statically-inherited meth\u00adods, we can check inherited \nstatic speci.cations, as follows: DEFINITION 3.3 (Checking Inherited Static Speci.cations). Consider \na method mn with static speci.cation spA (using a par\u00adtial view for its receiver) from class A that is \nbeing inherited into a subclass B with static speci.cation spB. If this method has been statically-inherited \ninto subclass B, we only need to check for speci\u00ad.cation subsumption spA<:spB. Otherwise, we have to \nre-verify the method body of mn with the new static speci.cation spB. As an example, PosCnt.tick is statically-inherited \nfrom Cnt.tick (with a partial view this::Cnt( v) ), and we can conclude that both methods are semantically \nequivalent modulo the receiver. To avoid the re-veri.cation of the static speci.cation of PosCnt.tick,we \nonly need to check for the following subtyping: static-spec(Cnt.tick) <: static-spec(PosCnt.tick) Some \nother methods, such as PosCnt.get, FastCnt.get, FastCnt.set, TwoCnt.tick and TwoCnt.get, are also statically-inherited. \nFor a counterexample that is not statically-inherited, consider: class A { int foo { return this.goo() \n} int goo { return 1 } } class B extends A { int goo { return 2 } } The foo method cannot be statically-inherited \nin subclass B,since it invokes an auxiliary goo method that is not statically-inherited (in this case \noverridden). In other words, method B.foo() is not semantically equivalent (modulo the receiver) to A.foo() \nsince they invoke different sequences of method calls when given the same parameters except for the receiver. \nAs a result, we expect that the static speci.cation (with partial view) for B.foo must be re-veri.ed \nagainst its inherited method body from A.foo. We have two solutions for handling methods that are not \nstatically-inherited. One solution is to transform each method that is not statically-inherited into \nan overriding method. This is achieved by cloning the method declaration for each such method in its \nsubclass. By doing so, we force code re-veri.cation to be performed for the cloned methods, when inheriting \nstatic speci.ca\u00adtions into such non statically-inherited methods. A second solution is to utilize full \nviews on the receivers of static speci.cations. By using full views on receivers, we shall be handling \neach method invocation of the form this.mn2(...) by using its corresponding dynamic speci.cation. As \na consequence, each such static speci.\u00adcation (with full views on receiver) can always be inherited into \nany subclass without the need for re-veri.cation, regardless of whether the method is statically-inherited \nor not. However, some loss in precision may occur since dynamic speci.cations are now used by each receiver \nduring the veri.cation of its method s body.  4. Deriving Speci.cations While a static speci.cation \ncan give better precision, having to maintain both static and dynamic speci.cations may seem like more \nhuman effort is required by our approach to OO veri.cation. To alleviate this, we provide the following \nset of derivation tech\u00adniques that can be used, where needed. derive dynamic speci.cations from static \ncounterparts.  re.ne dynamic speci.cations to meet behavioral subtyping.  inherit static speci.cations \nfrom method of superclass.  Let us initially assume that none of the dynamic speci.cations are given \nfor our running example. We .rst present a simple tech\u00adnique for deriving a dynamic speci.cation from \nits static counter\u00adpart, as follows: DEFINITION 4.1 (From Static to Dynamic Speci.cation). Given a static \nspeci.cation specS for class C, we shall derive its dynamic counterpart specD, as follows: specD = .C \nspecS where .C =[this::C( v * ). this::C( v * ) $, this::C#I( v * ) * ) $] . this::C#I( v Some examples \nof dynamic speci.cations that can be automat\u00adically derived from their static counterparts are: dynamic-spec(Cnt.get)= \n.Cnt static-spec(Cnt.get) = this::Cnt( v) $ *. this::Cnt( v) $ . res=v dynamic-spec(Cnt.tick)= .Cnt static-spec(Cnt.tick) \n= this::Cnt( v) $ *. this::Cnt( v+1) $ dynamic-spec(PosCnt.get)= .PosCnt static-spec(PosCnt.get) = this::PosCnt#I( \nv) $ *. this::PosCnt#I( v) $ . res=v dynamic-spec(FastCnt.tick) = .FastCnt static-spec(FastCnt.tick) \n= this::FastCnt( v) $ *. this::FastCnt( v+2) $ This technique can help us derive dynamic speci.cations \nthat are almost identical to static speci.cations, and are especially rele\u00advant for methods (e.g. in \n.nal classes) where overriding is not pos\u00adsible. However, these automatically derived dynamic speci.cations \nmay fail to meet the behavioral subtyping requirement. Failure of behavioral subtyping can be due to \ntwo possible reasons: 1. Dynamic speci.cation of method in superclass is too strong, or 2. Dynamic speci.cation \nof method in subclass is too weak.  We propose two re.nement techniques for related pairs of dy\u00adnamic \nspeci.cations to help them conform to behavioral subtyping. A conventional way is to use speci.cation \ninheritance (or special\u00adization) to strengthen the dynamic speci.cation of the overriding method. However, \nin our approach, this technique of strengthening the dynamic speci.cations of a method in the subclass \nmay violate a key requirement that the dynamic speci.cation be a supertype of its static counterpart. \nThus, prior to using speci.cation specializa\u00adtion, we must either check that each inherited dynamic speci.cation \nis indeed a supertype of the static speci.cation from the overriding method, or can be made to inherit \nthe static speci.cation from the overridden method, as follows : DEFINITION 4.2 (Speci.cation Specialization). \nGiven a dynamic speci.cation preDA *. postDA and its static speci.cation preSA *. postSA for a method \nmn in class A, and its overriding method in a subclass B with static speci.cation preSB *. postSB . A \ndynamic speci.cation (preDA . type(this) <: B *. postDA ) can be added to the overriding method of the \nB subclass if either of the following occurs: preSB *. postSB <:B preDA *. postDA holds, or .A.B (preSA \n*. postSA ) can be inherited into the static speci.\u00adcation of mn in class B and successfully veri.ed. \n* Note that .A.B =[this::A( v *). this::B( v , w *) , this::A#I( v *) . this::B( v * , w *)* dA ] where \nw * are free variables of the extended record, while dA captures the invariant of A class. The re.ned \ndynamic speci.cation for the overriding method is obtained via . intersection type, (preDB *. postDB \n)(preDA . type(this) <: B *. postDA ). As an example, the pair of dynamic speci.cations for Cnt.get and \nPosCnt.get do not conform to behavioral subtyping. We may therefore attempt to strengthen the dynamic \nspeci.cation of PosCnt.get by speci.cation specialization through the following multi-speci.cation: . \nthis::PosCnt#I( v) $ *. this::PosCnt#I( v) $ . res=v this::Cnt( v) $. type(this)<:PosCnt *. this::Cnt( \nv) $. res=v However, the inherited dynamic speci.cation from Cnt.get is not a supertype of static-spec(PosCnt.get). \nHence, in order to pro\u00adceed with this re.nement, we must also inherit the static speci.ca\u00adtion of static-spec(Cnt.get) \ninto PosCnt.get, as follows: . this::PosCnt#I( v)*. this::PosCnt#I( v). res=v this::PosCnt( v)*. this::PosCnt( \nv). res=v This strengthened static speci.cation is now a subtype of the correspondingly derived dynamic \nspeci.cation. Furthermore, be\u00adhavioral subtyping holds between the new dynamic speci.cations of Cnt.get \nand PosCnt.get. A caveat about speci.cation special\u00adization is that the strengthened static speci.cation \nof the method in the subclass may not always guarantee the invariant property. For example, this::PosCnt#I(v)*.this::PosCnt#I(v).res=v \nguarantees that the class invariant of PosCnt is preserved, but not this::PosCnt(v) *. this::PosCnt(v).res=v. \nIt is thus possible for successfully veri.ed calls of this method to violate the class in\u00advariant property, \nbut the above multi-speci.cation is fully aware of when each such violation occurs through the use of \ndifferent pred\u00adicates. This violation of a class invariant is one reason why Findler et al. (2001) considered \nspeci.cation inheritance to be a potentially unsound derivation technique. As a complement to speci.cation \nspecialization, we propose a dual mechanism that weakens the speci.cation of the overridden method instead. \nWe refer to this new technique as speci.cation abstraction. Instead of an intersection type, we use a \nunion type to obtain a weaker dynamic speci.cation for the overridden method. Formally: DEFINITION 4.3 \n(Speci.cation Abstraction). Givenadynamic speci.cation preDA *.postDA for a method mn in class A, and \nits overriding method in a subclass B with dynamic speci.cation preDB *. postDB . If behavioral subtyping \ndoes not hold between these dynamic speci.cations, we can generalise the speci.cation of the overridden \nmethod using the following union type: dynamic-spec(A.mn)=(preDA *. postDA ) . .B.A (preDB ) *. . w * \n\u00b7 .B.A (postDB ) .B.A =[this::B( v * , w * ) $. this::A( v * ) $, this::B#I( v * , w * ) $. this::A#I( \nv * ) $* dB ] We refertothisprocessas speci.cation abstraction.Itis a safe operation that weakens the \ndynamic speci.cation of an overridden method to the point where behavioral subtyping holds. As an example, \nconsider the derived dynamic speci.cations from a pair of methods Cnt.tick and FastCnt.tick where be\u00adhavioral \nsubtyping does not currently hold. We are unable to ap\u00adply speci.cation specialization, as the inherited \nstatic speci.ca\u00adtion of Cnt.tick cannot be veri.ed by the overriding method of FastCnt.tick. However, \nwith the help of speci.cation abstraction, we can obtain the following union type for dynamic-spec(Cnt.tick) \ninstead. . this::Cnt( v) $ *. this::Cnt( v+1) $ this::Cnt( v) $ *. this::Cnt( v+2) $ Our current separation \nlogic prover is able to directly handle in\u00adtersection types but not union types for its multi-speci.cations. \nWe propose to handle union type by the following translation instead: . (pre1 *. post1 )(pre2 *. post2 \n) =. (pre1 . pre2 ) *. (post1 . post2 ) For brevity, we shall omit the formal details of how normal\u00adization \n(of separation logic formulae) is carried out for the above translation. In the case of Cnt.tick, we \ncan perform normalization to obtain the following weakened dynamic speci.cation: this::Cnt( v) $ *. this::Cnt( \nw) $ . (w=v+1. w=v+2) It would appear that the use of speci.cation abstraction loses modularity, due \nto its dependence on the dynamic speci.cations of overriding methods. However, this is not true. Firstly, \nthe pur\u00adpose of speci.cation abstraction is to derive dynamic speci.ca\u00adtions which need not be re-veri.ed. \nSecondly, we maintain mod\u00adularity as each static speci.cation is veri.ed once, but need only be re-veri.ed \nwhen the speci.cations it depends on change. Though changes may occur for a dynamic speci.cation that \na method de\u00adpends on; the necessity for re-veri.cation is analogous to a modular compilation system which \nre-compiles a module whenever the type interface it depends on changes. While our approach can theoretically \nderive all dynamic speci\u00ad.cations, we shall also allow the option for users to directly specify dynamic \nspeci.cations, where required. This option is especially helpful in supporting modular open-ended classes \nthat could be further extended with new subclasses. Our overall procedure for selectively but automatically \nderiving dynamic speci.cations shall be as follows: DEFINITION 4.4 (Deriving Dynamic Speci.cations). \nWe derive and re.ne dynamic speci.cations, as follows: If the dynamic speci.cations of both overridden \nand overriding methods are given, check for the behavioral subtyping require\u00adment.  If only the dynamic \nspeci.cation of an overridden method is given, derive the dynamic speci.cation of the overriding method \nand then use speci.cation specialization to re.ne it.  If only the dynamic speci.cation of an overriding \nmethod is given, derive the dynamic speci.cation of the overridden method and then use speci.cation abstraction \nto re.ne it.  Otherwise, derive both dynamic speci.cations and then use speci.cation abstraction to \nre.ne the dynamic speci.cation of the overridden method in the superclass.  Note that the procedure \nis geared towards the preservation of class invariants, where possible, as it favours speci.cation abstrac\u00adtion \nover speci.cation specialization. Lastly, it may also be possible for static speci.cations to be omitted \nfor some statically-inherited methods. We propose a way to derive static speci.cations for such methods, \nas follows: DEFINITION 4.5 (Deriving Static Speci.cations). Given a method mn from class A with static \nspeci.cation spA, and a subclass B where the same method has been statically-inherited. If no static \nspeci.\u00adcation is given for B.mn, we can derive a static speci.cation for it, as follows : * ** static-spec(B.mn)=[this::A( \nv ). this::B( v , w ) ] spA The extra .elds, w *, in the subclass are never modi.ed by each statically-inherited \nmethod. The above substitution is only applicable for partial views, and it is not needed for full views \nwhich will remain unchanged when deriving static speci.cations. Though speci.cation derivation techniques \nare important aids that make it easier for users to adopt our OO veri.cation methodol\u00adogy, they are not \nfundamental in the current work. In the rest of this P ::= tdecl* e tdecl ::= classt |viewt classt ::= \nclass c1 extends c2 inv ..p {(tv)*meth* }t ::= int |bool |void t ::= c |t . viewt ::= view c(v *)=F inv \np sp ::= (Fpr *.Fpo)* meth ::= t mn ((tv)*)[static sp1][dynamic sp2][{e}] e ::= null |k |v |v.f |v:=e \n|v1.f:=v2 |new c(v *) |v:c |e1; e2 |tv; e |v.mn(v *) |if v then e1 else e2 |(c) v |while v where sp do \ne . * F ::= (.v \u00b7..p)* p ::= ..f.\u00df . ::= v1.. =v2 |v=null |v1=v2 |v=null |.1..2 . ::= emp |v::c(v *)|.1 \n*.2 \u00df ::= v=c |v<:c . ::= F |.1..2 |..p |.1*.2 |.v\u00b7. f ::=true |false |a1=a2 |a1=a2 |c<v |f1.f2 |f1.f2 \n|\u00acf |.v \u00b7f |.v \u00b7f a ::= k |v |k\u00d7a |a1 +a2 |-a |max(a1,a2) |min(a1,a2) Figure 3. A Core Object-Oriented \nLanguage paper, we shall assume that all required dynamic and static speci.\u00adcations are available, and \nproceed to describe core components of our enhanced OO veri.cation system.  5. Enhanced OO Veri.cation \nWe shall now formalise our veri.cation system. We consider a simple sequential language with just the \nbasic features from the OO paradigm. Some omitted features, such as exceptions, static .elds and static \nmethods, can be handled in an orthogonal manner and do not cause any dif.culty to our veri.cation system. \n5.1 A Core OO Language We provide a simple OO language in Figure 3, and assume that type-checking is \ndone on the program and speci.ed constraints prior to veri.cation. This core language is the target of \nsome pre\u00adprocessing steps. A program consists of a list of class and view dec\u00adlarations and an expression \nwhich corresponds to the main method in many languages. We assume that the super class of each class \nis explicitly declared, except for Object at the top of the class hierar\u00adchy. We also use this as a special \nvariable referring to the receiver object, and super to refer to a superclass s method invocation. For \neach view de.nition, we declare an invariant p over the parameters {root,v *}that is valid for each instance \nof the view. Also, F is a normalised form of ., . captures pointer constraint, \u00df type infor\u00admation, f \narithmetic constraints, while p a pure formula without any heap. Each method meth and while loop is declared \nwith in\u00ad . tersection type(s) of the form (Fpr *.Fpo)*. For simplicity, we assume that variable names \ndeclared in each method are all distinct and use the pass-by-value parameter mechanism. Primed notation \nis used to capture the latest value of local variables and may appear in the postcondition of loops. \nFor example : '' while x<0 where true *.(x>0.x=x) .(x=0.x=0) do {x:=x+1 }Here x and x' denote the old \nand new values of variable x at the entry and exit of the loop, respectively. Note that precondition \ntrue captures the loop s invariant, while postcondition (x>0.x'=x) . (x=0.x'=0) captures the loop s effects. \n 5.2 Veri.cation System Our veri.cation system for OO programs is implemented in a mod\u00adular fashion. \nIt processes the class declarations in a top-down man\u00adner whereby the methods of superclasses are veri.ed \nbefore those of the subclasses. We shall assume that static speci.cations are given, and that dynamic \nspeci.cations are already given (or au\u00adtomatically derived). Also, for each method that is not statically \ninherited in a subclass, we shall clone the method for that subclass. There are three major subsystems \npresent, namely: (i) View Gen\u00aderator, (ii) Inheritance Checker, and (iii) Code Veri.er. These are elaborated \nnext. 5.2.1 View Generator For each subclass in the class hierarchy, we must generate a lossless upcasting \nrule in accordance with Defn 2.2. However, the format Ext(c, v * , p) actually denotes a family of record \nextensions that is distinct for each subclass c. To distinguish them clearly in our implementation, we \nprovide a set of specialised record extensions of the form Extc (v * , p)instead. With this change, we \ncan generate the following casting rules for our running example: PosCnt(t, n, p)= root::Cnt(t, n, q)*q::ExtPosCnt \n(p) FastCnt(t, n, p)= root::Cnt(t, n, q)*q::ExtFastCnt (p) TwoCnt(t, n, b, p)= root::Cnt(t, n, q)*q::ExtTwoCnt \n(b, p) Correspondingly, we may also provide an ExtAll view for the class hierarchy. In the case of our \nrunning example, we can generate the following de.nition for the ExtAll view: ExtAll(t1 , t2 )= (t1 =t2 \n).root=null . root::ExtPosCnt (q)*q::ExtAll(PosCnt, t2 ).PosCnt<t1 .t2 <:PosCnt . root::ExtFastCnt (q)*q::ExtAll(FastCnt, \nt2 ).FastCnt<t1 .t2 <:FastCnt . root::ExtTwoCnt (b, q)*q::ExtAll(TwoCnt, t2 ).TwoCnt<t1 .t2 <:TwoCnt \n Lastly, for each subclass with a non-trivial invariant, we also generate two invariant-enhanced views \nfor this subclass. For our running example, only the subclass PosCnt has an invariant. Hence, our generator \nwill provide the following: PosCnt#I(t, n, p)= root::PosCnt(t, n, q).n=0 In summary, the above shows \nhow we explicitly generate pred\u00adicate views for casting and class invariants. In practice, our pro\u00adtotype \nveri.cation system creates these views on demand during entailment checking itself. 5.2.2 Inheritance \nChecker This subsystem ensures that speci.cations of added methods are consistent with class inheritance \nand method overriding require\u00adments. Whenever a new subclass B is added, we expect a set of new overriding \nmethods and another set of statically-inherited methods. We propose to check for consistency, as follows: \n Firstly, we check that each static speci.cation is a subtype of the dynamic speci.cation.  For each \nnew overriding method B.mn, we identify the nearest overridden method in a superclass of B. We then check \nthat each given dynamic speci.cation is a subtype of the given dynamic speci.cation of its overridden \nmethod in its superclass.  For each statically-inherited method B.mn, we check that its given static \nspeci.cation is a supertype of the corresponding static speci.cation in its superclass. If a dynamic \nspeci.cation is also given, we check that it is a subtype of the given dynamic speci.cation in its superclass. \n  Some of the static and dynamic speci.cations may have been automatically derived. As these derived \nspeci.cations are correct by construction, we shall not be checking for the speci.cation subsumption \nrelation amongst them. 5.2.3 Code Veri.er To support veri.cation, we shall use Hoare-style rule of the \nform f{.1}e{.2}. This rule is applied in a forward manner. Given a heap state .1 and an expression e, \nwe expect the above veri.cation to succeed and also produce a poststate .2. There are four features in \nour core language that are peculiar to the OO paradigm, namely (i) the object constructors, (ii) the \ncast constructs, (iii) instance method invocations and (iv) super calls. Let us discuss how they are \nhandled. For the object constructor, we use the following rule where each primed variable v ' i captures \nthe latest value of variable vi : .1=. * res::c(c,v1' , .., v n ' , null)f{.} new c(v1, .., vn ) {.1} \nThis rule produces an object of actual type c using partial view. Consider a cast construct (c)(v:c1 \n) where v:c1 captures the compile-time type of v inserted before veri.cation. We shall treat it as being \nequivalent to a primitive call of the form: c castc (c1 v) static v::c1 (t,..)*. v::c1 (t,..).t<:c . \ntrue *. true The above declaration allows the cast construct to possibly fail at runtime. If casting \nsucceeds, we may expect that the actual type of the object to be a subtype of c, as captured by the .rst \npre/post annotation. The second pre/post annotation is added for completeness, and may be used if we \nare unable to establish the heap state of v. Another important feature to consider is instance method \ncall of the form (v:c).mn(v1 ..vn ). We .rst identify the best possible type of v using \u00df=findtype(., \nv:c).The result \u00df will tell us if we have the actual type t=c1 or the best static type t<:c1 where t=type(v) \nand c1 <:c. Note that c1 can be more precise than the compile-time type c due to our use of .ow-and path-sensitive \nreasoning. If the ac\u00adtual type is known, we choose the static speci.cation of method mn from class c1 \n. Otherwise, we choose its dynamic speci.cation in\u00adstead. This decision is captured by spec=findspec(P,\u00df, \nmn) where P denotes the entire OO program. The overall rule is: \u00df=findtype(.,v:c) . =[v1.v1' , ..., vn \n.vn ' ] . findspec(P,\u00df, mn)= mi =1(prei *. posti ) .i . 1..m \u00b7 (.f(. prei ) * .i .r =(.i * posti )) \nf{.} (v:c).mn(v1..vn ) {.r } If . is a disjunctive formula with different types for v,we can use findtype/findspec \noperations in the entailment procedure, so that the best speci.cation is selected for either the actual \nor the static type of the object at v for each disjunct. For multi\u00adspeci.cations, we choose the .rst \nspeci.cation whose precondition holds. We assume that these multiple speci.cations are ordered to yield \na more precise result ahead of the less precise ones. We can easily deal with the invocation of super \nmethods. This feature can be used in place of the receiver this parameter to refer to the overridden \nmethod. It can be easily handled by our approach since super method calls are essentially static calls \nthat can be precisely captured by static speci.cations. Consider an overridden method mn in a superclass \nA and a call super.mn(..) being used in an overriding method in subclass B. We can handle this super \ncall by re-writing it to this.A.mn(..). In this case, our veri.cation process will select the static \nspeci.cation of the overridden method in class A to use. Past works, such as Parkinson and Bierman (2005); \nKiniry et al. (2005), do not handle super method calls for veri.cation well, as there is an inherent \nmismatch between super method calls (which are static calls) and the mechanism based on dynamic speci.cations. \n  6. Correctness There are several soundness results that are needed to show the overall safety of \nour veri.cation system. The semantics of our constraints is that of separation logic (Reynolds 2002), \nwith extensions to handle our shape views. To de.ne the semantic model we assume sets Loc of locations \n(pos\u00aditive integer values), Val of primitive values, with 0 . Val de\u00adnoting null, Var of variables (program \nvariables and other meta variables), and ObjVal of object values stored in the heap, with c[f1..1, .., \nfn ..n ] denoting an object value of data type c where .1, .., .n are current values (from the domain \nVal .Loc)ofthe cor\u00adresponding .elds f1, .., fn . This object denotation shall be abbre\u00adviated as c(.1, \n.., .n ).Let s, h |=F denote that stack s and heap h form a model of the constraint F, with h, s from \nthe following concrete domains: h . Heaps = df Loc -.n ObjVal s . Stacks = df Var . Val .Loc As we \nuse a .rst-order language, lexical scoping can be easily enforced by only allowing elements from the \ntopmost stack frame to be accessible at runtime. A complete de.nition of the model for separations constraints \ncan be found in Nguyen et al. (2007). We use a small-step dynamic semantics for our language (Fig. 3) \nbut extended with pass-by-reference parameters. For simplicity, we assume that all while loops have been \ntransformed to equivalent tail-recursive methods with the help of pass-by-reference parame\u00adters. The \nmachine con.guration is represented by (s, h, e)where s denotes the current stack, h denotes the current \nheap, and e denotes the current program code. The semantics assumes unlimited stack and heap spaces. \nEach reduction step can then be formalized as a small-step transition of the form: (s, h, e)'.(s1,h1,e1).The \nfull set of transitions is given in Fig. 4. We have introduced an inter\u00admediate construct ret(v * ,e), \nwith e to denote the residual code of its call, to model the outcome of call invocation. It is also used \nto handle local blocks. The following lemma highlights a key result showing that our use of speci.cation \nsubsumption relation is sound for avoiding re\u00adveri.cation, as follows: LEMMA 6.1 (Soundness of Enhanced \nSpec. Subsumption). Given that method body e has been successfully veri.ed us\u00ading preB *.postB. If speci.cation \nsubsumption preB *.postB <: preA *.postA holds, then its speci.cation supertype preA *.postA is guaranteed \nto verify successfully against the same method body. Proof: From the premise of speci.cation subsumption \n(Defn 2.5), we can obtain: preAfpreB *. and postB*.fpostA. In our context, preconditions preA, preB and \ntheir entailment s residual . do not contain any primed variables, while only primed variables are mod\u00adi.ed \nindirectly by our program. Hence, adding a formula with only unprimed variables, such as ., to both pre/post \nalways satis.es the side condition of the frame rule. Let e denote the method body which has been preprocessed \nto a form where pass-by-value pa\u00adrameters are never modi.ed. Let {v1 , .., vn }denote the set of free \n. n variables in e,and let N= i=1 (vi ' =vi ). From the premise that preB *.postB is a veri.ed speci.cation \nfor the code, we have f{preB.N}e {postB}. In order to show that its speci.cation su\u00adpertype preA *.postA \nis also veri.able for the same code, we need to derive f{preA.N}e {postA}. We conclude based on the follow\u00ading \nsteps: f{preB.N}e {postB} premise f{preB.N*.}e {postB*.} frame rule f{preA.N}e {postB*.} precondition \nstrengthening f{preA.N}e {postA} postcondition weakening D The above proof uses the following Consequence \nLemma stat\u00ading the soundness of precondition strengthening and postcondition weakening: LEMMA 6.2 (Consequence \nRule). The following veri.cation holds: P ' fP f{P }e {Q} QfQ ' f{P ' }e {Q ' } (s, h, v)'.(s, h, s(v))(s, \nh, k)'.(s, h, k)(s, h, v.f)'.(s, h, h(s(v))(f))(s, h, v:=k)'.(s[v.k],h, ()) (s, h, (); e)'.(s, h, e)(s, \nh, {tv; e})'.([v. ]+s, h, ret(v, e))(s, h, ret(v * ,k))'.(s-{v * },h, k) (s, h, e1)'.(s1,h1,e3) s(v)=true \ns(v)=false (s, h, e1; e2)'.(s1,h1,e3; e2)(s, h, if v then e1 else e2)'.(s, h, e1)(s, h, if v then e1 \nelse e2)'.(s, h, e2) (s, h, e)'.(s1,h1,e1)(s, h, e)'.(s1,h1,e1) r = h(s(v1))[f.s(v2)] h1 = h[s(v1).r] \n(s, h, v:=e)'.(s1,h1,v:=e1)(s, h, ret(v * ,e))'.(s1,h1, ret(v * ,e1))(s, h, v1.f := v2)'.(s, h1, ()) \n.elds(c)=[t1 f1, .., tn fn ] ./.dom(h) s1=[wi .s(vi )]ni =m +sh(s(v0)) = c[...] r=c[f1.s(v1), .., fn \n.s(vn )] t0 mn((ref ti , (ti wi )n ) {e}. meth(c) wi )m -1 i =1 i =m (s, h, new c(v1,,vn ))'.(s, h+[. \n. r],.)(s, h, v0.mn(v1, .., vn ))'.(s1,h, ret({wi }n , [vi /wi ]m -1 e)) i =mi =1 wi )m -1 s1=[wi .s(vi \n)]n +st0 mn((ref ti , (ti wi )n ) {e}. meth(c) i =mi =1 i =m (s, h, v0.c.mn(v1, .., vn ))'.(s1,h, ret({wi \n}n , [vi /wi ]m -1 e)) i =mi =1 Figure 4. Dynamic Semantics Proof Sketch: Based on the premise, we have \na set of s,hsuch that (s, h, e)'. * (s1,h1,v) and s,h|= P . s1+[res. v],h1 |= Post(Q). By Galois connection, \nwe have s1+[res. v],h1 |= Post(Q ' ). Thus, for all s,h|= P ',we have f{P ' } e {Q ' }. 0 We extract \nthe post-state of a heap constraint by: DEFINITION 6.1 (Poststate). Given a constraint ., Post(.) cap\u00adtures \nthe relation between primed variables of .. That is : Post(.) = df . (.V\u00b7.), where V = {v1, .., vn } \ndenotes all unprimed program variables in . . =[v1' .v1, .., v n ' .vn ] The next two lemmas state some \nresults on statically-inherited methods for which re-veri.cation is proven not to be needed. LEMMA 6.3 \n(Equivalence of Statically-Inherited Methods). Consider a method mn from class A that satis.es the conditions \nof being statically-inherited into a B subclass. Assuming that (s, h1, o.mn(p * ))'. * (s1,h3,v)h1=h+[s(o).A(v1..vn \n)] h3=h ' +[s(o).A(w1..wn )] . then .(s, h2, o.mn(p * ))'. * (s1,h4,v)h2=h+[s(o).B(v1..vn ,vn +1..vm \n)] h4=h ' +[s(o).B(w1..wn ,vn +1..vm )] Proof Sketch : Using the conditions of Defn 3.2, we can prove \nthe above by an induction on the dynamic semantics (see Fig. 4) over execution of the body of statically-inherited \nmethods. 0 LEMMA 6.4 (Soundness of Statically-Inherited Speci.cations). Consider a method mn from class \nA that has been successfully veri.ed against its static speci.cation preSA *. postSA , and a subclass \nB that statically-inherits mn with static speci.cation preSB *. postSB . Assuming that a speci.cation \nsubsumption re\u00adlation of the form preSA *. postSA <: preSB *. postSB holds, then B.mn is guaranteed to \nverify successfully against its speci.cation preSB *. postSB . Proof Sketch : Follows from Lemmas 6.3 \nand 6.1. 0 We shall now show a result regarding behavioral subtyping. LEMMA 6.5 (Soundness of Behavioral \nSubtyping). Consider a method mn from class A with dynamic speci.cation preDA *. postDA and that s, h1 \n|= preDA .h1=h+[s(o).A(v * )] (s, h1, o.mn(p * ))'. * (s3,h3,v)s3 +[res.v],h3 |= Post(postDA ) If we \nassume a similar object from a subclass B such that . s, h2 |= preDA h2=h+[s(o).B(v * ,w * )] and we \ncall the overriding method, then we obtain : .* (s, h2, o.mn(p ))'. * (s4,h4,v)s4 +[res.v],h4 |= Post(postDA \n) Proof Sketch : Follows from Defn 3.1 of the behavioral subtyping requirement and Lemma 6.1. 0 Lastly, \nwe prove the soundness of our veri.cation system using preservation and progress lemmas. LEMMA 6.6 (Preservation). \nIf f{.} e {.2} s, h |= Post(.) (s, h, e)'.(s1,h1,e1) Then there exists .1 such that s1,h1 |= Post(.1) \nand f{ .1} e1 { .2} . Proof Sketch: By induction on e. 0 LEMMA 6.7 (Progress). If f{ .} e{ .1} , and \ns,h|= Post(.),then either eis a value, or there exist s1,h1, and e1, such that (s, h, e)'.(s1,h1,e1). \n Proof Sketch: By induction on e. 0 THEOREM 6.8 (Soundness of Veri.cation). Consider a closed term e \nwithout free variables in which all methods have been successfully veri.ed. Assuming that f{ true} e{ \n.} , then either ([], [],e)'. * ([],h, v) terminates with a value v such that the fol\u00adlowing ([res. v],h) \n|=. holds, or it diverges ([], [],e) '. . * Proof Sketch: Follows from Lemma 6.6 and Lemma 6.7. 0  \n7. Related Work In support of modular reasoning on properties of object-oriented programs, the notion \nof behavioral subtyping has been inten\u00adsively studied in the last two decades, e.g. Liskov (1988); Amer\u00adica \n(1991); Liskov and Wing (1994); Dhara and Leavens (1996); Meyer (1997); Findler et al. (2001); Muller \n(2002); Parkinson (2005). The notion of speci.cation inheritance, where an overrid\u00ading method inherits \nthe speci.cations of all the overridden meth\u00adods, was .rst introduced in Eiffel (Meyer 1997). As an effort \nto relate these two notions, Dhara and Leavens (1996) presented a modular speci.cation technique which \nautomatically forces behav\u00adioral subtyping through speci.cation inheritance. More recently, Leavens and \nNaumann (2006) proposed a formal characterization for behavioral subtyping and modular reasoning. The \nbasic idea of modular reasoning, which the authors call supertype abstraction, is that reasoning about \nan invocation, say E.m(), is based on the spec\u00adi.cation associated with the static type of the receiver \nexpression E. In Leavens and Naumann (2006), the authors proved the equiva\u00adlence between supertype abstraction \nand behavioral subtyping. The new formalization is supposed to serve as a semantic foundation for object-oriented \nspeci.cation languages. Various embodiments of these proposals have been imple\u00admented in both static \nand runtime veri.cation tools and been ap\u00adplied to rich speci.cation and programming languages such as \nESC/Java (Flanagan et al. 2002), JML (Leavens et al. 2006), Spec# (Barnett et al. 2004), and ESpec (Ostroff \net al. 2006). The Krakatoa tool (March\u00b4e et al. 2004; March\u00b4e and Paulin-Mohring 2005) trans\u00adlates JML \nspeci.cations into the input language for the Why ver\u00adi.cation tool (Filli atre 2003). Veri.cation conditions \ngenerated by the Why tool can then be discharged by different theorem provers. However, to the best of \nour knowledge, neither inheritance nor method overriding is supported by their system. Software model \nchecking frameworks (Robby et al. 2003; Hatcliff et al. 2003) have also been used in the veri.cation \nof OO programs. Inference mech\u00adanisms for loop invariants have been proposed in Nimmer and Ernst (2002); \nPasareanu and Visser (2004) amongst others, and they can make veri.cation even easier to use. However, \nmost of these works are based primarily on the idea of dynamic speci.cations. Even when static speci.cations \nare added, like code contracts in JML (Leavens et al. 2007, ch 15), they did not enforce an important \nsubtyping relation between a static speci.cation and its dynamic counterpart. Moreover, in comparison \nwith our approach, Spec# is more restrictive in handling overriding as it does not allow any changes \nin the precondition of the overriding method. Using the rules of behavioral subtyping, Findler et al. \nhave for\u00admalized hierarchy violations and blame assignment for pre and postcondition failures (Findler \nand Felleisen 2001; Findler et al. 2001). They identi.ed a problem (related to preservation of class \ninvariants) that arises from synthesizing the speci.cations of over\u00adriding methods through speci.cation \ninheritance. This problem is caused by speci.cation inheritance s manner of enforcing behav\u00adioral subtyping \nwhich may wrongly assume that the original spec\u00adi.cation of an overriding method is too weak. In our \nproposal, we can avoid this problem by using speci.cation abstraction instead of speci.cation inheritance, \nif class invariants are to be preserved for the overriding methods. Furthermore, while Findler and Felleisen \n(2001) and Findler et al. (2001) focus on checking the correctness of contracts at run-time, we propose \na static veri.cation system. The problem of writing speci.cations for programs that use var\u00adious forms \nof modularity where the internal resources of a module should not be accessed by the module s clients, \nis tackled in several papers (O Hearn et al. 2004; Parkinson and Bierman 2005; Leavens and Muller 2007). \nIn O Hearn et al. (2004) the internal resources of a module are hidden from its clients using a so called \nhypo\u00adthetical frame rule, whereas in Parkinson and Bierman (2005) the notion of abstract predicates is \nintroduced. While O Hearn et al. (2004) only supports single instances of the hidden data structure, \nabstract predicates can deal with dynamic instantiation of a mod\u00adule. To support the reasoning of concurrent \nprograms, a rule similar to the hypothetical frame rule is used in O Hearn (2007) to model critical regions \nwith resource invariants. For soundness reason, pre\u00adcise resource invariants were also required in O \nHearn et al. (2004) and O Hearn (2007) due to the desire to support both the conjunc\u00adtion rule and the \nhypothetical frame rule. As both rules are not used in our current system, we do not suffer from this \nproblem and can safely support less precise heap states and multiple speci.cations. Visibility modi.ers \nare taken into consideration in Leavens and Muller (2007) where a set of rules for information hiding \nin spec\u00adi.cations for Java-like languages is given. Moreover, the authors demonstrate their application \non the speci.cation language JML. However, some JML tools, including ESC/Java2 (Flanagan et al. 2002; \nCok and Kiniry 2004) ignore visibility modi.ers in speci.\u00adcations. The emergence of separation logic \n(Isthiaq and O Hearn 2001; Reynolds 2002) provides a novel way to handle the challenging aliasing issues \nfor heap-manipulating programs. Parkinson and Bierman (2005) and Parkinson (2005) recently extended separation \nlogic to handle OO programs. They advocated the use of abstract predicate families indexed by types to \nreason about objects from a class hierarchy. Their approach supports full object views and essentially \ndynamic speci.cations, though for one class at a time. They also require every inherited method to be \nre-speci.ed and mostly re-veri.ed for OO conformance. Furthermore, no imple\u00admentation exists. In comparison, \nwe have designed a more compre\u00adhensive system with static speci.cations, partial views and modu\u00adlar mechanisms \nto minimise on re-veri.cation and to handle super method calls. These issues were informally referred \nto as untamed open problems in Sec 6.5 of Parkinson (2005). 8. Conclusion We have presented an enhanced \napproach to OO veri.cation based on the co-existence of both static and dynamic speci.cations, to\u00adgether \nwith a principle that each static speci.cation be a subtype of its corresponding dynamic speci.cation. \nOur approach attempts to track the actual type of each object, where possible, to allow static speci.cations \nto be preferably used. We have built our work on the formalism of separation logic, and have designed \na new object for\u00admat that allows each object to assume the form of its superclass via lossless casting. \nAnother useful feature of our proposal is a new speci.cation subsumption relation for pre/post speci.cations \nthat is novel in using the residual heap state from precondition checking to assist in postcondition \nchecking. We have constructed a prototype system for verifying OO programs. Our prototype is built using \nObjective CAML aug\u00admented with an automatic Presburger solver, called Omega (Pugh 1992). While Presburger \narithmetic is limited to integer con\u00adstraints, we have also provided hooks in our system to invoke Is\u00adabelle \nand MONA provers. These extensions allow us to support sets/bags/lists constraints, where required. The \nmain objective for building this prototype is to show the feasibility of our approach to enhanced OO \nveri.cation based on a synergistic combination of static and dynamic speci.cations. As an initial study, \nwe have successfully veri.ed a set of small benchmark programs. The ver\u00adi.cation process consists of \ntwo parts: veri.cation of the given static speci.cations against the bodies of the corresponding meth\u00adods \n(VS) and the speci.cation subtyping checking meant to avoid re-veri.cation of all dynamic speci.cations \nand some static speci.\u00adcations of statically-inherited methods (SSC). What we are mainly interested in \nis the ratio between the VS timing and the SSC tim\u00ading. As subsumption checking on speci.cation is typically \ncheaper than verifying a piece of program code against its speci.cation, we expect that VS will dominate \nthe total veri.cation time. This assumption is indeed validated by the examples we tried. For in\u00adstance, \nin the counter example presented in the paper, the time taken by the SSC (with 16 checks) is 0.06 seconds, \nwhile VS (with 11 veri.es) takes 0.18 seconds. For examples with larger code bases, we expect the ratio \nbetween the VS and SSC to increase. One fundamental question that may arise is whether static spec\u00adi.cations \nare really necessary? Some readers may contend that it is possible to incorporate the effect of static \nspeci.cation by adding type(this)=c into the precondition of a dynamic pre/post anno\u00adtation. As discussed \nin our paper, this approach is only a partial solution to static speci.cation as (i) it does not cater \nto statically\u00adinherited methods which support reuse of static speci.cations, (ii) it does not handle \nsuper method calls which are really static method invocations, and (iii) it does not help enforce class \ninvariants in subclasses when dynamic speci.cations of a superclass (without the class invariant property) \nare being inherited. By making each static speci.cation be a subtype of its dynamic speci.cation, we \ncan limit code veri.cation to only static speci.cations. The under\u00adlying philosophy of static speci.cation \nis better served by partial view and lossless casting. Perhaps, the ultimate goal for OO ver\u00adi.cation \nis to use completely static speci.cations with dynamic speci.cations derived on demand! Our solution \ncan be viewed as a signi.cant step towards this utopia. Post-Submission Note : Independent of our work, \nParkinson and Bierman (2008) proposed in the same proceedings a similar dis\u00adtinction and relation between \nstatic and dynamic speci.cations, in support of modular veri.cation and the handling of direct method \ncalls. Like us, they can support inheritance and overriding, while avoiding unnecessary re-veri.cations. \nHowever, there are at least two differences. Firstly, they continue to rely on the rather power\u00adful concept \nof abstract predicate families, while we have avoided its use in our work. Secondly, we have a marginal \nemphasis on static speci.cations over dynamic speci.cations, as we advocate for the latter to be derived \nfrom the former, when needed, using the re.ne\u00adment techniques of speci.cation specialization and abstraction. \nAcknowledgments : Cristian Gherghina implemented a prototype system for OO veri.cation. Florin Craciun, \nHugh Anderson, Martin Rinard, Peter O Hearn and anonymous reviewers provided insight\u00adful feedbacks on \nvarious aspects of this work. Matthew Parkinson and Gavin Bierman conducted helpful last minute discussions \nwith us. This work is supported by an A*STAR-funded research project R-252-000-233-305 on A Constructive \nFramework for Depend\u00adable Software . Shengchao Qin is supported in part by the EPSRC project EP/E021948/1. \n  References P. America. Designing an object-oriented programming language with behavioural subtyping. \nIn the REX School/Worshop on Foundations of Object-Oriented Languages, pages 60 90, 1991. M Barnet, R. \nDeLine, M. Fahndrich, K.R.M Leino, and W. Schulte. Veri\u00ad .cation of object-oriented programs with invariants. \nJournal of Object Technology, 3(6):27 56, 2004. M. Barnett, K. R. M. Leino, and W. Schulte. The Spec# \nprogramming system: An overview. In Workshop on Construction and Analysis of Safe, Secure, and Interoperable \nSmart Devices, 2004. D. R. Cok and J. Kiniry. ESC/Java2: Uniting ESC/Java and JML. In Int l Workshop \non Construction and Analysis of Safe, Secure, and Interoper\u00adable Smart Devices, pages 108 128, 2004. \nK. K. Dhara and G. T. Leavens. Forcing behavioral subtyping through spec\u00adi.cation inheritance. In IEEE/ACM \nIntl. Conf. on Software Engineering, pages 258 267, 1996. J. C. Filli atre. Why: a multi-language multi-prover \nveri.cation tool. Tech\u00adnical Report 1366, LRI, Universit\u00b4e Paris Sud, March 2003. R. B. Findler and M. \nFelleisen. Contract soundness for object-oriented languages. In SIGPLAN Object-Oriented Programming Systems, \nLan\u00adguages and Applications, pages 1 15, 2001. R. B. Findler, M. Latendresse, and M. Felleisen. Behavioral \ncontracts and behavioral subtyping. In ESEC/SIGSOFT Foundations of Software Engr., 2001. C. Flanagan, \nK. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. Extended Static Checking for Java. \nIn ACM PLDI, June 2002. J. Hatcliff, X. Deng, M. B. Dwyer, G. Jung, and V. P. Ranganath. Cadena: An integrated \ndevelopment, analysis, and veri.cation environment for component-based systems. In IEEE/ACM Intl. Conf. \non Software Engi\u00adneering, 2003. S. Isthiaq and P.W. O Hearn. BI as an assertion language for mutable \ndata structures. In ACM POPL, London, January 2001. J. Kiniry, E. Poll, and D. Cok. Design by contract \nand automatic veri.cation for Java with JML and ESC/Java2. ETAPS tutorial, 2005. G. T. Leavens and Peter \nMuller. Information hiding and visibility in inter\u00adface speci.cations. In IEEE/ACM Intl. Conf. on Software \nEngineering, pages 385 395, Washington, DC, USA, 2007. IEEE Computer Society. G. T. Leavens and David \nA. Naumann. Behavioral subtyping is equivalent to modular reasoning for object-oriented programs. Technical \nReport 06-36, Department of Computer Science, Iowa State University, 2006. G. T. Leavens, A.L. Baker, \nand C. Ruby. Preliminary design of JML: A behavioral interface speci.cation language for Java. ACM SIGSOFT \nSoftware Engineering Notes, 31(3):1 38, 2006. G. T. Leavens, E. Poll, C. Clifton, Y. Cheon, C. Ruby, \nD. Cok, P. Mller, and J. Kiniry. JML Reference Manual (DRAFT), February 2007. K. R. M. Leino and P. \nM\u00a8uller. Object invariants in dynamic contexts. In ECOOP, pages 491 516, 2004. B. H. Liskov. Data abstraction \nand hierarchy. ACM SIGPLAN Notices,23 (5):17 34, May 1988. Revised version of the keynote address given \nat OOPSLA 87. B. H. Liskov and J. M. Wing. A behavioral notion of subtyping. ACM Trans. on Programming \nLanguages and Systems, 16(6):1811 1841, 1994. C. March\u00b4e and C. Paulin-Mohring. Reasoning about Java \nprograms with aliasing and frame conditions. In 18th Int l Conf. on Theorem Proving in Higher Order Logics. \nSpringer, LNCS, August 2005. C. March\u00b4e, C. Paulin-Mohring, and X. Urbain. The KRAKATOA tool for certi.cation \nof JAVA/JAVACARD programs annotated in JML. Journal of Logic and Algebraic Programming, 58(1 2):89 106, \n2004. B. Meyer. Object-oriented Software Construction. Prentice Hall. Second Edition., 1997. R. Middelkoop, \nC. Huizing, R. Kuiper, and E. J. Luit. Invariants for non\u00adhierarchical object structures. In L. Ribeiro \nand A. Martins Moreira, editors, Proceedings of the 9th Brazilian Symposium on Formal Methods (SBMF 06), \nNatal, Brazil, 2006. P. Muller. Modular speci.cation and veri.cation of object-oriented pro\u00adgrams. Springer, \nNew York, NY, USA, 2002. ISBN 3-540-43167-5. H. H. Nguyen, C. David, S.C. Qin, and W.N. Chin. Automated \nVeri.cation of Shape And Size Properties via Separation Logic. In Intl Conf. on Veri.cation, Model Checking \nand Abstract Interpretation, Nice, France, January 2007. J. W. Nimmer and M. D. Ernst. Invariant inference \nfor static checking. In ESEC/SIGSOFT Foundations of Software Engr., pages 11 20, 2002. P. W. O Hearn. \nResources, concurrency, and local reasoning. Theor. Comput. Sci., 375(1-3):271 307, 2007. P. W. O Hearn, \nH. Yang, and J. C. Reynolds. Separation and Information Hiding. In ACM POPL, Venice, Italy, January 2004. \nJ. Ostroff, C. Wang, E. Kerfoot, and F. A. Torshizi. Automated model-based veri.cation of object-oriented \ncode. Technical Report CS-2006-05, York University, Canada, May 2006. M. J. Parkinson. Local Reasoning \nfor Java. PhD thesis, Computer Labora\u00adtory, University of Cambridge, 2005. UCAM-CL-TR-654. M. J. Parkinson \nand G. M. Bierman. Separation logic and abstraction. In ACM POPL, pages 247 258, 2005. M. J. Parkinson \nand G. M. Bierman. Separation logic, abstraction and inheritance. In ACM POPL, 2008. C. Pasareanu and \nW. Visser. Veri.cation of Java programs using symbolic execution and invariant generation. In SPIN Workshop, \nApril 2004. W. Pugh. The Omega Test: A fast practical integer programming algorithm for dependence analysis. \nCommunications of the ACM, 8:102 114, 1992. J. Reynolds. Separation Logic: A Logic for Shared Mutable \nData Struc\u00adtures. In IEEE Logic in Computer Science, Copenhagen, Denmark, July 2002. Robby, M. B. Dwyer, \nand J. Hatcliff. Bogor: an extensible and highly\u00admodular software model checking framework. In ESEC/SIGSOFT \nFoun\u00addations of Software Engr., pages 267 276, 2003. \n\t\t\t", "proc_id": "1328438", "abstract": "<p>Conventional specifications for object-oriented (OO) programs must adhere to behavioral subtyping in support of class inheritance and method overriding. However, this requirement inherently weakens the specifications of overridden methods in superclasses, leading to imprecision during program reasoning. To address this, we advocate a fresh approach to OO verification that focuses on the distinction and relation between specifications that cater to calls with static dispatching from those for calls with dynamic dispatching. We formulate a novel specification subsumption that can avoid code re-verification, where possible. Using a predicate mechanism, we propose a flexible scheme for supporting class invariant and lossless casting. Our aim is to lay the foundation for a practical verification system that is precise, concise and modular for sequential OO programs. We exploit the separation logic formalism to achieve this.</p>", "authors": [{"name": "Wei-Ngan Chin", "author_profile_id": "81100655104", "affiliation": "National University of Singapore, Singapore, Singapore", "person_id": "PP14224449", "email_address": "", "orcid_id": ""}, {"name": "Cristina David", "author_profile_id": "81332495281", "affiliation": "National University of Singapore, Singapore, Singapore", "person_id": "P886590", "email_address": "", "orcid_id": ""}, {"name": "Huu Hai Nguyen", "author_profile_id": "81339519285", "affiliation": "Singapore-MIT Alliance, Singapore, Singapore", "person_id": "PP43136281", "email_address": "", "orcid_id": ""}, {"name": "Shengchao Qin", "author_profile_id": "81314485027", "affiliation": "Durham University, Durham, United Kingdom", "person_id": "P493728", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328452", "year": "2008", "article_id": "1328452", "conference": "POPL", "title": "Enhancing modular OO verification with separation logic", "url": "http://dl.acm.org/citation.cfm?id=1328452"}