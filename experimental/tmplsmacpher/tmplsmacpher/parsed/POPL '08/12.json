{"article_publication_date": "01-07-2008", "fulltext": "\n Proving Non-Termination Ashutosh K. Gupta Thomas A. Henzinger Rupak Majumdar MPI-SWS EPFL UC Los Angeles \nagupta@mpi-sws.mpg.de tah@ep..ch rupak@cs.ucla.edu Andrey Rybalchenko Ru-Gang Xu MPI-SWS UC Los Angeles \nrybal@mpi-sws.mpg.de rxu@cs.ucla.edu Abstract The search for proof and the search for counterexamples \n(bugs) are complementary activities that need to be pursued concurrently in order to maximize the practical \nsuccess rate of veri.cation tools. While this is well-understood in safety veri.cation, the current focus \nof liveness veri.cation has been almost exclusively on the search for termination proofs. A counterexample \nto termination is an in.nite program execution. In this paper, we propose a method to search for such \ncounterexamples. The search proceeds in two phases. We .rst dynamically enumerate lasso-shaped candidate \npaths for counterexamples, and then statically prove their feasibil\u00adity. We illustrate the utility of \nour nontermination prover, called TNT, on several nontrivial examples, some of which require bit\u00adlevel \nreasoning about integer representations. Categories and Subject Descriptors D.2.4 [Software]: Software \nEngineering Program Veri.cation; D.2.5 [Software]: Software Engineering Testing and Debugging General \nTerms Reliability, Veri.cation Keywords Program veri.cation, Model checking, Testing, Non\u00adtermination, \nRecurrent Sets 1. Introduction It has become fairly undisputed that the main value of veri.cation tools \nlies in the discovery of bugs, not in the proof of program cor\u00adrectness (Godefroid 2005). Evidence of \na bug presented to a pro\u00adgrammer is often a more convincing demonstration of the utility of a tool than \na proof of correctness, which even in the best case is relative to certain semantic assumptions that \nmay not hold, and relative to partial speci.cations. Moreover, during software devel\u00adopment, a tool can \nrepeatedly demonstrate its utility by reporting bugs even on incomplete programs, while a proof can be \nprovided only at the end (if at all). Thus, it is important that both the preci\u00adsion and ef.ciency of \nveri.cation tools be geared towards .nding bugs, not proofs. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 08, January 7 12, 2008, San Francisco, \nCalifornia, USA. Copyright c . 2008 ACM 978-1-59593-689-9/08/0001. . . $5.00 Consequently, in safety \nveri.cation there has been much focus on checking whether a counterexample is spurious or genuine, and \non classifying which counterexamples are most likely to be real bugs (Kremenek and Engler 2003). A counterexample \nto a safety property is a .nite program execution that leads to an error. The discovery and feasibility \nanalysis of such executions lies at the heart of many recent tools (Ball and Rajamani 2002; Henzinger \net al. 2002; Godefroid et al. 2005; Gulavani et al. 2006). In contrast, in liveness veri.cation the main \nfocus to date has been on .nding proofs, i.e., evidence of program termina\u00adtion (Col\u00b4on and Sipma 2002; \nBradley et al. 2005; Cousot 2005; Cook et al. 2006). A liveness violation is a non-terminating pro\u00adgram \nexecution. Unfortunately, since techniques to prove termina\u00adtion are incomplete, failure to prove termination \ndoes not immedi\u00adately indicate the existence of a non-terminating execution. There\u00adfore, a failed termination \nproof produces a possible counterexam\u00adple, which may or may not be genuine. Currently, these counterex\u00adamples \nmust be inspected manually to determine if they are indeed bugs. This is unsatisfactory: experience with \nstatic program analy\u00adsis (for safety properties) indicates that a major obstacle to the prac\u00adticality \nof static analysis tools is the presence of false positives warnings that do not correspond to real errors. \nFurthermore, classi\u00adcal objects of study in temporal veri.cation are auxiliary assertions that are geared \ntowards proving temporal properties, e.g., invari\u00adants and ranking functions. Auxiliary assertions that \ndemonstrate the existence of speci.c executions have not received adequate at\u00adtention. Therefore, dual \nto the search for termination proofs, we must also develop tools that demonstrate feasible non-terminating \nexecutions. We present a method that searches precisely and ef.ciently for non-terminating program executions. \nIn particular, our algorithm looks for feasible lassos. A lasso consists of a .nite program path called \nstem that is followed by a .nite program path called loop. The loop must form a syntactic cycle in the \ncontrol-.ow or call graph of the program The lasso is feasible if an execution of the stem can be followed \nby in.nitely many executions of the loop. In general, the method is incomplete, as not all non-terminating \nprogram executions are induced by lassos (the in.nite behavior may be non-periodic). However, by limiting \nour attention to lassos, we can concentrate on .nding the most common non-termination bugs quickly. Our \nalgorithm proceeds in two phases. The .rst phase generates candidate lassos, and the second checks each \nlasso for possible non\u00adtermination. Our tool generates candidate lassos exhaustively by systemati\u00adcally \nexecuting all paths of the concrete program until some control location is re-visited. Backtracking is \ncontrolled by collecting sym\u00adbolic constraints during concrete program execution. This method has two \nadvantages. First, the stem followed by one execution of the loop is guaranteed to be feasible. Second, \nevery such lasso is guar\u00adanteed to be generated. Alternatively, a termination prover could be used to \nsupply a candidate lasso whenever its termination proof fails. The second phase proves the feasibility \nof a given lasso. A lasso is feasible if and only if there exists a recurrent set of states, i.e., a \nset of states that is visited in.nitely often along the in.nite path that results from unrolling the \nlasso. We formulate and solve the existence of a recurrent set as a template-based constraint satisfac\u00adtion \nproblem. The constraint satisfaction problem for recurrent sets turns out to be equivalent to constraint \nsystems for invariant gener\u00adation (Col\u00b4on et al. 2003; Sankaranarayanan et al. 2004). Therefore, techniques \nfor constraint-based invariant generation apply directly to the problem of checking non-termination. \nThe precision of our analysis can be adjusted by choosing an appropriate constraint the\u00adory. We can either \napply a more precise bit-level analysis that takes into account many of the machine-dependent characteristics \nof pro\u00adgrams such as over.ow, or a less precise integer-level (arithmetic) analysis that is geared towards \nmore algorithmic reasons for non\u00adtermination. We have implemented a tool to test for non-termination \nof C programs, called TNT. The lasso-generation algorithm in TNT is based on dynamic execution of the \nprogram, with symbolic con\u00adstraints gathered on the side for the systematic exploration of the state \nspace (Godefroid et al. 2005; Sen et al. 2005). The feasibility check of a lasso is symbolic, and can \nutilize precise information about data structures and address resolution along the lasso pro\u00advided by \nthe dynamic exploration. While dynamic exploration has its own drawbacks (path explosion), we believe \nthat the interaction of ef.cient dynamic and static analysis in TNT provides an inter\u00adesting design point \nin the search for liveness bugs. We provide several examples where our tool succeeds to prove non-termination. \nThe bit-level analysis can prove the non\u00adtermination of a standard implementation of binary search that \nis caused by arithmetic over.ows. The integer-constraint analysis shows a non-terminating path in an \nimplementation of the Mondri\u00adaan memory-protection scheme (Witchel et al. 2002). Dynamic ex\u00adploration \nof the program state space was especially helpful to .nd the non-termination bug in Mondriaan, as the \nnon-terminating ex\u00adecution required precise, bit-accurate reasoning about a three-level permissions table \ndata structure. Our non-termination checker can also be used whenever at runtime a program does not terminate \nwithin a given time bound. The non-termination checker can capture the state and the current execution \npath and try to prove online if the current execution is doomed to run forever. Therefore, a non-termination \nchecker is the liveness analogue to runtime monitors for safety (Sen et al. 2004; d Amorim and Rosu 2005; \nPnueli et al. 2006). A similar non-termination analysis has been independently de\u00adveloped by Velroyen \n(2007). 2. Example Non-Terminating Binary Search. Joshua Bloch recently pointed out that many existing \nimplementations of binary search can pro\u00adduce ArrayOutOfBounds exceptions because they ignore arith\u00admetic \nover.ows (Bloch 2006). For example, the version that used to be in Java s standard library is affected \nby this bug. Speci.cally, the statement mid = (lo + hi)/2; 1: int bsearch(int a[], int k, unsigned int \nlo, unsigned int hi) { 2: unsigned int mid; 3: while (lo < hi) { 4: mid = (lo + hi)/2; 5: if (a[mid] \n< k) { 6: lo=mid+1; 7: } else if (a[mid] > k) { 8: hi=mid-1; 9: }else{ 10: return mid; 11: } 12: } 13: \nreturn -1; 14: } Figure 1. Broken binary search implementation. that computes the midpoint of the range \ncan over.ow for large values of lo and hi, thus, producing a negative value that is used as an array \nindex. The version of binary search shown in Figure 1 is similar to the original, except that we have \nreplaced the signed integers of the original version with unsigned integers. (This is similar to the \nsignature of binary search in C s stdlib, which uses the unsigned type size t for the indices.) This \ntime, while the array index will remain within bounds, the arithmetic over.ow can lead to an in.nite \nloop. We illustrate the non-termination by considering an execution of a path through the while loop \nthat follows the .rst branch of the conditional statement visiting lines 2 6. The corresponding sequence \nof statements consists of {lo<hi}; mid=(lo+hi)/2; {a[mid]<k}; lo=mid+1; Here, we used curly braces {} \nto represent the evaluation of conditional expressions. We choose the following initial values lo =1, \nhi =MAXINT, a[0] < k, where MAXINT is the maximum value of an unsigned integer. The .rst statement on \nthe path, which evaluates the loop condition, returns true for the chosen inputs. Then, we update the \nvalue for the variable mid. Due to arithmetic over.ow, we obtain mid =0. Thus, we come back to the head \nof the loop with lo =1and hi =MAXINT, which is our starting program state. Thus, if an adversary can \nchoose the input values to the program, then she can force the program to enter an in.nite loop. We observe \nthat a suf.cient condition for such non-terminating loops is the existence of a lasso-shaped execution. \nA lasso-shaped execution is a program execution that reaches the head of the loop (the conditional lo \n< hi on line 3) with some state s, then executes the body of the loop (lines 4 11), and returns to the \nloop head with the same state s. We check the equality between states only for the live variables, i.e., \nthe variables whose values will be read in the future. In this case, we can unroll the execution of the \nloop arbitrarily many times by starting at s, executing the loop, and returning to s. We refer to the \nsequence of program statements in the lasso-shaped execution as a lasso. We can search for such lassos \nby exploring the program symbol\u00adically. In symbolic execution, the program is executed on symbolic instead \nof, or in addition to, concrete inputs. During the execution, we gather constraints on symbolic inputs. \nAny satisfying assign\u00adment to the symbolic constraints is guaranteed to execute the pro\u00adgram along the \ncurrently executed path. Let X be the set of program variables. Then, for a .nite program path p, we \nwrite .p(X, X') to denote the symbolic constraint generated by symbolic execution when traversing p. \nIt relates the values X' of the program variables at the end of the path to their original values X. \nWe assume that symbolic execution completes a loop in the stem control-.ow graph of the program, say, \nalong the path e0 ---. loop e --. e.Let e0 be the entry point of the program, let e be the head of the \nloop, and let stem and loop be the .nite paths that are executed up to the loop and in the loop body, \nrespectively. To detect an in.nite loop, we can check for the existence of a satisfying assignment to \nthe query '' .stem (X0,X) . .loop(X, X) . (X = X). (1) While we write X = X' to enforce the search for \nthe same state, we only require equality of all live variables. For the program bsearch and the path \nthat takes the .rst branch of the conditional, the generated query is true . constraints up to line 3 \nlo < hi . mid =(lo + hi)/2 . a[mid] < k . lo' = mid +1 . constraints for the loop lo' = lo . hi' = hi. \nset live variables equal This query can be resolved by a decision procedure that treats variables and \narithmetic in a bit-accurate way (Cook et al. 2005; Ganesh and Dill 2007; Xie and Aiken 2005). A satisfying \nas\u00adsignment to the variables will provide an input that causes non\u00adtermination. Unbounded Ranges and \nRecurrent Sets. Unfortunately, model\u00ading the bit-accurate semantics leads to too many cases of non\u00adtermination, \nas a signi.cant portion of C code is written without considering over.ow or with implicit assumptions \nabout the size of integer inputs to the program. For example, under the bit-accurate semantics, the following \nloop does not terminate: n = input(); for (i = 0; i <= n; i++) body; An offending input is when n is \nMAXINT, the maximum repre\u00adsentable number in the machine. When i is incremented after it reaches n, the \nvalue rolls back to either 0 or MININT, depend\u00adingonwhether i is declared as unsigned or signed. Then, \nthe loop guard i<= n continues to hold. Such loops occur in library func\u00adtions that sort inputs. However, \nthere is always an implicit assump\u00adtion that the arrays we shall sort in practice are not that large \n(or the memory allocator will fail to allocate the array even before the sorting routine is called). \nThese non-terminating programs represent an important class of bugs, especially for denial-of-service \nrelated vulnerabilities, where an attacker can exploit the over.ow. Equally important, we also want to \n.nd non-terminating executions in the abstracted seman\u00adtics, where numbers are modeled as unbounded, \nmathematical in\u00adtegers. These non-terminating executions can point out algorithmic problems in the code. \nIn the abstracted semantics, the condition in Equation (1) is suf.cient for non-termination, but clearly \nnot necessary. The same state may not be reached in every iteration of the loop, but the exe\u00adcution can \nnevertheless be non-terminating. For example, consider the following loop: loop() { i = input(); y = \ninput(); if (y!= 0) while (i >=0) {i =i -y; } } The loop is non-terminating if the initial value of i \nis non-negative, and y is negative. In this case, every execution of the loop body produces a new state \nwhere the new value of i is the old value of i minus the value of y. Thus, there is no .nite unrolling \nof the loop body which satis.es the requirement from Equation (1). Instead, we generalize the test for \nnon-termination and look for a recurrent set. A recurrent set R is a set of states at the head of the \nloop that satis.es the following properties: 1. R entails the loop guard; 2. some reachable state s \nsatis.es R;and 3. for every state s satisfying R, some successor of s after execut\u00ading the loop body \nis again in R.  Clearly, if there is such an R, then we can .nd a non-terminating execution of the program. \nIn case of the loop statement in the function loop,the set i = 0 . y = 0 forms a recurrent set. The .rst \ntwo conditions are easily checked. For condition (3), we notice that '' . i, y . i, y. (i = 0 . y = 0) \n. ' ''' (i= i - y . y= y) . (i= 0 . y= 0). Thus, we can conclude that there is a non-terminating execution \nof the loop. We have reduced the search for non-terminating execu\u00adtions to the search for recurrent sets. \nReduction to Constraint Solving. We shall use a template-based approach for computing recurrent sets. \nThe approach reduces the search for recurrent sets to constraint solving over a suitable do\u00admain. We \nrestrict our attention to the important class of linear pro\u00adgrams, where the transition relation is a \nlinear function of the vari\u00adables (and their updated values). As example, consider the lasso\u00adshaped execution \nwhere the stem consists of the .rst two instruc\u00adtions and the lasso consists of the remaining three instructions: \ni=input(); y=input(); {y!=0}; {i>=0}; i=i-y; Let us assume that the recurrent set is de.ned by a parametric \nlinear inequality together with the loop guard. That is, for the recurrent set we assume the template \ni = 0 . ai + by = c, where a, b,and c are unknown parameters. They de.ne a recurrent set if condition \n(3) is satis.ed: '' . i, y . i, y. (i = 0 . ai + by = c) . '' (i = 0 . i= i - y . y= y) . ' '' (i= 0 \n. ai+ by= c). These constraints are similar to constraints generated in template\u00adbased invariant generation \n(Col\u00b4on et al. 2003). Existing non-linear constraint solving techniques can be used to solve them. We \npro\u00advide the formal details in Section 5. After solving these constraints for a, b,and c, we get a recurrent \nset i = 0 . y = 0. This set is reachable for the initial condition i = 0 . y < 0.Any solution to these \nconstraints demonstrates an input that causes non\u00adtermination. Summary. Our non-termination checker TNT \nconsists of two components. The .rst component performs a reachability compu\u00adtation on the state space \nof the program to enumerate all possible lassos. The second component attempts to infer a recurrent set \nfor each lasso that is discovered by the .rst component. In our imple\u00admentation, the enumeration of lassos \nis performed using directed test generation. The existence of a recurrent set implies that the current \nlasso induces a non-terminating execution. If no recurrent set is found (either because the loop terminates \nor because the tem\u00adplate is too weak), the generation of lassos continues. 3. Preliminary De.nitions \nWe develop our algorithm for an abstract imperative programming language. For ease of exposition, this \nlanguage ignores features such as references, dynamic memory allocation, and function calls. 0 A program \nP =(X,L,L,e0,T) consists of a set X of variables, a set Lof control locations, a set L0 .Lof cutpoint \nlocations, an initial location e0 .L,and a set T of transitions. Each transition t .T is a tuple (e,.,e \n' ),where e,e ' .Lare control locations, and . is a transition relation over the variables from X .X \n' . The variables from X denote values at control location e, and the variables from X ' denote the (updated) \nvalues of the variables from X at control location e ' . The sets of locations and transitions naturally \nde.ne a directed graph, called the control\u00ad.ow graph (CFG) of the program (Aho et al. 1986); unlike Aho \net al. (1986) we put the transitions at the edges of the graph. We assume that for every in.nite path \nthrough the control-.ow graph, there exists at least one control location in L0 that is visited by the \npath in.nitely many times. In our examples, we shall write programs using a C-like syntax, but these \ncan be easily processed into (abstract) programs. A state of the program P is a valuation of the variables \nfrom X. The set of all states is denoted by V.X. We represent sets of states using formulas over X. We \nwrite s |= . if the state s .V.X satis.es the formula .. A formula . over X represents the set {s .V.X \n|s|=.}. For a formula . over X .X ' and a valua\u00ad ' '' tion (s,s ).V.X \u00d7V.X , we write (s,s )|=. if the \nvaluation satis.es the constraint ..An execution of the program P is a .\u00adnite or in.nite sequence (e0,s0),(e1,s1),...,(ek,sk),...,where \n(ei,si).(L\u00d7V.X)for each i. We require that e0 is the initial location, and for each ithere is a transition \n(ei,.,ei+1).Tsuch that (si,si+1)|=..A path of the program P is a .nite or in.nite sequence p =(e0,.0,e1),(e1,.1,e2),...,(ek-1,.k-1,ek),... \nof transitions, where e0 is the initial location and the sequence of transitions form a path in the CFG. \nThe path p is feasible if there is an execution (e0,s0),...,(ek,sk),... such that for each i,we have \n(si,si+1) |= .i. A location e is reachable if some feasible .nite path ends in e.A state s is reachable \nat location e if (e,s) appears in some execution. For a .nite path (e0,.0,e1),...,(ek-1,.k-1,ek), we \nwrite a compound transition (e0,.,ek),where . =.0 ......k-1 and .is the relational composition operator \nde.ned by ' '' '' ''' (f..)(X,X )=.X .f(X,X )..(X ,X ). A lasso at a cutpoint location e.L0 consists \nof two sequences of transitions, which are referred to as stem and loop: stemloop lasso = e0 ---.e--.e \nThe stem is a .nite path from the initial location e0 to the loca\u00adtion e.The loop is a .nite path that \nstarts and ends at the cut\u00adpoint location e by following a cyclic path through the control\u00ad.ow graph. \nA lasso induces an in.nite execution if the in.nite path stem(loop). obtained by traversing the stem \nand then unrolling the loop in.nitely many times is feasible. In this case, we say that the lasso is \nnon-terminating. 4. Generating Lassos Our algorithm for detecting non-terminating executions has two \nparts: one part generates lassos in the control-.ow graph, and the second part checks if each generated \nlasso induces an in.nite execution. We now describe the algorithm NONTERM that searches for lassos in \nthe control-.ow graph of the program. It is shown in Figure 2. input P: program vars s, t, \u00a3, \u00a3' : program \nstate, transition, and control locations stem, loop : sequences of transitions begin 1 \u00a3 := \u00a30 2 CHOOSE \ns .V.X 3 stem := E 4 loop := E 5 try 6 repeat (*selecting stem *) 7 t, (\u00a3, s):= CHOOSENEXT(\u00a3, s) 8 stem \n:= stem t 9 until \u00a3 .L0 and CHOOSE {true, false}10 \u00a3' := \u00a3 (*.xing cutpoint location *) 11 repeat (*selecting \nloop *) 12 t, (\u00a3, s):= CHOOSENEXT(\u00a3, s) 13 loop := loop t 14 until \u00a3 = \u00a3' and CHOOSE {true, false}15 \nif NONTERMLASSO(stem, loop) then 16 s := initial state witnessing non-termination 17 return non-terminating \nexecution starts from s 18 else 19 raise CHOICEFAILURE 20 catch CHOICEFAILURE do 21 backtrack 22 catch \nBACKTRACKINGEXHAUSTED do 23 return program terminates end. Figure 2. Algorithm NONTERM for testing non-termination. \nThe operator adds a transition at the end of a given sequence. The functions CHOOSE and CHOOSENEXT are \nbacktrackable. Non-Deterministic Search. In NONTERM, weuse thevariables e, s,and t to store the current \nlocation, program state, and transition that leads to the current location. The search for lassos is \ndivided into two phases, which follows the lasso structure. During the .rst phase, we construct the stem \npart; see lines 6 9 in Figure 2. It is chosen nondeterministically and also .xes the cutpoint location \ne ' . The second phase nondeterministically chooses a loop at e ' ;see lines 11 14. Our high-level exposition \ncombines nondeterministic choice and backtracking to achieve exhaustive enumeration of all possi\u00adble \nlassos. We use a nondeterministic choice operator CHOOSE, which selects an arbitrary element from a given \nset. We assume that CHOOSE raises the CHOICEFAILURE exception when applied to the empty set. The function \nCHOOSENEXT determines how a stem/loop is extended. When applied to a program state s at loca\u00adtion e, \nit returns a program transition that starts from e, a successor location, and a successor state. The \nde.nition of CHOOSENEXT is shown in Figure 3. The CHOOSE and CHOOSENEXT opera\u00adtions can be effectively \nimplemented using symbolic execution and depth-.rst search. We assume that if no more backtracking is \npossible, i.e., if all possible choices have been explored by the algorithm, then the exception BACKTRACKINGEXHAUSTED \nis raised. In this case, we report that the program is terminating, see line 22. Check. A discovered \nlasso is analyzed to check if it induces an in\u00ad.nite execution. We use symbolic constraint-based methods \nfor this analysis, which is motivated by the following considerations. Sym\u00adbolic methods can effectively \nexplore all possible executions that follow the stem and then unroll the loop part, despite their large \nor input \u00a3 : control location s : program state vars S : set of state-transition pairs begin S := {(t, \n(\u00a3 ' ,s ' ))|t =(\u00a3, ., \u00a3 ' ).T and (s, s ' )|=.}return CHOOSE S end. Figure 3. Auxiliary function CHOOSENEXT \nfor the nondetermin\u00adistic selection of an outgoing transition, a successor location and state.Thefunction \nCHOOSEraisesthe CHOICEFAILURE exception when applied on the empty set. We implicitly assume the .xed \npro\u00adgram P, which determines the possible states s ' and transitions t. unbounded number. Even if a particular \nexecution that is analyzed by the algorithm is terminating, there may be a similar one an execution that \ntraverses the same stem and loop, but has different valuations of the program variables that is non-terminating. \nWe apply a non-termination checker by calling the function NONTERMLASSO, see line 15. If the proof of \nnon-termination succeeds, then we assume that it yields an initial state of a non\u00adterminating execution. \nThis state is reported as evidence of non\u00adtermination,andthealgorithm NONTERM succeeds.Ingeneral,the \ntransition relation of the lasso may be nondeterministic, e.g., con\u00adtain some input statements. In this \ncase, we also require that NON-TERMLASSO computes a sequence of valuations for the inputs that are read \nby the program during the lasso traversal. In Section 5, we describe algorithms for proving non-termination \nthat provide a range of precision/ef.ciency trade-offs. A failed non-termination check guides the algorithm \ninto the search for a different lasso. We rely on backtracking to explore the alternative choices of \nthe calls to CHOOSE and CHOOSENEXT. Correctness. The correctness of the algorithm NONTERM relies on two \ncomponents: the exhaustiveness of the search process for lassos, and the soundness of NONTERMLASSO, i.e., \nit only gives a positive result if there exists an in.nite execution induced by the lasso. THEOREM 1 \n(Correctness). If the algorithm NONTERM termi\u00adnates on an input program P and returns non-terminating \nexe\u00adcution starts from s, then P has an in.nite execution starting from state s.If NONTERM terminates \non an input program P and re\u00adturns program terminates, then the execution of P terminates starting from \nevery initial state. PROOF[Sketch] The .rst case immediately follows from the cor\u00adrectness of NONTERMLASSO. \nFor the second case, we observe that if the BACKTRACKINGEXHAUSTED exception is raised, then NONTERM enumerated \nall possible lassos. From the correctness of NONTERMLASSO, we conclude program termination. . Since the \nproblem of detecting non-termination is undecidable, algorithm NONTERM may not terminate on all programs. \nThis could happen, for example, for programs with in.nite, aperiodic executions.  5. Proving Feasibility \nof Lassos In this section, we propose algorithms for proving the non\u00adtermination of lassos, which we \nuse to implement the function NONTERMLASSO in our algorithm NONTERM for testing non\u00adtermination. (Non-)Well-Foundedness. \nFirst, we describe conditions when a relation can induce in.nite sequences. Subsequently, we extend it \nto deal with lassos. A binary relation .(X,X ' ) over states is not well-founded if there exists an in.nite \nsequence s1,s2,... such that for each i= 1, we have (si,si+1)|=.. The relation is well-founded if there \nis no such in.nite sequence. We are interested in .nding the initial states of in.nite sequences induced \nby relations that are not well-founded. stemloop Let lasso =e0 ---. e--. ebealasso where .stem and .loop \nare the transition relations of the stem and loop, respectively. The lasso induces an in.nite execution \nif the transition relation of the loop induces an in.nite execution whose initial state is reachable \nby traversing the stem. Using non-well-foundedness, we formulate the following suf.cient condition. The \nlasso induces an in.nite execution if the relation '''' ' . X ..stem (X ,X). .loop (X,X ) is not well-founded. \n5.1 Recurrent Sets We now provide a condition for checking that a relation is not well\u00adfounded. We formulate \nour condition in terms of recurrent sets.Let . be a relation. A state s ' is called a .-successor of \na state s if (s,s ' )|=..A set G (X)of states is recurrent for .if for each state s|=G (X), there exists \na .-successor state s ' such that s ' |=G (X). PROPOSITION 1 (Recurrent sets and non-well-foundedness). \nA relation .(X,X ' )is not well-founded if and only if there exists a non-empty recurrent set of states, \ni.e., if for some G (X), we have . X. G (X), (2) ' '' . X . X. G (X). .(X,X ).G (X ). (3) PROOF If a \nnon-empty recurrent set exists, then we generate an in.nite sequence by choosing an element satisfying \nG (X) (this is possible by condition (2)), and then constructing an in.nite sequence by iteratively applying \ncondition (3). If a relation is not well-founded, let s1,s2,... be an in.nite sequence induced by the \nrelation. We de.ne G (X)to be the set { s1,s2,...} . . We illustrate recurrent sets by example. Consider \nthe relation . over the variables x,yand x ' ,y ' such that x= 0. x ' =x+y. y ' =y+1. We observe that \nfor the construction of an in.nite sequence induced by . it is necessary that the value of the variable \nx is always positive. One possibility to ensure this condition is to start with a positive value of xand \nincrease it at each step. Hence, we obtain the recurrent set G 1(x,y)=(x= 0. y = 0). An alternative recurrent \nset admits in.nite sequences in which the value of x may decrease initially, but never decreases below \nzero (here, | y| denotes the absolute value of y): 1 G 2(x,y)=(x= 0. x=| y| (| y| +1)). 2 An example \nof an in.nite sequence for the recurrent set G 2(x,y)is ( 6,- 3) , ( 3,- 2) , ( 1,- 1) , ( 0,0) , ( 0,1) \n, ( 1,2) , ( 3,3) , .... When analyzing the non-termination of a lasso, we need to construct a recurrent \nset for the loop of the lasso that is moreover reachable by traversing the stem. stem PROPOSITION 2 (Recurrent \nset for lasso). A lasso e0 ---. loop e --. e induces an in.nite execution if and only if there exists \na recurrent set G (X ' )for the relation .loop(X ' ,X '' )such that ' '' . X . X..stem (X, X ).G (X ). \n(4) 5.2 From Recurrent Sets to Constraint Systems We now describe two symbolic analyses to construct \nrecurrent sets satisfying the conditions of Proposition 2 for a given lasso. The .rst, bitwise analysis \nassumes that the state space is .nite, and, without loss of generality, encoded using Boolean variables. \nThe second, linear arithmetic analysis assumes that every program transition along the lasso can be represented \nas a (rational) linear constraint over the program variables. The bitwise analysis enables the precise \ntreatment of low-level features of programming languages, e.g., bit-wise operations and arithmetic modulo \n.xed widths. The linear arithmetic analysis is a useful abstraction for programs when bit-level precision \nis not required. In either case, we show how we can reduce the search for recurrent sets to automatic \nconstraint solving. Bit-level Analysis. For the bitwise analysis, we assume that pro\u00adgram variables range \nover Booleans, and that the transition relation of the lasso is given by a Boolean formula over propositional \nvari\u00adables. Since the state space is .nite, a lasso induces an in.nite exe\u00adcution if and only if some \nstate is repeated in.nitely many times in the course of the execution. Therefore, we can restrict the \nsearch to singleton recurrent sets (i.e., recurrent sets that contain exactly one stemloop state). Given \na lasso e0 ---. e --. e, we look for a state s that is reachable at e by executing the transition stem, \nand after executing the transition loop returns back to itself. We encode this condition by the constraint \n''' ' ''' ''' . X,X ,X ..stem (X, X ). .loop(X ,X ). (X =X ). (5) Thefunction NONTERMLASSOreturnsapositiveresultifthiscon\u00adstraint \nis satis.able, and can be implemented using Boolean satis.\u00adability solving. The valuation of X is an \ninitial state that witnesses non-termination. This is similar to the bounded model-checking procedure \nfor liveness (Clarke et al. 2001). The constraints can be resolved by a bit-precise decision procedure \nsuch as Cogent (Cook et al. 2005) or STP (Ganesh and Dill 2007), which eventually re\u00adduces the checks \nto Boolean satis.ability. Notice that the constraint in Equation (5) may not be satis.ed for a syntactic \nloop in the program, but only for some unrolling of this loop. Consider the program while (x== y) {x \n=!x; y =!y; } which has an in.nite loop if x and y are initially equal. For this program, the constraint \n(x =y). (x =\u00ac x . y =\u00ac y) obtained from Equation (5) is unsatis.able. However, since NON-TERM exhaustively \ngenerates all lassos, we shall eventually con\u00adsider a lasso where the loop is unrolled once {x==y};x \n= !x;y = !y;{x==y};x = !x;y = !y; We observe that a singleton recurrent set exists for this lasso. Linear \nArithmetic Analysis. The linear arithmetic analysis as\u00adsumes that the program transitions are representable \nusing conjunc\u00adtions of linear inequalities over the program variables. Our algorithm follows a constraint-based \napproach for the syn\u00adthesis of auxiliary assertions for temporal veri.cation, e.g., linear and non-linear \ninvariants and ranking functions (Col\u00b4on et al. 2003; Sankaranarayanan et al. 2004; Cousot 2005; Kapur \n2006). We ex\u00adtend its applicability to synthesizing recurrent sets. The constraint-based approach to \nthe generation of auxiliary assertions reduces the computation of an assertion to a constraint\u00adsolving \nproblem. The reduction is performed in three steps. First, a template that represents the assertion to \nbe computed is .xed in a language that is chosen a priori. The parameters in the template are the unknown \ncoef.cients that determine the assertion. Second, a set of constraints over these parameters is de.ned. \nThe constraints encode the validity of the assertion. This means that every solution to the constraint \nsystem yields a valid assertion. Third, the assertion is obtained by solving the resulting constraint \nsystem. Our approach to generate recurrent sets follows these three steps. We use templates over linear \ninequalities to represents re\u00adcurrent sets. We derive constraints over template parameters that encode \nthe conditions in Equations (2) (4) from Section 5.1. Then, we solve the constraints and obtain a recurrent \nset. Recurrent sets are de.ned by universally quanti.ed conditions. As for invariant generation in linear \narithmetic, our main technical tool for the elimination of universal quanti.cation will be Farkas lemma \nfrom linear programming. THEOREM 2 (Farkas Lemma (Schrijver 1986)). A satis.able sys\u00adtem of linear inequalities \nAx = b implies an inequality cx = d if and only if there exists a non-negative vector . such that .A \n=c and .b = d. We now present the details of our algorithm for the computation of recurrent sets. We \nassume that the transition relations of the stem and loop parts are given by systems of inequalities. \nIn particular, we assume that the transition relation of the loop is given by a guarded ' command with \nthe guard Gx = g and updates x =Ux +u.1 Our algorithm computes a recurrent set G that is an instantiation \nof a template consisting of a conjunction of linear inequalities: G = Tx = t. First, we present a translation \nof condition (3) into constraints over template parameters. We eliminate the existential quanti.ca\u00adtion \nin condition (3) by substituting the de.nition of the primed variables given by the loop update: . x. \nG (x). .loop (x, Ux +u).G (Ux +u), which we write in matrix form as . x. Tx = t . Gx = g . TUx = t - \nTu. Here, the template parameters T and t are existentially quanti.ed. Next, we eliminate the universal \nquanti.er by encoding the validity of implication using Farkas lemma: \u00ab \u00ab Gg . .= 0. .T =. .t = . (6) \nTU t - Tu We can translate condition (2) into the constraint . \u00b5 = 0.\u00b5T =0. \u00b5t = 0. The translation for \ncondition (4) is similar. Together with (6), this leads to the .nal constraint de.ning recurrent sets, \nwhich contains alternating quanti.ers, existential followed by universal, as well as non-linear constraints \narising from the multiplication between template parameters and variables that encode the implication. \nThe constraints are similar to those for invariant generation (Col\u00b4on et al. 2003). We can use existing \nsolution techniques based on instantiations and case splitting. Unfortunately, there is no practical \nconstraint solver that sup\u00adports quanti.er alternation. We propose an alternative solution, 1 We use \nlower case x instead of X to denote program variables in this subsection to avoid any confusion between \nmatrices and vectors. input `\u00b4 x M : = m: transition relation of the stem x ' Gx = g. x =Ux+u: transition \nrelation of the loop Tx = t: template for recurrent set vars F: auxiliary constraint ' s,s ' : program \nstates valuations of xand x begin \u00ab \u00ab Gg F:= ..= 0. .T =. .t = TU t- Tu try CHOOSE (T* ,t *)such that \n(T* ,t *)|=F if exist (s,s ' )such that `\u00b4 x ' (s,s ' )|=M : = m. T* x = t * then x * return recurrent \nset T* x = t else backtrack catch CHOICEFAILURE do return no recurrent set for template Tx = t end. Figure \n4. Auxiliary function NONTERMLASSO for checking non\u00adtermination of linear arithmetic lassos. which we \ncan be implemented using a constraint solver that can iteratively enumerate all solutions. We enforce \nconditions (2) and (4) by evaluating them for the values of T and t that the con\u00adstraint solver computes \nfor constraint (6). If the conditions are not satis.able, then we require the solver to .nd alternative \nvalues for T and t. A constraint logic programming-based solver, e.g., clp(Q,R) (Holzbaur 1995), can \nimplement this backtracking search. We summarize the described algorithm NONTERMLASSO in Fig\u00adure 4. THEOREM \n3. If the algorithm NONTERMLASSO terminates and ** * returns recurrent set Tx = t , then the set {x |Tx \n=t * }is reachable by executing the stem, and is recurrent for the loop. As a corollary, if algorithm \nNONTERMLASSO returns a recur\u00adrent set for an input lasso, then the lasso induces an in.nite execu\u00adtion. \nWe illustrate the constraint generation process on the loop x =0.x ' =x +y .y ' =y +1, which we write \nin matrix form as \u00ab \u00ab \u00ab \u00ab \u00ab `\u00b4 xx ' 11 x 0 -10 = 0 .=+. yy 01 y 1 | {z } |{z}' g | {z } | {z } G Uu First, \nwe assume a template axx +ayy =a . bxx +byy =b, where ax, ay, a, bx, by,and b are unknown parameters. \nThen, we have \u00ab \u00ab ax ax +ay a -ay TU =and a -Tu =. bx bx +by b -by Following (6), for 01 .11 .12 .=@.21 \n.22A .31 .32 we obtain the constraint system 0 101 \u00ab \u00ab -10 0 ax ay a @A . .@A ..= 0. .= ax ax +ay = a- \nay . bx by b bx bx +by b- by We compute a solution ax ay a bx by b -1 0 0 0 -1 0 , which de.nes the \nrecurrent set x = 0.y = 0. It is straightfor\u00adward to check that the validity of the corresponding implication \nin condition (3) is established by .such that 01 10 .=@11A , 01 for which the constraint below evaluates \nto true: 01 01 \u00ab \u00ab -10 0 -10 0 @ @A .= -1 -1A . .= 0 . 0 -10 0 -11 Our algorithm requires that a template \nfor recurrent sets is pro\u00advided. We propose an iterative strengthening heuristic to .nd a template for \nwhich a recurrent set exists. We start with a tem\u00adplate that is a singleton conjunction, and incrementally \nadd more conjuncts if the constraint solving fails. Our practical experience demonstrates that the solving \nfails quickly, thus, allowing us to con\u00adtinue with a stronger template when necessary.  5.3 Weaker Conditions \nfor Recurrent Sets A lasso induces an in.nite execution if and only if each unrolling of its loop induces \nan in.nite execution whose initial state is reachable by executing the stem. These unrollings determine \nweaker condi\u00adtions on recurrent sets, which can sometimes lead to more succinct representations for recurrent \nsets. We .rst illustrate the weakening by example, and then provide a formal account. Consider a lasso \n.stem =(y ' =0), .loop =(x =0.x ' =x +y .y ' =1-y). This lasso induces in.nite executions, and a witnessing \nrecurrent set is G1(x, y)= (x =0.(y =0.y =1)). We observe that the recurrent set contains a disjunction. \nIn general, disjunctions are dif.cult for constraint solvers to reason about. However, we may also consider \na loop relation .loop2 obtained from the given one by unrolling it once: ' .loop2 (X, X )=.loop ..loop \n=(x =0.x +y =0.x ' =x +1.y ' =y). For this relation we compute a recurrent set G2(x, y)= (x =0.y =0). \nThis set is represented using a conjunction of atomic predicates. Every in.nite execution induced by \nthe lasso stem.loop2 is also induced by the original lasso. We now de.ne the i-th weakening for recurrent \nsets. Given a binary relation ., we say that G is i-th recurrent for .,for i = 1, if it is recurrent \nfor the relation .i, which is obtained from . by unrolling it i times, i.e., concatenating the loop guard \nand body i times. Formally, G is i-th recurrent for . if G is non-empty (i.e., .X G(X)), and .X .X ' \n. G(X)..i(X, X ' ).G(X ' ), (7) where ( i . if i =1, .=. ..i-1 if i> 1. The constraint-based non-termination \ncheck (Algorithm NON-TERMLASSO) can be implemented using i-th recurrent sets. We observe that we can \naccount for the i-th weakening, where i> 1, by considering the (unrolled) loop relation: i-1 X i ' i-1 \nj-1 .loop(x, x )= GUx = g - GUu . j=1 i X ' ij-1 x =Ux + Uu. j=1 As a heuristic, when proving non-termination, \nwe .rst try to com\u00adpute a recurrent set following the original de.nition, i.e., no weak\u00adening is applied. \nIf the computation fails, then we continue with a weaker de.nition of recurrent sets until either an \ni-th recurrent set is computed or an upper bound on the number of weakening attempts is reached. The \ntemplate strengthening heuristic from the previous section can be combined with the weakening of recurrent \nsets. We increase the number of conjuncts in the template only af\u00adter a sequence of weakening steps is \nexplored up to an a priori given bound. Such a combination attempts to avoid the transition to more expensive \nconstraint-solving tasks involving disjunction by .rst trying to simplify recurrent sets through their \nweakening.  6. Experiences 6.1 Implementation We have implemented TNT, a tool that analyzes C programs \nfor non-terminating executions. TNT has an outer loop that performs concolic execution (Godefroid et \nal. 2005; Sen et al. 2005) by running the program on concrete as well as symbolic inputs. The constraints \ngenerated during concolic execution are bit accurate, and solved using the decision procedure STP (Ganesh \nand Dill 2007). In our symbolic execution, the heap is always kept concrete; we only allow symbolic constants \nwith base types. The template\u00adbased search for recurrent sets is implemented using a Sicstus Prolog-based \nconstraint solver for invariant generation. In preliminary experiments, we checked the non-termination \nof simple and small programs, including the programs from Section 2, and an abstraction of the non-termination \nbug from (Cook et al. 2006). In each case, the non-terminating loop was identi.ed in a few seconds. One \nlimitation of the current implementation is that the heap is concrete. While this means that the recurrent \nsets bene.t from precise address information, it is also a limitation of the tool to .nd potentially \nin.nite executions that depend on shape assumptions on data structures. For example, we cannot catch \nin.nite executions arising from acyclic list traversal routines when they are applied on circular lists \nas input. Integrating our work with symbolic shape information is left as future work.  6.2 Mondriaan \nMemory Protection In addition to the simple examples, we ran our tool on an early implementation of the \nMondriaan memory-protection system (Witchel et al. 2002; Witchel 2004; Witchel et al. 2005). Mondriaan \nis a protection scheme that allows .exible memory sharing and .ne-grained permissions control between \ndifferent user applications and a trusted supervisor mode running on an OS. Un\u00adlike usual virtual memory \nthat operates at the page level, Mondri\u00adaan allows arbitrary permissions control at the granularity of \nindi\u00advidual memory words. In the Mondriaan implementation, memory is organized as a linear address space, \ndivided into user segments. Each user segment determines a range of addresses and permis\u00adsions associated \nwith addresses in that range, and is de.ned as a triple (b, l, p) of a base address b, a length l, and \na permission p.By setting the permissions of a user segment, a process can .exibly and safely share its \naddress space with other processes. A privileged su- Address (bits 31 0) Root index (10) Mid index (10) \nLeaf index (6) Leaf offset (6) Bits 31 22 Bits 21 12 Bits 11 6 Bits 5 0 Figure 5. Modriaan permissions \ntable indexing. Root table Leaf tables Mid level tables Memory Range Figure 6. Typical permissions \ntable generated by mmpt insert. Root table Mid-level table Leaf table Figure 7. Table state after .rst \ncall of mmpt insert. pervisor mode provides an API to modify permissions. The permis\u00adsions associated \nwith a user segment can be modi.ed using this API by specifying the base word address, the length of \nthe user segment in words, and the desired permission (none, read-only, read-write, or execute-read). \nEach protection domain (i.e., group of processes sharing the address space) maintains a permissions table, \nstored in privileged memory, which speci.es the permissions associated with each address of the address \nspace. The permissions table is organized as a compressed multi-level table, with three levels: a root \ntable, a mid-level table, and a leaf table. Figure 5 shows how the table is indexed by a 32-bit address. \nThe root table has 1024 entries (indexed by the top 10 bits in Figure 5), each of which maps a 4MB block \nof memory. Each mid-level table has 1024 entries (indexed by the next 10 bits), each of which maps a \n4KB block. The leaf tables have 64 entries each (indexed by 6 bits), and each entry provides individual \npermissions for 16 four-byte words. To save space, upper-level table entries can either be pointers to \nlower-level tables (or NULL), or directly hold a permissions vector for sub-blocks. In this case, the \nrightmost bit of the entry indicates whether the entry is a pointer or a permissions vector (since addresses \nare word-aligned, the last two bits of an address are always zero). Permissions vectors stored in upper \nlevels of the table only store permissions for 8 sub-blocks (instead of 16 in the leaves). An auxiliary \nfunction uentry is data is used to check whether an entry is a pointer to a lower-level table or a permissions \nvector. We chose Mondriaan as our case study because (1) correctness is crucial, since the code runs \nin privileged mode in the kernel, (2) the code was complicated enough to warrant its author to annotate \nthe code with properties (both as assertions and as comments), and to suggest it as a challenge for formal \nveri.cation, and (3) the code is low-level, performing extensive bitwise operators that extract in\u00addices \nto arrays, and memory-intensive, traversing multiple levels of data structures, and both these features \nprovide exceptional chal\u00adlenges to static analysis. Initially, the Mondriaan implementation creates the \nroot permis\u00adsions table with 1024 entries all .lled with 0s (that is, no permis\u00adsions associated with \nany address). Figure 9 shows source code to perform updates from an early version of Mondriaan that was \npro\u00advided to us by the author Emmett Witchel as a challenging veri.ca\u00adtion problem. The code updates \nthe permissions of a user segment in the permissions table by taking as input a user segment and up\u00addating \nthe permissions of the segment in the table. The actual update is performed by the recursive procedure \nmmpt insert, shown in Figure 9, which takes as input a pointer to the permissions table structure mmpt, \na user segment (a base address, a pointer len to the length of the segment, and the de\u00adsired protection \nprot), and additional control parameters such as a pointer to the current table (initially, the root \ntable), the current level (root, mid-level, or leaf), and .ags determining whether or not some table \ncan be freed and whether or not to allocate. An insertion into the table for a user segment is performed \nas a call mmpt insert(mmpt, base, &#38;len, prot, mmpt.tab, 0, &#38;nonzero, 1); The code is complicated, \nas it must consider several different cases of inserting new permissions to the table, and performs dynamic \nallocation or freeing of lower-level tables when they are not neces\u00adsary. Furthermore, a user segment \nis broken into parts in the inser\u00adtion process, and the insertion routine is called recursively for each \npart. Instead of explaining the code line by line, we will explain the functional behavior of mmpt insert. \nAs shown in Figure 6, mmpt insert splits the memory range from base to base + len in aligned 4MB blocks \nat the root level. For an update, this can result in one of the following two cases: Exact Coverage. \nFor every 4MB sub-block of the user segment that is aligned with the sub-block size (512KB), the permissions \nvector is set in the corresponding entry in the root table. If the root entry was a pointer to a mid-level \ntable, then the mid-level table is recursively deallocated. Overlapped Coverage. Breaking the user segment \ninto aligned 4MB blocks can leave extra blocks at the beginning and at the end, that is, the .rst and \nlast blocks of the user segment may not be aligned with 512KB sub-blocks at the root level. For these \nblocks, mmpt insert recursively goes to the mid\u00adlevel table (allocating the mid-level table if necessary) \nand sets permissions in the mid-level table. Depending on the stored value in the root entry for the \nbase address, mmpt insert .rst performs the following action:        1. If the root entry is 0 \nthen it allocates a new mid-level permis\u00adsions table of 1024 entries and .lls the entries in the new \ntable with zeros. The root entry is set as a pointer to this table. 2. If the root entry is a permissions \nvector, then it allocates a mid\u00adlevel permissions table and .lls it with permissions vectors. The root \nentry is set as a pointer to this table. 3. If the root entry is a already a pointer to a mid-level \ntable, then it follows the pointer to the mid-level table.  Then, mmpt insert computes the the memory \nrange of the .rst or last section and recursively inserts this memory range into the mid\u00adlevel table. \nIn the recursive call, the memory blocks are 4K each. For the possibly unaligned .rst and last block, \nmmpt insert gen\u00aderates leaf tables. Permissions in leaf tables are set by a further re\u00adcursive call. \nIf leaf tables have unaligned blocks, then permissions are approximated in sub-blocks of 4 bytes in the \nleaf table. Non-termination in mmpt insert. When we ran TNT on mmpt insert, it found a non-terminating \nexecution. This bug is caused by calling mmpt insert with a user segment whose length is not a multiple \nof 4. To illustrate this, consider two consecutive calls to mmpt insert just after initialization (found \nby TNT). The .rst call sets a read permission for a user segment of 4 bytes with base address 0. The \nsecond one sets the permission for a user seg\u00adment of 3 bytes with base address 0. The .rst call terminates, \nwhile the second call runs into in.nite recursion. Figure 7 shows the state of the memory table after \n.rst call. Let us trace the code of mmpt insert line by line during the second call. Procedures called \nby mmpt insert are summarized in Figure 8. In the second call, mmpt insert is called with a (constant) \npointer to the mmpt structure, a base address base of 0, the address of the length variable len, which \ncontains the length 3, a pointer to the root table, and level =0 (signifying a root entry). (We omit \nthe other, unimportant parameters.) At line 4, the insertion routine checks that *len is not zero, that \nis, the current memory chunk needs to be .lled in the table. At line 5, the helper procedure make idx \ncomputes the index of the entry in the root table, which corresponds to base. This extracts the top 10 \nbits of base,which turn out to be 0. At line 6, the last comparison in the conditional checks whether \nthe value of *len is greater than the block size of the root entry (4MB). Since the length is 3, this \ncheck fails and control passes to line 19. The conditional on line 19 passes, since the passed table \nis not a leaf table, and the entry in the root table is a pointer to a mid-level table. (Recall the con.guration \nof the permissions table after the .rst call from Figure 7.) Now at line 20, mmpt insert makes a recursive \ncall with a pointer to the mid-level table that is pointed to by the zeroth entry of the root table, \ntab[idx]. The parameters base and len do not change, but level increases to 1, indicating that the current \ntable is a mid-level table. In this recursive call, control again comes to line 20, this time making \nanother recursive call with a pointer to a leaf table, and with level equal to 2. In this second recursive \ncall, the conditions at lines 6, 19, and 21 all fail because the current table is a leaf table. Thus, \ncontrol jumps to line 41. The for loop at line 41 does not execute at all, since *len (which is equal \nto 3) is smaller then the sub\u00adblock length (4 bytes) of the leaf table. Thus, control directly jumps \nto line 50 and makes a recursive call with base 0, length 3, a pointer to the root table, and level reset \nto 0. These are the same parameters which were passed at the start of execution of the procedure mmpt \ninsert. This causes an in.nite loop, as the recursion does not terminate. While this bug can be found \nusing random testing followed by manual inspection in a debugger, the complexity of the code path  \n           tab base(struct mmpt * mmpt, int base, int level) Returns the lower boundary of \nthe memory range that corresponds to the permissions table of a given level whose memory range contains \nbase tab len(struct mmpt * mmpt, int level) Returns the size of the memory block that corresponds to \neach entry of the permissions table of a given level tab addr(struct mmpt * mmpt, int base, int idx, \nint level) Returns the lower boundary of the memory range that corresponds to the entry at index idx \nin the permissions table of a given level whose memory range contains base tab nentries(struct mmpt * \nmmpt, int level) Returns the number of entries in the table of a given level subblock len(struct mmpt \n* mmpt, int level) Returns the sub-block size of a given level make idx(struct mmpt * mmpt, int base, \nint level) Returns the index of the .rst entry in the permissions table whose memory range contains base \nuentry is data(struct mmpt * mmpt, int entry) Checks if the entry in the permissions table is a pointer \nor a permissions vector entry prot(struct mmpt * mmpt, int permission entry, int i) Returns the i-th \npermissions .eld in permission entry Figure 8. Summary of functions called by mmpt insert  1: for (x \n= 0; x < 100; x++) { ... } 2: while (y > 0) { 3: y++; 4: ... 5: } Figure 10. TNT can skip the analysis \nof the .rst loop, which is terminating, thus accelerating its search for non-terminating lassos. We assume \nthat the omitted code fragments do not modify x or y. (there are 3 levels of recursive calls involved) \nshows the utility of having a tool like TNT check the executions for possible non\u00adtermination over the \ncurrent manual process of stepping through a debugger. Proving Termination. The non-terminating execution \noccurred because of the unchecked assumption that the lengths of user seg\u00adments are always a multiple \nof 4. We put this check in the code. This time, TNT timed out without identifying any in.nite exe\u00adcution. \nSince our implementation does not include a termination\u00adcheck based acceleration, most of the time was \nspent in analyzing longer and longer symbolic traces of recursive calls. We then proved termination of \nthe corrected version by hand. The proof of termination involves a lexicographic ranking on the pair \n(*len, 2 -level), as on every recursive call, either the length decreases or, if the length remains the \nsame, the distance of the level from the leaf tree decreases. The reasoning for termination uses crucially \nthe invariant that the length is always a multiple of 4 to rule out the previous in.nite execution. We \nbelieve that this example is a good challenge problem for termination checkers. Unfortunately, well-documented \nlimitations of current termination checkers (to deal with bitwise operators, or shared data structures \non the heap) make it dif.cult to prove termination of this program automatically with the current tools. \n  7. Acceleration for NONTERM In this section we describe a practical extension for our non\u00adterminationcheckingalgorithm \nNONTERM showninSection4.We describe how to avoid redundant non-termination checks by accel\u00aderating the \ntraversal of terminating loops. We .rst illustrate the proposed technique on the example code shown in \nFigure 10. The .rst loop statement terminates, thus, our algorithm should not consider lassos that loop \nat line 1 and try to prove their non-termination. We can apply an existing termination prover to automatically \ncheck if the .rst loop terminates. The successul check allows us to unroll the .rst loop until it exits, \nand consider the resulting sequence as an initial stem. Such an unrolling avoids 100 attempts to prove \nnon-termination of the .rst loop, and directly leads us to the interesting part of the program. Given \na lasso, the non-termination checking algorithm NON-TERMLASSO, as described in the previous section, \ncan fail to re\u00adturn a positive result. For complete checking algorithms, the failure is caused by the \ntermination of the lasso. Incomplete algorithms can produce an inde.nite result, which leaves open the \npossibility that the lasso may be terminating. Since the exploration of terminating loops does not advance \nthe search for in.nite executions, we pro\u00adpose a modi.cation of NONTERM that removes such loops from \nconsideration. See Figure 11 for the modi.ed statements. If the lasso can be proven terminating no matter \nwhat the input is, we lead the execution through the loop until it exits. In order words, we fully unroll \nthe loop by executing the loop sequence, and rely on the proof of termination to guarantee the convergence \nof the unrolling. Thus, we eventually reach line 18.9. The resulting sequence will be used to seed the \nselection of the next stem to be considered, i.e., the next stem will be chosen to contain the sequence \nas a pre.x. Thus, NONTERM can reach interesting parts of code by passing across loops in one step, without \ninterruption at each iteration. If the termination property of the lasso cannot be determined, we continue \nour search for non-terminating lassos. During the subsequent iterations of NONTERM, we shall only consider \nlassos that have the current stem as a pre.x. Thus, we ensure that the search makes progress. 8. Conclusion \nTermination checkers search for ranking functions; our non\u00adtermination checker searches for a recurrent \nset of states. Always one of the two must exist, and its presence or absence would be determined by a \ncomplete method. In practice, however, tools are incomplete. A failure to prove termination does not \nindicate def\u00adinite non-termination, and vice versa. In particular, we looked at a non-termination proof \nfor Mondriaan only after failed attempts to prove termination. This illustrates the need for complementing \na termination checker with a non-termination checker, because the former, when failing, gives no information \nas to why it failed to dis\u00adcover a ranking function. It may have failed because no such func\u00adtion exists \nwithin the assumptions and restrictions under which the checker operates, or because the program does \nnot terminate. 18.1 18.2 18.3 else if TERMLASSO(stem, loop) then S := { s ' | s loop---. s ' }while S \n. = \u00d8 do (* unrolling loop * ) 18.4 stem := stem loop 18.5 CHOOSE s . S 18.6 18.7 S := { s ' | s loop---. \ns ' }done 18.8 loop := E 18.9 else Figure 11. Acceleration of the algorithm NONTERM for testing termination. \nLines 18.1 18.9 replace line 18 in Figure 2. We unroll the loop part of a terminating lasso without intermediate \nchecks for non-termination. Recall that the variable s holds the value of the current program state, \nwhose successors are computed during loop unrolling. Research in testing has focused on safety assertions, \nprimarily because counterexamples are .nite objects that can be recognized online. In contrast, in.nite \nloops are identi.ed using ad hoc tech\u00adniques and guesses about the program runtime, which is almost always \nperformed through laborious manual inspection. Therefore, dual to the use of safety assertions in code, \nwe must also develop speci.cation techniques and automatic tools that assert and check the absence of \nnon-terminating executions. We believe that TNT is a step towards such a class of tools. Acknowledgments. \nGupta and Rybalchenko are supported in part by Microsoft Research through the European Fellowship Pro\u00adgramme. \nHenzinger is supported by the Swiss National Science Foundation. Majumdar and Xu are supported by the \nNational Sci\u00adence Foundation grants CCF-0427202, CCF-0546170, and CNS\u00ad0720881. We thank Emmett Witchel \nfor sharing and explaining the Mondriaan code and commenting on the draft, and Patrice Gode\u00adfroid for \nseveral useful comments on the draft.  References A. V. Aho, R. Sethi, and J. D. Ullman. Compilers: \nPrinciples, Techniques, and Tools. Addison-Wesley, 1986. T. Ball and S. K. Rajamani. The SLAM project: \nDebugging system software via static analysis. In Proc. POPL, pages 1 3. ACM, 2002. Joshua Bloch. Nearly \nall binary searches and mergesorts are broken, June 2006. http://googleresearch.blogspot.com/2006/06/ \nextra-extra-read-all-about-it-nearly.html. A. Bradley, Z. Manna, and H. Sipma. The polyranking principle. \nIn Proc. ICALP, LNCS 3580, pages 1349 1361. Springer, 2005. E.M. Clarke, A. Biere, R. Raimi, and Y. Zhu. \nBounded model checking using satis.ability solving. Formal Methods in System Design, 19(1): 7 34, 2001. \n M. Col\u00b4on and H. Sipma. Practical methods for proving program termina\u00adtion. In Proc. CAV, LNCS 2404, \npages 442 454. Springer, 2002. M. Col\u00b4on, S. Sankaranarayanan, and H.B. Sipma. Linear invariant gener\u00adation \nusing non-linear constraint solving. In Proc. CAV, LNCS 2725, pages 420 432. Springer, 2003.  B. Cook, \nD. Kroening, and N. Sharygina. COGENT: Accurate theorem proving for program veri.cation. In Proc. CAV, \nLNCS 3576, pages 296 300. Springer, 2005. B. Cook, A. Podelski, and A. Rybalchenko. Termination proofs \nfor systems code. In Proc. PLDI, pages 415 426. ACM, 2006. P. Cousot. Proving program invariance and \ntermination by parametric abstraction, Lagrangian relaxation and semide.nite programming. In Proc. VMCAI, \nLNCS 3385, pages 1 24. Springer, 2005. M. d Amorim and G. Rosu. Ef.cient monitoring of omega-languages. \nIn Proc. CAV, LNCS 3576, pages 364 378. Springer, 2005. V. Ganesh and D.L. Dill. A decision procedure \nfor bit-vectors and arrays. In Proc. CAV, LNCS 4590, pages 519 531. Springer, 2007. P. Godefroid. The \nsoundness of bugs is what matters (position statement). In BUGS 2005 (PLDI 2005 Workshop on the Evaluation \nof Software Defect Detection Tools), 2005. P. Godefroid, N. Klarlund, and K. Sen. DART: Directed automated \nrandom testing. In Proc. PLDI, pages 213 223. ACM, 2005. B. Gulavani, T.A. Henzinger, Y. Kannan, A. Nori, \nand S.K. Rajamani. SYNERGY: A new algorithm for property checking. In Proc. FSE, pages 117 127. ACM, \n2006. T.A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy abstraction. In Proc. POPL, pages 58 \n70. ACM, 2002. C. Holzbaur. OFAI clp(q,r) Manual, Edition 1.3.3. Austrian Research Institute for Arti.cial \nIntelligence, Vienna, 1995. TR-95-09. D. Kapur. Automatically generating loop invariants using quanti.er \nelim\u00adination. Technical Report 05431 (Deduction and Applications), IBFI Schloss Dagstuhl, 2006. T. Kremenek \nand D.R. Engler. Z-ranking: Using statistical analysis to counter the impact of static analysis approximations. \nIn Proc. SAS, LNCS 2694, pages 295 315. Springer, 2003. A. Pnueli, A. Zaks, and L.D. Zuck. Monitoring \ninterfaces for faults. Electr. Notes Theor. Comput. Sci., 144(4):73 89, 2006. S. Sankaranarayanan, H.B. \nSipma, and Z. Manna. Non-linear loop invariant generation using Gr\u00a8obner bases. In Proc. POPL, pages \n318 329. ACM, 2004.  A. Schrijver. Theory of Linear and Integer Programming. Wiley, 1986. K. Sen, A. \nVardhan, G. Agha, and G. Rosu. Ef.cient decentralized moni\u00adtoring of safety in distributed systems. In \nProc. ICSE, pages 418 427. ACM, 2004. K. Sen, D. Marinov, and G. Agha. CUTE: A concolic unit testing \nengine for C. In Proc. FSE, pages 263 272. ACM, 2005. H. Velroyen. Automatic non-termination analysis \nof imperative programs. Master s thesis, Chalmers University of Technology, Aachen Technical University, \n2007. E. Witchel. Mondriaan Memory Protection. PhD thesis, Massachusetts Institute of Technologys, 2004. \nE. Witchel, J. Cates, and K. Asanovi\u00b4c. Mondrian memory protection. In Proc. ASPLOS, pages 304 316. ACM, \n2002. E. Witchel, J. Rhee, and K. Asanovic. Mondrix: memory isolation for linux using mondriaan memory \nprotection. In Proc. SOSP, pages 31 44. ACM, 2005. Y. Xie and A. Aiken. Saturn: A SAT-based tool for \nbug detection. In Proc. CAV, LNCS 3576, pages 139 143. Springer, 2005. 1. static void  2. _mmpt_insert(struct \nmmpt* mmpt, unsigned long base, unsigned long* len, int prot, tab_t* tab, int level, int* nonzero, int \nallocate_ok) { 3. unsigned int idx; tab_t entry; 4. if(*len == 0) return; 5. idx = make_idx(mmpt, \nbase, level);  6. if(level < 2 &#38;&#38; base == tab_base(mmpt, base, level + 1) &#38;&#38; *len >= \ntab_len(mmpt, level + 1)) { // CASE A: Upper level, new region is aligned &#38; spans at least one entry \n 7. unsigned int entry_len;  8. if(tab[idx] &#38;&#38; !uentry_is_data(mmpt, tab[idx])) { 9. look_for_nonzero(mmpt, \n(tab_t*)tab[idx], level, nonzero); 10. table_free(mmpt, (void*)tab[idx], level + 1); 11. tab[idx] = \n0; 12. } 13. entry = tab[idx];  14. entry_len = make_entry(mmpt, base, *len, prot, level, &#38;entry); \n 15. tab[idx] = entry; 16. *len -= entry_len; 17. base += entry_len;  18. _mmpt_insert(mmpt, base, \nlen, prot, mmpt->tab, 0, nonzero, allocate_ok); 19. } else if(level < 2 &#38;&#38; tab[idx] &#38;&#38; \n!uentry_is_data(mmpt, tab[idx])) { // CASE B: Upper level, pointer entry // Recurse down through pointer \n 20. _mmpt_insert(mmpt, base, len, prot, (tab_t*)tab[idx], level + 1, nonzero, allocate_ok); 21. } else \nif(level < 2 &#38;&#38; ((base &#38; (subblock_len(mmpt, level)-1)) != 0 || *len < subblock_len(mmpt, \nlevel))) { // CASE C: Upper level, NULL or data entry, new region doesn t fit in // subblock (not aligned \nor not big enough) 22. unsigned long upper_data_entry = tab[idx]; 23. unsigned int i; 24. *nonzero \n|= (tab[idx] != 0); 25. if(allocate_ok) { 26. unsigned long sub_len;  27. tab[idx] = (tab_t)xmalloc(tab_nentries(mmpt, \nlevel + 1) * sizeof(*mmpt->tab)); 28. memset((tab_t*)tab[idx], 0, tab_nentries(mmpt, level + 1) * sizeof(*mmpt->tab)); \n 29. for(i = 0; i < 1<<mmpt->lg_num_subblock[level]; ++i) { 30. sub_len = subblock_len(mmpt, level); \n 31. _mmpt_insert(mmpt, tab_base(mmpt, base, level+1) + i * subblock_len(mmpt, level), &#38;sub_len, \nentry_prot(mmpt, upper_data_entry, i), (tab_t*)tab[idx], level + 1, nonzero, allocate_ok); 32. }  33. \n_mmpt_insert(mmpt, base, len, prot, (tab_t*)tab[idx], level + 1, nonzero, allocate_ok); 34. }else{ \n 35. unsigned int tlen = tab_len(mmpt, level + 1); // CASE D: Upper level, NULL or data entry, new region \ndoesn t fit in // subblock (not aligned or not big enough), and not // allocating new tables 36. if(*len \n< tlen) return; 37. *len -= tlen;  38. _mmpt_insert(mmpt, tab_addr(mmpt, base, idx+1, level), len, \nprot, mmpt->tab, 0, nonzero, allocate_ok); 39. }  40. }else{ // CASE E: Any level, NULL or data entry, \nfill in the rest of // this table and recurse for the remainder if necessary. 41. for(; *len >= subblock_len(mmpt, \nlevel) &#38;&#38; idx < tab_nentries(mmpt, level); idx++) { 42. int entry_len; 43. *nonzero |= (tab[idx] \n!= 0); 44. entry = tab[idx];  45. entry_len = make_entry(mmpt, base, *len, prot, level, &#38;entry); \n 46. tab[idx] = entry; 47. *len -= entry_len; 48. base += entry_len; 49. }  50. _mmpt_insert(mmpt, \nbase, len, prot, mmpt->tab, 0, nonzero, allocate_ok); 51. } 52. }  Figure 9. Mondriaan insertion \ncode (Witchel 2004; Witchel et al. 2005). The code is courtesy of E. Witchel. \n\t\t\t", "proc_id": "1328438", "abstract": "<p>The search for proof and the search for counterexamples (bugs) are complementary activities that need to be pursued concurrently in order to maximize the practical success rate of verification tools.While this is well-understood in safety verification, the current focus of liveness verification has been almost exclusively on the search for termination proofs. A counterexample to termination is an infinite programexecution. In this paper, we propose a method to search for such counterexamples. The search proceeds in two phases. We first dynamically enumerate lasso-shaped candidate paths for counterexamples, and then statically prove their feasibility. We illustrate the utility of our nontermination prover, called TNT, on several nontrivial examples, some of which require bit-level reasoning about integer representations.</p>", "authors": [{"name": "Ashutosh Gupta", "author_profile_id": "81418597229", "affiliation": "Max Planck Institute, Saarbruecken, Germany", "person_id": "P925376", "email_address": "", "orcid_id": ""}, {"name": "Thomas A. Henzinger", "author_profile_id": "81100034124", "affiliation": "EPFL, Lausanne, Switzerland", "person_id": "P280800", "email_address": "", "orcid_id": ""}, {"name": "Rupak Majumdar", "author_profile_id": "81100319213", "affiliation": "UC Los Angeles, Los Angeles, CA", "person_id": "P335105", "email_address": "", "orcid_id": ""}, {"name": "Andrey Rybalchenko", "author_profile_id": "81100483883", "affiliation": "Max Planck Institute, Saarbruecken, Germany", "person_id": "P688961", "email_address": "", "orcid_id": ""}, {"name": "Ru-Gang Xu", "author_profile_id": "81336494231", "affiliation": "UC Los Angeles, Los Angeles, CA", "person_id": "P898063", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328459", "year": "2008", "article_id": "1328459", "conference": "POPL", "title": "Proving non-termination", "url": "http://dl.acm.org/citation.cfm?id=1328459"}