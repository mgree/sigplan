{"article_publication_date": "01-07-2008", "fulltext": "\n Separation Logic, Abstraction and Inheritance MatthewJ.Parkinson GavinM. Bierman University of Cambridge, \nUK Microsoft Research Cambridge, UK Matthew.Parkinson@cl.cam.ac.uk gmb@microsoft.com Abstract Inheritance \nis a fundamental concept in object-oriented program\u00adming, allowing new classes to be de.ned in terms \nof old classes. When used with care, inheritance is an essential tool for object\u00adoriented programmers. \nThus, for those interested in developing formal veri.cation techniques, the treatment of inheritance \nis of paramount importance. Unfortunately,inheritance comesinanum\u00adber of guises, all requiring subtle \ntechniques. To address these subtleties, most existing veri.cation method\u00adologies typically adopt one \nof two restrictions to handle inheri\u00adtance: either (1) they prevent a derived class from restricting \nthe behaviour of its base class (typically by syntactic means) to triv\u00adialize the proof obligations; \nor (2) they allow a derived class to restrict the behaviour of its base class, but require that every \nin\u00adherited method must be reveri.ed. Unfortunately, this means that typical inheritance-rich code either \ncannot be veri.ed or results in an unreasonable number of proof obligations. In this paper, we develop \na separation logic for a core object\u00adoriented language. It allows derived classes which override the \nbe\u00adhaviour of their base class, yet supports the inheritance of methods without reveri.cation where this \nis safe.For each method, we re\u00adquire two speci.cations: a static speci.cation that is used to ver\u00adify \nthe implementation and direct method calls (in Java this would be with a super call); and a dynamic speci.cation \nthat is usedfor calls that are dynamically dispatched; along with a simple relation\u00adship between the \ntwospeci.cations. Only the dynamic speci.cation is involved with behavioural subtyping. This simple separation \nof concerns leads to a powerful system that supports all forms of in\u00adheritance withlow proof-obligationoverheads.We \nboth formalize our methodology and demonstrate its power with a series of inher\u00aditance examples. Categories \nand Subject Descriptors D.2.4[Software Engineer\u00ading]: Program Veri.cation class invariants; D.3.3 [Program\u00adming \nLanguages]:Language Constructs and Features Classes and inheritance General Terms Languages, Theory,Veri.cation \nKeywords Separation Logic, Modularity, Classes Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 08, January 7 12, 2008, San Francisco, California, USA. Copyright \nc &#38;#169; 2008ACM 978-1-59593-689-9/08/0001...$5.00 1. Introduction 1.1 Motivation Inheritance is \na fundamental concept in object-oriented program\u00adming. It allows new classes to be de.ned in terms of \nexisting classes. These new, or derived, classes inherit both attributes and behaviour from their base \nclasses. There are several different uses of inheritance in object-oriented code: Specialization: One \ncommon use of inheritance is to create a specialization of the base class. This typically involves directly \ninheriting members from the base class and extending this set with further members. Overriding: Most \nobject-oriented languages allow a class to re\u00ad place some of the members of the base class, these members \nare said to override the de.nitions in the base class. Codere-use: Sometimes inheritance is used purely \nfor code re\u00ad use, that is, a derived class is not intended to be used in the same places as its base \nclass,but rather theyjust share code. Our main concern is providing practical, modular veri.cation methodologies \nto enable programmers to reason about and docu\u00adment their code. As inheritance in all its guises plays \nsuch an important role in object-oriented code, we contend that any veri.\u00adcation methodology must provide \npracticable techniques for deal\u00adingwithit.Inotherwords,the programmer shouldbeabletoverify common inheritance \npatterns without substantial rewriting of their code. Moreover, these typical patterns should not result \nin unrea\u00adsonable proof obligations on the programmer. Let us consider some examples of these uses of \ninheritance and the problems they raise for formal veri.cation. In this paper we only address languages \nthat support single inheritance; for exam\u00adple, languages such asC0 and Java.1 In Figure 1, we de.ne a \nbase class, Cell, and a derived class, Recell. This code uses both spe\u00adcialization andoverriding.We will \nconsider DCell and code re-use later. The base class has a .eld val, and two methods, set and get. The \nderived class directly inherits the .eld val, and method get. In additionit specializes its base classby \nde.ninga new .eld bak; and also overrides the set method. (TheC0 expression base.m ac\u00adcesses the m member \nof the base class of the current object. It is written super.m in Java.)2 Firstly, by de.ning the derived \nclass, we are able to pass Recell objects as if theywere Cell objects. This syntactic property is guar\u00adanteed \nby the type system. The corresponding semantic property, known as substitutivity, is that whenever an \nobject of type Cell is 1In this paper, we shall write our code examples in a C 0-style syntax, but our \ntechniques apply to Java,Visual Basic and other single-inheritance object-oriented languages. 2The overridden \nset method is very abstract in using a base call for get, rather than direct .eld access or dynamic dispatch. \nWe discuss the alternatives in \u00a75.5. class Cell class Recell: Cell {{ public int val; public int bak; \npublic override void set(int x) public virtual void set(int x) {{ this.bak = base.get(); this.val=x; \nbase.set(x); }} } public virtual int get() class DCell:Cell {{ return this.val; public override void \nset(int x) }{ base.set(2*x); }}} Figure 1. Examples of inheritance. expected, supplying an object of \ntype Recell will not change the behaviourof the program. Liskov andWing (1994) de.neda no\u00adtion called \nbehavioural subtyping that guarantees the property of substitutivity. Secondly, Recell inherits the Cell \ns body for the get method. Thisis correctatthelevelof types,butisit semanticallyvalidto inherit this \nmethod? Unfortunately, this is a non-trivial problem. To simplify matters, most current veri.cation methodologies \nadopt one of two restrictions: either they (1) prevent a derived class restricting the behaviour of the \nbase class which trivializes the proof obligations, e.g.M\u00a8 uller (2002); Barnett et al. (2004), or (2) \ntheyallow a derived class to restrict the behaviour of its base class, but require that all inherited \nmethods are reveri.ed (Parkinson and Bierman 2005). Neither of these approaches are satisfactory and \none of the aims of this work was to remove these restrictions. Now let us consider code reuse and the \nDCell class in Figure 1. Asfar as we areaware, most systems (forexample, Barnett et al. (2005);M\u00a8uller \n(2002)) cannot cope with this use of inheritance. The intention is that instances of class DCell always \nstore double the value they have been set to. This use of inheritance is quite subtle; we have declared \nclass DCell as a derived class essentially to enable us to inherit the get method code. However, it is \nclear that instances of DCell behave quite differently from instances of Cell, which is at odds with \nour assumptions of behavioural subtyping. (It s an instance of the inheritance is not subtyping phenomenon \n(Cook et al. 1990).) Whilst such programming techniques are obviously fragile, it is our experience that \nthis use of inheritance is quite common in the developer community. So, we aim to verify such uses of \ninheritance. To summarize, our overall intention is to provide a .exible framework to allow programmers \nto formally specify and verify the behaviour of their object-oriented code. In this paper we con\u00adcentrate \nspeci.cally on verifying code that uses inheritance: where a class can re-use, extend or alter the representation \nand operations of its base class.We also imposea minimal setof requirements for anysolution to this problem: \nSoundness: We insist that our solution is sound, by which we mean that a veri.ed program will satisfy \nits speci.cation. Modular: We insist that our solution is modular, by which we mean that when new components \nare added to the system, no old component needs to be re-speci.ed or re-veri.ed. No base class code required: \nAn inherited method need never be reveri.ed, or, alternatively, a class need not see the code of its \nbase class (Ruby and Leavens 2000). Breadth: This is a harder criteria to quantify, but we insist that \nour approach can verify the typical patterns of inheritance use in real-world software. In this case, \nwe wish to support special\u00adization, overriding and code re-use. 1.2 Our proposal Our proposal for supporting \ninheritance builds on our earlier work (Parkinson and Bierman 2005) that developed a separation logic \nfor reasoning about object-oriented code. Separation logic offers a particularly good framework as it \nsupports local reason\u00ading about stateful computation (Reynolds 2002) and hence deals directly with issues \nof ownership and state modi.cation (in other systems these require additional complications to the underlying \nframework). In earlier work (Parkinson and Bierman 2005) we proposed the notion of abstract predicate \nfamilies to deal with the simple case of inheritance where every method is either overridden, or reveri.ed \nin the derived class. Previously, when we veri.ed a method body s for class C with pre-condition P and \npost-condition Q, we veri.ed the following. . \u00af.\u00af P . this:Cs Q The type information, this:C, enables \nthe use of abstract predicate families, but prevents inheritance of methods without reveri.ca\u00adtion: the \nveri.cation is speci.c to a single class. In this work, we provide a generalized logic that allows these \nrestrictions to be lifted.For each method, we require two speci.\u00adcations: a static speci.cation, that \nis used to verify the implemen\u00adtation and direct method calls (in Java this would be with a super call); \nand a dynamic speci.cation, that is used for calls that are dy\u00adnamically dispatched; along witha simple \nrelationship between the two speci.cations. Only the dynamic speci.cation is involved with behavioural \nsubtyping. We will demonstrate the use of dynamic and static speci.ca\u00adtionsbyexample,but .rstwe must \nrecap some detailsof abstract predicatesand abstract predicatefamilies.An abstract predicatehas a name,a \nde.nition, anda scope.Within the scope one can freely swap between using the abstract predicate sname \nand its de.nition, but outsideits scopeit mustbe handled atomically,i.e.byits name. Thus the scope de.nes \nthe abstraction boundary for the abstract predicate. Whilst this handles simple modules, it is not powerful \nenough to deal with object-oriented abstraction, as we wish each class to be able to provide its own \nde.nition of the predicate. To dealwith this, we introduced the notion of an abstract predi\u00adcatefamily. \nInformally,it canbe seen asa dynamically dispatched predicate. Just as the code for a method invocation \nis chosen based on the dynamic type of the instance parameter, we mirror this dis\u00adpatch behaviour in \nthe logic. An abstract predicatefamily uses its .rst argument to choose the de.nition of the predicate, \ni.e. if the .rst argument is of type C then the de.nition of the abstract predi\u00adcatefamilyis the one \nthat class C de.nes: x : C . (a(x, y) . aC(x, y)) where a is an abstract predicatefamily, and aC is the \nde.nition for class C. Returning to our Cell example, we could de.ne an abstract predicatefamily Val(x, \nv), which for the Cell class is de.ned as x.val . v, that is when verifying the Cell class we assume: \nx : Cell . (Val(x, v) . x.val . v) Other classes are free to de.ne their own entry for the Val family. \nThis only speci.es the de.nition for the Cell class; all other classes are unspeci.ed, hence the proof \nis independent of their de.nition. Now let us specify the Cell class. We will give the dynamic speci.cation \nusing abstract predicate families to allow more be\u00adhavioural subtypes, and the static speci.cation will \nclosely mirror the actual implementation: class Cell { public int val; public virtual void set(int x) \ndynamic {Val(this, )}{Val(this, x)} static {this.val . }{this.val . x)} { ... } public virtual int get() \ndynamic {Val(this, x)}{Val(this, x) * ret = x} static {this.val . x}{this.val . x * ret = x} { ... }} \nThe static speci.cations describe precisely how the methods work, that is set modi.es the val .eld to \ncontain x;andget returns the value stored in the val .eld.3 The dynamic speci.cation is given in terms \nof the Val abstract predicatefamilyto enable derived classes to alter the behaviour. If the dynamic speci.cationwasgivenin \ntermsof the .elds ac\u00adcessed then a derived class would not be able to extend or alter the behaviour in \nany way (Leino 1998). Similarly if the static speci\u00ad.cation was given in terms of the abstract predicate \nfamily, then the derived class would not be able to inherit the method without knowing the hidden representation \n(Parkinson and Bierman 2005). Byproviding bothastatic and dynamic speci.cation, we can inherit methods \nwithout reveri.cation, and this also allows derived classes to alter the representation and behaviour \nif theyoverride methods. Let us return to the derived class DCell.We wish to provide a speci.cation that \nallowsittobeaconsideredabehavioural subtype of Cell in spite of its radically different behaviour. The \nDCell class must behave the same as its parent s dynamic speci.cation. If we de.ne the Val predicate \nfamily as false for the DCell then this proof obligation becomes trivial. x : DCell . (Val(x, v) . false) \nDCell ensures no client will ever have a Val predicate for a DCell. Therefore, in the Val-world , DCell \nis not a subtype of Cell (that is, a variable of static type Cell that satis.es Val will not point to \na DCell object). class DCell : Cell{ public override void set(int x) dynamic {Val(this, )}{Val(this,x)} \nalso {DVal(this, )}{DVal(this,x * 2)} {...} public inherit int get() dynamic {Val(this,v)}{Val(this,v) \n* ret = v} also {DVal(this,v)}{DVal(this,v) * ret = v} } Here we use also to mean satis.es both speci.cations, \nand inherit to providea new speci.cation for an inherited method.We intro\u00adducea new predicatefamily DVal, \nwhich de.nes the DCell s be\u00adhaviour.We specify DVal as4 x : DCell . (DVal(x, v) . x.val . v) 3We could \nmake the static speci.cation more abstract to prevent a derived class depending on the precise representations \nof its base class.We could introduce a new predicate ValCell(x, v) for the entry in the Val family: x \n: Cell . (Val(x, v) . ValCell(x, v)) This prevents the derived class depending on the unknown de.nition \nof the Cell class. As, we do in the rest of the paper. 4We could alternatively specify it as x : DCell \n. (DVal(x, v) . ValCell(x, v)) to be abstract in the Cell s representation. The DCell does satisfy the \nspeci.cation of Cell,but only vac\u00aduously. However, clients do not need to know the speci.cation is only \nvacuously satis.ed. Theywill never be able to observe this.  1.3 Contributions and content This paper \ncontains a number of novel contributions to the .eld of object-oriented veri.cation. We explore the power \nof our system by considering a number of examples that exhibit typical uses of inheritance. Manyof these \nexamples are not supported by existing techniques. (Some more direct comparisons are given in \u00a76.) More \nspeci.cally, the main contributions of this work are as follows. The separation of method speci.cations \ninto static and dy\u00adnamic speci.cations,  The formalization of the proof obligations resulting from this \nseparation,  An elegant generalization of the formalization of abstract pred\u00adicatefamilies based on \nhigher-order separation logic, and  Asystematic exploration of the expressive power of our logic by \nconsideringa numberof typical programsexploitingvarious aspects of inheritance.  The proof system de.ned \nin this paper is modular, and does not require a derived class to see the code of its base class to verify \nits method. It can support many uses of inheritance: where a derived class extends its base class, where \nit restricts the behaviour of its base class, where it changes the behaviour of its base class, and even \nwhere it changes the representation of its base class. No other proof system that we are aware of can \nhandle all of these uses of inheritance. The rest of the paper is structured as follows. In \u00a72we de.ne \na core object-oriented language with annotated method de.nitions. In \u00a73 we de.ne formally our proof system, \nbased on separation logic. In \u00a74 we show how to simplify the annotations. In \u00a75 we verifya numberofexample \nusesof inheritance.We concludein \u00a76 by comparing our proof systemto others.In AppendixA wegive an overview \nof the semantics of our proof system. 2. Aprogramming language with speci.cations In this section we \nde.ne formally both the core object-oriented language we verify and the associated annotations. 2.1 Syntax \nOur core language is an extended, featherweight fragment of C0 called FVC0 (for FeatherweightVeri.edC0), \nthat is similar to var\u00adious formalized fragments of Java (Flatt et al. 1997; Bierman et al. 2004). The \nmainextension toC0 is that we annotate method de.\u00adnitions with static and dynamic speci.cations. The \nsyntax of FVC0 class de.nitions, method de.nitions, and statements is de.ned as follows. FVC0 programs \nL ::= class C: D{ public T f; A K M } Class de.nitions A ::= de.ne aC(x) as P PredicateFamily Entry K \n::= public C() Sd Ss {s} Constructor M ::= Method de.nition public virtual C m(D x) Sd Ss B Virtual method \npublic override C m(D x) Sd Ss B Overridden method public inherit C m(D x) Sd Ss; Inherited method Sd \n::= dynamic S Dynamic speci.cation Ss ::= static S Static speci.cation S ::= Method speci.cation {P }{Q} \nS also {P }{Q} B ::= { C x; s return y; } Method body s ::= Statement x = y; Assignment x= null; Initialization \nx = y.f; Field access x.f =y; Field update x = y.m(z); Dynamic method invocation x = y.C::m(z); Direct \nmethod invocation x = (C)y Cast if(x == y){s} else {t} Equality test x= new C(); Object creation In the \nsyntax rules we assume a number of metavariables: f ranges over .eld names, C,D over class names, m over \nmethod names, and x, y, z over programvariables.We assume that the set of program variables includes \na designated variable this, which cannot be used as an argument to a method (this restriction is imposed \nby the typing rules). We follow Featherweight Java, or FJ (Igarashi et al. 2001), and use an overbar \nnotation to denote sequences. As with FJ, for simplicity we do not include anyprimitive types in FVC0, \nand we assume that there is a distinguished class Object thatisattherootofthe inheritance hierarchy.Wedonot \nformalize the type system of FVC0 here as it is entirely standard. AFVC0 class de.nition, L, contains \na collection of .elds and method de.nitions and, for simplicity,a single constructor.A.eld is de.nedbya \ntype anda name.A virtual method de.nition, M, is de.ned by a return type, a method name, an ordered list \nof arguments where an argument is a variable name and a type a method speci.cation, S, and a method body, \nB. A method speci.cation consists of a dynamic speci.cation, Sd, and a static speci.cation, Ss, each \nconsisting of a sequence of pre-and post-conditions separated by also. The use of these was informally \npresented in the previous section, and the formal conditions on their use is given later. In \u00a74 we show \nhow one can drop one or the other speci.cation, but in our featherweight language we insist on both speci.cations \nto help in the de.nitions. We also insist that all inherited methods are explicitly speci.ed in the derived \nclass. This is partly to simplify some de.nitions, but also to allow derived classes to provide new speci.cations \nfor inherited methods. Clearly, outside the formalization we would not insist on specifying inherited \nmethods in which case it would be assumed that the method speci.cations were inherited also. Amethod \nbody,B, consists of a number of local variable dec\u00adlarations, followedbya sequenceof statements anda \nreturn state\u00adment. The real economy of FVC0 is that we do not have anysyn\u00adtacticformsforexpressions(oreven \npromotableexpressions(Bier\u00adman et al. 2004)), and that the forms for statements are syntactically restricted. \nAll expression forms appear only on the right-hand side of assignments. Moreover expressions only ever \ninvolve variables. In this respect, our form for statements is reminiscent of the A\u00adnormal form for .-terms \n(Flanagan et al. 1993).Astatement, s, is either an assignment, a .eld access, a .eld update, a method \ninvo\u00adcation, a cast, a conditional, or an object creation. In addition, we support direct method invocations \nusing a C++-style syntax, e.g. c.C::m(y). This syntax subsumes the standardC0 base calls:in a class derived \nfrom a base class B, the statement x=base.m(y) in C0 is written as x=this.B::m(y) in FVC0 . In FVC0 we \nfollow FJ and simplify matters by not consider\u00ading overloading of methods or constructor methods. In \nspite of the heavy syntactic restrictions, we have not lost any expressivity; it is quite simple to translate \na more conventional calculus with expres\u00adsions and promotableexpressions into FVC0. Another advantage \nof our approach is that we have no need for the stupid rules of FJ. In FVC0 we assume a rather large \namount of syntactic regular\u00adity to make the de.nitions compact. All class de.nitions must (1) include \na supertype; (2) start with all the declarations of the vari\u00adables local to the method (hence a method \nblock is a sequence of local variable declarations, followed by a sequence of statements); (3) have a \nreturn statement at the end of every method; and (4) write out .eld accesses explicitly, even when the \nreceiver is this.  2.2 Dynamic semantics The dynamic semantics of FVC0 are routine and are omitted. \nHow\u00adever, it is interesting to compare the reduction rules for the two forms of method invocations. These \nare as follows. mbody(C, m)=(z '. , B) B = Cx; s return x; . =[y1, z , x '/this, z , x] . S. z , x . \nfresh = S[z' . S(z)] S, H, y0 = y1.C::m(z);s -. S', H, (.s ')y0 = (.x '); s ' type(H(S(y))) = C S, \nH, x = y.C::m(z); s -. S',H. , s S, H, x = y.m(z); s -. S',H. , s . We de.ne the dynamic semantics in \nterms of transitions be\u00adtween con.gurations.Acon.gurationisatriple S, H, s consisting of (1) a stack \nS, which is a map from identi.ers to heap addresses; (2) a heap H, which is a map from heap addresses \nto object rep\u00adresentations, where an object representation has a type and a map from .eld name to addresses; \nand (3) a sequence of statements, s, which is the program being evaluated. The interesting feature of \nthe (dynamic dispatch) method invo\u00adcation transition rule is its use of a direct method invocation. 3. \nFormalizing the proof system In this section we formalize the proof system for reasoning about FVC0 programs. \nAn overview of the semantics of this system is given in Appendix A. 3.1 Logic syntax In this subsection \nwe de.ne the fragment of separation logic that we use to reason about our FVC0 programs.Formulae, P are \nde\u00ad.ned by the following grammar, where x, y, z ranges over variable names, a rangesover predicates.We \nencode the restof the usual connectives. Formulae P,Q ::= .x.P | P . Q | false | a(x) | e = e . | x : \nC | x.f . e | P * Q | P -* Q e ::= x | null Separation logic (Ishtiaq and O Hearn 2001; O Hearn et al. \n2001; Reynolds 2002) is an extension to Hoare logic that permits reasoning about shared mutable state. \nIt extends Hoare logic by adding spatial connectives to the assertionlanguage, which allow us to assert \nthat two portions of the heap are disjoint, that is P * Q means the heap can be split into twodisjoint \nparts in which P and Q hold respectively. Space prevents us from giving a more thorough introduction; \nthe reader is referred to the tutorial by Reynolds (2002) fora general introduction, and toParkinson \n(2005) for an introduction to the use of separation logic for verifying object\u00adoriented programs. We \nde.ne an environment, G, that contains the static and dynamic speci.cations speci.ed in a FVC0 program. \nWe write C.m(x): {P }{Q}. G to denote that G contains the dynamic speci.cation {P }{Q} that is associated \nwith the method m with parameters x de.ned in class C. Similarly C::m(x) : {S}{T }. G denotes that G \ncontains the static speci.cation {S}{T } that is as\u00adsociated with the method m with parameters x de.ned \nin class C. We assume two special speci.cationsC..ctor() and C::.ctor() for the static and dynamic speci.cations \nof the constructor of class C. We also need to de.ne an environment,., that stores the ab\u00adstract predicatefamiliesand \ntheir de.nitions.Inpreviouswork(Parkin\u00adson and Bierman 2005), we de.ned this as a set of predicate def\u00adinitions, \nalong with some complicated rules for controlling its use. One contribution of this paper is to utilize \nsome observa\u00adtions originating from more recentwork on higher-order separation logic (Bieringetal.2007),to \nsimplifythis representation.Wegive the details in \u00a73.2,but for now the reader can just consider . as \ncontaining the abstract predicatefamilies and their de.nitions. The judgements for reasoning about FVC0 \nprograms are of the form .; G f{P }s{Q}, meaning that given environments G and ., the statement sequence \ns satis.es the speci.cation {P }{Q}. The axioms and rules for forming valid judgements can be divided \ninto structural rules and program rules . The structural rules are those that work independently of the \nprograms, i.e. they manipulate purely the pre-and post-conditions. These have been given elsewhere for \nseparation logic (Parkinson 2005), so we do not repeat them here except for the frame rule , as it is \ncrucial to the local reasoning principle of separation logic. It is de.ned as follows. .; G f{P }s{Q} \n.; G f{P *R}s{Q *R} The program rules for forming valid judgements have also been given elsewhere. However, \nwe give below the rules for both forms of method invocation. First, the rule for dynamic dispatch invoca\u00adtion, \nwhich is as follows.5 x has static type C C.m(x): {P }{Q}.G .; G f{P [x, y/this,x] .this = null}z = x.m(y) \n{Q[z, x, y/ret, this,x]} The rule for direct method calls is similar, except that the static speci.cation \nis used. C::m(x): {S}{T }.G .; G f{S[x, y/this,x] .this = null}z = x.C::m(y) {T [z, x, y/ret, this,x]} \nFinally, we give the rule for constructing a new object. C..ctor(): {P }{Q}.G .; G f{P }x = new C(){Q[x/this]} \n 3.2 Abstract predicate families Nextweexplainhowwe represent abstract predicatefamiliesinthis framework \n(Parkinson and Bierman 2005). Rather than presenting a syntax for a context and rules for manipulating \nand using this context, we simply de.ne our context, ., as a conjunction of formulae from our logic: \n. ::= P |.1 ..2 |.a.. The existential is used to hide redundant de.nitions. 5To simplify the presentation, \nwe assume that the return variable, z, is not an argument or the instance parameter (receiver). This \nrestriction can be satis.ed trivially by adding an additional assignment to a fresh vari\u00ad ' able z' before \nthe rule and replacing the uses of z by z': z= z; z = x[z'/z].m(y[z'/z]) By using a formula from the \nlogic the work can be connected with developments in higher-order separation logic (Biering et al. 2007;Nanevskietal.2007; \nKrishnaswamietal.2007).To simplify the presentation we do not use the full generality of higher-order \nseparation logic in this paper: we simply require a second-order quanti.er. Now let us consider representing \npredicate de.nitions in this way.Wemight wishto de.neapredicatebyde.ne Point(x, v) as x.f . v, this can \nbe seen as saying the following formula is true: .x, v. Point(x, v) .x.f .v However, this is not powerful \nenough to reason about object\u00adoriented abstractions. Due to dynamic dispatch, a method call is chosen \nbased on the dynamic type of the instance parameter. Here we mirror this in the logic as the predicate \nde.nition is cho\u00adsen by the dynamic type of the .rst parameter. So we could say de.ne PointC(x, v) as \nx.f . v, which would mean two things: (1) the entry for the abstract predicate family Point is PointC; \nand (2) this entry is de.ned as x.f . v. These statements can be provided by the following (.x, v. PointC(x, \nv) .x.f .v) .(.x,v. x : C .(PointC(x, v) .Point(x, v))) Asa naming convention, we will use names, a, \nwithout a subscript to represent an abstract predicate family, and with aC to represent the entry for \nclass C infamily a. The role of the predicate arguments can be seen as analogous tothe useof model .eldsin \notherwork(LeinoandM\u00a8uller 2006). Derived classes generally introduce more model .elds, hence we wishto \ninterpretapredicateat manyarities.Toencode model .elds more directlywecouldpassarecordratherthanalistofarguments. \nThe implication below would then correspond to width subtyping and forgotten .elds are existentially \nquanti.ed. Returning to our point example, we might wish to be able to forget the outer most argument \nas a base class does not use this parameter: Point(x) ..v. Point(x, v) We can now de.ne the formal translation \nof a de.nition to a logical assumption. We break the translation into three parts: (1) family to entry,FtoE(a, \nC) isa formula that connects thefamily, a, with the entry aC assuming the .rst argument is of type C;(2) \nentry to de.nition, EtoD(de.ne aC(x, x) as P ) is a formula that connects the entry aC with the de.nition \nP ;and (3) changing arity, A(a; n) de.nes thatfamily a can be given any arity less than n and the missing \nvalues are existentially quanti.ed. def FtoE(a, C)= .x,x. x : C .(a(x, x) .aC(x, x)) EtoD(de.ne aC(x, \nx) as P ) def = .x,x. aC(x, x) .P def A(a; n +1) = A(a; n). .y1,...,yn.a(y1,...,yn) ..z. a(y1,...,yn,z) \ndef A(a; 0) = true We can translate an entry de.nition as (1) the formula connect\u00ading thefamily with \nthe entry; (2) the formula connecting the entry with the de.nition; and (3) the formula specifying that \nthe arity can be reduced. apf C(de.ne aC(x, x) as P ) def = FtoE(a, C) .EtoD(de.ne aC(x, x) as P ) .A(a; \n|x|) apf (class C: D{public T f; A1 \u00b7\u00b7\u00b7An KM }) def = apf C(A1) .\u00b7\u00b7\u00b7.apf C(An) We have two rules to reason \nabout these assumptions. The .rst allows us to strengthen our assumptions. If we can prove our program \nwith just the assumptions ., then we can prove it with the weaker assumptions . ' . . ' . . .;G f{P }s{Q} \nP-Weak . ' ;G f{P }s{Q} The second proof rule allows the removal of predicates: this is the second-order \nanalogy of the logical/ghost/auxilliary variable elimination rule. a/. FP(P , Q, G) .;G f{Q}s{R} P-Elim \n(.a. .); G f{Q}s{R} where FP(P, Q, G) is the set of free predicate names in P , Q and G. Finally, the \nrule of consequence is modi.ed to take account of the environment .. . . (P . P ' ) .;G f{P ' }s{Q ' \n} . . (Q ' . Q) .; G f{P }s{Q} 3.3 Re.nement and behavioural subtyping Anumber of authors have offered \nde.nitions of behavioural sub\u00adtyping,butin thiswork we follow Leavens and Naumann (2006) and proposea \nformulationintermsofanatural re.nement orderon speci.cations.We say thata speci.cation {P2}{Q2} re.nes \nan\u00adother speci.cation {P1}{Q1}, if for all programs s, if s satis.es the latter speci.cation, then it \nalso satis.es the former. We characterize6 speci.cation re.nement using the structural rules of Hoare \nand Separation logic (Consequence, Frame, Logical7 variable elimination); that is, there exists a proof \nof the form . f{P1}{Q1} . . . . f{P2}{Q2} When such a proof exists, we write . f{P1}{Q1} =. {P2}{Q2}. \nWe often need to introduce some type information in speci.cation re.nement.Todo so, we de.ne this: C \n. f{P1}{Q1} =.{P2}{Q2} def =. f{P1}{Q1} =.{P2 * this: C}{Q2}Weoften need to combine speci.cations. This \nis written asalso, and is encoded as follows using logical (auxiliary) variables. .\u00af.\u00af .\u00af.\u00af De.nition \n1. P1 Q1 alsoX P2 Q2 is de.ned as .\u00af. \u00af (P1 . X=1) . (P2 . X (Q1 . X=1) . (Q2 . X=1) =1) We omit the \nX to mean selecting a fresh variable. In our ver\u00adi.cation rules, we omit also by encoding the speci.cations \ninto a single speci.cation. Lemma 2. 1. . f ({P1}{Q1} also {P2}{Q2})=.{P1}{Q1} 2. . f ({P1}{Q1} also \n{P2}{Q2})=.{P2}{Q2}  3.3.1 Method veri.cation There are three forms of method de.nitions in FVC0. A \nmethod can be de.ned (1) as virtual, if it is not de.ned in its base class; or (2) as inherit, if it \nis not de.ned in this class,but is de.ned in its base class; or (3) as override, if it is de.ned both \nby this class and its base class.For each of these types of method de.nitions, we will provide the appropriate \nveri.cation rule. The judgement form is written as .; G f M in E, which means informally that given environments \nG and ., the method de.nition M in class 6We currently do not have an adaption completeness result for \nour proof system, and so we cannot assert whether our syntactic characterization of re.nement is complete. \nYang s thesis provides an adaption completeness result for separation logic without object-oriented features(Yang \n2001). 7Sometimes called auxiliary or ghost variables. E can be veri.ed to meet its speci.cation. (In \nwhat follows we write C -1 D when class D is the immediate base class of derived class C, i.e. class \nC : D { ... }. Additionally, to simplify the presentation, we assume that methods do not modify the variables \ncontaining the arguments. Methods can be trivially rewritten to this form.) First, we de.ne the rule \nfor verifying a new virtual method. B = { G y; s return z; } Sd = dynamic {PE}{QE} Ss = static {SE}{TE} \nthis: E . f{SE}{TE} =.{PE}{QE} (Dynamic dispatch) .; G f{SE}s{TE[z/ret]} (Body Veri.cation) .; G f public \nvirtual C m(D x) Sd Ss B in E In this case there are just two proof obligations: we must ver\u00adify that \n(1) the method body meets its static speci.cation,(Body Veri.cation); and (2) using the dynamic speci.cation \nis valid for dynamic dispatch,(Dynamic dispatch). This second proof obliga\u00adtion forces a relationship \nbetween the static and dynamic speci.ca\u00adtions of a method. It corresponds to showing that if the object \nhas type E and the dynamic speci.cation is satis.ed by the client, then the method body willexecute successfully. \nNotice thatbyusing the static speci.cation we do not have to verify the body against the dynamic speci.cation. \nNext, we de.ne the veri.cation rule for inheriting a method. E -1 F Sd = dynamic {PE}{QE} Ss = static \n{SE}{TE} F.m(x): {PF}{QF}. G F::m(x): {SF}{TF}. G . f{PE}{QE} =.{PF}{QF} (Behavioural Subtyping) . f{SF}{TF} \n=.{SE}{TE} (Inheritance) this: E . f{SE}{TE} =.{PE}{QE} (Dynamic dispatch) .; G f public inherit C m(D \nx) Sd Ss; in E In this case there are three proof obligations: we must verify that (1) the new dynamic \nspeci.cation is a valid behavioural subtype, (Behavioural Subtyping); (2) the method meets the static \nspeci.\u00adcation,(Inheritance); and (3) (as before) using the dynamic spec\u00adi.cationisvalid for dynamic dispatch,(Dynamic \ndispatch). The .rst proof obligation amounts to requiring that whenever it is valid to use the dynamic \nspeci.cation of the base class, it is also valid to use the dynamic speci.cation of this class, E. The \nsecond proof obligation amounts to showing that the inherited method body sat\u00adis.es the new static speci.cation. \nHowever, this rule does not use the inherited method body at all; it is not needed. The rule works purely \nat the level of the speci.cations. Finally, wegive theveri.cation rule foroverridinga method. E -1 F \nF.m(x): {PF}{QF}. G B = { G y; s return z; } Sd = dynamic {PE}{QE} Ss = static {SE}{TE} . f{PE}{QE} =.{PF}{QF} \n(Behavioural Subtyping) this: E . f{SE}{TE} =.{PE}{QE} (Dynamic dispatch) .; G f{SE}s{TE[z/ret]} (Body \nVeri.cation) .; G f public override C m(D x) Sd Ss B in E Again there are three proof obligations: we \nmust verify that: (1) the new dynamic speci.cation is a valid behavioural subtype, (Behavioural Subtyping); \n(2) the method body meets the static speci.cation,(Body Veri.cation);and (3) using the dynamic spec\u00adi.cationisvalid \nfor dynamic dispatch,(Dynamic dispatch). This veri.cationis almost identicaltotheprevious,butherewecanver\u00adify \nthe body of the method against the static speci.cation as it is de.ned in this class, E. The second veri.cation \nrule has a degenerate (but common) form, whena derived class inheritsa method froma base classbut does \nnot provide a new speci.cation. In this case, the veri.cation rule degenerates to the following. E -1 \nF F.m(x): {PF}{QF}. G F::m(x): {SF}{TF}. G this: E . f{SF}{TF} =.{PF}{QF} (Dynamic dispatch) .; G f \npublic inherit C m(D x); in E There is just one proof obligation, which amounts to verifying that if \nthe object has type E and the dynamic speci.cation of the base class is satis.ed by the client, then \nthe method body will satisfy the speci.cation. Again, it is worth pointing out that this proof obligation \nis at the level of the speci.cations; we do not need the inherited method body from the base class. Finally, \nwe need a special veri.cation rule for a constructor method de.nition. This is as follows. E -1 F .elds(E)= \nf1,..., fn F::.ctor(): {SF}{TF}. G Sd = dynamic {PE}{QE} Ss = static {SE}{TE} this: E . f{SE}{TE} =.{PE}{QE}.; \nG f{TF * R * Fs}s{TE} (Body Veri.cation) SE . SF * true R . SF --SE Fs = this.f1 .* ... * this.fn . .; \nG f public E() Sd Ss {s} This rule is complicated by the implicit base call at the beginning of the constructor, \nthat is, before the constructor body s begins executing, the base class constructor is executed. When \nverifying the body (Body Veri.cation) the pre-condition is composed of three things: (1) the post-condition \nof the base class constructor call, (2) a formula R which intuitively is the disjoint state required \nby the constructor (and hence is given by the formula SF --SE 8), and (3) a representation of the .elds \nde.ned in E but not including the .elds inherited from the base class.  3.4 Class veri.cation We cannow \nusethe methodveri.cation rulesgivenabovetoverify a de.nition. The rule is as follows. .Mi . M. .; G f \nMi in C .; G f K .; G f class C: D{ public T f; A K M } Informally, this means that to verify a class \nde.nition one must verify every method. The rule for verifying a complete program is then as follows. \nG= specs(L1 ... Ln) apf (L1); G f L1 \u00b7\u00b7\u00b7 apf (Ln); G f Ln true;G f{true}s{true} f L1 ... Lns Informally, \nthis rule states that under the assumption that all the speci.cations are correct, every class de.nition \nmust be veri.ed,9 along with verifying the main body, s. Properties Given the proof rules above, we can \nnow reconsider the criteriagivenin \u00a71.1. First, our proof system is sound. Theorem 3. The program veri.cation \nrule is sound. (See Ap\u00adpendixAfora formal statementof soundness and anoverviewof the proof.) 8P --Q is \nde.ned as \u00ac(P -* \u00acQ) and intuitively means subtracting P from Q. 9This assumption is valid as we are \nonly dealing with partial correctness. Secondly, our system is modular, i.e. the introduction of new \nmethods or classes does not invalidate an existing proof. Thirdly, each method body is veri.ed only once, \neven when de.ning an overridden method or inheriting a method from the base class. Finally, in \u00a75 we \nconsider the applicability of our system by considering a number of typical uses of inheritance in object\u00adoriented \ncode. 4. Simplifying annotations In many cases the dynamic and static speci.cations turn out to bevery \nsimilar.Fortunately, thereisa relatively simple processto derive the static speci.cation from the dynamic, \nand vice versa. Deriving static from dynamic We give a syntactic opening function, [P ]C , which opens \nall the abstract predicate families in P on the object this at type C. That is, def [a(this,x)]C = aC \n(this,x) def [a(y, x)]C = a(y, x) where y = this def = [aD(x)]C aD(x) def [pr(x)]C = pr(x) def [false]C \n= false def [P opQ]C = [P ]C op [Q]C where op ::= * |.| -* def [.x. P ]C = .x. [P ]C where pr(x, y) is \neither x.f . y, x = y and x : C. Lemma 4. this : C = . (P . [P ]C ) .\u00af.\u00af Hence, given a dynamic speci.cation \nPQ , we can de\u00ad . \u00af. \u00af rive the static speci.cation [P ]C [Q]C , which automati\u00adcally satis.es the(Dynamic \ndispatch)proof obligation. .\u00af..\u00af.\u00af \u00af this:C Lemma 5. [P ]C [Q]C =. PQ . \u00af. \u00af [P ]C [Q]C . \u00af. \u00af Frame \nProof. [P ]C * this:C [Q]C * this:C . \u00af.\u00af Conseq P * this:CQ Both the static speci.cations of the set \nand get methods of Cell can be inferred in this way. Deriving dynamic from static If we only provide \na static speci.\u00adcation for a method, we assume the dynamic speci.cation is iden\u00adtical to the static speci.cation. \nThis also satis.es the(Dynamic dispatch)proof obligation trivially. 5. Examples In this section we give \na number of examples to demonstrate the power and applicability of our proof system. All our examples \ninvolve inheritance of the Cell class that we described in \u00a71.For completeness we give the complete de.nition \nof the Cell class, including the abstract predicatefamilies and method speci.cations, in Figure 2. Before \nwe consider inheriting this class, we should .rst ver\u00adify thatit meets itsown speci.cation!Forthe three \nvirtual meth\u00adods, this means the two proof obligations,(Body Veri.cation)and (Dynamic dispatch). Luckily, \nfor all three methods the latter proof obligationis satis.ed following Lemma5.Wegive belowaveri.\u00adcation \nof the set methodbody,and suppresstheveri.cationsof get and swap. {ValCell(this, )} {this.val .}this.val=x;{this.val \n. x}{ValCell(this, x)} class Cell { int val; de.ne ValCell(x, v) as x.val . v public Cell() dynamic {true}{Val(this, \n)} {} public virtual void set(int x) dynamic {Val(this, )}{Val(this, x)} {this.val=x;} public virtual \nint get() dynamic {Val(this,v)}{Val(this,v) * ret = v} { return this.val; } public virtual void swap(Cell \nc) static {Val(this,v1) * Val(c,v2)}{Val(this,v2) * Val(c,v1)} { int t,t2; t = this.get(); t2 = c.get(); \nthis.set(t2); c.set(t); } } Figure 2. Source code for Cell examples Before turningtoderivingfromthis \nclass,we considerinalittle more detail the swap method. It is an example of the template method pattern \n(Gamma et al. 1994). It does not manipulate the data directly, but simply uses other methods to update \nthe state. This allows the code to be reused in derived classes that alter the representation. Hence \nit is interesting to consider the consequences of inheriting this method in some derived class, C, of \nCell. If the derived class C inherits swap and does not alter its speci.cation, then its only proof obligation \nis(Dynamic dispatch)which follows trivially (using the rule of consequence) as follows. . \u00af. \u00af Val(this,v1)*Val(c,v2) \nVal(this,v2)*Val(c,v1) . \u00af.\u00af Val(this,v1)*Val(c,v2)*this:C Val(this,v2)*Val(c,v1) Thus, anyderived class \nis essentially free to inherit this method. It is particularly interesting to explore the consequences \nof different implementations of the swap method and the effects on the ability of derived classesto inherit \nthis method.Forexample, considerif we had implemented swap using direct .eld access on the object, e.g. \npublic virtual void swap1(Cell c) dynamic {Val(this,v1) * Val(c,v2)}{Val(this,v2) * Val(c,v1)} static \n{ValCell(this,v1) * Val(c,v2)}{ValCell(this,v2) * Val(c,v1)} { int tmp = c.get(); c.set(this.val); this.val \n= tmp; } The proof obligation to inherit this method would impose a constraint on anyderived class.Abetter \nalternativewould probably be to override the method. Amore optimised implementation ofswap could directly \naccess the .elds of c as well. public virtual void swap2(Cell c) static {Val(this,v1) * Val(c,v2)}{Val(this,v2) \n* Val(c,v1)} { int tmp = c.val; c.val = this.val; this.val = tmp; } For the proof obligations to be \nsatis.ed, this would effectively impose a global constraint on all derived classes of Cell, that they \npreserve the usage of the val .eld:10 Val(x, v) . ValCell(x, v) * ValLeft(x) (1) This kind of constraint \nis analogous to the condition in other work (M\u00a8uller 2002) that derived class invariants cannot restrict \n10Our programveri.cation rulesdo not directly support this constraining of derived classes,but this couldbe \ntrivially added. class Recell : Cell{int bak; de.ne ValRecell(x, v, o) as ValCell(x, v) * x.bak . o public \nRecell () dynamic {true}{Val(this,, )} {} public inherit int get() dynamic {Val(this, v, o)}{Val(this, \nv, o) * ret = v} public override void set(int x) dynamic {Val(this, v, )}{Val(this, x,v)} { this.bak \n= this.Cell::get(); this.Cell::set(x); } public virtual void undo() dynamic {Val(this, v, o)}{Val(this, \no, )} { int tmp = this.bak; this.Cell::set(tmp); } } Figure 3. The Recell class the base class invariant. \nThe derived class must de.ne a mean\u00ading for the predicatefamily ValLeft. As we see later, this kind of \nconstraint prevents manyuseful subtypes. 5.1 Specialisation: Recell Now let us consider Recell,a derived \nclass of Cell, which addition\u00adally stores the previous value that was set to allow undo. The code isgivenin \nFigure3.We considerthe methodsin turn: First,letus consider the get method.We mustshow thatitisvalidto \ninherit this method into the Recell class. First, we need to verify the proof obligation(Inheritance)i.e. \nto show that the static speci.cation of the method in Recell re.nes the Cell static speci.cation. This \ncan be proved as follows. .\u00af. \u00af ValCell(x, v) ValCell(x, v) * ret=v j.j. Frame ValCell(x, v) ValCell(x, \nv) * x.bak.o * ret=v * x.bak.o .\u00af. \u00af Conseq ValRecell(x, v, o) ValRecell(x, v, o) * ret=v This proof \ndoes not depend on either the internal representation of the Cell class or the body of the get method, \nonly the static speci.cation of the Cell class andthe internal representationof the Recell class. Second, \nwe need to verify the proof obligation(Behavioural Subtyping), i.e. we must show that the Recell s dynamic \nspeci.ca\u00adtion of the get method is a valid behavioural subtype of the Cell s speci.cation. This can be \nproved as follows. .\u00af. \u00af Val(this, v, o) Val(this, v, o) * ret=v .\u00af. \u00af VarElim .o. Val(this, v, o) .o. \nVal(this, v, o) * ret=v .\u00af. \u00af Conseq Val(this,v) Val(this,v) * ret=o Note that this proof uses the arity \nmanipulation described in \u00a73.2. Now, we turn our attention to the set method. The .rst proof obligation,(Body \nVeri.cation), can be proved as follows. {ValRecell(this, v, )}{ValCell(this,v) * this.bak .} tmp = this.Cell::get(); \n{ValCell(this,v) * this.bak .* tmp = v} this.bak = tmp; {ValCell(this,v) * this.bak . v} this.Cell::set(x); \n{ValCell(this,x) * this.bak . v}{ValRecell(this, x, v)} class TCell : Cell {int val2; de.ne ValTCell(x, \nv) as ValCell(x, v) * x.val2 . v TCell() dynamic {true}{ValTCell(this, )} {} public override void set(int \nx) dynamic {Val(this, )}{Val(this, x)} { this.val2=x; this.Cell::set(x); } public virtual void check() \ndynamic {Val(this,x)}{Val(this,x)} { int tmp = this.Cell::get(); if(this.val2 != tmp) crash(); } } Figure \n4. The TCell code The proof obligation(Behavioural Subtyping)is proved almost identically as for the \nget method. .\u00af. \u00af Val(this, v, ) Val(this, x, v) .\u00af. \u00af VarElim .v. Val(this, v, ) .v. Val(this, x, v) \n.\u00af. \u00af Conseq Val(this, ) Val(this,x) The last proof obligation(Dynamic dispatch), can be shown simply \nand is omitted, as is the veri.cation of the undo method. Interestingly, this class can inherit all three \nversions of swap: we only need to provide proofs for swap1 and swap2.For swap1 we must show . \u00af. \u00af ValCell(this,v1) \n* Val(c,v2) ValCell(this,v2) * Val(c,v1) j.j. ValCell(this,v1) * Val(c,v2) ValCell(this,v2) * Val(c,v1) \n* this.bak .* this : Recell * this.bak .* this : Recell j.j. Val(this,v1) * Val(c,v2) Val(this,v2) * \nthis : Recell * Val(c,v1) For swap2 we must satisfy (1), which can done trivially by de.ning ValLeft \nfor Recell as this.bak . . 5.2 Restriction: TCell Now we consideraderived class, TCell, that restricts \nthe behaviour ofitsbaseclass.ThecodeisgiveninFigure4.It de.nesa.eld val2 that is expected to contain \nthe same value as would be returned by calling get. Every time the set method is called, both representa\u00adtions \nare updated, hence the check method should never be able to call crash. For this class, we must prove \nthat it is valid to inherit theget method,(Inheritance): .\u00af. \u00af ValCell(x, v) ValCell(x, v) * ret=v j.j. \nFrame ValCell(x, v) ValCell(x, v) * x.val2.v * ret=v * x.val2.v .\u00af. \u00af Conseq ValTCell(x, v) ValTCell(x, \nv) * ret=v We will omit the proof obligations for theset method. The check method requires that we prove(Body \nVeri.cation), which follows. {ValTCell(this, x)} {ValCell(this, x) * this.val2 . x} int tmp = this.Cell::get(); \n{ValCell(this, x) * this.val2 . x * tmp = x} if(this.val2 != tmp) { {ValCell(this, x) * this.val2 . x \n* tmp = x * tmp = x} {false}crash();{false} {ValCell(this, x) * this.val2 . x * tmp = x}}{ValCell(this, \nx) * this.val2 . x * tmp = x}{ValTCell(this, x)} class DCell : Cell {de.ne ValDCell(x, v) as false de.ne \nDValDCell(x, v) as ValCell(x, v) public inherit int get() dynamic {DVal(this,x)}{DVal(this,x) * ret = \nx}also {Val(this,x)}{Val(this,x) * ret = x} DCell() {} dynamic {true}{DValDCell(this, )} public override \nvoid set(int x) dynamic {DVal(this, )}{DVal(this, x * 2)}also {Val(this, )}{Val(this, x)}{ this.Cell::set(x \n* 2); }} Figure 5. The DCell class Hence, the method can never call crash when its pre-condition is met. \nNow, we consider inheriting the various swap methods. Firstly, swap can trivially be inherited. swap1 \ncannot be inherited: . \u00af. \u00af ValCell(this,v1) * Val(c,v2) ValCell(this,v2) * Val(c,v1) j.j. ValCell(this,v1) \n* Val(c,v2) ValCell(this,v2) * Val(c,v1) * this.val2 . v1 * this : TCell * this.val2 . v1 * this : TCell \nj.j. Val(this,v1) * Val(c,v2) ??? * this : TCell ??? Our prooffails because this.val2 . v1, so we cannot \nestablish the post-condition Val(this,v2) * Val(c,v1) as this requires the .eld to have been updated \nto this.val2 . v2. Hence, TCell would have to override the swap1 method. In addition, this class does \nnot satisfy (1) required by swap2. The state separate from ValCell depends on thevalue v,butValLeft doesnottakethisasanargument.Ifthis \nconstraintwas imposedon the system, then the TCell class would not be allowed. 5.3 Reuse: DCell In this \nexample we present a subtype of Cell that is not a well\u00adbehaved subtype in the traditional sense of behavioural \nsubtyping. We de.ne the classDCell in Figure 5; it is essentially a Cell that doubles thevalueitis set \nto. This breaks the standard substitutivity property, and hence is not allowed in other veri.cation method\u00adologies. \nHowever, as we shall see, it can be veri.ed in our proof system. We de.ne the predicate family for ValDCell \nto be false. This prevents clients calling a DCell using the Cell s interface. This re.ects that fact \nthat the use of inheritance in DCell is for code reuse.To inherit theget method we must show the(Inheritance) \nand(Behavioural Subtyping)proof obligations. The former can be proved as follows. .\u00af. \u00af ValCell(x, v) \nValCell(x, v) * ret=v .\u00af. \u00af ValCell(x, v) * x:DCell ValCell(x, v) * ret=v * x:DCell . \u00af.\u00af DVal(x, v) \n* x:DCell DVal(x, v) * ret=v The latter proof obligation follows directly from the de.nition of also \n(De.nition 1). Consider, the following client code of the DCell class. public void crash() dynamic {false}{false}{ \ncrash(); } public void f(Cell c, DCell d) dynamic {Val(c, ) * DVal(d, )}{Val(c, 5) * DVal(d, 10)} { \nclass SubRecell : Recell {Stack ints; de.ne ValSubRecell(x, v1,v2,l) as x.ints . i * Stack(i, v1 :: l) \n* ((l = [] . v2 = v1) . l = v2 :: ) SubRecell() dynamic {true}{Val(this,,, )} { ints = new Stack(); \nints.push(0); } public override int get() dynamic {Val(this,v1,v2,l)}{Val(this,v1,v2,l) * v1 = ret} \n{ return ints.readTop(); } public override void set(int x) dynamic {Val(this,v1,v2,l)}{Val(this, x,v1,v1 \n:: l)} { ints.push(x); } public override void undo() dynamic {Val(this,v1,v2,w2 :: l)}{Val(this,v2, \n,l) * v2 = w2}also {Val(this,v1,v2, [])}{Val(this,v2,, [])}{ if(ints.length()>1) this.ints.pop(); }} \nFigure 6. Recell with unbounded backup if(c.set(5).get() != 5) crash(); if(d.set(5).get() != 10) crash(); \n } The speci.cation for f amounts to showing that if the arguments c and d meet their speci.cations, \nthen the method body never invokes the crash method. Ordinarily, this would be very hard to establish \nas DCell is not normally considered to be a behavioural subtype of Cell. However, the power of the approach \ndescribed in this paper is that it is possible (and quite simple) to show that the method f meets it \nspeci.cation. The veri.cation proceeds directly from the dynamic speci.cations trivially. The .rst argument, \nc, can be any subtype of Cell that has the Val(c, ) predicate. Hence, we cannot call this with the .rst \nargument of type DCell. Surprisingly, the DCell class can validly inherit the swap1 method, and satisfy \nthe constraint (1) for swap2. The constraint is trivially satis.edby de.ning ValLeft for DCell as false. \nSimilarly, the swap1 method can be inherited trivially, as the speci.cations pre-condition is false for \nthis class, so the method will never be called. 5.4 Altering internalrepresentation: SubRecell Finally \nwe consider an example where we completely alter how data is represented in the base class. In Figure \n6, we present a derived class of Recell called SubRecell that has an unbounded undo capacity. The code \nuses a Stack to store the values, and does not update the redundant .elds it inherits from Recell;the \ncode is clearer and simpler by not using the parent .elds. As all the meth\u00adods are overridden this class \ncan be rather straightforwardly veri\u00ad.ed.We must simply show that each method satis.es the rule for behavioural \nsubtyping(Behavioural Subtyping), and the method bodies implement the speci.cation(Body Veri.cation). \nThe method swap can trivially be inherited as it does not depend on the representation. However, swap1 \ncannot be inherited as it assumes the original .elds are used. The constraint, (1), required for swap2 \ncannot be satis.ed by this class. 5.5 Interplay between static and dynamic calls Interestingly, the \nset method of Recell becomes considerably harder to verify if the call to get is turned into a dynamic \ncall, rather than a direct/super call, that is void set(int x) dynamic {Val(this, v, ) {Val(this, x,v)} \nstatic {Val(this, v, ) * Val TORecell(this)}{Val(this, x,v)} { int tmp = this.get(); this.bak = tmp; \nthis.Cell::set(x); } The increased dif.culty comes from considering all possible de\u00adrived classes. If \nthe derived class overrides the behaviour of get then this code could in.ict untold damage! Hence, we \nmust place a constraint on anymethod that inherits this code. This is done by adding Val TORecell to \nthe static pre-condition.We require that this predicate has the following properties Val TORecell(this) \n* Val(this, x, v) . ValRecell(this, x, v) * Val FROM Recell(this) ValRecell(this, x, v) * Val FROM Recell(this) \n. Val TORecell(this) * V al(this, x, v) If the derived class alters the representation too much, then \nit is not possible to .nd solutions to these equations. Finding these solutions can be simpli.ed11 to \nproving that the following is a tautology. .xv. Val(this, x, v)-* \u00ab ValRecell(this, x, v)* ''' '' .xv.ValRecell(this,x \n,v ' ) -* Val(this,x ,v ) The outer use of -* is theTO predicate, and the inner oneis the FROM predicate. \nWith this additional predicate we can perform the veri.cation,(Body Veri.cation), as follows: {Val(this, \nv, ) * Val TORecell(this)} tmp = this.get(); {Val(this, v, ) * Val TORecell(this) * tmp = v} {ValRecell(this, \nv, ) * Val FROM Recell(this) * tmp=v} {ValCell(this,v) * this.bak.* Val FROM Recell(this) * tmp=v} this.bak \n= tmp; {ValCell(this,v) * this.bak.v * Val FROM Recell(this)} this.Cell::set(x); {ValCell(this,x) * this.bak.v \n* Val FROM Recell(this)}{ValRecell(this, x, v) * Val FROM Recell(this)}{Val(this, x, v)} 6. Conclusionsandrelatedwork \nIn this paper we have considered the problem of verifying object\u00adoriented programs that use inheritance \nin a number of different ways.Wehave de.neda proof system that allowsa derived class to (1) simply extend \na base class(Recell); (2) restrict its base class s behaviour(TCell); (3) alter its base class s behaviour \nin a way incompatible with the standard view of behavioural subtyp\u00ading(DCell); and (4) replace the representation \nof its base class (SubRecell). Even in the presence of these drastic changes, we are still able to inherit \ncode without needing to see the actual imple\u00admentation.Asfarasweareaware,noother modularproofsystem can \nverify all of these examples. Poetzsch-Heffter andM \u00a8 uller (1999) present a logic with rules with both \nvirtual (dynamic) and implementation (static) speci.ca\u00adtions. However, theydo not explore the inter-relationship \nbetween the virtual and implementation speci.cations, and theydo not con\u00adsider how this distinction enables \nthe inheritance of methods with\u00adoutreveri.cation.The interactionwith inheritanceisthekeytothe examples \npresented in this paper. The Java Modelling Language, JML (Leavens et al. 2006), also has similar notions \nto static (known as code contracts) and dynamic 11 Some might say simplifying to uses of -* is not simplifying \nat all! speci.cations (known as non-code behaviour speci.cations). How\u00adever the treatment of these speci.cations \nis different. Code con\u00adtracts can be used to verify method invocations where the exact methodcanbe statically \ndetermined.JMLalsotakesadifferentap\u00adproach to verifying overridden methods. It requires a method in a \nderived class to be veri.ed against not only its speci.cation, but also against all the speci.cations \nin its base classes. This has the advantage of simplifying the framework (i.e. by eliminating proof\u00adtheoretic \nnotions such as re.nement),but ourworkis motivatedby wishing to avoid such repeated veri.cation of overridden \nmethods. Dhara and Leavens (1996) propose a relaxation of the JML approach by de.ning slightly more liberal \nrestrictions on the pre\u00adand post-conditions of a method in a derived class that ensure behavioural subtyping. \nJML does not currently de.ne restrictions on inheriting meth\u00adods. Addressing this,M\u00a8uller et al. 2006) \nuller (2002) and later(M \u00a8restrict invariants in a derived class to only mention .elds/proper\u00adties introduced \nin that class, and the class must preserve the invari\u00adants of its base classes. This means that methods \ncan be inherited, although not all code satis.es the restrictions.Forexample, this ap\u00adproach can only \ndeal with the Cell, and Recell examples presented in this paper. Ruby and Leavens (2000) allow the invariant \nof a derived class to depend on .elds from its base class. They provide a series of conditionsforwhenitisvalidto \ninheritamethodintoaclass.Their work can deal withCell,Recell and TCell examples. It still requires aderived \nclass to satisfy the invariant of its base classes, so it cannot allow representation changes that are \nrequired for SubRecell and DCell. Spec0/Boogie (Barnett et al. 2004) also allows the invariant of a derived \nclass to restrict the invariant of its base class. This means it can deal with the Cell, Recell and TCell \nexamples. Spec0/Boogie uses a single, polymorphic speci.cation for each method that is interpreted in \none of two ways, one for static/direct dispatch, and one for the dynamic dispatch. They do not explicitly \nseparate the speci.cation as we do in this paper,but their approach is clearly closely related. A polymorphic \nspeci.cation is one containing a distinguished symbol, typically written 1 , that is replaced with the \nexpression type(this) for dynamic dispatch, and with the ex\u00adpression C for the static dispatch, where \nC is the de.ning class. This polymorphism can be justi.ed quite succinctly using our notion of re.nement, \nas follows (where we write P [e] to mean the formula P where all occurrences of the symbol 1 are replaced \nwith the expression e): this:C {P [C]}{Q[C]} =.{P [type(this)]}{Q[type(this)]}. Currently,Spec0/Boogie \ncannot deal with the SubRecell and DCell classes as it enforces that a derived class preserves the invariant \nof its base class. In future work, we intend to pursue a more thorough compar\u00adison of our approach and \nthe Spec0/Boogie system. In joint work with others(Parkinsonetal.2007)we proposethe classic gangof four \ndesign patterns as a benchmark for the veri.cation of object\u00adoriented code. These patterns often makeuse \nof complicated aggre\u00adgate structures. Class invariant-based approaches, such as Spec0 , require signi.cant \nextensions to handle these structures and their use (Leino and Schulte 2007). Early experiments suggest \nthat our approach using separation logic and abstract predicatefamilies requires no extensions to handle \naggregate structures. Note Independenttoourwork,Chinetal.(2008) suggestinthese proceedings a similar \napproach to avoiding re-veri.cation. Whilst working in the more traditional setting of class invariants, \nthey propose a very similar use of static/dynamic method speci.cations in a separation logic. That two \ngroups independently proposed the distinction between static and dynamic speci.cations is perhaps encouraging \nas to the naturalness of the basic idea. Acknowledgments We should like to thankWei-Ngan Chin and Sophia \nDrossopoulou for discussions on this work, and Gary Leavens, Rustan Leino, PeterM\u00a8uller, Clyde Ruby andWolfram \nSchulte for discussions about related work. References M. Barnett, R. DeLine, M. F\u00a8ahndrich, K. R. M. \nLeino, and W. Schulte. Veri.cation of object-oriented programs with invariants. Journal of ObjectTechnology, \n3(6):27 56, 2004. M. Barnett, K. R. M. Leino, and W. Schulte. The Spec0 programming system: An overview. \nIn Proceedings of CASSIS, pages 49 69, 2005. B. Biering,L.Birkedal,andN.Torp-Smith.Bi-hyperdoctrines,higher-order \nseparation logic, and abstraction. ACMTOPLAS, 2007. To appear. G. M. Bierman, M. J.Parkinson, and A. \nM. Pitts. MJ: An imperative core calculusforJavaandJavawitheffects.Technical Report563,University of \nCambridge Computer Laboratory, 2004. W.-N. Chin, C. David, H. Nguyen, and S. Qin. Enhancing modular OO \nveri.cation with separation logic. In Proceedings of POPL, 2008. W. R. Cook, W. Hill, and P. Canning. \nInheritance is not subtyping. In Proceedings of POPL, 1990. K. K. Dhara and G. Leavens. Forcing behavioral \nsubtyping through speci\u00ad.cation inheritance. In Proceedings of ICSE, 1996. C. Flanagan, A. Sabry, B. \nF. Duba, and M. Felleisen. The essence of compiling with continuations. In Proceedings of PLDI, 1993. \nM. Flatt, S. Krishnamurthi, and M. Felleisen. A programmer s reduction semantics for classes and mixins. \nTechnical Report TR-97-293, Rice University, 1997. Corrected June, 1999. E. Gamma, R. Helm, R. Johnson, \nand J. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. AddisonWesley, 1994. \nA.Igarashi,B. Pierce,andP.Wadler. FeatherweightJava:Aminimal core calculus for Java and GJ. ACMTOPLAS, \n23(3):396 450, 2001. S. Ishtiaq andP.W. O Hearn. BI as an assertion language for mutable data structures. \nIn Proceedings of POPL, pages 14 26, 2001. N. Krishnaswami,J. Aldrich,andL. Birkedal. Modularveri.cationofthe \nsubject-observer pattern via higher-order separation logic. In Proceed\u00adings of FTfJP, 2007. G. T. Leavens \nand D. A. Naumann. Behavioral subtyping is equivalent to modular reasoning for object-oriented programs. \nTechnical Report TR 06-36, Iowa State University, 2006.  G.T. Leavens,A.L. Baker, andC. Ruby. Preliminary \ndesignof JML:a behavioral interface speci.cation language for Java. SIGSOFT Software Engineering Notes, \n31(3):1 38, 2006. K.R.M. Leino. Data groups: Specifyingthe modi.cationofextended state. In Proceedings \nof OOPSLA, pages 144 153, 1998. K.R.M. Leino andP.M\u00a8 uller.Averi.cation methodology for model .elds. \nIn Proceedings of ESOP, 2006. K.R.M. LeinoandW. Schulte. Using historyinvariantstoverify observers. \nIn Proceedings of ESOP, 2007. B. H. Liskov and J. M. Wing. A behavioral notion of subtyping. ACM TOPLAS, \n16(6):1811 1841, 1994.  P.M\u00a8uller. Modular Speci.cation andVeri.cation of Object-Oriented Pro\u00adgrams, \nvolume 2262 of LNCS. Springer-Verlag, 2002. PhD thesis, Fer\u00adnUniversit\u00a8 at Hagen. P.M\u00a8 uller, A. Poetzsch-Heffter, \nand G.T. Leavens. Modular invariants for layered object structures. Science of Computer Programming, \n62:253 286, 2006. A. Nanevski, A. Ahmed, G. Morrisett, and L. Birkedal. Abstract predicates and mutable \nADTs in Hoare Type Theory. In Proceedings of ESOP, 2007. P. W. O Hearn, J. C. Reynolds, and H. Yang. \nLocal reasoning about programs that alter data structures. In Proceedings of CSL, pages 1 19, 2001. M.Parkinson,G. \nBierman,J. Noble,andW. Schulte. Contractsfor patterns. Unpublished note, 2007. M. J.Parkinson. Local \nReasoning forJava. PhD thesis, Computer Labora\u00adtory, University of Cambridge, 2005. UCAM-CL-TR-654. \nM. J.Parkinson and G. M. Bierman. Separation logic and abstraction. In Proceedings of POPL, pages 247 \n258, 2005. A. Poetzsch-Heffter andP.M\u00a8A programming logic for sequential  uller. Java. In Proceedings \nof ESOP, volume 1576 of LNCS, 1999. J.C.Reynolds. Separationlogic:Alogicfor shared mutabledata structures. \nIn Proceedings of LICS, pages 55 74, 2002. C. Ruby and G. T. Leavens. Safely creating correct subclasses \nwithout seeing superclass code. SIGPLAN Not., 35(10):208 228, 2000.  H.Yang. Local reasoning for stateful \nprograms. PhD thesis, University of Illinois, July 2001. A. Semantics of proof system We give the semantics \nof our logic with respect to a state, s, an interpretation of predicates, I, and an interpretation of \nlogical variables, L.Aninterpretationof predicates maps predicate names to predicate de.nitions, where \npredicate de.nitions map a list of values to a set of states, that is: I : Preds . (Vals * .P(S)) L \n: Vars . Vals  We de.ne predicates in the standard way for a predicate calcu\u00adlus: s, I, L|= a(X) .. \ns . (I(a)(L(X))) De.nition 6. I|=. ifffor all s and L then s, I, L|=. holds Given this de.nition, we \ncan prove that any set of disjoint abstract predicatefamily de.nitionsis satis.able. Lemma 7. For any \nset of disjoint de.nitions, A1 ... An, there exists an environment,I,suchthatI|= [A1].....[An],provided \nthat if Ai de.nes aC and Aj de.nes aC, then i = j. Next, we de.ne the semantics of the judgements of \nthe proof system. We use the standard semantics of a triple for separation logic, that is, if the pre-condition \nholds of the start state, then (1) the program will notfault (e.g. access unallocatedmemory); and (2) \nif the program terminates, then the .nal state will satisfy the post-condition. .\u00af.\u00af De.nition 8. I|= \nn P s Q iff (S, H), I, L|= P then .m = n. S, H, s -.m fault does not hold; and  if S, H, s -.m S ' \n,H ' , skip then (S ' ,H ' ), I, L|= Q.  Note that the step index n is used to deal with mutual recursion \nin method de.nitions. We de.ne I|= n G to mean all the methodsgivenin G meet their speci.cations for \nat least n steps. De.nition9 (Semantics of method veri.cation). I, G |= n+1 C.m(x): {P }{Q} iff .\u00af .\u00af \nI|= n G . I|= n+1 P . this : C mbody(C, m) Q . \u00af.\u00af I, G |= n+1 C::m(x): ST iff . \u00af.\u00af I|= n G . I|= n+1 \nS . this = null mbody(C, m) T I|= 0 G always holds. I|= n+1 G iff .spec . G. I;G |= n+1 spec We can now \nde.ne the precise semantics of a judgement as follows. De.nition 10. .; G |= {P }s{Q} ifffor all I and \nn, if I|=. .\u00af.\u00af and I|= n G, then I|= n+1 P s Q . That is, for all interpretations satisfying the predicate \nde.nitions . and assuming all the methods executed for at most n steps meet their speci.cation given \nby G, then the statements s meet their speci.cation for at least n +1 steps. The judgements for statement \nand methodveri.cation are sound with respect to the semantics. Lemma 11. .\u00af.\u00af 1. If .; G f{P }s{Q} then \n.; G |= P s Q . 2. If .; G f M in E then .I. if I|=. then .n.spec . M. I;G |= n spec  Our notion of \nre.nement respects the weakening of assumptions and, hence, we can verify classes in a weaker context. \nLemma 12. .\u00af.\u00af .\u00af.\u00af 1. If . ' . . and . f P1 Q1 =. P2 Q2 , .\u00af.\u00af .\u00af.\u00af then . ' f P1 Q1 =. P2 Q2 . 2. If \n.; G f L and . ' . ., then . ' ;G f L. Finally, we state and outline the soundness proof for the pro\u00adgram \nveri.cation rule. Theorem 13. If a program and main body s can be proved using . \u00af. \u00af the program veri.cation \nrule, then .I, n. I|= n true s true . Proof. Using Lemma 12.2, we can simplify the rule to the follow\u00ading. \n.; G f L1 \u00b7\u00b7\u00b7 .; G f Ln .; G f{true}s{true} f L1 ... Lns where G= specs(L1 ... Ln) and .= apf (L1) .\u00b7 \n\u00b7\u00b7. apf (Ln). This rule assumes that . is satis.ed, which we know by Lemma 7. The rest of the details \nare standard for the soundness of an object-oriented logic for partial correctness, for example see (Parkinson \n2005).   \n\t\t\t", "proc_id": "1328438", "abstract": "<p>Inheritance is a fundamental concept in object-oriented programming, allowing new classes to be defined in terms of old classes. When used with care, inheritance is an essential tool for object-oriented programmers. Thus, for those interested in developing formal verification techniques, the treatment of inheritance is of paramount importance. Unfortunately, inheritance comes in a number of guises, all requiring subtle techniques.</p> <p>To address these subtleties, most existing verification methodologies typically adopt one of two restrictions to handle inheritance: either (1) they prevent a derived class from restricting the behaviour of its base class (typically by syntactic means) to trivialize the proof obligations; or (2) they allow a derived class to restrict the behaviour of its base class, but require that every inherited method must be reverified. Unfortunately, this means that typical inheritance-rich code either cannot be verified or results in an unreasonable number of proof obligations.</p> <p>In this paper, we develop a separation logic for a core object-oriented language. It allows derived classes which override the behaviour of their base class, yet supports the inheritance of methods without reverification where this is safe. For each method, we require two specifications: a <i>static</i> specification that is used to verify the implementation and direct method calls (in Java this would be with a super call); and a <i>dynamic</i> specification that is used for calls that are dynamically dispatched; along with a simple relationship between the two specifications. Only the dynamic specification is involved with behavioural subtyping. This simple separation of concerns leads to a powerful system that supports all forms of inheritance with low proof-obligation overheads. We both formalize our methodology and demonstrate its power with a series of inheritance examples.</p>", "authors": [{"name": "Matthew J. Parkinson", "author_profile_id": "81406598777", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P925380", "email_address": "", "orcid_id": ""}, {"name": "Gavin M. Bierman", "author_profile_id": "81100249578", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "PP39034464", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328451", "year": "2008", "article_id": "1328451", "conference": "POPL", "title": "Separation logic, abstraction and inheritance", "url": "http://dl.acm.org/citation.cfm?id=1328451"}