{"article_publication_date": "01-07-2008", "fulltext": "\n Foundations for Structured Programming with GADTs Patricia Johann Rutgers University, Camden, NJ, USA \n pjohann@crab.rutgers.edu Abstract GADTs are at the cutting edge of functional programming and be\u00adcome \nmore widely used every day. Nevertheless, the semantic foun\u00addations underlying GADTs are not well understood. \nIn this paper we solve this problem by showing that the standard theory of data types as carriers of \ninitial algebras of functors can be extended from algebraic and nested data types to GADTs. We then use \nthis obser\u00advation to derive an initial algebra semantics for GADTs, thus en\u00adsuring that all of the accumulated \nknowledge about initial algebras can be brought to bear on them. Next, we use our initial algebra semantics \nfor GADTs to derive expressive and principled tools analogous to the well-known and widely-used ones \nfor algebraic and nested data types for reasoning about, programming with, and improving the performance \nof programs involving, GADTs; we christen such a collection of tools for a GADT an initial al\u00adgebra package. \nAlong the way, we give a constructive demonstra\u00adtion that every GADT can be reduced to one which uses \nonly the equality GADT and existential quanti.cation. Although other such reductions exist in the literature, \nours is entirely local, is indepen\u00addent of any particular syntactic presentation of GADTs, and can be \nimplemented in the host language, rather than existing solely as a metatheoretical artifact. The main \ntechnical ideas underlying our approach are (i) to modify the notion of a higher-order functor so that \nGADTs can be seen as carriers of initial algebras of higher\u00adorder functors, and (ii) to use left Kan \nextensions to trade arbitrary GADTs for simpler-but-equivalent ones for which initial algebra semantics \ncan be derived. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs \nand Features-Data types and struc\u00adtures General Terms Languages, Theory 1. Introduction Generalized \nalgebraic data types, or GADTs, are at the cutting edge of functional programming and are .nding an ever-increasing \nnumber of applications. Types are traditionally used to guarantee that programs do not go wrong by using \ndata in inappropriate ways. GADTs extend this traditional use of types, allowing them to index, and thereby \ncapture more sophisticated properties of, data types. Properties of interest may include the size or \nshape of data, the state of program components, or some invariant that the Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 08, January 7 12, 2008, San Francisco, \nCalifornia, USA. Copyright c &#38;#169; 2008 ACM 978-1-59593-689-9/08/0001. . . $5.00 Neil Ghani University \nof Nottingham, Nottingham, UK nxg@cs.nott.ac.uk data type is expected to satisfy. By encoding properties \nas types, GADTs provide a means of abstracting them into a form that com\u00adpilers and other language tools \ncan exploit. This makes proper\u00adties of programs that would otherwise be available only dynami\u00adcally, \nif at all, statically checkable and analyzable, and thus makes progress toward closing what Sheard calls \nthe semantic gap be\u00adtween what the programmer knows about a program and what the programming language \nallows to be stated. GADTs are especially useful when combined with higher-kinded types, as in (extensions \nof) Haskell, and with user-de.nable kinds, as in Omega [Omega, Sheard et al. (2005)]. In such settings, \nGADTs can represent re.ne\u00adment types, witness types, existential types, and certain dependent types. \nGADTs are closely related to several other concepts, includ\u00ading .rst-class phantom types [Cheney &#38; \nHinze (2003)], equality\u00adquali.ed types [Sheard &#38; Pasalic (2004)], guarded recursive types [Xi et \nal. (2003)], and inductive families [Dybjer (1994)]. They can even be regarded as a variant of dependent \ntypes [McBride (2004), Xi &#38; Pfenning (1999)] in which the distinction between types and values is \nmaintained. It is widely accepted that a good theory of data types requires principled foundations in \norder to provide expressive tools for structured programming with them. One of the most successful foundations \nfor algebraic data types such as the natural numbers, lists, trees is that of initial algebra semantics. \nIn initial algebra semantics, every data type is seen as the carrier of the initial algebra of a functor. \nThe value of initial algebra semantics lies not only in its theoretical clarity, but also in that it \nsupports principled structured programming techniques for data types including: Combinators which uniformly \nproduce, uniformly consume, and otherwise capture commonly-occurring type-independent programming idioms \nfor data types. Among the most signi.cant of these are the build combinator, which uniformly produces \nstructures of a given data type; the structured recursion com\u00adbinator fold, which uniformly consumes \nstructures of a given data type; and the map combinator, which applies a speci.ed function to all data \nin a structure of a given data type.  Church encodings for data types, which represent structures of \ndata types as functions in the Girard-Reynolds polymorphic lambda calculus, the core formal calculus \non which many func\u00adtional languages are based. In addition to being interesting in their own right, Church \nencodings are the key to de.ning build combinators. Indeed, the build combinator for each data type derives \nfrom the isomorphism between that data type and its Church encoding.  fold/build fusion rules, also \nderived from the isomorphisms between data types and their Church encodings, that can be used to improve \nthe performance of modularly constructed pro\u00adgrams which manipulate data of those types. Such a rule \nre\u00adplaces a call to the build combinator for a given data type which is immediately followed by a call \nto the fold combi\u00adnator for that type with an equivalent computation that does not  construct the intermediate \nstructure introduced by build and immediately consumed by fold. Local program transforma\u00adtions [Gill \net al. (1993), Johann (2002), Svenningsson (2002)] based on fold/build rules can result in order-of-magnitude \nincreases in program ef.ciency. They also open the way for de\u00adveloping a so-called algebra of fusion. \nGeneric programming techniques based on the observation that initial algebra semantics allows us to derive \na single generic fold combinator, a single generic build combinator, and a sin\u00adgle generic fold/build \nrule each of which can be special\u00adized to any particular data type of interest. Despite their ubiquity \nand utility, the semantic foundations of programming with GADTs are not well understood. In particular, \nthere is currently no known initial algebra semantics for GADTs. From a theoretical standpoint, it is \nunsettling to think that our un\u00adderstanding of data types in terms of initial algebras of functors is \nlimited to algebraic and nested data types [Bird &#38; Meertens (1998)], and not applicable to more advanced \nones such as GADTs. But the lack of an initial algebra semantics for GADTs is also problematic from a \nprogrammer s point of view, since it forestalls the principled derivation of folds, builds, fold/build \nfusion rules, and other tools for structured programming with GADTs. Thus, for both the\u00adoretical and \npractical reasons, the time has come to ask whether or not an initial algebra semantics for GADTs can \nbe given. This paper provides an af.rmative answer to this question for covariant GADTs. The covariance \nrestriction is very mild: it is the natural analogue of the standard restrictions to covariant algebraic \ndata types and covariant nested data types which appear in the literature, and is also satis.ed by virtually \nall GADTs which arise in practice. Moreover, covariance is central to the derivation of initial algebra \nsemantics for algebraic and nested data types, since initial algebras of functors are taken, and functors \nare, by their very nature, covariant. The covariance restriction is similarly central to the derivation \nof initial algebra semantics for GADTs.1 We therefore speak simply of GADTs below, and leave the covariance \nrestriction implicit. With this understanding, we derive initial algebra packages for GADTs in any language \nwhich also supports universal and exis\u00adtential type quanti.cation. We use categorical tools as our main \ntechnical devices, and use Haskell to illustrate and make these cat\u00adegorical techniques more accessible \nto the programming languages community. We offer two kinds of results: For those languages supporting \nformal parametric models, our results can be read as formal theorems about GADTs and their semantics. \nThis is because the existence of a parametric model entails that existentially quanti.ed types are interpreted \nas co\u00adends, that left Kan extensions are de.nable, and that initial al\u00adgebras exist for all functors \ninterpreting type constructors in the underlying language. The canonical candidate for a parametric model \nis the category of PERs [Bainbridge et al. (1990)].  For languages not supporting formal parametric \nmodels, we use category theory as a heuristic to guide the derivation initial algebra packages for GADTs. \nIn this case, no formal proofs are claimed for the initial algebra packages, and all results about initial \nalgebra packages must be veri.ed independently.  As mentioned above, irrespective of the target language, \nwe use Haskell to illustrate our categorical ideas. We stress, however, that we do not claim the existence \nof a parametric model for full Haskell. The existence of such a model is a standard assumption in the \nliterature, but this assumption becomes increasingly speculative 1 We do, however, expect the standard \ntechniques for dealing with mixed variance algebraic and nested data types to scale to mixed variance \nGADTs. as Haskell is extended by more and more features. Thus, although we use Haskell to illustrate \nour ideas, we presently regard full Haskell as being in the second group of languages discussed above. \nIn the remainder of this paper we assume that we have at our dis\u00adposal a parametric model in the form \nof a category Cwhose objects interpret the types of the target language and whose morphisms in\u00adterpret \nits functions. Our .rst major result is THEOREM 1. Given a parametric model, every GADT has an ini\u00adtial \nalgebra semantics. Theorem 1 is signi.cant both theoretically and practically. On the one hand, it entails \nthat GADTs can be understood entirely in terms of initial algebras and thereby extends the semantics \nof algebraic types to cover GADTs. This is advantageous, since it ensures that all of our knowledge about \ninitial algebras can be brought to bear on GADTs. On the other hand, Theorem 1 is the key to structured \nprogramming with GADTs since it can be used to derive from every GADT, directly from its declaration, \na collection of tools for structured programming with data of that type. Indeed, in Section 5 we use \nthe initial algebra semantics of GADTs to give fold and build combinators, Church encodings, and fold/build \nrules for GADTs, and to show that these constructs are worthy of the names, i.e., that they have properties \nanalogous to those of the corresponding constructs for algebraic and nested data types. If we call such \na collection of tools an initial algebra package,then a second contribution of this paper is to show \nthat THEOREM 2. Every GADT has an initial algebra package. Note that this result holds even when no parametric \nmodel exists. The dif.culty in deriving initial algebra semantics for GADTs is two-fold. The .rst issue \nis that, although the interpretation of a GADT is most naturally a functor C.C, such an interpretation \nturns out not actually to be possible. It is therefore not clear how to model GADTs as carriers of initial \nalgebras of higher-order functors (C.C) .C.C. Our solution to this problem lies in modeling GADTs as \ncarriers of initial algebras of higher-order functors (|C|.C) .|C|.C,where |C|is the discrete category \nderived from C. The second issue is that an arbitrary GADT G has data constructors whose return types \nare not of the form Ga for some type variable a, but rather are of the form G(h a). (The possible presence \nof a non-identity h is what distinguishes GADTs from nested types.) We solve this second problem by using \nleft Kan extensions to show how to trade a GADT whose data constructors have return types of the form \nG(h a) for an equivalent one all of whose constructors have return types of the form Ga. An initial algebra \nsemantics for any GADT can be derived from the initial algebra semantics of the equivalent GADT obtained \nby transforming all of its constructors in this way. This paper is a follow-up paper to [Johann &#38; \nGhani (2007a), Johann &#38; Ghani (2007b)], which derive initial algebra semantics for nested data types. \nThose papers view nested data types as car\u00adriers of initial algebras of higher-order Haskell functors \nmapping Haskell functors to Haskell functors. They also use Kan extensions to establish the expressiveness \nof the resulting fold and build combinators for nested data types. There are thus similarities with this \npaper, but note that i) GADTs are interpreted here as carri\u00aders of initial algebras of higher-order functors \nwhich map functors with discrete domains to functors with discrete domains, rather than functors with \npossibly nondiscrete domains to functors with possi\u00adbly nondiscrete domains, and ii) Kan extensions are \nused in this pa\u00adper to derive initial algebra semantics for GADTs rather than to es\u00adtablish their expressiveness. \nAs a result, this paper is related only in spirit to [Johann &#38; Ghani (2007a), Johann &#38; Ghani \n(2007b)], via their shared use of functor categories and Kan extensions. But as with those papers, the \nideas in this one can be understood even if one has no prior knowledge of Kan extensions. In the course \nof our development we also give a constructive derivation of a third fundamental result, namely THEOREM \n3. Every GADT can be reduced to one involving only the equality GADT and existential quanti.cation. Like \nTheorem 2, Theorem 3 does not require a parametric model. Yet in the presence of one it ensures that \nwe can reason about GADTs by reasoning about the equality GADT and about existen\u00adtial quanti.cation. \nAlthough this result is implicit in the literature (see, e.g., [Sulzmann &#38; Wang (2005), Sulzmann \n&#38; Wang (2004)]), our reduction has the bene.t of being local to the particular GADT under consideration, \nand so does not require manipulation of the entire host language. It therefore is not impacted by the \naddition or deletion of other language features. Furthermore, our reduction is independent of any particular \nsyntactic presentation of GADTs. And it is easily implemented in Haskell, rather than existing solely \nas a metatheoretical artifact. We make several other important contributions as well. First, we execute \nour program for deriving initial algebra semantics and packages for GADTs in a generic style by parameterizing \nour GADTs over the types occurring in them. While this incurs a cer\u00adtain notational overhead, the inconvenience \nis outweighed by hav\u00ading a single generic fold combinator, a single generic build op\u00aderator, and a single \ngeneric fold/build rule, each of which can be specialized to any particular GADT of interest. Secondly, \nwhile the theory of GADTs has previously been developed only for syn\u00adtactically de.ned classes of GADTs, \nour development is not re\u00adstricted to a particular syntactic de.nitional format for GADTs, but rather \nis based on the semantic notion of the carrier of the ini\u00adtial algebra of a (in this case, higher-order) \nfunctor. Thirdly, this paper provides a compelling demonstration of the practical ap\u00adplicability of Kan \nextensions, and thus has the potential to ren\u00adder them more accessible to functional programmers. Finally, \nwe give a complete implementation of our ideas in Haskell, available at http://www.cs.nott.ac.uk/~nxg. \nThis demonstrates their practical applicability, makes them more accessible, and provides a partial guarantee \nof their correctness via the Haskell type-checker. This paper can therefore be read both as abstract \nmathematics and as providing the basis for experiments and practical applications. The remainder of this \npaper is organized as follows. In Section 2 we introduce GADTs, use Haskell (for which our abstract category \nCinterprets the kind *) as a target language to show that GADTs are not obviously functors C.C, and discuss \nthe dif.culty this poses for deriving initial algebra semantics for them. In Section 3 we show that GADTs \nfrom a restricted class are semantically carriers of initial algebras of higher-order functors (|C|.C) \n.|C|. C(although, as just noted, not necessarily higher-order functors (C.C) .C.C). We then use this \nobservation to derive initial algebra semantics for such GADTs. In Section 4 we recall the derivation \nof initial algebra packages of structured programming tools for inductive types and recap the well-known \ncategorical ideas which underlie them. In Section 5 we instantiate these ideas in the relevant category \nto derive initial algebra packages for GADTs from our restricted class. In Section 6 we extend our derivation \nto all (covariant) GADTs. We derive initial algebra packages for some GADTs from the literature in Section \n7. In Section 8 we conclude and indicate our next step in this line of research.  2. The Problem 2.1 \nGADTs Syntactically, GADTs are generalizations of algebraic data types. An algebraic data type is a data \ntype with the property that all applications of its type constructor which occur in its declaration have \nprecisely the same type variables as arguments.2 Consider, for example, the data type of lists, realizable \nin Haskell as data List a = Nil | Cons a (List a) This declaration introduces the data constructors \nNil :: List a and Cons :: a-> List a -> List a. The type variables ap\u00adpearing in the declaration of an \nalgebraic data type are implicitly universally quanti.ed; algebraic data types and their data construc\u00adtors \nare thus polymorphic in general. Since every application of the type constructor List in the declaration \nof List a and thus in the types of Nil and Cons is of the form List a for the same type variable a,the \nList data type is indeed algebraic. GADTs relax the restriction on the types of data constructors of \nalgebraic data types. Data constructors for a GADT can both take as arguments, and return as results, \ndata whose types involve type instances of the GADT other than the one being de.ned. (By contrast, data \nconstructors of nested types can take as arguments, but cannot return as results, data whose types involve \ninstances of the nested type other than the one being de.ned.) For example, the following Haskell declaration \nde.nes the GADT Term: data Term a where Const :: a -> Term a Pair :: Term a -> Term b -> Term (a,b) App \n::Term(a->b)->Terma-> Termb As is customary, the types of the data constructors of this GADT are given \nexplicitly. The data constructor Pair takes as input data of the instances Term a and Term b, and returns \nas its result data of the instance Term (a,b) of the Term GADT. Similarly, App takes as input data of \nthe instances Term (a -> b) and Term a of the GADT, and return data of the instance Term b. Although \nit is not illustrated by this example, a single data constructor for a GADT can simultaneously take as \ninput and return as its result data of new instances of that GADT as well. As for algebraic and nested \ndata types, all of the type variables appearing in the types of the data constructors of a GADT are implicitly \nuniversally quanti.ed, so that the type parameter a in the expression Term a is a dummy parameter used \nonly to give the kind of the GADT type constructor Term. Using Haskell s kind syntax, we could have instead \nwritten the above declaration as data Term :: * -> * where .... 2.2 Are GADTs Haskell Functors? The \ngoal of this paper is to show that GADTs have initial algebra semantics. To have an initial algebra semantics, \na GADT G must have an interpretation as the initial algebra of a functor (see Sec\u00adtion 4.2). Since G \nis a type constructor, it is natural to try to model it as a functor C.Cwhich is the carrier of the initial \nalgebra of a functor (C.C) .C.C. The .rst question which arises is thus whether or not every GADT can \nbe interpreted as a functor C.C. To answer this question, consider the situation in Haskell, where the \ncategory Cinterprets the Haskell kind *. Functors are imple\u00admented in Haskell as type constructors supporting \nfmap functions, as captured by the built-in type class class Functor f where fmap ::(a -> b)-> fa -> \nfb The function fmap is expected to satisfy the functor laws fmap id =id fmap (f .g) =fmap f .fmap g \nstating that fmap preserves identities and composition. But satisfac\u00adtion is not enforced by the compiler: \nit is the programmer s respon\u00ad 2 There are different uses of the word algebraic in the literature. We \nuse this de.nition consistently in this paper. sibility to ensure that the fmap function for each Haskell \nfunctor, i.e., instance of Haskell s Functor class, behaves appropriately. If G is to be a Haskell functor \nthen it must support an fmap operation. Establishing that Term is a Haskell functor, for example, would \nrequire a declaration instance Functor Term where fmap ::(d -> e)-> Term d -> Term e The clause for terms \nof the form Pair x y would have f :: (b,c) -> e and fmap f (Pair x y) :: Term e. Keepinginmind that fmap \nshould change the data in a term while preserving its structure, we should have fmap f (Pair xy) = Pair \nuv for some appropriately typed u and v. But it is not clear how to achieve this since e cannot be guaranteed \nto have a tuple structure. Even if e were guaranteed to be of the form (b , c ),we dthen have f :: (b,c) \n-> (b ,c ), but still no way to produce data of type Term (b ,c ) from only f :: (b,c) -> (b ,c ) and \nx:: b and y:: c. The problem stems from the fact that f is not guaranteed to be a pair of functions. \nSo it is not clear how to treat an arbitrary GADT in Haskell as a Haskell functor. It is thus not clear \nhow to treat GADTs semantically as functors in general.  3. The Key Ideas 3.1 Recovering Functoriality \nThe above considerations lead us to try to model a GADT G as a ' functor C.Cfor a category C' distinct \nfrom the category C. A natural candidate for C' is the category whose objects model the (inhabited) types \nof G.For the Fin GADT from Example 1 in Section 7, for instance, the inhabited types are essentially \nthe natural numbers. But for some GADTs, such as Term, the inhabited types will be all types. So a simpler \nand more uniform approach is always to take the objects of C' to be those of C. At .rst glance this seems \nto have gotten us nowhere, but we have not yet fully speci.ed the category C'. In addition to specifying \nthe objects of C', we must also specify its morphisms. Since the only functions between types that we \nknow for sure can be lifted to functions between GADTs parameterized over those types are the identity \nfunctions, we simply take C' to have as morphisms only the identities. That is, we take the category \nC' to be the discrete category derived from C. Writing |C|for this category, we observe that every function \nfrom the objects of |C|to Cis trivially a functor |C|.C. We now turn our attention to showing that every \nGADT can be modeled as the carrier of the initial algebra of a functor (|C|.C) .|C|.C.  3.2 Basic GADTs \nand Higher-order Functors To keep syntactic overhead to a minimum, and to highlight the key ideas underlying \nof our approach, we make some simplifying as\u00adsumptions in this section about the syntax of GADTs. We \nshow how to extend our approach to GADTs which do not satisfy these assumptions in Section 6. On the \nother hand, to emphasize that our approach is generic over all GADTs, as discussed in the introduc\u00adtion, \nour notation explicitly parameterizes GADTs over the types from which they are constructed. We say a \nGADT Gfh is basic if it has the form data G fh awhere GCon ::f (G f h) a-> Gf h(h a) The covariance restriction \nmentioned in the introduction is captured by the requirement that G does not appear in h,and that f is \nan instance of the higher-order functor class which we now discuss. A higher-order functor maps functors \nto functors, and maps between functors to maps between functors, i.e., natural transformations to natural \ntransformations. In particular, higher-order functors on * can be implemented in Haskell by the following \nanalogue of the built-in Functor class: class HFunctor f where ffmap ::Functor g => (a -> b) -> fg a-> \nfg b hfmap ::Nat g h-> Nat (fg) (f h) That a higher-order functor maps functors to functors is captured \nby the requirement that an HFunctor i.e., an instance of the HFunctor class supports an ffmap function; \nthat a higher\u00adorder functor maps natural transformations to natural transforma\u00adtions is captured by the \nrequirement that an HFunctor supports an hfmap function. The type of natural transformations can be given \nin Haskell by type Nat gh =forall a.g a-> h a A parametric interpretation of the forall quanti.er ensures \nthat a function of type Nat gh can be thought of as a uniform family of maps from g to h, so that the \nrelevant naturality squares commute. While not explicit in the class de.nition above, the programmer \nis expected to verify that if g is a Haskell functor, then fg is also a Haskell functor. Moreover, like \nthe fmap functions for functors, the hfmap functions are expected to preserve identities and composi\u00adtion \n here for natural transformations. An example of a basic GADT is the following alternative pre\u00adsentation \nof the GADT Fin of .nite sets from Example 1 in Sec\u00adtion 7. Here, Either is the standard Haskell type \nfor disjunctions, fga is Either Unit (g a), ha is Sa,and Gfh is BFin. data BFin a where BFinCon :: Either \nUnit (BFin a) -> BFin (S a) Now, if Gfh is to be interpreted as the carrier of the initial algebra of \na higher-order functor (|C|.C) .|C|.C,then in order for Gfh and its data constructor GCon to be well-kinded \nwe should have in Haskell: h :: |*| -> |*| f:: (|*| -> *)-> |*| -> * Gf h:: |*| ->* We can tailor the \nHFunctor class above to accommodate higher\u00adorder functors of kind (|*| -> *) ->|*| -> *. This amounts \nto eliminating the ffmap function from the class de.nition, since every functor necessarily maps identities \nto identities. When work\u00ading with GADTs, we therefore use the following specialized ver\u00adsion of the HFunctor \nclass: class HFunctor f where hfmap :: Natg h-> Nat (f g)(f h) 3.3 Initial Algebra Semantics for Basic \nGADTs We seek to derive from the syntax of Gfh a higher-order functor (|C|.C) .|C|.Csuch that the carrier \nof its initial algebra interprets Gfh. In a parametric model, the interpretation of the type f(G fh) \na -> Gfh(ha) of GCon is isomorphic to the interpretation of the type Lan h(f(Gf h))a->G fha,where data \nLan hg c= forall b. Lan (Eql (h b)c, gb) is the Haskell representation of the left Kan extension [MacLane \n(1971)] of g along h,and Eql is the equality GADT data Eql a b where Refl :: Eql aa The use of Eql in \nthe de.nition of Lan re.ects the fact that, in Haskell, the domain of h is the discrete category |*|. \nCon\u00adstructing an element of type Gfhc requires using GCon,and thus .nding a type b such that hb=c andgivingan \nelement of f(G fh) b to which GCon can be applied. The interpre\u00adtation of Gfhc is therefore isomorphic \nto the interpretation of exists b.(h b= c,f (G f h) b). Writing this type as Lan h(f (G fh)) c captures \nthis observation precisely once we remember that existential type quanti.cation is written using top-level \nuniversal type quanti.cation in Haskell. From this it follows that the interpretation of Gfh is the carrier \nof the initial algebra of the higher-order functor interpreting Kfh, where Kfh is de.ned by Kf hg a= \nLan h(f g)a Unfortunately, we cannot simply use this speci.cation in a Haskell type synonym, since this \nwould render the partial application Kfh unavailable for computations. We therefore make the fol\u00adlowing \ndata type declaration instead: data K fh ga= forall b. HFunctor f => K (Eql (h b)a, fg b) We can verify \nthat Kfh is indeed an HFunctor by observing that it is the composition of f, which is an HFunctor by \nassumption, and Lan h, which is an HFunctor as shown here: instance HFunctor (Lan h) where hfmap k (Lan \n(p, v)) = Lan (p, k v) Composition of HFunctors can be coded in Haskell using newtype (HFunctor g, HFunctor \nh) => HComp ghk a= HComp (g (h k)a) The following instance declaration shows that the composition of \ntwo HFunctorsis again an HFunctor: instance (HFunctor g, HFunctor h) => HFunctor (g HComp h) where hfmap \nk (HComp t) = HComp (hfmap (hfmap k) t) We can instantiate this declaration for Lan h and f to show that \ntheir composition is an HFunctor. But unfortunately, this causes a proliferation of HComp type and data \nconstructors throughout our code. To avoid this and thus purely for cosmetic reasons we give an HFunctor \ninstance declaration for the composition of Lan h and f directly. We have instance HFunctor f => HFunctor \n(K f h) where hfmap k (K (p, v)) = K (p, hfmap k v) The hfmap on the right-hand side of the de.nition \nin the instance declaration is the one for f. Since Gfh is inductively de.ned, we can see that the interpre\u00adtation \nof Gfh is the carrier of the initial algebra of the interpre\u00adtation of Kfh by establishing that the interpretation \nof Gfh is isomorphic to the interpretation of the type data NG fh awhere NGCon :: Kfh (NG fh) a-> NG \nfh a This follows from the isomorphism between the interpretation of forall c.Lan h g c-> f c and the \ninterpretation of forall c. gc -> f(h c) which holds for all h, g,and f.This isomor\u00adphism can be coded \nin Haskell as toLan :: (forall c. g c -> f (h c)) -> Lan hg c-> fc toLan s (Lan (Refl, v)) = s v fromLan \n:: (forall c. Lan h g c -> f c) -> gc-> f(hc) fromLan s t = s (Lan (Refl, t)) For our left Kan extension \nK, toLan and fromLan specialize to the following functions giving an isomorphism between the interpreta\u00adtion \nof forall c.Kf hg c-> kc and the interpretation of forall c. f gc-> k (h c): toK :: HFunctor f => (forall \nc. f g c -> k (h c)) -> Kf hg c-> kc toKs(K (Refl,v))= sv fromK :: HFunctor f => (forall c. K f h g c \n-> k c) ->f gc -> k (h c) fromK s t = s (K (Refl, t)) Thus, giving data appropriate for input to GCon \nis equivalent to giv\u00ading data appropriate for input to NGCon. Since the data constructors of these types \ncontain exactly the same information, they generate exactly the same GADT. In light of the above, we \ncan write Gfh as Mu (K fh) where newtype Muf a= In (f (Mu f) a) represents the carrier of the initial \nalgebra of the interpretation of f.Since Gfh is interpreted as the carrier of the initial algebra of \nthe interpretation of Kfh, it admits an initial algebra semantics.  4. Semantic Foundations of Initial \nAlgebra Packages In this section we .rst recall the derivation of initial algebra pack\u00adages for inductive \ntypes from [Ghani et al. (2003)], and then recap the well-known categorical ideas which underlie it. \nIn the next sec\u00adtion we show how to instantiate these same ideas in our higher\u00adorder setting to derive \ninitial algebra packages for GADTs. 4.1 Initial Algebra Packages for Inductive Types An inductive data \ntype is a data type which can be interpreted as the carrier of the initial algebra of a functor, and \nan inductive data structure is a data structure of inductive type. It is well known [Ghani et al. (2005), \nGhani et al. (2003), Takano &#38; Meijer (1995)] that every inductive type has an associated initial \nalgebra package. If f is a Haskell functor, then the associated inductive type Mf and its associated \nfold and build combinators can be implemented generically in Haskell by3 newtype M f = Inn (f (M f)) \nfold :: Functor f => (f a ->a) -> Mf ->a fold h (Inn k) = h (fmap (fold h) k) build :: Functor f => (forall \nb. (f b-> b) -> b) -> Mf build g =g Inn As usual, the type of the polymorphic function argument to build \ngives the Church encoding for Mf.These build and fold com\u00adbinators can be used to produce and consume \ninductive data struc\u00adtures of type Mf. Moreover, if f is any Haskell functor, h is any function of any \ntype fa-> a,and g is any function of closed type forall b. (f b-> b) -> b, then the following fold/build \nrule for Mf eliminates from computations structures of type Mf which are produced by build and immediately \nconsumed by fold: fold h(build g) =g h The familiar initial algebra package for list types [Gill et al. \n(1993)] is an instance of this scheme, as are the corresponding packages 3 Unfortunately, we cannot use \nthe same .xed point operator here as in Section 3. This is because f is not an HFunctor in this case, \nwhich is problematic because Haskell lacks proper polymorphic kinding. foldr :: (a ->b -> b) -> b-> [a] \n-> b foldrcnxs=casexsof[] ->n z:zs -> cz (foldr c nzs) --Church encoding forall b.(a -> b-> b) -> b -> \nb buildL :: (forall b. (a -> b -> b) -> b -> b) -> [a] buildL g= g(:) [] --fold/build rule foldr c n(buildL \ng) =g cn Figure 1. Generic initial algebra package for list types. foldT :: (a ->b) -> (b-> b -> b) -> \nTree a-> b foldT l bt =case t of Leaf x-> lx Branch t1 t2 -> b (foldT l b t1) (foldT l b t2) --Church \nencoding forall b.(a -> b)-> (b ->b -> b) -> b buildT :: (forall b. (a -> b) -> (b ->b -> b) -> b) -> \nTree a buildT g = g Leaf Branch --fold/build rule foldT l b(buildT g) =g lb Figure 2. Generic initial \nalgebra package for Tree. for algebraic data types given in [Johann (2002)]. The former is given in Figure \n1, while the initial algebra package for the non-list algebraic data type data Tree a = Leaf a | Branch \n(Tree a) (Tree a) of trees over data of type a is given in Figure 2. It is the fact that inductive types \nare interpreted by carriers of initial algebras of functors that makes it possible to de.ne initial algebra \npackages for them. In particular, this is what ensures that their folds are true folds, that their Church \nencodings really en\u00adcode them, and that their fold/build rules truly are correct. It s what allows us \nto program with, and reason about programs involv\u00ading, inductive types. Section 4.2 explains the theory \nunderlying this assertion and, at the same time, develops the semantic foundations for our derivation \nof initial algebra packages for GADTs; note that the material in Section 4.2.2 may be new even to those \nfamiliar with initial algebra semantics. Readers without the required background in category theory or \nwhose main focus is not on the categorical foundations of initial algebra packages for advanced data \ntypes can safely omit this section and other categorical discussions in the pa\u00adper since all of the relevant \ncategory-theoretic constructs used in this paper are implemented in Haskell. Readers who choose to do \nthis will miss some of the motivations for the theory of GADTs, and some of the connections between the \ntheory of inductive types and the theory of GADTs developed in this paper, but will miss no necessary \nfacts. We stress that we do not attempt a complete recon\u00adstruction of all of category theory here, but \ninstead introduce only those concepts that form the basis of our initial algebra approach to deriving \nprincipled programming tools for GADTs.  4.2 The Fundamental Theory The key idea underlying initial \nalgebra packages is the idea of initial algebra semantics. Within the paradigm of initial algebra semantics, \nevery data type is interpreted as the carrier \u00b5F of the initial algebra of a suitable functor F :C.Cfor \nsome suitable category C. In more detail, suppose we have .xed a category C. An algebra for a functor \nF :C.C(or, simply, an F -algebra) is a pair (A, h)where A is an object of Cand h :FA .A is a morphism \nof C. Here, A is called the carrier of the algebra and h is called its structure map. As it turns out, \nthe F -algebras for a given functor F themselves form a category. In the category of F \u00adalgebras, a morphism \nbetween F -algebras (A, h)and (B, g)is a map f :A .B such that the following diagram commutes: Ff - \nFA FB h g A f B We call such a morphism an F -algebra homomorphism. Now, if the category of F -algebras \nhas an initial object called an initial algebra for F , or, more simply, an initial F -algebra then \nLambek s Lemma ensures that the structure map of this ini\u00adtial F -algebra is an isomorphism, and thus \nthat its carrier is a .xed point of F . If it exists, the initial F -algebra is unique up to isomor\u00adphism. \nWe write (\u00b5F, in)for the initial F -algebra comprising the .xed point \u00b5F and the isomorphism in :F (\u00b5F \n).\u00b5F . 4.2.1 Folds The standard interpretation of a type constructor is a functor F , and the standard \ninterpretation of the inductive type it de.nes is the carrier of the initial algebra of F . Initiality \nensures that there is a unique F -algebra homomorphism from the initial F \u00adalgebra to any other F -algebra. \nThe map underlying this F -algebra homomorphism is exactly the fold for \u00b5F . Thus if (A, h)is any F -algebra, \nthen fold h :\u00b5F .A makes the following diagram commute: F (fold h) - F (\u00b5F ) FA in h fold h - \u00b5F A \n From this diagram, we see that fold :(FA .A).\u00b5F .A and that fold h satis.es fold h (in t)= h (F (fold \nh) t). This justi.es the de.nition of the fold combinator given in Sec\u00adtion 4.1. Furthermore, the uniqueness \nof the mediating morphism ensures that, for every algebra h,the map fold h is de.ned uniquely. This provides \nthe basis for the correctness of fold fu\u00adsion for inductive types, which derives from the fact that if \nh and h ' are F -algebras and . is an F -algebra homomorphism from h to h ' ,then .. fold h = fold . \nBut note that fold h ' fusion [Bayley (2001), Blampied (2000), Bird &#38; Paterson (1998), Bird &#38; \nPaterson (1999), Martin et al. (2004)] is distinct from, and inherently simpler than, the fold/build \nfusion in this paper. 4.2.2 Church Encodings, builds, and fold/build Fusion Rules Although the above \ndiscussion shows that fold combinators for in\u00adductive types can be derived entirely from, and understood \nentirely in terms of, initial algebra semantics, regrettably the standard initial algebra semantics does \nnot provide a similar principled derivation of the build combinators or the correctness of the fold/build \nrules. In fact, build has been regarded as a kind of optional add\u00adon which is not a fundamental part \nof the basic infrastructure for programming with inductive types. The practical consequence of this is \nthat the build combinators have been largely overlooked, treated as poor relatives of their corresponding \nfold combinators, and regarded as unworthy of fundamental study. This situation was recti.ed in [Ghani \net al. (2003)], where the standard initial algebra semantics was extended to support not only fold combinators \nfor inductive types, but also Church encod\u00adings and build combinators for them. Indeed, [Ghani et al. \n(2003)] considers the initial F -algebra to be not only the initial object of the category of F -algebras, \nbut also the limit of the forgetful func\u00adtor from the category of F -algebras to the underlying category \nC as well. We now summarize this result and its consequences, which we later apply to derive our combinators \nfor GADTs. If F is a functor on C, then the forgetful functor UF maps F \u00adalgebras to objects in Cby forgetting \nthe F -algebra structure. That is, UF maps an F -algebra (A, h) to its carrier A, and maps an F \u00adalgebra \nhomomorphism f : A . B between F -algebras (A, h) and (B, g) to the morphism f : A . B in C.If C is an \nobject in C,then a UF -cone for C comprises, for every F -algebra (A, h), a morphism .(A,h) : C .A in \nCsuch that, for every F -algebra map f : A .B,we have .(B,g) = f ..(A,h). f - (A, h)(B, g)  coding \nforall x. (f x-> x) -> c -> x. The term gener\u00adalized re.ects the presence of the parameter c, which is \nabsent in other Church encodings [Takano &#38; Meijer (1995)], but is essential to the derivation of \nbuild combinators for GADTs. Choosing c to be the unit type gives the usual isomorphism between the interpre\u00adtation \nof an inductive type and the interpretation of its usual Church encoding. This isomorphism comprises \nprecisely fold (up to order of arguments) and build for the interpretation of that type. Writing fold \n' mh for fold hm we have fold ' :: \u00b5F ..x.(Fx .x) .x build :: (.x.(Fx .x) .x) .\u00b5F From this we see that \ncorrectness of the fold/build rule for inductive types codes one half of the requirement that build and \nfold ' are mutually inverse. A parametric model guarantees the existence of the interpretation of the \nChurch encoding of a type constructor, which, by this isomorphism, guarantees the existence of the initial \nalgebra for the interpretation of that type constructor. Generic build combinators and Church encodings \nfor inductive types are given in [Takano &#38; Meijer (1995)], but that paper does not show how to derive \nbuilds for .xed points of higher-order functors or how to interpret GADTs as such .xed points. Indeed, \nit doesn t even mention GADTs. .(A,h) We write (C, .) for this cone, and call C its vertex and the mor\u00ad \n .(B,g)   5. Initial Algebra Packages for Basic GADTs In this section we give Haskell implementations \nof the initial alge\u00ad bra packages for basic GADTs derived from the initial algebra se\u00admantics developed \nfor them in Section 3. From Section 3 we have C phism .(A,h) the projection from C to A.A UF -cone with \nvertex C can be thought of as having the type .x.(Fx .x) .C .x. that the interpretation of the basic \nGADT data Gf ha where A UF -cone morphism g :(C, .) . (D, \u00b5) between UF -cones (C, .) and (D, \u00b5) is \na morphism g : C . D in Csuch that for any F -algebra (A, h),we have \u00b5(A,h) .g = .(A,h).A UF -limit is \na UF -cone to which there is a unique UF -cone morphism, called the mediating morphism, from any other \nUF -cone. When they ex\u00adist, UF -limits are unique up to isomorphism. Moreover, no extra structure is \nrequired of either F or Cfor the UF -limit to exist it simply comprises the carrier of the initial F \n-algebra together with the family of F -algebra-indexed fold functions. In [Ghani et al. (2003)], the \ncharacterization of the initial F \u00adalgebra as both the above limit and the initial object in the category \nof F -algebras is called the extended initial algebra semantics.As shown there, an initial F -algebra \nhas a different universal property as a limit from the one it inherits as an initial object. This alternate \nuniversal property ensures: For each F -algebra, the projection from the vertex of the UF \u00adlimit (i.e., \nfrom \u00b5F ) to the carrier of that F -algebra de.nes fold :(Fx .x) .\u00b5F .x.  The unique mediating morphism \nfrom the vertex C of a UF -cone to the vertex \u00b5F of the UF -limit de.nes build : (.x. (Fx . x) . C . \nx) . C . \u00b5F to be build g = gin. This justi.es the de.nition of the build combinator given in Section \n4.1.  Correctness of the fold/build rule follows from the fact that fold h. build g = gh, i.e., that \nfold after build is a projection after a mediating morphism from C to \u00b5F , and is thus equal to the projection \nfrom C to the carrier of h.Taking C to be the unit type proves the correctness, relative to the underlying \nsemantics, of the fold/build rule given in Section 4.1.  The extended initial algebra semantics thus \nshows that, given a parametric interpretation of universal quanti.cation of types, there is an isomorphism \nbetween the interpretation of the type c->Mf and the interpretation of its generalized Church en- GCon \n:: f (G f h)a -> G fh (h a) is isomorphic to the interpretation of data NG fh awhere NGCon ::K fh (NG \nfh) a-> NG fha which is the carrier of the initial algebra of the interpretation of Kfh,where data Kf \nhg a= forall b. HFunctor f=> K(Eql (hb) a, fg b) Instantiating the fundamental theory we get the fold \ncombinator foldNG :: (HFunctor f, Functor h) => Nat (K fh a) a-> Nat (NG fh) a foldNG m (NGCon u) = m \n(hfmap (foldNG m) u) the generalized Church encoding (forall a.Nat (K fh a)a -> Nat ca) and the build \ncombinator buildNG :: HFunctor f => (forall a. Nat (K f h a) a -> Nat ca) -> Nat c(NG fh) buildNG g \n= g NGCon for NGfh. Here, the instance of hfmap in the de.nition of foldNG is the one for the HFunctor \nK f h.We have the fold/build rule foldNG m .buildNG g =gm for NGf h.If we de.ne toNG :: HFunctor f=> \nGf ha -> NG fh a toNG (GCon t) = NGCon (K (Refl, hfmap toNG t)) fromNG :: (HFunctor f, Functor h) => \nNG fh a-> G fha fromNG = foldNG (toK GCon) foldG :: HFunctor f => (forall a. f x a -> x (h a)) -> Nat \n(Gf h) x foldG m (GCon t) = m (hfmap (foldG m) t) --generalized Church encoding forall y.(forall a. fy \na-> y(h a)) -> Natc y buildG :: HFunctor f => (forall y. (forall a. f y a -> y (h a)) -> Natc y) -> Nat \nc (G f h) buildG g = g GCon --fold/build rule foldG m .buildG g= gm Figure 3. Generic initial algebra \npackage for GADTs. then we have that toNG and fromNG are Haskell codings of mutual inverses. We can therefore \nuse these functions to derive from the initial algebra package for NG fh the one for Gfh given in Figure \n3. The derivation is based on the following de.nitions: foldG :: HFunctor f => (forall a. f x a -> x \n(h a)) -> Nat (G fh) x foldG m t = foldNG (toK m) (toNG t) buildG :: HFunctor f => (forall y. (forall \na. f y a -> y (h a)) ->Nat c y) -> Nat c(G f h) buildG g = fromNG . (buildNG g ) where g k = g (fromK \nk) The instance of hfmap in the de.nition of foldG is the one for f. Note that foldG terminates since \nit is structurally recursive. Unwinding these de.nitions justi.es the de.nitions in Figure 3.  6. More \nGeneral GADTs We have seen how a basic GADT, i.e., a GADT of the form data G fh awhere GCon :: f(G f \nh) a ->G fh (h a) can be reduced to a data type NG fh using only existentials and the Eql GADT. We considered \nthis special case .rst to highlight the basic ideas underlying our approach to initial algebra semantics \nfor GADTs, as well as to avoid the cumbersome notation associated with arbitrary GADTs. In this section \nwe show how the basic syntactic restriction can be lifted, and thus how our approach can be extended \nto arbitrary GADTs. Below, the covariance restriction entails that G does not appear in any hi, and that \nany fi is a higher\u00adorder functor. The initial algebra package for the Term GADT from Section 2.1 appears \nin Section 7 below. There are four independent dimensions along which basic GADTs can be generalized. \n 6.1 GADTs with Non-Unary Data Constructors If we have a GADT of the form data G f1 f2 ha where GCon \n::f1 (G f1f2 h) a-> f2 (G f1 f2 h) a -> Gf1 f2h (h a) then we can curry GCon to derive a data constructor \nwhich takes one tupled argument. The above GADT is thus equivalent to: data G f1 f2 h a where GCon :: \nPrHFunctor f1 f2 (G f1 f2 h) a -> G f1 f2h (h a) where PrHFunctor f1 f2 is the higher-order functor \ngiven by newtype PrHFunctor f1 f2 g a = PrHFunctor (f1 g a, f2 g a) It is easy to check that PrHFunctor \nf1 f2 is an HFunctor. Thus we can reduce a GADT whose data constructor takes several inputs to one whose \ndata constructor takes only a single input. An example of a GADT with a non-unary data constructor is \nTerm. 6.2 GADTs with More Than One Data Constructor The presence of the different functors h1 and h2 \nin the codomain types of the data constructors GCon1 and GCon2 of a GADT Gf1f2h1 h2 of the form data \nGf1 f2 h1 h2 a where GCon1 ::f1 (G f1f2 h1 h2) a-> Gf1f2 h1h2(h1 a) GCon2 ::f2 (G f1f2 h1 h2) a-> Gf1f2 \nh1h2(h2 a) entails that it is not possible to reduce a GADT with two data constructors to a GADT with \none data constructor. Nevertheless, we can still show that a GADT with more than one data constructor \ncan be reduced to a GADT using only existentials and the Eql GADT, and also derive an initial algebra \nsemantics for it. The basic idea is to treat each data constructor individually. That is, we use the \nsame technique as we used for single data constructor GADTs to convert the type of each data constructor \nof a GADT Gf1 f2h1 h2 into a type whose codomain is of the form Gf1 f2h1h2 a, and thus avoid the nesting \nof functors in the data constructors codomain types. Concretely, we transform the GADT Gf1f2h1 h2 into \nthe following equivalent GADT: data NG f1 f2 h1 h2 a where NGCon1 :: Kf1 h1 (NG f1 f2 h1h2) a -> NG f1f2 \nh1 h2a NGCon2 :: Kf2 h2 (NG f1 f2 h1h2) a -> NG f1f2 h1 h2a The return types of the data constructors \nof NG f1 f2h1 h2 are the same, and this GADT uses only existentials and the Eql GADT. The two data constructors \ncan now be bundled into one in the usual way, so that the interpretation of NGf1 f2 h1h2 is the carrier \nof the initial algebra of the higher-order functor interpreting newtype SumKs f1 f2 h1 h2 g a =Inl (K \nf1 h1g a) | Inr (Kf2 h2 ga) It is not hard to check that SumKs f1 f2 h1 h2 is indeed an HFunctor. We \ncan therefore derive an initial algebra semantics, and hence an initial algebra package, for NG f1 f2h1 \nh2.Us\u00ading toK and fromK, we can derive one for the original GADT Gf1f2h1 h2 as well. An example of a \nGADT with more than one data constructor is the Fin GADT from Example 1 below. 6.3 GADTs with More Than \nOne Type Parameter Consider a GADT G fh1 h2 ab data Gf h1 h2a bwhere GCon :: f (G f h1h2) a b-> Gf h1 \nh2(h1 a b) (h2 a b) with two type parameters. In Haskell, the kinds of h1, h2, f,and Gf h1h2 are h1, \nh2 :: |*| -> |*| -> |*| f:: (|*| -> |*| ->*) -> |*| ->|*| -> * Gf h1h2 :: |*| ->|*| -> * We can treat \nthis GADT by rewriting the type of GCon in terms of the type K representing left Kan extensions and the \nEql GADT, although K must be generalized to take two type arguments as input. This yields the de.nition \ndata BiK f h1 h2 ga b= forall c1 c2. BiHFunctor f => BiK (Eql (h1 c1 c2) a, Eql (h2 c1 c2) b, fgc1 c2) \nwhere BiHFunctor is the generalization class BiHFunctor f where mhfmap :: MNat g h -> MNat (f g) (f h) \ntype MNat f g= forall c1 c2. fc1 c2 -> g c1c2 of the HFunctor class to two type parameters which is required \nto capture the structure of f here. It is not hard to see that BiK fh1 h2 is an instance of the BiHFunctor \nclass: instance BiHFunctor f => BiHFunctor (BiK f h1 h2) where mhfmap k (BiK (p, q, v)) = BiK (p, q, \nmhfmap k v) The key universal property of the form of Kan extension captured by BiK is that there is \nan isomorphism between the interpretation of the type forall ab. fg ab -> g (h1 ab) (h2 ab) and the interpretation \nof the type forall ab. BiK fh1 h2 g ab -> gab The GADT Gf h1 h2a b is thus equivalent to the GADT data \nNG fh1 h2 ab where NGCon :: BiKf h1 h2 (NG f h1 h2) a b-> NG fh1 h2ab for which an initial algebra semantics \nis easily given, since the interpretation of NGf h1 h2 is the carrier of the initial algebra of the interpretation \nof BiKfh1 h2. An example of a GADT with more than one type parameter is the Expr GADT from Example 3. \n 6.4 GADTs Whose Data Constructors Have More Than One Type Parameter Consider a GADT of the form data \nG fh awhere GCon ::f (G f h) ab-> G fh (h a b) where the Haskell kinds of h, f,and Gfh are h :: |*| -> \n|*| -> |*| f:: (|*| -> *) ->|*| -> |*| -> * Gf h:: |*| -> * Without loss of generality, we may assume \nthat the number of type variables appearing in the domain type f(G fh) ab of GCon is the same as the \nnumber appearing in GCon s return type. We can treat a GADT Gfh of this form by rewriting the type of \nGCon in terms of the data type K representing left Kan extensions and the Eql GADT, although K must be \ngeneralized to allow h to take more than one type argument as input. This yields the de.nition data VK \nf h g a = forall c1 c2. VHFunctor f => VK(Eql (h c1 c2) a,f gc1 c2) where VHFunctor is the generalization \nclass VHFunctor f where vhfmap :: Nat g h -> MNat (f g) (f h) of the HFunctor class which allows f to \nreturn a type constructor parameterized over two type variables. It is not hard to see that VK fh is \nan instance of the VHFunctor class: instance VHFunctor f => HFunctor (VK f h) where hfmap k (VK (p, \nv)) = VK (p, vhfmap k v) The key universal property of the form of Kan extension captured by VK is that \nthere is an isomorphism between the interpretation of the type forall a b. fga b-> g(h a b) and the interpretation \nof the type forall a. VK fh ga ->g a The GADT Gfha is thus equivalent to the GADT data NG fh awhere NGCon \n::VK fh (NG fh) a-> NG fh a for which an initial algebra semantics is easily given, as the inter\u00adpretation \nof NG fh is the carrier of the initial algebra of the in\u00adterpretation of VKf h. An example of a (single \nparameter) GADT whose data constructor has more than one type parameter is Term.4 In summary, our techniques \nextend from basic GADTs to GADTs G of the form G f1 ... fk h11 ... h1n ... hk1 ... hkn where n is the \nnumber of type arguments G takes, and G is given as a list of data constructors with types of the form \nfi G ai1 ... airi -> G (hi1 ai1 ... airi) ... (hin ai1 ... airi) As discussed above, any constructor \ntaking several arguments can be exchanged for a constructor taking exactly one argument. Thus for every \ndata constructor of every GADT there is an appropriate Kan extension which can be used to trade that \ndata constructor for one based on existentials and the Eql GADT, and from which an initial algebra semantics \nfor the original GADT can be derived. Thus, the proliferation of different codings of Kan extensions, \nwhich seems a drawback at .rst, simply re.ects the fact that Haskell does not have a proper polymorphic \nsystem of kinds. If it did, then only one polykinded Kan extension would be required and we would be \nable to present the general case from the start rather than a special case followed by a sketch of the \ngeneral case.  7. Examples In this section we show how to derive initial algebra packages for some familiar \nGADTs. EXAMPLE 1. Consider the GADT of .nite sets [Sheard et al. (2005)] given by data Z data Sa data \nFin a where Fz ::Fin (S a) Fs ::Fin a -> Fin (S a) Note that Fin Z is empty. This GADT is equivalent \nto the GADT 4 An alternative way to handle a data constructor such as App which has more type variables \nin its domain type than in its return type is to wrap the extra type variables in the domain type in \nan existential quanti.er. This is justi.ed by observing that a type of the form forall b.f b -> g, where \nf is a type parameterized over b and g is a type in which b does not appear, is equivalent to the type \n(exists b. f b) -> g. Combined with the tupling described in Section 6.1, this allows us to trade, for \nexample, the App data constructor for the equivalent data constructor App :: exists b. (Term (b -> a), \nTerm b) -> Term a in whose domain type only the type variables appearing in the return type of the constructor \nappear free. foldFin :: (forall a. f (S a)) -> (forall a. fa -> f(S a)) ->Nat Fin f foldFinzs Fz =z foldFin \nz s (Fs t) = s (foldFin z s t) --generalized Church encoding forall f. (forall a. f (S a)) -> (forall \na. fa -> f(S a)) ->Nat c f buildFin :: (forall f. (forall a. f (S a)) -> (forall a. fa ->f (S a)) -> \nNat cf) -> Nat c Fin buildFin g = g Fz Fs --fold/build rule foldFin z s . (buildFin g) = g z s Figure \n4. Initial algebra package for Fin. data NFin a where NFz::LanSOnea -> NFina NFs :: Lan SNFin a -> NFin \na which has initial algebra package foldNFin :: (forall a. Lan S One a -> f a) -> (forall a. Lan Sf a-> \nfa) -> Nat NFin f foldNFin z s(NFz k) =z k foldNFin z s (NFs t) = s (hfmap (foldNFin z s) t) buildNFin \n:: (forall f. (forall a. Lan S Onea -> fa) -> (forall a. Lan S fa-> f a) -> Nat cf) -> Natc NFin buildNFin \ng = g NFz NFs foldNFin z s . (buildNFin g) = g z s The de.nitions of foldG and buildG in Section 5 can \nbe instanti\u00adated to give the initial algebra package in Figure 4 relative to Fin. EXAMPLE 2. Consider \nagain the GADT Term [Sheard et al. (2005)] data Term a where Const :: a -> Term a Pair :: Term b -> Term \nc -> Term (b,c) App ::Term(b->a)->Termb-> Terma from Section 2.1. This GADT is equivalent to newtype \nFst a b = Fst a newtype HProd g a b = HProd (g a, g b) newtype Prod a b = Prod (a, b) dataHLfab =HL(f(b->a),fb) \n data NTerm a where NConst :: a -> NTerm a NPair :: VK HProd Prod NTerm a -> NTerm a NApp :: VK HL Fst \nNTerm a -> NTerm a where VK is de.ned as in Section 6.4. Note that HProd and HL are instances of the \nVHFunctor class: instance VHFunctor HProd where vhfmap k (HProd (u,v)) = HProd (k u, k v) instance VHFunctor \nHL where foldTerm :: (forall a. a -> f a) -> (forall a b. f a-> f b-> f(a,b)) -> (forall a b. f (b ->a) \n-> fb ->f a) -> Nat Term f foldTerm c p a (Const v) = c v foldTerm c p a (Pair u v) = p (foldTerm c p \na u) (foldTerm c p a v) foldTermcpa(Apptu) =a(foldTermcpat) (foldTerm c p a u) --generalized Church \nencoding forall f. (forall a. a -> f a) -> (forall a b. f a-> fb -> f(a,b)) -> (forall a b. f (b ->a) \n-> fb ->f a) -> Natcf buildTerm :: (forall f. (forall a. a -> f a) -> (forall a b. f a-> fb -> f(a,b)) \n-> (forall a b. f (b ->a) -> fb ->f a) -> Nat c f) -> Nat cTerm buildTerm g = g Const Pair App --fold/build \nrule foldTerm cp a. (buildTerm g) =g cp a Figure 5. Initial algebra package for Term. vhfmap k (HL (u,v)) \n= HL (k u, k v) The GADT NTerm has initial algebra package foldNTerm :: (forall a. a -> f a) -> (forall \na. VK HProd Prod f a -> f a) -> (forall a. VK HL Fst fa-> f a) -> Nat NTerm f foldNTerm c p a (NConst \nv) = c v foldNTerm c p a (NPair t) = p (hfmap (foldNTerm c p a) t) foldNTerm c p a (NApp t) = a (hfmap \n(foldNTerm c p a) t) buildNTerm :: (forall f. (forall a. a -> f a) -> (forall a. VK HProd Prod f a -> \nf a) -> (forall a. VKHL Fst fa ->f a) -> Nat c f) -> Nat c NTerm buildNTerm g = g NConst NPair NApp \nfoldNTerm c p a . (buildNTerm g) = g c p a The de.nitions of foldG and buildG from Section 5 can be in\u00adstantiated \nto give the initial algebra package in Figure 5 relative to Term. EXAMPLE 3. Consider the GADT of polynomial \nexpressions with variables of type a and coef.cients of type b given by data Expr a b where Var ::a -> \nExprab IConst :: Int -> Expr a Int RConst :: Float -> Expr a Float PProd ::Exprab->Exprab->Exprab SIMul \n::Exprab->Int->Exprab SRMul :: Expr a b -> Float -> Expr a Float This GADT is equivalent to the GADT \ndata NExpr a b where NVar ::a-> NExprab NIConst :: MK HInt Fst KInt NExpr a b -> NExpr a b NRConst :: \nMK HFloat Fst KFloat NExpr a b -> NExpr a b NPProd :: H2Prod NExpr a b -> NExpr a b NSIMul :: H2ProdInt \nNExpr a b -> NExpr a b NSRMul :: MK H2ProdFloat Fst KFloat NExpr a b -> NExpr a b where BiK is as de.ned \nin Section 6.3 and newtype KInt a b = KInt Int newtype KFloat a b = KFloat Float dataHInt gab=HIntInt \ndata HFloat g a b = HFloat Float dataH2Prod gab=H2Prod(gab, gab) data H2ProdInt g a b = H2ProdInt (g \na b, Int) data H2ProdFloat g a b = H2ProdFloat (g a b, Float) Note that HInt, HFloat, H2Prod, H2ProdInt, \nand H2ProdFloat are instances of the BiHFunctor class from Section 6.3. Indeed, instance BiHFunctor HInt \nwhere mhfmap s (HInt t) = (HInt t) instance BiHFunctor HFloat where mhfmap s (HFloat t) = (HFloat t) \ninstance BiHFunctor H2Prod where mhfmap s (H2Prod (u,v)) = H2Prod (s u, s v) instance BiHFunctor H2ProdInt \nwhere mhfmap s (H2ProdInt (u,v)) = H2ProdInt (s u, v) instance BiHFunctor H2ProdFloat where mhfmap s \n(H2ProdFloat (u,v)) = H2ProdFloat (s u, v) The GADT NExpr has initial algebra package foldNExpr :: (forall \na b. a -> f a b) -> (forall a b. BiK HInt Fst KInt f ab -> f ab) -> (forall a b. BiK HFloat Fst KFloat \nf a b -> f ab) -> (forall a b. H2Prod fa b-> fa b) -> (forall a b. H2ProdInt f a b -> f a b) -> (forall \na b. BiK H2ProdFloat Fst KFloat f a b -> f ab) -> NExpr ab -> fa b foldNExprvirpsisr(NVart) =vt foldNExpr \nv i r p si sr (NIConst t) = i (mhfmap (foldNExpr v i r p si sr) t) foldNExpr v i r p si sr (NRConst t) \n= r (mhfmap (foldNExpr v i r p si sr) t) foldNExpr v i r p si sr (NPProd t) = p (mhfmap (foldNExpr v \ni r p si sr) t) foldNExpr v i r p si sr (NSIMul t) = si (mhfmap (foldNExpr v i r p si sr) t) foldNExpr \nv i r p si sr (NSRMul t) = sr (mhfmap (foldNExpr v i r p si sr) t) buildNExpr :: (forall f. (forall a \nb. a ->f ab) -> (forall a b. BiK HInt Fst KInt f ab -> f ab) -> (forall a b. BiK HFloat Fst KFloat f \na b -> fa b)-> foldExpr :: (forall a b. a -> f a b) -> (forall a. Int -> f a Int) -> (forall a. Float \n-> f a Float) -> (forall a b. f ab ->f ab -> f ab) -> (forall a b. f ab ->Int -> fa b)-> (forall a b. \nf a b -> Float -> f a Float) -> forall ab. Expr a b-> fa b foldExprvirpsisr(Vart) =vt foldExprvirpsisr(IConstt) \n=it foldExprvirpsisr(RConstt) =rt foldExprvirpsisr(PProdtu) = p (foldExpr v i r p si sr t) (foldExprvirp \nsisru) foldExprvirpsisr(SIMul tn) = si (foldExpr v ir psi sr t)n foldExprvirpsisr(SRMul tn) = sr (foldExpr \nv ir psi sr t)n buildExpr :: (forall f. (forall a b. a ->f ab) -> (forall a. Int -> f a Int) -> (forall \na. Float -> f a Float) -> (forall a b. f ab ->f ab -> f ab) -> (forall a b. f ab ->Int -> fa b)-> (forall \na b. f a b -> Float -> f a Float) -> MNat c f) -> MNat c Expr buildExpr g = g Var IConst RConst PProd \nSIMul SRMul --fold/build rule foldExpr v i r p si sr . (buildExpr g) = gvirpsi sr Figure 6. Initial algebra \npackage for Expr. (forall ab. H2Prod fab -> fa b)-> (forall a b. H2ProdInt f a b -> f a b) -> (forall \na b. BiK H2ProdFloat Fst KFloat f a b -> f a b) -> MNat c f) -> MNat c NExpr buildNExpr g = g NVar NIConst \nNRConst NPProd NSIMul NSRMul foldNExpr v i r p si sr . buildNExpr g = gvirpsi sr The de.nitions in Section \n5 give the initial algebra package in Figure 6 relative to the original GADT Expr. 8. Conclusion and \nFuture Work In this paper we have shown that the standard view of data types as carriers of initial algebras \nof functors can be extended from alge\u00adbraic and nested data types to GADTs. We have used this observa\u00adtion \nto derive an initial algebra semantics and initial algebra pack\u00adages for GADTs and, thereby, to provide \nexpressive and principled tools for reasoning about, programming with, and improving the performance \nof programs involving, GADTs. We have also given a constructive demonstration that every GADT can be \nreduced to one which involves only the equality GADT and existential quan\u00adti.cation. Our reduction is \nlocal, independent of any particular syn\u00adtactic presentation of GADTs, and implementable in the host \nlan\u00adguage. Our approach to initial algebra semantics for GADTs is based on an interpretation of them \nas carriers of initial algebras of higher-order functors which map functors with discrete domains to \nfunctors with discrete domains, rather than functors with pos\u00adsibly nondiscrete domains to functors with \npossibly nondiscrete domains, and on the use of left Kan extensions as a restructuring device. Our use \nof left Kan extensions here is reminiscent of their use in [Johann &#38; Ghani (2007a), Johann &#38; \nGhani (2007b)] to de\u00adrive initial algebra semantics for nested data types. The foundations of GADTs and \nother advanced inductive con\u00adstructions have been considered from the type-theoretic perspec\u00adtive; see, \ne.g., [Pfenning &#38; Paulin-Mohring (1990)], which consid\u00aders inductive types in the Calculus of Constructions. \nThis work gives fold combinators for GADTs, as well as Church encod\u00adings which are essentially the special \ncase of our generalized Church encodings obtained by taking the parameter c to be the constantly 1-valued \ntype constructor. The importance of gener\u00adalised Church encodings is discussed in [Johann &#38; Ghani \n(2007a), Johann &#38; Ghani (2007b)]. The relationship between our work and that of Pfenning and Paulin-Mohring \nis the subject for future re\u00adsearch, but we see our categorical approach as complementary to their type-theoretic \none. Also, our use of left Kan extensions to trade GADT constructors for simpler nested type constructors \nprovides a clean and concise derivation of the folklore result stat\u00ading that the essence of GADTs is \nexistential quanti.cation cou\u00adpled with the equality GADT. Our treatment of the foundations of GADTs \nas GADTs, rather than as embedded within more general type theories, is fundamental to our results. Our \nmain direction for future work involves extending the re\u00adsults of this paper from GADTs, which are indexed \nby types, to styles of indexed programming which allow more general indices. This paper and [Johann &#38; \nGhani (2007a), Johann &#38; Ghani (2007b)] together make clear that the fundamental structure underlying \nthe algebra of nested data types and GADTs is captured by functorial composition and its adjoints, namely \nleft and right Kan extensions. The mathematical basis for generalizing this structure to encom\u00adpass other \nforms of indexing is clear. We will therefore consider indexed programming in the context of .brations. \n  Acknowledgments Patricia Johann is supported in part by NSF grant CCF-0700341. Neil Ghani is supported \nin part by EPSRC grant EP/C511964/2.  References [Bainbridge et al. (1990)] E. S. Bainbridge, P. J. \nFreyd, A. Scedrov and P. J. Scott. Functorial polymorphism. Theoretical Computer Science 70(1) (1990), \npp. 35 64. [Bayley (2001)] I. Bayley. Generic Operations on Nested Datatypes. Ph.D. Dissertation, Univ. \nof Oxford, 2001. At http://web.comlab.ox. ac.uk/oucl/research/areas/ap/papers/bayley-thesis.pdf [Blampied \n(2000)] P. Blampied. Structured Recursion for Non-uniform Data-types. Ph.D. Dissertation, Univ. of Nottingham, \n2000. At http://www.cs.nott.ac.uk/Research/fop/blampied-thesis .pdf [Bird &#38; Meertens (1998)] Bird, \nR. and Meertens, L. Nested datatypes. Proc., Mathematics of Program Construction, pp. 52 67, 1998. [Bird \n&#38; Paterson (1998)] R. Bird and R. Paterson. de Bruijn notation as a nested datatype. Journal of Functional \nProgramming 9(1) (1998), pp. 77 91. [Bird &#38; Paterson (1999)] R. Bird and R. Paterson. Generalised \nfolds for nested datatypes. Formal Aspects of Computing 11(2) (1999), pp. 200 222. [Cheney &#38; Hinze \n(2003)] J. Cheney and R. Hinze. First-class phan\u00ad tom types. At http://www.informatik.uni-bonn.de/~ralf/ \npublications/Phantom.pdf [Dybjer (1994)] P. Dybjer. Inductive Families. Formal Aspects of Comput\u00ading \n6(4), pp. 440 465, 1994. [Gill et al. (1993)] A. Gill, J. Launchbury, and S. L. Peyton Jones. A short \ncut to deforestation. Proceedings, Functional Programming Languages and Computer Architecture, pp. 223 \n232, 1993. [Ghani et al. (2005)] N. Ghani, P. Johann, T. Uustalu, and V. Vene. Monadic augment and generalised \nshort cut fusion. Proceedings, International Conference on Functional Programming, pp. 294 305, 2005. \n[Ghani et al. (2003)] N. Ghani, T. Uustalu, and V. Vene. Build, augment and destroy. Universally. Proceedings, \nAsian Symposium on Program\u00adming Languages, pp. 327 347, 2003. [Johann &#38; Ghani (2007a)] P. Johann \nand N. Ghani. Initial algebra seman\u00adtics is enough! Proceedings, Typed Lambda Calculus and Applications, \npp. 207 222, 2007. [Johann &#38; Ghani (2007b)] P. Johann and N. Ghani. Programming with Nested Types. \nSubmitted, 2007. [Johann (2002)] P. Johann. A generalization of short-cut fusion and its correctness \nproof. Higher-order and Symbolic Computation 15 (2002), pp. 273 300. [MacLane (1971)] MacLane, S. Categories \nfor the Working Mathemati\u00adcian. Springer-Verlag, 1971. [Martin et al. (2004)] C. Martin, J. Gibbons, \nand I. Bayley. Disciplined ef.cient generalised folds for nested datatypes. Formal Aspects of Computing \n16(1) (2004), pp. 19 35. [McBride (2004)] C. McBride. Epigram: Practical programming with de\u00adpendent \ntypes. Proceedings, 5th International Summer School on Ad\u00advanced Functional Programming, 2004. At http://www.e-pig.org/ \ndownloads/epigram-notes.pdf [Omega] The Omega Download Page. http://web.cecs.pdx.edu/ ~sheard/Omega/index.html \n[Pfenning &#38; Paulin-Mohring (1990)] F. Pfenning and C. Paulin-Mohring. Inductively de.ned types in \nthe Calculus of Constructions. Proceedings, Mathematical Foundations of Programming Semantics, pp. 209-228, \n1990. [Sheard et al. (2005)] T. Sheard, J. Hook, and N. Linger. GADTs + exten\u00adsible kinds = dependent \nprogramming. At http://www.cs.pdx.edu/ ~sheard/papers/GADT+ ExtKinds.ps [Sheard &#38; Pasalic (2004)] \nT. Sheard and E. Pasalic. Meta-programming with built-in type equality. Proceedings, Logical Frameworks \nand Meta\u00adlanguages, 2004. At http://homepage.mac.com/pasalic/p2/ papers/LFM04 .pdf [Sulzmann &#38; Wang \n(2004)] M. Sulzmann and M. Wang. A systematic translation of guarded recursive data types to existential \ntypes. At http://www.comp .nus.edu.sg/~sulzmann/research/ms.html [Sulzmann &#38; Wang (2005)] M. Sulzmann \nand M. Wang. Translating generalized algebraic data types to System F. Manuscript, 2005. At http://www.comp. \nnus.edu.sg/~sulzmann/manuscript/simple -translate-gadts. ps [Svenningsson (2002)] J. Svenningsson. Shortcut \nfusion for accumulating parameters &#38; zip-like functions. Proceedings, International Conference on \nFunctional Programming, pp. 124 132, 2002. [Takano &#38; Meijer (1995)] A. Takano and E. Meijer. Shortcut \ndeforestation in calculational form. Proceedings, Functional Programming Languages and Computer Architecture, \npp. 306 313, 1995. [Xi et al. (2003)] H. Xi, C. Chen, and G. Chen. Guarded recursive datatype constructors. \nProceedings, Principles of Programming Languages, pp. 224 235, 2003. [Xi &#38; Pfenning (1999)] H. Xi \nand F. Pfenning. Dependent types in practical programming. Proceedings, Principles of Programming Languages, \npp. 214 227, 1999. \n\t\t\t", "proc_id": "1328438", "abstract": "<p>GADTs are at the cutting edge of functional programming and becomemore widely used every day. Nevertheless, the semantic foundations underlying GADTs are not well understood. In this paper we solve this problem by showing that the standard theory of data types as carriers of initial algebras of functors can be extended from algebraic and nested data types to GADTs. We then use this observation to derivean initial algebra semantics for GADTs, thus ensuring that all of the accumulated knowledge about initial algebras can be brought to bear on them. Next, we use our initial algebra semantics for GADTs to derive expressive and principled tools --- analogous to the well-known and widely-used ones for algebraic and nested data types---for reasoning about, programming with, and improving the performance of programs involving, GADTs; we christen such a collection of tools for a GADT an initial algebra package. Along the way, we give a constructive demonstration that every GADT can be reduced to one which uses only the equality GADT and existential quantification. Although other such reductions exist in the literature, ours is entirely local, is independent of any particular syntactic presentation of GADTs, and can be implemented in the host language, rather than existing solely as a metatheoretical artifact. The main technical ideas underlying our approach are (i) to modify the notion of a higher-order functor so that GADTs can be seen as carriers of initial algebras of higher-order functors, and (ii) to use left Kan extensions to trade arbitrary GADTs for simpler-but-equivalent ones for which initial algebra semantics can bederived.</p>", "authors": [{"name": "Patricia Johann", "author_profile_id": "81100058482", "affiliation": "Rutgers University, Camden, NJ", "person_id": "P220019", "email_address": "", "orcid_id": ""}, {"name": "Neil Ghani", "author_profile_id": "81100427276", "affiliation": "University of Nottingham, Nottingham, United Kingdom", "person_id": "PP43135693", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328475", "year": "2008", "article_id": "1328475", "conference": "POPL", "title": "Foundations for structured programming with GADTs", "url": "http://dl.acm.org/citation.cfm?id=1328475"}