{"article_publication_date": "01-07-2008", "fulltext": "\n The Intensional Content of Rice s Theorem (Pearl) Andrea Asperti Department of Computer Science, University \nof Bologna Mura Anteo Zamboni 7, 40127, Bologna, ITALY asperti@cs.unibo.it Abstract The proofs of major \nresults of Computability Theory like Rice, Rice-Shapiro or Kleene s .xed point theorem hide more informa\u00adtionof \nwhatis usuallyexpressedin their respective statements.We make this informationexplicit, allowingto state \nstronger,complex\u00adity theoretic-versions of all these theorems. In particular,we replace the notion of \nextensional set of indices of programs, by a set of in\u00addices of programs having not only the same extensional \nbehavior but also similar complexity (Complexity Clique).We prove, under very weak complexity assumptions, \nthat anyrecursive Complexity Clique is trivial, and any r.e. Complexity Clique is an extensional set \n(and thus satis.es Rice-Shapiro conditions). This allows, for in\u00adstance, to use Rice s argument to prove \nthat the property of having polynomial complexity is not decidable, and to use Rice-Shapiro to conclude \nthatitis noteven semi-decidable.We conclude the paper with a discussion of complexity-theoretic versions \nof Kleene s Fixed Point Theorem. Categories and Subject Descriptors F.4.1[Computability The\u00adory]; F.1.3[Machine-independent \ncomplexity] General Terms Theory Keywords Recursion Theory, computability 1. Introduction Recursive properties \nof extensional sets, i.e. index sets for par\u00adtial recursive functions, have been extensively studied \nsince the early days of Recursion Theory (Rice 1953; Dekker and Myhill 1958). Among intensional properties \nof programs, a major role is played by complexity. The theoretical research on effective proper\u00adties \nof recursive functions under complexityassumptions focused, since the very beginning, on complexity classes, \nthat is classes of recursive functions computable (almost everywhere) within a given bound of complexityt. \nStudies on complexity classes, mostly developed in the abstract framework promoted by Blum (Blum 1967), \nextensively investigated their order structure under set theo\u00adretic inclusion (Borodin 1972; McCreight \nand Meyer 1969), their recursivepresentabilityandthe computationalqualityofsuchapre- Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page.To copyotherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 08 January 7 12, 2008, \nSan Francisco, California, USA. Copyright c . 2008 ACM 978-1-59593-689-9/08/0001...$5.00. sentation (Lewis \n1970;Young 1969; Landweber and Robertson 1972). It is important to understand that a complexity class \nis a set of functions, and not of indices; regarded as a set of indices, it is thus extensional by de.nition. \nIf we are really interested in decid\u00adability properties of program complexity,complexity classes do not \nlook like as an adequate instrument to perform the investigation. The notion we propose here is that \nof complexity clique.Acom\u00adplexity clique (Section 2) is a set of indices for recursive functions closed \nw.r.t. indices of functions with same extension and similar complexity (de.ned in the only sensible way, \nnamely up to con\u00adstants).A complexity clique is not extensional, in general. On the other side, any extensional \nset is a complexity clique (the trivial complexity clique with arbitrary complexity). Set-theoretic (Section \n3) and, especially, recursive properties of complexity cliques are investigated. In particular, we general\u00adize \nboth Rice s Theorem (Section 4) and Rice-Shapiro s Theorem (Section 5), concluding with a discussion \nof Kleene s second .xed point Theorem fromacomplexity perspective(Section6). Remark\u00adably, all proofs \nremain essentially the same of their classical coun\u00adterparts: in other words, all those proofs seem to \nhide more infor\u00admation of what is expressed in their classical statements, and the notion of Complexity \nClique is precisely what is required to make this hidden information explicit (providing our original \nmotivation for their introduction). Following an old tradition, we try to stick to the appealing gen\u00aderality \nof Blum s axiomatic approach; however, axiomatization is not the focus of the paper, and we shall introduce \nnew axioms with some liberality, as far as they are satis.ed by standard complex\u00adity measures; in particular, \nwe shall introduce additional axioms boundingthecomplexityof(linear)composition,ofthe s-m-nfunc\u00adtion, \nand .nally of the universal machine. Our generalization of Rice s Theorem and other enumeration techniques \nis also different from (and in some sense complemen\u00adtaryto)the approachin(Kozen 1980): whileKozeninvestigates \nextensional properties in a sub-recursive setting, we are essentially concerned with decidability of \ncomplexity questions in a general recursive setting. 2. Similarity and Complexity Cliques We shall work \nwith n-ary partial recursive functions over natural numbers. If f is such a partial function, dom(f) \nand cod(f) re\u00adspectively denote the domain and range of f.We write f(n) . if n . dom(f). We use . for \nthe everywhere divergent function, that is dom(.)= \u00d8. Given two function f and g, we write f ~g = when \nfand g have the same graph, i.e. dom(f )= dom(g) and for any n . dom(f), f(n)= g(n).Wesaya functionis \n.nite if it has a .nite graph (i.e. dom(f ) isa .nite set).Partial functions are or\u00addered w.r.t the set-theoretic \ninclusion of their graphs: f = g if and only if graph(f) . graph(g). . is the set of all natural numbers. \nDEFINITION 1. Let f and g be partial functions on natural num\u00adbers: 1. we say f . O(g) if and only if \nthere exist n and c suchthat for any m = n, if g(m) . then f(m) = cg(m); 2. f . T(g) if and only if \nf . O(g) and g . O(f).  Note that if f . T(g) the domains of f and g may only differ for a .nite number \nof points. Let us also remark that, f . T(g) if and only if g . T(f);in particular,f . T(g) is an equivalence \nrelation. DEFINITION 2. (Blum 1967) A pair .f, F. is a computational complexity measure if f is a principal \neffective enumeration of partial recursive functions and F satis.es Blum s axioms: (a) fi(.n) .. Fi(.n) \n. (b) the predicate Fi(.n)= m is decidable We say two programs aresimilar when theycompute the same function \nand have the same complexity, up to constants: DEFINITION 3. Two programsi and j are similar (write i \n j)if and only if ~ fj = fi . Fj . T(Fi) THEOREM 4. Similarity is an equivalence relation. Proof. Obvious, \nsince similarity is de.ned as intersection of two equivalence relations. Weshall write[i] for the equivalence \nclass of i w.r.t. the similarity relation . DEFINITION 5. Let .f, F. be an abstract complexity measure.A \nset P of natural numbers is a Complexity Clique, if and only if for all i and j i . P . j i . j . P \nEXAMPLE 6. The following are examples of Complexity Cliques: 1. \u00d8 and .; 2. for any index i, [i] ; \n3. for any index i, {j|Fj . O(Fi)}.  On the other side the set {i|Fi(a)= b} (i.e. the programs whose \ncomplexity on input a is b)is nota Complexity Clique,ingeneral. 3. Simple properties of Complexity Cliques \nA set A . . of indices is extensional if, for all i and j, i . ~ A . fj = fi . j . A; this is equivalent \nto say that A is the counter-image (index set) under f of some subset of partial recursive functions. \nThe notionof Complexity Cliqueisastrict generalizationofthe notion of extensional set well known in computability \ntheory: THEOREM 7. Every extensional set is a Complexity Clique. Proof. Trivial. Of course, the converse \nis not true: for instance, the class of pro\u00adgrams with polynomial complexity is not extensional. Any \nComplexity Cliques is a union of similarity classes, in particular: THEOREM 8. Cis a Complexity Clique \nif and only if [ C =[i] i.C Proof. Trivial. As a consequence, Complexity Cliques have very good alge\u00adbraic \nproperties; in particular: THEOREM 9. Complexity Cliques, equipped with the subset rela\u00adtion, are a Complete \nBoolean Lattice. S Proof. Just note that C = i.C [i] . The rest is easy. The good set-theoretic properties \nof Complexity Cliques are to be compared with the very bad properties of Complexity Classes (stressing \nagain the strong difference between the two notions). In particular: 1. for anycomplexity measure, Complexity \nClasses are not closed under union (Hartmanis and Stearns 1965; McCreight and Meyer 1969); 2. there \nare complexity measures whose Complexity Classes are not closed under intersection1(Landweber and Robertson \n1972)  Let us .nally remark an important property about .nite functions. THEOREM 10. Let C bea Complexity \nClass and let i . C. If fi is ~ .nite then for any j suchthat fi = fj , j . C. Proof.For .nite functions, \nextensional equivalence implies similar\u00adity. 4. Generalized Rice s Theorem DEFINITION 11. A pair .f, \nF. has the s-m-n property if for all positive natural numbers m and n there exists a recursive function \ns n suchthat, for any i and all x1,...,xm m (a) fsn (i,x1,...,xm) m~ = .y1,...,yn.fi(x1,...,xm,y1,...,yn) \n(b)Fsn (i,x1,...,xm) m . T(.y1,...,yn.Fi(x1,...,xm,y1,...,yn)) Equation (a) is the standard s-m-n theorem, \nwhile equation (b) n states that the overhead introduced by the function sm is at most a constant factor: \nin fact, in standard computational models, it amounts to the cost of copying the (.xed) parameters x1,...,xm \nand then calling fi -see e.g. Cutland (1986);B\u00a8orger (1986); Odifreddi (1997). Since the set or recursivefunctions \nis closed under composition, by the s-m-n theorem we may conclude that there exists a total ~ computable \nfunction h such that fh(i,j) = fi .fj . Axioms relating the complexity of h(i, j) to the complexity of \nits components have been consideredby Lischke (1975, 1976, 1977).For the purposes of our analysis, we \nneed a tight bound: DEFINITION 12. A pair .f, F. has the (linear) time-composition property if there \nexists a total computable function h suchthat ~ (a) fh(i,j) = fi . fj (b)Fh(i,j) . T(Fi . fj +Fj ) We \nsay that it has the (linear) space-composition property if equa\u00adtion (b)isreplacedby (c)Fh(i,j) . T(max{Fi \n. fj , Fj }) Equation (b) says that the cost for computing fi(fj (x)) is, up to a constant factor, no \nmore than the cost for computing fj (x) plus the cost for computing fi on input fj (x). Similarly, the \nspace required for the same computation is the maximum among the 1An important exception are measures \nsatisfying the parallel computation property (Landweber and Robertson 1972) (see also section 5). space \nrequired for computing fj (x) and the space required for computing fi on input fj (x). The previous equations \nmay be extended to n-ary composition, provided that input variables are linearly partitioned among the \ncomponents; if duplication of some input is required, we should eventually take this cost into account, \nadding a linear overhead. Aparticular case of (multi-variable) linear composition of fre\u00adquent use in \ncomputability theory is sequencing with absence of communication, i.e. the case of a function ( fi(y) \nif fj (x) . fg(i,j)(x, y)= fj (x); fi(y)= . otherwise The aim is merely to force the evaluation of fj \n(x) before computing fi(y). According to our de.nitions Fg(i,j) . T(.xy.(Fj (x)+Fi(y))) for time and \nFg(i,j) . T(.xy.max{Fj (x), Fi(y)}) for space. In combination with the s-m-n property, .xing the parameter \nx, we have, for both time and space: LEMMA 13. There exists a total computable function c suchthat ( \nfc(i,j,x)(y)= fi(y) if fj (x) . (a) fc(i,j,x)(y)= . otherwise ( Fc(i,j,x) . T(Fi) if fj (x). (b) Fc(i,j,x) \n= . otherwise Infact,theprevious Lemmaisallweneedforthe generalizationof Rice s Theorem to Complexity \nCliques. THEOREM 14. Under the s-m-n (Def. 11) and the linear-composition (Def. 12) assumptions (either \nin time or space), a Complexity Clique P isrecursiveifandonlyifitis trivial,i.e. P = \u00d8.P = .. Proof. \nAssume P is recursive and let fp be its characteristic func\u00adtion. Suppose P is not trivial, so there \nexist a and b such that fp(a)=1 and fp(b)=0. Let m be the index of a program computing the everywhere \ndivergent function; either fp(m)=1 or fp(m)=0. Let us consider the latter case, the other one being analogous. \nLet K be a r.e. not recursive set, and let fk be its semi-decision function, i.e. dom(fk)= K. Consider \nthe following function: f(x, y)= fk(x); fa(y). By Lemma 13 there exists a total com\u00adputable function \nc such that ( fc(a,k,x)(y)= fa(y) if x .K (a) fc(a,k,x)(y)= . = fm(y) otherwise ( Fc(a,k,x) . T(Fa) if \nx .K (b) Fc(a,k,x) = . =Fm(y) otherwise Since P is a Complexity Clique, ( fp(a)=1 if x .K fp(c(a, k, \nx)) = fp(m)=0 otherwise So, .x.fp(c(k, a, x)) is a characteristic function for K;c is com\u00adputable, hence \nfp cannot be. The case fp(m)=1 is similar. The knowledgeable reader will have certainly recognized, \nin part (a) of the above proof, the traditional Rice s argument. We just rephrased it to put in evidence \nthe two elementary operations required by the transformation, namely composition and s-m-n. Providinga \ncomplexity boundforsuch operationsisthekeypoint that allows us to take complexity into account in a formal \nway. However, it is clear that, in concrete computational models, part (b) is always satis.ed (that is, \nthe program fx(x); fa(y) has, for anygiven x, the same computational complexity as fa(y). 5. Generalized \nRice-Shapiro s Theorem Rice s Theorem provides a simple structural criterion for an exten\u00adsional settofallin \nS0. Rice-Shapiro s Theorem2 does the same for S1. In a modern terminology, the result states that anycompletely \nr.e. set A of partial functions is upwardclosed and compact, i.e. fi . A ..u finite,u . A . u = fi Let \nus start considering upwardclosedness, or monotonicity. The proof is not as standard as the one for Rice \ns Theorem, and not ev\u00aderyproofis suitablefora complexity-theoretic generalization.We recall here the \nargument in Odifreddi (1997), that is particularly close to our approach. Suppose there exist two partial \nrecursive functions fi and fj such that fi . A, fj .. A and fi = fj . Let f be a recurtsive function \nsuch that ff(e)(x)= y . fi(x)= y . (e . K . fj (x)= y) where K is an arbitrary r.e. non recursive set. \nObserve that the function f is well de.ned and computable just because fi = fj . Then e . K . ff(e) . \nA and since A is completely r.e. K would be r.e. too, that is a contradiction. Thekeypointoftheaboveproof \nessentially consistsin runningin parallel two functions, namely fi(x) and fk(e); fj (x) where fk is a \nsemidecision function for K. In order to study the complexity of the composite function, we need some \nassumptions about the complexity of parallel composition. Remarkably, the subject was investigated by \nLandweber and Robertson (1972) a long time ago and for quite different reasons. DEFINITION 15. (Landweber \nand Robertson 1972)Apair .f, F. has the parallel computation property if there exists a total com\u00adputable \nfunction h suchthat ( fi(x) if Fi(x) = Fj (x)(a) fh(i,j)(x)= fj (x) otherwise (b)Fh(i,j) . T(.x.min{Fi(x), \nFj (x)}) THEOREM 16. Let P be a r.e. Complexity Clique. If i . P , fi is .nite and fi = fj then j . P \n. Proof. Suppose there exist i and j such that i . P , fi is .nite, fi = fj butj .. P . Let K be a r.e. \nnot recursive set, and let fk be its semi-decision function, i.e. dom(fk)= K.By Lemma 13 there exists \na total computable function c such that fc(j,k,x)(y)= fk(x); fj (y) Let h be the function of the parallel \ncomputation property, and let us consider ( fi(y) if Fi(y) = Fc(j,k,x)(y)fh(i,c(j,k,x))(y)= fc(j,k,x)(y) \notherwise 2There seem to be some controversy on the paternity of this result; in particular, it is attributed \nto Shapiro (1956) by Rogers (1987), pag.324, and to Myhill and Shepherdson (1955) by (Odifreddi 1997), \npag.206. We claim that ( fi(y) if x .. K fh(i,c(j,k,x))(y)= fj (y) otherwise If x .. K then fc(j,k,x)(y) \n. so, by de.nition of fh(i,c(j,k,x)), either Fi(y) . and then fh(i,c(j,k,x))(y)= fi(y) or otherwise both \nfh(i,c(j,k,x))(y) and fi(y) diverge. Conversely, suppose x .K. If fj (y) ., since fi = fj , also fi(y) \n. and hence fh(i,c(j,k,x))(y) .. If fj (y) . then, even if Fi(y) = Fc(j,k,x)(y) since fi = fj we have \nfi(y)= fj (y), and so in anycase fh(i,c(j,k,x))(y)= fj (y). The second claim is that ( T(Fi) if x .. \nK Fh(i,c(j,k,x)) . T(Fj ) otherwise Indeed if x .. K then Fc(j,k,x) = . and .y.min{Fi(y), Fc(j,k,x)(y)) \n= Fi Conversely, if x .K, by Lemma 13, Fc(j,k,x) . T(Fj ), and since by hypothesis fi is .nite, .y.min{Fi(y), \nFc(j,k,x)(y)) = Fc(j,k,x) almost everywhere, so T(.y.min{Fi(y), Fh(i,c(j,k,x))(y)} = T(Fj ) In conclusion, \nsince P is a Complexity Clique, having assumed i . P and j .. P , we have h(i, c(j, k, x)) . P . x .. \nK and thus P cannot be r.e. Let us remark that thehypothesis that fi is .nite playsa crucial role in \nthe previous proof. The point is that we have to compute a function similar to fi, if x .. K and a function \nsimilar to fj if x .K. The parallel composition of fi and fj , when x .K, might be too fast for our purposes \n(it could belong to our complexity ~ clique even if fj does not).Take for instance the case fi = fj but \nFi is uniformlyfaster then Fj :in this case the parallel composition of i and j gives an algorithm with \nthe same complexity as i. As a corollary of Theorem 16 we get the following alternative proof of Rice \ns Theorem (we repeat the statement bothfor com\u00adpleteness and for ease of reference to the new proof): \nTHEOREM 17. AComplexity CliqueP is recursive if and only if it is trivial, i.e. P = \u00d8. P = .. Proof. \nLet P bearecursiveComplexity Clique. Then both P and P arer.e. and both are Complexity Cliques, since \nComplexity Cliques are closed under complementation. Let m be and index for the everywhere divergent \nfunction. Eventually, m . P or m . P . If m . P thenby Theorem16theindexof any function must be in P \n, so P = .. Similarly, if .. P then P = .. Let us now come to the converse of Theorem 16, that is com\u00adpactness. \nIn this case, Odifreddi s proof runs as follows. Suppose A is a completely r.e. set of partial computable \nfunctions; assume fi . A but no .nite subfunction of fi is in A. Let g(t) be the partial computable function \nsuch that ( . if fx(x) . in less then t steps g(x, t)= 0 otherwise and consider the function ff(e)(x)= \ng(e, x); fi(x). It is clear that ~ ff(e) = fi if fe(e) . and ff(e) is some .nite subfunction of fi(x) \nif fe(e) .. Hence, ff(e) . A . e . K, that is a contradiction. We could probably argue that the complexity \nof g(x, t), when it terminates, is at most linear in t. However, this seems to require some delicate \nassumptions on the complexity of the intrepreter,and we .nally decided to follow a slightly different \nroute. First of all we need a slight generalization of the parallel com\u00adposition property. The problem \nis that de.nition 15 does not allow to apply different continuations to the two parallel computations \nafter termination of one of them. DEFINITION 18. A pair .f, F. has the generalized parallel com\u00adputation \nproperty if there exists a total computable function p such that for all i, i., j, j. ( fi. (fi(x)) if \nFi(x) = Fj (x) (a) fp(i,i.,j,j.)(x)= fj. (fj (x)) otherwise (! Fh(i.,i)(x) if Fi(x) = Fj (x) (b)Fp(i,i.,j,j.) \n. T .x. Fh(j.,j)(x) otherwise where h is the sequential composition function of De.nition 12. Even if \nthe de.nition is a bit involved, the generalized parallel computation property lookslikea naturalextensionof \nproperty15: roughly,theideaisthat,giventwoalgorithms,wemay arbitrarily .x a checkpoint in their respective \ncode, run them in parallel and, according to which one reaches its checkpoint .rst, drop the other computation. \nIn order to reduce the generalized property to the simpler one, it looks enough to state the existence \nof pairs and a test function (we must know which one of the two computations terminated .rst),but then \nwe should also discuss the complexityof all these new notions, thatwould drive usa bit toofaraway. THEOREM \n19. Let P be a r.e. Complexity Clique. If i . P and Fi .. O(1) then there exists j suchthat fj is .nite, \nfj = fi and j . P . Proof. Let K be a r.e. not recursive set, and let fk be its semi\u00addecision function, \ni.e. dom(fk)= K. Let m be an index for the everywhere divergent function, and let I be an index for the \nidentity. By the s-m-n property there exists a total computable function c such that fc(x,k)(y)= fk(x) \nfc(x,k) is either the everywhere divergent function if x .. K or a constant function with complexity \nFc(x,k) . T(.y.Fk(x)) = T(1) otherwise.By the generalized parallel computationproperty, ( fi(y) if Fi(y) \n= Fk(x) (a) fp(i,I,c(x,k),m)(y)= . otherwise (! Fi(y) if Fi(y) = Fk(x) (b)Fp(i,I,c(x,k),m) . T .y. . \notherwise If x .. K then for any y Fi(y) = Fk(x),hencefp(i,I,c(x,k),m)(y)= fi(y), and the two functions \nalso have the same complexity. If x .K, since Fi .. O(1) then, Fi(y) = Fk(x) only for a .nite number \nof values for y, and hence fp(i,I,c(x,k),m) is a .nite func\u00adtion. If no index of .nite sub-functions \nof fi is in P , we have fp(i,I,c(x,k),m) .. P . x .. K and thus P cannot be r.e. COROLLARY 20. Let P \nbe a r.e. Complexity Clique. If i . P and Fi .. O(1) then for every j suchthat fj ~ = fi we have j . \nP . Proof. By Theorem 19, there exists a .nite sub-function fr = fi such that r . P , and by Theorem \n16, any j such that fr = fj , independently from its complexity Fj , must belong to P . COROLLARY 21. \nNo Complexity Clique of total functions and containing (indices of) programs with non constant complexity \ncan be r.e. By the last corollary, we have e.g. that the class of programs with linear (polynomial,exponential, \n... )complexity is not r.e. (in fact, theyare all S02:see below). Corollary 20 essentially says that \nevery Complexity Clique in S01 is (morally) an extensional set; in other words, all Complexity Cliques \nin S01 have trivial complexity. Since the complement of an extensional set is also extensional, a similar \nresult holds for Complexity Cliques in .01. Precisely: COROLLARY 22. Let P be a Complexity Clique in \n.01. If i . P ~ then for every j suchthat Fj .. O(1) and fj = fi we have j . P . ~ Proof. Let i . P and \nconsider j such that Fj .. O(1) and fj = fi. If j .. P then j . P . Since P is a r.e. Complexity Clique, \nthen we are in thehypothesis of Corollary 20 and we should have i . P , that is contradictory. It is \nnatural to wonder if there are Complexity Cliques with non trivial complexity in S02. THEOREM 23. Let \nt be any total recursive function. Let Ct be the following Complexity Clique: Ct = {i|Fi . O(t)}. Then, \nCt . S02. Proof. By de.nition, Fi . O(t) if there exist n and c such that for any m = n, Fi(n) = ct(n). \nThe relation Fi(n) = ct(n) is decidable by de.nition of complexity measure (De.nition 2). Hence, Ct is \nS02. Since S02 is closed under r.e. unions, manyinteresting Complexity Cliques (such as, for instance, \nthe Cliques of programs with poly\u00adnomial complexity) are in S02. 6. Kleene s Second Fixed Point Theorem \nKleene s Second Fixed Point Theorem, in Rogers formulation (Rogers 1987), states that for anytotal recursive \nfunction f there exists an indices i suchthat fi ~ff(i). The question is if we can = always .nd a .xpoint \ni with the same complexity as f (i). In the general framework given by an arbitrary abstract com\u00adplexity \nmeasure, the best we can prove is that the two complexity of i and f(i) are related by a total recursive \nfunction. More pre\u00adcisely3: THEOREM 24. (Blum 1971) There exists a binary total recursive function h \nmonotonically increasing in its second argument such that, for any total recursive function fi there \nexists an index m suchthat, for any x, (1) fm(x)= ff(m)(x) (2) Fm(x) = h(x, Ff(m)(x)) (3) Fm(x) = Ff(m)(x) \n Fixing a particular model of computation, we may of course pro\u00advide a better estimation for h. The \ninteresting point is that, assum\u00ading the s-m-n property, the complexity of h uniquely depends from the \ncomplexity of the universal function fu: THEOREM 25. Let .f, F. be an abstract complexity measure with \nthe s-m-n property 11, and let u be an index for the universal 3See (Odifreddi 1999) for the analogous \ntheorem in terms of Kleene s formulation of the Fixed Point Theorem. This has been also investigated \nin (Hansenetal. 1989)butno theoretical measureisgiven:the emphasisof the paper is more on practical, \nimplementative issues. function. Then for any total recursive function fi there exists an index m suchthat, \nfor any x, ~ (1) fm = ffi(m) (2) Fm . T(.y.Fu(fi(m),y)  Proof. Consider the following computable function: \ng(x, y)= ffi(fx(x))(y)= fu(fu(i, (fu(x, x))),y) By the s-m-n theorem there exists a computable function \ns such that fs(x) = .y.g(x, y) and, for any x, Fs(x) . T(.y.Fu(fu(i, (fu(x, x))),y)) = T(.y.Fu(fi(fx(x)),y)) \n(x isa.xed parameter,hencethecomplexityof computing fi(fx(x)) does not matter). Since s isa total computable \nfunction thereexists p such that s = fp. fp(p). since fp is total. Moreover we have: ffp(p)(y)= g(p, \ny)= ffi(fp(p))(y) and Ffp(p) = T(.y.Fu(fi(fp(p)),y) DEFINITION 26. We say that a universal functionfu \nis fairif for any x .y.Fu(x, y) . T(Fx) The cost of interpreting a program i by a fair universal machine \nmay only introducea constant slow-downfactor c w.r.t. the direct computation of i. However, the constant \nc may depend on i.Fol\u00adlowing (Jones 1993) we say that the universal machine is ef.cient when the constant \nc is independent from the interpreted program. COROLLARY 27. Let .f, F. be an abstract complexity measure \nwith the s-m-n property11.Ifit admitsafair universal function u then for any total recursive function \nfi there exists an index m suchthat, for any x, ~ (1) fm = ffi(m) (2) Fm . T(Ffi(m))  Let us remark \nthat the previous result says almost nothing about the ef.ciency of the .xpoint; it only says that, independently \nfrom fi wemayalways.nda .xpoint m as (in-)ef.cient as fi(m) (that is not surprising: a .xpoint program \nis as ef.cient as the program de.nedby its body). Not all computational models seem to admitfair universal \nma\u00adchines. Discussing the case of multi-tapeTuring machines, Blum (1971) suggests an upper bound for \nFu(i, j) given by Fi(j)2 + j, wherethe squareisduetothefactthattheuniversal machinehasa given numberof \ntapes,butmayneedto simulate additional ones(if we admit that the universal machine has at least two tapes, \nthe cost is likely to be reduced to log(Fi(j))Fi(j)+ j)4. However, many models, comprising single tape \nTuring ma\u00adchines, lambda calculus and combinatory logic havefair universal machines. Unfortunately, this \nthe kind of results that, belonging to the so called folklore of these subjects, cannot be properly quoted \nor elaborated.We hope someone will assume soon or later thebur\u00adden to formally provethese important properties, \nand also hope that the scienti.c community will be so wise to accept these contribu\u00adtions.Asaremarkableexception,theexistenceof \nef.cient universal functions is proved by Jones (1993) for several classes of compu\u00adtational models de.ning \nproblems in deterministic linear time (i.e. computational models with very restricted capabilities). \n4In our opinion, the notion of multi-tape machine as a foundational model of computation is arguable: \nindeed, we are used to work with a .xed ma\u00adchinery (a given processor), that amounts to .x a single universal \nmachine with a given number of tapes, emulating all other programs. The strong version of the Fixed Point \nTheorem of Corollary 27 (whenit holds)isamajortoolfortheinvestigationof Complexity Cliques, since it \ncan be used with the same con.dence of the traditional theorem w.r.t. extensional sets. As a simple example, \nlet us consider the traditional proof of Rice s Theorem making use of a .xed point. THEOREM 28. AComplexity \nCliqueP is recursive if and only if it is trivial, i.e. P = \u00d8. P = .. Proof. Assume P is recursive and \nlet fp be its characteristic func\u00adtion. Suppose P is not trivial, so there exist a and b such that fp(a)=1 \nand fp(b)=0. Let us consider the following com\u00adputable function ( a if fp(x)=0 g(x)= b if fp(x)=1 If \nfp is total recursive, so is g, hence we may apply Corollary 27, concluding that there exists an index \nm such that ~ fm = fg(m) Fm . T(Fg(m)) In particular, if fp(m)=0 we have ~ fm = fa Fm . T(Fa) Since P \nis a Complexity Clique and fp(a)=1 it should also be fp(m)=1:contradiction. Similarly, if if fp(m)=1 \nwe have ~ fm = fb Fm . T(Fb) Since P is a Complexity Clique and fp(b)=0 it should also be fp(m)=0, that \nis again a contradiction. 7. Conclusions In this paper, we introduced the notion of Complexity Clique: \na set of indices for programs closed under a similarity relation de\u00ad.ned taking into account theirextension \nand complexity. Recursive properties of Complexity Cliques have been investigated, sharpen\u00ading classical \nresults of Recursion Theory, like Rice s and Rice\u00adShapiro s Theorems. In particular, we proved that all \nrecursive Complexity Cliques are trivial, and all Complexity Cliques in S01 and .01 areinfact (morally)extensional(i.e. \naretrivialw.r.t. com\u00adplexity).Inthisway,we rephrase classical theoremsin computabil\u00adity theory in order \nto establish properties of classes of programs de.ned by complexity conditions, concluding that no non-trivial \ncomplexity property is semi-decidable.For instance, the recent .eld of implicit computational complexity \n-seeegDal Lago and Baillot (2006), Amadio (2005), citetAR02 and the biliography therein \u00adstudies criteria \non programs implying some complexity properties. The results of this paper put in evidence that such \ncriteria, when\u00adever computable, can not be necessary and suf.cient conditions. In other words, if polytime \nlanguages may be extensionally complete (computing all polynomial functions) they cannot be intensionally \ncomplete, that is express all polynomial algorithms. The technical .avor of the paper follows Blum s \naxiomatic ap-proach,butfortheaimsoftheproofsweextendedBlum s axioms with stronger assumptions, concerning \nthe complexity of the s-m-n function, of sequential and parallel composition, and of the univer\u00adsal machine. \nNot all assumptions are needed for all results and the study of complexity seem to allow a deeper, .ne \ngrained, investi\u00adgation even of traditional aspects of Recursion Theory (see e.g. the three different \nproofs of the generalized Rice sTheorem: Theorems 14-17-28). It is possible (but not evident) that by \nrelaxing the complexity condition in the notion of similarity (e.g. to recursive relatedness via some \ntotal recursive function h)we could prove (much) weaker results in the full generality of an arbitrary \nabstract complexity measure (i.e. without requiring any additional axiom). However, our axioms are very \nnatural, and it is not clear if the effort would be worth the result. From a strictly technical point \nof view, the requirement i .. O(1) in Theorem 19 (and followings) is annoying (more from an aesthetic \npoint of view than a practical one). It would be nice to .nd a way to avoid it (or, alternatively, to \nprove that it is indeed an essentialhypothesis). We believe that most of the interesting problems investigated \nat the beginning of the seventies for Complexity Classes can also be studied, possibly more pro.tably, \nin the framework of Complexity Cliques. A typical example is recursive presentability, that is the problem \nto provide effective enumerations of representatives (up to extensional equivalence) for all elements \nin the given set (such as the problem of giving an effective enumeration of programs com\u00adputing all functions \nwith polynomial complexity). As already re\u00admarked by several authors -see e.g. Landweber and Robertson \n(1972);Young (1969) -,the problem does not makemuch sense for Complexity Classes: since complexity Classes \nare extensional you could enumerate bad programs (not within the given complexity bound) for good functions \n(functions admittinga program within the given complexity bound). The problem has been traditionally \nsolved introducing a notion of quality for presentations (Landwe\u00adber and Robertson 1972), but Complexity \nCliques, due to their intensional nature, could provide an alternative and possibly more natural framework \nto work with. One ofthe appealing aspects of Complexity Cliques is that, (at the contraryof Complexity \nClasses, for whicheven basic composi\u00adtional propertiesfail)theyhaveavery nice set-theoretic structure: \nthey are a Complete Boolean Lattice (Theorem 9). Inacategorical perspective, Complexity Cliques,equipped \nwith the similarity relation, are partial equivalence relations, and it looks natural to investigate \nthem as a sub-category of PER (Freyd et al. 1992). The natural notion of morphism seems to be that of \na complexity-preserving effective operator (Dekker and Myhill 1958); note that, however, in order to \nde.ne a category you im\u00admediately need some additional assumptions on the nature of com\u00adposition beyond \nBlum s axioms. As it is often the case, Category Theory may turn out to be the best tool to grasp the \nessence of the notions under investigation. Finally, from the point of view of Abstract ComplexityTheory, \nwe hope that our work can help to revitalize a .eld that, lately, has beenabit starving.In particular,in \n(AspertiandCiabattoni 1995)it was proved that anyenumerated collection of functions containing projections, \na universal function, and closed w.r.t. composition and the s-m-n constructionis algorithmically complete.For \nthis reason, an abstract approach based on complexity assumptions for these basilar constructions looks \nparticularly appealing. Acknowledgments We are grateful to G.Longo, S.Martini, U.Dal Lago and Claudio \nSacerdoti Coen for a few interesting discussions on the subject of this paper. References R. Amadio. \nSynthesis of max-plus quasi interpretations. Fundamenta Infor\u00admaticae 65 (2005), pp 29 60. IOS Press. \nA. Asperti, A. Ciabattoni. Effective applicative structures. In Proceedings the sixth biannual conference \non Category Theory in Computer Science (CTCS 95), volume 953, pp. 158 174, 1995. A.Asperti, L.Roversi. \nIntuitionistic Light Af.ne Logic (Proof-nets, Normal\u00adization Complexity, Expressive Power).ACMTransactions \non Compu\u00adtational Logic(TOCL),Volume3 , Issue1, January 2002, pp.137 175. M. Blum. A machine-independent \ntheory of the complexity of recursive functions. Journal ofACM, 14(2), pp.322 336, April 1967. M. Blum. \nOn effective procedures for speeding up algorithms. Journal of ACM, 18(2), pp.290 305, April 1971. E.B\u00a8orger. \nBerechenbarkeit,Komplexit\u00a8Friedr.Vieweg&#38;Sohn, at, Logik. Braunshweig, 1986. A. Borodin. Computational \ncomplexity and the existence of complexity gaps. Journal ofACM, 19, pp.158 174, March 1972. N. J. Cutland. \nComputability: An Introduction to Recursive Function Theory. Cambridge University Press, Cambridge, UK, \n1986. U.Dal Lago,P.Baillot. On light logics, uniform encodings and polynomial time. Mathematical Structuresin \nComputer Science,V.16, Issue4,pp. 713 -733, August 2006. J. C. E. Dekker and J. Myhill. Some theorems \non classes of recursively enumerable sets. Trans. Amer. Math. Soc., 89, pp.25 59, 1958. P.Freyd,P.Mulry,G. \nRosolini,andD. Scott. Extensional pers.Information and Computation, 98(2), pp.211 227, June 1992. T. \nA. Hansen,T. Nikolajsen, J. L.Tr\u00a8aff, and N. D. Jones. Experiments withimplementationsoftwotheoretical \nconstructions.In Logic at Botik, volume 363, pages 119 133, 1989. J. Hartmanis and R. E. Stearns. On \nthe computational complexity of algorithms. Trans. Amer. Math. Soc., 117, pp.285 306, 1965.  NeilD. \nJones. Constant timefactors do matter. In Proceedings of STOC 93, pp.602 611, 1993. D.Kozen. Indexingof \nsubrecursive classes. Theoretical Computer Science, 11, pp.277 301, 1980. L. H. Landweber and E. L. Robertson. \nRecursive properties of abstract complexity classes. Journal ofACM, 19(2), pp.296 308, April 1972. F. \nD. Lewis. Unsolvability considerations in computational complexity. In Proceedingsof SecondACM Symp. \non Theoryof Computing, pp.22 30, 1970. \u00a8 G. Lischke. Uber die erf \u00a8 atze ullung gewisser erhaltungss\u00a8durchkom\u00adpliziertheitsmasse. \nZeit. Math. Log. Grund. Math.,21, pp.159-166, 1975. G. Lischke. Nat\u00a8urlichekompliziertheitsmasse und \nerhaltungss\u00a8atze i. Zeit. Math. Log. Grund. Math., 22, pp.413-418, 1976. G. Lischke. Nat\u00a8 atze ii. Zeit. \nurlichekompliziertheitsmasse und erhaltungss \u00a8 Math. Log. Grund. Math., 23, pp.193-200, 1977. E. M. \nMcCreight and A. R. Meyer. Classes of computable functions de.ned by bounds on computation. In ProceedingsofACM \nSymp. on Theoryof Computing, Marina del Rey, Calif., pp. 79 88, 1969. J.Myhill, J.C.Shepherdson. Effective \noperations on partial recursive func\u00adtions. Zeit.Math. Log. Grund. Math., 1, pp.310-317, 1955. P. G. \nOdifreddi. Classical Recursion Theory: the Theory of Functions and Sets of Natural Numbers, volume 125 \nof Studies in Logic and the Foundations of Mathematics. Elsevier, 1997. P. G. Odifreddi. Classical Recursion \nTheory, Volume II, volume 143 of StudiesinLogic and theFoundationsof Mathematics. Elsevier, 1999. J. \nG. Rice. Classes of recursively enumerable set and their decision prob\u00adlems. Trans. Amer. Math. Soc., \n74, pp.358 366, 1953. H. Rogers. Theory of Recursive Functions and Effective Computability. MIT press, \n1987. N.Shapiro. Degrees of computability. Transactions of the American Math\u00adematical Society, 82, pp.281-299, \n1956. P. R. Young. Toward a theory of enumeration. Journal of ACM, 16(2), pp.328 348, 1969. \n\t\t\t", "proc_id": "1328438", "abstract": "<p>The proofs of major results of Computability Theory like Rice, Rice-Shapiro or Kleene's fixed point theorem hidemore information of what is usually expressed in theirrespective statements. We make this information explicit, allowing to state stronger, complexity theoretic-versions of all these theorems. In particular, we replace the notion of extensional set of indices of programs, by a set of indices of programs having not only the same extensional behavior but also similar complexity (Complexity Clique). We prove, under very weak complexity assumptions, that any recursive Complexity Clique is trivial, and any r.e. Complexity Clique is an extensional set (and thus satisfies Rice-Shapiro conditions). This allows, for instance, to use Rice's argument to prove that the property of having polynomial complexity is not decidable, and to use Rice-Shapiro to conclude that it is not even semi-decidable. We conclude the paper with a discussion of \"complexity-theoretic\" versions of Kleene's Fixed Point Theorem.</p>", "authors": [{"name": "Andrea Asperti", "author_profile_id": "81100182775", "affiliation": "University of Bologna, Bologna, Italy", "person_id": "PP43117295", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328455", "year": "2008", "article_id": "1328455", "conference": "POPL", "title": "The intensional content of Rice's theorem", "url": "http://dl.acm.org/citation.cfm?id=1328455"}