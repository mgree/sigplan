{"article_publication_date": "01-07-2008", "fulltext": "\n Back to the Future Revisiting Precise Program Veri.cation using SMT Solvers Shuvendu K. Lahiri Shaz \nQadeer Microsoft Research {shuvendu, qadeer}@microsoft.com Abstract This paper takes a fresh look at \nthe problem of precise veri.ca\u00adtion of heap-manipulating programs using .rst-order Satis.ability\u00adModulo-Theories \n(SMT) solvers. We augment the speci.cation logic of such solvers by introducing the Logic of Interpreted \nSets and Bounded Quanti.cation for specifying properties of heap\u00admanipulating programs. Our logic is \nexpressive, closed under weakest preconditions, and ef.ciently implementable on top of existing SMT solvers. \nWe have created a prototype implementa\u00adtion of our logic over the solvers SIMPLIFY and Z3 and used our \nprototype to verify many programs. Our preliminary experience is encouraging; the completeness and the \nef.ciency of the decision procedure is clearly evident in practice and has greatly improved the user \nexperience of the veri.er. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program \nVeri.cation General Terms Algorithms, Reliability, Veri.cation Keywords Software veri.cation, SMT solvers, \ndecision proce\u00addures, heap-manipulating programs, reachability, linked lists 1. Introduction First-order \ntheorem provers like SIMPLIFY (Detlefs et al. 2005) are a fundamental component of many scalable program \nveri.cation tools. These provers are used in many ways to solve the veri.\u00adcation condition of each procedure \nin a modular analysis (Flana\u00adgan et al. 2002; Barnett et al. 2005) and to compute and re.ne abstractions \nin a whole-program analysis (Ball et al. 2001; Hen\u00adzinger et al. 2002). First-order reasoning has the \nimportant ability to combine various useful theories required for program veri.ca\u00adtion, e.g., arithmetic, \narrays, and uninterpreted functions, in a sys\u00adtematic manner (Nelson and Oppen 1979). Recently, Satis.ability\u00adModulo-Theories \n(SMT) solvers (Satis.ability Modulo Theories Library (SMT-LIB)) such as YICES (Dutertre and de Moura \n2006) and Z3 (de Moura and Bjorner 2007), have combined advances in Boolean satis.ability solvers with \npowerful .rst-order theory rea\u00adsoning using decision procedures. We believe that these powerful solvers \nhave created an opportunity for scaling automated veri.ca\u00adtion to deep properties of complex software. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n08 January 7 12, 2008, San Francisco, California, USA. Copyright c . 2008 ACM 978-1-59593-689-9/08/0001. \n. . $5.00 Despite these recent advances, automated veri.cation of heap\u00admanipulating programs remains \ndif.cult with .rst-order reasoning. The main reason behind this dif.culty is that the speci.cation logic \nsupported by SMT solvers is not expressive enough. In particular, it is usually cumbersome and often \nimpossible to specify prop\u00aderties of unbounded lists and trees and non-aliasing invariants of deeply-nested \nheap structures. Previous attempts (Flanagan et al. 2002) at reasoning about these programs using .rst-order \nprovers relied heavily on the use of quanti.ers both for expressing asser\u00adtions about (unbounded) data \nstructures and for axiomatizing theo\u00adries for linked lists and trees. The result has been unsatisfactory \nfor two reasons. First, most recursive predicates useful for expressing invariants about unbounded data-structures \ncannot be axiomatized in .rst-order logic (B\u00a8orger et al. 1997). Consequently, these ax\u00adiomatizations \ntend to be incomplete leading to an unacceptable fre\u00adquency of failed proofs. Second, quanti.er-reasoning \nin .rst-order SMT solvers remains incomplete, heuristic-driven, and brittle. To properly use these solvers, \nconsiderable user ingenuity is required for writing carefully crafted quanti.ed assertions. Such expertise \nis usually beyond the capability of normal programmers. In this paper, we revisit the problem of precise \nveri.cation of heap-manipulating programs using .rst-order SMT solvers. Our work is motivated by our \ndesire to analyze systems software such as device drivers and operating systems code, which make heavy \nuse of linked lists and deeply-nested linked data structures. We are interested in building an assertion \nchecker for correctness proper\u00adties of such programs such as memory-safety and data-structure invariants. \nTowards this end, we present the Logic of Interpreted Sets and Bounded Quanti.cation for specifying properties \nof heap\u00admanipulating programs and a veri.er for proving these properties. Our logic uses .rst-order logic \nas a substrate. In addition to provid\u00ading useful but conventional theories such as arithmetic and equality \nwith uninterpreted functions, the logic also provides several novel features that alleviate, to a signi.cant \nextent, the aforementioned dif.culties faced by .rst-order solvers in verifying data-structure properties. \nThe contributions of this paper can be categorized along the following dimensions: Logic. We introduce \na new logic that facilitates precise, au\u00adtomated, and ef.cient reasoning about many heap-intensive pro\u00adgrams. \nThe logic provides an interpreted recursive predicate to rea\u00adson about lists and two interpreted set \nconstructors useful for writ\u00ading speci.cations involving bounded quanti.cation over the con\u00adstructed \nsets. 1. The logic is expressive. In addition to describing rich data struc\u00adture invariants (such as \ndisjointness of two lists), and properties of entire collections (such as sortedness of a list), the \nlogic is ex\u00adpressive enough for describing concisely object invariants over a given type and non-aliasing \nconstraints. 2. The logic is closed under weakest precondition. Given a loop\u00adfree and call-free program \nannotated with preconditions, post\u00adconditions and assertions in our logic, we present a procedure to \ngenerate a formula also in our logic that is unsatis.able if and only if the program does not go wrong \nby failing any assertions. 3. The logic is simple. In spite of its expressiveness, the decision problem \nfor the logic is NP-complete.  The increased expressiveness of our logic due to quanti.ers and closure \nunder weakest precondition make it much more attractive for program veri.cation, compared to other similar \nlogics (Nelson 1983; Rakamari\u00b4c et al. 2007). Decision procedure. We describe an ef.cient decision proce\u00addure \nfor the logic using a set of sound, complete and terminat\u00ading inference rules. The resulting decision \nprocedure can leverage theory reasoning (for arithmetic and uninterpreted functions) and con.ict-clause \ndriven backtracking search of modern SMT solvers. The presence of bounded quanti.cation over interpreted \nsets allows us to instantiate the quanti.ers in a lazy manner, an attribute that is essential for good \nperformance. Lazy instantiation greatly im\u00adproves the performance of the decision procedure as (often \nuse\u00adless) quanti.er instantiation is one of the bottlenecks for .rst-order SMT provers supporting general \nquanti.ers. We have implemented an initial prototype of the decision procedure over existing SMT solvers \nSIMPLIFY and Z3, using universally quanti.ed .rst-order axioms with matching triggers. Evaluation. We \nhave used our decision procedure to verify many small to medium-sized C programs. Our preliminary expe\u00adrience \nis encouraging; the completeness and ef.ciency of the deci\u00adsion procedure is clearly evident in practice \nand has improved the robustness of the veri.cation efforts manifold. Although we have applied our veri.er \nto annotated programs, where the user supplies the annotations, the ability to perform pre\u00adcise and automated \nveri.cation is the cornerstone of many other veri.cation techniques. Predicate abstraction techniques \n(Graf and Sa\u00a8idi 1997) make calls to a theorem prover to construct an ab\u00adstraction. Re.nement of abstractions \n(Kurshan 1995; Clarke et al. 2000) relies on computing the weakest precondition and solving the generated \nveri.cation condition. Symbolic execution of pro\u00adgrams (Godefroid et al. 2005) requires solving path \nconstraints pre\u00adcisely. The contributions of this paper are applicable, not only to modular program veri.cation, \nbut to these other domains as well. Proofs for the lemmas and theorems in this paper have been omitted \nfor lack of space. They can be found in a technical re\u00adport (Lahiri and Qadeer 2007a).  2. Motivating \nexample We consider the linked data structures present in an real-world application called muh (Muh). \nmuh is an Internet Relay Chat (IRC) bouncer, a program that acts as a middleman between an IRC-client \nand an IRC-server. The application is written in C. The main data structures, described in Figure 1, \nconsists of two acyclic doubly-linked lists, pointed to by log list.head and channel list.head, containing \na list of logentry and channel nodes respectively. Figure 2 and Figure 3 describe the lists and their \ncontents. Each node in the log list, pointed to by the data .eld in the dlink node, contains two character \narrays channel name and filename and an integer logtype. Similarly, each node in the channel list contains \ntwo character arrays name,and topic, and a pointer to a channel log node. The channel log structure further \ncontains an integer ftype and a pointer to a FILE called logfile. Note that the list node dlink node \nuses its void * data .eld polymorphically (Figure 1). When the node participates in the log list,the \ndata .eld is cast to a (logentry*) pointer, and typedef struct _dlink_node { struct _dlink_node *next; \nstruct _dlink_node *prev; void *data; } dlink_node; ty{ } pedef struct _dlink_list dlink_node *head; \ndlink_node *tail; dlink_list; typedef struct _logentry { char *channel_name; char *filename; int logtype; \n} logentry; extern dlink_list log_list; typedef struct _channel_log { int ftype; FILE *logfile; } channel_log; \nty{ } pedef struct _channel char *name; char *topic; channel_log *log; channel; extern dlink_list channel_list; \nFigure 1. Main data structures of muh log_list.tail  next next next     struct _logentry Figure \n2. The log list channel_list.head channel_list.tail next   ft struct struct channel _channel  void \nclear_logs(int clear) { dlink_node *ptr; dlink_node *next_ptr; struct _logentry *logptr; ....... /* \nthen clear the loglist */ for(ptr = log_list.head; ptr; ptr = next_ptr) { next_ptr = ptr->next; logptr \n= ptr->data; xfree(logptr->channel_name); xfree(logptr->filename); xfree(logptr); dlink_delete(ptr, \n&#38;log_list); dlink_free(ptr); } } void rem_channel(struct _channel *chptr) { dlink_node *ptr; /* close \nthe logfile if we have one */ if(chptr->log != NULL) { ..... xfree(chptr->log); } if((ptr = dlink_find(chptr, \n&#38;channel_list)) == NULL) return; dlink_delete(ptr, &#38;channel_list); dlink_free(ptr); xfree(chptr->name); \nxfree(chptr->topic); xfree(chptr); } Figure 4. Freeing entries from log list and channel list. when \nit participates in the channel list,the data .eld is cast to a(channel*) pointer. The example is representative \nof real-world applications written in C, which consist of a combination of multiple linked data struc\u00adtures. \nThese data structures can either be recursively de.ned (e.g. dlink node) or deeply-nested (e.g. channel). \nDuring the lifetime of the application, various operations mu\u00adtate these data structures through a set \nof functions. These functions correspond to adding or deleting a log to a list, adding or deleting a \nchannel to a list, opening or closing a FILE, or freeing a set of en\u00adtries of a list. In this section, \nwe focus on the routines clear logs and rem channel, which free objects present in the data structures. \nFigure 4 describe parts of the procedures that free elements (using a procedure xfree) from the log list \nand the channel list.An important memory-safety property to enforce is the following: Absence of double-free: \nAn object is not freed twice in the applications lifetime. Let us consider the procedure clear logs in \nFigure 4. The pro\u00adcedure iterates over the linked list pointed to by log list.head, freeing the objects \nin each node. It .rst frees the channel name and filename objects, then frees the logentry object pointed \nto      c . Integer x . Variable f . Function . . Formula ::= a |.1 ..2 |.1 ..2 |\u00ac. a ..Formula \n::= . |a1 .a2 |a1 .a2 |.x.S.a . . GFormula ::= t1 = t2 |t1 <t2 | ff t1 -.t2 -.t3 |\u00ac. t . Term ::= c |x \n|t1 -t2 |t1 + t2 | f(t) |ite(t= t',t1,t2) S . Set ::= g -1(t) |Btwn(f,t1,t2) Figure 5. Logic of Interpreted \nSets and Bounded Quanti.cation (LISBQ) by the data pointer and .nally deletes the dlink node object from \nthe list and frees it. The procedure rem channel similarly removes an entry from the channel list and \nfrees the objects. Let us examine a few scenarios to understand why it is non\u00adtrivial to establish the \nabsence of double-free for this routine: 1. Consider a given iteration of the loop, where channel name \nand filename are freed. If both these pointers are aliased, then xfree(logptr->filename) would free an \nobject that has already been freed by xfree(logptr->channel name). Hence, we would like to enforce that \nthe channel  name and filename pointers in a logentry node do not alias.  2. Now consider two different \niterations of the loop operating on two linked list nodes uand v. Let us imagine that u->data and v->data \nare aliased. In this case, each of the three xfree calls on the later iteration would free an already \nfreed object.  3. Another scenario causing a double-free could arise if the  channel  name or filename \n.elds in some node in log list aliases with name or topic .elds in some node in channel list. In this \nscenario, a call to rem  channel followed by a call to clear logs would cause a double-free.  4. \nFinally, if the data .eld in a dlink node object aliases with the channel  name .elds in a logentry \nobject, a double-free may be erroneously reported. This situation is avoided by en\u00adforcing that pointers \nto objects of two different types can never be equal. In Section 3, we present a simple and natural speci.cation \nlogic that can express the necessary invariants to prove the absence of double-free error in the program. \nIn Section 4, we revisit this ex\u00adample to illustrate the use of our logic. In spite of the expressive\u00adness, \nthe decision problem of the logic still remains NP-complete and we propose an ef.cient decision procedure \nfor the logic using SMT solvers.  3. Logic Our logic, presented in Figure 5, is interpreted over a .nite \npartially-ordered set Dof sorts. The set Dcontains the sort Integer of integers. Each variable x has \nsome sort D .D. Each uninter\u00adpreted function f has a sort D .E for sorts D,E .D. A model M for a formula \nin the logic provides an interpretation MD for each sort D,where MInteger is just the set of integers. \nThe model also provides an interpretation Mx .MD for each variable x of sort Dand an interpretation Mf \n: MD .ME for each function f of sort D .E. The interpretation is extended to arbitrary terms in the logic \nin the natural way. ff The logic provides a ternary reachability predicate \u00b7-.\u00b7-.\u00b7 for each function \nf of sort D .D where D .D. The model ff M |= t1 -.t2 -.t3 iff there are distinct u0,u1,...,un .MD T . \nStmt ::= Assert(.) | Assume(.) | x:= new | free(x) | x:= t | f(x):= y | T1; T2 | T1DT2  Figure 6. Program \nsuch that Mf (ui)= ui+1 for all i .[0,n), u0 = Mt1 , un = Mt3 , and ui = Mt2 for some i .[0,n]. We often \nrefer to the binary f ff reachability predicate t1 -.t2 which is de.ned to be t1 -.t2 -.t2. The logic \nallows bounded universal quanti.cation over two different kinds of (potentially unbounded) sets. The \nset f-1(t) is constructed using a function f of sort D .E where D,E .D and D E. The model M |x . f-1(t) \niff Mf(x) = Mt. = = The set Btwn(f,t1,t2) is constructed using a function f of sort D .D where D .D. \nThe model M |= x .Btwn(f,t1,t2) iff ff M |= t1 -.x-.t2. Note that our sorting requirements preclude the \nuse of the same function symbol f in a term f-1(t) and a term Btwn(f,t1,t2). This restriction is important \nfor the completeness of our decision procedure; it ensures that models for the sets g -1(t) and Btwn(f,t1,t2) \ncan be computed independently. The set of formulas Formula in our logic is closed under boolean combination. \nWe have both universal and existential quan\u00adti.cation but do not have alternation of quanti.ers. We require \nthat logical formulas satisfy the sort-restricted prop\u00aderty. This property is crucial for the termination \nof the decision pro\u00adcedure described in Section 3.3. In every formula .x . S.a, the sort of any term \nin a containing xas a strict sub-term is less than the sort of x. We assume the existence of a type checking \nor type inference algorithm that can check for any formula . in our logic that it is type-correct and \nsatis.es the property described above. 3.1 From programs to formulas In this section, we show how we \ntranslate a program T without loops and procedure calls into a formula .in our logic. The transla\u00adtion \nhas the property that .is unsatis.able iff S does not go wrong by failing an assertion. We assume that \na preprocessing phase has eliminated all loops either soundly by using a programmer-supplied loop invariant \nor unsoundly by unrolling each loop a bounded number of times. Similarly, all procedure calls have been \nelimi\u00adnated either soundly by using programmer-supplied pre-and post\u00adconditions or unsoundly by inlining \nupto a bounded depth. The syntax of the programs we consider is given in Figure 6. The statement Assert(.) \nis used to introduce intermediate asser\u00adtions and postconditions. The statement Assume(.) is used to \nin\u00adtroduce preconditions and conditional statements. The statement x := new creates a new object. Allocation \nof objects whose ad\u00addresses are in sort D is modeled using a map AllocD : D . Integer. The statement \nx := new gets desugared into the code sequence Assume(AllocD(k)= 0); AllocD(k):= 1; x:= k where kis a \nfresh variable (not used anywhere else) introduced per allocation site. The statement free(x) frees an \nobject. If xis of sort D, this statement is desugared into the code sequence Assert(AllocD(x)= 1); AllocD(x):=2. \nThe statement x:= tevaluates tand writes it into a variable x.The statement f(x):= y writes the value \nin variable y into the .eld f at cell x. The statement T1; T2 evaluates T1 followed by T2.The statement \nT1DT2 executes either T1 or T2 nondeterministically. wp(Assert(.),.)= ... wp(Assume(.),.)= . .. wp(x:= \nt,.)= .[x/t] wp(f(x):= y,.)=G(.,f,x,y) wp(T1; T2,.)= wp(T1,wp(T2,.)) wp(T1DT2,.)= wp(T1,.) .wp(T2,.) \nFigure 7. Weakest precondition G(.1 ..2,f,p,q) = G(.1,f,p,q) .G(.2,f,p,q) G(.1 ..2,f,p,q) = G(.1,f,p,q) \n.G(.2,f,p,q) G(\u00ac.,f,p,q) =\u00acG(.,f,p,q) Figure 8. De.nition of G(.,f,p,q) This statement, together with \nthe assume statement, is used to model conditional execution. The weakest precondition computation for \nthe various state\u00adments in our language (other than x := new and free(x) which are desugared) is given \nin Figure 7. As we discuss below, the set of formulas in our logic is closed under the computation of \nweak\u00adest precondition with respect to any statement T.Let true denote the formula x = x for some designated \nvariable x.We .rstcom\u00adpute wp(T,true) as described in the .gure. The translation has the property that \n\u00acwp(T,true) is unsatis.able iff T does not go wrong. In Sections 3.2 and 3.3, we present a procedure \nto decide whether \u00acwp(T,true) is satis.able. We use the notation .[x/t] to indicate the result of syntactically \nreplacing xeverywhere with t in the formula .. The computation described in Figure 7 is straightforward \nand follows the classical description (Dijkstra 1976) except in the case of the statement f(x):= y. It \nis nontrivial to provide the weakest precondition of aformula . with respect to f(x):= y because of the \nuse of the ff predicate \u00b7-.\u00b7-.\u00b7in .. This predicate may be used either as an ff atom t1 -.t2 -.t3 or \nin de.ning the bound set Btwn(f,t1,t2) of a universally quanti.ed fact. The main dif.culty is that a \nlocal change in the value of the function f at xmight cause global change in the value of this predicate. \nHowever, for closure under weakest precondition, we must capture this change using the vocabulary of \nthe logic. The function G de.ned in Figures 8-11 is used for comput\u00ading the weakest precondition of . \nwith respect to the statement f(p):= q. Figure 8 computes G(.,f,p,q) for a formula . by straightforward \nrecursion on the structure of the formula. Figure 9 computes G(a,f,p,q) for a formula a. The .rst two \nrules are straightforward recursion but to understand the next four rules, we must .rst understand G(.,f,p,q) \nde.ned in Figure 10 and G(t,f,p,q) de.ned in Figure 11. The rules for computing G(t,f,p,q) in Figure \n11 are mostly straightforward. Let fqp denote the function that is identical to f except at p where its \nvalue is q. The only nontrivial rule G(f(t),f,p,q) states that the value of fqp(t) is q if p = t and \nf(G(t,f,p,q)) otherwise. In Figure 10, G(t1 = t2,f,p,q) and G(t1 <t2,f,p,q) are obtained in a straightforward \nfashion by recursively computing G(t1,f,p,q) and G(t2,f,p,q). The computation of G(t1 -g-g .t2 . t3,f,p,q) \nis easy since g is different from f. We need to work ff harder, however, to compute G(t1 -.t2 -.t3,f,p,q). \nSuppose f f is a function of sort D .D.Let u-.v be the predicate de.ned w G(a1 .a2,f,p,q) =G(a1,f,p,q) \n.G(a2,f,p,q) G(t1 = t2,f,p,q) =G(t1,f,p,q)=G(t2,f,p,q) G(a1 .a2,f,p,q) =G(a1,f,p,q) .G(a2,f,p,q) G(t1 \n<t2,f,p,q) =G(t1,f,p,q) <G(t2,f,p,q) G(.x.g -1(t).a,f,p,q) = -- .t2 .t3,f,p,q) = let let ''' t ' =G(t,f,p,q),a \n' =G(a,f,p,q) t1 =G(t1,f,p,q),t2 =G(t2,f,p,q),t3 =G(t3,f,p,q) in in gg G(t1 -1'' .x.g (t ).a ' t -.t \n- .t 123 gg ' ' G(.x.f-1(t).a,f,p,q) = let ff G(t1 -.t2 -.t3,f,p,q) = '' let t =G(t,f,p,q),a =G(a,f,p,q) \n''' t1 =G(t1,f,p,q),t2 =G(t2,f,p,q),t3 =G(t3,f,p,q) in '' '' in f pq- .t x.f-1. q = t .a [x/p] ..(t \n).a 1 - .t2 pq f ' '' ' ..x.f-1(t ).x = p.at ' ' . = t q 3 G(.x.Btwn(g,t1,t2).a,f,p,q) = G(\u00ac.,f,p,q) \n=\u00acG(.,f,p,q) let '' ' t1 =G(t1,f,p,q),t2 =G(t2,f,p,q),a =G(a,f,p,q) Figure 10. De.nition of G(.,f,p,q) \nin '' ' .x.Btwn(g,t1,t2).a G(c,f,p,q) =c G(.x.Btwn(f,t1,t2).a,f,p,q) = let '' ' G(x,f,p,q) =x t1 =G(t1,f,p,q),t2 \n=G(t2,f,p,q),a =G(a,f,p,q) in G(t1 + t2,f,p,q) =G(t1,f,p,q)+G(t2,f,p,q) ' f ' ''' . t1 -.t2 ..x.Btwn(f,t1,t2).a \np G(t1 -t2,f,p,q) =G(t1,f,p,q) -G(t2,f,p,q) '' f f ' '' . p= t2 .t1 -.p.q-.t2 ..x.Btwn(f,t1,p).a p t \n2 G(g(t),f,p,q) =g(G(t,f,p,q)) f f '' ' '' . p= t2 .t1 -.p.q-.t2 ..x.Btwn(f,q,t2).a p t 2 G(f(t),f,p,q) \n= Figure 9. De.nition of G(a,f,p,q) let t ' =G(t,f,p,q) in ite(p= t ' ,q, f(t ' )) as follows: f f ff \nf u-.v = u-.v-.w.(u-.v.\u00acu-.w) w Intuitively, u f -.w v holds iff u can reach v by following zero G(ite(t1 \n= t2,t3,t4),f,p,q) = let t1 ' =G(t1,f,p,q),t2 ' =G(t2,f,p,q), '' t3 =G(t3,f,p,q),t4 =G(t4,f,p,q) or \nmore f links without going through w. Formally, the model in ' ''' ite(t1 = t2,t3,t4) f t2 iff there \nare distinct u0,u1,...,usuch -. . MD M |= t1 n t 3 that Mf (ui)= ui+1 for all i .[0,n), u0 ,and Figure \n11. De.nition of G(t,f,p,q) = M= M t1 , ut2 n ui = Mt3 for all i .[0,n). Then, we have the following \nidentity: pq pq u- .v- .w =. u ff f ff preconditions. Finally, this identity provides a simple way \nto com\u00ad -.v-.w.u-. w f pf pute G(t1 -.t2 -.t3,f,p,q) as shown in Figure 10. f ff f . p= w.u-.p.u-.v-.p.q-.w \n f p ff wf . p= w.u-.p.q-.v-.w.q-.w p w The .rst disjunct captures the case when pcannot destroy the \npath We now go back to Figure 9 to understand the last four rules for computing G(a,f,p,q). The third \nand .fth rules are straight\u00adforward because f and g are different functions. The intuition for G(.x.f-1(t).a,f,p,q) \nrests on the identity pq pq - .v- .w holds as well. The second disjunct captures the case when there \nis a path from ' where t ff -1' '-1'-1' (t )= ite(q = t,f(t ) .{p},f(t ) \\{p}), pq f -.v-.w and therefore \nu f (f) witnessing u =G(t,f,p,q) and we have extended the ite(\u00b7 , \u00b7, \u00b7) u to v and the update to f creates \na path from v to w. The third constructor to sets for brevity. The intuition for the rule G(.x .disjunct \ncaptures the case when there is a path from vto wand the update to f creates a path from uto v. Btwn(f,t1,t2).a,f,p,q) \nrests on the identity relating u pq f - .v pq f - . The identity given above provides a precise update \nfor the pred\u00ad w and u ff -.v -.w de.ned above; there is a one-one correspon\u00ad icate u f -.v-.w with \nrespect to the statement f(p):= q. Con\u00ad f [AND] [OR] [REACH] [REFLEXIVE] [STEP] .1 . .2 .1 . .2 f(t) \n f f(t1) t1 -.t2 .1,.2 .1 .2 f ff t-.tt-.f(t) -.f(t1) t1 = t2 t1 f - .t2 t1 -.t2 t1 -.t3 t1 -.t2 -.t3 \nf.-.-ttt121 [ITE] [EQ] .[ite(t1 = t2,t3,t4)] .1[t1] .2[t2] [CYCLE] [SANDWICH] ff t1 = t2,.[t3] t1 t1 \n= t2 t1= t2 = t2,.[t4] f(t1)= t1 t1 -.t2 t1 = t2 t1 = t2 Figure 12. Basic inference [ORDER1] [ORDER2] \nff f f The contribution of this section can be summarized in the fol\u00ad f - .t2 Figures 7-11. [TRANSITIVE1] \n[TRANSITIVE2] f-..-tttt1223 f fff f -.t2 -.t3 t1 -.t3 -.t2,t2 -.t3 lowing theorem about the de.nition \nof the wp(T,.) captured by t1 t1 THEOREM 1. For any program T, the formula \u00acwp(T,true) is fff ff t0 -.t1 \n-.t2 t1 -.t-.t2 in the logic LISBQ. Moreover, the program T goes wrong iff .t3 f -  3.2 Decision procedure \nfor ground logic [TRANSITIVE3] ff ff wp(T,true) is satis.able. -.t1 -.t, t0 -.t-.t2 t1 t0 \u00ac ff ff t0 \n-.t1 -.t2 t0 -.t-.t1 ff ff t0 -.t-.t2,t-.t1 -.t2 Figure 13. Reachability backtracks to the last untried \ndecision if there remains one and oth\u00aderwise returns unsatis.able. Otherwise, if the current context \nis sat\u00adurated, the algorithm reports that .is satis.able. Otherwise, there is a matching rule such that \nnone of the formulas below the line are present in the context. If there is only one formula below the \nline, it is added to the context. Otherwise, a case split is performed with one formula added to the \ncontext for each case. Figure 12 gives the basic inference rules. The rules [AND]and [OR] are straightforward \nand follow from the logical meaning of . and ..The rule [ITE] is applicable whenever the context contains \na ground formula .containing a term ite(t1 = t2,t3,t4),in which case we perform a case split on t1 = \nt2.If t1 = t2 we replace ite(t1 = t2,t3,t4) with t3 in ., otherwise we replace ite(t1 = t2,t3,t4) with \nt4.The rule [EQ] performs a case split on the equality between any two terms t1 and t2 that exist in \nthe context. The rules in Figure 13 are dedicated to proving facts about In this section, we provide \na decision procedure for checking satis\u00ad .ability of a formula .in our logic. First, we convert .into \nnega\u00ad tion normal form and skolemize the resulting existential quanti.ers that result from moving a negation \ninside a universal quanti.er. The resulting formula remains in our logic. We .rst present a decision \nprocedure for the case of ground formulas (Figures 12 and 13) and then augment the procedure to deal \nwith quanti.ers (Figure 14). Our algorithm maintains a context, which is a conjunction of formulas currently \nasserted to be true. The algorithm provides a collection of rewrite rules that operate over the context. \nIn each step of the algorithm, an applicable rewrite rule is applied which may cause a case-split together \nwith the addition to the context of one or more formulas. Each inference rule is written as a conjunction \nof antecedents above the line and a disjunction of consequents below the line. In some cases such as \n[AND], a consequent below the line might have several comma-separated formulas which are interpreted \nas conjoined. If there is a rule such that the current context contains all the formulas above the line, \nthen the it is guaranteed that the disjunction of the formulas below the line is entailed by the context. \nIn this case, we say that the rule matches the context. A context is called saturated if for every matching \nrule, the context contains all the formulas in one of the disjuncts below the line. Let U denote the \nquanti.er-free theory of equality with unin\u00adterpreted functions and relations. The signature of U contains \nall ff the ternary reachability predicate u .The rules make -. v-. w symbols of our logic LISBQ (Figure \n5) except +, -, <,and the constants in Integer. Note that while LISBQ interprets the relation f -.vwhich, \nas extensive use of the binary reachability predicate u f f - .\u00b7, the logic U treats it as uninterpreted. \nLet V denote the logic with the same signature as U in which the relation \u00b7 f ff mentioned earlier, is \nequivalent to u .Rule [REFLEXIVE] -.\u00b7 -.v-.v \u00b7 f says that f \u00b7 -.\u00b7 is a re.exive relation. In rule [STEP], \nas in a few -.\u00b7-.\u00b7is interpreted. Let A denote the quanti.er-free theory of linear arith-other rules \ndiscussed later, we take a notational liberty by putting a metic. The signature of A contains all symbols \nof LISBQ except term f(t) above the line. Rule [STEP] is applicable whenever a term the function symbols, \nsuch as f, and the relation symbols, such a f(t) occurs in any ground formula in the context and concludes \nthe f f \u00b7-.\u00b7- obvious fact that f(t) is reachable from t.Rule [REACH]draws .\u00b7. The only symbols shared \namong U and A are the vari\u00ad conclusions based on the presence of f(t1) in the context and the ables in \nVariable.Let UA denote the combination of U and A. reachability from t1 of another term t2. The signature \nof UA is exactly the same as the logic in Figure 5 Rules [CYCLE]and [SANDWICH] entail an equality without \nin\u00ad f -.\u00b7-.\u00b7 is treated as uninterpreted. f except that in UA the relation \u00b7 troducing a case split. \nBoth rules draw conclusions from the pres\u00ad ence of cycles in the graph of the reachability relation. \nRules A literal is a quanti.er-free formula that is free of boolean con\u00ad[ORDER1] and [ORDER2] connect \nthe ternary and binary reacha\u00ad bility predicates. Rule [ORDER1] says that if t1 reaches both t2 and t3, \nthen either t1 reaches t2 followed by t3 or t1 reaches t3 fol\u00ad if the oracle decides that set of literals \nin the context is satis.able. lowed by t2.Rule [ORDER2] draws the more obvious conclusion Otherwise, \nthe context is inconsistent. Our algorithm essentially explores a decision tree while main\u00ad fff -.\u00b7-.\u00b7. \nGiven a quanti.er-free formula . as input, the procedure de\u00ad.ned by the rules in Figures 12 and 13 terminates \nbecause the num\u00adber of new terms created is bounded by the number of ite(\u00b7, \u00b7, \u00b7) terms in .. Since the \nprocedure simply combines backtracking with the creation of new facts among this bounded set of terms, \nwe con\u00adclude that the procedure will terminate. Soundness of the algorithm is proved by reasoning locally \nabout each inference rule to verify that the conjunction of antecedents indeed implies the disjunction \nof the consequents. The argument for the completeness of the algorithm is as fol\u00adlows. Suppose during \nthe execution of the algorithm, we arrive at a consistent and saturated context C. We create a model \nthat satis.es each formula in C using the following steps: Remove each formula in C that is not a literal. \nDue to the rules [AND], [OR], and [ITE], it suf.ces to .nd a model for the resulting set of formulas. \nPurify the remaining literals by introducing fresh variables and new equalities and saturate the context \nwith all derived facts in the theory U using congruence closure. For each sort D, introduce a fresh variable \n.D and add literals .D= x, for every other variable xof sort D.The role of these variables will become \nclear later when we de.ne the model. Note that the addition of these disequalities to the context does \nnot create any fresh implications. Split the context into the set CV containing literals only from theory \nV and the set CA contain\u00ading literals only from theory A. Due to the rule [EQ], both CV and CA are convex \nand entail the same set of equalities. In addition, both theories V and A are stably in.nite. Therefore, \nin order to get a model for CV . CA, we only need to get models separately CV and CA (Nelson and Oppen \n1979). Here we only show how to gen\u00aderate a model for CV , since a model for CA can be generated from \nthe decision procedure for arithmetic. We now show how to construct a model M for a consistent and saturated \nCV . In order to de.ne a model M for CV ,we need for each sort D different from the sort Integer , a \ndomain MD, an assignment Mx . D for every variable x of sort D, andanassignment Mf : MD . MD for every \nfunction f of sort D . D. We start in the usual way and de.ne MD to be the partition {u1,...,un} of the \nset of variables of sort D satisfying the following condition: for all i . [1,...,n] and for all variables \nxand y of sort D, x . ui and y . ui iff x = y . CV . For each u . MD,let [|u|] denote a .xed representative \nmember of u.Now we de.ne Mx to be the unique u. MD such that x. u. Note that the equivalence class containing \nthe variable .D is the singleton {.D} because CV contains disequalities differentiating .D from every \nvariable of sort D. We would like to de.ne f(u) for an arbitrary element u . MD. If (f([|u|]) = [|v|]) \n. CV for some v . MD, then we de.ne Mf (u)= v.However, if (f([|u|]) = [|v|]) . CV for any v . MD, then \nwe must pick some element of MD to be f(u).The main dif.culty is that the interpretation of the function \nf is tied to the ff interpretation of the relation \u00b7 -.\u00b7 -.\u00b7. We must be careful not to de.ne f(u) to \nbe inconsistent with the constraints in CV .To help us in this task, we de.ne for each u . MD, the relation \nff Ru = {(v,w) . MD \u00d7MD | [|u|] -.[|v|] -.[|w|] . CV }. LEMMA 1. For all u. MD, the following facts hold: \n1. (u,u) . Ru. 2. Ru is re.exive over dom(Ru). 3. Ru is transitive. 4. Ru is totally-ordered over \ndom(Ru).  With the aid of Ru, we now provide a complete interpretation for Mf .Let u be an arbitrary \nelement of MD.If (f([|u|]) =[|v|]) . CV for some v . MD, then de.ne Mf (u)= v.Otherwise, if Ru = {(u,u)} \nthen de.ne Mf (u)= u.Otherwise,de.ne Mf (u) to be the least element, with respect to Ru,of dom(Ru) \\{u}. \n[INV] [BTWN] t ' ff f()=t t1 -.t-.t2 .x . f-1(t).a .x . Btwn(f, t1,t2).a a[x/t ' ] a[x/t] Figure 14. \nQuanti.er instantiation Lemma 1 guarantees that de.ning f in the last two cases does not create any contradictions \nwith the context CV . The interpretation ff for \u00b7-.\u00b7-.\u00b7is now de.ned as ff ff u-.v-.w . [|u|] -.[|v|] \n-.[|w|] . CV . In addition to de.ning the interpretation for each function f of sort D . D, we also need \nto de.ne an assignment Mg : MD . ME for every function g whose sort is D . E where D and E are different. \nLet u be an arbitrary element of MD. If (g([|u|]) = [|v|]) . CV for some v . ME , then we de.ne Mg(u)= \nv. Otherwise, we de.ne Mg (u)= {.E }. LEMMA 2. The model M de.ned above satis.es M |= CV . Based on Lemma \n2, we obtain the following theorem. THEOREM 2. Let . . Formula be quanti.er-free. Then the pro\u00adcedure \ndescribed by the rules in Figures 12 and 13 terminates and decides the satis.ability of .. In Section \n3.3, we extend our decision procedure to the full logic with quanti.cation. The following lemma captures \nan important property of the rules in Figures 12 and 13 that is used to prove the completeness of our \ndecision procedure for the full logic. LEMMA 3. Let X be any collection of facts of the form t1 = t2. \nff Let Y be any collection of facts of the form t1 -.t2 -.t3.Let C be . any consistent and saturated \ncontext. If C entails (X .Y),then one of the following must hold: 1. t1 = t2 . C for some t1 = t2 . X. \nff ff 2. t1 -.t2 -.t3 . C for some t1 -.t2 -.t3 . Y.  3.3 Decision procedure for quanti.ed logic We \nnow extend our decision procedure to handle quanti.ed facts by adding the rules in Figure 14. The .rst \nrule [INV] handles quanti.cation over the set constructor f-1(t); if the current context contains the \nfact f(t ' )= t then this rule instantiates the body of the quanti.er at t ' .The rule [BTWN] works in \nsimilarly for the set constructor Btwn(f,t1,t2). Our decision procedure terminates even after adding \nthe quan\u00adti.er instantiation rules in Figure 14 because the input formula is required to be sort-restricted. \nThere is a partial-order on the set of sorts and whenever a quanti.er .x . S.. is instantiated, any new \nterms generated are of a sort less than the sort of x. By well\u00adfounded induction over the partial-order \non the set of sorts, we can show that for each sort Dthere is a decision depth in the backtrack\u00ading search \nbeyond which the number of terms of sort D remains unchanged. In fact, for an input formula ., the number \nof terms of sort Dgenerated by our algorithm is bounded by |.|\u00b7K|D|,where K is the number of function \nsymbols. Since the number of sorts is .nite, the procedure will terminate. Since the size of the model \nconstructed in Section 3.2 is linear in the number of terms and the number of terms is linear in the \nsize of the formula, we have the following theorem about the complexity of our logic. THEOREM 3. The \nsatis.ability problem for the logic LISBQ is NP\u00adcomplete. The local soundness of the rules [INV]and [BTWN] \nis obvious. For completeness, we appeal to Lemma 3. Consider a context C that is consistent and saturated \nwith respect to all the rules in . Figures 12, 13, and 14. Let D1 be the conjunction t1 =t2 for all t1 \nand t2 such that t1 = t2 . C.Let D2 be the conjunction . ff ff \u00act1 -.t2 -.t3 for all t1, t2,and t3 such \nthat t1 -.t2 -.t3 .C. Lemma 3 guarantees that C .D1 .D2 is satis.able, which in turn implies that all \nthe quanti.ed facts in C have been instantiated enough. Therefore, a model for the set of literals in \nC is a model for all the facts in C. We have already shown, earlier in this section, how to construct \na model for the set of literals in C. Thus, we have the following theorem. THEOREM 4. Let . . Formula. \nThen the procedure described by the rules in Figures 12, 13, and 14 terminates and decides the satis.ability \nof .. It is important to note that set-bounded quanti.cation is not essential for either termination \nor completeness of our decision procedure. Termination is ensured by the sort-restricted property. Completeness \ncould be ensured simply by instantiating quanti.ed facts on all ground terms of the appropriate sort. \nHowever, such a procedure would lead to a huge number of instantiations and would consequently be very \nexpensive in practice. Set-bounded quanti.cation allows us to instantiate quanti.ers lazily and yields \nan ef.cient implementation. 3.4 Expressiveness In this section, we show various examples to illustrate \nthe expres\u00adsiveness of our logic. Cyclic lists. We specify that hd points to the head of a cyclic list \nas follows: f hd =null .f(hd).hd - Suppose each element of this list contains a .eld data.The invari\u00adant \nfor a loop that iterates, using a variable i, over this list setting the data .eld to 0is speci.ed as \nfollows: .u .Btwn(f,f(hd),i)\\{i}.data(u)=0 Sortedness. Suppose hd points to a null-terminated list. The \ninvariant that the values stored in the data .eld of the list members are sorted is speci.ed as follows: \n.u .Btwn(f,f(hd),null)\\{null}. .v .Btwn(f,u,null)\\{null}.data(u)=data(v) List of lists. Suppose hd is \npointing to a null-terminated list linked by the .eld f and each member of the list has a .eld l that \npoints to a distinct null-terminated list linked by the .eld g.The disjointness of these lists is speci.ed \nas follows: .u .Btwn(f,hd,null)\\{null}. .v .Btwn(f,hd,null)\\{null}. -g u =v ..w .Btwn(g,l(u),null)\\{null}.\u00acl(v).w \nThe ability to specify such invariants is useful for verifying systems software that uses composite data \nstructures (Berdine et al. 2007). List union. Suppose a, b,and c are null-terminated lists con\u00adstructed \nusing linking .elds f1, f2,and f3 respectively. We specify that a is the union of b and c as follows: \nf2f3 .u .Btwn(f1,a,null).b -.u .c -.u f1 .u .Btwn(f2,b,null).a -.u f1 .u .Btwn(f3,c,null).a -.u This \ninvariant is useful in proving the correctness of the in-place list reversal program.   4. Revisiting \nthe motivating example In this section, we revisit the example presented in Section 2 and describe the \nvarious invariants required to prove the absence of double-free property. We show that these invariants \ncan be naturally expressed using the simple logic we presented in Section 3. To easily follow the speci.cations, \nthe reader should reexamine the program in Section 2. For the purpose of illustration, we consider programs \nwritten in a subset of C that is simple yet rich enough to express the pro\u00adgram in Section 2. The language \nprecludes performing arithmetic on pointers, taking the address of (using the &#38;operator) a stack \nvariable or a .eld inside a structure, and the use of arrays, unions and nested structures. Before we \ndescribe our speci.cations, we brie.y describe the memory model and how we de.ne the opera\u00adtional semantics \nof the program. The memory is partitioned into a set of maps f1 ,f2 ,...,fn , one corresponding to each \n.eld declared in the program, and indexed by the objects or references. Without loss of generality, we \nassume that the .eld names are globally distinct.  The value of the C expression x->f is obtained by \nlooking up the map f at the index obtained by evaluating x. An update x->f =y updates the map f at the \nlocation obtained by evalu\u00adating x, with the value obtained by evaluating y.  4.1 Sorts To generate \na well-sorted formula from a program, we assign sorts to the different .elds and variables in the program. \nThe sorts are generated by analyzing the type structure of the program. Initially, a sort is assigned \nto each distinct type in the program. If two types can be the target of a void*.eld (e.g. data in our \nexample), we merge the sorts for the two types. For our example, the set of sorts Dconsists of at least \nthe following sorts: D={Integer ,P dlink node,P (logentry,channel), P channel log,P FILE,P char,...} \nP dlink node is the sort for a pointer to a dlink node.The sort P (logentry,channel) is for a pointer \nto either logentry or channel, uni.ed due to the presence of the polymorphic data .eld in dlink node. \nGiven the sort set D, we can assign sorts to the different variables and .elds in the program, by substituting \nthe sort corresponding to each type in the program. For each sort D .D, we maintain a map TypeD : D . \nInteger, that maps an object of sort D to an integer constant denoting the dynamic type of object. We \nintroduce a constant for each type, by pre.xing a @to the type name (e.g. @logentry for an object of \ntype logentry, @channel log for an object of type channel log). The dynamic type of each object is assigned \nduring the allocation of the object. All the casts in the program are checked to see that they match \nthe dynamic type of the objects. Finally, the partial order .on Dis generated by analyzing the signature \nof the .elds in the program, apart from the linking .elds like next and prev. For each .eld f :D .E in \nthe program, we add the constraint that E . D. The partial order for our program is the following: P \n(logentry,channel). P dlink node P char . P (logentry,channel) Integer . P (logentry,channel) P channel \nlog . P (logentry,channel) Integer . P channel log P FILE . P channel log 4.2 Speci.cations using g \n-1 set constructor The g -1 set constructor is useful for expressing both non-aliasing of heap objects \nand type invariants. To prove the absence of double-free property in our example, we need to ensure non-aliasing \nof various .elds of the same sort (e.g. the char*.elds channel name, filename,etc.).For a .eld f, and \na set of .elds F , we.rst de.neamacro NotAliased(f, F, u) as follows: NotAliased(f, F , u) = . f-1(f(u)) \n= {u}. g -1(f(u)) = {} g.F This macro speci.es that the object f(u) pointed to by a given .eld f, cannot \nbe also pointed to by any of the .elds in F.The set F usually contains a set of .elds that have the same \nsort as f.Note that we have used set equality as a syntactic sugar for the more elaborate formula using \nbounded quanti.cation. We can use this macro to specify that any object pointed to by the char*.eld channel \n name is distinct from the objects pointed to by the other char*.elds as follows: .u .Type-1(@logentry). \nP (logentry ,channel) name, {filename, name, topic}, u) NotAliased(channel It means for any object u \nof sort P (logentry, channel)with a dynamic type logentry, the object channel name(u) of sort P char, \ncan t be pointed to by any of the other char*.elds. Observe that the use of TypeD -1(@T ) allows us to \ndescribe type invariants for any given dynamic type T within the sort D,such as logentry in the previous \nexample. 4.3 Speci.cations using Btwn(f, x, y) set constructor Let us now illustrate the use of the \nset constructor Btwn(f, x, y) to describe properties of linked lists. Disjointness of lists: To specify \nthat the two linked lists have disjoint elements, we can exploit the fact that the nodes in the two linked \nlists have different dynamic types: .u .Btwn(next, log list.head, null) \\{null}. TypeP (logentry ,channel) \n(data(u)) = @logentry .u .Btwn(next, channel list.head, null) \\{null}. Type P (logentry ,channel)(data(u)) \n= @channel These invariants describe that for any node u in the linked list between log list.head (respectively, \nchannel list.head) and null, but excluding null, the type of the object pointed to by data(u) is @logentry \n(respectively, @channel). By the property of functions, this ensures that the set of nodes in the two \nlists are disjoint. The interesting nature of this speci.cation is that we can specify the disjointness \nof the two lists by stating an invariant locally for each list. Non-aliasing for lists: We also need \nto ensure that each node in each linked list points to a distinct object. We use both the set constructors \nin the following speci.cation: .u .Btwn(next, log list.head, null) \\{null}. NotAliased(data, {}, u) .u \n.Btwn(next, channel list.head, null) \\{null}. NotAliased(data, {}, u) The .rst invariant describes that \nfor any node u in the linked list between log list.head and null, but excluding null,the object pointed \nto by data(u) has exactly one object (namely u) pointing into it using the data .eld. This ensures that \nthe data .eld for each object in the list points to a distinct object. The second invariant states this \nproperty for the second list. Data structure invariant: In Figure 4, the routines clear logs and rem \n channel delete pointers from the doubly-linked lists using the dlink delete routine. The correctness \nof the routine relies on the input list being a doubly-linked list. We use the following macro to describe \nthe invariants for a generic acyclic doubly-linked list DlistInv(dlist, next, prev): DlistInv(dlist, \nnext, prev) = . prev(dlist.head)= null . next(dlist.tail)= null . Btwn(next, dlist.head, null)= Btwn(prev, \ndlist.tail, null) . null .Btwn(next, dlist.head, null) ..u .Btwn(next, dlist.head, null) \\{null}. u = \ndlist.head .next(prev(u)) = u ..u .Btwn(prev, dlist.tail, null) \\{null}. u = dlist.tail .prev(next(u)) \n= u The .rst two invariants are self-explanatory. The third invariant states that the set of objects \nreachable following the next .eld from the dlist.head is the same as the set reachable following the \nprev .eld from the dlist.tail. The fourth invariant states that the lists obtained by following the next \nand prev .elds are both acyclic. The last two invariants constrain the .elds next and prev to be .elds \nof a doubly-linked list. Although the invariant looks complex, these data structure in\u00advariants have \nto be written only once for each type of doubly\u00adlinked list. and then instantiated for the different \nlists (e.g. log list and channel list) in the program. This predicate can be reused across all other \nprograms that manipulate acyclic doubly-linked lists as well. In addition to these invariants, we also \nneed invariants stating that all objects reachable from the two lists are allocated. Moreover, for the \nloops iterating over the lists, we need to specify that the iterator (e.g. ptr in clear logs) points \nto an object in the list. All these invariants are expressible in our logic. 4.4 Sort-restriction To \nenable the algorithm described in Section 3.3 to terminate on the above queries, we need to ensure that \nthe formulas are sort\u00adrestricted as well. In this section, we show that almost all the formulas in this \nsection meet the requirement. Let us consider the following invariant, described in Section 4.3. .u .Btwn(next, \nchannel list.head, null) \\{null}. Type P (logentry ,channel)(data(u)) = @channel For this formula, the \nvariable u of sort P dlink node appears as a subterm of data(u), which has a sort P (logentry, channel)and \na subterm of TypeP (logentry ,channel)(data(u)), which has a sort Integer. In both cases, the sorts of \nthe subterms are less than the sort for u, according to the partial order .described in Section 4.1. \nHowever, consider the following invariant also described in the previous section: .u .Btwn(next, dlist.head, \nnull) \\{null}. u = dlist.head .next(prev(u)) = u In this formula, u appears as a strict subterm of prev(u) \nand next(prev(u)), both of which have the same sort as u. In fact, any legal sort assignment would equate \nthe sorts for the terms next(prev(u)) and u, and therefore the formula can not be sort\u00adrestricted for \nany sort assignment. It turns out that for this example (and also for the rest of the examples we consider \nthis paper), the only two formulas that do not meet the sort restrictions are the last two invariants \nof DlistInv. This is not surprising because the invariant constrains the two .elds next and prev that \nform singly-linked lists. In Section 6, we describe our solution for ensuring that the algorithm terminates \non such ill-behaved formulas as well.     [ORDER1] .x,y, z : {Reach(f, x, y, y), Reach(f, x, z, \nz)}Reach(f, x, y, y) . Reach(f, x, z, z) . Reach(f, x, y, z) . Reach(f, x, z, y) [TRANSITIVE1 ] .x,y, \nz : {Reach(f, x, y, y), Reach(f, y, z, z)}Reach(f, x, y, y) . Reach(f, y, z, z) . Reach(f, x, z, z) Figure \n15. Encoding inference rules using axioms with triggers  5. Implementation We have created an initial \nprototype of the decision procedure framework over existing SMT solvers, where we encode our in\u00adference \nrules using universally-quanti.ed .rst-order axioms with appropriate matching triggers. Our implementation \ntranslates an\u00adnotated C programs into the BoogiePL intermediate language (De-Line and Leino 2005). Each \nprocedure in a BoogiePL program is translated into a veri.cation condition by the Boogie veri.er (Bar\u00adnett \nand Leino 2005). Finally, the veri.cation conditions are proved by the SIMPLIFY (Detlefs et al. 2005) \nand Z3 (de Moura and Bjorner 2007) automated theorem provers. Figure 15 gives the axioms encoding two \nillustrative rewrite rules from Figure 13. We use predicates Reach(f, x, y,z) and   Example SIMPLIFY \nSIMPLIFY Z3 Old Time (s) New Time (s) Time (s) iterate 1.8 1.4 1.5 iterate acyclic 1.7 1.5 1.43 slist \nadd 1.5 1.3 1.36 reverse acyclic 2.0 1.4 1.37  slist sorted insert 16.4 3.1 4.85 dlist add 38.9 7.1 \n1.75 dlist remove 45.4 2.4 1.65 allocator * (901.8) 57.1 2.0 list appl * 200.1 30.22 muh free * * 8.2 \n   Figure 16. Results of assertion checking. The experiments were conducted on a 3.6GHz, 2GB machine \nrunning Windows XP. A timeout (indicated by *) of 5000 seconds was set for each experi\u00adment. For allocator, \ntime inside the parenthesis denotes the run\u00adtime after manual decomposition. allow us to perform additional \noptimizations, e.g. ordering the var\u00adious rules to detect unsatis.ability faster in common cases. -.y-.z \nand . respectively. To f f 6. Evaluation In(x,y) to stand for the relations x avoid the use of excessive \nparentheses, we use the convention that . has lower precedence than . and .. For each axiom, a set of \ntriggers is speci.ed using curly braces. Each trigger is a collection of terms enclosed within {\u00b7}, which \ntogether must refer to all of the universally-quanti.ed variables. The axiom is instantiated for those \nterms which if substituted for the quanti.ed variables in the trigger terms result in terms that are \nall present in ground formulas. Typically, each rewrite rule results in an axiom in which the conjunction \nof the literals above the line implies the disjunction of the literals below the line and the terms in \nthe literals above the line appear in the trigger. In addition to encoding the rules of our decision \nprocedure as axioms, we also provide triggers for the universally-quanti.ed assertions in the program. \nTo encode the reasoning for the rule [BTWN] (Figure 14), we infer a trigger {Reach(f, t1,x,t2)} for the \nformula .x . Btwn(f, t1,t2).a. To encode the reasoning for the rule [INV], we infer a trigger In(x,f-1(t)) \nfor the formula .x . f-1(t).a. To generate the term In(x,f-1(t)),we add the following axiom: [ININV] \n.y : {f(y)} In(y, f-1(f(y))) We automatically generate the appropriate triggers for any universally\u00adquanti.ed \nassertions that belongs to the sort-restricted fragment of our logic. There are many advantages to implementing \na rewriting-based decision procedure using .rst-order axioms over SMT solvers: 1. First, it allows us \nto quickly create an initial prototype for evaluation.  2. Second, it allows us to leverage ef.cient \nground reasoning for equality, uninterpreted functions and arithmetic.  3. Finally, we can leverage \nthe advances in matching based quan\u00adti.er instantiation using triggers (Detlefs et al. 2005; de Moura \nand Bjorner 2007). This is useful not only for the implementa\u00adtion of the rewrite rules, but also allows \nus to express quanti.ed invariants outside our logic in the rare cases when required. We present the \nneed for such invariants, and our solution to deal with them in Section 6.  We have used the decision \nprocedure presented in this paper in the tool HAVOC (Chatterjee et al. 2007), and performed a set of \npreliminary experiments for verifying small to medium sized C benchmarks. HAVOC is a tool for checking \nproperties of heap\u00admanipulating C programs. The memory model in HAVOC accounts for additional complications \nof low-level C programs, including pointer arithmetic, internal pointers, nested structures, unions and \narrays. The main differences over the memory model presented in this paper are: (i) each expression evaluates \nto a pointer type ptr :(Obj, int) consisting of an object and an offset; and (ii) there is a single map \nMem : ptr . ptr for the entire memory. This low-level model is required to maintain soundness across \npointer arithmetic and internal pointers in C. HAVOC also uses a alternate variant of the reachability \npredicate presented in this paper, called well-founded reachability predicate (Lahiri and Qadeer 2006; \nChat\u00adterjee et al. 2007).1 The rules presented in the paper were suitably extended to account for this \nmemory model and reachability predi\u00adcate. Figure 16 presents a set of C benchmarks that manipulate singly \nand doubly-linked lists. These benchmarks use pointer arithmetic, internal pointers into objects and \ncast operations in addition to linked data structures. The examples iterate and iterate acyclic respectively \ninitialize the data elements of a cyclic and acyclic lists respectively; slist add adds a node to a singly \nlinked list; reverse acyclic is a routine for in-place rever\u00adsal of an acyclic list. The example slist \nsorted insert inserts a node into a sorted (by the data .eld) linked list. dlist add and dlist remove \nare the insertion and deletion routines for cyclic doubly-linked lists. allocator is a low-level custom \nstorage allo\u00adcator; it maintains a list of freed regions in an object and returns a region whose size \nsatis.es the clients request. list appl is a simple application with multiple doubly-linked lists, parent \npoint\u00aders, and uses the primitive doubly-linked list operations. muh free is a simpli.ed version of the \nmuh example presented in Section 2. The examples range from 10 to 150 lines of C code. For all these \nexamples, we check a set of partial correctness properties including      f f However, our approach \nhas some drawbacks over a custom im-of -. y -. (but not limited to) the implicit memory-safety requirements. \nFor vides the weakest precondition for the predicate. Rakamari\u00b4cet al. instance, we check that the output \nlist of slist sorted insert (2007) provide a rewriting-based decision procedure for the ground  is sorted; \nfor reverse acyclic, we verify that the input and the fragment of our logic with x -.y -.z. However, \nthey do not pro\u00ad f f output lists have the same nodes; for allocator,we verify that vide the weakest \nprecondition for the predicate, and are imprecise the region returned by the application was already \npresent in the across updates to the linking .elds. In addition, the rewrite rules in our decision procedure \nare fewer and simpler resulting in a simpler free list and meets the size requirement; for list appl,we \nverify that the disjoint lists satis.es certain data invariants; .nally for muh we check the absence \nof double-free property. In an earlier work (Chatterjee et al. 2007), we veri.ed a subset of the examples \nin Figure 16 using an incomplete axiomatization of the reachability predicate, with universally quanti.ed \ninvariants. For most of the examples, we had to write down the triggers for the quanti.ed invariants \ncarefully; the theorem provers were quickly overwhelmed without such restrictions. The second column \nproof of completeness. Balaban et al. (2005) present a logic that allows reachability over singly-linked \nlists to be expressed. Their decision procedure is based on a small-model property of the logic. In all \nthese cases, the logics are strictly less expressive than ours since they do not have any support for \nquanti.ers as a result they cannot express most of the properties that we discuss in this paper. Ranise \nand Zarba (2006) present a decidable ground logic that in Figure 16 denotes the runtime using our previous \napproach, using the SIMPLIFY theorem prover (reported from (Chatterjee combines reachability constraints \nwith arithmetic. But they provide no implementation to evaluate the feasibility of their approach. et \nal. 2007)). The third and the fourth column denotes the runtime using the algorithm described in this \npaper (using SIMPLIFY and Z3 as the SMT provers respectively); for these cases, the triggers for the \nquanti.ed invariants (with a couple of exceptions below) were generated automatically, using the scheme \nof Figure 15. The results clearly indicate that the new algorithm outper-Moreover, the logic can t express \nmany properties of collections (such as sortedness of lists), since it does not provide support for quanti.ers. \nKuncak and Rinard (2005) provide a logic with sets for reasoning about data structures. Unlike our logic, \ntheir logic does not allow sets to be constructed from the reachability predicate. There have been several \nother attempts at .rst-order axiomatiza\u00adforms the older axiomatization in terms of ef.ciency. We can \ntion of reachability (Lev-Ami et al. 2005; Lahiri and Qadeer 2006), now solve several new examples (list \nappl, muh free)that which are incomplete. McPeak and Necula (2005) use decidable fragment of .rst-order \nlogic augmented with arithmetic on scalar .eld to specify properties of data structures. However, they \ndo not provide any theories for recursive predicates like reachability, and rely on user provided ghost \nvariables to express properties of data structures the updates to these ghost variables have to be inserted \nmanually by the user to generate the veri.cation conditions. How\u00ad ever, they demonstrate completeness \nof quanti.er instantiation for were not amenable to be solved by our previous approach. For  the allocator \nexample, the time reported inside the parenthesis (901.8 seconds) denotes the time taken to verify the \nexample with our previous approach, using additional triggers and manual de\u00ad composition of the proof \ninto two VCs without these changes the example did not verify within the time limit. It illustrates \nthe brittleness of our previous approach. The improved results with Z3 (over SIMPLIFY) also indicate \nthat the recent advances in SMT solvers are crucial to scale better. However, the recent advances alone \nare not suf.cient to solve these problems (as we learned from our failed attempts with Z3 with our old \naxiomatization). In most of these cases, the theorem provers quickly ran out of memory due to large number \nof (often useless) instantiations of the quanti\u00ad .ers. However, the real gain (not evident from the results) \nwas in the predictability of the new approach. In our experience, most of certain syntactic class of \nformulas that could help extend our deci\u00ad sion procedure for doubly-linked list assertions. Unlike the \npapers discussed so far that have essentially used .rst-order logic for reasoning about linked data structures, \nother approaches have used higher-order logic for the same purpose. The pointer assertion logic engine \n(PALE) (M\u00f8ller and Schwartzbach 2001) uses monadic second-order logic to express properties in\u00ad volving \nreachability. Although the logic can express more complex the failed proofs in our veri.cation effort \nwith the new framework points at insuf.cient assertions or bugs in the program. For these examples, the \nmain source of formulas that do not .t the sort-restricted fragment of LISBQ comes from speci.cation \nshape properties than that allowed by our logic, the logic precludes the use of integer valued functions \nand the decision procedure for the logic has high complexity. The work of Yorsh et al. (2006) on the \nlogic of reachable patterns is in a similar direction. They pro\u00adof the doubly-linked list invariant. \nFor the following doubly-linked vide a logic for expressing complex shape properties, show how list assertion \nmentioned in Section 2: to generate precise veri.cation conditions and provide a decision .u .Btwn(next, \ndlist.head, null) \\{null}. u = dlist.head .next(prev(u)) = u our solution has been to add a trigger {prev(u)} \nto ensure that this assertion never generates a new term prev(t) after instantiat\u00ading u with t. Note \nthat even though a new term next(prev(t)) could still be generated after instantiation, asserting this \nliteral next(prev(t)) = t in the context would cause this term to be equated with an existing term t. \nThis restriction ensures that the instantiations terminates even in the presence of such formulas.  \n7. Related work In this work, we have augmented .rst-order SMT solvers with use\u00adful theories for precise \nveri.cation of heap-manipulating programs. We discuss the various works that are similar in spirit to \nour goal of automatically verifying such programs. Nelson (1983) presents a ground logic with the ternary \npredi\u00ad f procedure by translation to monadic second-order logic. Separation logic (Reynolds 2002) has \nbeen proposed to reason about heap-manipulating programs. Berdine et al. (2004) describe a rewrite-based \ndecision procedure for a fragment of separation logic with linked lists. Among other things, it is not \nclear how to harness ef.cient arithmetic theory reasoning in this framework. Automatic computation of \n(shape) invariants for programs with linked data structures (shape analysis) has also received consider\u00adable \nattention in recent years. This work is orthogonal and comple\u00admentary to our work and we only discuss \nit brie.y. Most of this work is based on specialized abstract domains for the heap (Lev-Ami and Sagiv \n2000; Distefano et al. 2006) or use predicate ab\u00adstraction (Graf and Sa\u00a8idi 1997) with decision procedures \nfor log\u00adics with reachability (Balaban et al. 2005; Rakamari\u00b4c et al. 2007; Lahiri and Qadeer 2006). \nBetter decision procedures are crucial for the latter approaches, but they can also be used to improve \nthe imprecision of the underlying abstract domain in the former ap\u00adproaches (Lev-Ami et al. 2005). y, \nand an axiomatization for the logic. No claim is made z 8. Conclusions In this paper, we revisit the \nproblem of precise veri.cation of heap\u00admanipulating programs using .rst-order SMT solvers. To solve this \nproblem, we present the Logic of Interpreted Sets and Bounded Quanti.cation for specifying properties \nof heap-manipulating pro\u00adgrams and a veri.er for proving these properties. The veri.cation is fully precise \nwithin a procedure and loop body, and is scalable across typical loop-free code fragments found in practice. \nWe are currently working on extending our work in two direc\u00adtions: First, we would like to extend our \nlogic to support range of indices of an array as another interpreted set constructor this would allow \nreasoning about rich properites of the most common data structures (arrays and lists) in a single framework. \nSecond, we would like to perform abstraction across loop and procedure boundaries to reduce the annotation \nrequirement by automatically inferring many annotations. The recent advances in SMT solvers and the results \nof this paper that leverage these advances have cre\u00adated a strong foundation for carrying forward this \nwork.  Acknowledgments We would like to thank Nikolaj Bjorner and Leonardo de Moura for help with Z3 \nand Amit Goel and Sava Krsti\u00b4c for suggesting improvements to our decision procedure. References I. \nBalaban, A. Pnueli, and L. D. Zuck. Shape analysis by predicate ab\u00adstraction. In Veri.cation, Model checking, \nand Abstract Interpretation (VMCAI 05), LNCS 3385, pages 164 180, 2005. T. Ball, R. Majumdar, T. Millstein, \nand S. K. Rajamani. Automatic predicate abstraction of C programs. In Programming Language Design and \nImplementation (PLDI 01), pages 203 213, 2001. M. Barnett and K. R. M. Leino. Weakest-precondition of \nunstructured programs. In Program Analysis For Software Tools and Engineering (PASTE 05), pages 82 87, \n2005. M. Barnett, K. R. M. Leino, and W. Schulte. The Spec# programming system: An overview. In Construction \nand Analysis of Safe, Secure and Interoperable Smart Devices, LNCS 3362, pages 49 69, 2005. J. Berdine, \nC. Calcagno, B. Cook, D. Distefano, P. O Hearn, T. Wies, and H. Yang. Shape analysis for composite data \nstructures. In Computer Aided Veri.cation (CAV 07), LNCS 4590, pages 178 192, 2007. J. Berdine, C. Calcagno, \nand P. W. O Hearn. A decidable fragment of separation logic. In FSTTCS 04: Foundations of Software Technology \nand Theoretical Computer Science, LNCS 3328, pages 97 109, 2004. E. B\u00a8orger, E. Gr\u00a8adel, and Y. Gurevich. \nThe Classical Decision Problem. Springer-Verlag, 1997. S. Chatterjee, S. K. Lahiri, S. Qadeer, and Z. \nRakamari\u00b4c. A reachability predicate for analyzing low-level software. In Tools and Algorithms for the \nConstruction and Analysis of Systems (TACAS 07), LNCS 4424, pages 19 33, 2007. E. M. Clarke, O. Grumberg, \nS. Jha, Y. Lu, and H. Veith. Counterexample\u00adguided abstraction re.nement. In Computer Aided Veri.cation \n(CAV 00), LNCS 1855, pages 154 169, 2000. L. de Moura and N. Bjorner. Ef.cient Incremental E-matching \nfor SMT Solvers. In Conference on Automated Deduction (CADE 07),LNCS 4603, pages 183 198, 2007. R. DeLine \nand K. R. M. Leino. BoogiePL: A typed procedural language for checking object-oriented programs. Technical \nReport MSR-TR-2005\u00ad70, Microsoft Research, 2005. D. Detlefs, G. Nelson, and J. B. Saxe. Simplify: a theorem \nprover for program checking. J. ACM, 52(3):365 473, 2005. E.W. Dijkstra. A Discipline of Programming. \nPrentice-Hall, 1976. D. Distefano, P. W. O Hearn, and H. Yang. A local shape analysis based on separation \nlogic. In Tools and Algorithms for the Construction and Analysis of Systems (TACAS 06), LNCS 3920, pages \n287 302, 2006.  B. Dutertre and L. M. de Moura. A Fast Linear-Arithmetic Solver for DPLL(T). In Computer \nAided Veri.cation (CAV 06), LNCS 4144, pages 81 94, 2006. C. Flanagan, K. R. M. Leino, M. Lillibridge, \nG. Nelson, J. B. Saxe, and R. Stata. Extended static checking for Java. In Programming Language Design \nand Implementation (PLDI 02), pages 234 245, 2002. P. Godefroid, N. Klarlund, and K. Sen. DART: Directed \nautomated random testing. In Programming Language Design and Implementation (PLDI 05), pages 213 223. \nACM, 2005. S. Graf and H. Sa\u00a8idi. Construction of abstract state graphs with PVS. In Computer-Aided Veri.cation \n(CAV 97), LNCS 1254, pages 72 83, June 1997. T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy \nabstraction. In Principles of Programming Languages (POPL 02), pages 58 70, 2002. V. Kuncak and M. C. \nRinard. Decision procedures for set-valued .elds. Electr. Notes Theor. Comput. Sci., 131:51 62, 2005. \nR. P. Kurshan. Computer-Aided Veri.cation of Coordinating Processes: The Automata-Theoretic Approach. \nPrinceton University Press, 1995. S. K. Lahiri and S. Qadeer. Verifying properties of well-founded linked \nlists. In Principles of Programming Languages (POPL 06), pages 115 126, 2006. S. K. Lahiri and S. Qadeer. \nBack to the Future: Revisiting Precise Program Veri.cation using SMT Solvers. Technical Report MSR-TR-2007-88, \nMicrosoft Research, 2007a. S. K. Lahiri and S. Qadeer. A decision procedure for well-founded reacha\u00adbility. \nTechnical Report MSR-TR-2007-43, Microsoft Research, 2007b. T. Lev-Ami, N. Immerman, T. W. Reps, S. Sagiv, \nS. Srivastava, and G. Yorsh. Simulating reachability using .rst-order logic with applica\u00adtions to veri.cation \nof linked data structures. In Conference on Auto\u00admated Deduction (CADE 05), LNCS 3632, pages 99 115, \n2005. T. Lev-Ami and S. Sagiv. TVLA: A system for implementing static analy\u00adses. In Static Analysis Symposium \n(SAS 00), LNCS 1824, pages 280 301, 2000. S. McPeak and G. C. Necula. Data structure speci.cations via \nlocal equality axioms. In Computer-Aided Veri.cation (CAV 05), LNCS 3576, pages 476 490, 2005. Anders \nM\u00f8ller and Michael I. Schwartzbach. The pointer assertion logic engine. In Programming Language Design \nand Implementation (PLDI 01), pages 221 231, 2001. Muh. Available at http://muh.sourceforge.net/. G. \nNelson and D. C. Oppen. Simpli.cation by cooperating decision pro\u00adcedures. ACM Transactions on Programming \nLanguages and Systems (TOPLAS), 2(1):245 257, 1979. Greg Nelson. Verifying reachability invariants of \nlinked structures. In Principles of Programming Languages (POPL 83), pages 38 47, 1983. Z. Rakamari\u00b4c, \nJ. Bingham, and A. J. Hu. An inference-rule-based decision procedure for veri.cation of heap-manipulating \nprograms with mutable data and cyclic data structures. In Veri.cation, Model Checking, and Ab\u00adstract \nInterpretation (VMCAI 06), LNCS 4349, pages 106 121, 2007. S. Ranise and C. G. Zarba. A theory of singly-linked \nlists and its extensible decision procedure. In Software Engineering and Formal Methods (SEFM 06), pages \n206 215, 2006. J. C. Reynolds. Separation logic: A logic for shared mutable data structures. In Logic \nin Computer Science (LICS 02), pages 55 74, 2002. Satis.ability Modulo Theories Library (SMT-LIB). Available \nat http://goedel.cs.uiowa.edu/smtlib/. G. Yorsh, A. M. Rabinovich, M. Sagiv, A. Meyer, and A. Bouajjani. \nA logic of reachable patterns in linked data-structures. In Foundations of Software Science and Computation \nStructures (FoSSaCS 06),LNCS 3921, pages 94 110, 2006.  \n\t\t\t", "proc_id": "1328438", "abstract": "<p>This paper takes a fresh look at the problem of precise verification of heap-manipulating programs using first-order Satisfiability-Modulo-Theories (SMT) solvers. We augment the specification logic of such solvers by introducing the Logic of Interpreted Sets and Bounded Quantification for specifying properties of heap-manipulating programs. Our logic is expressive, closed under weakest preconditions, and efficiently implementable on top of existing SMT solvers. We have created a prototype implementation of our logic over the solvers Simplify and Z3 and used our prototype to verify many programs. Our preliminary experience is encouraging; the completeness and the efficiency of the decisionprocedure is clearly evident in practice and has greatly improved the user experience of the verifier.</p>", "authors": [{"name": "Shuvendu Lahiri", "author_profile_id": "81100338283", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "P540988", "email_address": "", "orcid_id": ""}, {"name": "Shaz Qadeer", "author_profile_id": "81100286660", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP14106781", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328461", "year": "2008", "article_id": "1328461", "conference": "POPL", "title": "Back to the future: revisiting precise program verification using SMT solvers", "url": "http://dl.acm.org/citation.cfm?id=1328461"}