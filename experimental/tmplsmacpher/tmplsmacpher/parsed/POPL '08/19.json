{"article_publication_date": "01-07-2008", "fulltext": "\n Lifting Abstract Interpreters to Quanti.ed Logical Domains Sumit Gulwani Bill McCloskey Ashish Tiwari \nMicrosoft Research EECS Department, University of CS Lab, SRI International Redmond, WA, USA California, \nBerkeley Menlo Park, CA, USA sumitg@microsoft.com Berkeley, CA, USA tiwari@csl.sri.com billm@cs.berkeley.edu \n Abstract We describe a general technique for building abstract interpreters over powerful universally \nquanti.ed abstract domains that lever\u00adage existing quanti.er-free domains. Our quanti.ed abstract do\u00admain \ncan represent universally quanti.ed facts like .i(0 = i< n. a[i]= 0). The principal challenge in this \neffort is that, while most domains supply over-approximations of operations like join, meet, and variable \nelimination, working with the guards of quanti\u00ad.ed facts requires under-approximation. We present an \nautomatic technique to convert the standard over-approximation operations provided with all domains into \nsound under-approximations. We establish the correctness of our abstract interpreters by identify\u00ading \ntwo lattices one that establishes the soundness of the abstract interpreter and another that de.nes its \nprecision, or completeness. Our experiments on a variety of programs using arrays and pointers (including \nseveral sorting algorithms) demonstrate the feasibility of the approach on challenging examples. Categories \nand Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; F.3.1 [Logics and \nMeanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams; F.3.2 [Logics and Meanings \nof Programs]: Semantics of Programming Languages Program analysis General Terms Algorithms, Theory, Veri.cation \nKeywords Underapproximation Algorithms, Quanti.ed Invari\u00adants, Abstract Interpreter, Logical Lattices \n 1. Introduction Proving the correctness of software almost always requires the use of universal quanti.ers, \nsince program invariants often need to con\u00adstrain unbounded segments of a data structure. However, abstract \ninterpreters are typically designed to constrain only a bounded set of program variables; they cannot \nexpress quanti.ed facts. In this paper, we describe a general method of transforming a quanti.er\u00adfree \nabstract domain into a universally quanti.ed domain. Since there already is a huge variety of quanti.er-free \ndomains available, our technique can be readily instantiated in many areas. For exam\u00adple, in our experiments \nwe were able to reason about unbounded Research was done while second author was at Microsoft. Research \nof the third author was supported in part by NSF grant CCR-ITR-0326540. Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 08, January 7 12, 2008, San Francisco, \nCalifornia, USA. Copyright c &#38;#169; 2008 ACM 978-1-59593-689-9/08/0001. . . $5.00 numbers of array \nlocations and heap objects using some fairly sim\u00adple base domains (difference constraints and reachability \npredi\u00adcates, respectively). We began our research by considering many potentially useful quanti.ed invariants. \nUltimately, we were able to express all of them in the following form. n ^ E ..Uj(Fj . ej) (1) j=1 Here, \nE, Fj and ej are quanti.er-free facts from three potentially different domains, Da, Db,and Dc, respectively. \nThese domains are the parameters to our universally quanti.ed domain; we call them the base domains. \nThe abstract element E, called the environ\u00adment, contains quanti.er-free facts about program variables. \nWith\u00adout any quanti.ed facts, our domain reduces to Da.Elements Fj are the guards to the quanti.ed facts \nej, which are quanti.ed over variables Uj . This universal domain, written D., represents typical quanti.ed \nfacts quite naturally. To constrain array values, we use the domain of difference constraints for the \nguards and uninterpreted func\u00adtions to represent array access in the quanti.ed facts: .i(0 = i< n. A[i]= \n0). In some cases, more complex domains are required. The invariant .i,j(0 = i<n . 0 = j< size[i] . A[i][j] \n= A[i][j +1]) can be represented using the combination of differ\u00adence constraints and uninterpreted functions \nfor both the guards and the facts (Gulwani and Tiwari 2006). In our experiments sec\u00adtion we describe \na reachability domain that allows us to represent constraints like .n(n . R(list) . n . R(p) . n.data \n=0). Here, all elements reachable from the variable list up to the el\u00adement pointed to by p are required \nto have a data .eld containing zero. Even some existential facts can be represented via Skolem\u00adization. \nIf our domain includes a function NLEN de.ned to be the length of null-terminated C string (and unde.ned \nfor non-strings), then .i(0 = i< NLEN(s) . s[i] ! ) forbids the string s, = regardless of its length, \nfrom containing exclamation points (facts like this are useful for analyzing string sanitization routines \nfor se\u00adcurity). To ensure adequate performance, we place some simple restric\u00adtions on the base domains. \nThe fact ej must be a single atomic fact a predicate of the form p(t1,...,pm),suchas t1 <t2 or t1 = t2.Elements \nE and Fj must be .nite conjunctions of atomic facts. There is no way to represent disjunctions explicitly \nin any of these elements, which eliminates a possible source of exponential explosion in the size of \nthe element. The abstract interpreters for the base domains will be supplied with transfer functions \nfor assignments, assume statements, and control-.ow joins. All of these functions are over-approximations \nof the ideal result. However, the crux of this paper is that quanti.\u00adcation introduces extra complexity: \nin order to over-approximate a function on a quanti.ed abstract element, we need to under\u00adapproximate \nits effect on the quanti.er guard. Under-approximation has been studied in the context of backward analysis, \nbut it has never been applied in this way before. The following example demonstrates the importance of \nunder-approximation. Under-approximation operators at work. The following exam\u00adple initializes elements \n0 to n-1of array A to 0. for (i= 0; i <n; i++) A[i] = 0 We would like to prove that .k(0=k<n.A[k]=0)when \nthe loop terminates. There are many ways to explore all the possible control-.ow paths taken by this \nloop. For explanatory purposes, we focus on the .rst two unrollings of this loop. We let Da be the com\u00adbined \ndomain of difference constraints and uninterpreted functions (Gulwani and Tiwari 2006). After the .rst \niteration, this domain infers the following quanti.er-free fact in the environment E: E1 : i=1 .A[0]=0 \nWe assume that no join occurs, so that the abstract interpreter con\u00adtinues to execute the second iteration, \nproducing another quanti.er\u00adfree fact: E2 : i=2 .A[0]=0 .A[1]=0 At this time, we would like to join E1 \nand E2. Using the standard join algorithm for the base domain does not yield a satisfying result; the \ninvariant we desire requires quanti.ers, as ncan be arbitrarily large. Therefore, the join algorithm \nfor our universally quanti.ed domain D. begins by introducing quanti.ers in both elements. (Throughout \nthis paper, we call anything of the form .U(F.e) a quanti.er or quanti.ed fact, while a domain element \nfrom D. is called a quanti.ed domain element.) The details of quanti.er introduction are explained later; \nthe result is as follows: E1 . : i=1 ..k(k=0.A[k]=0) E2 . : i=2 ..k(k=0.A[k]=0) ..k(k=1.A[k]=0) Note \nthat E1 . and E2 . are equivalent to E1 and E2. Also note that the two quanti.ed facts in E2 . have the \nsame right-hand side. Therefore, they can be simpli.ed to a single quanti.er. We call this simpli.cation \nquanti.er merging. The tricky part is merging the guards. In general, given two quanti.ed facts from \nthe same domain element, .U(F1 .e) and .U(F2 .e), it is logically sound to merge them into .U(F1 .F2 \n.e). However, our domain does not represent disjunctions since they are a major source of inef.ciency. \nThe standard way of approximating disjunction in an abstract domain is with the join operation. However, \nusing join will lead to unsoundness here. Consider the facts .i(i =0.e) and .i(i=2.e). The join of the \nguards in a typical numerical domain will yield 0=i=2. However, the fact .i(0=i=2.e) is not a sound over-approximation \nof the conjunction of the two original facts. The source of the problem is that the join algorithm for \nan ab\u00adstract domain is required to generate an over-approximation of the disjunction of two elements. \nSince the guard of a quanti.er ap\u00adpears in a negative position (in the antecedent of an implication), \nwe must under-approximate the disjunction of guards instead. Unfor\u00adtunately, most domains are not equipped \nwith under-approximation operators. This paper addresses the problem by constructing sound under-approximations \nfor each domain operation, given the corre\u00adsponding over-approximations. These under-approximations work \nin fairly general circumstances, which allows us to parametrize our universal domain with a wide variety \nof base domains. Our solution is quite simple. We under-approximate disjunc\u00adtions by taking the join \nin the base domain Db of the two disjuncts (an over-approximation) and then adding extra constraints \nto the result until it is a valid under-approximation. Fortunately, the join of the two guards in E1 \n. and E2. , 0 =k =1, is already a valid under-approximation, so there is no need to re.ne it. Hence, \nafter the simpli.cation of E2. , we now are faced with joining these two elements in D.: E1 '. : i=1 \n..k(k=0.A[k]=0) E2 '. : i=2 ..k(0=k=1.A[k]=0) The facts about iin the two environments can be joined \nusing the standard over-approximation operator from Da. Since the two quanti.ers have the same right-hand \nside, A[k]=0, we choose to join them together. In general, when joining two quanti.ers .U(F1 .e)and .U(F2 \n.e)from different quanti.ed domain elements, a safe answer is .U(F1 .F2 .e)(meaning it over\u00adapproximates \nthe .of the two inputs). However, doing such a sim\u00adple conjunction of guards will almost always lead \nto imprecision. In this case, it simply yields the new fact .k(k=0.A[k]=0), which is no better than if \nwe had joined the quanti.er-free facts. The key to solving this problem is to join quanti.ers in the \n presence of their environments.The iconstraints in E1 and E2 offer natural upper bounds for k. So rather \nthan generating F1 . F2, we would like to produce F =(E1 . F1).(E2 . F2),where E1 and E2 are the respective \nenvironments of the universally quanti.ed elements to be joined. Unfortunately, we are again faced with \nthe problem of under-approximating a logical formula that is essentially disjunctive (since implication \nis another form of disjunction). To solve this problem, we use a similar approach to the one before: \nwe use an over-approximation of the join algorithm in Db to start with, and then re.ne this answer until \nit is a valid under\u00adapproximation. The initial join takes the environments into account by joining E1 \n.F1 with E2 .F2. In the array initialization example, we must join i=1 . k =0with i=2 . 0 =k =1.The result, \n1=i=2 .0=k<i, is a sound and precise guard for the fact A[k]=0. Thus, there is no need to re.ne the result, \nsince it is already a valid under-approximation. For simplicity, we can eliminate the constraints on \ni, since they are already represented in the joined environment. Ultimately, we get the following element \nin the quanti.ed domain, which is the one we desired: E :1=i=2 ..k(0=k<i.A[k]=0) The steps we took to \narrive at this result may appear somewhat ad-hoc. Perhaps if the loop had not been unrolled twice, or \nthe ini\u00adtial quanti.ers had been introduced differently, or if the join algo\u00adrithm had not always produced \na valid under-approximation, our approach would have been less successful? In powerful domains like this \none, the threat is ever-present that small changes to the inputs can lead to a dramatic loss of precision. \nTo alleviate this fear, we prove that our domain is complete relative to a fairly in\u00adtuitive partial \norder in the quanti.ed domain (although not relative to the implication partial order, which is undecidable). \nOur under\u00adapproximation operators are also complete for common domains. Our implementation does perform \ntricks like loop unrolling, but it does so only as a performance optimization. It would still arrive \nat the desired invariant even without loop unrolling; however, doing so forces it to consider many more \npossible quanti.ed invariants, most of which are spurious. Contributions. The contributions of this paper \nare four-fold. We describe a parametrized framework of universally quanti\u00ad.ed abstract domains. We describe \na general technique to con\u00adstruct under-approximation operations from their respective over\u00adapproximations. \nWe provide soundness proofs and restricted com\u00adpleteness proofs for both. Finally, we present benchmarks \non com\u00adplex array-and pointer-based examples demonstrating that it is pos\u00adsible to construct practical \nabstract interpreters using our method\u00adology. 2. Quanti.ed Abstract Domain we prove soundness with respect \nto the standard logical implication The quanti.ed domain, D., is parametrized by three (not neces\u00ad sarily \ndifferent) base abstract domains, Da, Db,and Dc.We as\u00adsume these are conjunctive domains, meaning that \neach domain el\u00adement is a conjunction of atomic facts of the form p(t1,...,tk) or \u00acp(t1,...,tk). pcan \nbe any predicate, such as =, <, or reachabil\u00adity. Each ti is an arbitrary term. We assume that these \ndomains are equipped with a partial order . However, since the domains are conjunctive domains, we can \nthink of domain elements as formulas in some logical theory. As such, the partial order should always \n.for that theory T respect the standard logical implication relation (i.e., . .). T An abstract element \nEin quanti.ed domain D. is of the form . One important point to note is that when completeness is de\u00ad.ned \nrelative to this partial order of quanti.ed elements an analysis that never introduces any quanti.ed \nfacts is still considered com\u00adplete. This partial order only guarantees that, once a quanti.ed fact is \nintroduced, it will be preserved as long as possible. Addition\u00adally, the partial order treats quanti.ed \nfacts as independent of each other. Thus, for example, it does not require an analysis to transi\u00adtively \nclose quanti.ed facts to achieve completeness. We consider this property to be bene.cial, since it allows \nus to forgo transitive T partial order,. closure of quanti.ed facts for ef.ciency while still providing \na mea\u00ad sure of completeness. 2.2 Templates (2) E = E . ^ .Ui(Fi .ei) A serious problem in implementing \na quanti.ed domain is know\u00ad i where (a) E .Da is the environment, (b) Fi .Db and ei .Dc for each i, and \n(c) without loss of generality, for each i, Ui is a set of variables disjoint from the program variables. \nThe semantics of the abstract element Eis described in terms of the semantics of the constituent abstract \ndomains Da, Db,and Dc. Let .Da , .Db ,and .Dc , be the concretization functions of the base abstract \ndomains. The concretization function .D. of the quanti.ed abstract domain is de.ned as follows. A program \nstate ...D. (E) iff ...Da (E),and  for every i,if .' is an extension of state . with assignment to \nvariables in Ui such that .' ..Db (Fi), then, .' ..Dc (ei).  A special and important class of quanti.ed \nabstract domains is obtained when D:= Da = Db = Dc. For simplicity and ease of presentation throughout \nthe rest of this paper we will only refer to the base domain Dand the quanti.ed domain D..  2.1 Quanti.ed \nPartial Order The most obvious partial order for the quanti.ed domain is logical implication. However, \ngiven that the partial order for the base domain may be weaker than logical implication, we have no hope \nof deciding implication on the quanti.ed domain. A more tractable approach is to obtain a quanti.ed partial \norder whose power is relative to the partial order given for the base domain. However, even this problem \nis quite tricky. Consider the following two quanti.ed abstract elements. E1 : .j,k(0 =j<n-1 .k = j +1 \n.A[j] =A[k]) E2 : .j,k(0 =j<k<n.A[j] =A[k]) E1 implies E2, but proving the implication requires induction. \nWe would like to avoid solving such hard problems. Therefore, we use a simpli.ed partial order de.ned \nas follows. We say ' nn ing when to introduce quanti.ers. For example, consider the quanti.er-free element \nwhose environment is A[0] = 0. One valid way of turning this fact into a quanti.ed fact results in .k(k \n= 0 .A[k]= 0). However, there are many other ways, such as .k(k =0 .A[k]= k) and even .k(k =0 .A[A[k]] \n= A[k]). According to the quanti.ed partial order given above, these differ\u00adent quanti.ed elements are \nindependent of each other, since their right-hand sides are not related by in any environment. Introduc\u00ading \na greater number of quanti.ers may improve precision, but it incurs a cost in performance. Therefore, \nwe add extra structure to the Dc domain by requiring that all atomic facts represented in it match one \nof a given set of templates. A template is a formula such as a[a]=0.An atomic fact e matches a template \nt if there is a substitution s over the template s variables such that e = ts via syntactic equality. \nIn the examples above, we would not introduce the fact A[A[0]] = A[0] when using the template a[a]=0. \nWe would introduce A[0]= 0, since there is a substitution s = {a= A,a=0}. Templates have three kinds \nof variables, Greek, Roman, and .xed. Fixed variables are treated the same as constants they can only \nbe matched with a program variable of the same name; Greek and Roman variables can match arbitrary expressions. \nWhen in\u00adtroducing quanti.ers, we quantify over the Greek variables but not the Roman ones. Greek variables \nare written a,Roman vari\u00adables as a, and .xed variables as A. Thus, from the fact A[0]= 0 and the template \na[a]=0 we would create a single quanti.er, .a(a=0 .A[a]= 0). Templates have an important impact on precision \nin practice. Without any templates, no quanti.ers are ever introduced, making the analysis no more powerful \nthan the base domain. However, we did not .nd it dif.cult to produce good templates during our experiments. \nAll the quanti.ed invariants that we found useful have complex guards, but their right-hand sides are \nsimple. Since templates are needed only for the right-hand sides, they are not a signi.cant obstacle \nin generating useful invariants. E . ^ .Ui(Fi .ei) . E ' . ^ . U '' ' i (Fi .ei)  3. Abstract Interpreter \nfor D. i=1 i=1 when the following criteria are satis.ed: (i) The environments match up in the base domain: \nE E'. ' (ii) For each fact .U(Fi'.ei) on the right-hand side, there is a fact .U(Fj .ej) on the left-hand \nside (assumed to have the same set of variables, for simplicity) such that: (a) E.Fi' Fj , ' and (b) \nE .ej ei. We choose this partial order because it is fairly natural and because it is powerful enough \nthat the examples presented later are analyzable. We prove completeness relative to this partial order, \nbut This section presents the principal transfer functions for D., along with soundness and completeness \nproofs:  The join function computes an over-approximation of the log\u00adical .of two quanti.ed abstract \nelements (essentially their union), which involves under-approximating the . of their quanti.er guards. \n The assignment transfer function eliminates any references to the variable being assigned to. Then \nit adds a new equality rep\u00adresenting the assignment. Variable elimination is handled by over-approximating \n.quanti.er elimination, which, in turn, re\u00ad  I.lD. (E,E ' ) n 1 Let E be E. VVi=1 .Ui(Fi . ei). ' m \n'' 2 Let E be E ' . j=1 .Uj(Fj ' . ej). 3 E '' := I.lD (E,E ' ); 4 result := E '' ; 5 forall i .{1,..,n},j \n.{1,..,m}: 6 e:= I.lDc ((ei,E),(ej' ,E ' )); 7 if (e= \u00d8) continue; F '' ' 8 ij := L.J((Fi,E),(Fj ' \n,E )); 9 result := result ..Ui,(F '' . e) ij 10 forall i .{1,..,n}: F '' 11 i0 := L.J((Fi,E),(false,E \n' )); 12 result := result ..Ui(Fi'' 0 . ei) 13 forall j .{1,..,m}: F '' ' 14 0j := L.J((false,E),(Fj \n' ,E )); j' (F '' ' 15 result := result ..U 0j . ej) 16 return result; Figure 1. I.lD. . The join algorithm \nfor the quanti.ed domain. quires under-approximating . quanti.er elimination for quanti\u00ad .er guards. \n Quanti.er introduction uses templates to move facts from the environment into a new quanti.ed fact. \nQuanti.er merging combines the guards of two quanti.ed facts with the same right\u00adhand sides. Guards are \nmerged using an under-approximation of ..  A widening step ensures termination of abstract interpretation. \n We discuss these basic operators in this section; the next sec\u00adtion describes the under-approximation \noperators that they depend on. A common theme here is that over-approximating an oper\u00adator for the quanti.ed \ndomain requires us to under-approximate its dual for the guard. Since both under-approximation and over\u00adapproximation \nare so important in this area, we use a special nota\u00adtion. An under-approximation of a formula F is denoted \nLFJ, while an over-approximation is written IFl. Similarly, operators like . are written as either L.J \nor I.l. 3.1 Quanti.ed Join Algorithm V Consider two elements of D., E := E . n .U(Fi . ei) and Vi=1 \n'' m ' E := E . j=1 .U(Fj ' . ej). The join algorithm is described below; pseudo-code is shown in Figure \n1. Let L := (D, ) denote the base logical lattice. We assume that we are given a procedure, I.lD , that \nimplements a sound and complete join operator for the base domain with respect to the lattice L. The \n.rst step in joining two quanti.ed domain elements is to join their environments in the base domain, \nas shown on Line 3 of Figure 1. Next consider the process of joining quanti.ed facts. When computing \nthe join of, say, E..U(F1 . e1) and E ' ..U(F1 ' . e1' ), we .rst need to match e1 and e1' that is, make \nthem identical. To do so, we take advantage of the fact that all quanti.ers are generated from templates, \nso the right-hand side of each quanti\u00ad.er matches some template. We say two quanti.ers match if they \nmatch the same template in the same way. However, this matching can be tricky, as illustrated by an exam\u00adple. \nConsider the following two quanti.ed domain elements to be joined (facts like these appear in practice \nwhen analyzing selection sort). E1 :(x= min) ..u(F1(u) . A[x] = A[u]) E2 :(y = min) ..u(F1' (u) . A[y] \n= A[u]) When joining these elements, we would like to generate a quanti.er whose right-hand side is A[min] \n= A[u]. The facts in both of these elements were generated from a template t := a[v] = a[a].It is easy \nto see that in E1, the right-hand side matches the template t with substitution s1 = {a = A,v = x,a = \nu}.In E2 the substitution is s2 = {a = A,v = y,a = u}. Somehow from these two substitutions we must generate \nA[min] = A[u]. To do so, we take advantage of the environments of the two quanti.ed elements using the \njoin algorithm from the base domain. We convert each substitution into a fact in the base domain. For \nexample, s1 is converted to S1 := a = A . v = x . a = u (templates are required to use fresh variables). \nThen we compute the join of the substitutions: S := I.lD (E . S1,E ' . S2).In the example, we get S =(a= \nA.v = min.a = u).If Simplies that each template variable is equal to some expression, then S can be converted \nto a substitution s,and s applied to tyields the desired right-hand side of the joined quanti.er, A[min] \n= A[u].If S does not imply a value for each template variable, then the quanti.ers are said not to match. \nThe function I.lDc ((e1,E),(e1' ,E ' )) carries out the algorithm just described. It returns either an \natomic fact as its result, or \u00d8 if the inputs do not match. Now, suppose that we have made the right-hand \nsides of the two quanti.ers identical and we are left with the problem of computing the join of E ..U(F1 \n. e) and E ' ..U(F1 ' . e). It is easy to see that the result of this join should contain a fact .U(F \n. e), where F satis.es the following property: F . E . F1 and F . E ' . F1 ' ' . F ' Hence F is an under-approximation \nof (E . F1) . (E 1). We need a function on the base domain that computes such an F. Speci.cally, we assume \nthat we have the procedure L.J((Fil,El),\u00ad(Fjr,Er)) that under-approximates (El . Fil).(Er . Fjr) in D. \nSection 4 presents an algorithm to compute this function, which is sound and, in some cases, complete. \nGiven this algorithm, the pseudo-code in Figure 1 proceeds as one would expect. Lines 6-9 match up quanti.ers \non either side and relate their guards via L.J. Lines 10-15 perform a similar function, but their job \nis to match up a fact .U(F . e) on one side with a dummy fact .U(false . e) on the other. For example, \nconsider the following quanti.ed elements (similar to the .nd example in our experiments). E1 : found \n= false E2 : found = true ..i(0 = i< 10 . P(i)) The join of these two facts should not be simply T. \nWe can arrive at a more precise fact, namely: E ' : .i(found = true . 0 = i< 10 . P(i)) We produce this \nquanti.er because E1 has an implicit quanti.er saying .i(false . P(i)). This implicit quanti.er, when \nmatched with the quanti.er in E2, yields the quanti.er in E ' . Thisistrue because of the following fact: \nL.J((false,found = false),(0 = i< 10,found = true)) =(found = true . 0 = i< 10) Therefore, our join \nalgorithm also tries to match each quanti.er on either side with false, as shown in Lines 10-15. Correctness. \nWe prove the soundness of the join with respect to T the strongest partial order possible: logical implication, \n..How\u00adever, we prove completeness using a weaker partial order, .,since a complete algorithm with respect \nto logical implication is undecid\u00adable. Proofs of both these lemmas appear in the full version of this \npaper (Gulwani et al. 2007). The soundness (completeness) proof requires that the base domain operations, \nand L.J,are them\u00adselves sound (respectively complete). The L.J implementation we present later is sound, \nbut complete only in some circumstances. I.l( \u00a3,E) Vn 1 Let E be E . i=1 .Ui(Fi . ei); // Instantiate \nsome quantified facts. ' V 2 E := E .{eis | E D Fis; \u00a3 occurs in eis} // Fix Fi 1: Remove affected instances \n3 Ti := {t | t Voccurs in Fi,ei; Vars (t) n Ui = \u00d8}4 := Fi .{NotEffect((\u00a3,E '),t)}; F ' i t.Ti // Fix \nFi 2: Remove \u00a3 from Fi F '' ' 5 i := L.J(\u00a3,F i ' ,E ); // Fix ei: Remove \u00a3 from ei 6 ei ' := I.l(\u00a3,ei,E \n' . Fi ' ); // Fix E: Remove \u00a3 from E 7 E '' := I.l(\u00a3,E ' ); '' Vn .Ui(F '' ' 8 return E .. ei); i=1 \ni Figure 3. I.l. Procedure for existential elimination in the quanti\u00ad.ed domain. T LEMMA 1 (Soundness \nof Join wrt .). If E '' is the fact returned ' '' ''' TT by the function I.lD. (E,E ),then E.E and E \n.E . LEMMA 2 (Completeness of Join wrt .). Let E be the fact re\u00ad(El ' turned by the function I.lD. ,Er).If \nE is another fact such that El . E ' and Er . E ' ,then E . E ' .  3.2 Existential Elimination for Assignment \nThe transfer function for an assignment \u00a3 := r is shown on the left side of Figure 2. Most of the machinery \nfor this function is handled by I.l(\u00a3,E), which eliminates any reference to the lvalue \u00a3 from the quanti.ed \ndomain element E. Once all references have been eliminated, the equality created by the assignment is \nassumed. This function assumes that assignments where \u00a3appears in r have been decomposed into the form \nt := r; \u00a3 := t , where t is a fresh variable. The dif.cult part of implementing assignment is delegated \nto existential quanti.er elimination, I.l(\u00a3,E). This function elimi\u00adnates all references to \u00a3 from E. \nIt is described throughout the re\u00admainder of this subsection. When the assignment is to a program variable \n(i.e., when \u00a3 = v for some v) then the goal is to generate an over-approximation of the formula .\u00a3.E, \nwith the complication that . cannot be represented directly in our domain. When a heap location is being \nupdated (say, \u00a3 = A[0]) then the situation is more complicated. In this case, \u00a3 is a term F(t1,t2), where \nF is an operator like array sub-scripting or .eld access. We de.ne the notion of existential quanti.cation \nof the term F(t1,t2) in a formula fas follows: .(F(t1,t2),f) =.F ' ([.x,y(x= t1 . y = t2) . F ' (x,y)= \nF(x,y)] . f[F ' /F]) (3) The above de.nition is in terms of second-order existential quan\u00adti.cation (of \na function symbol) applied on a speci.c form of a universally quanti.ed formula. We require the base \ndomain to supply an operator I.l(\u00a3,E) that returns an abstract element E ' that over-approximates the \nlogical operator .(\u00a3,E) and that does not contain \u00a3. To formally de.ne the I.l operator on the lattice, \nwe need to de.ne what it means for aterm \u00a3to not occur in an abstract domain element E ' . DEFINITION \n1 (Provably not in, .E). Aterm t is provably not in E assuming environment E ' , denoted by t .E ' E, \nif either (a) tis a variable and tdoes not syntactically occur in E,or (b) t is of the form F(t1,t2) \nand for every term F(t1' ,t2' ) that (syntactically) occurs in E, it is the case that either E ' t1 = \nt1 ' or E ' t2 = t2' .  NotEffect((x,E),x)= false NotEffect((x,E),t)= true when tis not x NotEffect((t,E),x)= \ntrue when tis not x NotEffect((A[e],E),B[e ' ]) = e = e ' if EA = B NotEffect((A[e],E),B[e ' ]) = NotEffect((A[e],E),e \n' ) if EA = B NotEffect((A[e],E),B[e ' ]) = NotEffect((A[e],E),e ' ) . e = e ' otherwise Figure 4. NotEffect \nfunction for the Array Base Domain. The basic job of I.l(\u00a3,E) is to return an E ' so that \u00a3 . E ' . \nIt is clear from this de.nition that the more disequalities we know, the fewer terms will have to be \neliminated. Thus, we de.ne a more re.ned operator I.l(\u00a3,E,E ' ) that eliminates \u00a3 from E using disequalities \nfrom the environment E ' . This operator can be de.ned from the simpler one by .rst computing I.l(\u00a3,E \n. E ' ) and then eliminating from the result any facts that are implied by the environment E ' . EXAMPLE \n4. In the logical lattice induced by the theory of unin\u00adterpreted function symbols, we have (a) I.l(F(x),x \n= y. u = F(x)) is x = y, (b) I.l(F(x),F(x)= F(y) . u= F(x)) is true, (note here that soundness requires \nthat u = F(y) not be in the result because it is not the case that F(x) .F (x)=F (y).u=F (x) u = F(y) \nsince F(x)= F(y) . u = F(x) does not imply y = x.) (c) I.l(F(x),x = y.F(x)= F(y) .u = F(x)) is x = y.u \n= F(y), (d) I.l(F(F(x)),F(x)= F(y) . u = F(x) . x = u) is x = u. u = F(x).  The I.l(\u00a3,E,E ' ) operation \ncan be used to eliminate \u00a3 from the environment of a quanti.ed domain element E. Figure 3 shows the complete \nalgorithm for eliminating \u00a3from E.Line 7 shows the elimination from the environment. In the remainder \nof the section, we describe what the other lines do. Elimination from Dc. A universal quanti.er represents \nan in.\u00adnite conjunction over all possible instantiations of the quanti.ed variables. Some of these instances \nmay be affected by a change to \u00a3 and others may not be. We would like to eliminate the affected instances \nwhile leaving the others alone. This can be achieved by strengthening the guard. Consider the following \nfact: E := .i(0 = i< 10 . A[i]= 0) If the location A[0] is updated, then we can update the guard of \nthis quanti.er, but otherwise leave it alone: E ' := .i(0 = i< 10 . i =0 . A[i]= 0) The general process \nof updating the guard is handled by Line 4 of Figure 3. For each term in the quanti.er that includes \na quanti.ed variable, it computes a condition under which the term will not be affected by a change to \nthe updated lvalue. In the example above, it knows that the term A[i] appearing in A[i]=0 will not be \naffected by an update to A[0] as long as i =0. This constraint is then added to the guard. Computing \nthese constraints is the responsibility of the NotEffect function. This function will be somewhat domain-speci.c, \nsince it depends on the semantics of the functions used to represent heap access. In general, NotEffect((\u00a3,E),t) \ngenerates a constraint in D that holds when a change to \u00a3 does not affect the value of term PreCondition: \n\u00a3is not a pre.x of r. PreCondition: eis an atomic formula on the base domain PostAssign(E,\u00a3 := r) ' \nPostAssume(E,e) 1 E := I.l(\u00a3,E); Vn '' Vn ' // Let E be E..Ui(Fi . ei) i=1 // Let E be E ..Ui(Fi ' . \nei) i=1 // Add the new fact to the environment // Add the new fact to the environment 1 E ' := EI.le; \n2 E '' := PostAssume(E ' ,\u00a3 = r); Vn '' . Vn ' 2 return E ' ..Ui(Fi . ei); i=1 3 return E i=1 .Ui(F ' \n. ei); i Figure 2. PostAssign and PostAssume. The procedures for computing post-conditions of assignment \nand assume statements are standard. t. NotEffect may use information from the environment E.An example \nNotEffect function that works for Java-style arrays is shown in Figure 4. After adding extra constraints \nto the guard, Line 6 of the algo\u00adrithm eliminates any terms from the quanti.er s right-hand side that \nmay be affected by the update to \u00a3.The I.l algorithm is allowed to use disequalities from both the environment \nand from the guard, some of which may have been introduced by NotEffect. Elimination from guard. A common \ntheme of this paper is that performing an over-approximation operation on a quanti.ed do\u00admain element \nrequires us to perform an under-approximation of its dual on the guard. Consider the following example. \nE := i = n..k(0 = k<i. P(i)) This is a typical situation after exiting a loop that establishes prop\u00aderty \nP. Imagine now that the programmer assigns to variable i so it can be used for another loop. It is wrong \nto simply eliminate facts from the guard involving i, since that would produce .k(0 = k. P(i)), which \nis not a sound inference. Under-approximating existential elimination on the guard is also a mistake, \nsince that would produce .k(false . P(i)), which is sound but useless. Instead, we will under-approximate \nuniversal quanti.cation. In environment E, with guard F, we will .nd the weakest fact F ' such that F \n' ..\u00a3.(E . F). In the example above, our goal is to .nd F ' so that F ' ..i.(i = n. (0 = k<i)). It is \neasy to verify that F ' := 0 = k<nis such a fact. We use the function L.J(\u00a3,F,E) to .nd the under-approximation \nof .\u00a3on fact F in environment E. An algorithm to compute L.J is given later in the paper. Line 5 of Figure \n3 relies on this algorithm to eliminate \u00a3from the guard of a quanti.er. Quanti.er instantiation. One \nimportant step in existential elimi\u00adnation is to instantiate some quanti.ers and move the instantiations \nto the environment, especially those that may be invalidated. This may seem pointless, since these facts \nwill be immediately elimi\u00adnated from the environment as well. However, they may lead to inferences in \nthe environment before they are eliminated. Consider the following example, which is derived from insertion \nsort. E := .k(0 = k<i. A[k] = A[k+1]) The programmer assigns A[j +1] := A[j],where j is a local variable. \nOur NotEffect algorithm will convert the quanti.er to the following: .k(0 = k<i. k = j+1 . k+1= j+1 . \nA[k] = A[k+1]) Compared to the old quanti.er, two facts are lost: A[j] = A[j+1] and A[j +1] = A[j +2]. \nHowever, if we put these two facts into the environment, then even after eliminating A[j +1] from them, \nwe retain A[j] = A[j+2] by transitivity. Hence, we get a stronger result. Line 2 of Figure 3 performs \nthis quanti.er instantiation. Note that because of the way our partial order . is de.ned, this step is \nnot needed to prove completeness. However, it increases precision in practice, so we include it nonetheless. \nSoundness and completeness. These two lemmas prove sound\u00adness and completeness for I.l on D.. They are \nsimilar to the cor\u00adresponding ones for the join operation. They depend on the sound\u00adness and completeness \nof the base domain operations, , I.l,and L.J. Both are proved in the full version of this paper (Gulwani \net al. 2007). T LEMMA 3 (Soundness of I.l wrt .). If E ' := I.l(\u00a3,E),then T E.E ' and \u00a3 .E E ' . LEMMA \n4 (Completeness of I.l wrt .). If E '' := I.l(\u00a3,E), ''' ''' then for all E s.t. E . E and \u00a3 .E E ''' \n, it is the case that '' ''' E . E . 3.3 Miscellaneous Transfer Functions Conditionals. We assume that \nall conditionals in the program are converted to assume statements. The right side of Figure 2 shows \nthe transfer function for assume. It simply adds the assumed condition to the environment. Partial order. \nWhen computing a .xed point, it is necessary to check if one quanti.ed domain element is below another \nin the partial order. The de.nition of . is purely in terms of . Hence, the check for . is easily implemented \nusing an implementation of . The soundness and completeness of this implementation follows directly from \nthe soundness and completeness of and the de.nition of .. 3.4 Quanti.er Introduction and Merging Quanti.ers \nare introduced by .nding facts in the environment that match a given set of templates, as described in \nSection 2.2. This step takes place before a join, as joins may throw away facts from the environment \nunless they are quanti.ed .rst. This step clearly preserves soundness. It is complete according to our \nlattice ., since the resulting quanti.ed element is actually below the original one in the lattice. A \nrelated operation, merging two quanti.ers into a single one, is sometimes desirable. Frequently, after \nintroducing new quanti.ers from the environment, we get a fact like: E := .k(k =0 . A[k]= 0) ..k(k =1 \n. A[k]= 0) Since our lattice . essentially treats different quanti.ers indepen\u00addently, the analysis \nmay become more precise if we merge these facts into a single one: E ' := .k(0 = k = 1 . A[k]= 0) We \nmerge two quanti.ers (in a process called Merge) when their right-hand sides match the same template \nwith the same substitu\u00adtions. In this case, we can write these quanti.ers as .U(F1 . e) and .U(F2 . e). \nTo merge the guards F1 and F2, we compute an under-approximation of their disjunction (essentially unioning \nthem together). In Section 4, we describe how to implement an op\u00aderator L.J(F1,F2,E) that under-approximates \ndisjunction in an environment E. Given this function, we can eliminate the origi\u00adnal quanti.ers and replace \nthem with .U(F . e),where F = L.J(F1,F2,E). This transformation is sound (complete) assum\u00ading L.J is \nsound (complete). 3.5 Widening, Termination, and Complexity Widening is used in abstract interpreters \nto ensure termination. We de.ne a widening operator, \\., on the quanti.ed domain using a widening operator, \n\\, on the base domain and an operator, L,on the base domain that is dual of the widening operator. DEFINITION \n2 (Dual Widening). An operator L(F1,F2) is a dual widening operator if (i) L(F1,F2) F1, (ii) L(F1,F2) \nF2, and (iii) for every in.nite sequence F1>F2> \u00b7\u00b7\u00b7 , the sequence F1' ,F2' ,F3' ,...,where F1 ' := F1 \nand Fi ' := L(Fi'-1,Fi) (for i = 2), is not strictly decreasing. Atrivial L operator is one that always \nreturns false. Given quanti.ed abstract domain elements E1 and E2,the widening operator \\.(E1,E2) returns \nE3.Let Ei be written V Ei . ni .U(Fij . eij ). We assume that the universal vari\u00ad j=1 ables in e1j and \ne2k have been appropriately matched up. Then E3, the widening result, is de.ned as follows. (a) E3 is \n\\(E1,E2), (b) if E2 E1 (that is, E2 is not equivalent to E1), then n3 is equal to n2 and for each k \n=1,...,n3, e3k is e2k and F3k is F2k. (c) if E2 E1 (that is, E2 is equivalent to E1), then n3 is equal \nto n2 and for each k =1,...,n3, if, for some j .{1,...,n1}, e1j e2k and E1 n F2k E1 n F1j ,then e3k is \nequal to \\(e1j,e2k) and F3k is L(E1 . F1j ,E1 . F2k);otherwise, F3k := F2k and e3k := e2k.  Termination. \nWe now establish termination of our abstract inter\u00adpreter. Suppose that it does not terminate. This can \nhappen only if we get an in.nite chain of successively weaker facts, E1 . E2 . E3 . \u00b7\u00b7\u00b7 , V where Ei \nis Ei . ni .U(Fij . eij ). This in.nite chain and the j=1 the de.nition of . together imply that, E1 \nE2 E3 \u00b7\u00b7\u00b7 . The widening step (a) guarantees that the base abstract interpreter always terminates, and \nhence there is a .nite msuch that all Ei s, for i= m, are (logically) equivalent. Now let us consider \nthe quanti.ed facts in the above in.nite chain starting from the m-th element. The in.nite chain above \n(and the de.nition of .) implies that we will have a chain of quanti.ers, .U(Fmj . emj ),.U(Fm+1,j ' \n. em+1,j ' ),\u00b7\u00b7\u00b7 , such that (we assume universal variables have been renamed and made equal) Em n emj \nem+1,j ' Em n Fm+1,j ' Fm,j Em+1 n em+1,j ' em+2,j '' Em+1 n Fm+2,j '' Fm+1,j ' . . . . . . We know \nthat all E s in the above are equivalent to Em. Hence, it follows that, Em n Fm,j > Em n Fm+1,j ' > Em \nn Fm+2,j '' >\u00b7\u00b7\u00b7 Em n em,j Em n em+1,j ' Em n em+2,j '' \u00b7\u00b7\u00b7 The widening operator, \\,onthe e s and the \ndual widening opera\u00adtor, L,on the F s guarantee that this chain is not strictly decreas\u00ading. This establishes \ntermination of our abstract interpreter. Complexity. Recall that we use Merge to merge multiple quanti\u00ad.ed \nfacts .U(F1 . e), .U(F2 . e), ..., .U(Fk . e) with the same right-hand side, e. In our implementation, \nwe modify the Merge rule so that it keeps at most K different quanti.ed facts with the same right-hand \nside e. Second, by using a .nite set of templates to specify Dc (Section 2.2), we ensure that the number \nof distinct facts e that can occur on the right-hand side of a quan\u00adti.ed fact is bounded, say by M. \nAssuming M and K are .xed constants, we can show that the complexity of our abstract inter\u00adpreter is \nonly a polynomial factor over the complexity of the base domain abstract interpreter (Gulwani et al. \n2007).  4. Under-Approximation Operators The underapproximation operators, L.J, L.J,and L.J, are needed \nby the abstract interpreter for the quanti.ed domain. They are not, in general, reducible to the other \nstandard lattice operators. Hence, we have to develop dedicated algorithms for these operators for each \nbase domain. Here, we present sound generic procedures that work for any base domain. These procedures \nare complete only for certain theories, like difference constraints, as will be explained. The following \nexample demonstrates the dif.culty of computing under-approximations. EXAMPLE 5. In a version of insertion \nsort without loop unrolling (unlike the one appearing later in the experiments section), the fol\u00adlowing \ntwo quanti.ed domain elements are generated on different paths. j = i- 1 ..u(0 = k<i- 1 . A[k] <A[k+1]) \nj<i- 1 ..u(0 = k<i. A[k] <A[k+1]) Both facts say that the array is sorted except at position j,but they \nsay it in different ways. Eventually, these paths are joined together, causing the guards (and their \nrespective environments) to be combined via L.J. L.J((0 = k<i- 1,j = i- 1), (0 = k<i, j<i- 1)) := L(j \n= i- 1 . 0 = k<i- 1) . (j<i- 1 . 0 = k<i)J One valid result is 0 = k<i . k = j. When used as a guard, \nwe get the following quanti.er. It agrees with our intuition that the array is sorted at every position \nbut j. .u(0 = k<i,k = j . A[k] <A[k+1]) There are two dif.culties in computing the under-approximations. \nFirst, the under-approximation result must be an element of a con\u00adjunctive domain, so it cannot use any \ndisjunction. Second, each input to the under-approximation must be understood in the con\u00adtext of its \nenvironment, and the two inputs may have different environments (as is the case for L.J). We solve these \ndif.culties using a technique called abduction. Abduction is a process in arti.cial intelligence that \ngenerates an ex\u00adplanation for a fact given a set of assumed facts (the environment). We de.ne abduct(E,F \n' ) to be the set of all explanations F for a base fact F ' in the context of an environment E. Formally, \nT' E . F . F and E . F is consistent We require abduct(E,F ' ) to compute the set of all possible explanations \nF that satisfy the requirement above. An algorithm to compute abduct will be given later. Using it, we \ncan now de.ne the two underapproximation functions as follows: L.J(F1,F2,E):= abduct(E,F1 . F2) L.J((F1,E1),(F2,E2)) \n:= abduct(E1,F1) n abduct(E2,F2) We can use these two de.nitions as algorithms for computing L.J and \nL.J. However, since abduct can return many different answers, this algorithm would be fairly inef.cient. \nInstead, we use the standard over-approximations from the base domain to compute I.l and I.l, and then \nuse abduct to add additional constraints until we reach a valid under-approximation. Pseudo-code is given \nin Figure 5 and Figure 6; the next sections explain these algorithms in detail. L.J((F1,E1),(F2,E2)) \n1 F := I.l(F1I.lE1,F2I.lE2) 2 Forall e1 . F1 - F: 3 F := F . abduct(E1I.lF,e1); 4 Forall e2 . F2 - F: \n5 F := F . abduct(E2I.lF,e2); 6 Return F; Figure 5. Underapproximation of conjunction. This operator \nis used for implementing I.l on the quanti.ed domain. 4.1 Under-approximating Conjunction in Two Environments \nUnder-approximating conjunction is necessary when joining two quanti.ers from different domain elements. \nFor a quanti.ed do\u00admain element E1 ..U(F1 . e) and another E2 ..U(F2 . e), the joined quanti.ed element \nmust have a guard that under\u00adapproximates (E1 . F1) . (E2 . F2) (recall that simply using F1 . F2 is \ntoo imprecise). The function L.J((F1,E1),(F2,E2)) computes this under-approximation. As mentioned in \nthe previous section, abduct(E1,F1) n abduct(E2,F2) is a sound answer for this problem. However, us\u00ading \nabduct in this way may lead to many different answers, and it would be inef.cient. Instead, we start \nby computing a conjunction of facts that must be in the answer, and then add more conjuncts using abduct \nuntil we have a sound result. Another way to think of this algorithm is that we start with an initial \nguess and then re.ne it to a valid answer. An over-approximation of the conjunction of guards in their \nenvironments is a good place to start, since it is like an under\u00adapproximation but less constrained (because \nthe under-approximation implies the over-approximation). Therefore, starting with the over\u00adapproximation \nwill not preclude any potential answers; we then add extra constraints by abduction until we .nd a correct \nunder\u00adapproximation. Fortunately, it is easier to .nd a good over-approximation of (E1 . F1).(E2 . F2) \nthan to .nd a good under-approximation. We are allowed to assume E1 . E2, since it is known in the join \nthat either one quanti.ed domain element or the other holds. In this case, the following inference is \nvalid. (E1 . F1) . (E2 . F2)(E1 . F1) . (E2 . F2) . E1 . F1 assuming E1 . E2 . F2 assuming E2 . (E1 . \nF1) . (E2 . F2) assuming E1 . E2 It is easy to over-approximate this formula in the base domain using \nits join algorithm, I.l. In fact, with a bit more examination above, it s clear that when E1 is disjoint \nfrom E2 (that is, E1 .\u00acE2), then the top formula and the bottom formula are equivalent. In most cases, \nthe two environments are disjoint, usually having forms like E1 = E . i =1 and E2 = E . i =2. Due to \nthis fact, we know that (E2 . F2) . (E1 . F1) is not just an over-approximation, it is usually the best \nover-approximation. Figure 5 shows the remainder of the algorithm for conjunc\u00adtion in the presence of \nenvironments. After computing the over\u00adapproximation, it generates more constraints via abduction to \nen\u00adsure that the result is a valid under-approximation. Note that since abduction may generate multiple \nanswers, this algorithm may also have many results. The pseudo-code makes sense if we consider abduct \nas a non-deterministic algorithm, and let the results of L.J be the set of all possible results, given \nthe non-determinism of abduct. The algorithm .rst considers all atomic facts in F1 that are not already \nimplied by F, the over-approximation. For each such fact, abduction is used to .nd explanations for why \nthis fact is true in the .rst environment. For example, if E1 says j =2 and e is i =2, then one possible \nabduction result is simply i =2.However, i = j is another possible answer, which may be more precise. \nThe same process is repeated for F2, using the updated F. Note that the closer the initial over-approximation \nis to a valid under-approximation, the fewer calls there are to abduct, and the quicker the algorithm \nruns. EXAMPLE 6. Consider these inputs, which occur when zero itera\u00adtions of an array initialization \nare joined with one iteration. E1 := i =0 F1 := false E2 := i =1 F2 := j =0 The procedure L.J((F1,E1),(F2,E2)) \nwill compute j =0 . i = 1. This result is obtained in Line 1, and the other lines do not contribute to \nthe result. Similarly, the following occurs when the .rst iteration of an array initialization loop is \njoined with the second iteration. E1 := i=1 F1 := j =0 E2 := i=2 F2 := 0 = j< 2 In this case, the procedure \nwill compute 0 = j<i. Again, this result is obtained in Line 1, and the other lines do not contribute \nto the result. The following example illustrates the importance of the results returned by abduction. \nEXAMPLE 7. After unrolling the inner loop of bubble sort once, we get three different sets of facts. \nWe consider only two sets here. In set one, the .rst 3 elements of the array are already sorted and we \nget E1 : change =0 . A[0] = A[1] = A[2]. In the second set, the array is not sorted initially, but the \nlargest element moves up, and we get E2 : change =1 . A[0] = A[2] . A[1] = A[2]. These facts are generalized \nto give the following elements of the quanti.ed domain, E1 : change =0 ..U(0 = u1 = u2,1 = u2 = 2 . A[u1] \n= A[u2]) E2 : change =1 ..U(0 = u1 = 2,u2 =2 . A[u1] = A[u2]) where U := (u1,u2), and F1 and F2 are the \nunderlined formulas in the two elements respectively. When we join these two facts, we have to compute \nthe following underapproximation, L.J((F1,change =0),(F2,change =1)) This returns two mutually incomparable \nanswers: change =0.F1 and F2. The .rst one leads to the invariant which says that if change is zero, \nthen the array is sorted. The second one gives the quanti.ed invariant that the last element is the largest \nelement (which is the correctness statement of the inner loop of bubble sort). The soundness of the procedure \nin Figure 5 follows directly from the soundness of abduct. The completeness follows from the observation \nthat (i) we do not lose any solutions in Line 1 as it is an over-approximation of any possible answer; \nand (ii) completeness of abduct guarantees that we generate all possible explanations. 4.2 Under-approximating \nDisjunction in an Environment Under-approximating disjunctions of base facts is useful when two quanti.ers \nfrom the same quanti.ed domain element are to be combined into a single quanti.er. In this case, their \nguards are combined via L.J(F1,F2,E),where E is the environment and F1 and F2 are the guards. L.J(F1,F2,E) \n1 F := I.l(F1I.lE,F2I.lE) 2 Foreach e1 . F1 - F and e2 . F2 - F: 3 F := F . abduct(EI.lF,e1 . e2); 4 \nReturn F; Figure 6. Underapproximation of disjunction. This operator is used for implementing I.l on \nthe quanti.ed domain. As in the algorithm for conjunction, we start with an initial over\u00adapproximation \nof the result and then re.ne it with more constraints. In this case, the over-approximation is even easier \nto compute. We could start with I.l(F1,F2). However, we wish to take advantage of facts that are known \nto be true in the environment, so instead it is safe to start with I.l(F1I.lE,F2I.lE). Figure 6 shows \nthe remainder of the algorithm, which adds more constraints using abduction to get a sound under-approximation, \nas was done for conjunctions. EXAMPLE 8. For the inputs, F1 := (1 = k = n) F2 := (k =0) E := true the \nprocedure L.J(F1,F2,E) returns 0 = k = n. This result is obtained in Line 1, and the other lines do not \ncontribute to the result. We note here that this particular example is reminiscent of the range merging \napproach of Jhala and McMillan (2007). As another example, consider the inputs F1 := (j =0,k =1) F2 := \n(j = k) E := (0 = k = 1) In this case, the procedure L.J(F1,F2,E) will compute 0 = j = k. Again, this \nresult is obtained in Line 1 itself. The next example shows how abduction is useful. F1 := (0 = i< 10) \nF2 := (11 = i< 20) E := true The join in Line 1 produces F =(0 = i< 20). The loop in Line 2 has a single \niteration, with e1 =(i< 10) and e2 = (11 = i). These are the facts that are not implied by F.Line 3 calls \nabduct((0 = i< 20),(i< 10) . (i = 11)). It returns the answer i =10, which is correct because (0 = i< \n20) . (i = 10) implies (and thus under-approximates) (i< 10) . (i= 11)). The soundness of the procedure \nin Figure 6 follows directly from the soundness of abduct. The completeness follows from the fact that \n(i) Line 1 generates an over-approximation and does not forbid any solution; while (ii) the completeness \nof abduct guarantees that all solutions are generated.  4.3 Generating Explanations via Abduction The \nprevious two sections use abduction to generate alternate ex\u00adplanations for a formula in the context \nof an environment. This section explains how to implement abduction. The simplest sound implementation \nof abduct(E,e1 . ... . ek) can return any ei. However, a more sophisticated abduction procedure that \ntakes ad\u00advantage of facts from the environment will improve the precision of the rest of the system. \nThe abduction algorithm we describe in this section is even complete for certain base domains. Our abduction \nalgorithm is based on the following principle. ^ TT_ (E . (\u00acei) . e) implies (E .\u00ace. ei) ii That is, \nthe negation of any fact e implied by E and the negation of all the eisisavalid answer for abduct. Therefore, \nwe take the set of all such facts that are maximally strong and return their nega\u00adtions. As an optimization, \nwe ignore all facts implied by the envi\u00adronment alone, since they are not useful. Figure 7 shows pseudo\u00adcode \nfor this algorithm. abduct(E,f) 1 let f be e1 .\u00b7\u00b7\u00b7. ek, where ei is an atomic fact 2 ans := \u00d8; 3 Foreach \nmaximally strong V atom e s.t E. i \u00acei . e and E . e 4 ans := ans .{\u00ace}; 5 return(ans); Figure 7. Abductive \nreasoning in the base domain using forward reasoning. A literal is an atomic formula or its negation. \nThe abduct function is used for implementing all underapproximation operators. It assumes that negated \natomic formulas can be repre\u00adsented in the base domain. EXAMPLE 9. Consider computing abduct(E,f),where \nE := j =2 f:= i=2 We will search for all maximally strong facts e such that j = 2 . i=2 implies e(and \nj =2 alone does not imply e). The most obvious answer is i =2, but another potentially useful answer \nis i = j. We return the negations of both these facts as possible answers. Implementing this algorithm \nrequires two non-trivial properties of the base domain. First, it must support negation of atomic facts. \nAll of the domains that we have implemented for our experiments can perform sound reasoning about negated \nfacts. Second, the do\u00admain must be able to enumerate the maximally strong facts implied by a set of formulas. \nIt is easy to do this for saturation-based do\u00admains like difference constraints or reachability. If one \nof these properties is not satis.ed by the base domain, it is still possible to implement a simpler but \nless complete abduction procedure, such as the trivial one that returns its inputs. However, we believe \nthat most domains used in practice do ful.ll these requirements. EXAMPLE 10. Let us revisit Example 5 \nwherein we had to compute L.J((0 = u<i- 1,j = i- 1), (0 = u<i, j<i- 1)). In Line 1, we compute a join \nand get F := (0 = u< i,j = i- 1) This is not a sound underapproximation. We need to strengthen it as \nin Line 3 and Line 5 of Figure 5. For example, we will need to strengthen it by abduct(F.j = i-1,u<i-1). \nWe compute this by computing atomic facts implied by F . j = i- 1 . u = i- 1. Some such atomic facts \nare u= i-1,u= j,.... Using the second atomic fact, u = j, and adding its negation to F results in the \nanswer 0 = u<i,u = j that is used in Example 5. We remark here that the inductive invariant generated \nin Ex\u00adample 5 is not present in the code in any way. It took 3 hours of manual effort to generate this \nprecise inductive invariant, which is automatically generated in our approach. The soundness of the abduction \nprocedure (Figure 7) is obvious from its description. There is a potential loss of completeness on Line \n3 since we only search for atomic (and not arbitrary) e. However, the procedure in Figure 7 can be shown \nto be complete for certain theories (Gulwani et al. 2007). 4.4 Under-approximating . in an Environment \nThe underapproximation operator L.J requires computing an ex\u00adplanation for a fact in the context of a \nknown fact such that the explanation does not contain the quanti.ed term. Recall that L.J(\u00a3,F,E) under-approximates \nthe logical formula .\u00a3(E . F). The function L.J(\u00a3,F,E) can be computed using the procedure L.J(\u00a3,F,E) \n1 let F be e1 .e2 .\u00b7\u00b7\u00b7.ek, where ei is atomic 2 ans := true; 3 for i=1,...,k do 4 Nondeterministically \nchoose maximally strong atom e in I.l(\u00a3,\u00acei,E) 5 ans := ans .\u00ace; 6 return(ans); Figure 8. Underapproximation \nof .Quanti.cation. This operator is used in implementing I.lon the quanti.ed domain. given in Figure \n8. The soundness of the procedure follows from noting the following logical equivalences: ans ..\u00a3(E .F) \niff (.\u00a3.(E.\u00acF)) .\u00acans Assuming that the abstract domain can precisely represent literals (atomic formulas \nand negated atomic formulas), it is easy to see that the procedure of Figure 8 always returns an underapproximation \nof the forall quanti.ed formula.  5. Experiments In our experiments, we instantiated our quanti.ed \ndomain by two base domains. The .rst base domain was the logical domain de\u00ad.ned by the combination of \nlinear arithmetic and uninterpreted symbols (Gulwani and Tiwari 2006). We extended this domain to include \nsome disequality reasoning. Disequalities permit us to rep\u00adresent disjoint ranges in a single quanti.er \nguard, rather than split\u00adting them into multiple quanti.ers. The second base domain we used was a saturation-based \ndomain that has inference rules for reasoning about data structure reachability. One appeal of our ap\u00adproach \nis that our quanti.ed domain can switch from linear arith\u00admetic/uninterpreted functions to reachability \nwith little effort. This section .rst gives an overview of the reachability domain, and then describes \nour experiments over both domains. 5.1 Reachability We considered a domain in which each element is \na conjunction of atomic facts of the form R(e1,e2) |\u00acR(e1,e2) | e1 = e2 | e1 = e2 where each expression \neis of the form e::= x | null | e.next The reachability predicate, R(x,y), intuitively denotes that there \nis a path from the object speci.ed by x to the object speci.ed by y, where the path passes through a \nset of .xed pointer .elds in the objects (e.g., the next .eld). A reachability predicate is commonly \nused in the analysis of pointer data structures (Bingham and Rakamaric 2006). Given a set of known reachability \nfacts, we saturate it by apply\u00ading a set of inference rules to add new facts (as described in (Bing\u00adham \nand Rakamaric 2006)). Examples of these reachability infer\u00adence rules for lists include: e2 = e1.next \n. R(e1,e2) R(e1,e2) .R(e2,e3) . R(e1,e3) R(e1,e2) .e1 = e2 . R(e1.next,e2) The algorithms for meet, join, \nand existential elimination are be\u00adyond the scope of this paper. We used the generic under-approximation \nalgorithms described in Section 4 for this domain. Despite not being complete in this context, they are \nprecise enough to handle the following examples, which we extracted from our linked list manipulation \nbenchmarks. Underapproximation of disjunction in an environment. When initializing the data .elds of \nan acyclic singly-linked list to zero, we arrive at the following quanti.ed domain element. It represents \nthe case where property P has been established for the .rst two list elements (recall that we use loop \nunrolling for better performance). Variable \u00a3 is the head of the list and the iteration pointer p points \ntwo elements beyond it. We would like to merge the two quanti.ers. p= \u00a3.next 2 ..u(u= \u00a3.P(u)) ..u(u= \n\u00a3.next .P(u)) This requires computing an underapproximation of disjunction of F1 =(u = \u00a3) and F2 =(u \n= \u00a3.next) in presence of the environment E =(p = \u00a3.next2). The answer that is computed by our generic \nunder-approximation algorithm is as follows. It says that P is true for all nodes between \u00a3and \u00a3.next, \ninclusive, which is what we desire. L.J(F1,F2,E)= R(\u00a3,u) .R(u,\u00a3.next) Underapproximation of conjunction \nin two environments. The preceding example shows the case when the .rst two elements have been initialized. \nNow consider joining this case with the one where only the .rst element has been initialized. E1 := p= \n\u00a3.next ..u(u = \u00a3.P(u)) E2 := p= \u00a3.next 2 ..u(R(\u00a3,u) .R(u,\u00a3.next) .P(u)) This requires computing an underapproximation \nof conjunction of F1 =(u = \u00a3) and F2 = R(\u00a3,u) .R(u,\u00a3.next) in presence of their environments E1 =(p = \n\u00a3.next) and E2 =(p = \u00a3.next2). L.J((F1,E1),(F2,E2)) = R(\u00a3,u) .R(u.next,p) The above answer gives the \nguard for the quanti.ed fact that says that the property P is true for all nodes between \u00a3 and the node \nimmediately before p, inclusive. This is an inductive loop invariant that can now be used to verify that \nthe loop establishes P for all elements. 5.2 Results We applied our techniques to automatically generate \ninvariants for some standard sorting routines and other similar problems that have been studied as challenge \nproblems for generation of quanti.ed in\u00advariants in the literature. We report on some of the examples \nin detail in Table 1. Benchmarks were run on a 3 GHz Intel processor with 2 GB of RAM. In the array examples, \nwe used .xed vari\u00adables instead of Roman variables in the templates to increase per\u00adformance. We also \nunrolled loops two times to avoid discovering spurious invariants. The .rst few examples in Table 1 have \nbeen taken from Jhala and McMillan (2007). ArrayInit is the example from our Section 1. Our tool discovers \nthe invariant that all array elements are initial\u00adized to 0. It uses a template A[a]=0. VarArg (from \nJhala and McMillan (2007)) counts the number of non-null entries in a list, and then scans over that \nmany list entries again, asserting non\u00adnullness. We use a template A[a]=0. ArrayCopy (from Gopan et al. \n(2005)) simply copies the contents of one array into another, distinct array. Our tool discovers the \ninvariant that the two arrays arethe same. Weuse thetemplate A[a]= B[a]. ArrayCopyProp (from Jhala and \nMcMillan (2007)) starts with the pre-condition that a source array has only non-zero elements. It copies \nthis array into a distinct destination array. Our tool checks that the destination ar\u00adray has only non-zero \nelements. We use the template A[a]= B[a]. Find (from Flanagan and Qadeer (2002)) searches an input array \nfor a speci.c value, setting a .ag if it is found. After the search, our tool discovers that if the .ag \nis not set, the value is not present in the array. We use the template A[a]= v. PartialInit (from Gopan \net al. (2005)) copies those indices of a source array for which the source array s value is positive \ninto a target array. Our tool discovers that the source array s values are all positive at the indices \nstored in the target array. We use the template A[B[a]]=0. Partition (from Beyer et al. (2007)) copies \nthe zero and non-zero elements of a source array into two different arrays. Our tool discovers that the \ntwo destination arrays have entirely zero or non-zero entries. We use the two templates B[a]=0and C[a]=0. \nThe next four examples constitute the inner loop of various sort\u00ading algorithms. For each of these examples, \nwe were able to dis\u00adcover the inductive invariant required for proving that the .nal ar\u00adray is sorted. \nWe use three kinds of templates in these examples: A[a]= e, e = A[a],and A[a]= A[a+1]. (Caveat: Because \nof a bug in our quanti.ed instantiation routine, we had to hand-annotate the results of one quanti.er \ninstantiation in both InsertionSort and SelectionSort and the timing results do not take this into account. \nHowever, we do not anticipate any signi.cant increase in the tim\u00ading of these examples with the .x of \nthe quanti.er instantiation routine.) The .nal four examples are standard acyclic singly-linked list \nmanipulation routines. We were primarily limited by our current implementation of the reachability base \ndomain that can only han\u00addle one next link. However, our technique theoretically works equally well for \nother data-structures such as cyclic linked lists, doubly-linked lists, and trees, and we have manually \ntraced our al\u00adgorithm to successfully discover similar invariants for these data\u00adstructures. All four \nlist examples are designed to establish or preserve the invariant that all list elements have a data \n.eld set to zero. They all use the template that a.data =0. The insert and remove routines start with \na pre-condition that \u00a3is a list with data .elds set to zero, and t is a pointer into the list. They insert \nor remove at position t. The list init example assumes a valid list on entry, and we discover that its \ndata .elds are zero on exit. The list create example creates a list from scratch, and we discover that \nthe result is a list, whose data .elds are zero. (Caveat with the list create, insert, and remove examples: \na bug in our reachability saturation procedure forced us to hard-code the results of some reachability \ndomain operations. As a result, the timings for these benchmarks may under-estimate the true time.) The \ntotal time take by some of these examples seems rather large compared to the size of these examples. \nHowever, it must be noted that we have a very naive and inef.cient saturation based im\u00adplementation of \nthe underlying difference constraints domain and reachability domain. This is corroborated by the fact \nthat the time taken to do abstract interpretation over simply the base quanti.er\u00adfree abstract domain \nin those examples is also large. An interesting attribute to read from the tables in that case is the \nratio of the time taken to do abstract interpretation over quanti.ed domain and the corresponding quanti.er-free \ndomain.  6. Related Work Automatic generation of (universally) quanti.ed invariants has been a topic \nof extensive research (Flanagan and Qadeer 2002; Cousot 2003; Lahiri and Bryant 2004; Gopan et al. 2005; \nBradley et al. 2006; Beyer et al. 2007; Jhala and McMillan 2007). The var\u00adious approaches differ in the \nextent of user guidance assumed. In one class of methods, the user speci.es the predicates and the tool \nsearches for the right boolean structure that gives an inductive in\u00advariant (Flanagan and Qadeer 2002; \nBradley et al. 2006; Lahiri and Bryant 2004). In the dual approach, the user speci.es the boolean structure \nand the tool searches for the right predicates (Beyer et al. 2007). In our approach, the user is not \nrequired to specify either the boolean structure or the predicates. Flanagan and Qadeer (2002) require \nthat all atomic formulas in the quanti.ed invariants be given. Given such a set of atomic Table 1. Benchmark \nresults. Times are in seconds. The third col\u00adumn reports time for the mode wherein abstract interpretation \nis performed over the base quanti.er-free abstract domain. Procedure D. Time D Time Ratio ArrayInit \n3.2 1.5 2.1 VarArg 4.1 2.0 2.1 ArrayCopy 5.5 2.2 2.5 ArrayCopyProp 11.3 6.8 1.7 PartialInit 12.0 6.1 \n2.0 Find 24.6 8.3 3.0 Partition 73.0 22.7 3.2 InsertionSort (inner loop) 35.9 2.0 18 QuickSort (inner \nloop) 42.2 4.5 9.4 SelectionSort (inner loop) 59.2 8.1 7.3 MergeSort (inner loop) 334.1 73.5 4.5 List \nRemove 20.5 1.4 14.6 List Insert 23.9 1.4 17.1 List Init 24.5 1.9 12.9 List Create 42.0 3.4 12.4 formulas, \ntheir approach generates a quanti.ed invariant that can be expressed using only those atomic formulas. \nFor example, to generate the quanti.ed invariant .u(0 = u<n. A[u]= 0) for the array initialization procedure, \ntheir method requires that the three predicates u = 0, u<n,and A[u]=0 be given. Our approach, on the \nother hand, would generate the quanti.ed invariant with only the template a[a]=0. In our approach, the \nantecedent, 0= u<n,is learned using join of facts generated in 0, 1,or 2iterations of the loop. Jhala \nand McMillan (2007) have described an interpolation based technique to generate quanti.ed invariants. \nThey have in\u00adstantiated their technique to discover range predicates that capture properties of sequences \nof array properties (e.g., facts such as the elements of the array M from index i through j are positive \n). The range predicate R(t1,t2,p)denotes .i(t1 = i<t2 . p), where i is a free variable in p. This can \nnot represent, for ex\u00adample, that the contents of a two-dimensional array is initialized: .i,j(0= i< \nn,0= j<m. A[i][j]=0). Representing this fact would require a new and different range predicate with its \nown set of axioms. It is not clear what is a good choice for a complete set of such range predicates. \nThere will always be interesting examples that are not representable using a prede.ned range predicate. \nThe logic .ow analysis by Might (2007) also maintains quanti\u00ad.ed facts about contiguous ranges of array \nelements. It does not use predicate abstraction, but it still is unable to handle complex guards like \nthose that appear in the sorting examples. Beyer et al. (2007) combine invariant generation and predicate \nabstraction techniques using path invariants. While this technique is independent of any particular invariant \ngeneration technique, Beyer et al. (2007) describe a particular template-based approach for gen\u00aderating \nquanti.ed invariants. The template-based technique reduces the search of an invariant to constraint solving \nover a large number of (unknown) variables used to specify the templates. While it is sound in general, \nit is complete only for a very speci.c form of in\u00advariants, .U(.iti(X)= ui = ti' (X). r(X,U)),where X \nare the program variables and ti,ti' ,r are linear expressions (with pa\u00adrameterized coef.cients) with \nthe provision that array reads of the form A[ui]can occur in r. Note that correctness of sorting routines \ncan not be stated using the above template since it disallows com\u00adparison between quanti.ed variables. \nFurthermore, the translation from the original templates to the .nal constraints is not generic and has \nto be freshly worked out for each base domain. While the high-level approach (choose templates and translate \nto constraints) is general, the details are not general. One fundamental difference of our framework \nfor generating quanti.ed invariants, compared to these other works (Flanagan and Qadeer 2002; Lahiri \nand Bryant 2004; Bradley et al. 2006; Beyer et al. 2007; Jhala and McMillan 2007), is that it is based \non ab\u00adstract interpretation. This offers a more ef.cient methodology of discovering useful program invariants, \nalbeit at the cost of merging facts at join points (which may result in loss of some precision). While \nabstract interpretation based methods have been thoroughly investigated for unquanti.ed domains (Cousot \nand Cousot 1977; Karr 1976; Cousot and Halbwachs 1978), they have seen only lim\u00adited exploration for \nquanti.ed domains (Cerny 2003; Cousot 2003; Gopan et al. 2005). In the work of Cousot (2003) and Gopan \net al. (2005), quanti.ed facts are encoded as new unquanti.ed predi\u00adcates and lattice operators are de.ned \ndirectly on these unquanti.ed predicates. The automation achievable via the under-approximation operators \nhas to be painfully hard-coded in these methods. Cousot (2003) has used an abstract domain consisting \nof ele\u00adments of the form (lt(t, a, b, c, d),r), which informally says that all elements of t between \nindices a and b are less than any element of t between indices c and d. In our notation, this element \nis repre\u00adsented as, r(a, b, c, d)..u1,u2(a = u1 = b.c = u2 = d . t[u1] = t[u2]) (Since the auxiliary \nvariables a, b, c, d always have de.nitions in terms of program variables, they can be eliminated and \nwe get ex\u00adactly an element of our quanti.ed abstract domain.) Cousot (2003) presents procedures to compute \nthe abstract logical operators on this domain, and it can be easily veri.ed that the underapproxi\u00admation \ncalculation is built into the de.nitions. Using this abstract domain, Cousot (2003) generates invariants \nfor a sorting routine. The work of Gopan et al. (2005) is similar in spirit to the work of Cousot (2003). \nThey use an abstract domain (P, O, .),where P is a partition of an array s indices, O associates each \npartition with a numerical abstract domain element, and . is a valuation of some given abstract predicates \non each partition. Again, this abstract do\u00admain element can be expressed in our quanti.ed abstract domain \nas Requirements on base domain D Section(s) R1 Compute I.l, I.l, I.l, , \\ 3.1, 3.3, 3.2, 3.3, 3.5 R2 \nCompute L.J, L.J, L.J, L 3.1, 3.4, 3.2, 3.5 R3 Compute NotEffect, Matching 3.2 R4 Templates, Represent \nequality 3.4 (2.2) R2 Compute consequences 4 Table 2. Base domain requirements. In addition to a base \nabstract interpreter (R1), we need to compute under-approximations (R2), compute NotEffect and match \nterms in D (R3), and represent equality and match terms with templates (R4). We can replace R2 by R2 \nif we use our under\u00adapproximation procedures. using a rich interface provided by the base domain (Table \n2). This interface consists of the standard over-approximation functions along with additional functions \nthat compute under-approximations of logical boolean operators. The under-approximation functions play \na foundational role in the process of invariant generation. We also instantiate this framework to obtain \ntwo speci.c ab\u00adstract interpreters one for programs that manipulate arrays and the other for programs \nthat manipulate heap-based linked data\u00adstructures. These abstract interpreters are used to successfully \ngen\u00aderate quanti.ed invariants stating correctness of several procedures that work on arrays and lists. \nAcknowledgments. We thank Krishna Mehra and Lakshmisubrah\u00admanyam Velaga for their help implementing the \nbase domains. References Dirk Beyer, Tom Henzinger, Rupak Majumdar, and Andrey Rybalchenko. Path invariants. \nIn PLDI, 2007. Jesse D. Bingham and Zvonimir Rakamaric. A logic and decision procedure for predicate \nabstraction of heap-manipulating programs. In VMCAI, pages 207 221, 2006. A. R. Bradley, Z. Manna, and \nH. Sipma. What s decidable about arrays? In VMCAI, volume 3855 of LNCS, pages 427 442. Springer, 2006. \nP. Cerny. Veri.cation par interpretation abstraite de predicats parametriques. Master s thesis, Univ. \nParis VII &#38; Ecole normale su\u00adperieure, Paris 20, 2003. Patrick Cousot. Veri.cation by abstract interpretation. \nIn Veri.cation: ^ p .. where u . p essentially denotes a conjunction of constraints, and ^ .u(u . p . \nO(p)) . .u1,u2(u1 . p.u2 . p . .(p)), Theory and Practice, volume 2772 of LNCS, pages 243 268, 2003. \np .. Patrick Cousot and Radhia Cousot. Abstract interpretation: A uni.ed lattice model for static analysis \nof programs by construction or approximation of .xpoints. In POPL, pages 234 252, 1977. O(p) and .(p) \ndenote some atomic facts. It should again be noted that the antecedent is carefully .xed here and Gopan \net al. (2005) provide dedicated descriptions of the transfer functions. Our paper uniformly generalizes \nthese speci.c abstract domains (that represent quanti.ed facts) by explicitly making quanti.ed facts \n.rst-class objects. It builds on our earlier work (Gulwani and Tiwari 2007) that developed an abstract \nquanti.ed domain with must and may equalities but goes signi.cantly beyond by devel\u00adoping a precise \nformal theory for abstract interpretation on generic quanti.ed domains using under-approximation operators. \nWe also present generic procedures for computing transfer functions for the quanti.ed domain thus automating \na lot of the manual effort in building special domains such as in Cerny (2003); Cousot (2003); Gopan \net al. (2005).  7. Conclusion Quanti.ed abstract domains provide the expressive power re\u00adquired to state \nuniversally quanti.ed invariants of unbounded data\u00adstructures. We formally de.ne quanti.ed abstract domains \nby using base domains whose facts are used to build universally quanti.ed facts as parameters. We provide \na general framework for building abstract interpreters over such quanti.ed domains. This is achieved \n Patrick Cousot and Nicolas Halbwachs. Automatic discovery of linear restraints among variables of a \nprogram. In POPL, pages 84 97, 1978. Cormac Flanagan and Shaz Qadeer. Predicate abstraction for software \nveri.cation. In POPL, pages 191 202, 2002. Denis Gopan, Thomas W. Reps, and Shmuel Sagiv. A framework \nfor numeric analysis of array operations. In POPL, pages 338 350, 2005. Sumit Gulwani and Ashish Tiwari. \nCombining abstract interpreters. In PLDI, pages 376 386, June 2006. Sumit Gulwani and Ashish Tiwari. \nStatic analysis of heap manipulating low-level software. In CAV, LNCS, 2007. Sumit Gulwani, Bill McCloskey, \nand Ashish Tiwari. Lifting abstract inter\u00adpreters to quanti.ed logical domains. Technical Report MSR-TR-2007\u00ad87, \nMicrosoft Research, July 2007. Ranjit Jhala and Ken McMillan. Array abstractions from proofs. In CAV, \n2007. Michael Karr. Af.ne relationships among variables of a program. In Acta Informatica, pages 133 \n151. Springer, 1976. Shuvendu K. Lahiri and Randal E. Bryant. Indexed predicate discovery for unbounded \nsystem veri.cation. In CAV, pages 135 147, 2004. Matthew Might. Logic-.ow analysis of higher-order programs. \nIn POPL, pages 185 198, 2007.  \n\t\t\t", "proc_id": "1328438", "abstract": "<p>We describe a general technique for building abstract interpreters over powerful <i>universally quantified</i> abstract domains that leverage existing quantifier-free domains. Our quantified abstract domain can represent universally quantified facts like &#8704;<i>i</i>(0 &#8804; <i>i</i> &lt; <i>n</i> &#8658; &#945;[<i>i</i>] = 0). The principal challenge in this effort is that, while most domains supply over-approximations of operations like join, meet, and variable elimination, working with the guards of quantified facts requires <i>under</i>-approximation. We present an automatic technique to convert the standard over-approximation operations provided with all domains into sound under-approximations. We establish the correctness of our abstract interpreters by identifying two lattices---one that establishes the soundness of the abstract interpreter and another that defines its precision, or completeness. Our experiments on a variety of programs using arrays and pointers (including several sorting algorithms) demonstrate the feasibility of the approach on challenging examples.</p>", "authors": [{"name": "Sumit Gulwani", "author_profile_id": "81100315615", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP14115174", "email_address": "", "orcid_id": ""}, {"name": "Bill McCloskey", "author_profile_id": "81309509846", "affiliation": "University of California: Berkeley, Berkeley, CA", "person_id": "PP14170696", "email_address": "", "orcid_id": ""}, {"name": "Ashish Tiwari", "author_profile_id": "81100398928", "affiliation": "SRI International, Menlo Park, CA", "person_id": "PP43120154", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328468", "year": "2008", "article_id": "1328468", "conference": "POPL", "title": "Lifting abstract interpreters to quantified logical domains", "url": "http://dl.acm.org/citation.cfm?id=1328468"}