{"article_publication_date": "01-07-2008", "fulltext": "\n Automatic Inference of Stationary Fields: a GeneralizationofJava s Final Fields Christopher Unkel Monica \nS. Lam Computer Systems Laboratory Stanford University Stanford, CA 94305 {cunkel,lam}@stanford.edu \nAbstract Java programmers can document that the relationship between two objects is unchanging by declaring \nthe .eld that encodes that re\u00adlationship to be final. This information can be used in program understanding \nand detection of errors in new code additions. Un\u00adfortunately,few.elds in programs are actually declared \nfinal. Pro\u00adgrams often contain .elds that could be final,but are not declared so. Moreover, the de.nition \nof final has restrictions on initializa\u00adtion that limit its applicability. We introduce stationary .elds \nas a generalization of final.A .eld in a program is stationary if, for every object that contains it, \nall writes to the .eld occur before all the reads. Unlikethe de.nition of final .elds, there can be multiple \nwrites during initialization, and initialization can span multiple methods. We have developed an ef.cient \nalgorithm for inferring which .elds are stationary in a program, based on the observation that many .elds \nacquire their value very close to object creation. We presume that an object sinitialization phase has \nconcludedwhen its referenceissavedin someheap object.Weperform precise analysis only regarding recently \ncreated objects. Applying our algorithm to real-world Java programs demonstrates that stationary .elds \nare more common than final .elds: 44 59% vs. 11 17% respectively in our benchmarks. These surprising \nresults have several signi.cant implications. First, substantial portions of Java programs appear to \nbe written in a functional style. Second, initialization of these .elds occurs very close to object creation, \nwhen very good alias information is available. These results open the door for more accurate and ef.cient \npointer alias analysis. Categories and Subject Descriptors F.3.3[Studies of Program Constructs]: Object-oriented \nconstructs; F.3.2[Semantics of Pro\u00adgramming Languages]: Program analysis General Terms Algorithms, Languages \nKeywords stationary, Java, .nal, initialization Thisworkwas supportedin partby the National ScienceFoundation \nunder Grant No. 0326227. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page.To copyotherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. POPL 08 January 7 12, 2008, San Francisco, California, USA. Copyright c . 2008ACM 978-1-59593-689-9/08/0001...$5.00 \n1. Introduction In programs written in an object-oriented programming language, it is often the case \nthat one object has a .xed relationship to another object.Forexample,an object composedof smaller objects \nwill have a .xed relationship to each of its components. Such relationships are frequently captured in \nsome .elds of an object soon after the object is created. The .eld may be written multiple times during \nthe initialization phase, but it stabilizes before it is used and remains constant for the rest of its \nobject s lifetime.We refer to such .elds as stationary. Knowing which .elds arestationary providesan \nobject-oriented basis for reasoning about aliases for objects across time. Program\u00admers naturally use \nthese invariants when reasoning about their pro\u00adgrams. Theydon t worry that an object s parent has changed, \nbe\u00adcause they know or perhaps assume that no code ever alters a child s parent.When programmerswanttoknowthe \nidentityofthe window s parent, theywill start looking close to where the window is created to .nd out \nwhat the relationship is. Stationary .elds of\u00adferadifferent approachto reasoning about objects.We shallshow \nthat it is relative easy to .nd stationary .elds in a program. Once we know that a .eld is stationary, \nwe can conclude that two reads of the same .eld of an object are the same without tracking all the pointers \nthat may possibly point to the object of interest. This sug\u00adgests that it is bene.cial for compilers \nand program analysis tools to understand stationary .elds, as programmers already do. This may lead to \na more precise points-to analysis with less effort. 1.1 Final FieldsinJava The presence of unvarying \nrelationships between objects is not a new observation, as this notion motivated the design of Java s \n.\u00adnal .elds.AJava programmer can declare an object instance .eld (Java nomenclature for .elds inside \nobjects) to be final, which, informally, means that it does not change once initialized. TheJava Language \nSpeci.cation observes: Declaring a variable final can serveas useful documentation that itsvalue will \nnot changeand can help avoid programming errors. (Gosling et al. 2005) The Java compiler provides aid \nin avoiding mistakes by enforcing proper\u00adties in code it compiles. These properties combine to ensure \nthat final .elds, once initialized by the constructor, are not modi\u00ad.ed by ordinary means. (Declaring \na .eld final does not guaran\u00adtee absolutely that it is constant: it may still be modi.ed by ex\u00adtraordinary \nmeans such as re.ection, native methods, and other implementation-dependent functionality.) Declaring \na .eld final prevents programmers frommaking the mistakeof modifying .elds that should be constant, by \ndirecting the compiler to reject pro\u00adgrams that erroneously change those .elds. The properties of final \n.eldsare de.nedsothatverifyingthem .ts within Java s model of compilation and dynamic class loading. \nSpeci.cally, because Java classes may be compiled separately, and because they are then loaded separately, \nit must be possible to verifythe propertybyexamininga single classata time.Infact, it is possible to \nverify the property by examining a single method at a time. 1.2 Automatic Inference of Final Fields \nWe speculate that there are many more .elds that are being used like they are .nal without being declared \nas such. Automatic .\u00adnal .eld inference is useful because the information can serve as documentation \nand may be used for other analyses. It can also be used to .nd errors in subsequent code modi.cations \nin the software development process. Suppose a .eld is used originally as a .nal .eld; if subsequent \ncode additions violate this pattern, then it may be worthwhile to .ag the inconsistency as a possible \nerror. Many recent projectshaveusedtheideaof intenttoinfer propertiesinthe absence of accurate declarations \nor documentation (Engler et al. 2001; Heine andLam 2003, 2006; Kremenek et al. 2006; Livshits and Zimmermann2005;Williams \nand Hollingsworth 2005;Yang et al. 2006). Such properties have been used to .nd thousands of critical \nerrors in programs. We can infer if a .eld can be legally declared as .nal in a program, by examining \nthe usage pattern of the .eld in the code. Note that in the presence of dynamic loading, the inferred \nproperty holds only for the code examined. The Java .nal .eld modi.er is de.ned to admit a relatively \nsimple veri.cation procedure. As a result, it is not as generally applicable as it could be. There are \nseveral important limitations: A.nal .eld must be assigned exactly once on each execution path through \neach constructor de.ned for the class containing it. This de.nition excludes the case where the .eld \nis .rst de.ned for the common case, and based on some exceptional conditions, the .eld can be updated \nbefore the .eld is ever accessed otherwise.  A .nal .eld must not be assigned outside the constructors \nof the class declaring it. This is restrictive because the constructor might invoke utility procedures \nto perform initialization; or, an objectfactory may create and return the object, with the method using \nthefactory responsible for the initialization.  A.nal .eld is de.ned based on textual properties.Aprogram \nmay use a .eld as if it is a .nal even though it contains un\u00adexecuted code that violates such properties. \nThis is especially prevalent if large, general Java libraries are used.  Not all cases where a .nal \n.eld is read before it is assigned are identi.ed and prohibited: those through aliases to this, or in \nmethods invoked by the constructor, are not found. However, thefact that most cases are identi.ed and \nprohibitied suggests that it is undesirable to read such a .eld before it is written.  As we show in \nour empirical results, the de.nition of .nal .elds greatly restricts the number of .elds encoding unvarying \nrelationships to which it can be applied. 1.3 Stationary Fields In practice,the initializationofastationary.eldmayspandifferent \nmethods. The .eld may be written to multiple times during the initialization process. What is important \nis that the value of the .eld must stabilize before the .eld is used. That is, all reads of a stationary \n.eld of the same object are guaranteed to follow all the writes, and thus must return the same value. \nThus, we say that a .eld f in class c is stationary in a program if all writes to .eld f in every object \no of class c occurbefore all reads of f in o. 1.4 Inferring Stationary Fields This paperpresentsan algorithmfor \n.nding stationary .eldsinJava programs. The analysis is subject to the usual caveats regarding re\u00ad.ection \nand native methods,but is conservative otherwise. The re\u00adsults are thus useful for error detection and \nprogram understanding tools,but should not be used for program optimization in the gen\u00aderal case. Our \nalgorithm makes the simplifying assumption that an ob\u00adject s stationary .elds are initialized soon after \nthe object is cre\u00adated, and that the initialization, which may involve multiple writes and in multiple \nprocedures, is complete before it is released for use through other objects. Releasing an object for \nuse usually means making some other object refer to it: placing it in a list, registering a handler that \nuses it, etc. In general, once an object is connected to otherheap objects,it canbe touchedby manydifferent \npiecesof code. Thus, the object s initialization phase usually ends when it is pointed to by some heap \nobject. (In Java, all objects are allocated on the heap; only references to objects and primitive types \nsuch as int may be stored in stack variables.) We use a .ow and context sensitive analysis to track the \nreads and writesofall pointervariablesandheap object .elds.Wekeep track of the identity of each newly \ncreated object accurately during its initialization phase. We accurately follow how its references are \nassigned to local variables and passed as input parameters or return values. However, once the object \nis stored into some heap reference,itis assumedtoexitits initialization phase.We abstract its identity \naway and represent it with a special lost object. Any write to a .eld of this special object would render \nthe .eld not stationary. Becausewedonothavetokeeptrackofthe pointeesin the .elds of heap objects, the \nalgorithm converges quickly. 1.5 Experimental Results We have implemented the algorithms presented in \nthis paper to au\u00adtomatically infer .nal .elds and stationary .elds in Java programs. Wehaveapplied the \nalgorithms to 19 real-world Javaprograms and analyzed the results.To helpvalidate our static analysis \nalgorithm, we have also developed a dynamic analysis that records, for each .eld, if a write follows \na read of the same location. Clearly, no such pairs should ever be found for anystationary .elds identi.ed \nbyour algorithm.Wehavefoundthissanitychecktobehelpfulin providing con.dence that the algorithm and the \nimplementation are correct. In addition, we also record the number of times stationary .elds are read \nso as to assess if these .elds are important in the execution of a program. 1.6 Contributions Thekeycontributionsof \nthis paper are: The concept of stationary .elds, a generalization of Java s final that captures a wider \nrange of unchanging .elds, pri\u00admarilyby relaxing the requirements on initialization.  An ef.cient interprocedural \nalgorithm for .nding stationary .elds in Java programs.  Empirical results on the number of inferred \n.nal and stationary .elds across 19 real-world Java programs. In total, our algo\u00adrithm analyzed 88292 \nclasses and 620884 methods.We found that stationary .elds are widely present in real-world Java pro\u00adgrams \nand more common than final .elds: 44 59% vs. 11 17%. The experiments also address quantitatively how \nmuch eachdifference between the de.nitionsof stationary and final  contributes to the prevalence of \nstationary .elds, and show that inferring final .elds is valuable in its own right. Dynamic results showing \nthat stationary .elds are an important part of the runtime behavior of programs.  1.7 Paper Organization \nThe remainder of this paper is organized as follows.We show an algorithm for inferring final .eldsin \nSection2and thengiveour algorithm for .nding stationary .elds (Section 3). In Section4 we present our \nexperiences applying our algorithm to Java programs. We brie.y discuss relatedworkin Section5and concludein \nSec\u00adtion 6. 2. Final Fields This section describes the algorithm used by the Java compiler to verify \nthe legality of code that includes final instance .elds.We then progress to how we might infer final \n.elds. 2.1 Verifying Final Fields The Java Language Speci.cation provides an algorithm that is used by \na Java compiler to verify that programs that declare final .elds do not misuse them. Without loss of \ngenerality, let us just consider the more complex case where the .nal instance .eld is not initialized \nin the declaration in the following. Intuitively, a .nal .eld is one that is assigned exactly once dur\u00adinganynormalexecutionofthe \nconstructorofthe class declaringit, and never assigned elsewhere. (There is no requirement on the as\u00adsignment \nof a .nal .eld should the constructor terminate abruptly, thatis,by throwinganexception.)However, sinceitis \nundecidable to determine all the possible executed paths statically, the de.ni\u00adtion of a .nal .eld is \nspeci.ed by the veri.cation technique used, as outlined below. Let f be a .nal .eld in class c. 1. There \nis an error if anyof the methods that are not constructors of c contain an assignment to .eld f. Note \nthat constructors of classes derived from c do not count as constructors of c. 2. Perform a data .ow \nanalysis to determine if the .eld f is de.nitely assigned, de.nitely unassigned, or neither, at each \nprogram point.  Field f is de.nitely unassigned at the entry of the construc\u00adtor.  Executing an assignment \nthis.f= or f= , provided there is no local variable f, leaves .eld f de.nitely assigned.  Ata control-.owjoin \npoint, f is de.nitely assigned or unas\u00adsigned, respectively, iff it is de.nitely assigned or unas\u00adsigned, \nrespectively,on both incoming branches. Otherwise, f is considered to be neither.  No other statements \nalter whether f is de.nitely assigned or de.nitely unassigned.  3. Report an error if:  f is not de.nitely \nassigned at the normal exit of the con\u00adstructor.  f is not de.nitely unassigned immediately prior to \nan as\u00adsignment this.f= or f= .  f is not de.nitely assigned immediately prior to a use of this.f or \nf .  the constructor assigns to f through somevariable other than this, e.g. with other.f= .   class \nButton { private Window parent; void setParent(Window parent) { this.parent = parent; } void destroy() \n{ parent.removeChild(this); } void onClick() { parent.closeWindow(); } } Button b = ButtonFactory.newButton(); \nb.setParent(mainWindow); mainWindow.addChild(b); Figure 1. Code fragment from and using button object \nshowing stationary .elds. Notice that the legality of code that uses final can be veri.ed by examining \na single method at a time. This property of final allows it to .t within Java s compilation and loadingprocess. \n 2.2 Inferring Final The algorithm for verifying final can also be used to infer if a program uses a \n.eld like it is .nal, assuming all the code to be executedisavailable.We simply assume thata .eldis .nal, \nand execute the procedure for verifying a .nal .eld. If no errors are produced, the .eld may safely be \ndeclared final,given all thecode we have at hand. If we do this for all .elds, the result is a superset \nof .elds that are declared .nal, given that the input code does not contain errors. 3. Stationary Fields \nWehave previously introduced stationary .elds.We will nextgive some intuition on some kinds of stationary \n.elds we might expect to .nd in program, and then describe our algorithm for .nding stationary .elds. \n3.1 Stationary and Nonstationary Fields Consider the code fragment in Figure 1, which might appear in \na GUI-based program.Assumethatthisisonlyafragmentofourbut\u00adton class,but that none of the other methods \nmodify .eld parent. Thebutton s parent .eld shows a common type of stationary .eld: it encodesthe object \ns positionina hierarchyin whichobjectsmay be created or destroyed,butin which they never move. Thisexam\u00adple \nalsoshowsthe useofafactory method,a common motivation for initialization outside the constructor. Thefactory \nmethod itself calls the constructor for Button, so we cannot provide arguments. The example also shows \nwhy stationary .elds are useful for rea\u00adsoning about programs:weknowthatthebuttonisalways removed from \nthe window to which it is added because the parent .eld is stationary. Another common case of stationary \n.elds occurs when an object is created as a composite of smaller objects. Some examples of .elds we would \nexpect to be nonstationary include those encoding mutable current state of an object. For example, the \ncurrent position of an iterator changes repeatedly, as does the current state of a pattern matcher such \nas a tokenizer. Another example is that of a role (Kuncak et al. 2002), where the state of an object \nis captured by the existence of a reference from some other object. Changing roles are encoded by nonstationary \n.elds. 3.2 Algorithm Overview Our algorithmfor inferring stationary reads acceptsaJavaprogram as input \nand outputs a set of stationary .elds in that program. As with the de.nition of .nal .elds, the algorithm \nis subject to the same caveats respecting re.ection and native methods. For stationary .elds,programmers \ngenerally just read the ini\u00adtialization code and assume that the .eld is not changed in the rest of the \nprogram because theyunderstand the meaning of the .eld. (Note that there may be errors in the program \nthat violate this as\u00adsumption.) Likethe programmer,our algorithm tracks the reads and writes to each \n.eld carefully during initialization. But unlike the programmer, who instinctively knows which .elds \nare stationary, our algorithm needs to analyze if a .eld is written into after initial\u00adization before \nit can declare the .eld to be stationary. Our algorithm makes the simplifying assumption that an ob\u00adject \ns stationary .elds are initialized before its reference is stored into any objects.We say that an objectis \nlost once some other ob\u00adject points to it. Thus, a .eld f is stationary if 1. all the reads of .eld f \nin anyobject before it is lost occur after all the writes, and 2. there are no writes to .eld f upon \nanylost object.  With this assumption, we can derive a relatively ef.cient sta\u00adtionary .eld analysis. \nOur algorithm uses a hybrid approach to modeling objects. The algorithm tracks aliasesprecisely for all \nob\u00adjects until theyare lost;it models all lost objects coarselyby repre\u00adsenting them with a special object \ndenoted .. Conversely, all .eld dereferences are modeled as yielding the . object. Our algorithm is fast \nbecause tracking pointeesinheap objectsiswhatmakes pointer alias analysis expensive. Our analysis is \na .ow-sensitive and context-sensitive interpro\u00adcedural summary-based algorithm. It computes a .xedpoint \nthat summarizes how each method may lose objects and render .elds nonstationaryin termsofitsinput parametersand \nreturnvalue.The result of the entire program is given by the summary computed for the entry methodof \nthe whole program.We track all the input and return parameters accurately across method invocations, \nand the as\u00adsignments of parameters and local variables .ow-sensitively. Newly created objects are given \nlocal names preserving the context-sensitivity to the location of their creation. We rename newly created \nobjects that have not been lost, and therefore have no aliases, as they are returned by methods. By giving \nsuch an object the name of the method that most recently returned it, we can distinguish between objects \ncreated at the same line in the program, if the call stack to that spot is different. This precision \nis important for analyzingfactory methods. Usingonly local names alsokeeps the set of potential pointees \nsmall, speeding the computation. 3.3 Program Representation While our algorithm is de.ned for the full \nJava programming lan\u00adguage, for the sake of simplicity, we present the analysis over the following simpli.ed \nlanguage. There is a set of methods m . M. Methods have a set of local variables x, y . V . There is \nalso a set f . F of object .elds, which are accessed using syntax of the form v.f. The language has statements \ns . ST of the following forms: an assign statement x = y  an object creation statement x = new()  \na load statement x = y.f  a store statement x.f = f  a seq statement s1; s2  an if statement if ~ \nthen s1 else s2  a while statement while ~ do s  a method statement m(x1,...,xi){s; return y}  an \ninvoke statement x = m(y1,...,yi)  We use the notation ~ as a placeholder for the branch and loop conditions, \nwhich are irrelevant to the analysis. 3.4 Effect of Each Method Theinputto our algorithmisaJava programandthemain \nfunction to be invoked, and the output of the algorithm is a set of stationary .elds.The .xpoint computationkeeps \ntrackofallthe nonstationary .elds foundsofarinaset called S;the complement of S at the end \u00af\u00af of the \nalgorithm represents the result of the algorithm. Our algorithm uses class hierarchyanalysis (CHA) to \ncompute the possible call targets at each invocation (Dean et al. 1995). It assumes that the target of \na call site may be anymethod consistent with the method being called and the type of the reference through \nwhich the method is invoked.We include the class initializers of used classes as if theyoccured at the \nstart of the main function. The analysis of each method m operates on the following set of abstract objects \no . O: method input parameters A = {a1,a2,...}. The summary is computed parametrically with respect \nto the input parameters.  allocation-site objects. This is the set of objects allocated by m and named \nby the allocation site. These objects are not aliased at the time of creation.  call-site objects. This \nis the set of objects representing objects created by m s callees and are named by the call site.  the \n. object, used as a placeholder for untracked objects.  A method m and its callees may produce the following \nside effects that affect the computation of stationary .elds: generateasetof nonstationary.elds,whichareaddedtotheset \nof nonstationary .elds found sofar S\u00af.  lose a set of input objects, Lm . A.  write to a set of .elds \nfor each input parameter, Wm.  read a set of .elds for each input parameter, Em.  return a possible \nset of objects. It may  return some lost object or input parameters. These are rep\u00adresentedby the set \nRm. return some object created by m or its callees that has not been lost. In addition, it may have read \na set of .elds Dm from the returned object, before it is returned.For the sake of simplicity, and without \nloss of precision, we assume that a method always returns a new object that has not yet been lost. That \nis, a fresh call-site object is always created to represent such an object where m is invoked. generate \na set of alias conditions Cm of the form (ai,aj ,f), indicating that f is nonstationary if arguments \nai and aj can be the same object. 3.5 Effect of Each Statement To compute the effect ofeach method, \nthe algorithm uses a .ow\u00adsensitive analysis statement by statement to track where objects become lost, \nand the pointer aliases and reads of objects before they are lost. Thus, besides computing the effect \nof each statement on the terms introduced above for each method summary, the analysis keeps track of \nthe following terms .ow-sensitively,before and after every statement: P : a set of points-to relations \n(x, o) indicating that local vari\u00adable x may point to object o.  U: untracked objects, objects that \nare lost in this method or its callees.  Q: a set ofobject .elds o.f indicating that .eld f of object \no may have been read previously.   3.6 Inference Rules The properties of the solution are given by \ninference rules in Fig\u00adure 2. The notation P [x . B] indicates P with all points-to re\u00adlations involving \nx removed, and relations added for x pointing to each element of B: P [x . B] = {(y, o)|(y, o). P . x \n= y} . {(x, o)|o . B} This notation is used to discard the current contents of a variable and insert \nnew ones, that is, to destructively update the points-to set of a variable. The inference rules relate \nthe points-to relations, lost objects, and reads prior toa statement to those after it.Forexample, rule \nLOAD, which reads: P ' = P [x . {.}] Q' = Q .{o.f|(y, o). P } '' m, P, U, Q f x = y.f . P ,U,Q says that \nx = y.f, when executed within method m with prior points-to relations P , untracked objects U, and prior \nreads Q, resultsinpoints-to relations P ' , unchanged untracked objects, and prior reads Q' ;P ' is P \nmodi.ed such that x points only to .;and Q' is the union of Q' with o.f for every object to which y may \npoint. Analysis proceeds from a main function: our .nal conclusion is f main(x1,...){...}. The inference \nrules provide the following: Following an allocationx = new(), x points to a fresh object that represents \nall objects created by any execution of that allocation statement(NEW).  Following an assignmentx = \ny, x points to all objects that y pointedto; nothingislostorread(ASSIGN).  After a load x = y.f, x points \nto the lost object ., which is used in place of all objects that are fetched from the heap. Field f has \nbeen read on all objects thatymaypoint to(LOAD).  After a store x.f = y, objects pointed to by y are \nlost. If x pointed to anylost object, then f is nonstationary. If x points to an object passed as a parameter \nof m, then m writes .eld f of that parameter. If the store overwrites a previous read, the .eld is nonstationary.Ifthe \nstoreistoaparameter,andthe same .eld of some other parameter has previously been read, the store will \noverwrite the read if the two parameters alias; record this alias conditionsothatthe callermaycheckit(STORE). \n In a sequence of statements, s1; s2, the points-to relations after s1 are those before s2;likewise \nfor the lost objects and previous reads(SEQ).  Anything that may be lost after either branch of an if \n... then ... else ... statement is lost after the statement; any points\u00adto relation possible after either \nbranch is possible after the statement; likewise with prior reads(IF).  The points-to set, lost objects, \nand prior reads at the exit of a loop must be a .xed point under the body of the loop, and the .xed point \nmust include all points-to relations, lost objects, and prior readsattheentryoftheloop(WHILE).  All \nsubstatements of compound statements execute within the same method as the compound statement(SEQ,IF,WHILE). \n (NEW) ' P = P [x . \u00df] \u00df fresh m, P, U, Q f x = new() . P ' , U, Q (ASSIGN) P ' = P [x .{o|(y, o). P \n}] ' m, P, U, Q f x = y . P ,U,Q (LOAD) P ' = P [x . {.}] Q' = Q .{o.f|(y, o). P } '' m, P, U, Q f x \n= y.f . P ,U,Q (STORE) Wm .{a.f|a . A .(x, a). P } U' = U .{o|(y, o). P } `\u00b4 \u00af (.o)((x, o). P . o . \nU) . f . S `\u00b4 \u00af (.o)(o.f . Q .(y, o). P ) . f . S Cm . {(ai,aj ,f)|i = j . ai . A . ai.f . Q .(y, aj \n). P } ' m, P, U, Q f x.f = y . P,U,Q (SEQ) m, P, U, Q f s1 . P ' ,U' ,Q' '' '''''' m,P ,U,Q' f s2 . \nP ,U,Q '' '''' m, P, U, Q f s1; s2 . P ,U,Q (IF) m, P, U, Q f s1 . P1,U1,Q1 m, P, U, Q f s2 . P2,U2,Q2 \n' '' U= U1 . U2 P = P1 . P2 Q= Q1 . Q2 ''' m, P, U, Q f if ~ then s1 else s2 . P ,U,Q (WHILE) '' ''' \nm,P ,U,Q' f s . P ,U,Q''' P . PU. UQ. Q ''' m, P, U, Q f while ~ do s . P ,U,Q (METHOD) Rm .{o|(y, o). \nP ' . o . A} (.o)((y, o). U ' ) . (.. Rm) Lm = {a|a . U' . a . A} Dm = {f|(.o)(o.f . Q' .(y, o). P ' \n)} Em = {a.f|a . A . a.f . Q' } P = {(x1,a1) ,..., (xi,ai)} ''' U = {.} Q = \u00d8 m, P, U, Q f s . P ,U,Qf \nm(x1,...,xi){s; return y} (INVOKE) `\u00b4 \u00af ai.f . Wn . (.o)((yi,o). P . o . U' )) . f . S Wm .{ai.f|ai . \nA . (.j)(aj .f . Wn .(yj ,ai). P } P ' = P [x . B] B . (.i)(ai . Rn .(yi,o). P )} \u00df . B\u00df fresh .. Rn \n... B U' = U .{o|(.i)(aa . Ln .(yi,o). P )} Q' . QQ' .{\u00df.f|f . Dn} Q' .{o.f|(.i)(ai.f . En .(yi,o). P \n} (.i, j, o)((ai,aj ,f). Cn `\u00b4 \u00af .(yi,o). P .(yj ,o). P ) . f . S Cm . {(ai,aj ,f)|i = j . ai.f . Q. \n(.k)(ak.f . Wn .(yk,aj ). P )}Cm . {(ai,aj ,f)|i = j .(.k, l)((ak,al,f). Cn .(yk,ai). P .(yl,aj ). P \n)}f n(z1,z2,...){...} ''' m, P, U, Q f x = n(y1,y2,...) . P ,U,Q \u00af Figure 2. Inference rules for .nding \nnonstationary .elds S. The statements inside a method de.nition are executed in the context of that \nmethod; when they begin only . is lost, no .elds have been read, and each formal parameter points to \nthe corresponding placeholder object. Any parameter object that is lost at the end of the method is lost \nby the method. If a parameterobjectispointedtobythe returnvariableattheendof the method, the function \nreturns that parameter. Anyparameter .eld that has been read at the end of the method is lost by the \nmethod. Likewise, if a .eld of some object has been read, and thatobjectispointedtobythe returnvariable,thenthat.eldhas \nbeen read from the object returned by the method. If the return variable points to anylost object, the \nfunction also returns the lost object(METHOD).  RuleINVOKE isthe most complicated,asinvokinga function \nhas effects equivalent to some set of loads, stores, assignments, and allocations. Let x = n(y1,...) \nbe the invocation. If actual parameter i may refer to an object that is lost after the invo\u00adcation, and \nn writes f of its ith argument, then f is assumed to be nonstationary, because the write in n is to a \nlost object. This condition refers to the lost objects after the invocation be\u00adcause the summary fora \nmethod contains no information on the relative ordering of the writes and objects lost. The rule must \nconservatively assume that some objects are lost, and then the writes occur. If the called function n \nwrites its ith argument, and the ith actual parameter may point to parameter j of the calling method \nm, then the calling method writes .eld f of argument j;writes are propagated outward. The properties \nof invocations just given are parallel to those for stores. Likewise, the .elds writtenbythe calleemayoverwriteprevious \nreads,or imply that a .eld will be overwritten if two parameters of the caller alias, just as for a store. \n After the invocation, x points to anything n may have returned. If n may return parameter i, x may \npoint to anything parameter i pointed to; x may also point to . if n returns that. It is also assumed \nthat any function may return some newly created, not lost object, so x pointstoafresh placeholder object \njust as with an allocation.In thisfashion, wekeep the object names for allocation sites and call sites \ninternal to a method. The effect is to substitute the caller s call-site name for the callee s internal \nname. If n loses parameter i,thenanything pointedtobytheargument i is lost after the invocation of n. \nAny .elds of the returned object that were read by the callee havebeen read on the placeholder return \nobject. If n reads .elds fromaparameter,thenthose .eldshavebeenreadonanyobject pointed to by the corresponding \nargument.  3.7 Solution Procedure We seek the least solution consistent with the rules given above: \n\u00af we wish S as to be small as possible, and likewise for all the sets that comprise the method summaries, \nand P , U, and Q for each statement. The algorithm is ef.cient because the side effects of each method \nare represented in terms of its parameters, so no infor\u00admation needs to .ow from the caller to the callee. \nFurthermore, each method can only refer to the placeholder objects represent\u00ading the input parameters \nand the newly created objects returned by its callees.All indirect references are modeled simply as the \nlost object .. Figure3 shows the pseudocode for our algorithm. The proce\u00addure is as follows: 1. Compute \na call graph for the input program rooted at the entry function using CHA. procedure .ndStationaryFields(main): \ncallgraph = computeCHACallgraph(main) \u00af S := \u00d8 for eachmethod m . callgraph: Wm := \u00d8; Lm := \u00d8; Rm := \n\u00d8 Cm := \u00d8; Dm := \u00d8; Em := \u00d8 for eachscc . topologicalSort(.ndSCCs(callgraph)) repeat for eachmethod m \n. scc: summarizeMethod(m) until Wm, Rm, Lm, Cm, Dm, Em stabilize for all m . scc procedure summarizeMethod(m): \nfor eachp . programPoints(m): Up := \u00d8; Pp := \u00d8;Qp := \u00d8 visitRule(methodRule(m)) repeat for eachs . statements(m): \nvisitRule(statementRule(s)) until Up, Pp, Qp stabilize for all p . programPoints(m) visitRule(methodRule(m)) \nprocedure visitRule(r): add minimum items to sets referenced by r so that r holds Figure 3. Pseudocode \nfor our algorithm for identifying stationary .elds. 2. Begin by initializing sets we aim to compute to \nthe empty set: we have found no .elds that are written lost, and we have not discovered the side effects \nof anymethod. 3. Find strongly-connected components within the call graph and sort them in topological \norder. 4. Summarize all methods within each SCC, starting with leaf SCCs, and ending with the SCC containing \nmain. 5. Nontrivial strongly connected components contain recursive cycles; the summaries methods within \nthese SCCs depend on each other. Within such an SCC, iterate until a .xed point is reached for the summaries \nof all methods it contains.  The procedure to summarize a method m is: 1. Maintain a value for P , U, \nand Q at each program point; initialize these to the empty set. 2. Set P , U, and Q prior to the .rst \nstatement in the method in accordance with the METHOD rule. 3. Iterate over all statements in m until \na .xed point for P and U at all points is reached. 4. When visiting each statement, add the minimum \nitems to P , U, and Q following the statement to satisfy the appropriate rule. (Also add items to the \nsummary for m in Lm, or note  \u00af the discovery of a lost write in S, when appropriate.) 5. Update the \nsummary for m in accordance with the METHOD rule. The above procedure constitutes a particular order \nfor visiting the inference rules. We could of course iterate over them in any order until they converge. \nBy using this order, we may recompute the P , U, and Q for the program points inside a method each time \nwe visit it. This reduces the space required for the algorithm, by eliminating the need to store this \ninformation for every program point simultaneously. Our implementation incorporates an important optimization: \nonce a .eld f is assumed not to be stationary (known to be con\u00adtained in S), our implementation ignores \nside effects with respect \u00af to f in W , C, D, and E for every method. Information about such side effects \nhas no further use; suppressing their storagekeeps the method summaries small. 4. Experimental Results \nIn this section, we present results of applying our algorithms to infer .nal and stationary .elds in \nreal-world Java programs. 4.1 Methodology We applied our algorithms to a selection of real-world programs \nin order togauge its effectiveness and discover the prevalence of stationary .elds. We implemented our \nanalysis using the Joeq compiler in\u00adfrastructure (Whaley 2003). Experiments were conducted on an Opteron \n150 (2.4 GHz) with Sun JDK 1.5.0 03 running on CentOS 4. We selected a group of benchmarks from the most-downloaded \nJava programs on Sourceforge, selecting only those that would compile as standalone programs. (The version \nwe use in each case is what was at the head the source code repository as of 15 November 2003.) These \nare all real-world programs with thousands of users. In addition, we include the SPEC JVM98 benchmarks \nbecause these benchmarks come with input sets and thus make dynamic analysis possible.Weexclude the benchmark \ncheckfrom the SPEC JVM98 benchmarks, which is a JVM testsuite. Figure4lists the programs we used as benchmarks, \nalongwith a description, statistics about their size, and the runtime of our analysis. The .gure gives \nthe number of classes in the call graph for each program; the numberof methods de.nedby those classes; \nand the number of methods actually included in the call graph for the program. These numbers include \nlibrary methods andclasses. Manyof these are sizeable programs. Gruntspud, the largest, uses over four \nthousand classes, approximately half of which are in the application itself rather than the Java libraries. \nThe number of methods in the call graph is typically about two-thirds of those de.ned by the included \nclasses. This indicates that many applications that use classes, especially from libraries, use only \na portion of the functionality that those classes offer. The number of methods in the call graph appears \ntofall into two categories: less than 17,000 methods, or more than 32,000 methods. This is because the \ncall graph for the Java libraries includes some very large strongly connected components. The smaller \ncall graphs exclude one of these very large components. The presence of this large component has a strong \neffect on the analysis time. Those applications that do not include it are com\u00adpleted in under 15 minutes; \nthose that do include it generally take more than an hour. The algorithm must iterate over all the methods \nin each SCC until a .xed point is reached for their summaries; in these cases one SCC includes nearly \nhalf the program. Even on the largest programs, analysis is complete in under two hours, an ac\u00adceptable \namount of time for yielding whole-program information. Our implementationis not highly optimized.Itwouldbe \npossibleto apply techniques such as precomputation of results for the system library to minimize the \nruntime. 4.2 Static Analysis of Stationary and Final Fields Figures5,6,and7showthe resultsof applying \nour algorithmto our benchmarks. Fields are classi.ed either stationary or nonsta\u00adtionary. Only instance \n.elds from which the methods in the call graph include at least one load are included. Figures5 and7 \nin\u00adcludeall packagesexcept sun.*, whichcontainsprimarily JVM in\u00adternals, for .elds of reference and primitive \ntype respectively. The resultsfor reference-typed .eldsin Figure6alsoexcludethe core Javalibraries in \npackages java.* and javax.* and should generally represent the application itself and its libraries. \nThe results show that stationary .elds are prevalent in Java pro\u00adgrams: for reference-typed .elds, the \nstationary percentage ranges from44to59inthe programs,whentheJavalibraries are included. EvenwhentheJava \nlibrariesareexcluded, morethan30%of .elds are stationaryinevery application.In appliationportionof someof \nthe smaller programs, more than 60% of the .elds are stationary. For .elds that hold primitive types, \nstationary .elds are modestly less common,but are still more than 30%in allthe benchmarks. It is surprisingthat \nabout half of all the .elds in each of these Javaprograms program are stationary. This suggests that \nsigni.cant portions of Javaprograms are functional in nature, where data are initialized and not changed \nlater.Obviously,garbage collection plays an important role in encouraging this style of programming. \n4.2.1 Comparing Stationary with Final Fields We also analyzed all the .elds of the programs to determine \nif they were or could be declared .nal, using the algorithm given in Section 2.2. In the .gures, .elds \nare classi.ed as one of: declared as .nal;  undeclared .nal(uf), .elds that are not declared .nalbut \nfor whichsuchadeclarationwouldbelegal consideringallthecode contained in each program and its libraries; \n call-graph .nal(cgf),.elds that are not .nal or undeclared .nal, but that could legally be declared \n.nal when considering only the code within the call graph we used for each program; or  not .nal(nf). \n There are many fewer declared final .elds than stationary .elds: less than 20% of the .elds are declared \n.nal in both the full programs as well as just the application codes. The results suggest that automatic \ninference of .nal .elds is useful, as many.elds are used like they are .nalbut are not declared as such. \nNonetheless, almost 20% of the .elds in full programs are found to be stationary yet cannot be inferred \nto be .nal. This means that the relaxed de.nition of initialization of stationary .elds is signi.cant. \n  4.3 Stationary Non.nal Fields The table in Figure 8 quanti.es the reasons why stationary is stronger \nthan .nal. The three main reasons are: uninitialized, potentially uninitialized at the end of a construc\u00adtor; \n multiply initialized, potentially multiply initialized within the constructor; or  outside constructor, \nassigned outside the constructor of the class de.ning that .eld. Notice that .elds can belong to more \nthan one category, so the columns sum to more than 100%. The results show that potential lack of initialization \nis the most common reason that .elds cannot be declared .nal, appearing for a majority of .elds. Assignment \noutside the constructor is next most common, occurring for around half of .elds. Multiple assignment \nin the constructor is not com\u00admon,but does occurina handfulof placesin all programs. In every program, \nthe number of uninitialized .elds is strictly greater than the number of .elds assigned outside the constructor. \nThis might be surprising; after all, if we don t assign the .eld inside the constructor, we would certainly \nexpect an assignment somewhere else. Bear in mind, however,that this result only reports that a .eld \nis potentially unassigned. Constructors may leave .elds project description classes methods methods \nin callgraph analysis time (m) azureus bittorrent client 1710 16243 11576 8 columba graphical email client \n4447 37400 30494 76 .ndbugs .nd bugs in Java programs 1929 16804 11511 13 freetts speech synthesis system \n3614 32291 25551 62 gruntspud graphical CVS client 4479 37258 31245 78 jbidwatcher auction site tracking \ntool 3816 33714 27375 81 jboss j2ee application server 3687 33045 26052 65 jedit programmer s text editor \n4182 35856 30280 92 jetty HTTP server and servlet container 1450 13001 9171 7 jgraph graph objects and \nalgorithms 3653 33090 26322 75 joone neural net framework 3646 32937 25914 71 jxplorer LDAP browser 4053 \n35459 29087 106 l2j game server 1601 14170 10008 7 megamek networked Battletech game 3983 36130 30105 \n79 nfcchat distributed chat client 3610 32349 25565 60 openwfe work.ow engine 3669 33048 25937 62 pmd \nJava program analyzer 1599 13680 10228 8 spec/compress modi.ed Lev-Zimpel compression 3613 32314 25608 \n61 spec/db in-memory database 3605 32321 25613 62 spec/jack parser generator 3654 32405 25865 62 spec/javac \nJava compiler 3769 33256 26718 66 spec/jess expert shell system 3749 32772 26170 63 spec/mpegaudio decompress \nMP3 audio 3645 32508 25823 65 spec/mtrt ray tracer 3627 32406 25734 61 sshtools ssh terminal 3830 33827 \n26809 77 umldot make UML class diagrams from Java code 3672 32542 26123 74 Figure 4. Benchmarks used \nin our experiments. total %stationary %nonstationary % % project .elds .nal uf cgf nf total .nal uf cgf \nnf total .nal sta. azureus 1601 15 16 2 17 50 1 4 0 44 50 17 50 columba 4541 10 17 3 17 46 1 7 0 45 54 \n11 46 .ndbugs 1548 12 21 6 20 58 1 3 0 38 42 13 58 freetts 3289 12 17 5 17 51 1 3 0 44 49 13 51 gruntspud \n4928 13 14 3 14 45 2 8 0 46 55 15 45 jbidwatcher 3601 11 17 3 16 48 1 4 0 47 52 12 48 jboss 3377 12 17 \n5 17 51 1 3 0 44 49 13 51 jedit 4511 13 16 3 14 46 1 7 0 45 54 15 46 jetty 1087 14 18 2 21 56 1 3 0 40 \n44 15 56 jgraph 3483 12 17 4 17 50 1 3 0 46 50 13 50 joone 3368 11 17 5 17 50 1 3 0 45 50 13 50 jxplorer \n4334 13 14 3 15 45 1 7 0 46 55 14 45 l2j 1219 12 23 3 21 59 2 3 0 36 41 14 59 megamek 4679 9 15 3 16 \n44 1 11 0 44 56 11 44 nfcchat 3300 12 18 5 17 51 1 3 0 44 49 13 51 openwfe 3375 12 18 5 17 51 1 3 0 44 \n49 13 51 pmd 1160 14 19 2 22 57 1 3 0 39 43 14 57 spec/compress 3290 12 17 4 17 51 1 3 0 45 49 13 51 \nspec/db 3280 12 17 4 17 51 1 3 0 45 49 13 51 spec/jack 3336 12 17 4 17 51 1 3 0 44 49 13 51 spec/javac \n3455 11 18 4 16 50 1 3 0 45 50 12 50 spec/jess 3347 12 18 4 17 51 1 3 0 44 49 13 51 spec/mpegaudio 3368 \n11 18 4 17 51 1 3 0 44 49 13 51 spec/mtrt 3314 12 18 4 17 51 1 3 0 45 49 13 51 sshtools 3616 11 17 4 \n20 53 1 3 0 43 47 12 53 umldot 3492 12 16 4 17 49 2 3 0 46 51 14 49 Figure 5. Percentages of reference-typed \n.elds by stationary and .nal status, excluding packages sun.*.All percentages are of total .elds. (.nal:declared \n.nal;uf:undeclared .nal;cgf:.nal in program s call graph;nf:cannot be inferred .nal; see Section 4.2.1 \nfor de.nitions.) total %stationary %nonstationary % % project .elds .nal uf cgf nf total .nal uf cgf \nnf total .nal sta. azureus 533 18 13 1 7 40 1 7 0 52 60 20 40 columba 1313 6 18 2 14 41 1 14 1 44 59 \n7 41 .ndbugs 487 7 29 14 18 67 1 3 0 29 33 8 67 freetts 186 4 22 6 15 47 1 1 0 51 53 5 47 gruntspud 1692 \n16 9 1 9 36 2 16 0 45 64 19 36 jbidwatcher 499 4 16 3 10 33 1 10 0 56 67 5 33 jboss 268 9 24 8 16 57 \n2 1 0 41 43 11 57 jedit 1401 16 15 1 7 39 1 15 0 44 61 18 39 jetty 43 7 37 0 21 65 0 5 0 30 35 7 65 jgraph \n400 7 18 4 12 42 0 3 0 55 58 8 42 joone 289 3 17 11 13 45 1 3 0 51 55 4 45 jxplorer 1100 14 7 1 8 30 \n1 20 0 49 70 16 30 l2j 157 2 60 8 17 87 0 3 0 10 13 2 87 megamek 1586 4 13 1 14 31 1 26 0 42 69 5 31 \nnfcchat 221 4 28 7 13 52 1 1 0 46 48 5 52 openwfe 286 4 22 10 14 50 1 3 0 45 50 5 50 pmd 116 6 33 1 25 \n65 0 8 0 28 35 6 65 spec/compress 210 4 23 6 14 47 1 3 0 49 53 5 47 spec/db 200 4 24 6 14 48 1 2 0 50 \n52 5 48 spec/jack 256 3 23 5 18 50 1 4 0 46 50 4 50 spec/javac 375 2 23 3 10 39 1 5 2 53 61 3 39 spec/jess \n266 3 24 5 16 47 1 6 0 45 53 4 47 spec/mpegaudio 288 3 32 5 17 56 1 2 0 41 44 3 56 spec/mtrt 234 3 24 \n5 15 48 1 3 0 48 52 4 48 sshtools 529 4 23 7 33 67 0 2 0 31 33 4 67 umldot 402 14 11 3 9 37 4 2 0 57 \n63 18 37 Figure 6. Percentages of reference-typed .elds by stationary and .nal status, excluding packages \njava.*, javax.*, and sun.*. All percentages are of total .elds.(.nal: declared .nal; uf: undeclared .nal; \ncgf: .nal in program s call graph; nf: cannot be inferred .nal; see Section 4.2.1 for de.nitions.) total \n%stationary %nonstationary % % project .elds .nal uf cgf nf total .nal uf cgf nf total .nal sta. azureus \n1099 6 10 3 24 42 1 2 0 54 58 6 42 columba 2409 3 11 5 15 34 0 2 0 64 66 3 34 .ndbugs 803 6 11 8 19 45 \n1 2 0 52 55 7 45 freetts 2072 3 12 7 15 37 0 2 1 60 63 3 37 gruntspud 2437 3 11 4 17 35 0 2 1 62 65 3 \n35 jbidwatcher 2238 3 12 5 16 36 0 2 0 62 64 3 36 jboss 2095 3 12 7 16 37 0 2 1 60 63 3 37 jedit 2586 \n3 11 4 14 32 0 2 0 65 68 3 32 jetty 615 9 11 4 17 41 1 2 0 56 59 10 41 jgraph 2140 3 12 6 15 36 0 1 1 \n62 64 3 36 joone 2126 3 12 7 15 37 0 2 1 60 63 3 37 jxplorer 2251 3 11 4 16 34 0 2 0 64 66 3 34 l2j 891 \n6 20 11 17 55 1 1 0 43 45 7 55 megamek 2662 2 10 5 15 32 0 2 1 65 68 3 32 nfcchat 2072 3 12 7 15 37 0 \n2 1 60 63 3 37 openwfe 2098 3 12 7 15 37 0 2 1 60 63 3 37 pmd 665 8 11 4 18 42 1 2 0 55 58 9 42 spec/compress \n2098 3 12 7 15 37 0 2 1 61 63 3 37 spec/db 2082 3 12 7 15 37 0 2 1 61 63 3 37 spec/jack 2130 3 12 7 15 \n37 0 2 1 61 63 3 37 spec/javac 2154 3 12 7 15 36 0 2 1 61 64 3 36 spec/jess 2191 3 14 6 15 39 0 2 1 59 \n61 3 39 spec/mpegaudio 2144 3 12 7 15 36 0 1 1 62 64 3 36 spec/mtrt 2116 3 12 7 15 37 0 2 1 61 63 3 37 \nsshtools 2173 3 12 6 16 37 0 1 1 61 63 3 37 umldot 2088 3 12 6 16 36 0 2 1 62 64 3 36 Figure 7. Percentages \nof primitive-typed .elds by stationary and .nal status, excluding packages sun.*.All percentages are \nof total .elds. (.nal:declared .nal;uf:undeclared .nal;cgf:.nal in program s call graph;nf:cannot be \ninferred .nal; see Section 4.2.1 for de.nitions.) init. mult. project uninit. outside ctor. init. azureus \n88 42 3 columba 90 32 5 .ndbugs 87 46 3 freetts 90 33 5 gruntspud 92 36 5 jbidwatcher 90 33 6 jboss 90 \n33 6 jedit 92 31 5 jetty 87 42 3 jgraph 91 32 6 joone 91 33 5 jxplorer 90 33 6 l2j 88 433 megamek 89 \n34 6 nfcchat 90 32 5 openwfe 90 32 5 pmd 89 432 spec/compress 90 33 5 spec/db 90 33 5 spec/jack 90 34 \n5 spec/javac 90 33 5 spec/jess 90 33 5 spec/mpegaudio 90 32 5 spec/mtrt 90 33 5 sshtools 76 43 5 umldot \n90 32 6 Figure 8. Reasons whystationary .elds cannot be declared final. Percentages of stationary, non-.nal, \nreference-typed .elds. unassigned on some path, allowing them to retain their default null value. Also, \nit is possible for some constructors of a class to initialize a .eld while others do not.  4.4 Inferred \nFinal Fields Our results show that manyprograms seem to be missing opportu\u00adnities to declare .elds to \nbe .nal even including the Javalibraries, fewer than half the .elds that could be marked .nal are. There \nare several reasons whythere are so manyundeclared .\u00adnal .elds. First, our analysis only considers classes \nthat are usedby the program; there may be other classes inside these libraries that mutate these .elds. \nSecond, there may be public .elds for which legitimate client code could modify them. Third, the declaration \nof .nal could simply be missing. When we look at .nal in the application code itself, the percent\u00adage \nof declared .nal .elds is even lower. Indeed, some applica\u00adtions, suchas l2j, do not declare any .elds \nto be final!(The3.nal .eldsreportedforl2jarenotwithinthe applicationitself,butrather within the com.sun.management \npackage.) This is probably because thereisno feedback fromthe compilerwhena final declaration is missing, \nas it is compiling only a single class at a time. However, manyof these .elds areprivate, so the .elds \ncould notbe modi.ed outside the translation units. Java compilers might consider emit\u00adtingawarning whenaprivate \n.eld couldbe declared .nalbutis not,inthe sameveinthat someemitwarningsforprivate .eldsthat are never \nread within the body of the de.ning class. The number of callgraph .nal .elds suggests that manylibrary \nmethods that mutate some .elds are unused by applications. That is, even though a library de.nes an object \nas mutable, an applica\u00adtion treats it as .xed. It could also represent object con.guration parameters \nthat applications tend to leave in the default settings. The presence of call-graph-.nal .elds outside \nof the Java libraries indicates some dead code within applications,but also that appli\u00adcations are using \nonly portions of the (non-Java core) libraries that theyare packaged with. all .elds application only \nproject sta. semi-sta. sta. semi-sta. azureus 50 52 40 40 columba 46 48 41 42 .ndbugs 58 61 67 69 freetts \n51 53 47 49 gruntspud 45 46 36 37 jbidwatcher 48 49 33 36 jboss 51 53 57 59 jedit 46 48 39 40 jetty 56 \n59 65 72 jgraph 50 51 42 42 joone 50 52 45 48 jxplorer 45 47 30 33 l2j 59 62 87 89 megamek 44 45 31 32 \nnfcchat 51 53 52 53 openwfe 51 53 50 52 pmd 57 60 65 71 spec/compress 51 53 47 50 spec/db 51 53 48 52 \nspec/jack 51 53 50 55 spec/javac 50 52 39 44 spec/jess 51 52 47 50 spec/mpegaudio 51 53 56 57 spec/mtrt \n51 53 48 52 sshtools 53 55 67 68 umldot 49 50 37 38 Figure 9. Percentage of reference-typed .elds that \nare semi\u00adstationary. All .elds excludes sun.*; application only also ex\u00adcludes java.* and javax.*. 4.5 \nNonstationary Final Fields In general, we would expect most final .elds to be stationary as well. However, \nthere are a number of nonstationary .elds reported in the .nal, undeclared .nal, and call-graph .nal \ncategories, pri\u00admarily undeclared .nal. First, there is a category of .elds that are .nalbut that cannotbe \nshown stationaryby our analysis.Itis pos\u00adsible for a constructor to create a reference to this in another \nob\u00adject, or to pass this as an argument to a function that does so. Any .eld initialized after that point \nin the constructor is nonstationary. In our experience, a common reason is the creation of a object of \nnon-static inner class during construction. The inner class contains a reference to its outer class, \nand so the outer class is necessarily lost. For example, classes in the Java SWING library often cre\u00adate \nan inner class to use as an event handler. This implies that no .eld in a class derived from these classes \nis found to be stationary, because base class constructors execute before derived class con\u00adstructors. \nThe programs with signi.cant numbers of nonstationary, undeclared .nal .elds are all GUI programs. Second, \nbecause our algorithm is conservative, it is also possi\u00adble for an imprecision within it to report a \nstationary .eld as non\u00adstationary, even if no lost writes or overwritten reads are in fact possible. \nThe primary cause of this is the lack of relative ordering information between what is written and what \nis lost in the sum\u00admaries of methods. 4.6 Semi-Stationary Fields Stationary .elds are de.ned such that \nthey are read only after all the writes have been performed. Sometimes, a .eld may need to be read as \npart of the initalization. For example, a program may choosetowritetoa.eldonlyifithasnotpreviouslybeen \nassigned. This would require that the .eld be read .rst to check for nullness before the write operation. \nSuch an action would render the .eld nonstationaryby our de.nition. Even though reads during initalization \nmay access .elds before they stabilize, our algorithm can identify the reaching de.nitions for such reads \naccurately as long as the objects accessed have not been lost.Thus,we refertoa.eldas semi-stationary \nif all the reads of a .eld of an object either occur before the object is lost, or after all the writes \nto the .eld have taken place. Semi-stationary .elds are interesting because precise alias information \nis available for all their writes, and de.nitions reaching the read accesses are well identi.ed. Figure9compares \nthe fraction of .elds that are stationary and semi-stationary. The difference between the two is relatively \nsmall, never comprising more than 7% of total .elds. This suggests that the simpler de.nition of stationary \n.elds provides most of the bene.ts of our approach to track objects carefully before they are lost. We \nnote that if all objects of a certain class never escape into the heap,but are used and modi.ed locally, \nthen all the .elds in the class are considered semi-stationary.Forexample,in the SPEC program db, the \ntop level database object has this property. Its .elds are repeatedly changed,butitis only storedin localvariables. \n 4.7 ImplementationValidation withDynamic Analysis As a way of validating our implementation, we compared \nthe dy\u00adnamic behavior of the SPEC JVM98 programs with the results of our inference algorithm.We used \nbytecode rewriting to instru\u00adment the programs, recording all instance .eld reads and writes, and when \nheap references to objects were created.For ease of im\u00adplementation, we only instrumented the application \ncode, and not the Java libraries (speci.cally, we excluded classes in the java and sun packages.) This \nallowed the instrumentation to use the Java li\u00adbraries. Behaviorof nativemethodsand re.ectionwas not \ncaptured by bytecode instrumenation. In all cases where a .eld was overwritten at runtime, or where it \nwas written while after a heap reference existed, the static anal\u00adysis correctly identi.ed this possibility. \nWhile not exhaustive, the dynamic analysis serves as a substantial test suite, which our algo\u00adrithm passes. \n 4.8 Dynamic Analysis of Stationary and Final Fields To determine if stationary and .nal .elds are important \nto a pro\u00adgram s execution, we instrumented the SPEC JVM98 benchmarks programsto countthe numberoftimeseach \ninstance.eldwasread duringexecution. Figures10and11showthe results,for reference\u00adand primitive-typed \n.elds respectively. The dynamic numbers ex\u00adhibit morevariationthanthe static numbers, rangingfrom4to78% \nfor reference .elds. These numbers suggest that stationary .elds are accessed in real programs. Reads \nof .nal .elds are rare; reads of undeclared .nal .elds on the other hand are common, demon\u00adstrating thevalueof \ninferenceof .nal .elds.For .eldsof primitive type, most reads are directed at nonstationary .elds; this \nsuggests that .elds of reference and primitive types are used differently in programs.Forexample,itis \ncommonto createa data structure out of stationary reference .elds, and then the primitive .elds within \nthat structure are accessed and mutated. We also analyzed some of the more frequently used .elds to gain \na better understanding of how stationary and .nal .elds are used in practice. Among frequently accessed \nstationary .elds are such things as: the input stream of a scanner, the table for a hash table, as well \nas thehashcodeandkeyofatableentry, virtual this pointers(e.g. this$0 ) usedby inner classes, and inputbuffers. \n79% of the reference .eld accesses in mpegaudio are directed at stationary .elds that can be declared \n.nal,but are not declared as such in the program. The application mpegaudio is obfuscated so it is hard \nto tell what these .elds are exactly. However, they are of type array of array of .oat. From this and \nthe function of the program we may guess that these are statically allocated arrays. 36% of reference \n.elds in mtrt are to stationary but not .\u00adnal .elds. The main reason is that the initialization of an \nimpor\u00adtant .eld is performed outside the constructor, in a method called Initialize. This again shows \nthat it is important to relax the ini\u00adtialization constraints. Among nonstationary .elds, indexes are \nthe most common, such as intobuffers and other arrays andvectors. Also appearing as nonstationary .elds \nare reallocated structures, such as an input or vectorbufferthatmayneedtobe resized,oralazily generatedlist \nof database entries in sort order. In mtrt, 28% of the .eld reads are directedat nonstationary .eldsbut \ncanbe declaredas .nal .elds.In fact, these .elds are also stationary. Our algorithm cannot identify these \n.elds as such because of imprecision discussed in Section 4.5. For primitive-typed .elds, the only substantial \nreads of stationary, non-.nal .elds occur in jack; the .elds carry information about whetherabufferis \nread-only. 5. Related work We brie.y review some of the most directly relatedwork. We begin with previous \nexplorations of immutability in Java. Porat et al. (2000) presented an analysis that infers .nal .elds \nin Java; their implementation focused on static (class) .elds rather than instance .elds. Their analysis \noperated under an open-world assumption, limiting its ability to infer that non-private .elds were .nal. \nNonetheless, they found that static .elds not declared .nal could be inferred to be so. Pechtchanski \nand Sarkar (2002) used annotations about the immutability of Java .elds to enable opti\u00admizations; their \nimplementation used programmer-supplied anno\u00adtations, rather than inference. Salcianu and Rinard (2005) \nuse an analysis similarto oursto infer purityofJava methods.Fosteretal. (1999) presentedan inferenceoftype \nquali.ersforC,in whichthey discovered that manymore consts canbe usedinCprograms than are actually present; \nthis corroborates ourexperience that program\u00admers often neglect declarations of this kind. Several proposals \nhave been made for adding a read-only quali.er to Java, includingJAC(Kniesel and Theisen 2001), Uni\u00adverses \n(M\u00a8 uller and Poetzch-Heffter 2001), ModeJava (Skoglund and Wrigstad 2001), and Javari (Tschantz and \nErnst 2005). These all propose creating a quali.er to reference types; programs would be forbidden from \nusing a read-only reference to modify .elds. That is, with a read-only reference, the referenced object \ncannot be changed. This is orthogonal to final and stationary, which indicate that the quali.ed .eld \nmay not be altered to reference another ob-ject.This distinctionisalso presentinCandC++,wherethe const \nkeywordmay indicate eithera pointer must continuetopointtothe same object, or that it may not be used \nto mutate the object pointed to (Harbison and Steele 1987). Manyother languages include some method for \nindicating value immutability. The Ruby programming language (Thomas et al. 2005) includes the ability \nto freeze an object, after which no .eld of the object maybe altered.Enforcementis entirely dynamic; \nattemptsto mod\u00adify a frozen object result in an exception. Escape analyses commonly model unescaped objects \nin a more precise manner than escaped objects, similarly to how we track objects without heap references \nmore precisely (Choi et al. 1999; Whaleyand Rinard 1999). 6. Conclusions This paper introduces the notion \nof a stationary .eld, a .eld whose value never changes once the object containing the .eld is accessi\u00adble \nviaa heap reference.Wehavedeveloped anef.cient algorithm to identify stationary .elds. It was surprising \nthat this simple algo\u00ad total %stationary %nonstationary % % project reads .nal uf cgf nf total .nal \nuf cgf nf total .nal sta. spec/compress 1144M 0 33 0 13 46 0 38 0 16 54 0 46 spec/db 231M 14 0 0 0 14 \n0 22 0 64 86 14 14 spec/jack 47M 2 18 0 11 32 0 2 0 67 68 2 32 spec/javac 111M 1 6 0 17 23 0 1 0 75 77 \n1 23 spec/jess 104M 0 2 0 2 4 0 3 0 94 96 0 4 spec/mpegaudio 492M 0 79 0 6 85 0 0 0 15 15 0 85 spec/mtrt \n129M 0 14 0 36 50 0 28 0 22 50 0 50 Figure 10. Percentages of dynamic reads of reference-typed .elds, \nexcluding packages sun.*.All percentages are of total .elds.(.nal: declared .nal; uf:undeclared .nal;cgf:.nal \nin program s call graph;nf:cannotbe inferred .nal; see Section 4.2.1for de.nitions.)  total %stationary \n%nonstationary % % project reads .nal uf cgf nf total .nal uf cgf nf total .nal sta. spec/compress 795M \n0100 1 000 99 99 01 spec/db 92M 0000 0 000 100 100 00 spec/jack 63M 010 11 12 000 88 88 0 12 spec/javac \n132M 0500 5 000 95 95 05 spec/jess 139M 0 1900 19 300 78 81 3 19 spec/mpegaudio 304M 0200 2 000 98 98 \n02 spec/mtrt 167M 0000 0 000 100 100 00 Figure 11. Percentages of dynamic reads of primitive-typed .elds, \nexcluding packages sun.*.All percentages are of total .elds.(.nal: declared .nal; uf:undeclared .nal;cgf:.nal \nin program s call graph;nf:cannot be inferred .nal; see Section 4.2.1 for de.nitions.) rithm identi.es \napproximately half of the .elds in Java programs to be stationary. While the inference of stationary \n.elds is relatively simple com\u00adpared to other pointer alias analysis, it yields an important invari\u00adant \nproperty about object .elds. Previous context-sensitive points\u00adto analyses forego .ow sensitivity and \nobjects are often named by the allocationsite, without context sensitivity.A.eldinaheapob\u00adject usually \npoints to a multitude of objects; such analysis cannot tell if two accesses of the same .eld, even if \nthey are right next to each other, yield thevery same object.In contrast, our results show that for about \nhalf of the .elds, reading the same .eld offan object always yields the same result throughout theprogram. \nThis result suggests new approaches to tackling pointer alias analysis in Java. We can devise different \nanalysis techniques for stationary and nonstationary .elds.We already showed thathaving a bit more precision \nduring the initialization phase provides a lot of information for stationary .elds. Further analysis \nof the initial\u00adization code of stationary .elds will provide valuable information about the identities \nof what the stationary object .elds point to. Similarly, better understanding of nonstationary.elds may \nlead to specialized and more ef.cient analysis for them too. References Jong-Deok Choi, Manish Gupta, \nMauricio Serrano,VugranamC. Sreedhar, and Sam Midkiff. Escape analysis for java. In OOPSLA 99: Proceed\u00adingsofthe14thACM \nSIGPLAN conferenceon Object-orientedprogram\u00adming, systems, languages, and applications, pages 1 19,NewYork,NY, \nUSA, 1999.ACM Press. JeffreyDean, David Grove, and Craig Chambers. Optimization of object\u00adoriented programs \nusing static class hierarchy analysis. In ECOOP 95: Proceedings of the 9th European Conference on Object-Oriented \nProgramming, pages 77 101, London, UK, 1995. Springer-Verlag. Dawson Engler,DavidYu Chen, Seth Hallem, \nAndy Chou, and Bejamin Chelf. Bugs as deviant behavior:Ageneral approach to inferring errors in systems \ncode. In Proceedings of Eighteenth ACM Symposium on Operating System Principles, pages 57 72, October \n2001. Jeffrey S.Foster, ManuelF\u00a8ahndrich, and Alexander Aiken. A theory of type quali.ers. In PLDI 99: \nProceedings of theACM SIGPLAN 1999 Conference on Programming Language Design and Implementation, pages \n192 203,NewYork,NY, USA, 1999.ACM Press. James Gosling, Bill Joy, Guy Steele, and Gilad Bracha. TheJava \nLanguage Speci.cation, ThirdEdition. The Java Series. Addison-Wesley, Boston, Mass., 2005. SamuelP. HarbisonandGuy \nSteele. C,AReference Manual. Prentice-Hall, Inc.,NewYork,NY, 1987. DavidL.Heineand MonicaS.Lam.Apractical.ow-sensitiveand \ncontext\u00adsensitiveCand C++ memory leak detector. In PLDI 03: Proceedings of theACM SIGPLAN2003 ConferenceonProgrammingLanguageDesign \nand Implementation, pages 168 181,NewYork,NY, USA, 2003.ACM Press. David L. Heine and Monica S. Lam. \nStatic detection of leaks in poly\u00admorphic containers. In ICSE 06: Proceedings of the 28th International \nConference on Software Engineering, pages 252 261, NewYork, NY, USA, 2006.ACM Press. Gunter Kniesel and \nDirk Theisen. JAC acess right based encapsulation for Java. Software Practice and Experience, 31(6):555 \n576, 2001. Ted Kremenek,PaulTwohey, Godmar Back, Andrew Ng, and Dawson En\u00adgler. From uncertainty to belief: \ninferring the speci.cation within. In USENIX 06: Proceedings of the 7th conference on USENIX Symposium \non Operating Systems Design and Implementation, pages 12 12, Berke\u00adley, CA, USA, 2006. USENIX Association. \nViktorKuncak,Patrick Lam, and Martin Rinard. Role analysis. In POPL 02: Proceedings of the 29th ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, pages 17 32, New York, NY, USA, 2002.ACM Press. Benjamin \nLivshits and Thomas Zimmermann. DynaMine: .nding com\u00admon error patternsby mining software revision histories. \nIn ESEC/FSE\u00ad 13: Proceedings of the 10th European software engineering conference held jointly with 13thACM \nSIGSOFT international symposium onFoun\u00addations of software engineering, pages 296 305, NewYork, NY, USA, \n2005.ACM Press. PeterM\u00a8uller and Arnt Poetzch-Heffter. A type system for controlling representation exposure \nin Java. In 2nd ECOOPWorkshop onFormal Techniques forJavaPrograms, 2001. Igor Pechtchanski and Vivek \nSarkar. Immutability speci.cation and its applications. In JGI 02: Proceedings of the 2002 jointACM-ISCOPE \nconference onJavaGrande,pages 202 211,NewYork,NY,USA, 2002. ACM Press. Sara Porat, Marina Biberstein, \nLarry Koved, and Bilha Mendelson. Au\u00adtomatic detection of immutable .elds in Java. In CASCON 00: Pro\u00adceedings \nof the 2000 Conference of the Centre for Advanced Studies on Collaborative research, page 10. IBM Press, \n2000. A. Salcianu and M. Rinard. Purity and side effect analysis for Java pro\u00adgrams. Lecture Notes in \nComputer Science, 3385:199 215, 2005. Mats Skoglund andTobias Wrigstad. A mode system for readonly refer\u00adences. \nIn Akos Frohner, editor, FormalTechniques forJava Programs, number 2323 in Object-OrientedTechnology, \nECOOP 2001Workshop Reader, pages 30 , Berlin, Heidelberg, New York, 2001. Springer-Verlag. Dave Thomas, \nChad Fowler, and Andy Hunt. Programming Ruby: The Pragmatic Programmer s Guide, Second Edition. Addison-Wesley, \n2005. Matthew S. Tschantz and Michael D. Ernst. Javari: Adding reference immutability to Java. In Object-Oriented \nProgramming Systems, Lan\u00adguages, and Applications (OOPSLA 2005), pages 211 230, San Diego, CA, USA, October \n18 20 2005. John Whaley. Joeq:Avirtual machine and compiler infrastructure. In Pro\u00adceedings of the SIGPLANWorkshop \non Interpreters,Virtual Machines, and Emulators, pages 58 66, June 2003. John Whaleyand Martin Rinard. \nCompositional pointer and escape analysis for java programs. In OOPSLA 99:Proceedingsofthe 14thACMSIG-PLAN \nconference on Object-oriented programming,systems, languages, and applications, pages 187 206, New York, \nNY, USA, 1999. ACM Press. Chadd C. Williams and Jeffrey K. Hollingsworth. Recovering system speci.c rules \nfrom software repositories. In MSR 05: Proceedings of the 2005 international workshop on Mining softwarerepositories, \npages 1 5,NewYork,NY, USA, 2005.ACM Press. JinlinYang,DavidEvans,DeepaliBhardwaj, ThirumaleshBhat,andManu\u00advir \nDas. Perracotta: mining temporal API rules from imperfect traces. In ICSE 06: Proceeding of the 28th \ninternational conference on Software engineering, pages 282 291,NewYork,NY, USA, 2006.ACM Press.   \n \n\t\t\t", "proc_id": "1328438", "abstract": "<p>Java programmers can document that the relationship between two objects is unchanging by declaring the field that encodes that relationship to be final. This information can be used in program understanding and detection of errors in new code additions. Unfortunately, few fields in programs are actually declared final. Programs often contain fields that could be final, but are not declared so. Moreover, the definition of final has restrictions on initializationthat limit its applicability.</p> <p>We introduce <i>stationary</i> fields as a generalization of final. A field in a program is stationary if, for every object that contains it, all writes to the field occur before all the reads. Unlike the definition of final fields, there can be multiple writes during initialization, and initialization can span multiple methods.</p> <p>We have developed an efficient algorithm for inferring which fields are stationary in a program, based on the observation that many fields acquire their value very close to object creation. We presume that an object's initialization phase has concluded when its reference is saved in some heap object. We perform precise analysis only regarding recently created objects. Applying our algorithm to real-world Java programs demonstrates that stationary fields are more common than final fields: 44-59% vs. 11-17% respectively in our benchmarks.</p> <p>These surprising results have several significant implications. First, substantial portions of Java programs appear to be written in a functional style. Second, initialization of these fields occurs very close to object creation, when very good alias information is available. These results open the door for more accurate and efficient pointer alias analysis.</p>", "authors": [{"name": "Christopher Unkel", "author_profile_id": "81342514220", "affiliation": "Stanford University, Stanford, CA", "person_id": "PP43134557", "email_address": "", "orcid_id": ""}, {"name": "Monica S. Lam", "author_profile_id": "81100237956", "affiliation": "Stanford University, Stanford, CA", "person_id": "PP14092336", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328463", "year": "2008", "article_id": "1328463", "conference": "POPL", "title": "Automatic inference of stationary fields: a generalization of java's final fields", "url": "http://dl.acm.org/citation.cfm?id=1328463"}