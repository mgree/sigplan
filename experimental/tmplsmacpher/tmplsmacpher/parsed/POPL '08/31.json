{"article_publication_date": "01-07-2008", "fulltext": "\n An Approach to Call-by-Name Delimited Continuations Hugo Herbelin INRIA Futurs, France Hugo.Herbelin@inria.fr \nAbstract We show that a variant of Parigot s .\u00b5-calculus, originally due to de Groote and proved to satisfyB\u00a8 \nohm s theorem by Saurin, is canonically interpretable as a call-by-name calculus of delim\u00adited control. \nThis observation is expressed using Ariola et al s call-by-value calculus of delimited control, an extension \nof .\u00b5\u00adcalculus with delimited control known to be equationally equiva\u00adlent to Danvy and Filinski s calculus \nwith shift and reset. Our main result then is that de Groote and Saurin s variant of .\u00b5-calculus is equivalent \nto a canonical call-by-name variant of Ariola et al s cal\u00adculus.Therestofthepaperisdevotedtoa comparativestudyofthe \ncall-by-name and call-by-value variants of Ariola et al s calculus, covering in particular the questions \nof simple typing, operational semantics, and continuation-passing-style semantics. Finally, we discuss \nthe relevance of Ariola et al s calculus as a uniform frame\u00adwork for representing different calculi of \ndelimited continuations, including lazy variants such as Sabry s shift and lazy reset calcu\u00adlus. Categories \nand Subject Descriptors F.3.3[Studies of Program Constructs]: Control primitives; F.4.1[Mathematical \nLogic]: Lambda calculus and related systems Keywords Delimited control, Observational completeness,B\u00a8ohm \nseparability, Classical logic. 1. Introduction Control calculi emerged as an attempt to abstractly characterise \nthe semantics of operators like Scheme s call/cc that capture the current continuation of a computation. \nOne .rst such calcu\u00adlus is the .C-calculus of Felleisen et al. (1986). Control opera\u00adtor are connected \nto classical logic, as .rst investigated by Grif\u00ad.n (1990). Hence, it is not a surprise that the cleanest \nsuch .\u00adcalculus of control, namely .\u00b5-calculus ofParigot (1992) comes from a computational analysis of \nclassical natural deduction: as shown by Ariola and Herbelin (2007), .\u00b5-calculus extended with a single \ntoplevel continuation constant tp providesa .ne-grained calculus able, among other things, tofaithfullyexpress \nthe opera\u00adtional semantics of call/cc, C, etc, including its own operational semantics, a property that \n.C-calculus achieves only at observa\u00adtional level. The reason for this success is that .\u00b5-calculus treats \nevaluation contexts as stand-alone .rst-class objects while.C man- Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 08, January 7 12, 2008, San Francisco, \nCalifornia, USA. Copyright c &#38;#169; 2008ACM 978-1-59593-689-9/08/0001...$5.00 Silvia Ghilezan Faculty \nof Engineering, University of Novi Sad, Serbia gsilvia@uns.ns.ac.yu ages evaluation contexts through \ntheir rei.cation as regular func\u00adtions. Delimited control and completeness properties If we concentrate \non call-by-value control calculi, the introduction of delimiters can be traced back to Johnson (1987), \nJohnson and Duggan (1988), Felleisen (1988), and Danvy and Filinski (1989). It has then been shown in \ndifferent contexts that adding such delim\u00aditers increases theexpressivenessof control calculi.For instance, \nSitaram and Felleisen (1990) showed how to recover a full abstrac\u00adtion result for call-by-value PCF with \ncontrol by adding a control delimiter.As another strikingexample, Filinski(1994)showedthat delimited \ncontrol is complete for representing concrete monads, hence to simulate side-effects such as states, \nexceptions, etc. Historically, delimited control came with ad hoc operators for composing continuations: \nFelleisen had a calculus that included a delimiter prompt and a control operator control (also respectively \nwritten # and F); Danvy and Filinski hadan operatorshift to com\u00adpose continuations and an operator reset \nto delimit them (these were also written S and \\)). From Filinski (1994), it is known that shift and \nreset are equivalent to the combination of Scheme s call/cc, Felleisen s abort and reset, and hence equivalent \nto C and reset. From Shan (2004), it is known that control and prompt are also equivalent to shift and \nreset, in spite that control is se\u00admantically more complextostudy than C or shift. The simplicity of \nthe semantics of shift together with its relevance for some program\u00adming applications contributed to \nset shift asareferencein delimited control. And this is so in spite (it seems that) it has never been \nstud\u00adied untilnowaspartofa dedicated .-calculus of delimited control. As shown by Ariola et al. (2007), \na .ne-grained calculus of delimited control of the strength of shift and reset is obtained if one starts \nfrom .\u00b5-calculus and extends it .rst by a notation tp for the toplevel continuation, then by a toplevel \ndelimiter. A possible interpretation for this toplevel delimiter is as a dynamic binder of tp, what justi.es \nto interpret the resulting call-by-value calculus, called .\u00b5 b tp,asanextensionof call-by-value .\u00b5-calculus \nwith a single dynamically bound continuation variable b tp, where the hat on tp emphasises the dynamic \ntreatment of the variable. A typical analogy for the dynamic continuation variable here is exception \nhandling: each call to b tp is dynamically bound to the closest surrounding b tp binder, in exactly the \nsame way as a raised exception is dynamically bound to the closest surrounding handler. On the call-by-name \nside, we know no explicit mention of de\u00adlimited continuations,but two results related toB\u00a8ohm s theorem(a \nform of observational completeness stated as a separability prop\u00aderty) raised interesting questions: \nDavid and Py (2001) showed thatParigot s .\u00b5-calculus does not satisfyB \u00a8 ohm s theorem while Saurin (2005)showedthatan \napparentlyinoffensivevariantof .\u00b5\u00adcalculus due to de Groote (1994) does satisfyB \u00a8 ohm s theorem. Until \nSaurin s result, de Groote s variant of Parigot s .\u00b5\u00adcalculuswasmerely consideredintypedsettings,andmoreparticu\u00adlarly \nin settings where the continuation calls had type . (de Groote \u00df :(.x.M) N . M[N/x] \u00b5app :(\u00b5a.c) N . \n\u00b5\u00df.c[[\u00df](D N)/a] \u00df fresh \u00b5var :[\u00df]\u00b5a.c . c[\u00df/a] Figure 1. Reduction rules of .\u00b5-calculus 1994; Ong 1996; \nOng and Stewart 1997; Selinger 2001, non ex\u00adaustive list). But in such a typed setting, de Groote s calculus \nis equivalent1 to Parigot s .\u00b5-calculus extended with a single con\u00adtinuation constant of type .. Hence, \nSaurin s result is the .rst result revealing that de Groote s calculus is strictly stronger than Parigot \ns one in the untyped setting. In our opinion, this justi.es to refer to this calculus as de-Groote Saurin \ns calculus. Our main result then is that de-Groote Saurin s calculus can be interpreted as a canonical \ncall-by-name variant of call-by-value .\u00b5 b tp. Capitalising on the equational correspondence between \ncall-by\u00advalue.\u00b5 b tp and an axiomatic of Danvy and Filinski sshift and reset givenby (Kameyama and Hasegawa \n2003), we can then assert that the calculus with shift and reset and de-Groote Saurin s calculus aretwofacetsofthevery \nsame notionof delimited control. Outline of the paper Section2isa brief surveyofParigot s .\u00b5 and de Groote \ns variant of .\u00b5, including the separability properties studied by David and Py, and by Saurin. Section \n3 presents call-by-value .\u00b5 b tp and its relation with shift and reset. It reviews the results by Ariola \net al. (2007) and completes them by a formal presentation of the opera\u00adtional semantics of call-by-value \n.\u00b5 b tp. In Section4we introduce a call-by-name .\u00b5 b tp and show that it is equivalent to de-Groote Saurin \ns calculus. Especially, it directly inherits separability from it. We study call-by-name .\u00b5 b tp in comparison \nwith the call-by\u00advalue .\u00b5 b tp: we propose a system of simple types for which sub\u00adject reduction holds \nand we study the operational and continuation\u00adpassing-style semantics.Afurther analysisof .\u00b5 b tp leads \nto a clas\u00adsi.cation of four calculi of delimited continuations which is dis\u00adcussed in Section 5. Concluding \nremarks are given in Section 6. 2. Parigot s .\u00b5-Calculus and Saurin s .\u00b5-Calculus Failure of separability \nin .\u00b5-calculus The .\u00b5-calculus (Parigot 1992), for short .\u00b5, is an untyped calculus designed to computa\u00adtionally \ninterpret proofs of classical natural deduction. Its syntax is de.ned by the following grammar: Parigot \ns.\u00b5-calculus M ::= x | .x.M | MM | \u00b5a.c (terms) c ::= [a]M (commands) where x, y, z and their notational \nderivatives range over an in.nite set of term variables and a, \u00df, ., d and their notational derivatives \nrange over an in.nite set of continuation variables (also called evaluation context variables). Expressions \ncontain terms (called unnamed terms in Parigot) and commands (called named terms in Parigot). The operators \n. and \u00b5 are binders. Free and bound variables are de.ned as usual and we reason modulo renaming of boundvariables.Atermor \ncommandis closed if it contains no free variables. The calculus is equipped with the call-by-name reduction \nrules shown in Figure 1. The notations M [N/x] and c[\u00df/a] denote usual capture-free substitutions, whereas \nthe expression c[[\u00df](D N)/a], 1If we call tp. the continuation constant of type ., then \u00b5a.t and [a]t \nin de Groote s calculus are respectively equivalent to \u00b5a.[tp.]t and \u00b5d.[a]t (d fresh)inParigot s calculus. \n\u00df : (.x.M) N = M[N/x] \u00b5n : [\u00df](En[\u00b5a.c]) = c[[\u00df]En/a] .\u00b5 : \u00b5a.[a]M = M if a not free in M . : .x.(M x) \n= M if x not free in M Figure 2. Equational theory of .\u00b5-calculus called structural substitution, denotes \nthe capture-free substitu\u00adtion of every subterm of the form [a]M in c by [\u00df](MN). For instance, we have \n([a](x .y.\u00b5\u00df.[a]y))[[.](D N)/a] = [.](x .y.\u00b5\u00df'.[.](yN) N) where the binder \u00df has been renamed to avoid \nthe capture of possible free occurrences of \u00df in N. Note that the substitution c[q/a] coincides with \nthe structural substitu\u00adtion c[[q]D/a].Aterm that contains no redex is called normal.We know from Baba \net al. (2001) that call-by-name reduction system is con.uent. The syntax of call-by-name evaluation contexts \nis de.ned by En ::= D | En[D M] where D denotes the hole of the con\u00adtext. We write E[M] for the term \nobtained by substituting M in the hole of E and structural substitution extends straightforwardly into \na substitution of the form c[[\u00df]E/a].We equip .\u00b5 with the equational theory given in Figure 2. Up to \nthe use of (.\u00b5), the rule (\u00b5n) is equivalent to the combination of (\u00b5var ) and (\u00b5app) so that the equational \ntheory is correctly an extension with .-rules of the re.exive-symmetric-transitive closure of .. David \nandPyinvestigatedB\u00a8ohm s separability for the equa\u00adtional theory of .\u00b5 and showed that it does not satisfyB\u00a8ohm \ns separability2. PROPOSITION 1 (David andPy 2001). There are two closed nor\u00admal terms W0 and W1 that \narenot equatedbythe equational theory inFigure2andofwhichthe observational behaviourisnotsepara\u00adble, \ni.e., for distinct fresh variables x and y, there is no applicative context En, suchthat En[W0]= x and \nEn[W1]= y. Separability in .\u00b5-calculus Saurin (2005) showed that com\u00adpleteness can be recovered by relaxing \nthe syntax of .\u00b5 so that the category of commands (i.e. named terms) becomes a subcategory of the oneof \nterms. The syntax usedby Saurinwas already consid\u00aderedbyde Groote (1994),Ong (1996), Selinger (2001). \nThis syntax was considered as an alternative toParigot s original .\u00b5. Saurin s result sheds new light \non the relation between the two calculi.Fol\u00adlowing Saurin, we call .\u00b5 the calculus based on de Groote \nssyntax equipped with the same reduction rules and equational theory as in .\u00b5. The syntax is3: .\u00b5-calculus \nM ::= x | .x.M | MM | \u00b5a.M | [a]M In .\u00b5, there are more evaluation contexts. Theyare de.ned by: Dn ::= \nD | Dn[[a]En]. THEOREM 2 (Saurin 2005). If the closed normal terms M and N in .\u00b5 are not equatedby the \nequational theoryinFigure2, then theyare separable, i.e., for any two variables x and y, there exists \na context Dn, suchthat Dn[M]= x and Dn[N]= y. 2David and Py actually had (\u00b5var ) and (\u00b5app ) instead \nof (\u00b5n) and their rules were oriented as rewrite rules. They also considered the rule . : \u00b5a.c . .x.\u00b5a.c[[a](D \nx)/a] but this rule is redundant for equational reasoning as it derives from (\u00b5n) and (.). The initial \nmotiva\u00adtion for (.) was to turn their system of reduction rules (\u00df), (.), (\u00b5app), (\u00b5var ) and (.\u00b5) intoa \ncon.uent systemof reduction.Infact, (.) hides an .-expansion and it is enough to formulate (.) in the \nexpansion way to get a con.uent system, without anyneed for (.). 3Saurin ssyntaxisabitdifferentashe writes \nMa for what we write [a]M but that is really here a matter of notation. This may look strange as the \nonly change is a change in the syntax of the terms. Infact, the difference lies in the rule (\u00b5var ) which \nin the case of .\u00b5 can only occur in a con.guration of the form: M(\u00b5..[\u00df]\u00b5a.c) . M (\u00b5..c[\u00df/a]) while in \nthe case of .\u00b5, it can also occur in a con.guration of the form: M ([\u00df]\u00b5a.c) . M (c[\u00df/a]) so that the \ncomputational effect of any \u00b5a.c can be cancelled if we succeed in putting it in a context of the form \n[\u00df]D. This last property is the main reason why Saurin s completeness theorem works. 3. A Review of Call-by-Value \n.\u00b5ttp-Calculus The .C b-calculushasbeenintroducedby Ariolaetal. (2007).Itis tp an extension of the call-by-value \nvariant of .\u00b5 obtained by adding a single dynamically bound continuation variable b tp. Ariola et al \ns .C bis a .ne-grained calculus of delimited continuations in which, tp asanexample,the semanticsofDanvyand \nFilinski sshift and reset operators can be simulated. In the original formulation of .C b, the tp control \noperator of the language was called C in spite that .C bis tp based onParigot s structural substitution, \nas in .\u00b5, rather than on substitution of continuations rei.ed as ordinary functions, as it is the case \nin Felleisen .C-calculus. Here we rede.ne .C busing the tp \u00b5 notation instead of a C notation. The so-reformulated \ncalculus is called the call-by-value .\u00b5 b tp. 3.1 Syntax and reduction rules M, N ::= V | MM | \u00b5q.c (terms) \nV ::= x | .x. M (values) c ::= [q] M (commands) q ::= tp a | b(ev. context variables) Figure 3. Syntax \nof .\u00b5 b tp The syntax of .\u00b5 b tp isgivenin Figure3.We also de.ne call-by\u00advalueevaluation contextsby Ev \n::= D | Ev[D M] | Ev[V D] (eval. contexts) Dv ::= D | Dv[[q]Ev[\u00b5 b(nested eval. context) tp.D]] and the \nnotations Ev[M] and Dv[c] stand for the terms and com\u00admands obtained by plugging M into Ev and c into \nDv seen as expressions with one place-holder. \u00dfv :(.x. M) V . M[V/x] \u00b5app :(\u00b5a. c) M . \u00b5\u00df.c[[\u00df](D M)/a] \n\u00df fresh \u00b5app ' : V (\u00b5a. c) . \u00b5\u00df.c[[\u00df](V D)/a] \u00df fresh \u00b5var :[q]\u00b5a.c . c[q/a] .b\u00b5 btp] VV tp occurs in \nV tp : tp.[ b. even if b Figure 4. Reductions of call-by-value .\u00b5 b tp The reduction semantics of call-by-value \n.\u00b5 b tp is given in Fig\u00adure 4. The notation c[[q]E/a] stands for structural substitution of evaluation \ncontexts as in .\u00b5 (see Section 2). The substitutions are capture-free for term and continuation variables \nbut b tp gets captured (e.g. the substitution of x by h (\u00b5d.[ b tp]y)(\u00b5d.[\u00df]z) in [a](f \u00b5\u00df.(g\u00b5 btp]x))) \ngives as result the expression tp.[\u00df](g \u00b5..[ b[a](f \u00b5\u00df ' .(g\u00b5 b](g \u00b5..[ btp]y)(\u00b5d.[\u00df]z)))))). tp.[\u00df ' \ntp](h (\u00b5d.[ b Asimple analysis of the syntax and rules shows that the unique context lemma (see Felleisen \nand Friedman 1986) holds:anyclosed command which is not of the form [ b tp].x.M has a unique decom\u00adposition \nas Dv[[ btp]Ev[M] isa re\u00ad tp]Ev[M]] where either M or [ bdex. Hence the reduction system is complete \nfor the evaluation of closed programs.Aterm that contains no redex at all is said to be normal. 3.2 \nEquational theory \u00dfv :(.x. M) V = M[V/x] \u00b5v :[q](Ev[\u00b5a. c]) = c[[q]Ev/a] .b\u00b5 btp] V = V tp : tp.[ b \n\u00b5tpb: tp](\u00b5 b= [ btp.c) c \u00b5b: \u00b5 btp.c)) = (.x.\u00b5 btp.c) let tp.[q]((.x.M)(\u00b5 btp.[q]M)(\u00b5 b tp \u00b5 let : \n\u00b5a.[q]((.x.N) M) =(.x.\u00b5a.[q]N) M 1 .\u00b5 : \u00b5a.[a] M = M 1 .v : .x.(Vx)= V 2 \u00dfO :(.x.Ev[x]) M = Ev[M] 3 \n 1 a not free in M 2 x not free in V 3 x not free in Ev Figure 5. CPS-complete theory of call-by-value \n.\u00b5 b tp The equational theory of .\u00b5 b tp is given in Figure 5. Note that the equation (\u00b5v) generalises \nthe effect of the rules (\u00b5app), (\u00b5app' ) and (\u00b5var ) (up to the use of (.\u00b5)). 3.3 Simple typing X . \nTypeConstants A, B, T, U ::= X | AT . BU G ::= \u00b7| G,x : A . ::= \u00b7| .,a : AT Ax G,x : A f x:AT ; .; b \ntp : T G,x : A f M : BU ; .; b tp :T .i G f .x.M :(AT . BU )T , ; .; b' tp : T G fM :(AT1 .BU2)U1 ; .; \ntpb:T2 G fN :AT1 ; .; b tp:U1 .e G f MN : BU2 ; .; b tp:T2 G f c :. ;.,a : AU ; tpb: T G f c :. ; .; \nb tp : A G f \u00b5a.c: AU ; .; bG f \u00b5 btp : T tp: T tp.c : AT ; .; b G f M : AU ;.,a : AU ; tpb: T G f M \n:UU ; .; b tp: T G f [a]M :. ;.,a : AU ; tpb: T tp]M :. ; .; b G f [ btp : T Figure 6. Simple typing \nof call-by-value .\u00b5 btp-calculus The calculus .\u00b5 b tp is basically an untyped calculus. Still, it is \npossible to constrain it with a type system. Ariola et al s adaptation of Danvy and Filinski s system \nof simple types (Danvy and Filinski 1989) is given in Figure 6. As in Parigot, the typing context of \ncontinuation variables is on the right of the sequent. We use the symbol . in the typing judgements of \ncommands to emphasise that theyhave no type. A continuation of type AT is a continuation whose own con\u00adtinuation \nis a call to a toplevel continuation b tp expected of type T , i.e. whose own continuation is expected \nto be called in a con\u00adtext where the surrounding \u00b5 b tp has type T .Ajudgement G f M : AT ; .; b tp : \nU says that M is a term which expects a continuation of type AT :the possible capturebyM of itsevaluation \ncontext will be dispatched in contexts where the dynamically closest surround\u00ading \u00b5 b tp is of type T \n. In the judgement, U is the type of the actual closest surrounding toplevel \u00b5 b tp.To propagate the \ntype informa\u00adtion of the dynamically bound b tp, arrows have effects: a term of type AT . BU isaterm \nthatexpectsavalueof type A and returns a code of type B which: may capture its surrounding context and \nmove it in a place where the toplevel has type U,  eventually itself calls the toplevel continuation \nwith a value of type T .  3.4 Continuation-passing-style semantics x+ ! x (.x. M)+ ! .k.....x. [ M] \nk . [ V ] k . ! k . V + [ M N] k . ! [ M] (.. ' ..f. [ N] (f k) . ' ) . [ \u00b5a.c] k . ! ([[c] .)[k/a] [ \n\u00b5 btp c] k . ! [ c] (k .) [[[ btp] M] . ! [ M] (.k. k) . [[[a]M] . ! [ M] a . Figure 7. Call-by-value \nCPS translation of .\u00b5 b tp Wegivein Figure7a continuation-passing-style (CPS) seman\u00adtics in Fischer style \n(see Fischer 1972) for call-by-value .\u00b5 b tp. Ari\u00adolaetal.(2007))showedthatthisCPS translationcanbefactorised \n(up to currying and .-conversion)asthe composition .rstofastate\u00adpassing-style transformation to call-by-value \n.\u00b5 with subtraction, then of a standard call-by-value CPS translation to .-calculus with pairs. 3.5 Equational \ncorrespondence with Kameyama and Hasegawa s axiomatisation of a calculus with shift and reset Danvy and \nFilinski originally de.ned the operators shift and reset by their continuation-passing-style semantics.Weshowinthis \nsec\u00adtion that call-by-value .\u00b5 b tp contains shift and resetin the sense that theycontain operators of \nwhich the CPS semantics is the de.ning semantics of shift and reset. In a second step, we show that call-by-value \n.\u00b5 b tp contains no more than call-by-value .-calculus extended with shift and reset. This is shown by \nexhibiting an equational correspondence with Kameyama and Hasegawa s theory of call-by-value .-calculus \nwith shift and reset, a theory known to exactly capture the CPS semantics of .-calculus with shift and \nreset (Kameyama and Hasegawa 2003). The operators shift and reset are de.ned as follows: S M tp](M .x.\u00b5 \nb \u00b5a.[ btp.[a]x) \\M) tp.[ b \u00b5 btp]M The justi.cation that these encodings de.ne shift and reset is given \nby the following proposition taken from Ariola et al. (2007): PROPOSITION 3 (Simulationofshift and reset \nin .\u00b5 b tp). The CPS semantics of S M and \\M) are: [ S (.q. M)]] k. =[ M] [.k ' .... k (k ' .)/q](.k.k) \n. [ \\M )] k. =[ M] (.k.k)(k.) whichcoincide with the de.ning CPS semantics of shift and reset in Danvy \nandFilinski (1989). Let now(.S , = KH ) be .-calculus equipped with shift and reset and with the axiomatics \nof Kameyama and Hasegawa (2003). Let (.\u00b5 btp equipped with the axioms given tp, =) be call-by-value .\u00b5 \nbin Figure 5. Let .\u00b5tpb0 be the subset of expressions of .\u00b5 b tp that do not contain free continuation \nvariables.We de.ne (.\u00b5 b0 , =) tp as the restriction of (.\u00b5 btp 0 tp, =) to the expressions of .\u00b5 b. \nThe interpretation of .\u00b5 b tp in Kameyama and Hasegawa s cal\u00adculus works as follows: each continuation \nvariable a is injectively mapped to a fresh ordinary variable ka, \u00b5 btp]t is interpreted tp.[ bas \\M), \n\u00b5tpb.[a]t as \\ka M), \u00b5a.[\u00df]M as S(.ka.k\u00df M) and \u00b5a.[ b tp]M as S(.ka.M). The next theorem expresses the \nequa\u00adtional correspondence (in the sense of Sabry and Felleisen 1993) between call-by-value .\u00b5 b0 and \nKameyama and Hasegawa s cal\u00ad tp culus: THEOREM 4 (Ariola et al. 2007). The theories (.S , = KH ) and \n(.\u00b5 b0 , =) are isomorphic. tp COROLLARY 5 (Ariola et al. 2007). The theory (.\u00b5 b tp, =) is com\u00adplete \nwithrespectto \u00df and . through the CPS semantics of call-by\u00advalue .\u00b5 b tp. The addition of a continuation \ndelimiter was used in Sitaram and Felleisen (1990) to recover some completeness property that was lost \nin the move from .-calculus to .C-calculus. Our analysis of Saurin s separability result for call-by-name \n.\u00b5 in Section 4.3 shows thatB\u00a8 ohm s theorem, which amounts to observational com\u00adpleteness for normal \nterms, is also recovered by the addition of a continuation delimiter. This suggests the following conjecture: \nCONJECTURE 6. The theory (.\u00b5 bohm s theorem, tp, =) satis.esB\u00a8i.e., for any equationally distinct closed \nnormal forms M and N, there is a context Dv[[q]Evtp.Dv[M])] = x ] suchthat \u00b5 b[[q](Evand \u00b5 b tp.Dv[[q](Ev[N])] \n= y.  3.6 Operational semantics The operational semantics in natural style is characterised by a deterministic \napplication of the reduction rules at the head of a computation (so-called weak-head reduction). It is \ncommon to formulate the operational semantics on terms but we rather do it on commands what allows for \na more uniform characterisation of normal forms. Typically, when formulated on terms, a term like \u00b5a.[a]V \ncan be reduced further to V only if a does not occur in V but it cannot be reduced further if a does \noccur. To the contrary, if the same term is reduced as part of a command, as in [\u00df]\u00b5a.[a]V , then the \nresulting command uniformly reduces to [\u00df](V [\u00df/a]) independently of whether a occurs or not in V . The \noperational semantics, that we do not only de.ne on closed terms asitis commonbut also on terms with \nfreevariables,isgivenby the equations: \u00df : Dv[[q]Ev[(.x.M) V ]] . Dv[[q]Ev[M[V/x]]] \u00b5v : Dv[[q]Ev[\u00b5\u00df.c]] \n. Dv[c[[q]Ev/\u00df]] .bDv[[q]Ev[\u00b5 btp]V ]] . Dv[[q]Ev[V ]] tp : tp.[ b Obviously . is included in . of which \nit constitutes on com\u00admandsa convenientlevelof abstraction.We say that c is a weak\u00adhead normal command \nif for no c ' , c . c '. Weak-head normal commands are either of the form [ b[[a]V ], tp]V , or of the \nform Dvor of the form Dv[[q]Ev[xV ]]. Operational semantics can be also described by using an ab\u00adstract \nmachine. Evaluation in an abstract machine is closely re\u00adlated to cut-elimination in Gentzen ssequent \ncalculus (see e.g. Her\u00adbelin 1995, 1997; Danos et al. 1996) while, contrastingly, oper\u00adational semantics \nin natural style is related to Gentzen s natu\u00adral deduction. Sequent calculus proofs can be represented \nin .\u00b5\u00b5e\u00adcalculus (Curien and Herbelin 2000; Herbelin 2005) extended with K ::= q[e] | M[e] \u00b7 K | \u00b5 o.\\W \nI o \u00b7 K) (evaluation contexts) [S] ::= tp = K; S] [] | [ b(dynamic environment) W ::= V [e] (closure \nof value) [e] ::= [] | [x = W ; e] | [a = K; e] (environments) s ::= \\W || K)cont [S] | \\M [e] || K)eval \n[S] | \\V [e] || W \u00b7 K)logic [S] (states) \\W \\W \\W \\W \\W \\W \\V \\MN \\\u00b5a.[q]M \\\u00b5 b tp.[q]M \\.x.M \\x \\x \nFigure 8. Speci.c components of the abstract machine for call-by-value .\u00b5 b tp-calculus Control owned \nby the evaluation context || N[e] \u00b7 K )cont [S] .\\N [e] || \u00b5 o.\\W I o \u00b7 K))eval || \u00b5 o.\\V [e] I o \u00b7 K))cont \n[S] .\\V [e] || W \u00b7 K )logic || b)cont [ b.\\W || K )cont tp[e] tp = K; S] || a[e] )cont [S] .\\W || K )cont \n|| tpb[e] )cont [] . stop on [ b tp]W || a[e] )cont [S] . stop on S [[a]W ] Control owned by the term \n[e] || K )eval [S] .\\V [e] || K )cont [e] || K )eval [S] .\\M [e] || N[e] \u00b7 K )eval  [e] || K )eval \n[S] .\\M [a = K; e] || q[a = K; e] )eval [e] || K )eval [S] .\\M [e] || q[e] )eval  Controlownedby thevalue \n[e] || W \u00b7 K )logic [S] .\\M [x = W ; e] || K )eval [e] || W \u00b7 K )logic [S] .\\V [e ' ] || W \u00b7 K )logic \n[e] || W \u00b7 K )logic [S] . stop on S [K [xW ]] To evaluateM, the machine starts with the following initial \nstate: \\M [] || b tp[])eval [] [S] [S] [S] [S] if e(a)= K  if a not bound in e [S] [S] [S] [ b \ntp = K; S] [S] [S] if e(x)= V [e ' ] if x not bound in e  Figure 9. Abstract machine for call-by-value \n.\u00b5 b tp acalculusofexplicit substitutions(seee.g. Herbelin2001)to repre\u00adsent closures and environments, \nin the spirit of Hardin et al. (1996). The language of the abstract machine for call-by-value .\u00b5 b tp \nis showninFigure8andthe reductionstepsaregiveninFigure9.The syntax for evaluation contexts and states \nis reminiscent of .\u00b5\u00b5e\u00adcalculus. Stacks are identi.ed with evaluation contexts. The con\u00adstruction q[e] \nrefers to the continuation bound to q in the environ\u00adment e. The construction M[e] \u00b7 K denotes the continuation \nwhich .rst applies M[e] before continuing with continuation K. The con\u00adstruction \u00b5 o.\\V [e] I o \u00b7 K) \ndenotes the continuation that binds to o the current result, say W , so that computation continues with \ncode V in environment e and continuation W \u00b7K. The construction \\M I K) denotes the interaction of a \nterm M in context K. This construction comes in three .avours. In \\M [e] || K)eval [S], the term M in \nenvironment e has the control on what is going next. At some point of the evaluation process, the term \ngets evaluated and the control is transfered to the evaluation context. This cor\u00adresponds to a state \n\\W || K)cont [S]. At some point, both the termandtheevaluation context arein evaluated formanda log\u00adical \ninteraction happens. This corresponds to states of the form \\V [e] || W \u00b7 K)logic [S]. Speci.c evaluation \nrules correspond to eachof these differentstates.We write e(a) for the binding of a in e and similarly \nfor e(x). The dynamically bound variables are bound in an environment S that remains global (it is not \nstored in breferred to, not only the continuation bound to b closures). Note that when the dynamic continuation \nvariable tp is tp is restoredbut the binding is removed so that the next call to b tp will refer to the \nnext binding of the global environment. Observe that the abstract machine is designed to return the weak-head \nnormal form not only of closed programs but also of terms with free variables (see the stop transitions). \nFinal result reconstruction in terminal states turns explicit substitutions into ef\u00adfective substitutions. \nResult reconstruction turns closures of values into ordinary values. It also uses the operation S thatbuilds \ncon\u00adtexts for command of the form Dv and the operation K thatbuilds contextsof theform [q]Ev. These operations \nare de.nedbythe fol\u00ad lowing clauses: [a[e]] K if e(a) = K [a[e]] [a](D) otherwise [ btp[e]] [ btp](D) \n(M[e] \u00b7 K) K [D M[e] ] ( \u00b5o.\\W I o \u00b7 K)) K [W D] [ ] D [ btp = K; S] S [K [\u00b5 btp.D]] M[x = W ; e] \n M[W /x][e] M[a = K; e] M[K /a][e] PROPOSITION 7. If c isaweak-head normal form, then, [ b tp]M. c \niff the evaluation starting from \\M [] || b tp[])eval [] stops with result c. To make a comparison with \nthe operational semantics of shift and reset given in Biernacka et al. (2003), we show how (the encoding \nof) shift and reset in .\u00b5 b tp operationally reduce on closed terms. Using the abbreviation Cv ::= Dv[[ \nb tp]Ev], we get: Cv[\\Ev[S(.k.M)])] . Cv[\\M[.x.\\Ev[x])/k])] Cv[\\V )]] . Cv[V ] which coincide with the \nrules (S.) and (val) in Biernacka et al. (2003, Section 4.4) through the identi.cationof C2# with Dv \nand of C1 with, [ bif in position of context, or .x.\\Ev[x]) if in tp]Ev position of term. As for the \nrules (\u00df.) and (\u00dfctx ) in Biernacka et al. (2003) theyboth are instances of (\u00df).  3.7 Expressiveness \nCall-by-value .\u00b5 b tp is .ne-grained enough to directly simulate the operational semantics of most standard \ncontrol operators. Let C and A be Felleisen s C and abort operators4. Let call/cc be the implementation \nof call-cc in Scheme. Let M handle patterns and raise M be the constructions of the exception mechanism \nin SML (i.e. of try M with patterns and raise M in O Caml). Let Val be a special exception with one argument. \nIn addition to the de.nition of S M and \\M) above, we have the following encodings: A M \u00b5 .[ btp]M C \n(.k.M ) \u00b5ak.[ btp](M .x.\u00b5 .[ak]x) call/cc (.k.M) \u00b5ak.[ak](M .x.\u00b5 .[ak]x) raise M \u00b5 .[ btp]M M handle \npatterns case \u00b5 btp.[ btp](Val M) of | Val x . x | patterns | x . \u00b5 .[ btp]x Let us show for instance \nhow the operational semantics of Scheme s call/cc is faithfully simulated5. Thanks to structural substitution, \nwe have: Ev[call/cc .k.M] . Ev[M[.x.A Ev[x]/k]] while any other encoding from C (e.g. call/cc (.k.M) \nC(.k.k M))or from S (e.g. call/cc (.k.M) S(.k.k M ' ) with M ' M[.x.A (kx)/k])would give the following \nwrong semantics: Ev[call/cc .k.M] . (.x.A Ev[x]) M[.x.A Ev[x]/k] . Structural substitution also brings \nnew behaviours. Here are a few examples: (i): \u00b5a.[a](... \u00b5.[a]M ... \u00b5.[a]M ' ...) (ii): \u00b5a.[ b\u00b5 b... \ntp.[a]M ' tp](... tp.[a]M\u00b5 b...) (iii): \u00b5a.[ b\u00b5 b... \u00b5.[a]M ' ...) tp](... tp.[a]M (iv): \u00b5a.[ b\u00b5\u00df.[a](... \n... ' ...) tp](... [\u00df]M [a]M ...) 4As usual, A can be used itself to simulate break or return in imperative \nlanguage, assuming that a () marker has been inserted around the related block. 5Note that the SML variant \nof call/cc is not directly simulatable as it rei.es the whole undelimited continuation including theexception \nhandlers, which would mean that .\u00b5 b tp semantics would have to support the capture of the \u00b5 b tp markers, \nwhat it does not. Hence, only the Scheme s variant of call/cc, which does not interfere with exception \nhandling, is simulatable. Example (i) is an optimised variant of call/cc that does not need to wait that \nthe argument of the continuation is evaluated be\u00adfore to reinstall the continuation (compare (.x.\u00b5 .[a]x) \nM with \u00b5.[a]M). Example (ii) is a similarly optimised variant of shift. Example (iii) is anhybrid operator \nwhichis compositional on the left call to a (like shift)and abortive on the right call toa (like C). \nFinally, example (iv) shows how a call to continuation a in the body of a call to another control operator \ncan be contracted (compare \u00b5\u00df.[ b tp]((.x.\u00b5 [a]x) M), as in, e.g., the interpretation of S(.k\u00df .ka M), \nwith \u00b5\u00df.[a]M). More generally, see Ariola and Herbelin (2007) for an analysis of the advantages of structural \nsub\u00adstitution of evaluation contexts over substitution of continuations as regular functions. Thanks \nto Filinski s result on the ability of shift and reset to en\u00adcode monads (Filinski 1994), one can also \nsimulate, as anexample, reading and writing to a memory cell: read .().\u00b5a.[ btp.[a]s) s) tp].s.((\u00b5 bwrite \n.s.\u00b5a.[ btp.[a]()) s) tp]..((\u00b5 b so that the code (\u00b5 btp]M) which may refer to read and tp.[ bv0 write \nbehaves as a program M reading and writing to a global memory cell initialised to value v0. 4. Call-by-Name \n.\u00b5 ttp-Calculus In this section we introduce a call-by-name variant of .\u00b5 b tp. We formalise a reduction \nsemantics, an equational theory, a system of simple types, a continuation-passing-style semantics and \nan oper\u00adational semantics. Call-by-name .\u00b5 b tp is an extension of .\u00b5 that we show to be isomorphic to \n.\u00b5. From the programming point of view, call-by-name .\u00b5 b tp, is a bizarre calculus. In an attempt to \nclarifyhowit behaves, we end the sectionby anexample. 4.1 Syntax and reduction rules The syntax of .\u00b5 \nb tp was given in Figure 3. The reduction rules of the call-by-name variant of .\u00b5 b tp are in Figure \n10. Theyextend the reduction rules of .\u00b5 in Figure1by one rule, called (.b), that is tp similar to the \nequation (.\u00b5) but without anyconstraints on whether b tp occurs or not in M. \u00df :(.x. M) N . M [N/x] \u00b5app \n:(\u00b5a. c) M . \u00b5\u00df.c[[\u00df](D M)/a] \u00df fresh \u00b5 n :[\u00df]\u00b5a.c . c[\u00df/a] var .n \u00b5 btp] M tp occurs in M tpb: tp.[ \nb. M even if b Figure 10. Reductions of call-by-name .\u00b5 b tp We say that a term or a command is normal \nif it contains no redex. Call-by-name evaluation contexts are de.ned as follows: En ::= D | En[D M] (linear \neval. contexts) Dn ::= tp.D]] D | Dn[[a]En[\u00b5 b(nested linear eval. context) Call-by-nameevaluation contexts \nare called linear because theydo not erase nor duplicate the term theyexpect in their hole. An analysis \nof the syntax and rules shows that a form of unique context lemma holds: anycommand with a as only free \nvariable is either of the form Dn[[a].x.M], or of the form [ b tp]M, or, of the form Dn[[a](En[M])] with \neither M or [a](En[M]) a redex. This isinfacta curious result: b tp blocks the reduction and there is \nnot much hope to compute something interesting without at least one free continuation variable at hand. \n 4.2 Equational theory The equational theory of call-by-name .\u00b5 b tp extends the equational theory of \n.\u00b5 with (\u00b5b) (an analog of the rule (\u00b5var ) for the special tp b continuation tp) and with (.b) seen \nas equation. It is given in tp Figure 11. \u00df :(.x.M) N = M[N/x] \u00b5n :[\u00df](En[\u00b5a.c]) = c[[\u00df]En/a] .\u00b5 : \u00b5a.[a]M \n= M if a not free in M . : .x.(Mx)= M if x not free in M \u00b5btp]\u00b5 b= tp :[ btp.c c .btp.[ b= tp : \u00b5 btp]MM \nFigure 11. Equational theory of call-by-name .\u00b5 btp-calculus 4.3 Equational correspondence with .\u00b5 The \ncalculus .\u00b5 is derived from .\u00b5 by relaxing the syntax and keeping the same theory.We now show how.\u00b5 can \nbe contrast\u00adingly restatedasastrictextensionof .\u00b5. Thisextensionis precisely our call-by-name variant \nof .\u00b5 b tp. Embedding of .\u00b5 into call-by-name .\u00b5 bAnaive way to inter\u00ad tp pret .\u00b5 in .\u00b5, actually in \nits extension .\u00b5 b tp, is to interpret any .\u00b5-term \u00b5a.M as the .\u00b5-term \u00b5a.[ b tp]M and to interpret any.\u00b5\u00adterm \n[a]M as the .\u00b5-term \u00b5 b tp.[a]M.Formally, this corresponds to the following embedding . of .\u00b5 into .\u00b5 \nb tp: .(x) x .(.x.M) .x..(M) .(MN) .(M) .(N) .(\u00b5a.M) \u00b5a.[ b tp].(M) .([a]M ) \u00b5 b tp.[a].(M) This translation \nis not de.ned on continuation variables, since theyare not part of the formal syntax. Nevertheless we \ncan derive the following property: LEMMA 8. .(M[\u00df/a]) = .(M)[\u00df/a] We then check that all rules of.\u00b5 can \nbe simulated in .\u00b5, all but the(\u00b5var )rule. Indeed, .([\u00df]\u00b5a.M) = tp.[\u00df]\u00b5a.[ b \u00b5 btp].(M) .\u00b5var \u00b5 btp].(M)[\u00df/a] \ntp.[ b= \u00b5 btp].(M[\u00df/a]) tp.[ b but\u00b5 btp]..(M[\u00df/a]) has no reason to be equal to .(M[\u00df/a]) tp.[ bin .\u00b5. \nThis is actually expected since .\u00b5 is observationally com\u00adplete for normal termsbut .\u00b5 is not.However,in \ntheextended cal\u00adculus .\u00b5 b tp, this equality holds. Indeed, we now have: PROPOSITION 9. If M = N in .\u00b5 \nthen .(M) = .(N) in .\u00b5 b tp. Embedding of call-by-name .\u00b5 bWe now want totp into .\u00b5 show that our call-by-name \n.\u00b5 btp) tp, i.e. .\u00b5 extended with rules (\u00b5band (.b), is indeed equivalent to .\u00b5. Let us de.ne the following \ntp converse translation: S(x) x S(.x.M) .x.S(M) S(MN ) S(M ) S(N) S(\u00b5a.[\u00df]M) \u00b5a.([\u00df]S(M)) S(\u00b5a.[ b\u00b5a.(S(M)) \ntp]M) S(\u00b5 b[a]S(M) tp.[a]M) S(\u00b5 btp]M) tp.[ bS(M ) PROPOSITION 10. If M = N in call-by-name .\u00b5 b tp,thenS(M)= \nS(N) in .\u00b5. X . TypeConstants A, B ::= X | AS . B G ::= \u00d8| G,x : AS . ::= \u00d8| .,a : A S, . ::= .| A \u00b7 \nS Ax G,x : AS fS x : A;. G,x : AS f. M :B;. .i G f. .x.M :(AS . B); . G f. M :(AS . B);. G fS N : A;. \n.e G f. MN : B;. G fS c :. ;.,a :A G fA\u00b7S c:. ;. G fS \u00b5a.c :A;. G fS \u00b5 b tp.c: A;. G fS M : A;.,a : A \nG fS M :A;. G fS [a]M :. ;.,a : A G fA\u00b7S [ b tp]M :. ;. Figure 12. Simple typing of call-by-name .\u00b5 btp-calculus \nSince moreover, S(.(M)) = M and .(S(M)) = M (using (\u00b5b)), we get: tp THEOREM 11 (Equational correspondence). \n.\u00b5 equipped with the equations of Figure 2 and call-by-name .\u00b5 b tp equipped with the equationsofFigure11 \nequationally correspond. REMARK: Call-by-name .\u00b5 b tp and .\u00b5 form more than an equa\u00adtional correspondence: \ntheir reduction systems are also bisimilar: M. N iff.(M). .(N) and S(M). S(N) iffM. N. In par\u00adticular, \nnormal forms match. Observational completeness of normal forms in .\u00b5 bAs a con\u00ad tp sequence of the isomorphism, \nwe have: COROLLARY 12. Call-by-name .\u00b5 b tp is observationally complete for closed normal forms, i.e. \nfor any closed normal forms M and N not equal in call-by-name .\u00b5 b tp, there exists an evalua\u00adtion context \nDn, such that, in .\u00b5 btp.Dn[[ b= x and tp, \u00b5 btp]M] \u00b5 btp[N]] = y for x and y arbitrary fresh variables. \ntp.Dn[[ b Interestingly, this shows that ifB\u00a8ohm s theorem in .\u00b5 (Theo\u00adrem2)was apparently obtainedbyallowing \nmore contexts (namely contexts of the form D [a]M)which were not allowedinParigot s syntax,itis alternatively \nobtainedbyaddingnotonlymorecontexts butby adding new rules that were hiddenby thefact that.\u00b5 and .\u00b5 apparently \nshare the same rules. One may wonder whether the equational theory of call-by\u00adname .\u00b5 b tp is complete \nwith respect to its CPS semantics. This is answered positively in Section 4.5.  4.4 Simple typing We \npropose a system of simple types for call-by-name.\u00b5 b tp. Like for typing .\u00b5,wehavetwokindsofsequents, \noneforeach category of expressions: G fS M : A;. (for terms) G fS c :. ;. (for commands) Like for .\u00b5, \nwe have a context of hypotheses G that assigns types to term variables and a context of conclusions . \nthat assigns types to continuation variables. But we have also to take care of the \u00b5 b tp dynamic binder. \nLikefor Ariola et al sadaptation to call-by-value .\u00b5 b tp of Danvy and Filinski s typing system in Section \n3.3, we have an extra data to type the dynamic effects. Each use of \u00b5 b tp pushes the current continuation \non a stack of dynamically bound continuations. Each call to b tp pops the top continuation from this \nstack. To the contrary of Ariola et al s typing system, the extra infor\u00admation needed to type the dynamic \nbinding is not a single formula but the ordered listS of the types of the continuations present in the \nstack. Like for Ariola et al s typing system, functions can encapsulate occurrences of b tp that may \nbe called in a different typing context than the one that was active at the time \u00b5 b tp was typed.For \ntype consistency, arrows have to remember the types of the dynamic continuation stack that the calls \nb to tp expect to see. We write AS . B for an arrow annotated with the list S of effect types. To the \ncontrary of Ariola et al s typing system, calls to b tp are associated to terms and hence effects are \nassigned to the types of G rather than to the types of .. The typing system is given in Figure 12. Avery \nsimilar systemof simple types has beengivenby Saurin (2007) on top of .\u00b5. In .\u00b5, judgements G fS c :. \n;. are absent since there are no commands in the calculus. Judgements G fS M : A;. are written G, . f \nM : A . S. Moreover, A1 \u00b7 ... \u00b7 An is written A1 . ... . An . o and AS . B is written (A . S) . B. Intuitively, \nA . B denotes a term that returns an object of type B when applied to a linear evaluation context of \ntype A (astream in Saurin sterminology). Logically,the type A . B is equivalent to \u00acA . B,wherethe useofanegation \nemphasises that \u00acA is the type of an evaluation context expecting an argument of type A. Hence, A . B \nis logically equivalent to a disjunction. Note that because . isa connectivein Saurin s typing system, \na conversion rule from ((A . S) . B) . . to (A . S) . (B . .) is needed to type abstraction and application. \nThis latter conversion rule has no computational content. In order to prove subject reduction of the \ntype system in Fig\u00adure 12 we state two auxiliary lemmas (Generation and Substitution Lemma). LEMMA 13 \n(Generation Lemma). 1. G,x : AS f. x : B;. implies . = S and B = A. 2. G f. .x.M : C;. implies C = AS \n. B and G,x : AS f. M : B;.. 3. G f. MN : B;. implies G f. M : AS . B;. and G fS N : A;. for some A and \nS. 4. G fS \u00b5a.c : A;. implies G fS c:. ;.,a : A. 5. G fS [a]M : A;. implies . = . ' ,a : A and G fS \nM :. ;.. 6. G fS \u00b5 b tp.c : A;. implies G fA\u00b7S c:. ;.. 7. G f. [ b  tp]c :. ;. implies . = A \u00b7 S \nand G fS M : A;.. LEMMA 14 (Substitution lemma). 1. Let G,x : AS f. M : B;. and G fS N :A;.. Then G f. \nM[N/x]: B;.. 2. Let G f. c :. ;.,a : AS . B and G fS N : A;. and let \u00df be a fresh variable. Then G f. \nc[\u00df(D N)/a]:. ;.,\u00df : B. 3. Let G fS c :. ;.,a : A, \u00df : A. Then G fS c[\u00df/a]:. ;.,\u00df :  A. Subject reduction \nfollows directly. PROPOSITION 15 (Subject reduction). (i) If G fS M : A;. and M . N, then G fS N : A;.. \n (ii) If G fS c:. ;. and c . c ', then G fS c ' :. ;..  4.5 Continuation-passing-style semantics De \nGroote (1994) de.ned a CPS transformation to .-calculus for .\u00b5.We give here an alternative CPS transformation \nthat is based ona call-by-nameCPS translationto .-calculus with pairs (Lafont, Reus, and Streicher 1993). \nThe .-calculus with pairs is de.ned by the syntax M ::= x | .x.M | MM | (M, M) | let (y, x)= M in M and \nwe use .(x, y).t as an abbreviation for .z.let (x, y)= z in t for z fresh. In addition to (\u00df) and (.), \nthe calculus comes with the following reduction rules: . : let (x, y)=(M, N) in M ' . M ' [N/y; M/x] \n.lift :F [let (x, y)= M in N] . let (x, y)= M in F [N] .. : let (x, y)= M in (x, y) . M for F ::= D N \n| let (x, y)= D in M. We assume to have an injectionka from continuation variables to term variables. \nThe CPS transformation is shown in Figure 13. To the exception of some uses of .-conversion, it differs \nfrom de Groote s transformation on .\u00b5 only in the application and abstraction cases. * xx (.x.M) * .(x, \nk).M* k (MN) * .k.M* (N*,k) * (\u00b5a.c) * .ka.c ([a]M) * M* ka * * (\u00b5 b tp.c) c * ([ bM* tp]M) Figure 13. \nCall-by-name CPS translation of .\u00b5 b tp The CPS transformation is compatible with the type system. Indeed, \nif we de.ne the following transformation on types: X- \u00acX (AS . B)- AS+ . B- AS+ A- . S+ .+ . (A \u00b7 S)+ \nA- . S+ (\u00d8)+ \u00d8 G++ (G,x : AS)+ ,x : AS (\u00d8)- \u00d8 (.,a : A)- .-,a : A- (G fS M : A; .)+ G+ , .- f M * : \nA- . S+ (G fS c :. ; .)+ G+ , .- f c * :S+ then, we get the following compatibility result: PROPOSITION \n16. (i) If G fS M : A;. then (G fS M :A; .)+ . (ii) If G fS c :. ;. then (G fS c :. ; .)+ .  Unfortunately, \nthe CPS above does not simulate the reduction. As it is common, we would have needed a CPS that takes \ncare of administrative redexto geta simulation result. Still, the CPS above is compatible with equality \nin the .-calculus with pairs: PROPOSITION 17. If M . N then M * = N * . We can also state a completeness \nresult (this is an adaptation of standard proofs, see e.g. de Groote 1994; Fujita 2003): PROPOSITION \n18. If M * N * then M = N. =\u00df...lift .. REMARK: In the very same way as for call-by-value .\u00b5 b tp, the \ncall-by-name CPS translation canbefactorised as the composition .rst of a state-passing-style transformation \nto call-by-name .\u00b5 extended with an asymmetric disjunction (becausethe typeeffects in call-by-name .\u00b5 \nb tp naturally take the form of an asymmetric disjunction; for asymmetric disjunction, see Pym and Ritter \n2001), thenofa call-by-nameCPS translationtothe .-calculus with pairs. 4.6 Operational semantics We \n.rst give the operational semantics of call-by-name.\u00b5 b tp as a set of reduction rules applicable to \nthe term as a whole. This kind of operational semantics in natural style is de.ned on commands by the \nfollowing rules: \u00df : Dn[[a]En[(.x.M) N]] . Dn[[a]En[M[N/x]]] \u00b5n : Dn[[a]En[\u00b5\u00df.c]] . Dn[c[[a]En/\u00df]] .n \nb: Dn[[a]En[\u00b5 btp]M]] . Dn[[a]En[M]] tp tp.[ b As in the call-by-value case, . is included in . of which \nit constitutes on commands a level of abstraction. We say that c is a weak-head normal command if for \nno c ' , c . c '. Weak-head normal commands are either of the form [ b tp]M, or of the form Dn[[a]En[x]] \nor of the form Dn[[a].x.M]. We then present the operational semantics by means of a call\u00adby-name abstract \nmachine. The language of the abstract machine for call-by-name is shown in Figure 14 and the reduction \nsteps are given in Figure 15. As for the call-by-value machine in Section 3, the language of the machine \nis an extension with explicit environ\u00adments of the language of .\u00b5 b tp. To initiate the computation, \nwe need an extra constant of evaluation context that we write E. As in the call-by-value machine, the \nevaluation rules are split into three categories. However, the control is .rst owned by the evaluation \ncontext, so that the logical steps are controlled not by thevaluebutby the linearevaluation context. \nFinal result recon\u00adstruction in terminalstates uses almost the same operations as for the call-by-value \nmachine. [a[e]] L if e(a)= L [a[e]] [a](D) otherwise (M[e] \u00b7 L) L [D M[e] ] [] D [tpb= L; S] S [L [\u00b5 \nb tp.D]] M[x = N[e ' ]; e] M[N[e ' ] /x][e] M[a = L; e] M[L /a][e] PROPOSITION 19. If c isaweak-head \nnormal form, then, [E]M. c iffthe evaluation starting from \\M [] || E[])eval [] stops with re\u00adsult c. \n 4.7 An example How does call-by-name .\u00b5 b tp behave on standard examples that uses delimited control?We \nconsider theexampleof list traversal that Biernacki and Danvy (2005) used to emphasise the differences \nbetween operator F (Felleisen 1988) and shift. We extend .\u00b5 b tp with a .xpoint operator, list constructors \nand a list destructor: M, N ::= ... | .x.M | [] | M::N | if M is x::y then M else M and we extend call-by-name \nreduction with the rules .x.M . M [.x.M/x] if [] is x::y then M2 else M1 . M1 if M::N is x::y then M2 \nelse M1 . M2[M/x][N/y] if \u00b5a.c is x::y then M2 else M1 . \u00b5a.c[[a](if D is x::y then M2 else M1)/a] In \ninformal ML syntax, the example is the following let traverse l = let rec visit l = match l with | [] \n-> [] | a::l -> visit (shift (fun k -> a :: k l )) in reset (visit l) in traverse [1;2;3] Translated \ninto.\u00b5, it gives v (n1::n2::n3::[]) where v is .f .(.l.if l is a::l ' then f (\u00b5a.a::[a]l ' ) else []). \nTranslated into.\u00b5 bv is tp, .f .(.l.if l is a::l ' then f (\u00b5a.[ btp.[a]l ' tp]a::\u00b5 b) else []) . Let \n. be an arbitrary continuation distinct from b tp.We write li for ni:: ... ::n3::[].We list the steps \nof the reduction of [E](vl1): [E]vl1 . [E](.l.if l is a::l ' then v (\u00b5a.a::[a]l ' ) else []) l1 . [E]if \nl1 is a::l ' then v (\u00b5a.a::[a]l ' ) else []) . [E]v (\u00b5a.n1::[a]l2)  . if (\u00b5a.n1::[a]l2) is a::l ' then \nv (\u00b5a.a::[a]l ' ) else [] . [E]\u00b5a.n1::[a](if l2 is a::l ' then v (\u00b5a.a::[a]l ' ) else []) . n1::[E](if \nl2 is a::l ' then v (\u00b5a.a::[a]l ' ) else []) . n1::[E](v (\u00b5a.n2::[a]l3))  . n1::[E](\u00b5a.n2::[a](vl3)) \n . n1::n2::[E](vl3) . n1::n2::[E](\u00b5a.n3::[a](v [])) . n1::n2::n3::[E](v []) . n1::n2::n3::[E][]  \nOtherwise said, the list traversal program copies its argument and shifts its continuation to the tail \nof the list. 5. Discussion on a General Framework for Calculi of Delimited Continuations Wereviewbelowtwovariantsofthe \noriginal calculuswithshift and reset.Together with .\u00b5, we then obtain four calculi of delimited continuations.We \nshowhow these four calculi are related. Lazy reset A variant of call-by-value .\u00b5 b tp can be obtained \nby considering that terms of the form \u00b5 b tp.c arevalues.In this case, one obtains a calculus equivalent \nto the .-calculus with shift and lazy reset,a calculus for which Sabrygave an axiomatisation complete \nwith respect to its CPS semantics (Sabry 1996). Call-by-name shift/reset with lazy toplevel continuation \nThe .rst author onceaskedOlivierDanvy:Whatwouldbea canonical call-by-namevariantof the shift/resetcalculus? \nO. Danvy answered by an abstract machine that modi.es the pure .-calculus part of the machine for shift/reset \nin Biernacka et al. (2003) so that it behaves in call-by-name discipline. Expressed in the language of \n.\u00b5 b tp, the resulting calculus differs from the call-by-name variant of .\u00b5 b tp studied in the paper \nin that the rules (\u00b5var ) and (.b) are now those tp of call-by-value .\u00b5 b tp: \u00b5var :[q]\u00b5a.c . c[q/a] \n.b\u00b5 btp] V . V tp : tp.[ b Otherwise said, in this lazy call-by-name variant of .\u00b5 b tp, the toplevel \ncontinuation behaves asa regular linearevaluation context and it is captured by \u00b5a.c as the regular pieces \nof linear evaluation contexts D M, V D and [\u00df] D are. K ::= tp[e] | L b(evaluation contexts) L ::= a[e] \n| M[e] \u00b7 L (linear evaluation contexts) [S] ::= tp = L; S] [] | [ b(dynamic environment) [e] ::= [] \n| [x = M[e]; e] | [a = L; e] (environments) s ::= \\M[e] || K)cont [S] | \\M [e] || L)eval [S] | \\.x.M[e] \n|| L)logic [S] (states) Figure 14. Speci.c components of the abstract machine for call-by-name .\u00b5 btp-calculus \nControl owned by the evaluation context \\M[e] || L )cont [S] .\\M [e] || L )eval [S] tp[e )cont [ b[e] \n)eval \\M[e] || b' ] tp = L; S] .\\M || L [S] \\M[e] || b' ] )cont [] . tp]M[e] tp[e stop on [ b Control \nowned by the term \\x [e] || L )eval [S] .\\M [e ' ] || L )eval [S] if e(x)= M[e ' ] \\.x.M [e] || L )eval \n[S] .\\.x.M[e] || L )logic [S] \\MN [e] || L )eval [S] .\\M [e] || N[e] \u00b7 L )eval [S] \\\u00b5a.[q]M [e] || L \n)eval [S] .\\M[a = L; e] || q[a = L; e] )cont [S] \\\u00b5 b[e] || L [S] .\\M[e] || q[e] )cont tp = L; S] tp.[q]M \n)eval [ b\\x [e] || L )eval [S] . stop on S [L [x]] if x not bound in e Controlownedby the linearevaluation \ncontext '' '' \\.x.M[e] || M [e ] \u00b7 L )logic [S] .\\M [x = M [e ]; e] || L )eval [S] \\.x.M[e] || a[e ' \n] )logic [S] .\\.x.M[e] || L )logic [S] if e ' (a)= L \\.x.M[e] || a[e ' ] )logic [S] . stop on S [[a](.x.M[e] \n)] if a not bound in e ' To evaluateM, we need a linear toplevel free variables distinct from b tp (which \nis not linear). Let E be this variable. Then, the machine starts with the following initial state: \\M \n[] || E[])eval [] Figure 15. Abstract machine for call-by-name .\u00b5 btp-calculus Fundamental critical pair \nof computation (.x.t)(\u00b5a.c) , (CBV) (CBN) . (\u00dfv)+(\u00b5app )+(\u00b5 ' )+(\u00b5var )+(.b)(\u00df)+(\u00b5app)+(\u00b5 n )+(.b) apptpvar \ntp subsidiary choice subsidiary choice (.x.t)(\u00b5 btp]\u00b5a.c tp.c)[ b n tp not value) moved to \u00b5var ) , \ntp tp ) (\u00b5tpbvalue) ,. (\u00b5 b(\u00b5. (.bmoved to .n var b shift/lazy reset shift/reset CBN shift/reset .\u00b5 \n(Sabry) (Danvy-Filinski) (Danvy) (de-Groote Saurin) CPS completion (Sabry) CPS completion (Kameyama-Hasegawa) \nohm-completion (Saurin) B\u00a8typed domain -completion (Sitaram-Felleisen) Figure 16. Calculiof delimited \ncontinuations -a classi.cation The four calculi of delimited continuations The four calculi of In each \nvariant, a subsidiary choice has to be made to decide if delimited continuations are classi.ed in Figure \n16. \u00b5 btp behaves like a linear continuation tp is a value or not and if bChoosing between call-by-name \nand call-by-value amounts to variable or not. decide the fundamental dilemma of computation (as emphasised, \nIn call-by-value,theextra criticalpairis (.x.t)(\u00b5 btp.c tp.c). If \u00b5 be.g., in Curien and Herbelin 2000). \nChoosing call-by-value requires is considered as non evaluated, the call-by-value discipline expects \nto restrict \u00df-reduction into \u00dfv-reduction and to add a rule (\u00b5app' ) that priorityisgiventoitand one \nobtainsthe original shift and reset forincremental substitutionofthenewkindof context (.x.M) D. calculus \nfrom Danvy and Filinski. If otherwise \u00b5 b tp.c is considered asevaluated,ityieldsits prioritytoitsevaluation \ncontext,i.e.tothe function, and \u00df is applicable. One then obtains the calculus with lazy reset that was \nstudied in Sabry (1996). In call-by-name, the extra critical pair is [ b tp]\u00b5a.c. If priority is given \nto the evaluation context, i.e. b tp, one has .rst to know to what it is bound before to continue the \ncomputation. One then obtains the semantics of .\u00b5. If otherwise b tp is considered as a linear continuation \nvariable, it yields the priority to its argument and its capture is made possible. One then obtains Danvy \ns call-by\u00adname variant of the shift and reset calculus. 6. Conclusions Summary We showed that de Groote \nvariant of .\u00b5-calculus, here called .\u00b5 after Saurin, while apparently similar to Parigot s .\u00b5, can be \ninterpreted as an extension of .\u00b5 with call-by-name delimited control. Especially, we showed the following \npoints: .\u00b5 canbe interpretedasa call-by-namevariantof Ariolaetal s extension of call-by-value .\u00b5 with \ndelimited control, namely call-by-value .\u00b5 b tp. The abstract machine for .\u00b5 relies on a global stack \nfor the dynamic continuation as the abstract machine for call-by-value .\u00b5 b tp does. There is a system \nof simple types with effects for .\u00b5 for which subject reduction holds. The .\u00b5 is a surprising calculus. \nOn one side, its syntax and CPS semantics are very simple, and in particular simpler than the syntax \nand CPS semantics of call-by-value calculi of delimited continuations. On the other side, its canonical \nsystem of types andits operational semanticskeepthe complexityofa calculusof delimited control. The absence \nof an explicit control delimiter in .\u00b5 is at .rst glance surprising,but if we admit that the de.nition \nof \\M) is \u00b5 btp]M as it is in call-by-value .\u00b5 b tp.[ btp,then it is normal that no explicit \\M) is needed \nin .\u00b5 since it collapses in call-by\u00adname .\u00b5 b tp to an identity operator. Another lesson is that the \n\u00b5 operator of .\u00b5 is indeed a shift operator6. One could ask whether the syntax of .\u00b5 can be used for \ncall-by\u00advalue delimited control. The answer is yes if one adds an explicit \\M). Indeed, in .\u00b5 extended \nwith \\M), the four combinations \u00b5a.[\u00df]M, \u00b5a.[ btp.[a]M and \u00b5 btp]M are equivalently tp]M, \u00b5 btp.[ bexpressible \nin .\u00b5 by \u00b5a.[\u00df]M, \u00b5a.M, [a]M and \\M) respec\u00adtively. Section5showed that .\u00b5 is not the only call-by-name \ndelimited control. Further investigations into the four different calculi need to be done to better understand \nthe relative strengths of each of the calculi. The separability property in classical logic The .\u00b5\u00b5e-calculus \nis the calculus of choice to study the kind of duality given in Figure 16. Uniformly investigating the \ncomplete\u00adness properties of the four calculi and completing the picture in the framework of .\u00b5\u00b5e-calculus \nwould be interesting. Up to our knowledge, there are no results onB\u00a8ohm s separability property in other \nproof calculi for classical logic.We believe that the sepa\u00adrability property for call-by-name .\u00b5 b tp \nwould directly transfer to call-by-name untyped .\u00b5\u00b5e-calculusbutB\u00a8ohm s separability prop\u00aderty in the \nuntyped call-by-value and in the typed versions of .\u00b5\u00b5e\u00adcalculus are open problems. The question of separability \nin the Dual CalculusWadler (2003)isa topic for future research, as well. 6In passing, this suggests that \nde Groote s use of .\u00b5 for representing quan\u00adti.er scope in linguistic is not sofar from the shift/reset-based \napproach of quanti.er scope by Barker and Shan. An other question is also the investigation ofB\u00a8ohm s \ntheorem in the simply typed fragments of the four calculi (see e.g.B\u00a8ohm s theorem in the simply typed \n.-calculusbyDo.senand Petri\u00b4c(2001), Statman (1982), Simpson (1995), Joly (2000)). Finally, howfar the \nstudy ofB \u00a8 ohm s theorem in call-by-value calculus with control can help for investigating separation \nin Moggi s extension of Plotkin s .v (seePaolini 2001). Acknowledgements We wish to thank Olivier Danvy \nand Alexis Saurin for fruitful discussions we had during thework on this paper. References Zena M. Ariola \nand Hugo Herbelin. Control reduction theories: the bene.t of structural substitution. J. Funct. Program.,2007. \nIncludesaHistorical Noteby Matthias Felleisen.To appear. Zena M. Ariola, Hugo Herbelin, and Amr Sabry. \nAtype-theoretic founda\u00adtion of delimited continuations. Higher Order and Symbolic Computa\u00adtion, 2007. \nTo appear. Kensuke Baba, Sachio Hirokawa, andKen-etsu Fujita. Parallel reduction in type free .\u00b5-calculus. \nElectronic Notes in Theoretical Computer Science, 42:52 66, 2001. Malgorzata Biernacka, Dariusz Biernacki, \nand Olivier Danvy. An opera\u00adtional foundation for delimited continuations. Technical Report 03-41, BRICS, \nUniversity of Aarhus, Denmark, 2003. Dariusz Biernacki and Olivier Danvy. On the dynamic extent of delimited \ncontinuations. Technical Report 05-2, BRICS, University of Aarhus, Denmark, 2005. Pierre-Louis Curien \nand Hugo Herbelin. The duality of computation. In Proceedings of the Fifth ACM SIGPLAN International \nConference on Functional Programming, ICFP 2000, Montreal, Canada, September 18-21, 2000, SIGPLAN Notices \n35(9), pages 233 243. ACM, 2000. ISBN 1-58113-202-6. Vincent Danos, Hugo Herbelin, and Laurent Regnier. \nGame semantics&#38; abstract machines. In Proceedings, 11th Annual IEEE Symposium on Logic in Computer \nScience (LICS 96), pages 394 405. IEEEComputer Society Press, 1996. Olivier Danvy and Andrzej Filinski. \nA functional abstraction of typed contexts. Technical Report 89/12, DIKU, University of Copenhagen, Copenhagen, \nDenmark, August 1989. Ren\u00b4eDavidandWalterPy. Lambda-mu-calculusandB\u00a8ohm s theorem. J. Symb. Log., 66(1):407 \n413, 2001. Philippe de Groote. A CPS-translation of the .\u00b5-calculus. In S. Tison, editor, Proceedings \nof the Colloquium on Trees in Algebra and Pro\u00adgramming, CAAP 94, Edinburgh,U.K., April 11-13, 1994, volume \n787 of Lecture Notes in Computer Science, pages 85 99. Springer-Verlag, 1994. ISBN 3-540-57879-X. KostaDo.senand \nZoran Petri\u00b4c.ThetypedB\u00a8ohm theorem: ohm teorem. In B\u00a8applications to Computer Science Theory -BOTH 2001 \nCrete, Greece, volume 50(2) of Electronic Notes in Theoretical Computer Science, page 13, 2001. Matthias \nFelleisen. The theory and practice of .rst-class prompts. In Proceedingsofthe 15thACM Symposiumon PrinciplesofProgramming \nLanguages (POPL 88),pages 180 190.ACM Press,NewYork, January 1988. Matthias Felleisen and Daniel Friedman. \nControl operators, the secd ma\u00adchine, and the lambda-calculus. In Formal description of programming concepts-III, \npages 193 217. North-Holland, 1986. Matthias Felleisen, DanielP. Friedman, EugeneKohlbecker, and BruceF. \nDuba. Reasoning with continuations. In First Symposium on Logic and Computer Science, pages 131 141, \n1986. Andrzej Filinski. Representing monads. In Conf. Record 21st ACM SIGPLAN-SIGACT Symp. on Principles \nof Programming Languages, POPL 94,Portland, OR, USA, 17-21Jan. 1994, pages 446 457.ACM Press,NewYork, \n1994. Michael J. Fischer. Lambda-calculus schemata. In Proc.ACM Conference on Proving Assertions About \nPrograms, volume 7(1) of SIGPLAN No\u00adtices, pages 104 109.ACM Press,NewYork, 1972. Ken-etsu Fujita. A \nsound and complete cps-translation for lambda-mu\u00adcalculus. In TLCA, pages 120 134, 2003. Timothy G. Grif.n. \nThe formulae-as-types notion of control. In Conf. Record 17th Annual ACM Symp. on Principles of Programming \nLan\u00adguages, POPL 90, San Francisco, CA, USA, 17-19 Jan 1990, pages 47 57.ACM Press,NewYork, 1990. Th\u00b4ese \nHardin, Luc Maranget, and BrunoPagano. er`Functional back-ends within the lambda-sigma calculus. In ICFP, \npages 25 33, 1996. Hugo Herbelin. S\u00b4equents qu on calcule: de l interpr\u00b4etation du calcul dess\u00b4equents \ncomme calculde .-termes et comme calcul de strat\u00b4egies gagnantes. Th`esede doctorat, Universit\u00b4eParis7, \nJanuary 1995. Hugo Herbelin. Games and weak-head reduction for classical PCF. In Philippe de Groote and \nJ. Roger Hindley, editors, Third International Conference on Typed Lambda Calculi and Applications, TLCA \n97, Nancy,France, April 2-4, 1997, Proceedings, volume 1210 of Lecture Notes in Computer Science, pages \n214 230. Springer, 1997. ISBN 3\u00ad540-62688-3. Hugo Herbelin. Explicit substitutions and reducibility. \nJournal of Logic and Computation, 11(3):431 451, 2001. Hugo Herbelin. C est maintenant qu on calcule: \nau c ur de la dualit\u00b4e. Habilitation `e Paris 11, December a diriger les recherches, Universit\u00b4 2005. \n Gregory F. Johnson. Gl a denotational testbed with continuations and partial continuations as .rst-class \nobjects. In SIGPLAN 87:Papers of the Symposium on Interpreters and interpretive techniques, pages 165 \n176,NewYork,NY, USA, 1987.ACM Press. ISBN 0-89791-235-7. GregoryF. Johnson and Dominic Duggan. Stores \nand partial continuations as .rst-class objectsina language and its environment. In POPL, pages 158 168, \n1988. Thierry Joly. Codages, s\u00b4e et repr\u00b4eparabilit\u00b4esentation de fonctions dans divers .-calculs typ \n\u00b4es. Phd thesis, Universit\u00b4eParis7, January 2000. Yukiyoshi Kameyama and Masahito Hasegawa. A sound and \ncomplete axiomatization of delimited continuations. In Colin Runciman and Olin Shivers, editors, ProceedingsoftheEighthACM \nSIGPLAN International Conference on Functional Programming, ICFP 2003, Uppsala, Sweden, August 25-29, \n2003,volume 38(9) ofSIGPLAN Notices,pages 177 188. ACM Press,NewYork, 2003. Yves Lafont, Bernhard Reus, \nand Thomas Streicher. Continuations se\u00admantics or expressing implication by negation. Technical Report \n9321, Ludwig-Maximilians-Universitt, Mnchen, 1993. C.-H. Luke Ong. A semantic view of classical proofs: \ntype-theoretic, categorical, denotational characterizations. In Proceedings of 11th IEEE Annual Symposium \non Logic in Computer Science,pages 230 241. IEEE Computer Society Press, 1996. C.-H. Luke Ong and Charles \nA. Stewart. ACurry-Howard foundation for functional computation with control. In ProceedingsofACM SIGPLAN-SIGACT \nSymposium on Principle of Programming Languages, Paris, January 1997, pages 215 227.ACM Press, 1997. \nLucaPaolini. Call-by-Value separability and computability. In A. Restivo and S. Ronchi dellaRocca, editors, \n7th Italian Conference Theoretical Computer Science, ICTCS 05, volume 2202 of Lecture Notes in Com\u00adputer \nScience, pages 74 89. Springer-Verlag, 2001. Michel Parigot. Lambda-mu-calculus: An algorithmic interpretation \nof classical natural deduction. In LogicProgramming andAutomated Rea\u00adsoning: International ConferenceLPAR \n92Proceedings,St.Petersburg, Russia, pages 190 201. Springer-Verlag, 1992. David Pym and Eike Ritter. \nOn the semantics of classical disjunction. Journal of Pure and Applied Algebra, 159:315 338, 2001. Amr \nSabry. Note on axiomatizing the semantics of control operators. Technical Report CIS-TR-96-03, Dept of \nInformation Science, Univ. of Oregon, 1996. Amr Sabry and Matthias Felleisen. Reasoning about programs \nin continuation-passing style. Lisp and Symbolic Computation, 6(3-4): 289 360, 1993. Alexis Saurin. Separation \nwith streams in the .\u00b5-calculus. In Proceedings, 20th Annual IEEE Symposium on Logic in Computer Science \n(LICS 05), pages 356 365. IEEE Computer Society Press, 2005. Alexis Saurin.Typing streamsinthe lambda-mu-calculus.In \n14th Interna\u00adtional Conference on Logic for Programming Arti.cial Intelligence and Reasoning (LPAR 07), \nLecture Notes in Arti.cial Intelligence. Sprin\u00adger-Verlag, 2007. to appear. Peter Selinger. Control categories \nand duality: on the categorical seman\u00adtics of the lambda-mu calculus. Mathematical Structures in Computer \nScience, 11(2):207 260, 2001. Chung-chieh Shan. Shift to control. In Olin Shivers and OscarWaddell, editors, \nProceedings of the 5th workshop on Scheme and Functional Programming, pages 99 107, 2004. Alex K. Simpson. \nCategorical completeness results for simply typed lambda calculus. In M. Dezani-Ciancaglini and G. Plotkin, \neditors, Typed Lambda Calculus and Applications TLCA 95,volume 902 ofLec\u00adture Notes in Computer Science, \npages 414 427. Springer-Verlag, 1995. Dorai Sitaram and Matthias Felleisen. Reasoning with continuations \nii: full abstraction for models of control. In LFP 90: Proceedings of the 1990 ACM conference on LISP \nand functional programming, pages 161 175. ACM Press, 1990. ISBN 0-89791-368-X. Richard Statman. Completeness, \ninvariance and .-de.nability. J. Symb. Log., 47(1):17 26, 1982. PhilipWadler. Call-by-value is dual to \ncall-by-name. In Colin Runciman and Olin Shivers, editors, Proceedingsof the EighthACM SIGPLAN In\u00adternational \nConference on Functional Programming, ICFP 2003, Upp\u00adsala, Sweden,August 25-29, 2003, volume 38(9) of \nSIGPLAN Notices, pages 189 201.ACM, 2003. ISBN 1-58113-756-7.  \n\t\t\t", "proc_id": "1328438", "abstract": "<p>We show that a variant of Parigot's &#955;&#956;-calculus, originally due to de Groote and proved to satisfy Boehm's theorem by Saurin, is canonically interpretable as a call-by-name calculus of delimited control. This observation is expressed using Ariola et al's call-by-value calculus of delimited control, an extension of &#955;&#956;-calculus with delimited control known to be equationally equivalent to Danvy and Filinski's calculus with shift and reset. Our main result then is that de Groote and Saurin's variant of &#955;&#956;-calculus is equivalent to a canonical call-by-name variant of Ariola et al's calculus. The rest of the paper is devoted to a comparative study of the call-by-name and call-by-value variants of Ariola et al's calculus, covering in particular the questions of simple typing, operational semantics, and continuation-passing-style semantics. Finally, we discuss the relevance of Ariola et al's calculus as a uniform framework for representing different calculi of delimited continuations, including \"lazy\" variants such as Sabry's shift and lazy reset calculus.</p>", "authors": [{"name": "Hugo Herbelin", "author_profile_id": "81100052794", "affiliation": "INRIA Futurs, Palaiseau, France", "person_id": "PP43129435", "email_address": "", "orcid_id": ""}, {"name": "Silvia Ghilezan", "author_profile_id": "81100594201", "affiliation": "University of Novi Sad, Novi Sad, Serbia", "person_id": "P494323", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328484", "year": "2008", "article_id": "1328484", "conference": "POPL", "title": "An approach to call-by-name delimited continuations", "url": "http://dl.acm.org/citation.cfm?id=1328484"}