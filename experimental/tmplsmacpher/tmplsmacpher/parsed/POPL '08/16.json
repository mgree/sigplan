{"article_publication_date": "01-07-2008", "fulltext": "\n Demand-Driven Alias Analysis for C Xin Zheng and Radu Rugina Computer Science Department Cornell University \nIthaca, NY 14853 {xinz, rugina}@cs.cornell.edu Abstract Thispaper presentsa demand-driven, .ow-insensitive \nanalysis al\u00adgorithm for answering may-alias queries.We formulate the com\u00adputation of alias queries as \na CFL-reachability problem, and use this formulation to derivea demand-driven analysis algorithm. The \nanalysis uses a worklist algorithm that gradually explores the pro\u00adgram structure and stops as soon as \nenoughevidenceisgathered to answerthe query. Unlikeexisting techniques,our approach does not requirebuilding \nor intersecting points-to sets. Experiments show that our technique is effective at answering alias queries \naccurately andef.cientlyina demand-drivenfashion. For a set of alias queries from the SPEC2000 benchmarks, \nan implementation of our analysis is able to accurately answer 96% of the queries in 0.5 milliseconds \nper query on average, using only 65KBof memory. Comparedtoademand-driven points-to analysis that constructs \nand intersects points-to sets on the .y, our alias analysis can achieve better accuracy while running \nmore than 30 timesfaster. The low run-time cost and low memory demands of the analysis make it a very \ngood candidate not only for compilers, but also for interactive tools, such as program understanding \ntools or integrated development environments(IDEs). Categories and Subject Descriptors D.3.4[Processors]: \nCom\u00adpilers; F.3.2[Semantics of Programming Languages]: Program Analysis General Terms Algorithms, Languages \nKeywords Pointer analysis, alias analysis, memory disambigua\u00adtion, demand-driven analysis, CFL reachability \n1. Introduction The pervasive use of pointers and references in imperative lan\u00adguagessuchasCorJavahasledtoalargebodyof \nresearchdevoted to the pointer analysis problem, which aims to extract information about pointer values \nand aliases in programs. Such information is needed by virtually any analysis, optimization, or transformation \nfor pointer-based programs. Following Hind (2001), we make the distinction between points-to analysis, \nwhose goal is to compute points-to relations between program variables (represented using points-to sets), \nand Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n08, January 7 12, 2008, San Francisco, California, USA. Copyright c &#38;#169; 2008ACM 978-1-59593-689-9/08/0001...$5.00 \n alias analysis, which computes may-alias relations between pro\u00adgram expressions. Because points-to relations \ncompactly represent all possible aliases, theyhave been quickly adopted as the standard representation. \nTo the best of our knowledge, all of the analyses developed in the past decade are points-to analyses. \nBoth exhaus\u00adtive and demand-driven points-to analysis algorithms have been proposed. When using points-to \nanalysis to answer an alias query about two indirect memory accesses * p and * q, the standard approach \nis to compute the points-to sets of p and q, and then intersect these sets. If the intersection is non-empty, \nthen * p and * q may alias. However, in certain cases it is possible to answer alias queries without \nderiving full points-to sets. For instance, if the program assigns p to q, then the expressions * p and \n* q alias regardless of their points-to sets. This paper presents a demand-driven, .ow-insensitive analysis \nalgorithmforCaimedat answering alias queriesdirectly,withpre\u00adcision equivalent to an inclusion-based \n(Andersen 1994) points-to analysis. We formulate the alias problem as a context-free lan\u00adguage (CFL) \nreachability problem over a graph representation of the assignments and pointer dereference relations \nin a program. In this formulation, the alias relations are described using a grammar. Non-terminals in \nour grammar model alias relations, not points-to relations. We distinguish between two different kinds \nof alias relations: memory (or location) aliases, representing expressions that might denote the same \nmemory location; and value aliases, representing expressions that might evaluate to the same pointer \nvalue. In the example above, * p and * q are memory aliases, whereas p and q are value aliases. This \npaper shows that the computation of the two kindsof alias relationsis mutually recursive,andproposesacontext \nfree grammar that describes both notions of aliases. In the worst case, the proposed alias analysis algorithm \nmight endup performing as muchwork asbuilding full points-to sets for the two pointers being dereferenced. \nHowever, in manycases it can answer queries before the two points-to sets arefully constructed. This \ncan happen in the following two scenarios: If it can be seen from a small number of program assignments \nthat the two pointers in question may hold the same value. Our approach will quickly identify such assignments \nand conclude that the two pointers alias, without trying to determine all of their possiblevalues.Apoints-to \nanalysis willhowever search for all memory locations that the two pointers may point to.  If one pointer \npointstoonlyafewvalues, noneof which are pointed toby the other pointer.Apoints-to analysis must still \ncompute the entire points-to set of the second pointer before concludingthatthetwodonot alias.Ontheotherhand,thealias \nanalysis may discover that the few values of the .rst pointer cannot .ow into the second, and quickly \nterminate the search.  To make the alias exploration more ef.cient, our algorithm ex\u00adplores deeper levels \nof indirection gradually, and limits the amount ofexploration per query. Differentexplorationbudgets \nallow users to trade precision for run-time ef.ciency, andvice versa. We have implemented the alias analysis \nalgorithm and used it to answera setof aliasqueriesin the SPEC2000 benchmark pro\u00adgrams. Our experiments \ndemonstrate that the proposed alias anal\u00adysis can ef.ciently resolve a large fraction of alias queries \non de\u00admand.For our benchmarks, the analysis can correctly answer (with respect to results from an exhaustive \nanalysis) 96% of the queries in 0.52 milliseconds per query on average, using only 65 KB of memory. The \nlow run-time cost and low memory demands of the analysismakeitaverygood candidatenotonlyfor compilers,but \nalso for interactive tools, such as program understanding or pro\u00adgram development tools (e.g., IDEs) \nthat havemore restrictive time and space constraints. Our experiments also show that the proposed demand-driven \nalias analysis canbe signi.cantlyfaster than an analysisthat com\u00adputes points-to sets on demand (Heintze \nand Tardieu 2001) and then intersects the computed sets.For instance, our alias analysis can answer89%ofthe \nqueriesusingabudgetthat correspondsto 0.17 ms per query, whereas the approach based on points-to sets \nresolvesonly84%ofthe queriesusingamuchlargerbudgetthat corresponds to 6.32 ms per query, i.e., more than \n37 times slower. This demonstrates that alias problems can indeed be solved more ef.ciently without constructing \nfull points-to sets. 1.1 Contributions  This paper makes the following contributions: CFL-reachability \nformulation of alias relations. We present aframework for solving memory-alias andvalue-alias problems \nfor C programs using CFL-reachability. To the best of our knowledge, this is the .rst formulation of \nthe alias problem as a CFL-reachability problem.  Demand-driven alias analysis. We present an analysis \nalgo\u00adrithmforsolving alias problemsinademand-drivenfashion.To the best of our knowledge, this is the \n.rst demand-driven algo\u00adrithm capable of answering alias queries without constructing points-to sets. \n Experimental results. We present an experimental evaluation showing that our method can answer alias \nqueries accurately and ef.ciently.  The rest of the paper is organized as follows.We .rst review the \nrelated work in Section 2. Next, Section 3 presents our sim\u00adpli.ed program model. Section 4 describes \nthe CFL-reachability formulation and presents the demand-driven analysis algorithm.A formal semantics \nand soundness result is given in Section 5. Fi\u00adnally, Section6presentsanevaluationofthe analysisand Section7 \nconcludes. 2. Related Work Duetoits importance,pointer analysishasbeenand remainsavery activeareaof research.Welimitour \ndiscussiontothemostrelevant pieces of related work in this area, namely alias analyses, demand\u00addriven \nanalyses, memory disambiguation studies, and analyses for\u00admulatedas CFL-reachability problems.We referthe \nreadertoHind (2001) for a surveyof pointer analysis techniques. Alias analyses. Early approaches to pointer \nanalysis have been formulated as alias analyses (Landi and Ryder 1992; Choi et al. 1993). These are inter-procedural \ndata.ow analyses that compute a set of alias pairs at each program point. However, alias pairs are dif.cult \nto maintain and often contain redundant information. More compact representations of alias pairs have \nbeen explored (Choi et al. 1993),buteventually points-to graphs and points-to setshave emerged as the \nnatural way of representing pointer information. The analyses developed in the past decade have all used \nthis repre\u00adsentation. Our analysis differs from existing alias analyses in that it is .ow-insensitive \nanddemand-driven. Both of these aspects are keyto our approach: being demand-driven, we avoid the quadratic \nblowup of computing all alias pairs; and being .ow-insensitive, we avoid computing alias pairs at each \npoint. In the demand-driven set\u00adting, computing aliases directly is a better choice because points-to \nsets contain more information than needed to answer alias queries. Demand-driven pointer analyses. Heintze \nand Tardieu (2001) present a demand-driven Andersen-style points-to analysis for C programs,and useitto \ndisambiguate indirect function calls.To an\u00adswerapoints-to query,their algorithm recursively generates \npoints\u00adto and pointed-by queries until the original points-to query is fully resolved. Saha and Ramakrishnan \n(2005) use a similar formulation cast as a logic program. In contrast, our framework answers alias queriesand \ndoes not necessarily need tobuild complete points-to sets. In recent work, Sridharan et al. (2005); Sridharan \nand Bod\u00b4ik (2006) have proposed demand-driven points-to analyses for Java programs. Their algorithm extends \na previous CFL-reachability formulation of the points-to analysis problem (Reps 1997) to Java. Akeytechnique \nin their approach is matching loads and stores on the same .eld via match edges. They use a notion of \nre.nement\u00adbased analysis, where match edges are gradually re.ned until the answer to the query meets \nthe needs of the client. Such match edges are however not applicable toCprograms because indirec\u00adtioninCisnot \nlimitedtotheuseofobject .elds;itwould amount to considering any two pointer dereferences *p and *q as \naliased, which can be too conservative. Memory disambiguation. Ghiya et al. (2001) present a study of \nmemory disambiguation techniquesforCprogramsto resolvealias queries issued by several compiler optimizations \nand transforma\u00adtions. Among other techniques, they use an Andersen inclusion\u00adbased pointer analysis for \nanswering alias queries. Lattner et al. (2007) add context sensitivity to uni.cation-based (Steensgaard \n1996) points-to analysis and use it for memory disambiguation. Their analysis uses a context-sensitive \nheap abstraction to distin\u00adguish between heap objects allocated at the same site,but through different \ncalls.We usea simple malloc wrapper detectorto achieve a similar effect. In another study, Das et al. \n(2001) use a context\u00adsensitiveone-level.owanalysisto resolvealias queriesinseveralC programs. Alias pairs \nwere generatedbycomputing all possibleex\u00adpression pairs in each function. Their study indicates that \ntracking value.owsinacontext-sensitivefashionbringsvery littleimprove\u00admentsto alias disambiguationinCprograms.Allof \nthese analyses answer alias queries by intersecting points-to sets. CFL-reachability formulations. CFL-reachability \nhas become a popular technique for expressing program analysis problems (Reps 1997). Standard problems \nthat have been expressed in this frame\u00adwork include points-to analysis problems (Reps 1997; Sridharan \net al. 2005), context-sensitive inter-procedural data.ow analy\u00adsis problems (Reps et al. 1995), and context-sensitive, \nbut .ow\u00adinsensitive pointer analyses(F\u00a8ahndrichetal.2000;Dasetal.2001; Sridharan and Bod\u00b4ik 2006). In \nthe CFL-reachability formulation of points-to analyses (Reps 1997), the grammar expresses points-to relations. \nIn contrast, our formulation addresses the aliasing problem and non-terminals in our grammar denote alias \nrelations. Thefact that we usea single relation for assignments A, instead of four different kinds of \nas\u00adsignment edges (address-of, copy, load, and store) also makes the grammar simpler and more general. \nProgram: s = &#38;t; r = &#38;z; y = &#38;r; s = r; x = *y; ... = *x; *s = ...; Figure 1. Program Expression \nGraph example. Solid, horizontal edges represent assignments(A-edges) and dotted, vertical edges represent \npointer dereferences(D-edges). 3. Program Representation We formulate our analysis for C-like programs \nthat manipulate pointers. For simplicity, we shall assume that all program values are pointers. Programs \nconsist of sets of pointer assignments. The control-.ow between assignments is irrelevant since the analysis \nis .ow-insensitive. Assignments can execute in anyorder, any num\u00adber of times. Program expressions and \nassignments are represented in a canonical form with the following minimal syntax: Addresses a . Addr \nExpressions: e . Expr,e ::= a |* e Assignments: s . Stat,s ::= * e1 := e2 Primitive addresses a . Addr \nmodel symbolic addresses of variables (e.g., &#38;x)and dynamic allocation sites (e.g.,malloc()). There \nis one address amalloc per allocation site, and one symbolic address ax for eachvariable x. There aretwo \nkindsofexpressions: primitiveaddresses a,and pointer dereferences* e.Apointer deref\u00aderenceexpression \n* e denotesthevalueofthe memory locationthat pointer expression e points to. If x is a variable, then \nthe C ex\u00adpression &#38;x is represented in canonical form as ax;expression x is represented as * ax, \nand expression *x is represented as ** ax. In canonical form, an expression represents a memory location \nif and only if it is a dereference expression * e. In the rest of the paper we will also refer to such \nexpressions as lvalues (Kernighan and Ritchie 1988). Program assignments are of the form * e1 := e2, \nsyntactically enforcing that the left-hand side be an lvalue. Expres\u00adsion e1 is the address of the memory \nlocation being updated, and e2 is thevalue being written. Assignments include(but are not lim\u00adited to) \nthe four standard forms of pointer assignments used in the pointer analysis literature: address-of assignments \nx= &#38;y, repre\u00adsented as * ax := ay;copyassignmentsx=y, as * ax := * ay; loads x= *y, as * ax := ** \nay;and stores*x =y, as ** ax := * ay. Our formulation does not require the program to be nor\u00admalized \nto this form; it automatically handles more complex as\u00adsignments (for instance, *x = **y)without introducing \ntemporary variables. The data structure that our algorithm operates on is the Program Expression Graph \n(PEG). This is a graph representation of all expressions and assignments in the program. The nodes of \nthe graph represent program expressions, and edges are of two kinds: Pointer dereference edges(D): for \neach dereference * e, there is a D-edge from e to * e.  Assignment edges (A): for each assignment * \ne1 := e2, there is an A-edge from e2 to * e1.  For eachA and D edge, there is also a corresponding edge \nin the opposite direction, denotedby A and D,respectively. In the rest of the paper we will also refer \nto graph edges as relations between Figure 2. Context-free grammar G for the may-alias problem. The grammar \nuses EBNF notation, where ? indicates an optional term, and * is the Kleene star operator. Symbols D \nand A are the only terminals: D denotes dereference edges, and A denotes assignment edges. Memory aliases: \nM ::= D V D Value aliases: V ::= F M? F Flows of values: F ::= (A M?) * F ::= (M? A) *  the corresponding \nnodes. Hence, relations A and D are the inverse relations of A and D, respectively. All of the above \nrelations (or edges) are pre-computed before the analysis. In the remainder of the paper we will use \nthe terms node and expression interchangeably, because of the one-to-one mapping between PEG nodes and \nprogram expressions. Example. Figure1shows anexample graph. The sourceCpro\u00adgram consists of the pointer \nassignments shown on the left (control\u00ad.ow constructs are omitted because they are irrelevant to a .ow\u00adinsensitive \nanalysis). The program expression graph is shown on the right. The nodes in the graphrepresent all program \nexpressions and subexpressions.For readability, nodeexpressions are shownin Cform, not in canonical form. \nHowever, the graph is constructed using their canonical representation. Solid edges represent pointer \nassignments, and dotted edges represent pointer dereferences. Each horizontal line correspondstoalevelofpointer \nindirection. Expres\u00adsions lower in the .gure are at deeper pointer levels. 4. Alias Analysis via CFL-Reachability \nThe goal of the alias analysis is to compute may-alias relations between programexpressions.We de.netwo \nkindsof aliases: Memory (or location) aliases:two lvalue expressions are mem\u00adory aliases if theymight \ndenote the same memory location;  Value aliases: two expressions are value aliases if they might evaluate \nto the same pointer value.  We describe memory aliases using a binary relation M . Expr \u00d7 Expr, andvalue \naliases usinga binary relation V . Expr \u00d7 Expr. Each relation can be viewed as an edge in the program \nexpression graph.Weformulatethe computationofM and V edges asa context-free language (CFL) reachability \nproblem (Reps 1997; Kodumal and Aiken 2004) over the program expression graph. The idea of CFL-reachability \nis as follows. Given a graph with labeled edges, a relation R over the nodes of this graph can be for\u00admulated \nas a CFL-reachability problem by constructing a grammar G such that nodes n and n' are in the relation \nR if and only if there is a path from n to n' such that the sequence of labels on the edges belongs to \nthe language L(G) de.ned by G. Such a formulation makes it easier to develop demand-driven algorithms \nin a deduc\u00adtivefashion. Figure2shows the context-free grammar G for aliasing prob\u00adlems. The grammar is \nwritten using EBNF notation, where the star symbol is the Kleene star operator, and the question mark \nindicates an optional term. Each terminal and non-terminal representsa rela\u00adtion. The concatenation of \nterminals and non-terminals in the right\u00adhand side of a production corresponds to relation composition. \nThe grammar G from Figure2has three non-terminals, M, V , and F ;and two terminals,A and D.Terminals \nA and D represent assignments and dereference edges in the expression graph. Non\u00adterminal M models memory \naliasing relations, and non-terminal V represents value aliasing relations. Finally, non-terminal F de\u00adscribes \n.ows of values via assignments and memory aliases. More precisely, an F edge from e to e ' indicates \nthat the execution of the program might write the value of expression e into the memory location of expression \ne ' . The intuition behind each production is as follows: Production M ::= D VD shows that two memory \nlocations * e1 and * e2 are memory aliases, i.e., M (* e1, * e2),when their addresseshavethe samevalue: \nV (e1,e2). Hence, the path from * e1 to * e1 consists of an anti-dereference edge D(* e1,e1),a value \nalias edgeV (e1,e2), andadereference edge D(e2, * e2).   Production V ::= FM? F shows that two expressions \ne1 and e2 are value aliases if there exist two expressions e ' 1  ' '' and e2 that are memory aliases, \nM(e1,e 2), and whose values .ow into e1 and e2, respectively: F (e1' ,e1) and F (e2' ,e2). In this production \nM is optional because M is not re.exive for primitive addresses a . Addr (see the properties in the next \nsubsection). Production F ::= (AM?) * means that .ows of values are due to sequences of assignments and \nmemory aliases. The produc\u00adtion F ::= (M? A) * describes the inverse relation, i.e., value .ows in the \nopposite direction. The value-.ow relation F has been introduced in the grammar to make it easier to \nunderstand. However, non-terminal F can be eliminated from the productions, as follows: M ::= DVD (1) \nV ::= (M? A) * M?(AM?) * (2) Hence, memory aliases and value aliases are mutually recur\u00adsive.Computing \nmemory aliases requires computingvalue aliases for their addresses; and computing value aliases involves \nknowl\u00adedge about memory aliases during value .ows. At each step, the recursive process goes one pointer \nlevel deeper. Example. Considertheexamplefrom Figure1. Supposethe anal\u00adysis wants to determine whether \n*x and *s are memory aliases. Expressions &#38;r and y are value aliases V (&#38;r, y) because the as\u00adsignment \nA(&#38;r, y) causesavalue .ow from &#38;r to y. Therefore, the dereferences of these expressions are \nmemory aliases: M(r, *y). Furthermore, the value of r .ows into s, and the value of *y .ows into x. Since \nr and *y are memory aliases, we conclude that x and s are value aliases: V (x, s). Therefore, *x and \n*s are mem\u00adory aliases: M(*x, *s). From the CFL-reachability perspective, the path from *x and *s that \ntraverses nodes[*x, x, *y, y, &#38;r, r, s, *s]corresponds to a string DADADAD. Since this string is \nin the language of M in the alias grammar, the two expressions *x and *y may alias. 4.1 Properties To \nbetter understand relationsD, V and M, it is useful to identify theirkeyproperties. The list below enumerates \nand discusses these properties: The dereference relation D is an injective partial map. That is, each \nprogram expression e has at most one dereference expres\u00adsion e ' such that D(e, e ' ); and at most one \naddress-of ex\u00ad '' '' pression e such that D(e, e ). The relation DD (meaning the composition of D and \nD)is the identity for primitive address expressions; and DD is the identity for lvalue expressions. Relations \nV and M are symmetric. One can show that a rela\u00adtionis symmetricbyshowingthatitisequaltoitsinverse.Inthe \nCFL model, the inverse of a nonterminal is obtained by revers\u00ading the order of terms in the right-handside \nof its production, and then inverting them. The inverses of M and V are: M = DV D = DV D V = FM ? F = \nFM ? F The above equalities can then be used to inductively show that V = V and M = M, by induction on \nthe path length of relations M, M, V and V (where relations are regarded as paths, according to the CFL-reachability \nmodel). Relation V is re.exive. This is because V is nullable (it derives the empty string e in the \ngrammar).  Relation M is re.exive only for lvalue expressions. This is because V is nullable, so DD \nis a subset of the relations in M, and because DD is the identity for lvalue expressions. Relation M \nis not re.exivefor primitiveaddresses because such expressions do not have incoming D edges by construction. \n Relations M and V are not necessarily transitive. Hence, they are not equivalence relations and cannot \nbe implemented using union-.nd structures.  We illustrate this in the example from Figure 1. Expressionsr \nand s are value aliases, and so are s and &#38;t;however,r and &#38;t are not. Similarly, *x and *s are \nmemory aliases, and so are *s and t,but *x and t refer to disjoint pieces of memory. In particular, the \nnon-transitivity of M is the reason why the production for value .ows F applies M at most once after \neach assignment. Applying M more than once might generate spurious alias relations. 4.2 Hierarchical \nState Machine Representation This section shows a representation of grammar G using hierarchi\u00adcal state \nmachines (Alur andYannakakis 1998; Alur et al. 2001; Benedikt et al. 2001). The alias analysis algorithm \nwill be con\u00adstructed from this state machine model. A hierarchical state ma\u00adchine is an automaton whose \nnodes are either states or boxes. Each box representsa call to another state machine,andhasasetofin\u00adputs \nand outputs; these correspond to the start and .nal states of the machine being called.Transitions within \neach machine link states, box inputs, and box outputs. As the name implies, recursive state machines \nalso allow recursive calls between the machines. Figure 3 shows the hierarchical, recursive state machines \nfor the aliasing problem. These machines are constructed from produc\u00adtions (1) and (2), where the F non-terminal \nhas been eliminated. The machine for memory aliases M is shown in the upper part of the .gure, and the \none for value aliases V in the lower part. Each machine has one start state, indicated by the edge that \ncrosses the box. Furthermore, machine M has one output .nal state, and all of the four states of machine \nV are .nal. In M s automaton, all four edges emanating from the outputs of the V box are labeled D. The \nfour statesof the automaton V describe the current position in production (2). States 1 and 2 correspond \nto incoming value .ows in the .rst portion ofthe production. The automaton stays in these states while \ntraversing inverted assignment edges A. Once a forward assignment A is traversed, the execution moves \nto states 3 and 4. These states correspond to the second portion of the production. From this point on, \nonly A edges can be traversed. Hence, the execution can be thought of as consisting two stages, one represented \nby states 1 and 2, and the other represented by states3 and 4. Each of the stages needs two states to \nensure that M is never called twice in a row. After each invocation of M, the automaton follows either \nan A edge or an A edge, depending on the current stage. Figure 3. The Hierarchical State Machines that \ndescribes aliasing relations: machine M recognizes memory aliases, and machine V recognizes value aliases. \nThe two machines are mutually recursive. 4.3 Alias Analysis Algorithm We now present the demand-driven \nalgorithm for answering mem\u00adory may-alias queries. Given two lvalue expressions e1 and e2, the algorithm \ndetermines whether M(e1,e2) holds. Figure 4 shows the analysis algorithm. This is a worklist al\u00adgorithm \nthat propagates CFL-reachability information through the program expression graph. The propagation of \nreachability facts follows the structure of the recursive state machines from Figure 3. During propagation, \nthe algorithm uses machine call summaries to cache and reuse results of recursive calls to state machines. \nThis mechanismis similartotheway inter-procedural data.owanalyses cache and reuse function call summaries \n(Sharir and Pnueli 1981; Reps et al. 1995). The A and D edges of the expression graph are modeled using \nfour functions: deref(n) is the dereference of node n, or null if none exists; addr(n) is the address \nof node n, or null if none exists; assignTo(n) is the set of nodes that n is assigned into; and assignFrom(n) \nis the set of nodes that n is assigned from. Hence, functions deref, addr, assignTo, assignFrom indicate \nthe D, D, A, and A edges, respectively. The information being propagated by the algorithm is value aliases \nV . The worklist elements are triples of the form (n, s, c) indicating that a value-alias reachability \npropagation initiated at node s (the source node) has reached node n (the current node), in automaton \nstate c. Here, state c is one of the four states of the state machine V from Figure 3. Hence, the presence \nof element (n, s, c) in the worklist implies that n and s are value aliases. For each node n, the algorithm \nmaintains a set reach(n) of pairs (s, c) of sourcenodes and machine states that have reached node n. \nThealgorithm also maintainsa set aliasMem(n) that represents the currently known memory aliases of node \nn;these act as summaries of calls to state machine M. Both of the sets aliasMem(n) and reach(n) grow \nduring theexecutionof the algorithm,but need not be fully computed before the query is answered. The \nfunctioning of the algorithm proceeds as follows. Given the lvalue expressions e1 and e2, the algorithm \ntries to deter\u00admine whether addressexpressions addr(e1) and addr(e2) arevalue MAYALIAS(e1 : Expr,e2 \n: Expr) 1 /* initialize worklist */ 2 w .{(addr(e1), addr(e1),S1)} 3 4 while (w is not empty) 5 remove \n(n, s, c) from w 6 s ' . deref(s) 7 n ' . deref(n) 8 9 /* check if the destination has been reached \n*/ if (s ' = e1 . n ' = e2) 11 then return true 12 13 /* propagate informationupward*/ 14 if (n ' = \nnull . n ' . aliasMem(s ' )) 15 then aliasMem(s ' )= aliasMem(s ' ) .{n ' }16 for each (s '' ,c '') in \nreach(s ' ): 17 switch (c '' ) 18 case S1 : PROPAGATE(w, n ' ,s '' ,S2) 19 case S3 : PROPAGATE(w, n ' \n,s '' ,S4) 21 /* propagate reachability through value .ows */ 22 switch (c) 23 case S1 : 24 for each \nm in assignFrom(n): 25 PROPAGATE(w, m, s, S1) 26 for each m in aliasMem(n): 27 PROPAGATE(w, m, s, S2) \n28 for each m in assignTo(n): 29 PROPAGATE(w, m, s, S3) 31 case S2 : 32 for each m in assignFrom(n): \n33 PROPAGATE(w, m, s, S1) 34 for each m in assignTo(n): 35 PROPAGATE(w, m, s, S3) 36 37 case S3 : 38 \nfor each m in assignTo(n): 39 PROPAGATE(w, m, s, S3) for each m in aliasMem(n): 41 PROPAGATE(w, m, s, \nS4) 42 43 case S4 : 44 for each m in assignTo(n): 45 PROPAGATE(w, m, s, S3) 46 47 /* propagate information \ndownward */ 48 if (addr(n) = null . (c = S1 . c = S3)) 49 then PROPAGATE(w, addr(n), addr(n),S1) 51 return \nfalse PROPAGATE(w, n, s, c) 1 if ((s, c) . reach(n)) 2 then reach(n) . reach(n) .{ (s, c)} 3 w . w . \n{(n, s, c)} Figure 4. Demand-Driven Alias Analysis Algorithm. aliases.For this,it starts thevalue-alias \nreachability automatonin state S1, from node addr(e1), as shown by the initialization at line 2. If, \nduring the execution of the main loop, the propagation of this information reaches node addr(e2), then \nthe query returns true , as shown in lines 10 11. Otherwise, at each iteration the algorithm performs \nthe following tasks: Lines 14 19: information is propagated up in the graph, through dereference edges. \nIn this part, the algorithm identi\u00ad.es new summaries of calls to the M machine. If the current node n \nhas a dereference n ' = null, and that dereference is not in the memory alias set of s ' (the source \ns dereference), then a new summary M(s ' ,n ' ) is detected. In this case, the algorithm adds n ' to \nthe alias set of s ', and then propagates each pair '' '' (s ,c '' ) that has reached s over to n in \norder to simulate the call to M . Such calls are possible only for pairs in states S1 or S3;the resulting \nstates areS2 and S4, respectively. This models the transitions for M calls in the V machine. Lines 22 \n45: information is propagated through value .ows. This part of the algorithm precisely models all of \nthe transi\u00adtions in the V automaton.For transitions that correspond to M calls, the algorithm uses the \ncurrent memory-alias summaries. For the other transitions, it propagates information through the assignments \nor inverted assignments in the expression graph, changing the automaton state accordingly.  Lines 48 \n49: information is propagated down in the graph, through inverted dereference edges. This propagation \ncorre\u00adsponds to calling automaton M, with the purpose of discov\u00adering new memory aliases of the current \nnode n. Such calls are only possible if the automaton is currently in state S1 or S3, and if the current \nnode n has an address (i.e., an inverted dereference edge D). In these cases, the algorithm starts a \nnew value-alias propagation at the address of n. As this new prop\u00adagation proceeds, it will enable the \nalgorithm to discover new memory aliases at lines 18 and 19.  The execution of the algorithm can have \ntwo outcomes. If the algorithm identi.es that addr(e1) and addr(e2) are value aliases, then it terminates \nearly and reports that e1 and e2 are memory aliases, at line 11. Otherwise, when the worklist becomes \nempty, all of the value-.ow paths from addr(e1) have been explored, and none of them reached addr(e2). \nIn this case, the algorithm reports that the two expressions are not aliased, as shown at line 51. 4.4 \nAnalysis Example We demonstrate the functioning of the alias algorithm using the example from Figure1.Suppose \nwewantto answerthe alias query mayAlias(*x, *s). Figure5illustrates the propagationofworklist items for \nthis query starting from expression *x. Only the relevant portion of the graph is shown. The shaded circles \nabove the nodes represent worklist items; the numbers inside items show the item state; and the dashed \nedges show the propagation of items through the graph. The table below shows this propagation in textual \nform: Step Current Added Propagation item to worklist kind 1 (x, x, S1) (x, *y, S1) .ow 2 (x, *y, S1) \n(y, y, S1) down 3 (y, y, S1) (y, &#38;r,S1) .ow 4 (y, &#38;r,S1) (x, r, S2) up 5 (x, r, S2) (x, s, S3) \n.ow 6 (x, s, S3) return may alias The table describes each step of the algorithm, the full contents \nof each item, and the new items being generated at each step. The last column indicates the kind of propagation. \n Figure 5. Functioning of the worklist algorithm for the query mayAlias(*x, *s). The shaded circles \nrepresent worklist items, and the dashed lines indicate the propagation of items.The automaton state \nis shown in each of the items. The analysis starts the reachability propagation from theaddress of expression \n*x, in state S1 of the automaton, as indicated by the .rst item(x, x, S1). The analysis traverses the \nassignment edge *y . x in the opposite direction, maintaining the automaton state S1. The new triple \nbecomes(x, *y, S1). At this point there are no other incoming or outgoing assign\u00adment edges for *y, so \nthe analysis starts looking for aliases of *y. This is donebypropagating information down in the graph \nand starting a new reachability propagation at the address of *y. The starting item is(y, y, S1). After \ntraversing the assignment &#38;r . y (again in the opposite direction) the analysis generates the triple \n(y, &#38;r, S1). This shows that y and &#38;r are value aliases. Hence, the analysis concludes that their \ndereferences are memory aliases. This is done by propagating the information up in the graph:for each \nitem that has reached *y, the analysis moves it over to r, adjust\u00ading the automaton state to indicate \nthat a memory alias has been detected.In thisexample, the item(x, *y, S1)is propagated over to(x, r, \nS2). The automaton state changes to S2 to show that the propagation has traversed a memory alias. Finally,the \nanalysis traverses the assignment edge r . s. Since this edge is now traversed in the forward direction, \nthe automaton moves to state S3,and the newitem becomes(x,s,S3).This shows that x and s are value aliases. \nTheir dereferences, *x and *s, are the expressions in the query. Hence, the analysis reports that the \ntwo expressions may alias. Note that the analysis would have given the same answer if the propagation \nof information had started from the other end, i.e., ex\u00adpression *s.Inthatcase,the samepathwouldhavebeentraversed, \nbut in the opposite direction. This behavior is in agreement with the fact that the alias relationM is \nsymmetric. 4.5 Analysis Enhancements We propose several improvements to the basic alias algorithm. Gradual \nexploration. First, we impose an order on the explo\u00adration at different pointer levels, giving priority \nto reachability propagation at upper levels of the expression graph. In this way, the algorithm .rst \nexplores the possibility of value aliases through assignments only. If the query is still not answered, \nthen the al\u00adgorithm searches for memory aliases and starts using them in the value .ows. Furthermore, \nat each pointer level, the algorithm per\u00adforms a breadth-.rst search to avoid exploring long assignment \nchainswhen shortpathsexist.Thisexplorationbehavioris achieved byimplementingtheworklistasamulti-level \nqueue.Each insertion speci.esthelevelat whichtheworklist elementis added.Each re\u00admoval retrieves the \n.rst element in the topmost non-empty queue. Concurrent exploration. The second improvement follows from \nthe observation that memory alias relations are symmetric,but the alias algorithm is asymmetric, since \nit starts propagation only from the .rst expression. Changing the order of expressions in the query will \nnot affect the .nal answer, but might impact ef.ciency. To address this issue,wepropose an enhancement \nwhere the algorithm starts propagation from both ends, e1 and e2. Conceptually,the algorithm consists \nof twoseparate, concurrent searches. This lends itself to parallelism and can take advantage of a multi-core \nor multi-processor system. However, our experiments with a truly concurrent implementation showed that \nthe synchro\u00adnization and thread management overheads outweigh the concur\u00adrencygains. Thus, our algorithm \nuses a single-threaded implementation where the two searches use two separate worklists, and tasks from \nthetwoworklists are manually interleaved.Additionally,the search at the topmost pointer level stops as \nsoon as the propagations from the two opposite ends connect to each other.We refer to this ap\u00adproach \nas the two-worklist algorithm. Tunable exploration budget per query. To limit the time spent on alias \nqueries, our analysis uses a parameter N that controls the amount of exploration per query. This represents \nthe maximum number of items that will be inserted into the worklist. While it is more intuitive to limit \nthe number of worklist iterations (i.e., the number of items taken out of the worklist), the latter is \nnot as useful in bounding the running time. This is because the amount of work done per iteration is \nnot constant; it depends on the number of edges incident on the current node. If the analysis does not \nterminate within itsbudget,it stops and conservatively reports that theexpressionsmaybe aliased.Theexplorationbudget \nN provides a convenient way for analysis clients to trade running time for precision, and vice versa. \nCaching. The presentation so far assumed that each query is executed from scratch. We can improve the \nanalysis by caching alias results so that successive queries bene.t from the efforts of earlier ones, \nat the expense of using more memory. New queries will be able to reuse the memory alias information aliasMem(n) \nstored at each node n, without exploring the deeper pointer levels. One complication arisesduetothefactthatwhenaquery \ntermi\u00adnates the loop early, at line 11, it has not .nished its exploration; in particular, it has not \n.nished computing full memory alias sets for the dereference nodes traversed.Asubsequent query reaching \nsuch a dereference node will not know whether the alias set is complete, and will need to conservatively \nstart a new reachability search at that node.To solve this, each querykeeps track of the dereference \nnodes it traverses. If the query completes, returning at line 51, it marks all of those nodes as having \nfull alias sets. 4.6 Comparison to Points-to Analysis It is useful to compare our alias analysis to points-to \nanalyses. The key difference between the two analyses is that the alias analysis computes the alias relations \nV and M, whereas points-to analyses compute a points-to relation P . Expr \u00d7 Addr between program expressions \nand memory addresses. RelationP can be derived from V , as follows. If R is a relation that marks all \nof the primitive address expressions, R = { (a, a) | a . Addr}, then: P = FR =(M? A) * R (3) The above \nequation indicates that an address is in the points-to set of an expression if it .ows into the expression. \nUsing this equation, one can build a demand-driven points-to analysis that answers queries of the form \npointsTo(e).We brie.y sketch such an analysis,but omit the full algorithm because it is not the focus \nof this paper. The algorithm would be similar to the alias analysis in Figure 4, with the following exceptions. \nThe initialization of the worklist would mark the source with a special symbol START. Then, propagations \nthrough assignments A (at lines 29, 35, 39, and 45) will be disallowed when the source is START to model \njust the backward .ows. The termination condition at lines 10 11 would be replaced by code that adds \nthe current node into the points-to set being queried, provided the source is START and the current node \nis an address. The .nal points-to set will then be returned aftertheloop. Essentially,thiswouldbethe \ndemand-drivenpoints\u00adto analysis of Heintze andTardieu (2001).Akeyobservation here is that the alias analysis \npresented in Section 4.3 might terminate early, at line 11, whereas the points-to analysis cannot, because \nit must construct the full set. Equation (3) also indicates that the computation of points-to sets requires \ninformation about memory aliases. As we know, the memory alias relation M and value alias relation V \nare mutually recursive. Hence, points-to analyses, either exhaustive or demand\u00addriven, must compute relations \nM and V , or some approximation thereof. Conservativeapproximations can be obtained via transitive closure \n(recall that M and V are symmetric, but not transitive). This leadstothe following classi.cationof three \nimportant points\u00adto analysesby the kindsof alias relation approximations theyuse: Andersen s inclusion \nalgorithm (Andersen 1994): M and V are not transitive. Thisis the case for the relations computedby the \nalgorithminthispaper, as de.nedbyequations(1)and(2).  Steensgaard s uni.cation algorithm (Steensgaard \n1996): both M and V are approximatedby their transitive closure.  Das s one-level .ow algorithm (Das \n2000): M is approximated by its transitive closure,but V remains non-transitive.  The uni.cation-based \nanalyses areef.cientbothintimeandin space. These analyses run in almost linear time in the program size, \nand theyef.ciently represent computed relations using union-.nd data structures. Steensgaard s analysis \nprovides an approximation ofboth M and V ,whereas the uni.cation phase of Das s algorithm provides an \napproximation of M only (computing V or P still requires performing value .ows). 4.7 Uninitialized Pointers \nand Null Pointers Uninitialized and null pointers can cause our analysis to answer alias queries more \nconservatively that using points-to analysis and intersecting points-to sets. This is the case if an \nuninitialized or null pointer e is assigned intotwo otherexpressions p and q,whose points-to sets are \ndisjoint. Our analysis says that * p and * q may alias because of the assignments from e. However, this \nsituation arises only if: e is never initialized, whichisabug; oralways null, in which case all uses \nof e could be renamed to null via constant propagation. Inourexperiments,wehaveseenonlyonesuch case,foraquery \nbetween two dereferences of the command-line argument pointer argv. Interestingly, this revealed a minor \nerror in the points-to analysis: argv was treated as uninitialized and considered to have an empty points-to \nset. Our alias analysis correctly determined that theexpressions may alias.Wehave not encountered spurious \nalias relations due to assignments of null pointers. 5. Semantics and Soundness We brie.y state our soundness \nresult here as follows. Consider the following semantic domains: s . Store = Addr . Value . . Value = \nAddr . {.} where a . Addr ranges over addresses, and . represents uninitial\u00adized values. The denotational \nsemantics of statements and expressions is: [ a] s = a [ * e] s = s([[e] s) [ * e1 := e2] s = s[[[e1] \ns . [ e2] s] A program is a set of statements prog = {s1, ..., sn}. The execution of the program consists \nof executing statements si any number of times, in any order, starting from an initial store s0 where \nall memory locations are uninitialized: s0 = .a... DEFINITION 1. We say that relations M, V , and F are \nsound approximations of store s, written (M, V, F ) s, if: '' ' .e, e :[ e] s =[ e ] s = .. V (e, e \n) '' ' .e, e :[ e] s =[ e ] s = .. M(* e, * e ) .e :[ e] s = a . Addr . F (a, e) THEOREM 1. The relations \nV , M , and F de.ned using CFL\u00adreachability over the program expression graph are sound approx\u00adimations \nof all stores that might arise during the execution of the program. The proof is by strong induction \non the program s execution: we show that if (M, V, F ) s for all stores s that arise before an assignment \ns, then these relations are also sound approximations of the store s ' =[ s] s after the assignment, \ni.e., (M, V, F ) s ' . The full proof can be found in Appendix A. 6. Evaluation This section presents \nan evaluation of the algorithms proposed in this paper, as well as the enhancements discussed in Section \n4.5. These algorithms were implemented in Crystal (Rugina et al.), a program analysis infrastructure \nfor C written in Java. The alias analysis is implemented in Java and is publicly available as part of \nthe latest release of the Crystal infrastructure. Weran ourexperimentsonthe SPEC2000 suiteofCbenchmark \nprograms. Figure6lists these benchmarks and their sizes, both in terms of number of lines of source code, \nand in terms of the size of their Program Expression Graphs (PEG). The experiments were conducted ona \ndual-processor 3.8 GHz Pentium4 machine with 2GBof memory, runningWindowsXP. 6.1 Program Representation \nand C Language Features The Crystal program analysis infrastructure uses an intermediate representation \nof expressions and statements similar to the canon\u00adical form presented in Section 3. The PEG is constructed \nby scan\u00adning all of the statements in the Crystal representation. This takes 8seconds in total for our \n15 benchmark programs. Our front-end handles all of the C language, translating all expressions and as\u00adsignments \ninto their canonical forms. In addition to primitive addresses and dereference expressions, the intermediate \nrepresentation contains two other kinds of canoni\u00adcalexpressions: .eldexpressions and arithmeticexpressions. \nArray expressions are automatically translated into pointer arithmetic and dereference expressions. In \nthe PEG, each pointer arithmetic ex\u00adpression e + i is mappedto the same node as its base expression e, \nso the analysis does not distinguish between the two. This also im\u00adplies that the analysis does not distinguish \nbetween different array elements. Field expressions e + f, where e is a pointer expression and f a structure \n.eld, denote the address of .eld f in the structure pointed to by e. StandardCexpressions such as x.f, \n&#38;(x->f), or x->f are represented as * (ax + f ), * ax + f , and * (* ax + f), respectively. In the \nPEG, each .eld expression e + f is mapped to the same node as its base expression e, meaning the analysis \nis .eld-insensitive.Wehave alsoexperimented witha .eld-sensitive Program Code size (KLOC) PEG size Nodes \nEdges Alias queries 164.gzip 7.8 4767 3226 34 175.vpr 17.0 11242 9833 91 176.gcc 205.7 112341 168484 \n1086 177.mesa 50.2 51766 271863 955 179.art 1.3 1226 659 4 181.mcf 1.9 1303 1040 4 183.equake 1.5 1716 \n967 54 186.crafty 19.5 10929 7238 17 188.ammp 13.3 13526 9203 59 197.parser 10.9 9538 8753 99 253.perlbmk \n61.8 48703 52964 304 254.gap 59.5 58915 809665 656 255.vortex 52.6 50322 65125 784 256.bzip2 4.6 3523 \n1681 22 300.twolf 19.7 14057 9977 120 Figure 6. Benchmark programs. formulation of our analysis (presented \nin Appendix B),but found that the bene.ts of.eld sensitivity are extremely small (affecting less than \n1% of queries) to justify the additional complexity in the analysis. Therefore, all of the results in \nthis section use a .eld\u00adinsensitive analysis. Finally, function calls are handled in a context-insensitive \nman\u00adner, as assignments from actual arguments to parameters, and from the returnedexpressiontotheexpressionbeing \nassignedatthe call. To resolve possible targets of indirect function calls, the number of arguments at \nthe call site is matched against all of the functions that have had their addresses taken. Allocation \nwrappers are automati\u00adcally detected by our system using a simple intra-procedural .ow\u00adinsensitive analysis. \nThe analysis identi.es as allocation wrappers those functions whose return values exclusively come from \nalloca\u00adtion points (either malloc or other allocation wrappers) via assign\u00adments to local variables whose \naddresses have not been taken. The alias analysis treats calls to allocation wrappers as distinct alloca\u00adtion \nsites. 6.2 Evaluation Methodology We ran our analysis against a static set of queries using different \nbudgetsN tojudgeits precision.To generatea more realisticsetof queries, we performed a standard available \nexpressions analysis, a data.ow analysis commonly used for partial redundancyelimina-tion.From this set \nweexcluded those queries that canbe trivially answered without pointer analysis, or that require techniques \nbe\u00adyond pointer analysis. These include the following: Pairs of memory locations corresponding to memory \nblocks with different names, e.g., differentvariables or different alloca\u00adtion sites. In canonical form, \nthese are dereference expressions whose base expressions are distinct primitive addresses. Such expressions \ncannot alias.  Pairs where one of the expressions is a variable whose address has not been taken. In \ncanonical form, the primitive addresses of these variables have no outgoing assignment edges. Such variables \ncannot alias anyother expression.  Pairs referring to different elements of the same array, e.g., a[i] \nand a[j]. These expressions map to the same PEG node. Disambiguating such expressions would require techniques \nbe\u00adyond pointer analysis, for instance, array dependence analy\u00adsis (Maydan et al. 1991).We conservativelyassume \nthat such expressionsmayalias,andweexcludethemfromour statistics.    Figure 8. Average run time per \nquery (in milliseconds) for the demand-driven alias analysis(DDA) undervariousbudgets. Both axes are \nlogarithmic. Pairs of expressions that access different .elds of a structure, for instance a.f and b.g. \nRegardless of whether expressions a and b are the same, the two .eld accesses never alias. These pairs \nare also excluded. ThelastcolumninFigure6showsthenumberof remainingqueries from each benchmark. We evaluate \nand compare the following three algorithms for answering alias queries: 1. Demand-Driven Alias Analysis \n(DDA). This is the analysis algorithm proposed in this paper. 2. Exhaustive Points-to Analysis (EXH). \nThis is an exhaustive Andersen-style points-to analysis (Kodumal and Aiken 2005). The analysis pre-computes \npoints-to sets for all variables in the program, and then answers alias queries by intersecting their \npoints-to sets.We use the results of this analysis as an upper bound for determining the accuracyof our \nanalysis. 3. Demand-Driven Points-to Analysis (DDPT). This is the demand-driven points-to analysis discussed \nin Section 4.6.For each alias query, the analysis computes points-to sets on de-  Figure 9. Maximum \nmemory consumption (in kilobytes) of DDA acrossallqueriesinall benchmarksfordifferentbudgets.Bothaxes \nare logarithmic. mand and then intersects the computed sets.We compare both the precision and the ef.ciencyof \nthis approach against ours. Section 6.3 presents an evaluation of DDA alone. Next, Sec\u00adtions 6.4 and \n6.5 compare DDAagainst EXH and DDPT, respec\u00adtively. 6.3 Evaluating DDA Alone We evaluate the demand-driven \nalias analysis algorithm presented in Section 4. The implementation of the analysis includes all of the \nextensions presented in Section 4.5: the gradual exploration of deeper pointer levels, the two-worklist \nalgorithm, and the tunable analysis budgets. Our main results do not make use of cached alias information,but \nwehave alsoexperimented with the caching versionand brie.y statetheimprovements.Theexplorationbudget \nparameter N ranges from6iterations to 2000 steps per query, and all budgets are divided equally between \nthe two worklists of the algorithm. Running time. Figure8shows the time to answer an alias query on demand, \naveraged over all queries from all benchmarks, for dif\u00adferentvaluesof the analysisbudget N. Both of the \naxes are loga\u00adrithmic.The results indicatethatDDAtakeslessthan1millisecond per queryonaverage forbudgetsup \nto 1000. Since some queries can terminate much sooner than others, variation from the average isexpectedto \nsomedegree.We.ndthatthelongestrunningqueries can take about an order of magnitude more time than the \naverage. On the other hand, the majority of queries(60% to 80%, depending on thebudget) takes less time \nthan theaverage. The run times shown represent the version of the analysis that does not cache query \nresults. If caching is used to help future queries, the running time is lowered by an average of 12%. \nPrecision. Figure7 shows anevaluationof the precisionof the demand-driven alias analysis. The .gure shows \nthe percentage of queries completed and the percentage of queries answered as una\u00adliased for differentvaluesof \ntheexplorationbudget N. The numbers in Figure 7(a) show that the analysis completes and thus fully resolves \n(either with a positive or with a negative answer) about 72% of the queries on average using a budget \nof 2000 steps. Almost 50% of the queries can be answered in only 50 steps or less. The .gure shows that \nfor increasingexploration sizes, the analysis yields diminishing returns. In particular, there is little \nbene.t in running the analysis withbudgets larger than 500 steps. For that budget, the analysis resolves \nabout 67% of the queries. Figure7(b)showsthatthenumberofqueries answeredasunaliased follows the same \ntrends. As we will show in Section 6.4, most of the un.nished queries correspond to expressions that \nmay alias according to the exhaus\u00adtiveanalysis. Since we conservatively answer thatexpressions may\u00adalias \nwhena queryexceeds itsbudget,it means that mostof our conservativeanswersareinfact correct.This situation \noccursinap\u00adplications such as mesa and gap that use complex, custom memory management that leads to long, \neventually unsuccessful searches. Settingalowexplorationbudget thus becomes useful foravoiding such expensive \nqueries in these cases, while providing the correct answer in most cases. Memory consumption. Since our \nimplementation is in Java and thisisagarbage-collected language,itisdif.cultto monitor precise memory \nusage.As such, we measure memory demandby identify\u00ading the total number of objects createdduring each \nquery and es\u00adtimating the memory consumed by each type of object. The latter was done by separately creating \na large number of those objects, inserting them into the same Java collection structures as the algo\u00adrithm \n(e.g., HashSets), and then deriving theaverage memory usage per object. Figure 9 shows the estimated \nmemory consumption of the alias analysis (without caching). These numbers con.rm that our demand-driven \nanalysishasverylow memory requirements.Fora budgetof500,only65KB are needed.Evenforthelargestbudget, \nthe analysis never uses more than 264 KB. In addition, for the caching version we have estimated the \namount of memory being used for the cache. This cache size in\u00adcreases both with the budget N and with \nthe number of queries. The maximumcachesize observedinourexperimentswas380KB for vortex withabudgetof \n2000.Forabudgetof 500, the cache sizeforall benchmarkswaslessthan150KB.Notethatitwouldbe possible to \nimplement a more .ne-grained cache eviction policyto ensure control on the cache memory size, thusbalancing \nmemory usage and performance. 6.4 Comparison to Exhaustive Points-to Analysis (EXH) We compare our analysis \nto Banshee (Kodumal and Aiken 2005), anexhaustivestate-of-the-art Andersen-stylepoints-to analysis that \npre-computes points-to sets for all variables in the program. Alias queries are then answered by intersecting \nthese sets. We refer to this analysis as EXH. Since the precision of EXH is an upper bound for the precision \nof our analysis, the purpose of comparing the two analyses is to determine how close our analysis gets \nto the ideal answers.  Figure10shows the resultsof this comparison. The barsin this .gure show the percentage \nof queries where DDAgives the same answer as EXH. The results indicate that our analysis is highly accurate,even \nforlow analysisbudgets.Forabudgetof 500 the analysis correctly answers more than 95% of the queries. \nEven with as little as 50 steps, DDAresolves about 90% of the queries that EXH does. Comparing Figures \n10 and 7(a), we conclude that the majority of queries where our demand-driven analysis does not .nish \nare cases where expressions may alias. As mentioned earlier, our conservativeanswer becomes the correct \nanswer in these cases. Wehave also computed and compared the memory consump\u00adtion of the exhaustive analysis. \nThe computed memory size ex\u00adcludes the memory needed for parsing the programs (estimated by a run where \npoints-to analysis is disabled). On average, EXH re\u00adquires 35 MB of memory per benchmark, and up to 150 \nMB for gcc.We see that an exhaustive analysis can be very expensive in terms of the memory needed, especially \nwhen compared with the memory demands of DDA. Although comparingrunningtimesisless meaningful,astheex\u00adhaustive \nanalysis pre-computes all of the results and amortizes the cost over all queries, we brie.y report these \nnumbers for the sake of completeness. EXH takes 12 seconds in total to pre-compute the points-to sets \nfor all 15 benchmarks. The run time per query is 1ms,but mostof this timeis spentbuilding points-to sets \nfor com\u00adplex expressions (such as **p)from the points-to sets of individual variables. The actual set \nintersection operation is a small fraction of this time. 6.5 Comparison to Demand-Driven Points-to Analysis \n(DDPT) Finally, we compare DDA against our own implementation of demand-driven points-to analysis (DDPT), \nas described in Sec\u00adtion 4.6. This points-to analysis is similar to the one proposed by Heintze andTardieu \n(2001). Although an implementationinCand SMLofthat analysisis publiclyavailable,wechosetouseourJava implementation \nfor two reasons: to ensure that DDA and DDPT are implemented in the same language and same framework; \nand to provide tunable exploration budgets for DDPT. These aspects make the comparison more meaningful. \nBudget N Completed DDA DDPT %of EXH DDA DDPT Run time (ms) DDA DDPT 6 10 20 50 100 200 500 1000 2000 \n12% 8% 22% 15% 40% 19% 49% 27% 55% 29% 59% 30% 67% 31% 70% 31% 72% 31% 61% 63% 69% 69% 84% 73% 89% 80% \n91% 82% 93% 83% 96% 84% 96% 84% 96% 84% 0.08 0.08 0.10 0.09 0.13 0.11 0.17 0.18 0.22 0.23 0.31 0.36 0.52 \n0.75 0.85 1.63 1.84 6.32 Figure 11. Accuracyand performance comparison between DDA and DDPT: percentage \nof queries completed, percentage giving same answer as EXH, and average run time per query.  Figure \n11 compares the precision of the demand-driven alias analysis against the demand-driven points-to analysis \ngiven the sameexplorationbudgets.We see that the alias analysis can com\u00adplete more queries than the points-to \nanalysis for allbudgets. Be\u00adyond a budget of 500, DDPT is unable to complete many more querieseven withanexponential \nincreaseinthebudget. Accuracy as compared to EXH reveals the same pattern, with an exception attheextremelylowbudgetof6. \nDDPTis ableto resolve slightly morequeriesas unaliasedcomparedtoDDAatthisbudget because ofthetwo-worklistalgorithmusedbyDDA,wherethebudgetisdi\u00advided \nand some work is duplicated between the worklists. Beyond this, the data is very striking when one considers \nthe difference in budget needed to achieve the same results. The number of queries that is decided as \nunaliased is about the same (84%)when DDAis givenabudgetof20 and whenDDPTisgiven oneof 500. The last \ntwo columns of Figure 11 show the run-time perfor\u00admanceofbothDDAandDDPT.Our initialgoalwastoverifythat \nthe run times for the two analyses are about the same, since this shouldbe controlledbythebudget.We found \nthistobethe case at smaller budgets (below 200 steps), but were surprised to .nd thatDDAisnoticeablyfaster \nthan DDPTat higherbudgets.Ata budget of 2000, DDPT takes more than3times longer to run than DDA does. \nThere are two main reasons for this difference. First, many more queries are completed within thebudget \n(and thus take less than the maximum time) for DDA. Second, we have observed that when both analyses \nare able to resolve a query under the same budget, DDPT takes on average twice as manyexploration steps. \nComparing both the running times and the accuracies of DDA againstDDPT,weseethatthereisa signi.cantdifferenceincostto \nachieve the same results.For an 84% accuracyDDA uses 0.13 ms onaverage, whereas DDPT needs 0.75 ms, whichis \nmore than5 times higher. DDA resolves in 50 steps more queries as unaliased than DDPT does in 2000 steps, \nand the difference in running time here amountstoafactorof37. 6.6 Summary of Findings Wesummarizethemain \nconclusionsofourexperimentsasfollows: Ademand-driven alias analysis can effectively resolvememory\u00adalias \nqueries with the same accuracy as an exhaustive analysis in very little time and using no pre-computed \ninformation.  The memory consumption of our demand-driven analysis is extremely low and orders of magnitude \nless than that of a state\u00adof-the-art exhaustive analysis.  For answering may-alias queries, a demand-driven \nalias anal\u00adysis will do less work than a demand-driven points-to analysis andcan answermorequeriesinlesstimegiventhesamebudget. \n  7. Conclusions We have presented a novel demand-driven algorithm that answers may-alias queries. The \nanalysis is designed to answer the alias queries without attempting to compute or intersect points-to \nsets. We have described the alias relation using a context-free grammar, and then formulated the alias \nproblem as a CFL-reachability prob\u00adlem over a graph representation of the program. Our results show that \nthe analysis can accuratelyanswer on demandavery large frac\u00adtion of the queries with small time and space \nconsumption, making the approach attractive not only for compilers, but also for more constrained environments \nsuch as program development and inter\u00adactive tools. A possible direction of future work will concern \ninvestigating the applicability of existing optimizations proposed for inclusion\u00adbased points-to analysis, \nsuch as on-line cycle elimination (F\u00a8ahn\u00addrich et al. 1998), to the alias analysis problem. Such optimizations \nhave proved to be very effective for exhaustive points-to analyses, but it is unclear if the same applies \nto alias analyses or to demand\u00addriven analyses. Acknowledgments The authors would like to thank Manu \nSridharan for insightful comments on earlier draftsof this paper.We also thank JeffFoster for useful \ndiscussions about Banshee. This work was supported in partby NSF grants CCF-0541217 andCNS-0406345. References \nR.AlurandM.Yannakakis. Model checkingof hierarchical state machines. In Proceedings of the 6th ACM SIGSOFT \ninternational Symposium on the Foundations of Software Engineering, Lake Buena Vista, FL, November 1998. \n R. Alur, K. Etessami, and M. Yannakakis. Analysis of recursive state machines. In Proceedings of the \n13th International Conference on Computer AidedVeri.cation,Paris, France, July 2001.  Lars Ole Andersen. \nProgram Analysis and Specialization for theC Pro\u00ad gramming Language. PhD thesis, DIKU, University of \nCopenhagen, May 1994. M. Benedikt,P. Godefroid,andT.Reps. Model checkingof unrestrictedhi\u00aderarchical \nstate machines. In Proceedingsof theTwenty-Eighth Interan\u00adtional Colloquium onAutomata, Languages, and \nProgramming, Crete, Greece, July 2001. J. Choi, M. Burke, andP. Carini. Ef.cient .ow-sensitive interprocedural \ncomputation of pointer-induced aliases and side effects. In Conference Recordof theTwentieth Annual Symposium \non Principles of Program\u00adming Languages, Charleston, SC, January 1993. M. Das, B. Liblit, M.F\u00a8ahndrich, \nand J. Rehof. Estimating the impact of scalable pointer analysis on optimization. In Proceedings of the \nInternational Static Analysis Symposium,Paris, France, July 2001. Manuvir Das. Uni.cation-based pointer \nanalysis with directional assign\u00adments. In Proceedings of theACM SIGPLAN 2000 Conference on Pro\u00adgramming \nLanguage Design and Implementation,Vancouver, Canada, June 2000. M.F\u00a8 Partial onlinecycle elim\u00ad ahndrich, \nJ. Foster, Z. Su, and A. Aiken. ination in inclusion constraint graphs. In In Proceedings of the ACM \nSIGPLAN 98 Conference on Programming Language Design and Im\u00adplementation, Montreal, Canada, June 1998. \n M. Fahndrich,\u00a8J. Rehof, and M. Das. Scalable context-sensitive .ow analysis using instantiation constraints. \nIn Proceedings of the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation,Vancouver, \nCanada, June 2000. R. Ghiya, D. Lavery, and D. Sehr. On the importance of points-to analysis andother \nmemory disambiguation methods forCprograms. In Proceed\u00adingsoftheACM SIGPLAN2001 ConferenceonProgrammingLanguage \nDesign and Implementation, Snowbird, UT, June 2001. N. HeintzeandO.Tardieu. Demand-driven pointer analysis.In \nProceedings of the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation, Snowbird, \nUT, June 2001. Michael Hind. Pointer analysis: Haven t we solved this problem yet? In Proceedings of \nthe SIGPLAN-SIGSOFT 01Workshop on Program Analysis for SoftwareTools and Engineering, Snowbird, UT, June \n2001. B.Kernighan and D. Ritchie. The C Programming Language. Prentice-Hall, second edition, 1988. J.Kodumal \nand A. Aiken. The set constraint/CFL reachability connection in practice. In Proceedings of theACM SIGPLAN \n2004 Conference on Programming Language Design and Implementation,Washington, DC, June 2004. J.Kodumal \nand A. Aiken. Banshee:Ascalable constraint-based analysis toolkit. In In Proceedings of the International \nStatic Analysis Sympo\u00adsium, London, UK, September 2005. W. LandiandB.Ryder.Asafe approximation algorithmfor \ninterprocedural pointer aliasing. In Proceedings of theACM SIGPLAN 92 Conference on Programming Language \nDesign and Implementation, San Francisco, CA, June 1992. C. Lattner, A. Lenharth, andV. Adve. Making \ncontext-sensitive points-to analysis with heap cloning practical for the realworld. In Proceedings of \nthe2007ACM SIGPLAN ConferenceonProgrammingLanguageDesign and Implementation, San Diego, CA, June 2007. \n D. Maydan, J. Hennessy, andM. Lam. Ef.cient and exact data dependence analysis. In Proceedings of the \nACM SIGPLAN 1991 Conference on Programming Language Design and Implementation, June 1991. T. Reps, S. \nHorowitz, and M. Sagiv. Precise interprocedural data.ow analysis via graph reachability. In Proceedings \nof the 22nd Annual ACM Symposium on the Principles of Programming Languages, San Francisco, CA, January \n1995.  Thomas Reps. Program analysis via graph reachability. In Proceedings of the International Logic \nProgramming Symposium, Port Jefferson, NY, October 1997. R.Rugina,M.Orlovich,andX.Zheng. Crystal:Aprogramanalysissystem \nfor C. URL: http://www.cs.cornell.edu/projects/crystal. D. Saha and C. R. Ramakrishnan. Incremental \nand demand-driven points-to analysis using logic programming. In Proceedingsof the 7thACM SIG-PLAN International \nConference on Principles and Practice of Declara\u00adtive Programming, July 2005.  M.SharirandA.Pnueli.Twoapproachesto \ninterproceduraldata.owanal\u00adysis. In S. Muchnick and N.D. Jones, editors, Program Flow Analysis: Theory \nand Applications. Prentice Hall Inc, 1981. M. Sridharan and R. Bod\u00b4ik. Re.nement-based context-sensitive \npoints-to analysis for Java. In Proceedings of theACM SIGPLAN 2006 Confer\u00adence on Programming Language \nDesign and Implementation, Ottawa, Canada, June 2006. M. Sridharan, D. Gopan, L. Shan, and R. Bod\u00b4ik. \nDemand-driven points\u00adto analysis for Java. In Proceedings of the 20th AnnualACM SIGPLAN Conference on \nObject-Oriented Programming,Systems, Languages, and Applications, San Diego, CA, October 2005.  Bjarne \nSteensgaard. Points-to analysis in almost linear time. In Proceed\u00adings of the 23rdACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, St. PetersburgBeach, FL, January 1996. A. Proof of \nTheorem 1 We will show that (M, V, F ) s for all s that can arise in a program by strong induction on \nprogram execution. Base case. Trivially true fors0. Inductive case. Let s be the store after execution \nof statement s. Write s as * e1 := e2. Inductively assume that (V, M, F ) s ' for all s ' before execution \nof s. Consider an arbitrary expression e such that [ e] s = a. We will show that F (a, e) holds. If \n[ e] s ' = a for anys ' that existed before the execution of s, then F (a, e) already holdsby the inductivehypothesis. \nOtherwise, we must have [ e] s =[ e] s ' where s ' is the store immediately before the execution of s. \nThat is, statement s modi\u00ad.ed thevalueofexpression e, and as such, s must have written into at least \none memory location represented by a subexpression of e. Write e as *\u00b7 \u00b7 \u00b7* ae, and let e ' be the smallest \nsubexpression of e whosevalue changed asa resultofexecuting s. Statement s must have updated the memory \nlocation where e ' resides. Write e ' as * e ''. Since s explicitly updated * e1, we must have '' ''' \n [ e ] s ' =[ e1] s '. This implies V (e ,e1) and M(e, * e1) by our inductivehypothesis. Let expression \ne ' be updated to have value a ' by statement s. We must have [ e2] s ' = a ' and thus F (a ' ,e2) holds. \nStatement s itself implies A(e2, * e1). Altogether, the facts F (a ' ,e2), A(e2, * e1), and M(* e1,e \n' ) imply F (a ' ,e ' ). If e ' = e, we would have a ' = a and F (a, e), and we are done. If e ' is some \nstrict subexpression of e, we have the following. Let [ * e ' ] s = a '', and let s ' be the statement \nthat updatedthe memory location where * e ' residesby writing a '' into it. Note that s ' can be anystatement \nexecuted before s or even possibly s itself. (Our inductive assumption will still hold even if s ' = \ns, since we will only need information about the store before the execution of s '.) '' ' Write s as \n* e1 := e2, and let s '' be the store before the ' 1] s ''' ' 2] s '' '' execution of s '. We thus have \n[ e = a and [ e = a . ' ' ''' By our inductionhypothesis, we get F (a ,e1) and F (a ,e2). ' ''' '' Thefacts \nF (a ,e ) and F (a ,e1) together imply V (e ,e1) and '' ''' M(* e, * e1). Statement s gives us A(e2, \n* e1). ''' '' '' Wehavethus inferredF (a ,e2),A(e2, * e1),andM(* e1, * e ). Thesefacts imply F (a '' \n, * e ' ). Repeat this process to show value .ows into ** e ' , *** e ', and so onupto *\u00b7 \u00b7 \u00b7* e ' = \ne. The last .owgives us F (a, e) as desired. Now consider two arbitrary expressions e and e ' such that \n[ e] s =[ e ' ] s = a. We have shown that F (a, e) and F (a, e ' ) hold, which implies V (e, e ' ) and \nM(* e, * e ' ). B. Field-Sensitive Analysis The CFL formulationof alias analysis from Section4canbeex\u00adtended \nto distinguish between different structure .elds. In the pres\u00adence of .elds, the PEG contains .eld edges \nbetween nodes in addi\u00adtion to assignment and dereference edges. Each .eld edge is labeled with a .eld \nname f. Recall that an expression e + f is a .eld ad\u00address expression: it denotes the address of .eld \nf of the structure pointed toby e. In the PEG, there is an f edge from e to e + f, and an inverse edge \nf in the opposite direction. We now augment the grammar for alias relations to deal with the presence \nof structure .elds. The grammar Gf for .eld-sensitive alias analysis is as follows: Memory aliases: M \n::= DVD Value aliases: V ::= F VF | fi Vfi | M? Flows of values: F ::= (AM?) * F ::= (M? A) * This grammar \nre.ects the fact that two .eld expressions are value aliases if and only if they refer to the same .eld \nand their base expressions are value aliases. This is shown in the production V ::= fi Vfi, where fi \nis a structure .eld. There is one such pro\u00adduction for each .eld fi in the program. The language of grammar \nGf subsumes the language of the .eld-insensitive grammar G.A demand-driven, .eld-sensitive alias analysis \nalgorithm can be de\u00adrived from the above grammar. \n\t\t\t", "proc_id": "1328438", "abstract": "<p>This paper presents a demand-driven, flow-insensitive analysisalgorithm for answering may-alias queries. We formulate thecomputation of alias queries as a CFL-reachability problem, and use this formulation to derive a demand-driven analysis algorithm. The analysis uses a worklist algorithm that gradually explores the program structure and stops as soon as enough evidence is gathered to answer the query. Unlike existing techniques, our approach does not require building or intersecting points-to sets.</p> <p>Experiments show that our technique is effective at answering alias queries accurately and efficiently in a demand-driven fashion. For a set of alias queries from the SPEC2000 benchmarks, an implementation of our analysis is able to accurately answer 96% of the queries in 0.5 milliseconds per query on average, using only 65 KB of memory. Compared to a demand-driven points-to analysis that constructs and intersects points-to sets on the fly, our alias analysis can achieve better accuracy while running more than 30 times faster. The low run-time cost and low memory demands of the analysis make it a very good candidate not only for compilers, but also for interactive tools, such as program understanding tools or integrated development environments (IDEs).</p>", "authors": [{"name": "Xin Zheng", "author_profile_id": "81546868956", "affiliation": "Cornell University, Ithaca, NY", "person_id": "PP43116486", "email_address": "", "orcid_id": ""}, {"name": "Radu Rugina", "author_profile_id": "81100094619", "affiliation": "Cornell University, Ithaca, NY", "person_id": "P237448", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328464", "year": "2008", "article_id": "1328464", "conference": "POPL", "title": "Demand-driven alias analysis for C", "url": "http://dl.acm.org/citation.cfm?id=1328464"}