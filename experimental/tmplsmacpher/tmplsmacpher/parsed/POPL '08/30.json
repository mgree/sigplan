{"article_publication_date": "01-07-2008", "fulltext": "\n A Type-theoretic Foundation for Programming with Higher-order Abstract Syntax and First-class Substitutions \n Brigitte Pientka McGill University, Canada bpientka@cs.mcgill.ca Abstract Higher-order abstract syntax \n(HOAS) is a simple, powerful tech\u00adnique for implementing object languages, since it directly sup\u00adports \ncommon and trickyroutines dealing with variables, such as capture-avoiding substitution and renaming. \nThis is achieved by representing binders in the object-language via binders in the meta\u00adlanguage. However, \nenriching functional programming languages with direct support for HOAS has been a major challenge, be\u00adcause \nrecursion over HOAS encodings requires one to traverse .\u00adabstractions and necessitates programming with \nopen objects. We present a novel type-theoretic foundation based on contex\u00adtual modal types which allows \nus to recursively analyze open terms via higher-order pattern matching. By design, variables occurring \nin open terms can never escape their scope. Using severalexamples, we demonstrate that our framework \nprovides a name-safe foun\u00addation to operations typically found in nominal systems. In con\u00adtrast to nominal \nsystems however,we also support capture-avoiding substitution operations and even provide .rst-class \nsubstitutions to the programmer. The main contribution of this paper is a syntax\u00addirected bi-directional \ntype system where we distinguish between the data language and the computation language together with \nthe progress and preservation proof for our language. Categories and Subject Descriptors D.3.1[Programming \nLan-guages]:Formal De.nitions and Theory GeneralTerms Theory, Languages Keywords Type theory, logical \nframeworks 1. Introduction Typed functional programming languages are particularly suited for analyzing \nand manipulating syntactic structures and are per\u00advasively used for implementing object languages. Although \nmany object languages include binding constructs, it is striking that typed functional languages still \nlack direct support for binders and com\u00admon trickyoperations such as renaming, capture-avoiding substi\u00adtution, \nand fresh name generation. The most common approach in practice is to implement binders via de Bruijn \nindices, which at least provides for a-renaming. While this leads to an ef.cient im\u00adplementation, analyzing \nand especially manipulating data can be Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. POPL 08, January 7 12, 2008, San Francisco, California, USA. Copyright c &#38;#169; \n2008ACM 978-1-59593-689-9/08/0001...$5.00 cumbersome and error-prone. Capture-avoiding substitution must \nbe implemented separately. Nominal approaches (Gabbay and Pitts 1999) as found in FreshML (Shinwell et \nal. 2003) provide .rst\u00adclass names and a-renaming. This approach is appealing because it gives us direct \naccess to names of bound variables. The genera\u00adtion of a new name and binding names are separate operations \nand fresh name generation is an observable side effect.Unfortunately, this means that it is possible \nto generate data which contains acci\u00addentally unbound names.To address this problem, Pottier (2007) recently \nproposed pure FreshML where one can reason about the setof names occurringinanexpressionviaaHoare-styleproofsys\u00adtem. \nThis static analysis approach is quite expressive since the lan\u00adguage of constraints includes subset \nrelations, equality, and inter\u00adsection. Nevertheless, the programmer needs to implement capture\u00adavoiding \nsubstitution manually. In higher-order abstract syntax (HOAS) we represent binders in the object-language \nvia binders in our meta-language (i.e. func\u00adtional programming language). One of thekeybene.ts is that \nwe not only get support for renaming and fresh name generation,but also for capture-avoiding substitution. \nConsequently, it is typically easier to ensure correctness and reason about HOAS representa\u00adtions, since \ntedious lemmas about substitutions and fresh names do not need to be proven. The strengths of HOAShave \nbeen impres\u00adsively demonstrated within the logical framework LF (Harper et al. 1993) and its implementation \nin theTwelf system (Pfenning and Sch\u00a8urmann1999)overthepast decade.However,HOAShasrarely been considered \nin real programming languages (example include Washburn andWeirich (2006); Guillemette and Monnier (2006)). \nTo illustrate the dif.culty, we de.ne a small language with let\u00adexpressions and arithmetic operations. \nThe let-expression is de.ned via higher-order abstract syntax, i.e. the binder in the let-expression \nis represented via a binder in our meta-language. We distinguish between natural numbers and expressions, \nand variables in expres\u00adsions represent only values. exp: type . nat: type . Nat: nat . exp. z: nat. \nAdd: exp . exp . exp. suc: nat . nat. Let: exp . (nat . exp) . exp. The expression let val x = 1 in \nAdd(0, x) end is repre\u00adsented as Let (Nat(suc z)) (.x.Add (Nat z) (Nat x)) in our meta-language. When \nwe recursively analyze the body of the let-expression, we must analyze Add (Nat z) (Nat x) which contains \na free variable x and hence is an open term. Moreover, we often also want to manipulate the variable \nx and compare it to other variables. However, HOAS encodings do typically not allow us to directly access, \nmanipulate and compare bound variables. The message of this paper is that we can recursively analyze \nand manipulate open data, which is de.ned via HOAS and may contain variables, and safely add this functionality \nto typed functional pro\u00adgramming. In particular, we can support operations such as analyz\u00ading and comparing \nboundvariables.By design,variables occurring in open data can never escape their scope thereby avoiding \na prob\u00adlem prevalent in previous attempts. Our framework therefore may be seen as a name-safe alternative \nfoundation for the operations typically supported in nominal systems. However, in addition to supporting \nbinders and a-renaming, we provide capture-avoiding substitution operation together with .rst-class substitution. \nBuildingon ideasbyNanevskietal. (2006),we designa type\u00adtheoretic foundation for programming with HOAS \nand substitu\u00adtions based on contextual modal types. The contextual modal type A[.] classi.es open data \nM where M has type A in the context .. Consequently, the object M may refer to the variables declared \nin the context .,but M is closed with respect to the context .. The data-object Add (Nat (suc z)) (Nat \nx) from the previous ex\u00adample has type exp in the context x:nat. Generalizing ideas from Despeyroux et \nal. (1997), data of type A[.] may be injected into the computation level and analyzed via pattern matching \nvia the box-construct thereby separating data from computations.Sincewewanttoallow recursionoveropendataob\u00adjects \nand the local context . which is associated with the type A may grow, our foundation supports context \nvariables and abstrac\u00adtion over contexts. Consequently, different arguments to a compu\u00adtation may have \ndifferent local contexts and we can distinguish be\u00adtween data of type A[\u00b7], which is closed, and open \ndata of type A[.]. This gives us .ne-grained control and allows us to specify strong invariants. Our \ntype-theoretic foundation based on contex\u00adtual modal types is substantially different from previous propos\u00adals \nto marry HOAS with functional programming as proposed by Sch\u00a8urmannetal. (2005).InSch\u00a8urmannetal. (2005),the \nnecessity modality Dt describes computation of type t which can be exe\u00adcuted in every world where we \nhave at least one context extension. The context containing binding occurrences is hence left implicit \nand associated with a computation. As a consequence, every ar\u00adgument of the computation must share one \nglobal context. While Sch\u00a8urmann swork does provide for capture-avoiding substitution via \u00df-reduction, \nit lacks the support to construct substitutions as .rst-class objects. The type of a substitution in \nour framework will be .[F] where . describes the domain and F the range. In other words, the substitution \nof type.[F] maps boundvariables declared in the context . to objects which may refer to the bound variables \ndeclared in F.We believe this foundation provides general insights into how open data-objects can be \nunderstood type-theoretically and incorporated as .rst-class into programming languages. The main contribution \nof this paper are: We present a syntax-directed decidable bi-directionaltype sys\u00adtem for open data and \nsubstitutions based on contextual types. By design, variables occurring in open data objects cannot es\u00adcape \ntheir scope, and no separate reasoning about scope is re\u00adquired (Section 3).Followinga recentpresentation \ntechnique for logical frameworks due toWatkins et al. (2002) our syntax only allows for objects which \nare in canonical form since only these are meaningful for representing object-languages. Conse\u00adquently, \nexotic terms that do not represent legal objects from our object-language are prevented.  Extending \nour previouswork (Pientka and Pfennning 2003),we present a linear higher-order pattern matching algorithm \nfor open data and substitutions together with its correctness proof (Section 3.4).We also discuss the \ntrade-offs and costs of con\u00adsidering the full pattern fragment as de.ned by Miller (1991) versus linear \nhigher-order patterns (Section2and Section 3.4).  Using several examples (Section 2), we show that our \nframe\u00adwork may be seen as a name-safe foundation to operations typ\u00ad  ically found in nominal systems \nwhile at the same time also providing for capture-avoiding substitutions together with .rst\u00adclass substitutions. \nWe present a syntax-directed decidable bi-directionaltype sys\u00adtem for computation whichallowsrecursion \nand pattern match\u00ading on open data and substitutions (Section 4) together with a small-step operational \nsemantics (Section 5). Open data is in\u00adjected into computation via the box-construct. The driving force \nbehind the operational semantics is the higher-order matching algorithm describedin Section3.4.Thekey \ntoa cleanandel\u00adegant meta-theory is our distinction between bound variables in data, contextual variables \nwhich may be instantiated via pat\u00adtern matching with data, context variables,andbound variables in computations. \nEach of these variables gives rise to their own substitution de.nition and theyplaya central rolein de.ning \nour operational semantics. Building on different substitution properties, we prove type preservation \nandprogress. We believe our calculus is an important step towards under\u00adstanding syntactic structures \nwith binders, and how one can pro\u00advide direct support for binders in the setting of typed functional \nprogramming. More generally, it provides a type-theoretic founda\u00adtion for open data-objects which play \nan important role in many areas of computer science beyond programming with higher-order abstract syntax, \nsuch as explaining linking of code, or staged com\u00adputation (see for example (Kim et al. 2006)). 2. Motivation \nIn this section we brie.y discuss four small examples to illustrate the main ideas behind our approach. \nThe examples are purposely simpleto emphasizethekeyfeaturesof ourworkandwekeepthe notation as close as \npossible to the theoretical foundation. In all our examples, we consider a small language with let-expressions \nand arithmetic operations which we introduced earlier. Counting occurrences of a variable In the .rst \nexample, we show how to count the occurrences of a particular variable in a given data-object.Weexploitthepowerof \nhigher-order patternsto accomplish this. The function cntV takes in a context . of natural numbers, and \na data-object e of type exp[.,x:nat], i.e. an ex\u00adpression which may refer to the bound variables listed \nin the con\u00adtext (.,x:nat), and returns as a result an integer. Just as types classify data-objects and \nkinds classify types, we introduce con\u00adtext schemas to classify contexts. In the type declaration for \nthe function cntV we state that the context variable . has the context schema (nat) *. In other words \n. stands foradata-level context of the form x1:nat, ...,xn:nat.We represent contextual vari\u00adables which \nare instantiated via higher-order pattern matching with capital letters. rec cntV : . .:(nat) * .exp[.,x:nat] \n. int = . . . fn e . case e of box (.,x. Nat U[id.]) . 0 | box (.,x. Nat U[x]) . 1 | box (.,x. Let U[id.,x] \n(.y.W[id.,x,y])) . cntV i.l box(.,x. U[id.,x]) + cntV i.,y:nat l box(.,y,x. W[id.,x,y]) | box (.,x. Add \nU[id.,x] W[id.,x]) . cntV i.l box(.,x. U[id.,x]) + cntV i.l box(.,x. W[id.,x]) The function cntV isbuiltbya \ncontext abstraction . . which introduces the context variable . and binds every occurrence of . in the \nbody of the function. Next, we introduce the computation\u00adlevel variable e which has type exp[.,x:nat] \nby function\u00adabstraction. In the body of the function cntV we analyze objects of type exp[.,x:nat] by \ncase-analysis. As mentioned earlier, we separate data from computations via the box-construct. Holes \nin the pattern which are instantiated via higher-order pattern matching are characterizedbya closure \nU[s] consisting of a contextual variable U and a postponed substitution s. As soon as we know what the \ncontextual variable stands for, we apply the sub\u00adstitution s. In the example, the postponed substitution \nassociated with U is the identity substitution which essentially corresponds to a-renaming.Wewrite id. \nfor the identity substitution with domain .. Intuitively, one may think of the substitution associated \nwith contextual variables which occur in patterns as a list of variables which may occur in the hole. \nIn U[id.], for example, the contex\u00adtual variable U can be instantiated with anynatural number which either \nis closed, i.e. it does not refer to anybound variable listed in the context . or it contains a bound \nvariable from the context .. Torecursively analyzeexpressionswehaveto considerdifferent cases. The .rst \ncase box (.,x. Nat U[id.]) captures the idea that if we encounter a natural number which does not contain \noccurrencesof the boundvariable x then we return 0. In the second case box (.,x. Nat (U[x])) we pattern \nmatch against a hole which may refer to the bound variable x. The only time this case now succeeds, is \nfor a natural number which actually refers to x since this is the only case not already covered by the \n.rst case. In the third case box (.,x.Let U[id.,x] (.y.W[id.,x,y])) we analyzethe let-expression.To countthe \noccurrencesofthevariable x, we .rst count the occurrences in U[id.,x], and then count the occurrences \nin the body of the let-expression.To accomplish this, we mustextend the context with the declaration \ny:nat and pass the extended context(.,y:nat) to the recursivecall of cntV. Context applicationis describedby \ncntV i.,y:natl. The box-construct binds occurrences of data-level variables only. For example in box \n(.,y,x.U[id.,x,y]), the variables x and y are bound and subject to a-renaming. However we empha\u00adsize \nthat the context variable . is not bound by the box-construct in the branch ofa case-expression,but boundby \nthe context ab\u00adstraction . . . ... . In particular, . is not instantiated via pattern matching. One may \nthink that listing the bound variables explicitly in the box-construct is not necessary because they \nare determined by the type exp[.,x:nat]. However to support a-renaming of data-level variables, we explicitly \nlist the names of the bound vari\u00adables, and enforce that this list can be obtained by erasing all types \nfrom the context .,x:nat. In an implementation of our language based on de Bruijn indices this complication \ncan be eliminated. Extracting variables Next, we show how to compute the vari\u00adables occurringina data-object.We \nwill writea function which ac\u00adcepts a natural number of type nat[.] which may refer to bound variables \nlisted in the context ., and returns a data-object of type nat[.] option. If a bound variable occurs \nin the natural number then we return it, otherwise we return NONE. rec FVnat:. .:(nat) * .nat[.] . (nat[.]) \noption = . . . fn e . case e of box (..z) . NONE | box (..p[id.]) . SOME box(..p[id.]) | box (..suc U[id.]) \n. FVnat i.l box(.. U[id.]) Thekeyquestionishowdowe detectand pattern matchagainst a data-levelvariable? \nTo accomplish this, we use theparameter variable p.A parameter variable represents a bound variable and \ncan only be instantiated with a variable from the object level. Similar to meta-variables they are treated \nas closures. In contrast to meta-variables which can be instantiated with an arbitrary object and are \nrepresented by capital letters, we will use small letters for parametervariables.Parametervariables allowusto \nwriteexplicitly a case for matching against variables and allow us to collect them, and even compare \nthem. Given the function FVnat, it should be obvioushowtowriteafunctionwhich collectsallthefreevariables \noccurring in a let-expression. Closed value Sofar ourexamples onlyutilized one context and didn t exploit \nthe power that we are able to distinguish between different contexts. For example, we may want to write \na simple function which tests whether a given natural number is closed, and hence constitutes avalue.It \nmaybeinfact importantin the later part of the program that we know that we have a closed value. This \ncanbeachievedbythe function isVal which not only tests whether agiven natural numberis closedbut also \nstrengthens the result. val isVal:. .:(nat) * . nat[.] . (nat[.]) option = . . . fn e . case e of box \n(..U[.]) . SOME box(U[.]) | box (..U[id.]) . NONE In the .rst case we test whether the input is closed, \nand if it is we return it in a strengthened context. While in other approaches we can recursively analyze \nobjects and thereby check whether they are a closed value, the property of being closed is usually harder \nto capture in current type systems. Environment-based interpreter Finally, we give an example which uses \n.rst-class substitutions and substitutionvariables which our foundationprovides.Thetaskistowriteasimpleenvironment\u00adbased \ninterpreter for the language we have de.ned earlier, where we take in a context . of natural numbers, \nan expression e of type exp[.] and an environment r which maps variables declared in the context . to \nclosed values. The environment is represented as a substitution with domain . and range empty and has \nthe type .[.]. The result of the interpreter is a closed value. Similar to the box-construct which injects \nopen data-objects into the compu\u00adtation, we use the sbox-construct to inject data-level substitutions \ninto the computation.We will use capital letters S to describe sub\u00adstitutionvariables whichmay occurin \npatterns,and similarto other contextual variables we think of substitution variables as closures, providingabuilt-in \noperation for composingsubstitutions. rec eval:. .:(nat) * . exp[.] . .[.] . nat[.] = . . . fn e . fn \nr . let sbox (S[.]) = r in case e of box (..Nat U[id.]) . box(U[S[.]]) | box (..Add U1[id.] U2[id.]) \n. let val a = eval i.l box(..U1[id.]) r val b = eval i.l box(..U2[id.]) r in add(a, b) end | box (..Let \nW[id.](.x. U[id., x])) . let box V[.] = eval i.l box(..W[id.]) r in eval i.,x:natl box (.,x. U[id.,x]) \nsbox(S[.], V[.]) end end When we encounter a natural number as in the .rst case, we can simply apply \nthe substitution S[.] to the object U. Since the substitution S[.] has domain . and range empty, applying \nit to the meta-variable U yields a closed object. Because we apply S[.] as soon as we know what U stands \nfor, the variable occurring in the instantiation for U will now be replaced by its correct corre\u00adspondingvalue. \nClosures thereby provide us withbuilt-in support for substitutions. The type system guarantees that the \nenvironment r provides closed instantiations for every variable in the local con\u00adtext .,and applying \nthe substitutionS[.] to the contextualvariable U must yield a closed natural number. When evaluating \nbox (..Let W[id.](.x.U[id.,x])), we evaluate the expression box (..W[id.]) in the environment r to some \nclosed value V, and then evaluate box (.,x.W[id.,x]) in the extended environment where we associate the \nbinder x with the valueV. Sincewe thinkof substitutionsbyposition,wedonotmake their domain explicit and \nsimply write sbox (S[.], V[.]) In traditional approaches where names are .rst-class, as in FreshML,or \nwherevariables are representedbystringsorde Bruijn indices, environments are usually implemented as a \nlist of pairs consisting of variable name and their corresponding value. How\u00adever, the type system cannot \neasily guarantee that the environment indeed provides closed values for all free variables occurring \nin theexpression.Moreover, one needsto writea lookup-functionfor retrieving a value from the environment \nand a substitution func\u00adtion for replacing the occurrence of the free variable with its cor\u00adresponding \nvalue. In contrast, our foundation enforces a strong invariant about the relationship between the expression \nwe are an\u00adalyzing and the environment. Remark: Higher-order pattern matching and its trade-offs We would \nlike to emphasize that our interest is in designing a type-theoretic foundation for programming with \nHOAS and the code snippets presented are intended to model our theory closely to provide an intuition. \nIt is not necessarily intended as the source language which a programmer would use. As mentioned earlier, \nwe treat contextual variables uniformly as closures and allow full higher-order pattern matching to instan\u00adtiate \ncontextual variables. In higher-order patterns (Miller 1991), the substitution associated with contextual \nvariables must consist of some distinct bound variables, and pattern matching must en\u00adforce checks on \nbound variables. The cost of checking for variable dependencies is hidden from the user (see for example \nthe func\u00adtion cntV or isVal). Linear higher-order patterns (Pientka and Pfennning 2003) restrict higher-order \npatterns such that every con\u00adtextualvariable mustbe appliedto all the bound variables in whose scope \nit occurs. In this case no bound variable dependencychecks are necessary (see Section 3.4) yielding an \nef.cient matching al\u00adgorithm closely resembling .rst-order matching. Our foundation leaves implementors \na choice of whether to enforce linear higher\u00adorder patterns dynamically or statically.To enforce them \ndynami\u00adcally, one translates every pattern into a linear one with potentially additional constraints \n(see (Pientka and Pfennning 2003)). Conse\u00adquently, only if bound variable checks are necessary, theywill \nbe done. Alternatively, if we enforce it statically, then all contextual variables must be applied to \nall the bound variables. In this case, contextualvariables occurringin patterns canbe simply described \nby U or p and not as closure U[id.] and p[id.].To check whether an object depends onaboundvariable we \ncan writeaseparate func\u00adtion.To illustrate, we presenta function for counting occurrences of a variable \nx in a natural number. rec cntVN : . .:(nat) * .nat[.] . nat[.] . int = . . . fn e . fn e . let box (.. \np [id.]) =e in case e of box (.. z) . 0 | box (.. p[id.]) . if box (..p [id.]) = box(.. p[id.]) then \n1 else 0 | box (.. suc U[id.]) . cntVN i.l box(.. U[id.]) e end If we elide the identity substitutions \nassociated with the con\u00adtextual variables, we obtain a program which closely resembles the one we write \nin a nominal style1. Closures however provide us with direct built-in substitution operation. As shown \nin the 1There are two remaining differences: First, our foundation makes the context (= set of names) \nexplicit. This is necessary if we want to reason environment-based interpreter, the closure of meta-variable \nand substitution allows us to retrieve a value. Similarly, when im\u00adplementing a substitution-based interpreter, \nwe can use closures to propagate instantiation. Providing not only direct support for bindersbut also \nsubstitution,is the essencein higher-order abstract syntax. However, this discussion seems to suggest \nthat basic oper\u00adations provided by nominal systems can be explained by imposing special restrictions \non our foundation. Summary of key ideas We summarize here the fourkeyideas underlying ourwork: First, \nwe separate the data from the computation via the modality box. Second, every data-object is closed with \nrespect to a local con\u00adtext.For example, box (x1,x2.Add (Nat(suc x1)) (Nat x2) ) denotes a data-object \nof type exp[x1:nat,x2:nat]. The box\u00adconstruct introduces the bound variables x1 and x2. Third, we al\u00adlow \ncontext variables . and abstract over them on the computation level. This is necessary since the concrete \nbound variables occur\u00adring in a data-object are only exposed once we recursively traverse abinder,and \nthe context describing thesevariables maygrow. Con\u00adtext abstractionvia . bindsevery occurrenceof . in \ntheexpression e.Fourth, weprovide closures consistingofa contextual variable and a postponed substitution. \nWhen replacing the contextual vari\u00adable with a concrete object, we apply the substitution thereby pro\u00advidingbuilt-in \nsupport for substitutions.We support three kindsof contextual variables, meta-variables which can be \ninstantiated with an arbitrary object, parameter variables which can be instantiated with bound variables \nonly, and substitution variables which repre\u00adsent .rst-class substitutions. While meta-variables allow \nus to de\u00adconstruct arbitrary objects with binders, parametervariables allows usto manipulate namesof \nboundvariables directlyin computation. 3. Data-level terms, substitutions, contexts In this section, \nwe concentrate on the formal de.nition and type system for data-objects. The de.nition of computation-level \nex\u00adpressions which allow recursion and pattern matching on data\u00adobjects is discussed later in Section \n4. Our theoretical development is closely based on contextual modal type theory by Nanevski et al. (2006) \nwhich we extend with pairs and projections and more importantly with parameter variables and substitution \nvariables as well as context variables. For simplicity, we also restrict our data-objects to the simply-typed \nfragment, however the ideas can be extended to the dependently typed setting (see Nanevski et al. (2006) \nfor more details). Types A, B ::= P | A . B | A \u00d7 B NormalTerms M, N ::= .x. M | (M, N) | R NeutralTerms \nR ::= c | x | u[s] | p[s] | RN | projiR Substitutions s, . ::= \u00b7| s ; M | s, R | s[s] | id. Context Schema \nW ::= A | (W )* | W1 + W2 Contexts ., F ::= \u00b7| . | .,x:A Meta-contexts . ::= \u00b7| .,u::A[.] | .,p::A[.] \n| .,s::.[F] Context Schema context O ::= \u00b7| O,.::W Following a recent presentation technique for logical \nframe\u00adworks due toWatkins et al. (2002) our syntax only allows for ob\u00adjects which are in canonical form \nsince only these are meaningful about the closedness of an object, and is also done for example in pure \nFreshML by Pottier (2007). Since context schemas classify contexts, we naturally can distinguish between \ndifferent sets of names. Second, unlike nominal type systems which have a special type atom for names, \nour type system does not distinguish between a type for names and objects. for representing object-languages. \nThis is achieved by distinguish\u00ading between normal terms M and neutral terms R. While the syntax only \nguarantees that terms N contain no \u00df-redices, the typing rules will also guarantee that all well-typed \nterms are fully .-expanded. We distinguish betweenfourdifferentkindsofvariablesin our theory: Ordinary \nbound variables are used to represent data-level binders andare boundby .-abstraction. Contextual variables \nstand for open objects and they include meta-variables u which repre\u00adsent general open objects and parameter \nvariables p which can only be instantiated with an ordinary bound variable, and substi\u00adtution variables \ns which represent a mappingfrom one context to another. Contextualvariables are introducedincase-expressionson \nthe computation level, and can be instantiated via pattern matching. They are associated with a postponed \nsubstitution s thereby repre\u00adsenting a closure. Our intention is to apply s as soon as we know which \nterm the contextual variable should stand for. The domain of s therefore describes the free variables \nwhich can possibly occur in the object which represents the contextual variable, and our type system \nwill ensure statically that this is indeed the case. Substitutions s arebuilt of either normal terms \n(in s ; M)or atomic terms (in s, R).We do not make the domain of the sub\u00adstitutions explicit. This will \nsimplify the theoretical development andavoidhavingto renamethe domainofagiven substitution s. Similarto \nmeta-variables, substitutionvariables are closures witha postponed substitution.We also requirea .rst-class \nnotionof iden\u00adtity substitution id.. Our convention is that substitutions, as de.ned operations on data-level \nterms, are written in pre.x notation [s]N for a data-level substitution. Contextual variables such as \nthe meta\u00advariables u, parameter variables p, and substitution variables s are declared in the meta-context \n., while ordinary boundvariables are declared in the context .. Finally, our foundation supports context \nvariables . which al\u00adlow us to reason abstractly with contexts. Abstracting over con\u00adtexts is an interesting \nand essential next step to allow recursion over higher-order abstract syntax. Contextvariables are declaredin \nthe context O. Unlike previous uses of context variables for exam\u00adple in (McCreight and Sch\u00a8urmann 2004), \na context may at most contain one context variable. In the same way as types classify objects, and kinds \nclassify types, we will introduce the notion of a context schema W which classi.es contexts .. We will \nsay a context . belongs to context schema W or a context . is an el\u00adement of the context schema W , if \nit consists of declarations x:A where A occurs in W . Context schemas are described by a sub\u00adsetofregularexpressions.Forexample,a \ncontext schema A + B describes anycontext which contains declarations of the form x:A or y:B. Concept \nschemas resemble the notion of worlds described in (Sch\u00a8urmann 2000), however while similar in spirit, \nwe simplify mattersbydrawingonthepowerofpairsand cross-productstoex\u00adpress the relationship between multiple \nobjects in a context. Weassume that type constants and object constants are declared ina signature S \nwhich we typically suppress since it never changes duringa typing derivation.However,we willkeepin mind \nthatall typing judgments have access to a well-formed signature. 3.1 Data-level typing Next, we present \na bi-directional type system for data-level terms. Typing is de.ned via the following judgments: O; .; \n. f M . A Check normal object M against A O; .; . f R . A Synthesize A for neutral object R O; .; F f \ns . . Check s against context . O f . . W Context . checks against schema W For better readability, \nwe omit O in the subsequent develop\u00adment since it is constant and assume that context . and . are well-formed. \nFirst, the typing rules for objects.We will tacitly re\u00adname bound variables, and maintain that contexts \nand substitutions declare no variable more than once. Note that substitutions s are de.ned only on ordinary \nvariables x and not contextual variables. Moreover, we require the usual conditions on boundvariables.For \nexample in the rule for .-abstraction the bound variable x must be new and cannot already occur in the \ncontext .. This can be always achieved via a-renaming.Weare alsoexplicit about a-renaming in the rule \nfor substitution variables where a describes equality be\u00ad = tween two contexts up to renaming. Data-level \nnormal terms .; .,x:A f M . B .; . f R . P ' P ' = P .; . f .x. M . A . B .; . f R . P .; . f M1 . A1 \n.; . f M2 . A2 .; . f (M1,M2) . A1 \u00d7 A2 Data-level neutral terms x:A . . c:A . S .;. f R . A1 \u00d7 A2 .; \n. f x . A .; . f c . A .; . f projiR . Ai u::A[F] . . .;. f s . F p::A[F] . . .;. f s . F .; . f u[s] \n. A .; . f p[s] . A .; . f R . A . B .; . f N . A .; . f RN . B Data-level substitutions .; . f \u00b7.\u00b7 .; \n., . f id. . . a s::F1[F2] . . .; . f . . F2 F = F1 .; . f (s[.]) . F .; . f s . F .; . f R . A' A = \nA' .; . f (s, R) . (F,x:A) .; . f s . F .;. f M . A .; . f (s ; M) . (F,x:A) In the simultaneous substitutions \ns, we do not make its domain explicit. Rather we think of a substitution as a list of normal and neutral \nterms, and if s has domain . the i-th element in s corre\u00adsponds to the i-th declaration in ..We can turn \nany substitution s which does not make its domain . explicit into one which does by s/.. We distinguish \nbetween substituting a normal term M and a neutral term R. Thisis justi.edby the natureofhypotheti\u00adcal \njudgments, since an assumption x:A represents x . A so we can substitute R for x if R . A. This distinction \nbetween normal and neutral terms is necessary since we can extend a given simul\u00adtaneous substitution \ns with x and obtain (s, x) when traversing a binding operatorinatype-freeway.Wecouldnotextendthe simul\u00adtaneous \nsubstitutions with (s ; x), since x is not a canonical term unless it is of atomic type. Identity substitutions \ncan now have the form (x1 ,... ,xn). The typing rules for substitutions also make clear that the identity \nsubstitution id. is necessary once we intro\u00adduce context variables. Without the identity substitution \nid., we wouldn tbe able to construct substitutions where the domain is de\u00adscribed abstractly by the context \nvariable .. Finally, we present context schema checking. Context . checks against a context schema W \nA . W O f . . W.::W . O O f .,x : A . W O f . . W O f \u00b7. W Essentially a context is well-formed, if every \ndeclaration xi:Ai is declared in the context schema W = A1 + A2 + ... + An. A . W succeeds if W =(A1 \n+ ... + An) * and there exists an Ai s.t. A = Ai. Theorem 3.1. [DecidabilityofType Checking] All judgments \nin the contextual modal type theory are decidable.  3.2 Substitution Since we have different kinds \nof variables, context variables ., or\u00addinaryvariables x,and contextualvariables,thisgivesrisetodiffer\u00adent \nsubstitution operations. These different substitution operations Each of these hereditary substitution \noperations will be de.ned by nested induction, .rst on the structure of the type A and second on the \nstructure of the objects N, R, and s. In other words, we either go to a smaller type, in which case the \nobjects themselves can become larger, or the type remains the same and the objects become smaller. We \nwrite A = B and A<B if A occurs in B (as a proper subexpression in the latter case). For an in depth \ndiscussion, we refer the reader to (Nanevski et al. 2006). Data-level normal terms '' where N [M/x] nA \n(.y. N)= .y. N =[M/x] nA (N) choosing y . FV(M), and y arekeyto the elegant and simple preservation and \nprogress proof. = x (M1)= N1 and if [M/x] nAnA [M/x](M1,M2)=(N1,N2) Substitution for context variables \n[M/x] nA (M2)= N2 We begin by considering the substitution operation for context '' : A ' if [M/x] nArA \n[M/x] (R)= M (R)= M variables. The most interesting cases are where actual substitution R ' (R)= R ' \nif [M/x] nArA [M/x] (R)= happens. If we encounter a context variables ., then we simply replace it with \nthe context .. When we apply the substitution fails otherwise nA [M/x] (N) [[./.] to the context F,x:A, \nwe apply the substitution to the Data-level neutral terms context F to yield some new context F '. However, \nwe must check [M/x] r()xA = M : A whether x occurs in the variables declared in F ', i.e. x . V(F ' ), \nif y rArA [M/x] (y)= y = x u[s ' ] where s ' to avoid name clashes. This side condition can always be \nmet by sA [M/x] (u[s]) =[M/x](s) appropriately renaming bound variable occurrences. = p[s ' ] where \ns ' rAsA [M/x] (p[s]) =[M/x](s)= Data-level context ' R ' N where R ' (R) and rArA [M/x] (RN) =[M/x]= \n' nA (N) N =[M/x] [[./.]](\u00b7) = \u00b7 [[./.]](F, x:A) = (F ' , x:A) if x . V(F ' ) and [[./.]]F = F ' [[./.]](.) \n= . [[./.]](f) = f '' rA [M/x] (RN)= M : B ' if [M/x] :A1 . B where rA (R)= .y. M ' A1 . B = A and N \nnA (N)=[M/x] and M '' =[N ' /y](M 1 ' ) nA The remaining de.nition is mostly straightforward. Since, \ncon\u00ad [M/x] rA (proji R)= Ni : Ai text variables occur in the identity substitution id., we must apply \nif [M/x] rA (R)=(N1,N2):A1 \u00d7 A2 the context substitution to objects and in particular to substitutions. \nWhen we replace . with . in id., we unfold the identity sub\u00ad proji R ' (R)= R ' if [M/x] rA rA [M/x] \n(proji R)= fails otherwise rA [M/x] (R) stitution. Expansion of the identity substitution is de.ned by \nthe operation id(.) for valid contexts . as follows: Data-level substitution sAsA [M/x] (\u00b7) id(\u00b7) = \u00b7 \n= \u00b7 id(.,x:A)= id(.) ,x (s ' ; N ' ) where s ' sA (s) [M/x] (s ; N) =[M/x]= ' and N id(.)= id. =[M/x] \nnA (N) (s ' ,R ' ) (R)= R ' if [M/x] sArA Lemma 3.1. [Unfolding identity substitution] [M/x] (s, R) \n= and s ' sA If id(.) = s then .; ., . ' f s . .. =[M/x](s) (s ' ; M ' ) ' : A ' if [M/x] sArA [M/x](s, \nR) (R)= M= Theorem 3.2. [Substitution for context variables] and s ' sA =[M/x](s) If O,.::W, O ' ; .; \nF f J and O f . . W s[s ' ] where s ' sAsA (s) [M/x] (s[s]) =[M/x] then O, O ' ; [ ./.]].; [[./.]](F) \nf [[./.] J. = sAsA [M/x] [M/x] (id.)= id. (s) fails otherwise Ordinary substitution In the de.nition \nfor ordinary data-level substitutions, we need to bea littlebit careful because the only meaningful data-level \nterms are those which arein canonical forms.To ensure that substitution If the original term is not well-typed, \na hereditary substitution, though terminating, cannot always return a meaningful term. We formalize thisasfailureto \nreturna result.However,on well-typedpreserves canonical forms, we will employa technique pioneered terms, \nhereditary substitution will always return well-typed terms. byWatkins et. al. (Watkins et al. 2002) \nand described in detail in (Nanevski et al. 2006). The idea is to de.ne hereditary substitu-Theorem 3.3. \n[Termination] tion as a primitive recursive functional which will always return a 1. If [M/x] rA (R)= \nM ' : A ' then A ' = A canonical object. In places where the ordinary substitution would *2. [M/x]A \ny in M. Since this could again create a redex, we must continue after a .nite number of steps. and hereditarily \nsubstitute and eliminate potential redices.We de- Theorem 3.4. [Hereditary Substitution Principles].ne \nthe hereditary substitution operations for normal object, neutral If .; . f M . A and .; .,x:A, . ' f \nJ thenobjects and substitutions next. f [M/x] * () terminates, either by returning a result or failingconstruct \na redex (.y. M) N we must continue, substituting N for .; ., . ' (J) where * = {n, r, s}. n A ' Hereditary \nsubstitution into N Building on the discussed ideas and extending (Nanevski et al. .(M) nA [M/x] (N)= \nN 2006), we can de.ne also simultaneous substitution (R)= R ' or M ' : A ' [s] Hereditary substitution \ninto R rA [M/x] s r ([s].(R), [s].(s) resp.). (s)= s ' Hereditary substitution into s sA Contextual \nsubstitution for contextual variables Substitutions for contextualvariables area little more dif.cult.We \ndiscuss next the three kinds of contextual variables, meta-variables u, parameter-variables p, and substitution \nvariables s. Contextual substitutionfor meta-variables We can thinkofu[s] as a closure where, as soon \nas we know which term u should stand for, we can apply s to it. The typing will ensure that the type \nof M and the type of u agree, i.e. we can replace u which has type A[.] with a normal term M if M has \ntype A in the context .. Because of a-conversion, the variables that are substituted at dif\u00adferent occurrences \nof u may be different, and we write the con\u00adtextual substitution as [ . .M/u] n (N), [ . .M/u] r (R), \nand A[.]A[.] [ . .M/u] s (s), where . binds all free variables in M. This A[.] complication can be eliminated \nin an implementation of our cal\u00adculus based on de Bruijn indexes. The typing annotation A[.] is necessary \nsince we apply the substitution s hereditarily once we know which term u represents, and hereditary substitution \nrequires this information to ensure termination. In de.ning the substitution we must pay attention that \nnormal forms are preserved.We show contextual substitution into data-level terms next.For better read\u00adability, \nwe will write a as an abbreviation for the type A[.]. Data-level normal terms '' [ . .M/u] n(.y. N)= \n.y. N where [ . .M/u] nN = N aa '' ' [ . .M/u] n(N1,N2)=(N ,N ) where [ . .M/u] n(N1)= N a 12a 1 ' and \n[ . .M/u] n(N2)= N a 2 [ . .M/u] n(R)= R ' where [ . .M/u] r (R)= R ' aa '' [ . .M/u] n(R)= M where [ \n. .M/u] r (R)= M : A aa [ . .M/u] n(N) fails otherwise a Data-level neutral terms [ . .M/u] r (x)= x \na [ . .M/u] r (c)= c a [ . .M/u] r (u[s]) = N : A where [ . .M/u] s s = s ' aa and [s ' /.]n M = N . \n[ . .M/u] r (u ' [s]) = u ' [s ' ] where [ . .M/u] s s = s ' aa ' choosing u = u [ . .M/u] r (p[s]) = \np[s ' ] where [ . .M/u] s s = s ' aa [ . .M/u] r (RN) =(R ' N ' ) where [ . .M/u] r R = R ' aa ' and \n[ . .M/u] n(N)= N a ' [ . .M/u] r (RN)= M : A2 a if [ . .M/u] r R = .x. M0 : A1 . A2 for A1 . A2 = A[.] \na '' and [ . .M/u] n(N)= N and [N ' /x]n (M0)= M aA1 [ . .M/u] r (projiR)= projiR ' if [ . .M/u] r (R)= \nR ' aa [ . .M/u] r (projiR)= Mi : Ai a if [ . .M/u] r (R)=(M1,M2): A1 \u00d7 A2 a [ . .M/u] r (R) fails otherwise \na Applying [ . .M/u] r to the closure u[s] .rst obtains the si\u00ad A[.] multaneous substitution s ' = [ \n. .M/u] s s,but instead of re\u00ad A[.] turning M[s ' ], it proceeds to eagerly apply s ' to M. However before \nwe apply s ' to M we recover its domain by [s ' /.]. To enforce that we always return a normal object \nas a result of con\u00adtextual substitution, we carry the type of the meta-variable u which will be replaced. \nIn the case where we would possibly obtain a non-normal object, we resort to ordinary hereditary substitution \nin order to guarantee that the .nal result of contextual substitution is in normal form. Contextual substitutionforparameter \nvariables Contextual sub\u00adstitution for parameter variables follows similar principles, but it substitutes \nan ordinaryvariable foraparametervariable. This could not be achieved with the previous de.nition of \ncontextual substitu\u00adtion for meta-variables since it only allows us to substitute a nor\u00admal term for \na meta-variable and x is only a normal term if it is of atomic type. In the case where we encounter a \nparameter variable p[s], we replace p with the ordinary variable x and apply the sub\u00adstitution [ . .x/p] \nto s. This may yield a normal term, and hence we must again ensure that our contextual substitution for \nparame\u00adtervariables preserves normal forms.We only show here the case where substitution actually happens \nand again write a as an abbre\u00adviation for A[.]. [ . .x/p] r (p[s]) = M : A if [ . .x/p] s s = s ' and \naa [s ' /.]r x = M : A . [ . .x/p] r (p[s]) = R if [ . .x/p] s s = s ' and [s ' /.]r x = R aa . [ . \n.x/p] r (p ' [s]) = p ' [s ' ] where [ . .x/p] s s = s ' aa The distinction between parametervariables \nand meta-variables is mainly interesting from an operational point of view. Substitution for substitution \nvariables in data-level terms Fi\u00adnally, we give a brief de.nition for substituting for substitution variables.To \nensureitworks correctly withthepreviously de.ned substitution operations, we also annotate it with the \ntype of the sub\u00adstitutionvariable.Wewill abbreviate F[.] as c, and concentrate on the case for substitution. \n[ . .s/s] s(\u00b7)= \u00b7 c ' [ . .s/s] s(. ; N)=(. ' ; N ) if [ . .s/s] s. = . ' cc ' and [ . .s/s] nN = N c \n[ . .s/s] s(., R) =(. ' ,R ' ) if [ . .s/s] s. = . ' cc and [ . .s/s] rR = R ' c [ . .s/s] s(s[.]) = \ns ' if ([[. .s/s] s.)= . ' cc and [. ' /.]s s = s ' and c = F[.] . [ . .s/s] s(s ' [.]) = s ' [. ' ] \nif [ . .s/s] s. = . ' cc [ . .s/s] s(idf)= idf c [ . .s/s] s(.) fails otherwise c Applying [ . .s/s] \ns to the closure s[.] .rst obtains the si\u00ad F[.] multaneous substitution . ' = [ . .s/s] s .,but instead \nof return\u00ad F[.] ing s[. ' ], it proceeds to eagerly apply . ' to s. Theorem 3.5. [Termination] [ . .M/u] \n* (), [ . .x/p] * () A[F]A[F]and [ . .s] F[.]* () terminate, eitherby returninga result orfailing after \na .nite number of steps. Theorem 3.6. [Contextual Substitution Principles] 1. If .1;F f M . A and .1,u::A[F], \n.2;. f J then .1, .2;. f [ F .M/u] * J where * = {n, r, s}. A[F] 2. If .1;F f x . A and .1,p::A[F], .2;. \nf J then .1, .2;. f [ F .x/p] * J where * = {n, r, s}. A[F] 3. If .; F f s . .1 and .1,s::.1[F], .2;. \nf J then .1, .2;. f [ F .s/s] * J where * = {n, r, s}. .1[F]  3.3 Simultaneous contextual substitution \nOften it is convenient to allow simultaneous contextual substitu\u00adtion ..Typing rules for simultaneous \ncontextual substitutions can be de.ned via the judgment . ' f . . ., where . denotes the domain of the \ncontextual substitution . and . ' describes its range. Just as we annotate the contextual substitution \n[ . .M/u] A* [.] with the type of the meta-variable u, we annotate the simultaneous con\u00adtextual substitution \n. with its domain .. This is necessary because when applying the substitution . =(.1, . .M/u, .2) to \na closure u[s],we instantiateu withaterm M and then apply to it the substi\u00adtution [ .] s. Since the ordinary \nsimultaneous substitution operation is annotated with its domain, we annotate also the simultaneous contextual \nsubstitution with its domain. . ' . ' f . . . ;. f M . A . ' f\u00b7.\u00b7 . ' f (., . .M/u) . .,u::A[.] . ' \nf . . . x:A . .. ' f . . .. ' ;. f s . F . ' f (., . .x/p) . .,p::A[.] . ' f (., . .s/s) . .,s::F[.] \nDe.nition of the simultaneous contextual substitution is a straightforward extension of the previous \nsubstitution operation. Theorem 3.7. [Simultaneous contextual substitution] If . ' f . . . and .; . f \nJ then . ' ;. f [ .] * J where . * = {n, r, s}.  3.4 Linear higher-order pattern matching Data-level \nterms represent our data which we analyze via pattern matching in computations. In this section, we describe \na pattern matching algorithm for linear higher-order patterns. Linear higher\u00adorder patterns (Pientka \nand Pfennning 2003)are data-level terms where we impose the following two restrictions on contextualvari\u00adables: \nFirst, contextualvariables must occur uniquely. Second, they are applied to all bound variables in whose \nscope theyoccur. In our setting, this means the postponed substitution s associated with a contextual \nvariable must be a substitution which maps all variables to distinct variables. We will write p for the \nsubstitution which has domain and range .. The identity substitution is the simplest form of p,but in \ngeneral we can allow permutations of variables. As mentioned earlier, linear higher-order patterns re.ne \nthe notion of higher-order patterns as identi.ed by Miller (Miller 1991), and eliminateexpensive checks \nfor boundvariable dependencies.For the theoretical development, we enforce that every meta-variable must \nbe of base type. This can always be achieved by lowering. Pattern matching for data-level terms is then \nde.ned as follows: . .; . f M1 = M2/. Ground term M2 matches M1 .; . f R1 . R2/. Ground term R2 matches \nR1 . .; . f s1 = s2/. Ground substitution s1 matches s2 In the judgments describing matching we will \nkeep a context . which describes the ordinary variables occurring in M1 and M2 and R1 and R2 respectively. \nLet . describe the meta-variables, parameter variables and substitution variables. Only M1, R1, and s1 \nmay contain contextual variables which we will instantiate via matching. The result of matching M2 against \nM1 will be a contex\u00adtual simultaneous substitution . for all the contextual variables in M1, s.t. [ .] \nn M1 = M2 and [ .] r R1 = R2. .. Matching normal objects . .; . ,x f M = N/. .; . f R . R ' /. .. .; \n. f .x. M = .x. N/. .; . f R = R ' /. .. .1; . f M1 = M2/.1 .2; . f N1 = N2/.2 . .1, .2; . f (M1 ,N1)=(M2 \n,N2)/(.1,.2)) Matching neutral objects \u00b7; . f x . x/\u00b7\u00b7; . f c . c/\u00b7 u::P [. ' ]; . f u[p] . R/(. ' .[p]-1R/u) \np::A[. ' ]; . f p[p] . x/(. ' .[p]-1x/p) .; . f R . R ' /. .; . f projiR . projiR ' /. . .1; . f R1 . \nR2/.1 .2; . f N1 = N2/.2 .1, .2; . f R1 N1 . R2 N2/(.1,.2) This matching algorithm extends ideas on higher-order \npattern uni.cation (Pientka and Pfennning 2003; Pientka 2003) to handle parameter variables and substitution \nvariables. Note that we will only match a term against another if both have the same type. The interesting \ncases are when we match a neutral term R against a contextual modal variable u[p], a substitution s against \na substi\u00adtution variable s[p], and a parameter x against a parameter vari\u00adable p[p].We .rst consider \nmatching a neutral term R against the meta-variable u[p]. Since we require that all meta-variables u \nare applied to all bound variables whose scope theyoccur in, we can simply apply the inverse substitution \n[p]-1 to the object R. If p is a substitution with domain . ' and range . then [p]-1 is the substi\u00adtution \nwith domain . and range . '. Since we require that . ' is a permutation of ., applying the inverse substitution \n[p]-1 to R will only rename variables and must always succeed since all variables possibly occurring \nin R are in the range of p. If p is the identity substitution then we have [p]-1R = R.We note that the \nalgorithm aboveis strikingly similar to .rst-order matching algorithms. If one would like to allow the \nfull pattern fragment where meta-variables are only required to be applied to some bound variables, then \nwe must check whether applying the inverse substitution to the object R doesinfactexist. This requiresa \ntraversalof R.For a more de\u00adtailed discussion we refer the reader to (Pientka 2003). The rules for matchingagainst \nsubstitutions are straightforward. We note that wedo not consider the case of matching against the identity \nsubstitution id. since our operational semantics will en\u00adforce that all contextvariables have been instantiated \nand therefore all identity substitutions have been unrolled. Matching substitutions . . -1 \u00b7; . f\u00b7 = \n\u00b7/\u00b7 s::F[.]; . f s[p]= ./. .[p]./s .. .1; . f s = ./.1 .2; . f M = N/.2 . .1, .2; . f (s ; M)=(. ; N)/(.1,.2) \n.. .1; . f s = ./.1 .2; . f R = R ' /.2 . .1, .2; . f (s, R)=(., R ' )/(.1,.2) Soundness of linear \nhigher-order pattern matching ensures that if an object N pattern matches against an object M then [ \n.] n (M)= N. We require that M is indeed well-typed and is . a linear higher-order pattern, i.e. all \ncontextual variables occur uniquely and are applied to all bound variables whose scope they occur in, \nwhich is described by the judgment.; . fl J. Theorem 3.8. [Soundness of linear higher-order pattern matching] \n. 1. If .; . fl M . A and \u00b7;. f N . A and .; . f M = N/. then \u00b7f . . . and [ .] n M = N. . 2. If .; . \nfl R . A and \u00b7;. f R ' . A ' and A = A ' , .; . f R . R ' /. then \u00b7f . . . and [ .] r R = R ' . . . 3. \nIf .; . fl s . F and \u00b7;. f . . F and .; . f s = ./. then \u00b7f . . . and [ .] s s = .. . Proof. By structural \ninduction on the matchingjudgment. Theorem 3.9. [Completeness of higher-order pattern matching] 1. If \n.; . fl M . A and \u00b7;. f N . A and [ .] dnM = N and . \u00b7f . . . then .; . f M = N/.. l . A ' 2. If .; \n. fR . A and \u00b7;. f R ' , and A = A ', and \u00b7f . . . and [ .] rdR = R ', then .; . f R . R ' /.. 3. If \n.; . f s . F and \u00b7;. f . . F and \u00b7f . . . and  . [ .] sds = . then .; . f s = ./.. Proof. Induction \non M, R and s respectively. 4. Computation-level expressions Our goal is to cleanly separate the object \nlevel and the computation level. While the object level describes data, the computation level describes \nthe programs which operate on data.Computation-level types may refer to data-level types via the contextual \ntype A[.] which denotes an object of type A which may contain the variables speci.ed in ..Toallow quanti.cationover \ncontextvariables .,we introduce a dependent type ..:W.t where W denotes a context schema and context \nabstraction via ...e. We overload the . which is used to denote function types at the object level as \nwell as the computation level. However, it should be obvious from the usage which one we mean. Types \nt ::= A[.] | F[.] | t1 . t2 | ..::W.t Expressions e ::= y | rec f.e | fn y.e | ...e | e1 e2 | box(. .M) \n| sbox(. .s) | e i.l| (e : t ) | (case e of b1 | ... | bn ) Branch b ::= box(. .M) . e | sbox(. .s) \n. e | .p::A[.].b | .u::P [.].b | .s::F[.].b Contexts G ::= \u00b7| G,y:t Data can be injected into programs \nvia the box-construct box(. .M). Sine we do not need types inside objects, we write . for a list of variables \nx1,...,xn which we think of as a context . without types. Here M denotes an data-level term which has \ntype A in the context .. Annotating the box-construct with . , i.e. the list of variables occurring in \nM, is necessary due to a-conversion, and some renaming of bound variables may be necessary to bring the \nvariables in A[.] in accordance with the variables in . .M.We keep. asa proper context sinceinthe dependenttype \ncase A may depend on it. It is worth pointing out that in an implementation with de Bruijn indices this \ncomplication can be eliminated. Similarly, we can inject substitutions sbox(F .s) which are of type .[F] \nwhere . is the domain of the substitution s and F is its range.Due to a-conversion issues we list the \nvariables occurring in the range of the substitution. Since substitutions can be viewed as pairs betweenvariables \nanddata-level terms, thisfacility essen\u00adtially allows us to model explicit environments. Finally, we \nallow pattern matching on data-level terms via case-expression. In our case-expression, we explicitly \nabstract over contextual variables which occur in the pattern using the .-quanti.er, however this pre.x \ncan always be reconstructed. This will simplify our meta\u00adtheoretic development. 4.1 Typing rules for \ncomputation level Next, we present bi-directional typing rules for programs which will minimize the amount \nof typing annotations. We distinguish here between typing of expressions and branches. In the typing \njudgment, we will distinguish between the context O for context variables, the context for contextual \nvariables ., and the con\u00adtext G which includes declarations of computation-level variables. Context variables \nwill be introduced via context abstraction. The contextual variables in . are introduced in the branch \nof a case\u00adexpression, and computation-level variables in G are introduced by recursion or functions. \nO; .; G f e . t check an expression e against t O; .; G f e . t synthesize t for expression e O; .; G \nf b : t ' . t branch b checks against t ' . t Branches b are of the form .. ' .box(. .M) . e, where \n. ' contains all the contextual variables occurring in box(. .M). The judgment for checking branches \nthen stipulates that the guard box(. .M) checks against t ' and the expression e checks against the type \nt. The typing rules for expressions are next. Expressions O,.:W ; .; G f e . t O; .; G,f:t f e . t O; \n.; G f ...e . ..:W.t O; .; G f rec f.e . t O; .; G,y:t1 f e . t2 O; .; G f fn y.e . t1 . t2 O; .; . \nf M . A O; .; . f s . F O; .; G f box(. .M) . A[.] O;.;G f sbox(. .s) . F[.] O; .; G f e . A[.] for all \ni O; .; G f bi : A[.] . t O; .; G f case e of b1 | ... | bn . t O; .; G f e . F[.] for all i O; .; G \nf bi : F[.] . t O; .; G f case e of b1 | ... | bn . t '' O; .; G f e . tt = t O; .; G f e . t O; .; G \nf e . t O; .; G f (e : t) . t y:t . G O;.;G f e . ..:W.t O f . . W O; .; G f y . t O; .; G f e i.l. [[./.] \nt O; .; G f e1 . t2 . t O; .; G f e2 . t2 O; .; G f e1 e2 . t Branches O; . ' ;. fl M . A O; (., . ' \n); G f e . t O; .; G f .. ' .box(. .M) . e : A[.] . t O; . ' ;. fl s . F O; (., . ' ); G f e . t O; .; \nG f .. ' .sbox(. .s) . e : F[.] . t We observe the usual bound variable renaming conditions in the rule \nfor function abstraction, recursion, and context abstrac\u00adtion. Contextvariables areexplicitly quanti.edandboundby...e. \nThere areafew interesting issues which deserve attention: Firstthe typing rule for box(. .M). M denotesadata-level \nterm whose free variablesarede.nedinthe context.,i.e. it is closed with respect to acontext..Totype box(. \n.M) we switch to data-level typing, and forget about the previous context G which only describes assump\u00adtions \non the computation level. Our typing rules will ensure that all variables occurring in M must have been \ndeclared in the context .. Similar reasoning holds for the typing rule for sbox(. .s). In both cases, \nsome renaming may be necessary to apply the typing rule to bring the variables in A[.] in accordance \nwith the variables in . .M.To accessdata,weprovidea case-expressionwith pattern matching. The intention \nis to match against the contextual modal variables occurring in the pattern. When type-checking a branch, \nwe appeal to a linear typing judgment O; . ' ;. fl M . A, which ensures that all contextual variables \noccur linearly and are higher\u00adorder patterns. Theorem 4.1. [DecidabilityofType Checking] Type-checking \ncomputation-level expressions is decidable. Proof. The typing judgments are syntax-directed and therefore \nclearly decidable. Due to space constraints, we omit here the substitution de.\u00adnitions [e/x]e ' and extensions \nof previous substitution operations such as [[./.]](e) and [ .] .(e). The de.nitions are mostly straight\u00adforward. \n5. Operational semantics In this section, we describe a small-step operational semantics for the presented \nlanguage. During execution type annotations are unnecessary, and we de.ne evaluation only on expressions \nwhere all type annotations have been erased. First, we de.ne the values in this language. Value v ::= \nfn y.e | ...e | box(. .M) | sbox(. .s) Next, we de.ne a small-step evaluation judgment: e -. e ' e evaluates \nin one step to e ' . . ' (box(. .M)= b) -. e Branch b matches box(. .M) and steps to e ' . ' (sbox(. \n.s)= b) -. e Branch b matches sbox(. .s) and steps to e ' Evaluation relies on pattern matching and evaluating \nbranches. The casefor function applicationis straightforward.Valuesforpro\u00adgram variables are propagated \nby computation-level substitution. Instantiations for context variables are propagated by applying a \nconcrete context . to a context abstraction ...e. rec f.e -. [rec f.e/f]e (fn y.e) v -. [v/y]e e1 -. \ne1 ' e2 -. e2 ' (e1 e2) -. (e1 ' e2)(ve2) -. (ve2' ) e -. e ' e i.l -. e ' i.l (...e) [.] -. [[./.] e \ne -. e ' (case e of b1 | ... | bn ) -. (case e ' of b1 | ... | bn ) . \u00b7f box(. .M)= bi -. e ' (case (box(. \n.M)) of b1 | ... | bn ) -. e ' . \u00b7f sbox(. .s)= bi -. e ' (case (sbox(. .s)) of b1 | ... | bn ) -. e \n' Evaluation in branches relies on higher-order pattern matching against data-level terms to instantiate \nthe contextual variables oc\u00adcurring in a branch and data-level instantiations are propagated via contextual \nsimultaneous substitution.We assume that box(. .M) does not contain anymeta-variables, i.e. it is closed. \n.; . f M ' = . M/. . ' (box(. .M) = ...box(. .M ) . e) -. [ .] .e . .; . f s ' = s/. . (sbox(. .s) = \n...sbox(. .s ' ) . e) -. [ .] .e Given the current setup, we can prove type safety for our pro\u00adposed \nfunctional language with higher-order abstract syntax and explicit substitutions.We assume that patterns \ncover all cases here, but coverage checking can be incorporated by following ideas de\u00adscribedin (Sch\u00a8 \nurmann and Pfenning 2003). First we state and prove the necessary canonical forms lemma where |e| denotes \ntheexpres\u00adsion e where typing annotations in e : t are erased. Lemma 5.1. [Canonical forms] 1. If |e| \nis a value and \u00b7; \u00b7; \u00b7f e . A[.] then |e| = box(. .M) and \u00b7; \u00b7; \u00b7f box(. .M) . A[.] 2. If |e| is a value \nand \u00b7; \u00b7; \u00b7f e . F[.] then |e| = sbox(. .s) and \u00b7; \u00b7; \u00b7f sbox(. .s) . F[.] 3. If |e| is a value and \n\u00b7; \u00b7; \u00b7f e . t1 . t2 then |e| = fn y.e ' and \u00b7; \u00b7; \u00b7f fn y.e ' . t1 . t2 4. If |e| is a value and \u00b7; \n\u00b7; \u00b7f e . ..::W.t then |e| =...e ' and \u00b7; \u00b7; \u00b7f ...e ' . ..::W.t  Proof. By induction on the typing \njudgment and case analysis. Theorem 5.1. [Preservation and Progress] 1. If \u00b7; \u00b7; \u00b7f e . t and e coverage \nchecks then either |e| is a value or there exists an expression e ' s.t. |e| -. |e ' | and \u00b7; \u00b7; \u00b7f e \n' . t. 2. If \u00b7; \u00b7; \u00b7f e . t and e coverage checks then either |e| is a value or there exists an expression \ne ' s.t. |e| -. |e ' | and \u00b7; \u00b7; \u00b7f e ' . t.  Proof. By structural induction on the .rst derivation \nusing canoni\u00adcal forms lemma, correctness of higher-order pattern matching, and various substitution \nproperties we proved earlier. 6. Related Work One of the .rst proposals for functional programming with \nsup\u00adport for binders and higher-order abstract syntax was presented by Miller (1990). Later, Despeyroux \net al. (1997) developed a type\u00adtheoretic foundation for programming which supports primitive re\u00adcursion.To \nseparate data from computation, theyintroduce modal types DA which can be injected into computation. \nHowever, data in theirwork mustalwaysbeclosedand canonlybeanalyzedviaa primitiverecursiveiterator. Ourwork \nessentially continues the path set out in (Despeyroux et al. 1997), and generalizes their work to allow \nfor open data-objects and .rst-class substitutions. Closely relatedto our approachistheworkbySch\u00a8urmannetal. \n(2005) where the authors present the .-calculus which provides a foundation for programming with higher-order \nabstract syntax as found in the simply typed Elphin language. In Sch\u00a8urmann et al. (2005) the necessity \nmodality Dt describes computation of type t which can be executed in every world where we have at least \none context extension. The contextcontaining binding occurrences is hence left implicit and associated \nwith a computation. When a new context extension is introduced, the computation moves from the present \nworld to a world where the context is extended. To return the computation to the present world again \nwhere the context extension is not present, the programmer has to explicitly use a pop-operation which \nremoves the introduced binding. The fact that binders can never escape their scope during execution is \na meta-theoretic property which is proven. Since Dt describes computation which may be executed in every \nworld where we have at least one context extension, the whole function and all its arguments must be \nwell-typed in this extended context. This is in stark contrast to our work based on contextual modal \ntype, where A[.] denotes some object of type A which is well\u00adtyped in every world where we have a context \n. and hence every data-object carries its own local context. Therefore we can for ex\u00adample return an \nobject which is closed and distinguish it from an object whichis not closed. Thefact that local binders \ncan never es\u00adcape their scope is an inherent property ofcontextual types A[.]. . denotes exactly the \nbound variables which are allowed to occur in an object of type A[.], and the type system will detect \nif this is violated. Elphin seems a special case of our foundation where there is only one context variable \nwhich all arguments depend on. Because we can distinguish between different contexts, we believe our \nfoundationis moreexpressiveandislikelyto scale betterwhen we compose different computations, since it \nprovides more .ne\u00adgrained control. Finally, we propose to extend the framework with .rst-class substitutions, \nwhich seem interesting on their own and are absent from Elphin. Although their full impact still needs \nto be explored, explicit substitutions have been used to model records, closures, modules, classes and \nabstract data types with one single versatile and powerful construct. The lack of .rst-class substitu\u00adtions \ngenerally forces the inclusion of several different name-space mechanisms. Most recently, Poswolsky and \nSch\u00a8urmann (2007) proposed a dependently typed language for programming with higher-order encodings. \nWhile substantially different from Elphin, it also does not provide .ne-grained control to distinguish \nbetween multiple different contexts and does not support .rst-class substitutions. Adifferent more pragmatic \napproach to allow manipulation of binding structures is pursued in nominal type systems which serve asafoundationof \nFreshML (Shinwelletal.2003).Inthis approach names and a-renaming are supportedbut implementing substitu\u00adtion \nis left to the user. The type system distinguishes at the type\u00adlevel between expressions and names, and \nprovides a special type atom whichis inhabitedby all names. The distinction between dif\u00adferent categoriesof \nnamesis usually moredif.cult. Generationofa new name and binding names are separate operations whichmeans \nit is possible to generate data which contains accidentally unbound names since fresh name generationis \nan observable sideeffect.To address this problem, Pottier (2007) describes pure FreshML where wecan reasonaboutthesetofnames \noccurringinanexpressionvia a Hoare-style proof system. The system relies on assertions writ\u00adten by the \nprogrammer to reason about the scope of names. This static-analysis approach is quite expressive since \nthe language of constraints includes subset relations, equality, intersection etc. In contrast, our work \naims to provide a type-theoretic understanding of open data, binders, and substitutions. This has various \nbene.ts: For example, it should be possible to provide precise error mes\u00adsages on where names escape \ntheir scope. In contrast to nominal systems, our foundation also leaves .exibility as to how data-level \nboundvariables are implementedandinfact lends itselftoanim\u00adplementation based on de Bruijn indices. While \nthe exact relation\u00adship between nominal types, static analysis of names and contextual types still needs \nto be investigated, we believe the presented work is a start towards comparing both approaches. From \na more theoretical perspective, various .-calculi support\u00ading contexts as a primitive programming construct \nhave been con\u00adsidered (Sato et al. 2001, 2002; Nishizaki 2000; Mason 1999; Hashimoto and Ohori 2001). \nNishizaki (2000)forexampleextends a lambda-calculus with explicit substitutions in the spirit of the \nex\u00adplicit substitution calculus proposed by Abadi et al. (1990). How\u00adever, unlike Abadi s work, the author \nproposes a polymorphic cal\u00adculus where we can quantify over explicit substitutions. This work crucially \nrelies on de Bruijn indices. Although the use of de Bruijn indices is useful in an implementation, nameless \nrepresentation of variables via de Bruijn indices are usually hard to read and critical principles are \nobfuscatedby the technical notation. Sato et al. (2002) introduce a simply typed .-calculus which has \nboth contexts and environments (=substitutions) as .rst-class values, called ..,c-calculus. There are \nmanydistinctions, however, between their work andthe contextual modal type theory we pro\u00adpose as a foundation. \nMost of these differences arise because the formerisnot basedon modal logic.Forexample,theydonotallow \na-conversion on open objects and theydo not require open objects tobe well-formedwithrespecttoalocalcontext.Moreover,theydo \nnot cleanly distinguish between meta-variables and ordinary vari\u00adables. All these restrictions together \nmaketheir system quite heavy, and requiresfancysubstitution operationsandlevels attachedtoor\u00addinary variables \nto maintain decidability and con.uence. None of these approaches allows for pattern matching and recursion \non open data-objects. 7. Conclusion We have presented a type-theoretic foundation for programming with \nhigher-order abstract syntax and .rst-class substitutions based on contextual modal types together with \nits type preservation and progress proof.We support recursionover data de.nedinHOAS\u00adstyle,and allowpattern \nmatchingagainst open dataandvariables. By design bound variables in data cannot escape their scope. This \nis to our knowledge the .rst type-theoretic proposal to achieve this. This work also provides interesting \ninsights into the relationship between nominal systems and higher-order abstract syntax. In the future \nwe plan to address the following questions: Existential quanti.cation over context variables In some \nexam\u00adples, we would like to be able to write a function which returns an open object of type exp[. ] \nfor some context . . This is for example necessary if we want to write a small-step environment based \ninterpreter, or even if we want to translate a name-based rep\u00adresentation of terms into a higher-order \nrepresentation. Adding ex\u00adistential quanti.cationfor contextvariablesisinfact possibleand straightforward. \nTypes t ::= ... | S.::W.t Expressions e ::= pack(.,e) | let pack(., x)= e in e ' end The typing and evaluation \nrules are then straightforward. Typing rules O; .; G f e . [[./.] t O f . . W O; .; G f pack(.,e) . S.::W.t \n O; .; G f e . S.::W.t O,.::W ; .; G,x : t f e ' . t ' O; .; G f let pack(., x)= e in e ' end . t ' Evaluation \nrules let pack(., x)= pack(.,e) in e ' end -. [e/x][[./.] e ' e1 -. e2 let pack(., x)= e1 in e ' end \n-. let pack(., x)= e2 in e ' end The full impact of existential types in practice however still needs \nto be addressed. Mixing data with computations At the moment our foundation for programming with HOAS \nand substitutions is pure, i.e. we never mix data and computation.However, there maybegood rea\u00adsonsto \nallow some formof computation insideof data-de.nitions. Forexample, consider the de.nitionof arithmeticexpressions.We \nde.ned natural numbers inductively, and then included them in the expressions via the coercion Nat. However, \nclearly we may want to use the integer-type given by our functional language when we de.ne the language \nof arithmetic expressions, and thereby be able to rely on the built-in arithmetic operations instead \nof rede.ning them. How to mix data and computation and retain all our good properties is an important \nquestion we plan to address in the future. Also the interaction with other features realistic programming \nlan\u00adguages provide such as mutable state, exceptions, etc. needs to be investigated. Reconstruction of \ncontext variables In the presented foundation we explicitly abstract over context variables and pass \nthem explic\u00aditly. An interesting question in practice is whether we can recon\u00adstruct someof these contextvariables \nandkeep contexts implicit. This also leads to the question whether we should support pattern matchingagainst \ncontextualvariables.Atthe moment, contextvari\u00adables will be instantiated to some concrete context via \ncontext ap\u00adplicationbeforewe use pattern matchingto decide which branchto pickina case-expression. Thisinfactis \nimportantto achieveel\u00adegant meta-theoretic properties. In the future, we plan to consider in more detail \nhow to reconstruct context variables and how to add matching for context variables. Acknowledgments Iwould \nlike to thank Frank Pfenning, Aleks Nanevski, and Adam Poswolsky for many insightful discussion regarding \nthis topic. Moreover, thisworkbene.ted from comments and suggestionsby Derek Dreyer,Stefan Monnier,and \nFranc\u00b8ois Pottier. Special thanks go to Joshua Dun.eld for helping to typeset the code. References Mart\u00b4in \nAbadi, Luca Cardelli, Pierre-Louis Curien, and Jean-JacquesL` evy. Explicit substitutions. In Conference \nRecordof the Seventeenth Annual ACM Symposium on Principles of Programming Languages, SanFran\u00adcisco, \nCalifornia, pages 31 46.ACM, 1990. Jo\u00a8urmann. elle Despeyroux, Frank Pfenning, and Carsten Sch\u00a8Primitive \nre\u00adcursion for higher-order abstract syntax. In R. Hindley, editor, Proceed\u00adings of the ThirdInternational \nConference onTyped Lambda Calculus and Applications (TLCA 97), pages 147 163, Nancy, France, Lecture \nNotes in Computer Science (LNCS) 1210, Springer-Verlag, 1997. Murdoch Gabbay and Andrew Pitts. A new \napproach to abstract syntax involving binders. In G. Longo, editor, Proceedings of the 14th Annual Symposium \non Logic in Computer Science (LICS 99), pages 214 224, Trento, Italy, IEEE Computer Society Press, 1999. \nLouis-Julien Guillemette and Stefan Monnier. Statically veri.ed type\u00adpreserving code transformations \nin Haskell. In Programming Languages meets ProgramVeri.cation (PLPV), Seattle, USA, Electronic Notes \nin Theoretical Computer Science (ENTCS). Elsevier, 2006. Robert Harper, Furio Honsell, and Gordon Plotkin. \nA framework for de.ning logics. Journal of the Association for Computing Machinery, 40(1):143 184, January \n1993. Masatomo Hashimoto and Atsushi Ohori. Atyped context calculus. Theo\u00adretical Computer Science, 266(1-2):249 \n272, 2001. Ik-Soon Kim, Kwangkeun Yi, and Cristiano Calcagno. A polymorphic modal type system for Lisp-like \nmulti-staged languages. In 33rdACM SIGPLAN-SIGACT Symposium on Principles of Programming Lan\u00adguages(POPL \n06), pages 257 268, NewYork, NY, USA,ACM Press, 2006. Ian A. Mason. Computing with contexts. Higher-Order \nand Symbolic Computation, 12(2):171 201, 1999. Andrew McCreight and Carsten Sch\u00a8urmann.Ameta-linear logical \nframe\u00adwork.In CarstenSch\u00a8urmann, editor, 4th InternationalWorkshoponLog\u00adicalFrameworks and Meta-Languages \n(LFM 04), 2004. Dale Miller. Uni.cation of simply typed lambda-terms as logic program\u00adming. In Eighth \nInternational Logic Programming Conference, pages 255 269,Paris, France, MIT Press, 1991. Dale Miller. \nAn extension to ML to handle bound variables in data struc\u00adtures. In G. Huet and G. Plotkin, editors, \nProceedingsof theFirstWork\u00adshop onLogicalFrameworks, pages 323 335, 1990. Aleksandar Nanevski, Frank \nPfenning, and Brigitte Pientka. Acontextual modal type theory. ACM Transactions on Computational Logic \n(ac\u00adcepted, to appear in 2008), page 56 pages, 2006. Shin-Ya Nishizaki. A polymorphic environment calculus \nand its type\u00adinference algorithm. Higher Order Symbol. Comput., 13(3):239 278, 2000. Frank Pfenning and \nCarsten Sch urmann.\u00a8System description: Twelf a meta-logical framework for deductive systems. In H. \nGanzinger, editor, Proceedings of the 16th International Conference onAutomated Deduction (CADE-16), \npages 202 206,Trento, Italy, Lecture Notes in Arti.cial Intelligence (LNAI) 1632, Springer-Verlag, 1999. \nBrigitte Pientka. Tabled higher-order logic programming. PhD thesis, Department of Computer Sciences, \nCarnegie Mellon University, 2003. CMU-CS-03-185. Brigitte Pientka and Frank Pfennning. Optimizing higher-order \npattern uni.cation. InF. Baader, editor, 19th International Conference on Automated Deduction, pages \n473 487, Miami, USA, Lecture Notes in Arti.cial Intelligence (LNAI) 2741, Springer-Verlag, 2003. Adam \nPoswolsky and Carsten Sch\u00a8urmann. Programming with higher\u00adorder encodings and dependent types. Technical \nReport YALEU/D\u00adCS/TR1375, Department of Computer Science, Yale University, July 2007. Franc\u00b8ois Pottier. \nStatic name control for FreshML. In Twenty-Second Annual IEEE Symposium on Logic in Computer Science \n(LICS 07), pages 356 365, Wroclaw, Poland, IEEE Computer Society, 2007. MasahikoSato,Takafumi Sakurai, \nand Rod Burstall. Explicit environments. Fundamenta Informaticae, 45(1-2):79 115, 2001. Masahiko Sato,Takafumi \nSakurai, andYukiyoshi Kameyama. A simply typed context calculus with .rst-class environments. Journal \nof Func\u00adtional and Logic Programming, 2002(4), March 2002. Carsten Sch\u00a8urmann. Automating the meta theory \nof deductive systems.PhD thesis, Department of Computer Sciences, Carnegie Mellon University, Available \nasTechnical Report CMU-CS-00-146, 2000. Carsten Sch\u00a8urmann and Frank Pfenning. A coverage checking algorithm \nfor LF. In D. Basin and B. Wolff, editors, Proceedings of the 16th International Conference on Theorem \nProving in Higher Order Logics (TPHOLs 2003), pages 120 135, Rome, Italy, Lecture Notes in Com\u00adputer \nScience (LNCS) 2758, Springer-Verlag, 2003. Carsten Sch\u00a8urmann, Adam Poswolsky, and JeffreySarnat. The \n.-calculus. functional programming with higher-order encodings. InPawel Urzy\u00adczyn, editor, Proceedings \nof the 7th International Conference onTyped Lambda Calculi and Applications(TLCA 05), pages 339 353, \nNara, Japan, Lecture Notes in Computer Science (LNCS) 3461, Springer, 2005. Mark R. Shinwell, Andrew \nM. Pitts, and Murdoch J. Gabbay. FreshML: programming with binders made simple. In Eighth ACM SIGPLAN \nInternational Conference on Functional Programming (ICFP 03),pages 263 274,NewYork,NY, USA, 2003.ACM \nPress. Geoff Washburn and Stephanie Weirich. Boxes go bananas: Encoding higher-order abstract syntax \nwith parametric polymorphism. Journal of Functional Programming, 2007 (to appear). Kevin Watkins, Iliano \nCervesato, Frank Pfenning, and David Walker. A concurrent logical framework I: Judgments and properties. \nTechnical Report CMU-CS-02-101, Department of Computer Science, Carnegie Mellon University, 2002.  \n\t\t\t", "proc_id": "1328438", "abstract": "<p>Higher-order abstract syntax (HOAS) is a simple, powerful technique for implementing object languages, since it directly supports common and tricky routines dealing with variables, such as capture-avoiding substitution and renaming. This is achieved by representing binders in the object-language via binders in the meta-language. However, enriching functional programming languages with direct support for HOAS has been a major challenge, because recursion over HOAS encodings requires one to traverse lambda-abstractions and necessitates programming with open objects.</p> <p>We present a novel type-theoretic foundation based on contextual modal types which allows us to recursively analyze open terms via higher-order pattern matching. By design, variables occurring in open terms can never escape their scope. Using several examples, we demonstrate that our framework provides a name-safe foundation to operations typically found in nominal systems. In contrast to nominal systems however, we also support capture-avoiding substitution operations and even provide first-class substitutions to the programmer. The main contribution of this paper is a syntax-directed bi-directional type system where we distinguish between the data language and the computation language together with the progress and preservation proof for our language.</p>", "authors": [{"name": "Brigitte Pientka", "author_profile_id": "81100506891", "affiliation": "McGill University, Montreal, PQ, Canada", "person_id": "PP14262403", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1328438.1328483", "year": "2008", "article_id": "1328483", "conference": "POPL", "title": "A type-theoretic foundation for programming with higher-order abstract syntax and first-class substitutions", "url": "http://dl.acm.org/citation.cfm?id=1328483"}