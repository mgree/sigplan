{"article_publication_date": "06-01-1994", "fulltext": "\n Efficient Detection of All Pointer and Array Access Errors Todd M. Austin Scott E. Breach Gurindar S. \nSohi Computer Sciences Department University of Wisconsin-Madison 1210 W. Dayton Street Madison, {austin, \nbreach, Abstract We present a pointer and array access checking technique that provides complete error \ncoverage through a simple set of program transformations. Our technique, based on an ex\u00adtended safe pointer \nrepresentation, has a number of novel aspects, Foremost, it is the first technique that detects all spatial \nand temporal access errors. Its use is not limited by the expressiveness of the language; that is, it \ncan be ap\u00adplied successfully to compiled or interpreted languages with subscripted and mutable pointers, \nlocal references, and ex\u00adplicit and typeless dynamic storage management, e.g., C. Because it is a source \nlevel transformation, it is amenable to both compile-and run-time optimization. Finally, its per\u00adformance, \neven without compile-time optimization, is quite good. We implemented a prototype translator for the \nC lan\u00adguage and analyzed the checking overheads of six non-trivial, pointer intensive programs. Execution \noverheads range from 130% to 540%; with text and data size overheads typically below 100~0. 1 Introduction \nIt is not difficult to convince programmers (or employers of programmers) that programming errors are \ncostly, both in terms of time and money. Memory access errors are particu\u00ad larly troublesome. A memory \naccess error is any dereference of a pointer or subscripted array reference which reads or writes storage \nout side of the referent. This access can either be outside of the address bounds of the referent, causing \na spatial access error, or outside of the lifetime of the referent, causing a temporal access error. \nIndexing past the end of an array is a typical example of a spatial access error. A typical temporal \naccess error is assigning to a heap allocation after it has been freed. Our own experiences as programmers \nas well as published evidence lead us to believe that memory access errors are an important class of \nerrors to reliably detect. For example, in This work was supported by grants from the National Science \nFoundation (grant CCR-9303030) and Office of Naval Research (grant NOO014-93-1-0465). Permission to \nco y wfthout fee all or part of this material is granted provid al that the copies are not made or distributed \nfor direct commercial advantage, the ACM copyright notice and the title of the publication and its date \nappear, and notice is given that copytng is by permission of the Association of Computing Machinery. \nTo copy otheiwise, or to republish, requires a fee and/or specific permission. SIGPLAN 94-6/84 Orlando, \nflorida USA @ 1994 ACM 0-89791 -662-xIWO006..$ 3.5O WI 53706 sohi}@cs.wise.edu [MFS90], Miller et. al. \ninjected random inputs (a.k.a fuzz ) into a number of Unix utilities. On systems from six different vendors, \nnearly all of the seemingly mature programs could be coaxed into dumping core. The most prevalent errors \nde\u00adtected were memory access errors. In [SC91], Sullivan and Chillarege examined IBM MVS software error \nreports over a four year period. Nearly 50~o of all reported software errors examined were due to pointer \nand array access errors. Fur\u00adthermore, of these errors, 25% were temporal access errors an error our \nchecking methodology is particularly adept at cat thing. Memory access errors are possible in languages \nwith ar\u00ad rays, pointers, local references, management. Such errors are and fix because: The effects of \na memory themselves except under . The exceptional conditions error may be very difficult . Once the \nerror is reproduced, correlate the program error or explicit dynamic storage particularly difficult to \ndetect access error may not manifest exceptional conditions. which lead to the program to reproduce. \nit may be very difficult to to the memory access error. Consider the erroneous C function in Figure 1. \nThis func\u00adtion can create a memory access error in the return state\u00adment expression. The function will \nreference the word im\u00admediately following the array referenced by the pointer data if the array does \nnot contain the token. The function illustrates the three difficulties in finding and fixing memory access \nerrors. First, FindToken () will only produce an incorrect result if the word following the array referenced \nby data cent sins the same value as token (or is inaccessible storage). This event is unlikely if the \nword con\u00adtains an arbitrary value. Second, when (or if) FindToken () creates an incorrect result, it \nwill be difficult to recreate dur\u00ading debugging. The programmer will have to condition the inputs of \nthe program such that the word following the ar\u00adray referenced by data once again contains the same value \nas token. If the value of the illegally accessed word is inde\u00ad pendent of the value of token, be very \nlow. Third, correlating gram to the incorrect actions difficult, This connection may be visible for a \nlong period of Many execution environments tection against memory access the probability of success will \nthe visible errors of the pro\u00adof FindToken ( ) may be very be very subtle and may not time. do provide \nsome level of pro\u00aderrors. For example, in most Unix based systems, a store to the program text will cause \nthe operating system to terminate execution of the program (usually with a core dump). Unix typically \nprovides storage int FindToken(int *data, int count, int token) { int i =O, *p =data; while ((i < count) \nW (*p != token)) { p++; i++; } return (*p == token) ; } Figure 1: A C function with a (spatial) memory \naccess error. protection on a segment granularity the segments are the program text, data, and stack. \nOther, more hostile environ\u00adments such as MS-DOS, do not offer such luxuries, and stores to the program \ntext may or may not manifest themselves as a program error. If a program error does occur, correlating \nit to a fault may be difficult, if not impossible. IdeallY, we would like the language execution environment \nto support memory access protection at the variable level, that is, an access to a variable should only \nbe valid if the access is within the range (for both time and space) of the intended variable all other \naccesses should immediately flag an error. We call any program that supports these execution semantics \na safe program. Our solution to the memory access error problem is simple and provides efficient and \nimmediate detection of all memory access errors. We transform programs, at compile-time, to use an extended \npointer representation which we call a safe pointer. A safe pointer contains the value of the pointer \nas well as object attributes. The object attributes describe the location, size and lifetime of the pointer \nreferent. When a safe pointer value is created, either through the use of the reference operator (e. \ng., &#38; in C) or through explicit storage allocation, we attach to it the appropriate object attributes. \nAs the value is manipulated, through the use of pointer op\u00aderators, the object attributes are transferred \nto any new safe pointer values. Detecting a memory access error involves simply validating dereferences \nagainst the object attributes if the access is within the space and time bounds of the object, it is \npermitted, otherwise an error is flagged and the access error is detected immediately. We implemented \na prototype source-to-source translator for the C language and examined the performance of six non\u00adtrivial, \npointer intensive programs. The performance is quite good. Instruction execution overheads range from \n130% to 540%, and text and data size overheads are typically below 100%. We also benchmarked our prototype \nsystem against two commercially available tools that support memory access checking (Purify [HJ92] and \nCodeCenter [KLP88]) and found that our checking technique consistently uses less resources, even while \nproviding better error coverage for memory access errors. This paper is organized as follows. Section \n2 introduces our extended safe pointer representation. Section 3 details the program transformations \nrequired to create safe programs, and in Section 4 we discuss the translation and performance implications \nof providing complete error coverage. In Sec\u00adtion 5, we present compile-and run-time optimization frame\u00adworks. \nSection 6 describes our prototype implementation and presents results of our analyses of six programs. \nSec\u00adtion 7 compares our checking technique to other published techniques. Section 8 concludes the paper. \ntypedef { <type> *value; <type> *base; unsigned size; enum {Heap=O, Local, Global} storageClass; int \ncapability; /* plus FOREVERand NEVER */ } SafePtr<type>; Figure 2: Safe pointer definition. This C-1ike \ntype definition is parameterized by <type>, the type of the pointer referent. 2 Safe Pointers To enforce \naccess protection, we must extend the notion of a pointer value to include information about the referent. \nThe idea is similar to tagged pointers used in many Lisp implementations [Lee91]. Figure 2 shows our \nsafe pointer representation. The definitions of the contained fields follow: value: The value of the \nsafe pointer; it may contain any expressible address. base and size: The base address of the referent \nand its size in bytes. In languages where pointers are immutable, base is redundant and may be omitted. \nWith this in\u00adformation, we can detect all spatial access errors with a range check. storageClass: The \nstorage class of the allocation, either Heap, Local, or Global. Using this value, it is possible to detect \nerrant storage deallocation, e.g., it is illegal to free a global or local variable. capability: A capability \nto the referent. When dynamic variables are created, either through explicit storage al\u00adlocation (e.g., \ncalls to malloc () ) or through procedure invocations (i. e., a procedure call crest es the local vari\u00adables \nin the stack frame of the procedure), a unique ca\u00adpability is issued to that storage allocation. The \nunique capability is also inserted into an associative store called the capabdity store and deleted from \nthat store when the dynamic storage allocation is freed or when the pro\u00adcedure invocation returns (the \nexact mechanics of this process are discussed in a following section). Thus, the collection of capabilities \nin the capability store represent all active dynamic storage. Temporal access errors oc\u00adcur whenever \na reference is made through a stale pointer, i.e., a pointer which references storage whose capability \nis no longer in the capability store. Two capabilities are predefine. FOREVER is unique and always ex\u00adists \nin the capability store; this capability is assigned to all global objects. NEVER is unique and never \nexists in the capability store; this capability can be assigned to invalid pointers to ensure any dereference \ncauses an error. The value attribute is the only safe pointer member that can be manipulated by the program \nsource; all other mem\u00adbers are inaccessible. base and size are the spatial at\u00adtributes. storageClass \nand capability are the temporal attributes. Safe pointers can exist in three states: unsafe, invalid, \nand vakd. If the object attributes are incorrect, we say that the pointer has become unsa}e; dereferencing \nthis pointer may cause an undetected memory access error. It is the goal of this work to ensure that \na safe pointer never becomes unsafe. If the safe pointer is not unsafe, it is either invalid or valid, \ndepending on whether a dereference would flag an error. Languages with mutable pointers allow the program \nto legally create invalid pointers; for example, iterating a pointer across all the elements of an array \nexits the loop with the pointer pointing to the memory location following the last object. If the invalid \npointer is never dereferenced, the program would not be in error. This behavior illustrates precisely \nwhy we only place error checks at dereferences; it is not illegal to have an invalid pointer only to \nuse it. The initial value of a safe pointer, if not specified by an initialization expression, must \nbe invalid. This condition en\u00adsures that a dereference before the initial assignment is de\u00adtected. A \nsimple way to invalidate a pointer value is to assign it the unique capability NEVER. 3 Program Transformations \nCreating a safe program from its unsafe counterpart involves three transformations: pointer conversion, \ncheck insertion, and operator conversion. The first, pointer conversion, ex\u00adtends all pointer definitions \nand declarations to include space for object attributes. Check insertion instruments the pro\u00ad gram to \ndetect all memory access errors. operator conver\u00adsion generates and maintains object attributes. In this \nsec\u00adtion, we also describe the run-time support. 3.1 Pointer Conversion All pointer definitions and declarations \nmust be extended to include object attributes. To make this transformation transparent, the composite \nsafe pointer must mimic the first class value semantics of scalar pointers. That is, when passed to a \nfunction, the safe pointer must be passed by value, and when operators are applied to a safe pointer, \nthe result, if a pointer, must be a new safe pointer. There is no need to add object attributes to array \nvari\u00adables. Array variables (in the C sense) are merely address constants, and thus only exist as statically \nallocated objects or within structure definitions; as a result, the spatial at\u00adtributes can be generated \nfrom the address constant and its type size, and the temporal attributes can be taken from the safe pointer \nto the containing object or derived from the array name.  3.2 Check Insertion Assuming the safe pointer \nobject attributes are correct (how to ensure this property is detailed in the following sections), complete \nsafety for all pointer and array accesses is provided by inserting an access check before each pointer \nor array dereference.1 The dereference check first verifies that the referent is alive by performing \nan associative search for the referent s capa\u00adbility. If the referent has been freed, the capability \nwould no longer exist in the capability store and the check would fail. Because capabilities are never \nre-used, the temporal check fails even if the storage has been reallocated. Once the stor\u00adage is known \nto be alive, a bounds check is applied to verify that the entire extent of the access fits into the referent. \nOur access check, shown in Figure 3, takes advantage of the wrap-around property of unsigned arithmetic \nto simplify 1We use the term dere.ference as a blanket term for any indirect access either through application \nof the dereference operator (e.g., * or -> in C) or through indexing an array or pointer variable (e. \ng., [ ] in C). void ValidateAccess (<type> *addr) { if (storageClass ! = Global W !ValidCapability (capability)) \nFlagTemporalErroro ; if ( (unsigned) (addr-base) > size-s izeof (<type>)) FlagSpatialError () ; /* valid \naccess! */ } Figure 3: Memory access check. ValidCapability( ) indicates whether or not the passed \ncapability is currently active, i.e., in the capability store. The Flag functions performs system specific \nhandling of an access error. the bounds check. If the accessed address is prior to the start of the array, \nthe unsigned subtraction under flows and creates a very large number, causing the test to fail. The advantage \nof this expression over traditional bounds checks2 is that it only requires one conditional branch to \nimplement. This simplification reduces the additional control complexity introduced by dereference checks, \nwhich can result in better optimization results and better dynamic executions. 3.3 Operator Conversion \nPointer operators must interact properly with the compos\u00adite safe pointer structure. When applied, they \nmust reach into the safe pointer to access the pointer value. If the op\u00aderator creates a new pointer \nvalue, it must include an un\u00admodified copy of the pointer operand s object attributes. For example, in \nthe C statement q = p + 6, the application of the + operator on the pointer p creates a new safe pointer \nwhich is assigned to q. The new pointer value in q shares the same object attributes as p. Operators \nwhich manipulate pointer values never modify the copied object attributes be\u00adcause changing the value \nof the pointer does not change the attributes of the storage it references. This property holds even \nfor pointers to aggregate structures. In this case, the object attributes refer to the entire aggregate. \nThe assignment operator requires special handling if the right hand side is a constant. Two common pointer \nconstants are the NULL value and pointers to string constants (for C). If the assignment value is NULL, \nthe NULL value can be replaced by an invalid safe pointer value, e.g., one with the capability NEVER. \nFor string constants, we can generate the needed object attributes at compile-time. If the right hand \nside of the assignment is a pointer expression, the result\u00ading pointer value (and its object attributes) \nis copied to the pointer named on the left hand side of the assignment. Casting between pointer types \ndoes not require any spe\u00adcial program transformations. This operation only alerts the compiler that future \npointer arithmetic or dereferences of a particular pointer value should be made with respect to the new \ntype size. Casting to a non-pointer type requires that the object attributes be dropped (if only pointers \ncarry ob\u00adject attributes) and the cast be carried out as defined by the language. Casting from a non-pointer \ntype to a pointer type is problematic if non-pointer types do not carry object at tribut es. We address \nthis problem in Section 4. 2Our check is functionally equivalent to: (addr < base I / addr > base+ size-s \nizeof(<type>)) which requires two conditional branches (or extra instructions to combine the boolean \nterms). Handling of the reference operator, e.g., the k operator in the C statement q = %p->b [10], is \nslightly more complex as it must generate object attributes. The reference opera\u00adtor is applied to an \nexpression (p->b [10], in our example) which names some storage. We call this expression the ac\u00adcess \npath. The result of the operation is a new safe pointer to the referent named by the expression. To generate \nobject attributes for a reference operation (e.g., &#38; ), we decompose access paths into two parts, \na prefix and a suffix. The access path prefix is a non-empty sequence of variable names, dereferences, \nsubscripts, field selectors, and pointer expressions leading to the memory object being referenced, The \nremaining part of the access path, the access path sufiz, is a possibly-empty sequence of field selectors \nand subscripts (on array variables only) indicating the extent of the memory object being referenced. \nWe further classify access paths as direct or redirect. A direct access path refers to an object in the \nglobal or local space by name. An indirect access path contains at least one pointer traversal. Given \na reference operator expression, we can parse the access path prefix by traversing the expression tree \nstarting with the left-most, lowest precedence operator. The part of the expression up to but not including \nthe last pointer traversal is the access path prefix; the remainder of the ex\u00adpression becomes the access \npath suffix. If the access path does not contain any pointer traversals, the access path pre\u00adfix is merely \nthe name of the referenced variable. To illustrate this decomposition, consider the C expression kf ->g \n[4] . i [6], where g is a pointer and i is an array within a structure. The access path prefix is the \nsub-expression f ->g [4]. The access path suffix is the remainder of the ex\u00adpression, i [61. The access \npath prefix is indirect. The temporal attributes of the new safe pointer are de\u00adrived from the access \npath prefix. If the prefix is direct, the referenced object is either a global or a local variable. If \nglobal, the capability FOREVER is assigned to the new safe pointer. If local, the capability allocated \nto the local vari\u00adable s stack frame is assigned to the new safe pointer (frame capability allocation \nis discussed in the following section). If the access path prefix is indirect, the temporal attributes \nare taken from the safe pointer named by the access path prefix. The spatial attributes are derived from \nboth the access path prefix and suffix. The base of the safe pointer is taken from the object referred \nto by the access path prefix, namely the address of the named variable for a direct prefix or the corresponding \nspatial attributes of the referenced safe pointer for an indirect prefix. The value and size of the safe \npointer are computed from the access path suffix. Because all mem\u00adbers of the referenced object (i. e., \nthe member of any con\u00adtained structure) are of a known size, the spatial attributes of the reference \ncan be computed at compile-time from type information. In the event the final term of the suffiJc is \na subscript, the spatial attributes are set to the extent of the entire array. This technique allows \nthe safe pointer to be subsequently manipulated to point to other members of the array. The use of the \naccess path prefix and suffix to produce a safe pointer via the reference operator cannot subvert the \nchecking framework. In order to maintain safe semantics, any pointers traversed within the access path \nprefix must be validated using the techniques described in the previous subsection. void *malloc(unsigned \nsize) { void *p; p.base = p.value = unsafe-malloc (size) ; p.size = size; p. storageClass = Heap;  \np. capability = NextCapabilityo ; InsertCapability (p. capability) ; bzero(p. value, size) ; /* capability \nNEVER is O */ return p;  } void *calloc(unsigned nelem, unsigned elsize) { return mallOc(nelsm*els \nize) ; } void *realloc(void *p, unsigned size) { void *new; new = malloc(size) ; bcopy(p. base, new. \nbase, min(size, p.size)) ; free(p) ; return new; } void free(void *p) { if (p. storageClass != Heap) \nFlagNonHeapFree () ; if ( !ValidCapability (p. capability)) FlagDuplicateFree ( ) ; if (p. value != p. \nbase) FlagNonOriginalFree () ; Destroy Capability (p. capability) ; unsaf e_f ree (p. value) ; } Figure \n4: Safe malloc implementation with additional checking. InsertCapabilityo, ValidCapability( ), and Destroy \nCapabilityo insert, locate, and delete capabilities, re\u00adspectively. Next Capabilit y ( ) returns the \nnext unique capability. unsaf emalloc () and unsaf e.f ree () are interfaces to the system\u00addefined storage \nallocator. 3.4 Run-Time Support The explicit storage allocation mechanism must be extended to create \nsafe pointers. During allocation, a capability must be allocated for the storage, and any contained pointers \nmust be invalidated. At deallocation, the capability given to the storage must be destroyed. Figure 4 \nshows how this support would be provided for mallo c ( ), the storage allocator provided under Unix. \nDur\u00ading allocation, malloc ( ) generates a safe pointer using the size and location of the allocation \nrequest. The call to NextCapabilit y ( ) returns the next available and unused ca\u00adpability. Next Capabilit \ny ( ) can be implemented with an in\u00adcrementing counter or a pseudo-random number generator. The capability \nis inserted into the capability store via the call to InsertCapabili-ty (). The call to bzero () clears \nthe entire storage allocation. This action ensures that any point\u00aders in the untyped allocation are initially \ninvalid (assuming the storage class of Heap and capability NEVER are both assigned the value of O). The \nimplementation of reallot ( ) is slightly more subtle. This function takes an existing storage allocation \nand resizes it to the requested size. The reallocated storage may move for any request, either larger \nor smaller. If moved, the contents of the new allocation will be unchanged up to the lesser of the new \nand old sizes. In our safe programming environment, we void Func(int a) { /* procedure prologue */ unsigned \nfrsmeCapabili ty = NextCapabilityo ; InsertCapability (frameCapability) ; ZeroFramePointers () ; /* cap. \nNEVER == O */ /* procedure epilogue, common exit point */ DestroyCapability (frameCapability) ; return; \n} Figure 5: Function frame allocation and deallocation. ZeroFramePomters ( ) is a system specific function \nwhich clears all pointers in the newly allocated stack frame. must move the storage in all cases, otherwise, \nthere may exist safe pointers (which we cannot locate and change) whose object attributes have incorrect \nrecords of the referent size. If dereferenced, these pointers may flag errors even though the access \nwas valid in the reallocated storage, or worse, the reallocation may have shrunk the referent, creating \nunsafe pointers whose referent sizes are too large. We can solve both these problems by always moving \nthe storage. This action will force the program to update any old pointers to the previous allocation. \nBecause the reallocated storage is allocated under a new capability, any stale pointers to the previous \nallocation will flag errors if dereferenced. We need not clear the remaining storage in the reallocation \nif it is larger, as the call to malloc ( ) returns cleared storage. At calls to free ( ), the capability \nof the allocation (con\u00adtained in the safe pointer object attributes) is deleted from the capability store \nby the call to Destroy capabilityo. Our implementation also verifies that the freed storage is indeed \na heap allocation, has not been previously freed, and points to the head of the allocation (as this condition \nis re\u00adquired by free()). The same allocation mechanism is applied to the dynamic storage allocated in \nprocedure stack frames. When a funct ion is invoked, a capability must be allocated for the entire frame \nif it contains any referenced locals. Any pointers contained in the frame must be set to an invalid state. \nFigure 5 shows how this rewriting would be done for a C function. The function ZeroFrsmePointers ( ) \nserves the same purpose as the call to bzero ( ) in rnalloc ( ); it ensures that any pointers in the \nprocedure stack frame are initially invalid by clearing the frame storage. Because stack frame allocations \nare strongly typed, ZeroFramePointers () could be replaced by NULL assignments to all the frame pointers. \nIf the language supports non-local jumps, e.g., longjmp ( ) in C, the run-time support must delete the \nframe capabilities of any elided function frames. This operation can be simply and portably implemented \nif the local capability space and heap capability space are kept disjoint, and function frame capabilities \nare allocated using an incrementing counter. The allocation of frame capabilities then becomes a depth-first \nnumbering [ASU86] of the dynamic call graph. When a non\u00adlocal jump occurs, all elided frame capabilities \nbetween the source frame and destination frame are deleted by removing all frame capabilities in the \ncapability store that are larger than the frame capability of the destination frame. This mechanism only \nworks if the source and destination frames are on the same call stack this stipulation may not be true \nin all cases, e.g., coroutine jumps. The capability store is an associative memory containing the capabilities \nof all active memory. It can be implemented as a hash table with the capability as the hash key. Accesses \nto the capability store exhibit a great deal of temporal lo\u00adcality, so moving accessed elements to the \nhead of the hash table bucket chains is likely to decrease average access time. We close this section \nwith two examples. Figure 6(a) shows a spatial access error, and Figure 6(b) demon\u00adstrates a temporal \naccess error. Safe pointer values are specified as a 5-tuple with the following format: [ualue,base,size, \nstorageClass,capability]. x indicates a don t care value. In the first example, a spatial access error \nis flagged when the program dereferences a safe pointer whose value is less than the base of the referent. \nIn the second example, a stale pointer, q, is dereferenced. Even though the same storage has been reallocated \nto p, the capability originally assigned to q has been destroyed during the call to free (); thus, the \ntemporal access error is detected. 4 Implications of Complete Error Coverage Our safe programming technique \ncan detect all memory ac\u00adcess errors provided that the following conditions hold: %.Storage management \nmust be apparent to the transla\u00adtor. ii. The referents of all pointer constants must have a known location, \nsize, and lifetime. iaz.The program must not manipulate the object attributes of any pointer value. \n Our claim to complete error coverage must be limited to storage management controlled by the safe programming \nrun-time system. If a program implements a domain specific allocator at the user level, some memory access \nerrors, as viewed by the programmer, can be missed. Consider, for example, a fixed size storage allocator. \nIf a program relies heavily on a fixed size structure, storage re\u00adquirements and allocation overheads \ncan be greatly reduced by applying a fixed size allocation strategy. At the program level, the fixed \nsize allocator calls the system allocator, e.g., malloc ( ) or sbrk (), to allocate a large memory allocation. \nThe fixed size allocator then slices the system allocation into fixed size pieces with a zero overhead \nfor each allocation. Under this scheme, our safe programming technique would ensure that no accesses \nto a fixed size allocations are out\u00adside of the space and time bounds of the block from which the fixed \nsize allocation was derived. This imprecision oc\u00adcurs because the translator can not distinguish the \nuser level storage allocation actions from other pointer related program activities. With some programmer \nintervention this problem can be overcome. Any useful safe compiler implementation will have to include \nan application programmers interface, or API, through which systems programmers can construct and ma\u00adnipulate \nthe object attributes of safe pointers. In the case of the fixed size storage allocator, the programmer \nwould spec\u00adify the base and size of the fixed size allocation. The storage class and capability would \nbe generated from the safe pointer to the block from which the fixed size allocation was derived. Without \nthe second qualification, the compiler may not be able to generate correct object attributes for a pointer \nconstant. For example, device driver code typically crest es pointers to device buffers and registers \nby recasting an inte\u00adger to a pointer value. The translator has no way of knowing struct ( char a; ~ \n~ capability store char b[100]; } x, *p; char q; [X, X, X, X, NEVER] [X, X, X, X, NEVER] {) p = &#38;x; \n[1000,1000,101, Global, FOREVER] [X, X, X, X, NEVER] {}*p; I* no error */ !! !, ,, ,! q = &#38;p->b[l \nO]; [l 011,1001,1 00, Global, FOREVERl , ~__; ,, [1010,1001,1 00, Global, FOREVER] ,, ,! ,, q; p = 2; \n[798, 1000,101, Global, FOREVER] ,, *p; I* error!! ! *I !, a) capability store char *p, *q; [X, X, \nX, X, NEVER] [X, X, X, X, NEVER] {) p = mall Oc(l O) ; [2000,2000, 10, Heap,l] [x, x,x, x, NEVER] {1} \n,, q = P+6; [2006,2000,10, Heap, l] *q; /* no error */ ,, !!free(p) ; p = mall Oc(l O) ; [2000,2000,10, \nHeap,2] {{2}) q; /* error! I ! *I b) Figure 6: Memory access checking examples. Figure a) is an example \nof a spatial access error, Figure b) is an example of a temporal access error. Safe pointer values, shown \nafter each line is executed, are specified as a 5-tuple with the following format: [value, base, size, \nstorageClass,capabilit~]. An occurrence of x indicates a don t care value. the size and lifetime of the \nreferent; thus, program safety one in which pointer values are never created from or manip\u00adcannot be \nmaintained. In C, the only well defined pointer ulated as non-pointer values. If a program violates this \nrule constants are NULL, strings, and functions. For all other intentionally (e. g., through a recast), \na safe compiler which cases, this problem can be avoided by supplying the pro-makes a conservative approximation \nas to the intended ref\u00adgrammer with an API suitable for specifying the size and erent of the new pointer \nvalue allows the pointer to access lifetime of problematic pointer constants. any live storage. 3 If \nthe rule is broken unintentionally (e.g., The second qualification does not, however, preclude the through \nincorrect use of a union), the error will likely be use of recasts from non-pointer variables to pointer \nvariables. caught because it is difficult to manufacture, accidentally, To successfully support these \noperations, object attributes an unsafe pointer. must be attached to all variables. In general, to provide \ncomplete safety, we need to attach object attributes to any storage that could hold a pointer value. \nIt is our contention 5 Optimizing Dereference Checks that most well behaved programs will only require \npointer variables to carry object attributes. In the interest of performance, it may be possible to elide \ndereference checks and still provide complete program safety. The final qualification protects object \nattributes. If a pro-If we can determine that the following invariant holds, the gram can arbitrarily \nmanipulate the object attributes of a pointer value, then safety can always be subverted. For ex-check \nmay be elided. ample, changing the storage class of a pointer from Global A check at a dereference of \npointer value u may be to Heap and then freeing the pointer would likely cause dis\u00adelided at program \npoint p if the previous, equivalent astrous effects under our storage allocation scheme. check executed \non v has not been invalidated by some If object attributes are only attached to pointer values, the program \naction. danger exists of manipulation through the use of recasts or unions. With a recast, it is possible \nto type storage in the We can implement this check optimization either at run\u00adreferent first as a non-pointer \nvalue, manipulate the storage time or at compile-time. Run-time check optimization hasarbitrarily, and \nthen recast the referent storage to a (possibly the advantage of being more flexible. We only need to \nex\u00adunsafe) pointer. Using a union, it is possible to create a ecute the checks absolutely required to \nmaintain programpointer value under one field and then manipulate the object safety. However, the cost \nfor this precision is extra safeattributes of the pointer value through another overlaid, non\u00adpointer \nstate which must copied, maintained, and checked atpointer field of the union. each dereference. Compile-time \ncheck optimization, on the The only solution that we can conceive to prevent this other hand, is less \nflexible because we must constrain the kind of manipulation is to attach object attributes to each decision \nto elide a check to all previous possible executions byte of allocated storage. For types larger than \none byte, the leading to a program point. The advantage of compile-timeobject attributes would be copied \nto all other storage holding the allocation. In this way, any arbitrary overlaying of types 3Note that \nin this case, safety can no longer be guaranteedwould still not allow the object attributes to be manipulated \nbecause the intended referent is not known. Hence, we cannot at the program level. bind the object attributes \nof a live variable to the new pointer In reality, we can provide a high margin of safety for well because \nthe program may have manipulated the pointer value to behaved programs by attaching object attributes \nonly to point outside of the intended referent prior to recasting it to a pointer values. We consider \na well behaved program to be non-pointer value. 29: i void ValidateAccess (<type> *addr) { if (f reeCount \n! = currentFreeCount) { if (storageClass != Global W ! ValidCapabilit y (capability) ) FlagTemporalError \n() ; freeCount = currentFreeCount; if (lastDeref Addr ! = addr) { if ( (unsigned) (addr-base) > size-s \nizeof (<type>) ) FlagSpat ialError () ; lastDeref Addr = addr; } /* valid access! */ } Figure 7: Memory \naccess check with run-time check opti\u00ad mization. The variable currentFreeCount is a global counter incremented \neach time storage IS deallocated. check optimization is that no additional overhead is required at run-time \nto determine if a check may be elided. 5.1 Run-Time Check Optimization We have designed and implemented \na framework for dynami\u00adcally eliding spatial and temporal checks. Spatial checks have no side effects, \nthus we can employ memorization [FH88] (or function caching) to elide their evaluation. We store the \noperands to the last check in the safe pointer object at\u00adtributes, which amounts to the effective address \nof the last dereference. At any dereference, the spatial check may be elided if the effective address \nsince the last check has not changed. This test is shown in Figure 7 in the if statement surrounding \nthe bounds check. It may be useful to memoize more than one set of operands. In our implementation, we \nmemoize both the effective address of the last dereference, i.e., use of the C operator * , and the effective \naddress of the last subscript operation, t. e., use of [ ] . Changes in the former can be tracked with \nonly a single dirty bit, set when the pointer value is changed. Changes in the latter are tracked by \nretaining a copy of the last index applied to the pointer value. To elide temporal checks, we keep a \ncopy of a global counter, incremented when storage is deallocated, in the safe pointer. If this counter, \nwhich we call the ~ree counter, has not changed since the last temporal check, the referent has not been \nfreed and the temporal check can be safely elided. In our implementation, we keep separate counters for \nheap and stack deallocat ions,  5.2 Compile-Time Check Optimization We have also designed (and are currently \nimplementing) a compile-time optimization framework like that proposed by Gupta [Gup90]. Our algorithm \nimplements a forward data\u00adflow framework similar to that used by common subexpres\u00adsion elimination [ASU86]. \nHowever, our algorithm extends previous work to include eliding of temporal error checks, and because \nof our simplified bounds check, there is no need to split the optimization into upper and lower bounds \ncheck elimination. Our optimization algorithm is shown in Figure 8. The algorithm is run twice, once \nfor optimization of spatial checks and again for temporal checks. The algorithm executes in three phases. \nInput: A flow graph G with blocks B with gen[B,] and kzll[ll,] computed for each block B, c B. gen[ll,] \nis the set of check expressions generated in B,. M1[B,] is the set of check expressions killed in B,. \nThe entry block is B1. Output A flow graph G with redundant checks deleted. Method The following procedure \nis executed twice, once for spatial check optimization and again for temporal check optimization. /+ \nimtialize out sets */ WLIB1] = 0; out[Bl] = gen[l?l]; U = ~t&#38;Bgen[B,l; for BzEB B1do out[B,] = U \n ktU[B,]; / compute availability of checks, m sets */ change = true; while change do begin change = false; \nfor B, EB BI do begin II out[P]; wBil = p<p,e~[q OkiOUt = out[B, ] ; out[B%] = gen[B,] U (zn[l?,] kzU,[B,]), \nif OUt[Bt] # oldout then change = true; end end / elide redundant checks / for B%E B B1 do begin for \nc E gen[B,] do begin if c E in[Bt] then elide check c; end end Figure 8: Compile-time check optimization \nalgorithm. In the first phase, the algorithm seeds the data-flow anal\u00adysis by approximating all out sets. \nFor all blocks except the entry block, the value of out [1?;] is set to all check expressions less those \nkilled by the block l?,, i.e., U kill [B,]. For the program entry block, Ell, we must assume that no \nchecks are available, hence, in[131 ] is set to empty and OUt[B1] is set to the checks generated in the \nentry block B1. In the second phase, the data-flow framework is solved to determine where check expressions \nreach in the program. For a check expression to reach a node B%, it must be available at B, for all executions, \nthat is, it must be available in the out sets of all predecessors to block B,. This requirement is pre\u00adcisely \nwhy the confluence operator is intersection. After the data-flow computation converges on a solution, \ni. e., change == false, the set in[B,] contains all checks that reach block 15~. In the third phase, \nthe in sets are used to elide redundant checks. Checks may be elided wherever a lexically identical or \nequivalent (if more powerful tests are applied) check is available in the block (i. e., the same check \nis in the in set of the block). The defining feature for each analysis (spatial and tem\u00adporal) is the \nspecification of what constitutes a kill. A spa\u00adtial check is killed by any assignment to a check operand, \nwhich includes assignment to the pointer variable or any of the operands of the index expression (if \nthe pointer was in\u00addexed in the check expression). A temporal check is killed by any deallocation of \nthe referent storage. If the referent of a free can be determined to be different than the check referent \n(e. g., through alias analysis), the free need not kill the check. While performing these analyses, \nwe must also be wary of kills that may occur through function calls or aliases. In either caae, we must \nmake a conservative approximation if insufficient information is available and assume that a kill does \noccur.  6 Experimental Evaluation We evaluated our safe programming methodology by imple\u00admenting a \nsemi-automatic source-to-source translator and examining the run-time, code and data size overheads for \nsix non-trivial programs. For each program, we analyzed its performance without optimization and with \nrun-time re\u00adsolved optimizations; we did not consider compile-time opti\u00admization (our current implementation \ndoes not support this technique, though work in this direction is in progress). 6.1 Experiment al Framework \nWe translated C programs to their safe counterparts by first rewriting all pointer and array declarations, \ncalls to malloc ( ) and free (), and references (use of the &#38; operator) to use our Safe-C macros. \nThese macros, when passed through the C preprocessor ( CPP), produce either the original C program or \na Safe-C program. A Safe-C program has all pointer and array declarations changed to type parameterized \nC++ class declarations. Using operator overloading in the C++ class definition, we implement the extended \nsafe pointer and array semantics as described in Section 3. All explicit storage allocation, i.e., calls \nto malloc () and free (), call wrapper functions which create safe pointers from the standard library \nroutines. Our malloc ( ) implemen\u00adtation clears all allocated storage, so any contained pointers start \nin the invalid state. If a local in a function is used as a pointer referent, we also rewrite the function \nto allocate a capability for the frame. Any pointer in the stack frame of a function is initialized to \nan invalid state in the constructor of the C++ safe pointer class. Application of the reference operator \ncalls a function which creates a safe pointer from the decomposed access path.  6.2 Analyzed Programs \nWe analyzed six programs, selected because each exhibits a high frequency of indirect references. The \nprograms in\u00adclude an anagram generator (Anagram), a neural net sim\u00adulator (Backprop), an arbitrary precision \ncalculator (GNU BC), a minimum spanning tree generator (Min-Span), a graph partitioning tool (Partition), \nand a VLSI channel router (YACR-2). Table 1 details the programs that we ana\u00adlyzed. For each, we show \nthe code size (Instructions/Static), the number of instruction executed without checking (ln\u00adstructions/Dynumic), \nthe frequency of dereferences in the program text (Insts per Dereference/Static), and the dy\u00adnamic frequency \nof dereferences executed (lnsts per Deref\u00ad erence/Dynamic). All programs were compiled and executed on \na DECsta\u00adtion 3100 using AT&#38;T USL cfront version 3.0.1. The output of cfront (C code) was compiled \nusing MIPS cc version 2.1 at optimization level -02 . All instruction counts were ob\u00adtained with QF Z \n[Lar93]. For all analyses, object attributes were only attached to pointer values. We used a 15 byte \nsafe pointer (27 5~0 over\u00adhead) in the unoptimized case: 4 byte pointer value, 4 byte Table 1: Analyzed \nprograms. Program Instructions Insts per Dereference Static Dynamic Static Dynamic (XI03) (X106) Anagram \n10.0 19.4 106.3 7.6 Backprop 10.8 122.4 148.5 8.9 GNUBC 19.5 12.2 15.5 7.6 Min-Spm 11.9 13.3 4B.7 5.9 \nPart it ion 13.5 21.1 62.4 3.7 YACR-2 1s.5 546.2 37.1 14.0 base, 4 byte size, a 1 byte storage class \nspecifier, and a 2 byte capability. For run-time check optimization, we added a 1 byte dirty flag, a \n4 byte last index, and a 2 byte free counter for a total size of 22 bytes (450% overhead). Due to a bug \nin the C++ compiler, we could not use sizeof () in the safe pointer implementation if the referent referred \nto itselfi as a result, B C, AIin-Span, and Partition all required the size of the referent to be stored \nin the safe pointer, which added a 4 byte overhead for these programs. There were no space overheads \nfor array variables, as all required object attributes are known at compile-time. We only rewrote the \nactual pro\u00adgram code, all system library routines remained unchecked. We did, however, perform interface \nchecking. Whenever a system library is called, any pointer arguments are validated against the time and \nspace bounds expected by the library routine. For example, if a call were made to f read (), the interface \ncheck would ensure that the destination of the read was live storage and that the entire length of the \nread oper\u00adation would fit into the referent. 6.3 Results Figure 9 shows the execution overheads for \nthe analyzed programs. The Unopt columns show total dynamic instruc\u00adtion counts for executions with no \noptimization, and the Opt columns show instruction counts with run-time resolved op\u00adtimization. For the \nrun-time optimized executions, the normalized in\u00adstruction counts range from 2.3 ( YA CR-2) to 6.4 (B@. \nThis overhead reflects program performance without any compile\u00adtime optimization. While this performance \ndegradation will likely be acceptable for the development cycle of short or medium length program executions, \nit may still be pro\u00adhibitively expensive for very long running programs, and it is certainly too costly \na price to pay for in-field instrumen\u00adtation of a program. Examining more closely the breakdown of the \nexecution overheads yields much insight into how the performance of our checking methodology could be \nimproved. For each program, we break down the overhead costs into five categories. We measured this cost \nby compiling and run\u00adning the program repeatedly with incrementally more func\u00adtionality in the safe pointer \nimplementation. Original Pro\u00adgram is the instruction count for the unchecked program, always normalized \nto one. User Defined Ptr is the cost in our framework for imple\u00admenting all pointers as structures at \nthe user level. The pri\u00admary factors affecting performance here are increased loads, stores, and function \ncalls. The first factor is due to the MIPS cc compiler s handling of structure variables; once wrapped \nin a structure, the field variables are no longer eligible for reg\u00ad 45 ,~I. n. IR Anagram Backvcp BC \nMin-Span Partition YACR-2 U Or@nalPrw-am EZZ Usar OefinsdFtr ~ Spat!a Dat9 ~ SpatralChecks m TemFoialoat. \n~ Tempml Cheds Figure 9: Execution overheads. ister allocation. Wrapping attributes around pointers \nalso in\u00adcreases the costs of procedure call parameter passing. MIPS cc compiler passes most scalar arguments \nthrough registers; however, composite structures are always passed through memory (on the stack). The \nsecond major factor affecting performance is an increased number of function calls. The AT&#38;T C++ \ncompiler simplifies complex expressions created during template instantiation by extracting portions \nof the expression into static functions. This cost is only a side-effect of our implementation. Spatial \nData is the cost of maintaining and copying spatial object attributes. For the optimized executions, \nthis over\u00adhead includes the cost of maintaining the pointer dirty bits and previous index values. Spatial \nChecks is the cost of per\u00adforming spatial checks. Temporal Data is the cost of main\u00adtaining and copying \ntemporal object attributes. For the op\u00adtimized executions, this overhead includes the cost of main\u00adtaining \nthe additional counter variable. Temporal Checks is the cost of performing temporal checks. For BC, Man-Span, \nand Partition, run-time resolved opti\u00admization paid off with a slightly lower execution cost for spa\u00adtial \nchecking. For Anagram, Backprop, and YA CR-2, adding run-time checks resulted in a higher cost for spatial \naccess checking; and in the case of Backprop, a higher overall exe\u00adcution overhead. These programs demonstrate \nthe trade-offs involved in providing run-time resolved optimization. Run-time opti\u00admization-adds the \nextra overhead of copying, maintaining, and checking the extra safe pointer state. If this added over\u00adhead, \nplus the overhead of the required checks, is greater than doing all the checks, there is no advantage \nto run-time check optimization. With faster checks, compile-time optimization, and spatially complex \nprograms, this trade-off becomes even more acute. Since Anagram, Backprop, and YACR-2 must execute many \nof their checks (t?9~0, 67Y0, and 86% respec\u00adtively), they do not benefit from the run-time optimizations. \nFor YACR-2, the effects are much less pronounced because dereferences aremuch less frequent (asshownin \nTable l). The second effect to observe when comparing the opti\u00admized to unoptimized execution costs is \nthat the greatest benefit of run-time check optimization always comes from eliding temporal checks. In \nfact, adding run-time optimiza\u00adtion for temporal checks caused a significant decrease in all execution \noverheads except Backprop. There are two facets to this result. First, temporal checks are very expensive \n(requiring an associative search), so eliding one has a great Anagram Backprcp SC Mm-Span Pariilon YACR-2 \noOnglnal Prqiam@ll Usar C!efinwlPtr ~Spat.l Data w Spat.1 Chds D Tempo.1 oat. ~ TeinForalChaeks Figure \n10: Text overheads. performance advantage. Second, our run-time resolved op\u00adtimization of temporal checks \nis very effective. Temporal checks are rarely required, even for BC and Mwz-Span, both of which free \nstorage often. In the case of Backprop, adding run-time optimization for temporal checks resulted in \nan in\u00adcreased execution overhead. Backprop has only one dynamic object, an array, so temporal checking \nis relatively cheap without any optimization (the capability is always at the head of the hash bucket \nchain). In this case, the cost of maintaining the extra storage required for the free counter outweighs \nthe cost of executing all temporal checks. Adding checking code reduces the effectiveness of many traditional \ncompiler optimizations. We inline all check code except for calls to ValidCapabi.lit y ( ) and abort \n( ), These functions are both externally defined, so the compiler must make conservative assumptions \nas to what actions they take. This conservative approximation has the effect of limiting the effectiveness \nof many optimizations such as invariant code motion, register allocation, copy propagation, and common \nsubexpression elimination. Neither of these functions pro\u00adduce any side-effects for normal executions. \nHence, better compiler integration, i.e., providing a special channel of com\u00admunication between the safe \nprogram generator and the com\u00adpiler optimizer, would cert airily increase the performance of our safe \nexecutions.4 Text size overheads are shown in Figure 10. All check\u00ading code, except the capability routines \nand what the G++ compiler extracts for expression simplification, is inlined into the original program \ntext. Surprisingly, the text overheads are quite small; 3570 to ?IOO~o for the unoptimized executa\u00adble \nand 41% to 340% for the run-time optimized programs. The text sizes for the run-time optimized programs \nare larger due to additional code required for maintaining, copying, and checking the extra object attributes. \nAs shown by comparing Table 1 and Figure 10, there is a strong correlation between static dereference \ndensity and the resulting text overhead. The data size overheads, shown in Figure 11, are mea\u00adsured as \nthe total size of initialized (. data) and uninitialized (. b..) data segments plus the size of the heap \nsegment when the program terminates execution. The data size overheads on the stack were not measured. \nAll programs, except Min\u00ad 4Many compilers, e.g. GNU gee, already understand the sPe\u00ad cial semantics of \nabort ( ) and use this inter-procedural information to improve optimizations. We should be able to achieve \nthe same results for ValidCapabilityo. 4,5\u00ad . ...... .. ........... 4-............................................................. \n~. Il!l 35+ ..........--------.....................-.--. ---{ t.l.. ............................................... \n.-i33 m s ~ 25 % Q2 E 0 1s z 1 0s 0 Anagram Backprcp BC Mm-Span Patttion YACR-2 0 Omy.al Programn Useros.finadW \n~ Spahaloats C7 Temwal Data Figure 11: Data overheads. Span, have data size overhead below 100%. Backprop \nhaa the lowest overhead (less than 5%) because most of its storage is large global arrays which do not \nrequire any object at\u00adtributes. Min-Span has the highest overhead (330%), which stems from the high density \nof pointers in its heap alloca\u00adtions, most of which contain eight pointers and three inte\u00adgers. Some \nof the run-time optimized programs have slightly larger overheads due to the additional object attributes. \nTo summarize the main points of our results: Execution overheads, even without compile-time opti\u00admization, \nare low enough to make our methodology use\u00adful during program development. However, the over\u00adheads are \nnot likely low enough that programmers would releaae software with checking enabled. We are currently \nexploring the use of compile-time optimization and bet\u00adter compiler integration as means of increasing \nthe per\u00adformance of our approach.  The largest contributing factors to execution overhead are 1) safe \npointer structures are not register allocated, and 2) many traditional optimizations fail with the addi\u00adtion \nof checks. Other performance losses are attributed to the C++ compiler simplifying expressions through \nthe use of static functions, and, due to a bug in the C++ compiler, the need to include the type size \nof the referent in the object attributes. None of these difficul\u00adties are without recourse, however. \nBetter integration between the safe compiler and the optimizer could fix most problems.  Dynamically \neliding spatial checks is generally ineffec\u00adtive, primarily because maintaining the extra state, and \nchecking it, quickly outweighs the cost of executing all checks. Our spatial check is very cheap to execute, \nand pointer intensive programs tend to execute most of the checks anyway.  Temporal checks, on the other \nhand, are very expensive to perform and are rarely required, so run-time opti\u00admization shows to be beneficial \nin most cases.  The text and data size overhead are generally quite low. The text overheads for all \nprograms with run-time op\u00adtimization, range from 41% to 340Y0, with all but two below 100%. Data overheads \nrange from 5% to 330%, with all but one below 100%. Run-t ime optimized exe\u00adcutions have slightly larger \ntext and data sizes.   7 Related Work Our first attempt at creating a safe programming environ\u00adment \nfor C employed reference chaining. The technique is similar to that used by many smart pointer implementa\u00adtions \n[EP91, Gin92]. The idea is to insert any pointer which is generated either through use of explicit storage \nallocation, e.g., rnalloc t J, the reference operator ( % ), or assignment into a reference chain rooted \nat the referent. When a pointer value is destroyed, e.g., through assignment, storage deallo\u00ad cat ion, \nor at procedure returns, the pointer is removed from the reference chain. This technique has a number \nof useful properties. First, it is possible to ensure temporal safety by destroying all pointer values \nwhen a referent is freed just march down the reference chain assigning NULL to all point\u00aders. Second, \nif a destructed pointer value is the last value in the referent s reference chain, a storage leak hss \noccurred and it is detected immediately. Unfortunately, this tech\u00adnique cannot be made to work reliably \nin C. It is relatively easy for the programmer to subvert the checking mechanism through recasting and \ntypeless calls to free ( ). Storage leak detection also fails in the presence of circular references. \nThe safe programming technique described in this paper is signif\u00ad icantly more reliable because its correctness \ndoes not rely on tracking pointer values. Some researchers have recently proposed providing com\u00ad plete \nprogram safety through limiting the constructs allowed in the language. The main thrust of this work \nis the de\u00adsign of languages that support garbage collection reliably and portably. In [ED93], a safe \nsubset of C++ is defined. The safe subset does not permit any invalid pointers to be created; this restriction, \nfor example, precludes the use of any explicit pointer arithmetic. The safe subset also requires some \nchecking, but much less than our checking technique re\u00adquires. Languages which can easily be made totally \nsafe have existed for a long time; for example, many FORTRAN imple\u00admentations provide complete safety \nthrough range checking. However, these languages tend to be less expressive than in\u00adtrinsically unsafe \nlanguages such as C or C++. We felt that it was important not to restrict the expressiveness available \nto the programmer. Our checking technique is not limited by the language upon which it is applied, it \ncan be applied successfully to compiled or interpreted languages with sub\u00adscripted and mutable pointers, \nlocal references, and explicit and type-less dynamic storage management. Table 2 details our work (Sa~e-C) \nand five other published systems that support memory access checking. Hastings and Joyce s Purify [HJ92] \nis a commercially available memory access checking tool. It is particularly con\u00advenient to use because \nit does not require program source . all transformations are applied to the object code. Pu\u00adrify supports \nboth spatial and temporal access error check\u00ading to heap storage only through the use of a memory state \nmap which is consulted at each load and store the program executes. Purify also provides uninitialized \nread detection, and storage leak detection through a conservative collector [Boe93, BW88]. Spatial access \nerrors are detected by brack\u00adeting both ends of any heap allocation with a led zone . These zones are \nmarked in the memory state map as inac\u00adcessible. When a load or store touches a red zone a memory access \nerror is flagged. Temporal access errors are detected by cietting the memory state of freed storage to \ninaccessible. Purify cannot detect all memory access errors. For exam\u00adple, accessing past the end of \nan array into the region of the next variable, or accessing freed storage that has been real\u00adlocated \ncannot be detected. These limitations occur because Purzfy does not determine the intended referent of \nmemory Name Environment Method Error Model Sped,d Checka7 TemPoralChecks7 Extensions Safe-C c/c-t+ source-to-source \ntranslation yes* yes* errant free s Purify [HJ92] object files object code translation yes limited to \nheap yes limited to heap errant reads, free s, storage uninitialized leaks RTCC [Ste92] CodeCenter [KLP88] \nc c/c-t+ safe compiler interpreter yes* yes* no yes errant dynamic free s, type uninitialized checking, \nreads, etc. Bcc [Ken83] c source-to-source translation yes* no alignment overflow checks, checks UW-Pascal \n[FL80] Pascal safe compiler yes* yes errant free s, arithmetic faults, etc. Table 2: Comparison of that \nparticular error class. memory access checking work. Entries with an asterisk (*) indicate that the method \ndetects all errors for accesses it can only verify that the accessed storage is ac\u00adtive. Our checking \ntechnique, on the other hand, can detect all memory access errors because it tracks not only the state \nof storage, but also the intended referents of all pointer val\u00adues. To increase the effectiveness of \ntemporal error checking, Purify ages the heap, holdlng freed storage in the heap free list longer than \nneeded. This aging increases the storage requirements of programs that use the heap. The primary disadvantage \nof our technique compared to Purify is that we require source code before any checking can be implemented; \nthus, source code is required if libraries are to be checked. Our technique is also not portable across \nlanguages, that is, a given implementation must be tailored for a specific lan\u00adguage. However, our technique \nis quite portable across differ\u00adent platforms, especially if implemented as a source-to-source translator. \nAlthough Purify is portable across languages (on a given platform), it is not portable across platforms. \nSteffen s RTCC [Ste92] extended the functionality of the C language compiler PCC to include spatial error \nchecking. RTCC attaches object attributes to pointers in a fashion sim\u00adilar to our technique; it does \nnot, however, detect temporal access errors, nor does it explore the use of check opt imiza\u00adtion. Our \nchecking technique finds both spatial and temporal access errors, and incorporates run-time and compile-time \noptimizations through which access checks can be elided. In the implementation of RTCC the issue of interfacing \nto li\u00adbrary and system calls is addressed through encupsulatio~ Steffen also augmented sdb to provide \nusers with transparent debugging support. Code Center [KLP88] is an interpreted C language environ\u00adment. \nThe error checking provided is very rich it detects many memory access errors as well as provides dynamic \ntype checking (i. e., the type of the last store to memory must match the type of subsequent loads), \nuninitialized read de\u00adtection, errant free detection, and other useful checks. The published information \ndescribing Code Center is somewhat ambiguous as to how it implements memory access checking. Object attributes \n(namely, type and size) are attached to all storage when it is initialized. If a reference is made to \nstor\u00adage, it appears that the base and size attributes, associated with the referent storage, are also \nattached to the pointer value. Using this information, Code Center provides com\u00adplete coverage for spatial \naccess errors. However, it does not employ a capability based temporal checking scheme, so it is (sometimes) \npossible to access freed storage after it has been reallocated for another purpose. Temporal access checking \ncan also fail for pointer references to local variables. Because our checking technique employs a capability \nbased scheme, it never misses temporal access errors. The primary dis\u00adadvantage of Code Center is its \nresource requirements. Since programs run in an interpreter, the execution overheads may discourage its \nuse, and in the case of long running programs, may preclude its use. Due to our use of compile-time in\u00adstrumentation, \nresource requirements are significantly lower. Compile-time instrumentation also allows us to employ \nstatic check optimizations. Kendall s Bcc [Ken83] is a commercial source-to-source translator for the \nC language. It supports spatial error check\u00ading, but temporal error checking is limited to NULL checks \nat all pointer dereferences. The published information on Bcc does not specify how the checking is implemented, \nhowever, one figure in the paper, showing the output of the translator, suggests that base and bound \nobject attributes are attached to all pointer values. Fischer and LeBlanc s UW-Pascal compiler [FL80] \nsup\u00adports both temporal and spatial error checking. However, the lack of mutable pointers and dynamically \nsized arrays makes access checking much easier. While U W-Pascal detects all spatial access errors, temporal \naccess errors may not be de\u00adtected if storage is reallocated. Use of our checking technique is not limited \nby the expressiveness of the language; that is, it can be applied successfully to compiled or interpreted \nlanguages with subscripted and mutable pointers, local ref\u00aderences, unions, and explicit and typeless \ndynamic storage management. A closely related area of work, which can benefit from our safe programming \ntechnique, is storage leak detection [Boe93, BW88, ZH88]. A storage teak is any storage to which the \nprogram can no longer generate a name. These leaks occur when the last accessible pointer to a heap object \nis overwritten. Without the ability to generate a name to the heap object, it cannot be freed, hence \nit has leaked out of the heap. For languages like C and C++, leak detection is commonly implemented with \na conservative collector. A conservative collector sweeps memory looking for unreferenced storage. Because \nit is difficult to know where all pointers are located, the collector makes the conservative assumption \nthat all pro\u00adgram accessible (non-heap) storage contains pointers. It then uses a traditional mark and \nsweep collection method. While effective, this method has some drawbacks. First, storage leak detection \nis not immediate, it is usually applied only when the programmer demands it or when the program com\u00adpletes \nexecution. Thus, for it to be useful, some dynamic information, like a partial call chain, must be kept \nwith allo\u00adcations, in order for the programmer to deduce the circum\u00adstances under which the storage leak \noccurred. Second, the conservative pointer assumption can cause non-pointer val\u00adues to be mistaken as \npointer values which seem to reference heap storage. These false hits can hide a storage leak. The problem \nis aggravated by large storage allocations because it is more likely that non-pointer values inadvertently \nreference them; unfortunately, it is these large allocation leaks that we would most like to find. Third, \nif the program hides pointers, for example, by encoding type information in the upper bits of a pointer, \nor does not keep all pointers within the bounds of memory allocations, the collector may regard heap \nstorage as a leak when it is still in use. These false leaks cannot occur under our checking scheme because \nthe base field always holds a pointer to the head of the allocation, and the program cannot manipulate \nthis value. We can also address the problem of false hits, that is, non-pointer values which appear to \nreference heap stor\u00adage, by applying safe pointer invariants to possible references. One trivial test \nis to ensure that both the capability and the free counter values of the possible reference are valid. \nIf an incrementing counter is used for each, each value should be less than the current counter value. \nTo summarize, using a conservative collector to detect storage leaks with our safe programming technique \nmakes the process intrinsically more reliable by eliminating false leaks and reducing the possibility \nof false hits. 8 Conclusions In this paper, we presented a pointer and array access check\u00ading technique \nthat provides complete error coverage through a simple set of program transformations. Our technique, \nbased on an extended safe pointer representation, has a num\u00adber of novel aspects. It is the first technique \nthat detects all spatial and temporal access errors. Its use is not limited by the expressiveness of \nthe language; that is, it can be ap\u00adplied successfully to compiled or interpreted languages with subscripted \nand mutable pointers, local references, unions, and explicit and type-less dynamic storage management. \nWe showed the transformations required in the context of the C language, and also developed run-time \nand compile-time check optimization frameworks. Finally, we described our prototype implementation, and \nused it to analyze the execu\u00adtion, text and data size overheads of six non-trivial, pointer intensive \nC programs. We showed that performance with only run-time resolved optimizations was quite good. For \nall six programs, instruction execution overheads ranged from 130~o to 540%, with text and data size \noverheads typically below 100Yo. The primary factors to performance degrada\u00adtion in safe programs are \nthe lack of safe pointer register al\u00adlocation and ineffective optimization in the presence of check functions. \nWe see the solution to these problems as better integration between the safe compiler and the code genera\u00adtor. \nOur prototype implementation, while successful at show\u00ading the viability of our compile-time safe programming \nmeth\u00adods, leaves many questions of efficiency and usability unan\u00adswered. We are addressing these issues \nwith the development of our fully automatic, optimizing Saje-C compiler. Acknowledgements We thank Jim \nLarus, Tom Ball, Alain Kagi, and Alvy Lebeck for numerous discussions which helped shape this paper. \nAlso, thanks to Mary Baker, Hans-Juergen Boehm, John El\u00adlis, Mark Sullivan, Mark Weiser, Ben Zorn, and \nthe anony\u00admous referees for providing useful comments and directing us to relevant references. References \n[ASUS6] A.V. Aho, R. Sethi, and J.D, Unman. Con@ers: Prin\u00adciples, ? echnzques, and Tools. Addisoll-Wesley, \nReadiug, MA, 1986. [Boe93] Hans-Juergen Boehm. Space efficiel,t conservative garbage collection. Proceedings \nof the A C M SIGPLA N 93 Confer= ence on Programming Language Deszgn and Implementa\u00adtion, 2S(6):197 204, \nJune 1993. p3w8s] Hans-Juergen Boehm and Mark Weiser. Garbage collection in an uncooperative environment. \nSoftware Pract2ce and Experience, 18(9):807 820, September 1988. [ED93] John R. Ellis and David L. Detlefs. \nSafe, efficient collection for C++. Technical Report 102, DEC Research Center, June 1993. garbage Systems \n[EP91] D. R. Edelson and I. Pohl. Smart pointers: They re but they re not pointers. Proceedings of the \n1991 C++ Conference, April 1991. smart Userux [FHSS] Anthony gramming. J. Field and Peter Addison-Wesley \nG. Harrison. Publishing Functional Pro-Company, 1986. [FL80] Charles N. Fischer and Richard J. LeBlanc. \nThe implemen\u00adtation of run-time diagnostics in Pascal. IEEE Transactions on Software .%gineemng, SE-6(4):313 \n319, 1980. [Gin92] Andrew Ginter. Design alternatives garbage collector for the C++ programming nical \nReport 91/417/01, Department of University of Calgary, 1992. for a cooperative language. Tech-Computer \nScience, [GuP90] Rajiv Gupta. ing. proceedings Programmmg 272 282, June A fresh look at optimizing array \nbound check\u00adof the ACM SIGPLA N 90 Conference on Language Design and Implementation, pages 1990. [HJ92] \nReed Hastings and Bob Joyce. memory leaks and access errors. fJsenzz Conference, 1992. Purify: Proceedings \nfast detection of of the Winter [Ken83] Samuel C. Kendall. Proceedings of the Bee: Runtime checking for \nsummer Usenzz Conference, C programs. 1983. [KLPss] Stephen Kaufer, Russel C: an interpreter-based language. \nProceedings pages 161 171, 198S. Lopez, and Sesha Pratap. Saber\u00adprogramming environment for the C of \nthe Summer Usenix Conference, [Lar93] James R. Larus. Efficient 26(5):52 61, May 1993. program tracing. \nIEEE Computer, [Lee91] Peter tation. Lee, editor. The MIT Topzcs in Advanced Press, Cambridge, Language \nMA, 1991. Implemen\u00ad [MFS90] Barton P. Miller, Lars Fredriksen, and Bryan So. An empiri\u00adcal study of the \nreliability of Unix utilities. Communications of the ACM, 33(12):32 44, December 1990. [RosS?] Graham \nRoss. Integral C a practical environment for C programming. In Proceedings of the ACM SIG-SOFT/SIGPLAN \nSoftware Engineering Symposium on Practical Software Development Enmronments (SIGPLAN Notzces), pages \n42 48. Association for Computing Machiu\u00adery, January 1987. [SC91] Mark Sullivan and Ram Chillarege. Software \ndefects and their impact on system availability a study of field fail\u00adures in operating systems. Digest \nof the 21st International S~mposzum on Fault Tolerant Computing, pages 2 9, June 1991. [Ste92] Joseph \nL. Steffen. Portable C Compiler. 22(4):305 316, 1992. Adding Software run-time Practice checking to \nthe and &#38;cperience, [zH88] Benjamin filer for Usemz Zorn and C and Lisp Conference, Paul Hilfinger. \nA memory programs. %oceedmgs pages 223 237, 1988. allocation pro\u00adof the Summer  \n\t\t\t", "proc_id": "178243", "abstract": "<p>We present a pointer and array access checking technique that provides complete error coverage through a simple set of program transformations. Our technique, based on an extended safe pointer representation, has a number of novel aspects. Foremost, it is the first technique that detects all spatial and temporal access errors. Its use is not limited by the expressiveness of the language; that is, it can be applied successfully to compiled or interpreted languages with subscripted and mutable pointers, local references, and explicit and typeless dynamic storage management, e.g., C. Because it is a source level transformation, it is amenable to both compile- and run-time optimization. Finally, its performance, even without compile-time optimization, is quite good. We implemented a prototype translator for the C language and analyzed the checking overheads of six non-trivial, pointer intensive programs. Execution overheads range from 130% to 540%; with text and data size overheads typically below 100%.</p>", "authors": [{"name": "Todd M. Austin", "author_profile_id": "81100312227", "affiliation": "Computer Sciences Department, University of Wisconsin-Madison, 1210 W. Dayton Street, Madison, WI", "person_id": "P283115", "email_address": "", "orcid_id": ""}, {"name": "Scott E. Breach", "author_profile_id": "81100066114", "affiliation": "Computer Sciences Department, University of Wisconsin-Madison, 1210 W. Dayton Street, Madison, WI", "person_id": "P260751", "email_address": "", "orcid_id": ""}, {"name": "Gurindar S. Sohi", "author_profile_id": "81100336064", "affiliation": "Computer Sciences Department, University of Wisconsin-Madison, 1210 W. Dayton Street, Madison, WI", "person_id": "PP40036652", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/178243.178446", "year": "1994", "article_id": "178446", "conference": "PLDI", "title": "Efficient detection of all pointer and array access errors", "url": "http://dl.acm.org/citation.cfm?id=178446"}