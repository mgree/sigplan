{"article_publication_date": "06-01-1994", "fulltext": "\n Interprocedural May-Alias Analysis for pointers: Beyond k-limiting Alain Deutsch INRIA Rocquencourt \n78153Le Chesnay Cedex, France Alain.Deut sch@inria.fr Abstract Existing methods for alias analysis of \nrecursive pointer data structures are based on two approximation techniques: /s\u00ad hrnziing, which blurs \ndistinction between sub-objects below depth k; and store-based (or equivalently location or region\u00ad based) \napproximations, which blur distinction between elements of recursive data structures. Although notable \nprogress in inter\u00ad procedural alias analysis has been recently accomplished, very little progress in \nthe precision of analysis of recursive pointer data structures has been seen since the inception of these \nap\u00ad proximation techniques by Jones and Muchnick a decade ago. As a result, optimizing, verifying and \nparallelizing programs with pointers has remained difficult. We present a new parametric framework for \nanalyzing recur\u00ad sive pointer data structures which can express a new natural class of alias information \nnot accessible to existing methods. The key idea is to represent alias information by pairs of symbolic \nac\u00ad cesa paths which are qualified by symbolic descriptions of the positions for which the alias pair \nholds. Based on this result, we present an algorithm for interproce\u00ad dural may-alias analysis with pointers \nwhich on numerous ex\u00ad amples that occur in practice is much more precise than recently published algorithms \n[CWZ90, H.90, LR92, CBC93]. 1 Introduction and related work Alias analysis: definition and applications. \nAliasing occurs when two distinct names (data access paths) denote the same run-time location. It is \nintroduced by reference parameters and pointers. The aim of existential alias anal\u00ad ysis algorithms is \nto determine for each program point 1 an upper approximation of the exact set of possible pairs of access \npaths that may be aliased when 1 is reached. Exis\u00ad tential alias analysis is also called may-alias analysis. \nComDile-time alias information is imDort ant for scalar .. optimization such as code motion; compile-time \ngarbage\u00ad collection; program verification and debugging; dependence analysis; parallelism at ion and \nimproving code generation for instruction-level parallelism [Wa91, HG92, RF93]. Static determination \nof aliases for reference parameters and single-level pointers is now a well understood problem for which \nthere exists accurate polynomial intraprocedu\u00ad ral [SF+ 90] and interprocedural [LR91] algorithms. How- \nPermission to copy without fee all or part of tkk material is granted provided that the copies are not \nmade or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication \nand Its date appear, and notice is given that copying is by permission of the Association of Computing \nMachinery. To copy otherwise, or to republish, requires a fee and/or speoific permission. SIGPLAN 94-6/94 \nOrlando, Florida USA Q 1994 ACM 0-89791 -662-ti9410006..$3.5O ever, determining aliases for recursive \npointer datatypes is a much harder problem [La92b]. Intuitively, this is because alias sets become potentially \ninfinite, and because transfer functions are not distributive as with single-level pointers. Existing \nmethods. Approxi mate existential alias anal\u00ad ysis methods for pointers can be classified into: store-based \n methods and access-paths based methods. These methods use either jimte graphs (or abstract stores) to \nrepresent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, \nSt92] possibly augmented with reference count information [Hu86, He88, CWZ90], set9 oj paws oj acce99 \npaths to represent alias\u00ading [CC77b, We80, ASU86, He90, SF+90, La92a, LR92] or a combination of the two \n[CBC93]. Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of \ngraph nodes (abstract locations) [J081, JM82] determined by the allocation context. All these methods \npartition an infinite number of run\u00adtime objects (or access paths) into a finite number of equiv\u00adalence \nclasses. As a consequence, store-based methods will typically fail to distinguish between elements of \nrecursive pointer data structures. This is because a finite number of graph nodes have to be used during \nthe analysis to represent all the elements of those potentially unbounded structures. This introduces \nfalse cycles and precludes, for instance, dis\u00adtinguishing either between a linear and a cyclic list, \nor be\u00adtween a tree and a graph. Similarly, approximation meth\u00adods based on k-limiting fail to distinguish \nbetween elements of recursive pointer data structures that are below depth k. They can distinguish a \ntree from a general directed graph. But as soon as a sub-object below depth k becomes aliased, aliasing \nerroneously propagates to all other sub-objects be\u00adlow depth k, contaminating even objects of different \ntypes. [De92b] presents a theoretical framework for alias analy\u00adsis. The formalism used is based on Eilenberg \ns unitary\u00adprefix monomial decomposition [Ei74], on Parikh s com\u00admutative decomposition [Pa66] and on \na storeless semantic model of aliasing properties based on right-regular equiva\u00adlence relations. The \nmain result of that paper is the lattice of unitary-prefix monomial relations on subsets of a regular \nlanguage, which is shown to be an abstract interpretation of the lattice of right-regular equivalence \nrelations. The present paper provides a practical application to impera\u00adtive languages of the general \ntheory of [De92b]. [He90] cannot handle cyclic data: as noted in [HHN92], this is a serious obstacle \nto its use in languages with point\u00aders. [CWZ90] and [He90] can distinguish to some extent between trees, \ndags and graphs. The first one extends store\u00adbased methods with reference counting, but is accurate only \nstruct List char { *hd; Algorithm Result at Doint L2 Spurious aliases struct List *tl; {(x+tl+tl,x+tl+tl+tl), \n}; struct List * [LH88a] (Y+tbtl,Y+tbtW), (Y;tl+hd,YM+tl+hd), . . . Copy(struct List *L) { struct List \n*p, *tl; x {(X+hd,X+tl+hd), cl: if (L == null) 01 (Y+hd,Y+tl+hd),[CWZ90] Ca: return(L); Y (YytbtWad,X+hd), \nc~: p = rnalloc(...); 01 ...} c,: tl = L+tl; X {(x+tl+tl, Y+tPtl), Gs: P+tl = Copy(tl); (X+tl+tl+hd,Y+ti+tl+hd), \nc.: p+hd = L+hd; [LR92] (xMl+tl,Y+tM+tq, c,: return(p); } } x+ti,x+tl+tl , {(x, Sl), (Y, S2), (fY+tl,Y+tl+tl)! \nI* Xisanunaliasedlwt *I [CBC93] (Sl+hd, S3), (S2+hd, S3), (Y~tl+hd,Y+tl+tl+hd), Ll: t2 = X; (Sl+ti, \nsl), (s2+tl, S2)} Y = copy(t2); -{j~;tl+)ahd, Y+(tb) hd) I L2: X = null; Deutsch none L3. Program property \ndiscovered ] [LH88a] [CWZ90] [LR92] [CBC93] Deutsch  PI : X and Y are acvclic ves ves yes Pi : two successive \nh~ads of Y don t alias ~es yes P3: Xand Ytailsdon t alias yes yes yes yes P4 : heads ofXand Yarealiased \nonly pairwise yes Pfi : at point Ls, heads and tails of Y are completely unaliased yes yes Figure 1: \nPrecision of alias analysis algorithms on a structure-copying program creating two lists whose elements \nare pairwise aliased (adapted from [LH88b, p. 103]) intraprocedurally in limited cases, as reference \ncounts can\u00adnot, in general, be decremented safely. Contributions. 1. an expressive and parametric program \nanalysis frame\u00adwork for may-alias analysis with pointers. Our framework embodies an expressive notion \nof de\u00adpendency that, for example, allows relationships be\u00adtween positions in a data structure and aliasing \nto be captured. For inst ante, the property: the ith element of list X is aliased to element 2i + 1 of \nlist Y can be represented exactly in our semilattice frame\u00adwork. We believe that such a notion of position\u00addependent \naliases is new. Our alias analysis frame\u00adwork is parametrized by a lattice framework Vfl whose purpose \nis to express information about tuples of in\u00adtegers. In essence, this lattice VI controls qualita\u00adtively \nthe ability to reason about dependencies (typ\u00ad ical examples of Vd are constant propagation [Ki73], linear \narithmetic constraints [Ka76], arithmetic interv\u00adals [CC77a], simple sections [BK89] etc., and combi\u00adnations \nof these). 2. an algorithm for interprocedural may-alias analysis with pointers. Based on our parametric \nframework, we define a polynomial-time, flow-sensitive algorithm for may\u00adalias analysis for a call-by-value, \nimperative language with arbitrary recursion, dynamic allocation, nested recursive structures, pointer \nvariables and pointers to functions, excluding casting and unions. This encom\u00ad passes a large subset \nof the C language. Why is it significant? An example Our method pro\u00advides a solution to an open problem \n[LH88a, CWZ90, He90, HHN92]: how to improve the accuracy of alias analysis in the presence of recursive \npointer data structures. The information obtained by our analysis is generally much more precise than \nthat obtained by previous methods. Figure 1 presents the analysis results of several methodsl on an example \ndue to Larus &#38; Hilfinger [LH88b, p. 103]. The spurious aliases are due to k-limiting (Larus&#38;Hilfin\u00adger, \nLandi&#38;Ryder) or to collapsing together different heap nodes (Chase et aL, Choi et al.). As can be \nseen, the anal\u00adyses arein general not strictly comparable in precision. In Figure 1, we therefore consider \nspecific program properties Pi, ..., P5 andexamine which anslyses candiscover each of them. Section 2 \npresents our parametric join semilattice for alias analysis and the corresponding intraprocedural trans\u00adferfunctions. \nTheinterprocedural framework, based on the notion of generic object names, is presented in Section 3. \nSection 4discusses thetime complexity ofour method, and our prototype implementation is discussed in \nSection 5. Fi\u00adnally, we assess the precision of the sdias information dis\u00adcovered by our framework in \nSection 6. I Node labels computed by the method [LH88a] arc not shown. In the entry [CWZ90], graph nodes \nare annotated with approxi\u00admate reference counts. For themethod[CBC93], the S1, S2, . . . areheap names \n(allocation sites). Alias pairs areshown for read\u00adability without the external level of dereferencing. \nFor instance the pair (X+hd, Y+hd) is really (*( X+Dhd), .( Y+hd)). 2 The intraprocedural framework 2.1 \nThe join semilattice 2.1.1 S ymbol.ic access paths An access path is a string of selectors connected \nby the field component operator . . Selectors include structure field names, variable names and the dereferencing \noperator * . Z is the set of all selectors for a given program. Access paths are internally represented \nin postfix notation. For instance the C language pointer expression X->lef t, which is by definition \nequivalent to (*X) . lef t, is represented in postfix notation as the access path X*. left. The algorithms \nwe present below operate on access paths in postfix form. For readability y, however, we will write access \npaths using the ordinary C language representation. A symbolic access path (SAP for short) is an access \npath possibly containing symbolic expressions of the form 13k, where B is a set of access paths called \na bums, and k is a variable. 13\u00b0 denotes the empty access path e, and Bn+l is the set 13. Bn. Consider \nfor instance the SAP2 f = X+(ti+=)ihci. If i = O then f denotes the set {X+hd}; if i = I then j denotes \nthe set {X+tl+hd} and so on. Con\u00adsider the SAP g = T+{iefi+, ~ight+}~ key. If j = O then g denotes the \nset {T +key}; if j = 1 then g denotes the set {7 + left+key, Z +mght+key} and so on. What kind of symbolic \nexpressions can occur in a symbolic access path? The basis of a recursive pointer type t is a set of \naccess paths B = Basu(t) such that: (1) if an access path x yields an object of type twhen applied to \nan object of type tthen ~ S B ; (2) B is minimal. Figure 2 presents recursive types and their associated \nbases. The function Basis maps a recursive pointer type name to its corresponding basis. Bases can be \nrepresented by deterministic finite automata (DFA) over the alphabet of accessors E, and states of the \nDFA are just type names. Bases for mutually recursive types are defined similarly, see Appendix. Definition \n2.1 (Symbolic access paths) A symbohc ac\u00adcess path is a strtng of the form el. ez. . .e~, where for each \n1 < i < n, e, is ezther: 1. a selector s E E; 2. an expression of the form Bk, where k is a coefictent \nvariable and B = Basis(t) M the basts of some recur\u00adswe type t.  We write fv(~) to denote the set of \ncoefficient variables occurring in the SAP ~. In practices a basis can be rep\u00adresented uniquely by its \ncorresponding type name, and a global table can be maintained by mapping type names to bases represented \nby DFA. 2,1.2 The numeric lattice Our lattice for alias analysis is parametrised by a nu\u00ad meric lattice \n@ . V~ determines which class of relations between positions in aliased data structures can be cap\u00ad tured. \nIndependent (mono-dimensional) numeric lattices include: constant propagation [Ki73], arithmetic intervals \n[CC77a, M084] and arithmetic congruences [Gr89], Rela\u00adtional (multidimensional) numeric lattices include: \nlinear 2 The internal, postfix representation of the symbolic access path f is X*.(tl*)i.hd. 3 The theoretically \ninclined reader is encouraged to consult [De92b] and [De92e., $3] for a theoretical account of the correc\u00adtion \nbet we en SAPS, the unit ary-pretix monomials of Eilenberg s treatise [Ei74] and Parikh s commutative \ndecomposition [Pa66]. struct List { char *hd; struct List *tl; } struct Li.st2 { struct List *hd; struct \nList2 *tl; } struct Tree { char *key; struct Tree *left ,*right; } Basis(hwct List) = {tZ+} Basts(stwct \n.List2) = {tl+} Basis(struct Tree) = {Iefl+, right+} Figure 2: Recursive pointer types and their corresponding \nbases equahtzes [Ka76], hnear inequahties [CH78], simple secttons [BK89, CC92], linear congruence equalities \n[Gr91] and con\u00adgruent~al trapezoids [Ma91]. We will now list our assump\u00adtions about the numeric lattice \nand its associated opera\u00adtions, so as to keep our construction parametric by avoiding dependence on a \nparticular numeric lattice. Hypothesis 2,1 (Properties of the numeric lattice) Given a finite set of \nvarzables V, the numerical latttce V[(V) is equipped with the followzng abstract operators which are \nupper approximations of their exact counterparts an P(V + N) (sets of maps from variables to integers): \n1. the bwaary operations A (meet] and V (join) upper ap\u00adproximate mtersectton and unzon on sets; 1 represents \nexactly the empty set; 2. projection: if U ~ V then ProjectH(K) U) c VU(U) is the projection of K E \nVU(V) onto U; 3. extension: if K E V (V) then K T U c VU(U U V) w the exterwon of K to U U V; resolution \nof a linear system: zf S i9 a system of ltnear equations over V then S[(S) is an upper approxima\u00adtion \ntn V[(V) of the set of integer sohhons to S; 4. 5. intersection with a linear system: zf S u a system \nof linear equatzons over V and K G V!(U) then Cfl(K, S) zs an upper approxzmatzon in Vti(U U V) of the \nset of integer sotutzons to S that are also in K; 6. meet of spaces of different dimensions: if K1 E \nV!(U)  and K2 E VI(V), K1 Ah Kz a~ (Kl t V) A (K2 t U). In adchtzon we define T = SK(0). FznaUy, t$ \nVB(V) has mjinite hezght then it is equipped wdh a widening operator V [CC77a] to ensure terminatzora \nof fixpoint computations. The relational lattices enumerated above satisfy this hy\u00adpothesis (except the \nlattice of simple sections [BK89] which must be extended as explained in [CC92, $9.1]). Each in\u00addependent \nnumeric lattice L can also be accommodated by defining Vu as the n-fold (smash) product of L. V! can \nalso be defined using one of the systematic methods for combin\u00ading analysis frameworks proposed in [CC79, \n$10]. By abuse of notation, we will write Vu instead of Y (V) when V is clear from the context. If K \nE VI(V) then Dom(K) = V (Dom(K) is the domain of K).  2.1.3 The parametric semilattice UR(V ) Definition \n2.2 (Symbolic alias pairs) A symbolic alias pair is of the form ((fI, f2), K), where fl and fz are sym. \nbolic access paths; K c Urn; Dom(K) = fv(~l) U fv(f2) and the coejjicient variables of fl and f2 are \nd~s~omt. In addition we say that a pair ((~1, ~z ), K) is named canonzcaily if the sequence of coefficient \nvariables occurring in left to right order in the SAPS fl and -fz is a sequence of Algorithm u (Join \nof symbolic alias relations) Input: two symbolic alias relations QI, QZ E UR(Vn) Output : their join \nQ1 u Q2 Method: e := elUg2; exhaustively apply the following on g: if ((A, A), K) E e ~d ((fl, f2), ~ \n) E Q then replace these two pairs by ((.fl, f2), ~V ~ ); return g Example: ~1 ={((x+(~z+)k ~~, Y+(tl+)k \nhd), Sn{kl=o, k2=o})} ez={((X+(tl+)k hd, Y+(i/+)k~hd), St{kl=l, k2=l})} if V[ is the lattice of arithmetic \nintervals ~CC77a]: ell-i~2= {(( X+(t/+)kl /ad, Y+(t/+)kz hd), SB{O<k1,k2<l})} if Vu is Karr s lattice \n[Ka76]: e1ue2={((X+(t/+ )kl M, Y+(t/+)kz hd), Sfl{kL=k2})} Figure 3: The join operator predefine variables, \nsay kl, kz, . . . The operator Rename maps a symbolic alias pair ((~1, ~2), K) to its canonically named \ncounterpart, and extends componentwise to sets of symbolic alias pairs. For instance: (( X(+tl)kl +hd(+t[) \nz+hd, Y(M)ka%d),Sfl{k, = k, +k,}) is a symbolic alias pair which is canonically named. Proposition 2.3 \n(Symbolic alias relations) The set UR(VU) oj symbolic ahas relations over Vu M a semtlattice with least \neiement ~ = @ and join U where: 1. a symbolic alias reiat~on Q ouer Vfl is a set of canon\u00adically named \nsvmbolzc alias pairs over VU such that if  ((fI;t2),W Eeand ((fi,fzj,~ ) E ~= ~ i\u00ad e then 2. the jotn \noperator is computed pointwise, see Figure 3. 2.1.4 Termination of fixpoint computations The parametric \nsemilattice UR(VU) we have just defined has infinite chains: (1) because the number of possible SAPS \nis not bounded; and (2) because V! may have infinite chains (for instance the lattice of intervals [CC77a]). \nWe define the normalisation operation Factor which maps a SAP j to a SAP ~ in which potentially unbounded \nsubsequences of ~ (paths through recursive data struc\u00adtures) have been replaced by bases guarded by new \ncoef\u00adficient variables. For instance, Factor applied to the SAP t = x+t~+tl+hd would return a pair (~ \n, S) consisting of the SAP ~ = X+(tl+~hd and of the system of equations S = {i = 21. The ahrorithm Factor \nis shown in Fi~ure 15. W: exte~d Factor-by overloading: given a symb~lic alias relation e, Factor(e) \nis a symbolic alias relation obtained by normalizing (with Factor and Rename) the symbolic alias pairs \ncontained in Q. The widening Q1V P2 of two symbolic alias relations is defined as follows: (1) normalise \nc1 and Q2 using Factor; (2) apply pointwise the numeric widening operator V (this is similar to the join \noperator)4. This operator V is in\u00adserted in the data flow equations at points contained in a feedback \nset W of the dependence graph of the equations. For instance, the feedback set can be defined as the \nset of intervals headers or loop headers, see Appendix for details. 4 If the numeric lattice V H has \nno intinite chains, then the widening operator on symbolic alias relations can be defied sim\u00adply as: \nelV@~ = l tactor(e~) l-l Factor(@z). A4atchG(X-Wh+ X+(t[+)i) = {({z= 1}, hd)} Match3(X+(ti+) hd, X+t2) \n= {({i= j + 1}, +(t[+)jhd)} Compl({i = j+ l,k = 2}, {j}) = {Sn{o < k < l},Sd{k ~ 3}, Sfl{i = O}} if e \n= {(( X+(t/+)ihd, Y+(tl+)jhd), Sfl{i = j})} then : Equwa/enceCLzss u(Y+hd, e) = {( Y+hd, T), (X+(tl+) \nhd,Sfl{i = O})} StripPrejizB(*X, {(.Y, T), (X+tl+hd, T)})= {(tl+hd, T)} StripPrefZrB(*( X+t/), {(.Y, \nT), (*( X+(t/+) hd), Sti{i ~ O})}) = {((t/+ )khd+, SK{k ~ 1})} StarC20surefl({ (t2+t2+, T)}, #tract Li$i) \n= {((tl+) , S!{i mod2 = 0})} StarClo9urefl({ ((t[+) tl+, SK{i > 2})}, struct Li8t) = {((tl+) )sn{t 2 \n0})} if P = {( X+(ti+)i, S~{i > l})}, Q = {((t/+ )i, Sfl{i > 2})} then : P.Q = {( X+(t[+)i(,t/+)J, Sfl{i \n~ l,j ~ 2})} P.* = {(*( X+(t/+)l), SB{i > l})} Figure 4: Elementary operations: examples  2.2 The function \nspace We have defined the parametric semilattice UR(V[) of symbolic alias relations, and we equipped \nit with a join operation U, a least element 1 and widening operator V to ensure the termination of fixpoint \niterations. We now define transfer functions that model the effects of individual program stat ements \non symbolic alias relations. 2.2.1 Elementary operations Transfer functions operate on sets of symbolic \nalias pairs, which contain svmbolic access Daths. Therefore, we define . operations to manipulate these \nsymbolic representations. Examples are presented in Figure 4 and full definitions ap\u00adpear in the Appendix. \nThe binary operator Match determines if a symbolic ac\u00adcess pat h ~ can enerate (cent ains) a particular \naccess path,$ or a prefix of it . More precisely, &#38;fatchM(M, N) takes as parameters: (1) a relational \noperator M which must be one of {~, 3, =}; (2) two access paths kf and N, one of which at most is symbolic. \nMatchM(M) N) returns a set of so\u00adlutions the form (S, A), where the residual A is a (possi\u00adbly symbolic) \naccess path and S is a system of equations. Each (S, A) is such that the equation A4 w N.A is true for \neach assignment of the numerical coefficients of kf, N and A which is a solution of equation system S. \nThe operator Corngd takes a system of linear equations S and a set of variables U, and returns Compl(S, \nU), a set of .. elements of Vt whose union upper approximates the comple\u00ad ment of the system S with \nrespect to the positive integers. Variables of U occurring in the system S are assumed to be arbitrary \npositive integers which are eliminated. A symbolic path set is a set of pairs (~, K), where j is a symbolic \naccess path, and K an element of Vu. Such sets will be used to represent finitely possibly infinite sets \nof access paths. For instance {(X+( tl+) hd+( tl+)J hd, St{i = 5 This is necessary because alias relations \nare right-regular [J081]: if r is aliased to # then for each path 6 (such that x.6 exists), 7r.6 is aliased \nto 7r .6. Algorithm Killn(~)(Q) (Deletion of a fixed access path n) Input: a symbolic alias relation \ng E UR(VK) Output : a symbolic alias relation Kill~(~)(p) Ifethod: J.-.\u00ad 0; $oreach symbolic alias pair \n((~1, fz), ~) E Q do K := KillPath(T, f,, K) ; K := KillPath(T, j,, K) ; if (K # 1) then p := Q u{((fl, \nf2), K)} return .q Algorithm KillPath(n, f, K) Input: an access path m, a SAP f, and an element K of \nVu Output : an element KiUPath(x, f, K) of Vfl Method: A := {Com?l(S, fi(A)) I (S, A) $ Match= (~, f)} \nK :=KA (K Ah K ) ; (Av \\ \\BG4K eB ) return K Example: KdtPath(X+tZ+hd, X+(t{+)kl M, Su{lq = 1}) = 1 \nKiUPath(XWMd, X+(t[+)kI hd, S~{kl ~ 1}) = S[{kl ~ 2} KiUPath(XM, X+(tJ+)kl hcf, S[{kl > O}) = Sfl{kl \n= O} Figure 5: The transfer function Kill[(r) j})} denotes an infinite set of access paths which is contezt. \nfree but not regular. The binary operator Equivalence C[assd (m, g) computes a symbolic path set which \nrepresents the set of access paths to which the access path x is aliased in .q. Implicit aliases that \ncan be deduced by reflexive, symmetric and right-regular closure are taken into account. This operation \nis based on ilfatche. In addition, symbolic operations (intersection and projection) on the numerical \nlattice element K have to be performed to extract relevant information. The operation StrzpPrefi~ (~, \nP) computes a symbolic path set denoting the set of access paths obtained by strip\u00adping the prefix r \nout of the access paths represented by P. This operation is also based on Match. The operator StarCtosured(P, \nt) computes a symbolic path set denoting the star closure of the set of access paths denoted by P, where \nt is the recursive type to which paths of P can be applied. This is based on Match and Factor. The infix \noperation . computes a representation of the concatenation of (the access paths denoted by) two sym\u00adbolic \npath sets P and Q. Given a symbolic path set P and an access path T, we also write P.r for P.{(T, T)}. \n2.2,2 Deletions (kills) The transfer function Kill (z), where ~ is a fixed access path, deletes all the \nalias pairs whose left or right compo\u00adnent contains T (or an extension of m). Deletions are used to model: \n(1) when a variable goes out of scope at the exit from a lexical unit (local block or procedure); (2) \nassign\u00adments: X = Y first kills *X, then generates aliases int re\u00adduced by the alias pair (*X, *Y) (using \nthe function GenH). Assignments to a component also kills aliases, for instance X+tl = Y first kills \n*( X+tl), then generates aliases induced by (*( X+ti), *Y). Kill (~) is presented in Figure 5. Algorithm \nGen[(lhs.u, rhs)( Q) Input: two access paths Ihs.u and rhs s.t lhs.u ~ rh,9 and ih~.u ~ rhs; a symbolic \nalias relation p output : a symbolic alias relation e which incorpo\u00adrates the aliases generated by the \nassignment lhs. a + rhs Method: E := Equivalence Classi (lhs, Q); /* aliases of lhs */ B : = StripPrefixH(rhs, \nE); C := StarClosrmeti(B.u, Z ypeoj(rhs)); P := E.u.C; e := Qu RewriteK(rhs, P)(Q); return e Figure \n6: The transfer function Genl  2.2.3 Alias introduction What are the effects of the assignment of rhs \nto ihs.u, where cr is simple selector ? For instance, we have lhs = X+tl, u H * and rhg G *Y for the \nassignment X+ti = Y. Assume without loss of generality that the access paths rhs and ihs are not comparable \nby the prefix relation (otherwise first copy rhs: assignments such as X = X+t.1 are decomposed in the \ntwo assignments tmp = X+%1 and X = tmp, followed by KiU (*trnp)). We describe exactly the aliases introduced: \n1. if lhs is not aliased: it generates the pair (lhs. u, rhs); in addition, an incoming alias pair (rhs.~ \n, r ) generates the pair (lhs.u.x , T ) (and symmetrically); an incom\u00ading pair (rhs.~ , rhs.z ) generates \n(Ihs.u.z , Uts.u.z ). In short, we say that the effect of this assignment is Rewrite(rhs, {lhs.a}); \n2. if ihs is aliased to the access paths E = {ihs, rl, T2 . .} and no ~i cent ains rhs as a prefix: as \nan assignment to lhs must also assign to all of the aliases of lhs, the net effect is Rewrite(rhs, E.cr); \n 3. if lhs is aliased to the access paths E = {lhs, m, m . . .}, and B ~ E, with B =-{rhs.fll, ;hs.~zl~. \n.} tie aliases of lhs cent aining rhs as a prefix: the effect is Reunite (rhs, E.a. ({flI, &#38;, . . \n.}. cr)* ) (this assignment creates cycles).  This case analysis describes precisely the aliases gener\u00adated \nby an assignment [J081, De92a], in terms of (pos\u00adsibly infinite) sets of alias pairs. We now define an \nab\u00adstract counterpart of this operation which does not oper\u00adate on sets of alias pairs, but on (finite) \nsymbolic alias re\u00adlations. The abstract counterpart of Rewrite, the opera\u00adtion Rewrite [(rhs, P), maps \na symbolic alias relation e to a symbolic alias relation p = Rewrite n(rhs, P)(e). As for Rewrite, rhs \nis an access path, but P is a symbolic path set. The transfer function Genti is shown in Figure 6, m \n= {((*( Y+(ti+);hd), *( Z+(tt+)jhd)), Sl{i = j})} x = Y%l; f [ m = {((* X,*( YWZ)}, T), + ((*( Y+(tl+)ahd), \n*( Z+(tZ+)jhd)),S~{, = j}), ((*( X+(tl+) hrf), *( Z+(tl+)Jhd)),S1{J = ~+1})} Transfer function: f = \nGenti(*X, *( Y+tl)) o Kill[(*X) Figure 7: Analysis of an assignment Algorithm Calli{(jl, al ), . . . \n. (~~, a~)}(eca]l) Input: formals ~1 ,..., fn, distinct arguments al,..., aw, a symbolic alias relation \n~call  r-J=i+c T{( I al) ; HF(f  fnR @.xit Returnn } -#-i --1-. _ Figure 8: Interprocedural information \nflow Example 2.4 Assume the altasing Just before the assign\u00adment shown in Figure 7 is described by the \nsymbolic alias re\u00adlation Q1, then aliasmg after this assignment is e, = f (Ql). 3 The interprocedural \nframework Interprocedural methods for non-distributive problems over large semilattices limit information \nloss by analysing procedures separately [CC77C, SP81, JM82], keyed by some token abstracting the call \ncontext. However this usually re\u00adsults in information loss for recursive procedures, as each recursive \ncall can generate a new semilattice value. There\u00adfore, following [CC77C, Ha79, MR89, LR92], we perform \ntherefore generalisation of data flow values through func\u00adtion calls and instantiation through function \nreturns. Con\u00adsider two alias pairs (z, ml) and (z, 7rz ) reaching the entry of a function F( z, g). If \nml and mz are not visible in F and in the functions called by F, we can generalise these two alias pairs \nby a single alias pair (x, U). U is a generic ob\u00adject name. The key observation, due to [MR89, LR92], \nis that F operates unsjmndy on all the aliases of z that are not visible. Then F will be analysed with \nthe incoming pair (z, U), and the aliasing at the output of F can be propa\u00adgated back by instantiation. \nThis is done by applying the transformation [U ~ m, U I-+ Tz]. We assume in the rest of the text that \nno two distinct variables have the same name. This can be achieved, for instance, by prefixing each variable \nby the name of its static definition point (e.g. procedure name). 3.1 Generic objects In order to perform \ninstantiation and generslkation on symbolic alias relations, we enrich symbolic access paths with generic \nobjects of the form U[kl, . . . . k~], where U is a name. Intuitively, U[kl, . . . . k~] stands for an \nunknown symbolic access path whose coefficients are Icl, . . . . kfi. 3.2 Function calls A call S1: \ny= Foal,..., an); S2: to a function F with formal parameters fl, . . . . ~fi is modelled by the transfer \nfunction Callp as follows: (@ II~ry, ~~hr~us~, @) = Cdn{(fl, al),..., (fw, %)}(&#38;all) All is the symbolic \nalias relation describing the aliasing at program point SI; QthrO sh rCpeSentS the aliaSeS Of @cdl that \nare not affected by F and that do not affect F, they can be directly propagated to point Sz; ~~~t,Y represents \nthe aliases of ~=all plus those induced by the binding of each for\u00ad mal fi to the corresponding actual \na;, see also Figure 8. The alias relation e=n~,Y contains only the symbolic alias pairs relevant to F, \nand generalisation has been performed. The set of symbolic alias pairs @ represents the substitution \nto be applied upon return from F. @ associates generic ob\u00adjects (introduced during the generalisation) \nwith the sym\u00adbolic access paths they represent. The arguments al, . . . . an are temporaries which are \nkilled by the call: this discipline avoids the introduction of spurious aliases between a formal parameter \nand a dead argument. Output: the symbolic alias relations @~t,Y, ~ih,~~sh and o Method: foreachi=l, . \n. ..n do Q.all := [Killf(a;.*) o Gen~(~i.*, a;.*)] (gc~u) done; support : = . . . . fn} u GlobalVartables; \n{fl , ,=0; @,=0; Qentry : = 0; Qthr.augh f oreach symbolic pair ((gl, g2), ~) C QC.11 do if gl end gz \nera in support then @.nt ry := @entry U {((91, 92), )}; if neither gl nor gz is in gupport then ethrough \n:= &#38;%hr.ush U {((91, g2), ~)]; if g2 is in support and gl is not in support then (@entry,@) : = Generalise \n(((gl, gz), K), gentry, @); if gl is in support and gz is not in support then (eentry, e) := Generaksen(((gz, \ngl ), ~), @entry)@) done; return (@entry, pthrOu5h, @) Figure 9: The interprocedural transfer function \nCallt The transfer function Calln is shown in Figure 9. The function Generali$et(((gl, gz ), ~), Qentry, \n@) f3enera~ses the symbolic pair ((gl, gz ), ~) by replacing gt with a generic object U[kl, . . . , kn], \nwhere n is the number of coefficients of g2, and updating accordingly Qentry ad @. The generic object \nname U is determined uniquely by the factorised form of the symbolic path gz. 3.3 Function returns The \npropagation of aliases back to a calling point is mod\u00adelled by the transfer function Returnn: Q,.tu,n \n= Returni(@e~it , Qthrough, @) where the symbolic alias relations et hrmgh and @ have b-n computed by \nthe corresponding Callfl, and @exit is the sym\u00adbolic alias relation describing aliasing at the exit of \na func\u00adtion F. The newly computed symbolic alias relation ~,~t ~.~ describes the abasing just upon return \nfrom F. ReturnK es\u00adsentially instantiates each generic object name occurring in Qexit. Each generic name \nis red-d by the Swbofic ac\u00ad paths it represents, as described by @. Because we consider a call-by-value \nlanguage, formals need not be replaced by corresponding locals. Finally, the aliases Qthr..sh are added \ndkectly to the result Qr,t ,~. The transfer function Returnfl is shown in Figure 10. Given a variable \nor a generic object name u, the func\u00adtion Instantiate[(u, K, ~) returns a set of pairs (u , K ) ob\u00adtained \nby replacing u by the symbolic access paths asso\u00adciated with u in @ and adjusting accordingly K. For \nin\u00adstance if@ = {(( UI[k], z+(tl+)thd), SK{k = 10 1})}, then htantiaten(Ul[j], Sfl{j = 2i}, @) = {(z+(t~+)~hd, \nS[{j = 10 1, j = 2i})}. As in the intraprocedural case, widening operators must be inserted in the interprocedural \nequations in order to ensure termination of fixpoint iterations, see Ap\u00adpendix. Example 3.1 Consider \nthe following program fragment: void F(struct List *L) { Fl: result = L+tl; Fz : } Algorithm Ret?JrnH(@,it, \n@th,~~~h, ~) Input : the symbolic alias relations ee.i~, &#38;%h,o~@ and @ Output: the symbolic alias \nrelation .QM.,. Method: er=turn : = 0; @ := @ U {(g, g) [ g E Global Variables}; f oreach symbolic pair \n((df, v~), ~) 6 Qexit if u and v are globals or generic names then foreach (W , ~l)C InstantuzteH(u, \n~,@) end (v , ICz) E Instantiate[(v, K, @) do K := KIAhKz; if (K # 1) then Qreturn := Qr.t.r. u Re~~~e{((~ \n~, v fIO, ~ )} done fi; (h.turn : = Lbeturn U Qthrough ; return Qr.turn Figure 10: The interprocedurs.1 \ntransfer function Retur-nfl P, F(a); P2 The corresponding data jlow equations are then: (FI, e, 0) = \nCalln{(L, a)}(R) Fz = [Genfl(*restdt, *(-L+tl)) o Kill[(*result)] (F,) { Pz = Return (Fz, LI) @) Because \nthe functson F is not recursive, widening operator-a are not needed. Assume that ahasmg at point PI is: \nPI = {((*a, *X), T), ((*( X+(tl+)k hd), *( Y+(tl+)k hd)))S1 {kl = kz+l}), ((*(a+ (ti+)k hd), *( Y+(tl+)k \nhd)), S {kl = kz+l})} The solution of the above data flow equations is then: FI = {(( U,, *.L), T), ... \n (( U,[k,]:*(&#38;tl+)k2 hd)),S[ {k, = k,})} @ = {((Ul, *X), T), (( U2[k,], *(Y+(tl+ ) 2hd)), Si{kl = \nk,+l})} e = {((*( X+(ti+)k hd), *( Y+(tl>)k2hd)), Sti{kl = kz+l})) Fz = FI u {((*result, *( U1. ti)), \nT), ((*result, *(L+tl)), T), ((UZ[k~], *(result*(t~+)k hd)), S${kl = k~+l})} P2 = {((*result, *( X+ti)), \nT), ((*( X+(tl+)k hd), *( Y~(tl~) 2 hd)), St{k, = kz+l}), ((*(remdt>(tl+) k hd), *( Y+(tl+)k2hd)), .S \n{kl = k2})) 3.4 Extended interprocedural framework As with any iterative program analysis, the precision \nof our basic interprocedural framework can be improved by keeping several symbolic alias relations at \neach program point of a procedure, each qualified by a different token. This is to avoid non-realizable \ninterprocedural paths. The seminal papers [CC77C, SP81, JM82] present systematic and direct methods to \nperform this extension. [LR92] uses alias sets of size one as tokens, [CBC93] uses calling points and/or \nincoming alias sets (which can result in exponen\u00adtial behaviour, see [ML+ 93]). We clearly separated \nthe ba\u00adsic interprocedural framework from its extensions, unlike [LR92, ML+ 93]. Our framework can therefore \neasily be ex\u00adtended to an arbitrary token set. This is an issue orthogonal to the present contribution. \nPointers to functaons can be accommodated using a technique similar to [De90]. struct List * Reverse \n(struct List *X, *Y) { struct List *p, *q; if (X == null) q=x; else { p = X+tl; X+tl = Y; q = Reverse \n(p, X) ; return(q) ; } Gz: 1 = Reverse (l, null) ; Gs: Figure 11: A destructive list-reversal function \n 4 Complexity We define: n the number of program points, m the max\u00adimal length of a normalised symbolic \naccess path, A the number of distinct normalised symbolic access paths, and the parameter ~, which varies \nbetween 1 (for control flow graphs with fixed outdegree) and 2 (for control flow graphs in which every \nprogram point depends on all the others). h(v) is the height of the numerical lattice Vti on v coefficient \nvariables. In terms of the number of node evaluations, the worst case complexity of our analysis is O(np \nx AZ x h(2rn)). h(v) is v + 1 for the constant propagation lattice, 4V for the lattice of intervals, \nv + 1 for the lattice of linear equalities and 8V2 + 4V for the lattice of simple sections. m is the \nlength of the longest access path that traverses each recur\u00adsive pointer type at most once. In real programs, \nm is likely to be small and even bounded. 5 Prototype implementation Our interprocedural program analysis \nframework has been rxototvDed in Standard ML, as a Parametric mod\u00ad . .. ule (functor) taking as a parameter \na module implementing the numeric framework V[. Excluding the numerical lat\u00adtice, which is 22OO lines \nlong, the implementation of the semilattice and its transfer functions requires 6000 lines of Standard \nML. Symbolic alias relations are implemented by two-level tries: a first trie maps each symbolic access \npath to a trie mapping symbolic access paths to elements of the numerical lattice VI. The numerical lattices \nwe have ex\u00adperimented with are: (1) the lattice of arithmetic intervals [CC77a]; (2) the combination \nof the lattice of intervals and of the lattice of linear equalities [Ka76] (see [CC79] and [Gr92] for \nan explanation of how to devise an optimal com\u00adbination). Data flow equations augmented with widening \noperators are solved using standard iterative techniques. Preliminary experimentation -not yet of statistical \nvalue -indicates that the number of iterations was less than 10 and took less than 30 seconds to analyse \nprograms of less than about 50 lines. 6 Precision of the analysis We have shown in the introduction that \nour frame\u00adwork can discover position-dependent aliasing properties. But how well does our framework perform \nwhen the ex\u00adact dependence between aliased positions cannot be cap\u00adtured? Consider the program fragment \nshown in Figure 11. Reverse destructively reverses the list X, without in\u00adtroducintr cvcles. Exact relationships \nbetween initial and final pos~ions in X cannot be captured, as it would require information about the \nlength of X. Assume that 1 cent ains some sharing, for inst ante that its 10 first elements point other \nmethods fail to detect, even on elementary pointer to z. Aliasing at point G2 is thus: programs, Although \nwe have not yet experimented with our approach on medium to large size programs, the para\u00ad ((*(l+(tl+)ihd), \n*Z), Sf{i < 9}), metric nature of our method gives us confidence about the 2= ((*(l+ (tl+) hd), *(l+(tl+) \nhd)), Sf{i, j < 9]){ } scalability of our approach. We are currently undertaking Our analysis discovers \nin four iterations over Reveree that systematic experimentation on real C programs. aliasing at G3 is: \nWe conjecture that many other applications ofourorigi\u00adnal concept opposition-degremfentp roperties to \nthedetermi\u00ad ((*(l+ (tl+) hrf), *Z), So{i ~ O}), nation of properties of dynamically allocated pointer \ndata = ((*(i+ (tl+) hd), *(l+(tl+)Jhd)), Sfl{i, j > O}) { } structures are possible. We have correctly \ndetected that no cycles have been in- Acknowledgements. We would like to thank Keith troduced by Reverse. \nSuch information is important for Cooper, Patrick Cousot, Evelyn Duesterwald, Mooly Sa\u00adoptimisation, \nfor instance to perform software pipelin\u00ad giv and Linda Torczon for their helpful comments. ing [HHN92, \nRF93]. In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list 1 may References \nbe cyclic at G3. [He90] would probably detect that 1 is [POP91] ACM Press. Eighteenth Annual ACM Symp. \non Princi\u00adplea of Programming Language8, Orlando, FL, Jan. 1991. not cyclic. However, as noted in [HHN92], \n[He90] is not [PLD92] ACM Press. SIGPLA N*92 Conf. on Programming Lan\u00ad of general applicability as it \ncannot handle graph-shaped guage Design and Implementation, volume 27(7) of SIG\u00addata. The store-based \nmethods [LH88a, HPR89, 13e90, PLAN Notices, San Francisco, June 1992. St92, CBC93] fail because of their \ninability to distinguish [AsU86] A. Aho, R. Sethi, and J. UIImrm. Compilers: Principles, an unbounded \ndata structure from a cyclic data structure Techniques Took. Addison\u00ad and Wesley, 1986. [BK89] V. Balasundaram \nand K. Kennedy. A technique for sum\u00ad (this is independent of the parameter k of [St92, CBC93]). marizing \ndata access and its use in parallelism enhancing The addition of reference counting proposed by Chase \net transformations. In SIGPLA N 89 Con.f. on Programming al. also fails, asdiscussed intheir paper [CWZ90, \np.309, $8]. Language Design and Implementation, volume 24(7) of Regardless of the value of the parameter \nk of their analysis, SIGPLAN Notices, pp. 41 53, June 19S9. [Br64] J. Brzozowski. Derivatives of regular \nexpressions. .1. A CM, [LR92] also report a cyclic list as it detects spurious aliases 11:481 494, 1964. \nof the form (*(l+*(l+tl+ti+ti)). tl+tl),  [CWZ90] D.R. Chase, M. Wegman, and F.K. Zadeck. Analysis \nof Landi &#38; Ryder s method is based on sets of pairs crfk-pointers and structures. In Conj. on Programming \nLan\u00adguage Design and Implementation, voiume 25(6) of SIG\u00ad limited access paths. Itwill not report aliasing \nwhen a data PLAN Notices, pp. 296-310, June 1990. structure is completely unaliased, unlike store-based \nmeth\u00ad [CBC93] J.D. Choi, M.G. Burke, and P. Carini. Efficient flow\u00adods. However, as soon as one subcomponent \nof an object sensitive interprocedural computation of pointer-induced u located at depth >k become aliased, \nspurious aliasing of aliases and side-effects. In Twentieth Annual ACM SVmp. all the subcomponents of \nu below depth k will be reported. on Principles of Programming Languages, pp. 232 245. ACM Press, Jan. \n1993. This is a class of situations in which our method is markedly [CCF91] J.D. Choi, R. Cytron, and \nJ. Ferrante. Automatic Con\u00adsuperior to k-limited methods. struction of sparse evaluation graphs. In [POP91]. \n[C081] P. Cousot. Semantic foundations of program analysis. In Conclusion Program Flow Analyaia: Theory \nand Application, pp. 303-342. Prentice-Hall, 1981. Alias analysis for pointers is a long-standing and \ncriti\u00ad [CC77a] P. Cousot and R. Cousot. Abstract interpretation : a uni\u00adcal issue in optimizing, verifying \nand parallelising imper-fied lattice model for static analysis of programs by con\u00adative languages. It \nis becoming even more crucial since struction of approximation of fixpoints. In Fourth Annual ACM Symp. \non Princip le8 of Programming Languages, the advent of superscalar architectures and massively par\u00ad pp. \n23S 252, Jan. 1977. allel processing, which place a higher demand on optimizing [CC77b] P. Cousot and \nR. Cousot. Static determination of dynamic compilers to restructure code. properties of generalized type \nunions. SIGPLA N Notices, Virtually every existing alias analysis method is based 12(3):77-94, Mar. 1977. \n[CC77C] P. Coumt and R. Con sot. Static determinant ion of dynamic on two approximation techniques proposed \nby Jones and properties of recursive procedures. In Working Conf. on Muchnick: store-based approximations \nand k-limiting. As Formal Description of Programming Concept8. IFIP WG was pointed out by several researchers, \nthese techniques are 2.2, North-Holland, Aug. 1977. not sufficiently accurate to apply optimisation methods \nto P. and Cou.sot. pro\u00ad [CC79] Cousot R. Systematic design of gram analysis frameworks. In Sixth Annual \nACM Symp. programs with pointers. on Principles of Programming Language8, Pp. 269 282, Based on our previous \ntheoretical results in seman\u00ad 1979. tics, formal language theory and abstract interpretation [CC92] P. \nCousot and R. Cousot. Comparing the Galois connec\u00ad[De92b, De92a], we have proposed a method for may-alias \n tion and widening-narrowing approaches to abstract in\u00adt erpretation. In Programming Language Imp lemsntation \n analysis which radically departs from the currently preva\u00ad and Logic Programming, .Jth Int 1. SyImp, \nPLILP 92, vol\u00adlent store-based andk-limited approximation methods. The ume 631 of Lecture Notes on Computer \nScience, pp. 269\u00adkey concept is that of symbokca ccesspathsq ualified by in-295. Springer Verlag, Aug. \n1992. teger coefficients denoting positions in data structures. Us-[cH78] P. Cousot and N. Halbwachs. \nAutomatic discovery of linear restraints among variables of a program. In Fifth Annual ing existing numerical \napproximation techniques developed ACM Symp. on Princip lea of Programming Languages, for scalar and \narray analysis, we can finitely represent the pp. 84 97, Jan. 1978. set of positions for which a given \npair of symbolic access [De90] A. Deutsch. On determining lifetime and aliasing of dy\u00adpaths holds. We \nobtained thus a practical, flow-sensitive namically allocated data in higher-order functional spec\u00adificat \nions. In Seventeenth Annua2 ACM Symp. on Prin\u00ad interprocedural analysis framework which can detect a \nnew ciples of Programming Language8, PP. 157-168. ACM class of may-alias properties that were out of \nreach of ex- Press, Jam. 1990. isting alias analysis methods. [De92a] A. Deutsch. Operational Mode 1s \nof Programming Lan- We have implemented a prototype to assess the practical guages and Representations \nof Relations on Regular Languages with Application to the Static Determina\u00ad feasibility of our approach. \nPreliminary experimentation tion of Dynamic Aliasing Properties of Data. PhD the\u00addemonstrates that our \nalgorithm is significantly superior, sis, LIX, Ecole Polytechnique, F-91128, Palaiseau, France, in that \nit can extract accurate pointer information that 1992. [De92b] [DGS94] [Ei74] [Gr89] [Gr91] [G.92] [Ha79] \n[Ha89] [H.88] [H.90] [HG92] [HHN92] [HPR89] [HU86] [ICC92] [J081] [JM81] [JM82] [J081] [Ka76] [Ki73] \n[La92a] [La92b] [LR91] A. Deutsch. A storeless model of aliasing and its abstrac\u00adtions using finite representations \nof right-regular equiva\u00adlence relations. In [ICC92], pp. 2 13. E. Duesterwald, R. Gupta, and M.L. Soffa. \nReducing the cost of data flow analysis by congruence partitioning. In International Conference on Compzler \nCon8tructi0n, to appear in the Springer Verlag Lecture Notes in Computer Science, Apr. 1994. S. Eilenberg. \nAutomataj Languages and Machines, vol\u00adume A. Academic Press, 1974. P. Granger. Static analysis of arithmetical \ncongru\u00adences. International Journal oj Computer Mathematical, 30:165 190, 1989. P. Granger. Static analysis \non linear congruence equalities among variables of a program. In TAPS OF T 91, volume 493 of Lecture \nNotes on Computer Science, pp. 169 192. Springer Verlag, 1991. P. Granger. Improving the results of \nstatic analyses of pro\u00adgrams by local decreasing iterations (extended abstract). In Proc. 12th Conference \nof Foundations of Sojtware Technology and Theoretical Computer Scw?nce, Lecture Notes on Computer Science, \npp. 68 79. Springer Verlag, Dec. 1992. N. Halbwachs. D6tevmznation automatique de relatiom IinJair-es \nv6rifiie. par l.. variables d un prog.amme. PhD thesis, Universit6 Scientifique et M&#38;dicale de Grenoble \n&#38; Institut National Polytechnique de Grenoble, Grenoble, France, Mar. 1979. W.L. Harrison. The interprocedural \nanalysis and auto\u00admatic parallelisation of Scheme programs. Lisp and Sgnn\u00adboiic Computation, 2(3):176 \n396, Oct. 1989.  L. Hederman. Compile time garbage collection. Master s thesis, Rice University, Houston, \nAug. 1988. Tech. report COMP TR88-75.  L. Hendren. Parallelizing programs with recursive data structures. \nIEEE Trans. on Parallel and Distributed Proc\u00adessing, 1:35 47, Jan. 1990.  L.J. Hendren and G.R. Gao. \nDesigning programming lan\u00adguages for analyzability: a fresh look at pointer data struc\u00adtures. In [ICC92], \npp. 242 251.  L.J. Hendren, J. Hummel, and A. Nicolau. Abstrac\u00adtions for recursive pointer data structures: \nImproving the analysis and transformation of imperative programs. In [PLD92], pp. 249-260.  S. Horwitz, \nP. Pfeiffer, and T. Reps. Dependence analysis for pointer variables. In Conj. on Prograrnmzng Language \nDesign and Implementation, volume 24(7) of SIGPLAN Notices, pp. 28 40, June 1989.  P. Hudak. A semantic \nmodel of reference counting and its abstraction. In Conf. Record of the 1986 ACM Syrnp. on LISP and Functional \nProgramming, pp. 351 363, Aug. 1986. Proc. of the IEEE 1992 International Conf. on Com\u00adputer Languages, \nSan Francisco, Apr. 1992. IEEE Press.  N.D. Jones. Flow analysis of lambda expressions. In Symp. on \nFunctional Languages and Computer Archi\u00adtecture, pp. 376 401. Chalmers University of Technology, June \n1981.  N.D. Jones and S. Muchnick. Flow analysis and opti\u00admization of Lisp-like structures. In S. Muchnick \nand N.D. Jones, editors, Program Flow Analysis: Theory and Ap \u00adpiicatiom, pp. 102 131. Prentice-Hall, \n1981.  N.D. Jones and S. Muchnick. A flexible approach to inter\u00adprocedural data flow analysis and programs \nwith recursive data structures. In Ninth Annual ACM Symp. on Princip\u00adles of Programming Languages, pp. \n66 74. ACM Press, 1982,  H.B.M. Jankem. Ab9tract storage structures. In de Bakker and van Vliet, editors, \nAlgorithmic Languages, pp. 321 343. IFIP, North Holland, 1981. M. Karr. Affine relationships among \nvariables of a pro\u00adgram. Acts ~nfomnatica, 6:133 151, 1976, G. Kildall. A unified approach to global \nprogram opti\u00admisation. In ACM Symp. on Principles of Programming Languages, pp. 194 206, 1973. W. Landi. \nIntevpvocedu?al Akzsing in the Presence of Pointers. PhD thesis, Rutgers University, Jan. 1992. W. Landi. \nUndecidability of static analysis. ACM Letters on Programming Languages and Sy8teme, 1(4):323 337, Dec. \n1992. W. Landi and B.G. Ryder. Pointer-induced aliasing. In [POP91], pp. 93-103. [LR92] W. Landi and \nB.G. Ryder. A safe approximate algorithm for interprocedural pointer aliasing. In [PLD92], pp. 235 248. \n [LH88a] J.R. Larus and P.N. HiIfinger. Detecting conflicts between structure accesses. In ACM SIGPLAN \n88 Conf. on PTo \u00adgr-ammzng Language Design and Implementation, pp. 21 34, June 1988. [LH88b] J.R. Larus \nand P.N. Hilfinger. Restructuring Lisp pro-Krams for concurrent execution. In ACM SIGPLAN 88 ?onf. on \nParallel Programming: Experiences with Ap\u00adplications, Languages and Systems, pp. 100 110, June 1988. \n[ML+ 93] T.J. Marlowe, W.G. Landi, B.G. Ryder, J.D. Choi, M.G. Burke, and P. Carini. Pointer-induced \naliasing: A clarifi\u00adcation. SIGPLAN Notices, 28(9):67 70, Sept. 1993. [MR89] T.J. Marlowe and B.G. Ryder. \nHybrid incremental alias algorithms. Tech. report LCSR-TR-129, Rutgers Univer\u00adsity, Oct. 1989. [Ma91] \nF. Masdupuy. Using abstract interpretation to detect ar\u00adray data dependencies. In Proc. of the International \nSymp. on Supercomputing, pp. 19 27. Kyushu University Press, Nov. 1991. ISBN 4-87378-2848. [M084] E, \nMorel. Data flow analysis and global optimisation. In B. Lorho, editor, Methodn and Tools for Compiler \nCon\u00adstruction, an Advanced Course, pp. 289 315. Cambridge University Press, 1984. [NPD87] A. Neirynck, \nP. Panangaden, and A.J. Demers. Compu\u00adtation of aliases and support sets. In Fourteenth Annual ACM Symp. \non Principles of Programming Language a, pp. 274 283, 1987. [Pa66] R.J. Parikh. On context-free lanma~es.. \nJ. A CM, 13:670 . 581, 1966. [RF93] B. Rau and J. Fisher. Instruction-level parallel processing. The \nJournal of Supercornputing, 7:9 50, 1993. [RM88] C. Ruggieri and T. Murtagh. Lifetime analysis of dynami\u00adcally \nallocated objects. In Fifteenth Annuat ACM Symp. on Principles of Programming Language8, pp. 285 293. \nACM Press, Jan. 1988. [SF+ 90] S. Sagiv, N. Francez, M. Rodeh, and R. Wilhem. A logic\u00adbased approach \nto data flow analysis. In Programming Language Implementation and Logic Programming, VOl\u00adume 456 of Lecture \nNotes on Computer Science, pp. 277 292. Springer Verlag, Aug. 1990. [SP81] M. Sharir and A. Pnueli. \nTwo approaches to interprocedu\u00adral data flow analysis. In S. Muchnick and N.D. Jones, ed\u00aditors, Program \nFlow Analgsis: Theory and Applications, pp. 189 234. Prentice-Hall, 1981. [Sh91] 0. Shivers. Control-flow \nAnalysis of Higher-Order Lan\u00adguages. PhD thesis, Carnegie Mellon University, Pitts\u00adburgh, May 1991. CMU-CS-91-145. \n[st92] J. Stransky. A lattice for abstract interpretation of dy\u00adnamic (Lisp-like) structures. Infomnatzon \nand Computa\u00adtion,101(1):70 102, Nov. 1992. [wa91] D.W. Wall. Limits of instruction-level parallelism. \nIn Proc. ASPLOS III, pp. 176 178, Apr. 1991. [W.80] W.E. Weihl. Interprocedural data flow analysis in \nthe pres\u00adence of pointers, procedure variables, and label variables. In Seventh Annual ACM Symp. on Principles \no.j Pro\u00adgramming Languages, pp. 83 94, 1980. A Appendix Generating bases for mutually recursive pointer \ntypes. Given the mutually recursive types tl, . . . . t~, we define Basw(t;) as the minimal set of access \npaths B such that B generates all paths mapping objects of type t: to objects of type t, without traversing \nobjects of type tj with j < i. This ordering condition is necessary to ensure that each path from tjto \nitself that traverses tihas a unique factorisation in Baszs(tj ). See Figure 12 for an example. The algorithm \nMatch. itfatch~(ill, N) is defined by it\u00aderative decomposition. The only more complex case occurs when \nthe leading term of M is an iterated basi8 Bk such no proper prefix p of N consisting only of accessors \nis prop\u00aderly in B and that some p is in a prefix of B. For instance: MatchH(BkM , sons+ tl+N ) with B \n= sons+ (tl+)xhd. In this case we compute the derwative of B w.r.t, sons+tl+ Basis(stmctkfl%ee) =sons+(tl+) \nhd+ struct MTree { char *key; struct TreeList *sons; } struct TreeList { struct MTree *hd; struct TreeList \n*tl; } Baszs(stmct TTee.L2st) = {t/+} Figure 12: Mutually recursive pointer types and thei~ cor\u00adresponding \nbases (see [Br64]), which yields a set {B; ,..., l?:} of regular ex\u00adpressions in monomial form [Ei74] \n(no U appears in B; un\u00adless it is contained in a star expression). For our example, we get one regular \nexpression {( ti +) * hd}, and the matching proceeds with MatchH(( tl+)k hd.M , IV ). The algorithm Factor \n(Figure 15). The normalisation of a SAP f is performed in three steps. First, subsequences of (a copy \nf of) f beginning with a selector u and traversing a recursive type tare replaced by a term of the form \nBk, where B is the basis of the type t. The system of equations S is augmented with either k = O (if \nthe traversal is partial) or k = 1 (if the subsequence performs a full traversal of i!). Second, if the \ntype of ~ is a recursive type, a basis .Bk is appended to f, and k = O is recorded in S. The third step \nsimplifies ~ by replacing occurrences of the form Bk .Bk by Bk and recording the equation k = k + k . \nWe then extend Factor to symbolic alias relations in Figure 16. The widening operator V(Figure 14). Given \ntwosym\u00adbolic alias relations QI and gz, their widening glV~2iscom\u00adputed by first normalizing their SAPS \n(using Factor). The f oreach loop then applies the widening operator associated to the numeric lattice \nV[ to the numeric spaces Kand If of each symbolic alias pair defined in both ~1 and Qz. Placement of \nwidenings. Widening operators must be inserted in the interprocedural data flow equations [CC77a] as \nfollows: (1) determine a jeedback set W of the dependence graph of the equations such that any cycle \ntraverses at least a node from W; (2) if the data flow equation X; = t(Xj ) is in the feedback set, with \ntsome transfer function, then replace it by Xi = Xi Vt(Xj ). W can be defined, for in\u00adst ante, as the \nset of (int erprocedural) loop headers, see [C081, p.334]. The algorithm E@ualenceClass[ (Figure 17). \nThe func\u00adtion Equivalence Class (z, g) computes a symbolic path set P representing the set of access \npaths to which m is aliased in e ss follows: each pair ((fl, fz), K) of Q is examined (with Match~ ) \nto check if ~1 (resp. ~Z ) can generate a prefix of r. In this case, the SAP A represents the paths which \nmust be appended to fl (resp. $2) to generate m (thk is necessary because of right-regular reduction). \nThe system of numeric equations S describes the values of the coefficients of fl (resp. f,) for which \nfl (resp. ~z) generates a prefix of z, and the corresponding values of the coefficients of A. The numeric \nspace K is then intersected with S, and projected onto the coefficients occuring in ~Z (resp. ~1 ) and \nA, yield\u00ading K . For the example of Figure 17, we have: S = {i=l} and A = {hd}, C (Sti{i=j-l}, S) = S]{i=j \nl, i=l} and K = S {j=2}. The pair (fZ.A, K ) is then added to P. Finally, P is adjusted to take reflexivity \ninto account. The remaining algorithms, see Figures 18, 19, 20 and 21, are based on conceptually similar \nmechanisms. Pointers to functions. Among the global variables, we distinguish the set F of function names. \nGiven a par\u00adticular function name f, the assignment p = f generates (in particular) the alias pair ((*p, \n*f), T). To analyse the higher-order function call y = (*q)(al, . . . . an), where g is of function pointer \ntype, we compute ~he symbolic path set Q = EguiuaienceC1ass (*q, ecall ). Q then contains directly the \nset of function names potentially called. This is a tech\u00ad nique similar to [De90]. Exploiting sparsity \nof data flow equation systems. Alias analysis is an interesting candidate for sparse evalu\u00ad ation graph \ntechniques [CCF91, DGS94]. These methods simplify data flow equations by eliminating copies and ex\u00adploiting \nidempotence of the join (or meet) operator. Oppor\u00adtunities for such simplification occur in data flow \nequations for alias analysis: copies occur because of statements that do not involve pointers, and joins \ncan be typically elimi\u00adnated at the end of conditionals that does not involve point\u00ad ers. We are investigating \nthe incorporation of the new ap\u00ad proach [DGS94] in our analyser and plan to evaluate the impact on performance. \nCompaction methods. Because aliasing is symmetric, we perform symmetric reduction by: (1) defining a \ntotal order < on SAPS (which ignores coefficient names); (2) enforcing that each symbolic alias pair \n((f, g), K) satisfies f ~ g. This can divide the number of alias pairs by two. Because aliasing is reflexive, \nwe perform refiezive reduction, by discarding a symbolic alias pair ((j, g), K) if it generates only \nreflexive alias pairs. Because ~ and g can be symbolic, reflexive reduction is based on the Match operation. \nNot every alias analysis can perform reflexive reduction in gen\u00aderal. For instance, an alias pair (u, \nv) where u and v are of length k cannot be safely removed in the analysis of [LR92]. Because aliasing \nis right-regular (e.g z aliased to y implies z. 6 aliased to y. 6) we also perform right-regular reduction. \nThe symbolic alias pairs produced by our framework are generally not right-regularly closed, but there \nare neverthe\u00adless opportunities for right-regular reduction. These three reduction methods should not \nbe applied to the sets of sym\u00adbolic alias pairs El used in CallP and Returnn, as they do not denote symmetric \nrelations. These reductions can however safely be applied to all other symbolic alias relations. Un\u00adlike \nthe transitive reduction method proposed in [CBC93], these compaction methods provably do not result \nin loss of precision. Generation of data flow equations. We have ex\u00adplained how to handle assignments, \nfunction calls and re\u00adturns. We now illustrate the translation of other statements through the example \nin Figure 13. Function return values are handled by assigning the re\u00adturn value to the global variable \nresult (see cecit ~, Cetwit2 ). Because Copy is recursive, the dependence graph of the equations in Figure \n13 cent ains two cycles: Centry + cjnl+c~ -+... + CI -+ Cantrv and C exit -+ Cezit= + C r + C6 + Ca,l \n+ Cezit. Two widening operations have thus been inserted; one at function entry (see Centr~) and one \nat function exit (see Cecit ). Conditional branches guarded by pointer comparisons can be taken into \naccount [CC77C, p.2711. For instance, the transfer function corresponding to if (L == null) then . . \n. is KillH(*Z) (see Cz). Other predicates, such as pointer equality testing can be handled similarly. \nCent.g = Cent. g~(Cinl l-l CtT12 ) c1 = Cent.y C2 = Kill[(*L)(Cl) Cen,tl = GenH (*result, *L)(C2 ) c, \n=c1 C4 = Kill Crj = Genfl(*tl, *( L%1))(C4) (Cim~ , Cthmughl YE)I) = CallK{(L, tI)}(C6) C6J = ~etwnn \n(Cecit, Cthroughl ! 1) C6,2 = Kill[(*(P+41))( C6,1 ) c.?+ = Genfl(*(P%l), *result) (C6,, ) C6 = Killl \n(*result) (Ctj,, ) C7,1 = Kill[(*(P+hd))(C6) C7 = GenH(*(P+hd), *(-L+= M))(C77,1) Ce=it, = Genfl(*restdt, \n*P)(C7) Ce=~t. = C ezit V(cezitl U ce22it2 ) L2,1 = GenB(*t,, *X)(L1) 02) = Callfl{(L, t2)}(JZ2,1)(tin,, \nCthmmgh,, ~2,2 = R.dUTnn(cezit, Cthrough2, 2) L2,3 = Kill (*Y)(L2,2) L2,4 = GenH(*~ *result) (L,,,) Lz \n= Kill[(*result)( Lz,, ) Ls = Kill  Figure 13: Data flow equations corresponding to the pro\u00adgram of \nFigure 1 Algorithm V (Widening on symbolic alias relations) Input : two symbolic alias relations ,g, \n.Q, c UR(V[) Output : their widening el VQ, Method: . .\u00ad e 0; QI := I actor(Ql); Q, : = Factor; f oreach \nsymbolic alias pair ((~1, i2), ~) ~ QI do if there exists a pair ((.fI) ~2), ~ ) C Q2 then e := Qu {(( \nfl, f2), ~vK )]; e, := !$?2 {(( fl, Jf2)) ~ )}; else  e := eu{((fl, fz), ~)}; return ~ U Q2; Example: \nlet ~1 = {((*( X~hd), *( Y+M)), T)} Q2 = {((*( X+tZ+hd), *( Y+tZ+hd)), T)} U L?I if VI is the lattice \nof arithmetic intervals [cc77a]: QiVQ2 = {((*( X+(tl+) hd), *( Y+(tl+)Jhd)), Sfl{O<i, j<l})} if Vfl is \nKarr s lattice [K%76]: QIVQ2 = {((x( X~(tl~) hd), *(YA(tl~)~hd)),St{i=j})} Figure 14: The widening operator \nV Algorithm Factor(f) Input: a symbolic access path f output : a normalised symbolic access path j and \na sys\u00adtem of linear equations S relating the variables off and f Method: s ,=0; y :=j; apply the following \nto f 1 b left to right order: let f =el ... ei ... en such that: (1) e; is a selector e; G X and (2) \nTypeof(el . . . .5;-1) is a recursive type t; let B := Basis(t) and k be a fresh variable; if there exists \na minimal j in [i + 1, n]  such that Typeof(e; . . . r?j ) = t then e~... el-~k~ej+l+en; .en; S := SU{k= \n1}; else f := e~... e;_ BkBe;een; .en; S := SU{k= O}; fi if Typeo~(f ) is a recursive type t then ~ \n:= ~a$is(t) and let k be a fresh variable; *if := f .Bk; s :=su{k= o}; Y := exhaustively apply the \nf ollowlng to f : if f is of the form e~ . . . ei_l.B~.B~ .ei+z . . . en then let k be a fresh variable; \nf :=el ...e; l. B~ . e;+2 ...en; S := Su{k =k+k }  fi return (~ , S) We also define a similar algorithm, \nFactor(g, ty), where g is a symbolic access path g, and ty is a type name. g is a partial access path \nwhich can be applied to objects of type ty. This is used by Star ClosureU. Example: Factor(X+ti+(tl+ \n)iM) = (X+(tl>)jhd, {j = i + 1}) Factor(tl+tl+hd, .struct List) = ((ti+)jhd, {j = 2}) Figure 15: The \nnormalisation algorithm Factor(f) Algorithm Factor(@) Input : a symbolic alias relation e E UR(Vfl ) \nOutput : a normalised symbolic alias relation F actor(Q) Method: /.= 0; $oreach symbolic alias pair ((fl, \nfz), ~) E Q do : = Factor(fl ); (91, S1 ) := Factor(fz); := Projectfl(Cti(K, S~ U S2), fU(g1) LJfrJ(92)) \ne := Q u Reraame{((gl, gz), ~ )1 done; return e $,s2) The algorithm Factor used above is defined in \nFigure 15. Example: F actor{((T+le&#38;rtght+ key, K), T)} = {((T+ {ie&#38;, right~}k key, K), Sfl{kl \n= 2})} Figure 16: The normalisation algorithm Factor(e) Algorithm Rewrite~ef,(~, P)(e) Algorithm EquivalenceClas# \n(~, e) Input: an access path ~, a symbolic alias relation Q Input: an access path z, a symbolic path \nset P and a sym- Output: a symbolic path set P bolic alias relation e Method: Output: a symbolic alias \nrelation e P := 0; Method: f oreach symbolic alias pair ((~1, fz), ~) C e do Q := o; foreach (S, A) E \nlfatch=(~, fl) do rename P et. coeffe. of P and Q are di.ejoint; f oreach symbolic alias pair ((~1, fz), \n~) E e do K := Project (CH(K, S), jv(~2.A)); foreach (S, A) E Matche(r, fl) do if (If # 1) then P := \nP U {(~2. A, K )}; foreach (g, K ) E P do done; foreach (S, A) G Matche(~, fz) do K := Projectfl(CH(KA~ \nK , S), fv(g)ufv(fz.A)); if (K # 1) then K := Project[(Cf(K, S), fv(jl.A)); := e U Rename{((g, ~z.A), \nK )} if (K # 1) then P := PU{(~l. A, K )}; e done; done f oreach (S, A) c Match3(fl, ~) do done; foreach \n(g, K ) c P do P := Pu{(~, T)}; K,, return P := ProjectH(@(K A,K , S), fv(g.A)Ufv(~,)); if (K # 1) \nthen Example: if g={((Y+(tl+)i, h(tl+)~), ~h{i=j l})} then: := e u Rename{ ((g.A, .f2), K )] e EquivalenceClass \n( Y+t6+hd, e) done = {(Y+tl+hd, T), (L+(tb)ihd, Sb{j = 2})} done; return e Figure 17: Equivalence class \nof an access pith /* Rewr~te~ight is defined similarly *I Algorithm llewrden(~, P)(@) Input: an access \npath ~, a symbolic path set P and a sym-Algorithm Strip%ej@(r, P) bolic alias relation .g Input: an access \npath m, a symbolic path set P Output: a symbolic alias relation e Output: a symbolic path set P Method: \nMethod: e := Rewrite~e~,(~, P)(.Q); P :=0; := Q 1-lRewrite~i~hi(r, P)(Q U e ); foreach (f, K) c P e \ne := Q u Rename{((f, m), K) I (f, K) c P}; f oreach (S, A) c Matcha(f, ~) do return Q K := Project[(C[(K, \nS), fv(A)); Figure 20: The operator Rewritefl if (K # 1) then P := PU {(A, K )} done; return P! Example: \nAlgorithm GeneraliseH(((il, f2), K), @entry, ~) StripPrefiz[(X+tl, {( X+(t/+)k hd, Sfl{kI ~ 2})}) Input: \na symbolic alias pair ((fl, $2), K), the Symbofic = {(+(tl+) hd, sn{k, > l})} alias relations ,Q.n~,Y \nand @ Figure 18: Algorithm StripPrefiz Output: the symbolic alias relations e&#38;y and ~ Method: f; \n:= Make GenericName( fz); let (ul, . . ..%) =fi(f. ) ad (vi,...,%)=fif~);); s := {U1=V1, . . ..%=WJ. \nAlgorithm P.Q (Concatenation of symbolic path sets) .&#38;y : = eewY u Rename{ ((f<, f,), S$(S))}; Input: \ntwo symbolic path sets P, Q K := Project (Cu(K, S), fv(fo U fv(~l)); Output: a symbolic path set P. \nQ denoting the concat en a-f+ := @ u Rename{ ((~~, ~1), K )}; tion of the access paths denoted by P and \nQ return(&#38;Y, W) Method: u := 0; Exarnde: rename P so that the coefficients appearing in Gene~alisen(((* \n(l+tl), *(a+(tl+)ihd)), SB{i ~ 2}), 0, 0) P and Q are dietinct; = (kt.y, ~) foreach (fl, KI) c P uith \ne.~t,~ = {((u, [j], *(a+(t~+)ih~)), s {~ = ~])} foreach (~z, Kz) c P end El = {(( Ul[k], *( Ml)),S {k \n> 2})} U := U U {( fI.f2, &#38; Ah K2)] return U The operator Make Generic Name(~) returns a symbolic \nac\u00adcess path f consisting of a generic object U[ki, . . . . km], Example: let P = {( L+(tl*~hd*, Sti{j \n= 2})} where n is the number of coefficient variables occurring in and Q = {((tl~)khd, SK{k ~ 1})}, then: \nf. The name U is determined uniquely from f, ignoring P.Q = {( L+(tl+)jhd+(tl+ )khd, Si{j = 2, k ~ 1})} \ncoefficient names and the kl, . . ., k= are fresh variables. Figure 19: Concatenation of symbolic path \nsets Figure 21: Generalisation of symbolic access paths  \n\t\t\t", "proc_id": "178243", "abstract": "<p>Existing methods for alias analysis of recursive pointer data structures are based on two approximation techniques: <italic>k-limiting</italic>, and <italic>store-based</italic> (or equivalently location or region-based) approximations, which blur distinction between elements of recursive data structures. Although notable progress in inter-procedural alias analysis has been recently accomplished, very little progress in the precision of analysis of recursive pointer data structures has been seen since the inception of these approximation techniques by Jones and Muchnick a decade ago. As a result, optimizing, verifying and parallelizing programs with pointers has remained difficult.</p><p>We present a new parametric framework for analyzing recursive pointer data structures which can express a new natural class of alias information not accessible to existing methods. The key idea is to represent alias information by pairs of <italic>symbolic access paths</italic> which are qualified by symbolic descriptions of the positions for which the alias pair holds.</p><p>Based on this result, we present an algorithm for interprocedural may-alias analysis with pointers which on numerous examples that occur in practice is much more precise than recently published algorithms [CWZ90, He90, LR92, CBC93].</p>", "authors": [{"name": "Alain Deutsch", "author_profile_id": "81100239001", "affiliation": "INRIA Rocquencout, Le Chesnay Cedex, France", "person_id": "PP14092631", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/178243.178263", "year": "1994", "article_id": "178263", "conference": "PLDI", "title": "Interprocedural may-alias analysis for pointers: beyond <italic>k</italic>-limiting", "url": "http://dl.acm.org/citation.cfm?id=178263"}