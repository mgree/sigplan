{"article_publication_date": "06-01-1994", "fulltext": "\n Context-Sensitive Interprocedural Points-to Analysis in the Presence of Function Pointers Maryam Emami \nRakesh Ghiya Laurie J. School of Computer Science McGill University, Montreal, Quebec Canada H3A 2A7 \n{emami ,ghiya,hendren}@cs .mcgill. Hendren ca Abstract This paper reports on the design, implementation, \n and empirical results of a new method for dealing with the aliasing problem in C. The method is based \non ap\u00ad proximating the points-to relationships between acces\u00ad sible stack locations, and can be used \nto generate alias pairs, or used directly for other analyses and transfor\u00ad mations. Our method provides \ncontext-sensitive interproce\u00ad dural information based on analysis over invocation graphs that capture \nall calling contexts including re\u00ad cursive and mutually-recursive calling contexts. Fur\u00ad thermore, the \nmethod allows the smooth integration for handling general function pointers in C. We illustrate the effectiveness \nof the method with empirical results from an implementation in the Mc- CAT optimizing/p araHelizing \nC compiler. 1 Introduction and Motivation Alias and dependence analysis are fundamental com\u00adponents of \noptimizing and parallelizing compilers. Al\u00adthough traditionally studied in the context of For\u00adtran or \nblock-structured languages [1, 2, 8, 9], there has been increasing interest in providing accurate alias \nand side-effect analysis for C programs [7, 31]. Solv\u00ading these problems for C rather than Fortran leads \nto many interesting and difficult problems including the treatment of the address-of operator (i.e. &#38;a) \nwhich can create new pointer relationships at any program point, multi-level pointer references (i.e. \n**a) which en\u00adable the called function to modify alias relationships in the calling function, the integration \nof pointer analysis for stack-allocated variables and dynamically-allocated variables, and the proper \ninterprocedural handling of recursion and function point ers. Permission to cc y vvithout fee all or \npart of this material is granted provid Jthat the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association of Computing Machinery. To copy otherwise, \nor to republish, requires a fee anct/or specific permission. SIGPIAN 94-6/94 Orlando, Florida USA @ 1994 \nACM 0-89791 -662-xKWO006..$3.5O This paper reports on the design, implementation, and results of a new \nmethod for dealing with the alias\u00ading problem in C. Our method, called points-to analy\u00adsis, estimates \nthe relationships between abstract stack locations. This method has been developed over the last two \nyears within the framework of the McCAT optimizing/p arallelizing C compiler, and is currently operational. \nThe import ant facets of our approach in\u00adclude: The points-to abstraction: Rather than compute sets of \nalias pairs, our method computes a different ab\u00adstraction: the points-to relationships between stack \nlo\u00adcations. We say that a stack location x points-to stack location y at program point p if x contains \nthe ad\u00address of y. 1 In addition to providing a more compact abstraction as compared to alias pairs, \nthe points-to information is well suited for immediate use by other analyses. Unlike most approaches \nthat compute may aliases, our analysis computes both possible and definite points\u00adto relationships. Using \nthe points-to abstraction, the additional overhead of providing the definite informa\u00adtion is minimal, \nwhile at the same time providing several advantages. The first advantage is that defi\u00adnite points-to \ninformation can be used to sharpen the points-to analysis itself, by providing accurate killing information. \nFor example, given the statement *p = x, and the information that p definitely points to y, we can kill \nall points-to relationships from y. The sec\u00adond major advantage is that definite relationships can be \nused to direct transformations like pointer replace\u00adment. For example, given the statement x = *q, and \nthe information that q definitely points-to y, we can replace the statement x = *q with x = y. This trans\u00adformation \ncan then lead to better results in later phases of the compiler such as reducing the number of loads \nand stores [12]. We present the points-to abstraction and the basic flow analysis rules in Section 3 \nand we compare our approach to similar approaches in Section 7. A context-sensitive interprocedural analysis: \n1In more conventional alias analysis, the notion that x points\u00adto y would be captured by an alias pair \n(*x, y). The points-to abstraction and basic flow analysis rules could be implemented in many different \nanalysis frame\u00adworks. However, our particular approach is a struc\u00adtured or compositional analysis that \nuses invocation graphs to provide a context-sensitive analysis. This ap\u00adproach allows us to get accurate \nresults and to correctly handle recursion. Function pointers provide a big challenge for inter\u00adprocedural \nanalysis of C programs. In this paper we give a natural extension of the points-to analysis that gracefully \nincludes the general problem of single and multi-level pointers to functions. In fact, as we demon\u00adstrate, \nthe problem of instantiating function pointers in C must be done at the same time as points-to anal\u00adysis \nin order to get a reasonably general and accurate solution. We discuss the basic interprocedural strategy \nin Sec\u00adtion 4 and then we show how to extend this to handle function pointers in Section 5. Related interprocedural \napproaches are compared in Sections 4 and 7. Experimental results and applications: It is our viewpoint \nthat any alias analysis must be implemented and tested in order to measure the actual costs and ben\u00adefits \nof the analysis. We have completely implemented the analysis described in this paper, and in Section \n6 we provide empirical evidence that our approach gives ac\u00adcurate and useful results. We also provide \na summary of how the results of points-to analysis are used as a building block for other analyses and \ntransformations. Separating stack-based aliasing from array and heap-based aliasing: The problem of aliasing \nreally comes in three varieties: (1) aliases between variable references to the stack, (2) aliases between \nreferences to dynamically-allocated storage on the heap, and (3) aliases between two references to the \nsame array. It has become accepted that the last problem, aliases be\u00adtween references to the same array, \nrequires special de\u00adpendence testing methods based on analyzing the index expressions. We claim that \none must also consider to\u00adtally different analysis methods for stack-based aliases and heap-based aliases, \nand that the two problems can safely be decoupled. In the case of stack-based aliases a name exists for \neach stack location of interest, and one may compute some approximation of the relation\u00adships between \nthese locations. In the case of heap\u00adbased aliases, there are no natural names for each lo\u00adcation. In \nfact, one does not know statically how many locations will be allocated. Thus, a completely differ\u00adent \napproach is likely to be required. For example, Deutsch argues that a store~ess model is more appro\u00adpriate \nfor the heap-based problems [11]. We discuss this issue further in Section 7. 2 Setting -the McCAT compiler \nOur points-to analysis is implemented in the Mc-CAT (McGill Compiler Architecture Testbed) opti\u00admizing/parallelizing \nC compiler. In order to pro\u00advide the correct intermediate language, we designed a structured intermediate \nrepresentation called SIM- PLE [22, 43]. On one hand, we need to analyze real C programs (not just programs \nwritten in a toy subset of C), and therefore our SIMPLE representation faithfully represents these programs. \nOn the other hand, we re\u00adquire as compact and clean a representation as possible, so that new and powerful \nanalyses can be implemented in a straightforward and compositional fashion. In designing the SIMPLE intermediate \nrepresenta\u00adtion there were three major design criteria: (1) basing our analysis framework on structured \n(compositional) analyses, and thus using a structured intermediate rep\u00adresent ation, (2) retaining high-level \nvariable references and type casting information, and (3) designing a com\u00adpact representation for statements \nand expressions that includes 15 basic statements, plus explicit simplified representations of the while, \ndo, for, if, switch, break, continue and return statements.2 Typical simplifications include: compiling \ncomplex statements into a series of basic statements, simplifying all condi\u00adtional expressions in if \nand while statements to sim\u00adple expressions with no side-effects, simplifying proce\u00addure arguments to \neither constants or variable names, and moving variable initializations from declarations to statements \nin the body of the appropriate proce\u00addure. After simplification, points-to analysis rules need to be \ndeveloped only for the 15 basic statements and the compositional control statements. The design of these \nrules is further simplified by the fact that each of the basic statements can have only one level of \npointer indirection for a variable reference. Further details are given in [13, 22]. 3 Abstract Stack \nLocations and Basic Analysis Rules Traditionally, alias analysis methods have approxi\u00admated aliases by \nsets of alias pairs. With this approxi\u00admation, two variable references are said to be aliased if they \nrefer to the same location. Typical alias pairs are of the form (*x, y), (**p, **q), (*u, *v) and so \non. 3.1 Points-to Abstraction We have chosen a different abstraction that approxi\u00admates the points-to \nrelationships between stack loca\u00adtions at each program point. The basic idea is to abstract the set of \nall accessible stack locations with a finite set of named abstract stack locations. Based on this abstraction, \nthe approximation of interest con\u00adsists of a set of points-to relationships between the ab\u00adstract stack \nlocations. For example, after the statement p = &#38;y, we would say that abstract stack location p points-to \nabstract stack location y. The key to our approach is to guarantee that each real stack location involved \nin a points-to relationship 2 It should be noted that the unrestricted use ~f got. is not compositional \nand cannot be supported directly. Thus, our Mc-CAT compiler provides a strnctnring phase that converts \npro\u00adgrams with unstructured control flow to equivalent programs with structured control flow [14]. is \nproperly abstracted with an abstract stack location with an appropriate name. More specifically, the \nab\u00adstraction must obey the following two properties. Property 3.1 Every real stack iocation that is either \na source or target of a pointer reference at a program point p is represented by exactly one named abstract \nstack location. Property 3.2 Each named abstract stack location at program point p represents one or \nmore real stack lo\u00adcations. An important part of our abstraction is the fact that we guarantee to provide \nall points-to relationships us\u00ading the names of abstract stack locations that are inde\u00adpendent of calling \ncontext. Thus, each abstract stack location corresponds to: (1) the name of a local vari\u00adable, global \nvariable or parameter; or (2) a symbolic name that corresponds to locations indirectly accessi\u00adble through \na parameter or global variable (of pointer type), when these locations correspond to variables not in \nthe scope of the procedure under analysis; or (3) the symbolic name heap. Given that all stack locations \nhave the appropriate names, we can define the rela\u00ad tionships definitely points-to and possibly points-to \nas follows , Definition 3.1 Abstract stack location x definitely points-to abstract stack !ocation y, \nwith respect to a particular invocation context, if x and y each represent exactly one real stack location \nin that contezt, and the real stack location corresponding to x contains the ad\u00address of the real stack \nlocation corresponding to y. This is denoted by the triple (x, y, D). Definition 3.2 Abstract stack location \nx possibly points-to abstract stack location y, with respect to a parttcuiar invocation context, if it \nis possible that one of the real stack locattons corresponding to x contains the address of one of the \nreal stack locations correspond\u00ading to y in that context. This is denoted by the triple (x, y, P). Based \non these relationships, we can define what is meant by a safe approximation. Definition 3.3 A points-to \nset S at program point p is a safe approximation if for all pairs of real stack locations loci and locj, \nwith x as the name associated with 10Ci and y with locj: 1. if loci points-to loci on all valid execution \npaths to p, then the points-to set S contains either (x, y,D) or (x, y, P). 2. if loci points-to Iocj \non some, but not all, ezecu \u00adtion paths to p, then the points-to set S contains (x, y, P).  3. if S \ncontains (x, y, D), then loci must point to locj along all execution paths to program point p. Thus, \nthere are two basic ways in which an approx\u00adimation may not be safe: (1) a real points-to relation\u00adship \nis not included in S, or (2) a spurious definite points-to relationship is included in S. Of course, \nit is easy to find safe approximations that are not precise. For example, it would be safe to say that \nevery abstract stack location possibly points-to every other abstract stack location. The goal is to \nfind approximations that are as precise as possible. In our abstraction impre\u00adcision can be introduced \nby: (1) introducing spurious possible relationships, or (2) using a possible relation\u00adship in the place \nof a definite relationship.  3.2 L-locations and R-locations Given that a points-to set S has been calculated \nfor a program point p, we can define the set of abstract lo\u00adcations referred to by each kind of variable \nreference in the statement at p. L-locations are those abstract loca\u00adtions referred to by a variable \nreference on the left-hand side of an assignment statement, while R-locations are those abstract locations \nreferred to by a variable refer\u00adence on the right-hand side of an assignment statement. L-locations and \nR-locations are represented as pairs of the form (z, D), (z, P) where x is an abstract location name, \nand D and P indicate definite and possible loca\u00adtions respectively. Table 1 summarizes the L-location \nand R-location set for each type of variable reference allowed in the SIMPLE intermediate representation. \nNote that an L-location refers to the stack location of the variable reference itself, while an R-location \nrefers to the stack locations pointed to by the variable refer\u00adence. Thus, the L-location set for a is \nsimply {(a, D)}, while the R-location set is the set of all locations (z, d) such that a points-to x \nwith the relationship of d (i.e. (a,x,d) is in the points-to set). The L-location set for *a is the set \nof stack locations pointed to by a, while the R-location set has one more level of indirection. That \nis, the R-location set includes all locations (y, d) such that a points-to some location x and x points-to \ny. In this case, the R-location is definite (d= D) only if a definitely points-to x and x definitely \npoints-to y. The treatment of structure references is similar, ex\u00ad cept that the field name is appended \nto the location names. For array references we use the notation a [i] to refer to an ordinary array reference, \nand (*a) [i] to refer to an array reference via a pointer. In the c source program these would both appear \nas a [i], but in the first case a would have an array type, while in the second case a would have a pointer \ntype. There are a variety of ways of dealing with arrays. One method is to associate an entire array \nwith one stack location. The method presented in Table 1 uses 2 abstract stack locations for each array \na: ahead is used for the location a [0] and aiail is used for all other locations a [1 . . n] . This \nuse of two abstract stack locations per array allows us to determine when two array pointers are aligned \nto Var Ref L-lot Set I R-lot Set &#38;a N/A {(a, D)} &#38;a. f N/A {(a.f, D)} &#38;a [0] N/A {(a&#38;acz, \nD)} &#38;aCi] (2 > O) N/A {(a,ae~, D)} &#38;a[i] (i ~ O) N/A {(ahead, P), (wad,F )} a {(cL, D)} ~ a.f \n{(a. f, D)} {(z, d)l(a.f, z,(t) G s} a [0] {(wt.a~, D)} {(z, ~)l(wead,Z,O Cs} a[i] (2 > O) {(atG,~, {(z, \nes} D)} Ol(atad,x,d)a[i] (z ~ O) {(a~.a~, P), (atat~, P)} {(~, ~)l(ahead,~,~) ~s v (atatt, x,~) 6s} \n*a {(z, f.i)l(a, z,d) C S} {(y, dl Ad2)l(a,x,dl) c SA (z, v,dz) e S} (*a) .f {(x. f,(t) l(a, z,d) E s} \n{(w d A dz)l(%z, dl) c s A (x. f,?/, dz) c S} (*a) [01 {(x, d)l(ahead, x, d) E S} {(!/, al A az)l(ahead,x, \nal) C S A (z, Y, dz) 6 s} (*a) [i] (i> O) {(x, d)l(at~tt,x,d) ES} {(v, dl Ad2)l(at~it,G s} z,dl)c SA \n(Z,v,dz)  (*a) [i] (2> O) {(x, p)l(ahe-d, x,d) G S {(v, p)l((~head, X, dl) Cs v (m~tt,~,dl) C s)A v(at~;l, \nz, d) c S} (z, y, d2) C S} ...-/. XT/A (/l.- n\\l Table 1: L-location and R-location sets relative to \npoints-to set S. the beginning of the same array. This information is the problem of restricting the \npropagation of informa\u00aduseful For arr~y dependence test_ing [28]. tion-along realizable interprocedural \nexecution paths. One traditional solution to this problem has been to 3.3 Basic Analysis Rules include \nsome context information in the abstraction The basic analysis rules are presented in Figure 1. being \ncalculated [27]. Typical examples of this ap-Note that for pointer assignment statements we have proach \ninclude: memory components [34], procedure a general rule that uses the L-locations for the lhs and strings \n[18, 19], assumed alias sets [30] and source alias R-locations for the rhs to compute the returned flow \nsets with the last call-site [7]. information. There are three basic changes to the in- Rather than embedding \nthe context in the abstrac\u00adput flow information: (1) the set of relationships killed, tion being estimated, \nwe have chosen to follow a dif\u00ad (2) the set of relationships that should be changed from ferent strategy \nwhere we explicitly represent all in\u00addefinite to possible, and (3) the set of relationships gen\u00ad vocation \npaths in an invocation graph. In the case of erated. Note that any assignment bet ween structures programs \nwithout recursion, the invocation graph is can be handled by breaking down the assignment into built \nby a simple depth-first traversal of the call struc\u00adassignments between corresponding fields and then \nap\u00ad ture of the program, starting with main.3 Consider for plying the basic rules. example, the invocation \ngraph for the program in Fig-After defining the basic assignment rule, we have ure 2(a). An important \ncharacteristic of the invocation defined structured or compositional rules for each of graph is that \neach procedure invocation chain is rep\u00adthe loop and conditional constructs. We give simple resented by \na unique path in it, and vice versa. Using versions of the if and while rules in Figure 1. The the invocation \ngraph we can distinguish not only calls complete set of compositional rules that handle break, from two \ndifferent call-sites of a procedure (calls to go cent inue and return in a straightforward manner can \nin Figure 2(a)), but we can also distinguish two differ\u00adbe found elsewhere [13]. ent invocations of a \nprocedure from the same call-site when reached along different invocation chains (call to 4 Interprocedural \nAnalysis fo in Figure 2(a)). To accurately estimate the effects of procedure calls In the presence \nof recursion the exact invocation on points-to information, we perform context-sensitive structure of \nthe program is not known statically, and we interprocedural points-to analysis. That is, when mea\u00ad must \napproximate all possible unrolling of the recur\u00adsuring the effect of a procedure call we estimate it \n2(b) with re\u00ad sion. Figure illustrates a program simple within a specific calling context and not just \nsumma\u00ad cursion and the set of all possible invocation unrolling rize the information for all calling \ncontexts. In general, for this program. To build the graph in the case of a calling context depends on \nthe chain of procedure in\u00ad recursion one terminates the depth-first traversal each vocations starting \nwith main and ending with the par\u00ad time a function name is the same se that of one of the ticular procedure \ncall under analysis. ancestors on the call chain from main. The leaf node The problem of ensuring that \nthe analysis of a pro\u00ad (representing the repeated function name) is labeled as cedure call is specific \nto a particular calling context has an approximate node, and its matching ancestor node been termed the \ncalling context problem by Horwitz et al. [25], while Landi and Ryder [30] consider this to be 3The treatment \nof function pointers is given in Section 5. fe Given a strnt S, an input points to set, and an invocation \ngraph node ign , return the output points to set */ fun process_stmt (S, Input,ign) = if basic_stmt(S) \nreturn(process_basic_stmt (S, Input )); else case S of < SEQ(S1, S2) > => return (proc.ss_stmt (S2,process_stmt \n(Sl,Input,ign) ,ign)); < IF(cond,th.nS,elseS) > => return(process_if( cond,thenS,elseS, Input ,ign)); \n < WHILE(cond,bodyS) > => return(process_while( cond,bodyS,Input, ign)); ... fun process=basic_stmt( \nS, Input) = if (! is_pomter_type(S) ) /* not a pointer assignment */ return(Input); else /* assignment \nto a pointer variatde */ kill_set = {(p,x,d) I (p,D) 6 L locations(lhs( S))}; /* kill all relationships \noj definite L iocations of lhs(S) */ J* change from definite to possible, ailrelationships from possible \nL-locations oflhs(S)*/ change_set = {(p,x,D) I (P,P) 6 L locations(lhs( S)) A (P,x,D) C Input}; /* Genera \nteallpossible relationships between L-locations oflhs(S) and R-locationsof rhs(S). * The generated relationship \nis definite only if the L 1ocation and R 1ocation are both definite *I gen_set = {(p,x,dl A d2) I (p,dl) \nc L locations(lhs( S)) A (x,d2) c R locations(rhs( S))}; changed_input = (Input change_set) U {(p,x,p) \nI (P,x, D) C change set}; ret urn( (changed_input kill_set ) U gen_set ); fun process_if(cond, thenS,elseS,Input \n,ign) = thenOutput = process_stmt (thenS ,Input ,ign); if (elseS != {}) elseOutput = process_stmt(elseS, \nInput, ign); else else Out put = Input; return(Merge(thenOutput ,elseOutput)); fun process_while(cond, \nbodyS ,Input ,ign) = /* fixed point calculation */ do lastIn = Input; Output = process_stmt(body S, \nInput, ign); Input = Merge(Input ,Output); while(lastIn != Input); return(lastIn); Figure 1: Basic Analysis \nRule for Points-to Analysis is labeled as a recursive node. We indicate the pair-computation can be avoided \nat analysis time), and (4) ings of these nodes with a special back-edge from the it provides a simple \nframework for implementing simple approximate node to the recursive node. It should be compositional \nfixed-point computations for recursion. noted that these back-edges are used only to match the approximate \nnode with its appropriate recursive node, Our overall strategy for interprocedural analysis is and they \nare therefore quite different from the other depicted in Figure 3, and the complete rules are given tree \nedges which correspond to procedure calls. This in Figure 4. The general idea is that, first, the points\u00adscheme \nis completely general. Consider, for example, to information at the call-site is mapped to prepare the \ninvocation graph for a program with both simple the points-to input set for the called procedure. This \nand mutual recursion displayed in Figure 2(c). has to take into account the association of formal and \nactual parameters, the global variables, and the ac- Our approach of explicitly building the invocation \ncessibility of non-local stack-locations through indirect graph has the following advantages: (1) it \ncleanly sep-references. Next, the body of the function is analyzed arates the abstraction for any interprocedural \nanaly-with this input points-to set and the output obtained sis from the abstraction required to encode \nthe calling is unmapped and returned to the call-site. Note, that cent ext, (2) it allows us to deposit \ncent ext-sensit ive by using this strategy points-to information induced by information computed from \none analysis that can be one call-site is never returned to another call-site, and useful for the next \nanalysis, (3) it provides a place to similarly points-to information arriving from different store (memoize) \nIN/OUT pairs previously computed to call-sites is never simultaneously used to generate new summarize \nthe effect of the function call (so that extra points-to information. With the overall strategy being \nbe mapped to the called procedure. ~aino go ... ... { fo; go; ... }} .!30; (a) main main main maino \nfo ii+ ... {if# fo;   { i i... ... ... } } i f (b) main maino fo go + ... { if$; fo; if(y) . { \n{ go; : 7-RR fo; }} :9 f-A } 1+ f-A (c) Figure 2: Invocation Contexts clear, we now explain the strategies \nfor mapping and unmapping points-to information, the use of invoca\u00adtion graph to store context-sensitive \nmap information and the handling of recursive calls through fixed-point computations guided by the invocation \ngraph,  ~f-jr Unmap Process Figure 3: The Interprocedural Strategy 4.1 Mapping and Unmapping Points-to \nInformation When preparing the input points-to set for the called procedure from the points-to information \nat the call\u00adsite, the formal parameters inherit the points-to rela\u00adtionships from the corresponding actuals, \nglobal vari\u00adables retain the same points-to relationships, while lo\u00adcal variables are initialized to \npoint to NULL . However, there are two important points to be considered: If a formal parameter or a \nglobal variable is a multi-level pointer, another pointer variable can be ac\u00adcessed by dereferencing \nit. The points-to relationships for all such indirectly accessible pointers also need to Formals and \nglobals can point to variables not in the scope of the procedure, which in turn can point to variables \nwithin/outside the scope of the procedure. Henceforth, we refer to variables outside the scope of the \ncalled procedure as invisible variables.4 The first problem is resolved by applying the map\u00adping process \nrecursively to all levels of pointer type. For the second problem, we generate special symbolic names \nto represent each level of indirection of pointer variables. For example, for a variable x with type \nint **, we would generate symbolic names l_x and 2X with types int * and int. Now, if an indirect refer\u00adence, \nsay *x, can lead to an invisible variable, say b, the corresponding symbolic name I_x is used to rep\u00adresent \nb in the points-to pairs. So a points-to pair like (x ,b, P) at the call-site would be mapped to the \npair (x, I-x, P). Further, a points-to pair like (b, c ,P), where c is again an invisible variable, would \nbe mapped aa (IX, 2-x, P ). Simultaneously, the association of in\u00advisible variables b and c with symbolic \nnames 1-x and 2X is recorded in the invocation graph node currently under investigation, as map information. \nThis context\u00adsensitive information is used while unmapping and also by other interprocedural analyses \n(20]. Note that only the map information is context-sensit_ive; the symbolic names themselves are used \nin a context-free manner inside the procedures, by all analyses. However, any scheme to map invisible \nvariables to symbolic names, should take into account the following observations: An invisible variable \nshould be represented by at most one symbolic name. For example if both x and y definitely point to the \ninvisible variable b, it should be mapped to either I-y or i-x and not to both. Other\u00adwise, we would \nhave two abstract stack locations rep\u00adresenting one real stack location, which would violate Property \n3.1. So, if b is mapped to I-y, we would have the following points-to pairs: (x, l_y, D ), (y, l-y, D \n) and the map information would be: (l.y, b), (I-x, {}).  A symbolic name can represent more than one \nin\u00advisible variable, For example, consider the case where x possibly points to invisible variables a \nand b. Now, both a and b need to be mapped to IX. Next, sup\u00adpose a global variable, say y also definitely \npoints to b. Now, either both a and b can be mapped to the symbolic name l-x or a can be mapped to l-x \nand b to I.y. However, with the first choice we would have the points-to pairs (x, l_x, P), (y, Ix, P), \nwhich on unmapping would generate the spurious points-to pair (y, a, p), and the inaccurate pair (y ,b, \nP) (instead of  (y, b, D ) ). 5 So, a good mapping scheme should min\u00adimize the number of invisible variables \nmapped to a symbolic name to improve the accuracy of information. Our experience shows that mapping invisibles \ninvolved 4A similar notion of non-visible variables is given in [30]. 5Note that the information provided \nis still safe, but less precise. fun process_cd(Input, actudList,formdList,ign, funcBody) = (funcInput,mapInfo) \n= map_process(Input ,formalList ,act ualList ) case ign of < Ordinary > => if (funcInput == ign.storedInput) \n/* already computed */ return(unmap_process( Input ,ign.storedOutput ,mapInfo)); else /* compute output, \nstore input and output */ funcOutput = process_stmt(funcBody, funcInput,ign); ign.storedInput = funcInput; \nign.storedOutput = funcOutput; return (unmap_process( Input, funcOutput,mapInfo)); < Approximate > => \nrecIgn = ign.recEdge; /* get partner recursive node in inu. graph *I if isSubsetOf(funcInput, recIgn.storedInput) \n/* if thisinput is contained in stored input, use stored ouput */ ret urn(unmap_process( Input ,recIgn.storedOutput \n,mapInfo) ); else 1* put this input in the pending list, and return Bottom */ addToPendingList (funcInput \n,recIgn.pendingList ); return (Bottom); < Recursive > => if (funcInput == ign.storedInput) /* already \ncomputed */ return (unmap_processs (Input, ign.storedOutput ,mapInfo)); else I* imtial input estimate \n*/ /+ initial output estimate */ ign.st oredInput = funcInput; ign.storedOutput = Bottom; ign. pendingList \n= {}; done = false; /* no unresolved inputs pending *I do  I* process the body *I funcOutput = process_stmt \n(funcBody,ign.storedInput,ign); /* if there are unresolved inputs, merge inputs and restart *I if (ign.pendingList \n!= {}) ign.storedInput = Merge(ign.storedInput, pendingListInputs); ign.pendingList = {}; ign. storedOutput \n= Bottom; else if isSubsetOf(funcOutput, ign.storedOutput) /* check if the new output is included in \nold output */ done = true; else [e merge outputs and try again +/ ign.storedOutput = Merge(ign.storedOutput, \nfuncOutput); while (not done); ign.storedInput = funcInput; j+ reset stored znput to irutial input for \nfuture memorization *I return(unmap_process( Input, ign.storedOutput, mapInfo)); /* return the fi~ed-point \nafler ~nrnapping */ Figure 4: Compositional Interprocedural Rules for Points-to Analysis in definite \nrelationships before the ones involved in pos-rolling for call-chains involving recursion are approx\u00adsible \nrelationships, gives more accurate mapping infor-imated by introducing matched pairs of recursive and \nmation. approximate nodes in the invocation graph. Each re- Once the function is analyzed with the mapped \nin-cursive node marks a place where a fixed-point com\u00adput, the output points-to set of the function needs \nto be putation must be performed, while each approximate mapped back to obtain the output points-to informa-node \nmarks a place where the current stored approxi\u00adtion at the call-site. The unmap algorithm essentially \nmation for the function should be used (instead of eval\u00ad consists of mapping the points-to information \nof sym-uating the call, the stored output is used directly). bolic names to that of invisible variables \nrepresented At each recursive node we store an input, an output, by them, besides that of globals. Complete \ndetails of and a list of pending inputs. The input and output our map and unmap algorithms are described \nin [13]. pairs can be thought of as approximating the effect of 4.2 Recursive Procedure Calls the call \nassociated with the recursive function (let us The cases of approximate and recursive procedure call \nit f). The fixed-point computation generalizes the calls shown in Figure 4 work together to implement \nstored input until it finds an input that summarizes all a safe and accurate fixed-point computation \nfor recur-invocations off in any unrolled call tree starting at the sion. As we have explained previously, \nall possible un-recursive node for f. Similarly, the output is general\u00adized to find a summary for the \noutput for any unrolling of the call tree starting in the recursive node for f. The generalizations of \nthe input and output may alternate, with a new generalization of the output causing the input to change. \nLet us consider the rule for the approximate node in Figure 4. In this case, the current input is compared \nto the stored input of the matching recursive node. If the current input is contained in the stored input, \nthen we use the stored output as the result. Otherwise, the result is not yet known for this input, so \nthe input is put on the pending list, and BOTTOM is returned as the result. Note that an approximate \nnode never evaluates the body of a function, it either uses the stored result, or returns BOTTOM. Now \nconsider the recursive rule. In this case we have an iteration that only terminates when the input is \nsufficiently generalized (the pending list of inputs is empty) and the output is sufficiently generalized \n(the result of evaluating the call doesn t add any new infor\u00admation to the stored output). Handling Punction \nPointers In the presence of function pointers, the invocation graph cannot be constructed by a simple \ntextual pass over the program, because a function pointer call-site cannot be bound to a unique function \nat compile time. A set of functions can be invoked from such a call-site, depending on the address contained \nin the function pointer when program execution reaches that point. Thus, proper handling of a function \npointer call re\u00adquires a precise estimate of this set. The simplest safe approximation for this set is \nthe set of all functions in the program. Another possible strategy is to collect the set of all functions \nwhich have had their addresses taken, and use this set to instantiate each function pointer reference. \nThe number and types of parame\u00adters passed cannot be safely used to refine this set, as C permits passing \nvariable number of arguments to func\u00adtions, and type casting. Either of the above methods is likely to \nbe overly conservative and can substantially reduce the quality of flow information being collected, \neven if there is only one indirect call in the program. Further, these simple strategies could incur \nconsider\u00adable cost, as each function has to be analyzed in the context of the call. A more precise estimate \ncan be obtained by observ\u00ading the fact that the set of functions invocable from a function pointer call-site \nis identical to the set of func\u00adtions that the function pointer can point to at that program point. To \ncompute the points-to set of the function pointer, we need to perform points-to analy\u00adsis. Points-to \nanalysis itself needs the invocation graph of the program, as it is a context-sensitive interproce\u00addural \nanalysis. How do we get the invocation graph for points-to analysis? The solution lies in constructing \nthe invocation graph while performing points-to anal\u00adysis, as described below. First, we build the invocation \ngraph of the program following the strategy described in section 4, leaving it incomplete at the points \na function pointer call is encountered. Next, we perform points-to analysis us\u00ading this incomplete invocation \ngraph. On encounter\u00ading an indirect call through a function pointer, we find all the functions it can \npoint to, according to the cur\u00adrent points-to information. The invocation graph is updated to indicate \nthat the indirect call can lead to invocation of any of these functions. Simultaneously, each pointed \nto function is analyzed in the context of the call. When analyzing an invocable function, say f, we consider \nthe function pointer to be definitely point\u00ading to f, as this would be the case whenever execution reaches \nfunction f from the given indirect call-site. Fi\u00adnally, the output points-to information for the indirect \ncall is obtained by merging the output points-to sets obtained by analyzing each of the invocable functions. \nA more formal description of the algorithm is provided in Figure 5. The detailed description is given \nin [15]. fun process_call_indirect( Input ,actualList ,ign) = /* Get the function pointer used to make \nthe indirect call */ fptr = getFnPtr(ign) /* Get the set of functions pointed to by fptr from current \npoints to information +/ pointedToFns = pointsToSetOf(Input, fptr) /+ Initialize output of the indirect \ncall */ Calloutput = {} foreach fn in pointedToFns I* Indicate function fn to be invocable by the indirect \ncall */ updateInvocGraph(ign, fn) /* Get Invocation Graph node for fn */ igNode = getIgNode(fn) J* make \nfptr dejiniteiy point to fn *f igNodeInput = makeDefinitePointsTo( Input, fptrjfn) J* Get output for \neach invocable function *f igNodeOutput = process_ +(igNodeInput, actualLlst ,fn.formalList, igNode,fn.funcBody) \nI* Merae all outputs */ &#38;llOut&#38;t = M&#38;ge(c~Output,igNodeOutput) return(callOutput) Figure \n5: Algorithm for Handling Function Pointers It should be noted that this algorithm does not add any extra \ncost to the analysis phase of the compiler. It simply extends the points-to analysis by using the points-to \ninformation available at indirect call-sites at the appropriate time. We provide an example to demonstrate \nhow this algorithm works. Consider the program given in Figure 6. Its initial incomplete invocation graph \nis shown in Figure 7(a). During points-to anal\u00adysis, when the function pointer call f p ( ) is en\u00adcountered \nat program point A, the points-to set int a,b, c; int *pa, *pb, *pc; main main main int (*fp)(); maino \nfooo baro ... ... pc=&#38;c; pa=&#38;a; pb=&#38;b; if (cond) if (cond) /* Point D ~/ fp = foo; fpo; \nelse /* Point c ./ fp=bar; } /* Point A ~~ fpo; /* Point B ~/ { {{. } A: (fp,foo,P) (fp,bar,P) (pc,c,D) \nB: (fp,foo,P) (fp,bar,P) (pc,c,D) (pa,a,P) (pb,b,P) C: (fp,foo,D) (pc,c,D) (pa,a,D) D: (fp,bar,D) (pc,c,D) \n(pb,b,D) Figure 6: Example Program with Function Pointers of fp is {( fp, foo, P), (fp, bar, P)}. The \ninvoca\u00adtion graph is updated accordingly, as shown in Fig\u00adure 7(b).6 Next, function f oo is analyzed \nwith the input points-to set as {( fp, foo,D) , (pc, c, D)} and function bar with the input points-to \nset {( fp,bar,D), (pc, c,D)}. Note that this set is not {( fp,foo, P), (fp,bar, P), (pc, c, D)} for both \nthe functions, for reasons mentioned in the above para\u00adgraph. While analyzing the function f oo, another \nfunc\u00adtion pointer call f p ( ) is encountered. The invocation graph is again updated according to the \ncurrent points\u00adto set off p : {(f p,f oo ,D) }, and consequently the po\u00adtential call to foo in main (which \nis currently being considered) becomes a recursive call and is handled specially as explained in the \nprevious section. Finally, the points-to information at program point B is ob\u00adtained by merging the output \npoints-to sets from the two potential function calls. The final points-to sets at important program points \nare given at the bottom of Figure 6. The final invocation graph is shown in Figure 7(c). 6 Experimental \nResults and Applica\u00ad tions of Points-to Analysis In this section we present our experimental results \nobtained by analyzing a set of 17 C programs. Ta\u00adble 2 summarizes the following characteristics of each \nbenchmark: source lines including comments, number of statements in the SIMPLE intermediate representa\u00adtion, \nand the minimum and maximum number of vari\u00adables in the abstract stacks of its functions (including symbolic \nvariables, and all the fields of structures rele\u00advant to points-to analysis). Our empirical results are \ngiven in tables 3, 4, 5, and 6. These results are based on our implementation in the 6The double-Lined \nedges in the figure are used just for clarity of presentation. They are not treated differently from \nother edges in the graph. fpfp fp  /\\ / \\ foo bar foo-R bar + /# f 1 J fp I I fp foo-A (a) (b) (c) \n Figure 7: Invocation Graph Construction with Func\u00ad tion Pointers McCAT compiler. For pointer arithmetic \nwe assume that pointers to arrays do not cross array boundaries. For non-array pointer arithmetic our \nanalysis supports a flag that indicates that either: (1) the pointer target stays within the presently \npointed-to data structure, or (2) the pointer target can be any memory location. For the first case a \nwarning message is issued so that the programmer can determine if t his is a safe assumption. Our experiments \nwere done with this setting. The accuracy of points-to information collected, is best reflected in how \nprecisely it helps in resolving indirect references in programs. We present data on points-to characteristics \nof indirect references in ta\u00adble 3. Columns 2 to 6 give the number of indirect refer\u00adences with the dereferenced \npointer definitely pointing to a single stack location, possibly pointing to a sin\u00adgle stack location \n(the other being NULL), and then to two, three and four or more stack locations. The next two columns \ngive the total number of indirect ref\u00aderences in the program, and the number of indirect ref\u00aderences \nthat can be replaced by a direct reference, by using definite points-to information. 7 Columns 9 and \n10 give the number of points-to pairs used by indirect references, with the pointer target being on the \nstack and in the heap respectively. The Tot column gives their sum. The last column gives the average \nnumber of points-to pairs used in resolving an indirect reference in the program, which is the same as \nthe average num\u00adber of stack locations pointed to by the dereferenced pointer. For each multiple entry \ncolumn, the first en\u00adtry provides statistics for indirect references of the form *x and (*x) . y. z, \nand the second for indirect references of the form x [i] [j], where x is a pointer to an array. Note \nthat in our analysis we initialize all pointers to NULL. Since this initialization is not necessarily \ndone by the user, points-to relationships contributed by it are not counted in the statistics. 7Note \nthat this replacement cannot be done when the deref\u00aderenced pointer definitely points-to an invisible \nvariable. Benchmark genetic dry clinpack Config toplev compress mway hash misr xref stanford fixoutput \nsim travel csuite msc lWS 506 826 1231 2279 1637 1923 700 256 276 146 885 400 1422 862 872 148 2239 SIMPLE \n479 212 920 4549 1096 1342 869 110 235 140 889 391 1768 543 781 226 6671 Min Max Description #of #of \nvar Var 33 61 Implementation of a genetic algorithm for sorting. 21 43 Dbrystone benchmark. 11 109 The \nC version of Linpack. 19 188 Checks all the features of the C-language. 92 164 The top level of GNU C \ncompiler. 41 186 UNIX utility program. 51 125 A unified version of the best algorithms for m-way partitionhg. \n15 30 An implementation of a hash table. 10 43 This program creates two MISR S. Their values are compared \nto see 26 61 if the introduced A cross-reference errors have program to caqcelledbmld a them~elves. tree \nof Items. 31 67 Stanford baby benchmark. 17 31 A simple translator, 99 137 Finds local similarities with \n&#38;e weights. 28 55 Implements Traveling Salesman Problem with greedy heuristics. 34 55 Part of test \nsuite for Vectorizing C compilers. 20 73 Calulates the ruin spanning circle of a set of n points in the \nplane. 64 527 Implements dynamic simulation of flexible water molecule. Table 2: Characteristics of \nBenchmark Programs Bench\u00ad 1 1 2 3 >4 ind scalar To To Tot Avg mark D rel P rel P rel P rel P rel refs \nRep Stack Heap genetic 25 14 27 02 02 20 54 7 38 30 68 1.26 dry 2 11 37 0 80 00 00 58 9 21 45 66 1.14 \nclinpack 7 98 02 0 39 04 00 150 101 197 0 197 1.31 Contlg 83 34 0 00 00 00 45 3 45 0 45 1.00 toplev 50 \n110 0 00 00 20 117 5 171 0 171 1.46 compress 00 40 10 00 00 00 50 0 43 7 50 1.00 mway 31 38 00 05 00 \n00 74 0 79 0 79 1.07 hash 20 12 0 00 00 00 14 0 7 7 14 1.00 misr 13 80 27 0 00 00 39 0 31 35 66 1.69 \nxref 00 20 2 9 0 00 00 31 0 9 31 40 1.29 stanford 6 61 74 0 02 0 0 00 143 51 119 26 145 1.01 fixoutput \n50 12 00 00 00 8 5 5 3 8 1.00 sim 00 122 231 00 00 00 353 0 34 319 353 1.00 travel o 20 30 32 17 41 00 \n77 20 125 11 136 1.77 csuite 8 13 36 9 00 0 0 00 66 21 64 2 66 1.00 msc 60 35 0 00 00 00 41 6 6 35 41 \n1.00 lWS 77 90 54 197 50 00 00 423 110 428 0 428 1.01 Table 3: Points-to Statistics for Indirect References \n The results in this table are very encouraging. The following important observations can be made: The \naverage number of stack locations pointed to by the dereferenced pointer in an indirect reference, is \nquite close to one for most programs, where one in\u00addicates the best possible case. The overall average \nis equal to ~, while the maximum average for a pro\u00adgram is only 1.77. This indicates that the informa\u00adtion \ncollected by our points-to analysis is highly pre\u00adcise. The overall average is quite close to that reported \nby Landi et al. [31], which is 1.2. . Overall, 28.80% of indirect references in the pro\u00adgrams have the \ndereferenced pointer definitely pointing to a single stack location. Using the definite informa\u00adtion, \n19.39% of indirect references, can be replaced by direct references (when the dereferenced pointer does \nnot point to an invisible variable). For this replace\u00adment, 67.33 %o of definite relationships applicable \nto in\u00addirect references, are useful. These are very important results, which support our strategy of \ncollecting both possible and definite information. A pointer should not be pointing to NULL when being \ndereferenced during program execution. With this assumption, 90.76% of indirect references, have the \ndereferenced pointer definitely/possibly pointing to a single stack location. For certain benchmarks, \nin particular clinpack , st anford , sire and lws , the majority of definite relationships are for indirect \nreferences of the form x [i] [j], (where x is a pointer to an array). This in\u00ad formation is very useful \nfor array dependence analysis, as it reduces the number of array pairs to be collected for subscript \nanalysis [28]. o Overall, 27.92~0 of points-to relationships used, have heap locations as the pointer \ntarget. This under\u00adlines the need for a powerful companion heap analysis to identify disjoint accesses \nto heap locations [16]. There are very few cases with three or more pOS\u00adsible points-to relationships \nfor an indirect reference. Bench-Stack Stack Heap Heap A Max One of these cases (with more than 4 points-to \nrelation\u00ad mark To To To To vperships), occurs when an array of pointers is initialized 11 Stack Heap \nHeap Stack g stint -(in toplev ). genetic 3901 1066 0 0 10 38 Table 4 further categorizes the points-to \nrelation-dry 512 S83 198 0 7 24 ships with the pointer target on stack (column To clinpack 18987 0 0 \n0 20 91 Config 136315 18 0 0 29 120 Stack of table 3), into relationships arising/directed toplev 41539 \n6 0 0 37 100 from/to abstract stack locations representing local compress 30502 1070 0 0 23 82 variables \n(lo), global variables (gl), formal parameters mway 16399 0 0 0 18 76 (fp) and symbolic names (sy). The \nstatistics in the ta-hash 577 207 34 0 7 Is misr 1314 706 90 825 ble show that most of the relationships \narise from for\u00adxref 46 506 170 416 mal parameters> and are directed to symbolic names st anford 3137 \n364 7 0 3 30 or global variables. This indicates that procedure calls fixoutput 3111 794 n n 9 14 I II1 \ngenerate the majority of points-to relationships, and sim 7048 31174 143; I G 2i ii 1 ,, that points-to \nanalysis needs to be a context-sensitive travel 3581 1174 010 8 42 csuit e 4527 14 010 II 5I 26 interprocedural \nanalysis to collect precise information. msc 221 907 8810 II 5I 221 Table 5 contains statistics about \nthe total number of lWS 241291 0I 010 II 35 I 366 points-to pairs collected, obtained by summing up the \nnumber of pairs valid at each statement in the simpli- Table 5: General Points-to Statistics fied program. \nColumns 2 to 4 give a classification of the points-to pairs based on their origin and target in the memory \norganization. The last two columns give Bench-ig call #of R A Avgc Avgf the average and maximum number \nof pairs valid at a mark nodes sites fns statement. genetic 45 32 17 0 0 1.38 2.65 dry 19 17: The major \nobservation from this table, is the ab\u00ad clinpack 92 42 sence of points-to relationships from heap to \nlocations cOPfi =. ----493.-. 1OR? ~ 11 1I!, on stack, implying that pointers in heap objects only nl \n+ 53 2.94 TF.-. .-29 181010 1.80 II point to other heap objects, for the given benchmark compress 45 \n23 121010 II 1.91 I 3.75 row..,.-, II .-42 21 0 0 1.02 2.10 44 set. This supports our strategy of separating \nstack and 11 1 1 -1. 0Q ha~., . 5 00 1.0 1.80 II II heap points-to analyses. However, we need to analyze \nmicr 8 7 1.60 -----11 15 00 1.0 1 .-.. a larger set of benchmarks to further strengthen this xret 15 \n14 8 24 1.0 1.88 1I ,, claim, and to measure the inaccuracy introduced by our stanford 64 61 37 I6I1O \n1.03 I 1.73 approach for those benchmarks that do have pointers fixoutput 23 12 sim 120 47 from the \nheap to the stack. travel----39. . .. 22 II 11 c<,lit, e -- .. 37-. 36 36 0 0 1.00 1.00 II 11 Bench-From \nTo msc 6 5 5221.001.00 mark 10 gllfplsy lolgllfplsy lWS 33 29 I17 0 0 1.10 1.94 gem-tie 010 ,-------I \n3810 01381010 11 1I IT- Ilnlo 21 0 0 9 012 Table 6: Invocation Graph Statistics 01970 019304 0420 33309 \n.-r--0171 0 0171 0 0  II 1 pare their numbers with ours, because they greatly de\u00adcompress 113290 04003 \npend on the intermediate program representation. We nwav II010 79 0 0 5 074 hash 7 0 0 0 OIO1OI7  do \nprovide simple examples in Section 7 which illus\u00admisr 23 0 8 0 01010131 trate when one method is superior \nto the other. xref o0 90o 90 0 Finally, Table 6 gives the following measurements st ati~rd 119 ---o01 \n0 0103 016 fixc-.=-.cl,1+,n,, t n-n for invocation graphs: nodes in the invocation graph, -5 00 500 \nsim 15 0 19 0 0 26 0 8 call-sit es in the program, functions actually called in travel 2 0123 0 14 57 \n054 the program, recursive and approximate nodes in the csuite 120520 85600 invocation graph, and the \naverage number of nodes in msc 00 600 600 the invocation graph per call-site, and per called func\u00ad lWS \n0 0428 0 1350 077 tion. Table 4: Categorization of Points-to Information Used The overall average for \nthe number of invocation by Indirect References graph nodes per call-site is 1.45. Thus each call-site \nappears on an average on two call-chains for our bench- Landi and Ryder [30] also present empirical data \non mark set. This indicates that our approach of explic\u00adthe total number of program-point-specific alias \npairs itly following call-chains is practical for real programs collected. However, it is difficult to \nmeaningfully com-of moderate size, though it is theoretically exponential in cost. However, to fully \nsupport this claim, we need to do further experimentation on larger benchmarks. If the size of the invocation \ngraph becomes unreason\u00adable on such benchmarks, we plan to reduce its size by sharing sub-trees that \nhave the same or similar invoca\u00adtion contexts. This can be implemented by caching or memoizing the input \nand output points-to information for each function, and by recognizing when a particular input has already \noccurred. If the output has already been computed, then the sub-trees can be shared and the stored output \ncan be used to continue the analysis. To estimate the benefits of our technique to han\u00addle function pointers, \nwe studied the benchmark live , which is a collection of Iivermore loops. It has three global arrays \nof function pointers, each initialized to a set of 24 functions. There are three indirect call\u00adsites \nin the program (each inside a loop), one involving each function pointer array. Each indirect call is \nmade through a scalar local function pointer, which is first as\u00adsigned the appropriate function pointer \narray element. Our algorithm constructs the precise invocation graph, instantiating each function pointer \ncall with the cor\u00adresponding 24 functions, giving a total of 203 nodes. The naive approach mentioned \nin section 5 would in\u00adstantiate each indirect call with 82 functions (the pro\u00adgram has total 82 functions), \nleading to an invocation graph with 619 nodes. An approach considering only the functions whose address \nhas been taken, would still instantiate each indirect call to 72 functions, and con\u00adstruct an invocation \ngraph with 589 nodes. Thus, both the approximations would yield very imprecise invoca\u00adtion graphs, as \ncompared to our algorithm. 6.1 Applications of Points-to Analysis The measure of success of an analysis \nlike points\u00adto or alias analysis is not just in measuring the num\u00adber of pointed-to locations. One must \nalso show how the results of such an analysis can be used as a build\u00ading block for other interprocedural \nanalyses and opti\u00admizing/parallelizing transformations. In our compiler framework, the points-to analysis \nprovides: (1) point\u00adspecific points-to information and (2) a complete invo\u00ad cation graph with mapping \ninformation that encodes how one maps variables from a calling context to a called context. The point-specific \npoints-to information is very use\u00ad ful to compute read/write sets such as those used in constructing \nthe ALPHA intermediate representa\u00adtion [21]. In these approaches one can directly compute the read and \nwrite sets based on the names of variables and the symbolic names used for invisibles. The points\u00adto \nresults are also critical to the support analyses re\u00adquired for dependence testing for array references \n[28]. In this context, points-to results are used to: increase the number of admissible loop-nests, decrease \nthe num\u00ad ber of array pairs that require testing, and allow the analysis of array subscripts that involve \npointer vari\u00adables. One example of an optimizing transformation is the use of definite points-to information \nto reduce the number of loads required in the low-level program rep\u00adresentation [12]. In the context \nof fine-grain paralleliz\u00ading transformations, we are currently studying the use of points-to information \nfor providing more accurate dependence information for instruction scheduling. The complete invocation \ngraph and mapping infor\u00admation provides a convenient basis for implementing other interprocedural analyses \nsuch as generalized con\u00adstant propagation [20], and practical heap analysis [16]. The important point \nhere is that after points\u00adto analysis is completed one does not need to worry about function pointers \nor the correspondence between invisible variables and the calling context. All of this information has \nbeen stored by the points-to analysis and need not be recalculated. 7 Related Work 7.1 Alias Analysis \nThe most closely related work is that of Landi and Ryder [30], and Choi et al. [7]. In the following \npara\u00adgraphs, we compare our approach with this and other related work, under different points of import \nante: Alias Representation Our points-to abstraction provides alias information in a more compact and \ninformative manner than the exhaustive alias pairs used by Landi and Ryder. This abstraction is par\u00adticularly \nsuited for calculating stack-based aliasing, as each stack location can be given a compile-time name. \nIt also eliminates the generation of extraneous alias . pairs in certain cases. Consider the example \nin Fig\u00adure 8. Figure 8(a) gives the points-to information, while Figure 8(b) gives the alias pairs computed \nby the Landi/Ryder may-alias algorithm. We can compare the two results by calculating the set of alias \npairs im\u00adplied by the points-to set using transitive closure. For this example, the spurious alias pair \n(**x, z) at pro\u00adgram point S3, would not be generated by our method. However, for the example in Figure \n9, the transitive closure of points-to pairs at S3 would generate spurious alias pair (**a, c), which \nwon t be reported by Landi and Ryder. The transitive reduction scheme proposed in [7] is similar to our \npoints-to abstraction in this con\u00adtext. maino { Sl: (*x,y) (**x, *y) int **x, *y, z, w; S2: (*x,y) (**x, \n*y) S1: x = &#38;y; /* (x,y, D) */ (*y,z) (**X,Z) S2: y = &#38;z; /* (x, y,D) S3: (*x)y) (**x, *y) * \n(Y, z,D) *I (*y,w) (**X,Z) S3: y = &#38;w; /* (z, y,D) (**X,W)  * (Y, w,D) *I }  (a) Original Program \n(b) Alias Information Figure 8: Points-to Pairs vs. Alias Pairs Must Aliases: The points-to abstraction \nenables the simultaneous calculation of both possible and def\u00adinite points-to relationships without any \nextra over\u00adhead. The empirical results presented in section 6 show the existence of a substantial number \nof definite points\u00adto relationships, which forms very valuable informa\u00adtion. Landi and Ryder give an \nalgorithm only for cal\u00adculation of may-aliases. An algorithm for calculating must-aliases is presented \nin [32]. However, it handles only single level pointers and considers the problem in isolation from may-alias \ncomputation. Choi et al. give an example of how must-alias infor\u00admation can improve the precision of \nalias analysis. But they do not describe how to calculate must-aliases and how to integrate this calculation \nwith the may-alias calculation. Sagiv et al. [38] propose simultaneous collection of both universal and \nexistential properties of programs, in their logic-based formulation of data flow analysis problems. \nIn particular, they show how universal as\u00adsertions can be used to improve the accuracy of exis\u00adtential \nassertions, using the pointer equality problem as an example. This is similar to our approach where the \ndefinite points-t o information gives more precise killing information and reduces the number of spurious \npossible points-to pairs. maino { int **a, *b, c; ... S1: (*a,b) (**a, *b)if(c) S2: (*bjc)S1: ~:~: &#38;b; \n/* (a, b,D) */ S3: (*a,b) (**a, *b) (*b,c) s2: b = &#38;C; /+ (b,c,D) */ S3: 1* (a, b,P) (blc, P) */ \n} (a) Original Program (b) Alias Information Figure 9: Points-to Pairs vs. Alias Pairs Interprocedural \nAnalysis: Landi and Ryder pro\u00adpose a conditional approach for context-sensitive inter\u00adprocedural alias \nanalysis. They associate an assumed\u00adalias pair with every alias pair, where the validity of the alias \npair at a program point is condtttonal on the va\u00adlidity of the assumed-alias pair at the entry node of \nthe procedure containing the program point. They recover the calling context by determining the call-sites \nwhich can propagate the assumed-alias pair to the entry node of the procedure under analysis. Their scheme \nis pre\u00adcise for single-level pointers. However, in the presence of multi-level pointers, it can simultaneously \nuse infor\u00admation arriving from different call-sites and also prop\u00adagate information to extraneous call-sites. \nIn contrast, as illustrated in our discussion of mapping/unmapping, our method can be imprecise even \nfor single-level point\u00aders. However, in some instances, our interprocedural scheme can avoid combining \ninformation arriving from different calls sites and will thus give more accurate results for multi-level \npointers. Choi et al. associate the last call-site C encountered with each alias pair. They use this \ninformation to re\u00adcover cent ext, and to avoid simultaneously using alias information arriving from different \ncall-sites. However, they cannot distinguish information propagated by two different invocations of a \nprocedure from the same call\u00ad site. Further, they cannot properly handle information propagated along \ncall-chains of size greater than one. They also propose using a source alias set abstraction, but its \nrole is not clear from their paper [33]. We do not introduce these approximations, as we ex\u00adplicitly \npropagate information along invocation paths in the program, using the invocation graph represen\u00adtation. \nSeveral other advantages of using invocation graphs are mentioned in section 4. Our empirical results \nalso support the feasibility of this approach, though it is theoretically exponential in cost. FinalIy, \nnone of the above techniques handle function pointers, which oft en occur in C programs. We gracefully \ninte\u00adgrate them in our points-to analysis framework, with\u00adout incurring any extra overhead. Dynamically-allocated \nobjects: Landi and Ry\u00adder use the access paths as names for anonymous heap objects. They k-limit the \naccess paths to have a fi\u00adnite set of object names, in the presence of recursive structures. Choi et \nal. name the heap objects by us\u00ading the place in the program where they are created, as in [24]. They \nuse procedure-strings and k-limiting of recursive structures [26] to improve their naming scheme. These \nnames are then used in alias calcula\u00adtion. We differ from these approaches in that we claim that the \nstack and heap problems can and should be separated. The fact that the analyses can be separated is substantiated \nby our empirical evidence that heap\u00addirected pointers do not in general, point back to the stack in real \nprograms. Thus, we use a single location called heap in our abstract stack for the points-to anal\u00adysis. \nAll heap-directed pointers point to this location. We have designed a separate family of abstractions \nto capture meaningful relationships between these heap\u00addirected pointers [16], based on the path-matrix \nmodel proposed in [23]. Both the original path matrix analy\u00adsis [23] and the heap-based method proposed \nby Chase et al. [6] also assume that pointer fields in heap nodes only point to heap nodes, and do not \npoint to vari\u00adables (which are locations on stack). It is important to note that our points-to method \nprovides a safe ap\u00adproximation even in the presence of pointers from the heap to the stack. However, \nthere maybe some loss of precision due to the abstraction of all heap locations with one abstract stack \nlocation, To date, our exper\u00adiments show that this is not a problem, and that it is reasonable to decouple \nthe stack and heap analyses. 7.2 Function Pointers The problem of constructing the call graph of a pro\u00adgram \nin the presence of procedure variables has been previously studied [3, 17, 29, 37, 42, 44]. However, \nthe above techniques cannot handle function pointers, be\u00ad cause in C they are considered no different \nfrom data pointers. One can have function pointers of multiple level, as fields of structures, and as \narrays. They can also be type-cast into data pointers and vice versa. Hence the full power of a points-to \nanalysis is needed to correctly and precisely accommodate them in an in\u00adterprocedural analysis. An analogous \nproblem of control flow analysis [40], has been studied in the domain of higher order lan\u00adguages. Here, \nthe possibility y of creating functions dy\u00adnamically (for example, using lsmbda in Scheme) poses additional \ncomplexity. Different approaches to solve this problem have been proposed [10, 18,35,39,40, 41]. In object-oriented \nlanguages, call graph analysis be\u00adcomes non-t rivial due to inherit ante and function over\u00adloading. The \nmethod invoked from a call-site depends on the type of the receiver, and static type determi\u00adnation is \nused to estimate control flow. Type analy\u00adsis techniques have been developed for C++ [36] and SELF [4, \n5]. 8 Conclusions and Further Work In this paper we have presented a new method for computing the points-to \ninformation for stack\u00adallocated data structures. This method uses the con\u00adcept of abstract stack locations \nto capture all possible and definite relationships between accessible stack lo\u00adcations. The method provides \ncontext-sensitive inter\u00adprocedural information, and it handles general func\u00adtion pointers in an integrated \nfashion. The points-to information can be used to generate traditional alias pairs, or it can be used \ndirectly for numerous other op\u00adtimization and transformations including pointer re\u00adplacement and array \ndependence testing. We have provided substantial empirical results that demonstrate that the method provides \naccurate and useful approximations, These results also show that it is safe and accurate to separate \nthe stack-based points\u00adto analysis from the structure-based approximations for heap-allocated objects. \nFurthermore, the metlhod has been used as a foundation for a general purpose interprocedural analysis \nmethod [20]. The next steps in our work will be to add further optimizations to the method itself, and \nto measure the effect of accurate points-to analysis on other optimiza\u00adtion and transformations. We are \nalso working on the companion analyses to approximate the heap. These analyses are based on a series \nof practical approxima\u00adtions of the relationships between directly-accessible heap-allocated nodes. These \napproximations vary from simple connection matrices that approximate the con\u00adnectivity of nodes, to complete \npath matrices that give complete approximations of connectivity and paths be\u00adt ween nodes. 9 Acknowledgments \nA special thanks to Bill Landi for numerous e-mail discussions and his willingness to share with us output \nfrom his analysis and some of his benchmarks. We would also like to thank the PLDI program committee \nfor their careful reviews and helpful comments. Last, but not the least, we thank all the people who \nhave participated in developing the McCAT compiler. References [1] J. P. Banning. An efficient way to \nfind the side ef\u00adfects of procedure calls and the aliases of variables. In Conference Record of the Sixth \nA ranual ACM Sympos\u00adium on Principles of Programming Languages. pages 29-41, January 1979. [2] J. M. \nBarth. An interprocedural data flow anaJysis algorithm. In Conference Record of the Fourth ACM Symposium \non Principles of Programming Languages, pages 119 131, January 1977. [3] D. Callahan, A. Carle, M. W. \nHall, and K. Kennedy. Constructing the procedure call Multigraph. IEEE Transactions on So&#38;ware Engineering \n16,4, pages 483\u00ad487, April 1990. [4] C. Chambers and D. Ungar. Customization: Opti\u00admizing compileq technology \nfor SELF, a dynamically\u00adtyped object-oriented programming language. In Pro\u00adceedings of the SIGPLAN 89 \nS rnposium on Program\u00ad ming Lan uage Design and Ymplernentation, pages 146-160, ?une 1989. [5] C. Chambers \nand D. Ungar. Iterative t ype analysis and extended .messa~e splitting: Optimizing dynamicrdly\u00adt ped \nob ect-oriented pro~rams. In Proceedings of tie SIG~LAN 90 S mposmm on Programming Lan\u00ad ua e Design and \nimplementation, pages 150-164, Yunz 1990. [6] D. R. Chase, M. Wegman, and F. K. Zadeck. Analysis of \nointers and structures. In Proceedings of the SIG-P~AN 90 Conference on Programming Language De\u00ad si n \nand Im lamentation, pages 296 310, June 1990. Sl?GPLAN $otices, Vol 25, No 6. [7] J. D. Choi, M. G. \nBurke, and P. Carini. Efficient flow-sensitive inter rocedural computation of pointer\u00adinduced aliases \nan $ side effects. In Conference Record of the Twentieth Annual ACM Symposmna on Princi\u00ad ples of Programming \nLanguages, pages 232 245, Jan\u00aduary 1993. [8] K. Cooper and K. Kennedy. Efficient computation of flow \ninsensitive interprocedural summar informa\u00adtion. In Proceedings of the SIGPLAN 84 ~ymposium on Compiler \nConstruction, ~~a247-258 , June 1984. SIGPLAN Notices, Vol 19, . [9] K. D. Cooper and K. Kennedy. Fast \ninterprocedural alias analysis. In Conference Record of the Sixteenth Annual ACM Symposium on Principles \nof Program\u00adming Languages, pages 49 59, January 1989. [10] A. Deutsch. On determining lifetime and alissing \nof dynamically allocated data in higher-order functional s edifications. In Conference Record of the \nSeventeenth ~nnua! ACM Symposium on Principles of Program\u00adming Languages, pages 157 168, January 1990. \n [11] A. Deutsch. A storeless model of aliasing and its ab\u00adstractions using finite re resentations of \nri ht-regular equivalence relations. In ?h-oceedings of the ?EEE 199.2 International Conference on Computer \nLanguages, pages 2 13, April 1992. [12] C. M. Donawa. The design and implementation of a structured \nbackend for the McCAT C com tier. Mas\u00ad ter s thesis, School of Computer Science, ficGill Uni\u00adversity, \nexpected July 1994. [13] M. Emami. A practical interprocedural alias analysis for an optimizing/ parallelizing \nC compiler. Master s thesis, School of Computer Science, McGill University, August 1993. [14] A. M. \nErosa and L. J. Hendren. Taming control flow: A structured approach to eliminating goto statements. In \nProceedings of the IEEE 1994 Internatzoncd Confer\u00adence on Computer Languages, May 1994. [15] R. Ghiya. \nInterprocedural analysis inthe presence of function pointers. ACAPSTechnical Memo 62. School of Computer \nScience, McGill University, December 1992. [16] R. Ghiya. Practical techniques for heap analysis. ACAPS \nTechnical Note 46, School of Computer Sci\u00adence, McGill University, May 1993. [17] M. W. Hall and K. \nKennedy. Efficient call graph anal\u00adysis. ACM Letters on Programming Languages and Systems, 1(3), pages \n227-242, September 1992. [18] W. L. Harrison III. The interprocedural analysis and arallelization of \nScheme programs. Lis automaticand Symbo Ftc Computation: an International Journa Y, 1989. 2(3/4):179-396. \n [19] W. L. Harrison III and Z. Ammarguellat. A program s eye view of Miprac. In Conference Record of \nFifth International Workshop on Languages and Compilers for Parallel Computing, August 1992. Volume 757 \nof Lecture Notes in Computer Science, pages 512-537. Springer Verlag, 1993. [20] L. J. Hendren, M. Emami, \nR. Ghiya, and C. Ver\u00ad bru ge. A practical context-sensitive inter rocedural an 3 ysis framework for C \ncompilers. ACAP { Technical Memo 72, School of Computer Science, McGill Univer\u00ad sity, July 1993. [21] \nL. J. Hendren, G. R. Gao, and V. C. Sreedhar. AL-PHA: A family of.structured intermediate re resenta\u00adtions \nfor a arallehzmg C compd~r. ACAPS. $ ethnical Memo 49, 8 chool of Computer Science, McGdl Univer\u00adsity, \nNov 1992. [22] L. J. Hendren, C. Donawa, M. Emami, G. R. Gao, Justiani, and B. Sridharan. Designin the \nMcCAT compiler based on a family of structure ~ intermediate representations. In Conference Record of \nFifth Interna\u00ad tional Workshop on Languages and Compilers for Par\u00adallel Computing, August 1992. Volume \n757 of Lecture Notes in Computer Science, pages 406 420. Springer Verlag, 1993. [23] L. J. Hendren and \nA. Nicolau. Parallelizing programs with recursive data structures. IEEE Trarzsactiom on Parallel and \nDistributed Systems, 1(1):35-47, January 1990. [24] S. Horwitz, P. Pfeiffer, and T. Reps. Dependence \nanal\u00adysis for pointer variables. In Proceedings of the SIG- PLAN 89 Symposium on Programming Language \n13e\u00adsign and Implementation, pages 28 40, June 1989. [25] S. Horwitz, T. Reps, and D. Birddey. Interprocedural \nslicing using dependence graphs. ACM Transactions on Programming Languages and Systems, 12(1):26 60, \nJanuary 1990. [26] N. D. Jones and S. Muchnick. Flow analysis and op\u00adtimization of LISP-like structures. \nIn Program Flow Analysis, Theory, and Applications, pages 102 131. Prentice-Hall, 1981. Chapter 4. [27] \nN. D. Jones and S. Muchnick. A flexible approach to interprocedural data flow anal sis and programs with \nrecursive data structures. In Conference Record of the Ninth Annual ACM Symposium on Principles of Pro\u00ad \ngramming Languages, pages 66-74, January 1982. [28] Justiani and L. J. Hendren. Supporting array depen\u00addence \ntesting for an optimizing/parallelizing C com\u00adpiler. In Proceedings of 199ij International Conference \non Compiler Construction., A ril 1994. Volume 749 of Lecture Notes in Computer .S&#38;ence. Springer \nVerlag, 1993. [29] A. Lakhotia. Constructing call multigraphs using de\u00adpendence graphs. In Conference \nRecord of the Twen\u00ad tieth Annual ACM Symposium on Principles of Pro\u00adgrammmg Languages, pages 273 284, \nJanuary 1993. [30] W. Landi and B. G. Ryder. A safe approximate algo\u00adrithm for interprocedural pointer \naliasing. In Proceed\u00adings of the 1992 SIGPLAN Symposium on Program\u00ad ming Language Design and Implementation, \npages 235-248, June 1992. [31] W. Landi, B. G. Ryder, and S. Zhang. Interprocedural modification side \neffect analysis with ointer aJiasing. In Proceedings of the 1993 SIGPLA$ Symposium on Programmz n Language \nDesign and Implementation, pages 56-67, $une 1993. [32] W. A. Landi. Interprocedzmal Aiiasirag in the \nPresence of Potnters. PhD thesis, Rutgers University, 1992. [33] T. J. Marlowe, W. A. Landi, B. G. Ryder, \nJ. D. Choi, M. G. Burke, and P. Carini. Pointer-induced aliasing: A clarification. ACM SIGPLAN Notices, \n28(9), pages 67-70, September 1993. [34] E. W. Myers. A precise inter-procedural data flow al\u00adgorithm. \nIn Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Lan\u00adguages. pages \n219 230, January 1981. [35] A. Neirynck, P. Panangaden, and A. J. Demers. Ef\u00adfect analysis in higher-order \nlanguages. International Journal of Parallel Programming, 18(1):1-37, 1989. [36] H. D. Pande and B. G. \nRyder. Static type determina\u00ad tion for C++. In Proceedin s of the Sizth Usenix C++ Technical Conference, \nApr 1 1994. [37] B. G. Ryder. Constructing the call graph of a pro\u00adgram. IEEE Transactions on Software \nEngineering, SE-5(3):216-226, May 1979. [38] S. Sagiv, N. Francez, M. Rodeh, and R. Wilhem. A logic-based \napproach to data flow anaJysis. Iu Proceed\u00adings of Second International Worksho on Program\u00adming Language \nImplementation and f$c Promcl; ming, Volume 456 of Lecture Notes in ence, pages 277 292. Springer Verlag, \nAu~~<t 1990.  [39] P. Sestoft. Replacing function parameters by global variables. In Conference on Function \nat Programming Lan uages and Computer Architecture, pages 39-53, Lon i on, September 1989. ACM Press. \n [40] 0, Shivers. Control flow analysis in Scheme. In Pro\u00adceedings of the SIGPLAN 88 S mposium on Program\u00ad \nmang Language Design and 7mplementation, pages 164-174, June 1988. [41] O. Shivers. Control Flow Analysis \nof Higher Order Languages. PhD thesis, School of Computer Science, Carnegie Mellon University, 1991. \n [42] T, G. Spillman. Exposing side-effects in a PL/I op\u00adtimizing compiler. In Proceedings of the 1971 \nIFIPS Congress. North Holland Publishing Co., Amsterdam, 1971, pages 56 60. [43] B. Sridharan. An analysis \nframework for the McCAT com iler. Master s thesis, School of Computer Science, Mc 8 iU University, September \n1992. [44] W. Weihl. Interprocedural data flow analysis in the presence of pointers, procedure variables \nand label variables. In Conference Record of the Seventh An\u00ad nual ACM Symposium on Principles of Programming \nLanguages. pages 83-94, January 1980.   \n\t\t\t", "proc_id": "178243", "abstract": "<p>This paper reports on the design, implementation, and empirical results of a new method for dealing with the aliasing problem in C. The method is based on approximating the points-to relationships between accessible stack locations, and can be used to generate alias pairs, or used directly for other analyses and transformations.</p><p>Our method provides context-sensitive interprocedural information based on analysis over invocation graphs that capture all calling contexts including recursive and mutually-recursive calling contexts. Furthermore, the method allows the smooth integration for handling general function pointers in C.</p><p>We illustrate the effectiveness of the method with empirical results from an implementation in the McCAT optimizing/parallelizing C compiler.</p>", "authors": [{"name": "Maryam Emami", "author_profile_id": "81332497280", "affiliation": "School of Computer Science, McGill University, Montreal, Quebec, Canada H3A 2A7", "person_id": "PP31077104", "email_address": "", "orcid_id": ""}, {"name": "Rakesh Ghiya", "author_profile_id": "81100605741", "affiliation": "School of Computer Science, McGill University, Montreal, Quebec, Canada H3A 2A7", "person_id": "P238209", "email_address": "", "orcid_id": ""}, {"name": "Laurie J. Hendren", "author_profile_id": "81100646110", "affiliation": "School of Computer Science, McGill University, Montreal, Quebec, Canada H3A 2A7", "person_id": "P169482", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/178243.178264", "year": "1994", "article_id": "178264", "conference": "PLDI", "title": "Context-sensitive interprocedural points-to analysis in the presence of function pointers", "url": "http://dl.acm.org/citation.cfm?id=178264"}