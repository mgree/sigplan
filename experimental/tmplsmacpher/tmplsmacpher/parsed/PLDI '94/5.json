{"article_publication_date": "06-01-1994", "fulltext": "\n Division by Invariant Integers using Multiplication Torbjorn Granlund* Cygnus Support 1937 Landings \nDrive Mountain View, CA 94043-0801 tegeQcygnus.com Abstract Integer division remains expensive on today \ns pro\u00adcessors as the cost of integer multiplication declines. We present code sequences for division \nby arbitrary nonzero integer constants and run time invariants us\u00ading integer multiplication. The algorithms \nassume a two s complement architecture. Most also require that the upper half of an integer product be \nquickly accessi\u00adble. We treat unsigned division, signed division where the quotient rounds towards zero, \nsigned division where the quotient rounds towards co, and division where the result is known a priori \nto be exact. We give some implementation results using the C compiler GCC. 1 Introduction The cost of \nan integer division on today s RISC proces\u00ad sors is several times that of an integer multiplication. \nThe trend is towards fast, often pipelined combinatorics multipliers that perform an operation in typically \nless than 10 cycles, with either no hardware support for integer division or iterating dividers that \nare several times slower than the multiplier. Table 1.1 compares multiplication and division times on \nsome processors. This table illustrates that the dis\u00ad crepancy between multiplication and division timing \nhas been growing. Integer division is used heavily in base conversions, number theoretic codes, and graphics \ncodes. Compilers *Work done by first author while at Swedish Institute of Com\u00ad puter Science, Stockholm, \nSweden. t Work done by second author while at University of Califor\u00ad nia, Los Angeles. Supported by U.S. \nArmy fellowship DAAL03 89 G 0063. Permission to cop without fee all or part of this material is granted \nprovided t{ at the copies are not made or distributed for direct commercial advantage, the ACM copyright \nnotice and the title of the publication and its date appear; and notice is given that copying is by permission \nof the Association of Computing Machinery. To copy otherwise, or to republish, requires a fee and/or \nspecific permission. SIGPLAN 94-6/94 Orlando, florida USA @ 1994 ACM 0-89791 -662-x19410006..$3.5O Peter \nL. Montgomery Centrum voor Wiskunde en Informatica 780 Las Colindas Road San Rafael, CA 94903-2346 pmontgomQmath.orst \n.edu generate integer divisions to compute loop counts and subtract pointers. In a static analysis of \nFORTRAN programs, Knuth [13, p. 9] reports that 39% of 46466 arithmetic operators were additions, 2270 \nsubtract ions, 27% multiplications, 10% divisions, and 2% exponenti\u00adations. Knuth s counts do not distinguish \ninteger and floating point operations, except that 4% of the divi\u00adsions were divisions by 2. When integer \nmultiplication is cheaper than integer division, it is beneficial to substitute a multiplication for \na division. Multiple authors [2, 11, 15] present al\u00adgorithms for division by constants, but only when \nthe divisor divides 2k 1 for some small k. Magenheimer et al [16, ~7] give the foundation of a more \ngeneral approach, which Alverson [1] implements on the Tera Computing System. Compiler writers are only \nbegin\u00adning to become aware of the general technique. For example, version 1.02 of the IBM RS/6000 XIC \nand xlf compilers uses the integer multiply instruction to ex\u00adpand signed integer divisions by 3, 5, \n7, 9, 25, and 125, but not by other odd integer divisors below 256, and never for unsigned division. \nWe assume an N bit two s complement architecture. Unsigned (i.e., nonnegative) integers range from O \nto 2N 1 inclusive; signed integers range from 2N-1 to 2N ~ 1. We denote these integers by uword and \nsword respectively. Unsigned doubleword integers (range O to 22N 1) are denoted by udword. Signed 2 \n2N-1 to 22N-1 1) are doubleword integers (range denoted by sdword. The type int is used for shift counts \nand logarithms. Several of the algorithms require the upper half of an integer product obtained by multiplying \ntwo uwords or two swords. All algorithms need simple operations such as adds, shifts, and bitwise operations \n(bit ops) on uwords and swords, as summarized in Table 3.1. We show how to use these operations to divide \nby ar\u00adbitrary nonzero constants, as well aa by divisors which are loop invariant or repeated in a basic \nblock, using one multiplication plus a few simple instructions per di\u00advision. The present ation concentrates \non three types of 61 ~ Approx. Time (cycles) for Time (cycles) for Architecture/Implementation Year HIGH(N-bit \n* N-bit) N-bit/N-bit divide 76-78 (unsigned) Motorola MC68020 [18, pp. 9-22] 32 1985 41-44 88-90 (signed) \nMotorola MC68040 32 1991 20 44 Intel 386 [9] 32 1985 9-38 38 Intel 486 [10] 32 1989 13-42 40 Intel Pentium \n32 1993 10 46 SPARC Cypress CY7C601 32 1989 40 100s SPARC Viking [20] 32 1992 5 19 HP PA 83 [16] 32 1985 \n45s 70s HP PA 7000 32 1990 3FP 70s MIPS R3000 [12] 32 1988 12P 35P 12P 75 MIPS R4000 [17] ;: 1991 20P \n139 POWER/RIOS I [4, 22] 32 1989 5 (signed only) 19 (signed only) PowerPC/MPC601 [19] 32 1993 5-1o 36 \nDEC Alpha 21064AA [8] 64 1992 23P 200s Motorola MC881OO 32 1989 17s 38 Motorola MC88110 32 1992 3P 18 \ns No direct hardware support; approximate cycle count for software implementation F Does not include \ntime for moving data to/from floating point registers p -Pipelined implementation (i.e., independent \ninstructions can execute simultaneously) Table 1.1: Multiplication and division times on different CPUS \ndivision, in order by difficulty: (i) unsigned, (ii) signed, quotient rounded towards zero, (iii) signed, \nquotient rounded towards m. Other topics are division of a udword by a run time invariant uword, division \nwhen the remainder is known a priori to be zero, and testing for a given remainder. In each case we \ngive the mathe\u00admatical background and suggest an algorithm which a compiler can use to generate the code. \nThe algorithms are ineffective when a divisor is not invariant, such as in the Euclidean GCD algorithm. \nMost algorithms presented herein yield only the quo\u00adtient. The remainder, if desired, can be computed \nby an additional multiplication and subtraction. We have implemented the algorithms in a develop\u00admental \nversion of the GCC 2.6 compiler [21]. DEC uses some of these algorithms in its Alpha AXP compilers. 2 \nMathematical notations Let c be a real number. Then [z] denotes the largest integer not exceeding z and \n[*1 denotes the least in\u00adteger not less than z. Let TRUNC(Z) denote the integer part of a, rounded towards \nzero. Formally, TRUNC(Z) = [xJ if z ~ O and TRUNC(Z) = [xl if z < 0. The absolute value of z is lx 1. \nFor z > 0, the (real) base 2 logarithm of z is logz z. A multiplication is written z * y. If x, y, and \nn are integers and n # O,then x ? y (mod n) means x y is a multiple of n. Two remainder operators are \ncommon in language definitions. Sometimes a remainder has the sign of the dividend and sometimes the \nsign of the divisor. We use the Ada notations n rem d = n d * TRUNC(n/d) (sign of dividend), nmodd=n \nd*[n/dJ (sign of divisor). (2.1) The Fortran 90 names are MOD and MODULO. In C, the definition of remainder \nis implementation dependent (many C implementations round signed quotients towards zero and use rem remaindering). \nOther definitions have been proposed [6, 7]. If n is an udword or sdword, then HIGH(n) and LOW(n) denote \nthe most significant and least signifi\u00adcant halves of n. LOW(n) is a uword, while HIGH(n) is an uword \nif n is a udword and an sword if n is a sdword. In both cases n = 2N * HIGH(n)+ LOW(n). 3 Assumed instructions \nThe suggested code assumes the operations in Ta\u00adble 3.1, on an N bit machine. Some primitives, such as \nloading constants and operands, are implicit in the notation and are not included in the operation counts. \n62 TRUNC(X) Truncation towards zero; see ~2. HIGH(x), LOW($) Upper and lower halves of x: see ]2. MULL(Z, \ny) Lower half of product ~ x y (i.e., product modulo 2N ). MULSH(Z, y) Upper half of signed product z \n*y: If 2N-l ~ z, y s 2N-1 1, then z x y = 2N x MULSH(r, y) + MULL($, y). MULUH(@, y) Upper half of \nunsigned product z x y: If O s z, y s 2N 1, then z x y = 2N x MULUH(Z, y) + MULL(Z, y). AND(z, y) Bitwise \nAND of z and y. EOR(Z, y) Bitwise exclusive OR of x and y. NOT($) Bitwise complement of z. Equal to \n1 x if x is signed, to 2N 1 z if x is unsigned. OR(X, y) Bitwise OR of z and y. SLL(X, n) Logical \nleft shift of z by n bits (O ~ n ~ IV 1). SRA(Z, n) Arithmetic right shift of x by n bits (O < n s iV \n 1). SRL(Z, n) Logical right shift of z by n bits (O ~ n ~ iV 1). XSIGN(X) 1 if x < O; O if x ~ O. \nShort for SRA(X, N 1) or SRL(Z, IV 1). X+y, x y> z Two s complement addition, subtraction, negation. \nTable 3.1: Mathematical notations and primitive operations  The algorithm in 58 requires the ability \nto add or subtract two doublewords, obtaining a doubleword re\u00adsult; this typically expands into 2 4 instruct \nions. The algorithms for processing constant divisors re\u00adquire compile time arithmetic on udwords. Algorithms \nfor processing run time invariant divi\u00adsors require taking the base 2 logarithm of a positive integer \n(sometimes rounded up, sometimes down) and require dividing a udword by a uword. If the algo\u00adrithms are \nused only for constant divisors, then these operations are needed only at compile time. If the ar\u00adchitecture \nhas a leading zero count (LDZ) instruction, then these logarithms can be found from [log, xl = iV -LDZ(Z \n-1), [log, XJ = N -1-LDZ(Z) (1< Z<2N-1). Some algorithms may produce expressions such as SRL(Z, O) or \n(x y); the optimizer should make the obvious simplifications. Some descriptions show an ad\u00addition or \nsubtraction of 2N, which is a no-op. If an architecture lacks arithmetic right shift, then it can be \ncomputed from the identity SRA(Z, 1) = SRL(Z + 2N-1, 1) 2N-1-e whenever O<l ~ N 1. If an architecture \nhas only one of MULSH and MULUH, then the other can be computed using MULUH(X, U) = MULSH(X, y)+ AND(%, \nXSIGN(v)) + AND(Y, XSIGN(X)) for arbitrary N bit patterns x, y (interpreted as uwords for MULUH and as \nswords for MU LSH). 4 Unsigned division Suppose we want to compile an unsigned division q = [n/d], where \nO < d < 2N is a constant or run-time invariant and O s n < 2N is variable. Let s try to find a rational \napproximation m/2N+t of l/d such that M=B%Jwhenever O < n < 2N 1. (4.1) Setting n = d in (4.1) shows \nwe require 2N+1 s m *d. Setting n=q*d l shows 2N+txq> rnx(qxd-1). Multiply by d to derive (m x d 2N+1) \n*(q* d 1) < 2N+~, This inequality will hold for all values of q * a! 1 below 2N if m * d 2N+~ ~ 2~. \nTheorem 4.2 below states that these conditions are sufficient, because the maximum relative error (1 \npart in 2N) is too small to affect the quotient when n < 2N. Theorem 4.2 Suppose m, d, / are nonnegative \ninte\u00adgers such that d # O and 2N+~ < m~d< 2N+~ +2~. (4.3) Then Ln/d] = [m * n/2N+1j for every integer \nn with 0~n<2N. PROOF. Define k = m * d 2N+t. Then O ~ k <21 by hypothesis. Given n with O s n < 2N, write \nn = q*d+rwhere q=[n/d]and O~r~d l. We must show that q = [m * n/2 N+LJ. A calculation gives m*n ~=k+2N+~ \nn _ 2N+t *2Nfl q k fn (4.4) d*2N+t+; ~ k 1 ~* +~. P*2N d d 63 IMPROVEMENT. If d is constant and m = \nm + 2N is This difference is nonnegative and does not exceed 2N 1 1d l l_ 1<1 1* * + = 2N d d m Theorem \n4.2 allows division by d to be replaced with multiplication by rn/2N+t if (4.3) holds. In general we \nrequire 22 ~ d 1 to ensure that a suitable multiple of d exists in the interval [2N+~, 2N+~ +22]. For \ncompatibil\u00adity with the algorithms for signed division (!j 5 and ~6), it is convenient to choose m * \nd > 2N+~ even though Theorem 4.2 permits equality. Since m can be almost as large as 2 +1 we don t multiply \nby m directly, but instead by 2N &#38;d m 2N. This leads to the code in Figure 4.1. Its cost is 1 multiply, \n2 adds/subtracts, and 2 shifts per quotient, after computing constants dependent only on the divisor. \nInitialization (given uword d with 1 ~ d < 2N ): int 1 = ~logz dl; /*d~2 ~2*d-1*/ uword m = [2N *(2L \nd)/dJ + 1; / m = [2 Nt /d] -2N + 1 / int shl = min(l, 1); int shz = max(f 1, O); / sh, =1-shl / For \nq = n/d, all uword: uword tl = MULUH(m , n); ~ = SRL(tl + SRL(n tl, shl), shz); Figure 4.1: Unsigned \ndivision by run time invariant divisor EXPLANATION OF FIGURE 4.1. If d = 1, then 1 = O, so m = 1 and \nshl = shz = O. The code computes tl=[l*n/2NJ =Oandq=n. Ifd>l, then 1~1, soshl= land sh2=/ l. Since m, \n< 2N * (21 d) +1<2N*(d 1)  +1<2N, J ,1 the value of m fit: in a uword. Sinc~ O < tl < n, the formula \nfor q simplifies to But tl +n= [m *n/2N] +n= l(m +2N) *n/2NJ. Set m = m +2N= 12N+Z/dj + 1.The hypothesis \nof Theorem 4.2 is satisfied since 2N+~ < m * d ~ 2N~t + d< 2N+k+2i. H ~AUTION. Conceptually q is SRL(n \n+ tl, 1), as in (4.5). Do not compute q this way, since n+tl may over\u00adflow iV bits and the shift count \nmay be out of bounds. IMPROVEMENT. If d is constant and a power of 2, replace the division by a shift. \neven, then reduce m/21 to lowest terms. The reduced multiplier fits in IV bits, unlike the original. \nIn rare cases (e.g., d = 641 on a 32 bit machine, d = 274177 on a 64 bit machine) the final shift is \nzero. IMPROVEMENT. If d is constant and even, rewrite n in/2 J for some .>0. Then [n/2e] can be  [1 \n[ 2= d/2 computed using-SRL. Since n/2e < 2N e, less preci\u00adsion is needed in the multiplier than before. \nThese ideas are reflected in Figure 4.2, which gener\u00adates code for n/d where n is unsigned and d is constant. \nProcedure CHOOSE.MULTIPLIER, which is shared by this and later algorithms, appears in Figure 6.2 Inputs: \nuword d and n, with d constant. uword dodd, tl; udword m; int e, 1, &#38;Um~y, s pOst, S pre; (m, Apo.t, \nP)= ~HOOS~.MULTIPLIER(d, IV); if m ~ 2N and diseven then Find e such that d = 2e * dodd and dodd is odd. \n/ 2e= AND(d, 2N -d) / shpre = e; (m, hp.st, ~d.rnrny) = CHOOSE.MULTIPLIER( dOdd, IV e); else shpre \no; md if if d = 21then Issue q = SRL(n, l); ~lseif m> 2Nthen assert shpre = O; Issue tl = MULUH(m 2N, \nn); Issue q = SRL(tl + SRL(n fl, 1), shpow 1); else Issue g = SRL(MULUH(m, SRL(n, Shpre)), sh post \n) , end if Figure 4.2: Optimized code generation of unsigned q = [n/dj for constant nonzero d The following \nthree examples illustrate the cases in Figure 4.2. All assume unsigned 32 bit arithmetic. EXAMPLE. ~ \n= [n/IoJ . CHOOSE_MULTIPLIER finds mlo~ = (236 6)/10 and mh@ = (236+ 14)/10. After one round of divisions \nby 2, it returns (m, 3, 4), where m = (234 + 1)/5. The suggested code q = SRL(MULUH((234 + 1)/5, n), \n3) eliminates the pre shift by O. See Table 11.1. EXAMPLE. q = [n/7j. Here m = (235 + 3)/7 >232. This \nexample uses the longer sequence in Figure 4.1. EXAMPLE. q = in/14J. CHOOSE.MULTIPLIER first returns \nthe same multiplier as when d = 7. The 64 suggested code uses separate divisions by 2 and 7: q= SRL(MULUH((234 \n+5)/7, SRL(n, l)), 2). Signed division, quotient rounded towards O Suppose we want to compile a signed \ndivision q = TRUNC(n/d), where d is constant or run-time invari\u00adant, O < Idl ~ 2N-1, and where 2N l < \nn ~ 2N 1 1 is variable. All quotients are to be rounded towards zero. We could prove a theorem like Theorem \n4.2 about when TRUNC(n/d) = TRUNC(m * n/2N+~) for all n in a suitable range (cf. (7.1)), but it wouldn \nt help since we can t compute the right side given only [m* n/2 NJ. Instead we show how to adjust the \nestimated quotient when the dividend or divisor is negative. Theorem 5.1 Suppose m, d, f are integers \nsuch that d#Oand O<m*ldl 2N+e-1~ 2~. Letn bean arbitrary integer such that 2N-1 ~ n ~ 2N 1 1. Define \nq. = Lm * n/2 N+1-lJ. Then ( qoifn~Oandd>O, l+qOifn<Oandd>O,TRUNC (j) = qoifn~Oandd <O, l qOifn<Oandd<O. \n{ PROOF. When n ~ O and d >0, this is Theorem 4.2 with N replaced by N 1. Suppose n< Oandd>O, sayn=q \n*d r where O~r~d l. Define k=m*d-2N+L-l. Then m*n k nlr (5.2) q x 3*2JJ-1 *2+2 as in (4.4). Since O < \nk ~ 2t by hypothesis, the first fraction on the right of (5.2) is positive and r/d is non\u00adnegative. The \nsum is at most I/d + (d 1)/d = 1, so qo= [m *n/2 N+1 1 ] = q -1, as asserted. For d <0, use TRUNC(n/d) \n= TRUNC(n/ld[). CAUTION. When d <0, avoid rewriting the quotient as TRUNC(( n)/ldl), which fails for \nn = 2N-1. For a run time invariant divisor, this leads to the code in Figure 5.1. Its cost is 1 multiply, \n3 adds, 2 shifts, and 1 bit op per quotient. EXPLANATION OF FIGURE 5.1. The multiplier m satisfies 2N \n1 < m < 2N except when d = +1; in the latter cases m = 2N + 1. In either case m = m 2N fits in an sword. \nWe compute Lm * n/2NJ as n+ [(m 2N) *n/2Nj, using MULSH. The subtraction of XSIGN(n) adds one if n < \n0. The last line negates the tentative quotient if d <0 (i.e., if d~i~. = 1). VARIATION. An alternate \ncomputation of m is m = 2N * (21-1 [all)+ 1 TRUNC This uses signed ( Idl ) (2 N)-bit/N -bit division, \nwith NLbit quotient. Initialization (given constant sword d with d # O): int / = max( [log2 Idll, 1); \nudword m = 1 + [2N+1-1/\\dlJ; sword mt = m 2N; sword d~ign = XSIGN(d); int shPOSt=/ 1; For q = TRUNC(n/d), \nall sword: sword qo = n + MULSH(mt, n); go = sRMqo, Skt) xsIGN(n); u = EOR(U.. d.,..) d.,.. : Figure \n5.1: Signed division by run time invariant divi\u00adsor, rounded towards zero OVERFLOW DETECTION. The quotient \nn/d overflows ifn= 2N-1 and d = 1, The algorithm in Figure 5.1 returns 2N 1, If overflow detection is \nrequired, the final subtract ion of dsign should check for overflow. IMPROVEMENT. If m is constant and \neven, then re\u00adduce m/2e to lowest terms, as in the unsigned case. This improvement is reflected in Figure \n5.2, which generates code for TRUNC(n/d) where d is a nonzero constant. Figure 5.2 also checks for divisor \nbeing a power of 2 or negative thereof. Inputs: sword d and n, with d constant and d # O. udword m; int \n/, shPOSt; (m, sh,ost, 1) = CHOOSE.MULTIPLIER( loll, N -1); if Idl = 1then Issue q= d; else if Id[ = \n2t then Issue q = SRA(n + SRL(SRA(n, / 1), N /), 4); else if m < 2N-1 then Issue q = SRA(MULSH(m, \nn), shP~,t) XSIGN(n); else Issue q = SRA(n + MULSH(m 2N, n), shP~~t) XSIGN(n); Cmt. Caution m 2N \nis negative. end if if d<0 then Issue q = q; end if Figure 5,2: Optimized code generation of signed \nq = TRUNC(n/d) for constant d # O EXAMPLE. q = TRUNC(n/3). On a 32 bit machine. CHOOSE.MULTIPLIER(3, \n31) returns shP~~t = O and m = (232 + 2)/3. The code q = MULSH(m, n) XSIGN(n) uses one multiply, one \nshift, one subtract. 65 6 Signed division, quotient The dividend and divisor on the right of (6.3) are \nboth nonnegative and below 2 1. One can view them as rounded towards m signed or as unsigned when \napplying earlier algorithms. IMPROVEMENT. The XSIGN(OR(n, n + dsign)) is Some languages require negative \nquotients to round equivalent to (n < NOT(d.,g.)) and to (n < towards co rather than zero. With some \ningenuity, d,,gn), where the relational produce 1 if true and O we can compute these quotients in terms \nof quotients if false. On the MIPS R2000/R3000 [12], for example, which round towards zero, even if the \nsigns of the div\u00adone can compute idend and divisor are unknown at compile time. If n and d are integers, \nthen the identities d,,g. = SRL(d, N 1); TRUNC(n/d) ifn~Oandd>O, %gn = (n< d~lgn); / SLT, signed */ \n_ TRUNC((n + I)/d) 1 if n <0 and d >0, qslgn = EoR( ~sign, dslgn); [J: TRUNC((n 1)/d) 1 if n >0 and \nd <0, q = TRUNC((n ( ds,gn) + ( n.,g. ))/d) ( qsign); TRUNC(n/d) ifn~Oandd<O I (six instructions plus \nthe divide), saving an instruction are easily verified. Since the new numerators n+l never over (6.1). \noverflow, these identities can be used for computation. IMPROVEMENT. If n known to be nonzero, then ns,g. \nThey are summarized by simplifies to XSIGN(n). For constant divisors, one can use (6. 1) and the al\u00ad \n n n + dslgn nsign = TRUNC + ~s,gn, (61) gorithm in Figure 5.2. For constant d > 0 a shorter [1 d z( \n) algorithm, based on (6.3), appears in Figure 6.1. where d~ign = XSIGN(d), nsig. = XSIGN(OR(n, n + \n dsign) ), and ~sign = EOR(nwgn, ds,gn). The cost is Inputs: sword n and d, with d constant and d # O. \n2 shifts, 3 adds/subtracts, and 2 bit-ops, plus the di\u00adudword m; vide (n + dsi~. is a repeated sub expression). \nint 1, shPOSt; For remainders, a corollary to (2.1) and (6.1) is (m, shp~,,, 1) = CHOOSE_MULTIPLIER(d, \nIV -1); nmod d= n d*TRUNC((n + dsign nslgn )/d) if d= 21then Issue q = SRA(n, Y); d * ~sign = ((n+ dsign \n nsig.) rem d) else (6.2) assert m < 2N; Issue sword nsign = XSIGN(n); dsig. + n,ig~ d * gs,gn = ((n+ \nd~ign ~sign) rem d) + AND(d 2 * dsig. 1, Issue uword qo = MULUH(m, EOR(nsign, n)); qsign). Issue \nq = EOR(nS,gn, SRL(qO, shpost)); The last equality in (6.2) can be verified by separately end if checking \nthe cases q~ign = nsign d,i~n = O and qsig. = nsign + dsign = 1. The sub expression d 2 * d~ign 1 \nFigure 6.1: Optimized code generation of signed q = depends only on d. in/dj for constant d >0 For rounding \ntowards +cm, an analog of (6.1) is n n ~sign + npo5 EXAMPLE. Using signed 32 bit arithmetic, the code \n= TRUNC EoR(4ign, np.s), 11 z d for r = n mod 10 (nonnegative remainder) can be ( ) where d~ign = XSIGN(d) \nand nP~, = (n > dsign). sword n,lgn = XSIGN(n); IMPROVEMENT. If d >0 is constant, then dsign = O. uword \nq. = MULUH((233 + 3)/5, EOR(nsign, n ));Then (6,1) becomes sword q = EOR(nSign, SRL(qO, 2)); r = n SLL(q, \n1) SLL(q, 3);. n z [1 TRuNc(n-~sign)  +nsign} The cost is 1 multiply, 4 shifts, 2 bit ops, 2 subtracts. \nAlternately, if one has a fast signed division algo\u00ad where nsign = XSIGN(n). Since TRUNC( Z) = rithm \nwhich rounds quotients towards O and returns TRUNC(Z) and EOR( 1, n) = 1 n = (n + 1), remainders, then \n(6.2) justifies the code this is equivalent to n EOR(n~,g., n) r = ((n XSIGN(n)) rem 10) + AND(9, XSIGN(n)). \n= EOR nsign, TRUNC II z d (6.3) ( ()) (d> O). The cost is 1 divide, 1 shift, 1 bit op, 2 adds/subtracts. \n66 procedure CHOOSE.MULTIPLIER( uword d, int prec); Cmt. d -Constant divisor to invert. 1 ~ d < 2N. \nCmt. prec -Number of bits of precision needed, 1 ~ prec ~ IV. Cmt. Finds m, shPO,t, 1 such that: Cmt. \n2~-1 < d< 2~. Cmt. 0 s ShPO,~S 1. If shPo,~ >0, then N + shPost < / + prec. Cmt. 2N+ hPOSt < m * d < \n2N+shPOSt * (1 + 2-pre ). N~shpo,t * 1 + L1-e)/d < 2N+ APOSt ~+1 . Cmt. Corollary. If d < 2f re , ;hen \nm <2 ( Cmt. Hence m fits in max(prec, N 1) + 1 bits (unsig~ed). Cmt. int 1 = ~logz dl, shPost = 1; \nudword m~~~ = [2N+L/dj , mhigh = [(2N+L + 2~tt-f ec)/dj; Cmt. To avoid numerator overflow, compute rnlow \nas 2N + (mlOW 2N). Crnt. Likewise for mhigh. Compare m in Figure 4.1. 1 + POSt/dj < m~lg~ = 12N+shP0St \n* (1 + 2-~ ec)/dJ . Invariant. mlOW = 2 while lml~~ /2] < [mh,gh /2] and shPOSt >0 do mlow = lm~OW/2j; \nmhigh = [mhigh /2]; shpost = shpost 1; end while; /* Reduce to lowest terms. */ return (mhigh, Shpost, \n1); /* Three outputs. / end CHOOSE.MULTIPLIER; Figure 6.2: Selection of multiplier and shift count 7 \nUse of floating point One alternative to MULUH and MULSH uses floating point arithmetic. Let the floating \npoint mantissa be F bits wide (e.g., F = 53 for IEEE double precision arith\u00admetic). Then any floating \npoint operation has relative error at most 21 F, regardless of the rounding mode, unless exponent overflow \nor underflow occurs. Suppose N ~ 1 and F ~ N +3. We claim that TRUNC ~) = TRUNC(~est), ( (7.1) here \n= =n*(l+:-F) whenever Inl ~ 2N 1 and O < Idl < 2N, regardless of the rounding modes used to compute \nqest. The proof assumes that n > 0 and d > 0, by negating both sides of (7.1) if necessary (the case \nn = O is trivial). Since the relative error per operation is at most 21-F, the estimated quotient qe,t \nsatisfies 1 + 22-F *R< qe,t < (1+22 -F)*(l+2 -~)2 *;. (1+ 21-~)2 d - Use this and the inequalities (1+ \n22-F) *(1 + 2 -~)2 < l_;3-F s &#38;;-N to derive n/d n/d n+l (l_2-q* ;<qest<1_2_Ns1 1,=~ Denote q = TRUNC(n/d). \nThen qe,t < (n + 1)/d implies TRUNC(q~st) ~ q. If qest < q, then (1 2-~) *q<(l 2-~) *:< est < . Both \nq and qe,t are exactly representable as floating point numbers, but there are no representable numbers \nstrictly between (1 2 F) * q and q. This contradiction shows that qe,t ~ q and hence q = TRUNC(qe,t \n). For quotients rounded towards 00, use (6. 1). If F = 53 and N s 50, then (7.1) can be used for N-bit \ninteger division. The algorithm may trigger an IEEE exception for inexactness if the application program \nenables that condition. Alverson [1] uses integer multiplication, but com\u00adputes the multiplier using \nfloating point arithmetic. Baker [3] does modular multiplication using a com\u00adbination of floating point \nand integer arithmetic.  8 Dividing udword by uword One primitive operation for multiple precision arith\u00admetic \n[14, p. 251] is the division of a udword by a uword, obtaining uword quotient and remainder, where the \nquotient is known to be less than 2N. We 67 Initialization (given uword d, where O < d < 2N): int 1= \n1+ [logz dj; / 2t-~ ~ d< 2t / uword m = 1(2N * (21 d) 1)/dJ; / m = 1(2N+ -1)/dJ -2N / norm uword d \n SLL(d, N l); / Normalized divisor d * 2N-1 / Forq=[n/d] andr=n q*ct, where d, q, r are uword and n \nis udword: uword n2 = SLL(HIGH(n), iV 1) + SRL(LOW(n), ~); /* See note about shift count. / uword n10 \n= SLL(LOW(n), IV 1); / n~o = n~ * 2~-1 + no * 2N-L */ Ignore overflow. / / sword nl = XSIGN(nlO); uword \nnadj = n10 + AND( nl, Lorm 2N); ~lo + TZ1 * (dnorm 2N) / / /* = n, *(d.Orm 2N-1) + no*2N-L */ Underflow \nis impossible. uword ql = nz + HIGH(rn * (nz ( nl)) + n.dj); /* See Lemma 8.1. / / / sdworddr =n 2N*d+(2N \nl qI) *d; /*dr=n-ql*d-d, -d~dr< d / q = HIGH(dr) (2N 1 ql) +2N; / Add 1 to quotient if dr z O. */ r \n= LOW(dr) + AND(d 2N, HIGH(dr)); / Add d to remainder if dr <0. / Figure 8.1: Unsigned division of udword \nby run time invariant uword, describe a way to compute this quotient and remain\u00adder after some preliminary \ncomputations involving only the divisor, when the divisor is a run time invariant ex\u00adpression. Lemma \n8,1 Suppose that d, m, and 1 are nonnegative rntegers such that 2~ ~ ~ d < 2~ < 2N and ~<2N@-m*d <d.(8.2) \n Given nwith 0<n<d*2N l, write n=nz*2t+ nl * 2t-1 + no, where no, nl, and nj are integers with O ~ nl \n~ 1 and O < no < 2t-1 1. Define zntegers ql and q. by q~*2N+qo =n2*2N+(nj+n~)*(m 2N) + nl * (d* 2N-~ \n 2N-1) (8.3) + no * 2N-~  and O~qo~2N 1. Then O~q1<2N land O~n ql*d<2*d. PROOF. Define k = 2N+~ m \n* d. Then (8.2) implies 0<k~d~2~ 1. The bound n ~ d* 2N 1implies nz ~ d* 2N-~ 1. Equation (8.2) implies \nm > 2Nyt/d > 2N. A corollary to (8.3) is q~*2N+qo =n~*m+n~*(m 2N) +2N-~ * (nl *(d 2L-l)+ no) ~(d*2N-1 \nl)*m+l*(m 2N) + 2N-~ * (1* (21-1 1) + (21-1 1)) 2N-i *(d* m 2)<22N. This proves the upper bound on \nthe integer ql. A straightforward calculation using the definitions of k and q. and no reveals that n \nqlxd=(nj+nl) ~+qo d c)N  +(1-~)*(w*(d-2 -1)+ m). (8.4) Since 21-1 ~ d < 2! by hypothesis, the right \nside of (8.4) is nonnegative. This remainder is bounded by  (d.2N-2) .d+(2N l)*d +(4- -4  N*(l*@-2 \n- )+ ($+d)+(l-4*d=2*d completing the proof. H This leads to an algorithm like that in Figure 8.1 when \ndividing a udword by a run time invariant uword with quotient known to be less than 2N. Unlike the previous \nalgorithms, this code rounds the multiplier down when computing a reciprocal. After initializa\u00adtions \ndepending only on the divisor d, this algorithm requires two products (both halves of each) and 20 25 \nsimple operations (including doubleword adds and sub\u00adtracts). Five registers hold d, d.o,m, 1, m , and \nAJ 1. NOTE. The shift count Y in the computations of m and n2 may equal N. If this is too large, use \nseparate shifts by Y 1 and 1. If a doubleword shift is available, compute n2 and nlo together. 68 9 \nExact division by constants by expanding this rotate into Occasionally a language construct requires \na division whose remainder is known to vanish. An example oc\u00adcurs in C when subtracting two pointers. \nTheir numer\u00adical difference is divided by the object size. The object size is a compile time constant. \nSuppose we want code for q = n/d, where d is a nonzero constant and n is an expression known to be divisible \nby d. Write d = 2 * dodd where dodd is odd. Find dinv such that 1 s dinv s 2N 1 and dinv * dod,j E 1 \n(mod 2N). (9.1) Then 2 *q=2 *&#38;~ dodd = (dinv * dod~) * &#38; = dinv * n (mod 2N), 0 as in [2]. \nHence 2e * q s d,nv * n (mod 2N). Since n/dOdd = 2e * q fits in N bits, it must equal the lower half \nof the product dinv * n, namely MULL(dinv, n). An SRA (for signed division) or SRL (for unsigned di\u00advision) \nproduces the quotient q. The multiplicative inverse d,., of dodd modulo 2N can be found by the extended \nEuclidean GCD algo\u00adrithm [14, p. 325]. Another algorithm observes that (9. 1) holds modulo 23 if dlnv \n= dodd. Each Newton iteration di.v ~ dinv *(2 dinv * dodd) mod 2N (9.2) doubles the known exponent \nby which (9.1) holds, so ~log2(N/3)1 iterations of (9.2) suffice. If dodd = +1, then dinv = dO&#38;j \nso the multiplication by dinv is trivial or a negation. If d is odd, then e = O and the shift disappears. \nA variation tests whether an integer n is exactly di\u00advisible by a nonzero constant d without computing \nthe remainder. If d is a power of 2 (or the negative thereof, in the signed case), then check the lower \nbits of n to test whether d divides n. Otherwise compute dlnv and e as above. Let q. = MULL(dinv, n). \nIf n = q * d for some q, then q. = 2 * q must be a multiple of 2 . The original division is exact (no \nremainder) precisely when (i) q. is a multiple of 2 , and (ii) qo is sufficiently small that qo*dOdd \nis representable by the original data type.   For unsigned division check that and that the bottom \ne bits of q. (or of n) are zero. When e >0, these tests can be combined if the archi\u00adtecture has a rotate \n(i.e., circular shift) instruction, or 2N 1 OR(SRL(qO, e), SLL(qo, N e)) s ~ . 1] For signed division \ncheck that and that the bottom e bits of q. are zero; the inter\u00adval check can be done with an add and \none signed or unsigned compare. Relatedly, to test whether n rem d = r, where d and r are constants with \n1 ~ r < d and where n is signed, check whether MULL(dinv, n r) is a nonnegative multiple of 2 not exceeding \n2 * [(2 N-1 1 r)/dJ. EXAMPLE. To test whether a signed 32 bit value i is divisible by 100, let dinV \n= (19 * 232+ 1)/25. Compute sword q. = MULL(dinV, i). Next check whether go is a multiple of 4 in the \ninterval [ q~~x, q~~x], where qmax = (231 48)/25. Since these algorithms require only the lower half \nof a product, other optimizations for integer multiplica\u00adtion apply here too. For example, applying strength \nreduction to the C loop signed long i, imax; for (i =0; 1<irnax; 1++) { if ((i X100) == O) { .t might \nyield (** denotes exponentiation) const unsigned long dinv = ( 19*2* *32 + 1)/25; const unsigned long \nqmax = (2**31 -48)/25; unsigned long test = qmax; /* test = dinv*i + cynax mod 2**32 *I for (i = O; i \n< imax; i++, test += dinv) { if (test <= 2*qmax &#38;&#38; (test &#38; 3) == O) { No explicit multiplication \nor division remains. 10 Implementation in GCC We have implemented the algorithms for constant di\u00advisors \nin the freely available GCC compiler [21], by extending its machine and language independent in\u00adternal \ncode generation. We also made minor machine dependent modifications to some of the machine de\u00adscriptor, \nor md files to get optimal code. All languages and almost all processors supported by GCC benefit. Our \nchanges are scheduled for inclusion in GCC 2.6. 69 To generate code for division of N bit quantities, \nthe CHOOSE-MULTIPLIER function needs to per\u00adform (2 N) bit arithmetic. This makes that procedure more \ncomplex than it might appear in Figure 6.2. Optimal selection of instructions depending on the bitsize \nof the operation is a tricky problem that we spent quite some time on. For some architectures, it is \nimportant to select a multiplication instruction that has the smallest available precision. On other \narchitec\u00adtures, the multiplication can be performed faster using a sequence of additions, subtractions, \nand shifts. We have not implemented any algorithm for run time invariant divisors, Only a few architectures \n(AMD 29050, Intel x86, Motorola 68k b 88110, and to some extent IBM POWER) have adequate hardware support \nto make such an implementation viable, i.e., an instruction that can be used for integer logarithm computation, \nand a (21 V bit/N bit divide instruction. Even with hardware support, one must be careful that the transformation \nreally improves the code; e.g., a loop might need to be executed many times before the faster loop body \noutweighs the cost of the multiplier computation in the loop header. 11 Results Figure 11.1 has an example \nwith compile time constant divisor that gets drastically faster on all recent proces\u00adsor implementations. \nThe program converts a binary number to a decimal string. It calculates one quotient and one remainder \nper output digit. Table 11.1 shows the generated assembler codes for Alpha, MIPS, POWER, and SPARC. There \nis no ex\u00adplicit division. Although initially computed separately, the quotient and remainder calculations \nhave been combined (by GCC)S common subexpression elimina\u00adtion pass). The unsigned int data type has \n32 bits on all four architectures, but Alpha is a 64 bit architecture. The Alpha code is longer than \nthe others because it multi\u00adplies (234 + 1)/5 by z using 4*[(216+ 1)*(28 +1)* (4*[4*(4*0 z)+x] z)] +Z \ninstead of the slower, 23 cycle, xnulq. This illustrates that the multiplications needed by these algorithms \ncan sometimes be computed quickly using a sequence of shifts, adds, and subtracts [5], since multipliers \nfor small constant divisors have regular binary patterns. Table 11.2 compares the timing on some processor \nimplement ations for the radix conversion routine, with and without the division elimination algorithms. \nThe number converted was a full 32 bit number, sufficiently large to hide procedure calling overhead \nfrom the mea\u00adsurements. We also ran the integer benchmarks from SPEC 92. The improvement was negligible \nfor most of the pro\u00adgrams; the best improvement seen was only about 3%. Some benchmarks that involve \nhashing show improve\u00adments up to about 3070. We anticipate significant im\u00adprovements on some number theoretic \ncodes.  References [1]Robert Alverson. Integer division using recipro\u00adcals. In Peter Kornerup and David \nW. Matula, editors, Proceedings 10th Symposium on Computer Arithmetic, pages 186 190, Grenoble, France, \nJune 1991. [2] Ehud Artzy, James A. Hinds, and Harry J, Saal. A fast division technique for constant \ndivisors. CACM, 19(2):98-101, February 1976. [3] Henry G. Baker. Computing A*B (mod N) ef\u00adficiently in \nANSI C. ACM SIGPLAN Notices, 27(1):95-98, January 1992. [4] 11.B. Bakoglu, G .F. Grohoski, and R. K. \nMontoye. The IBM RISC system/6000 processor: Hardware overview. IBM Journal of Research and Develop\u00adment, \n34(1):12 22, January 1990. [5] Robert Bernstein. Multiplication by integer con\u00adstants. Software -Practice \nand Experience, 16(7):641-652, July 1986. [6] Raymond T. Boute. The Euclidean definition of the functions \ndiv and mod, ACM Transactions on Programming Languages and Systems, 14(2):127\u00ad144, April 1992. [7] A.P. \nChang. A note on the modulo operation. SIGPLAN Notates, 20(4):19-23, April 1985. [8] Digital Equipment \nCorporation. DECchip 21064 -AA Microprocessor, Hardware Reference Manual, 1st edition, October 1992. \n[9] Intel Corporation, Santa Clara, CA. 386 DX Microprocessor Programmer s Reference Manual, 1990. [10] \nIntel Corporation, Santa Clara, CA, Inte/486 Microprocessor Family Programmer s Reference Manual, 1992. \n[11] David H. Jacobsohn. A combinatorics division al\u00adgorithm for fixed-integer divisors. IEEE Trans. \nComp. j C-22( 6):608-61O, June 1973. [12] Gerry Kane. MIPS RISC Architecture. Prentice Hall, Englewood \nCliffs, NJ, 1989. 70 #define BUFSIZE 50 char *decimal (unsigned int x) { static char buf[FIUFSIZE]; \nchar *bp = buf + BUFSIZE -1; *bp = (); do { *--bp = o) bx~ 10; x /= 10; } while (x != O); return bp; \nI* Return pointer to first digit *I Figure 11.1: Radix conversion code Alpha MIPS  POWER SPARC lda $2 \n,buf la $5,buf+49 1 10,LC. .O(2) sethi Xhi(buf+49),~g2 1 ldq-.u $1,49($ 2) sb $0,0($5) cau II,O,OXCCCC \nor Xg2,%lo(buf+49) ,~ol addq $2,49,$0 li $6,0xcccc0000 oril ll,ll,Oxcccd stb ~go,~~oll mskbl $1,$0,$1 \nori $6,$6,0xcccd cal O,O(Oj sethi %hi(Oxcccccccd),~g2 stq.u $1,49($2) .1: multu $4,$6 stb 0,0(10) or \nXg2,0xcd,202 ,1: zapnot $16,15,$3 rnfhi $3 ,1: mul 9,3,11 .1: add %01,-1,%01 s4subq $3,$3,$2 subu $5,$5,1 \nsrai 0,3,31 Umul %oo,%02,%go s4addq $2,$3,$2 srl $3,$3,3 and 0,0,11 rd xy , %g3 s4subq $2,$3,$2 511 $2,$3,2 \na 9,9,0 srl xg3,3,2g3 Sll $2,8,$1 addu $2,$2,$3 a 9,9,3 511 xg3,2,%g 2 subq $0,1,$0 Sll $2,$2,1 sri 9,9,3 \nadd %g2,xg3,%g2 addq $2,$1,$2 SUbU $2,$4,$2 muli 0,9,10 Sll xg2,1,xg2 Sll $2,16,$1 addu $2,$2,48 Sf 0,0,3 \nsub ~00,%g2,~g2 ldq.u $4,0($0) move $4,$3 ai. 3,9,0 add Xg2,48,Zg2 addq $2,$1,$2 bne $4,$0,LI ai 0,0,48 \norcc Xg3,Xg0,100 s4addq $2,$3,$2 sb $2,0($5) stbu 0,-1(10) bne L1 Srl $2,35,$2 j $31 bc 4,2,L1 stb xg2,~401] \nmslrbl $4,$0,$4 move $2,$5 ai 3,10,0 retl s4addl $2,$2,$1 br mov %01,%00 addq $1,$1,$1 subl $16,$1,$1 \naddl $1,48,$1 insbl $1,$0,$1 bis $2,$2,$16 bis $1,$4,$1 Stq-u $1,0($0) bne $16,L1 ret $31,($26),1 Table \n11.1: Code generated by our GCCfor radix conversion 71 Time with Time with Speedup Architecture/Implementation \nMHz division division ratio performed eliminated Motorola MC68020 [18, pp. 9-22] 25 39 33 1.2 Motorola \nMC68040 25 19 14 1,4 SPARC Viking [20] 40 6.4 3.2 2.0 HP PA 7000 99 9.7 2.1 4.6 MIPS R3000 [121 40 12 \n7.3 1.7 MIPS R4000 ~17j 100 8.3 2.4 3.4 POWER/RIOS I [4, 22] 50 5.0 3.5 1.4 DEC Alpha 21064 [8] 133 22 \n1.8 12* xThis time difference is artificial. The Alpha architecture has no integer divide instruct ion, \nand the D EC library functions for division are slow. Table 11.2: Timing (microseconds) for radix conversion \nwith and without division elimination [13] Donald E. Knuth. An empirical study of FOR-TRAN programs. \nTechnical Report 03-186, Com\u00adputer Science Department, Stanford University, 1970. Stanford artificial \nintelligence project memo AIM-137. [14] Donald E. Knuth. Semmumerical Algorithms, vol\u00adume 2 of The Art \nof Computer Programming. Addison-Wesley, Reading, MA, 2nd edition, 1981. [15] Shuo-Yen Robert Li. Fast \nconstant division rou\u00adtines. IEEE Trans. Comp., C-34(9):866-869, September 1985. [16] Daniel J. Magenheimer, \nLiz Peters, Karl Pettis, and Dan Zuras. Integer multiplication and division on the HP Precision Architecture. \nIn Proceedings Second International Conference on Architectural Support for Programming Languages and \nOperat\u00ading Systems (ASPL OS II). ACM, 1987. Published as SIGPLAN Notices, Volume 22, No. 10, Octo\u00adber, \n1987. [17] MIPS Computer Systems, Inc, Sunnyvale, CA. MIPS R4000 Microprocessor User s Manual, 1991. \n[18] Motorola, Inc. MC 68020 32-Bit Microprocessor User s Manual, 2nd edition, 1985. [19] Motorola, Inc. \nPowerPC 601 RISC Microproces\u00adsor User s Manual, 1993. [20] SPARC International, Inc., Menlo Park, CA. \nThe SPARC Architecture Manual, Version 8, 1992. [21] Richard M. Stallman. Using and Porting GCC. The \nFree Software Foundation, Cambridge, MA, 1993. [22] Henry Warren. Predtcttng Execution Time on the IBM \nRISC System/6000. IBM, 1991. Preliminary Version. 72   \n\t\t\t", "proc_id": "178243", "abstract": "<p>Integer division remains expensive on today's processors as thecost of integer multiplication declines. We present code sequences fordivision by arbitrary nonzero integer constants and run-time invariantsusing integer multiplication. The algorithms assume a two's complementarchitecture. Most also require that the upper half of an integerproduct be quickly accessible. We treat unsigned division, signeddivision where the quotient rounds towards zero, signed division wherethe quotient rounds towards <inline-equation><f>-&#8734;</f><?Pub Caret></inline-equation>, and division where the result is known<?Pub Fmt italic>a priori<?Pub Fmt /italic> to be exact. We give someimplementation results using the C compiler GCC.</p>", "authors": [{"name": "Torbj&#246;rn Granlund", "author_profile_id": "81100039099", "affiliation": "", "person_id": "P284519", "email_address": "", "orcid_id": ""}, {"name": "Peter L. Montgomery", "author_profile_id": "81100528007", "affiliation": "", "person_id": "PP31087348", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/178243.178249", "year": "1994", "article_id": "178249", "conference": "PLDI", "title": "Division by invariant integers using multiplication", "url": "http://dl.acm.org/citation.cfm?id=178249"}