{"article_publication_date": "10-17-2010", "fulltext": "\n Component Adaptation and Assembly Using Interface Relations Stephen Kell Computer Laboratory, University \nof Cambridge 15 JJ Thomson Avenue Cambridge CB3 0FD United Kingdom ................. ......... Abstract \nSoftware s expense owes partly to frequent reimplementa\u00adtion of similar functionality and partly to maintenance \nof patches, ports or components targeting evolving interfaces. More modular non-invasive approaches are \nunpopular be\u00adcause they entail laborious wrapper code. We propose Cake, a rule-based language describing \ncompositions using inter\u00adface relations. To evaluate it, we compare several existing wrappers with reimplemented \nCake versions, .nding the lat\u00adter to be simpler and better modularised. Categories and Subject Descriptors \nD.2.3 [Coding Tools and Techniques]; D.2.12 [Interoperability] General Terms Languages 1. Introduction \nToday s software development ecosystem is vast in scale and decentralised in nature. Inevitably, most \ncode is written in isolation from most other code with which it could use\u00adfully be combined. Most software \ngrows upwards in stacks or silos, each piece written for some speci.c infrastruc\u00adture: libraries for \nsome programming language, tools for some IDE or editor, plugins for some web browser or me\u00addia player, \napplications for some operating system or desk\u00adtop suite or hardware platform. Put differently, interface \nmis\u00admatch abounds in software. Since there are always different ways of expressing the same meaning, \ncomponents that are logically compatible nevertheless evolve with mismatched interfaces. Current software \npractices fail to exploit the com\u00adpositional potential within existing code; they encourage from-scratch \ndevelopment and coupled code. Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright &#38;#169; \n2010 ACM 978-1-4503-0203-6/10/10. . . $10.00 The adapter pattern [Gamma et al. 1995] is a noble fail\u00adure. \nIt provides a modular, compositional approach to mis\u00admatch, but despite these potential bene.ts, programmers \nfaced with mismatch usually choose to port source code by invasive editing. This is unfortunate, because \nmuch expense in software stems from many versions of similar things.Mul\u00adtiplied code means multiplied \ncomplexity and multiplied costs. Invasive porting also risks introducing bugs to work\u00ading code. To avoid \nthese costs, we must make non-invasive adaptation a more effective option for the programmer. Adapters \ncan be described an order of magnitude more simply than conventional tools allow. Currently, writing \nadapters is repetitive, error-prone and inconvenient. We in\u00adtroduce a tool for concise, high-level and \nconvenient de\u00adscription of adapters, based on our special purpose language Cake. Cake is rule-based: \nthe Cake programmer declara\u00adtively speci.es how components interfaces relate. Cake advances on prior \nwork by supporting context-dependent, many-to-many relations between interface elements, and in its automatic \ntreatment of complex object structures. By tar\u00adgetting binaries, Cake is convenient, and eliminates com\u00adplexity \nassociated with multiple build environments. The contributions of this paper are as follows. A language \nof correspondences Cake abstracts black-box adaptations using rules called correspondences.These both \nunify and extend the expressiveness found in prior work on black-box adaptation. In particular, they \nsupport complex relations between interfaces, of the kind found in real adaptation tasks. Object structures \nBy applying correspondences while also following pointers, Cake adapts complex object struc\u00adtures at \nno extra effort. Our implementation, which tar\u00adgets native binaries, makes use of novel well-behavedness \ncriteria in order to correctly discover object structures in real code at run time. Bene.ts We show, \nby using Cake to reimplement some pre\u00adexisting wrappers, how Cake results in simpler, better\u00admodularised \ncode. We begin with Cake s motivation and design goals.  2. Motivation Currently, non-invasive adaptation \nis usually eschewed in favour of invasive editing or from-scratch redevelopment. To understand why, consider \nthat adapters currently consist of wrapper functions like the two in Fig. 1. These form part of an adapter \n(covered fully in \u00a76.1) between a pair of .lesystem interfaces, ....(here exported) and ....(here consumed). \n(The ....call repositions an open .le cursor, while ......deletes a directory entry.) We have added comments, \nbut the details are not important. Instead, notice several problems with this style of code. ......................................... \n........................................ ...................... ................ ...... ................................... \n........ ............. ............................................ ........ ............... ....................................... \n......... . ........................................... .................................. .................... \n..................... ...... ............ ............... ........ ............. ............................... \n.......... ................ ..................................... ....................................... \n........ ............................ .......... ............................ ........... .............. \n......... . Figure 1. Example .lesystem wrapper code Repetition A large volume of similar code is required \nfor a conceptually simple task. Poor modularity The code is not trivially repetitive. Each wrapper applies \na different subset of rules, e.g. for treat\u00adment of arguments. Consider ..above: one case re\u00adquires a \nbumped reference count and has different un\u00adlocking semantics from the other. The programmer must juggle \nthese rules correctly amid the sea of similarity. Inconvenience Among other headaches, to compile this \ncode the programmer must construct a hybrid build envi\u00adronment supporting compilation against both interfaces. \nComplexity This shows a very simple case, where functions correspond one-to-one. In others, complexity \nquickly es\u00adcalates. ....................... ................................... -. .................................. \n................................................... ..-. ............................ ..................... \n..................-. ........................ ...................-........................ ................-.............................. \n................................ .................-........................ ...............................-. \n.......... ...............- ............................. .........................-. .............. \n.............- ............................. Figure 2. Cake rules generating equivalent wrappers In \nshort, wrappers are an unnecessarily complex approach to adaptation. Cake is a language designed to .x \nthis prob\u00adlem. Figure 2 shows some Cake rules suf.cient to generate the wrappers in Figure 1. Again the \ndetails are not important, but notice several advantages. Separation of concerns The Cake programmer \nwrites rules which we call correspondences. Each rule localises a particular piece of domain-speci.c \nknowledge about the adaptation task. The compiler is responsible for compos\u00ading rules into wrappers. \nIn particular, notice here that rules concerning functions and rules concerning values are kept separate. \nSuch rules form the basic Cake language (\u00a73). Expressiveness Cake rules advance on prior work by sup\u00adporting \ncontext-sensitive and many-to-many relations be\u00adtween interface elements. For example, a single function \nmay map to one of several calls on the opposing interface, depending on what calls have come before, \nor to a sequence of calls. Similarly, sets of values or objects occurring to\u00adgether may be treated as \na group, and corresponded by a single rule. These and other advanced features greatly ex\u00adtend the power \nof the Cake language (\u00a74). Object structures This example passes only isolated ob\u00adjects across the interface. \nHowever, Cake can handle the exchange of arbitrary object graphs across mismatched in\u00adterfaces. This \ncan eliminate considerable code: consider a wrapper walking a linked list to convert each element in \nturn. The programmer need only specify how separate classes of object relate; the Cake runtime automatically \nexplores the graph, applying rules to the objects it .nds (\u00a75). Simpler, shorter code The rules above \nmay appear to be only a little shorter than the wrapper code. However, the en\u00adtire ...adapter contains \nnot two but 28 wrapper functions. Each rule above contributes to many of these wrappers, and often many \nwrappers can be generated from a single rule. The result is shorter, more readable and more maintainable \ncode, as we show in three case studies (\u00a76).  Figure 3. Example comparable usage patterns for libraries \n........and ..... 3. The design of Cake We use a relatively ambitious running example to illustrate \nthe design of Cake as a tool and a language. Can we take a client and library implementing hitherto unrelated \ninter\u00adfaces and, by writing a succinct description of their corre\u00adspondences, glue the unmodi.ed binaries \ntogether? Consider a simple program which uses a library to decode some video. There are many possible \nchoices of library; we consider a client written against the ........library1. Sup\u00adpose we wish to link \nthis instead against the .....family of libraries2. This has many plausible motivations: perhaps to reduce \nthe dependency footprint of a larger system, per\u00adhaps to exploit the larger feature-set of .....(which \ncan decode video in other encodings than MPEG), or perhaps for differences in reliability or performance. \nFigure 3 shows equivalent usage patterns of the two interfaces. Note that the correspondence between \nthe two is nontrivial: in most cases there is no one-to-one correspondence between either the ob\u00adjects \nor the function calls used by the two interfaces. 1 ............................... 2 ................. \n 3.1 Insights The primary design goal of Cake is to abstract composition tasks in a modular way. In the \nspirit of Parnas s information hiding [Parnas 1972], one useful approach is to restrict the programmer \ns attention to some notion of interface,just as Fig. 3 describes the two components only in terms of \nthe function calls and data structures that they exchange. We re\u00adfer to this as black-box adaptation \n(cf. white-box approaches, which may reference arbitrary internals of a component). A convenient formalisation \nof this notion of interface is the trace of a component s interactions, of the sort displayed by tools \nsuch as .....3. Figure 4 shows the .....output for our client s interaction with ............ Abstractly, \na trace is simply a sequence of calls or events, each communicating zero or more values. Cake code consists \nlargely of rules which, abstractly, describe a transducer over this trace that is, an automaton which \nboth recognises and generates. At run time, Cake-generated code feeds each component a trace generated \nfrom those output by the other components. Note that our discussion of traces is purely conceptual; a \nCake 3 ............................... ............ ......... .................... ......... ..................... \n.. ..................................................... ....................... .............. ........................ \n....................................................... ....................... Figure 4. Example trace \nof a ........client programmer never needs to generate or manipulate traces in any way.  3.2 Requirements \nWhat kinds of rules are required for realistic adaptation tasks like our video decoding example? From \nFig. 3 it is clear that simple remappings of function signatures and object .elds are not suf.cient, \nfor several reasons. Correspondences between events are not one-to-one. In .....there is usually more \nthan one call for each ..... ....call, so we require a way of mapping one call to many. Sometimes this \nrelationship is reversed, so we need to recognise a sequence of many calls and map it back to a singleton. \n Arguments to one call may not be suf.cient to perform the corresponding call. For example, ................ \nmaps to ..............., but the latter needs a refer\u00adence to the input .le rather than the decoder, \nwhich in\u00adconveniently is the only argument to .................  Components differ in the shapes of \ntheir data structures. Single .elds or single objects may correspond to many .elds or many objects. Moreover, \nobjects may be passed indirectly, perhaps over many levels of indirection from the arguments themselves. \n These imply that our transducer needs to be stateful,and that it must be able to navigate object structures. \nAt run time, Cake maintains two kinds of state: pattern state, which en\u00adables matching of calls in a \ncontext-sensitive fashion; and as\u00adsociation state, which tracks sets of semantically related ob\u00adjects \ncollaborating across sequences of calls. The program\u00admer does not manipulate this state directly, but \nembodies it in abstract rules. Before describing these rules, we provide a summary of some additional \ndesign goals and a high-level view of Cake.  3.3 Additional goals Our design accommodates several other \ngoals which make Cake a more effective programming tool. Target binaries Since traces are agnostic to \nsource code and source language, Cake affords the convenience of work\u00ading on binaries the form in which \nsoftware is usually de\u00adployed. To apply Cake to some installed software, it is not necessary to reproduce \nthe build environment for that soft\u00adware, or recompile the software, nor even to possess source code \nfor target components. Applicability We want Cake to apply to a large volume of existing components. \nWe chose (somewhat arbitrarily) to focus on components produced in the open-source commu\u00adnity. These \nare often written in C, C++ and other unsafe lan\u00adguages with explicit storage management. This entails \ncer\u00adtain memory-aware adaptation features (\u00a74.6), and careful treatment of pointers (\u00a75). However, the \ncore problem which Cake addresses, namely interface mismatch among compo\u00adnents, is speci.c neither to \nbinaries nor to unsafe languages. Non-goals Our design sacri.ces focus on other potential goals. We will \ntouch on reasons why ef.cient implementa\u00adtion is possible, and why formal reasoning about Cake code is \nfeasible, but these are not explicit goals. Also, despite tar\u00adgetting modularity, note that Cake is not \na module system per se: it does not de.ne any novel abstraction of components themselves. Rather, it \nabstracts differences among compo\u00adnent interfaces; its notions of component and interface are conventional. \nSafety At .rst glance it may appear risky to perform pro\u00adgramming tasks at the binary level. We .rmly \nbelieve that it need not be less safe than any existing source-level ap\u00adproach. For reasons of simplicity, \nCake has not initially been designed to provide guarantees of safety. However, bina\u00adries admit exactly \nthe same sorts of type-checking and local reasoning as source-level representations, given appropriate \nmetadata. Well-abstractedness We also assume that our task is well abstracted , meaning that there is \nsuf.cient information in traces generated (and traces accepted) to express the required composition. \nThis is precisely the necessary condition for a black-box approach to suf.ce. We believe white-box tech\u00adniques \n(including aspect-oriented programming, instrumen\u00adtation systems and so on) to be an essential complement \nto black-box ones, especially for turning non-well abstracted tasks into well-abstracted ones, which \nwe consider for fu\u00adture work (see \u00a77). Computational power Cake is not Turing-powerful. We believe that \nfuture work can semi-automate the generation of Cake code (discussed brie.y in \u00a77). Cake is emphatically \nnot a language for implementing new functionality, so it can afford to sacri.ce some computational power \nfor tractability. Support heterogeneity Software is developed in a multi\u00adtude of languages and coded \nin a multitude of styles. We want Cake to embrace this diversity by enabling low-cost mix-and-match of \nheterogeneous components. Since much code can be compiled down to a single binary representa\u00adtion, Cake \nis well-placed for this. So far our examples have centred on C-language codebase; many other procedural \nand object-oriented languages also .t Cake s model and could be supported with little effort (primarily \nback-end support for  Figure 5. High-level view of an application of Cake input components Cake source \n 1 2 3 4 5 6 7 8 9 Figure 6. Cake s tool .ow interposing on virtual function dispatch). Supporting user\u00adde.ned \nstyles of object code is planned future work.  3.4 High-level view Fig. 5 gives a high-level view of \nthe intended result of our video decoding adaptation task: the original components bridged by some Cake-generated \nadaptation logic. (While our examples show only two components, Cake applies equally well to tasks involving \nany number.) Fig. 6 illustrates Cake s place in the toolchain. The Cake compiler inputs a collection \nof components (in the form of binaries) and some Cake code, and outputs Cake-generated source code, build \nrules for assembling the output binary (out of this code and the original binaries), and possibly some \nextended and relinked versions of the original binaries. Fig. 7 shows the outline of a Cake source .le. \nThere are two main top-level constructs: ......and ....... The .rst of these identi.es an existing component \ntypically a relocat\u00adable object .le and optionally adds descriptive information to supplement the debugging \ninformation already present. Cake s interface model is based on DWARF 3 [Fre 2005] and its notions of \ntypes and subprograms . The availabil\u00adity of debugging information is a huge convenience which we will \nassume for the purposes of this paper, although Cake does not demand it all such information can be supplied \nwithin the ......block. Certain annotations may also be added (\u00a74.3). Cake s other essential top-level \nconstruct is .......This describes a new component to be created by assembly and adaptation of .....ing \nones. Derived components are ex\u00ad ............................................ .... ............................................ \n.... .............................................. . ..... ... . .......................... . .. Figure \n7. Skeleton of a simple Cake program ....................-. .................. ............ ............ \n.................. ............-. .............. ................... .- ................ Figure 8. Some \nsimple Cake correspondence rules pressed in a simple algebra of built-in functions and oper\u00adators. The \nmost important of these is ...., which applies to a list of component names. All the correspondence rules \nwe have seen would appear inside a block opened by a ....key\u00adword, and these account for the vast bulk \nof any typical Cake program. Since correspondence rules always relate a pair of interfaces, rules appear \nin pairwise blocks, of which there maybe manyfor a given ....application (if linking more than two components). \n 3.5 Syntactic conventions Arrows in Cake signify correspondence rules, and point in the direction of \ndata .ow. In Cake source code, correspon\u00addence arrows are rendered using angle brackets and double\u00adhyphens. \nFor example, the bidirectional arrow is .....In this paper we typeset them directly as long arrows. Aside \nfrom this, Cake s syntax is familiar from other languages, and is mostly C-like. For ease of recognition \nwe typeset all arrow operators specially: ..denotes indirect member se\u00adlection as in C, and is typeset \n..; meanwhile ..denotes functional abstraction as in ML, typeset .; its converse .. (typeset .) binds \nnames to function return values (\u00a74.1). 3.6 Simple correspondences Corresponding events Lines 1 2 in \nFigure 8 de.ne an event correspondence, stating that a call to .......with second argument ....should \nbe translated to a call to ....................4 The ...keyword signi.es that the .rst argument is an \noutput parameter into which the logi\u00adcal return value of the call will be written; Cake automat\u00adically \nmaps this to the return value expected by ....... handling of this is discussed in detail later (\u00a74.6). \nFinally, the ...quali.er matches only the .rst .......call in the client s execution (since it may want \nto open other .les not for video decoding). Corresponding values Line 4 says that a ............ ....object \n(on the .....side) can be created from a .... object (on the ........side) and vice-versa. In this in\u00adstance, \nno further rules are speci.ed and no .elds are propa\u00adgated between the two. This is suf.cient since the \n....ob\u00adject is completely opaque to the client. If the objects were not opaque, we could add rules inside \nthe braces to de\u00adscribe how their .elds relate. In combination with the pre\u00advious rule, Cake can now \ngenerate a wrapper for ....... which calls ...................with appropriate param\u00adeters and substitutes \nthe ...............object with a ....object on return. Compound statements and return Lines 6 9 describe \nini\u00adtialization of the library state. The pair of .....initializa\u00adtion calls is given as a compound statement \nin Cake s stub language , a simple loop-and recursion-free imperative lan\u00adguage. (Although syntactically \nC-like, this language is com\u00adpletely independent of the components source languages, since Cake deals \nonly with binaries.) A special post.x arrow syntax is provided to describe handling of a return event, \nhere saying that a new object of class ..........should be allocated on return to ........... Again, \nthis object is treated opaquely, so we do not need to describe its .elds.  3.7 Remarks on simple Cake \nusage We may remark on the usage seen so far. Dual scoping As be.ts a language describing relations, \nCake has dual scoping: different sides of an arrow denote different components, in whose respective scopes \nnames are resolved. The left-hand side of our rules always represent the ........client, and the right-hand \nside represent al\u00adways the .....libraries. This means that arrows may point left-to-right or right-to-left, \naccording to which data .ow the rule describes. Event correspondences are described using pattern-matching: \nthe arrow-tail side (the source ) repre\u00adsents a pattern that the event matches, perhaps supplying names; \nthese are then bound on the other side (the sink side) to the elements they matched in the call. We can \nbind events to stubs in cases, as in lines 6 7 above, where the function correspondence is not one-to-one. \nRule selection Note that these rules only apply to inter\u00adactions between our speci.c pair of components; \nthey say 4 Readers familiar with the .....API may notice that we have used Cake s argument defaulting \nsupport to reduce the number of arguments in the second call, for clarity of exposition. nothing about \ne.g. how to treat ....objects passed across other interfaces. In this example the Cake compiler can au\u00adtomatically \ndeduce what value correspondences need to be applied, whereas in a few cases it is necessary to manually \ninstantiate a value correspondence. Programmer knowledge Like any programming tool, Cake depends on the \nprogrammer to understand the semantics of the domain. In writing the above rule, the programmer ex\u00adploits \ntwo facts about the client s usage of the ........ interface: that it is accompanied by C library calls \nsuch as .......to do the .le I/O, and that the .rst .......call opens the video .le signi.ed by the ...suf.x \nto the pat\u00adtern.5 Similarly, the programmer is responsible for writing rules which, in combination, access \nthe .....interface correctly, e.g. by inserting the .................call. 3.8 Correspondences for free: \nname matching Cake automatically draws implicit correspondences between compatible like-named elements \nin linked interfaces. For ex\u00adample, if one module requires function .....and another provides it, an \nevent correspondence is automatically drawn between them. This reproduces the behaviour of a conven\u00adtional \nlinker. Since our current example is an example of unanticipated composition, few names match, so the \ngains from name-matching are modest. However, name-matching is very helpful when applying Cake to interface \nevolution, where many interface elements can be matched without pro\u00adgrammer intervention. Cake extends \nname-matching to structured values. If two interfaces both de.ne a class ..., then these will be corre\u00adsponded; \nif one ...contains .elds ........., .......and ........, and the other ......., ........and ......., \nCake will correspond .......and ........, and leave the others uncorresponded. This means that minor \nmismatches in size or layout of structures are automatically adapted around. For example, the implementation \nof the C library call .......often needs to adapt between kernel-and user\u00adformat ....structures, owing \nonly to layout differences and extra .elds. Cake could perform this adaptation automati\u00adcally. In the \nrare case where a given name-matching is not wanted, it can be overridden by mapping the name to an al\u00adternative \nelement (if one exists) or ..... Identi.ers often contain meaningful structure. A com\u00adplementary name-matching \nfeature is the .......construct, where a single rule can map together sets of similar event names using \nregular expression matching. The following .ctitious example expresses three similar event correspon\u00addences \nin one rule. ..................................... -. .......................... 5 We brie.y describe \na cleaner approach to this class of rule, based on a more dynamic notion of components de.ned by generalised \nslices of traces, as future work (\u00a77). Use of names is sometimes latent rather than explicit. For example, \ninteger .elds may implicitly model enumerations or sets; function arguments may also be best understood \nby their name rather than positionally. Cake supports a ..... annotation for applying a vocabulary of \nnames (e.g. perhaps from a separate enumeration type, or perhaps given explic\u00aditly) to functions or integer \n.elds, in order to induce further name-matching.  4. Advanced features of Cake We saw in Section 3.2 \nthat simple correspondences are in\u00adsuf.cient for realistic tasks like our video decoding exam\u00adple. This \nsection discusses the features of Cake which make it suf.ciently powerful to tackle these real-world \nuse-cases. 4.1 Corresponding sequences of events: event context Often when performing an adaptation, \nconsidering each call independently is not enough: the correct action depends on what calls have come \nbefore. To this end, Cake event pat\u00adterns may be pre.xed by a context predicate: the rule only applies \nwhere certain preceding calls have occurred. Auto\u00admatic management of the state necessary to match such \npat\u00adterns is another way in which Cake saves programmer ef\u00adfort. In our example, we use this facility \nwhen the client re\u00adtrieves an object storing metadata about the video .le: we tell Cake that a call to \n................follows earlier calls to .......and ............, whose arguments and return values are \nsigni.cant. ......................................... ........................... ....................... \n..................-.................. Since it may be necessary to refer to values passed or returned \nduring the preceding calls, context predicates can bind names just like event patterns can. The ...keyword \nal\u00adlows further names to be bound to return values and useful auxiliary values. This does not denote \nassignment (and the same name may not be re-bound within a rule). In patterns like the above which bind \nnames to return values of contex\u00adtual calls, we can use the shorter ........ syntax instead of ...(see \nthe Appendix for examples). Resolving ambiguity There is a potential ambiguity in context matching: which \npreceding call is relevant? When a call to ................occurs, the ........client has not yet associated \nits decoder with an input stream. How\u00adever, in .....the corresponding .................... call requires \nan input stream as an argument. Somehow, we must match the incoming call with the relevant preced\u00ading \n.......call. What if there have been many preceding .......calls? Cake assumes that related calls occur \nclose together: it matches the nearest preceding .......(with appropriate arguments). This is expressed \nusing the ellip\u00adsis (...) to extend our pattern over unspeci.ed intervening calls. The ellipsis functions \nmuch like .. within a regular expression, matching any intervening character sequence, but ellipsis matches \nthe shortest such sequence rather than the longest. If we had left out the ellipsis, this would match \nonly if the two calls occurred in direct succession (among all calls across this particular interface). \n 4.2 Generating data-dependent call sequences: stubs Cake s stub language offers some special features \nfor han\u00addling complex data-dependent sequences of calls. These are illustrated by the right-hand side \nof the the ................ rule begun in the previous section. ...............-. . ....................................... \n..................................... .................................... .... .......................... \n ................................... ..................................... .......................... \n................ ......................... .......... Error discovery Manually determining the success \nor fail\u00adure from every function call can get very tedious. Every ex\u00adpression in the Cake stub language \nhas a success or fail\u00adure outcome, logically separate from any result value it may yield if successful. \nCake determines the success of a function call in a style-dependent way (as described in \u00a74.3). The default \nstyle assumes that functions returning signed in\u00adtegers are successful iff they return zero, and that \npointer\u00adreturning functions are successful iff they return non-null. This style is typical of a majority \nof C APIs. Calls that re\u00adturn neither a signed integer nor a pointer are treated as al\u00adways succeeding. \nError handling Stubs are generally not complex enough to require try catch exception handling. Instead, \nexpressions can be joined with short-circuit boolean connectives ..and .., in an idiom similar to that \nfound in Unix shell program\u00adming. Unlike the shell, success exists independently of the result value, \nso the connectives are distinct from the boolean operators ..and ... In the few cases where the style \ndoes not detect error status correctly, the programmer can explic\u00aditly describe success conditions using \nthe .....pseudo\u00advariable and constants ....(which yields no value but al\u00adways succeeds) and ....(which \nalways fails). Binding Just as ...binds names to values in context pat\u00adterns, it can bind names to values \nin stubs. These enable data\u00addependencies between calls. The ...keyword also binds a name, and is used \nwhen calling functions have output pa\u00adrameters (\u00a74.6). Associations Sometimes bound names are not enough; \na stub must navigate a data structure to .nd relevant arguments to a call. The dot (.) and short arrow \n(.., typeset ..)have the C-like access member semantics in Cake. Analogously, the ...syntax is overloaded \nto denote access associated : it enables formation and dereferencing of associations be\u00adtween objects \nor values. Associations are the mechanism for many-to-many value correspondences in Cake, and are dis\u00adcussedinSection4.4. \nLambdas and algorithms Traversing data structures algo\u00adrithmically is beyond the scope of Cake. However, \nsimple algorithms are often indispensable when performing adap\u00adtation. Cake makes a selection of algorithms \navailable in the stub language, here ...denoting linear search. Algo\u00adrithms are de.ned outside of Cake \nin an implementation\u00adspeci.c way. Currently, we exploit the fact that Cake s back\u00adend generates C++ code: \nmost of the C++ standard library s algorithms may be applied. Cake automatically infers usable iterator \nde.nitions using its style-dependent notion of lists and arrays (\u00a74.7). Since algorithms sometimes take \nfunc\u00adtions or predicates as arguments, simple functions may be de.ned as lambdas in the stub language. \nThe expressiveness of this is deliberately constrained: lambdas may not contain other lambdas, and cannot \nrefer to themselves, so cannot in\u00adtroduce recursion in the stub language.  4.3 Practicalities We have \nnow seen the basics of the Cake language. In this interlude we discuss several practical issues arising \nin the use of Cake. Target representation Our chosen binary representation is relocatable object code. \nThis means compiled native code, before linking, in any modern containing format such as ELF. Most of \nour work has applied Cake only to static linking, but its approach applies equally to dynamic linking. \nSource languages Cake can compose components deriv\u00ading from several source languages. In this paper we \nhave targetted only components written in C, since our current implementation lacks understanding of \nsome incidental fea\u00adtures found in binaries originating in other languages (such as name-mangling, and \nvarious DWARF constructs). Adding such support in most cases is straightforward and is ongoing work. \n(At run time, some cooperation with garbage collec\u00adtors is required: see \u00a75.) Obtaining debugging information \nCompilers usually re\u00adquire a command-line .ag to enable generation of debugging information.6 Most software \nbuilds released to end users 6 An extended set of .ags may be needed to generate the most detailed debugging \ninformation available. With .we have been using ...................................... .................................. \nWe also disable inlining, since premature inlining can potentially interfere with Cake. Interprocedural \nop\u00adtimisation is best done at link time, when a complete call graph is available. ............. ....................................... \n............. ................. ....................................... ............ .... ........................................... \n......................... Figure 9. Interface description syntax do not contain debugging information, \nbut distributors often supply it as an optional extra.7 We encourage this practice, since there is considerable \nvalue in providing debugging in\u00adformation to users (e.g. enabling higher-quality bug reports). Interface \ndescription As described earlier (\u00a73.4), Cake al\u00adlows programmers to supplement or replace available \ndebug\u00adging information within ......blocks. For this, we devised a simple textual syntax for the relevant \nsubset of DWARF, of which Fig. 9 shows a small fragment. Annotations The same syntax extends DWARF by \naccept\u00ading certain annotations. For example, attributes ...or ..... can be made to function arguments, \naffecting how Cake ap\u00adplies value correspondences to values .owing into and out of a function call (\u00a74.6). \nSome of these annotations could be useful to debuggers as well as to Cake; we plan to feed these back \ninto the DWARF design process. Comprehension As with any programming tool, we as\u00adsume that the programmer \nunderstands the interfaces he is coding against. In addition to debugging information, the programmer \nmight use various means to gain this under\u00adstanding: API documentation, source code, other code ex\u00adercising \nthe same interfaces, patterns mined from such code [Wasylkowski et al. 2007] or reverse-engineering tools \n[Bal\u00adakrishnan et al. 2005]. The latter is especially relevant when Cake is used to compose binaries \nfor which source code is not available. Although these means each have their short\u00adcomings, we consider \nthese as separable problems; in this work we assume that the combination of these techniques is suf.cient \nto gain the necessary understanding. Styles All components introduced by an ......block are interpreted \naccording to a style. Styles are an abstraction mechanism designed to seamlessly support mixing and matching \nof object code adopting different sets of inter\u00adface conventions, perhaps originating from multiple pack\u00adagings \n(e.g. component systems, application plugins, etc.), language implementations and/or coding styles. Styles \nde\u00adtermine various higher-level interpretations which the Cake compiler applies to object code, including \nerror-handling, treatment of lists, string handling and so on. At present, Cake supports only one style, \nthe default style , which cor\u00adresponds to the conventions typically found in components 7 e.g. in Debian \nand certain other GNU/Linux distributions written in C. However, Cake is designed to accommodate multiple \nuser-de.ned styles in the future. Instantiate Many clients dynamically load back-end com\u00adponents, such \nas plug-ins. To use Cake across these inter\u00adfaces requires a small extra feature. Since the client does \nnot call the back-end directly, but through an indirect dispatch table, we provide an ...........primitive \nused alongside ....in ......expressions. This constructs an instance of a given data structure usually \na dispatch table and creates a new symbol for each element in the structure. This lifts ta\u00adble entries \nto .rst-class symbolic function names which can be used like any other in a ....block. Conveniences The \n......construct is similar to ......,but allows a component to be supplied not by reference to an existing \n.le, but by inclusion of a snippet of foreign source code embedded directly in a Cake source .le. These \nsnippets are lexed but not parsed by Cake, so any language with compatible lexical structure (up to balanced \nopening and closing braces) may be used; they are de-lexed and output as source .les alongside Cake s \nother output, and compiled at the same time as Cake-generated code (\u00a75.1).  4.4 Many-to-many value correspondences \nIn our running example of ........and .....,the struc\u00adtures maintained during decoding by the two libraries \ncon\u00adtain mostly the same information, but split differently among various objects. In general, while \nobjects or values often do not correspond one-to-one among different interfaces, we can often say that \na group of objects corresponds to another group. Many-to-many value correspondences describe how to create \nand update values in one group from (multiple) values in the other. Fig. 10 illustrates this and some \nother advanced features of value correspondences. Associations Each many-to-many value correspondence \ncreates associations at run time. Each instantiated associa\u00adtion is a tuple binding together several \nobjects. Bindings are formed in stubs by applying the ...keyword to in combi\u00adnation with the access associated \nconnective, written .... These tuples constitute a dynamic relation maintained at run time, analogously \nwith join tables in a relational database. A tuple persists as long as any bound object does. Initialization \nversus update Value correspondences may distinguish initialization from update, as seen in the .rst rule \nabove. When an object .ows across an interface for the .rst time, Cake may need to instantiate one or \nmore corresponding objects (co-objects). Initialization rules use an arrow suf.xed with a question mark. \nWhen initializing the right-hand side above, .will point to a new ....... object. Rules without the question \nmark are update rules. Above, no update rule is needed because the client never updates any state corresponding \nto ....... s .elds. Al\u00adternatively, sometimes a co-object s .elds have no analo\u00adgous .elds in the original \nobject. Cake will initialize these ....................................... .......................................... \n.. ............................... ................................ ...................................... \n....-. ..................... .................................... ......... .... ................................ \n..............- ...... ...............- ...................... ............-........................... \n.............- ........... ........................................ .......................-...... .................................. \n...... ...... .................................. .. .................................... ......................................... \n.. ...................................... ......................................... .. ...................................... \n... ......................-............ .....................................- ....... .......................-............ \n...................................- ....... Figure 10. An advanced value correspondence .elds (using \nthe initialization rule), but will subsequently leave them alone (there are no update rules), avoiding \nre\u00adpeatedly re-initializing the .elds at each traversal of the in\u00adterface (which might clobber updates \nmade earlier by code on the co-object side). The separation is asymmetric: if there is no separate initialization \nrule, an update rule will be used, whereas the converse is not true. Primitive values Cake can usually \ndeduce sensible be\u00adhaviour for passing primitive values between components, since it inherits from DWARF \nan understanding of all the common encodings of primitive values like integers, booleans, characters \nor .oating-point data. Tying The ...keyword can be used when allocating ob\u00adjects in Cake, to specify \nthat the allocated object should be deallocated at the same time as the tied-to object. This is a common \nrequirement in Cake, since objects created by adaptation logic are normally tightly dependent on some \napplication-domain object. Tying greatly reduces the need for explicit object freeing in Cake. Tying \nmay be thought of as a generalisation of stack-allocated objects or contained subobjects; in all these \ncases, one object s lifetime is tied to that of some other allocation. Implementation of tying relies \non the Cake runtime s ability to interpose on object deallo\u00adcation, which is also used heavily by the \nCake runtime inter\u00adnally (\u00a75.4.2). Internal reference The unusual-looking rule describing ............is \nused to describe the pointer structures within a group of objects. When creating an ............ structure, \nCake needs to know that its ........eld should point to the related ...............structure. Since this \ndoes not depend on any value from the right-hand side, .... appears (to denote no value ), but the syntax \nis otherwise identical to any other correspondence. Applying functions A bracketed stub-language expression \non one side of an arrow may be used to apply a function to the outcome of the source side, for cases \nwhere some computation is required in order to acquire the correct sink\u00adside representation. (Consider \na sink-side .eld storing an index into a table, while the source provides only a pointer to the corresponding \nelement a search through the table is required.) Such functions may be applied either before or after \nthe conversions implied by other rules, according to which side of the arrow the expression appears on. \nThis and that The ....and ....keywords are pointers to the local and (respectively) other-side representations \nof the value (i.e. before and after applications of the value cor\u00adrespondence). These pointers can be \nuseful when applying functions as values traverse the interface. In the example above, both interfaces \ndescribe some buffers containing the decoded data, but with a subtlety: the layout of the buffers is \nnot quite identical. In .....each line is padded, whereas in ........there is no padding. The code above \nuses the ..keyword, which implicitly de.nes a new named class of value (equivalent to a DWARF type) and \ntreats the value as if it were of that class. We can then supply special value correspondences for that \nclass here these override the de\u00adfault handling of .......arrays, using .......on .... and ....to move \nthe data in a padding-sensitive fashion.  4.5 Adapting constants Sometimes, correspondences occur at \nthe level of individual values. Consider explicitly mapping the individual elements of two enumeration \ntypes. Cake provides a .....construct for this purpose, syntactically much like a value correspon\u00addence \nbut mapping constants or literals rather than .elds. Components often statically embed meaningful static \ndata (e.g. con.guration .le paths) which need to be adapted. We support unilateral adaptation of these \nby rewrite rules in ......blocks. Strings can be matched by regular expres\u00adsions, and updated in the \nobject .le by appending new static data and rebinding existing references. This is the only form of binary \nrewriting done by Cake.  4.6 Input and output parameters Pointers are used to perform certain forms \nof parameter\u00adpassing. Cake s default style assumes (unless overridden) ....... ........................................ \n. ............ ........ ............................. . ......................... Figure 11. Enabling \nallocation adaptations on ........ and ......... that singly-indirected arguments typically denote in-place \nupdate a value passes out of the call as well as in.Cake will apply the appropriate value correspondences \non both en\u00adtry and exit. These semantics ensure that balanced operations can be reliably expressed (e.g. \nto insert locking and unlock\u00ading as an object traverses an interface). A singly-indirected argument might \nalso denote an output parameter (typically passing an uninitialised location in the caller s stack frame). \nSince the ..direction may perform a (meaningless) conversion on contents of the stack location, the argument \ncan be annotated as .... Similarly, for objects no longer valid after a call (e.g. if deallocated during \nthe call), we can annotate the pointer as an .....argument, preventing any output value correspondence \nfrom running. Commonly, output values .ow into caller-allocated mem\u00adory. However, some interfaces return \ncallee-allocated results. Given simple annotations, Cake can automatically adapt be\u00adtween mismatches \nin these caller-versus-callee allocation semantics. Consider the C library functions ........and .........(shown \nin Fig. 11). In the .rst, a caller supplies its own buffer for output data to be placed in. The second \nin\u00adstead returns a pointer to a new buffer, which the caller must free when .nished. Thanks to the ..........annotation, \nCake will adapt a call to the .rst function so that it instead calls the second, by post-copying the \ncallee-provided buffer into the caller\u00adprovided buffer and then freeing the former. Cake can also adapt \na call to the second function so that it calls the .rst, by pre-allocating a buffer and returning it. \n 4.7 Arrays and lists Pointers may also point to arrays; as seen in Fig. 11 with ....., array syntax \ncan be used to name a local .eld which holds the length of the array. Cake usually detects the size of \narrays at run time and applies appropriate conversions (\u00a75.3). Cake also has a style-dependent notion \nof iterables; in the default style this includes arrays (either statically\u00adsized, length-af.xed, or explicitly \nterminated as with null\u00adterminated strings) and linked lists. These allow algorithms (...seen in Section \n4.2) to be applied uniformly to any style-de.ned iterable.  4.8 Function pointers Functions are just \nanother kind of object. Although their in\u00adternal structure is opaque to Cake, we already have a mech\u00adanism \nfor describing correspondences between functions, namely, event correspondences. Passing a function pointer \nis equivalent to giving the recipient a capability to raise events across the interface between a pair \nof components. There\u00adfore, Cake will handle .ow of function pointers appropri\u00adately provided there is \nsome event correspondence de.ned across that interface whose sink expression is a simple in\u00advocation \nof the passed function (rather than, say, a multi\u00adexpression stub). Consider the following example. \n1 ....... ....... 2 .......................-. ................... 3 ...........................- ................ \nHere the developer describes how a function pointer may be passed from client to library by ..................Line \n2 adapts a mismatch in the callback registration interface: the client requires a call named ...............whereas \nthe library provides only a similar function called ............ For simplicity our rules assume that \nthe callback interface itself (e.g. the signature of functions passed as the .param\u00adeter) is well-matched \nbetween the two interfaces, but if ad\u00additional adaptations are required on the function, they can be \nadded as a lambda expression (e.g. wrapped around .in ...........above). The event correspondence in \nline 3 is unusual because it does not specify a name for the called function, but sim\u00adply uses the . \nsyntax, meaning some call . This is be\u00adcause the because the call-site in the library is an indirect \ncall, so does not statically name the function it is calling. Without line 3, or some other rule calling \n............. from ......., the Cake compiler would not generate code to interpose on the callback e.g. \nto apply the value correspon\u00addences appropriate for the two components. The presence of this rule enables \nfunction pointers (such as .............) to be correctly adapted as they are passed to the library, \nby substituting a pointer to a Cake-generated wrapper which ap\u00adplies the relevant correspondences.  \n4.9 Completing the example One hurdle remains in our running example, which is to match up the decoder \nloops of the two interfaces use pat\u00adterns. This requires no new Cake language features, so for space \nreasons we have left it to the Appendix, which con\u00adtains the example s Cake code in full.  5. Implementation \nWe discuss the compiler implementation brie.y, and the Cake runtime in detail. 5.1 Compiler back-end \nCake models a program as a set of communicating object .les or more properly, groups of objects .les, \nwhich we call components. Communication occurs along the control path of the program; an event between \ntwo components interfaces occurs when control .ows out of one component and into another. Cake is implemented \nby interposing on these events: Cake-generated code runs when events occur. (The de.ning characteristic \nof a component is that it is inter\u00adnally well-matched with itself no interposition is necessary on communication \nwithin the component.) The current implementation of Cake assumes that inter\u00adcomponent data .ow occurs \nonly through function calls, or through shared objects whose sharing was established at run time through \nfunction calls (e.g. by passing a pointer in an earlier function call). This allows Cake to intervene \nat the point where sharing is established. We discuss this further in Section 5.4. The assumption might \nbe violated by statically allocated shared variables, since sharing is established at link time. In practice, \nglobals shared among components are rare. Where they do exist, this interface is usually that of a standard \nlibrary (e.g. the C library s .....) rather than one suffering mismatch. Our current Cake compiler s \nback-end uses a specially created ........tool to generate C++ headers which re\u00adproduce the ABIs described \nin DWARF information, us\u00ading compiler-speci.c attributes to match alignment and en\u00adcoding where necessary. \nThe Cake compiler outputs wrap\u00adpers in the form of the C++ code consuming these head\u00aders, and a POSIX \nmake.le. Cake s algorithms and lamb\u00addas map conveniently onto those provided by C++. Wrappers are interposed \nusing the linker s .....option, and we have prototyped a similar mechanism using the dynamic linker s \n..........setting for the dynamic linking case. To perform string rewriting and occasional other symbol \nre\u00adbinding, Cake s back-end uses a specially modi.ed version 8 of GNU ....... 5.2 Compiler status At \nthe time of writing, our Cake implementation is not com\u00adplete, but is progressing fast. Code generation \nfor is imple\u00admented for the simpler kinds of correspondences and is a work in progress for the remainder. \nThe compiler back-end machinery, including ........and the modi.ed ......, is complete. The Cake runtime \nis also very usable and has been used successfully in some earlier case studies involv\u00ading script-generated \nwrapper code.9 5.3 Dynamic binding When control passes from one component to another, Cake behaves as \nif the program s entire object graph is carried 8 .................................... 9 We encourage \nthe reader to check for software releases at the Cake web page, ................................... \nover and transformed according to the set of value corre\u00adspondences. Its actual behaviour is subtler \nand less inef.\u00adcient (\u00a75.4.2). Objects in native code are not self-describing at run time, and the debugging \ninformation which describes them, much like static types, is inherently imprecise. If debug informa\u00adtion \nsays that a function returns a pointer to a ......,and ......is a subclass of ......, the function might \nactually return a ......pointer. Suppose we write some Cake rules to adapt between two different implementations \nof a similar windowing toolkit. .................... ...................... ................-. ......................... \n.............. ...... .......... .................... .......... . Cake has dynamic matching semantics. \nIf the pointed\u00adto object is a ......,then ...... s rules must apply. We achieve this by de.ning an is \na relationship between DWARF types. In turn, this means assuming a certain well\u00adbehavedness of the target \ncode: DWARF information may be imprecise, but not wilfully misleading. Arrays compound this dif.culty: \ndoes a pointer point to one object, or to (or into) a block containing several? If Cake decides incorrectly, \nit will not apply the correct conversions. In summary, the Cake runtime must be able to decide two questions \nabout objects. Given a pointer to an object, what byte-scale reinterpre\u00adtations might a component reasonably \nmake, to reveal a pointer to a larger object?  Given a pointer to an object, what block-scale adjust\u00adments \nmight a component make, to navigate among ob\u00adjects in the same array?  The two are not independent: \nto apply pointer arithmetic, a component must know the element size, so we assume that a component may \nnot do both byte-and block-scale reinterpretations (unless the Cake programmer provides a precise type \nby annotation).10 Cake s rules about allowable byte-scale reinterpreta\u00adtions de.ne what we call admissible \nreinterpretations.They are designed to separate out common-case well-behaved pointer adjustments from \nuncommon cases requiring annota\u00adtion. We call these uncommon cases abstraction violating after prior \nwork [Neamtiu et al. 2006] which also provides evidence that they are suitably rare. 10 To do both would \nbe to access an array through a pointer whose static type did not re.ect the true element size. In our \nexperience this occurs only when a function receives an array as a ....., but accesses the array by strengthening \nthat type. Cake s annotations handle this case conveniently. For a pointer whose referent is statically \ntyped with type t, admissible reinterpretations are as follows. If t is primitive, no reinterpretations \nare admissible.  If t is structured, reinterpretations to any zero-offset con\u00adtaining type are admissible. \nA zero-offset containing type is one which contains a subobject of type t at offset zero. We allow this \nto support the idiom often found in C\u00adlanguage object systems11 which simulate inheritance by zero-offset \ncontainment.  If t is structured, reinterpretations to any DWARF\u00adrecorded inheriting type are admissible. \nThis allows for downcasts using DWARF s special inheritance tag (which supports single or multiple inheritance). \n  To discover the most precise DWARF type for a given pointer, we use knowledge of address space layout \nto de\u00adduce whether the object is in heap, stack or static storage. For the latter two cases, a precise \ntype is found in debugging information (for the allocating stack frame or static variable de.nition). \nThis also reveals whether the object is part of an array.12 In the heap-allocated case, we exploit our \nassump\u00adtion that the recipient might do either byte-scale or block\u00adscale adjustment (but not both) to \nderive a best-effort solu\u00adtion using linear programming, as follows. 1. Discover the size and start address \nof the object s heap block in bytes, using implementation-speci.c knowledge of the heap. (This requires \nthat custom allocators be in\u00adstrumented to collaborate with the Cake runtime.) If the start address and \nsize match the pointer and its static type, we have an answer. 2. Else test whether the heap block is \nan array (block-scale adjustment): if its size is a multiple of this static type s size, and the pointer \ns offset into the heap block is a nonnegative integer multiple of that size, assume we have a pointer \ninto an array occupying the entire heap block. 3. Else test whether the heap block is a containing object \n(byte-scale adjustment): compute what (admissible) con\u00adtaining types would have sizes matching the heap \nblock size and consistent offset. If there is a unique match, we are .nished: we assume that the adjusted \nstatic type pre\u00adcisely describes the object.  If this fails, we issue a run-time warning and proceed \nwith an imprecise type. This is often not a problem, depend\u00ading on how the receiving component interprets \nthe pointer. We consider the unknowability of precise run-time types for heap-allocated objects as a \nweakness in language runtime design, which hinders not only Cake but also debuggers, garbage collectors \nand other dynamic analyses. The omis\u00adsion is often deliberate for example, the C language de.\u00ad 11 A popular \nexample is GObject, ................... 12 Note that we are now requiring that debugging information, \nor equivalent annotation, be available at run time. nition explicitly disclaims the existence of a de.nitive \ninter\u00adpretation for any memory location. However, in reality, pro\u00adgrammers nearly always do have such \nde.nitive interpreta\u00adtions in mind. Compile-time analyses could generate precise heap metadata in most \ncases (e.g. by examining data .ow out of .......), and issue warnings in others. A similar problem occurs \nwith unions: which arm of the union is the currently valid representation? Nontrivial use of unions is \nsuf.ciently rare that we have left this to future work. The best treatment is to re-encode union types \nas Pascal-style variant types: these are supported by DWARF, and the re-encoding can be expressed as \nannotations in a Cake ......block.  5.4 Adapting objects We consider objects to be structured values \nwith two key additional properties: identity and lifetime. 5.4.1 Object identity Cake understands objects \naddresses in memory as their identities. At run time, it maintains a table called the co\u00adobject relation \nwhich maps related identities to each other. As pointers pass across an interface, Cake substitutes point\u00aders \nto appropriate co-objects. Usually, for a given tuple in the co-object relation, exactly one object was \nallocated by user code; the others were allocated by Cake when a pointer to the .rst object, or some \nsubseqent co-object, was passed. Asso\u00adciations (\u00a74.4) are implemented by mapping each object to an Cake-generated \numbrella object which contains pointers to other objects in the association. At present this constrains \nan object to be participating in at most one association at a time, although we intend to relax this \nto one per correspon\u00addence rule, by giving each association rule a run-time tag. 5.4.2 Object lifetime \nWhen applying value correspondences to produce trans\u00adformed versions of objects, Cake must allocate memory. \nThis memory has a lifetime tied to the user-managed ob\u00adjects that caused its allocation. Implementing \ntying requires interposing on object deallocation. In the case of heap deal\u00adlocation (with ......or other \nheap-speci.c mechanism) this is straightforward. For stack-allocated objects, Cake must interpose on \ncleanup of the allocating stack frame. This is implemented by replacing the on-stack return address for \nthe allocating frame with the address of a handler. This handler uses the stack pointer to identify which \nframe is returning, deallocates any tied objects, and jumps back to the intended return address.  5.4.3 \nSharing objects As described so far, each component appears to have its own heap, completely separate \nfrom other components . In fact, Cake allows sharing of objects between components, subject to the invariant \nthat each component can only reach objects whose representation it understands. (We de.ne this more precisely \nbelow.) The effect is a partially split heap some objects are shared, and others are replicated (perhaps \nin alternative representations). Enforcing this invariant is nontrivial because of the tran\u00adsitivity \nof reachability. We start by partitioning the (in.\u00adnite) set of run-time objects into equivalence classes \nbased on their most precise DWARF type (\u00a75.3). Our question then becomes whether Cake can allow two components \nto share an object of a given class. We only have space to out\u00adline the intuition behind our algorithm \nhere. Firstly, consider the DWARF types of all objects which are related between each pair of interfaces. \nWe call this the master type rela\u00adtion for that pair, and it is enumerated by the set of of value correspondences \nestablished between the two components (including those made by name-matching). Next, we de.ne a binary \nrelation representation compatibility on DWARF types, recursively as follows. For a structured type: \nif the two structures de.ne identical sets of .eld names at identical offsets, and for each like\u00adnamed \n.eld the .eld s type is representation-compatible, then the structures are representation compatible. \n For a pointer type: all pointers are representation compat\u00adible. We account for reachability in a separate \nstep (be\u00adlow).  For a primitive type, the types are representation compat\u00adible if and only if size and \nencoding match exactly.13  The possibly shareable set is those pairs in the mas\u00adter type relation that \nare representation compatible. Not all of these are actually shareable, because they might contain pointers \nto objects which are not shareable. We generate the de.nitely shareable from the possibly shareable set \nby removing (until a .xed point) pairs where, given a pointer to some shared object, both components \ncould reach some piece of memory about which their expectations are not rep\u00adresentation compatible. We \ndo this by considering the type reachability graph as the connected digraph (V, E) where E includes (v1,v2) \niff a pointer to type v1 can yield a pointer to type v2 by either member selection or an admissible reinter\u00adpretation \n(\u00a75.3). We must label each edge to identify which member was selected or what interpretation was applied, \nthen remove any (a, \u00df) if there exist some non-shareable a. and \u00df. reachable respectively from a and \n\u00df by analogous paths in each s type reachability graph. We conclude this discussion with a few notes. \n Opaque and ignored pointers A technique complement\u00ading this algorithm is to obtain more precise information \nabout the interpretations each component makes of its ob\u00adjects. If a component always ignores some .eld \nin an ob\u00adject, or treats a pointer opaquely, this can enable more shar\u00ad 13 A subtlety here is enumerations, \nbit.elds and other encodings layered onto primitive types. We rely on programmer annotation to interpret \nthese, for example using the .....construct (Section 3.8). ing. We are working on support for this using \nprogrammer\u00adsupplied ......and .......annotations; future work could infer these by analysis. Update propagation \nand multithreading The partially split heap is compatible with multithreaded programming, but our current \npropagation policy is not. Speci.cally, we currently use a policy of propagating updates between all \nreplicas whenever control passes between components; this is correct in the single-threaded case, although \nslow (be\u00adcause of potentially high update volumes at each interface crossing). To reduce the update volume, \npoints-to analysis could produce a tighter bound on which objects updates may be needed during a given \ncall. Our policy also risks deadlock in multithreaded programs where more than one component contains \nactive threads at a given instant, since depending on the program s control .ow, updates may never be \npropagated. A periodic background sync thread could en\u00adsure liveness, but since this might activate mid-update, \nen\u00adsuring safety is a problem: it could most likely be solved like the analogous problem in dynamic software \nupdate systems, using quiescent update points [Neamtiu et al. 2006] and programmmer-annotated propagation \npoints [Neamtiu and Hicks 2009]. A .nal problem in the multi\u00adthreaded case is con.icting updates to separate \nreplicas of (logically) shared state. To solve this, shared-writeable ob\u00adjects could be managed using \nan alternative replication-free approach, using memory protection techniques to trap up\u00addates.   6. \nEvaluation Cake s major advance is as a convenient, powerful adap\u00adtation tool which can be applied to \nreal-world tasks. We therefore evaluate it by identifying a series of example tasks which have already \nbeen performed using conventional ap\u00adproaches, and comparing this code to the equivalent Cake code. We \ndiscuss each task brie.y and report aggregate mea\u00adsurements for both versions (lines-of-code counts, \ntoken and statement counts). Since we currently lack a complete imple\u00admentation of Cake, reimplementing \nexisting adapters in this way is useful, because we can nevertheless gain reasonable assurance that our \nCake code is complete by checking that all of the original logic is accounted for in the Cake version. \nMeasurements Although we use count-based measure\u00adments, we appreciate their shortcomings. Cake s lower \ncounts certainly originate partly in improved abstraction, but perhaps also to incidental factors such \nas a reduction in boil\u00aderplate code. We have partially remedied this by providing adjusted counts for \nC code, made after erasing common C boilerplate (speci.cally, variable declarations and function prototypes), \nbut this is an ad-hoc adjustment which still does not account for certain other areas where Cake s syntax \nmay be more concise (e.g. error-path control .ow). The remain\u00ading column in our tables refers to C code \nthat could not be reimplemented in Cake and was left as-is (to be linked alongside the Cake-generated \ncode). Limitations Even if Cake did little to simplify code (which is far from true), there are inherent \nbene.ts in Cake s black\u00adbox, binary approach which are not substantially evalu\u00adated here. Our goals with \nCake are not simply to provide a marginally better way of coding adapters, but rather to enable a shift \nin development practices towards integration\u00adbased approaches and away from reimplementation and in\u00advasive \nediting. Clearly this cannot be achieved or evaluated in small-scale studies. 6.1 Bridging related components: \n...... Filesystems are a ubiquitous abstraction: .lesystem-like in\u00adterfaces are implemented deep within \noperating system ker\u00adnels, but also in graphical desktop environments, in web servers and elsewhere. \nThe programming interfaces behind which .lesystems are implemented are invariably abstractly similar \nyet often concretely different, and conventionally coded adapters exist between some of them. We took \nthe ......adapter [Kantee 2009] from NetBSD, which adapts between NetBSD s native user-space .lesystem \nimplemen\u00adtation (....) and a special environment for running unmodi\u00ad.ed kernel code, including .lesystems, \nin user-space (....), and reimplemented it using Cake. Figure 12 shows a large portion of the Cake code \nfor this task. We were fortunate to have a one-to-one correspondence between most calls in the two interfaces, \nwith well-matched naming conventions; this is captured neatly in two ....... rules (labelled hunk 1 ). \nThere are some simple correspondences between objects in the two interfaces (hunk 2). Some ....library \ncalls leave their .....target unlocked, so we need not apply .................in those cases (hunk 3). \nThese calls are exactly those which may modify the .lesystem s di\u00adrectory structure; such calls also \nrequire the reference count of any modi.ed .....to be pre-incremented to avoid pre\u00admature reclamation, \nas captured by the ..........rules. Some ....functions return output values through pa\u00adrameters (hunk \n4a). The ....interface requires these to be passed through an opaque object, ............, populated \nusing setter functions. We can express this .rstly by describ\u00ading which ....calls arguments are outputs, \nand secondly by providing value correspondences between ............ and the relevant ....structures. \nCode in .......originated in the kernel, where client reading and writing of .le data requires address-space \ntraversal. The four relevant calls use a special interface called ...for passing this data. To us, this \nis just a new way of packaging parameters for input and/or output, and is handled by a few more correspondences. \nThe rules shown generate complete implementations of all but six of the 28 ...wrappers. The omissions \nare ex\u00adplained by special error-handling requirements, one-to-many ..................................... \n................................... .. ............................ ............................................. \n.................. .. ................................ .............................. .........................................-. \n...... ...............................-. .......... ...............- ............................. ................................................ \n...................-. ............................................... ....................-............................... \n.........................-. .............. .............- ............................. ................-. \n................................... ................................ .................-........................ \n.............................................. -. ............................. .............................................. \n-. ............................ ..................................... ......................................... \n........................................................... .- ............................... ................................... \n.......................................................... .................................. ................................. \n.......................................- ........................................................ ............................................. \n...................................................... ................................................. \n....................................... ................. ........................ .................................... \n.. ...................... ...................................... ..... .................... .................... \n-............................................. .....................-.. .................................... \n......................... .................................................. ............-. .......................... \n........................................... ....................- ......................... ........................-................................. \n.............................. ......................... ........................................ ................................. \n................................... -. .............................. .............................................. \nFigure 12. Selected rules from the ...study Table 1. Comparing ...implementations in Cake and C. C adjusted \nCake remaining C LoC (nb nc) tokens semicolons 605 3469 358 523 3137 277 133 1131 69 54 347 33 function \nmappings, and function correspondences which do not follow the naming convention. They were easily handled \nby a few more event correspondences (not shown). In summary, Cake can express the ...component in a fraction \nof the code size, and in a way which localises each concern of the two interfaces syntactic and seman\u00adtic \ndifferences far more clearly than the existing ...code. For example, treatment of unlocking and reference \ncount\u00ading is handled by discrete and localised rules, rather than being scattered throughout the code. \nThe only logic re\u00adquired which Cake couldn t adequately express was about 40 lines of C code in ....which \nload the .lesystem (the ............function). This loader is necessary because ....only calls into ...indirectly, \nthrough a table of func\u00adtion pointers passed during initialization. We instantiate this table using Cake \ns ...........helper (\u00a74.3). Table 1 shows the aggregate comparison of Cake s ... with the original implementation. \n 6.2 Migration between support libraries: ........... Another area of continuing evolution is in web \nbrowsers. The Epiphany web browser14 migrated during 2007 08 from a Mozilla-based HTML display widget \nto supporting adition\u00adally a Webkit-based one. We compare Epiphany s internal ...........adaptation layer \nwith a Cake implementa\u00adtion. Since the developers of Epiphany chose to strip out the adaptation layer \naround July 2008, after Webkit migration was completed, to target Webkit APIs directly, we used Subversion \nrevision 8300 (28 June 2008) and isolated the adaptation logic in class ...........for Cake reim\u00adplementation. \n(Although there is no relevant discussion in the changelogs or mailing list archives, clearly the devel\u00adopers \nanticipated no future need to change the target API; this strikes us as optimistic.) For simplicity, \nwe left as-is some additional adaptation code handling cookie manage\u00adment, password management and certain \nother functionality, since this contained only no-op implementations in our cho\u00adsen revision. Similarly, \nwe retained the utility classes ... ..............and ......................for use by our adaptation \nlogic; these could be implemented in Cake, but owing to their small size, their C code is dominated by \nboilerplate, so would not give a useful measurements. Epiphany uses subclassing (using the GObject library) \nto connect an .....object with a Webkit instance: the sub\u00adclass s .elds point to Webkit resources. In \nCake we use an 14 ...................................... association: the Embed object is associated \nwith the relevant Webkit objects. ......................................... ................................ \n................................ ................... Most of the calls between the two interfaces map \nvery directly. Some are left unimplemented by Epiphany; these are mapped to empty stubs in Cake. ................................................ \n-. ............................ ............................................. .....................-. \n............................................... .....................-. ............................................ \n.........................-. ................................................ ....................-......... \nThe two components exchange history item objects. Value correspondences are provided. Note that in both \ncases these are passed as .....objects, but with different payload types. Our object-sharing analysis \n(\u00a75.4.3) correctly catches this: the list nodes are not shared. We rely on explicit spe\u00adcialisation of \nthe ....pointers in each .....node. Without this, the pointed-to objects would not be explored by the \nCake runtime. .................... ....................................................... .................. \n......................................................... .... ............................... .......... \n............................... -. . ............. ....................................................... \n................. ......................................................... ..................................... \n............... Epiphany provides code to manually walks and convert the two history lists. Our code \nsimply treats the list as an object graph and applies the relevant value correspondences. Pattern-matching \non event correspondences also simpli.es the ....and .................functions. Finally, a small bene.t \nin the Cake implementation is a relative lack of boilerplate: whereas Epiphany s use of the GObject library \nnecessitates somewhat verbose C code to perform downcasts and populate a dispatch table, by contrast \nCake can succinctly instantiate the table using ............Since associations are formed dynamically \nand navigated using run-time metadata, downcasts are unnecessary. This case study proves a fair demonstration \nof Cake. However, since the data passed back and forth between the C adjusted Cake remaining C LoC (nb \nnc) tokens semicolons 525 2529 175 513 2455 163 161 784 70 0 0 0 Table 2. Comparison of ...........in \nCake and C. browser and its back-end are relatively simple, Cake s pow\u00aderful rule-based value conversions \ndo not pay off as heavily as in .... Table 2 shows the aggregate comparison of the original implementation \nand Cake s. 6.3 Evolving interfaces in distributed systems: ... Codebases in long-lived distributed \nsystems accumulate complexity over time. Occasionally developers choose to redesign the client interfaces \nto shed this complexity and better serve current needs. Such an initiative began in the X Window System \naround 2003, when a new client library ...was proposed to replace ..... For clients of ....,an adaptation \nlayer called ...[Sharp and Massey 2002] was devised. We took a small but representative subset of the \nXCL source code (around 600 raw lines out of 6000) and reimplemented it using Cake. Since ...is designed \nto be more minimal than ...., there is a small abstraction gap between the two. As a result, some utility \ncode from ...whose purpose was to bridge that gap was retained unmodi.ed for use with our Cake im\u00adplementation. \nMeanwhile, many data structures are shared verbatim between ....and ..., so there was only limited opportunity \nto exploit the expressiveness of value correspon\u00addences. This study exposed a .aw with the current Cake \nlan\u00adguage: it has no means to factor out cross-rule commonal\u00adity which cannot be captured using value \ncorrespondences. In ...there is some such commonality. For example, sev\u00aderal ....calls for setting window \nproperties map to the .................call, which takes many arguments. In ...,there is an ............function \nwhich abstracts away most of these arguments, and series of other ....calls are implemented using this \nfunction. In Cake we were forced to implement each as a verbose call to ................. instead, making \nthe Cake version longer than the C version. ................................................. ....................-................... \n................... ......................... ................................. ............................................. \n.................................................... ........................................ Table 3 \nshows the aggregate comparison of the original implementation and Cake s. We were disappointed not to \nmake bigger savings in this study. The abstraction gap con\u00adtributed some additional complexity to the \nCake code, as did C adjusted Cake remaining C LoC (nb nc) tokens semicolons 380 2581 187 315 2328 148 \n189 1543 107 42 232 19 Table 3. Comparison of an ...subset in Cake and C. the asynchronous style of \ndispatch in the ...interface, and the fact that .... s return conventions, which return 1 on success, \ndo not match Cake s default style of error report\u00ading (\u00a74.2). We hope that support for styles in Cake \nwill be able to abstract these more cleanly in the future. Had we had the resources to implement the \nwhole of XCL in Cake, we would expect better .gures, since greater commonality would be extracted by \nvalue correspondences.  7. Discussion and future work Performance Achievable performance using Cake \nde\u00adpends greatly on the cut of the interfaces being composed. We have several reasons to believe that \nCake s generated code can be ef.cient in many cases: it is often remarkably similar to hand-written code \n(particularly the ...study), and link-time optimisations can be applied after Cake has done its work. \nThe relatively slow uptake of link-time optimisa\u00adtion suggests that cross-library calls are rarely performance\u00adcritical \n(cf. intra-library calls). Finally, there is huge scope for adding further annotations and analysis to \nallow genera\u00adtion of faster code. Applicability Cake s range of applicability can only be discovered \nin the longer-term, but its underlying model is highly general and certainly not limited to procedural \ninter\u00adaction. Cake s design might apply particularly well to dis\u00adtributed systems where storage is naturally \nreplicated more than it is shared. White-box complement Cake only tackles well-abstracted tasks (\u00a73). \nBinary instrumentation systems, such as Pin [Luk et al. 2005] could make an extremely useful complement \nto Cake for turning ill-into well-abstracted tasks, but we have yet to investigate this. Dynamic component \nstructure Cake currently identi.es components by interfaces visible statically in object code. Often, \nhowever, the same static set of functions and data\u00adtypes can realise logically quite different components \nat run time. For example, two ....objects might each constitute a logical component to which different \nadaptation rules should be applied. A re.ned notion of component interfaces as slices of a trace, identi.ed \nby patterns much like event sequences (\u00a74.1), could support such use-cases. Binaries and styles The programmer \nmust understand two versions of their interface: source-level and binary-level. With C code (the default \nstyle target) these two views are usually very similar, but can be obscured by use of the preprocessor \n(e.g. to redirect function calls). Styles become more indispensable when targetting components written \nin other languages. For example, comfortable support for C++ and Java requires styles to interpret name-mangling \nconven\u00adtions, virtual function dispatch and exception handling. Our immediate future work is to tackle \nthese and related issues. Scale Our evaluation case studies are relatively small. However, we would \nexpect interface size or surface area to grow sublinearly with both component size and program size ( \nvolume ). A deeper study of this is warranted. Bidirectionality Currently in Cake, only the simplest \ncor\u00adrespondences may easily be made bidirectional. In future work we hope to unify stubs and patterns \nsomewhat, so that more rules can be naturally bidirectional. For instance, a stub which does .......can \nbe treated as a pattern which matches the sequence .......in the reverse direction. Stubs which restrict \nthemselves to reversible programming con\u00adstructs, much like lenses [Bohannon et al. 2008], could be interchangeably \nrendered as patterns in this way. Automation Cake s correspondences are effectively a some\u00adwhat strengthened \nspeci.cation such as might be fed to a converter synthesis algorithm [Passerone et al. 2002]. Still missing \nis a description of the protocols of the input compo\u00adnents, so that the trickier aspects of control structure \ncan be inferred automatically. Recent work on object usage pattern mining [Wasylkowski et al. 2007] extracts \nexactly this infor\u00admation; this could be a basis for greater automation of Cake coding. 8. Related work \nCake is primarily an adaptation tool, and combines many of the techniques in foundational work on procedural \nadapta\u00adtion [Purtilo and Atlee 1991] and protocol adaptation [Yellin and Strom 1997, Passerone et al. \n2002, Bracciali et al. 2005]. Jigsaw [Bracha et al. 1993] is an early system proposing lim\u00adited adaptation \nand composition abstractions for binaries. None of this work has Cake s support for complex object structures \n(\u00a75), nor many-to-many correspondences among values (\u00a74.4), nor Cake s level of expressiveness in data\u00addependent \nfunction correspondences. More generally, none presents a complete and practical tool design nor experimen\u00adtal \nevaluation on realistic use-cases. Cake s interface correspondence rules are similar to com\u00adposition \nrules found in subject-oriented programming [Har\u00adrison and Ossher 1993], although the latter is neither \na black\u00adbox approach (since rules may range over all source arti\u00adfacts) nor specialised for adaptation \ntasks. Cake s notion of value correspondences is somewhat similar to typemaps in Swig [Beazley 1996]. \nSwig targets a strictly smaller prob\u00adlem (interoperation between C/C++ and scripting languages) than \nCake, and has a clear directional bias (the script inter\u00adface is generated from the C one) which constraints \nits order of application. Cake s treatment of pointers, being able to translate entire object graphs \nat a time, is far more expres\u00adsive than Swig s. Recent work has furthered adaptation as a language fea\u00adture \nin C++ code [J\u00e4rvi et al. 2007], as a compatibility tech\u00adnique in cooperation with refactoring tools \n[Dig et al. 2008] and as a source-to-source translation for Java code [Nita and Notkin 2010]. The latter \nwork, Nita and Notkin s twin\u00adning , shares many of its goals with Cake. While their tool supports a strictly \nsmaller set of adaptations than Cake (which does not include the breadth of context-sensitive, stateful \nor many-to-many mappings for which Cake was de\u00adsigned), Cake lacks its deep adaptation , meaning the \nabil\u00adity to factor two variant components into a single component targeting a more abstract API. Cake \nis also a component assembly language. It was in\u00ad.uenced by Knit [Reid et al. 2000], but radically extends \nits adaptation capabilities. It shares its deliberate computational constraints with SuperGlue [McDirmid \nand Hsieh 2006], but applies to a different programming problem. Other work in component orchestration \nand coordination, such as Reo [Arbab and Mavaddat 2002] or Orc [Misra and Cook 2006] generally does not \ninclude adaptation as a primary goal, and consequently lacks a full feature-set, but sometimes never\u00adtheless \ncaters to some adaptation use-cases in a black-box style similar to Cake s. Flexible Packaging [DeLine \n2001] is perhaps the work with most closely aligned long-term goals to Cake, in seek\u00ading to separate \nfunctionality from integration, but takes a clean-slate approach. It also concerns only matters of style \n(Cake s analogy with packaging) rather than detailed inter\u00adface mismatch (since it is envisaged that \nthe packaging au\u00adthor would also write code to adapt the details).  9. Conclusions We have presented \nthe design and implementation of Cake, a language designed to abstract the adaptation, composition and \nintegration of mismatched components by describing abstract relations between component interfaces. Our \nim\u00adplementation for native binaries .nds novel use for debug\u00adging information and applies novel techniques \nto enable dy\u00adnamic behaviour and selective sharing of objects exchanged by such code. We have demonstrated \nhow Cake s features apply to real coding tasks, and our application of Cake to three real case studies \ndemonstrates its ability to yield sim\u00adpler, better modularised code.  Acknowledgments The author is \ngrateful for feedback and encouragement from David Greaves. Amitabha Roy suggested using the on-stack \nreturn address to interpose on stack frame cleanup, and pro\u00advided code. Jamey Sharp provided valuable \nsupport for the XCL case study. This version has bene.ted from helpful sug\u00adgestions from Michael Hicks, \nJon Crowcroft, Tim Deegan, Tim Harris, Orion Hodson, David Greaves, Alan Mycroft, Dominic Orchard, Robin \nMessage, Jukka Lehtosalo, Derek Murray, Steven Hand, Chris Smowton, David Evans, Atanu Ghosh and Alan \nLawrence. This work was supported by an EPSRC Doctoral Training grant.  References F. Arbab and F. Mavaddat. \nCoordination through channel compo\u00adsition. In Proc. Coordination, pages 21 38, 2002. G. Balakrishnan, \nR. Gruian, T. Reps, and T. Teitelbaum. Codesurfer/x86 a platform for analyzing x86 executables. In Proc. \n14th Intl. Conf. Compiler Construction, 2005. D. Beazley. Swig: An easy to use tool for integrating scripting \nlanguages with C and C++. In Proceedings of the 4th USENIX Tcl/Tk Workshop, pages 129 139, 1996. A. Bohannon, \nJ. N. Foster, B. C. Pierce, A. Pilkiewicz, and A. Schmitt. Boomerang: resourceful lenses for string data. \nIn Proc. POPL 08, pages 407 419. ACM, 2008. A. Bracciali, A. Brogi, and C. Canal. A formal approach \nto com\u00adponent adaptation. J. Syst. Softw., 74:45 54, 2005. G. Bracha, C. Clark, G. Lindstrom, and D. \nOrr. Module manage\u00adment as a system service. In OOPSLA Workshop on Object\u00adoriented Re.ection and Metalevel \nArchitectures, 1993. R. DeLine. Avoiding packaging mismatch with .exible packaging. IEEE Transactions \non Software Engineering, 27:124 143, 2001. D. Dig, S. Negara, V. Mohindra, and R. Johnson. ReBA: a tool \nfor generating binary adapters for evolving java libraries. In Proc. 30th Intl. Conf. Softw. Eng., pages \n963 964. ACM, 2008. DWARF Debugging Information Format version 3. Free Standards Group, December 2005. \nE. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design patterns: elements of reusable object-oriented \nsoftware. Addison-Wesley Longman Publishing Co., Inc. Boston, MA, USA, 1995. W. Harrison and H. Ossher. \nSubject-oriented programming: a critique of pure objects. ACM SIGPLAN Not., 28:411 428, 1993. J. J\u00e4rvi, \nM. Marcus, and J. Smith. Library composition and adapta\u00adtion using C++ concepts. In Proc. 6th Intl. Conf. \non Generative Programming and Component Engineering, pages 73 82, 2007. A. Kantee. Rump .le systems: \nKernel code reborn. In Proceedings of the 2009 USENIX Annual Technical Conference,Berkeley, CA, USA, \n2009. USENIX Association. C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. \nJ. Reddi, and K. Hazelwood. Pin: building cus\u00adtomized program analysis tools with dynamic instrumentation. \nIn Proc. PLDI. ACM, 2005. S. McDirmid and W. Hsieh. SuperGlue: Component programming with object-oriented \nsignals. In ECOOP 2006. Springer, 2006. J. Misra and W. Cook. Computation orchestration: A basis for \nwide-area computing. J. Softw. &#38; Syst. Modeling, 6:83 110, 2006. I. Neamtiu and M. Hicks. Safe and \ntimely dynamic updates for multi-threaded programs. In Proc. PLDI 09, pages 13 24, 2009. I. Neamtiu, \nM. Hicks, G. Stoyle, and M. Oriol. Practical dynamic software updating for C. In Proc. PLDI 06. ACM, \n2006. M. Nita and D. Notkin. Using twinning to adapt programs to alternative APIs. In Proc. 32nd Intl. \nConf. Softw. Eng. IEEE, 2010. D. Parnas. On the criteria to be used in decomposing systems into modules. \nCommunications of the ACM, 15:1053 1058, 1972. R. Passerone, L. de Alfaro, T. Henzinger, and A. Sangiovanni-Vincentelli. \nConvertibility veri.cation and converter synthesis: Two faces of the same coin. In Proc. Intl. Conf. \nComputer-Aided Design, 2002. J. Purtilo and J. Atlee. Module reuse by interface adaptation. Software \n Practice and Experience, 21:539 556, 1991. A. Reid, M. Flatt, L. Stoller, J. Lepreau, and E. Eide. Knit: \nComponent composition for systems software. In Proc. 4th OSDI, pages 347 360. USENIX Association, 2000. \nJ. Sharp and B. Massey. XCL: An Xlib compatibility layer for XCB. In Proceedings of the FREENIX Track: \n2002 USENIX Annual Technical Conference. USENIX Association, 2002. A. Wasylkowski, A. Zeller, and C. \nLindig. Detecting object usage anomalies. In Proc. ESEC-FSE 07, pages 35 44. ACM, 2007. D. Yellin and \nR. Strom. Protocol speci.cations and component adaptors. ACM TOPLAS, 19:292 333, 1997. A. Complete example \n.......................................... ........................................... ................................................. \n............................................. ..................................... ................................................ \n............... .. ................ . ....................-. .............................. ............ \n.............../*{}*/. ............-. .............. .................. .- ................ ........................... \n....................... ..................-.. .....................// in -place update to f ......................// \nstandard algorithm ........... .... ................// lambda! ................... ..................................... \n.......................... ................ ......................... ........... ....................................... \n.......................................... .. ............................... ................................ \n. // ensure an AVPacket exists , on any .ow L-to-R ....-...................... // picture dimensions \nare in sequence and ctxt ......... .... // width and height done automatically ..............- ...... \n...............- .......// here we assume a ............-........// 4:2:2 pixel format .............- \n........... // info.sequence always points to sequence object .......................-...... // special \nconversion required for buffers ...... ...... .................................. .. .................................... \n......................................... .. ...................................... ......................................... \n.. ...................................... .. .. ......................-............ .....................................- \n....... .......................-............ ...................................- ....... /* The loop \nin ffmpeg proceeds frame -by-frame, whereas in libmpeg2 * each iteration might yield zero frames ( in \nthe STATE_BUFFER * case) *or* one or more frames (in the STATE_SLICEcase). Solve * this by ensuring \nthat each iteration yields exactly one frame --\u00ad * a case supported by both library and client. */ ..................-. \n...... .- ............. /* Notice use of [0]: \" the .rst call to mpeg2_parse () **on a given dec , for \nall dec* returns STATE_BUFFER */ /* Reading from the input .le handle must also be mapped to an * ffmpeg \nlibrary call. Since success of fread () entails a return * value of nmemb, we must return this , irrespective \nof the size * of the frame actually read. This is a rare example where error \u00ad* -reporting conventions \nmust be explicitly satis.ed in stubs. */ .............................. ....................... ..................-. \n ........................................... /* Since ffmpeg handles input buffering for us , no * action \nis required on a call to mpeg2_buffer (). */ ............../*buf*/../*buf + siz */..-. ....... /* The \nclient calls mpeg2_parse () to request decoded frames. This * translates to a call to avcodec_decode_video \n(). Since our earlier * call to av_read_frame () may have returned a frame from a * different stream \n( e.g. an audio stream in the same .le ), we have * two cases to consider. These map directly to the \nlibmpeg2 constants * STATE_BUFFER (\"must read more data \") and STATE_SLICE (\"one or more * decoded frames \navailable \"), distinguished by an if --then --else. */ .. ......................... ... ................. \n..... ................... ...............-.................. .. ..................................... \n.........................// this is null -safe ................................. ................................ \n ................................ ..... .......... ... .- ............................... .................. \n /* Notice the special reverse -arrow syntax for returning. Moreover , * the special \"--{\" (\" continuing \n\") syntax retains all name bindings * from the preceding stub. */ /* Finally , we relate the state tear \n-down calls of the two interfaces. */ ..............-. ...................... ..................... ........................... \n .- ........... . // end mpeg2play .. ffmpeg .. // end derive   \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Software's expense owes partly to frequent <i>reimplementation</i> of similar functionality and partly to <i>maintenance</i> of patches, ports or components targeting evolving interfaces. More modular non-invasive approaches are unpopular because they entail laborious wrapper code. We propose Cake, a rule-based language describing compositions using <i>interface relations</i>. To evaluate it, we compare several existing wrappers with reimplemented Cake versions, finding the latter to be simpler and better modularised.</p>", "authors": [{"name": "Stephen Kell", "author_profile_id": "81338488995", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P2354071", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869487", "year": "2010", "article_id": "1869487", "conference": "OOPSLA", "title": "Component adaptation and assembly using interface relations", "url": "http://dl.acm.org/citation.cfm?id=1869487"}