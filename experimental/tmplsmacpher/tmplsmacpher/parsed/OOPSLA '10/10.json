{"article_publication_date": "10-17-2010", "fulltext": "\n Lime: a Java-Compatible and Synthesizable Language for Heterogeneous Architectures Joshua Auerbach \nDavidF. Bacon Perry Cheng Rodric Rabbah IBM Research {josh,dfb,perry,rabbah}@us.ibm.com Abstract The \nhalt in clock frequencyscaling has forced architects and language designers to look elsewhere for continued \nimprove\u00admentsin performance.We believe thatextracting maximum performance will require compilation to \nhighly heteroge\u00adneous architectures that include recon.gurable hardware. We presentanewlanguage,Lime, \nwhichis designedto be executable across a broad range of architectures, from FPGAsto conventional CPUs.We \npresentthe languageasa whole, focusing on its novel features for limiting side-effects and integration \nof the streaming paradigm into an object\u00adoriented language. We conclude with some initial results demonstrating \napplications running either on a CPU or co\u00adexecuting on a CPU and an FPGA. Categories and Subject Descriptors \nB.6.3[Design Aids]: Hardware Description Languages; D.3.3 [Programming Languages]: Language Constructs \nand Features; D.1.3 [ProgrammingTechniques]:Concurrent Programming, Object\u00adoriented Programming General \nTerms Design, Languages Keywords object oriented, value type, streaming, func\u00adtional programming, recon.gurable \narchitecture, FPGA, high level synthesis 1. Introduction The search for single-CPU performance has moved \nbeyond clock frequencyscaling which has almost ground to a halt. The vast majority of effort, by both \nindustry and academia, has focused on homogeneous multicore systems. We take the opposite view, namely \nthat achieving high performance with limited power consumption will require a heterogeneous architectural \napproach in which there is a Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page.To \ncopyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright&#38;#169;2010ACM \n978-1-4503-0203-6/10/10... $10.00 considerable degree of specialization of the hardware re\u00adsources to \nthe desired mix of applications. This is already evident to some degree with the addition of GPUs and \n.xed\u00adfunction accelerators for cryptography.We believe this trend will accelerate. Achieving maximal \nperformance will re\u00adquireexploitationof recon.gurable hardwareand othervery .ne-grained resources in \naddition to, rather than instead of, more conventional approaches like GPUs and homogeneous multicores. \nThe disadvantage of such heterogeneous systems is that without suf.cient levels of abstraction and compilation \ntech\u00adnology, they will be very dif.cult to program. Currently, CPUs are often programmed in high-level \nmanaged lan\u00adguages like Java; GPUs are programmed with dialects of C; and recon.gurable hardware is programmed \nwith hardware description languages likeVerilog and VHDL. We believeexploiting heterogeneous systems \nwill require a language, compiler, and run-time system with the follow\u00ading properties: A single language \nthat can be compiled to a highly di\u00adverse set of computational elements;  The capability to express \nmanydifferent forms of paral\u00adlelism so that those computational elements can be ex\u00adploited in the manner \nbest suited to them;  A dynamic run-time system that is capable of sub\u00addividing programs to run across \na variety of compu\u00adtational elements, and dynamically re-partitioning pro\u00adgrams as they change or as \nthe system application mix changes;  Auniform semantic model that allows transparent migra\u00adtion between \ncomputational elements; and  Alanguagesuf.cientlyfamiliartoachieveawidedegree of adoption.  In this \npaper we present Lime, a language designed to meet these requirements.We will describe thevarious fea\u00adtures \nof the language and how theyemerge from and attempt to address the sometimes con.icting needs of such \nvastly different kinds of computational elements. Our implementationhassofar focusedonthe mostdiver\u00adgent \nkinds of computational elements: traditional processor cores and recon.gurable hardware (.eld-programmablegate \narrays or FPGAs). This has placed the maximal stress on the language design. While our implementation \nhas so far emphasized semantic completeness over performance opti\u00admization, we present preliminary results \nfor some represen\u00adtative applications that can be compiled into bytecode, C, orVerilog, and co-execute \nacrossa CPU/FPGA system.We have currently written and run over 40,000 lines of Lime code.  1.1 Key LimeFeatures \nBefore diving into the details of the language, we begin by providinganoverviewofthe language featuresandhowthey \naddress the requirements set out earlier. Lime is a Java-based language with signi.cant exten\u00adsions. \nUsing Java as a starting point provides both a fully machine-independent semantics and a dynamic execution \nmodel in which the run-time system adaptively recompiles the program as needed. While abstract semantics \nand dynamicity are requiredto allow computations to be shared across divergent computa\u00adtional elements, \neffective compilation to hardware requires the ability to conveniently express statically known code, \ntypes, and sizes.To this end Lime provides unerased gener\u00adics (which can be compiled in a template expansion \nstyle to maximize compile-time knowledge), ordinal types (inte\u00adger ranges with a statically known number \nof elements), and bounded arrays indexed by (possibly parameterized) ordinal types. Thelackof side-effectsandexplicitpointersmakeafunc\u00adtional \nprogramming style well-suited to hardware. Lime adds both micro-functional and macro-functional fea\u00adtures \nthat integrate cleanly with an imperative, object\u00adoriented style. The micro-functional features center \naround recursively immutable value types. The macro-functional features are based on isolated tasks that \ninternally allow arbitrarily complex sequential imperative code, but can be modularly replaced with purely \nfunctional code. Lime allows the convenient expression of various styles of parallelism. Fine-grained \nparallelism can be expressed down to the bit-level since bits are .rst-class objects in Lime, and primitive \ntypes with bit-level parallelism can be programmed directly in the language (e.g., 27-bit .xed-point \nnumbers).Fine-andmedium-graineddata parallelismcanbe expressed with collective and reduction operations \non both built-in and user-de.ned array and collection types. This includes operations as .ne-grained \nas performing a not operation across an array of bits. Medium-and coarse-grained pipeline and data paral\u00adlelism \ncan be expressed using new streaming primitives which compose individual tasks into computation graphs. \nStreaming features are integrated into the language with the introduction of a task operator that converts \na method intoa componentina stream computation graph.A connect operator then allows rich graphstobe composed \nfrom tasks. It is the responsibility of the run-time system to handle buffering, partitioning, and scheduling \nof the stream graphs. Many languages that introduce streaming or message passing have suffered from a \ntwo paradigms problem, in which programmers must decide early whether they will code a computation in \nfunction style or stream style . For instance, in StreamIt [33] stream computations are writ\u00ad ten with \nexplicit operators that dequeue and enqueue one or more objects for theworker computation; such computations \ncannot subsequentlybeusedina contextwhere functionap\u00adplication is being used. In Lime, the same method \nbody can be used in either style (the distinction being whether the task operator is ap\u00adplied). Rather \nthan provide explicit enqueue/dequeue opera\u00adtors, Lime has tuples and bounded arrays that can be used \nto express multi-input/multi-output operations, and a match operator is used to connect tasks with different \ndata rates. To expose functional properties and strong isolation within an imperative language, Lime \nrelies on three key concepts: valueness, localness, and sole-reference isolation. Valueness or immutability \nis declared using thevalue key\u00adword to modify a type declaration. Localness is declared us\u00ading the local \nkeyword which may be applied to anymethod declaration. It means that the method does not access mu\u00adtable \nstatic .elds (although it may read certain .nal static .elds). Finally, sole-reference isolation means \nthat only the task has a reference to the underlying object and hence any mutation of instance .elds \noccur as a result of the instance itself. These properties are easy to check and verify. Using these \nproperties, Lime can classify the world of objects into tasks that are provably functional and those \nthat are mutable but sole-reference isolated. These properties afford a great deal of compilation .exibility \nin realizing ef.cient parallel implementations that eschews data races and implicit non\u00addeterminism. \n 1.2 Contributions A language is much more than the sum of its parts, and this paper is primarily organized \nso as to give the reader an overview of the language as a whole. The language is based on Java, extended \nwith a combination of well-known and novelfeatures. The novel features described for the .rst time in \nthis paper are: a simple, polymorphic, statically checked mechanism for preventing non-local side-effects \n(Section 3);  the compositionoftheeffect mechanismwithvaluetypes to obtain referentially transparent \nimperative expressions (Section 3.1);  the integration of stream-based computation into an object-oriented \nlanguage (Section 6);  the introduction of rate matchers, which combined with .xed-size arrays can express \nnon-unit-rate stream com\u00ad   putations without requiring methods to be expressed in a different paradigm \n(Section 7); and description of the compiler and run-time system with preliminary results showing that \nprograms can be co\u00adexecuted across conventional processors and .eld pro\u00adgrammablegate arrays (Section \n9). Language constructs for expressing micro-functional op\u00aderations and bit-level parallelism, and their \ncompilation to FPGAs were previously described in [21]. The full language is described in detail in the \nlanguage reference manual [5]. 2. Lime Language Fundamentals Two of the biggest challenges in the design \nof Lime were (a) to provide convenient ways to expose manylevels of paral\u00adlelism and (b) to enable, encourage, \nand simplify the use of language constructs that can be used to generate the kinds of static structures \nrequired when compiling to hardware. The latter is particularly dif.cult in Java-like languages which \ntend to have the opposite goal. Many fundamental language features are shown in the single example of \nFigure 1, a partial and simpli.ed imple\u00ad mentation of thebuilt-in unsigned type. An unsigned num\u00adberis \nde.nedasa.xed-size arrayofbits,andeach operation is then de.ned as a function on those bit arrays. Since \nmuch of the computation and parallelism available in hardware occurs at the bit-level, it is essential \nthat Lime provide constructs for exposing such operations, and yet maintain a high level of abstraction. \nThus the ability to compute at the bit-level is combined in Lime withthe ability to de.ne what in almost \nevery other language are included as primitive types. 2.1 ValueTypes One of the most fundamental aspects \nof Lime is the intro\u00adduction of value types. An object of value type is deeply im\u00admutable;that is, all \nof its .elds must be both unmodi.able ( final , in Java parlance) and must themselves be of value type.Thisisin \ncontrasttothe structvaluetypesofC#,whose .elds are immutablebut may point to mutable objects. Deeply \nimmutable objects provide a host of bene.cial mathematical properties (long espousedbyadherentsof pure \nfunctional programming) which are exploited extensively in the other features of the language and in \nits compilation.For compilation to hardware, Lime s value classes are essential since they can be freely \nmoved across a chip as a chunk of bits, without requiring anyremote accesses. Greatly motivated by the \nneeds of both hardware com\u00adpilation and exposure of parallelism, Lime pushes Java to\u00adwardsa more functional \nstyle.Value types providea micro\u00adfunctional portion of the language. Streaming computation (see Section \n6) provides the macro-functional portion of the language. Value classes are de.nedby adding thekeyword \nvalue to the class de.nition, as in line1of Figure 1. All .elds of 1 public final value class 2 unsigned<N \nextends ordinal<N>> { 3 private bit[[N]] data; 4 public unsigned() { 5 this.data = new bit[[N]]; 6} \n 7 public unsigned(bit[N] data) { 8 this.data = new bit[[N]](data); 9} 10 public unsigned<N> this &#38; \nunsigned<N> that { 11 var result = new bit[N]; 12 for (N i: N.first::N.last) 13 result[i] = this.data[i] \n&#38; that.data[i]; 14 return new unsigned<N>(result); 15 } 16 ... 17 } 18 public typedef uint = unsigned<enum<32>>; \n Figure 1. Unsigned number implementation in Lime a value class are implicitly final, and must themselves \nbe value classes.Adefault constructoris auto-generatedby the compiler if it is not explicitly de.ned. \nValue classes have no reference identity: the equality ( == ) operator recursively compares the equality \nof the .elds, and the hashCode() methodisadeterministic function of the values of the .elds. Synchronization \noperations on value classes are statically forbidden, except when they are up-cast to Object or non-value \ninterface types, in which case a dynamic check guards against the synchronizing on a value object by \nthrowing an exception. 2.2 Ordinals Ordinals are .nite non-negative integral types, and are fun\u00addamental \nto theway statically sized and bounded objects are expressed in Lime. Despite their super.cial resemblance \nto integers, ordinals are a special kind of enumeration type. Thus they are de.ned using the enum keyword: \nenum<3> is the ordinal type with members {0, 1, 2}. Ordinals havesuccessor and predecessor operations \n(writ\u00adten +++ and --- ,respectively), canbe comparedbyorder (e.g. with < ), and can be added to or subtracted \nfrom each other (in which case the arithmetic is performed modulo the size of the ordinal).  2.3 Bounded \nArrays andValue Arrays In Lime, there are two different kinds of arrays: mutable arrays and value arrays. \nLime s mutable arrays are similar to Java s arrays. Value arrays, like value classes, are deeply immutable, \nmeaning that the arrays elements may not be changed and the element types must themselves be value arrays \nor value classes.Value arrays are written witha double-bracket nota\u00adtion.For instance,anunboundedvalue \narrayof int elements is written as int[[]].  An array with a statically .xed size is called a bounded \narray. Bounded arrays are heavily used in Lime, both to express .xed-size components of value classes, \nas well as to describe the input and output rates of stream operators (see Section 7). Abounded array \ntype is written with its ordinal bounding type inside of the square brackets as in bit[enum<3>],which \nis a 3-element array of bits. When the bounding type can be expressed without using type variables, it \nis commonly abbreviated to just a constant expression, as in bit[3].A bounded arrayis indexedbyintegerexpressions \nthat are stat\u00adically con.ned to be within range. The two easiest ways to achieve this are (1) to use \neither integer literals or (2) to use expressions of the ordinal bounding type (which are implic\u00aditly \nturned into integers whose range is known). This leads to more reliable code and reducesthe need forexception \nlogic in hardware. Bounded arrays are subclasses of unbounded arrays, and can thus be implicitly cast \nto their unbounded form. Thus a variable of type bit[3] can be assigned to a variable of type bit[],and \nvice-versaifanexplicitcastisused.InLime,the unbounded array types are abstract; all arrays are actually \ninstancesof bounded arrays parameterizedby their size. Bounded and value arrays are used extensively \nin the de.nition of unsigned in Figure 1. The only .eld of the class (line 3) is a bounded value array \nof bits. In this case, the bounding type of the array is the generic parameter N (Lime generics are described \nin more detail below). There is also a constructor (line 7) which takes a mutable bounded array of bits, \nand uses it to create a new unsigned number. It uses the array constructor ( new bit[[N]](data) ), which \ninputsthe mutable bounded array and returns an equivalent immutable bounded array,which is then used \nto initialize the newly constructed object. Finally, bounded arrays are usedin the de.nition of the &#38; \noperator on lines 10 15. The bounded mutable array result is de.ned on line 11, and its elements are \ninitialized on lines 12 13. Finally, on line 14, the constructor of line 7 is invoked to create a new \nunsigned value from the bits assembled in the result array.  2.4 Unerased Generics As can be seen from \nour example, generics of .xed size are extremely important for the generation of hardware. Unfor\u00adtunately, \nJava s implementation of generics uses erasure, in whichall instancesofagenericclassarecompiledintoasin\u00adgle \nclass in which the generic parameters have been erased. This has three implications: (1) the information \nneeded by the hardware backend(or indeedbya highly optimized soft\u00adware backend) to generate speci.c types \nis lost; (2) safety is compromised, since erasure loses information, and(3)ex\u00adpressivityislost,sinceanyoperation \nrequiringtheexacttype of the generic parameter must be disallowed.For instance, the expression new T[10], \nwhere T is a generic parameter, is not permitted in Java. In Lime, generics are compiled without erasure, \nobtaining semantics similar to those of NextGen [28].We rely on this property in Figure1 in lines 5, \n8, and 11, which construct new bounded arrays where the bounding type is a generic parameter. In addition, \nand unlike NextGen, Lime generics are capableof being parameterizedby primitive types. Compilation strategies \nfor generics have typically suf\u00adfered from a tension between time-and space-ef.ciency. Parameterization \n(where the type parameters are included as parameters to the methods) produces the most space\u00adef.cient \ncode (since there is only one copy) but loses any opportunity for type-speci.c optimization.Template \ngener\u00adation produces one instance of the generic class for each unique combination of type parameters \nin the source code; this maximizes opportunities for optimization,but can result in huge space overheads. \nInLime,weuseahybrid implementation strategy.Insoft\u00adware, the default compilation is parameterized; in \nhardware, the default is templatized. However, where needed templa\u00adtized compilation can be used in software, \nand in some restricted cases, parameterized compilation can be used in hardware.  2.5 User-De.ned Operators \nLime allows programmers to de.ne the behavior of stan\u00addard unary and binary operators as theyapply to \nnew types. Operatoroverloading as practicedinC++was deliberately avoided in Java since manyfelt its overuse \nresulted in con\u00adfusing code. In Lime, however,the ability to de.ne basic op\u00aderators associated with arithmetic \nand logical operations is essential to the strategy of bringing object orientation down to the bit level \nand on a par with primitive types. As an ex\u00adample, the &#38; operator for the unsigned<N> type, is shown \non lines 10-15 of Figure 1. The following unary and binary operators can be user-de.ned: ~!+++---+-*/ \n&#38; |^% < <= > >= &#38;&#38; || <<>> >>> ::[] The operators +++ and ---are the successor and prede\u00adcessor \noperators introduced in Section 2.2. and the range op\u00ad erator :: is explained in Section 2.6. Lime does \npermit the array indexing operator [] to be rede.ned both for ac\u00adcess (when not the target of an assignment) \nand for setting an element. The equality operators ( == and != ) may not be rede.ned in Lime.Value types \nhave compiler-generated equality operators that check for recursive value equality. The language also \nprohibits the overloading of exotic op\u00aderators such as the dot operator for method call Certain binary \noperators implicitly de.ne their corre\u00adsponding compound operator.For instance, the + operator implicitly \nde.nes the += operator. More subtly, the pre\u00adand post-increment/decrement operators are respectively \nde\u00ad.ned by the successor and predecessor operators.  2.6 Ranges Ranges are a convenience feature to \nsupport iteration over subranges of value types (assuming the type provides order\u00ading operations). Examples \ninclude Lime ordinals and value enums as well as the Java integral primitive types. The expression x::y \nhas the type lime.lang.range<T> where T is the least upper bound type of x and y. The type range<T> implements \nthe Iterable<T> interface from Java, but is itself avalue type. Ranges are thus usable in the for\u00adeach \nstyle loops introduced sinceJava5and also asvalues in their own right. Ranges are particularly useful \nin conjunction with the constructs .first and .last which resemble .elds and ap\u00adply to all bounded types \n(most notably, ordinals). Unlike or\u00addinary .elds, the .first and .last special selectors (also .size)are \ndispatched virtually through type variables. An example is line 12 of Figure 1, which loops over the \nrange of the ordinal N which is a type parameter. Lime also providesa special shorthand when the iteration \nis over the entire range of a value type. For example, the looponline12oftheexample couldbe written for \n(N i) (with the limits N.first and N.last implied). 2.7 Typedefs Given that Lime permits the de.nition \nof new primitive types, it is convenient to be able to give those types short intuitive names, especially \nwhen the types are de.ned using generic types which tend toward verbosity. Thus, Lime pro\u00advides typedefs \nsimilarin.avortowhat areofferedintheC language. An example is shown on line 18 of Figure 1. Semantically, \na type de.nition is just one step above a lexical macro and is substituted for the de.ned symbol prior \nto any other semantic analysis. However, the scoping and visibility for typedefs follows that for class \nde.nitions. Thus, the typedefintheexampleis public just as unsigned<N> is public (as a result, it actually \nneeds to be in a source .le of itsown).Typedefs at package scope, class scope, and local scope are also \npossible. 2.8 LocalType Inference Lime programs canmakeheavy useoftheexpanded generic types. Parameterized \ntypes tend to be verbose, and some of the types introduced by task programming are especially verbose \n(see Section 6.3). As a compensating convenience, Lime provides a limited form of local type inference \nto avoid the need to present verbose type declarations twice. The pseudo-type var in a .eld or local \nvariable declaration causesthe type to be inferred from the initializer. When the variable or .eld being \nde.ned is also final one simply uses final rather than final var. Anexampleis shown on line11of Figure1 \nwhere the var keywordis usedtoavoidhavingto typebit[N] twice on the same line. Inference is limited to \nthese contexts and there is no attempt to infer types across multiple expressions.  2.9 Java Compatibility \nAkeydesign decision in developing Lime has been to make it Java compatible. Most legal Java programs \nbecome legal Lime programs without change. All legal Java programs can be imported as Lime programs by \na purely syntactic trans\u00adformation that is extremely non-intrusive and trivially per\u00adformed by a development \ntool. Lime reserves twelve addi\u00adtionalkeywords. These identi.ers,if presentinaJava pro\u00adgram, can continue \nto be used by escaping them with a ` (backtick) character. Generic types and methods have an ex\u00adpanded \nsemantics in Lime,but the original Java semantics can be obtained by use of the ~ (tilde) character. \nSimi\u00adlarly, arrays have been enhanced in Lime but one can es\u00adcape back to Java arrays with a tilde. Usually \nthe tilde es\u00adcape proves unnecessary and can be removed, conferring some Lime advantages immediately. \nThen, Lime language features can be gradually added making the program more readily parallelizedby the \ncompiler. Lime programs are also binary compatible with Java in that they can freely invoke Java methods; \nif Lime-speci.c types are avoided in public signatures, then Java code can call back into Lime. 3. Local \nMethod Checking The goalsof Lime requirea classi.cationof methods into those that are pure functions, \nthose that are stateful but isolated (receiving new information only as arguments and providing results \nonly as return values), and those that have arbitrary side-effects.For modular compilation andef.cient \nimplementation, this classi.cation should be decidable by examining single methods without computing \na call-graph or similar structure and in the presence of inheritance and virtual dispatch. More precisely, \na stateful isolated method is an instance method that may read and mutate all information reachable from \nthe this instance. It may not read or mutate any other information, thus excluding all information reachable \nfrom static .eldsof anyclass.It may read,but not mutate, argument information. It may not retain a reference \nto its return value or anything reachable from it. We rejected the idea of translating these properties \ndi\u00adrectly into checkablekeywords like pure or isolated. While both properties are easy to state as requirements, \nenforcing them as unitary properties in an imperative language would require complexchecking.Toensure \nthatamethodis purein the absence of an independent immutability property means analyzing all of its actions \nin context (what the method is doing and which objectsitis doingit to).To ensure thata methodis statefulbut \nisolatedis similarly dif.cult since one must enable one large class of accesses while disabling an\u00adother \nlarge class which will break isolation.  Lime substantially simpli.es and modularizes the re\u00adquired \nchecking for both pure functions and statefulisolated methods by decomposing both of these properties \ninto two simpler properties. The .rst is valueness which is already capturedby the Limevalue types (see \nSection 2.1).Value\u00ad ness is useful in its own right and can mostly be checked by examining .eld declarations \nand by directly generating the code for equality checking (constructor code is also checked to prevent \nexposure of uninitialized final .elds). The sec\u00adond property is localness, which simply means that no \nside\u00adeffects can be propagated through static .elds or information reachable from them.Inthe presenceofvalueness, \nlocalness is readily checked method-by-method, examining only .eld accesses and method calls. Two different \ncompositions of valueness and localness yield the desired purity and isola\u00adtion properties as explained \nbelow. The method modi.ers for localness are called local and global (explained next) and glocal (explained \nin Sec\u00adtion 3.2).Amethod labeled local must not write anystatic .elds and must not read anystatic .elds \nexcept repeatable static .elds as de.nedin Section 3.1.A global method may freely access all static .elds. \nBy default, the instance methods and constructors of value types are considered to be local,while all \nstatic meth\u00adods and the instance methods and constructors of non-value types are considered to be global. \nThe defaults maybeover\u00adriddenby using theexplicitkeywords. Alocal method may only invokeother local methods.A \nglobal method may invoke either local or global methods. Alocal method may not be overridden or implemented \nby a global method. These rules together ensure that the prop\u00aderty asserted by local can be checked without \nrecursively investigating callees, and without knowing the complete in\u00adheritance hierarchy. To ensure \nfull checking,local and global apply equally to concrete and abstract methods (including the methods \nof interfaces). In Figure 2, the interface IRandom provides a single method, nextInt(), which generates \na random integer. nextInt() is declared global since that is the most permissive quali.er. There are \ntwo implementations: Random and PseudoRandom. The .rst implementation calls nanoTime() and therefore \naccesses global system state, and so the method is also declared global. However the sec\u00adond implementation, \nPseudoRandom, uses a (very primitive) deterministic function (for the purpose of illustration) to generate \npseudo-random numbers; therefore, its nextInt() method is declared local and can be called in anycontext. \nRecallthat one motivationwasto determine when meth\u00adods are pure functions. The rules for determining \nthis prop\u00aderty are as follows: 1.A local static method whose arguments are all value types is necessarily \na pure function. It cannot communi\u00adcate through static .elds, it has no this argument, and its explicit \narguments have no mutable instance .elds. 1 public interface IRandom { 2 global int nextInt(); 3} 4 \npublic class Random implements IRandom { 5 public global int nextInt() { 6 return (int) System.nanoTime(); \n7} 8} 9 public class PseudoRandom implements IRandom { 10 int nextValue = 17; 11 public local int nextInt() \n{ 12 nextValue = nextValue * 317 + 9; 13 return nextValue; 14 } 15 } 16 public final value class 17 \nunsigned<N extends ordinal<N>> { 18 ... 19 static glocal unsigned<N> random(IRandom g) { 20 return new \nunsigned<N>(g.nextInt()); 21 } 22 } 23 public class BoundedMap<K extends ordinal<K>, V> { 24 protected \nfinal V[K] mapping = new V[K]; 25 ... 26 public glocal boolean containsValue(V val) { 27 for (K key) \n28 if (val.equals(mapping[key])) 29 return true; 30 return false; 31 } 32 } 33 class Test { 34 static \nfinal boolean repeatable = hasFoo(); 35 static local boolean hasFoo() { 36 var g = new PseudoRandom(); \n37 var u = unsigned<32>.random(g); 38 var map = new BoundedMap<enum<20>, 39 unsigned<32>>(); 40 map[enum<20>.random(g)] \n= u; 41 return map.containsValue(u); 42 } 43 } Figure 2. Example of Local, Global, and Glocal Methods. \n2.A local instance method of a value type whose argu\u00adments are all value types is a pure function. Although \nthere is a this argument, that argument is a value too. A second motivation was to determine when methods, \nthough stateful, are isolated. This requires controlling the reachability of objects from instance .elds. \nThe desired property can be computed by .rst de.ning an isolating con\u00adstructor as follows: a constructor \nis isolating if it is local and has only value arguments. Instances that are created with isolating constructors \nare guaranteed to have no aliases initially stored in their instance .elds. We can then guar\u00adantee that \na method is stateful but isolated with respect to a particular instance if (1) the instance was created \nwith an isolating constructor, and (2) the method has only value arguments and a value return.  Apure \nfunction may return non-values (since theycannot also store a reference to what they return) but returning \na non-value from a stateful isolated method could break isolation by creating an alias. Stateful isolation \nwith respect to a particular instance is useful when we can guarantee that a task holds the only reference \nto the instance. This .nal guarantee is quite easy to achieveas described in Section 6.2. 3.1 Repeatable \nStatic Fields Recall that a local method may read certain static .elds deemed to be repeatable. The concept \nof a repeatable ex\u00adpression is thus an extension of the concept of a compile\u00adtime constant expression \n(which in Java is limited to primi\u00adtive types). Repeatableexpressions allow complexinitializa\u00adtion of \nany value type with complex imperative code. Astatic .eld is repeatable if it is recursively immutable \n(i.e.,a final .eld of value type) and all accesses to it during the lifetime of the computation produce \nthe same result. The recursive immutability property is clearly needed to avoid introducing new opportunities \nfor side-effects. Re\u00adpeatability is added to avoid the subtle requirement that would otherwise exist \nthat all static final .elds that are read by local methods must be initialized before those methods can \nbe allowed to execute. It eschews any non\u00addeterminism due to class loading order, and it makes it sub\u00adstantially \neasier to relocate computations to hardware ele\u00adments that lack a distinguished class initialization \nphase. In Lime, the only sources of non-determinism in a single thread are limited to global methods, \nsuch as System.nanoTime() in the example in Figure 2. So, the re\u00ad peatability property is obtained if \nthe following properties hold in addition to recursive immutability. 1. The .eld must have an explicit \ninitializer. 2. Its initializer must be an expression that would be legal in a local method. 3. The \n.eld s initializer may not refer directly or indirectly (via other static variables) to the .eld itself \n(this would make the value dependent on the order in which classes are initialized).   3.2 Local/GlobalPolymorphism \nItwas said earlier that abstract methods (and more generally, methods high in the class hierarchythat \nare intended to be overridden) must commit to being either local or global. This is not quite true: Lime \nprovides a third option, moti\u00advatedby the following observation. Thefact that local can override global \nbutnot viceversawould tendtofavorusing global for abstract or frequently overridden methods. But, thefact \nthat global can call local but not viceversafavors making methods local whenever feasible so that they \ncan be used in more contexts. Thus, a user designing a class hi\u00aderarchyto be used in multiple contexts \nhas a con.ict if only those choices exist. In fact, abstract methods which have, as yet, no actual behavior, \ncan later be implemented in either a local or a global fashion, as in theIRandom class hierarchyof Figure \n2. But, simply declaring a neutral category would do no good by itself, since a conservative analysis \nwould have to preclude calling any neutral method in a local context. Lime solves this problem with a \ncontext-dependent cate\u00adgory, called glocal,with rules anda supporting static analy\u00adsis that allows manycalls \nto glocal methods to be treated as local calls. This promotes the more extensive use of local methods \nwithout compromising ef.ciency or re-usability. Our solution is based on the observation that, for many \nmethods, whetherthe method accesses global stateisa func\u00adtion of its input arguments.For instance, Figure2lines \n16 22 show the random() method of the unsigned type. It is a glocal method that accepts a random generator \nof type IRandom. On line 37, unsigned s random() method is in\u00advoked with a parameter of type PseudoRandom, \nall of whose methods are local. Therefore, we can treat the random() method as local in the calling context \nat line 37. Lime s glocal modi.er exploits the greater information available at call sites by de.ning \nlocalizing calls and de.n\u00ading glocal methods so that calls to them are localizable. At the call site, \na local method may only call a glocal method when all of its parameters are localizing. An actual parameter \nlocalizes a formal parameter when all of the ac\u00adcessible non-.nal instance methods of the formal parameter \nare overridden to be local in the static type of the actual pa\u00adrameter. When used in combination withgenerics, \na call to a glocal method is localizing only when all of the generic and method parameters are localizing. \nAt the method de.nition, a glocal method has the same restriction as a local one in its access to static \n.elds. In addition 1. calling final global methods is prohibited (such a call can never be localized); \n 2. calling non-.nal global methods is prohibited except when (a) the receiver is a parameter of the \nmethod being de.ned, or (b) its type is determined by a type variable (only calls indirected in such \na fashion can hope to be localized); 3. calling other glocal methods is only allowed when it would be \nallowed for a global one by the previous rule or when such a call is localizing;   4. a glocal method \nmay not override a local method and a global method may not override a glocal one (this en\u00adsures that \nthe strongest necessary check is always per\u00adformed at call sites). In Figure2, unsigned.random() isavalid \nglocal method by rule 2(a): it calls a non-.nal global method of its pa\u00adrameter g of type IRandom. The \ncall on line 37 is localizing because all methods of PseudoRandom are local. The locality-polymorphism \nprovided by glocal is also essential for generic classes, as shown in the fragment of the de.nition of \nthe class lime.util.BoundedMap on lines 23 32. This class implementsa mapping where thekeyisof an ordinal \ntype, allowing a very ef.cient implementation with a .xed-size bounded array. The values held by the \nmapping, on the other hand, are of unconstrained type (type V). Consider the implementation of the containsValue() \nmethod on lines 26 31: it iterates over the mapping array checking whether it contains the passed parameter \nval. It does this by calling the equals() method, which, since V is of unconstrained type, is considered \nto be Object.equals(). Although it is considered good style for equals() to bea local method, we do not \nconstrain it as such (in particu\u00adlar, doing so would break Java compatibility). Thus the call to equals() \non line 28 is not local,but it is localizable by rule 2(b). The call to containsValue() on line 41 is \nlo\u00adcalized because the actual type of the generic parameter V is unsigned<32>, which is a value type \nwhose equals() method is therefore guaranteed to be local. The analysis that supports glocal is conservative \nin two ways. First, the simple name of the parameter must be the receiver of the call. Second, all accessible \nnon-.nal instance methods of a substituting type must be local, regardless of which of those methods \nare actually called. Because calls can occur in subroutine methods as well as the one being analyzed, \nthe additional analysis to support greater precision would be complex and non-modular,but more to the \npoint, the reasoning required on the part of the programmer to understand what is safe and what isn t \nwould likely be quite challenging. Over time, experience with the language may lead us to attempt a more \nprecise de.nition and analysis. To maximize reuse, it is highly desirable that classes be usable in a \nlocal method, and as localizing parameters. In particular, the three overridable public methods of Object \n equals(), hashCode(), and toString() should be local whenever possible. Since a value type causes all \nof these methods to become local, substituting a value type for the Object type is always localizing \n(e.g., BoundedMap). For non-values, the programmer must take care to en\u00adsure the same property holds \nwherever possible. The eas\u00adiest way to do so is to have a non-value class extend lime.lang.Mutable rather \nthan Object. The former pro\u00advides local implementations of the threekey Object meth\u00adods. The equals() \nmethod simply uses the == method on its arguments (checking for object identity); the toString() method \nreturns the class name appended with an @ and the object s hash code, and the hashCode() method produces \na hash code computed entirely from the immutable values of the .elds of the object. Note that the default \nObject.hashCode() method, as well as System.identityHashCode(), are global methods. Be\u00adcause their values \nchange unpredictably with each instance of an object, they can not be used to create repeatable static \n.elds. On the other hand, Mutable s hashCode() method can be used in computing a repeatable static. 4. \nCollective and Data-Parallel Operations Lime encourages programmers to use collective operations by making \nthem convenient and general. They are not in\u00adherently data parallel in that there is no explicit prohibition \nagainst using collectiveoperations with mutable types where there are dependencies between elements. \nThe semantics are de.nedasiftherewasanimplicit iteration(inorder)overthe subject collections. However, \ncollective operations applied in the presence of the value and local properties will reveal parallelism \nto the compiler without the need to analyze loops or perform interprocedural analysis. Collective operations \n(indicated by @ ) may be applied to operators, instance methods, and static methods. On in\u00ad.x and pre.x \noperators, the @ precedes the operator. On instance method calls, the @ takes the place of the . in the \nmethod call. On static methods, the @ appears next to a speci.c argument which is to supply the Collector \nas ex\u00adplained below. The &#38; operator de.ned in Figure 1 may actually be written more compactly as \nfollows: public unsigned<N> this &#38; unsigned<N> that { return new unsigned<N>(this.data @&#38; that.data); \n} The @&#38; pair is like a map operation in that it extends its subject operator ( &#38; ) to apply \n(in this case pair-wise) between all the elements of an array or collection. Collective operations may \nbe used with methods of any number of parameters, and the parameters may be a combi\u00adnation of either \ncollections of the parameter type, or single instances of the parameter type. In the latter case, the \npa\u00adrameter expression is evaluated exactly once and used as the argumentofevery individual operation.Forexample: \nstring[] v1 = { \"x\", \"y\" }; string[] v2 = v1@toUpperCase(); // v2=={\"X\", \"Y\"} int[]a1={ 1,2,3 }; int[]a2=a1@+ \n1;//a2=={2,3, 4} int[]a3=a1@+ a2; //a3=={ 3,5,7} If the arrays are not of the same size, a domain con\u00adformance \nexception is thrown. Lime s array types and the collection types supplied by Lime s development library \nall implement the appropriate interfaces to ensure participa\u00adtion. The interfaces are Indexable and Collectable. \nThe Indexable interface speci.es that the collection has some index value type and an indexing operator \nthat returns an object of the element type. Furthermore, it has a domain() method which returns an object \nthat allows iteration over all ofthevalid indicesofthe objects containedinthe collection.  The Collectable \ninterface extends Indexable with a method that returns a collector.Acollector is an object that is used \nto gather the results together to produce the new collection resulting from the operation.Acollector \nmust im\u00adplement the Collector interface which provides an indexed store operation to allow the individual \nresults to be collected, and a result() method that returns a new collection1 which must also be Collectable. \nData-parallelism. Acollective operation is data parallel if the elements are all values and the collector \nmeets the state\u00adful isolation requirements described in Section 3. The com\u00ad pilermaybeableto determine \notherdata parallel cases,but that is more dependent on the use of various optimizations that were not \nthe speci.c focus of this language feature. Reductions. Lime also provides facilities for perform\u00ading \nreduction, namely applying a binary operator, instance method or static method across the elements of \na collection to generate a single result of the element type. Reduction can be applied to any Iterable \nclass. The method must take two arguments of the same type and pro\u00adducea resultof that type. Thusan instance \nmethodofa class T must havethe signature T foo(T) anda static method must have the signature T foo(T,T).Areduction \nis indicated by the use of @@ as the examples below illustrate. inta={1,2, 3}; string[] fooletters = \n{ \"f\", \"o\", \"o\" }; // reduction with binary operators: int sum = @@+ a; // sum==6 string foo1 = @@+ \nfooletters; // foo1==\"foo\" // reduction with instance methods: string foo2 = fooletters@@concat; // \nfoo2=\"foo\" // reduction with static methods: int max = Math.max(@@a); // max==3 5. EnablingFeaturesfor \nStream Computing Tuples. Lime s model of stream computation is based on turning methods into compute \nnodesinagraph. This implies a way to turn the multiple arguments of a method into a single structure \nthat canbe transmitted.Asimilar needexists on the return side. Both goals are accomplished by Lime s \ntuple types.Tuples are shallowly immutable collections of heterogeneous objects. A tuple type is written \nas a comma separated parenthe\u00adsized listof types with an initial backtick.Tupleexpressions are similarly \nwritten. For example, `(3, \"foo\") is a tuple 1Itis usuallyof the same type as the original collection,but \nneed not be. expression of tuple type `(int, string).Atuple type is a value type if and only if all of \nits member types are value types since the tuple type itself only guarantees shallow im\u00admutability. Tuple \ntypes are anonymous and de.ned structurally. That is, two tuple type declarations that employthe same \ntypes in the same positions are the same type and will interoperate. The elements of a tuple can be accessed \nusing a dot ( . ) followed by a 0-based integer literal indicating its po\u00adsition in the tuple. Projection \nof multiple .elds may also be more succinctly expressed with a left-hand tuple of vari\u00adables. Element-wise \ntype compatibility and widening is pro\u00advided for tuples. These features are shownby the following: var \ntriple = -(1, 3.14159, \"blah\"); double pi = triple.1; // project one field -(a, b, c) = triple; // project \nall fields -(double, String) x = -(1, \"as\"); // 1 is widened -(long, Object) y = -(1, \"as\"); // \"as\" \nis upcast Closed World. Inalanguage designed bothtobeJavacom\u00adpatibleandto support directexecutionin hardware \nthereisa tension between the Java development model (separate com\u00adpilation, dynamic class loading, no \nclosed world assump\u00adtion) and the requirements of hardware (it is impractical to support dynamic class \nloading in an FPGA). Our strategy for generating hardware-related artifacts necessarily employs some \nclosed-world assumptions.With one notable exception, we accomplish these by extra lin\u00adguistic means: \nwe require that all Lime source and object artifacts be stored in a directory structure similar to the \nJava classpath.We supportversion-basedinvalidation and regen\u00aderation of hardware artifacts in our toolchain. \nTo avoid dynamic class loading in hardware, one must be able to explicitly seal parts of a class hierarchy \nso that the subtypes of a given class is .nitely enumerable during hardware synthesis. The necessary \nsupport takes the form of an extendedby keyword, which follows the standard Java extends and/or implements \nclauses of class and interface declarations. public interface Animal extends Comparable extendedby Cat, \nDog { ... } public final class Cat implements Animal { ... } public class Dog implements Animal extendedby \nHound, Poodle { ... } When an extendedby keyword is present on a type, the following consequences follow. \n1. Exactly the types listed must exist and must directly extend or implement (as appropriate) the present \ntype. 2. No other types mayextend or implement the present type.  It is expected practice that a type \nnamed in an extendedby clause but that does not itself have an extendedby clause will be final. If this \npractice is not followed, the compiler will issue a warning that the type extension subhierarchyis not \nclosed. Otherwise, hardware synthesis can proceed in a closedworld fashionbyexploiting closed types,which \nare types that are either final or extendedby a list of types all of which are closed.  It is never \nan error to write a Lime program that does not use extendedby. If used where appropriate, portions of \nthe program will have the necessary closed world property to increase the likelihood of ef.cient synthesis \nto hardware. 6. Task Programming Model Lime offers language features for expressing task, data, and pipeline \nparallelism. They are based on the creation of data.ow graphs that perform computation on streams of \ndata. The approach exposes algorithmic data-locality and communication topologies to a compiler that \ncan then de\u00adcide on the best implementation choices depending on the target platform.A data.ow graph, \nalso known asa stream graph, consists of nodes that perform computation and edges that imply an exchange \nof data between connected nodes. In Lime, nodes are tasks which read data from an input port, apply a \nworker method to the data, and commit the re\u00adsults to an output stream.Atask s worker method is applied \nrepeatedly as long as there are input data available on the port. A connected set of tasks form a closed \nworld if the types that can enter them from the outside (via initialization or via ports) are all closed \ntypes and there is no explicit re\u00ad.ection (e.g., Class.forName)in anyof the worker method. An example \nstream graph is illustrated in Figure 4. It de\u00ad scribes the processing steps required to decode a JPEG \nim\u00adage and convert it to an RGB bitmap. There are four pro\u00adcessing stages: bitstream parsing, channel \ndecoding, color space conversion and descrambling. The .rst stage parses an encoded string of bits to \nextract the decoding properties and the sequence of macroblocks comprising the image.A macroblock(mb)represents \nan 8x8 block of pixels from a particular color channel as a 64 pixel array. There are three color channels, \none for luminance (Y) and two for chromi\u00adnance (Cb and Cr). The parser produces a sequence of n macroblocks \narranged as (mbY 1 , mbCb , mbCr ) ... (mbY , mbCb , mbCr ). 11 nn n Each of the macroblocks is channel \ndecoded to reconstruct the original image2. The channel decoding consists of .ve steps: zigzag decoding, \nDC coef.cient decoding, inverse quantization, inverse discrete cosine transform, and value centering. \nEach of these steps is a function f : block . block where block is a bounded value array of 64 pixel \nvalues (i.e., pixel[[64]]). We can summarize the channel decoding using function composition as center \n. iDCT . deQuantize . dcDecode . zigzag which in an imperative programming style may be coded as shown \nin Figure3lines 11-18. The decode method applies the .ve transforms sequentially for every macroblock. \nThe 2JPEG encoding is usually lossy hence the reconstruction is approximate. 1 typedef pixel = unsigned<24>; \n2 typedef block = pixel[[64]]; 3 public class Channel { 4 static final Decode d = new Decode(); 5 private \nfinal Coefficient dc; 6 public final Quantization q; 7 public Channel(Color c) { 8 dc = new Coefficient(); \n9 q = new Quantization(c); 10 } 11 public block decode(block mb) { 12 return d.center(128, 13 Transforms.iDCT( \n14 q.deQuantize( 15 dc.dcDecode( 16 d.zigzag(mb))))); 17 } 18 } Figure 3. Lime pseudocode for JPEG decoder \nin an imper\u00adative programming style. transforms are stateless except for dcDecode which decodes the .rst \npixel of each macroblock relative to the value of the corresponding pixel in a previous macroblock. Each \nof the transforms is carried out by a local method that produces a value thatis consumedby another method.The \ncomposition of methods in this way lends itself well to pipeline paral\u00adlelism where each of the .ve methods \nis concurrently oper\u00adating on different (but successive) macroblocks in the same color channel as illustrated \nin Figure 4. However, the in\u00ad troduction of pipeline-parallelism in an imperative language is intrusive, \nrequiring the incorporation ofbuffering stages between method-calls or the use of other schemes that \nul\u00adtimately obfuscate the program. This in turn leads to rigid implementations that are dif.cult to modify \nor tune for per\u00adformance. In addition, the language semantics in an imper\u00adative programming model ensure \neager evaluation and the resultant code dictatesa speci.cexecution order or schedule that may not be \neasily ported between architectures. The JPEG example also affords opportunities for data parallelism. \nData parallelism is readily apparent from the stream graph: each color channel decoder may operate on \nits corresponding macroblocks independent of the other de\u00adcoders. In this case, threads could have been \nused to achieve coarse-grained parallelism. However, threads are often too heavy-weight an instrument \nfor this purpose. In general it is better to let the compiler or an independent scheduler decide how \nto assign computation to threads. Lime overcomes these challenges by introducing lan\u00adguage features that \nenable lazyevaluation, encapsulate com\u00adputation, abstract away communication, and provide strong isolation \nguarantees that make it feasible to realize scalable\n\t\t\t", "proc_id": "1869459", "abstract": "<p>The halt in clock frequency scaling has forced architects and language designers to look elsewhere for continued improvements in performance. We believe that extracting maximum performance will require compilation to highly heterogeneous architectures that include reconfigurable hardware.</p> <p>We present a new language, Lime, which is designed to be executable across a broad range of architectures, from FPGAs to conventional CPUs. We present the language as a whole, focusing on its novel features for limiting side-effects and integration of the streaming paradigm into an object- oriented language. We conclude with some initial results demonstrating applications running either on a CPU or co- executing on a CPU and an FPGA.</p>", "authors": [{"name": "Joshua Auerbach", "author_profile_id": "81100247226", "affiliation": "IBM Research, New York, NY, USA", "person_id": "P2354016", "email_address": "", "orcid_id": ""}, {"name": "David F. Bacon", "author_profile_id": "81100628167", "affiliation": "IBM Research, New York, NY, USA", "person_id": "P2354017", "email_address": "", "orcid_id": ""}, {"name": "Perry Cheng", "author_profile_id": "81451593218", "affiliation": "IBM Research, New York, NY, USA", "person_id": "P2354018", "email_address": "", "orcid_id": ""}, {"name": "Rodric Rabbah", "author_profile_id": "81100434259", "affiliation": "IBM Research, New York, NY, USA", "person_id": "P2354019", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869469", "year": "2010", "article_id": "1869469", "conference": "OOPSLA", "title": "Lime: a Java-compatible and synthesizable language for heterogeneous architectures", "url": "http://dl.acm.org/citation.cfm?id=1869469"}