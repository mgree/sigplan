{"article_publication_date": "10-17-2010", "fulltext": "\n Tribal Ownership Nicholas Cameron James Noble Tobias Wrigstad Victoria University of Wellington Victoria \nUniversity of Wellington Uppsala University ncameron@ecs.vuw.ac.nz kjx@ecs.vuw.ac.nz tobias.wrigstad@it.uu.se \n Abstract Tribal Ownership uni.es class nesting and object ownership. Tribal Ownership is based on Tribe, \na language with nested classes and object families. In Tribal Ownership, a pro\u00adgram s runtime object \nownership structure is characterised by the lexical nesting structure of its classes. We build on a variant \nof Tribe to present a descriptive ownership system, using object nesting to describe heap par\u00adtitions, \nbut without imposing any restrictions on program\u00adming disciplines. We then demonstrate how a range of \ndiffer\u00adent prescriptive ownership policies can be supported on top of the descriptive Tribal Ownership \nmechanism; including a novel owners-as-local-dominators policy. We formalise our type system and prove \nsoundness and several ownership in\u00advariants. The resulting system requires strikingly few anno\u00adtations, \nand uses well-understood encapsulation techniques to create ownership systems that should be intuitive \nfor pro\u00adgrammers. Categories and Subject Descriptors D.3.3 [Software]: Programming Languages Language \nConstructs and Features General Terms Languages, Theory Keywords Ownership types, virtual classes, nested \nclasses, family polymorphism 1. Introduction Ownership Types Ownership type systems statically im\u00adpose \nhierarchical structures onto the heap. By structuring the heap, compilers and programmers can reason \nabout small parts of it in isolation, which makes many otherwise in\u00adtractable analyses possible. Ownership \nlanguages often sup\u00adport encapsulation policies based on the heap structure (pre\u00adscriptive systems); \nthese might restrict references, modi.ca\u00adtion, or access. Alternatively, ownership information can be \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA/SPLASH \n10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright c . 2010 ACM 978-1-4503-0203-6/10/10. . . \n$10.00 used to describe the effects of computation without impos\u00ading any restrictions (descriptive ownership) \n[16]. Ownership types have been used to support memory management and garbage collection [10, 51], alias \nanalysis [2], veri.cation [25], concurrency [7, 24, 50], parallelisation [21, 18], real\u00adtime programming \n[46, 51], and more [2, 23, 9]. Ownership types tend to require substantial annotations to describe how \nindividual .elds and methods relate to the ownership hierarchy. These annotations can be confusing, and \nhave negative side-effects on refactoring and program maintenance. Furthermore, because the annotations \nprimar\u00adily decorate individual methods and .elds, it can be dif.cult to see how each class or object \n.ts into the ownership struc\u00adture as a whole. In this paper we present an ownership system based on virtual \nclasses that does not require any additional annota\u00adtion, and, by making the ownership structure explicit \nin a program s class structure, should be easier for programmers to use and understand. Virtual Classes \nVirtual classes allow families of classes to be inherited, rather than just single classes. In a language \nwith virtual classes, classes are lexically nested inside other classes. When a class is inherited, its \nnested inner classes (and the relationships between them) are inherited along with its methods and .elds. \nVirtual classes allow programs to express types such as all nodes of any graph , all nodes belonging \nto the graph g , and this particular node in this particular graph , and to distinguish between them \nstatically. Virtual classes are a powerful and intuitive mechanism which are beginning to appear in practical \nprogramming languages [36, 12]. We expect virtual classes to become more mainstream; our proposal uses \nvirtual classes to bring the considerable bene.ts of ownership types to a language at low additional \ncost. Our Contribution In this paper we describe Tribal own\u00adership, an ownership types system built on \na variant of the virtual class calculus Tribe [19]. Our language has no ad\u00additional syntax to support \nownership, only the usual syn\u00adtax used to support virtual classes. In Tribal Ownership, the object ownership \nand nested class hierarchies coincide. By unifying these hierarchies we make the ownership hierarchy \nmore apparent in source code and the system easier for pro\u00adgrammers to understand. In our proposed system, \nall instances of a class are owned by the object which encloses that class. Since this object is already \ntracked by the type system, no additional annotations are required to enforce ownership. Flexibility \nis provided by allowing classes to be imported into a different class, and so take instances of the importing \nclass as owners. We show how different encapsulation policies can be enforced on top of the descriptive \nTribal Ownership sys\u00adtem. Additionally, we present a new variation on the stan\u00addard owners-as-dominators \npolicy that enforces owners-as\u00addominators locally within isolated sub-heaps, whilst giving full access \nto other areas of the heap. In summary, the contributions of this paper are: A new variant of the Tribe \nlanguage with simpler types, cross-family inheritance, and generics. We believe this variant is easier \nto program with and understand than the original version of Tribe. We also contribute a new for\u00admalism \n(in which, formalising cross-family inheritance was the main challenge) and type soundness proof.  The \n.rst formalisation of ownership types using virtual classes (Tribeown), and a proof that the ownership \nhierar\u00adchy is preserved by our type system.  Formal and informal descriptions of several different en\u00adcapsulation \npolicies built on top of Tribal ownership.  The novel encapsulation policy owners-as-local-domin\u00adators, \na .exible policy which subsumes owners-as-domin\u00adators. We prove that this property is enforced by our \nfor\u00admalism.  Organisation We give background on the Tribe language in Sect. 2. We describe our new variant, \nTribeown, its formal\u00adisation, and soundness proof in Sect. 3. We describe how this system supports descriptive \nownership, and extend our for\u00admalism in order to prove sound ownership typing in Sect. 4. We describe \nhow encapsulation policies can be encoded in Tribeown and describe and formalise our new encapsulation \nproperty owners-as-local-dominators in Sect. 5. We cover re\u00adlated work in Sect. 6, and further work and \nour conclusions in Sect. 7. 2. Tribe Tribe (along with many other languages following on from BETA [37]) \nsupports nested virtual classes. As with Java s (non-static) inner classes, Tribe s nested class declarations \nlead to nested objects at runtime. Consider the following simple example, inspired by [40]:  Figure \n1. Nesting structure of nested classes class University { class Student {...} class Course { class RawMark \n{...} this.Map<this.out.Student, this.RawMark> marks_map = ...; } } This code de.nes a University class \nwith two nested classes inside it: one class for modelling Students, and another for modelling Courses. \nEach Course object has a RawMark class, representing the private, unmoderated marks for each course, \nand a Map which relates students to their raw marks. Figure 1 shows how the lexical structure of the \nclass de.nitions imposes a nesting relationship on the classes. The marks map .eld maps students (this.out.Student, \ni.e., student objects from the enclosing university object) to raw marks (this.RawMark). The respective \ntypes re.ect that Student is de.ned one level out in the nesting hierarchy, and RawMark is de.ned inside \nthe current class (Course). 2.1 Nested Objects Fig. 2 shows an example of how these nested classes could \nbe instantiated at runtime. The outermost University class is instantiated twice, with one instance representing \nVUW and the other representing Uppsala . Nested inside each university object are a number of different \nobjects, instances of the Student and Course classes. Just as the Student and Course class declarations \nare nested inside the declaration of the University class in the program source code, so the various \nStudent and Course instances are nested inside the University object to which belong. Going further down \ninside the VUW course SWEN221, inside that course object are Map and three RawMark objects. Being nested \ninside another object has no effect on references between objects: the Map refers to those three RawMarks \nand also to three students who  Figure 2. Objects instantiating nested classes are presumably taking \nthose courses (and have the associated raw marks) but who are outside the Course object. In Tribe, inner \nclass instances maintain a runtime refer\u00adence to their enclosing object: this is written out . So out \nfor Mats, Lars, and 1DL240 is the Uppsala object; while out for Amy, Nick, Alli, SWEN423, and SWEN211 \nis the VUW ob\u00adject. This is illustrated in Fig. 3. Note the ? on the dotted line from Map to Uppsala, \nwhich we will return to when dis\u00adcussing cross-family imports later. The out above is the same out used \nin de.ning types: conceptually, the types of the inner classes are also nested within their enclosing \nobject. Every object anchors a class family: objects in the class are only compatible (related by subtyping) \nwith objects in the same family. So the courses and students in each university are different types from \ndif\u00adferent families: a VUW student cannot enroll at an Uppsala course, and vice versa [29, 19].  2.2 \nFamily Polymorphism Tribe supports a powerful notion of inheritance which al\u00adlows groups of classes to \nbe extended together, preserving the relationships between classes. Nested classes can be in\u00adherited \nor overridden along with a superclass s .elds and methods. This is known as family polymorphism [29], \nand supports sophisticated implementations for design patterns and the expression problem [48, 47]. The \nfollowing example shows how a Conservatorium a stand-alone music school can be implemented by inheriting \nfrom a University: class Conservatorium extends University { class Student {this.out.Instrument major; \n...} } class Instrument {...} Because they include nested inner classes, University and Conservatorium \nde.ne two class families, which are related by inheritance. So, Conservatorium will not only inherit \nFigure 3. Paths from nested to enclosing objects. methods and .elds from University, but also University \ns Course and Student classes. Because every conservatorium student must major in a musical instrument, \nConservatorium. Student further binds University.Student: adding in a major .eld of type Instrument. \nThis is called further bind\u00ading because by class family inheritance, a Conservatorium. Student (i.e. \nthe Student class declared within Conserv\u00adatorium) will also gain all the .elds and methods from the \nUniversity. Student student and any inner classes too! Subtyping in Tribe follows from subclassing, \nbut not fur\u00adther binding. For example, Conservatorium is a subtype of University; but Conservatorium. \nStudent is not a subtype of University.Student 2.3 Tribe Types Tribe uses path dependent types to distinguish \nclasses which belong to different families. For example, assuming the variables University u and Conservatorium \nc, the type c.Course is not a subtype of u.Course, because u and c might refer to different objects. \nObject family types consist of a path to an object and the name of a class de.ned by that object. Paths \nstart at a variable (often this) and have steps using .nal .elds or the out keyword (which denotes a \nclass s enclosing object). For example, in an object with type u.Course, the path this.out, will refer \nto a University ob\u00adject, in an object of type c.Course, the same path will refer to a Conservatorium \nobject. Tribe types form a spectrum: from singleton types which consist of a path only and denote a speci.c \nobject; object family types which represent instantiations of a class nested in a speci.c object; to \nabsolute types which specify only the class. In our running example, u is a singleton type denot\u00ading \nthe speci.c university object referred by the variable; u.Course is an object family type denoting any \ncourse in u, and the absolute type University.Course is any course in any university. Subtyping only \noccurs within an object family: u.Course is a subtype of u.Course (by re.exivity), but u1.Course is not \na subtype of u2.Course; all three types are subtypes of their corresponding absolute type, University.Course \n(assuming u, u1, u2 are instances of University). Tribe is not only expressive, but intuitive: nested \nclasses are easy to understand, families of classes are a natural unit of code, and paths are familiar \nfrom Java programming. 3. Tribeown Our goal has been to support ownership types in a virtual classes \nlanguage. We chose Tribe as our base language be\u00adcause of its .exible types, elegant and fairly standard \nfor\u00admalism, and because the type system is amenable to cap\u00adturing ownership information. Supporting object \nownership in Tribe is not trivial, however: we had to improve support for cross-family inheritance (described \nbelow in Sect. 3.2), change some aspects of the formalisation (Sect. 3.3) and add ways to reason about \nand enforce ownership properties (Sect. 4 and Sect. 5). We call our variant language Tribeown. In Tribeown, \nwe take the hierarchy of nested classes as the ownership hierarchy. An object s owner is its enclosing \nobject. For any type T, T.out (the type of the enclosing object) is the owner of objects with type T. \n 3.1 Path Types and generics Tribeown has a more restrictive syntax of types than Tribe: we disallow \nthe use of .nal .eld names in types and restrict the ordering of the components of types, in effect, \nimposing a normal form for types. This is necessary to conceptualise and prove some ownership properties \n(discussed in Sect. 4). It also simpli.es our formalisation. Tribe types have syntax x.(ff | out | C)*, \nwhere x includes this and the outermost world object, world, ff is the name of a .nal .eld, and C is \na class name. Tribeown types have the form x.out*.C*; that is, a path which starts at a variable, then \ngoes outward some number of steps, and then inward by some number of class names. We support absolute \ntypes (where the path starts at world and has no outward steps), singleton types (where there are no \nclass names), and all types with an intermediate level of precision (e.g., this.out.C.D). We do not support \ntypes with .elds1 or types which have an outward step from a class name. Types of the latter case can \nbe represented in Tribeown by using the equivalent type, which has neither class name nor outward step, \ne.g., x.D for x.C.out.D. To make up some of the expressivity lost by removing .elds from types, we introduce \nsimple type genericity. For now, we only support unbounded generics on classes and 1 We found .eld types \nuncommon in our experience, and often restrictive because the Tribe type system cannot associate .elds \nused in types with the values instantiating the .elds; e.g., even if x.f = y, there is no relation\u00adship \nbetween y.C and x.f.C. types. Generic methods should be easy to support and are elided. Bounded and \nvariant generics are left for future work. 3.2 Importing Module Classes Tribeown supports cross-family \ninheritance through module classes. Module classes restrict external dependencies by forbidding the use \nof out in their de.nitions. Since module classes do not have any external dependencies, they (and their \nnested classes) can be imported arbitrarily. As the code example below shows, Map is a module class, \nand therefore cannot name any external object. Hence, the dotted-line from Map to Uppsala in Fig. 3, \ncannot exist. Module classes may only extend other module classes. We elaborate the example from Sect. \n2: module Collections { class List<X> {...} class Map<K, V> {...} } class University { ... class Course \nimports Collections{ ... this.Map<this.out.Student, this.RawMark> marks_map = ...; } } Importing a module \ngives subtyping: in the example above, Course is a subtype of Collections and Course. List<Uni\u00adversity> \nis a subtype of Collections.List<University>. Module classes are reminiscent of mixin modules, which \nlack a super class, except that the dependency is on nesting rather than on subclassing. In our formalism \n(described below), out is modelled as a distinguished .eld. A module class is simply a class which does \nnot de.ne an out .eld. Thus, we check whether an out .eld is de.ned or not to check if a class is a module, \nand can thus be imported. Cross-family inheritance via module classes allows Tribeown to have a single \ntop type. Tribe lacks a top type each class has a nested Object class which is unrelated to other Object \nclasses. We assume a module class Root nested directly inside world which contains an Object class. All \nclasses (including world) implicitly import Root, and all classes without explicit superclasses are implicit \nsub\u00adclasses of the adopted Object (a local top type). Every local Object is a subtype of Root.Object, \nwhich is thus a top type for Tribeown. We can, therefore, describe any ob\u00adject nested within an object \nor class using a local Object (e.g., x.Object is the superclass of all classes nested in x) and describe \nall objects using Root.Object. A top type is useful for describing variables to be used as owners and, \nhypothetically, for bounds on type variables. Tribe did not support cross-family polymorphism, al\u00adthough \nan adoption mechanism was proposed (but not proved sound) which addressed some of the same motiva\u00adtions. \nModule classes are a more developed solution: we formalise their interaction with subclassing and subtyping, \nand include them in our soundness proof.  3.3 Formalisation Our formalisation of Tribeown borrows heavily \nfrom the Tribe formalism. Differences re.ect differences in the lan\u00adguage design, some simpli.cations, \na focus on ownership rather then general language design, and differences in style. Our formalism is \nin the Featherweight Java [32] mould. Languages with multiple inheritance (including Tribeown and Tribe) \nmust deal with the possibility of ambiguous lookup, where .elds and methods with the same name are inherited \nfrom several different superclasses. Tribe sidesteps this problem by non-deterministically selecting \none. This is not an issue for soundness because all methods inherited by a class with the same name, \nmust have the same type. We go a step further and do not even guarantee that a method from the most speci.c \nclass will be executed, only that some inherited method will be executed. Although this decision would \nbe impractical in a real language, it does not affect our soundness result because our (non-deterministic) \ncalculus is more general than a corresponding language with determin\u00adistic dispatch. In a practical implementation, \nwe can select from a variety of solutions, e.g., forcing the programmer to manually resolve ambiguities. \nSyntax The syntax of Tribeown is de.ned in Fig. 4. Ele\u00adments in grey may appear during evaluation, but \nmay not be written by a programmer. The syntax of expressions will be described when we cover their type \nrules. The key feature of class declarations is that they may include nested classes. We use < for extends \nand v for imports . The former indicates subclassing, the latter importing a module. We dis\u00adcuss public \nand private classes in Sect. 5. We treat this as a distinguished variable and out as a distinguished \n.eld. Environments (G) can contain mappings from variables to their types, type variables (showing which \ntype variables are in scope), and a heap (HG, used as an environment for type checking runtime expressions). \nOur rules make use of substitution. Because of the .ex\u00adibility of types in Tribe, any type can be substituted \nfor a variable in a type and give a syntactically valid type. This is not the case in Tribeown; for example, \n[y.C/x]std x.out.D gives y.C.out.D which is not a Tribeown type (it is valid in Tribe). To address this, \nwe de.ne substitution in a non\u00adstandard way in Fig. 5. In this .gure we use [...]std to mean standard \nsubstitution. Tribeown substitution is thus de\u00ad.ned to normalise ill-formed types into Tribeown types \nby matching and eliminating outs with class names. For exam\u00adple, [y.C/x]x.out.D is de.ned to give y.D \nin Tribeown, and [y.out.C/x]x.out.D to give y.out.D. Inheritance Tribeown has two forms of inheritance: \nsub\u00adclassing and further binding. These relations (between ab\u00ad e ::= null | p | ..f | ..f = e expressions \n| let x:T = e in e | ..m(.) | new ..N | err v ::= null | world | . values P ::= Q e programs Q ::= a \nclass C<X> < N v A {QT f; M} class declarations a ::= public | private naming modi.ers M ::= T m(T x) \n{return e;} method declarations s ::= . | world path starts p ::= s | p.out paths N ::= C<T > instantiated \nclass names P ::= p | P .N path types T , U ::= P | X types A ::= world | A.N absolute types r ::= world \n| . runtime paths R ::= r.C<R> runtime types G ::= \u00d8| G, .:T | G,X |HG environments . ::= x | . variables \nor addresses H ::= \u00d8 |H,. .{R; f.v} heaps x, this variables X type variables C, D, Object class names \nf,out .elds Figure 4. Syntax of Tribeown. [T /.]stdT ' ' = p.C.out.C|C| = |out|[T /.]T ' = p.C' Figure \n5. Type subsitution in Tribeown. solute types) are de.ned in Fig. 6. The auxiliary function P(de.ned \nin Fig. 9) looks up the de.nition of a class in the program, taking into account type substitution. Sub-classing \nre.ects the relationship between classes denoted by the programmer using the extends keyword (SC-SUBCLASS). \nWhen a class is inherited, the subclass relationships be\u00adtween its child classes are also inherited (SC-NEST). \n(SC-IMPORT) accounts for subclassing due to imported modules. Further binding is the implicit inheritance \nof child classes when a surrounding class is inherited (FB-NEST). For con\u00adcreteness, B.C further binds \nA.C and subclasses B.D in the following: class A{ class C {} } class B extends A{ class D {} class C \nextends D {} }  Subclassing f A Ls A a class C<X> < N ... .P(A) f A.C<T > Ls A.[T /X]Ni (SC-SUBCLASS) \nP(A) de.ned ' f A Li A ' f A ' .N Ls A ' .N ' f A.N Ls A.N (SC-NEST) a class C<X>...y A ... .P(A) f A.C<T \n> Ls [T /X]Ai (SC-IMPORT) Further Binding f A Lf A f A Li A ' a class C<X> ... .P(A ') f A.C<T > Lf A \n' .C<T > (FB-NEST) Inheritance f A Li A f A Ls A ' f A Lf A ' f A Li A ' f A Li A ' (I-SC) (I-FB) Figure \n6. Tribeown inheritance and subclassing. Well-formed and absolute types An absolute type (A) de\u00adscribes \nan object by a path from the world program root, down through the class tree, for example, world.C.D. \nThe judgement G f P . A holds if A is an absolute type for all objects of type P . A non-variable type \nin Tribeown is well\u00adformed if a corresponding absolute type can be derived. Ab\u00adsolute types and well-formed \ntypes are de.ned in Fig. 82. The rules that de.ne absolute types are a combination of standard well-formedness \nrules for languages such as FGJ [32], and an inductive navigation of the nested class hierar\u00adchy3. Well-formed \nheaps are de.ned in the same .gure. A heap is well-formed if each object in it has a well-formed runtime \ntype, a sensible out .eld, and all other .elds are well-typed. Subtyping Subtyping rules are given in \nFig. 7. Subtyping follows from subclassing and importing ((S-SUBCLASS) and (S-IMPORT)), and the expected \nsemantics of out (S-OUT-2). 2 The fType auxiliary function looks up the type of a .eld and is de.ned \nin Fig. 9. 3Compared to Tribe, we require an inheritance premise in (A-CLASS) (as well as (SC-NEST)) \nbecause we do not have a cls judgement which takes inheritance into account. Subtyping G f T <: T G \nf T1 <: T3 G f T3 <: T2 G f T<: T G f T1 <: T2 (S-REFLEX) (S-TRANS) ' G f P . A G f P<: P '' f A.N Ls \nA.N G f P .N OK '' G f P .N <: P .N G f P .N <: P .N (S-SUBCLASS) (S-NEST-CLASS) G f p . A.N G(.)= P \nfType(out,A.N) de.ned G f .<: P G f p<: p.out.N (S-VAR) (S-OUT-2) ' G f P<: P ' G f P . A G f P . A ' \nfType(out,A ') de.ned G f [P /x]x.out <: [P ' /x]x.out (S-OUT-NEST) G f P . A ' f A ' .* A.C<T > i a \nclass C<X>...y A ... .P(A) G f P<: [T /X]Ai (S-IMPORT) Figure 7. Tribeown subtyping. Variables may be \nused as types; subtyping re.ects that a variable s type is a less accurate way to describe the variable \nthan the variable itself (S-VAR). Types denote sets of objects, and a subtype is a smaller set of objects; \n(S-NEST-CLASS) and (S-OUT-NEST) re\u00ad.ect that we can go up or down the nested class hierar\u00adchy and preserve \nthis smaller set of objects concept. (S-OUT-NEST) must use substitution rather than plain nest\u00ading (that \nis, [P /x]x.out rather than P .out) to account for types which are semantically out but do not use the \nout keyword. Furthermore, we take advantage of the de.nition of Tribeown substitution. For example, we \ncan derive that x.out is a subtype of world.C, if we can derive that x is a subtype of world.C.D. By \nusing (S-OUT-NEST) in this way, (S-VAR), and (S-NEST-CLASS) we can derive that any type is a subtype \nof its absolute type, and so the rule (S-ABS) of Tribe is admissible in Tribeown. Type checking Auxiliary \nfunctions are de.ned in Fig. 9. We de.ne .eld type, and method type and body lookup functions and the \nlookup function method, which checks if a method is de.ned. These are all de.ned declaratively using \nthe inheritance relation, as opposed to the usual inductive Absolute types G f P . A G(.)= P G f P . \nA G f . . A G f world . world (A-VAR) (A-WORLD) G f p . A.N fType(out,A.N ) de.ned G f p.out . A (A-OUT) \n* A ' G f P . A f A i a class C<X> ... .P(A ') |T | = |X| G f T OK G f P .C<T > . A.C<T > (A-CLASS) Well-formed \ntypes G f T OK G f P . A X . G G f P OK G f X OK (F-PATH-TYPE) (F-TYPE-VAR) Well-formed heaps fH OK .. \n.{. ' .C<R>; f.v}.H fi = out . vi = . ' Hf . ' .C<R> . A fType(f,A)= T Hf v : [./this]T fH OK (F-HEAP) \nFigure 8. Tribeown well-formed types and heaps. formulation [32] or using class tables [19, 42]. Finally, \nAH .nds the absolute type of an address in the heap. Rules for type checking Tribeown are given in Fig. \n10. (T-SUBS), (T-LET), and (T-NULL) are standard. A variable (or world) type checks (T-VAR) if it is \na valid type. A vari\u00adable s minimal type is that variable itself; the type recorded in the environment \ncan be used by subsumption. (T-FIELD), (T-ASSIGN), and (T-INVK) lookup the absolute type of the receiver \nand use that absolute type to look up the type of the .eld or method; otherwise, they are mostly standard. \nOf note in these rules is the substitution of the receiver for this (and similarly for the arguments \nin (T-INVK)), this (and arguments) may appear in Tribeown types and must be substituted away accordingly. \n(T-NEW) requires a re\u00adceiver which is unusual for object-oriented languages with\u00adout nested classes: \nit allows the precise class to be instan\u00adtiated to be determined statically. We require receivers and \nactual parameters to method calls to be variables, this sim\u00adpli.es substitution. We do not lose expressivity \nbecause we can use let expressions to create local variables as needed. If we create a local variable \nwith a path, then we can use that P = Q e a class C<X> ... {Q ...} .P(A) P(world)= Q P(A.C<T >)= [T /X]Q \n* f A i A ' .C<T > a class C<X> ... {QU f; M } .P(A ') fType(fk, A)= [T /X]Uk * f A i A ' .C<T > ' a \nclass C<X> ... {QU f; M} .P(A ') U m(U x) {return e;} . M mType(m,A)= [T /X].x:U.U mBody(m,A)=(x; [T \n/X]e) method(Mk,A) public(world) * A ' f A i public class C<X> ... .P(A ') public(A.C<T >) AH(world)= \nworld H(.)= {r.N; ...} AH(.)= AH(r).N Figure 9. Auxiliary functions for Tribeown. path as a type so \nthe type system can be aware of the relation between variable and path. Rules for type checking programs, \nclasses, and methods are given in Fig. 11. The absolute type of this is kept up to date in the environment \nby (T-CLASS) and (T-PROG). Elements of a class (methods, .eld types, classes, super\u00adclasses, etc.) are \nchecked to be well-formed. We also check that imported modules are in fact modules, that is, they do \nnot have an out .eld. We check that overriding methods have matching types with all methods they override. \nMethod type checking is standard, other than that return and argument types may include the names of \nformal arguments and this. Operational semantics We give a large step operational semantics for Tribeown \nin Fig. 12; rules for handling error conditions are standard and are relegated to the accompany\u00ading technical \nreport [15]. Despite the complexities of virtual class languages and ownership, all semantics rules are \nstan\u00addard for object-oriented formalisms. In (R-NEW), we ini\u00adtialise .elds to null and set the out .eld \nto the new object s surrounding object. 3.4 Properties We prove preservation (subject reduction) for \nTribeown, this states that reduction preserves the type of expressions: Expression typing G f e : T \n'' G f e : T G f e : T ' '' G f T<: T G, x:T f e : T G f T OK G f T OK ' G f e : T G f let x:T ' = e \nin e : T (T-SUBS) (T-LET) G f . . A G f . . A fType(f,A)= T f= out fType(f,A)= T G f e : [./this]T G \nf ..f : [./this]T (T-FIELD) G f ..f = e : [./this]T (T-ASSIGN) G f T OK G f null : T (T-NULL) G f s OK \nG f s : s (T-VAR) G f ..N . A.N G f new ..N : ..N (T-NEW) G f . . A G f . : [./this,./x]T mType(m,A)=.x:T \n.T G f ..m(.) : [./this,./x]T (T-INVK) Figure 10. Tribeown expression typing rules. Theorem: preservation \nfH OK, Hf e : T,e; H . '' e ' ; H ' ,e err .f H ' OK,e = v, H ' f v =: T . Proof is by structural induction \non the derivation of e; H . e . ' ; H ' The proof of this theorem and supporting lemmas are given in \nthe accompanying technical report [15]; the proof struc\u00adture mostly follows [19]. 4. Tribal Topologies \nIn this section we will show how Tribeown can be used as a descriptive [14, 16] ownership system for \nfree that is, without any additional program annotations or formal rules. In the next section we will \nshow how a range of different prescriptive ownership policies can be supported by the same underlying \ndescriptive Tribeown type system separating ownership policies from the mechanisms that implement them \n[1]. The key insight is that the nesting of classes in objects, used in Tribeown to support family polymorphism, \nis pre\u00adcisely the information needed to support descriptive owner\u00adship. Lexically, classes are nested \nin other classes; seman\u00adtically, classes, and their instantiations, are nested under an Program typing \nfP OK this:world f Q OK this:world f e : T + is acyclic i f Q e OK (T-PROG) Class typing G f Q OK G(this)= \nA ' G' = G[this . A ' .C<X>], X G' f A ' .N, A, Q, T , M OK .A . A. fType(out,A) unde.ned fi = out . \nTi = this.out ' .M, M .{M|method(M, A ' .C<X>)}. override(M, M ') * a = private ..A st f A ' .C<X> A. \n\u00acpublic(A) i G f a class C<X> < N y A {QT f; M} OK (T-CLASS) Method typing G f M OK G, x:T f e : T G, \nx:T f T ,T OK G f T m(T x) {return e;} OK (T-METHOD) M = T m(T x) {return e;} ' ' M = T m(T x) {return \ne ;} override(M, M ') (T-OVERRIDE) M = T m(T x) {return e;} ' '' ' M = T m ' (T x ' ) {return e ;} ' \nm = m ') override(M, M (T-OVERRIDE-NE) Figure 11. Tribeown typing rules for classes and methods. object: \nthe owner of those instantiations. This nesting of ob\u00adjects is our ownership hierarchy. The owner of \nan object (or an approximation to the owner) can be derived from its type. For object family types, the \nowner is the path part, for example, the owner of x.C is x, the owner of this.out.C is this.out, and \nthe owner of world.C is world. Variables with singleton (path) types can only hold the object indicated \nby the singleton type, there\u00adfore the owner of objects with singleton type is the owner of the path; \ne.g., the owner of objects with type x.out is x.out.out. If the type is a variable, then we can .nd a \nmore precise owner by examining the type of the variable. For example, if x has type y.C, then an object \nwith type x will have owner y or x.out, and these two paths will always denote the same object. We know \nthey denote the same object because they are subtypes (y is a subtype of x.out by rules (S\u00ad Computation \ne; H v; H H(.)= {T ; f.v} v; H v; H ..fk; H vk; H (R-VAL) (R-FIELD) ' ; H '' e; H v; H ' [v/x]e ' ; H \n' v ' ; H '' let x:T = e in e ' ; H v (R-LET) f = {f|fType(f, AHn (r).N) de.ned} H ' = Hn,. .{r.N; out. \nr, f.null} new r.N; H .; H ' (R-NEW) e; H v; H1 H1(.)= {R; f.v} H ' = H1[. .{R; f.v[fk . v]}] ..fk = \ne; H v; H ' (R-ASSIGN) e; H r; Hn mBody(m, AHn (.)) = (x; e) [./this,r/x]e; Hn v; H ' ..m(e); H v; H \n' (R-INVOKE) Figure 12. Tribeown reduction rules. VAR) and (S-OUT-NEST)) and path types that are subtypes \nalways denote the same object (which is obvious since their interpretation are singleton sets, and the \ninterpretation of subtyping is subset). For other types, we cannot say what the precise owner is. This \nis clear if we consider, for example, objects with type x.Course.RawMark that denote any RawMark object \nin any Course object in x. We say that the owner type of x.Course.RawMark is x.Course. In general, an \nowner type in Tribeown can be any non\u00advariable type; if the owner type is not a path, then it does not \ndenote a speci.c owner. Non-path owner types represent partial information about the actual owner, and \nare similar to existential [14, 49] or variant owners [35]. Subtyping between owner types can be used \nto identify types that refer to the same owner or set of owners, or refer to a more precise owner type. \nFor example, if x is a subtype of y.C then the owner type x is a single owner and y.C describes a group \nof owners which includes x. An owner type is not de.ned for all types. Because mod\u00adule classes can be \nimported into any other class, objects with module type may have any owner. Therefore, types which indicate \na module class do not have de.ned owner types; for example, world.Collections cannot be assumed to have \nowner world, because it may be imported into some other Owner relation G f P . P G f P . A fType(out,A) \nde.ned G f P . [P /x]x.out (O-OWNER) Inside relation G f P -: P '' '' G f P<: P G f P . A G f P -: P \n'' ' fType(out,A) de.ned G f P -: P '' G f P -: P G f P -: P (I-SUB) (I-TRANS) G f p -: p.out G f P .N \n-: P (I-OUT) (I-CLASS) H(.)= {r.N; ...} Hf . -: r (I-RUNTIME) Figure 13. Tribeown owner function and \ninside relation. class with a different owner; if world.Collections is im\u00adported into some non-module \nclass C with owner x then x.Collections will have owner x, as usual. Note also that world does not have \nan owner, because it is the top level of nesting. We use the judgement G f T . P to .nd the owner (P \n) from a type (T ). The owner judgement is de.ned in Fig. 13. Within a class, out can be used to name \nthe current object s owner in types and expressions. We .nd the owner by leveraging Tribeown substitution: \nwe attempt to append out and Tribeown substitution gives us the result described informally above. We \nmust, of course, check that out is de.ned in the given type. At runtime, we can .nd an object s owner \nby observing its object record in the heap. The object record stores an object s runtime type which is \nan object family type, the owner can be found in the usual way. The owner can also be found by looking \nat the value in the object s out .eld, these two approaches will give the same result in a well-formed \nheap. By observing that each object in the heap is de.ned as having a single owner, and that the resulting \nowner relation between objects in the heap is acyclic (because the owner must be present in the heap \nat the time an object with that owner is created), we deduce that owners in the heap form a tree. Therefore, \nour ownership system describes an hierar\u00adchical topology for the heap. We prove below that the topol\u00adogy \ndescribed statically by the type system is sound with respect to the runtime heap topology. 4.1 The \nInside Relation We de.ne the inside relation [40] for owner types in Tribeown in Fig. 13. The inside \nrelation is re.exive (given by (I-SUB) and (S-REFLEX)) and transitive. Since subtyping indicates more \nprecise descriptions of the same owner-type, subtyping between two owner types gives an inside relation4. \nRules (I-OUT) and (I-CLASS) describe stepping outward or inward one step in the nested class hierarchy, \nwhich corresponds to one step outward or inward in the ownership hierarchy. (I-RUNTIME) is used to compute \nthe inside relation for dy\u00adnamic owner types and is based directly on the structure of the heap. 4.2 \nImported Module Classes Having owners de.ned by the lexical nesting of classes could limit reuse, for \nexample, a programmer would need to write a new list class nested inside every class which needs to own \na list. Reuse of classes by importing modules is thus crucial for creating a practical ownership system. \nImporting a module not only allows the code to be reused, but also allows the importing class to own \nthe imported classes. To the best of our knowledge, this feature is not found in other virtual classes \nlanguages. For example, module Collections { class Map<K, V> {...} } class University { ... class Course \nimports Collections{ ... this.Map<this.out.Student, this.RawMark> marks_map = ...; } } Here, the .eld \nmarks map is an instance of Map owned by the current instance of Course.  4.3 Discussion In most ownership \nsystems, an object may be owned by any other object in the program and the owner is independent of the \nobject s class. Classes are declared in a .at topology and there is no direct indication of the ownership \nhierarchy in the source code. In Tribeown, an object s place in the own\u00adership hierarchy is determined \nin part by the hierarchy of nested classes. Although the owner of each object may be different, the class \nof the owner is determined by the owned object s class. That is, while objects of the same class may \nbe owned by different owners, the objects will be on the same tier of the ownership hierarchy and their \nowners will have a single class. Furthermore, objects of different classes are 4 In fact, it indicates \na re.exive relationship with respect to the inside relation, if we offered a single step (irre.exive, \nintransitive) version of the inside relation, then the rule (I-SUB) could not be used. guaranteed to \nhave different owners. Analogously to vari\u00adance annotations [13], more of the ownership information in \nTribeown is de.ned where a class is declared, compared to other ownership systems where all ownership \ninformation is de.ned where classes are used. In Tribeown the nesting of classes speci.es the topology \nof objects in the same way as individual classes specify the structure and behaviour of individual objects \nin class-based object-oriented languages. 4.4 Tribal Effects To show that our descriptive ownership \nsystem is useful, we have used it to de.ne an effect system [45] for Tribeown. The nested-ness of Tribeown \nis used to de.ne computational effects without extra ownership or regions notations. This should make \neffects systems accessible and attractive to programmers. We offer the formalised effect system without \nproofs in our technical report [15]. Our effects can describe a single object (by using a sin\u00adgleton \ntype and an exact annotation), a single object and its transitive representation (by using a singleton \ntype), a con\u00adtext (exact, non-singleton type), or a context and all contexts under it (non-singleton \ntypes). Effects can be combined. The sub-effect relation follows from the subtype and inside rela\u00adtions. \nOur effect assignment rules are mostly standard and we expect the usual rules for disjointness of effects \n[18] to apply. Therefore, Tribal effects could be used to support par\u00adallelisation of Tribeown code [18, \n5]. 4.5 Properties We prove that ownership in Tribeown is sound; that is, the owner given by an expression \ns static type corresponds to the owner, found in the heap, after evaluating that expression. This result \nis necessary for supporting an effect system or other application of descriptive ownership. Theorem: \nReduction preserves owners fH OK, Hf e : T,e; H .; H ' , Hf T . P .H '(.)= {r.C<...>; ...}, H ' f r<: \nP This theorem follows straightforwardly from our preser\u00advation theorem (see Sect. 3.4) and the following \nlemma. Lemma: Subtyping preserves owners G f P<: ''' ' P, G f P . P . G f P . P0, G f P0 <: P 00. Proof \nis by structural induction on the derivation of the subtyping judgement. In Tribeown different paths \ncan point to the same object, thus a single owner can be denoted by different types. We formalise this \nfact using subtyping: p and p ' denote the same ' object if and only if p is a subtype of p or p ' is \na subtype of p. This statement only makes sense if subtyping monotonically increases precision of types, \nwe prove this as a lemma to support our ownership soundness argument: Lemma: Subtypes are more precise \nG f T<: p . ' T = p and G f T<: ..N . T .{p, p.N ' }. Proof is by structural induction on the derivation \nof the subtyping judgement. 5. Encapsulation In this section, we show how encapsulation policies can \nbe enforced in Tribeown by building on top of the descriptive ownership outlined in the previous section. \nWe construct three different variants of owners-as-modi.ers (in Fig. 14) and a new, more .exible variant \nof owners-as-dominators with two mechanisms for enforcement (in Fig. 15); we show how standard owners-as-dominators \nis a simple restriction of our variant. Encapsulation policies in Tribeown are de.ned independently of \nthe mechanism of descriptive ownership, and are, essentially, pluggable. Owners-as-Modi.ers (syntactic) \nG f . : this.N * ... G f ..f = e : ... G f ..m(e) : ... (T-ASSIGN T-INVK) Owners-as-Modi.ers (expressive) \nG f . . P G f P -: this . P = this.out ... G f ..f = e : ... G f ..m(e) : ... (T-ASSIGN T-INVK) Owners-as-Modi.ers \n(Universes) G f . . PP .{this, this.out} ... G f ..f = e : ... G f ..m(e) : ... (T-ASSIGN T-INVK) Figure \n14. Enforcing owners-as-modi.ers in Tribeown. 5.1 Owners-as-Modi.ers Owners-as-modi.ers is an encapsulation \npolicy .rst imple\u00admented in the Universes type system [39, 27, 23]. It enforces that any modi.cation \nof an object must be initiated by its owner. Owners-as-modi.ers in the Tribal setting is implemented \nby adding restrictions (extra premises) to the rules for .eld assignment and method invocation. For simplicity, \nwe ignore Owners-as-Local-Dominators G f this . T ... G f a class C<X> < A y C ' {QT f; M} OK (T-CLASS) \n... G f P .C<T > . T G f P .C<T > . A.C<T > (A-CLASS) Owners-as-Local-Dominators Heap .. .{R; f.v}.H \n... .f . v . v. f = out . v = null . G f . -: v.out. (HfH(v) . A . public(A)) fH OK (F-HEAP) Figure 15. \nEnforcing owners-as-dominators in Tribeown. pure methods. They could easily be supported by allowing \nall calls to pure methods; the formalisation is standard (e.g., [23]). Over the next few paragraphs we \ndescribe three variations of the owners-as-modi.ers discipline. Each variation is im\u00adplemented in a different \nway and enforces a slightly different invariant; all three variations are de.ned formally in Fig. 14. \nSyntactic variant Our syntactic variant of owners-as\u00admodi.ers has a simple implementation, formalised \nby ex\u00adamining the syntax of the static type of the receiver. We only allow .eld assignment and method \ninvocations on objects nested inside the current this. The syntactic variant allows an aggregate to manipulate \nits (transitive) representation (instances of classes nested, possibly deeply, inside the aggregate), \nbut not operate on peer objects (instances of classes directly nested inside the aggregate s owner). \nExpressive variant The expressive variant is, to the best of our efforts, the most .exible policy that \nsticks to the spirit of owners-as-modi.ers. It allows access to transitively owned objects and peer objects. \nIt is formalised using the owner and inside relations, rather than a syntactic test, and is therefore \nmore expensive to implement. It handles paths which alias a transitively owned object. Finally, it subsumes \nthe simple variant. Universes variant The Universes variant emulates Uni\u00adverse Types. An object can modify \nits own representation and peer objects, but nothing else. The formalisation uses the Naming G f P . \nT Local o-as-d, semantic style ' '' '' G f P . P G f P -: P ' G f P . P G f P . X (N-O-AS-D) (N-TYPE-VAR) \nG f T . A public(A.N)G f P . T G f P . T .N (N-PUBLIC) Local o-as-d, syntactic style G f T . A public(A.N) \nG f P . T G f P . T .N G f P . X (N-PUBLIC) (N-TYPE-VAR) G f p.N . p.N G f p . p.N G f p . p (N-REP) \n(N-REFLEX) G f P . p G f P . p.out G f p.N . p G f P . p.out.N (N-OUT-2) (N-OUT-1) '' G f P . T G f P<: \nP G f P . T (N-SUB) Figure 16. Tribeown naming restrictions. owner relation, but not the inside relation \n(and thus, not sub\u00adtyping), it is therefore more syntactic than the expressive variant, but not purely \nso. Similarly to the syntactic variant, the Universes variant only handles types which start at this, \nnot equivalent types.  5.2 Owners-as-Local-Dominators In a system that supports owners-as-dominators, \nan object s owner is found on all access paths from the root of the system to the object itself [22]. \nIn this section we propose a new, more .exible variation of owners-as-dominators which has two formalisations. \nWe call our policy owners-as-local\u00addominators; it subsumes owners-as-dominators. The rules in .gures \n15 and 16 de.ne owners-as-local\u00addominators encapsulation in Tribeown. By (T-CLASS), a class may only \nuse types that it is allowed to name. Nam\u00ading, denoted ., is de.ned in two ways: a semantic variant with \nfew, declarative rules and a syntactic variant with more rules, but using only the syntax of types, where \npossible. We call our policy owners-as-local-dominators because it enforces owners-as-dominators over \nlocal sub-heaps, rather than the whole heap. This is supported in the language by declaring classes public \nor private. Public class names can be named anywhere in a program, private class names can only be named \nwithin the surrounding class s declaration (at any level of nesting). These private naming rules mimic \nstandard ownership types, where naming is dictated by the visibility of this. As a consequence, each \ninstance of a private class forms the root of an encapsulated sub-heap. Objects in the sub-heap may be \nreferenced only according to the owners-as-dominators policy. In both our naming formalisations, the \nrules for public classes and type variables are the same. Both sets of rules handle aliasing paths by \nsubtyping, in the semantic version via (I-SUB), and explicitly in the syntactic version. A public class \nnested inside an encapsulated sub-heap may be referenced freely within that heap, but not outside. It \nis easy to see why this is the case: WLOG, assume p.C is a type where p is a path to an object with private \nclass and C is a public class name. By the rules in Fig. 16, to name p.C, an object must be able to name \np. As a result, public classes provide .exibility without compromising safety for objects inside an aggregate. \nImportantly, it is not possible to de.ne a public class inside an encapsulated sub-heap and use it as \na proxy to export references to objects outside the sub-heap5. For concreteness, consider the following \ncode: private class A{ private class B{ private class C {} public class D {} } private class E{ this.out \nf1; //OK -owner this.out.B f2; //OK -peer this.out.B.C f3; //ERROR -private class this.out.B.D f4; //OK \n-can name B world.F f5; //OK -public class } } public class F{ world.A f6; //OK -peer world.A.B.D //ERROR \ncan t name B }  Public classes may inherit from private classes, but not vice versa. Therefore, instances \nof private classes cannot be named by subsumption. It is safe to subsume a public class to a private \nclass because a public class can be named everywhere that a private class can. Because we wish to use \nRoot.Object as a top type, we must be able to name it everywhere, and so it must be a public class. Since \nprivate classes can not inherit from public classes, we require a Root.PrivateObject to be the root of \n5 This distinguishes deep ownership from shallow ownership. the inheritance hierarchy for private classes6. \nUnfortunately, this means Root.Object is not a top type after all, but only one for public classes. We \nbelieve this is a feature rather than a .aw, as subsuming private classes to a global top type effectively \nbreaks encapsulation. If all classes are private (or we remove the rule (N-PUBLIC)), our system upholds \nthe owners-as-dominator property. If all classes are public, then we enforce no en\u00adcapsulation policy \nand have descriptive ownership. By using a mix of public and private classes, we allow the program\u00admer \nto de.ne the level of encapsulation required. For increased .exibility we only enforce our encapsula\u00adtion \npolicy on the heap. Similar to Clarke and Drossopou\u00adlou s Joe1 [18], we do not enforce naming restrictions \non the types of local variables. (See also a discussion of borrowing and owner-polymorphic methods in \n[20].) Owners-as-local dominators and a default public anno\u00adtation for classes makes it easy to allow \narbitrary aliasing in a system; except for speci.c sub-heaps which can be eas\u00adily created by a single \nprivate annotation on a class. This is similar to the .at ownership hierarchies in Joelle [21] and Loci \n[50], where .elds are implicitly encapsulated in the cur\u00adrent owning object, and active and @Thread annotations \nare used as cut-off points to de.ne the root of an encapsulated sub-heap. The big difference is that \nin Tribeown, the own\u00adership hierarchy is not .at, even when aliasing is permitted, which facilitates \ngradually increasing encapsulation. 5.2.1 Properties We de.ne oasld(H) if .., . ' .H where Hf .'. . ' \n. G f . -: . ' .out . (HfH(. ') . A . public(A)), where '. means has a reference to. Theorem: owners-as-local-dominators \nfH OK, Hf e : T,e; H e ' ; H ' , oasld(H) . oasld(H ') We prove this theorem for both syntactic and semantic \nvariants of our naming relation. Both are proved as part of our preservation theorem by proving that \nthe extra invari\u00adants in (F-HEAP) are preserved. This requires extending our substitution lemmas to the \ninside, owner, and naming rela\u00adtions, and, in the syntactic case, proving that syntactic nam\u00ading gives \nsemantic naming.  5.2.2 Discussion Super.cially, owners-as-local-dominators appears to be or\u00adthogonal \nto the family-polymorphic aspects of Tribal own\u00adership. The programmer can specify encapsulated sub-heaps \nby annotating classes, however, only because of the unique correspondence between the nested class hierarchy \nand the ownership hierarchy. In a context-parametric ownership sys\u00adtem, it would only make sense to annotate \nindividual context 6 PrivateObject can be inherited from because its surrounding class is public. Root.PrivateObject \ncannot be used as a supertype of the local PrivateObjects because it cannot be named. parameters. This \nis not a solution however, because we could not control the nesting of public and private contexts; there\u00adfore, \nthis would not create encapsulated sub-heaps. 6. Related Work Tribeown is closest in spirit to work by \nDietl and M\u00a8uller [26] expressing ownership type systems on top of dependent classes (a similar language \nfeature to virtual classes, but that allows classes to be nested inside more than one enclos\u00ading object). \nTheir system is inspired by the original Tribe work and has similar properties to Tribeown topological \nconstraints and encapsulation restrictions are handled sep\u00adarately. Their system is an encoding and has \nnot been for\u00admalised or proven correct. Furthermore, it requires more annotations (notably, special owner \nannotations) than our system. Thus, we believe that Tribeown is a further simpli\u00ad.cation of Dietl and \nM\u00a8uller s system. Tribeown also comes with proofs of type and ownership soundness. The simplest way to \nsupport ownership in a Tribe-like language is to mimic the context parameters of context\u00adparametric ownership \nsystems with .elds. For example, a non-generic map could be written as: class Map { Object keyOwner; \nObject valueOwner; this.Node[] nodes; Map(Object keyOwner, Object valueOwner) {...} class Node { this.out.keyOwner.Object \nkey; this.out.valueOwner.Object value; } } Map m = new Map(k, v); k.Object ko = new k.Object(); m.put(ko, \nnew v.Object()); //type error v.Object vo = m.get(ko); //type error  Although, this code looks sensible, \nit cannot be type checked because the type system cannot determine that m s keyOwner is the same object \nas k, and similarly for valueOwner. This makes the map essentially useless if we want to preserve ownership \ninformation. We address this problem in Tribeown by using generics. In a fully dependent class system \nsuch as Dietl and M\u00a8uller s, Map can be depen\u00addent upon keyOwner and valueOwner, as well as the map s \nowner, allowing programmers to write this kind of code. Tribeown uses similar restrictions to Con.ned \nTypes [31] a simple set of rules to guarantee that instances of pack\u00adage scoped classes de.ned in a \npackage are not referenced outside the package. In con.ned type, there is no nesting or notion of topology. \nIn this respect, the encapsulation pro\u00advided by con.ned types is similar to systems that offer .at ownership \nhierarchies, like Joelle [21] and Loci [50]. Ownership and Alias Management Systems There are a plethora \nof ownership systems to date, notably Clarke s orig\u00adinal deep ownership system [22], Universes [39], \nshallow ownership [3], and Ownership Domains [1]. Ownership Do\u00admains was the .rst system to advocate \nseparating policy from topology. Ownership Domains is more .exible than Tribe, but requires more annotations. \nSince the Ownership Domains programmer can customise encapsulation, the type system will only enforce \nad hoc encapsulation, not an en\u00adcapsulation policy. Therefore, compilers and programmers cannot rely \non the invariants of a policy to aid reasoning. In similar spirit, Boyland et al. [11] de.ne a set of \ncapabilities on pointers, although without a static type system. Tribeown s out .eld is similar to Pedigree \nTypes chains of parents for transitive owners, although Pedigree Types are not based on virtual or nested \nclasses [34]. Inner classes in Java are a primitive kind of nested class, lacking virtual inheritance. \nBoyapati et al. [8] have proposed integrating inner classes with a typical context-parametric ownership \ntypes system. In their system, the ownership hier\u00adarchy is de.ned orthogonally to the nested class hierarchy: \ninner classes have owners independent of their surround\u00ading classes. Their system supports a modi.ed \nowner-as\u00addominators encapsulation policy where, as well as the usual rules, inner classes have privileged \naccess to the representa\u00adtions of their enclosing objects. Our owners-as-dominators policy is similar \nto the inner classes part of Boyapati et al. s policy. Our policy is more .exible because nested classes \nhave access to their peer and owned classes, as well as their owners, and more intuitive because of the \ncoincidence of the ownership and nested class hierarchies. Our scheme of pub\u00adlic classes introduces further \n.exibility so we avoid the need for having a separate ownership hierarchy. Virtual Class Systems Since \nErnst s original proposal [29], built on gBeta [28], a range of different proposals for virtual class \nsystems have appeared, both with class families (Con\u00adcord [33], .FJ [44], and Jx [41]) and object families \n(Caesar/J [38], vc [30], Scala [36], gBeta [28], and Tribe). For owner\u00adship types, object families are \nneeded since encapsulation is per-object. Building an ownership system on top of Scala is an interesting \ndirection for future work. Recently, Bach Nielsen and Ernst have investigated VM support for virtual \nclasses [4]. We believe that having ef\u00ad.cient VM support for virtual classes could enable space\u00adef.cient \ndowncasting in ownership types, which is a long\u00adstanding problem in the community (see further [6, 49]). \nBracha s Newspeak [12] is a recent, dynamically typed language with virtual classes. Like the aforementioned \nlan\u00adguages, Newspeak does not have ownership support. 7. Conclusion and Further Work We have shown how \nTribeown, a language with virtual classes, can support ownership types, and a range of differ\u00adent encapsulation \npolicies, in a .exible and straightforward way. We have shown that using a class s enclosing object as \nthe owner of instances of that class gives a sound own\u00adership system. This has been suggested before \n(.rst, to our knowledge, by Clarke [17], later by Dietl and M\u00a8uller [26]) but not developed, formalised, \nor proven. A language based on Tribeown will have low syntactic overhead, and should make it easy for \nprogrammers to comprehend the ownership hierarchy. We have further described a novel, .exible encap\u00adsulation \npolicy, owners-as-local-dominators; an extension to the standard owners-as-dominators policy, which leverages \nthe nested-class-based ownership of Tribeown and allows the programmer to customise the level of encapsulation \nen\u00adforced. Future work We have shown how both an owners-as\u00admodi.ers policy and an owners-as-dominator \npolicy can be layered on top of Tribeown, and how the latter can be lo\u00adcalised. We did not .nd an obvious \nway to localise owners\u00adas-modi.ers. We hope to .nd a way to do this, then combine the local variants \nof both properties in the same program. We believe that class invariants can be extended to fam\u00adilies \nof classes to describe invariants which depend on the relationships between classes as well as the classes \nthem\u00adselves; for example, to verify subject-observer [43]. Acknowledgments We would like to thank Dave \nClarke and Sophia Drossopoulou, who were part of the team de.ning the original Tribe system, and were \nalso present in several initial discussions about us\u00ading Tribe to express ownership types. We would also \nlike to thank the OOPSLA reviewers for their useful feedback. The .rst author s work was funded in part \nby a Build IT postdoctoral fellowship. References [1] J. Aldrich and C. Chambers. Ownership Domains: \nSeparating Aliasing Policy from Mechanism. In European Conference on Object Oriented Programming (ECOOP), \n2004. [2] J. Aldrich, C. Chambers, and D. Notkin. ArchJava: Connecting Software Architecture to Implementation. \nIn International Conference on Software Engineering (ICSE), 2002. [3] J. Aldrich, V. Kostadinov, and \nC. Chambers. Alias An\u00adnotations for Program Understanding. In Object-Oriented Programming, Systems, Languages, \nand Applications (OOP-SLA), 2002. [4] A. Bach Nielsen and E. Ernst. Virtual Class Support at the Virtual \nVachine Level. In Workshop on Virtual Machines and Intermediate Languages (VMIL), 2009.  [5] R. L. Bocchino, \nJr., V. S. Adve, D. Dig, S. V. Adve, S. Heumann, R. Komuravelli, J. Overbey, P. Simmons, H. Sung, and \nM. Vakilian. A Type and Effect System for Deterministic Parallel Java. In Object-Oriented Program\u00adming, \nSystems, Languages, and Applications (OOPSLA), 2009. [6] C. Boyapati, R. Lee, and M. Rinard. Safe Runtime \nDowncasts With Ownership Types. In International Workshop on Aliasing, Con.nement and Ownership in object-oriented \nprogramming (IWACO), 2001. [7] C. Boyapati, R. Lee, and M. Rinard. Ownership Types for Safe Programming: \nPreventing Data Races and Deadlocks. In Object-Oriented Programming, Systems, Languages, and Applications \n(OOPSLA), 2002. [8] C. Boyapati, B. Liskov, and L. Shrira. Ownership Types for Object Encapsulation. \nIn Principles of Programming Languages (POPL), 2003. [9] C. Boyapati, B. Liskov, L. Shrira, C.-H. Moh, \nand S. Rich\u00adman. Lazy Modular Upgrades in Persistent Object Stores. In Object-Oriented Programming, Systems, \nLanguages, and Applications (OOPSLA), 2003. [10] C. Boyapati, A. Salcianu, W. Beebee, Jr., and M. Rinard. \nOwnership Types for Safe Region-based Memory Manage\u00adment in Real-time Java. In Programming Language Design \nand Implementation (PLDI), 2003. [11] J. Boyland, J. Noble, and W. Retert. Capabilities for Sharing: \nA Generalization of Uniqueness and Read-Only. In European Conference on Object Oriented Programming (ECOOP), \n2001. [12] G. Bracha, P. Ah\u00b4e, V. Bykov, Y. Kashai, W. Maddox, and E. Miranda. Modules as Objects in \nNewspeak. In European Conference on Object Oriented Programming (ECOOP), 2010. [13] N. Cameron. Existential \nTypes for Variance Java Wildcards and Ownership Types. PhD thesis, Imperial College London, 2009. [14] \nN. Cameron and S. Drossopoulou. Existential Quanti.ca\u00adtion for Variant Ownership. In European Symposium \non Programming Languages and Systems (ESOP), 2009. [15] N. Cameron, T. Wrigstad, and J. Noble. Tribal \nOwner\u00adship (accompanying technical report). Technical Report 10 14, School of Engineering and Computer \nScience, Victo\u00adria University of Wellington. https://ecs.victoria. ac.nz/twiki/pub/Main/TechnicalReportSeries/ \nECSTR10-14.pdf. [16] N. R. Cameron, S. Drossopoulou, J. Noble, and M. J. Smith. Multiple Ownership. In \nObject-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2007. [17] D. Clarke. Nested \nClasses, Nested Objects and Ownership. Invited talk at FOOL/WOOD, 2006. [18] D. Clarke and S. Drossopoulou. \nOwnership, Encapsulation, and the Disjointness of Type and Effect. In Object-Oriented Programming, Systems, \nLanguages, and Applications (OOP-SLA), 2002. [19] D. Clarke, S. Drossopoulou, J. Noble, and T. Wrigstad. \nTribe: A Simple Virtual Class Calculus. In Aspect-Oriented Software Development (AOSD), 2007. [20] D. \nClarke and T. Wrigstad. External Uniqueness is Unique Enough. In European Conference on Object Oriented \nProgramming (ECOOP), 2003. \u00a8 Minimal Ownership for Active Objects. In Asian Symposium on Programming \nLanguages and Systems (APLAS), 2008. [21] D. Clarke, T. Wrigstad, J. Ostlund, and E. B. Johnsen. [22] \nD. G. Clarke, J. M. Potter, and J. Noble. Ownership Types for Flexible Alias Protection. In Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), 1998. [23] D. Cunningham, W. Dietl, S. Drossopoulou, \nA. Francalanza, P. M\u00a8uller, and A. J. Summers. Universe Types for Topology and Encapsulation. In Formal \nMethods for Components and Objects (FMCO), 2008. [24] D. Cunningham, S. Drossopoulou, and S. Eisenbach. \nUni\u00adverse Types for Race Safety. In Veri.cation and Analysis of Multi-threaded Java-like Programs (VAMP), \n2007. [25] W. Dietl and P. M\u00a8uller. Universes: Lightweight Ownership for JML. Journal of Object Technology, \n4(8), 2005. [26] W. Dietl and P. M\u00a8Ownership Type Systems and uller. Dependent Classes. In Foundations \nof Object-Oriented Languages (FOOL), 2008. [27] W. M. Dietl. Universe Types: Topology, Encapsulation, \nGenericity, and Tools. PhD thesis, ETH Zurich, Switzerland, 2009. [28] E. Ernst. Propagating Class and \nMethod Combination. In European Conference on Object Oriented Programming (ECOOP), 1999. [29] E. Ernst. \nFamily Polymorphism. In European Conference on Object Oriented Programming (ECOOP), 2001. [30] E. Ernst, \nK. Ostermann, and W. R. Cook. A Virtual Class Calculus. In Principles of Programming Languages (POPL), \n2006. [31] C. Grothoff, J. Palsberg, and J. Vitek. Encapsulating Objects with Con.ned Types. ACM Transactions \non Programming Languages and Systems (TOPLAS), 29(6), 2007. [32] A. Igarashi, B. C. Pierce, and P. Wadler. \nFeatherweight Java: a Minimal Core Calculus for Java and GJ. ACM Transactions on Programming Languages \nand Systems (TOPLAS), 23(3), 2001. [33] P. Jolly, S. Drossopoulou, C. Anderson, and K. Ostermann. Simple \nDependent Types: Concord. In ECOOP Workshop on Formal Techniques for Java-like Languages (FTfJP), 2004. \n[34] Y. D. Liu and S. Smith. Pedigree Types. In International Workshop on Aliasing, Con.nement and Ownership \nin object\u00adoriented programming (IWACO), 2008. [35] Y. Lu and J. Potter. On Ownership and Accessibility. \nIn European Conference on Object Oriented Programming (ECOOP), 2006.  [36] M. Odersky et al. An Overview \nof the Scala Programming Language. Technical Report IC/2004/64, EPFL Lausanne, Switzerland, 2004. [37] \nO. L. Madsen and B. Moller-Pedersen. Virtual Classes: A Powerful Mechanism in Object-oriented Programming. \nIn Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 1989. [38] M. Mezini and \nK. Ostermann. Conquering Aspects with Caesar. In Aspect-Oriented Software Development (AOSD), 2003. [39] \nP. M\u00a8uller and A. Poetzsch-Heffter. Universes: A Type System for Alias and Dependency Control. Technical \nReport 279, Fernuniversit\u00a8at Hagen, 2001. [40] J. Noble, J. Vitek, and J. Potter. Flexible Alias Protection. \nIn European Conference on Object Oriented Programming (ECOOP), 1998. [41] N. Nystrom, S. Chong, and A. \nC. Myers. Scalable Extensibil\u00adity via Nested Inheritance. In Object-Oriented Programming, Systems, Languages, \nand Applications (OOPSLA), 2004. \u00a8 [42] J. Ostlund and T. Wrigstad. Welterweight Java. In International \nConference on Objects, Components, Models and Patterns (TOOLS Europe), 2010. [43] M. Parkinson. Class \nInvariants: The End of the Road? In International Workshop on Aliasing, Con.nement and Ownership in object-oriented \nprogramming (IWACO), 2007. [44] C. Saito, A. Igarashi, and M. Viroli. Lightweight Family Polymorphism. \nJ. Funct. Program., 18(3), 2008. [45] M. Smith. A Model of Effects with an Application to Ownership Types. \nPhD thesis, Imperial College, 2007. [46] J. H. Spring, J. Privat, R. Guerraoui, and J. Vitek. Stream-Flex: \nHigh-throughput Stream Programming in Java. In Object-Oriented Programming, Systems, Languages, and Applications \n(OOPSLA), 2007. [47] M. Torgersen. The Expression Problem Revisited. In European Conference on Object \nOriented Programming (ECOOP), 2004. [48] P. Wadler. The Expression Problem. Message to Java-Genericity \nmailing list, November 1998. [49] T. Wrigstad and D. Clarke. Existential Owners for Ownership Types. \nJournal of Object Technology, 6(4), 2007. [50] T. Wrigstad, F. Pizlo, F. Meawad, L. Zhao, and J. Vitek. \nLoci: Simple Thread-Locality for Java. In European Conference on Object Oriented Programming (ECOOP), \n2009. [51] T. Zhao, J. Baker, J. Hunt, J. Noble, and J. Vitek. Implicit Ownership Types for Memory Management. \nSci. Comput. Program., 71(3), 2008.    \n\t\t\t", "proc_id": "1869459", "abstract": "<p><i>Tribal Ownership</i> unifies class nesting and object ownership. Tribal Ownership is based on Tribe, a language with nested classes and object families. In Tribal Ownership, a program's runtime object ownership structure is characterised by the lexical nesting structure of its classes.</p> <p>We build on a variant of Tribe to present a <i>descriptive</i> ownership system, using object nesting to describe heap partitions, but without imposing any restrictions on programming disciplines. We then demonstrate how a range of different <i>prescriptive ownership policies</i> can be supported on top of the descriptive Tribal Ownership mechanism; including a novel <i>owners-as-local-dominators</i> policy. We formalise our type system and prove soundness and several ownership invariants. The resulting system requires strikingly few annotations, and uses well-understood encapsulation techniques to create ownership systems that should be intuitive for programmers.</p>", "authors": [{"name": "Nicholas Cameron", "author_profile_id": "81339492259", "affiliation": "Victoria University of Wellington, Wellington, New Zealand", "person_id": "P2354117", "email_address": "", "orcid_id": ""}, {"name": "James Noble", "author_profile_id": "81100588708", "affiliation": "Victoria University of Wellington, Wellington, New Zealand", "person_id": "P2354118", "email_address": "", "orcid_id": ""}, {"name": "Tobias Wrigstad", "author_profile_id": "81323497904", "affiliation": "Uppsala University, Uppsala, Sweden", "person_id": "P2354119", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869510", "year": "2010", "article_id": "1869510", "conference": "OOPSLA", "title": "Tribal ownership", "url": "http://dl.acm.org/citation.cfm?id=1869510"}