{"article_publication_date": "10-17-2010", "fulltext": "\n Mostly Modular Compilation of Crosscutting Concerns by Contextual Predicate Dispatch Shigeru Chiba \nAtsushi Igarashi Salikh Zakirov Tokyo Institute of Technology, Japan Kyoto University, Japan Tokyo Institute \nof Technology, Japan www.csg.is.titech.ac.jp www.sato.kuis.kyoto-u.ac.jp www.csg.is.titech.ac.jp Abstract \nThe modularity of aspect-oriented programming (AOP) hasbeen a controversial issue. To investigate this \nissue com\u00adparedwithobject-orientedprogramming(OOP),weproposea simple language providing AOP mechanisms, \nwhich areenhanced traditional OOP mechanisms. We also present itsformal system and then show that programsin \nthis languagecan be only mostly modularly (i.e. separately) typecheckedandcompiled.We mentionasourceofthisunmodularityanddiscuss \nwhether or not it is appropriate to claim that AOPbreaks modularity compared with OOP. Categories and \nSubject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features Classes and objects \nGeneral Terms Languages Keywords Aspect Oriented Programming,Java, AspectJ. 1. Introduction Aspect-orientedprogramming(AOP)hasbeenactivelystud\u00adied \nfor more than a decade. A challenge of AOP is to man\u00adage crosscutting concerns in a modular fashion. \nWhat is acrosscutting concern? According to Kiczales et al. [25], Ingeneral, whenever two properties \nbeing programmed mustcomposedifferentlyandyetbe coordinated,wesay that theycross-cut each other. A crosscutting \nconcern consists ofsuch crosscutting properties. Hence, by de.nition, it mightseem anti-modular; something \nnot locally complete or self\u00adcontained at all. This might give us an impression that AOPisaparadigmto \nmodularizetheun-modularizable [29]butthis phrase sounds contradictoryor at least confusing. TypicalAOP \nlanguagessuchas AspectJ[26]increasethisconfusion and, what is worse, they have lead some develop- Permission \nto make digital or hard copies of all or part of this work for personal orclassroom use is granted without \nfee provided that copies are not made or distributedfor pro.t or commercial advantageand that copies \nbearthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistributeto lists, requires prior speci.c permission and/or a fee. OOPSLA/SPLASH 10, October \n17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright c &#38;#169; 2010 ACM 978-1-4503-0203-6/10/10...$10.00 \ners to feeling that AOP languages do not really modularizeprograms but rather break modularity in a classical \nsense.As we show in this paper,AspectJ programscannotbe mod\u00adularly (i.e. separately) typechecked or compiled. \nThis factwould not be inherent to AOP in general but it would bean intentional design decision for maximizing \npractical use\u00adfulness of the language. However, some users claimed that Given that AOP has set out to \nmodularize crosscutting con\u00adcerns (its methodological claim), but by its very nature (itsmechanics) breaks \nmodularity [42]. To respond such con\u00adfusion, Kiczales and Mezini proposed a new interpretationof modularity \n[27], in which a module interface is contextdependent on a deployment con.guration of classes and as\u00adpects. \nIn fact, a module interface of AspectJ is not deter\u00admined in their sense until a list of all wovenaspects \nis given.The authors of [27] also mentioned crosscutting concernsinherently require global knowledge \nto support reasoning. The need of global analysis is, however, a sign of being un\u00admodular. To investigate \nthis confusion, we attempt to develop asimple Java-like AOP language whose programs can bemodularly typecheckedand \ncompiled without a global anal\u00adysis. This language is named GluonJ. This paper reportsthis attempt. This \nlanguage supports a useful subset of theAOP functionality of AspectJ. If a program in this languagecan \nbe modularly compiled, then it will be revealed that un\u00admodularity is not inherent to AOP or crosscutting \nconcernsin general. Even if it cannot, we will see the source of theunmodularity. Being modularly compilable \ndoes not meanmodular reasoning is also possible. However, it will be asolid basis of discussion. Directly \ndiscussing modular rea\u00adsoning is dif.cult. For example, it is not clear that modularreasoningispossibleinobject-orientedprogramming(OOP)because \nof method overriding. To ease comparison with traditional modular OOP lan\u00adguages, the AOP mechanisms \nof our language are simpleenhancement of method overriding and method dispatch ofOOP. They are not based \non the popular pointcut-adviceof AspectJ. The pointcut-advice is too different from OOPmechanisms to \nbe compared side-by-side with respect tomodularity. Our language adopts the idea of predicate dis\u00adpatch[16, \n32],whichis modi.edto use externalcalling con\u00adtexts, such as who is a caller, so that method dispatch \ncan be used for AOP. Thismodi.ed mechanismis called contextual predicate dispatch.  Unfortunately, it \nturns out that a program written in Glu\u00adonJ cannot be completely modularly typechecked or com\u00adpiled. \nGluonJ is only mostly modular and a limited globalanalysis is necessary. However,it is not inherent to \nthe basicidea of the language;accepting the global analysis is our de\u00adsign decision. We can avoid the \nglobal analysis by changingthe language design of GluonJ if we can degrade its prac\u00adtical usefulness \nto a certain degree. Furthermore, our com\u00adpilation technique for minimizing runtime overheads due toAOP \nalso needs global analysis and transformation at linktime or load time. This paper, however,shows that \nonly lim\u00adited global transformation is necessary. Our contribution is twofold. (1) We propose a languageproviding \nAOP mechanisms, which are not traditional onesbut rather enhanced OOP mechanisms for dealing withcrosscutting \nconcerns. This makes it easy to investigate themodularity of AOP mechanisms by comparing with well\u00adknown \nOOP mechanisms. (2) We show programs in thatlanguagearemostly modularly compiledalthoughit is oftencriticized \nthat AOP will break modularity. Then we discussthe modularity of AOP. In the rest, Section 2 brie.y overviewsthe \nAOP function\u00adalitydiscussedinthispaper.Section3proposesourlanguageGluonJ,which providesAOP functionalityin \nthe OOP style.Sections 4 to 6 show the calculus and implementation ofGluonJ. Section 7 mentions related \nwork and Section 8 con\u00adcludes this paper.  2. Language mechanisms for AOP This section brie.y presents \nthe AOP mechanisms that wedeal with in this paper. Then it shows that AspectJ programsusing those mechanisms \nare not modularly compiled. 2.1 Destructive extension A combination of execution pointcut and advice \nis one ofthe most useful mechanisms of AspectJ. It enables destruc\u00adtively modifyingan existingmethod.Thesourcecodeofthatmethoddoesnotchangedueto \ntheobliviousnesspropertyofAOP [17]. Figure 1 shows a simpli.ed example of interpreter writ\u00adten with aspects. \nThe Calc class has a main method, which makes an instance of Parser to parse a program given as acommand-line \nargument. Then it evaluates the program bycallingthe eval method.Supposethatthislanguagecancom\u00adpute only \nan integer value. We can extend this program bywriting an aspect to support .oating-point numbers besides \nintegers. For example,the AddExpr class, which is for the + nodes of an abstract syntax tree, originally \ncan process onlyinteger values but it can be extended by the FloatExt aspect tocompute.oating-pointnumbersaswell.Its \naround advice public class Calc { public static void main(String[] args) { ASTree t = new Parser().parse(args[0]); \nt.eval(); } } class AddExpr extends ASTree { Value eval() { return new IntValue(left.eval().intValue() \n+ right.eval().intValue()); } } public aspect FloatExt { Value around(AddExpr ae): execution(Value AddExpr.eval()) \n&#38;&#38; this(ae) { if (ae.left.isType(Integer.class) &#38;&#38; ae.right.isType(Integer.class)) return \nproceed(); else return new DoubleValue(ae.left.eval().doubleValue() + ae.left.eval().doubleValue()); \n} } Figure 1. A simple interpreter in AspectJ. substitutes for the original eval method in AddExpr.This \nis similar to method overriding. proceed() invokes the original method body of eval. Note that the aspect \ndestructively modi.es the behavior of the eval method in AddExpr and hence we do not have to modify the \nparse method in the Parser class to instantiate a new version of the AddExpr class when it .nds a + expres\u00adsion.1 \nTheoriginalprogram(Calc and AddExpr) remainsthe same; the behavior reverts to the original if the FloatExt \nas\u00adpect is removed. If the compiler above is implemented without AOP, thislevel of customizability is \nnot available by other extensionmechanisms such as inheritance, mixins [7], mixin layers[40], family \npolymorphism [15], traits [39], and nested in\u00adheritance[34]. These mechanismslet an extendedversion ofa \nclass, namely a subclass, coexist with the original versionof that class. Thus, if programmers want to \nuse the new be\u00adhavior for some instances, they must explicitly declare thatfact, for example, by giving \nthe subclass name when theinstances are created. The other instances remain showingthe old behavior. \nThis is bene.cial when reusing parts of a program, such as classes, since both a new version and itsoriginalversioncan \nbe used in the same program.For exam\u00adple,programmerscanimplementa JarFile classasasubclass of ZipFile \nclass and use both in one program. On the otherhand, when programmers want to use only the new behav\u00adior, \nthey have to modify all occurrences of object creationincluded in the original program to use the new \nversion. 1No matter whether we use AOP, we must modify the Parser class to parse a .oating-point constant. \n AOP does not allow original and new versions of a classto coexist in a program. It makes only the new \nversionavailable in the program. This destructive feature of AOP is useful when programmers want to reuse \na whole pro\u00adgram and partly customize it to build new software. Reusinga whole program has practical \nneeds. A good example isJastAdd [14], which is a compiler construction framework.Since JastAdd containsa \nsimple AOP mechanism, program\u00admers can develop a Java 1.5 compiler by only writing as\u00adpects for extending \na Java 1.4 compiler. They do not haveto modify object-creation expressions in the original pro\u00adgram of \nthe Java 1.4 compiler. All extensions are separatedinto the aspects. We hence easily switch Java 1.4 \nand 1.5 byadding/removingthe aspects.  2.2 Limited scope In AspectJ, the within/withincode pointcut \nenables to applyan extension into a limited scope. In particular, a combina\u00adtion of call and withincode \npointcuts enables to execute an adviceinthemiddleof amethodbody.Thispartialextensionof a method body \nis a unique feature of AOP. Note that wedo not have to modify the source code of the method body.Since \nit may be considered as breaking the information hid\u00ading principle [37] on a method, its bene.ts have \nbeen con\u00adtroversial [42] and several ideas for dealing with this havebeen proposed so far [1, 19]. On \nthe other hand, this featureisnecessarytoimplementanumberofcrosscuttingconcernsrepresented by a famous \nlogging concern. Figure 2 presents a simple Logging aspect. Its before ad\u00advice is invoked in the middle \nof the eval method in the VariableDecl class, namely, just before the recordVariable methodin Env iscalledfromthe \neval method.Thecall point\u00adcut selects all occurrences of recordVariable calls and the withincode selects \nonly the occurrencesin the eval method. Although the Logging aspect is a simple example, thesame idea \ncan be used to implement a variety of cross\u00adcutting concerns including performance pro.ling, transac\u00adtion, \nsynchronization, and security. For example, it is pos\u00adsible to write around advice for performing mutual \nexclu\u00adsion to make the method thread-safe when the recordVari\u00adable method in Figure 2 is executed. 2.3 \nModular compilation The AspectJ designers do not seem to have prioritized mod\u00adular typechecking.For example,a \nproceed call in an around advice is not type-safe due to its generic nature. This prob\u00adlem was solved \nby StrongAspectJ [18]. Furthermore, anearly AspectJ compiler needs to compile all source .les composing \na program together. Although a later compilercan modularly compile each source .le and .nally link all \nthe compiled binary .les, programmers still need to manu\u00adally give a compiler some source .les together. \nFor exam\u00adple, if a method calls another method introduced by an as\u00adpect, that aspect must be compiled \ntogether with the callermethod. In Figure 3, the print method in the Printer aspect public class VariableDecl \nextends ASTree { String name; Value eval() { Value initValue = right.eval(); env.recordVariable(name, \ninitValue); return null; } } public aspect Logging { before(): call(void Env.recordVariable(String,Value)) \n&#38;&#38; withincode(Value VariableDecl.eval()) { System.out.println(\"declare a variable\"); } } Figure \n2. A logging aspect. public aspect Printer { public void AddExpr.print() { System.out.println(this.opName()); \n} } public aspect OperatorName { public String AddExpr.opName() { return \"+\"; } } Figure 3. An intertype \ndeclaration depending on another calls the opName method introduced by the OperatorName aspect. If only \nthe AddExpr class and the Printer aspect are compiled without the OperatorName aspect, the compiler will \nreport opName is not found since it cannot see the Op\u00aderatorName aspect. The lack of modular typechecking \nmight be not intrinsicin AOP in general. It might be an intentional design deci\u00adsion for practical .exibility \nand .xing this problem mightbe possible by adding extra declarations. However,this con\u00adfuses the discussion \non the modularity of AOP. If modulartypechecking were possible, the checkable properties wouldbe the \nbase of the discussion on the modularity.  3. GluonJ This section presents our simple AOP language \nnamed Glu\u00adonJ, which provides the AOP functionality mentionedin theprevious section. GluonJ is an extension \nof Java and intro\u00adduces a new language construct called reviser into Java. 3.1 Reviser A reviser is \nsimilar to a class but the member declarationsof a reviser are considered as part of the de.nition of \nits targetclass. They are merged into its target s. Figure 4 is an exam\u00adpleofreviser.Likeopenclasses[12],thisreviserPrinting \ndi\u00adrectlyappendsnew members,a tag .eld anda print method, to its target class AddExpr. A reviser cannot \nbe instantiated  class Printing revises AddExpr { String tag = \"+\"; void print() { System.out.println(left \n+ tag + right); } } Figure 4. A reviser adding new members. class FloatExt revises AddExpr { Value eval() \n{ if (left.isType(Integer.class) &#38;&#38; right.isType(Integer.class)) return super.eval(); else return \nnew DoubleValue(left.eval().doubleValue() + right.eval().doubleValue()); } } Figure 5. A reviser equivalent \nto the aspect in Figure 1. like an abstract class of Java, which cannot be instantiatedeither. Hence \na reviser cannot declare a constructor. Note that the initial value of tag is given in the declaration; \nnoexplicit constructor can be declared. If a method name in a reviser is the same as a method in its \ntarget class, then the method implementation in the re\u00adviser destructively replaces (or overrides) the \noriginal im\u00adplementation in the target class as an around advice with an execution pointcut does in AspectJ. \nFigure 5 presents a re\u00adviser that performs the same modi.cation that the FloatExt aspect in Figure 1 \ndoes. Now a call to eval on an AddExpr object invokes the implementationdescribedin the FloatExt class. \nA call super.eval() included in FloatExt invokes the original implementation of the eval method in AddExpr. \nUnlike a method, a reviser cannot revise a constructor inits target class since a reviser cannot declare \nan explicit con\u00adstructor. Eliminating this restriction would not be dif.cult but it is one of future \npossible extensions of the language. A static method in a reviser may substitute for the corre\u00adsponding \nstatic method implementation declared in its tar\u00adget class. Suppose that the AddExpr class declares a \nstatic method foo and the reviser FloatEx also declares foo. Then, a call AddExpr.foo() invokes the implementation \nof foo in the reviser FloatEx. Within the body of the foo method in the reviser, however, a call AddExpr.foo() \ninvokes the im\u00adplementationby AddExpr whileacall FloatEx.foo() invokes the implementation by FloatEx. \n 3.2 A within method To apply destructive extension in a limited scope, GluonJadoptsthe idea of predicatedispatch.A \nreviser can declare amethod with a predicate. With predicate dispatch, a methodimplementationmay havea \npredicateasa guard.Itoverridesanotherifitspredicateistrueandimpliestheotherpredicate. class Tracer revises \nEnv { void recordVariable(String name, Value value) within VariableDecl.eval() { System.out.println(\"declare \na variable\"); super.recordVariable(name, value); } } Figure 6. A method with a predicate. In JPred [32], \na predicate may be a test of an argument typeor value, or the receiver s .eld value. In GluonJ, only \nthe within predicate is available to pro\u00advide the capability of the within/withincode pointcut of As\u00adpectJ. \nWe below call a method with this predicate a within method.The within predicate becomes true if a method\u00adcaller \ns site is within the location given by the argument.Like in AspectJ, with a within method, GluonJ enables \ntoappenda method invocationin the middle of the body of an\u00adother method. Since a predicate referring \nto external callingcontexts is unique to AOP, we call the method dispatch inGluonJ contextual predicate \ndispatch. Figure 6 shows an example of within method. Note that the method signature is followed by a \nwithin clause, which speci.es a class or a method. The reviser Tracer adds logging functionality as the \nLogging aspect in Fig\u00adure 2 does. The implementation of recordVariable in this reviser is invoked only \nwhen the method is called from the eval method in the VariableDecl class. It prints a messageand then \ninvokes the original implementation in Env by su\u00adper.recordVariable(...). On theotherhand,whenthemethod \nis called not from the eval method, the original implementa\u00adtion in Env is invokedsince the predicateis \nfalse. A compileerror would be reported if a program does not provide amethod implementation without \na predicate or with a predi\u00adcatematchingthecaller ssite.Notethatarevisercandeclare a within method that \ndoes not override any method imple\u00admentation in its target class.  3.3 Combining revisers GluonJallowsmultiplerevisersto \nrevisethe sameclass. Theprecedence order among reviser is speci.ed by a requiresclause in a class declaration. \nFigure 7 shows an example.This reviser StringExt declares that it has higher precedence than another \nreviser FloatExt in Figure 5, which revises thesametarget AddExpr. It also declares that StringExt runs \ntogether with FloatExt.A requires clause can include multiple reviser names separated by comma. The left \nhashigher precedence. Moreover, a reviser may have a requiresclause including the name of another reviser \nthat revises adifferent class. A requires clause is used to incrementally implement anew reviser by reusing \nother revisers. A required reviser,which has lower precedence, is applied to the target classbefore the \nreviser requiring that. The precedence order istransitive. In a valid GluonJ program, the precedence \norder  class StringExt requires FloatExt revises AddExpr { Value eval() { if (left.isType(Number.class) \n&#38;&#38; right.isType(Number.class)) return super.eval(); else return new StringValue(left.eval().toString() \n+ right.eval().toString()); } } Figure 7. A requires clause. among the revisers revising the same class \nmust be a totalorder. If not, a compile error will be reported. A method implementation declared in a \nreviser mayoverride another reviser s implementation if the reviser hashigherprecedencethantheother.Theirtargetclasshaslowerprecedence \nthan them. A call on super invokes the overrid\u00adden implementation in a reviser with lower precedence \n(orthe target class). This is also true for within methods. On a method call, a reviser with higher precedence \nis searched.rst to select an implementation matching the calling con\u00adtexts.Thetargetclass issearchedlast. \nThisruleis signi.cant if two revisers for the same target class have implementa\u00adtions of the same method \nbut with different predicates such as within C and within C.foo(). Suppose that a caller site is the \nfoo method in C. If a reviser with higher precedence hasthe implementation with within C, it is selected \ninstead of the implementation with within C.foo() although the latter is more speci.c. The formal semantics \nof method dispatchis presented in the next section.  3.4 Using a new member A reviser can refer to members \nadded by other revisersspeci.ed by its requires clause. In Figure 7, StringExt can refer to members added \nby FloatExt (if any). On the other hand, a class needs a using declaration when it refers to membersadded \nby a reviser. The addedmembersare visibleonly within the source .le including the using declarationof \nthat adding reviser. Figure 8 shows an example. The Printer class can call the print method on an AddExpr \nobject since the source .le includes a using declaration of the reviser Printing. This restriction might \nseem to decrease the obliviousnesspropertyof GluonJ.The reader might think that a source .le must be \nmodi.ed to include a using declaration and hence reusing a whole program as is wouldbemadedif.cult. However, \nthis restriction is not a problem. If an originalprogram is self-contained, it never accesses newly addedmembers \nsince it was written before the reviser. Only theclasses written with or after the reviser will access \nthe added membersandthusit is acceptabletoenforceprogrammerstoincludea using declarationin thesource \n.le ofthoseclasses. On the other hand, a using declaration helps modular type checking. using Printing; \n// a using declaration class Printer { static void print(AddExpr e) { e.print(); } } Figure 8. A class \nusing a method added by a reviser. 3.5 Visibility rule A reviser follows the same visibility rule as \nnormal classes.Itmayonlyaccess public members,so-called packagemem\u00adbers in the same package, protected \nmembers of the target class and its super classes, and private members of the re\u00adviser itself. It may \nalso access protected members of other reviserssharingthesametargetclassbuthavinglowerprece\u00addence. Method \noverriding by a reviser also follows the ruleof the standard Java. It cannot override a private method \nin the target class. This rule restricts the extensibility by revis\u00aders but we adopt this rule for the \ninformation hiding princi\u00adple[37]. Thisrulewillalso ease thefragilepointcutproblemof AOP [28, 31, 43]. \nIn a good Java program, a non-privatemethod can be expected to be available until the design ofthe program \nis largely changed due to refactoring. 3.6 Current Limitations Dynamic pointcuts AlthoughAspectJprovidesdynamicpointcutssuchas \nc.ow,GluonJdoesnotdealwiththem.Introducingotherpredicateslike c.ow and improving the AOP capability of \nGluonJ is astraightforward extension as our previous workshop paper [9] showed. However,our goal is modular \ntypecheckingandcompilation;thedynamicbehaviorofdynamicpointcutsob\u00adviously complicates type checking, \nin particular, checkingthe exhaustiveness property. This property guarantees that no such method is found \nerrors never happen during run\u00adtime. Unless a method with a dynamic predicate like c.ow always overridesa \ndefault method, which has no dynamicpredicate, GluonJ could not statically check that this prop\u00aderty \nis preserved. This limitation might look serious but the static pointcutsdiscussed in this paper are \nstill a useful subset. For exam\u00adple, the AspectJ support for Eclipse AJDT 2.0.2 consistsof 2212 classes \nand 47 aspects. It includes only 8 occur\u00adrences of c.ow while it includes 60 execution,92 call,and 97 \nwithin/withincode pointcuts.A drawingtoolAJHotDraw 0.4 includes no c.ow although it includes 18 execution,30 \ncall,and36 within/withincode in290classesand31aspects.  Other AspectJ features For the same reason of \nmodular typechecking, GluonJ doesnot support the pattern matching feature of AspectJ, withwhich a pointcut \nargument may include wild cards and/orenumerate several join points. For example, in GluonJ, a within \nmethod cannot overridemultiple methods whose sig\u00adnatures match a pattern. A single reviser cannot revise \nmul\u00adtiple classes. Although this pattern matching feature is use\u00adful to implement a homogeneous concern, \nGluonJ does notsupport it and hence its main applicationsare heterogeneous concerns.  Although AspectJ \nprovides abstract aspects and point\u00adcuts,GluonJdoesnot.Theseenableseparatingconcretede.\u00adnitionsofpointcutsintosub-aspectsandtherbytheyimprovethe \nreusability of aspects. An example of the use is found in[20]. Introducing this template-like mechanism \ninto GluonJfor better code reusability is out of scope of this paper. super and proceed A call on super \nin a within method invokes the overridden implementation, either in a next reviser with lower prece\u00addence \nor in its target class if there are no more revisers. Thesearch for the target method of the super call \nuses the re\u00adviser as the caller site when checking a within predicate. Itdoes not use the original caller. \nSuppose that a method foo in C invokes a within method bar in a reviser R.If bar calls super.bar(), then \nthe caller site for the search is not foo in C but bar in R. Thus, the implementation with a predicate \nwithin C.foo() is not selected. Thissemantics is differentfrom proceed in AspectJ since proceed searches \naspects under the same contexts as theoriginal.ExtendingGluonJtoprovidea proceed-likemecha\u00adnism is our \nfuture work. GluonJ adopts the semantics abovefor keeping super calls simple. Note that a within method \nbar may call a different method on super, for example, su\u00adper.bar2() instead of super.bar(). GluonJ searches \nfor both super.bar2() and super.bar() under the same calling con\u00adtexts. Another design option is that \nthe caller site is bar in R for super.bar2() while it is foo in C for super.bar(). GluonJ,however,doesnot \nadoptthis design because of its complica\u00adtion.  Multiple within methods If a reviser declares a method \nfoo with a within predicate,then it cannotdeclare anothermethod foo with the same sig\u00adnature with/without \na predicate. This limitation is just forsimplifying the speci.cation and implementationof GluonJ.Todeclaremorethanone \nwithin methodfor foo,multiplere\u00advisers for the same class must be declared and each of them mustdeclareone \nwithin method.AsinJava,arevisercande\u00adclare multiple methods foo if they have different signatures.  \n4. Core calculus of GluonJ In this section, we give a formal calculus called GluonFJ asan extension of \nFeatherweight Java (FJ) [24]. GluonFJ addsrevisers and within methods to FJ. For simplicity, we do not \nmodel super calls, and .elds of revisers; within clauses are restricted so that only class names can \nbe given as sourcecode locations. The purpose of developing a formal calculus is twofold: (1) to show \ntype soundness of the core language as usual and (2) to rigorously discuss to what extent type checkingand \ncompilation are modular. Actually, our proof of typesoundness is an easy extension of one for FJ, thanks \nto thefact that most of the features of GluonJ are extensions of those of traditional object-oriented \nlanguages. We discussin what sense typechecking is (mostly) modular in the nextsection. Later in Section \n6, we give a formal translationfrom GluonFJ to FJ to model compilation and argue thatcompilation is also \nmostly modular. We .rst give the syntax, typing rules, and operationalsemantics of GluonFJ and then state \ntype soundness. Here,weshowonlyamainpartofde.nitionsandthestatementsof theorems here; the full de.nition \nof the language and proofsketches are found in the companion technical report [10]. 4.1 Syntax As mentionedabove,GluonFJ \nhas revisers and within meth\u00adods in addition to most of the features of FJ. Although theyare important \nin compilation as we see in the next section,typecasts have been removed from GluonFJ, since they areorthogonalto \nthe additional features. The syntax of GluonFJ is given as follows: CL ::= class C extendsC usingR{ C \nf; M} class | class R revises C using R{ M} reviser L ::= C | R location M ::= Cm(C x){ return e; } [within \nL] method e ::= x | e.f | e.m(e) | new C(e) | ein L expression v, w ::= new C(v) value Following the \nconvention of FJ, we use an overline to de\u00adnote a sequence and write, for example, x as shorthand for \nx1,..., xn and C f; for C1 f1;,..., Cn fn; . The empty sequenceis written . The metavariables B, C, D,and \nE rangeoverclass names; R rangesoverrevisernames; m rangesover method names; and x and y range over variables, \nwhich in\u00adclude the special variable this. For technical convenience,we assume that class names and reviser \nnames are disjointand the (denumerable) set of reviser names is totally or\u00addered. This total order represents \nthe precedence in methoddispatch and so there are no requires clauses in class def\u00adinitions. In what \nfollows, we assume that any sequence ofreviser names R is sorted accordingto this order(the smallerthe \nindex is, the higher the precedence is). CL is a class (orreviser)de.nition,consistingofits name,a super \nclass name (or the class name that it revises, respec\u00adtively), reviser names that it uses, .elds, and \nmethods. A re\u00adviser cannothave .elds. We omit explicitconstructor de.ni\u00adtions,whichtakeinitialvaluesofall \n.eldsandsetthemtothe correspondingones. Typesof GluonFJare onlyclass names,hence C for .eld, parameter, \nand return types. A method de.nition M can have an optional clause within L,where L, standing for locations, \nis a class/reviser name. One classcannot have more than one method of the same name. The body of a method \nis a single return statement, followingFJ. Expressionsare mostlythe same as FJ exceptforomittedtypecasts \nand the new form einL, which is used to mark which class e originates from in the operational semantics.This \nform is not supposed to appear in class de.nitions. We will denote a substitution of expressions e for \nvariables x by [e/x].       A GluonFJ program is a triple consisting of a class ta\u00adble CT, which \nis a mapping from class names to class de.nitions, a reviser table RT, which is also a mappingfrom reviser \nnames to reviser de.nitions, and an expression,which stands for the body of the main method. We writedom(CT) \n(and dom(RT)) for the domain of the table and write C ext D when CT(C)= class C extends D \u00b7\u00b7\u00b7 . Similarly, \nwe use R rev C and L using R. Finally, we always assume .xed class tables, whichare assumed to satisfy \nthe following sanity conditions: (1)CT(C)= class C \u00b7\u00b7\u00b7 for every C . dom(CT) and sim\u00adilarly for RT;(2) \nObject ./dom(CT) . dom(RT);(3) for every name L (except Object) appearing anywhere in CT and RT,we have \nL . dom(CT) . dom(RT); and (4) there are no cycles formed by extends clauses.  4.2 Lookup functions \nAs in FJ, we need functions to look up .elds, method sig\u00adnatures and bodies in the class tables. The \nfunction .elds(C)returnsallthe .eldsof C anditssuperclasseswiththeirtypes as Cf. We omit its straightforward \nde.nition (which in fact is the same as in FJ). Thefunction fstrev(C, R), whosede.ni\u00adtion is omitted, \nreturns the .rst reviser that revises C, found in R, or just returns C if there is no such reviser. The \nfunc\u00adtion next(L, R) returns the next class of L to look up and is de.ned by: . . Rj if j>i, Ri rev C, \nRj rev C, . . and \u00ac.k . (i, j).Rk rev C next(Ri, R)= . C if Ri rev C and . . \u00ac.j>i.Rj rev C next(C, R)= \nfstrev(D, R) (if C ext D) (Here, (i, j) stands for the set {i +1,...,j - 1}). We often omit the second \nargument R to these functions when it is dom(RT). Thefunction mtype(m, L, R, L') returnsthe signature \nC.C of the method found in class L using R. L' represents the location of the caller. It is de.ned by \nthe following rules: class L {extends, revises} C using R' {Cf; M} Bm(B x){ return e; } [within L'] . \nM mtype(m, L, R, L')= B.B class L {extends, revises} C using R' {Cf; M} m [within L'] . M mtype(m, next(L, \nR), R, L')= B.B mtype(m, L, R, L')= B.B The .rst rule represents the case where m is found in L.The method \nmay be a within method, in which case the locationhastoagreewiththelastargument.Thesecondruleisforthecase \nwhere m is not present in L (m [within L'] . M means that thereis neithermethodnamed m nor m \u00b7\u00b7\u00b7 within \nL' in M); then, the signature is equivalent to that from the nextclass, representedby next(L, R). As \nwe see in typing rules, R will be taken from the using clause of the class in which a method invocation \nappears so that typechecking of ex\u00adpressions does not need all revisers, that is, it is modular.As in \nFJ, we assume that Object has no methods and so mtype(m, Object, , L) is unde.ned for any L. Finally, \nwe de.ne the function mbody(m, L, L') to look up a method body. It returns the body of the method m in \nL called from L' as the triple, written x.e in L'',where x are parameters, e is the method body, and \nthe location L'' stands for the location where the method is found. The rules are similar to mtype: class \nL {extends, revises} C using R{ C f; M} Bm(B x){ return e; } [within L'] . M mbody(m, L, L')= x.einL \nclass L {extends, revises} C using R{ C f; M} m [within L'] . M mbody(m, next(L), L')= x.einL'' mbody(m, \nL, L')= x.e in L'' Unlike mtype, however, it (implicitly) uses all revisers (re\u00admember that next(L) is \nshorthand for next(L, dom(RT))).  4.3 Type system The subtype relation is written C<: D, which is the \nre.exive and transitive closure of the extends relation. The type judgment for expressions is of the \nform L;G f e : C, read expression e in class/reviser L is given type C under type environment G. A type \nenvironment G,also written x:C,is a .nite mapping from variables x to types C. The typing rules are given \nbelow. L;G f x: G(x) (T-VAR) L;G f e0 :C0 .elds(C0)= Cf (T-FIELD) L;G f e0.fi :Ci L;G f e0 :C0 L;G f \ne:C L using R mtype(m, fstrev(C0, R), R, L)= D.C C<:D L;G f e0.m(e):C (T-INVK) .elds(C)= D f L;G f e \n: C L;G f new C(e):C C <: D (T-NEW) L';G f e:C L;G f einL' :C (T-IN)  Most rules are straightforward \nadaptations from FJ typ\u00ading rules. In the rule T-INVK, method lookup starts from fstrev(C, R), taking \ninto accountrevised classes R taken from the using clause of the current class L, which is also given \nto mtype as the caller information. In the rule T-IN,the lo\u00adcation for e is switched since e originates \nfrom a method in L ' . ThetypejudgmentformethodsisoftheformMOKINL,read method M is well typed in class \nL. We show only therule for methods in a reviser since the other rule for ones in a class is similar. \nRrevD R; x : C, this : D f e0 :E0 E0 <: C0 for any L,if mtype(m, next(R), dom(RT), L)= D.D0, then C = \nD and C0 = D0 C0 m(C x){ return e0;} [within L '] OK IN R (T-METHODR) In both rules, the method body \ne has to be well typed underthe type declarations of the parameters x; the type of this is the (revised, \nif the method is declared in a reviser) classname in which the method is declared. The last conditional \npremise checks whether M correctly overrides all the method (be it normal or within) of the same name \nin super classes. Note that dom(RT) is used here. It means that it requires allrevisers to check valid \nmethod overriding. Only this condi\u00adtion preventscompletely modulartypecheckingand thus thecorresponding \ncheck is deferred to the .nal stage of compi\u00adlation (see the next section). Finally, the type judgment \nfor classes is written CL OK,meaning class CL is well typed. We show only the rule forclasses here (the \nother rule for revisers is similar). MOKINC class C extendsD usingR{ C f; M}OK A class table CT or RT \nis well typed if all the classes in itare well typed and we write (CT, RT) OK when both class tables \nare well typed.  4.4 Operationalsemantics The reduction relation is of the form L f e -. e ', read ' \nexpression e reduces to expression e in one step in L. Reduction rules are given below: .elds(C)= Cf \n(R-FIELD) L f new C(v).fi -. vi (R-RETURN) L f vin L ' -. v mbody(m, fstrev(C), L)= x.e0 in L ' (R-INVK) \nL f new C(v).m(w) -. ([w/x, new C(v)/this]e0) in L ' All rules are straightforward. When a method is \ninvokedon an object of C, method lookup starts from fstrev(C),the .rst reviser for C. To distinguish \nthe location of the methodbody from that of its caller, in L ' is added to it. The rule R-RETURN represents \nthe return from a method. Unlike FJ,the semantics is call-by-value because the location wherean expression \nis reduced is important and passing a non\u00advalue expression from one location to another changes itsmeaning. \nSo, the receiver and arguments must be a value,whose meaningis independentof locations,in R-FIELD and \nR-INVK. We omit congruence rules, which allow a subexpressionto reduce.  4.5 Type soundness It is not \ndif.cult to show that GluonFJ is type sound; itenjoys subject reduction and progress [46], which can \nbeprovedinthestandardmanner.(Seethecompaniontechnicalreport [10] for details.) Here, we suppose that \n(CT, RT) OK and write L f e1 -.* en when L f e1 -. e2, ..., L f en-1 -. en. THEOREM 1 (Subject Reduction). \nIf L;G f e:C and ' L f e -. e ',then L;G f e :D for some D such that C<: D. THEOREM 2 (Progress). If \nL; \u00d8f e . C, then either e is a '' value, or there exists some e such that L f e -. e . THEOREM 3 (Type \nSoundness). If L; \u00d8f e:C and L f '' ' e -.* e with e a normal form, then e is either a value v with L; \n\u00d8f v:D for some D<:C. PROOF 1. Immediate from Theorems 1 and 2. 5. Discussion Mostly Modular typechecking \nThe typechecking of a GluonJ program is mostly modular.Aswerigidlyshowedintheprevioussection,everyclassandreviser \nis modularly typecheckable except two rules. First,the precedence order among the revisers revising the \nsameclassmustbe atotalorder.Checkingthis rulerequiresall therevisersusedinaprogramareknown.Second, T-METHODR \nshown in Section 4.3 (and the corresponding rule for meth\u00adods in a class) must be checked. This rule \nis violated whena method addedby a reviser is incompatiblyoverriddenby amethod in an existing subclass \n(or another reviser for a sub\u00adclass). Checking this also requires all the revisers are knownat compile \ntime. The modularly typecheckable part of a program can beregarded as a module interface, which does \nnot change bydeploymentcon.guration of revisers. On the other hand, theunmodularity of GluonJ is due \nto checking T-METHODR and the precedence order among revisers. This check guar\u00adantees compatibility among \nthe modi.cations by revisers since the modi.cations mutually affect each other. Thischeck is a cost of \ndealing with crosscutting concerns.  However, the unmodularity of GluonJ is a property grad\u00adually introduced \ndepending on language design. In fact,avoiding the unmodularity of GluonJ is possible althoughit restricts \npractical usefulness of the language. For exam\u00adple, a compiler could modularly typecheck T-MethodR ifthe \nlanguage semantics were modi.ed. We could avoid this unmodularityif method overloading consideredreturntypesas \nwell as parameter types, for example, if we allow over\u00adloading two methods such as int foo() and String \nfoo()when one is declared in a class and the other is in a subclass ofthat class. However,thisnewsemantics \nis incompatibletonormal Java s. Avoiding the global check of the precedenceorder is also possible if \nwe restrict usefulness of GluonJ.For example, if a program can include only one reviser R and its directly/indirectly \nrequiring revisers, a compiler cantypecheck that the precedence order among those revisersare total order \nwhen it compiles the root reviser R.  Is encapsulation broken? Since a reviserdestructivelymodi.esa \nclass, like AspectJ,itmight seem to break modularity. However, comparing Glu\u00adonJ with other OOP languages, \nwe can hardly claim thatGluonJ largely breaks modularity. We see its AOP capabil\u00adity is provided by simple \nvariants of OOP constructs likemethod overriding. It is just design decision to what ex\u00adtent the modularity \nis weakened from the rigid modularityachievedinOOP.AlthoughGluonJstillhasthefragilepoint\u00adcut problem \ndue to the within predicate and GluonJ s de\u00adstructivenaturemaybedangerous,theseproblemsaresome\u00adwhat addressed \nby the normal visibility rule by private and so on.Typecheckingis onlymostly modularbut,if we reallyneed, \nwe can .x this problem by giving up some expressivepower of the language. Our observationis thatAOP is \na paradigmfor (notbreak\u00ading but) loosing modularity to meet practical demands. Thedegree of loosing is \na design issue. Since modularity isloosen with respect to typechecking and compilation, AOPrequires more \nglobal knowledge for reasoning than OOP.However, OOP also requires global knowledge to a certaindegree.To \nknowthe exactbehaviorof a methodcall in OOP,weneedglobalknowledge,suchaswhichclassoverridesthemethod. \n 6. Implementation 6.1 Compilationoverview We implement a reviser by translating it into a subclass \nofits target class and then adjusting a whole program so thatthe reviserwill be used instead of its targetclass \nin instantia\u00adtions. Thus, the compilation of a GluonJ program consistsof two stages: source-to-bytecode \ntranslation and linking.We implementedthetranslationstagebyextendingJastAddJ [14] and the linking stage \nby using Javassist [8]. Thelinking stage is bytecode transformation and it is executed at loadtimeorstaticallyatthe \nendofcompiletime.Thesourcecodeof the compiler is available from our website.2 Translation stage At the \ntranslation stage, a source .le is separately com\u00adpiled into Java bytecode. This compilation is modular; \nitneeds only the revisers speci.ed by using declarations and requires clauses as well as the classes \nand interfaces on whichthe source .le explicitlydepends.Static typecheckingis executed at this stage \nexcept T-METHODR shown in Sec\u00adtion4.3.Informally,ourcompilerperformsthetypecheckingfornormalJava and \ngeneratesbytecodeasif a reviseris a di\u00adrect subclass of its target class. It also translates a member\u00adaccessexpressionif \nit accessesa memberaddedby a reviser.For example, an expression e.print() is translated into: ((Printing)e).print() \nif the print method is newly added to the class of e by the reviser Printing givenbya using declaration(asinFigure8). \nA within methodiscompiledas ifit is anormalmethod.The within predicate is translated into a Java annotation \nto thatmethod. A constructor of a reviser is compiled differently fromnormal constructors of Java classes. \nRecall that a reviser cannot declare an explicit constructor. At this stage, thecompiler generates only \nthe default constructor,which takesno arguments, initializes .eld values, and calls the defaultconstructor \nof the target class since the target class of areviser is treated as its super class during compilation. \nThetarget class does not have to declare the default constructorsince the generatedconstructor is modi.ed \nat the next stage.  Linking stage At the linking stage, all the revisers included in a programmust be \ngiven. In this sense, this stage needs a whole\u00adprogram analysis and hence it is not modular. Our linkerapplies \nbytecode transformation to every compiled class.Since this transformation can be applied separately to \neveryclass if only all the revisers are given, this stage is still fairlymodular.It never refers to other \nclasses. Our linker .rst computesthe precedenceorderamongtherevisersandchecksitsvalidity.Thismaythrowacompileer\u00adror.Thenthelinkersetsthedirectsuperclassofeveryreviserto \nits target class. If multiple revisers revise the same targetclass, then they are linearized to make \na single inheritancehierarchy according to the precedence order. For example,if class R and S revises \nthe same class C and the reviser R has higher precedence than S,then R extends S,which ex\u00adtends C. If \nthe targetclass has normalsubclasses, their superclass is changedfromthat targetclass to the reviser. \nIf a nor\u00admal class D extends C,then D is also changed to extend R. When a super class is changed, all \nmethod calls on super is 2 www.csg.is.titech.ac.jp/projects/gluonj  also modi.ed (at bytecode level) \nto invoke a method in thenew super class. Our linker next checks the last premise of T-METHODR,which \nrequires that the method overriding by revisers isvalid. Suppose that two revisers revise the same class. \nIfthese revisers declare methods with the same name and pa\u00adrameter types but with different(not-covariant)return \ntypes,then this method overriding is invalid and a compile errorwill be thrown. The linker also generates \nconstructors for every reviserby modifying the default constructor generated at the .rst stage.Aconstructorisgeneratedperconstructorofthesuperclass. \nIt calls super() with the received arguments and then initializes .eld values. For example, the reviser \nFloatExt in Figure5will havethefollowingconstructorif itstargetclass AddExpr has a constructor AddExpr(ASTree,ASTree): \npublic FloatExt(ASTree left, ASTree right) { super(left, right); // initialize field values } The generated \nconstructors are public. The constructors of the target class may be changed to public or protected to \nbe visible from the reviser. Finally, our linker applies bytecode transformation to ev\u00adery class .le. \nIf a class C is revisedbya reviser R,then all instantiations of C is transformed into instantiations \nof R.If C is revised by multiple classes, then they are instantiationsof the reviser with the highest \nprecedence. Furthermore, if a static methodisoverriddenbya reviser,thenalloccurrencesofthecalltothatstatic \nmethodisredirectedtotheoverriding method in the reviser. Implementing a within method If there is a within \nmethod, method dispatch considers atriple:methodname,receivertype,andcallerlocation.Inourimplementation,the \nmethodnameand the callerlocation arestaticallyevaluatedandonlythereceivertypeisdynamicallyevaluated at \nevery method call. The overhead of calling a within method is, therefore, equivalent to that of calling \nanormal method, in which only the receiver type must bedynamically evaluated. Although caller location \nis static,this optimization is not naive since a within method may beoverriddenby a normal method in \na subclass. Suppose that a method foo declared in R has a predicate within L. Our linker .rst renames \nthat within method to foo L (the real method name is more elaborate). Next, ourlinker transforms a call \nto foo into a call to foo L if that call expression is located within L and the static type of the receiver \nis R or a super type of R. Otherwise, the call is nottransformed. Since the dynamic type of that receiver \nmaynot be R, if a super typeor a subtypeof R declares a method foo, then our linker generates a method \nfoo L for that type. Here, a super/sub type of R is determined on the basis of the inheritance relations \nmodi.ed at the linking stage. A super type may be an interface. The generated foo L method just executes \nthe foo method declared in that same class by the invokespecial bytecode (or the body of foo L is a copy \nof the bodyof foo). Thisdelegationmaycauseasmallruntimeoverhead. Furthermore, if a super type of R declares \na foo method, then all the subtypes of that type are transformedto have a foo L method. If the super \ntype is an interface, itssubtypes include classes implementing that interface.  Since Java prohibits \ntransforming some built-in classes,our implementation does not allow revising a class if it isinstantiated \nwithin those built-in classes. The linker can\u00adnot modify this instantiation. It allows declaring a within \nmethodthatoverridesamethodinabuilt-inclass,suchasthe toString method in the Object class, but that within \nmethod isimplementedinaslightlydifferentapproach.Supposethatareviser FloatExt revises the AddExpr class \nand it declares the toString methodwith a predicate within Parser. Accord\u00ading to the approach mentioned \nabove, our linker must ap\u00adpend a toString Parser method to the Object class. How\u00adever, since this is \nnot possible, our linker transforms a callto toString within the Parser class in a different approach.Forexample,iftheexpressionis \nexpr.toString() andthe typeof expr isa supertypeof AddExpr,thenthelinkertrans\u00adforms it into this: expr \ninstanceof AddExpr ? ((AddExpr)expr).toString_Parser() : expr.toString() This does not call the toString \nParser method if the receiver does not understand that method. The condition expressionwill be more complex \nwhen a sibling of AddExpr is revised to have a toString method with the same predicate. 6.2 Formalmodelofcompilation \nWe formalize the core of the implementation scheme de\u00adscribed above as translation from GluonFJ to FJ. \nInstead of reviewing the de.nition of FJ from scratch, we use a subsetofGluonFJ, wherethereviserclass \ntableis empty,as thetar\u00adget language. (Precisely speaking, we need typecasts (C)ein the target language \nbut omit typing and reduction rulessince they can be added in a straightforward manner as inFJ [24].) \nFor simplicity, the formalized translation is done atonce, mixing the two stages described above. After \ngivingthe de.nition of formal translation, we state that translationpreserves typing. First, we give \na few auxiliary de.nitions used in the translation.Thefunction origin(m, L) returnsthe nameofthe super \nclass of L that has .rst introduced m (be it normal or within) in the class hierarchy. class L {extends, \nrevises} D using R ' {C f; M} Bm(B x){ return e; } [within L1] . M for any L0,mtype(m, next(L), dom(RT), \nL0) unde.ned      origin(m, L)= L  origin(m, next(L)) = L ' origin(m, L)= L ' The next two functions \nwithinsub(m, C) and within(m, L) are usedtotranslatewithin methods.Thefunctionwithinsub(m, C)collects \nall predicates L from classes that revise a subclass of C and contain a within method of name m. withinsub(m, \nC)= . . . R . dom(RT) and (.D.R rev D <: C) . L and class R revises \u00b7\u00b7\u00b7 {M} . . and Bm(B x){return e;} \nwithin L . M The function within(m, L), which collects all locations used aspredicatesform in L,isde.nedtobe \nwithinsub(m, thistype( origin(m, L))) where thistype(C)= C and thistype(R)= C if R rev C. For example, \nconsider the following classes: class A extends Object { C m(){ return e1; } } class B extends A { C \nm(){ return e2; }} class R1 revises A { C m(){ return e3; } within C } class R2 revises B { C m(){ return \ne4; } within D } Then,withinsub(m, B)= {D} andwithin(m, B)= within(m, R2)= within(m, R1)= within(m, \nA)= {C, D}.WhenL . within(m, C)the invocationof m on C fromclass L will be translated to the invocation \nof mL , which stands for the name mangled from m and L. The judgment for translation is of the form L;G \nf e =. ' e ', read expression e is translated to e under L and G. We show only rules for method invocations \nand constructors,since others are trivial. In translating a method invocation,we ensure that a method \nonly available in a reviser can beinvoked, by casting the receiver to L ', which is the reviserthat revises \nthe receivertype with the highestpriority.As wementioned above, the method name may be changed if thecaller \nlocation L is found in within(m, C0). '' L;G f e0 =. e0 L;G f e =. eL;G f e0 : C0 L using R fstrev(C0, \nR)= L ' { if L . within(m, C0) ' mL m = m otherwise L;G f e0.m(e) =. ((L ' )e0 ' ).m ' (e ' ) (TR-INVK) \nFor example, under the four classes A, B, R1,and R2 above, D; x : B f x.m() =. ((R2)x).mD () is derivable. \nThe translation of objectcreationis mostlytrivial, exceptthat theclass name is changed to fstrev(C). \n' fstrev(C)= L ' L;G f e =. e L;G f new C(e) =. new L ' (e ' ) The judgment for translation of methods \nis written L f M =. M. Note that the translation of one method may re\u00adsult in multiple methods. The .rst \nrule is for translation of a normal method. The method body is translated underthe type environment where \nparameters have declared typesand this has thistype(L), which is equivalent to the statictype used in \ntypechecking. Since a normal method is called within everywhere, it overrides all the other within meth\u00adods, \nwhich have mangled names. The location names arecollected by within(m, L). ' L; x:B, this:thistype(L) \nf e =. e within(m, L)= L L f Bm(B x){ return e; } Bm(B x){ return e ' ;} BmL1 (B x){ return e ' ;} =. \n. . . BmLn (B x){ return e ' ;} For example, the method m in class B above will translate to three methods \nnamed m, mD ,and mC , even though no reviser revising B has a method with within C.(B will have R1,which \nhas mC after translation, as a super class of B.) The translation of a within method is straightforward. \n' L; x:B, this:thistype(L) f e =. e L f Bm(B x){ return e; } within L ' =. BmL, (B x){ return e ' ;} \n Translation of a class is written f CL =. CL ',and the translation rule is below. next(L)= L ' L f M \n=. M ' f class L {extends, revises} D using R{ C f; M} =. class L extends L ' {Cf; M ' } The super class \nD is replaced with L ', which is the name of the next class when looking up de.nitions. Note that everyreviser \nistranslatedtoanormalclass,so,preciselyspeaking,the set of class names of the target language is taken \nas theunion of the sets of class and reviser names of the source language. ' We write (CT, RT)=. CTwhen \nevery class in thesource class tables translates to one in the target, namely, (1)dom(CT')= dom(CT).dom(RT);(2) \nf CT(C)=. CT'(C)for any C . dom(CT);and (3) f RT(R)=. CT'(R) for any R . dom(RT).  6.3 PropertiesofTranslation \nWe show that translation preserves typing. Actually, trans\u00adlation does not change the type of an expression, \nexcept forthe case where the expression is new C(e), in which case it will become fstrev(C). Since we \nmention two programs be\u00adfore and after translation at the same time, we explicitly say  class C { public \nvoid work(T1 ticker) { ticker.tick(); } } class T1 { public void tick() { Microbench.count1 += 1; } } \nclass R revises T1 { public void tick() within C { Microbench.count2 += 1; } } class T2 extends T1 { \npublic void tick() { Microbench.count1 += 1; } } Figure 9. Microbenchmarkworkload which class table is \nassumed to avoid confusion. Since lo\u00adcations are not signi.cant in the target program, we omit L from \njudgments. ' LEMMA 1. If (CT, RT)=. CTand L;G f e : C under ' (CT, RT) and L;G f e =. e ',then G f e \n: L (under CT')where L is either C or fstrev(C). It is easy to show that translation succeeds when both \nclassand reviser tables are well typed. Then, we now have thetheorem that a pair of well-typed class \nand reviser tablestranslates to a well-typed class table. ' THEOREM 4. If (CT, RT) is OK, then there \nexists CTsuch '' that (CT, RT)=. CTand CTis OK. It is left for future work to prove that the translation \nalsopreserves semantics, meaning that no typecasts inserted bythe translation will fail.  6.4 Experiments \nAs we showed above, since within methods are transformed into normal method calls, the execution overheads \ndue tothem are extremely small. To investigate this fact, we per\u00adformed series of experiments on a machine \nwith Intel Core2 Duo E8500 3.16GHz processor, 3GB memory, GentooLinux with libc ver. 2.9, and Java 1.6.0 \n15 HotSpot Server VM (build 14.1-b02,mixed mode). Microbenchmark We evaluated the technique adopted by \nGluonJ as wellas several other possible implementation techniques. Forcomparison, we .rst implemented \na micro benchmark in\u00adcorporating several implementation techniques for within methods. It uses two classes \nT1 and T2 and one reviser R (see Figure 9). T2 extends T1 and R revises T1. Each 5 1 0 1 5 2 0 2 5 3 \n0  none static gluonj aspectj instanceof getclass dynamic Figure 10. Overheads of method dispatch \ntechniques. class/reviser declares a method tick and R s method has a predicate within C. The benchmark \ncalls tick from C on a various mixture of objects with static type T1. This oper\u00adation is repeated 10 \nmillion times in a hot loop, compiledby a JIT (Just-In-Time) compiler with the highest optimiza\u00adtion \nlevel. We found in initial experiments that uniform orclose to uniform distribution of object types results \nin a JITcompiler using additional optimizations and hence the com\u00adparison becomes biased towards cases \nwith less object di\u00adversity. To reduce this bias, callee objects of different typesare pseudo-randomlychosen \nat every call to tick. Figure 10 shows the results. The upper graph shows theresults when the code inlining \nby a JIT compiler is enabled.The lower graph shows the results when it is disabled. Thevertical axis \nrepresents the duration of a single iteration ofmicro benchmark in nano seconds. The horizontal axis \nrep\u00adresents implementation techniques for within methods. We examined seven techniques: none, gluonj, \nstatic, aspectj, in\u00adstanceof, getclass,and dynamic. Gray dots visible on thegraphs show the data points \nof measurement with a particu\u00adlar ratio of object mixture. When optimizations of the caller site are \npossible, likeguarded devirtualization, all implementation techniques ex\u00adhibit similar performance. none \npresents a reference point,where the method is not overridden. gluonj presents our im\u00adplementation. The \nreviser R is translated into a subclass of T1 (and a super class of T2). A within method tick is re\u00adnamed \ninto tick C and a call by C to tick is translated into a call to tick C. Thus,a tick C methodis also \naddedto T1 and T2. static is the same as gluonj except the body of a tick C method in T1 and T2 is a \ncopy of tick and thus it implies no overhead due to delegation. aspectj presents an equiva\u00adlent implementation \nin AspectJ. In instanceof and getclass,the caller calls tick C only when the receiver object is R;otherwise, \nit calls tick. instanceof checks the type by the in\u00adstanceof operator:  public void work(T1 ticker) \n{ if (ticker instanceof R &#38;&#38; !(ticker instanceof T2)) ticker.tick_C(); else ticker.tick(); } \nOn the other hand, getclass does this by the getClass method: public void work(T1 ticker) { if (ticker.getClass() \n== R.class) ticker.tick_C(); else ticker.tick(); } Finally, in dynamic, the caller object passes a Class \nobject representingthetypeofthecallerandthewithin methodtick in R checks it: public void tick(Class caller) \n{ if (caller == C.class) Microbench.count2 += 1; else Microbench.count1 += 1; } The DaCapo benchmarks \nNext, we used the DaCapo suite of benchmarks[5] to evalu\u00adate potential impact of within methods on real \napplications,especially in the cold code. To conservatively estimate theimpact,we directlyinstrumentedthebytecodeofall \napplica\u00adtion methods, which is structurally equivalent to an empty within method.Thus,allmethodcalls \n.rst invokethat within method, which delegates to the original one. We comparedseveral of the implementation \ntechniques mentioned above,those that can be easily imitated via code instrumentation. Figure 11 shows \nthe results on 8 of 11 DaCapo bench\u00admarks (the other benchmarks did not work after the instru\u00admentation). \nThe vertical axis represents the elapsed time ofeach run in seconds. A lower number is better. The horizon\u00adtal \naxis represents the iteration of the run from the 1st tothe 10th. A .rst few iterations show the performancebeforedeep \noptimization by a JIT compiler. Overhead of the instrumentation on the .rst iteration is up to 22% for \nwell-behaving benchmarks, and up to 151% for luindex. Note that we measured overheads of extreme cases, \nin which all methods are within methods. In real ap\u00adplications, most methods would not be within ones. \nSince the modi.cation to the benchmark bytecode is essentiallyredundant code, the impact is contained \nonly in a warm-upphase except for lusearch and luindex, which have thesame underlying software package, \nLucene. The cause ofsuch a drastic and constant slowdown remains a topic forfurther inquiry. However, \nin the two benchmarks,the imple\u00admentation technique of GluonJ shows the best performance.Forthe otherbenchmarks,the \nimpactof anyimplementationtechnique is negligible on the 10th iteration. 7. Related work Predicate dispatch \nThe original predicate dispatch allows only predicates thataccess variables locally visible in the static \nscope of amethod, such as parameters, the receiver object (i.e. this variable in Java), and their .elds. \nFor example, in JPred[32], a method can be selected only when a parameter valueis an instance of some \nclass. The predicates of JPred werecarefully selected by the JPred designer for modular compi\u00adlation. \nOn the other hand, GluonJ provides contextual predicatedispatch. The within predicate of GluonJ refers \nto external calling contexts, like who is a caller, since it must deal withcrosscutting structures, which \nintrinsically depend on theexternals.Thisfactremovessomelocalityfrommethodsandcomplicates modular compilation. \nHowever, as we showedabove,thecompilationof aGluonJprogramby ourcompileris still mostly modular. Presenting \nsimilarity between predicate dispatch and thepointcut-advice of AOP is not new. This idea has beenpointed \nout by other researchers [6, 21, 35] and ourselves[9]. The idea of method dispatch depending on a caller \nob\u00adjectisalso foundin[41].Ourcontributionis thatweactuallydesignand implementa languagebased on this \nidea and dis\u00adcussed modular typechecking and compilation. Other related work A unique feature of GluonJ \nis to provide OOP-based mech\u00adanisms for not only enabling destructive extension but alsolimiting its \nscope. Although limiting its scope has not gotmuch attention except in the AOP contexts, enabling de\u00adstructive \nextension has been actively studied in OOP. Forexample, MixJuice [23], Feature-Oriented Programming(FOP) \n[3], and JavaGI [45] enable this as much as AOPlanguages.Thepartialclasses ofC# allowaddingnew mem\u00adbers \nto an existing class. Categories in Objective-C also doso. Some researchers of FOP have suggested using \nAOPconstructssuchas pointcutand adviceforcrosscuttingstruc\u00adtures while using their OOP-based construct, \nwhich is a de\u00adstructive style of mixin, for destructive extension [2]. Theirproposalis a hybrid of OOP \nand AOP.  char t  0 2 4 6 8 0 5 1015202530  time, s 0 1 2 3 4 0.00.51.01.52.02.53.03.5 0 5 10 15012345 \n 246810 246810 246810 246810  246810 246810 246810 246810 iteration Figure 11. DaCapo benchmarks. \nOpenclasses[12]andexpanders[44]alsoenabledestruc\u00adtive extension although they can only append new methodsbut \ncannot override existing methods. They are using decla\u00adrations like using of GluonJ for modular typechecking. \nThework by Malabarba et al. [30] allows dynamically changingclass de.nitions. Classbox/J[4]andContext-OrientedProgramming(COP) \n[22] can apply destructive extension into only a limitedscope of program. However, their ability is not \nequivalentto the within/withincode pointcut of AspectJ or GluonJ scontextual predicate dispatch. They \ndo not enable executingextra code in the middle of an existing method body withoutmodifying the body. \nFor example, in Classbox/J, a new ex\u00adtension is applied and made effective only within a packageexplicitly \nimporting that extension. This import is described in the source code of the package, that is, the client-sidecode. \nOn the other hand, in GluonJ, where a new extensionis applied is described in the source code of that \nextension. J&#38;s [38] also supports destructive extension through themechanism called class sharing. \nAlthough there is no needto modify the original program that creates an object of amodi.ed class, a view \nchange operation has to be applied toenable access to new members. From a typechecking pointof view, \nthe view change operation plays a role somewhatsimilar to using declarations, but the execution model \nisrather different since new members do not always overrideold ones. AspectJ2EE [13] is an AOP system \nbut it has similarityto GluonJ since it implements an aspect by a subclass ofthe target class. However, \nit only supports the execution pointcut but not call or within pointcuts. Hence it cannotlimit the scope \nof extension. It does not provide the sameexpressiveness that GluonJ does.  An AOP language Hyper/J \n[36] might seem to adoptOOP-style constructs as GluonJ does. It allows implement\u00ading every concern by \na normal Java class like the partialclasses of C#. However, how to weave (combine) multipleclasses to \ncompose a complete class must be described sep\u00adarately in a dedicated language, which is far from typicalOOP \nlanguages like Java. We have been developing a series of AOP languages andsome of the languages inherited \nthe name GluonJ. However,there is no overlap among this paper and the others. Thedesign of those languages \nare different. The .rst GluonJ publishedin [11] used XML for describingaspects. The aimof this work was \nto allow programmers to .exibly controlthe construction of aspect instances. The second GluonJpublished \nin [33] is more similar to GluonJ presented in thispaper but it is a dynamic AOP language. The work focusedon \nhow to dynamically deploy intertype declarations.   8. Concluding remark We presented GluonJ, which \nsupports revisers and within methods for AOP. These mechanisms are natural enhance\u00adment to OOP ones and \nhence GluonJ can be compared withOOP languageson a side-by-sidebasis. We developeda for\u00admal system for \nGluonJ and rigidly presented that mostlymodulartypecheckingandcompilationispossible.SincetheAOP capabilityofGluonJis \na subset ofAspectJ s,extendingit and discussing its modularity is our future work. Through this work, \nwe observed that AOP does notlargely break modularity, relatively to OOP, but AOP loosesit to meet demands. \nSince crosscutting modules may con\u00ad.ict each other, the compatibility among the modules mustbe checked \nin an unmodularfashion with global knowledge.This is a source of the unmodularity of AOP. It might bepossible \nto avoid unmodular checking by restricting the ex\u00adpressive power of the language so that crosscutting \nmoduleswillnotcon.ict.Althoughthisapproachmakesthelanguagemore modular, we would have to give up the \n.exibility for implementing destructive extension. Our discussion in this paper is on modular typecheckingand \ncompilation; it is not on modular reasoning. However,our work would be a solid basis of further discussion \nof the modularity of AOP. Acknowledgement We thank Hidehiko Masuhara and other members of the Kumikiprojectfortheirhelpfulcommentsonthiswork.Thiswork \nwas partly sponsored by the KAKENHI program ofJSPS/MEXT of Japan.  References [1] Aldrich, J.: Open \nmodules: Modular reasoning about advice.In: ECOOP 2005. pp. 144 168. LNCS 3586, Springer-Verlag(2005) \n[2] Apel, S., Batory, D.: When to use features and aspects?: Acase study. In: Proc. of the 5th Int l \nConf. on GenerativeProgramming and Component Engineering (GPCE 06). pp.59 68. ACM Press (2006) [3] Batory, \nD., Sarvela, J.N., Rauschmayer, A.: Scaling step\u00adwise re.nement. IEEE Transactions on Software Engineering30(6), \n355 371 (2004) [4] Bergel, A., Ducasse, S., Nierstrasz, O.: Classbox/J: Control\u00adling the scope of change \nin Java. In: Proc. of ACM OOPSLA.pp. 177 189 (2005) [5] Blackburn,S.M.,etal.:TheDaCapobenchmarks:Javabench\u00admarking \ndevelopment and analysis. In: Proc. of ACM OOP-SLA. pp. 169 190. ACM (2006) [6] Bockisch, C., Haupt, \nM., Mezini, M.: Dynamic virtual joinpoint dispatch. Workshop on Software Engineering Propertiesof Languages \nand Aspect Technologies (SPLAT 06) (2006) [7] Bracha, G., Cook, W.: Mixin-based inheritance. In: Proc. \nofOOPSLA/ECOOP 90. pp. 303 311. ACM Press (1990) [8] Chiba, S.: Load-time structural re.ection in Java. \nIn: ECOOP 2000. pp. 313 336. LNCS 1850, Springer-Verlag (2000) [9] Chiba, S.: Predicate dispatch for \naspect-oriented program\u00adming. In: the 2nd Workshop on Virtual Machines and Inter\u00admediate Languages for \nemerging modularization mechanisms(VMIL 08). pp. 1 5. ACM (2008) [10] Chiba, S., Igarashi, A., Zakirov, \nS.: Mostly modular com\u00adposition of crosscutting structures by contextual predicatedispatch. Research \nReports C-267, Dept. of Math. and Comp. Sciences, Tokyo Institute of Technology (December2009) [11] Chiba, \nS., Ishikawa, R.: Aspect-oriented programming be\u00adyond dependency injection. In: ECOOP 2005. pp. 121 143.LNCS \n3586, Springer-Verlag (2005) [12] Clifton, C., Leavens, G.T., Chambers, C., Millstein, T.: Mul\u00adtiJava: \nmodular open classes and symmetric multiple dispatchfor Java. In: Proc. of ACM OOPSLA. pp. 130 145. ACMPress \n(2000) [13] Cohen, T., Gil, J.Y.: AspectJ2EE = AOP + J2EE : Towardsan aspect based, programmable and \nextensible middlewareframework. In: ECOOP 2004 Object-Oriented Program\u00adming. pp. 219 243. LNCS 3086 \n(2004) [14] Ekman, T., Hedin, G.: The Jastadd extensible Java compiler.In: Proc. of ACM OOPSLA. pp. 1 \n18. ACM (2007) [15] Ernst, E.: Family polymorphism. In: ECOOP 2001 Object-Oriented Programming. pp. \n303 326. LNCS 2072, Springer-Verlag (2001) [16] Ernst, M., Kaplan, C., Chambers, C.: Predicate dispatching: \nAuni.ed theory of dispatch. In: ECOOP 98 -Object-OrientedProgramming. pp. 186 211. Springer-Verlag (1998) \n[17] Filman, R.E., Friedman, D.P.: Aspect-oriented programmingis quanti.cation and obliviousness. In: \nFilman, R.E., Elrad, T.,Clarke,S.,Aks\u00b8it, M. (eds.) Aspect-Oriented Software De\u00advelopment, pp. 21 35. \nAddison-Wesley (2005)  [18] Fraine,B.D.,S\u00a8udholt,M.,Jonckers,V.:Strongaspectj: .exible and safe pointcut/advice \nbindings. In: Proc. of 7th Int l Conf.onAspect-Oriented SoftwareDevelopment (AOSD2008). pp.60 71. ACM \n(2008) [19] Griswold, W.G., et al.: Modular software design with cross\u00adcutting interfaces. IEEE Software \n23(1), 51 60 (2006) [20] Hannemann, J., Kiczales, G.: Design pattern implementationin java and aspectj. \nIn: Proc. of ACM OOPSLA. pp. 161 173(2002) [21] Haupt, M., Schippers, H.: A machine model for aspect\u00adoriented \nprogramming. In: ECOOP 2007 Object-OrientedProgramming. LNCS, vol. 4609, pp. 501 524 (2007) [22] Hirschfeld, \nR., Costanza, P., Nierstrasz, O.: Context-orientedprogramming. Journal of Object Technology 7(3), 125 \n151(2008) [23] Ichisugi, Y., Tanaka, A.: Difference-based modules: A class\u00adindependent module mechanism. \nIn: ECOOP 2002 Object-Oriented Programming. pp. 62 88. LNCS 2374 (2002) [24] Igarashi, A., Pierce, B.C., \nWadler, P.: Featherweight Java: Aminimal core calculus for Java and GJ. ACM Trans. Prog.Lang. Syst. 23(3), \n396 450 (May 2001) [25] Kiczales, G., Lamping, J., Mendhekar, A., Maeda, C., Lopes,C., Loingtier, J., \nIrwin, J.: Aspect-oriented programming. In:ECOOP 97 Object-Oriented Programming. pp. 220 242.LNCS 1241, \nSpringer (1997) [26] Kiczales, G., Hilsdale, E., Hugunin, J., Kersten, M., Palm, J.,Griswold, W.G.: An \noverview of AspectJ. In: ECOOP 2001 Object-Oriented Programming. pp. 327 353. LNCS 2072,Springer (2001) \n[27] Kiczales, G., Mezini, M.: Aspect-oriented programming andmodular reasoning. In: Proc. of the Int \nl Conf. on SoftwareEngineering (ICSE 05). pp. 49 58. ACM Press (2005) [28] Koppen, C., Stoerzer, M.: \nPcdiff: Attacking the fragile point\u00adcut problem. In: Proc. of European Interactive Workshop onAspects \nin Software (EIWAS 04) (2004) [29] Lesiecki, N.: Improve modularity with aspect-oriented programming. \nhttp://www.ibm.com/developerworks/ java/library/j-aspectj (2002) [30] Malabarba, S., et al.: Runtime \nsupport for type-safe dynamicJava classes. In: ECOOP 2000. pp. 337 361. LNCS 1850,Springer-Verlag (2000) \n[31] McEachen, N., Alexander, R.T.: Distributing classes with wo\u00adven concerns: an exploration of potential \nfault scenarios. In:Proc. of Int l Conf. on Aspect-Oriented Software Develop\u00adment (AOSD 05). pp. 192 \n200. ACM Press (2005) [32] Millstein, T.: Practical predicate dispatch. In: Proc. of ACMOOPSLA. pp. 345 \n364. ACM (2004) [33] Nishizawa, M., Chiba, S.: A small extension to Java for class re.nement. In: Proc. \nof the 23rd ACM Sympo. on AppliedComputing (SAC 08). pp. 160 165 (2008) [34] Nystrom, N., Chong, S., \nMyers, A.C.: Scalable extensibilityvia nested inheritance. In: Proc. of ACM OOPSLA. pp. 99 115 (2004) \n[35] Orleans, D.: Separating behavioral concerns with predicatedispatch, or, if statement considered \nharmful. In: Workshopon Advanced Separation of Concerns in Object-Oriented Sys\u00adtems at OOPSLA 01 (2001) \n[36] Ossher, H., Tarr, P.: Hyper/J: multi-dimensional separation ofconcerns for Java. In: Proc. of the \nInt l Conf. on Software Engineering (ICSE). pp. 734 737 (2000) [37] Parnas, D.L.: Information distributions \naspects of designmethodology. In: Proc. of IFIP Congress 71. pp. 26 30(1971) [38] Qi, X., Myers, A.C.: \nSharing classes between families. In:Proc. of Conf. on Programming Language Design and Imple\u00admentation. \npp. 281 292 (2009) [39] Sch\u00a8arli, N., Ducasse, S., Nierstrasz, O., Black, A.: Traits:Composable units \nof behavior. In: Proceedings of EuropeanConference on Object-Oriented Programming (ECOOP 03).LNCS, vol. \n2743, pp. 248 274. Springer Verlag (July 2003) [40] Smaragdakis, Y., Batory, D.: Mixin layers: an object-orientedimplementation \ntechnique for re.nements and collaboration\u00adbased designs. ACM Trans. Softw. Eng. Methodol. 11(2),215 \n255 (2002) [41] Smith, R.B., Ungar, D.: A simple and unifying approach tosubjective objects. Theory and \nPractice of Object Systems2(3), 161 178 (1996) [42] Steimann, F.: The paradoxical success of aspect-oriented \npro\u00adgramming. ACM SIGPLAN Notices 41(10), 481 497 (2006) [43] Stoerzer, M., Graf, J.: Using pointcut \ndelta analysis to supportevolution of aspect-oriented software. In: ICSM 05: Proceed\u00adings of the 21st \nIEEE International Conference on SoftwareMaintenance. pp. 653 656. IEEE Computer Society (2005) [44] \nWarth, A., Stanojevi\u00b4c, M., Millstein, T.: Statically scopedobject adaptation withexpanders. In:Proc.ofACMOOPSLA.pp. \n37 56 (2006) [45] Wehr, S., L\u00a8ammel, R., Thiemann, P.: JavaGI: Generalized in\u00adterfaces for Java. In: \nECOOP 2007 Object-Oriented Pro\u00adgramming. LNCS 4609, Springer-Verlag (2007), 347 372 [46] Wright, A.K., \nFelleisen, M.: A syntactic approach to typesoundness. Information and Computation 115(1), 38 94 (Nov1994) \n  \n\t\t\t", "proc_id": "1869459", "abstract": "<p>The modularity of aspect-oriented programming (AOP) has been a controversial issue. To investigate this issue compared with object-oriented programming (OOP), we propose a simple language providing AOP mechanisms, which are enhanced traditional OOP mechanisms. We also present its formal system and then show that programs in this language can be only <i>mostly</i> modularly (<i>i.e.</i> separately) typechecked and compiled.We mention a source of this unmodularity and discuss whether or not it is appropriate to claim that AOP breaks modularity compared with OOP.</p>", "authors": [{"name": "Shigeru Chiba", "author_profile_id": "81100060268", "affiliation": "Tokyo Institute of Technology, Tokyo, Japan", "person_id": "P2354100", "email_address": "", "orcid_id": ""}, {"name": "Atsushi Igarashi", "author_profile_id": "81309510908", "affiliation": "Kyoto University, Kyoto, Japan", "person_id": "P2354101", "email_address": "", "orcid_id": ""}, {"name": "Salikh Zakirov", "author_profile_id": "81470654573", "affiliation": "Tokyo Institute of Technology, Tokyo, Japan", "person_id": "P2354102", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869503", "year": "2010", "article_id": "1869503", "conference": "OOPSLA", "title": "Mostly modular compilation of crosscutting concerns by contextual predicate dispatch", "url": "http://dl.acm.org/citation.cfm?id=1869503"}