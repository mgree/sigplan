{"article_publication_date": "10-17-2010", "fulltext": "\n Registration-Based Language Abstractions Samuel Davis Department of Computer Science University of \nBritish Columbia Vancouver, BC, Canada sddavis@cs.ubc.ca Abstract Programming language innovation has \nbeen hindered by the dif.culty of making changes to existing languages. A key source of dif.culty is \nthe tyrannical nature of existing ap\u00adproaches to realizing languages adding a new language construct \nmeans that any tool, document or programmer that works with the language must be prepared to deal with \nthat construct. A registration-based approach makes it possible to de.ne language constructs that are \nnot tyrannical. They are instead transient the program appears to be written using the con\u00adstructs only \nso long as a given programmer wants to see it that way. This approach may have the potential to greatly \nfacilitate programming language innovation. Categories and Subject Descriptors D.2.3 [Software En\u00adgineering]: \nCoding Tools and Techniques Program editors; D.3.3 [Programming Languages]: Language Constructs and Features \nGeneral Terms Languages, Experimentation Keywords Registration, Fluid AOP, Programming Tools 1. Introduction \nProgramming language design research has sought to im\u00adprove software development practice by developing \nnew constructs and languages that make programs more expres\u00adsive, modular, .exible, reliable, valuable \nand pleasant to develop. There have been signi.cant accomplishments in a wide range of sub.elds including \nobject-oriented program\u00adming, functional programming, logic and constraint pro\u00adgramming, type systems, \netc. Despite the technical quality of these contributions, they have, by and large, been adopted fairly \nslowly. In particular, Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. Onward! 2010, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright c &#38;#169; 2010 \nACM 978-1-4503-0236-4/10/10. . . $10.00 Gregor Kiczales Department of Computer Science University of \nBritish Columbia Vancouver, BC, Canada gregor@cs.ubc.ca it has been dif.cult to adopt research results \nas incremen\u00adtal improvements to existing languages, which we refer to in this paper as language design \ninnovation. This slow rate of innovation stands in contrast to certain other areas of soft\u00adware development \nresearch. For example, work on design patterns and refactoring have both spread very quickly by comparison \nwith most language innovation. Similarly, the Mylyn Eclipse plug-in (n\u00b4ee Mylar) [5, 6], went from initial \nrelease in 2005 to daily use by 500,000 programmers in 2010 [10]. Is this simply the way it has to be \nfor programming lan\u00adguage innovation? Are the fruits of language design research inevitably destined \nto be adopted more slowly than results from other areas of software development research, even when there \nappears to be no fundamental con.ict between the research result and existing languages? In this paper \nwe present the results of an experiment in reframing the programming language innovation equation. We \nare asking whether the form in which language innova\u00adtions are realized today sets up inherent obstacles \nthat im\u00adpede adoption, and whether a different way of delivering programming language innovations could \nchange the adop\u00adtion equation. Our hypothesis has several parts: To date, the way in which programming \nlanguage innova\u00adtions are realized makes them tyrannical.1 A program is not just an executable representation \nof a desired compu\u00adtation, it is the only such representation, and so to change the desired computation, \nthe programmer must compre\u00adhend and edit the program itself.  One consequence of this tyranny is that \nany programmer working with a language must at least understand (if not actually like) any newly adopted \nconstructs. This leads to a high training cost of adoption for new constructs programmers, testers, support \ntechnicians, etc. all must be trained, and this in turn requires development of a variety of training \nmaterials.  1 Our use of the term tyrannical is due to Tarr et. al., who use it to describe a closely \nrelated phenomenon [17]. This similarity is discussed further in Section 5.  In addition there is a \nhigh tooling cost of adoption as every tool in an increasingly deep and wide tool chain must support \nany new constructs.  These costs mean that a high degree of consensus is required from a large number \nof stakeholders before new language constructs can be adopted.  In our proposed new approach what the \nprogrammer sees and edits as the program is actually an automatically generated abstraction of the underlying \nsource code. In contrast to techniques such as syntactic macros, in our approach the abstraction is derived \nfrom the executable code rather than the other way around.  Using the new approach, constructs can be \nadded to a language simply by de.ning new automatically recog\u00adnized abstractions. Different programmers \nand organiza\u00adtions can use different language abstractions as they see .t. When and if a new construct \ngarners signi.cant con\u00adsensus more traditional realization of the concept can be considered; the signi.cant \nadoption costs are delayed un\u00adtil that point.  1.1 A First Example Step back in time to Java 1.4 and \nconsider the adoption of for-each syntax for simple loops over natural numbers such as is provided by \nthe Python for-each syntax and range primitive [11]. A simple Java adaptation of that functionality could \nbe used to rewrite loops such as this one: for ( int i= 0 ; i < columnCount ; validColumns . s e t ( \ni ) ; i ++) (A) as follows: for ( int i : r a n g e ( columnCount ) ) (B) validColumns . set ( i ); \n The bene.ts of more abstract (higher-level) language constructs such as this are familiar: the code \nis more con\u00adcise, less detailed, and common cases appear in a canonical form. As a result the code is \neasier to maintain (comprehend and modify) and some common mistakes are eliminated. But, as suggested \nabove, changing the language to add a construct such as this is problematic. A large group of stakeholders \nmust be convinced, signi.cant resources must be expended, and, as we shall see, even after that is done \nongoing disagreement and/or tooling problems can lead to a long trailing edge of adoption. In Figure \n1 we show our alternative approach to adding more abstract language constructs to programming lan\u00adguages. \nThe screenshot shows how a programmer could choose to see a method including such a loop in our editor. \nWhat is displayed is an automatically generated abstraction of the loop that makes it look like the program \nis written in a language that supports the for-each in range construct (as in B above) even though the \nactual program text is an ordinary Java 1.4 for loop (as in A). The purple ball in the margin indicates \nto the programmer that they are seeing such an ab\u00adstraction. The programmer can edit the abstraction \nfreely as long as the edits have a clear meaning with respect to the underlying code. The programmer \ncan click the purple ball to cause the editor to revert to the underlying code. Or they can disable the \nfor-each in range abstraction entirely. 1.2 Registration Our understanding of this kind of abstraction \nis based on Brian Smith s description of a concept called registra\u00adtion [14]. To understand registration, \nconsider the personal experience of coming to perceive part of a program in a cer\u00adtain way. For example, \nreading the ordinary for loop labeled A above, and coming to understand it it as a for-each in range \nloop like B above. We use the term registration to mean the work done to frame or understand part of \na program a cer\u00adtain way, the work to maintain that framing in the face of change and passing time, and \nthe framing itself. For a regis\u00adtration to be communicated, we say that it must be presented in some \nform. Furthermore, for registration presentations to serve as a way of editing programs they must be \nmade effective editing the presentation must have a predictable editing effect on the program. Our registration-based \neditor is constantly scanning the program trying to form registrations of latent abstractions in the \ncode. When a registration forms, it is then presented to the programmer as an editable form of the abstraction. \nThe programmer can edit the registration as long as that has a well-de.ned effect on the actual program. \nBut some edits inherently cause a registration to break down. If for example, the programmer adds an \nassignment to i in the body of the loop in Figure 1, then the registration as a simple for each in range \nloop breaks down, and our editor dissolves the presentation to show the plain underlying code. A guiding \nprinciple of this work has been to accept the fact that registrations break down as part and parcel of \nwhat makes them powerful. In exchange, the concept of registra\u00adtion has allowed us to implement language \nabstractions in a non-tyrannical way. In the next section we present the core architecture of our editor. \nThis is followed by discussion of the registrations we have implemented to date in Section 3. We follow \nthis with an initial evaluation in Section 4, followed by three sections on related work, future work \nand a summary. 2. Architecture The kernel of our registration-based abstraction (RBA) edi\u00adtor consists \nof three elements: (i) a visible editor containing an editable presentation of the program, (ii) a hidden \neditor containing the actual underlying program, and (iii) a corre\u00adspondence structure describing how \nthe contents of the visi\u00adble editor and hidden editor are related. On top of this kernel is a framework \nthat facilitates de.ning new registrations.  Figure 1: Fragment of Apache Derby code as seen in our \neditor. The third statement in the body of the method is a for-each in range registration-based abstraction \n(RBA). A purple ball in the margin indicates the presence of an RBA. Clicking on the ball forces the \nregistration to break down or, in cases where more than one registration applies, selects the next one. \nHovering over the RBA causes the underlying code to appear. The .rst and last statements in the method \nare multiple-.eld assignment RBAs; in the second a deliberately introduced error results in a compiler \nerror appearing properly in the presentation. 2.1 Correspondence Structure The top part of Figure 2 shows \nhow the architecture sup\u00adports the for-each in range example introduced above. On the left is the the \neffective presentation (in the visible editor) we want the programmer to see and edit, on the right is \nthe underlying code (in the hidden editor). The .gure illustrates most of the correspondence mapping \nrequired between the visible editor and the hidden editor. In particular, a registra\u00adtion must be able \nto: Cause the visible editor to contain added text that does not appear in the original program, e.g. \nthe characters : range( .  Contain text in a 1:1 correspondence with text in the original program. \nThe characters for(int correspond 1:1 with characters in the hidden editor.  Contain text in a 1:n correspondence \nwith text in the original program. The character i in the .rst line is in a 1:3 correspondence with the \nthree occurrences of i in the for loop control clause in the hidden editor.  Contain text in a m:1 correspondence \nwith text in the original program. This is not required for the for-each in range registration, but the \ndelegate registration discussed in Section 3.2, which summarizes a class s delegation be\u00adhavior, requires \nthe names of a class s implemented inter\u00adfaces to appear in multiple places in the visible editor.  \nControl the editing of text in the visible editor, in particu\u00adlar, to prevent editing of added text, \nand cause editing of  other text to edit through to the corresponding hidden ed\u00aditor. For example, if \nthe programmer edits the name of the variable i, all three occurrences in the for loop s control clause \nshould change in the hidden editor. Cause editing of text in the hidden editor to edit through to the \ncorresponding text in the visible editor. This makes it possible for pre-existing refactoring and other \nhigh\u00adlevel editing operations to still operate on the hidden editor, where there is no surprising syntax, \nbut have those edits still be re.ected back into the visible editor.  Cause keyword highlighting, compiler \nwarnings, quick\u00ad.xes, refactoring menus and other annotations and menus that the IDE attaches to text \nin the hidden editor to be propagated to the visible editor (optionally under control of the registration). \nFor example, in the for-each in range case if the loop variable declaration rede.nes an existing variable \na typical Java IDE will display some indication of the compiler warning at the variable declaration. \nWe would like those markers to appear in the visible editor.  The correspondence structure that ful.lls \nthese require\u00adments is built on core elements typical to IDEs, speci.cally: editors, sometimes called \nbuffers, that contain program text and provide primitive operations on that text; regions that identify \na contiguous span of characters in an editor; and a noti.cation mechanism for registering listeners to \nbe noti.ed when there is a change to a region. The correspondence between the visible and hidden edi\u00adtor \nis represented using region objects. For the visible editor Figure 2: The upper part of the .gure shows \nthe correspondence structure corresponding to the for-each in range example in Section 1. The visible \neditor is on the left, the hidden editor is on the right. Regions are underlined and numbers indicate \ncorrespondences between visible and hidden regions. A indicates added text in the visible editor. The \ncircles indicate a single linked region group. The lower part of the .gure is the implementation of the \nfor-each in range registration. (C) marks the pattern that matches loops like the one in the upper right. \n(D) and (E) mark the method calls that build the correspondences in the upper part of the .gure.  defineRegistration \n( \" for -e a ch i n range \" , \" for ( $type $ i = 0 ; $ i < $u ; $ i ++) [N[C[A $ i ] ] ] \" , (C) new \nMatchHandler ( ) {public Registration matched ( Presenter pres enter ) {p r e s e n t e r . replace ( \ngetEncl osingCo ntrolCl ause ( \" $i \" ) , (D) \" $type $ i : range ( $u ) \" ); presenter . link ( a l \nl H R e g i o n s ( \" $i \" )); (E) return p r e s e n t e r . makeRegistration ( ) ; } ); } we maintain \nan ordered list of non-overlapping visible re\u00adgions that completely tile the editor. Each visible region \nei\u00adther corresponds to added text or is in a 1:1 relationship with a hidden region. A list of hidden \nregions represents parts of the hidden editor; hidden regions can overlap, thus the list of hidden regions \nis a partial order. Finally, for the hidden editor we maintain groups of linked regions. The correspondence \nstructure is used to propagate edits back-and-forth between the editors, as well as to propagate annotations \nand context-dependent commands from the hid\u00adden to the visible editor. Visible and hidden regions are \nkept synchronized through all editing operations. A change the user makes to the visible editor propagates \nto the hidden one. Similarly, a change that a refactoring or other command makes to the hidden editor \npropagates to the visible editor. In addition, annotations such as keyword highlighting, compiler warnings, \ncontext menus etc. propagate from the hidden to the visible editor. The text of regions in each linked \nregion group is kept synchronized, but annotations are not propagated among linked regions. 2.2 Registration \nFramework This kernel architecture is wrapped in a framework that makes it easy to de.ne new registrations. \nUsing the frame\u00adwork we currently have 16 registrations implemented. The median length of of these is \n40 SLOC and the longest is 223 SLOC. When implementing individual registrations the corre\u00adspondence structure \nis not accessed directly, instead the framework provides a declarative pattern language used to .nd possible \nregistrations in the underlying program and a set of methods used to describe the editable presentation \nin terms of speci.c pattern match instances and new text. A simpli.ed version of the for-each in range \nregistra\u00adtion implementation is shown in Figure 2. The second ar\u00adgument to defineRegistration (marked \nC) speci.es what source code patterns this registration matches. The pattern language is matched against \nan AST using the technique described in [19], in which the matcher re\u00adcursively unparses the AST as it \nmatches the pattern. This approach makes it easy for us to support full Java syntax. It also means that \npattern variables can stand for any AST node, which allows patterns to be focused on only the points \nrelevant to that pattern. The pattern language also includes a small set of special commands. In the \npattern in Figure 2, the [N [C [A $i]]] in the body of the for loop means match a statement or block \nthat does not contain assignments to the loop variable $i. By default what appears in the visible editor \nis the orig\u00adinal underlying program: a single visible region that corre\u00adsponds to a single hidden region. \nWhen the pattern matches, the matched method is called to create a Registration. The matched method can \nchange the visible editor by constructing a new presen\u00adtation for (part of) the visible editor. (Or it \ncan decline if, after further analysis, it determines the registration should  (a) A triply-nested \nloop as registered by the nested for-each in range registration. The variables i, j and k range over \nthe intervals 0 to 100,0to 25 and0to 50 respectively. (b) A parallel for-each loop registration. At \neach iteration of the loop the child and balloon variables both advance to the next element in children \nand balloon respectively. The loop terminates when it reaches the end of either collection. (c) A loop \nover object chain registration. The square brackets and + around the method name indicate that it loops \nover one or more calls to getParent(). The .rst value of ancestor is the result of node.getParent(). \nEach successive value is the result of ancestor.getParent(). The loop terminates when getParent() returns \nnull. (d) A for each key-value pair registration. file and document are bound to the key and value of \nsuccessive Map.Entry elements of XMLDocuments.   Figure 3: Four special-case for-each loop registrations. \nnot match.) The matched method can access bound vari\u00adables from the pattern. In the example in Figure \n2, the call to replace (labeled D) speci.es that part of the visible text (the entire for loop control \nclause) will be replaced with a combination of added text, speci.cally : range( and ) , as well as selections \nfrom the original program ( $type $i and $u ). Places where the second argument to replace uses variables \nestablish a visible to hidden region correspon\u00addence. The call to link (labeled E) establishes a single \nlinked region group for all the occurrences of i in the loop control clause. The framework continually \nchecks de.ned registration patterns, so that as the program is edited new registrations can form and \nold ones can either be maintained or break down. Our implementation uses the AST provided by the underlying \nIDE, and registration updates are therefore some\u00adtimes delayed if the IDE s robust parser cannot form \nan AST. As registrations match, build presentations and later break down, there is a natural tendency \nfor the region struc\u00adture in both editors to become fragmented. The framework prevents this by re-aggregating \nregions when registrations and their presentations break down. In some cases more than one pattern can \nmatch the same part of the underlying program. In this case the registration that produces the most spanning \npresentation is used by de\u00adfault. The programmer can click on the purple ball to select the others. This \nmakes it possible for different programmers to choose to see and edit different abstractions of the same \ncode, or for one programmer to shift the code from one ab\u00adstraction to another, all without actually \nchanging the code. 3. Implemented Registrations In this section we discuss the registrations we have \nimple\u00admented to date. We begin by discussing two points related to the for-each in range discussion introduced \nabove. First we note that the correspondence structure supports natural editing of the presented for-each \nin range abstrac\u00adtion. Changes to the upper bound (the argument to range) edit through to the hidden \nregion, as do changes to the body of the loop. Changes to the loop variable name .rst edit through to \nthe hidden region, and then the linked region group causes the other two hidden regions to be updated. \nAdding an assignment to the loop variable in the body of the loop causes the pattern to no longer match \nand the registra\u00adtion then breaks down.  The for-each in range example illustrates a common is\u00adsue in \ndesigning registration presentations. The presentation makes it appear that range is a function (method) \nas it is in Python. But the real semantics of the underlying code is somewhat different, in particular \nin the underlying code the upper bound expression is evaluated each time through the loop. We have considered \na different presentation for range, such as italics or a different style of parentheses to denote the \nnon-strict argument evaluation. But for now we .nd the presence of the purple ball in the margin as an \nindication that what we are seeing is an abstraction of the underlying code suf.cient. Nested for-each \nin range Having implemented for-each in range, we began to see such loops appear nested inside each other \nand realized we could de.ne a registration that abstracts the nested loops to make their structure more \nexplicit. The abstract presentation uses a cartesian product notation using the \u00d7 character. (The use \nof special characters and graphics in presentations is discussed in more depth in Section 3.2.) Figure \n3a shows an example of a triply-nested loop registered this way. Ap\u00adpendix A provides the underlying \nJava source code for this and all other examples in the paper. The nested for-each in range registration \nuses a mecha\u00adnism in our pattern language that enables recursive patterns. Explicit iterators as for-each \nloops We also implemented a registration that matches loops that make explicit use of iterators and presents \nthem as if they had been converted to use the Java 1.5 for-each syntax. Some of these loops contain code \nto remove the current loop item using the iterator. Since removing an item requires explicit access to \nthe iterator, this code cannot normally be written in the 1.5 for-each syntax. The registration handles \nthis special case by presenting the removal as a special <<remove item>> statement in the body of the \nloop. This example highlights the question of whether and how to support programmers writing new code \n(including addi\u00adtions to existing code) in terms of registrations. The sim\u00adplest approach is to use IDE \ntemplates or code generation commands to generate code and to de.ne a registration that matches such \ncode. Eclipse includes templates and code gen\u00aderation commands that correspond to several of the registra\u00adtions \nwe de.ne. Because registrations can use non-standard characters and even graphics, simply typing code \nusing registration syntax will not work in general. But many special cases could be handled. Parallel, \nobject chain and key-value for-each loops We de.ned registrations to handle three additional loop cases. \nIn the .rst, the pattern identi.es loops that make ex\u00adplicit use of iterators to loop through several \ncollections in parallel. This is presented as a simple parallel loop syntax as shown in Figure 3b. In \ndeveloping our editor we found ourselves reading a lot of code with loops that run through an object \nchain. For example, starting with a node and following its ancestor link, and then that node s ancestor, \nand so on until the chain ends or some other condition is satis.ed. To make this code easier to read \nwe de.ned a registration to match such cases and present them using the syntax shown in Figure 3c. An \nadditional loop registration provides a more compact and abstract syntax for looping over key-value pairs \nin maps. The explicit Java code to do this is cumbersome because it involves a loop over the map entry \nelements of the map together with explicit destructuring of the map entry into its key and value components. \nAs shown in Figure 3d we register such loops into a simple destructuring syntax using an arrow to express \nthe key to value relation. Appendix A shows how the underlying Java code looks, both in Java 1.4 and \n1.5. Figure 8 contains two further examples of this registration. 3.1 Registrations abstracting over \nsuccessive statements The registrations presented in this section match succes\u00adsive statements and present \nan abstraction of their combined meaning. The .rst registration matches cases in which as\u00adsignments to \nmultiple .elds of the same object follow one another directly in the code. It registers those assignments \ninto a more compact syntax similar to the multiple assign\u00adment construct in Python. An example of the \nmultiple-.eld assignment registration appears as the .rst statement in Figure 1. Constructors such as \nthis one are a common place for this registration to match. A second example appears as the last statement \nin the .gure, and shows a compiler warning that has been propagated from a hidden region to the corresponding \nvisible region. As before, the correspondence structure automatically supports the programmer editing \nthe presentation, in partic\u00adular the .eld names and assigned value expressions. In addi\u00adtion, an IDE \nrename .eld operation on the class is immedi\u00adately re.ected in the registrations. Adding a new assignment \nimmediately before or after one of these registrations causes the pattern to match one more assignment \nthe programmer sees the presentation update to include the new assignment. Several other registrations \nthat abstract over successive statements are illustrated in Figures 4 and 5. The .rst of these registers \nsuccessive statements that build up a map as a single map construction, and builds on the syntax established \nby the for-each key-value pair registration to make that more expressive. As shown in Figure 4a this \nregistration can cause code that builds a static table to look like the table itself. Figure 8 shows \nhow the same presentation is used when adding a single element to an existing map.  (a) Fragment of \ncode from AspectJ weaver as abstracted by the map registration. A sequence of statements calling the \nput method to build a map are abstracted as one coherent entity, a map using arrows to indicate the mappings. \n (b) Example from Apache Harmony illustrating three array-assign registrations. Each registration abstracts \nmultiple assignments to sequential array indices to a single assignment to a half open interval. The \nthird array-assign registration has been dissolved to show the underlying code, and this is indicated \nby the lighter shade of the corresponding purple ball.  Figure 4: Map and array assignment registrations \nabstract over successive statements. Four registrations work together to abstract common ar\u00adray operations. \nThe array assignment registration matches assignments to successive elements of an array, and uses an \nassignment to interval notation to present these cases. Three matches of this registration are shown \nin Figure 4b; the last of these has been dissolved. Figure 5a shows how array con\u00adcatenations are abstracted \nusing an overloaded + syntax. Fig\u00adure 5b shows how arraycopy statements are presented using an assignment \noperator decorated to illustrate the copying. Together, as shown in Figure 5, the last two registrations \nmake it possible to work with some array code at three lev\u00adels of abstraction. By default the most abstract \noverloaded + form is seen, that can be dissolved to array-copy registra\u00adtions, which can themselves be \ndissolved to see the under\u00adlying calls to System.arraycopy. A fourth registration (not shown) provides \nsimpler syntax for adding an element to an array. 3.2 Extended Graphics in Registrations Several of \nthe registrations discussed above make use of special characters and icons to make their presentations \nmore expressive. But the fact that registrations are not the unique effective representations of the \nprogram they are not tyrannical allows us signi.cantly more .exibility to use graphics to make the registrations \nmore expressive. We do not have to con.ne ourselves to syntax that could be a  (a) An array-concatenation \nregistration. The presentation uses an overloaded + to indicate the concatenation of two arrays through \ncalls to System.arraycopy. (b) Two arraycopy registrations. The notation 0 : * indicates that the elements \nare copied into the indices starting at 0. An icon is used to disambiguate the syntax, by making it clear \nthat the dependents array is not truncated to the length of the copied elements.   (c) The arraycopy \nregistrations have been dissolved to reveal the underlying calls to arraycopy. Figure 5: A single method \nfrom Eclipse PDE shown at three different levels of abstraction. In 5a, the con\u00adcatenation of two arrays \nis abstracted by an array-concatenation registration. In 5b, the array-concatenation registration has \nbeen dissolved to reveal the calls to System.arraycopy, but these are abstracted as ar\u00adraycopy registrations. \nIn 5c, the registrations are all broken down and the underlying code is shown. (The class BundleDescription \nis renamed above to save space.) compatible extension to Java, our main requirement is that it be more \nexpressive to programmers. With this in mind, we have de.ned several registrations that use simple graphics \nin their presentations. Runnable The .rst example of a registration like this has to do with im\u00adproving \nthe much maligned (and deservedly so) syntax for runnables in Java. From a pattern matching perspective \nthis registration is straightforward, it uses the declarative pattern language to match code creating \nanonymous runnables. As shown in Figure 6 the presentation uses additional frame\u00adwork mechanisms to draw \na labeled box around the body of the runnable and elides the worst of the anonymous class syntax (see \nAppendix A for the plain Java code). The net effect is that the box looks something like a lambda expres\u00adsion. \nOur current implementation of the runnable registra\u00adtion also matches SafeRunnable and Action. It might \nbe appropriate to introduce a form that matches any one method anonymous class. Again, in this approach, \nthat is something any programmer could introduce for themselves if they wanted it. Getter/Setter One \nof the .rst registrations we implemented has to do with getter and setter methods. As shown in Figure \n7 the presen\u00adtation elides the actual getter and setter methods and instead attaches declarations to \nthe right of .eld declarations indicat\u00ading whether they have getter or setter methods. Getter/setter \ndeclarations include the access modi.er and pre.x for the methods, so the prototypical getter declaration \nis Getter: public get. If the return type is different than the type of Figure 6: Example from Eclipse \nUI showing how a runnable registration abstracts over the Java anonymous class syntax. Note that the \nbody of the runnable includes a for-each in range abstraction.   Figure 7: Example from Eclipse containing \nfour registrations. The part .eld has a getter method with the pre.x get. The site .eld has a getter \nmethod called getWorkbenchPageSite. In addition, it is the delegation target for three of the methods \nfrom IHistoryPageSite. The constructor has a multiple-.eld assignment.  Figure 8: A screenful of code \nfrom AspectJ Development Environment selected to show eight registrations. The top two lines contain \nmap registrations. These are followed by the allocation of an array, allSourceFolders, and a range registration \nof the code which populates it. If the array is not completely .lled, it is then truncated, and this \nis abstracted as an arraycopy registration. The two nested for loops abstract while loops in the underlying \ncode: in the outer loop, a loop using an explicit iterator is abstracted as a for-each loop; the inner \nloop is a key-value for-each abstraction. Finally, the image shows another map registration and another \nkey-value for-each registration. (We have added line breaks and removed unnecessary type quali.ers both \nabove and in Appendix A for spacing reasons.) the .eld it is also listed. Successive .elds with similar \ngetter/ setter method de.nitions share a single attached getter/setter declaration. This makes the registration \nlook better and pro\u00advides some abstraction by effectively saying, for example, all these .elds have public \ngetter methods, with return type the same as the .eld type and with the same pre.x. The getter/setter \nregistration, in the way that it gathers getter and setter methods from throughout the class, demonstrates \none way in which registrations can have non-local effect. The method name pre.x, access modi.er and return \ntype (when present) of getter/setter registrations are editable. When working with an IDE like Eclipse \nprogrammers often generate getter and setter methods automatically; but once that is done the abstraction \nof these as getter/setter methods is only implicit in the code. By contrast, using the RBA approach that \nabstraction is preserved in the code the programmer sees and edits. Delegate A similar but more elaborate \nregistration has to do with cases where a class is delegating part of its implementation to (the value \nof) one of its .elds. An example of this registration is shown in Figure 7. As with getter/setter, this \nis presented as a declarative attachment to the .eld. In this case the attachment summarizes the delegation \nbehavior by saying how many methods from what interface(s) are delegated and whether any are renamed. \nIn cases where fewer than .ve methods are delegated they are listed explicitly, otherwise just the number \nof delegated methods is shown. This registration allows editing of the method names, and the called method \nname in renaming cases. Switch Perhaps the most complex registration we have implemented to date is designed \nto abstract over commonality in if-then\u00adelse statements. We have seen a number of examples of Java code \nin which the tests of a multi-branch if-then-else contain code that differs only in one (or a small number \nof) positions. Code that processes .ags is a canonical example. The switch registration matches cases \nlike this and presents them using a new syntax that .rst shows an abstraction of the similar tests in \nwhich the code that is common to all tests appears (and is editable) as usual, but where the parts that \ndiffer are replaced by parameters represented as empty boxes. This is followed by a number of on cases \nproviding concrete values for the parameters. A simple example showing .ag processing appears in Figure \n9. The switch registration uses the overlay AST compar\u00adison functionality developed as part of earlier \nFluid AOP work [4]. This allows it to handle other, more complex cases. We include that functionality \nas part of the registration framework library. 4. Analysis In this section we present three forms of \ninitial evaluation of RBA: informal interviews with four developers, measure\u00adments of registration match \nfrequency in existing code bases, and an evaluation against our hypothesis outlined in Sec\u00adtion 1. 4.1 \nInterviews We conducted informal interviews with four professional software developers to get feedback \non registration-based abstractions. Three of the four volunteered to be interviewed after having seen \na demonstration at a public event, the fourth was recruited by posting at a local company. The interviews \nwere conducted one at a time and consisted of a demonstration of the editor on a real code base followed \nby encouraging the subject to take control of the editor and use it to explore the code base. Developer \nfamiliarity with the code bases used ranged from very familiar to interested in. During the interview, \nsubjects were asked questions to elicit their feedback and the interviews were recorded for later analysis. \nOverall, the response was positive. What was perhaps most striking was the degree to which subjects believed \nin the code that they saw: they just assumed that all features of the Java editor would work as usual, \nand two of them asked if they could write code in the abstract syntax. The strength of their opinions \nabout Java code was also striking: whenever they saw a registration that they particularly liked, they \nwould talk about how they hate the underlying Java code and would like to be able to see a more abstract \nview. Of the negative comments we received, the vast majority re.ected either individual preferences \nabout what should be abstracted and how it should look, or de.ciencies in the presentations we were using \nat the time. For example, some complained that we were not using commas to delimit variables in the multiple \nassignments registration, which we subsequently corrected. A bene.t of our approach is that it can accommodate \nthe diversity of individual preferences, because programmers are free to choose which registrations they \nwant to see and how they are presented. The ability to support all existing Java editor functional\u00adity \nwas thought to be critical for real-world use of the editor. One subject complained that the line numbers \nshown in the editor were different from the line numbers in the underly\u00ading code, and said that this \nwould impede communication with other programmers using different registrations. How\u00adever, another subject \nfelt that the registrations correspond to the semantic units that people refer to when talking about \ncode, and so having different presentations would not signif\u00adicantly hamper communication. The .rst subject \nwas con\u00adcerned that programmers could become dependent on the tool, that it would make pair programming \nmuch harder, and that it would hide coding conventions. Still, he said he would like to use it for code \nexploration, but that when actually Figure 9: Example from Eclipse SWT illustrating how the switch registration \nabstracts over repeated code in if-then-else statements. The hover window shows the underlying code. \n  editing code, he would only want to use simple registra\u00adtions. When looking at code that did not match \nany registrations we had de.ned, the subjects suggested several registrations they would like to see. \nThe interviews were conducted be\u00adfore we had implemented the map and switch registrations (Sections 3.1 \nand 3.2) one person suggested the map reg\u00adistration, and the idea of a more general switch statement \n( switch for objects ) came up several times. Other sugges\u00adtions included somehow abstracting native \nmethod declara\u00adtions and static final int .elds, folding sequences of assert statements, abstracting \nthe idiomatic checks that appear at the beginning of methods in certain code (such as widget != null \n&#38;&#38; !widget.isDisposed() common when using SWT), and replacing a constructor call followed by \na sequence of calls to setter methods with some\u00adthing more like a keyword arguments syntax, but with \neach argument on its own line. One of the subjects commented that he has dif.culty reading long lists \nthat are not format\u00adted like a spreadsheet but that reformatting code accord\u00ading to his preferences is \nnot feasible in a team setting; the registration-based abstraction mechanism could potentially be exploited \nto provide programmer-speci.c formatting this way. One subject articulated a design principle for registration\u00adbased \nabstractions, saying that your quick glance guess at what it does needs to be pretty close to what it \nactually does. He said that when seeing a new kind of registration for the .rst time, he would not spend \ntime thinking about it, unless he were really zoomed in on that code. Another complained that there s \njust so much noise in Java code and said that RBA would make it easier for programmers who have to switch \nback and forth between languages. One subject looked at a code base on which he worked and noticed that \nin one .le, many .elds had getters but many others did not. He found it strange that the author of the \n.le had not grouped the .elds according to their accessors, and felt that without the getter/setter registration, \nyou would have no idea which .elds were accessible outside the class. In general, people liked the delegates \nregistration but disagreed about how verbose the presentation should be. The presentation we used required \nsome explanation. It might be useful, especially for higher level registrations such as this, to include \ndocumentation in the form of a hover.  4.2 Frequency of Registration Matches Our current registration \nframework is limited to matching based on syntax and name binding only, and this limits the registrations \nwe have been able to de.ne. Nonetheless we felt that we had already been able to de.ne a number of useful \nregistrations that would have a noticeable impact on existing programs. To get an initial assessment \nof that im\u00adpact we measured registration matches in a number of Java projects ranging in size from hundreds \nto millions of SLOC, and having over 15 million SLOC in total.2 We analyzed NetBeans, OpenJDK, 14 projects \nfrom the Apache Software Foundation, 15 projects from SourceForge, and 203 Eclipse plugins (including \nJDT, parts of AJDT, and others whose source is included in the RCP/Plugin distribution). We ran the registration \nmatcher in a batch mode to collect the number of matches for each .le. We excluded from our analysis \n.les which contained no concrete methods (e.g. most interfaces and some abstract classes) and those which \ncontained only an exception class, because we felt that those .les are already in a declarative form \nand have not been the target of the registrations we have developed so far. Figures 10a and 10b show \nthe distribution of code across registration frequency bins, for non-test .les (12.4 MSLOC) and test \n.les (2.7 MSLOC). We present these results sepa\u00adrately because they have very different distributions \ntest .les are far more likely not to contain any registration matches at all. Given that many of our \nregistrations were 2 We use the non-blank, non-commenting lines de.nition of SLOC.   Registration Matches \nper 100 SLOC Registration Matches per 100 SLOC (a) Non-test .les (12.4 MSLOC). (b) Test .les (2.7 MSLOC). \ninspired by looking at non-test .les, this is not surprising. We suspect that test .les might bene.t \nfrom more domain\u00adspeci.c registrations for abstracting common setup code, and from registrations that \nabstract repeated blocks of state\u00adments.3 As shown in Figure 10a, roughly 75% of the code in non-test \n.les occurs in .les with at least 1 registration per 100 SLOC, and of the remaining 25% the .rst two \nbars of the graph more than half occurs in relatively small .les (less than 250 SLOC). Furthermore, over \n50% of the code occurs in .les with at least 2 registrations per 100 SLOC, and there is a signi.cant \ntail with higher registration frequencies. Overall, the non-test .les contain 2.4 registrations per 100 \nSLOC. Figure 10b shows that more than a third of the test .les do not contain any registrations, and \nclose to 60% contain no more than 1 per 100 SLOC. The large, light green bar at the right of the graph \nrepresents 100 identical test classes found in the same package, each of which has a very large number \nof getters and setters which happen to be arranged in such a way that they are not grouped together by \nthe 3 Given the amount of code we analyzed, we could only approximate which .les were test .les. We assumed \nthat any .le with test in its path (con\u00adverted to lower case) was a test .le; because we analyzed a number \nof JUnit plugins for Eclipse, which contain many .les with names like TestCase, we did not apply this \nrule to projects with junit in their name, effectively assuming that they did not contain test .les. \ngetter/setter registration.4 Excluding this outlier, the test .les contain only 1.4 registrations per \n100 SLOC. Because of the nature of the matching we used, we ex\u00adpect that, overall, the data underestimates \nthe potential num\u00adber of registration matches even of the kinds we have de\u00ad.ned. While there are probably \na small number of false positives matches that a more robust matching technology would reject there are \nlikely many more false negatives pieces of code that .t the spirit of the registrations even though their \nexact syntactic form is not matched by the cur\u00adrent registration pattern. Using a matching technology \nwith better awareness of the semantics of the code being matched might allow more of those false negatives \nto be matched, without having to specify a different pattern for each coding idiom. Figure 11 shows the \nbreakdown for different categories of registration in Eclipse, NetBeans, Apache, OpenJDK, and the other \ncode we analyzed. The graph shows that there is a wide variation in the frequency of different registrations, \nre.ecting the fact that some registrations like array manip\u00adulation and the use of runnables may occur \nfrequently in a minority of .les and rarely in others, whereas other registra\u00adtions like for-each in \nrange and getter/setter are more broadly applicable. Furthermore, the frequency of both classes of registration \nvaries from one code base to another. For in\u00ad 4 Note that for the getter/setter registration, we have \ncounted the number of declarations presented in the editor, rather than the number of getters and setters \nthat are abstracted; one declaration can group a large number of getters and setters.  Registration \nMatches per 100 SLOC 1 0.9 Project Eclipse (2.7 MSLOC) NetBeans (5.7 MSLOC) 0.8 0.7 Apache (2.6 MSLOC) \nOpenJDK (2.4 MSLOC)0.6 Other Code (1.6 MSLOC) 0.5 0.4 0.3 0.2 0.1 0 for-each in range Figure 11: Frequency \nbreakdown for different categories of registration. The vertical axis is frequency per 100 SLOC. Each \ngroup of .ve bars corresponds to a registration or a set of similar registrations, for example, the various \narray operation registrations are represented by one group of bars. The bars in a group show the frequency \nof those registrations in Eclipse, NetBeans, Apache, OpenJDK, and other code. stance, array registrations \nare much less common in Net-Beans code, whereas the runnable registration occurs much more often. We \nconsider these kinds of variations unsurpris\u00ading: they re.ect differences in coding style and purpose. \n 4.3 Evaluation Against Hypothesis In this section we look at what our initial experiments with RBA appear \nto say about the hypothesis outlined in Sec\u00adtion 1, in particular to what extent RBA appears to reduce \ntooling, training and consensus hurdles for language innova\u00adtion. We also discuss what implications that \nmight have for language innovation itself. While all the presented registra\u00adtions have some bearing on \nthese points, some allow more speci.c comparisons to traditional language innovation, and we begin with \nthose cases. The for-each in range registration was one of the .rst we implemented. We realized only \nafterwards that it is possible to implement this functionality in Java 1.5, by de.ning a range iterator. \nBut a high-cost of tooling obstacle makes that impractical. On the J9 and Hotspot virtual machines (v2.4 \nand v16.3-b01 respectively), the iterator-based version runs 5-7 times more slowly than the equivalent \nprimitive for loop. It appears that the JIT compilers do not suf.ciently optimize this case. Today, nearly \nsix years after the release of Java 1.5, this use case is not viable. By contrast, the registration\u00adbased \nimplementation of for-each in range would have been usable not only in Java 1.5 the day it was released, \nbut in   1.4 and earlier versions as well. There would have been no performance penalty, since the \nunderlying code remains the plain for loop. The iterator to for-each loop registration provides an ex\u00adample \nof how the RBA approach could help with a different kind of trailing edge of adoption problem. The Eclipse \n3.4 project plan [1] from May 2008, required that the Eclipse project SDK as a whole be able to deploy \non 1.4 JVMs. So, in 2008, nearly four years after the J2SE 1.5 (5.0) re\u00adlease in September 2004, most \nEclipse platform code could still not take advantage of the new for-each construct, since the required \niterable type does not exist in 1.4 runtimes. By contrast, using an RBA realization of for-each in range, \npro\u00adgrammers could have felt like they were using the new lan\u00adguage abstraction right away. Very few \nlanguages have built-in or standardized support for the special case loop constructs presented above.5 \nNot only does Java not have these today, it is dif.cult to imagine them being added to the language anytime \nsoon. The signif\u00adicant work required on tools (compilers, IDEs etc.) would engender resistance. Different \ngroups might like one or an\u00adother of the features, but it would probably be dif.cult to get consensus \nsupport for all or perhaps even any of them. We have been able to develop these special loop con\u00adstructs \nat very low cost (once the underlying RBA editor was developed). Because the underlying code does not \nchange, only new registrations need to be de.ned, no other tools must be updated. Because the registrations \nare not tyrannical a machine parsable syntax is not required. Because individ\u00adual developers can control \nwhich registrations they use little or no consensus is required to put a registration into active use. \n(In pairs both members of the pair must agree.) Because use can begin locally the training costs of adoption \ncan be limited until consensus begins to form around an abstrac\u00adtion. For-each in range, and for-each \nwith iterables exist in Python and Java 1.5 and up respectively. And a few lan\u00adguages have looping constructs \nlike those we have presented. But few if any languages have declarative delegation con\u00adstructs like that \nprovided by our delegate registration. It seems inconceivable to us that Java would be extended to include \nsuch a construct, and yet we developed it inexpen\u00adsively and feel that it provides a useful abstraction \nwith which to comprehend and even edit the code. There appears to be a desire by programmers to work \nwith these kinds of abstractions when writing programs. The IDEs support this with code generation commands. \nBut once the code is generated, the abstraction of delegating a set of methods to a .eld is lost or having \ngetter and setter methods, or a for-each in map loop, or a for-each in range loop, etc. The programmer \nhas to build the registration for themselves (internally) and perhaps present it in the code in the form \nof comments. RBA has allowed us to support 5 Common Lisp has the loop macro [16], Scheme has numerous \niteration libraries [12].  these abstractions in the language (in a different sense) and thereby make \nthem more explicit to the programmer. It has allowed us to bridge the gap between the language and tool\u00adbased \nsolutions to the problem. At least for us the use of RBA has allowed innovation in the space of new language \nconstructs for Java much more easily than would otherwise have been possible. One of the time consuming \nelements of language design innovation in the past has always been .guring out, for any new idea, what \nprograms would be like if such a construct were added to the language. With RBA, this has been much easier, \nwe have literally been able to prototype a registration and start scrolling through code to see what \neffect it has on programs. In addition, innovating with RBA makes it much easier to change our mind. \nOur loop registrations and array syn\u00adtax went through many different versions (and may still be evolving). \nBut because the underlying source code never changes, we had no problems with backward compatibility \nduring development if we felt the need to change the way a registration was presented we simply did so; \nnothing else had to change. Whether the ability for local groups of programmers to innovate more easily \nin the language design space would have a larger systemic effect is of course not at all assessed by \nour current experiment. All we can report now is that it has made language design innovation much easier \nfor us. 5. Related Work When considering work related to registration-based ab\u00adstraction, a large number \nof topics come up. Many share sim\u00adilar goals, a smaller number use similar techniques. Some of the related \nwork is in the programming languages commu\u00adnity and other work is in tools. Higher-level languages and \nsyntactic macros Section 1 identi.es a basic shared goal with traditional work in programming languages \nthat seeks to improve code qual\u00adity by de.ning more abstract language constructs. The main difference \nbetween this prior work and our proposed ap\u00adproach is that new constructs de.ned as registration-based \nabstractions are not tyrannical. They do not even appear in the underlying program source. These abstractions \nare only there when a programmer who wants them there is looking at the code. (When the IDE is closed, \nthe light does go out.) Syntactic macros [9, 20] in their various forms make the syntax of the language \nopen-ended (in varying degrees), and this allows the programmer to de.ne their own linguistic constructs. \nIntentional Programming (IP) [13, 21] can be understood as syntactic macros with two expanders. One expands \nthe macro to code, as with traditional syntactic macros. The second expands the macro to the display \neditor. By designing a suf.ciently sophisticated display expansion protocol IP is able to achieve very \nhigh levels of abstraction and expressiveness. The main difference between the RBA approach and macros \nof any kind is that RBA goes in the opposite di\u00adrection. RBA forms an abstraction of the underlying code, \nwhereas macros and IP generate code from the higher-level abstraction. Syntactic macros are less tyrannical \nthan adding new con\u00adstructs to the whole language, but they are still more tyranni\u00adcal than registration-based \nabstraction any other program\u00admers working with the code must be able to at least com\u00adprehend the macros. \nIP potentially allows different program\u00admers to see the same macro (intention) differently, but it is \ntyrannical in that code must be incorporated into its metadata format before IP can be used. Because \nsyntactic macros and IP both perform syntactic transformations, our current registration-based editor \ncan in principle capture any macro or intention as a registration, simply by matching the code that would \nbe generated. This is what happens when the getter/setter registration matches the code produced by the \ngenerate getters and setters command. Re.ection and aspect-oriented programming Work on re.ection [7, \n15] and aspect-oriented programming (AOP) [8] are similar to our current work in that they provide mechanisms \nfor alternative effective program-like abstrac\u00adtions of a total program. Unlike registration-based abstrac\u00adtions, \nmeta-programs and aspects are not transient. They are tyrannical in that any parts of the code written \nas meta\u00adprograms or aspects must be seen that way by all program\u00admers. By contrast Hyper/J [18] allows \nmultiple slices of a sys\u00adtem, and the same functionality can be sliced multiple ways into different pieces. \nSo the slicing is not tyrannical, but the slices do not provide effective access to the code. Editing \nthe elements of a slice does not have a well-de.ned effect on the whole system. Design patterns and Mylyn \nRegistration-based abstraction is partly inspired by work in design patterns [3] and tools like Mylyn \n[5], both of which involve non-tyrannical representations of programs. In our terminology, design patterns \nare a non-effective registration of a program. Mylyn task contexts are registrations of the program, \nand they are effective in some of the same ways as our abstractions. The programmer can directly edit \nthe .les, but not the shape of the task context itself, just as in a for\u00adeach in range registration the \nprogrammer can edit the loop variable name, the upper bound and the body, but not the range identi.er. \nIDEs Existing IDEs like Eclipse include features to annotate code to indicate visibility, overriding \nand deprecation, and this has some similarity to registrations that use icons to be more ex\u00adpressive. \nFlow break icons in CodeRush take this somewhat farther in terms of animating the relation between breaks, \nre\u00adturns and throws and the point to which they transfer control. But these IDE features simply decorate \nthe program, they do not appear to extend the language the program is written in.  The systems developed \nby Eisenberg [2] and Hon [4] are key precursors to our current work. Eisenberg s system al\u00adlows a programmer \nto annotate code to specify what alter\u00adnate presentation should be invoked to display and edit Java programs. \nIn terms of our present work Eisenberg s anno\u00adtations specify exactly which registration should match \nand how. Hon showed how to provide transient code-like represen\u00adtations of combinations of non-local \nparts of a program. In her editor it is possible to dynamically de.ne .uid aspects of a program that \ncollect together and/or merge different parts of the program to leave a partially editable form. Finally \nthe basic inspiration to search for transient, par\u00adtially connected but at the same time effective representa\u00adtion \nof programs is due to the foundational work of Brian Smith [14]. In particular, the understanding that \nthe kind of abstractions we were looking for would inherently be sub\u00adject to breakdown comes from Brian \ns work, and was key to allowing us to develop this work. 6. Future Work There are a number of areas for \nimmediate work improving our current editor and registration framework. These include work on how to \nhandle comments and white space, a more declarative framework for producing presentations, and test\u00ading \nintegration with common Eclipse tools such as JUnit, Mylyn etc. We would also like to begin a careful \nstudy of what hap\u00adpens when developers try to work with registration-based language abstractions. We \nintend to start with a small study to simply get most of the usability and functionality bugs worked \nout and then proceed to in the wild studies. It should be possible to design a log-based study to gather \ninforma\u00adtion about how often programmers work with registrations, whether they force them to break down \nto see the underlying code, whether they edit them, etc. Some of our abstractions make use of graphical \nlayout and design to be more expressive. These raise a number of interesting issues we have only begun \nto explore, one of which is how to understand the correspondence between in\u00addexical reference via lexical \nscoping and indexical reference via spatial locality. How should we think about the relation between \nthe switch presentation and functional abstraction with named parameters? Another area of work is to \nincorporate additional forms of pattern de.nition and matching based on analyses that go beyond syntax \nand name binding. We might consider using .ow analysis and execution trace mining to register control \nstructures that could be made more explicit. Another idea would be to try using data mining techniques \nto discover common patterns in programs and produce registrations with automatically generated abstractions. \nWhile both of the lat\u00adter suggestions may seem extreme, we feel that the fact that registration-based \nabstractions are not tyrannical could give us more room to play with these ideas than might otherwise \nseem possible. We would also like to better understand the limits of RBA. Clearly there are kinds of \nlanguage design work it cannot support. The abstractions must be latent in existing programs in a given \nlanguage. And RBA does not seem well suited to extensions that might add a new kind of type check\u00ading \nto an existing language. It is better suited to supporting what we are calling innovation than invention. \nBut how far could it be pushed? How great a degree of abstraction would be possible? We do not yet have \nclear answers to these ques\u00adtions. 7. Summary We have shown that it is technically feasible to support \nsome kinds of language innovation in a registration-based way. Using a simple syntax-based analysis framework \nwe were able to de.ne a number of registrations, representing both previously imaginable and more novel \nlanguage inno\u00advations. The registration-based approach means these are not tyrannical individual programers \ncan choose to use or ig\u00adnore the new language constructs. Other tools need not be extended to support \nthe new constructs. It is technically pos\u00adsible for new constructs to build a user base and be re.ned \nbefore any large-scale adoption hurdle must be cleared. Our current implementation is able to support \na number of apparently useful registrations. Analysis of 32 existing systems shows that the 16 simple \nregistrations described in this paper show up in many programs. A programmer with all these registrations \nenabled would almost surely see these abstractions as a regular part of their day-to-day work. Our experience \nis that we see them regularly, with screenfuls of code such as in Figures 1, 4b, 7 and even 8 being not \nuncommon. Whether the last part of our hypothesis is correct that registration-based language abstraction \ncould enable easier language innovation on a larger scale, and could acceler\u00adate traditional adoption \nof more language innovation is an open question at this point. A perhaps more interesting question is \nwhether registration-based language abstraction might, to some extent, even replace traditional implementa\u00adtions \nof language abstractions. Could we end up program\u00adming in a world in which most of what we read and edit \nis not the real (underlying) code? Acknowledgments We thank the interview subjects for their participation \nand helpful comments. We are also grateful to Andrew Eisenberg and Terry Hon for providing important \nfeedback. We thank the members of the Software Practices Lab at UBC for their assistance and support. \nBill Griswold, Gail Murphy and Emerson Murphy-Hill provided suggestions and feedback on early drafts \nof this paper.  This work was funded in part by IBM Centers for Ad\u00advanced Studies and the Natural Sciences \nand Engineering Research Council of Canada. References [1] Eclipse Plan. The eclipse project 3.4 plan \n(.nal). http: //www.eclipse.org/eclipse/development/ eclipse_project_plan_3_4.html, May 2008. [2] Andrew \nD. Eisenberg and Gregor Kiczales. Expressive pro\u00adgrams through presentation extension. In AOSD 07: Proceed\u00adings \nof the 6th international conference on Aspect-oriented software development, pages 73 84, New York, NY, \nUSA, 2007. ACM. ISBN 1-59593-615-7. doi: http://doi.acm.org/ 10.1145/1218563.1218573. [3] Erich Gamma, \nRichard Helm, Ralph Johnson, and John M. Vlissides. Design Patterns: Elements of Reusable Object-Oriented \nSoftware. Addison-Wesley Professional, illustrated edition edition, November 1994. ISBN 0201633612. [4] \nTerry Hon and Gregor Kiczales. Fluid AOP Join Point Mod\u00adels. In Proceedings of the Asian Workshop on \nAspect-Oriented Software Development, pages 14 17, 2006. [5] Mik Kersten and Gail C. Murphy. Mylar: a \ndegree-of\u00adinterest model for IDEs. In AOSD 05: Proceedings of the 4th international conference on Aspect-oriented \nsoftware development, pages 159 168, New York, NY, USA, 2005. ACM. ISBN 1-59593-042-6. doi: http://doi.acm.org/10.1145/ \n1052898.1052912. [6] Mik Kersten and Gail C. Murphy. Using Task Context to Improve Programmer Productivity. \nIn SIGSOFT 06/FSE\u00ad 14: Proceedings of the 14th ACM SIGSOFT international symposium on Foundations of \nsoftware engineering, pages 1 11, New York, NY, USA, 2006. ACM. ISBN 1-59593-468-5. doi: http://doi.acm.org/10.1145/1181775.1181777. \n[7] Gregor Kiczales. The Art of the Metaobject Protocol. The MIT Press, July 1991. ISBN 0262610744. [8] \nGregor Kiczales, John Lamping, Anurag Menhdhekar, Chris Maeda, Cristina Lopes, Jean-Marc Loingtier, and \nJohn Ir\u00adwin. Aspect-oriented programming. In Mehmet Aks\u00b8it and Satoshi Matsuoka, editors, Proceedings \nEuropean Confer\u00adence on Object-Oriented Programming, volume 1241, pages 220 242, Berlin, Heidelberg, \nand New York, 1997. Springer-Verlag. [9] Eugene Kohlbecker, Daniel P. Friedman, Matthias Felleisen, and \nBruce Duba. Hygienic macro expansion. In LFP 86: Proceedings of the 1986 ACM conference on LISP and func\u00adtional \nprogramming, pages 151 161, New York, NY, USA, 1986. ACM. ISBN 0-89791-200-4. doi: http://doi.acm.org/ \n10.1145/319838.319859. [10] Gail C. Murphy and Mik Kersten. Mylyn usage. Personal communication, 2010. \n[11] Python range. The python tutorial: The range() func\u00adtion. http://docs.python.org/release/ 3.0.1/tutorial/controlflow.html# \nthe-range-function, July 2009. [12] Scheme do. The revised6 report on the algorith\u00admic language scheme: \nControl structures. http: //www.r6rs.org/final/html/r6rs-lib/ r6rs-lib-Z-H-6.html#node_chap_5, Septem\u00adber \n2007. [13] Charles Simonyi. Intentional programming -innovation in the legacy age. In Presented at IFIP \nWorking G 2.1 meeting, June 1996. [14] Brian C. Smith. On the Origin of Objects (Bradford Books). The \nMIT Press, January 1998. ISBN 0262692090. [15] Brian C. Smith. Procedural re.ection in programming lan\u00adguages. \nPhD thesis, Massachusetts Institute of Technology Dept. of Electrical Engineering and Computer Science, \nCam\u00adbridge, MA., 1982. [16] Guy Steele. Common Lisp the Language, 2nd edition. Digital Press, 1990. ISBN \n1-55558-041-6. [17] Peri Tarr, Harold Ossher, William Harrison, and Stanley M. Sutton, Jr. N degrees \nof separation: multi-dimensional separa\u00adtion of concerns. In ICSE 99: Proceedings of the 21st inter\u00adnational \nconference on Software engineering, pages 107 119, New York, NY, USA, 1999. ACM. ISBN 1-58113-074-0. \ndoi: http://doi.acm.org/10.1145/302405.302457. [18] Peri Tarr, Harold Ossher, and Stanley M. Sutton, \nJr. Hyper/jTM: multi-dimensional separation of concerns for javaTM.In ICSE 02: Proceedings of the 24th \nInternational Conference on Software Engineering, pages 689 690, New York, NY, USA, 2002. ACM. ISBN 1-58113-472-X. \ndoi: http://doi.acm.org/10.1145/581339.581447. [19] Nic Volanschi and Christian Rinderknecht. Unparsed \npat\u00adterns: easy user-extensibility of program manipulation tools. In PEPM 08: Proceedings of the 2008 \nACM SIGPLAN sym\u00adposium on Partial evaluation and semantics-based program manipulation, pages 111 121, \nNew York, NY, USA, 2008. ACM. ISBN 978-1-59593-977-7. doi: http://doi.acm.org/10. 1145/1328408.1328425. \n[20] Daniel Weise and Roger Crew. Programmable syntax macros. In PLDI 93: Proceedings of the ACM SIGPLAN \n1993 conference on Programming language design and im\u00adplementation, pages 156 165, New York, NY, USA, \n1993. ACM. ISBN 0-89791-598-4. doi: http://doi.acm.org/10.1145/ 155090.155105. [21] E. Van Wyk, O. de \nMoor, G. Sittampalam, I. Sanabria-Piretti, K. Backhouse, and P. Kwiatkowski. Intentional programming: \nA host of language features. Technical Report PRG-RR-01\u00ad21, Computing Laboratory, University of Oxford, \n2001.  A. Java Source of Figures First multiple-.eld assignment registration from Figure 1: this . rowCount \n= count ; this . columnCount = columnCount ;  Nested for-each in range registration from Figure 3a: \nfor ( int i=0; i < 100; i ++) { for ( int j=0; j < 25; j ++) { for ( int k= 0; k < 50; k++) { checkCell(i \n, j , k); } } }  Parallel for-each loop registration from Figure 3b: Iterator childIter = children \n. iterator (); Iterator balloonIter = balloons . iterator (); while (childIter.hasNext() &#38;&#38; balloonIter.hasNext()) \n{ Child child = (Child) childIter.next(); Balloon balloon = (Balloon) balloonIter.next(); giveBalloonToChild \n( balloon , child ); } Loop over object chain registration from Figure 3c: for (Node ancestor = node.getParent(); \nancestor != null ; ancestor = ancestor . getParent ()) {if ( ancestor . getColor () == Colors .RED) {redAncestors \n.add(ancestor ); } }  For-each key-value pair registration from Figure 3d, as written in Java 1.4 using \ncasts: Iterator entries = XMLDocuments. entrySet (). iterator (); while ( entries .hasNext()) { Map.Entry \nentry = (Map.Entry) entries.next(); File file = (File) entry.getKey(); XMLDocument document = (XMLDocument) \nentry.getValue(); document.addCommentNode(file .getPath()); } For-each key-value pair registration \nfrom Figure 3d, as written in Java 1.5 using generics: Iterator <Map. Entry<F i l e , XMLDocument>> entries \n= XMLDocuments. entrySet (). iterator (); while ( entries .hasNext()) { Map. Entry<F i l e , XMLDocument> \nentry = entries.next(); File file = entry.getKey(); XMLDocument document = entry.getValue(); document.addCommentNode(file \n.getPath()); } Map registration from Figure 4a: boxedTypesMap = new HashMap ( ) ; boxedTypesMap . put \n( \"int\" , Integer . class ); boxedTypesMap . put ( \"short\" , Short . class ); boxedTypesMap . put ( \"long\" \n, Long . class ); boxedTypesMap . put ( \"byte\" , Byte . class ); boxedTypesMap . put ( \"char\" , Character \n. class ); boxedTypesMap . put ( \".oat\" , Float . class ); boxedTypesMap . put ( \"double\" , Double . \nclass );  Runnable registration from Figure 6: d . syncExec ( new Runnable () { public void run () \n{  for ( int i=0; i < refs . length ; i++) { IWorkbenchPart part = refs[i].getPart( true ); if ( part \n!= null ) { result .add(part ); } } } } );  Getter/setter, delegate, and multiple-.eld assignment registrations \nfrom Figure 7: public class WorkbenchHistoryPageSite implements IHistoryPageSite { GenericHistoryView \npart ; IPageSite site ; public WorkbenchHistoryPageSite(GenericHistoryView part , IPageSite site) {this \n. part = part ; this . site = site ; } public IPageSite getWorkbenchPageSite () { return site ; } public \nIWorkbenchPart getPart () { return part ; } public Shell getShell () { return site . getShell (); } \n public ISelectionProvider getSelectionProvider () { return site . getSelectionProvider (); } public \nvoid setSelectionProvider ( ISelectionProvider provider ) { site . setSelectionProvider(provider ); \n} public void setFocus () { // Nothing to do } public boolean isModal () { return false ; } public \nIToolBarManager getToolBarManager () { return site . getActionBars (). getToolBarManager (); } }  Map, \nrange, arraycopy, for-each, and key-value for-each registrations from Figure 8: types . put ( new String(simpleTypeName), \npath); secondaryTypes.put(key, types); } } ;  // Build scope using prereq projects but only source \nfolders IPackageFragmentRoot[] allRoots = project.getAllPackageFragmentRoots(); int length = allRoots \n. length , size = 0; IPackageFragmentRoot [] allSourceFolders = new IPackageFragmentRoot[length ]; for \n( int i=0; i <length ; i ++) { if (allRoots[i].getKind() == IPackageFragmentRoot.K SOURCE) {allSourceFolders \n[ size ++] = allRoots [ i ]; } } if ( size < length ) {  System.arraycopy(allSourceFolders , 0, allSourceFolders \n= new IPackageFragmentRoot[size], 0, size); } // Search all secondary types on scope new BasicSearchEngine \n(). searchAllSecondaryTypeNames( allSourceFolders , nameRequestor , waitForIndexes , // Build types from \npaths Iterator packages = secondaryTypes.values(). iterator(); while ( packages . hasNext ( ) ) {HashMap \ntypes = (HashMap) packages.next(); Iterator names = types . entrySet (). iterator (); while ( names . \nhasNext ( ) ) { Map.Entry entry = (Map.Entry) names.next(); String typeName = (String) entry.getKey(); \nString path = (String) entry.getValue(); if ( isJavaLikeFileName ( path )) { = monitor ); IFile file \nResourcesPlugin.getWorkspace().getRoot(). getFile ( new Path(path )); ICompilationUnit unit = createCompilationUnitFrom \n( file , null ); IType type = unit.getType(typeName); types.put(typeName, type); // replace stored path \nwith type itself }}} // Store result in per project info cache if still null or there s still an // \nindexing cache (may have been set by another thread . . . ) if ( projectInfo . secondaryTypes == null \n|| projectInfo . secondaryTypes . get (INDEXED SECONDARY TYPES) != null ) {projectInfo . secondaryTypes \n= secondaryTypes ; if (VERBOSE || BasicSearchEngine .VERBOSE) { System . out . print ( Thread . currentThread \n() + \" -> secondary paths stored in cache : \" ); // $NON-NLS-1$ System.out.println (); Iterator entries \n= secondaryTypes.entrySet(). iterator(); while ( entries .hasNext()) { Map.Entry entry = (Map.Entry) \nentries.next(); String qualifiedName = (String) entry.getKey(); Util . verbose ( \" - \"+qualifiedName+ \n- + entry.getValue()); // $NON-NLS-1$ }  \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Programming language innovation has been hindered by the difficulty of making changes to existing languages. A key source of difficulty is the tyrannical nature of existing approaches to realizing languages -- adding a new language construct means that any tool, document or programmer that works with the language must be prepared to deal with that construct.</p> <p>A registration-based approach makes it possible to define language constructs that are not tyrannical. They are instead transient -- the program appears to be written using the constructs only so long as a given programmer wants to see it that way. This approach may have the potential to greatly facilitate programming language innovation.</p>", "authors": [{"name": "Samuel Davis", "author_profile_id": "81350580257", "affiliation": "University of British Columbia, Vancouver, BC, Canada", "person_id": "P2354142", "email_address": "", "orcid_id": ""}, {"name": "Gregor Kiczales", "author_profile_id": "81100495415", "affiliation": "University of British Columbia, Vancouver, BC, Canada", "person_id": "P2354143", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869521", "year": "2010", "article_id": "1869521", "conference": "OOPSLA", "title": "Registration-based language abstractions", "url": "http://dl.acm.org/citation.cfm?id=1869521"}