{"article_publication_date": "10-17-2010", "fulltext": "\n A Time-Aware Type System For Data-Race Protection and Guaranteed Initialization Nicholas D. Matsakis \nETH Zurich, Switzerland nmatsaki@inf.ethz.ch Abstract We introduce a type system based on intervals, \nobjects rep\u00adresenting the time in which a block of code will execute. The type system can verify time-based \nproperties such as when a .eld will be accessed or a method will be invoked. One concrete application \nof our type system is data-race protection: For .elds which are initialized during one phase of the program \nand constant thereafter, users can designate the interval during which the .eld is mutable. Code which \nhappens after this initialization interval can safely read the .eld in parallel. We also support .elds \nguarded by a lock and even the use of dynamic race detectors. Another use for intervals is to designate \ndifferent phases in the object s lifetime, such as a constructor phase. The type system then ensures \nthat only appropriate methods are invoked in each phase. Categories and Subject Descriptors D.1.3 [Concurrent \nProgramming]: parallel programming General Terms Design, Theory, Veri.cation 1. Introduction The notion \nof time is central to reasoning about the correct\u00adness of programs. Most objects, for example, can only \nsafely be used after a designated construction period, which es\u00adtablishes the class invariants. Similarly, \nin parallel program\u00adming, it is common to restrict the operations permitted on an object during the times \nwhen it is accessible to multiple threads; for example, one might require that an object be im\u00admutable \nwhile it is shared between threads. Despite the importance of time, most languages offer only implicit \nmeans for interacting with it. There are no constructs for naming the period of time in which a block \nof Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA/SPLASH \n10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright &#38;#169; 2010 ACM 978-1-4503-0203-6/10/10. \n. . $10.00 Thomas R. Gross ETH Zurich, Switzerland trg@inf.ethz.ch code executes or in which multiple \nthreads are active. In fact, in a parallel context, even the relative ordering of program statements \nis not fully exposed in the language itself. In a typical threading API, for example, happens-before \nrelations between statements in different threads are not declared, but rather come about as a side-effect \nof using library primitives like signals and locks. The intervals model [21] incorporates program time \ninto the language as a .rst-class construct. An interval is an object representing the span of program \ntime in which a certain piece of code such as a statement, method call, or asynchronous task executes. \nIntervals are partially ordered through a happens-before relation. The key contribution of this paper \nis a static type system that is aware of intervals and the happens before relation. We focus on two concrete \napplications: Flexible Data-Race Protection: Our system supports both lock-free and locked parallel \npatterns. Users can choose which data-race protection scheme to use on a .eld-by-.eld, object-by-object \nbasis. For example, some .elds might be immutable after a speci.c interval has elapsed, while others \nare protected by a lock and changed continuously.  Controlled Object Initialization: Users can designate \nwhen and under what conditions .elds and methods are accessible. This can be used, for example, to ensure \nthat initialization methods are only invoked during a speci.c construction phase.  Our type system allows \neach method to be checked modularly, without the need for inter-procedural or whole\u00adprogram analysis. \nAlthough they are rarely needed, we also allow checked escape hatches (similar to a checked down\u00adcast). \nThese checks allow the user to assert that data is read\u00adable or writable if the static rules prove to \nbe insuf.cient. The paper begins with a high-level overview of the inter\u00advals model. We then introduce \nour type system and give a series of examples demonstrating its various features. Next, we present a \nformal model of our type checker and report on our experiences using our implementation. Finally, we \ndis\u00adcuss related work and conclude the paper.  lines 3-6: middle  parent method line 2 4 5     \n7 1 void example(Lock l) { 1 2 doX(); 2 3 middle: { 3 4 Subintervals sub = new Subintervals(middle, \nl); 4 5 doY(); 5 6 } // (Class \"Subintervals\" defined in Figure 2) 6 7 doZ(); 7 8 } 8 Figure 1. Inline \nsubintervals. An interval is depicted by two inward facing triangles. The numbers indicate the line number \nof the statement(s) represented by each interval.  2. Summary of the Intervals Model In this section, \nwe introduce the core ideas of intervals. The model we present here is based on earlier work [21 23] \nbut modi.ed to better support the static type system that is the focus of this paper. Intervals are .rst-class \nobjects representing the slice of program time used to execute some block of code. The code associated \nwith an interval can be anything from a single statement to an entire method. Intervals can be nested \ninside of one another, forming a tree. An interval will not begin execution until its parent has begun, \nand it must .nish before its parent can .nish. In addition, intervals may be related to one another through \na happens-before relation. If interval i happens before inter\u00adval j,then i must complete before j can \nbegin. There are two distinct kinds of intervals: Inline intervals, presented in Figure 1, represent \nthe control .ow of sequen\u00adtial code. Asynchronous intervals, presented in Figure 2, rep\u00adresent parallel \ntasks. We explain each in turn. 2.1 Inline Intervals: Sequential Code Inline intervals represent the \nexecution of individual statements within a method. They allow the programmer to reference and name the \ntime in which different portions of the method will execute. Figure 1 contains a method example() and \na diagram showing the intervals for its statements. An interval is de\u00adpicted with two inward-facing triangles. \nLines (both dashed and solid) represent the happens-before relation. The dashed box depicts asynchronous \nintervals. It will be explained in the next section, along with its contents. The statements from the \nmethod example() each corre\u00adspond to an interval in the diagram (labeled by line number). asynchronoussubintervals \n class Subintervals(Interval parent, Lock l) { interval a(this.parent) { /* code for a */ } interval \nb(this.parent) { /* code for b */ } interval c(this.parent) { /* code for c */ } this.a hb this.c; this.b \nhb this.c; this.c locks this.l; } Figure 2. Asynchronous subintervals. Each interval is drawn as two \ninward facing triangles. The lines (both dashed and solid) represent the happens-before relation. These \nintervals are fully ordered with respect to one another, re.ecting the ordering of the statements in \nthe method body. The nesting of inline intervals matches the nesting of substatements within compound \nstatements. The statement labeled middle on line 3, for example, is a code block. Its interval is therefore \nthe parent of the intervals for its substatements. The various inline intervals are all contained within \na larger interval labeled method. method is a special variable representing the current activation of \nthe method in which it is used, much as this represents the current receiver. The method interval is \nalways the parent of the inline subinter\u00advals from the method body. Labeling a statement gives a name \nto its inline interval. It also creates a local variable of type Interval, whose value is the corresponding \ninterval. The interval for the statement middle, for example, is used in an expression on line 4. Inline \nintervals are usually used only during compilation. They need only be instantiated at runtime if the \ninterval is used in an expression.  2.2 Asynchronous Intervals: Parallel Tasks Asynchronous intervals \nare used to express parallel tasks. Asynchronous intervals and any dependencies between them are declared \nas members of a class, as shown in Figure 2. When an instance of the class is created, its interval mem\u00adbers \nare instantiated as well and added to the scheduler for eventual execution. The syntax used in Figure \n2 bears some explanation. First, we make use of a streamlined, Scala-like [28] con\u00adstructor notation, \nwhere the constructor arguments appear directly after the class name. These arguments are implic\u00aditly \nstored into final .elds of the same name. Line 1 of Figure 2 would therefore be written in standard Java \nas:  class Subintervals { 1 final Interval parent; 2 final Lock l; 3 Subintervals(Interval parent, Lock \nl) { 4 this.parent = parent; 5 this.l = l; 6 } 7 } 8 9 Lines 2 4 declare the interval members. The declaration \n10 interval a(this.parent), for example, creates an asyn-11 chronous interval named a whose parent interval \nis the .eld 12 this.parent. This interval a is then accessible as a .eld, 13 14 like this.a. 15 Note \nthat the parent of the three subintervals comes from 16 the class constructor. In this way, the class \nde.nes a bundle of related intervals, but the code which instantiates it decides 17 where those intervals \n.t into the overall schedule. 18 Asynchronous intervals run during a second phase of their parent interval. \nFirst, the parent interval runs its asso\u00adciated code. Once the interval s code has .nished, its asyn\u00adchronous \nsubintervals begin to execute. In the diagram in Figure 2, this second phase is depicted by the dashed \nbox. It is right-justi.ed to indicate that the phase occurs after the execution of the code associated \nwith parent. To better understand how the execution of asynchronous intervals works, let us return to \nline 4 of Figure 1. Here, the class Subintervals is instantiated with the interval middle as the value \nfor the parent parameter. The resulting schedule is shown in the diagram above the code: after lines \n4 and 5 have executed, but before the block as a whole is complete, the subintervals a, b,and c (now \nmembers of sub) will execute. All three intervals will have .nished before the interval for line 7 executes. \nAn inline interval can thus be used as a lexically scoped fork-join construct. The .nal lines in Figure \n2 declare special requirements to the scheduler. Lines 5 and 6 extend the happens-before relation with \ntwo new edges, a.c and b.c. These edges ensure that a and b will complete before c begins (a and b remain \nunordered with respect to one another). Line 7 associates the interval c with the lock l.As a result, \nthe runtime will automatically acquire the lock l before c starts and release it after c ends.  3. \nThe Intervals Type System This section gives an overview of the intervals type system. We give a number \nof examples featuring common parallel patterns, such as point-to-point synchronization or fork-join processing, \nand show how each case could be typed. These examples serve not only to illustrate the features of our \nsys\u00adtem but also to demonstrate the variety of programs which we can handle. 3.1 Data-Race Protection \nFigure 3 presents a modi.ed version of the Subintervals class where each interval generates a result. \nThe c interval class Subintervals(Interval parent) { int aResult guardedBy this.a; interval a(this.parent) \n{ aResult = ...; } int bResult guardedBy this.b; interval b(this.parent) { bResult = ...; } int cResult \nguardedBy this.c; this.a hb this.c; this.b hb this.c; interval c(this.parent) { cResult = process(aResult, \nbResult); } } Figure 3. Point-to-point synchronization with intervals as guards. uses the results generated \nby a and b to compute its own re\u00adsult, which is safe due to the edges a.c and b.c. This ex\u00adample demonstrates \na pattern similar to futures [16], where a future is represented as the pair of an interval with its \nresult (a and aResult, for example). Each .eld declaration is annotated with a guard ob\u00adject [23]. The \nguard object is a gatekeeper: it determines the intervals that are permitted to read or write the .elds \nit protects. The guards in Figure 3 are all intervals. In the next section we will show how other kinds \nof objects, such as locks, can be used as guards. When a .eld is guarded by an interval i, it means that \nthe .eld can only be written by i or by an inline subinterval of i. Asynchronous subintervals cannot \nwrite to the .eld because there can be multiple asynchronous subintervals active at one time. However, \nbecause the parent s code will have .nished execution before they begin, asynchronous subintervals may \nsafely read .elds guarded by their parents. In addition to subintervals, .elds guarded by an interval \ni can be read by any other interval j which happens after i. Such an interval j can also be sure that \nthe .elds guarded by i are immutable, because they could only have been written by i and its subintervals, \nwhich have already .nished. 3.1.1 The Guard Interface Objects which will serve as guards must implement \nthe interface Guard.The Guard interface de.nes three methods that can be used to dynamically check whether \nthe guard permits reads or writes from a particular interval, as well as whether the data protected by \nthe guard is immutable at a particular point: g.permitsWr(i) checks whether the guard g permits i to \nwrite to the .elds guarded by g.  1 class Interval implements Guard { 2 boolean permitsWr(Interval current) \n{ 3 return current == this 4 || current.inlineSubOf(this); 5 } 6 boolean permitsRd(Interval current) \n{ 7 return current == this 8 || current.subOf(this) 1 9 || ensuresImm(current); 2 10 } 3 11 boolean ensuresImm(Interval \ncurrent) { 4 12 return this.hb(current); 5 13 } 6 14 } 7 15 8 16 class Lock implements Guard { 9 17 boolean \npermitsWr(Interval current) { 10 18 return current.holdsLock(this); 11 19 } 12 20 boolean permitsRd(Interval \ncurrent) { 13 21 if(current.holdsLock(this)) return true; 14 22 for(Interval i : current.superIntervals()) \n15 23 if(i.holdsLock(this)) return true; 16 24 return false; 25 } 26 boolean ensuresImm(Interval current) \n{ 27 return false; 28 } 29 } Figure 4. Implementation of the Guard interface for inter\u00ad vals and locks. \ng.permitsRd(i) is the same but for reads. g.ensuresImm(i) checks whether the .elds protected by g are \nimmutable for the interval i. This means that by the time i executes, they will have reached their .nal \nvalue and will not change again. Typically this occurs because the guard is an interval which happens \nbefore i and thus will have .nished when i is active. Figure 4 demonstrates how Interval and Lock objects \nimplement the Guard interface. Lock guards permit writes from intervals holding the lock and their inline \nsubintervals1 . Reads are permitted from any subinterval of an interval which holds the lock. Normally, \nthe built-in guards methods are never called: the compiler can .gure out for itself whether they will \nsuc\u00ad ceed or not. They can still be useful, however, as a form of dynamic escape hatch . The user can \nassert that the meth\u00ad ods will return true, and the compiler will permit the cor\u00ad responding accesses. \nIf the assertion is false at runtime, an exception will be thrown. Our built-in guards ensure that writes \nare fully ordered with respect to all other accesses. In some cases, however, 1 Note that holdsLock() \nis true if an interval holds the lock directly or if it is an inline subinterval of one that does. method \nmap workers  class Tree(Guard wr) { int value guardedBy this.wr; Tree left, right guardedBy this.wr; \n} class Compute { void computeValue(Tree tree) { assert tree.wr.permitsWr(method); map: { /* create async. \nsubintervals of map that read tree.value, tree.left, etc */ } tree.value = /* reduce results from workers \n*/; } } Figure 5. Map-reduce-like pattern using a dynamic asser\u00adtion. users may wish to use a weaker \nordering guarantee for better performance. This can be achieved through the use of a custom guard, as \ndiscussed in Section 5.2. No matter what ordering guarantees they make, all guards must ensure that the \nfollowing properties hold: 1. Authorization to read or write cannot be revoked:Ifa check method succeeds \nfor a given interval, then sub\u00adsequent checks for the same interval will also succeed. This implies that \nthere is never a need to invoke a check method twice and that checks and accesses do not need to be performed \natomically. 2. Write and immutable imply read: If an interval has per\u00admission to write, or if the guarded \ndata is immutable, then the interval also has permission to read. 3. Inline subintervals can write: \nIf an interval has permis\u00adsion to write, then its inline subintervals have permission to write. 4. All \nsubintervals can read: If an interval has permission to read or write, then both its asynchronous and \ninline subintervals have permission to read.  These constraints make it possible to write generic code \nthat works with any kind of guard. This same code can then be applied to any data, no matter how it is \nprotected. This code can even contain parallelism. The ability to write such code is essential to allow \nreusable libraries. Figure 5 gives an example of reusable code implementing a simple MapReduce-like [10] \npattern. The computeValue() routine takes a Tree argument and updates its value .eld.  1 class Tree \n{ 2 ghost Wr; 3 int value guardedBy this.Wr; 4 Tree[Wr=this.Wr] left, right guardedBy this.Wr; 5 } 6 \nclass Compute { 7 void computeValue( 8 Tree[Wr permitsWr method] tree) 9 { 10 // \"tree.Wr\" is writable \nwithin the method. 11 } 12 } Figure 6. Ghost .elds and wildcards. As part of these calculations, the \nmethod creates various asynchronous subintervals that use value in a read-only fashion. tree.value is \ndeclared on line 2 as being guarded by the guard tree.wr, which could be any kind of guard. Nonethe\u00adless, \nall the accesses to tree.value are considered safe by the compiler due to line 7, which asserts that \nthe guard tree.wr permits writes from method, the variable repre\u00adsenting the interval for the current \nmethod invocation. This enables the write on lines 14. It also implies that asyn\u00adchronous subintervals \nof method may read tree.value.  3.1.2 Ghost Fields The class Tree in Figure 5 used a .eld wr to store \nits guard. Most classes, however, do not enforce synchronization them\u00adselves, but rather rely on their \ncaller to ensure they are used in a proper manner. In this case, storing the guard in a .eld is not an \noptimal solution. Besides the obvious memory over\u00adhead, it provides the caller with no way to verify \nstatically that the guard is writable. Ghost .elds2 are a technique for rectifying this problem. A ghost \n.eld is a .eld that is erased at runtime. The values for an object s ghost .elds are speci.ed when it \nis .rst cre\u00adated and become part of its type. Because the caller knows the callee s type, it also knows \nthe values of the callee s ghost .elds, and so it can use those values as needed to verify statically \nthat writes and reads are permitted. It can also be helpful to think of ghost .elds as a mixture of a \n.eld and a generic type argument: like a .eld, they refer to objects and are inherited by subclasses. \nLike a generic type argument, their value is carried through the type of the object. All ghost .elds \nfor a class must be bound to a speci.c object when an instance of the class is created and cannot be \nchanged thereafter. Figure 6 demonstrates the use of ghost .elds. The con\u00adstructor argument wr from class \nTree has been converted 2 We originally adopted the term ghost .elds from RccJava [2], but our ghost \n.elds are somewhat different, in that they are inherited by subtypes. The Related Work section explains \nwhy we no longer use the purely parametric model found in RccJava. into a ghost .eld Wr, declared on \nline 2. Ghost .elds are un\u00adtyped, so the declaration consists solely of a name. We use capitalized names \nfor ghost .elds to distinguish them from normal, rei.ed .elds. From the perspective of the type checker, \nghost .elds and rei.ed .elds are generally interchangeable. The main distinction is that ghost .elds \ncannot be used within an expression. This is because the ghost .eld is not present at runtime, so there \nwould be no way to .nd the corresponding object. Another distinction is that, because ghost .elds are \nuntyped, they must be the .nal element in any path (for example, the path this.Wr is legal, but this.Wr.f \nis not). The value of a ghost .eld can be speci.ed by using a type annotation such as Tree[Wr=path]. \nHere, the [Wr=path] annotation indicates that the Wr .eld of the Tree instance is equal to the object \nreached by following the path path.An example of such a type annotation appears on line 4, which indicates \nthat the left and right .elds both point to Tree objects whose Wr .eld is the same as this.Wr. Ghost \ntype annotations are always optional. The unadorned type Tree refers to any Tree object, regardless of \nthe value of its Wr ghost .eld. Frequently, however, we do not wish to specify a pre\u00adcise value for a \nghost .eld, but we do wish to impose some constraints. As an example, consider the method computeValue() \nde.ned on line 7 of Figure 6. This method takes as argument a binary tree tree and performs some modi.cations \nto it. The precise value of the tree.Wr ghost .eld associated with the tree is not important to the method. \nWhat is important is that tree.Wr should be writable. To handle such scenarios, we support wildcard type \nan\u00adnotations, which are similar to the wildcard type arguments used in Java generics or the type constraints \nfrom Con\u00adstrained Types [26]. Line 8 gives an example. The wild\u00adcard annotation [Wr permitsWr method] \nspeci.es that the ghost .eld Wr is bound to some guard which permits writes from method, but does not \nspecify exactly which guard that is.3 Similar annotations can be used for the other guard methods as \nwell, as shown in the formalization in Section 4.  3.1.3 Method Requirements Ghost .elds can be used \nto impose conditions on a method s arguments, but sometimes a method may wish to specify other conditions \nthat do not relate to its parameters. Such conditions can be speci.ed with a method requirement. Two \nexamples appear in Figure 7. The .rst requirement, this.wr permitsWr method, speci.es that the method \nmay only be invoked if it is permitted to write .elds guarded by this.wr.The variable method here refers \nto the callee. The second requirement, method inlineSubOf this.i, states that the callee must be an inline \nsubinterval of this.i. 3 Although ghosts are untyped, the ghost Wr here could only be bound to a guard \nobject because only instance of Guard can permit writes.  1 class Compute(Guard wr, Interval i) { 1 \n2 int value guardedBy wr; 2 3 3 4 void computeValue() 4 5 requires this.wr permitsWr method 5 6 { /* \nmay write to fields guarded by this.wr */ } 6 7 7 8 void duringI() 8 9 requires method inlineSubOf this.i \n9 10 { /* may only be invoked during this.i */ } 10 11 } 11 12 13 Figure 7. Method requirements. 14 \n15 16 In effect, this means that the method can only be invoked 17 during the interval this.i. Method \nrequirements always relate two paths. These 18 paths may begin with this,the variable method,or any 19 \nof the method parameters. The full set of relations that can 20 appear in a method requirement is de.ned \nin our formaliza-21 tion in Section 4. 22 23 When a method that has requirements is overridden by 24 \na subtype, the subtype is not allowed to declare additional 25 requirements beyond those of the base \nclass. This is neces\u00ad 26 sary for type safety, as the method could always be invoked 27 28 through a \npointer typed as the base class. The caller would 29 then be unaware of the additional requirements imposed \nby 30 the subtype. It is legal for subtypes to declare fewer require\u00adments than their supertypes, however. \n31 32  3.2 Program Phases So far we have seen how to use intervals and guards to protect against data \nraces. However, the same machinery is also useful in a purely sequential context. In this section, we \nshow how to use intervals to separate the initialization phase for an object from its normal usage. Ideally, \nthe class constructor should already encapsulate the initialization phase for every object. In practice, \nhowever, many objects offer methods for additional setup and con.g\u00aduration even after the constructor \nhas returned. The Java type system is not strong enough to ensure that the normal meth\u00adods of an object \nare not used until con.guration is complete; nor it is able to ensure that methods which should only \nbe used in con.guration are not used at other times. Using in\u00adtervals, it is possible to guarantee both \nof these properties. The basic idea is to use an interval to represent the initial\u00adization phase. This \ninterval is normally associated with an object using a ghost .eld, as shown in Figure 8. The class Phases \nde.nes a ghost .eld Init which stores the initial\u00adization interval. It uses method requirements to control \nwhen each method can be invoked relative to this initialization in\u00adterval. The .eld configField on line \n3 is worthy of special mention. Because it is guarded by this.Init, configField will be mutable during \ninitialization but immutable after\u00ad class Phases { ghost Init; int configField guardedBy this.Init; void \nsetupMethod() requires method inlineSubOf this.Init { /* Init in progress. */ } void eitherMethod() \nrequires this.Init permitsRd method { /* Init may have completed. */ } void constructedMethod() requires \nthis.Init hb method { /* Init must have completed. */ } } class Creator { void construct() { Phases[Init=init] \nobj; init: { obj = new Phases[Init=init](); obj.setupMethod(); // OK. obj.eitherMethod(); // OK. obj.constructedMethod(); \n// ERROR. } obj.setupMethod(); // ERROR. obj.eitherMethod(); // OK. obj.constructedMethod(); // OK. return \nobj; } } Figure 8. Use of the Constructor interval. wards. This pattern is the intervals equivalent \nto a Java final .eld. Unlike the final keyword, however, an in\u00adterval guard can support .elds which are \nimmutable during normal operation but which cannot be initialized within the constructor for whatever \nreason. The second class in Figure 8, Creator, demonstrates how to create and initialize an instance \nof Phases.It des\u00adignates an inline interval init as the value for the Init ghost (note that inline intervals \nmay be referred to at any point in the method). Within init, any attempt to invoke constructedMethod() \nresults in an error, because the method requirement is not met. After init has completed, however, constructedMethod() \nmay be freely invoked, but setupMethod() cannot. Although the class Phases only de.nes a single Init \nphase, this technique could easily be extended to multiple object phases by adding more ghost .elds or \ninterval mem\u00adbers.  4. Formalization This section presents the highlights of our type checker. Rather \nthan give an exhaustive summary of each rule, we  cdecl member := := class c(tys fs) extends c(paths) \n{ members }gdecl | fdecl | mdecl | idecl | ldecl | hbdecl gdecl := ghost f fdecl := ty f guardedBy path \nmdecl req := := void m(tys xs) reqs { lstmts }path rel path idecl ldecl := := interval f(path) { lstmts \n}path locks path hbdecl := path hb path path := x.fs rel := trel | wcrel | locks trel := subOf | inlineSubOf \n| hb wcrel := permitsWr | permitsRd | ensuresImm | eq lstmt := x : stmt stmt := x.f= x | x= x.f | x = \nnew c[fs eq paths](xs) | x.m(xs) | assert x wcrel x ty := c[fs wcrels paths] Figure 9. Grammar for Inter \nhave chosen to explain at a high-level how two represen\u00adtative examples would be typed. The .rst example \ndemon\u00adstrates how the type checker validates loading and storing into .elds. The second example concerns \ndynamic assertions and method requirements. The complete type rules can be found in the Appendix. Our \ntype system guarantees that all .eld accesses would be approved by the appropriate guard object and that \nall method requirements are satis.ed. We have proven that pro\u00adgrams which use interval or lock guards \nare data-race free. Of course, if the user provides their own guards, those guards may permit data races. \nThis is in fact a strength of our sys\u00adtem, as some programs can permit race conditions to im\u00adprove performance \nwithout harming correctness. The type checker is based on a language Inter, which is a highly simpli.ed \nversion of the syntax we have been pre\u00adsenting in our examples. To keep the type rules concise, we have \nomitted any language feature that is not strictly nec\u00adessary. This includes such common features as compound \nstatements like if or while and even method return values. Inter also removes all syntactic sugar. References \nto .elds must explicitly mention the this pointer, for example, and all statements are labeled with a \nname for the corresponding inline interval. One minor difference in notation between Inter and our examples \nis that the type Tree[Wr=method] would be writ\u00adten Tree[Wr eq method] in our formal grammar. This is \nbecause we wish to reserve the symbol = for lexicographic equality. The full grammar for Inter is shown \nin Figure 9. We use the following lexical conventions: The terminals c, f, m,and x stand for class, .eld, \nmethod and local variable names, respectively. Keywords are shown in typewriter font and non-terminals \nin italics. Note that this and method are not keywords in the grammar but treated as normal local variable \nnames. Sequences are indicated by a trailing s,so xs stands for zero or more local variable names. Unless \nseparated by a semicolon (;), adjacent sequences indicate a sequence of tuples. This notation is widespread \nbut often surprising to those who have not seen it before. As an example, tys xs does not indicate a \nsequence of types followed by a sequence of local variable names, but rather a sequence of ty x pairs. \nSimilarly, fs eq pairs indicates a sequence of f eq pair tuples. An Inter program consists of a series \nof class declarations. A class declaration cdecl for a class c de.nes its constructor arguments, supertypes, \nand members. A class member can be a ghost declaration (gdecl), a rei.ed .eld (fdecl), an in\u00adterval member \n(idecl), a lock or happens-before declaration (ldecl, hbdecl), or a method (mdecl). A method requirement \nreq relates two paths by a relation rel. The relations are further re.ned into transitive relations trel \nand wildcard relations wcrel. Only wildcard relations can appear in a type. The meanings of the various \nrelations are: p subOf q:Interval p is a subinterval of q.  p inlineSubOf q:Interval p is an inline \nsubinterval of q.  p hb q: The interval p happens before q.  g permitsWr i: g.permitsWr(i) would succeed. \n g permitsRd i: g.permitsRd(i) would succeed.  g ensuresImm i: g.ensuresImm(i) would succeed.  p eq \nq: The paths p and q evaluate to the same object.  i locks l: The interval i acquires the lock l.  \nThe nonterminals lstmt and stmt correspond to statements with and without a label. As there are no nested \nexpressions, any intermediate results must be stored into a local variable. There are .ve kinds of statements: \nField stores and loads set or get the value of rei.ed .elds. new statements create new objects. The full \ntype of the new object must be speci.ed, in\u00adcluding precise (not wildcard) values for all ghost .elds, \nand the constructor arguments must all be supplied. A method call x.m(xs) invokes a method m on the receiver \nx with the arguments xs. Finally, assertions that a guard permits writes or reads are converted into \na special form, the assert state\u00adment. Inter generally assumes that all names are unique and methods \nare given in SSA form. The names of declared .elds, interval members, and constructor arguments all live \nin the same namespace and must be unique from other names in the same class or any of its superclasses. \nMethods in a subclass may of course override methods in a superclass. Finally, the names of all local \nvariables, parameters, state\u00adment labels must be unique within a method or interval body.  2 3 4 5 6 \n7 8 9 10 11 class Subintervals(Interval parent) { Eclass this : Subintervals this.a subOf this.parent \nthis.b subOf this.parent this.a hb this.b int aResult guardedBy this.a; interval a(this.parent) {...} \n int bResult guardedBy this.b; this.a hb this.b; interval b(this.parent) { Eb (also includes Eclass \n) b1 : Interval b2 : Interval b1 inlineSubOf this.b b2 inlineSubOf this.b b1 hbb2 b1: r = this.aResult; \nEb1 (also includes Eb ) r : int r eq this.aResult b2: this.bResult = r; } } Figure 10. A simpli.ed version \nof the class Subintervals from Figure 3, along with the environment that is deduced by the type checker \nat each point. These limitations simply make the type rules easier to under\u00adstand, they do not change \nthe set of programs we can type in any meaningful way. 4.1 Example 1: Field Loads and Field Stores The \n.rst example we consider appears in Figure 10. It con\u00adsists of a class with two interval members, a and \nb.Both generate a result. b happens after a and copies a s result from the .eld aResult into bResult. \nWe will explain step\u00adby-step how the type checker checks the interval member b. 4.1.1 The Environment \nE The environment E is the heart of the type checker. It records facts that the compiler has been able \nto deduce about the code being checked. As the compiler proceeds through the program, it adds new facts \nto the environment. Nothing is ever removed. The facts in the environment take the form of tuples. These \ntuples can take two forms. Tuples like path rel path relate two paths. Tuples like x : ty record the \ntype for a local variable. In Figure 10, the new tuples that are deduced from each statement or declaration \nare shown beneath it. When check\u00ading a particular statement, the environment in scope includes all the \ntuples deduced from previous statements, as well as those from the interval/method and class the statement \nis contained in. 4.1.2 Class and Interval Environments We begin the example by looking at the class environment \nEclass. This environment contains all the information that the compiler can deduce from the class declaration. \nThe contents of Eclass will be in scope when checking all members of the class. The.rst tuplein Eclass \nis this : Subintervals.This simply records the fact that the local variable this has the type Subintervals. \nThe next two tuples declare that this.a and this.b are both subintervals of this.parent. These tuples \nwere de\u00adduced by examining the parent declarations for each interval member. The .nal tuple this.a hb \nthis.b is based on the happens-before declaration on line 6. If there were any lock declarations, they \nwould appear in the environment as well. Next, we proceed to the interval b declared on line 7. The box \nlabeled Eb shows the tuples added to the environment from b s declaration. These tuples all relate to \nthe inline subintervals for b s two statements, b1 and b2. Each state\u00adment has a corresponding local \nvariable of type Interval, as indicated by the .rst two tuples. The next two tuples spec\u00adify that b1 \nand b2 are both inline subintervals of this.b. Finally, the last tuple gives the happens-before ordering. \n 4.1.3 Stable Paths Because we never remove any tuples from the environment, we must be sure that tuples \nin the environment re.ect facts that are always true as the program executes, and will not become invalidated \nas .elds are updated. This is done by ensuring that all paths referenced from the environment are stable. \nIntuitively, a path is stable if the object it will evaluate to at runtime cannot change. Some paths \nare always stable. For example, a path that consists only of a local variable, like x or this, can never \nchange, since we do not allow variables to be reassigned. Similarly, the path this.parent on line 7 is \nstable because the .eld parent is a constructor argument and therefore immutable. Other parts are only \nstable at certain times. For example, consider the .eld aResult, which is guarded by the interval a. \nWhen the class is .rst created, the interval a has not yet executed, and so aResult is not stable. Therefore \nwe could not add a path involving aResult to the class environment. During the interval b, however, we \nknow that a has .nished, and therefore the .eld aResult is immutable. That is why the tuple r eq this.aResult \nthat appears in Eb1 is safe. In the rules that follow, the judgement E. path stableBy xi declares that \npath is stable during the interval xi.Apath which is stable during xi will also be stable for all intervals \n STMT-LOAD E. : c rei.ed(c, f)=(tyf ; path) T =[this . xogxo] E. T(pathg) stableBy xl E. T(pathg) permitsRd \nxl E. xl :(xd = xo.f).E +(xd : T(tyf )) STMT-LOAD-IMMUTABLE E. xo : c rei.ed(c, f)=(tyf ; path) T =[this \n. xo] g E. T(pathg ) stableBy xl E. T(path) ensuresImm xl g E. xl :(xd = xo.f).E +(xd : T(tyf )) + (xd \neq xo.f) STMT-STORE E. xo : c rei.ed(c, f)=(tyf ; path) T =[this . xo] g E. T(pathg) stableBy xl E. T(pathg) \npermitsWr xl E. xv : T(tyf ) E. xl :(xo.f = xv).E Figure 11. Rules for checking the statements from \nFig\u00adure 10. T represents a substitution. that happen after xi. The de.nition of this judgement can be \nfound in the Appendix.  4.1.4 Checking Statements Figure 11 gives the formal type rules for checking \nloads and stores. Statements are checked with the judgement E. lstmt .E' ,where E represents the environment \nwhen the ' statement starts and Erepresents the environment after the statement has .nished. This judgement \nallows a statement to add tuples to the environment that may be used by later statements. There are three \nrules in Figure 11. The .rst two rules cover .eld loads. STMT-LOAD can be used for any .eld load. STMT-LOAD-IMMUTABLE \nis an improved version that only applies to loads of immutable .elds. It is always preferable to apply \nthe rule STMT-LOAD-IMMUTABLE when possible. The .nal rule, STMT-STORE, covers .eld stores. All three \nrules are very similar. They begin by invoking the helper function rei.ed(c, f) to determine the declared \ntype tyf and guard path pathof the .eld f being accessed. g The notation T =[this . xo] de.nes a substitution \nfunction T which replaces instances of this with the .eld owner xo. T is used to convert from the viewpoint \nof the class declaration to the viewpoint of the method. In order to access a .eld, the path to its guard \nmust be stable during the current statement xl. This ensures that the guard for a .eld cannot be reassigned \nwhile we are access\u00ading the .eld itself. Furthermore, the guard must either permit reads, ensure immutability, \nor permit writes, depending on the rule. In the case of a store, there is the additional require\u00adment \nthat the value xv to be stored must have a compatible type with the .eld. Assuming all checks are successful, \nboth STMT-LOAD and STMT-LOAD-IMMUTABLE add a new tuple xd : T(tyf ) to the environment. This tuple declares \nthat the newly de\u00ad.ned variable xd has the same type as the .eld which was just loaded. The rule STMT-LOAD-IMMUTABLE \nadds an additional tuple (xd eq xo.f) to the environment. This tuple states that xd always contains the \nsame object as xo.f. This tuple is safe because the .eld f is immutable, and therefore any later load \nof xo.f would yield the same result. Returning to Figure 10, the statement b1 on line 8 loads the .eld \nthis.aResult into the variable r. Because aResult is immutable, this statement can be checked using the \nrule STMT-LOAD-IMMUTABLE. The .rst step is to .nd the guard path for aResult,which is declared on line \n2 as this.a.The this pointer here is relative to the owner whose .eld is being accessed; in this case, \nthe owner is also this, so the guard path does not change after substitution. Proving that the guard \nthis.a ensures immutability for the interval b1 can be done by observing two facts: .rst, this.a happens \nbefore this.b. Second, the interval b1 is a subinterval of this.b. Therefore, this.a must have .nished \nwhen b1 is active. Because immutable .elds are always readable, this state\u00adment could also have been \nchecked using the rule STMT-LOAD. The only difference is that the resulting environment would not include \nthe tuple r eq this.aResult.In this example, this makes no difference, but we will see a case in the \nnext section where it is necessary. Processing the store to bResult in statement b2 is very similar. \nThe guard path in this case is this.b.Here the type checker deduces that this.b permits writes from the \ninterval b2 because b2 is an inline subinterval of this.b.  4.2 Example 2: Assertions and Method Requirements \nFigure 12 presents the second example, which shows the interaction of dynamic assertions, method requirements, \nand equivalence relations. As before, we have interspersed the environment deduced at each point with \nthe code it\u00adself. This time there are no interval members but instead the class de.nes two methods, requireWritable() \nand assertWritable(). The .rst method modi.es the .eld value. It requires that the guard wr permit writes \nin order to be invoked. The second method .rst asserts dynamically that wr permits writes and then invokes \nthe .rst. We examine each method in turn. 4.2.1 The Method requireWritable() The method requireWritable() \nis interesting because it declares a requirement that this.wr permitsWr method. This requirement is added \nto the method s initial environ\u00adment Erw() , along with the tuples relating to the inline subin\u00adterval \nfor the statement rw1. As we will see in the next sec\u00adtion, in order to invoke requireWritable(), a caller \nmust .rst ensure that the requirement is true. Therefore, it is safe for requireWritable() to assume \nthat the requirement holds when it executes.  2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Compute(Guard \nwr) { Eclass this : Compute int value guardedBy this.wr; void requireWritable() requires this.wr permitsWr \nmethod Erw() (also includes Eclass ) this.wr permitsWr method rw1 : Interval rw1 inlineSubOf method \n{ rw1: this.value = ...; } void assertWritable() { Eaw() (also includes Eclass ) ... aw3 : Interval aw3 \ninlineSubOf method aw1: wr = this.wr; Eaw1 (also includes Eaw() ) wr : Guard wr eq this.wr aw2: assert \nwr permitsWr method; Eaw2 (also includes Eaw1 ) wr permitsWr method aw3: this.requireWritable(); } } \nFigure 12. A mixture of the class Compute from .gures 5 and 7, along with the environment deduced at \neach point. The statement rw1 itself is a store to the .eld value.As before, the checker must verify \nthat value s guard this.wr permits writes from the statement rw1.It is able to do so by combining the \ntuple this.wr permitsWr method with the tuple rw1 inlineSubOf method. Without the method requirement, \nhowever, the type check would not have succeeded, because there would be no way to show that this.wr \npermitsWr method. 4.2.2 The Method assertWritable() assertWritable() begins on line 11 with a load of \nthe .eld this.wr.The rule STMT-LOAD-IMMUTABLE from Figure 11 can be used, because the .eld being loaded \nis an immutable constructor argument. Two tuples are therefore added to the environment, one declaring \nthe variable wr and another equating it with the immutable path this.wr. Line 12 then performs a dynamic \ncheck that wr is writable. The type rule for assert statements is called STMT-ASSERT STMT-ASSERT E. xg \n: Guard E. xi : Interval E. xl :(assert xg wcrel xi).E +(xg wcrel xi) STMT-MTHDCALL E. xr : c signature(c, \nm)=(tysxsm ) reqs mm T =[this . xr, method . xl, xsm . xsa] .i. E. T(reqs(i)) .i. E. xsa(i): T(tys(i)) \nmm E. xl :(xr.m(xsa)) .E Figure 13. Rules for checking the method assertWritable(). and appears in Figure \n13. It simply assumes that the call will succeed and adds the asserted tuple to the environment. Finally, \nline 13 calls requireWritable(). Method calls are typed by the rule STMT-MTHDCALL. This rule must validate \nthat (a) the method requirements are met and (b) the arguments to the method are of the correct type. \nThe function signature(c, m) returns the types tysand m names xsm of the arguments as well as the method \nrequire\u00adments reqs. The substitution T is then used to convert to the m viewpoint of the caller: references \nto this are converted to the method receiver; the interval method is converted to the interval for the \ncall statement; and the formal arguments xsm are converted to their actual values xsa. The .nal two clauses \nensure that the environment E sup\u00adports all method requirements and that the arguments have the correct \ntypes. Note that we treat sequences as a func\u00adtion from their index to their items. Therefore, the notation \nreqs(i), for example, refers to the ith method requirement. m Returning to the call on line 13 of Figure \n12, we see that the invoked method has a single method requirement. After substitution, the requirement \nis: this.wr permitsWr aw3. The type checker can deduce that this requirement is satis.ed by combining \nseveral available facts: (1) the variable wr and the path this.wr both refer to the same object; (2) \nwr permits writes by method;and (3) aw3 is an inline subinterval of method. This example highlights the \nimportance of distinguishing immutable .elds. We were able to type this example because we could reliably \nlink the local variable wr to the path this.wr.  4.3 Rules Concerning Ghosts One feature that did not \nappear in our examples was ghost .elds. Ghosts come into play in two places: checking types and judging \nrelations between paths. The key rules are pre\u00adsented in Figure 14 and explained in this section. 4.3.1 \nChecking Types Because of its dependent type system, Inter does not have rules that compare two types \nin isolation. Instead, the judge\u00adment E. path : ty is used to state that the path path has the  T-VAR \n(x : tE. x y).E : ty T-FIELD E. path : E. path c .f : rei.ed[this (c, f)= (ty; ...) . path] ty T-SUB \n E. path : csub csub is a subclass of csup .i. E. path.fs(i) wcrels(i) paths(i) E. path : csup[fs wcrels \npaths] REL-WILDCARD E. path1 : c[..., f wcrel path2, ...] E. path1.f wcrel path2 Figure 14. Rules related \nto ghost .elds. type ty. The .rst three rules in Figure 14 de.ne this judge\u00adment. The rules T-VAR and \nT-FIELD determine the type of local variables and rei.ed .elds and should be self-explanatory. The .nal \nrule T-SUB de.nes the subtyping relation. It states that path can be assigned the type csup[fs wcrels \npaths] so long as (a) path is typable as some subclass csub of csup; and (b) all the ghosts fs wcrels \npaths apply to path.For ex\u00adample, given a path x.y and a type Tree[Wr permitsWr method], we must ensure \nthat x.y.Wr permitsWr Method is supported by the environment E.  4.3.2 Judging Relations Between Paths \nThe .nal rule in Figure 14, called REL-WILDCARD,is used to determine that relation holds based on a wildcard. \nFor ex\u00adample, given a path x.y with the type Tree[Wr permitsWr method], this rule would allow us to conclude \nthat x.y.Wr permitsWr method. This rule is therefore the inverse of the rule T-SUB we saw earlier: where \nT-SUB only allows a type to be given if a relation holds, REL-WILDCARD assumes that a relation holds \nbased on a type.  4.4 Remaining Rules We have only presented the highlights of the full Inter type system \nhere. The complete rules are published in the ap\u00adpendix. 4.5 Proof Outline In this section, we brie.y \noutline the proof that our type system prevents data races. The complete proof, along with the operational \nsemantics of Inter, is available on our web\u00adsite [1]. For the purpose of the proof, we assume that users \nare only using the built-in guards. A machine state in the operational semantics is repre\u00adsented as a \ntuple (E; O; A): E is a restricted subset of the environment used in the type check rules. It records \nthe names of intervals and other objects that have been created along with the happens\u00adbefore relation, \ninterval hierarchy, and what locks must be held. O contains the set of points that have occurred thus \nfar in the execution. A point has the form x.f where f is either start, mid,or end.  When x.start has \noccurred, the interval x has com\u00admenced execution.  When x.mid has occurred, the interval s code block \nis complete and so asynchronous subintervals may commence execution.  When x.end has occurred, the \ninterval x has com\u00adpleted execution in its entirety.   A: x . lstmts maps an asynchronous interval \nx to its statements lstmts.  The data-race theorem itself rests on three main lemmas. The .rst is a \nstandard preservation lemma showing that ev\u00adery step from a well-formed machine state results in another \nwell-formed machine state. The second lemma states that given a well-formed machine state (E; O; A), \na guard xg, ' and two intervals x, x such that E. xg permitsWr x and '' E. xg permitsRd x , x must be \nordered with respect to x . That is, any interval permitted to write must be ordered with respect to \nall other intervals granted access (read or write). The .nal lemma is analogous to the second, but applies \nto guards speci.ed by a full path path, not only a single lo\u00ad g cal variable. These three lemmas are \nthen combined to show that, in every execution beginning from a well-formed ma\u00adchine state, all writes \nto a given .eld are ordered with respect to all other accesses of that .eld. The proof is largely straight-forward, \nbut there is one subtle point concerning null pointers. Imagine a method with a parameter x that had \nthe type Tree[Wr permitsWr method].If null were given as a parameter of this method, then rule REL-WILDCARD \ncan still be used to judge that x.Wr permitsWr method, even though the value of x is in fact null (and \nthus x.Wr was never bound to a speci.c object). The reason this does not permit race conditions is that \nREL-WILDCARD is the only rule which can apply to such a path, and therefore a non-existent guard can \nonly allow writes by at most one interval (method, in this case).  5. Experience Prototype versions \nof the intervals runtime and type checker are available on our website [1]. We have implemented a complete \nchecker for our type system based on an expanded version of Inter, the language used in our formalization. \nOur type checker supports the core features of Java, such as generic types with wildcards or multiple \ninheritance in the form of interfaces. It omits features, like anonymous classes, that can be emulated \nby source-to-source translation. We have used our implementation to check a number of representative \nexamples of different parallel patterns, includ\u00ading fork-join, point-to-point, and lock-based synchroniza\u00adtion \npatterns. None of the examples require dynamic checks  join or assertions of any kind. 1. BBPC is a \nbounded-buffer producer-consumer. Interest\u00adingly, although such a design is typically implemented with \nlocks, the intervals implementation is lock-free. It relies solely on creating happens-before edges. \nSec\u00ad 1 tion 5.1 will explore BBPC in detail. 2 2. TSP is a parallel solver for the travelling salesman \nprob\u00ad 3 lem. It uses asynchronous intervals to exhaustively ex-4 plore all possible paths and .nd the \nshortest one. The 5 TSP example is interesting because it makes use of many 6 7 different kinds of guards, \nincluding a custom guard that 8 permits data races under controlled circumstances. Sec\u00ad 9 tion 5.2 will \ncover these guards in detail. 10 3. SOR is an implementation of the successive over-relaxation 11 method \nfor solving linear systems of equations. It is im-12 plemented in a fork-join style, where each round \nis pro\u00ad 13 cessed to completion before beginning the next round. 14 15 The matrix is divided into two \nparts, red and black. Each 16 round .rst writes to red while reading from black, and 17 then does the \nopposite. This example makes use of a li\u00adbrary class for encapsulating arrays which we have not 18 discussed \nin this paper. 19 20 4. Life is an implementation of Conway s Game of Life. We 21 divide the board into \ntiles and create an interval per tile 22 23 per round. Each interval happens after the neighboring 24 \nintervals from previous rounds, thus allowing it to read 25 the results which they generate. 26 27 28 \n 5.1 Bounded-Buffer Producer-Consumer Bounded-buffer producer-consumers are very common in 29 30 parallel \nsystems. The idea is to have two independent par\u00ad 31 allel tasks. Traditionally, the producer task writes \ndata into 32 a buffer and the consumer reads it out. If the producer pro\u00ad 33 duces items faster than \nthe consumer can consume them, the 34 35 buffer will eventually become full. This causes the producer \n36 to wait until the consumer has caught up. Most implementa\u00ad 37 tions use locks on the buffer to coordinate \nthe two workers. The intervals version, shown in Figure 15, performs the 38 same task, but does so quite \ndifferently. There is no central 39 buffer and thus there are no locks. The producer and con-40 sumer \nare represented as streams of intervals; each interval represents the time to produce or consume one \nparticular item. In the diagram, these intervals are given names like p[i], meaning the producer of the \nith item, and c[i], mean\u00ading the consumer of the ith item. Happens-before edges are used instead of locks \nto coor\u00addinate the timing between producer and consumer: 1. Edges like p[i].c[i] ensure that the consumer \nof item i will wait for the producer of item i. These edges result from the declaration on line 9. next \npointer abstract class Stream { Stream next guardedBy inter; abstract interval inter; } // this == c[i], \nprod == p[i] class Consumer(Interval parent, Producer prod) extends Stream { prod.inter hb inter; // \np[i] -> c[i] interval inter(parent) { /* consume prod.result */ next = new Consumer(parent, (Producer)prod.next); \n}} // this == p[i], cons == c[i-2] class Producer(Interval parent, Stream cons) extends Stream { Object \nresult guardedBy inter; cons.inter hb inter; // c[i-2] -> p[i] interval inter(parent) { result = /* \nproduce item */; next = new Producer(parent, cons.next); }} class DummyConsumer(Interval parent) extends \nStream { Stream link guardedBy parent; interval inter(parent) { next = link; }} class Start { void main() \n{ join: { DummyConsumer one = new DummyConsumer(join); DummyConsumer two = new DummyConsumer(join); Producer \nprod = new Producer(join, one); one.link = two; two.link = new Consumer(join, prod); }}} Figure 15. BBPC \n2. Edges like c[i - 2].p[i] ensures that the producer for item i will wait until item i - 2 has been \nconsumed. This corresponds to a bounder buffer size of 2. These edges result from the declaration on \nline 19. Thebaseclass Stream is used to de.ne a single link in a stream of intervals. Each link has a \ncorresponding interval inter, which is de.ned abstractly and therefore must also be de.ned in each subclass. \nWhen inter executes, it will create the next link in the stream and store it into the .eld next. That \nmeans that the producer p[i], for example, cre\u00adates p[i + 1], which in turn creates p[i + 2], and so \non.  The classes Producer, Consumer,and DummyConsumer all extend Stream. We .rst describe how Producer \nand Consumer work in the steady state, then discuss DummyConsumer, which is used only to bootstrap the \nsystem. The Producer and Consumer classes are each parame\u00adterized by a link from the opposite stream. \nThis link is used to create the incoming happens-before edges. Each con\u00adsumer c[i] expects to be created \nwith p[i] as argument, whereas each producer p[i] expects the consumer c[i - 2] from two items back. \nWhen the Consumer s interval executes, it begins on line 11 by reading the data which was produced produced. \nIt then creates the next link in the Consumer stream, c[i + 1].It uses prod.next to obtain the next producer.4 \nProducer is similar but it begins by producing data instead. The class DummyConsumer is used to bootstrap \nthe pro\u00adducer and consumer streams. The problem is that a Producer, when created, expects to be given \nthe Consumer from two items back. But for the .rst two producers, there is no such consumer! Therefore, \nwe create two instances of the class DummyConsumer.A DummyConsumer interval doesn t do any actual work, \nit simply sets the next pointer to the value in its .eld link. By creating more DummyConsumer in\u00adstances, \nthe example could be adjusted to allow an arbitrary buffer size instead of only 2. DummyConsumer expects \nthe .eld link to be initial\u00adized by the interval parent. DummyConsumer s interval can therefore read \nthe .eld safely, because it does not begin execution until its parent s code has executed. In the class \nStart,two DummyConsumer instances are instantiated. The parent for both is the inline interval join. \nOn lines 38 and 39, the two link .elds are initialized as shown in the diagram.  5.2 Use of Guards in \nthe TSP Solver The parallel solver for the Travelling Salesman Problem is the most complex of the example \nimplementations. One of the interesting aspects of TSP is that it uses a variety of techniques for protecting \nthe shared data, including custom guards that permit controlled data races. The solver is based around \nasynchronous worker inter\u00advals that share access to a priority queue storing partially ex\u00adplored paths. \nEach worker extracts the most promising path from the queue and extends it by one step, resulting in \na set of new paths (one for each node that is not yet in the path). Each new path is initialized and \nthen inserted into the prior\u00adity queue for other workers to extend. Once a path is inserted in the queue, \nit is never modi.ed again. 4 Here we use a downcast from Stream to Producer. The actual imple\u00admentation \nuses generic types instead, but we avoided them here to keep the example simple. Whenever a worker .nds \na complete path that visits all nodes, it acquires a lock and checks to see whether this is the shortest \npath found so far. At the same time, it updates a heuristic .eld that stores the length of this path. \nIf a worker ever .nds that the path it is exploring is already longer than the shortest path, then it \nsimply stops and proceeds to the next path in the priority queue. This avoids expanding paths that cannot \npossibly be shorter than the current solution. The TSP example uses three kinds of guards in total: Interval \nGuards: Because each partial path is only mutable during initialization, and are shared freely afterwards, \nthey are perfect candidates for an interval guard. The type checker ensures that the interval guard must \nhave completed before the object is placed into the queue, and so all shared paths are immutable. Lock \nGuards: Because they must be modi.ed repeatedly by concurrent intervals, the shared queue and .eld storing \nthe shortest path are protected by a lock. Custom Guards: A custom guard is used for the .eld which stores \nthe shortest path length. This guard allows access from any thread. This guard permits data races, but \nas the .eld is used merely a heuristic, this cannot af\u00adfect the program s overall correctness. Because \nthis .eld is read very frequently, acquiring a lock for every access would be far too expensive.  6. \nRelated Work 6.1 Lock-based Type Systems The closest ancestor to our system are the type systems for \nenforcing the consistent use of locks found in systems like RccJava [2], Cyclone [15], or SafeJava [7]. \nOur work generalizes these approaches to support a variety of data\u00adrace protection schemes, rather than \nmerely locks. We also integrate the happens-before relation into the type system, allowing us to check \nlock-free programs as well. One of the effects of this is that we do not need special case treatment \nfor thread-local data or immutable objects. Another difference between our work and earlier systems is \nour treatment of ghost .elds. All of the systems cited above used a dependent type system of some kind \nthat al\u00adlowed types to be parameterized by objects. Most of these systems were modeled on traditional \ngeneric types, only with objects substituted for types. We initially tried this ap\u00adproach but found that \nit interacted poorly with other Java features, particularly generic types. Inherited ghost .elds as presented \nhere were designed to circumvent the problems we encountered. Figure 16 demonstrates the most severe \nproblem we en\u00adcountered with a parametric system, which concerned in\u00adterfaces like Comparable<T>. Annotating \nsuch an interface in our current design is straightforward (as shown). In a parameterization-based system, \nhowever, there is no way to refer to the ghost .elds of the parameter o unless type vari\u00adables like T \ncan themselves be parameterized (in most sys\u00adtems, only classes can have type parameters).  1 // The \ninherited ghost field system we use 2 // can easily refer to a ghost field of o: 3 interface Comparable<T> \n{ 4 int compareTo(T o) 5 requires this.Wr permitsRd method 6 requires o.Wr permitsRd method; 7 } 8 9 \n// A traditional, parameterization-based approach 10 // cannot express that OWr is associated with o: \n11 interface Comparable[Wr]<T> { 12 [OWr] int compareTo(T o) 13 requires Wr permitsRd method 14 requires \nOWr permitsRd method; 15 } Figure 16. The difference between guards inherited by de\u00adfault and those that \nmust be passed explicitly through super\u00adtypes.  6.2 Effect Systems Many projects have applied effect \nsystems towards detecting data races [6, 14, 18, 25], including prior work by the current authors [20]. \nEffect systems have the characteristic that each method summarizes the regions of memory that it might \naccess as part of its signature. When multiple threads are executed, the system must guarantee that the \nregions affected by different threads are disjoint. If they are not, an error is reported. However, and \nthis is the key difference with our system, neither of the con.icting routines is wrong in and of itself. \nIt is only their composition that is incorrect. In our system, in contrast, at least one of those con.icting \nroutines must be accessing .elds without permission from the guard. Therefore, each routine is only concerned \nabout proving that it itself is safe, and not for what others might do. Both approaches have their advantages. \nAn effect system can theoretically permit greater re-use, assuming the various challenges towards effectively \nmodularizing and abstracting effect and region declarations are overcome. Our system, on the other hand, \n(a) has no need of an alias analysis and (b) supports localized dynamic escape hatches, which we view \nas an essential feature. In an effect system, in contrast, a method cannot check dynamically whether \nan access is con.icting unless the other potentially concurrent methods also use dynamic checks (otherwise \nthe necessary information is not present at runtime). 6.3 Other Static Analyses A number of whole program \nanalysis techniques [11, 24] have been applied to data-race detection. Such analyses gen\u00aderally must \nprocess a large codebase with little to no anno\u00adtation, so the speed of the analysis and the rate of \nfalse pos\u00aditives is often the primary concern. Our work in contrast is intended to be a modular type \nsystem that programmers use while writing parallel programs. Rather than detecting data races, some work \nfocuses on enforcing higher-level properties such as method atomic\u00adity [13] or higher-level data races \n[5, 9, 17, 31]. Our use of guards helps to avoid high-level data races, because re\u00adlated .elds tend to \nbe protected by the same guard and thus modi.ed atomically. SharC [4] de.nes annotations that can be \nused on C structures to identify thread-local, read-only, or shared data. They employ a simple means \nof parameterization, but for complex cases rely on a dynamic monitoring system. Jade [29] and Serialization \nSets [3] are two projects which use programmer-provided speci.cations to dynam\u00adically parallelize a program. \nTheir speci.cations resemble the ones which we use, but their purpose is quite different. Fractional \npermissions [8, 30] have been used as an alter\u00adnative to effects for detecting races. Because fractional \nper\u00admissions allow exclusive access to be parceled out to many threads but later reclaimed, they can \nhandle objects which are only temporarily shared: however, they are limited by the ability of the compiler \nto pair up which threads are forked and joined. Delayed types [12] introduced a notion of time with the \naim of addressing object initialization. In their system, each object has an associated time by which \nit will be fully ini\u00adtialized, similar to the Constructor interval discussed in Section 3.2. Their type \nsystem is otherwise quite different from ours. Times are not .rst-class objects and cannot be used to \ncreate parallelism. Furthermore, times are not ex\u00adposed to the user but rather introduced by the type \nsystem in a stylized fashion. Constrained types [26] allow users to annotate types with constraints that \nspecify what values their .elds possess or other criteria. These constraints are very similar to our \nwild\u00adcard type annotations, but applied to more general con\u00adstraints such as the range of values an integer \nmay possess. Their constraints also apply to rei.ed .elds, whereas ours are currently limited to ghost \n.elds. Their work and ours complement each other and could be fruitfully combined. Our use of inherited \nghost .elds is reminiscent of virtual types, an alternative to parametric polymorphism supported by languages \nsuch as Scala [27] and Beta [19]. In these languages, a class can declare an abstract type member that \nis inherited by subtypes.  7. Conclusion Despite its importance, time is generally a second-class citi\u00adzen \nin programming languages. It is possible to tell the com\u00adpiler the types of a method s arguments, but \nnot when it should be invoked. Similarly, the compiler knows the type for each .eld, but not when it \nwill be initialized. At best, a language may offer ad hoc techniques such as constructors or final .elds, \nwhich encode a few common patterns but cannot be generalized.  In this paper, we have presented an approach \nfor giving users the ability to name and describe time in their programs. Our system uni.es sequential \nand parallel control .ow into one construct, the interval. Through a static type system, we allow users \nto choose when and under what conditions a .eld should be modi.ed or a method should be invoked. We have \nproven that our type system protects against data races. We demonstrate that these same techniques can \nbe reapplied to to enforce phases in an object s lifetime. We have focused on creating a practical system. \nTools like ghost .elds and method requirements help users enforce their desired protocols with zero runtime \nand memory over\u00adhead. Similarly, because no type system can describe all pro\u00adgrams, we allow users to \ninsert checked assertions about the program schedule. As demonstrated in our experience sec\u00adtion, however, \nthe type system is expressive enough that such checks are rarely needed. References [1] http://intervals.inf.ethz.ch. \n[2] M. Abadi, C. Flanagan, and S. N. Freund. Types for safe locking: Static race detection for Java. \nACM Trans. Program. Lang. Syst., 28(2), 2006. [3] M. D. Allen, S. Sridharan, and G. S. Sohi. Serialization \nsets: a dynamic dependence-based parallel execution model. In PPoPP. ACM, 2009. ISBN 978-1-60558-397-6. \n[4] Z. Anderson, D. Gay, R. Ennals, and E. Brewer. SharC: checking data sharing strategies for multithreaded \nC. In PLDI. ACM, 2008. [5] N. E. Beckman, K. Bierhoff, and J. Aldrich. Verifying correct usage of atomic \nblocks and typestate. SIGPLAN Not., 43(10), 2008. [6] R.L.Bocchino, Jr.,V. S.Adve, D.Dig, S.V. Adve, \nS. Heumann, R. Komuravelli, J. Overbey, P. Simmons, H. Sung, and M. Vakilian. A type and effect system \nfor deter\u00administic parallel java. In OOPSLA. ACM, 2009. [7] C. Boyapati, R. Lee, and M. Rinard. Ownership \ntypes for safe programming: preventing data races and deadlocks. In OOPSLA. ACM, 2002. ISBN 1-58113-471-1. \n[8] J. Boyland. Checking Interference with Fractional Permis\u00adsions. In R. Cousot, editor, Static Analysis: \n10th International Symposium, volume 2694 of LNCS. Springer, 2003. [9] L. Ceze, C. von Praun, C. Cas\u00b8caval, \nP. Montesinos, and J. Tor\u00adrellas. Concurrency control with data coloring. In MSPC. ACM, 2008. ISBN 978-1-60558-049-4. \n[10] J. Dean and S. Ghemawat. MapReduce: simpli.ed data pro\u00adcessing on large clusters. In OSDI. USENIX \nAssociation, 2004. [11] D. Engler and K. Ashcraft. Racerx: effective, static detection of race conditions \nand deadlocks. SIGOPS Oper. Syst. Rev., 37(5):237 252, 2003. ISSN 0163-5980. [12] M. F\u00a8ahndrich and S. \nXia. Establishing object invariants with delayed types. In OOPSLA. ACM, 2007. [13] C. Flanagan, S. N. \nFreund, M. Lifshin, and S. Qadeer. Types for atomicity: Static checking and inference for Java. ACM Trans. \nProgram. Lang. Syst., 30(4), 2008. ISSN 0164-0925. [14] A. Greenhouse and W. L. Scherlis. Assuring and \nevolving concurrent programs: annotations and policy. In ICSE.ACM, 2002. [15] D. Grossman. Type-safe \nMultithreading in Cyclone. In TLDI. ACM, 2003. [16] R. H. Halstead, Jr. MULTILISP: a language for concurrent \nsymbolic computation. ACM Trans. Program. Lang. Syst.,7 (4), 1985. ISSN 0164-0925. [17] B. Jacobs, F. \nPiessens, K. R. M. Leino, and W. Schulte. Safe Concurrency for Aggregate Objects with Invariants. In \nSEFM. IEEE Computer Society, 2005. [18] J. M. Lucassen and D. K. Gifford. Polymorphic effect sys\u00adtems. \nIn POPL. ACM, 1988. [19] O. L. Madsen and B. M\u00f8ller-Pedersen. Virtual classes: a pow\u00aderful mechanism \nin object-oriented programming. In OOP-SLA. ACM, 1989. [20] N. D. Matsakis and T. R. Gross. Thread Safety \nthrough Partitions and Effect Agreements. In LCPC, 2008. [21] N. D. Matsakis and T. R. Gross. Programming \nwith Intervals. In LCPC, 2009. [22] N. D. Matsakis and T. R. Gross. Handling Errors in Parallel Programs \nBased on Happens Before Relations. In HIPS, 2010. [23] N. D. Matsakis and T. R. Gross. Re.ective Parallel \nProgram\u00adming. In HotPar, 2010. [24] M. Naik, A. Aiken, and J. Whaley. Effective static race detection \nfor java. SIGPLAN Not., 41(6):308 319, 2006. ISSN 0362-1340. [25] I. Neamtiu, M. Hicks, J. S. Foster, \nand P. Pratikakis. Con\u00adtextual effects for version-consistent dynamic software updat\u00ading and safe concurrent \nprogramming. SIGPLAN Not., 43(1), 2008. [26] N. Nystrom, V. Saraswat, J. Palsberg, and C. Grothoff. Con\u00adstrained \ntypes for object-oriented languages. In OOPSLA. ACM, 2008. [27] M. Odersky, V. Cremet, C. R\u00a8ockl, and \nM. Zenger. A nominal theory of objects with dependent types. In Proc. FOOL 10, Jan. 2003. [28] M. Odersky, \nL. Spoon, and B. Venners. Programming in Scala: A Comprehensive Step-by-step Guide. Artima Incor\u00adporation, \nUSA, 2008. [29] M. Rinard. The Design, Implementation and Evaluation of Jade, a Portable, Implicitly \nParallel Programming Language. PhD thesis, Dept. of CS, Stanford University, 1994. [30] T. Terauchi. \nChecking race freedom via linear programming. In PLDI. ACM, 2008. [31] M. Vaziri, F. Tip, and J. Dolby. \nAssociating synchronization constraints with data in an object-oriented language. In POPL. ACM, 2006. \nISBN 1-59593-027-2.  A. Complete Typing Rules for Inter A.1 Lexical Conventions  The terminals c, \nf, m,and x stand for class, .eld, method and local variable names, respectively. Non-terminals are shown \nin italics.  Sequences are indicated by a trailing s. Unless separated by a semicolon (;), adjacent \nsequences indicate a sequence of tuples. Sequences are a function from their index to their items. Therefore, \nxs(i) indicates the ith variable in the sequence. We use the notation (F (i)|i) to mean a sequence whose \nitems are F (1),F (2),etc.  The notation T =[x . path] de.nes a substitution function T which replaces \ninstances of the variable x with the path path. T can be applied to types (T(ty)) or method requirements \n(T(req)).  fold ' The notation E. lstmts . EN indicates apply the judgement E. lstmt .Eto each statement \nin lstmts in turn. The ' initial environment is E. Thereafter, the result Erepresents the .nal environment. \n A.2 Summary of Judgements E. path : ty E. path stable E. path stableBy xi E. ty stableBy xi E. req \nstableBy xi E. req c:OK E. ldecl : OK E. hbdecl : OK E. fdecl : OK E. mdecl : OK E.(tys xs) reqs overrides \nmdecl ' E. lstmt .E from each statement is used as the initial environment for its successor. EN path \nhas type ty in E Value of path cannot change Value of path cannot change once interval xi starts Type \nty only references paths that are stable during xi. Requirement req only references paths that are stable \nduring xi. req = path rel path is supported by E. De.nition of class c is sound. Lock declaration ldecl \nis sound in E. Happens-before declaration hbdecl is sound in E. Field declaration fdecl is sound in E. \nMethod declaration mdecl is sound in E. Override of mdecl with signature (tys xs) reqs is sound. Labeled \nstatement lstmt is sound in E. ' The next statement should be checked in E. A.3 Helper Functions \n The functions gdecls(c), fdecls(c), idecls(c), hbdecls(c),and ldecls(c) return the corresponding declarations \nfrom the body of class c.  rei.ed(c, f)=(ty; path) yields the type ty and guard path path for the .eld \nf de.ned in the class c or a superclass. No substitutions are performed. If f is a constructor argument \nor interval member, then the special variable final is returned as its guard path.  signature(c, m)=(tys \nxs) reqs yields the parameters (tys xs) and requirements reqs declared for the class m in the class c \n (or a superclass, if c does not override m). No substitutions are performed. overrides(c, m)= mdecls \nyields the list of method declarations with name m from superclasses of c. A.4 Typing Paths T-VAR (x \n: ty). E T-FIELD E. path : c rei.ed(c, f)=(ty; ...) E. x : ty E. path.f :[this . path] ty T-SUB E. path \n: csub csub is a subclass of csup .i. E. path.fs(i) wcrels(i) paths(i) E. path : csup[fs wcrels paths] \n A.5 Stability PATH-STABLE-ALL xi fresh E. path stableBy xi E. path stable PATH-STABLE-LV (x : ty).E \nE. x stableBy xi PATH-STABLE-GHOST E. patho stableBy xi E. patho E. patho : c .f stableBy xi f . ghosts(c) \nPATH-STABLE-REIFIED E. pathstableBy xi o E. path: c rei.ed(c, f)=(... ; path) T =[this . path] E. T(path) \nstableBy xi E. T(path) ensuresImm xi o gogg E. path.f stableBy xi o TY-STABLE REQ-STABLE fs . ghosts(c).i. \nE. paths(i) stableBy xi E. path1 stableBy xi E. path2 stableBy xi E. c[fs wcrels paths] stableBy xi E.(path1 \nrel path2) stableBy xi A.6 Relations (All) REL-ENV (path1 rel path2).E REL-TRANS E. path1 trel path2 \nE. path2 trel path3 REL-WILDCARD E. path1 : c[... , f wcrel path2, ...] E. path1 rel path2 E. path1 trel \npath3 E. path1.f wcrel path2 A.7 Relations (eq) EQ-SELF E. path eq path EQ-SYMMETRIC E. path2 eq path1 \nE. path1 eq path2 EQ-EXTEND E. path1 eq path2 E. path1.feq path2.f EQ-REL E. path1 eq path' 1 E. path2 \neq path' 2 E. path1 rel path2 E. path' 1 rel path' 2 A.8 Relations (hb) HB-SUB-LEFT HB-SUB-RIGHT E. \npathc subOf pathp E. pathp hb path E. pathc subOf pathp E. path hb pathp E. pathc hb path E. path hb \npathc  A.9 Relations (all guards) RBY-WBY E. pathpermitsWr pathi g E. pathg permitsRd pathi RBY-IMMUTABLE \nWBY-INLINE E. pathg ensuresImm pathi E. pathi inlineSubOf pathp E. pathg permitsWr pathp E. pathg permitsRd \npathi E. pathg permitsWr pathi RBY-SUB E. pathi subOf pathE. pathpermitsRd path pg p E. pathg permitsRd \npathi A.10 Relations (built-in guards) IMM-INTERVAL WBY-LOCK WBY-INTERVAL E. pathhb pathi E. pathi \nlocks path gg E. pathg permitsWr pathg E. pathensuresImm pathi E. pathpermitsWr pathi gg IMM-FINAL \nE. final ensuresImm pathi  A.11 Declarations CLASS-OK idecls(c)= interval fs(paths) { ... } Ec =[this \n: c]+ ldecls(c)+ hbdecls(c)+(this.fs(i) subOf paths(i)| i) .i. Ec ; c . hbdecls(c)(i): OK .i. Ec ; c \n. ldecls(c)(i): OK .i. Ec ; c . fdecls(c)(i): OK .i. Ec ; c . mdecls(c)(i): OK .i. Ec ; c . idecls(c)(i): \nOK c : OK LOCK-DECL-OK E. pathi stable E. pathl stable E. pathi : Interval E; c : pathi locks pathl \nOK E. pathl : Lock HB-DECL-OK E. pathi stable E. pathl stable E. pathi : Interval E; c : pathi hb pathl \nOK E. pathl : Interval FIELD-OK E. path stable E. ty stable E. ty f guardedBy path : OK INTERVAL-OK E. \npath stable E. path : Interval this.f; E. lstmts : OK E; c . interval f(path) { lstmts } : OK METHOD-OK \nE1 +(method : Interval)+(xs(i): tys(i)| i)+ reqs =Em .i. Em . reqs(i) stableBy method .i. Em . tys(i) \nstableBy method overrides(c, m)= methodso .i. Em .(tys xs) reqs overrides methodso(i) method; Em . lstmts \n: OK E1 . void m(tys xs) reqs { lstmts } : OK METHOD-OVERRIDE-OK T =[ xsp . xsb ].i. E+ T(reqsp). reqsb(i).i. \nT(tysp(i)) = tysb(i) E.(tysb xsb) reqsb overrides void m(tysxsp) reqs{ ... } pp  A.12 Statements LSTMTS-OK \n lstmts =(xs : ...) E2 =E1 +(xs(i): Interval | i)+(xs(i) inlineSubOf pathpar | i)+(xs(i - 1) hb xs(i)| \ni) fold E2 . lstmts !. EN path. lstmts : OK par; E1 STMT-STORE E. xo : c rei.ed(c, f)=(tyf ; path) T \n=[this . xo] E. T(path) stableBy xl E. T(path) permitsWr xl ggg E. xv : T(tyf ) E. xl :(xo.f = xv).E \nSTMT-LOAD E. xo : c rei.ed(c, f)=(tyf ; path) T =[this . xo] E. T(path) stableBy xl E. T(path) permitsRd \nxl ggg E. xl :(xd = xo.f).E +(xd : T(tyf )) STMT-LOAD-IMMUTABLE E. xo : c rei.ed(c, f)=(tyf ; path) \nT =[this . xo] E. T(path) stableBy xl E. T(path) ensuresImm xl ggg E. xl :(xd = xo.f).E +(xd : T(tyf \n)) + (xd eq xo.f) STMT-NEW '' .i. E. paths(i) stableBy xl E+(xd : c[fs eq paths]) = E ctor(c)= tys.i. \nE. xsa(i):[this . xd] tys(i) cc ' E. xl :(xd = new c[fs eq paths]) (xsa ) .E STMT-MTHDCALL E. xr : \nc signature(c, m)=(tysxsm ) reqs mm T =[this . xr, method . xl, xsm . xsa].i. E. T(reqs(i)) .i. E. xsa(i): \nT(tys(i)) mm E. xl :(xr.m(xsa)) .E STMT-ASSERT E. xg : Guard E. xi : Interval E. xl :(assert xg wcrel \nxi).E +(xg wcrel xi)   \n\t\t\t", "proc_id": "1869459", "abstract": "<p>We introduce a type system based on intervals, objects representing the time in which a block of code will execute. The type system can verify time-based properties such as when a field will be accessed or a method will be invoked.</p> <p>One concrete application of our type system is data-race protection: For fields which are initialized during one phase of the program and constant thereafter, users can designate the interval during which the field is mutable. Code which happens after this initialization interval can safely read the field in parallel. We also support fields guarded by a lock and even the use of dynamic race detectors.</p> <p>Another use for intervals is to designate different phases in the object's lifetime, such as a constructor phase. The type system then ensures that only appropriate methods are invoked in each phase.</p>", "authors": [{"name": "Nicholas D. Matsakis", "author_profile_id": "81339516313", "affiliation": "ETH Zurich, Zurich, Switzerland", "person_id": "P2354120", "email_address": "", "orcid_id": ""}, {"name": "Thomas R. Gross", "author_profile_id": "81332502168", "affiliation": "ETH Zurich, Zurich, Switzerland", "person_id": "P2354121", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869511", "year": "2010", "article_id": "1869511", "conference": "OOPSLA", "title": "A time-aware type system for data-race protection and guaranteed initialization", "url": "http://dl.acm.org/citation.cfm?id=1869511"}