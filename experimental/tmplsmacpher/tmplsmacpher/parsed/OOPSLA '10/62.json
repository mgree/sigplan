{"article_publication_date": "10-17-2010", "fulltext": "\n TheTowerof Babel Did NotFail Paul Adamczyk paul.adamczyk@gmail.com Abstract Fred Brooks retelling of \nthe biblical story of theTower of Babel offers many insights into what makes building soft\u00adware dif.cult. \nThe dif.culty, according to common interpre\u00adtations, comes from the communication and organizational \nproblems in software development. But the story contains one more important lesson that people tend to \nmiss: one can\u00adnot accomplish impossible goals, which programmers are of\u00adten asked to do. Software engineering, \nas a discipline, can overcome poor communication;but as long as we attempt to liveupto impossibleexpectations,wewillalwaysfail. \nCategories and Subject Descriptors K.6.3[Management of Computing and Information Systems]: Software Manage\u00adment \nSoftware development; K.7.m[The Computing Pro\u00adfession]: Miscellaneous Codes of good practice General \nTerms Design, Documentation, Economics, Hu\u00admanFactors, Languages, Management Keywords communication, \ndocumentation, engineering, programming, science Introduction The story of the Tower of Babel comes from \nthe book of Genesis,but software developers, regardless of their meta\u00adphysicalviews,knowitasastoryoffailingsoftware \nprojects a tradition that dates back to Fred Brooks [6]. The main takeaway from this story is the confusion \nof the language that led to thefailure of communication between men. God became afraid that men working \nin unison might accomplish impossible things, so he used his supernatural powers to confuse their language. \nInterpreting this part of the story literally implies that the Almighty was consider\u00ading (if only for \na brief moment) men to be his equals and then resorted to a trick to reclaim his superior position. But \nmore than a story about a power struggle between mortals Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, \nNevada, USA. Copyright c . 2010 ACM 978-1-4503-0203-6/10/10. . . $10.00 Munawar Ha.z University of Illinois \n mha.z@illinois.edu and God, theTower of Babel contains lessons about human endeavors. It suggests, for \nexample, a historical explanation of how large ancient cities evolved it was a communal ef\u00adfort, not \njust the work of powerful rulers. More to the point, thebuildersofthetowerhadfailedduetoa technical rea\u00adson \n they were trying to accomplish an impossible task: to build atowerthat reachestoheavens. Oncethefailurebe\u00adcame \napparent, the tribes separated, migrating in different directions, because their ambitious project didn \nt hold them together anymore. Theylost contact and,overtime, their lan\u00adguages began to grow apart. Had \nthey tried to re-assemble latertobuildthetoweragain,theywouldnotbeableto com\u00admunicate effectively. I1 \nhave heard the story of theTower of Babel told many times, as a quote from Brooks, to illustrate why \nsoftware fails. The main point made by the storytellers is that pro\u00adgrammers can tcommunicate effectively \namong themselves and with their stakeholders. Thisfact should not be surpris\u00ading: an industry built by \nintroverts for introverts is bound to experience some communication problems. But there is more to consider: \nmuch too often,a software projectfails, because it tries to accomplish an impossible goal, something \nthat can tbe done, by de.nition. What are some impossible goals of software engineering?Tobuild perfectly \nmalleable software. To overcome the physical limitations of the do\u00admainsto which softwareis applied.Tomake \nsoftwaredevel\u00adopment project management easily predictable.Toguarantee consistent return oninvestmentin \nsoftwareby adding new features. Someexpectations come from non-technical stake\u00adholders, who don tunderstand \nwhich tasks can and can tbe accomplished with software. (This is not surprising: God in the biblical \nstorywas also unabletogaugethe feasibilityof building the tower of Babel.) Other expectations originate \nwithin our discipline. But, in spite of the constant pressure to achieve impossible goals, our discipline \nis continuously growing.Toexplore this apparent contradiction, this essay examines theexpectationsplaced \non software engineering. 1Anote on the authors voice is in order. Even though we are two authors, our \nopinions are presented with a collective I. I use the term we when referring to the community (i.e. programmers, \nor software developers, or software engineers). These three terms will be used interchangeably for reasons \nthat are explained later in the essay.  1. On Impossibility impossible (adj)1 a:incapableof being orof \noccurring b:felttobe incapableofbeingdone, attained,or ful.lled: insuperably dif.cult Merriam-Webster \ns Online Dictionary Brooks notesthatthegoalofthebuildersofthetowerwas naively impossible [6], but he \ndoesn t follow up on this observation, because he is focusing on communication and organization. Software \ndevelopment today is facing many impossibilities. Granted, many other disciplines constantly confront \nimpossibilities. Medicine, for instance, deals with incurable diseases and ultimately always loses to \ndeath. The difference is that people outside of the medical .eld un\u00adderstand that not all diseases have \ncures. But people don t have an intuitive understanding of the limitations of soft\u00adware, which gives \nrise to manyimpossible expectations. It s possibletoshow that someexpectations are incorrect. Theory \nof computation proves manyresults about the limits of computability,whichshowthat computerscan tdoevery\u00adthing. \nOthers, like the impossibility ofbuilding defect-free software, are slowly becoming understood. Dijkstra \ns asser\u00adtion that testing can t prove the absence ofbugs [10], cou\u00adpledwithPareto s80/20rule[2]that predictsthe \nincreasein costof removingeach additionalbug,helpto highlightwhat makes this expectation unrealistic. \nSome other expectations are also impossible to achieve,but they are not obvious to people outside of \nour discipline. Perfect Flexibility Some blame for the unrealistic expectations from software can be \nattributed to its .exibility and scalability. Software doesn t behave like physical materials, because \nit has no physical presence, which makes it a unique medium. As such, there are no good analogies that \nwould help people whodon thaveexperiencewithsoftwaretograsp intuitively which tasks are easy to accomplish \nwith software and which are impossible. Software is malleable and deceptively easy to change. A modularized \nsystem makes it easy to make sweeping changes that affect the entire product, if the software was designed \nto handle that type of change.But it s impossible to build software that can easily accommodate every \ntype of change no modeling or decomposition technique can do that, regardless of what research in MDA \norAOP might suggest. Not all changes can be planned for at the design time and other, seemingly trivial \nchanges break systems or take long time to implement. These, admittedly capricious, restrictions baf.e \nnon-technical stakeholders. One day the programmerisa magician, anotherday the same whiz can t addasimplebuttontotheuser \ninterface. Another form of .exibility in software is scalability. There are many waystobuild systems \noutofexisting sys\u00adtems. Once implemented, a program will always perform its well-de.ned tasks without \nfailure. However, this property isn t guaranteed combining two seemingly .awless pro\u00adgrams intoa new \none doesn tguaranteea .awless result.To a non-technical stakeholder, this constraint is also dif.cult \nto comprehend. Software can achieve excellent reliability, even in highly distributed environments.Forexample, \ntelecommunications systems, both wired and wireless, operate at .ve nines of availability (up 99.999% \nof the time which translates to about5minutesofdowntimeperyear).Telecommunications software is very .exible. \nOver time, cellular networks have been extended to support a wide range of capabilities of cell phones, \ne.g. accessing the Internet, downloading and streaming music and movies. But there are limits to this \n.exibility; when the limit is reached, adding new features becomes increasingly dif.cult as software \nturns brittle. Although nobody realistically expects perfect .exibility from software, different people \nhave experience with soft\u00adware that was perfect in one -ility or another. Given enough people with different \nexperiences, their collective expecta\u00adtions amount to perfection. No Physical Limitations Applying software \nto a new domain helps in automating manual tasks: thus improving productivity. Thesegains en\u00adcourage \nfurther application of software, with the intent of overcoming physical limitations of the domain. Unfortunately, \nsoftware can t remove limitations inher\u00adent to the domain for which it sbuilt. Embedded systems, even \nthough they arebuilt according to the well understood laws of the physical world, are bound by the physical \nlim\u00aditations of mechanical systems they control. Financial soft\u00adwareis limitedby the accuracyof economic \nmodelsofhow moneycirculates.(Thefateoftheexotic.nancialderivatives that brought about the current economic \ndownturn shows that these rules apparently still aren tunderstood very well.) SocialWeb applications \nare limitedby theattention spanof people (more precisely: teenagers) who use them.Webuild softwarethatextendstheknownlimits,butwe \nre boundto run into new limitations at some point. Another limitation software helps to overcome is how \nmuch information and knowledge one can access. But soft\u00adware is only a tool, and the information is only \nas good as its understanding. One can t expect that the quality of infor\u00admation will improve by the virtue \nof being implemented in software. Nor can the users of software become more intel\u00adligent justby using \nit. Theexpectationofovercomingphysical limitations comes from users and system analysts, who understand \nthe needs of the market,but not the limitations of software. While no sane person would ever consider \nusing an abandoned land\u00ading strip as a base of an aircraft carrier, software sometimes goes through even \nmore unbelievable metamorphoses. The manner in which software is created (i.e. the software devel\u00adopment \nprocess) also raises impossible expectations.  Predictable Project Management Project managers expect \nthat the quality of project schedul\u00ading and estimation in software engineering will match those of other \nrelated domains. Unlike the previous two expecta\u00adtions, which are based on the observation of current \ntrends, nothing in the state of practice in software engineering sup\u00adports this expectation. Historically, \nmanagement of software projects has been poor. The Chaos Summary 2009 from the Standish Group reports \nthat only 32% of all projects theystudied were suc\u00adcessful. They de.ne a successful project as delivered \non time, on budget, with required features and functions [32] Critics have been calling it the software \ncrisis.Parnas [29] points out thefallacyof this claim: it s not possible to have a crisis that lasts \nfor decades, yet this simplistic explanation resonates with manynon-technical stakeholders. The Stan\u00addish \nGroup recognizes that some improvementoccurredover the years. Theyattribute the improvements of project \nresults to more formalized project management, but also point to the adoptionof iterative softwaredevelopment \nasakeyfac\u00adtor [31]. The StandishGroup studies onlyIT projects, so we can tcompare their .ndingsto other \n.elds. In my experience, the reason why some projects are de\u00adliveredon timeand withinbudgethas littletodo \nwiththe quality of schedule and estimates of project management, but rather indicates the perseverance \nof programmers. Given achoice betweenworkinglong hoursorbeingletgo because the projectfailed, we choose \ntoface thefamiliar technical challenges, hoping that if this projectsucceeds, the next one will have \nmore realistic deadlines. It s easier to estimate the time and effort required if a projectisvery similarto \nsomethingthatwasdone before[7]. Incivil engineering,all bridges sharethe underlyingphysics, materialsscience, \nand mathematical principles, sobuilding a new bridge is an exercise of routine design [8], which means \nfollowing prede.ned steps.There s no such common denominator for software, which requires extensive explo\u00adration \n(or original design [8]) nearly every time a new productisbuilt. Software estimatesfail, because (application \nframeworks and software product lines notwithstanding) the products beingbuilt are oneofa kind.Evenif \nnew software isbuiltsolelytoreplaceanexisting system,it sstilldelivered with new features. Otherwise, \nthe existing software would be used instead, thus eliminating all the risks of developing a new product. \nSoftware project management is failing, because it fo\u00adcuses mostly on controlling the software development \npro\u00adcess according to the unreliable estimates. Tom DeMarco pointsout thatthe focuson peopleis important,but \ninstead of putting so much effort on control, we should focus more on the main tasks: on transforming \nthe world with software and fostering exploration [14]. The focus of what we do should not be on the \nartifact, the program,but rather on the environment in which the program will be deployed. Explo\u00adration \nis harder to measure than the execution of prede.ned steps, but this is the only way to make real progress. \nUn\u00adfortunately,even gooddevelopmentprocesses that improve programmer productivity, such as agile development, \nmorph into something different when project managers try to ap\u00adply them in practice. Mitchell observes \nthat many organiza\u00adtions that claim to practice agile development selectively fol\u00adlow the management \npractices (iterative planning and daily stand-up meetings),but not the engineering ones (test-driven \ndevelopment, user stories) [26]. As a result the exploratory quality is completely abandoned. Improvements \ncan come only from wholehearted attempts to change. Market conditions, business contract negotiations, \nand many otherfactors that in.uence project schedules are be\u00adyond programmers control. Good project managers \nunder\u00adstand thesefactors and are able to set realistic goals, achiev\u00adable by the development team. But \noften people without technical expertise, who understand only the management side make all the important \ndecisions. The result is impos\u00adsible deadlines, forcing developers to deliver an un.nished or incompletely \ntested product, which inevitablyfails at the hands of real users. Often this is the only time when non\u00adtechnical \nmanagement communicates directly with develop\u00aders. But .xing the reported defects quickly is not enough \nto regain their respect. Business people don tappreciate work\u00aders who can t meet schedules or deliver \nquality products. The past performance discredits developers from providing reliable input later. So \ndevelopers .nd themselves continu\u00adally trying to meet deadlines assigned by people who don t know how \nto set realistic expectations. The lack of understanding of the dif.culties of soft\u00adwaredevelopmentbythe \nmanagement precludes predictable project management. It s impossible to successfully manage a task without \nhaving some understanding of what the task entails. Guaranteed Pro.ts Project managementisnotagoal;it \nsameansto accomplish themaingoalofanyproduct,whichistomakemoney. Brian Foote summarizes it well: Programming \nis building a bigger abacus for man to count his money. Non-technical stakeholders are notfamiliar with \nthe con\u00adstraints that makebuilding software dif.cult. They tend to focus on the bottom line. The expectation \nof guaranteed pro.ts is a major source of unrealistic expectations that plague our profession. Owners, \ninvestors, and other stake\u00adholderswantto control/in.uence whatwedoandhow.They are looking for consistent \nreturn on their investment, because theirmaingoalisto continuetomakepro.ts.Butsuchagoal hasnoendinsight \nregardlessofhowmuch moneyonehas made already, there s always more to be made. The drive for pro.ts affects \notherfactors of software de\u00advelopment, such as good quality and reuse. Software is of\u00adten beingextended \npast its prime.To maximize pro.ts, non\u00adtechnicalstakeholders insistonadding more features,evenif the \nsoftware is becoming bloated. In the quest to capture new markets,old software quickly reachesits limits \nit becomes costly to maintain and eventually pro.ts dwindle. Alterna\u00adtively, if certain software captures \nmost of its market before it becomes unmaintainable(e.g.SAPin accountingandbusi\u00adness operations), its \nusers are stuck with software that cannot be changed.  Software doesn t age or wear out the way physical \nma\u00adterials do. Rather than through use, software ages when it s modi.ed, especially when modi.ed hastily \n[29]. Since max\u00adimizing pro.ts requires adapting existing software to new problems by adding more features, \nthe changes cause soft\u00adware to age. Software has many limitations, but it opens many pos\u00adsibilities and \ngives people the illusion that anything can be done and (because it s done by computers) it can be done \nwell.This illusionisspreadbyadvertisers,vendors, technol\u00adogy evangelists and mis-informedbusiness people.Software \nvendors build up unbelievable expectations, even among software practitioners. They offer productivity-increasing \nsoftware platforms, libraries, tools, and services. These so\u00adlutions rarely match theoverblown promises,butbythe \ntime the customers take note, the vendor is already marketing the next version of their product that \nwill solve the problem. Similarly, well-known experts offer new methodologies and processes aimedto solvethe \nsametypesof problems.Too often, it s thefameof theexpert rather than the qualityof ideas that prompts \norganizations to implement these inven\u00adtions. Non-technical people get caught up in thehype, con\u00advincedthatsoftware \nengineeringisjustonestepawayfroma breakthrough thatwill allow themto create perfect software; theywanttobethe.rstonesto \naccomplishthisfeat. 2. Self-imposed Impossibilities Sofar,I ve discussed four typesof impossibleexpectations. \nThat software is perfectly .exible, so making anychanges to softwareistrivial.That softwarecanovercomephysicallim\u00aditations \nof the domain it serves. That software can be man\u00adaged in an easily predictable way. That growing software \nby adding more features will guarantee continuing .nancial success. These expectations have a common \ncharacteristic theyoriginate outside of our community, from non-technical stakeholders. This suggests \nthat perhaps software develop\u00adment would not be restrained by impossible expectations if we simply ignored \nthe expectations of non-technical people. AsWeMay Think [9] To entertain thishypothesis, let s consider \nonevery success\u00adful endeavorin softwaredevelopment,theWorldWideWeb. TimBerners-Leebuiltthe initialversionoftheWebforthe \nphysicists to help them organize their vast information with the useofhypertext.He believed thattheWebcould \nconnect humans and machines so that once the state of our inter\u00adactions was on line, we could then use \ncomputers to help us analyze it, makesense of what we were doing, and wherewe individually.tin,andhowwe \ncan betterwork together [4]. (This great idea goes backtoVannevar Bush [9].) Initially, in theearly 1990s, \ntheWebwas free from unrealisticexpec\u00adtations. As it grew, it incorporated academic institutions and then \ncommercial traf.c. ThentheWeb becameahuge success,givingrisetonew industries such as eCommerce and social \nnetworking. Soon, the Web began to face same types of impossible expecta\u00adtions of perfection and .nancial \nsuccess. New types of soft\u00adware systems, most notably search engines, appeared and raisedtheexpectationof \nbringing disparate sourcesof infor\u00admation together to produce new knowledge. Unfortunately, petabytesof \ndataavailable on theWeb can tbe searched ef\u00adfectively. Few improvements have been made in the quality \nofWeb search in the last decade (Google s page rank algo\u00adrithm still remains the biggest breakthrough \nidea)but search\u00ading is nowhere near true understanding. The expectations of predictable project management \nis also present, and equally impossible, because the technologies for building new ap\u00adplicationsontheWeb \nchangeveryoften, makingitdif.cult to estimate schedules. And, like every other successful en\u00addeavor, \ntheWebfaces the same impossibleexpectationsof continuing pro.ts by adding new capabilities on top of \nthe baseWeb technologies. More deserves to be said about the .rst impossible ex\u00adpectation the perfect \n.exibility ofsoftware because a lot of progress has been made in this area. The software run\u00adning theWebisvery \n.exible. The systemsavailable on the Web today showcase incredible capabilities, especially since they \narebuilt on the original HTML, HTTP, and URI proto\u00adcols designedin the early 1990s, andhaveto account \nfor all their limitations.A great invention of theWeb is the status code 404 Not Found, which solves \nthe problem of pre\u00adsenting unavailable data if there is no resource to show, the system handles the \nerror gracefully. Another example of extending .exibility is the upcoming HTML5, which in\u00adcludes multimedia \nand text editing support, which promises to makeWeb software behave the same as desktop software, inallbrowsers.The.exibilityoftheWebis \nconstantlybeing pushedtoits limits,butit snot gettinganycloserto reaching the idealistic goals setupby \nBerners-Lee. The history of the Web brings forth two other impossi\u00adble goals of software engineering. \nFirst, it s not possible to design a massive system like the Web up front. The Web came into existence \nin a highly organic, non-designed, self\u00adorganized manner, and recognizing thisfact challenges the way \nwe think aboutbuilding software systems. Second, al\u00adthoughWebisa qualitatively as wellas quantitatively \ndif\u00adferent system from anything previously experienced in soft\u00adware engineering, we still try to think \nof it as just another machine , a system that we can manage, and set expecta\u00adtions for.  Whether it \nsBerners-Lee designingaworldwide network to better understand how people think, or companies like Google \nusing theWeb to deliver free services for their users the end result of trying to achieve great, but \nimpossible goals is the same: increased expectations. These idealistic expectations originate within \nthe software engineering com\u00admunity.Butregardlessof their source,the impossibleexpec\u00adtations affect the \ncore of software engineering; theycan tbe avoided. Every successful software will run into them even\u00adtually, \nby the virtue of its success. Metaphors of Our Discipline Another source of unrealistic expectations \nthat originate within our community is the de.nition of our discipline. More precisely: lack of a single \nde.nition. Software engi\u00adneering encompasses so many tasks that it s impossible to do all of them well. \nBefore explaining why the self-image of software engineering is a source of impossible expecta\u00adtions \nlet me summarize some of the more prevalent views (or metaphors). Without distinguishing between computer \nscience and software engineering, Fred Brooks says that building soft\u00adware is like a craft, because the \nprogrammer is a tool\u00adsmith [5]. Programmers serve others by .xing their prob\u00adlems and derive their rewards \nand self-worth from solving problems. Brooks emphasizes thatbuilding software is not a science, even \nthough the research methods we practice are modeled on sciences. Another direct analogy for software \ndevelopment is the assemblyline. It s a very old perspective that comes from the true engineering disciplines \n[13]. Rather than building software from scratch, it s better to assemble it from exist\u00ading artifacts: \nreusable programs and libraries,but also pro\u00adgramming languages, frameworks, tools [18]. This approach \nalso advocates developing more documentation artifacts and more focus on repeatability oftasks. One viewof \nthe relationship between computer science and software engineering is that the former provides the theoretical \nbasis for the latter.Forexample,Parnas notes that using science and mathematics tobuild products for \nothers is what engineers do [30]. But since programmers think of themselves as scientists, the problems \nexhibited by typical software are exactly those to be expected when products arebuiltbypeople who are \neducated for other professions and believe thatbuilding things is not their real job [30]. His pointwas \nthat manypeople fromother .elds werework\u00adingas programmers(or managers),buttodayhavinga com\u00adputer science \ndegree is not suf.cient either, because many programs don tteach enough about software engineering. Michael \nJackson [20] observes that software engineering is too broad a discipline to be meaningful. He equates \nits scope to physical engineering, an imaginary discipline that puts the concepts of physics into practice. \nAs different engi\u00adneering .elds have corresponding branches of natural sci\u00adences, Jackson wants to see \nsimilar specialization in soft\u00adware engineering. He lists compiler construction, operating systems and \nGUI as examples of individual engineering disciplines that have branched out of software engineering, \neven though they are all based on computer science. One observation to add here is that some of these \ndisciplines have developed a corresponding science. Compilers have elaborate mathematical notations and \nsystems for manipu\u00adlating the symbolic representation of the data,but operating systems have none. Instead \ntheyfollow a standard architec\u00adture with well-understood decompositionofthekernel into modules and well \nunderstood algorithms to implement these tasks. Programming revolves around people. Chuck Connell notes \nthat the difference between computer science and soft\u00adware engineering is that the formerhas lasting \nresults,but the practices in the latter change constantly [12]. He points out that software engineering \ndirectly involves human ac\u00adtivity, which makes the results of tasks such as maintain\u00adability, safety, \nor requirements engineering dependent on the people who work on them. Tried-and-true methods that work \nfor one team of programmers do not work for other teams [12]. This means that software development is \na lot likea social science,because it deals with people, especially with controlling and managing people. \nFor example, stud\u00adies of agile practices such as pair programming by Laurie Williams [11] show importance \nof observing programmers at work. However, observation is only a part of social sci\u00adences; the other \nis experimentation. But it s hard to conduct large-scale programmingexperiments, and it s impossible \nto perform double-blind studies (procedures in which neither the subjectsoftheexperiment northe persons \nadministering it know which aspects of the experiment are critical). Some (non-trivial) portion of software \ndevelopment bor\u00adders on art, i. e. work that produces aesthetically pleas\u00ading, yet useful, results. Donald \nKnuth considers program\u00adming an art form in an aesthetic sense [21]. He adds style and taste as important \ningredients of good programs. Pro\u00adgramming languages with small number of constructs, like Smalltalkand \nPython, appeartohavethisquality.Buteven hard core programming languages, like C++, have art. I likeQt, \nmanypeoplelike Boost,two collectionsof libraries and language extensions that simplify many programming \ntasks in C++. What makes a language or a library estheti\u00adcally pleasing?Asmall numberofconcepts that \nmesh well together in a uniform manner (in accordance with Brooks conceptual integrity [6]), are simple \nto use, and extensible. Every software developer has his or her personal favorites that .t this category. \nUnfortunately, being an art form is not a prevalent state: when such software shows good potential, it \nis extended and over-extended until it reaches its limit. As its size explodes, the good qualities simplicity, \nextensibil\u00adity, uniformity slowly erode. This seems to be thefate of all successful systems andlanguages. \n All these views represent some truth about software de\u00advelopment, because programming touches a wide \nvariety of tasks. James Herbsleb points out that our discipline is an interdisciplinary science [19] \nthat is more than computer science. He notes that understanding the underlying mech\u00adanisms in play as \npeople tackle software engineering tasks mechanisms rooted in human cognition, social practices, and \nculture is criticaltothe progressof our .eld. Ihaven t discussed cognition or culture,but these concepts \nalso come into play when trying to de.ne the proper scope of our dis\u00adcipline. It seems that programmers \nare living in a world of metaphors. To describe our discipline, we explain how it relates to other, better \nde.ned disciplines and occupations, which are a little like programming: like a craft, like an art, a \nsocial science, an assembly line. The term software engi\u00adneering is itself a metaphor; so is computer \nscience. The sheer number of metaphors makes it obvious that our discipline has dif.culty with de.ning \nits proper scope. No individual can be a toolsmith of all tools and Jack of all trades. A discipline \nwithout well-de.ned boundaries can t produce good results consistently. If we keep on trying to incorporate \ntoo many skills into the de.nition of our pro\u00adfession, we will continually .nd ourselves chasing what \nwe know are unrealistic and unattainable goals. (Sadly) Not Rocket Science Every disciplineislikelytoface \nsome unrealistic expecta\u00adtions, challenges that drive its progress. What is so special about software? \nThe expectations from software appear to be more extreme. Having looked at them in detail, let me highlight \nwhat makes our discipline unique. Programmingisnotasdif.cultas engineering.Alayper\u00adson is likely to consider \nthe established engineering disci\u00adplines to be dif.cult, because they require the application of mathematics \nand physics. Most software is not that hard to write. Scientists write their own programs using environ\u00adments \nlike Matlab; theyfeel theydon t need dedicated pro\u00adgrammers.The proliferationofWeb authoring toolsmakesit \neasyfor non-technicalpeopleto createtheirownWeb pages. Since software development is easier than, say, \nrocket sci\u00adence, it s no surprise that peopleexpect software profession\u00adals to deliver quality products. \nIn contrast, the products of engineering work are much easier to understand than software. Even though \nmost peo\u00adplewouldnot claimtoknowhowtobuilda bridge,aplane, or a rocket, they would be able to recognize \nthese products. If a rocket were missing a major component, like a propul\u00adsion system,a non-engineerwouldbe \nableto point that out, even without knowing anything about propulsion. Not so with software an average \nperson cannot tell apart a com\u00adpleted productfroma prototypethatprovidesonly5%ofthe advertised functionality,but \nhasa slick user interface. This lack of transparencymakes it more dif.cult to manage ex\u00adpectations in \nsoftware than in disciplines that create tangible products. Ironically, not only the users,but also the \nprogrammers fail to recognize that expectations from software are dif\u00adferent than from engineering. What \nwe do is both easier and harder than typical engineering .elds: the engineering part is often easier, \nwhile the non-engineering aspects are often harder than in other disciplines. However, program\u00admers want \nto be like engineers and scientists. These are our dominant metaphors, even though our work is different. \nIn attempts to show that we belong, we sometimes over\u00adengineer our solutions by building in extra functionality \nfor future changes that never materialize,by introducing op\u00adtimizations prematurely, or by building and \nusing bloated software platforms and processes. Some of our science is whimsical(e.g. formal methods \nde.ne elaborate proof tech\u00adniques for toy-size programs thatfail to scale to 1KLOC the amountof production-quality \ncode thata competent pro\u00adgrammer can produce in a month). All this effort goes to show that programming \nis a scienti.c discipline. This ex\u00adplains why alternative approaches, such as agile-style con\u00adtinuous \ndevelopment, still tend to be ignored, because they aren trecognizable as engineering. Theyare seen as \ninferior, because nobody couldbuilda rocket thatway. This interplay of ideals and realities of software \ndevelop\u00adment ampli.es the impossible expectations from software. We would probably understand them better \nif we .nally ad\u00admittedthatwhatwedois morethanmerelybuilding(or en\u00adgineering ) software. 3. Good Communication:ADif.cult \nGoal In hisstoryof theTowerof Babel, Brooks discusses com\u00admunication and organizational problems of software \nengi\u00adneering. Effective communication is still one of our biggest challenges,but it s not an impossible \ngoal; it s merely dif.\u00adcult. One reason that makes it dif.cult is that we don tfocus on the essential \nproblems of communication,but rather fo\u00adcus on tasks like documentation. How Documentation Hinders Communication \nIt is sometimes suggested that software engineers can stream\u00adline communication by preparing more documentation \narti\u00adfacts. While this approach works well in other engineering .elds that produce written documents \nin order to explore ideas and to re.ne the design, it doesn t work in software engineering. Whena project \nplan calls for manydocumenta\u00adtion deliverables, developers get bogged down with writing documents(thatadd \nlittlevaluetothedevelopment process), rather than writing the software. Large documentationmanuals, producedto \ncommunicate the behavior of a software system to its users, suffer from manyproblems. First, maintaining \nup-to-dateexternal documentation sep\u00adarately from code is hard to enforce, because it violates the say \nit once and only once rule [1]. The code de.nes the actual state of the system, and trying to duplicate \nit with\u00adout tracing the documentation back to the code will cause problems when the code changes. Often \ndocumentation is obsoleteby the time the softwareis implemented.  Naur goesfarther and claims that documentation \ncannot conveythe essential information necessary to understand a program, because software development \nis not about text production[27]. Documentation,evenif producedtothebest of our abilities,islikelyto \nmisleada readerwhoisnotfa\u00admiliar with the software. Naur claims that the only way to learn aboutthe softwareistowork \nwith other programmers who know it.WhileIdisagree with Naur s Theory Building View, which he proposes \nas an alternative approach, his dis\u00adtrust in text as a primary medium of software development is well-reasoned \nand convincing. Second, programmershave little motivationtokeep doc\u00adumentation up to date the programmer \nlikely won t be around when the code needs to be changed, and there are al\u00adways more pressing tasks to \ncomplete.Parnas suggests im\u00adposing standards on structure and documentation, making sure that products \nthat are produced using short cuts do not carry the industry seal of quality [29]. Although this is a \ncommendable stance in theory, quality documentation is not a required deliverable on most projects, because \nthere is no goodbusiness case for it. Third, there are no good examples of software docu\u00admentation. Should \none document software with textual de\u00adscriptions? with pictures and UML diagrams? using for\u00admal notation? \nBrooks spends most of his Tower of Babel chapter discussing a documentation technique called work\u00adbook. \nIt was a thick manual that included all the documen\u00adtation produced for the project. While Brooks still \nadvocates the use of workbook in the second edition of his book, in 1995 [6], this approach is too cumbersome \nfor most projects. An automated process would be ideal. Mahoney suggests documenting software evolution \nusing the moving picture metaphor [24], i.e. recording the process. While this idea has the advantage \nof obtaining the data for free while pro\u00adgrammers areworking,itfacestheproblemof editingthe raw data \nto recover the important lessons. Finally, it s not easy to determine which parts of the sys\u00adtem are \nmore important and should be documented .rst. And even if the order is known, it s impossible to write \nthe docu\u00admentation without repetition, once again violating the say it once rule. The only good documentation \nI mfamiliar with comes with open source libraries and frameworks (like J2EE frameworks or Qt). These \nsystems offer manyforms of doc\u00adumentation: high-leveltextoverviewof main concepts, fully functional demos, \ncookbook code, discussion board, wiki. The effort expanded to produce and maintain these artifacts is \njusti.edbylarge user base.Atypical application doesn t bene.t from most of these artifacts, because they \nare costly (in time and effort) to produce. Better Communication Documentationisonly oneof manyexamplesof \nmisdirected focusin softwaredevelopment.It doesn thelpthat program\u00admerstendtonotbegood writers.Wearemuch \nbetteratprob\u00adlem solving and creative thinking. In order to improve communication in software engineer\u00ading, \nwe ought to use these skills to our advantage.We need to learnhowto better managetheexpectations,bothfromin\u00adternalandexternalstakeholders,tobe \nmoreagileaboutwhat we do, and try to understand better which goals are feasible andwhich areimpossible.To \nimprove communication, we need to look for better ways to understand and explain what wedo.Let s considerin \nsome detailtwoexamplesthattake advantage of programming skills de.ning good abstrac\u00adtions and improving \nthe readability of code. Communicating throughAbstractions Abstraction identi.esageneral conceptbyeffectively \nhiding details. The resulting view is easier to understand and com\u00admunicate.Forexample,formal methodsworkby \nidentifying and eliminating unnecessary details.Without these simpli.\u00adcations, the amount of details \nwould make it impossible to scale any machine-veri.able proofs. But that is one of the reasons whyformal \nmethods are ineffective in practice, be\u00adcause eliminating details leads to loss of information and a \nlossy abstraction. In contrast, good software abstraction is loss-less:it hides details without eliminating \nthem.Aloss-less abstraction has multiple levels and its users can select the level at which to view, \nuse, or extend it. While continually raising the level of abstraction helps in identifying general concepts, \nit seffective onlyifit doesn t discard details.Forexample, modeling and visual assembly languagesbuilt \nontopof 4th generation programming languages [18] are only as good as their ability to handle modeling \nerrors. Most non-trivial problems have special cases to be considered, so it must be possible to recover \nthese details when necessary. To illustrate a lossy abstraction, consider the program\u00adming model where \ndistributed and local objects are treated uniformly. JimWaldo and colleagues [33] analyze four fun\u00addamental \nconcepts that break this model. First two concepts are latency of procedure calls and the use of pointers \nfor memory access. Sincethe local latencyisat least5ordersof magnitude smaller than the distributed one \nand implement\u00ading distributed pointers requires much more overhead, ac\u00adcommodating these two concepts \nrequires signi.cant effort and will make local computing inef.cient. The two other concepts, partial \nfailure and concurrency, can t be imple\u00admented locally, because these don t exist in local comput\u00ading. \nThe only way to implement them is to make all com\u00adputing distributed, which is obviously the wrong thing \nto do. In order to accommodate both programming models, pro\u00adgrammers must be able to distinguish between \ndistributed and local objects when necessary. The abstraction of uni.ed programming model will work well \nuntil there is a serious failure then the errors caused by distribution must be han\u00addled as special cases. \n Information hiding [28] is a good example of applying a loss-less abstraction. This technique identi.es \na system de\u00adcomposition that enables the hidingof internal changes.To\u00adday, information hiding is often \nsimpli.ed to mean encapsu\u00adlation and access control (with public,protected, andprivate visibility modi.ers) \nin object-oriented languages. But there is more to this concept. In his paper,Parnas compares two decompositionsofa \nprogram into modules one where each step of the program s algorithm is a module, the other based on \nisolating design decisions. The second decomposition is more maintainable it enables the hiding of design \ndeci\u00adsions (not just data) from other modules so thatit s easier to change them independently. It also \ngroups together code and decisions that are likely to change at the same time (in the spirit of the say \nit once rule). Brooks criticizedinformation hiding in 1975 [6]. He ar\u00adgued that it s impossible to completely \nand precisely de.ne all interfaces between modules and that it s easier to .nd er\u00adrors between interfaces \nif the internals are not hidden. In the second edition, he admitted that he was wrong. When infor\u00admation \nhiding is applied correctly, the clients only need to consider the interfaces, which greatly aids the \nunderstand\u00ading of a system. The hard part of implementing information hiding is .guring out how to divide \nresponsibilities between modules.Very little research has been done on this topic (for one example see \nLamb et al [23], who propose a theory of modular information hiding design methods). By better un\u00adderstanding \nhow to divide responsibilities in the code, we can improve communication through the use of better ab\u00adstractions. \nAbstractions are not limited to programming concepts; they appear also in written documentation, e.g. \nin design patterns [16]. A pattern begins with a descriptive title and a one-sentence summary. An expert \ncan recognize the idea by reading the opening sentence.Areader who doesn thave thatexperienceisledtodiscoveritin \nsteps.A patternde\u00adscription explains the context where the pattern applies, fol\u00adlowed by the forces that \nmake it a non-trivial solution, then the description of the solution again, from overview to de\u00adtail.Apattern \ndescription typicallyendswithalistofknown uses that mention actual software that uses the pattern. This \ngives readers references to other documents that describe the concept captured in the pattern. That sthe \nbeauty of loss-less abstractions provide an overview, then add more details to unveil the complexity \nbehind the basic idea that represent the abstraction (in this case:the pattern). Although it s not a \nblack art, understandingabstractions can tbetaughtasaprescribed sequenceofsteps.Thekeyto abstractions \nis good metaphors; theyrequire creative think\u00ading and continuous re.nement. Abstractions are best learned \nby doing. Communicating via Code The way programmers communicate with computers and with one another \nthrough code, is also imperfect. My col\u00adleague Scott noted recently: Eachline of code could be either \narbitrarily capricious, sloppy,orextremely carefullycrafted.Asareader,youcan t tell whichitis,butitmakesalotofdifference. \nThis is probably the saddestfact about the state of prac\u00adtice in software engineering. Readable code \nis the obvious goal to strive for in order to improve communication. The irony of the word code should \nnot escape us; code is, as the name indicates, cryptic. It s easier to write code than to read it later. \nMany of the decisions made while writing code are not preservedin the codebecause theycan tbeex\u00adpressed \nwithprogramming languages. Butwhyhaven tpro\u00adgrammers devised a good way of indicating which code is critical? \nCertainly not to protect our code from others. The codeIwrite turns intoa riddle for meifIdon t useit \nfora few weeks. Programming languages lack good mechanism for effec\u00adtively tagging code with additional \nmetainfo. De.ning an\u00adnotations for human readers is rarely used in practice. Sim\u00adilarly, code comments \nare seldom considered when code needs to be changed. If one were to add a comment to a line of code, \nstating This line was implemented this way because..., the comment is likely to stay in the code for\u00adever,untouched. \nOther developers have no problems making changes the code,but nobodyever edits such comments, not even \nto mark them as obsolete . Literate programming [22] is sometimes suggested as a known solutionforthisproblem.Knuthmotivatedit \nInstead of imagining that our main task is to instruct a computer what to do, let us concentrate rather \non explaining to hu\u00adman beingswhatwewanta computertodo. He combineda programming language and documentation \nintoa single sys\u00adtem thatwould improve communication.Today, literate pro\u00adgramming is a thing of the past. \nPerhaps users were put off by the idea of programs as works of literature. Or perhaps the need to combine \ntwo languages unnecessarily deterred programmers from focusing on writing software. One modern technique \nthat helps to improve communi\u00adcation via code, albeit indirectly, is writing unit tests: doc\u00adumenting \ncode by writing more code. Automated unit test\u00ading coupled with continuous integration arekeypracticesin \nagile development, which de-emphasizes the importance of documentation artifacts [3].Test casesdo not \nmakeit easier toreadcode,buttheyhelpto clarify whichcodeis important (the important code has more tests). \nThey help developers rephrase what the application says, using code.Tests are run continuouslyto check \nthatboth interpretations match.Test casesareeffective, becausetheyarecode(sotheycanbeex\u00adecuted, which \nmakes them real ) and documentation at the same time.  It s easier to see source code as a good documentation \nmedium if most of the program s code is accessible. The riseof open source software has been instrumentalingiving \napplication developers access to the code of frameworks and libraries. Simple techniques like extractable \ncode comments (think Javadoc) and annotations make it easier to understand code. The best and worst of \ncommunication between program\u00admers occurs via code. Still, code comprehension remains a dif.cult task. \n4. From Impossible to Realistic Goals Finding better solutions for improved communication is an ambitious \ngoal,but at least it is not an unrealistic one. Per\u00adhaps the realism kicks in by acknowledging the fact \nthat there is no unique and perfect way to communicate; instead communication occurs through various \nartifacts, each play\u00ading its part. This subtlety distinguishes an impossible goal from an ambitious,but \nrealistic one. There is a big difference between impossible and ambi\u00adtious goals. Building faster stock-trading \nsoftware is a re\u00adalistic goal, whilebuildingbug-free stock-trading software is impossible. It s important \nto be able to recognize which goals are unattainable, and to focus on achievable substitutes instead. \nOver time, some impossible goals can become achiev\u00adable.Twofactors contribute to this: technological \nimprove\u00adments and rationalization of goals.Technological improve\u00adments act as a game changer. With constant \ntechnological advancesand better understandingofthe challengesfacedin software engineering, some impossible \nexpectations of the past have become realistic goals. Online upgrades make it possible to update software \nwhile it s running, something that couldn tbe done earlier. Modular design makes it possi\u00adble tobuild \nincreasingly bigger software systems. The com\u00admunication protocolsof theWeb enablecommunication be\u00adtween \nheterogeneous systems. Multicore processors enable executing parallel programs oneven the smallest computers. \nThese and manyother technological advances explore new ways of breaking down the incidental complexity \n[6] that can makea difference betweenfacing impossible, or merely dif.cult, goals. Another way to eliminate \nan impossible goal is to ratio\u00adnalize the expectation, i.e. to constrain the degrees of free\u00addom of the \noriginal impossible goals.Typically, this comes from prior experience (.rst hand or from engineering \nhis\u00adtory), or from better understanding of the problem itself. One of the biggest challenges of software \ndevelopment is deal\u00ading with changing requirements. Is trying to keep up with changing requirements an \nimpossible goal? In a way, yes, because requirements changes will always precede changes in the software, \nso theyforce programmers to constantly play catch-up. A rational goal is to leverage improved technol\u00adogy \nto make it easy to play catch-up. At the process level, this could be done by following agile practices. \nAt the code level,refactoringcodeandmakingitmodularhelps bringing in the changes when needed.With good \nchange management and open communication,keepingup with changing require\u00adments becomes a realistic goal. \nButfast-paced software projects can tbe haltedtowait for technological improvements, and rationalization \nof goals sometimesmightfeellikeabadcompromise.Inthose cases, setting realistic goals requires open communication \nto ed\u00aducate the stakeholders who expect too much. Comparison with competing systemsshowwhat capabilitiesare \ncurrently available.Techniques like Domain Driven Design [15] show how to grow a common language from \nexperiences of var\u00adious stakeholders. Realistic goals also comefrom thinking like designers [8], not \nmerely software designers, but in\u00adformed creators of systems. 5. TheTowerof Babel Did NotFail Current \nresearch in archeology indicates that the story of theTowerof Babelwasinspiredbya real edi.ce, a staged \ntemple-tower [ziggurat] that the Babylonians knew by the Sumerian ceremonial name of E-temen-anki (House \nof the Foundation Platform of Heaven and Underworld) [17]. Throughout the 2ndand 1st millennium BC, virtually \nevery invader of Babylon destroyed the tower, and every success\u00adful ruler dreamt of rebuilding it. Several \nBabylonian kings started the rebuilding process and, although it s not certain howmanysucceeded, the \ntower was completed at least once, after almost a century of work, around 590 BC. The .nal destruction \nof the tower came at the hands of the Persians. Alexander the Great or one of his successors in Babylonia \ntried to rebuild it again. Their short-lived effort began and ended with clearing out the debris; it \ns not clear why.Adifferent, smallerbuildingwas erectedinplaceofthe tower later,buttheextensive foundationsofthetowerhave \nsurvived under ground until the modern times. Although the biblical story says that the tower could only \nhave been built by people communicating with one language,history indicates otherwise. Men speaking many \nlanguages worked there, because ancient Babylon was the multilingual center of the civilized world. Less \ncivilized people came (attractedby itsfame), conquered the land and destroyed the city,but then were \nslowly assimilatedby the locals who taught them how to rebuild it. The historical Tower of Babel did \nnot fail. In contrast to the biblical story, the tower was completed successfully, and by people speaking \nmany languages. The construction succeeded, because in place of an impossible goal of reach\u00ading the heavens, \ntheir actual goal was to build the largest tower possible.Today,evenasaruin,thetower teachesmany important \nlessons. Humans are capable of achieving great things, and we enjoy the challenge of completing dif.cult \ntasks.Weshouldalways thinkbig,but recognizeandstay away from the trap of the impossible.  An Epilogue \nMcCullough s historyofthePanama Canal [25] presentsa modern study offacing impossibilities. What is impossible \nfor one person or group, need not be impossible for another. Expectations, as well as time, can change \nthe dif.culty of a problem. The .rst attempt to build the Panama Canal was by a French company,in 1880. \nThe taskwas ledby Ferdinandde Lesseps, who hadbuilt the Suez Canal earlier. That success has led to high \nexpectations, even though the conditions in Panama were different. Lesseps underestimated the amount \nof dirt that needed to be moved, and ignored the effects of tropical diseases. This attempt was abandoned \nin 1889, after over 20,000 workers died, mostlyfrom disease. Soon after, from 1904 to 1914, the Americans \nsucceeded at building the canal. They focused .rst on eliminating mosquitoes so that disease was less \nof a problem, then on building a good railroad to carry away the dirt (the French one was too small). \nOneoftheadvantagesthathelpedthe Americanshadwas that medicine had advanced during that time. People knew \nwhat caused malaria and yellow fever; earlier theydid not. As a result, the project consumed only 5000 \nlives. Anotheradvantagewasthattheydidn ttrytobuilda sea\u00adlevel canal. They used a lake as part of the \ncanal, which meant that every ship has to be raised to the lake level, and then brought down, using locks. \nThe French tried to dig the entire length of the canal (48 miles) by themselves, which would have been \neven more work. The storyof the FrenchinPanamaisa tragic taleof man trying to do the impossible.The American \neffort bene.ted from understanding the problems that plagued the French. Technological improvements and \nsuccessful rationalization of goals (aidedby better understandingof the prior impossi\u00adbilities) have \nmade it possible for Americans to achieve the same goal, only a quarter century later. 6. ACKNOWLEDGEMENTS \nThe authors would like to thank Baris Aktemur, Nicholas Chen, Maximiliano Davids, Ralph Johnson, Jason \nKahn, Maurice Rabb, Linda Rising, Roger Whitney, Arturo Zam\u00adbrano, the anonymous reviewers, and especially \nour shep\u00adherd, DavidWest. References [1] , Once And Only Once.Available at: http://c2.com/cgi/ wiki?OnceAndOnlyOnce. \n[2] , What is 80/20 rule? Available at:http://www.80-20 presentationrule.com/whatisrule.html. [3] Beck, \nK. Extreme Programming Explained: Embrace Change, AddisonWesley, 2000.  [4] Berners-Lee,T. TheWorldWideWeb:Avery \nshort personal story. Available at:http://www.w3.org/People/Berners\u00ad Lee/ShortHistory.html. [5] Brooks, \nF. P. The Computer Scientist as a Toolsmith II, Communicationsof theACM, March1996. [6] Brooks,F.P. \nThe Mythical Man-Month, Anniversary Edition, AddisonWesley, 1995. [7] Brooks,F.P.Three Great Challenges \nfor Half-Century-Old Computer Science, Journalof theACM.January 2003. [8] Brooks,F.P. The Design of Design: \nEssays from a Computer Scientist, AddisonWesley, 2010. [9] Bush,V.AsWeMay Think. The Atlantic Monthly, \nJuly 1945. [10] Buxton, J. N. and B. Randell, eds. Software Engineering Techniques, April 1970, p. 21. \nReport on a conference sponsoredby theNATO Science Committee, Rome, Italy, 2731 October 1969. [11] CockburnA. \nandL.Williams. The Costs and Bene.tsofPair Programming, Proceedings of eXtreme Programming and Flexible \nProcesses in Software Engineering, XP2000. [12] Connell, C. Software Engineering .Computer Science, = \nDr. Dobb s HighPerformance Computing, June 04, 2009. Available at: http://www.drdobbs.com/hpc-high\u00adperformance-computing/217701907. \n[13] Cusumano, M.A. Factory Concepts and Practices in Software Development: An [sic] Historical Overview. \nWorkingPaper #3095-89 BPS. Sloan SchoolofManagement, MIT, 1989. [14] DeMarco,T. Software Engineering: \nAn Idea WhoseTime Has Come and Gone? IEEE Software,July/August 2009. [15] Evans, E. Domain DrivenDesign:TacklingComplexityinthe \nHeart of Software, AddisonWesley, 2004. [16] Gamma, E., R. Helm, R. Johnson, and J. Vlissides. Design \nPatterns: Elements of Reusable Object-Oriented Software, AddisonWesley, 1994. [17] George,A.R.TheTowerof \nBabel:Archaeology, Historyand CuneiformTexts Archivf.ur Orientforschung,51 (2005/2006). pp. 75-95.Available \nat: https://eprints.soas.ac.uk/ 3858/. [18] Green.eld, J., K. Short, S. Cook, and S. Kent. Software Factories: \nAssembling Applications withPatterns, Models, Frameworks, andTools.Wiley, 2004. [19] Herbsleb, J. Beyond \nComputer Science, Proceedings of the 2005 (27th) International Conference on Software Engineering. [20] \nJackson, M. Problem Analysis Using Small Problem Frames, South African Computer Journal 22; Special Issue \non WOFACS 98, pp47-60, 1999. [21] Knuth, D. E. Computer programming as an art. Communica\u00adtionsoftheACM.Volume17, \nIssue12 (December 1974). [22] Knuth, D. E. Literate Programming. The ComputerJournal. Volume 27(2), pp \n97 111, 1984. [23] Lamb,D.A. andK.A. Schneider.Formalizationof informa\u00adtion hiding design methods, CASCON \n92:Proceedings of the 1992 conference of the Centre for Advanced Studies on Collaborative research. \n [24] Mahoney, M. Software Evolution and the Moving Picture Metaphor, Proceedings of the Conference on \nObject-Oriented Programming, Systems, Languages, and Applications (OOP-SLA 2009). [25] McCullough, D. \nThePath Between the Seas:The Creation of thePanama Canal, 1870-1914. Simon&#38;Schuster, First Edition, \n1978. [26] Mitchell, C. Guest View: The half-agile path leads nowhere. SD Times, March 15, 2010. Available \nat: http://www.sdtimes .com/GUEST VIEW THE HALF AGILE PATH LEADS NOWHERE/ By CYNDI MITCHELL/About AGILE/34197. \n [27] Naur,P. Programming as Theory Building, North Holland Publishing Company, Micropocessing and Microprogram\u00adming \n15 (1985) 253-261. [28]Parnas,D.L.On the CriteriaToBe Usedin Decomposing Systems Into Modules, Communications \nof theACM, Dec. 1972,Vol.15, No.12. [29]Parnas,D.L.Software Aging,InvitedTalk, International Conference \non Software Engineering,1994. [30] Parnas, D. L. Software Engineering: An Unconsummated Marriage, CommunicationsoftheACM,Sept. \n1997,Vol.40, No.9. [31] The Standish Group, CHAOS Summary2004.Available at: http://www.softwaremag.com/L.cfm?doc=newsletter \n/2004-01-15/Standish [32] The Standish Group, CHAOS Summary2009.Available at: http://www1.standishgroup.com/newsroom/chaos \n2009.php. [33]Waldo,J.,G.Wyant,A.Wollrath andS.Kendall. ANote on Distributed Computing, Sun MicrosystemsTechnical \nReport SMLI TR-94-29, November 1994.  \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Fred Brooks' retelling of the biblical story of the Tower of Babel offers many insights into what makes building software difficult. The difficulty, according to common interpretations, comes from the communication and organizational problems in software development. But the story contains one more important lesson that people tend to miss: one cannot accomplish <i>impossible</i> goals, which programmers are often asked to do. Software engineering, as a discipline, can overcome poor communication; but as long as we attempt to live up to impossible expectations, we will always fail.</p>", "authors": [{"name": "Paul Adamczyk", "author_profile_id": "81319487467", "affiliation": "Booz Allen Hamilton, McLean, VA, USA", "person_id": "P2354192", "email_address": "", "orcid_id": ""}, {"name": "Munawar Hafiz", "author_profile_id": "81100376625", "affiliation": "University of Illinois at Urbana-Champaign, Champaign, IL, USA", "person_id": "P2354193", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869537", "year": "2010", "article_id": "1869537", "conference": "OOPSLA", "title": "The Tower of Babel did not fail", "url": "http://dl.acm.org/citation.cfm?id=1869537"}