{"article_publication_date": "10-17-2010", "fulltext": "\n Ownership and Immutability in Generic Java Yoav Zibin Alex Potanin PaleyLi Mahmood Ali Michael D. Ernst \nVictoria University of Wellington Massachusetts Institute of Technology University of Washington Wellington, \nNew Zealand Cambridge, MA, USA Seattle, WA, USA yoav|alex|lipale@ecs.vuw.ac.nz mali@csail.mit.edu mernst@cs.washington.edu \n Abstract The Java language lacks the important notions of ownership (an object owns its representation \nto prevent unwanted alias\u00ad ing) and immutability (the division into mutable, immutable, and readonly \ndata and references). Programmers are prone to design errors, suchas representation exposure or violation \nof immutability contracts. This paper presents Ownership ImmutabilityGenericJava (OIGJ), a backward-compatible \npurely-staticlanguageextension supportingownershipand immutability.We formally de.neda corecalculusforOIGJ, \nbased on FeatherweightJava, and proveditsound.Wealso implementedOIGJ and performed case studies on 33,000 \nlines of code. Creation of immutable cyclic structures requires a cook\u00ad ing phase in whichthe structureis \nmutatedbut the outside world cannot observe this mutation. OIGJ uses ownership informationtofacilitate \ncreationof immutable cyclic struc\u00ad tures,by safely prolongingthe cooking phaseeven afterthe constructor \n.nishes. OIGJis easyfora programmerto use, anditis easyto implement (.ow-insensitive, adding only14 rulesto \nthoseof Java).Yet,OIGJismoreexpressive than previousownership languages, in the sense that it can type-check \nmore good code.OIGJcanexpressthefactoryandvisitor patterns,and OIGJ can type-check Sun s java.util collections \n(except for the clone method) without refactoring and withonly a small number of annotations. Previous \nwork required major refactoring of existing code in order to .t its ownership restrictions. Forcing refactoring \nof well-designed code is undesirable becauseit costs programmereffort,degradesthe design, and hinders \nadoption in the mainstream community. Categories and Subject Descriptors D.3.3[Programming Languages]: \nLanguage Constructs and Features; D.1.5[Pro\u00ad grammingTechniques]: Object-oriented Programming GeneralTerms \nExperimentation, Languages, Theory Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright c \n. 2010ACM 978-1-4503-0203-6/10/10... $10.00 1. Introduction This paper presents OwnershipImmutabilityGenericJava \n(OIGJ), a simple and practical language extension that ex\u00ad presses both ownership and immutabilityinformation. \nOIGJ is purely static, without any run-time representation. This enables executing the resulting code \non anyJVM without run-timepenalty.Our ideas,though demonstrated usingJava, are applicable to anystaticallytypedlanguage \nwith generics, such asC++, C#, Scala, and Eiffel. OIGJfollows the owner-as-dominator discipline[1, 11, \n33]wherean object cannotleakbeyonditsowner: outside objects cannot access it. If an object owns its representation, \nthen there arenoaliasestoitsinternalstate.Forexample, a LinkedList should own all its Entry objects (but \nnot its elements);entries shouldnotbeexposedtoclients,andentries from different lists must not be mixed. \nThekeyword private does not offer such strong protec\u00adtion as ownership, because a careless programmer \nmight writea publicmethodthatexposesaprivateobject(a.k.a.rep\u00adresentationexposure). Phraseddifferently,thename-based \nprotection usedinJava hides thevariablebut not the object, as opposedtoownershipthatensuresproper encapsulation. \nThekeyideainownershipisthatrepresentationobjects are nested and encapsulated inside the objects to whichtheybe\u00adlong. \nBecausethisnestingis transitive,thiskindofownership is also called deep ownership [12]. OIGJis based \non our previous type systems for ownership (OGJ[33]) andimmutability(IGJ[40]). Although ownership andimmutabilitymay \nseemliketwo unrelated concepts,a designinvolving both enhancestheexpressivenessof each individual concept. \nOn the one hand, immutability previ\u00adouslyenhancedownership by relaxing owner-as-dominator to owner-as-modi.er[24]: \nit constrains modi.cation instead of aliasing. On the other hand, the bene.ts of adding owner\u00adshipontopofimmutabilityhave \nnotbeeninvestigatedbefore. One such bene.t is easier creation of immutable cyclic data\u00adstructuresby usingownership \ninformation. Constructing an immutable object must be done with care. An objectbegins in the raw (not \nfully initialized) state and transitions to the cooked state[6]when initialization is complete.For animmutable \nobject, .eld assignmentis allowedonly whentheobjectis raw,i.e.,the object cannot bemodi.ed afteritis \ncooked.Animmutable object should notbe visibleto the outsideworldinitsraw state because itwould seemtobemutating.Thechallengeinbuildingan \n immutable cyclic data-structure is that manyobjects must be raw simultaneously to create the cyclic \nstructure. Previous work restricted cooking an object to the constructor, i.e., an object becomes cooked \nwhen its constructor .nishes. Ourkeyobservationis that an object can be cooked when its owner s constructor \n.nishes. Moreprecisely,inOIGJ,a programmer can choose between cooking an object until its constructor \n.nishes, or untilits owner becomes cooked. Because the object is encapsulated within its owner, the outside \nworld will not see this cooking phase. By adding ownershipinformation,we canprolongthe cookingtimeto \nmake it easier to create complex data-structures. Considerbuilding animmutable LinkedList (Sun s imple\u00ad \nmentation is similar): LinkedList(Collection<E> c) { this(); Entry<E> succ = this.header, pred = succ.prev; \nfor (E e : c) { Entry<E> entry = new Entry<E>(e,succ,pred); // It is illegal to change an entry after \nit is cooked. pred.next = entry; pred = entry; } succ.prev = pred; } An immutable listcontainsimmutable \nentries, i.e., the .elds next and prev cannotbe changed after an entryis cooked.In IGJ and previous work \non immutability, an object becomes cooked after its constructor .nishes.Because next and prev are changed \nafter thattime,this codeis illegal.In contrast, in OIGJ, this code type-checks if we specify that the \nlist (the this object) owns all its entries(the entries are the list s representation). The entries willbecome \ncookedwhen their owner s (the list s) constructor .nishes, thus permitting the underlined assignments \nduring the list s construction. Therefore,therewasno needtorefactorthe constructorof LinkedList for the \nbene.t of OIGJ type-checking. Informally,OIGJ providesthefollowingownership and immutability guarantees.Let \n.(o) denotethe owner of o and let j. denotetheownershiptree,i.e.,thetransitive, re.exive closure of o \nj..(o). Phrased differently, .(o) is the parent of o inthe tree,andthetop(biggest)nodeinthetreeisthe \nroot World.We say that o1 is inside o2 iff o1 j. o2, and it is strictly inside if o1 = o2. Ownership \nguarantee: An object o' canpointto object o iff o'j..(o), i.e., o is owned by o' orby oneofitsowners. \n(This is the classical guarantee of owner-as-dominator.) Immutability guarantee: An immutableobject cannot \nbe changed after it is cooked. (When exactly an objectbecomes cooked is formally de.ned in Sec. 3.) Contributions \nThe main contributions of this paper are: Simplify ownership mechanisms Most previousworks used new mechanisms \nthat are orthogonal to generics. Our pre\u00ad viouswork(OGJandIGJ)reusesJava s underlying generic mechanism.However, \nOGJ prohibited using genericwild\u00ad cardsandcertain kindsofgenericmethods.OIGJincreases theexpressivenessofOGJwithout \nintroducingnew mecha\u00adnisms,byimplementing scopedregions[37]usinggeneric methods, andexistentialowners[38]usinggeneric \nwild\u00adcards. No refactoring of existing code Java s collection classes (java.util)are properly encapsulated. \nWe have imple\u00admentedOIGJ, andveri.edthe encapsulationby running the OIGJtype-checkerwithout changingthesource \ncode (except fortheclone method).Verifying Sun s LinkedList requires only3 ownership annotations(see \nSec.4). Pre\u00advious approachestoownership orimmutability required major refactoring of this codebase. Flexibility \nAsillustratedby our casestudy, OIGJis more .exible and practicalthanprevious type systems.Forex\u00ad ample, \nOIGJ can type-checkthevisitordesign pattern(see Sec. 2),but other ownership languages cannot[26].An\u00ad \nother advantage of OIGJis thatit uses ownership informa\u00ad tiontofacilitatecreatingimmutablecyclic structuresby \nprolonging their cooking phase. Formalization Wede.neaFeatherweightOIGJ(FOIGJ)cal\u00ad culus to formalize \nthe concepts of raw/cookedobjects and wildcardsasowner parameters.Weprove FOIGJis sound and show our \nownership and immutability guarantees. Outline. Sec.2presentstheOIGJlanguage.Sec.3de.nes the OIGJformalization. \nSec.4discussestheOIGJimplemen\u00ad tation andthe collections case study.Sec.5compares OIGJ to relatedwork, \nand Sec.6concludes. 2. OIGJ Language This section presentsthe OIGJ languageextension thatex\u00adpresses both \nownership andimmutabilityinformation.We .rst describe the OIGJ syntax (Sec. 2.1).We then proceed with \na LinkedList classexample(Sec. 2.2),followedby the OIGJtyping rules(Sec. 2.3).We conclude withthefactory \n(Sec. 2.4) and visitor (Sec. 2.5) design patterns in OIGJ. 2.1 OIGJ syntax OIGJintroducestwonewtype \nparameterstoeachtype,called the owner parameter and the immutabilityparameter.For simplicityofpresentation,intherestof \nthis paperwe assume that thespecial type parametersareatthebeginningofthe listoftype parameters.We stress \nthat genericsinJava are erasedduringcompilationto bytecodeanddonotexistatrun time, thereforeOIGJdoes \nnotincurany run-timeoverhead (nor does it support run-time casts). InOIGJ,allclasses are subtypesoftheparameterizedroot \ntype Object<O,I> thatdeclaresanownerandanimmutability parameter. In OIGJ, the .rst parameteris theowner(O), \nandthe secondis theimmutability(I).Allsubclassesmust invariantly preserve their owner and immutabilityparameter. \n  Figure 1. The type hierarchyof (a) ownershipand (b) im\u00ad mutability parameters. World means the entire \nworld can ac\u00adcessthe object,whereas This means that this owns the object and no one else can access it. \nThe meaning of Mutable/Immut is obvious.A ReadOnly reference points to a mutable or im\u00admutableobject,andtherefore \ncannotbeusedtomutatethe object. Raw represents an object under construction whose .elds can be assigned. \nTheownerandimmutability parametersformtwoseparate hierarchies, which areshownin Fig.1.These parameters \ncannotbeextended, andtheyhave no subtyperelationwith any other types. The subtyping relation is denoted \nby =, e.g., Mutable = ReadOnly.Subtypingisinvariantin theowner parameter and covariant in the immutability \nparameter. (See also paragraph Subtype relation in Sec. 2.3.) Note that the owner parameter O is a type, \nwhereas the owner of an object is an object. For example, if the owner parameter is This,thentheowneris \nthe object this. Therefore, the owner parameter (which is a type) at compile time correspondstoanowner(whichisan \nobject)atruntime. (See also paragraph Owner vs. Owner-parameter below.) OIGJ syntax borrows from conditional \nJava (cJ)[20], where a programmer can write method guards. A guard of the form <X extends Y>? METHOD \nDECLARATION has a dual meaning: (i) the method is applicable only if the type ar\u00adgument that substitutes \nX extends Y, and(ii)the bound of X inside METHOD DECLARATION changes to Y. The guards are used toexpresstheimmutabilityof \nthis:a method receiver oraconstructor result.Forexample,a method guarded with <I extends Mutable>? meansthat(i) \nthemethodis applica\u00adble onlyifthereceiverismutableand therefore (ii) this can be mutated inside the method. \nClass de.nition example Fig.2showsanexampleof OIGJ syntax.Aclass de.nition declarestheowner andimmutability \nparameters(line1);by conventionwealways denote them by O and I andtheyalwaysextend World and ReadOnly. \nIf the extends clauseismissingfroma class declaration, then we assume it extends Object<O,I>. Immutability \nexample Lines 2 4 show different kinds of immutability in OIGJ: immutable, mutable, and readonly. Areadonly \nand an immutable reference may seem similar because neithercanbe usedto mutate the referent.However, \nline 4 shows the difference between the two: a readonly reference may point to a mutable object. Phraseddifferently, \na readonly reference maynot mutate its referent, though the referent may be changed via an aliasing mutable \nreference. 1:class Foo<O extends World,I extends ReadOnly> { 2: // An immutable reference to an immutable \ndate. Date<O,Immut> imD = new Date<O,Immut>(); 3: // Amutable reference to a mutable date. Date<O,Mutable> \nmutD = new Date<O,Mutable>(); 4: // A readonly reference to any date. Both roD and imD cannot mutate \ntheir referent, however the referent of roD might be mutatedby analias, whereas thereferentof imD is \nimmutable. Date<O,ReadOnly> roD = ... ? imD : mutD; 5: // Adate with the same owner and immutability \nasthis. Date<O,I> sameD; 6: // Adate ownedbythis;it cannot leak. Date<This,I> ownedD; 7: // Anyone \ncan access this date. Date<World,I> publicD; 8: // Can be called on any receiver; cannot mutate this. \nThe method guard <...>? is part of cJ s syntax [20]. <I extends ReadOnly>? int readonlyMethod() {...} \n9: // Can be called only on mutable receivers; can mutate this. <I extends Mutable>? void mutatingMethod() \n{...} 10: // Constructor that can create (im)mutable objects. <I extends Raw>? Foo(Date<O,I> d) { 11: \nthis.sameD = d; 12: this.ownedD = new Date<This,I>(); 13: // Illegal, because sameD came from the outside. \n// this.sameD.setTime(...); 14: // OK, because Raw is transitive for owned .elds. this.ownedD.setTime(...); \n15:}} Figure 2. An example of OIGJ syntax. Java s type arguments areinvariant (neithercovariant nor contravariant),toavoid \na typeloophole[21],so line4is illegalinJava. Line4islegalinOIGJ, becauseOIGJ safely allows covariant \nchanges in the immutability parameter (but notin theowner parameter).OIGJ restricts Java by having additional \ntyping rules,whileatthe sametimeOIGJalso relaxes Java s subtyping relation. Therefore, neither OIGJ nor \nJava subsumes the other, i.e., a legal OIGJ program may beillegalinJava(andviceversa).However, because \ngenerics areerased duringcompilation,the resulting bytecode canbe executed on anyJVM. The immutability \nof sameD (line 5) depends on the immutability of this, i.e., sameD is (im)mutable in an (im)mutable Foo \nobject. Similarly, the owner of sameD is the same as the owner of this. Ownership example Lines 5 7 show \nthree different owner parameters: O,This,andWorld.Theowner parameterisinvari\u00ad ant, i.e., the subtype \nrelation preserves the owner parameter. For instance, the types onlines 5 7have no subtype relation with \neachother becausetheyhavedifferentowner parameters. Reference ownedD cannotleak outside of this, whereas \nreferences sameD and publicD can potentially be accessed by anyone with accessto this. Although sameD \nand publicD can  be accessedbythe same objects,theycannotbe storedinthe same places: publicD can be \nstored anywhere on the heap (even in a static public variable) whereas sameD can only be stored inside \nits owner. We useO(...) to denote the functionthat takesa type ora reference,andreturnsitsowner parameter;e.g., \nO(ownedD)= This. Similarly,function I(...) returns the immutability pa\u00adrameter; e.g., I(ownedD)= I.We \nsay that an object o is this\u00adowned (i.e., owned by this)ifO(o)= This;e.g.,ownedD is this-owned,but sameD \nis not.OIGJprevents leaking this\u00adownedobjectsby requiring that this-owned.elds(and meth\u00adods with this-owned \narguments or return-type) can only be used via this. For example, this.ownedD is legal, but foo.ownedD \nis illegal. Owner vs. owner-parameter Now we explain the connec\u00ad tion between the owner parameter O(o), \nwhichisageneric type parameter at compiletime, and the owner .(o), which is an object at run time. This \nis an owner parameter that rep\u00adresents an owner that is the current this object, and World representsthe \nrootoftheownershiptree(wetreat World both as a type parameter and as an object that is the root of the \nownership tree).Formally,if O(o)= This then .(o)= this, if O(o)= O then .(o)= .(this), andif O(o)= World \nthen .(o)= World.Two references (in the same class) with the same owner parameter (at compile time) will \npoint to ob\u00ad jectswiththe sameowner(atruntime),i.e., O(o1)= O(o2) implies .(o1)= .(o2). Finally, recall \nthe Ownership guarantee: o ' can point to o iff o 'j..(o). By de.nition of j., we have that for all o:(i) \no j. o, (ii) o j..(o), and (iii) o j. World. By part (iii), if .(o)= World then anyone can point to o. \nOn lines 5 7, we see that this can point to ownedD, sameD, publicD, whose owner parameters are This, \nO, World, and whose owners are this, .(this), World. This conforms with theownership guarantee accordingtoparts(i),(ii),and(iii), \nrespectively. More complicated pointing patterns can occur byusingmultipleownerparameters, e.g.,anentryinalist \ncanpointtoanelementownedbythe list sowner, such asin List<This,I,Date<O,I>>. Thereisasimilar connection \nbetweentheimmutability typeparameter(at compile time)andthe object simmutabil\u00ad ity(at run time). Immutabilityparameter \nMutable or Immut implies the object is mutable or immutable (respectively), ReadOnly implies the referenced \nobject may be either mu\u00adtable or immutable and thus the object cannot be mutated through the read-only \nreference. Raw impliesthe objectis still rawandthuscanstillbemutated,butitmight become immutable after \nit is cooked. Method guard example Lines8and9showareadonly and a mutating method. These methods are guarded \nwith <...>?. Conditional Java(cJ)[20]extends Java with such guards (a.k.a. conditionaltypeexpressions).Note \nthatcJchanged Java s syntaxby usingthe question markin the guard <...>?. TheexpositioninthispaperusescJfor \nconvenience.How\u00adever, our implementation of OIGJ(Sec. 4) uses type anno\u00ad tations[15]without changingJava \nssyntax, forconciseness and compatibility with existing tools and code bases. A guard such as <T extends \nU>? METHOD DECLARATION has a dual purpose: (i) the method is included only if T extends U, and(ii) the \nbound of T is U inside the method. In our example, the guard on line 9 means that (i) this method can \nonly be called on a Mutable receiver, and (ii) inside the method the bound of I changes to Mutable. For \ninstance, (i) only a mutable Foo object can be a re\u00adceiver of mutatingMethod, and (ii) .eld sameD is \nmutable in mutatingMethod.cJalsoensuresthatthe conditionofan overridingmethodis equivalent or weakerthan \nthecondition of the overridden method. IGJ[40]used declaration annotations to denotetheim\u00ad mutability \nof this.Inthispaper,OIGJ usescJtoreducethe numberoftypingrulesand handleinnerclassesmore.ex\u00adibly.1 OIGJdoes \nnot use the full power of cJ: it only uses guardswithimmutabilityparameters. Moreover, wemodi.ed cJtotreat \nguardsover constructorsina specialway described in the Object creation rule of Fig. 4. To summarize, \non lines 8 10 we see three guards that change the bound of I to ReadOnly, Mutable, and Raw, respec\u00adtively.Becausethe \nboundof I is already declared online1 as ReadOnly, the guard on line8canbe removed. Constructor example \nThe constructoronline10isguarded with Raw, and therefore can create both mutable and im\u00admutableobjects, \nbecauseallobjectsstarttheirlifecycleas raw. Thisconstructorillustratestheinterplay between owner\u00ad ship \nand immutability, which makes OIGJ more expressive than previous work on immutability. OIGJ uses ownership \ninformation to prolong the cooking phase for owned objects: the cooking phase of this-owned.elds(ownedD)islonger \nthanthatof non-owned.elds(sameD).Thispropertyiscritical to type-check the collection classes, as Sec. \n2.2 will show. Consider the following code: class Bar<O extends World,I extends ReadOnly> { Date<O,Immut> \nd = new Date<O,Immut>(); Foo<O,Immut> foo = new Foo<O,Immut>(d); } Recall our Immutability guarantee: \nan immutable object cannot bechanged after itis cooked.A This-ownedobject is cooked whenitsowneris cooked(e.g., \nfoo.ownedD). Any other object is cooked whenits constructor .nishes(e.g., d and foo). The intuitionis \nthat ownedD cannot leak and so the outside world cannot observe this longer cooking phase, whereas d \nis visible to the world after its constructor .nishes andmust notbe mutatedfurther. The constructor onlines \n10 15 shows this difference betweenthe assignments to sameD (line 11) and to ownedD (line 12): sameD \ncancomefrom the outside world, whereas ownedD mustbe createdinside this. 1Our implementation uses type \nannotations to denote immutability of this. Atypeannotation@Mutable onthe receiverissimilartoacJ <I extends \nMutable>? construct,butitseparates the distinct rolesof thereceiver and the result in inner class constructors. \n Thus, sameD cannot befurthermutated(line 13)whereas ownedD can be mutated (line 14) until its owner \nis cooked. Anobjectinarawmethod,whoseimmutabilityparameter is I, is still considered raw (thus the modi.ed \nbody can still assign to its .elds or call other raw methods) iff the objectis this or this-owned. Informally, \nwe say that Raw is transitive only for this or this-owned objects.Forexample, the receiver of the method \ncall sameD.setTime(...) is not this nor this-owned, andtherefore the call online 13is illegal; however, \nthe receiver of ownedD.setTime(...) is this-owned, and therefore the call on line 14 is legal.  2.2 \nLinkedList example Fig.3shows an implementationof LinkedList in OIGJ that is similar in spirit to Sun \ns implementation. We explain thisexamplein threestages:(i)we .rstexplainthe data\u00adstructure,i.e.,the .eldsofalistanditsentries(lines1 \n6), (ii)then we discuss the Raw constructors that enable creation of immutable lists (lines 7 24), and(iii) \n.nally wedive into the complexities of inner classes and iterators (lines 27 53). LinkedList data-structure \nAlinked list has a header .eld (line6) pointingtothe .rst entry.Eachentryhasan element and pointers tothe \nnext and prev entries(line 3).We explain .rst the immutability and then the ownership of each .eld. Recall \nthatweimplicitly assumethat O extends World and that *I extends ReadOnly on lines 1, 5, 35 and 49. An(im)mutablelist \ncontains(im)mutableentries,i.e.,the entire data-structure is either mutable or immutable as a whole.Hence,allthe \n.eldshavethe sameimmutability I.The underlying generictypesystempropagatestheimmutability information \nwithout the need for special typing rules. Next consider the ownership of the .elds of LinkedList and \nEntry. This online6 expressesthat the reference header points to an Entry owned by this,i.e., the entry \nis encap\u00adsulated and cannot be aliased outside of this. O online3 expresses that the owner of next is \nthe same as the owner ofthe entry,i.e.,alinked-listowns all its entries. Note how the generics mechanism \npropagates the owner parameter, e.g., thetypeof this.header.next.next is Entry<This,I,E>. Thus, the owner \nof all entries is the this object, i.e., the list. Finally, note that the .eld element has no immutability \nnorowner parameters, because theywillbe speci.edbythe client that instantiates the list type, e.g., LinkedList<This,Mutable,Date<World,ReadOnly>> \nImmutable object creation Aconstructorthatismaking an immutable object must be able to setthe .elds of \nthe object. It is not acceptable to mark such constructors as Mutable, whichwould permitarbitrarysideeffects, \npossiblyincluding making mutable aliases to this. OIGJ usesafourth kindof immutability, Raw,topermitconstructorsto \nperformlimited sideeffectswithout permittingmodi.cationofimmutable objects. Raw represents a partially-initialized \nraw objectthat can still be arbitrarily mutated,but after it is cooked(fully initialized), then the object \nmight become immutable. The 1: class Entry<O,I,E> { 2: E element; 3: Entry<O,I,E> next, prev; 4: } 5: \nclass LinkedList<O,I,E> { 6: Entry<This,I,E> header; 7: <I extends Raw>? LinkedList() { 8: this.header \n= new Entry<This,I,E>(); 9: header.next = header.prev = header; 10: } 11: <I extends Raw>? LinkedList( \n12: Collection<?,ReadOnly,E> c) { 13: this(); this.addAll(c); 14: } 15: <I extends Raw>? void addAll( \n16: Collection<?,ReadOnly,E> c) { 17: Entry<This,I,E> succ = this.header, 18: pred = succ.prev; 19: for(Ee: \nc){ 20: Entry<This,I,E> en=new Entry<This,I,E>(); 21: en.element=e; en.next=succ; en.prev=pred; 22: pred.next \n= en; pred = en; } 23: succ.prev = pred; 24: } 25: int size() {...} 26: // iterator isageneric method; \nthisis notacJ guard: 27: <ItrI extends ReadOnly> Iterator<O,ItrI,I,E> 28: iterator() { 29: return this.new \nListItr<ItrI>(); 30: } 31: void remove(Entry<This,Mutable,E> e) { 32: e.prev.next = e.next; 33: e.next.prev \n= e.prev; 34: } 35: class ListItr<ItrI> implements 36: Iterator<O,ItrI,I,E> { 37: Entry<This,I,E> current; \n38: <ItrI extends Raw>? ListItr() { 39: this.current = LinkedList.this.header; 40: } 41: <ItrI extends \nMutable>? E next() { 42: this.current = this.current.next; 43: return this.current.element; 44: } 45: \n<I extends Mutable>? void remove() { 46: LinkedList.this.remove(this.current); 47: } 48: }} 49: interface \nIterator<O,ItrI,CollectionI,E> { 50: boolean hasNext(); 51: <ItrI extends Mutable>? E next(); 52: <CollectionI \nextends Mutable>? void remove(); 53: } Figure 3. LinkedList<O,I,E> in OIGJ.  constructors on lines 7 \nand 11 are guarded with Raw, and therefore can create both mutable and immutable lists. Objects must \nnot be captured in their raw state to prevent further mutation after the object is cooked. If a programmer \ncoulddeclare a .eld, such as Date<O,Raw>, then a raw date couldbestoredthere,andlaterit couldbeusedtomutatea \ncooked immutable date. Therefore, a programmer can write the Raw type only after the extends keyword,butnot \nin any other way. As a consequence, in a Raw constructor, this can only escape as ReadOnly. Recall that \nan object becomes cooked either when its constructor .nishes or when its owner is cooked. The entries \nof the list (line 6) are this-owned. Indeed, the entries are mutatedaftertheir constructor .nished,but \nbefore thelist is cooked,onlines9,22,and23. Thisshowsthepowerof combining immutability and ownership: \nwe are able to create immutablelists only by usingthefactthat the list ownsits entries.Ifthose entrieswere \nnot ownedby the list, then this mutation of entries might be visible to the outside world, thusbreakingthe \nguarantee thatanimmutable object never changes.By enforcingownership,OIGJ ensures that such illegal mutations \ncannot occur. OIGJ requires that all access and assignment to a this\u00adowned.eld mustbe done via this.For \nexample, see header, on lines 8, 9, 17, and 39. In contrast, .elds next and prev (which are not this-owned) \ndo not have such a restriction, as can be seen on lines 32 33. Iterator implementation and inner classes \nAn iterator has an underlying collection, and the immutabilityof thesetwo objectsmightbedifferent.Forexample,you \ncanhave a mutable iterator over a mutable collection (the iterator supports both remove() and next()), \na mutable iterator over a readonly/immutable collection (the iterator supports next() but notremove()), \nor areadonlyiteratoroveramutable collection(theiterator supports remove() but not next(), which can be \nuseful if youwantto pass aniteratortoa method thatmay not advance the iteratorbut may remove the current \nelement). Consider the Iterator<O,ItrI,CollectionI,E> interface de.ned on lines 49 53, and used onlines27 \nand 36. ItrI is the iterator s immutability, whereas CollectionI is intended tobe the underlying collection \nsimmutability(see online36 howthe collection simmutability I is used in the place of CollectionI).Line51requiresa \nmutableItrI to call next(), and line 52 requires a mutable CollectionI to call remove(). Inner class \nListItr (lines 35 48)istheimplementationof Iterator for list. Its full name is LinkedList<O,I,E>.List\u00adItr<ItrI>, \nand online35itextends Iterator<O,ItrI,I,E>. It reuses the owner parameter O from LinkedList, but de\u00adclares \na new immutabilityparameter ItrI. An inner class, such as ListItr<ItrI>, only declares an immutability \nparam\u00adeterbecauseit inheritstheownerparameterfromits outer class. ListItr and LinkedList have the same \nowner O,but different immutability parameters(ItrI for ListItr, and I for LinkedList). ListItr must inherit \nLinkedList s owner because it directly accesses the(this-owned) representation of LinkedList (line39),whichwouldbeillegaliftheirowner \nwasdifferent.Forexample, considerthe typesof this and LinkedList.this on line 39: Iterator<O,ItrI,...> \nthisIterator = this; LinkedList<O,I,...> thisList = LinkedList.this; Becauseline 38 setsthe bound of \nItrI to be Raw, this can be mutated. By contrast, the bound of I is ReadOnly, so LinkedList.this cannot. \nAn innerclassmusthaveadistinctimmutabilityparameter, but it must reuse the owner parameter of its outer \nclass. We couldhave severalThis types, e.g., LinkedList.This vs. ListItr.This,but this would complicate \nthe typing rules. Finally, consider the creation of a new inner object on line 29 using this.new ListItr<ItrI>(). \nThis expression is type-checked both as a method call (whose receiver is this) and asa constructor call. \nObserve thatthe boundof ItrI is ReadOnly (line 27) and the guard on the constructoris Raw (line 38), \nwhichislegalbecausea Raw constructor can create both mutable and immutable objects.  2.3 OIGJ typing \nrules Fig.4 containsall the OIGJ typingrules.We now discuss each rule. Sec. 3 presents a formal type \nsystem based on a simpli.ed version of these rules. Some of the rules are identicaltothosefoundinOGJ[33]and \nIGJ[40](see Sec.5 for a comparison with OIGJ). Ownership nesting Consider thefollowingexample: List<This,I,Date<World,I>> \nl1; // Legal nesting List<World,I,Date<This,I>> l2; // Illegal! De.nition of l2 hasillegalownership nesting \nbecauseowned dates might leak, e.g., we can store l2 in this variable: public static Object<World,ReadOnly> \npublicAliasToL2; Onthe one hand, typesin OIGJ mayhavemultipleowner parameters, e.g., the type of l1 has \ntwo owner parameters (This and World).Ontheother hand,an objectmayonlyhave a singleowneratruntime.Forexample,thetypeof \nl1 will correspondatrun timetoalistthatisownedby this while its elements are owned by World, and observe \nthat this is always inside World. Recall that an owner o1 is inside o2 iff o1 is a descendant in the \nownership tree of o2,i.e., o1 j. o2.We extend this de.nitionfromownerstoowner parametersasfollows:given \ntwo owner parameters O1 and O2 in the same type,then O1 is inside O2 iffinanypossibleexecution, theseowner \nparameters correspondto someowners o1 and o2 (respectively) where o1 j. o2. For example, This is inside \nO, and any owner parameter is inside World. OIGJ requires that owner parameters are properly nested, \ni.e.,thatthe .rstowner parameteroftype T is inside anyother owner parameter in T.To enforce this rule,OIGJ \nmaintains  Ownership nesting The .rstowner parameteroftype T must be inside any other owner parameter \nin T. Field access Field access o.f is legal iff O(f)= This . o = this. Field assignment Fieldassignment \no.f=... is legaliff(i) I(o) = Raw, and se (ii) I(o)= Raw . (o = this or O(o)= This) , and (iii) .eld \naccess o.f is legal. Method invocation Consider method T0 m(T1,...,Tn). The invoca\u00adtion o.m(...) is legal \niff (i) O(Ti)= This . o = this for i= 0,..., n, and (ii) I(m)= Raw implies .eld assignment part (ii). \ncJ s method guard (i) An invocation o.m(...) is legal if the type of o satis.es the guardof m. (ii) When \ntyping method m, the bound of type variables that appear in the guardchanges to their bound in the guard. \n(iii) The guardof an overriding method is equivalent or weaker than that of the overridden method. Inner \nclasses An inner class reuses the owner parameter of the outer class. However, it has a distinct immutability \nparameter. Invariant The programmer marks each type parameter as invariant or covariant. An immutability \nparameter is always covariant, whereas an owner parameter is always invariant. A type parameter must \nbe invariant if it is used in a superclass that contains Mutable, a .eld thatcontains Mutable but is \nnotthis-owned, or in the position of another invariant type parameter. Same-class subtype relation Let \nC<X1,...,Xn> be a class. Type S = C<S1,..., Sn> is a subtype of T = C<T1,...,Tn>, written as S = T,iff(S \n= T) I or (allimmutabilityparameters T j are either ReadOnly or Immut), and se for i= 1,..., n, Si = \nTi or(Si = Ti and Xi is covariant in C). ' Erased signature If method m overrides a readonly/immutable \nmethod m, thentheerased signaturesof m ' and m,excluding invarianttype parameters, must be identical. \n(The erased signature of a method is obtained by replacing type parameters with their bounds.) Object \ncreation A constructor cannot have any this-owned arguments. Furthermore, new SomeClass<X,...>(...) is \nlegal iff the constructor s guard <I extends Y>? satis.es: Y = Mutable and X = Mutable, or Y = Raw. Generic \nWildcards OIGJ prohibits using a generic wildcard(?)in the positionof theimmutability parameter.For theowner \nparameter,OIGJ prohibitsusingawildcardina.eldorinamethodreturntype,butpermits it for stack variables \nand method parameters. Raw parameter Raw can onlybe used after the extends keyword. It cannot be used \nin the position of a generic parameter. Fresh owners Afresh owner is a method owner parameter that is \nnot used inthemethod signature.Itisadescendantintheownershiptreeofall other owners in scope. Static \ncontext This cannot be used in a static context (static methods or .elds). Figure 4. All the OIGJ typing \nrules (beyond those of Java), in English. Alsosee Sec.3fora formalization.Underlined sentences show similarities \namong the rules. ordering constraints among owner parameters in the same way as described in OGJ [33]. \nField access This rule enforces ownership: this-owned .elds can be assigned only via this. In Fig. 3, \nnote that all accesses and assignments to header are done via this. Field assignment Assigningtoa.eldshould \nrespect both immutabilityandownership constraints.Part(i)oftherule enforces immutability constraints: \na .eld can be assigned only by a Mutable or Raw reference.Part(ii) ensures Raw is transitive onlyfor \nthis or this-ownedobjects.Part(iii) enforces ownership constraints as in .eld access. Forexample, consider \nthe assignments onlines8and9of Fig. 3. Note that the bound of I is Raw, thus the assignments satisfy \npart(i).Part(ii) holds,i.e., Raw is transitivein the .rst assignment because thetarget objectis this \nand inthe second assignment because it is this-owned(thetype of this.header is Entry<This,I,E>).Finally, \npart(iii) holdsin the .rst assignment because header was assignedvia this, and in the second assignment \nbecause .eld next (Entry<O,I>) is not this-owned. Method invocation Method invocation is handled in the \nsameway as .eld access/assignment: parts(i)and (ii) are similar to .eld access and .eld assignment part(ii).For \nexample,consider the following method: Rm(Aa) { ...} Then, the method call o.m(e) is handled as if there \nis an assignmenttoa .eldoftype A,andthe returnvalueistypedas iftherewasanaccesstoa .eldoftype R. Note \nthat regarding thetransitivity of Raw,we checkboththeimmutabilityofthe receiver object(I(o))and that \nofthe method,i.e.,its guard (I(m)). If both are Raw, then we require that o is either this or this-owned. \nInner classes An inner class is a non-static nested class, e.g., iterators in java.util are implemented \nusing inner classes.Aninner class reusestheowner parameterofthe outer class, i.e., the inner object is \nseen as an extension ofthe outerobject.However,ithasadistinctimmutability parameter. Therefore, both \nthis and OuterClass.this are treatedidenticallybythe typing rules thatinvolveownership. Nested classesthat \nare static can be treated the same as normal classes. Invariant Auser canannotateatype parameter X in \nclass C with @InVariant to prevent covariant changes, in which case we say that X isinvariant.Otherwise \nwe say that X is covariant. An immutability parameter must be covariant, or else a mutable reference \ncould not be a receiver when calling a readonly method. An owner parameter must be invariant, because \nthe owner of an object cannot change. A type parameter must be invariant if it is used in a .eld/superclass \nthat contains Mutable, orif the erased sig\u00adnature differs. For example, if a class has a .eld of type \nFoo<O,Mutable,X>, then X must be invariant (the owner pa\u00adrameter O is always invariant). Subtype relation \nJava is invariant in generic arguments, i.e.,itprohibits covariant (or contravariant)changes. Vector< \nInteger> is not a subtype of Vector<Object>. If it were, then mutatinga Vector<Integer> byinserting, \ne.g.,a String, breaks type-safety. OIGJ permits covariantchangesfor non-mutable refer\u00adences because the \nobject cannotbemutatedinaway that is not type-safe. OIGJ s subtyping rules includes Java s subtyping \nrules, therefore OIGJ s subtype relation is a superset of Java s subtype relation. If mutation is disal\u00adlowed, \nOIGJ s subtypingrule allows covariantchangesin other type parameters, within the same class.For example, \n List<O,ReadOnly,Integer> isasubtypeof List<O,ReadOnly, Number>. Notethat covarianceis allowediff all \nimmutability parameters of the supertype are ReadOnly or Immut, e.g., Iterator<O,ReadOnly,Mutable,Integer> \nis not a subtype of Iterator<O,ReadOnly,Mutable,Number>,butitisa subtype of Iterator<O,ReadOnly,ReadOnly,Number>. \nErased signature Whenthe erasedsignatureof anoverrid\u00ad ing method differs from the overridden method, \nthe normal javac compilerinserts a bridge method to cast the arguments to thecorrect type[7].Suchbridge \nmethodswork correctly only underthe assumptions that subtypingis invariant.For example, consider an integer \ncomparator intComp thatimple\u00adments Comparable<Integer>. If Comparable<Integer> werea subtype of Comparable<Object>,then \nwe couldpassaString to intComp s implementation of compareTo(Integer): ((Comparable<Object>)intComp).compareTo(\"a\") \nOIGJ requires that the erased signature of an overriding method remains the same(excludinginvariant parameters)if \ntheoverriddenmethodiseither readonlyorimmutable.For example,theerased signatureofcompareTo in intComp \ndiffers from the one in the interface Comparable<O,I,X>.Therefore, this rule requires that the type parameter \nX must be invariant: interface Comparable<O,I, @InVariant X> { int compareTo(X o); } Object creation \nA constructor should not have any this\u00adowned parameters, because this-owned objects can only be created \ninside this. Recall thattheimmutabilityofa constructor (or any method in general) is de.ned to be the \nbound of the im\u00admutabilityparameter in that constructor, e.g., a mutable con\u00adstructor has the guard <I \nextends Mutable>?. Recall that cJ prohibits calling a Raw constructorto create an Immut object because \nthe guard is not satis.ed: Immut is not a subtype of Raw.OIGJchanged cJ and treats constructor calls \nusing this object creation rule: a Raw constructor can create any object(mutable and immutable).A Mutable \nconstructor can only create Mutable objects.Aconstructor cannotbe Immut or ReadOnly, so that it is able \nto assign to the .elds of this. Generic wildcards OIGJ usesJava sexistinggeneric wild\u00ad card syntax(?)to \nexpress existential owners[8, 30, 38]. One can use existential owners when the exact owner of an ob\u00adjectis \nunknown.Amotivationforexistentialownersisthe downcast performed in the equals method [38]. ConsiderthefollowingtwocastsinnormalJava: \nboolean equals(Object o) { List<?> l = (List<?>)o; // OK List<Object> l = (List<Object>)o; } // Warning! \nThe second castis a warning since erasure makes it impossi\u00adble to checkat run time that the generic parameter \nis Object. OIGJprohibitswildcardsontheowner parameterof .elds, e.g., Date<?,ReadOnly> field, because \none can declare a static .eld of that type and store a this-owned date, thus breakingowner-as-dominator.Wildcards \nonamethodreturn type are also prohibited becausethey canbe usedtoleak this-owned .elds.However, wildcards \non stackvariables (method parameters or local variables) are allowed. Note that the immutability parameter \nis covariant, and therefore thereisnoneedto usea wildcardforimmutability. Forexample, considertheDateList \nclass,whichis param\u00adeterizedbyitsowner parameter(O)and the dates owner parameter(DO): class DateList<O,I,DO \nextends World> { boolean equals(Object<?,ReadOnly> o) { DateList<?,ReadOnly,?> l = // No need to check \nownership or immutability at run time. (DateList<?,ReadOnly,?>) o; return listEquals(l); } <O2 extends \nWorld,DO2 extends World> boolean listEquals(DateList<O2,ReadOnly,DO2> l) {...} } Method listEquals showsthatitispossibleto \nnametheexis\u00adtential owner the unknown list s owner parameter is O2 and the unknown dates owner parameter \nis DO2. Phrased differ\u00adently,thetwo wildcards in DateList<?,ReadOnly,?> are now named DateList<O2,ReadOnly,DO2>.Althoughwildcards \ncan sometimes be replaced by generic methods, wildcards are necessary in downcasts (as shown in method \nequals). Recall that Java s generics can be bypassed by using re.ection orrawtypes such as List. Similarly,one \ncan bypass OIGJ when using these features. Raw parameter Raw can only be used after the extends keyword.Forexample,itis \nprohibitedto writeDate<O,Raw>. Ifthiswas possible,thensucha date couldleakfroma Raw constructor thatisbuilding \nanimmutable objectresultingin an alias that could mutate such immutable object. Freshowner Afresh owner \nis a method owner parameter thatis not usedin themethodsignature.InOIGJ,afresh owner expresses temporary \nownership within the method. Thisallowsamethodto createstack-localobjectswithaccess toanyobjectvisibleatthepointofcreation,butwithaguaran\u00ad \ntee that stack-locals will not leak. Hence, stack-localobjects canbegarbage-collected whenthe method \nreturns.Forexam\u00ad ple, consider a method that deserializes a ByteStream by cre\u00adatingatemporary ObjectStream \nwrapper: <O,TmpO> void deserialize(ByteStream<O> bs) { ObjectStream<TmpO,ByteStream<O>> os = ... } Note \nthat TmpO is afresh owner, whereas O is not. Because TmpO isstrictlyinside otherowner parameterssuchas \nO, there cannot be any aliases from bs to os. In fact, os can only be referencedfrom other stack-local \nobjects, andtherefore, when the method returns, os can begarbage-collected. Technically,a fresh owner \nis strictly inside all other non\u00ad fresh owners in scope,to make sureitcannotexistafterthe method returns. \n(Multiple fresh owners are incomparable with each other.) Because a fresh owner is inside several otherowners \nthat mightbe incomparablein theownership  tree, theownership structureisaDAGrather thana tree. To type-checktemporaryownership \nandDAGownership structures, OIGJ adopts Wrigstad s scoped con.nement [37] ownership model,in which the \nfreshowners areownedbythe current stack-entry. Brie.y stated, each method invocation pushesanewstack-entry(the.rst \nstack-entry correspondsto the static main method),whichis the rootofa newownership tree.Objectsinthisnewtreemay \npointtoobjectsinprevious trees,but not viceversa. Static context This representsthatan objectisownedby \nthis, and so OIGJ prohibits using it in a static context, such as static .elds or methods. Static .elds \ncan use the owner parameter World, and static methods can also use generic method parameters extending \nWorld.For example, method: static <LO extends World,E> void sort( List<LO,Mutable,E> l) { ... } is parameterized \nby the list s owner LO.  2.4 Factory method design pattern The factory method pattern [17]isa creational \ndesign pattern for creating objects without specifying the exact class of the object that will be created.The \nsolutionis to de.ne an interface with a method for creating an object. Implementers can override the \nmethod to create objects of a derived type. The challengeof thefactory method pattern with respect to \nownership [26]is thatthe pointofcreation and usage are in different classes, and the created object must \nbe owned byits user. Previousworkmakesa newly-createdobjectbe ownedbyits creator, and then changes theownershipafter \nthefactviasophisticatedownership transfermechanisms[25] using capture and release. InOIGJ s approach, \nan object hasits .nalowner from its moment of creation. When requesting creation of a new object, the \nclient of the factory also speci.es the owner. The type-checker ensures that the created object cannot \nbe captured (stored in a location that wouldrequire a different owner)in theprocess.Speci.cally, a generic \nfactory method can abstract over the owner (and immutability) parameter of the constructedobject.The \nunderlyinggenerics mechanism .nds the correct generic method arguments. Wewillshowhowto usethefactorymethodpatterninthe \ncontext of synchronized lists. Consider this client code: b = new LinkedList<T>(); l = Collections.synchronizedList(b); \nThe documentation of Collections.synchronizedList states: In order to guarantee serial access, it is \ncritical that all ac\u00ad cess to the backing list is accomplished through the returned list. That means \nthatthere might be concurrencyproblems if one accidentally uses the backing list b instead of l. So, \nyou want to own a list l, whichis backedby another list b.The challengeisthat b should be owned by l \n(and not 1: class SafeSyncList<O,I,E> implements List<O,I,E> { 2: List<This,I,E> l; 3: <I extends Raw>? \nSafeSyncList( 4: Factory<?,ReadOnly,E> f) 5: { List<This,I,E> b = f.create(); 6: l = Collections.synchronizedList(b); \n} 7: ... // delegate methods to l 8: } 9: class Collections<O,I> { 10: //Sun soriginal implementation,augmented \nonlyby O2 and I2 11: static <O2,I2,E> List<O2,I2,E> 12: synchronizedList(List<O2,I2,E> list) { ... } \n13: } 14: interface Factory<O,I,E> 15: { <O2,I2> List<O2,I2,E> create(); } 16: class LinkedListFactory<O,I,E> \nimplements 17: Factory<O,I,E> { 18: <O2,I2> List<O2,I2,E> create() { 19: return new LinkedList<O2,I2,E>(); \n20: }} Figure 5. Factory method design pattern in OIGJ. OIGJ guaranteesthat the backinglist b (line 5) \nis never accessed directly, e.g., it cannot be captured on line 19. by you),in order to guarantee that \nyou do not accidentally access b directly and comprise thread-safety. Fig.5showshowowner-as-dominator \ncan ensure thatthe backing list b has no outside aliases. This solution avoids refactoringofexistingJava \ncodeby delegating callstothe synchronized list l. Speci.cally, class SafeSyncList (lines 1 8) owns both \nthe list l (line2) and the backing list b (line 5). Afactory method is used on lines 3 6. The Factory \ninterface is de.ned on lines 14 15. The owner and immutabilityof the Factory is irrelevant because it \nonly has a readonlymethod. However, the newlycreated list has a generic owner and immutability, which \nare stati\u00adcally unknownatthecreationpoint(line15).Thegenerics mechanism .llsin the correct generic argumentsfromthe \nusagepoint(line6)tothe actualcreationpoint(line19).Note thatthefactoryimplementationcannot captureanaliastothe \nnewly createdlistonline19,becauseitsownerparameter O2 is a generic method parameter that cannot be used \nin .elds. To conclude, one can useSafeSyncList instead of using Sun s unsafe synchronizedList, and be \ncertain no one else can access the backing list. All this was achieved using generic factory methodson \nlines 15 and 18.  2.5 Visitor pattern The visitor design pattern [17]is a way of separating an algorithm \nfrom a node hierarchy upon which it operates. Insteadofdistributingthe nodeprocessingcodeamongall the \nnodeimplementations,the algorithmiswrittenina single visitor class that hasavisitmethod forevery nodein \nthe hierarchy. This is desirable when the algorithm changes  1: interface Visitor<O,I,NodeO,NodeI> { \n2: <I extends Mutable>? void 3: visit(Node<NodeO,NodeI> n); 4: } 5: class Node<O,I> { 6: void accept(Visitor<?,Mutable,O,I> \nv) 7: { v.visit(this) } 8: } 9: // Visiting a readonly node hierarchy. 10: Node<This,ReadOnly> readonlyNode \n= ...; 11: readonlyNode.accept( new 12: Visitor<World,Mutable,This,ReadOnly>() { 13: <I extends Mutable>? \nvoid 14: visit(Node<This,ReadOnly> n) 15: { ... // Can mutate the visitor,but not the nodes. } 16: }); \n17: // Visiting a mutable node hierarchy. 18: Node<This,Mutable> mutableNode = ...; 19: mutableNode.accept( \nnew 20: Visitor<World,Mutable,This,Mutable>() { 21: <I extends Mutable>? void 22: visit(Node<This,Mutable> \nn) 23: { ... // Can mutate the visitor and the nodes. } 24: }); Figure 6. Visitor patternin OIGJ.TheNode \ns ownership and immutability are underlined. We omit the extends clause for generic parameters, e.g., \nwe assumethat NodeO extends World.Asingle visitor interface can be used bothfor Mutable and ReadOnly \nnodes. frequently or when new algorithms are frequently created. The standard implementation(that does \nnot use re.ection) de.nes a tiny accept method that is overridden in all the nodes, that calls the appropriate \nvisit method for that node. N\u00a8 ageli[26]discusses ownership in design patterns, and showsthat previous \nownership work was not .exible enough toexpress thevisitor pattern.A visitorisalwaysmutable becauseitmay \naccumulate information during thetraversal of the nodeshierarchy.However,some visitors only need readonly \naccessto the nodes, and some needtomodifythe nodes.In the former case,theownerofthe visitor and nodes \nmaybedifferent, andinthe latter case,itmustbe the same owner. The challengeis to usethesame visit and \naccept methods, and to avoid duplicating the traversal code. OIGJ canexpress the visitor patternby relying \nonowner\u00ad polymorphic methods: the owner of an object o, can passit to an owner-polymorphic method, which \ncannot capture o. Fig.6shows the visitorpatterninOIGJ.Asmentioned before, the owner of the visitor and \nnodes may be differ\u00adent, and some visitors may or may not modify the nodes. Therefore, the visitoris \nparameterized online1by theowner (NodeO)andimmutability(NodeI)of the nodes. Thevisit methodonline2ismutablebecauseit \nchangesthevisitor that accumulates information duringthetraversal. Different visitor implementations \nmay have different immutability for the nodes, e.g., readonly on line 14 or mutable on line 22. Finally, \nnote how the type arguments This,ReadOnly of the nodeonline10matchthelasttwoargumentsofthevisitor on \nline12,andon line18thetypearguments This,Mutable match those on line 20. This shows that the same accept \nmethod(without duplicating the nodes hierarchytraversal code)can be used bothfor readonly and mutable \nhierarchies. 3. Formalization and Type Soundness Proving soundness is essentialin theface of complexities \nsuch as wildcards and raw/cooked objects. This section gives the typing rules and operational semantics \nof a simpli.ed version of OIGJ and sketches the proofs of our immutability andownershipguarantees.Forlackofspace,the \nfullproofs are included in our technical report [39]. Our type system,calledFeatherweightOIGJ (FOIGJ),is \nbased on FeatherweightJava(FJ)[21]. FOIGJmodels the essenceof OIGJ: thefactthat every objecthas anownership \nand immutability, and the cooking phase when creating immutable objects. FOIGJ adds imperative constructs \nto FJ, such as null values, .eldassignment, locations/objects, and a heap. FOIGJ also adds a constructor \nbody (to model the cooking phase),ownerandimmutabilityparametersto classes, guards as in cJ[20], wildcard \nowners, and the run\u00adtime notion of raw/cooked objects. FOIGJposestwomain challenges:(i)modeling wildcards \nin the typing rules, and (ii) the representation for raw ob\u00adjects.We use the followingexample(similarto \nFig.2)to demonstrate these two challenges: class Foo<O,I> { Date<O,I> sameD; Date<This,I> ownedD; Date<This,Immut> \nimmutD; <I extends Raw>? void Foo(){ this.ownedD = new Date<This,I>(); this.immutD = new Date<This,Immut>(); \n... }} Wildcards pose a dif.culty due to a process in Java called wildcardcapture inwhicha wildcardis \nreplaced withafresh type variable. For example, the two underlined wildcards belowmightrepresenttwodistinctowners: \nFoo<?,I> f = ...; Date<?,I> d = ...; f.sameD = d; // Illegal assignment! Different owners! AJava compiler \nrejectsthe assignment duetoincompatible types, becausethe wildcards were capturedby different type variables.Formalizingthefullpowerofwildcards(with \nupper andlower bounds)was only recently achieved[9]. FOIGJ does not model wildcard capture.Instead,itisenoughto \naugment the .eldassignment rule with thefollowing check: assigning to o isillegal if O(o)= ? (similarly \nfor method invocation).Thisextra checkis neededonlyinFOIGJ, and notin OIGJ, becauseOIGJisbuilt ontopofJava,which \n supports wildcard capture. The second challenge is modeling raw objects in the non\u00ad erased operational \nsemantics. Recall that generics are erased inJavaandarenotpresentatruntime. FOIGJ s erased opera\u00adtional \nsemanticsis identicaltothatof normalJava:ownership and immutability information is not kept. In contrast, \nthe non-erased version stores with each object its owner and immutability, and it checks at run time \nthe ownershipand immutability guarantees (i.e., that .eld assignment respects owner-as-dominator and \nis done only on mutable or raw ob\u00ad jects). The non-erased version is used only in the formalism. Storing \nthe owner and immutability of every object at run timewouldbea hugeoverhead, andis not requiredfor cor\u00ad \nrectness if the program satis.es OIGJ s type rules. The non-erased semantics of Featherweight Generic \nJava[21](FGJ) performs variable substitution for method calls,however FGJ swayof doing substitution does \nnotwork in FOIGJ.Forexample, consider thefollowing reduction as done in imperative FGJ: new Foo<World,Immut>() \n. l.ownedD = new Date<l,Immut>(); l.immutD = new Date<l,Immut>(); ... The variable I in the constructor \nwas substituted with Immut, and the variables this and This were substituted with a new location l that \nwas created on the heap, i.e., the heap H now containsa new objectinlocation l whose .elds are all null: \nH= {l . Foo<World,Immut>(null)}.(Locations are pointers to objects; we treat locations and objects identically \nbecause they have a one-to-one mapping, e.g., the owner ofa locationis de.nedtobetheownerofits object.)Note \nhowowner parameters(O(o))at compiletimeare replaced with owners(.(o))at run time, e.g.,This was replacedwith \nlocation l. There aretwo reasonswhysubstituting I with Immut does not work in FOIGJ: (i) the reduction \ndoes not type-check becausewe mutate animmutable object(l.ownedD = ...), and (ii) we lost information \nabout the two new Date objects, namely that ownedD can stillbe mutatedafterits constructor .nishes (because \nit is this-owned) whereas immutD cannot. FOIGJsolvesthesetwo issuesby introducing an auxiliary type Immutl. \nAn object o of immutability I(o)= Immutl becomes cooked when the constructor of l .nishes, therefore \nwe call l its cooker, denotedby .(o)= l. Phrased differently, anobjectis cooked whenits cookeris constructed \n(i.e., the cooker sconstructor.nishes).Notethatthe cooker l can be o itself, its owner, or even some \nother incomparable object. The connection between the cooker and the owner will be showninthe subtypingandtypingrulesbelow.Intuitively,for \na reference of type C<o,Immutl>, if the cooker l is not inside theowner o,thenthatreferencemustpointtoanobject \nwhose cookeris l. Otherwise (if l isinside o), then that reference might pointtoanycookedimmutableobject(even \nonewitha cooker that is not l). In our example, the location l that was created with new Foo<World,Immut>() \nbecomes cooked when it is constructed, i.e., .(l)= l, and H = {l . Foo<World,Immutl>(null)}. Now FGJ \ns way of doing the substitution works for FOIGJ, because I is replaced with Immutl, i.e., l.ownedD = \nnew Date<l,Immutl>(); l.immutD = new Date<l,Immut>(); Note how the cooker of ownedD is l, whereas the \ncooker of immutD is immutD itself. Therefore, ownedD has a longer cooking phase than immutD. FOIGJalso \nmaintains the set of currently executing con\u00adstructors K, where K. dom (H).We maintaintheinvariant that \na location l is raw iff .(l) . K, and require that only mutable or raw objects can be mutated.Speci.cally, \nImmutl is a subtype of Raw when l . K, anditisa subtypeof Immut when l . K. TypeImmutl also helps understandthe \nObject creation rule better. Recallthat an Immut object canbecreatedfrom a Raw constructor, even though \nImmut is not a subtype of Raw, which seems to contradict cJ s method guard rule. However, type Immutl \nisinfact a subtypeof Raw when the objectis created, becausein our typing ruleswehave that Immutl = Raw \niff l . K,andwhen an objectis created,its cooker must be in K. Phrased differently, the type of an immutable \nobject never changes (always Immutl),but during the programexecutionthe set Kchanges, andthereforethe \nsubtyping relation changes:initially Immutl is a subtype of Raw,butlater the object becomes cooked, and \nthen Immutl is no longer a subtype of Raw,but instead it becomes a subtype of Immut. Faced with such \nmajor challenges, we removed from FOIGJ anything thatwas not neededto prove our run-time guarantees. \nSpeci.cally, FOIGJ does not model: generics (except fortheowner andimmutability parameters), owner polymorphic \nmethods,casting, innerclasses,freshowners, or multipleimmutability/owner parameters.On the one hand, \nthe interaction between generics and immutability (which enables covariant subtyping) was previously \nproven sound in FeatherweightIGJ (FIGJ)[40]. On the other hand, the interaction between generics and \nownership (as found in the ownershipnesting rule) was previouslyproven sound in Featherweight OGJ(FOGJ)[33].Becausecovariant \nsubtyp\u00ading(asfoundinIGJ)andownership nesting(asfoundinOGJ) was not changed in OIGJ, we decided not to \nmodel generics inFOIGJ.We notethatFOIGJ does model Raw, which was not modeled previously in FIGJ. Consider \nthe typing rulesin Fig.4.ClassesinFOIGJhave a single Raw constructor, therefore Object creation rule \nis always satis.ed and can be ignored.Furthermore, because FOIGJ does not modelgenerics, static, or inner \nclasses, then the following rules canalsobeignored: Ownership nesting, Inner classes, Inheritance, Invariant, \nErased signature, and Fresh owners. Covariant subtyping and erased signa\u00adtures were described in FIGJ, \nand ownership nesting and  FT ::= C<FO,IP> Field (and method return)Type. T ::= C<MO,IP> Type. N ::= \nC<NO,NI> Non-variable type (for objects). NO ::= World | l Non-variable Owner parameter (for objects). \nFO ::= NO | This | O Field Owner parameter. MO ::= FO | ? Method Owner parameter (including generic wildcard). \nNI ::= Mutable | Immutl Non-variable Immutability parameter (for objects). VI ::= NI | Immut | I Variable \nImmutability fornew. IP ::= ReadOnly | VI ImmutabilityParameter. IG ::= ReadOnly | Immut | Mutable | \nRaw Immutability method Guard. M ::= <I extends IG>? FT m(T x) { return e; } Method declaration. L ::= \nclass C<O,I> extends C <O,I>{ FT f;M } cLass declaration. v ::= null | l Values: eithernull or a location \nl.  e ::= v | x | e.f | e.f = e | e.m(e) | new C<FO,VI>(e) | e ;return Expressions. Figure 7. FOIGJSyntax.Theterminals \nare null, owner parameters(O, This, World), and immutabilityparameters(I, ReadOnly, Mutable, Raw, Immut). \nGiven a location l, Immutl represents animmutable object with cooker l. The program source code cannot \n contain the grayed elements (locations are only created during execution/reduction in R-NEW of Fig. \n10). (limited)owner-polymorphic methodsinFOGJ.Westress thatFOIGJ does model wildcard for the owner parameter \n(?), which is used in owner-polymorphic methods such as sort or equals.In our view, extending the formalism \nwith freshowners or innerclasses increasesthe complexityof the calculus without providing new insights. \nThe followingrules areenforcedby thesyntaxof FOIGJ (Fig. 7): Generic Wildcards and Raw parameter.The \nre\u00admaining rules are: Field assignment, Field access, Method invocation, cJ s [20] method guard, and \na Subtype rela\u00adtion (without generics). Theserules areformalizedin FOIGJ in the subtypingrulesof Fig.8(K,G \nf T = T )andthetyping rulesof Fig.9(K,G f e :T).Finally,thereduction rulesare described in Fig. 10(Kf \nH,e . H' , e '). Sec. 3.1 describes the syntax of FOIGJ, Sec. 3.2 the subtyping rules, Sec. 3.3 the typing \nrules, Sec. 3.4 the reduction rules, andSec. 3.5proves preservation, progress, and our run-time immutability \nand ownership guarantees. 3.1 Syntax of FOIGJ FOIGJaddsimperativeextensionstoFJsuchas assignmentto .elds, \nobject locations, null, and a heap[32].Aconstructor initializesallthe .eldsto null, andthen callsabuild \nmethod that constructs the object.Having null values is important because this-owned.eldsmustbe initializedwith \nnull since theycannotbeassignedfromthe outside, i.e., they mustbe created within this.Forexample,alistconstructor \ncannot receiveits entries as constructor arguments;insteaditmust create the entries within the build \nmethod. Fig. 7 presents the syntax of FOIGJ. Expressions in FOIGJincludethe fourexpressionsinFJ(method \nparam\u00adeter, .eld access, method invocation, and new instance creation; without casting), as well as the \nimperative ex\u00adtensions (.eld update, e;return l, and values). Expres\u00adsion e;return l is created when \nreducing a constructor call, e.g., Kf new N(...) . l.build(...);return l, then we proceed to reduce l.build(...) \nand .nallyreturn l.Note that O and I areterminals, i.e.,theownerandimmutability parameters are always \nnamed O and I. An evaluation of an expression(e)is either in.nite, or is stuck on null-pointer exception, \nor terminates with a value (v), which is either null or a location l. Note how the syntax limits the \nusage of wildcards and Raw:wildcards(?)can be used onlyas the owner of method arguments (FOIGJ does not \nhave local variables), and Raw only as a method guard(IG). We represent sequences using an over-line \nnotation, simi\u00ad larlytoFJ,i.e.,comma denotes concatenationof sequences, and FT f; represents the sequence \nFT1 f1; ...FTn fn; Aclassin FOIGJhasa single constructorthatcancreate bothmutableandimmutableobjects, \ni.e.,itisa Raw construc\u00ad tor. The constructoris not showninthe syntaxbecauseit can be inferredfrom the \nclass declaration: it always assigns null tothe .eldsofthe newlycreated object, andtheninvokes this special \nmethod (ignoring the return value): <I extends Raw>? T build(T e) { return e; } We require that each \nclass has such a method, and that its parameters are not this-owned nor have wildcards. The re\u00adduction \nrules call that method after the .elds are set to null.  3.2 Subtyping in FOIGJ An environment G is \na .nite mapping from variables x and locations l to types T, e.g., x : T . G. The location types de.ne \nthe ownership tree j. (or without re.exivity -.). The set of currently executing constructors is denoted \nK. In addition, G mapstheimmutability parameter I toits bound accordingto the current method s guard(IG \nin Fig. 7).For  K,G f S = T K,G f T = U class C<O,I> extends C ' <O,I> (S1) (S2) (S3) (S4) K,G f I = \nG(I) K,G f T = T K,G f S = U K,G f C<MO,IP> = C ' <MO,IP> (S5) (S6) (S7) K,G f Mutable = Raw K,G f Raw \n= ReadOnly K, G f Immut = ReadOnly K,G f IP = IP ' l . K (S8) (S9) (S10) K,G f C<MO,IP> = C<MO,IP ' > \nK,G f C<MO,IP> = C<?,IP> K,G f Immutl = Raw l . K l . K l -. NO (S11) (S12) (S13) K,G f Immutl = Immut \nK,G f Immut = Immutl K,G f C<NO,Immut> = C<NO,Immutl> Figure 8. FOIGJ Subtyping Rules(K,G f T = T ). \nRule S13 shows the connection between cooker l and owner NO. example, I :Raw . G whentypingthe expression \ne in method build above. Fig.8shows FOIGJ subtypingrules.Rules S1 S4 are the same as FGJ rules: S1 means \nthat a generic variable is a subtype of its bound, S2 is re.exivity, S3 is transitivity, and S4 is that \nsubclassing de.nes subtyping.Rules S5 S7 show subtyping among non-variableimmutability parameters as \nshownin Fig.1b. Rule S8 de.nescovariantsubtyping forthe immutability parameter. Rule S9 formalizes subtyping \nwith a wildcard owner. Thelastfour rules S10 S13 are concerned with cookers such as Immutl. Recall that \nan object is cooked when its cooker l is constructed, i.e., the constructor of l is no longer executing: \nl . K. Rule S10 views the type as Raw, while rules S11 S12 shows the equivalence to Immut. Note that \nsubtypingisno longer antisymmetric, i.e., therearenon-equal types T1 and T2 for which T1 = T2 = T1.For \nexample, T1 = C<O,Immutl> and T2= C<O,Immut>,whenl . K.Infact,this is not surprising because these types \nboth represent immutable object, and after the cooker is cooked, the identity of the cooker is irrelevant. \nCooker vs.owner Rule S13assumes that the cooker is inside theowner(l -. NO),whichmeanstheobjectmightcamefrom \nthe outside. This rule addressesthe difference betweenthe cooker of (i) a location l or(ii)thatofanexpression \nsuchas .eld access l.f:(i) locationl will be cooked exactly when the constructor of .(l) is .nished,however,(ii)the \ncooker of l.f is an over-approximation, i.e., the object stored in that .eld might have been cooked earlier. \nRule S13 allows an over-approximation onlywhenthe cookeris inside theowner. Consider this example: class \nFoo<O,I> { Date<O,I> same; <I extends Raw>? Foo(Date<O,I> d) { same=d; } } Field same is assigned fromtheoutside,butitmightstillbe \nthis-owned.We willshowthereductionoftwoexpressions: one where same is assigned a cooked (outside) date, \nand one witharaw date. Theexpressions are insidethe constructorof some object b whose cooker is b itself. \nThereductionofthe .rstexpression: new Foo<This,Immut>(new Date<This,Immut>()) results in the heap: H \n= {d1 . Date<b,Immutd1>(),f1 . Foo<b,Immutf1>(d1)}. Note that the type of d1 must be a subtype of f1.same \nina well-typedheap(formallyde.ned later). Thetypeof d1 is a subtype of Date<b,Immut> (because d1 . K \nin rule S12), which is a subtype of Date<b,Immutf1> (because f1 -. b in rule S13).Phrased differently, \nthe cooker of f1.same is f1,butitmay pointtoanobject thatwas cooked before,and indeeditpointstoanobject \nwhosecookeris d1 (so it is an over-approximation). The reductionofthesecondexpression: new Foo<This,I>(new \nDate<This,I>()) results in the heap (because I = Immutb): H = {d2 . Date<b,Immutb>(),f2 . Foo<b,Immutb>(d2)}.Note \nthat in this case, both d2 and f2 havethesame cooker b. The type of f2.same is Date<b,Immutb>,and becauseb \n-. b (see rule S13), then we knowthat thisis not anover-approximation, i.e., that .eld points to an object \nwhose cooker must be b. To summarize, consider a type Foo<o,Immutc>. If the cooker c is inside the owner \no (c -. o), or the cooker is cooked(c . K), thenthe typeis anover-approximation, i.e., it can point to \nany Immut object(thatis,to anyobjectwith cooker c . K). Otherwise, it points to an object whose cooker \nis exactly c.Formally, LEMMA 3.1. If K,G f C<MO,IP> = C <NO,Immutl>, l -. NO, and l . K, thenIP = Immutl. \nWe also prove in the technical report that: LEMMA 3.2. If K,G f C<MO,IP> = C <MO ,IP >,then(i)MO = ? \n. MO = MO ,(ii)(IP = Immutl or l -. MO ) . K, G f IP = IP , and(iii) C is a subclass of C , (iv) K,G \nf D<l,IP> = D<l,IP > for any class D and location l where MO j. l.  3.3 Typing rules of FOIGJ Auxiliary \nfunctions We use the following auxiliary func\u00ad tions: .elds(C) returnsallthe .eld names(including inherited \n.elds) of class C, ftype(f,C) returns the type of .eld f in class C, mtype(m,C) returns the type of method \nm in class C, and mbody(m,C) returns its body. Their de.nitions are based on their counterparts in FJ, \nand thus omitted from this paper. In addition,function mguard(m, C) returnsthe method s guard (IG in \nFig. 7).  K.{l},G f e :T mtype(.,build,C<FO,VI>)= T . U K,G f e :T K,G f T = T (T-RETURN) (T-NEW) K,G \nf e;return l :G(l) K, G f new C<FO,VI>(e) :C<FO,VI> K,G f e :C<MO,IP> ftype(e,f,C<MO,IP>)= T (T-VAR) \n(T-NULL) (T-FIELD-ACCESS) K,G f x :G(x) K, G f null :T K,G f e.f :T K,G f e.f :T K, G f e :T K,G f T \n= T K,G f e :C<MO,IP> (T-LOCATION) K, G f IP = Raw isTransitive(e,G,C<MO,IP>) MO = ? (T-FIELD-ASSIGNMENT) \nK,G f l :G(l) K,G f e.f = e :T K,G f e0:C<MO,IP> mtype(e0,m,C<MO,IP>)= T . T\" K,G f e :T K,G f T = T \nmguard(m, C)= IG K,G f IP = IG IG = Raw . isTransitive(e0,G,C<MO,IP>) mtype(m,C)= U . V O(Ti)= ? . O(Ui)= \n? (T-INVOKE) K,G f e0.m(e) :T\" Figure 9. FOIGJ ExpressionTyping Rules(K,G f e :T). Weoverloadtheauxiliary \nfunctionsabovetoworkalso for types(T = C<MO,IP>)and not justclasses(C)by substi\u00adtuting [MO/O,IP/I].However,we \nalso needto carefully sub\u00adstitute This when the receiver is this or locations. Func\u00adtion ftype(e,f,T) \nreturnsthetypeofthe.eldaccess e.f where T isthe typeof e,orerror ifthe accessisillegal.Forexample, ftype(ownedD,Foo) \n= Date<This,I> ftype(this,ownedD,Foo<O,Immut>) = Date<This,Immut> ftype(this.f,ownedD,Foo<O,Immut>) = \nerror ftype(l,ownedD,Foo<o,Immutc>) = Date<l,Immutc> Formally,ftype(e,f,C<MO,IP>)=[MO/O,IP/I,z/This]ftype(f,C), \nwhere (i) z = l if e = l,(ii) z = This if e = this,(iii) oth\u00aderwise z = error (and if a type contains \nerror then it means the call to ftype failed). When we know the .eld is not this-owned, then the expression \ne is not used, and we write ftype(.,f,C).However,ifthe .eldis this-owned, then e must be this or a location \nl. Recall that Field access rule inFig.4required that this\u00adowned .elds can be accessed only via this. \nAt run time, this is substituted with a location l. Therefore, there is a duality between this and a \nlocation l in the de.nition of ftype.For example, the .eld access this.ownedD of type Date<This,I> is \nlegal because we accessed a this-owned .eld via this. At run time, this is substituted with some location \nl, andthe access l.ownedD of type Date<l,...> is now still legal because we accessed a this-owned.eld \nvia a location l.Notethatifthe accessis not done viaa location, e.g., bar.l.ownedD,then we cannot type-check \nthe resulting expression (because we do not know what should be the substitute for This). Thereisasimilar \ndualityin Field assignment rule part (ii),thatchecks that Raw is transitivefor this or this-owned objects. \nThe dual of this is alocation l, and the dual of a this-owned object(C<This,I>)is an object whose cooker \nis not insideitsowner(C<o,Immutl> where l -. o).The second duality holds because, fortype C<This,I>,the \ncooker(I)is never inside theowner(This).At runtime,theowner willbe the location of this,andthe cookeriseither \nthis or some other object that was created before this, i.e.,the cookeris never inside the owner (but \ntheymight be equal). Function isTransitive checks whether Raw is transitive. The underlined part shows \nthe dual version of Field assignment rule part (ii): (i) this vs. l ', and (ii) MO = This vs. l -. MO. \nisTransitive(e,G,C<MO,IP>)= se IP = I and G(I)= Raw . (e=this or MO = This) or se IP = Immutl . (e=l \nor l -. MO) Typing class declarations FOIGJprogramconsists of class declarations followed by the program \ns expression. Next, we describeinwords therulesfortypingtheclass declarations, and therulesfor typing \nanexpression aregiven formallyin Fig. 9. When typing an expression, we assumed the class declarations \nare well-formed. To check that class declarations are well-formed, FOIGJ .rstperformsallthechecksdoneinFJ, \ne.g.,thatthereareno cyclesintheinheritancerelation,that.eldandmethod names are uniqueinaclass,that this \nis notalegalmethodparameter name, that anoverridingmethodmaintainsthe same signa\u00adture,etc. FOIGJperformsadditionalchecksrelatedtomethod \nguardswhentypingmethod declarations,i.e.,we modifyrule T-METHOD in FJ as follows: (i) An overriding method \ncan only make the guardweaker, i.e.,ifa methodwithguard IG over\u00adrides one with guard IG then IG = IG.(ii) \nIn class C, when typing a method: <I extends IG>? FT m(T x) { return e;} we use an environment G in which \nthe bound of I is IG, i.e., G = {I : IG,x : T, this : C<O,I>}, and we must prove that 0/,G f e : S and \n0/, G f S = FT. Finally, we require that if IG = ReadOnly then I(Ti)= I. This last requirement is not \nreallyalimitation, becausea programmer can replace I with ReadOnly for parameters in readonly methods, \nand previouslylegalprograms would remain legal. (This require\u00admentis neededto prove preservation for \nthe congruence rule of method receiver, see our technical report for details.)  _ Immutl if VI = Immut \nor (VI = Immutc and c . K)l . dom(H) VI ' = VI otherwise (R-NEW) Kf H,new C<NO,VI>(v) . H[l . C<NO,VI \n>(null)],l.build(v);return l K.{l}f H,e . H' ,e H[l]= C<NO,NI>(v) .elds(C)= f (R-C1) (R-FIELD-ACCESS) \nKf H,e;return l . H' ,e ;return l Kf H,l.fi . H,vi H[l]= C<NO,NI>(v) .elds(C)= f NI = Mutable or .H(l) \n. K v ' = null or l j..H(v ') (R-FIELD-ASSIGNMENT) ' Kf H,l.fi = v '. H[l . C<NO,NI>([v ' /vi]v)],v \n' H[l]= C<NO,NI>( ... ) mbody(m,C)= x.e (R-RETURN) (R-INVOKE) ' Kf H,v;return l . H,l Kf H,l.m(v) . \nH,[v/x,l/this,l/This,NO/O, NI/I]e Figure 10. FOIGJ Reduction Rules(Kf H,e . H' ,e '), excluding all congruence \nrules except R-C1. Typing expressions Fig.9 shows the typingrules forex\u00adpressions in FOIGJ. Most of these \nrules are a direct trans\u00adlationfromFig.4. Themain challengewas handling wild\u00adcards correctlywithoutresultingin \nwildcard-capture.Rule T-FIELD-ASSIGNMENT requires that MO = ?, i.e., one cannot assign toan object with \nunknownowner.Typingmethodparame\u00adtersissimilarto typing .eld-assignment,however, method parameters can \nhave a wildcard owner whereas .elds cannot (seethe difference between T and FT in Fig. 7). Thus, rule \nT-INVOKE requiresthat O(T)= ? . O(U)= ?,i.e.,ifTi= C<?,IP> then Ui = C<?,IP >. I.e.,iftheownerof e0 is \nunknown, then the owner of the method parameters cannot be O. Rule T-NEW performsless checkscomparedtoamethod \ncall(e.g., no need to checkthe guard, isTransitive, nor wild\u00adcards) because build has several restrictions: \nits guard is Raw andit does not contain wildcards nor this-owned pa\u00adrameters. Because This does not appear \nin the signature of build, we know that mtype will not use . in the call: mtype(.,build,C<FO,VI>). An \nexpression/type is called closed ifitdoes not contain anyfreevariables (e.g., wildcards, this, I, O, \nor This),but it maycontain World, ReadOnly, Mutable, Immut, Immutl or l. Note that the type of a closed \nexpression is also closed. ' LEMMA 3.3. If K,G f e ' :T ' and e is closed and e ' = null, then T ' is \nclosed. The delicate part of the proof is showing that T ' does not contain This.Note that ftype returns \na type with This only if e = this (which cannot happen since e is closed).  3.4 Reduction rules of FOIGJ \nThe initial expressiontobe reducedis closed, and we guar\u00adanteethataclosedexpressionisalways reducedto \nanother closed expression: ' LEMMA 3.4. If e is closed and Kf H,e . H' ,e ', then e is closed. The heap(or \nstore) H maps each location l to an ob\u00adjectC<NO,NI>(v),where.H(l)= NO isitsowner,and IH(l)= NI is its \nimmutability, and v are the values of its .elds. If NI = Immutl ' then we saythatits cookeris .H(l)= \nl '.(We added the subscript H tothe functions that return theowner, immutabilityand cooker,in ordertoexplicitlyshowthe \nde\u00adpendence on the heap.)We de.nea heap-typing GH :l . T thatgivesa typeto eachlocationin theobviousway \n(simply removing the list of .elds (v)). The setof currentlyexecuting constructorsis K.Aheap H is well-typed \nfor K if it satis.es two conditions: (i) Each .eld locationisa subtype(using K,GH)ofthe declared.eld \ntype,i.e., forevery location l, where H[l]= C<NO,NI>(v) and .elds(C)= f, and for every .eld fi, we have \nthat ei\u00adther vi = null or K,GH f GH(vi) = ftype(l,fi, C<NO,NI>). (ii) There is a linear order jT over \ndom (H) such that for every location l, .H(l)= World or .H(l) -T l, and IH(l)= Mutable or .H(l) jT l. \nThe linear order jT can or\u00adderthe objects accordingtotheir creation time,because.H(l) is always created \nbefore l, and .H(l) is either l or created before l. In our technical report we prove that if H is well-typed \nfor K then (a) owner-as-dominator holds (Lem. 3.5), and (b) His well-typed for anysubsetof K(Lem. 3.6).Part(b)is \nnottrivial, becausethesubtypingrelationfora subsetof Kis different because raw objects become immutable. \nIntuitively, duringexecutionobjectsbecome cooked(when their cooker is removed from K), and therefore \nLem. 3.6 guarantees that the heap remains well-typed when Kdecreases. LEMMA 3.5. If heap H is well-typed \nfor K, then for every location l . dom (H), l . C<NO,NI>(v), then either vi = null or l j..H(vi). LEMMA \n3.6. Given a heap H that is well-typed for K, then for anyS . K, the heapH is well-typed forS. Fig. 10 \npresents the reduction rules in a small-step nota\u00ad tion, excluding all congruence rules except R-C1. \nRule R-RETURN ignores the return value of build and re\u00adturns l. Rule R-FIELD-ACCESS is trivial.Rule R-FIELD-ASSIGNMENT \nenforces ourimmutabilityguarantee(onlymutable or raw  objects can be mutated) and our ownershipguarantee(owner\u00ad \n' as-dominator, i.e., l can point to v iff l j..H(v ')). Rule R-INVOKE .ndsthe method body accordingto \nthe receiver, and substitutes all the free variables in the method body. Rule R-C1 is the congruence \nrulefor e;return l.Note that this rule is the only place the set K is modi.ed,i.e.,when reducing e, the \nset of ongoing constructors is K.{l}. It ' is easy to prove that if K f H, e . H' ,e then GH . GH' . \nThe other congruence rules are not shown because they are trivial, e.g.,in ordertoreduceamethodcall e0.m(e), \nwe .rst reduce e0 toa location,then reduce the .rst argumenttoa value, etc. Rule R-NEW createsa new location \nl, sets the .eldsto null, sets the cooker of l (VI )and .nallycalls build.In orderto build the newly \ncreated objectl, then it must be raw, i.e., its cooker VI must bein K. (Note that l will bein Kaccording \nto R-C1.)Therefore,if VI = Immutc and c . K,then we must set the cooker to l. This can happen if there \nis a method that returns new C<O,I>(...) and thereceiverisa cooked immutable object.  3.5 Guarantees \nof FOIGJ Wenowturntoprovevarious propertiesofFOIGJ,including preservation theorem,ownershipandimmutabilityguaran\u00ad \ntees, and an erasureproperty.In the remainderofthis section, we assume that reduction does not getstuck \non null-pointer exceptions, i.e.,the receiver/targetof .eldaccess,assignment and method calls is never \nnull.Under this assumption, then e ' can always be reduced to another expression e . Before stating the \npreservation theorem, we need to es\u00adtablish a connection between K and the reduced expres\u00adsion e, which \nmay contain return l. Given an expression e, we de.ne K(e) to be the set of all ongoing constructors \nin e, i.e., all the locations in subexpressions e ;return l. Formally, K(e;return l)= K(e) .{l}, and \nfor any other expression we just recurse into all subexpressions, e.g., K(e.f=e )= K(e) . K(e ). Wewillmaintaintheinvariant \nthatHis well-typedfor K. K(e). FromLem. 3.6, then H will also be well-typed for K. Initially, we start \nwith a closed expression e without any locations (therefore K(e)= 0/), an empty heap H, and an empty \nset of constructors K. THEOREM 3.7. (Progress and Preservation) For every closed expression e = v, K, \nand H, if K,GH f e : T and ' His well-typed for K. K(e), then there exists H' ,e ,T ' such ' that Kf \nH,e . H' ,e , H' is well-typedfor K. K(e '), T, T , ' and e are closed,K,GH'f e ' :T ', andK,GH'f T '= \nT. Proved by showing there is always (exactly) one applicable reduction rule, which preserves subtyping. \nFrom Lem. 3.4, ' we know that e isclosed,andfromLem. 3.3, we know that T and T ' areclosed.Nextwe mention \nsomehighlightsfrom the proof. In rule R-RETURN, we have that K(e ')= K(e) \\{l}, buteventhough weshrinkK, \nwe still have a well-typed heap from Lem. 3.6. In rule R-FIELD-ASSIGNMENT,Lem. 3.5shows that the assumption \nl j..H(v ') holds, and the resulting heap is well-typed for K.K(e ') because K(e ')= {} andfrom T-FIELD-ASSIGNMENT.Inrule \nR-NEW,we needtotypethe calll.build(v), and for parameters withimmutability I,we usethe subtyping rule \nS13. Our ownership and immutability guarantees follow di\u00ad rectlyfrom thereduction rules,because rule \nR-FIELD-ASSIGNMENT enforces them. Thm.3.8shows thatthereisno needtomaintainat run time K nor to storetheowner \nandimmutabilityparameter of each object. Formally, we de.ne an erased heap struc\u00adture E(H) that maps \nlocation to objects without these pa\u00adrameters, i.e., l . C(v) . E(H).We de.nethe erasureof an expression \ne, E(e), by deleting all generic parameters, and de.ne new reduction rules .E in the obvious way. ' THEOREM \n3.8. (Erasure) IfK f H,e . H' ,e then Kf E(H),E(e) .EE(H'), E(e '). 4. OIGJ Case Studies This sectiondescribes \nour implementationofOIGJ: thelan\u00ad guage syntax(Sec. 4.1) and thetype-checkerimplementation (Sec.4.2).Sec.4.3presents \nourcasestudythatinvolvedan\u00ad notating Sun s implementation of the java.util collections, and our conclusions \naboutthe designof the collection classes w.r.t. ownership and immutability. The prototype OIGJ type-checker \nis implemented and distributed aspartof theCheckerFramework[31]2, which supports pluggable type systems \nusing type annotations. 4.1 Syntax: from generics to annotations Whereas this paper uses generics to \nexpress ownership and immutability (e.g., Date<O,I>), our OIGJ implementation usesJava7 stype annotations[15](e.g.,@O \n@I Date). Java 7 s receiver annotations play the role of cJ s guards. Using annotations has the advantage \nof compatibility with existing compilers and other tools. Another advantage is the abilityto use a defaultvalue, \nsuch as @Mutable. Furthermore, itispossibleto customizethesedefaultsperclass.Defaults are not possible \nin generics, because a programmer must supply arguments for all generic parameters. Using annotations \nhas the disadvantage that some notions are no longer explicit in the syntax, such as transitivity, wildcards, \nand genericmethods.Forexample, comparethe annotation and generic syntax: class Foo { @O @I Bar bar; } \nclass Foo<O,I> { Bar<O,I> bar; } Note that the type of new Foo<World,Immut>().bar is ex\u00adplicit in the \ngeneric syntax, whereas the annotation syn\u00ad tax(new @World @Immut Foo().bar)requires additionalrules \nthat mimic generics.Useof annotations alsocomplicatesthe implementation (see below).For practical use,the \ncompati\u00ad 2http://types.cs.washington.edu/checker-framework/  bility bene.ts of using annotations outweigh \ntheir disadvan\u00ad tages. OIGJ s annotations arethe Cartesian productofowner parameters and immutability \nparameters.Ourimplementation does not yet support wildcards (though in practice the @I and @O annotations \nsubsume most need for wildcards), nor classeswithmultipleownerorimmutabilityparameters, such as Iterator<O,ItrI,CollectionI,E> \nin Fig. 3. (In our case study, weimplemented iterators usinga singleimmutability parameter by declaring \nnext() as mutable.) Aclass declaration can be annotatedas @Immut to indicate classimmutability,i.e.,allinstances \nareimmutableandno mutable methods exist.  4.2 OIGJ implementation Because a pluggable type checker augments, \nrather than replaces, the type system of the underlying language, the Checker Frameworkpermits only language \nextensions that are stricter than ordinary Java. A pluggable type system cannot relaxJava srules,as the \nOIGJ subtyping rule does. For example, @Immut List<@Immut Date> a; @ReadOnly List<@ReadOnly Date> b=a; \n// OK @Immut List<@Immut Object> c=a; // Illegal! The assignment c=a isillegalinJava and thereforeinthe \nChecker Framework,thoughitislegalinOIGJitself.Phrased differently,in ourimplementation, thecovarianceislimited \nto annotations. The OIGJtype-checker incorporates,extends, andin some placesoverridesthe IGJ checker, \nandaddsOGJfeatures.It consistsof about700 sourcelinesofcode(ofwhich100lines isJavaboilerplatetode.nethe \nannotations).Mostofthecode handles default and implicit types.  4.3 java.util collections case study \nAsa case study, we type-checkedSun simplementationsof the java.util collections (77 classes, 33,246 lines \nof code). This required us to write 85 ownership-related annotations and 46 immutability-related annotations \nin 102 lines of code (the lines with new usually contain2annotations). Sun s collections are nottype-safewith \nrespectto generics because Java does not support generic arrays. However, the OIGJimplementation uses \ntype annotations, which can be placed on arrays as well, and therefore our annotated collections type-check \nwithout any errors with respect to ownership and immutability. Class LinkedList in Fig.3is similarin \nessenceto Sun s implementation. We annotated the constructors with Raw, thus allowing creation of immutable \ninstances. Since all instances of Entry are this-owned, using @This @I as the default annotationfor Entry \nmeantthat onlythree ownership\u00adrelated3 annotations were needed in LinkedList: 3The other annotations \nare immutability-related, e.g., receiver annotations. @Default({This.class, I.class}) static class Entry<E> \n{ E element; @O Entry<E> next; @O Entry<E> prev; ... } Similarly, in a HashMap, boththe array and the \nentries are this-owned: @This @I Entry[@This @I] table; Thecasestudy supportsthese conclusions:(i)the \ncollec\u00ad tions classes are properlyencapsulated(they own their repre\u00ad sentation),(ii)itispossibleto createimmutableinstances(all \nconstructors are Raw), and(iii)methods Map.get and clone contain designmistakes(seebelow).Wewerenotpreviously \nawareofthese designmistakes.We believethatif the col\u00ad lections were designed with ownershipand immutability \nin mind, such mistakes could be avoided. Immutability of method get Let sstart withaquickriddle: is there \na Map implementation in java.util that mightthrow an exception when running the following single-threaded \ncode? for (Object key : map.keySet()) { map.get(key); } The answer is that for a map created with new \nLinkedHashMap(100, 1, /*accessOrder=*/ true) that contains more than one element, the above code throws \nConcurrentModificationException after printing one ele\u00ad ment. Most programmers assumethat Map.get is \nreadonly,but there is no such guarantee in Java s speci.cation. The doc\u00adumentation of LinkedHashMap states: \nA special constructor isprovidedtocreatealinkedhashmap whoseorderofit\u00aderationistheorderinwhichits entrieswerelast \naccessed, from least-recently accessed to most-recently(access-order). Invoking the put or get methodresultsin \nan accesstothe corresponding entry. Because calling get modi.ed the list, the above code threw ConcurrentModificationException. \nPhrased differ\u00adently, method LinkedHashMap.get is mutable! Because an overriding method can only strengthen \nthe speci.cation of the overridden method, HashMap.get and Map.get must be mutable as well. Ownership \nand method clone Method clone violates owner-as-dominator because it leaks this-owned references by creatinga \nshallow copy,i.e., onlyimmediate .elds are copied. Furthermore, Sun s implementation of LinkedList assigns \nto result.header, which is a this-owned .eld.This violates Field assignment rule of Sec. 2.3, which only \npermits assignment to this.header. // The following code appears in LinkedList.clone(). // Calling super.clone() \nbreaks owner-as-dominator because // it leaked this.header to result.header. LinkedList result = (LinkedList) \nsuper.clone(); result.header = new Entry(); // Illegal in OIGJ! Wesketcha solution that,insteadof initializingthecloned \nresult from this, usestheideaof inversion of control.The  OIGJ OGJ IGJ GUT UTT IOJ JOE3 [33] [40] [14] \n[25] [19] [30] Owner-as-dominator + + + + Owner-as-modi.er + + Readonly references + + + + + Immutable \nobjects + + + + Uniqueness + Ownership transfer + Factory method pattern + + + + + + Visitor pattern \n+ + Sun s LinkedList + Figure 11. Features supported by various language designs.  solutionhastwo parts.(1)The \nprogrammerwritesa method constructFrom thatinitializes this froma parameter.(Thisis similartoa copy-constructorin \nC++, and indeedthismethod shouldbe given allthe privileges of a constructor, such as as\u00ad signment to \nfinal .elds.)(2) The compiler automaticallygen\u00aderatesa clone method that .rst nulli.es all thereference \n.elds and thencallsthe user generated constructFrom method. This approach enforcestheownership andimmutabilityguaran\u00ad \ntees. 5. Related Work In thissection we discuss relatedwork onownership andim\u00ad mutability.We .rsthighlight \nthe relationship betweenOIGJ and our previous work on ownership(OGJ)and immutabil\u00adity(IGJ).We also survey \nsomeof the most relevantrelated language designs and show how OIGJ compares to them. 5.1 Relationship \nwith OGJ and IGJ OIGJcanbethoughtofasthe cartesian product ofOGJand IGJ: OIGJusestwotypeparameterstoexpressownershipand \nimmutability.However,thedelicate intricaciesbetweenown\u00ad ership andimmutability required changesto bothOGJ \nand IGJ,making OIGJ moreexpressivethana naivecombination. Ownership Generic Java (OGJ) [33]demonstrated \nhow ownership andgeneric types canbe uni.ed asalanguage feature. OGJ featured a single owner parameter \nfor every classthat wastreatedinthesamewayas normalgenerictype parameters, simplifyingthelanguage,theformalism, \nandthe implementation. OGJcompletely prohibits wildcards as owner parameters, e.g., Point<?>, whereasOIGJ \nrelaxes this rule and allows wildcards on stack variables, which enables writing the equals method (see \nGeneric Wildcards rule in Sec. 2.3). In OGJ, a method may have generic parameters that are owner parameters, \ne.g., class Foo<O extends World> { <O2 extends World> void bar(Object<O2> o) {...} However,OGJ requiredthatthe \nparametricowners are out\u00adside the owner of the class, e.g., O j. O2. This rule is very restrictive, however \nit guarantees that the ownershipstructure isatree.OIGJremovedthisruleatthe costofcomplicating theownership \nstructure:itisa directed acyclic graph (DAG) instead of a tree. Finally, OIGJcanexpresstemporaryownership \nwithina methodby usinga freshowner parameter(see Fresh owners in Sec. 2.3). Immutability Generic Java \n(IGJ) [40] showed how generic types can be used to provide support for readonly references and objectimmutability. \nOIGJ usedownership information to improve the expressiveness of IGJ. Speci.\u00adcally, certain restrictionsinIGJ \nno longer applyin OIGJfor this-ownedobjects.Forexample, Raw is not transitivein IGJ, e.g., the assignment \nto next in Fig.3 on lines9 and 22is illegalinIGJ,thus limiting creationofimmutable objects.In contrast, \nRaw is transitive in OIGJfor this-owned .elds (see Field assignment rule in Sec. 2.3), and therefore \nthere was no need to refactor the collections code. IGJ includes an @Assignable annotation on .elds that \npermits .eld assignment even in immutable objects. The @Assignable annotation indicates that a given \n.eld is not partoftheobject sabstract state.Thisisnecessarytotype\u00adcheck caches, lazily-initialized .elds, \nand other programming idioms.OIGJ removed this annotation to simplifythe formal\u00adism. This also guarantees \nrepresentation immutability as well as immutabilityof the abstraction:the .eldsofa cooked im\u00admutable \nobject never change. Ourimplementation supports the @Assignable annotation. IGJonly permits a single \nimmutabilityparameter, which simpli.es the subtyping rule. In contrast, types in OIGJ can have multiple \nimmutability parameters, for example, Iterator<O,ItrI,CollectionI,E>. BecauseIGJ usesasin\u00adgle immutabilityparameter, \nthe immutability of an iterator and its underlying collection must be the same. Thus, in IGJ, method \nnext() mustbereadonly(oryou couldn titerateover a readonly list), and therefore we had to use an @Assignable \nannotation on ListItr.current (line 37in Fig. 3). In con\u00adtrast,in OIGJ, we guard next() witha mutable \nItrI (line 51), and guard remove() with a mutable CollectionI (line 52).  5.2 Relationship with other \nwork OIGJusesmethod guards borrowedfrom cJ [20].(The OIGJ implementation uses annotations syntax instead.) \nIn what follows, we have room to survey only closely relatedpapers.Fig.11 compares OIGJtosomeoftheprevious \nwork described below. Mutability and encapsulation were .rst combined by Flexible Alias Protection(FLAP)[28].FLAPinspireda \nnum\u00adberof proposals includingownershiptypes[13]and con.ned types[36]. Capabilitiesfor Sharing[5]describes \nthe fun\u00addamentals underlying various encapsulation and mutability approachesby separating mechanism (thesemanticsof \nsharing and exclusion) from policy (the guarantees pro\u00advidedbytheresulting system). Capabilitiesgivesalower\u00adlevelsemanticsthat \ncanbe enforcedat compileorruntime. Areference can possessanycombinationofthese7access  rights: read, \nwrite, identity(permitting address comparisons), exclusive read,exclusive write,exclusiveidentity, andown\u00ad \nership(givingthe capabilityto assertrights).Immutability, for example, is represented by the lack of \nthe write right and possession of the exclusive write right. Finally, Fractional Permissions [6]can give \nsemantics to various annotations such as unique, readonly, method effects, and an ownership variant called \nowner-as-effector in which one cannot read or writeownedstatewithout declaringthe appropriateeffectfor \nthe owner. Ownership types [2, 3, 11]impose a structure on the references between objectsina program \nsmemory. OIGJ and other work[30, 33]enforce the owner-as-dominator disciplines.Generic UniverseTypes(GUT)[14, \n24]enforce owner-as-modi.er by usingthree type annotations: rep, peer, and readonly. rep denotes representation \nobjects (similar to This), while peer denotes objects owned by the same owner(similar to O). UTT [25]is \nan extension of Universe Types thatsupportsownershiptransferby utilizinga modular static analysis, which \nis useful for merging data-structures or complex object initialization. MOJO[10]can express multiple \nownership: objects can have morethan oneowneratruntime.OIGJ supportsonly a single owner at run time. \n(OIGJ supports multiple owner parameters,but according to the Ownership nesting rule, all owner parameters \nare inside the .rst owner parameter.) Jo. [8]supports variant subtyping over the owner parame\u00ad terby \nusingexistential types. OIGJ supportswildcards used asownersfor stack variables,but those areless .exible \nthan Jo..For example, Jo. can distinguish a listof students that mayhavedifferentowners,fromalistofstudentthat \nshare the same unknown owner. Immutability and ownership. Similarly to OIGJ, Im\u00admutableObjects foraJava-like \nLanguage(IOJ)[19]asso\u00adciates with eachtypeits mutability andowner.In contrastto OIGJ, IOJ does not have \ngenerics, nor readonly references. Moreover, in IOJ, the constructor cannot leak a reference to this. \nHaack andPoll[19]later added .exibleinitializa\u00adtionofimmutableobjects,i.e.,animmutable objectmaystill \nbe mutated afterits constructor returns. They usetheanno\u00adtations RdWr, Rd, Any, and myaccess, which corresponds \nto our Mutable, Immut, ReadOnly, and I. In addition,theyhave aninference algorithm that automatically \ninfersthe end of objectinitialization phases.(Their algorithminferswhich variables are Fresh(n), which \nresembles our Raw.However, the programmer cannot write the Fresh annotationexplicitly.) X10[29]supports \nconstrainedtypesthatcan refertoprop\u00adertiesand .nallocalvariables.X10supportscyclicimmutable structures \nby using proto annotations,which aresimilarto our immutability I and the notion of cookers. However, \nboth X10 and IGJ cannot type-checkSun s LinkedList because an object becomes cooked when its constructor \n.nishes. It is possible to refactor LinkedList to .tX10 styping-rulesby usinga recursiveimplementation,butthenyouriskastack\u00ad \nover.ow when creating large lists. Delayed types[16], which are similar to X10 s proto, are used to verify \nnon-null .elds or other heap-monotonic properties. JOE3 [30]combines ownership(as dominators, not modi\u00ad \n.ers), uniqueness,andimmutability.Italso supportsowner\u00ad polymorphic methods,but notexistentialowners. \nFrozenObjects[23]show how ownership can help sup\u00ad port immutability by allowing programmers to decide \nwhen the object should becomeimmutable. This systemtakesa veri.cation approach rather than a simple type \nchecker such as OIGJ.Frozen Objects showhow.exible theinitialization stage can potentiallybeinthe presenceofownership \nand immutability, while OIGJ shows how much .exibility can be achieved while staying at the type checking \nlevel. Readonly references are found in C++(usingthe const keyword),JAC[22], modes[34], Javari[35], etc. \nPrevious work on readonly references lack ownership information. Boyland[4]observes that readonly does \nnot address ob\u00adservational exposure, i.e., modi.cations on one side of an abstraction boundary that are \nobservable on the other side. Immutable objectsaddress suchexposurebecausetheirstate cannot change. List \niterators posea challengetoownership becausethey requireadirectpointertothelist sprivately owned entries, \nthusbreaking theowner-as-dominator property.BothOIGJ andSafeJava[3]allow an inner instance to access \nthe outer instance s privately owned objects. Clarke[11]suggested to use iterators only with stack variables, \ni.e., you cannot store aniteratorina.eld.Itisalso possibleto redesignthecode andimplementiterators withoutviolatingownership, \ne.g.,by using internal iterators or magic-cookies [27]. 6. Conclusion OIGJisaJavalanguageextension that \nsupports bothown\u00adership and immutability, while enhancing the expressive\u00adness of each individual concept. \nBy using Java s generic types, OIGJ simpli.es previous type mechanisms, such as existentialowners, scoped \nregions, and owner-polymorphic methods. OIGJ is easy to understand and implement, us\u00ading only14 (.ow-insensitive)typing \nrules beyond those of Java.Wehave formalizedacore calculus called FOIGJ and proveditsound.Ourimplementationis \nbackward-compatible with Java, and it scales to realistic programs. OIGJ can type-check Sun s java.util \ncollections (without the clone method), using a small number of annotations. Finally, var\u00adious design \npatterns, such as the factory and visitor pat\u00adterns, canbeexpressedin OIGJ,makingit ready for prac\u00adticaluse.Animplementationis \npubliclyavailableat http: //types.cs.washington.edu/checker-framework/. Future work includes inferring \nownership and immutabil\u00adity, conductinga bigger case studywith client andlibrary code,andextendingOIGJ \nwith conceptssuch as owner-as\u00admodi.er [41], uniqueness, and external-uniqueness [12].  Acknowledgments \nThisworkwas supportedbythe grantsfromRSNZ Marsden, ISAT, andNSF CNS-0855252.Weespecially thankWerner \nDietl, James Noble, ELVIS, and the anonymous referees. References [1] Chandrasekhar Boyapati. SafeJava:AUni.edType \nSystemfor Safe Programming. PhD thesis, MIT Dept. of EECS, Feb. 2004. [2] Chandrasekhar Boyapati, Robert \nLee, and Martin Rinard. Ownership typesfor safe programming: Preventingdata racesand deadlocks.In OOPSLA, \npages 211 230, Oct. 2002. [3] ChandrasekharBoyapati,BarbaraLiskov,andLiuba Shrira.Ownership types for \nobject encapsulation. In POPL, pages 213 223, Jan. 2003. [4] John Boyland. Why we should not add readonly \ntoJava (yet). In FTfJP, July 2005. [5] John Boyland, James Noble, and William Retert. Capabilities for \nsharing:Ageneralisationof uniqueness and read-only. InECOOP, pages 2 27, June 2001. [6] John Boyland, \nWilliam Retert, and Yang Zhao. Comprehending annotations on object-oriented programs usingfractionalpermissions. \nIn IWACO, pages 1 11, July 2009. [7] GiladBracha, Martin Odersky,David Stoutamire, andPhilipWadler. Making \nthefuture safe forthe past: Adding genericityto theJava programming language. In OOPSLA, pages 183 200, \nOct. 1998. [8] Nicholas Cameron and Sophia Drossopoulou. Existential quanti.ca\u00adtion for variant ownership. \nIn ESOP, pages 128 142, Mar. 2009. [9] Nicholas Cameron, SophiaDrossopoulou, and ErikErnst.Amodel for \nJava with wildcards. In ECOOP, pages 2 26, July 2008. [10] Nicholas R. Cameron, Sophia Drossopoulou, \nJames Noble, and Matthew J. Smith. Multiple ownership. In OOPSLA, pages 441 460, Oct. 2007. [11] DaveClarke \nand Sophia Drossopoulou. Ownership, encapsulation and the disjointness of type and effect. In OOPSLA,pages \n292 310,Oct. 2002. [12] Dave Clarke and Tobias Wrigstad. External uniqueness is unique enough. In ECOOP, \npages 176 200, July 2003. [13] DavidG. Clarke,JohnM. Potter,andJamesNoble. Ownership types for .exible \nalias protection. In OOPSLA, pages 48 64, Oct. 1998. [14] Werner Dietl, Sophia Drossopoulou, and Peter \nM \u00a8Generic uller. Universe Types. In ECOOP, pages 28 53, Aug. 2007. [15] MichaelD.Ernst.Type Annotations \nspeci.cation (JSR 308). http: //types.cs.washington.edu/jsr308/, Sep. 12, 2008. [16] ManuelF\u00a8ahndrich \nand Songtao Xia. Establishing object invariants with delayed types. In OOPSLA, pages 337 350, Oct. 2007. \n[17] Erich Gamma,Richard Helm, RalphE. Johnson, and JohnVlissides. DesignPatterns. Addison-Wesley, Reading, \nMA, 1995. [18] Christian Haack andErik Poll.Type-based object immutabilitywith .exible initialization. \nIn ECOOP, pages 520 545, 2009. [19] Christian Haack, Erik Poll, JanSch\u00a8 afer, and Aleksy Schubert. Im\u00admutable \nobjects for a Java-like language. In ESOP, pages 347 362, Mar. 2007. [20] Shan Shan Huang,DavidZook,andYannisSmaragdakis.cJ: \nEnhanc\u00ad ing Java with safe type conditions. InAOSD, pages 185 198, Mar. 2007. [21] AtsushiIgarashi, BenjaminC. \nPierce, and PhilipWadler. Feather\u00ad weightJava:a minimal core calculus forJava andGJ. ACMTOPLAS, 23(3):396 \n450, May 2001. ISSN 0164-0925. [22] Gunter Kniesel and DirkTheisen. \u00a8JAC access right based encap\u00adsulation \nfor Java. Software: Practice and Experience, 31(6):555 576, 2001. [23] K.RustanM. Leino, PeterM\u00a8uller, \nandAngelaWallenburg. Flexible immutability with frozen objects. In VSTTE, pages 192 208, Oct. 2008. [24] \nP. M\u00a8 Universes: A type system for uller and A. Poetzsch-Heffter. controlling representation exposure. \nIn Programming Languages and Fundamentals of Programming, pages 131 140, 1999. [25] PeterM \u00a8uller and \nArseniiRudich.Ownershiptransferin universe types. In OOPSLA, pages 461 478, Oct. 2007. [26] StefanN\u00a8ageli. \nOwnership in design patterns. Master sthesis, ETH Z\u00a8urich,Z\u00a8urich, Switzerland, Mar. 2006. [27] JamesNoble.Iteratorsand \nencapsulation. In TOOLSPaci.c, pages 431 442, 2000. [28] James Noble,JanVitek, and John Potter. Flexible \nalias protection.In ECOOP, pages 158 185, July 1998. [29] Nathaniel Nystrom, Vijay Saraswat, Jens Palsberg, \nand Christian Grothoff.Constrained typesforobject-orientedlanguages.In OOPSLA, pages 457 474, Oct. 2008. \n\u00a8 uniqueness and immutability. In Tools Europe, pages 178 197, 2008. [30] Johan Ostlund, Tobias Wrigstad, \nand Dave Clarke. Ownership, [31] MatthewM.Papi,MahmoodAli,TelmoLuisCorreaJr.,JeffH.Perkins, and MichaelD. \nErnst.Practicalpluggable typesforJava. In ISSTA, pages 201 212, July 2008. [32] Benjamin C. Pierce. Types \nandProgrammingLanguages. MITPress, 2002. [33] Alex Potanin, James Noble,DaveClarke,and RobertBiddle.Generic \nOwnership for Generic Java. In OOPSLA, pages 311 324, Oct. 2006. [34] MatsSkoglund andTobiasWrigstad.A \nmodesystem forread-only references in Java. In FTfJP, June 2001. [35] Matthew S. Tschantz and Michael \nD. Ernst. Javari: Adding reference immutability to Java. In OOPSLA, pages 211 230, Oct. 2005. [36] JanVitek \nand BorisBokowski.Con.nedtypes.In OOPSLA, pages 82 96, Nov. 1999. [37] Tobias Wrigstad. Ownership-BasedAlias \nManagement. PhD thesis, Royal InstituteofTechnology, Sweden,May 2006. [38] Tobias Wrigstad andDaveClarke. \nExistentialowners forownership types. J. ObjectTech., 6(4):141 159, May June 2007. [39] Yoav Zibin. Featherweight \nOwnership and Immutability Generic Java (FOIGJ). Technical Report 10-16, ECS, VUW, June 2010. http://ecs.victoria.ac.nz/Main/TechnicalReportSeries. \n[40] YoavZibin, Alex Potanin, MahmoodAli, Shay Artzi, Adam Kie. zun, andMichaelD. Ernst. Object and referenceimmutability \nusingJava generics. In ESEC/FSE, pages 75 84, Sep. 2007. [41] Yoav Zibin,Alex Potanin,PaleyLi,MahmoodAli, \nand Michael D. Ernst. OIGJ with owners as modi.ers. Technical Report 10-15, ECS, VUW, January 2010. \n   \n\t\t\t", "proc_id": "1869459", "abstract": "<p>The Java language lacks the important notions of <i>ownership</i> (an object owns its representation to prevent unwanted aliasing) and <i>immutability</i> (the division into mutable, immutable, and readonly data and references). Programmers are prone to design errors, such as representation exposure or violation of immutability contracts. This paper presents <i>Ownership Immutability Generic Java</i> (OIGJ), a backward-compatible purely-static language extension supporting ownership and immutability. We formally defined a core calculus for OIGJ, based on Featherweight Java, and proved it sound. We also implemented OIGJ and performed case studies on 33,000 lines of code.</p> <p>Creation of immutable cyclic structures requires a <i>\"cooking phase\"</i> in which the structure is mutated but the outside world cannot observe this mutation. OIGJ uses <i>ownership</i> information to facilitate creation of <i>immutable</i> cyclic structures, by safely prolonging the cooking phase even after the constructor finishes.</p> <p>OIGJ is easy for a programmer to use, and it is easy to implement (flow-insensitive, adding only 14 rules to those of Java). Yet, OIGJ is more expressive than previous ownership languages, in the sense that it can type-check more good code. OIGJ can express the factory and visitor patterns, and OIGJ can type-check Sun's java.util collections (except for the clone method) without refactoring and with only a small number of annotations. Previous work required major refactoring of existing code in order to fit its ownership restrictions. Forcing refactoring of well-designed code is undesirable because it costs programmer effort, degrades the design, and hinders adoption in the mainstream community.</p>", "authors": [{"name": "Yoav Zibin", "author_profile_id": "81100037778", "affiliation": "Victoria University of Wellington, Wellington, New Zealand", "person_id": "P2354112", "email_address": "", "orcid_id": ""}, {"name": "Alex Potanin", "author_profile_id": "81100005943", "affiliation": "Victoria University of Wellington, Wellington, New Zealand", "person_id": "P2354113", "email_address": "", "orcid_id": ""}, {"name": "Paley Li", "author_profile_id": "81442607757", "affiliation": "Victoria University of Wellington, Wellington, New Zealand", "person_id": "P2354114", "email_address": "", "orcid_id": ""}, {"name": "Mahmood Ali", "author_profile_id": "81361598628", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P2354115", "email_address": "", "orcid_id": ""}, {"name": "Michael D. Ernst", "author_profile_id": "81100204056", "affiliation": "University of Washington, Seattle, WA, USA", "person_id": "P2354116", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869509", "year": "2010", "article_id": "1869509", "conference": "OOPSLA", "title": "Ownership and immutability in generic Java", "url": "http://dl.acm.org/citation.cfm?id=1869509"}