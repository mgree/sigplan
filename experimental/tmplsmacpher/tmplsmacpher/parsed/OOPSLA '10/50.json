{"article_publication_date": "10-17-2010", "fulltext": "\n PINOCCHIO: Bringing Re.ection to Life with First-Class Interpreters Toon Verwaest Camillo Bruni David \nGurtner Adrian Lienhard Oscar Nierstrasz Software Composition Group, University of Bern, Switzerland \n http://scg.unibe.ch Abstract To support development tools like debuggers, runtime sys\u00adtems need to \nprovide a meta-programming interface to al\u00adter their semantics and access internal data. Re.ective ca\u00adpabilities \nare typically .xed by the Virtual Machine (VM). Unanticipated re.ective features must either be simulated \nby complex program transformations, or they require the devel\u00adopment of a specially tailored VM. We propose \na novel ap\u00adproach to behavioral re.ection that eliminates the barrier be\u00adtween applications and the VM \nby manipulating an explicit tower of .rst-class interpreters. PINOCCHIO is a proof-of\u00adconcept implementation \nof our approach which enables rad\u00adical changes to the interpretation of programs by explicitly instantiating \nsubclasses of the base interpreter. We illustrate the design of PINOCCHIO through non-trivial examples \nthat extend runtime semantics to support debugging, parallel de\u00adbugging, and back-in-time object-.ow \ndebugging. Although performance is not yet addressed, we also discuss numerous opportunities for optimization, \nwhich we believe will lead to a practical approach to behavioral re.ection. Categories and Subject Descriptors \nD.3.4 [Programming Language]: Processors Interpreters, Runtime environments; D.3.3 [Programming Language]: \nLanguage Constructs and Features; D.3.2 [Programming Language]: Language Class\u00adifications Very high-level \nlanguages General Terms Re.ection, Virtual Machines Keywords Smalltalk, Behavioral Re.ection, Metacircular\u00adity, \nVirtual Machines, Debugging, Object-Flow Analysis 1. Introduction Debuggers, pro.lers, sandboxing, support \nfor memory bar\u00adriers, transactions, the addition of re.ective capabilities, and Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. Onward! 2010, October 17 21, 2010, Reno/Tahoe, \nNevada, USA. Copyright &#38;#169; 2010 ACM 978-1-4503-0236-4/10/10. . . $10.00 many other language extensions, \nare all common examples of useful tools and techniques that are conveniently provided by modifying the \nruntime of a language. [Modifying the interpreter] presents the advantage of having direct access to \nthe internal structure of the interpreter and therefore provides greater .exibility and expressiveness \nfor supporting dynamic adapta\u00adtion. The major disadvantages are the loss of compat\u00adibility with standard \nenvironments, which often results in particular tools becoming obsolete quickly, and the complexity of \nthe implementation. Indeed, modifying a production virtual machine is not an easy task, and it is subsequently \ndif.cult to keep up-to-date with new versions and technologies ... [39] Consider the example of the \nobject-.ow debugger [27], a back-in-time debugger that keeps track of the .ow of objects in an object-oriented \nruntime. Although this is a very effective debugging tool for object-oriented languages, the original \nObject Flow VM prototype quickly became out of sync with the rapidly changing Pharo VM that it was based \non [3]. The problem is not related to the choice of modifying the interpreter de.nition, but rather to \nthe fact this interpreter de.nition cannot be changed from within the language itself. If the semantics \nof the interpreter could be changed from within, the code would be kept in sync with the standard VM, \njust like normal applications. Although high-level languages traditionally support re\u00ad.ective programming, \nthey provide only a limited set of ca\u00adpabilities for introspection and intercession. Normal applica\u00adtions \ncannot extend the re.ective interface. Hence, applica\u00adtions that need features that are not supported \neither cannot be implemented, must be simulated in a roundabout way, or have to resort to modifying the \nVM. Early research on re.ection, rooted in Lisp, proposed a different approach to re.ection in which \nthe interpreter itself is modeled as a .rst-class entity [36]. Although such an approach is extremely \npowerful, it has not been made practical and is not implemented in modern VMs. In this paper we present \nPINOCCHIO, a runtime that sup\u00adports .rst-class interpreters. PINOCCHIO is based on Small\u00adtalk, but uses \nan AST instead of bytecode interpretation. Ap\u00adplications freely .ow from interpreter to interpreter depend\u00ading \non the required semantics. Applications specify their own interpreters inside the runtime as subclasses \nof the de\u00adfault Interpreter class, a rei.cation of the core inter\u00adpreter.  PINOCCHIO absorbs and exploits \nthree features from Smalltalk to effectively extend interpreters: the object model: PINOCCHIO adopts \nthe object model of Smalltalk since specialized interpreters typically make only modest changes to their \nbase-level semantics, ob\u00adjects can often .ow freely between levels;  recursion: interpreters are de.ned \nas recursive AST visi\u00adtors instead of as bytecode machines with explicit stacks .rst-class continuations \ncan be used to implement non-local .ow of control;  garbage collection: interpreters can rely on the \ngarbage collection provided by their meta-level.  The contributions of this paper include (i) an analysis \nof the limits of behavioral re.ection as practiced today; (ii) a novel approach to behavioral re.ection \ninspired by Refci s .rst-class interpreters [36]; (iii) the design and implementa\u00adtion of PINOCCHIO, \na proof-of-concept prototype of the ap\u00adproach; (iv) the presentation of three non-trivial case studies \ndemonstrating how PINOCCHIO s design facilitates behav\u00adioral re.ection. This paper is organized as follows: \nSection 2 reviews standard approaches to behavioral re.ection and summa\u00adrizes the practical challenges \nfacing these approaches. In Section 3 we present PINOCCHIO in a nutshell, it explains how PINOCCHIO bootstraps \nitself with the help of .rst-class interpreters and presents PINOCCHIO s metaobject protocol. Section \n4 illustrates how a .rst-class interpreter can easily be extended to support debugging, and then motivates \nthe de\u00adsign of multiple interpreters with the help of an example of a specialized interpreter to support \nobject-.ow analysis for back-in-time debugging and a parallel debugger. Section 5 compares PINOCCHIO \nto other dynamic languages in terms of performance, and outlines the further steps required to turn PINOCCHIO \ninto a fast approach to behavioral re.ec\u00adtion. Section 6 compares PINOCCHIO with related work. Section \n7 concludes with a brief summary of the results.  2. Practical Limits of Behavioral Re.ection We .rst \nreview basic terminology and history before consid\u00adering the challenges and limits of behavioral re.ection. \nComputational re.ection refers to the ability of computer programs to reason about their own structure \nand behavior at runtime [29, 37]. Re.ective systems distinguish the base (application) level from the \nmeta (semantic) level. Re.ection entails the rei.cation of meta-level entities to the base level, that \nis, semantic entities are rei.ed as ordinary application entities. (If we ask a Java object for its class \nwe obtain an ordinary Java object representing that class.) Structural re.ection is concerned with rei.cation \nof the structure of the program, i.e., its data and code. Behavioral re.ection is concerned with rei.cation \nof the behavior of the program, i.e., its interpretation.Re.ection can be further re.ned into introspection \nand intercession. Introspection is purely concerned with reifying meta-level concepts to rea\u00adson about \nthem at the base level. For example, we may ask an object what .elds it has so we can print them all. \nInterces\u00adsion, on the other hand, allows us to manipulate rei.ed meta\u00adlevel entities and re.ect changes \nback to the meta-level. In Smalltalk one can change the class of an object at runtime, immediately causing \nthat object s behavior to change. Such changes effect a causal connection between the rei.ed enti\u00adties \nand the meta-level entities they represent [29]. Some typical uses of re.ection are found in (i) debugging \ntools; (ii) GUIs for object structures; (iii) code instrumenta\u00adtion and analysis tools; (iv) dynamic \ncode generation; and (v) language extensions. In mainstream high-level languages support for re.ection \nis dictated by whatever is provided by the VM. Short of building a tailored VM, users of the re.ective \nAPI are strictly limited to the capabilities that have been built into the VM. As a consequence, practical, \nmainstream uses of re.ection are mostly limited to (structural) introspection, for example, as offered \nby the Java re.ection API. These systems provide no means for extending them with re.ective capabilities \nthat were not anticipated. Since extending and shipping a modi\u00ad.ed runtime usually is not an option, \ninnovative extensions are not possible. Several different approaches to behavioral re.ection have been \nrealized over the years, but each suffers from its own practical limitations. Smith introduced the notion \nof compu\u00adtational re.ection and he illustrated his model through the implementation of a re.ective dialect \nof Lisp, called 3-Lisp [37]. 3-Lisp applications can contain special rei.er functions that take rei.cations \nof aspects of the interpreter as argu\u00adments: the current expression, the environment in which the expression \nis being executed and the continuation of the ap\u00adplication. In Smith s model these rei.ers conceptually \nrun in the scope of the interpreter since they operate on the applica\u00adtion from the point of view of \nthe interpreter. Adding support for rei.ers to a language thus adds the ability to add lines to the code \nof the interpreter from within the application con\u00adtext. It also makes us believe that below every interpreter \nthere is another interpreter that evaluates the interpreter and all rei.cations requested by the application \non top. Re.ec\u00adtion is therefore supported by an in.nite tower of interpre\u00adters. Starting with Smith s \nTower of Interpreters we will re\u00adview the practical challenges faced by the different ap\u00adproaches to \nbehavioral re.ection.  2.1 Continuous behavioral re.ection Behavioral re.ection in most systems is discrete, \nwhich means that re.ective computations are initiated at a dis\u00adcrete point by calling a re.ective procedure \nand only lasting until this procedure returns [30]. For example, a method wrapper that makes a method \nasynchronous only affects the particular wrapped method not all the methods in the whole system. Discrete \nre.ection is not well suited for use cases requiring continuous changes that span the execution of multiple \nmethods or even of a whole application. Contin\u00aduous behavioral re.ection refers to re.ective computations \nthat are explicitly inserted in the meta-interpreters, thus hav\u00ading a continuous effect on the base level \ncomputation [30]. Software transactional memory, for example, entails a con\u00adtinuous change to the semantics \nof a language which can bene.t from invasive changes to the runtime [19]. Smith s Tower of Interpreters \n(ToI) approach is funda\u00admentally discrete since the behavior of interpreters can only be extended, not \nmodi.ed. Existing meta-behavior cannot be mutated strictly limiting custom re.ective behavior to the \nbase-level code explicitly triggering this custom re.ec\u00adtive behavior. Simmons et al. extended the discrete \nre.ec\u00adtive tower to a continuous model of re.ection by introduc\u00ading .rst-class interpreters in Refci \n(re.ective extension by .rst-class interpreters) [36]. In Refci, changes can be applied to the interpreter \nby explicitly wrapping around the meta\u00adinterpreter. These wrappers are then used for the interpreta\u00adtion \nof all code to which the modi.ed interpreter is applied, thus having a continuous effect on its interpretation. \nRefci extends the interface of rei.ers with rei.cations of the interpreter itself in the form of a preliminary \nand a dis\u00adpatch procedure. The preliminary is a function that trans\u00adforms a dispatch onto another dispatch, \nand is executed be\u00adfore executing the actual dispatch. The dispatch itself evalu\u00adates expressions and \nas such is a rei.cation of the actual in\u00adterpreter. By obtaining .rst-class access to these procedures \nthe programmer can extend the semantics of the interpreter for the duration of the evaluation of the \npassed expression. To our knowledge, no further research has taken place to make .rst-class interpreters \npractical. The key research problem is how to implement extensible .rst-class interpre\u00adters in a VM in \na clean and fast way. 2.2 High-level re.ective API Re.ection enabled by mechanisms such as method wrappers \n[7], proxies [15], or overriding exception handling meth\u00adods [15] is used in practice only in limited, \nidiomatic ways depending on the host programming language. To enable widespread use of re.ection, a safe \nand practical re.ective API is needed. Bracha and Ungar claim as a fundamental design princi\u00adple for \nre.ection that meta-level facilities must encapsulate their implementation [6]. McAffer justi.es this \nprinciple as follows: the metalevel has been thought of as a place for mak\u00ading small changes requiring \nsmall amounts of code and interaction. We believe that the metalevel should be viewed as any other potentially \nlarge and com\u00adplex application it is in great need of management mechanisms. [32] In an effort to make \nit feasible to develop libraries and applications that rely on re.ection, Kiczales et al. proposed the \nuse of metaobject protocols (MOPs) to implement dis\u00adcrete re.ection. What re.ection on its own does not \nprovide, however, is .exibility, incrementality, or ease of use. This is where object-oriented techniques \ncome into their own [25]. Since its de.nition, all re.ective object-oriented languages have resorted \nto metaobject protocols to provide discrete re.ection. By providing a clear interface to the language, \nmetaobject protocols give the user the ability to incremen\u00adtally customize the language s behavior and \nimplementation. Metaobject protocols provide discrete re.ection since one has to install custom metaobjects \nwherever non-standard be\u00adhavior is required. Open implementations [24] provide a general design principle \nthat moves the black box boundary of objects so that part of their internal implementation strategy becomes \nopen and customizable to the user. For example a Set class could allow the user to specify what kind \nof operations are most common for a particular instance so that instance can be optimized towards that \nuse-case. Open implementations provide discrete customizations, affecting only particular in\u00adstances \nrather than the system as a whole.  2.3 Separation of base and meta-level Typically, discrete re.ection \nis implemented by manipulat\u00ading base-level code (e.g., through source or bytecode trans\u00adformation). This \ntechnique brings forth a whole new set of problems (the same that optimizers introduce for debug\u00adging). \nMost importantly, the application that uses re.ection has to keep track of the meta-level on which it \nis being evalu\u00adated to avoid endless recursion [8, 12]. For instance, the code that logs a method execution \nmust avoid itself triggering the logging meta behavior to avoid in.nite meta recursion. This problem \narises from the lack of a clean separation between base and meta behavior. Bracha and Ungar argue that \nmeta-level facilities must be separated from base-level functionality [6]. McAffer [31] argues that \nThe implementation of an object must be explicitly exposed and clearly distinguished from the object \ns domain-speci.c behaviour description. While towers of interpreters clearly separate the base\u00adlevel \nand meta-level computations, metaobject protocols generally lack this clear distinction, leading to confusion \nbetween the two levels [8, 12].   2.4 Summary Behavioral re.ection is most usable in practice when \nencap\u00adsulated through a well-designed MOP. All re.ective sys\u00adtems therefore provide .xed MOPs: as .exible \nas they may be, they impose the actual interfaces of metaobjects. [39] Despite their practical advantages, \nMOPs inherently offer discrete re.ection, lead to meta-level confusion, and are thus limited in their \nsupport for extension. These limitations are also inherent to today s VM approaches which establish a \nrigid barrier between what one may re.ect on, and what is hidden in the guts of the runtime. The following \ntable summarizes the shortcomings of the various approaches. ToI MOP Refci Discrete re.ection .. . Continuous \nre.ection . High-level re.ective API . Separation of levels ..  3. PINOCCHIO in a Nutshell PINOCCHIO \neliminates the barrier between applications and the VM by using .rst-class interpreters to realize behavioral \nre.ection. The VM core implements a dialect of Smalltalk\u00ad80 [17]. PINOCCHIO supports the runtime implementation \nand use of interpreter extensions. Instead of interpreting bytecodes, PINOCCHIO directly interprets abstract \nsyntax trees (ASTs) that more faithfully represent Smalltalk-80 code. The core interpreter is imple\u00admented \nin C, and is rei.ed in the runtime as a .rst-class in\u00adterpreter. The interpreter provides a basic MOP \nto support structural re.ection. Unlike most interpreters that are based on the assumption that the VM \nis a black box isolated from the runtime system, PINOCCHIO supports behavioral re.ec\u00adtion by opening \nthe interpretation of code to the runtime. Behavioral re.ection is supported by explicitly instantiat\u00ading \n.rst-class interpreters that subclass the rei.ed core inter\u00adpreter. Extending interpreters is facilitated \nsince AST nodes are semantically closer to the original source code than byte\u00adcode [11, 13]. To construct \na new variant of the PINOCCHIO interpreter it suf.ces to subclass the Interpreter class and override \na part of its interface (see Figure 1). The Interpreter class de.nes a meta-circular interpreter implemented \nas an AST visitor that manages its own environment but relies on recursion to automatically manage the \nruntime stack. The meta-circular interpreter rei.es the core interpreter written in C, so its methods \nare actually implemented as native functions that hook into the underlying C interpreter code. From user \ns point of view the Interpreter is fully written in PINOCCHIO itself. Application code is evaluated by \na new interpreter by sending the interpret: message to the desired interpreter class with a closure representing \nthe code as its argument. For example, the expression Figure 1. Native methods in the Interpreter and \ninter\u00adpreter extension through subclassing Debugger interpret: [ self runApplication ]. will cause the \nclosure [ self runApplication ] to be evaluated by the Debugger interpreter. As usual, closures encapsulate \nan environment and an ex\u00adpression object. When starting up a specialized interpreter the continuation \nof the interpreted application is empty. The interpreter installs the enclosed environment and starts \neval\u00aduating the expression in this environment. Since the passed expression for the default interpreter \nis a closure the evalu\u00adation is done by sending the message value to the closure on top of the interpreter: \ninterpret: aClosure t self send: (Message new selector: #value ) to: aClosure. Although it might seem \ncorrect to directly evaluate the clo\u00adsure by invoking aClosure value, this is incorrect as the closure \nwould be evaluated at the wrong level of interpreta\u00adtion. It would run at the level of the interpreter \n(the meta\u00adlevel from the application s point-of-view) rather than at the application level as desired. \nThe open design of the meta-circular interpreter lets pro\u00adgrammers extend the runtime with very little \neffort. More importantly, the extensions to the interpreter are imple\u00admented within the language provided \nby the interpreter it\u00adself. As such they can be implemented using any of the existing tools for the language, \nincluding development envi\u00adronments, debuggers, test-runners and versioning systems. 3.1 Bootstrapping \nPINOCCHIO The bootstrapping C interpreter is the .rst interpreter used in the runtime. It is an instance \nof the MainInterpreter class, a subclass of the Interpreter class. The main inter\u00adpreter does not override \nthe interpretation implementation but provides a prelude that decides how to start interpreta\u00adtion. It \nuses the command line arguments passed to the exe\u00adcutable to decide whether to directly interpret an \ninput .le or to start a REPL. As shown in Figure 2, all code passed to the  Figure 2. Bootstrapping \nPINOCCHIO interpreter in either case is parsed, compiled and interpreted on top of this interpreter instance. \nSource code is transformed into the AST using a compiler that runs on top of our runtime, just like the \nself-hosted Smalltalk compilers. This compiler is completely written in standard Smalltalk code hosted \non Pharo [3]. The compiler is then bootstrapped to PINOCCHIO with the help of a bridge that performs \nthe following steps: a Pharo class is translated to a Pharo object representing aPINOCCHIO class, and \nthe compiler is used to generate PINOCCHIO ASTs for the methods of the class;  the bridge then transforms \nthese Pharo objects to C code that uses the internal API of the PINOCCHIO runtime;  the generated C \ncode is statically compiled into the inter\u00adpreter;  when the runtime boots, the generated C code builds \nthe PINOCCHIO version of the original class and its associ\u00adated ASTs.  The compiler .rst uses a Parsing \nExpression Grammar (PEG) [16] that translates the input source code to a full Smalltalk AST. We use a \nPEG since they provide a simple way of combining parsers into bigger parsers and are well suited for \nextensions to existing languages [33]. This parsing step is followed by one step of simple semantic analysis \nand translation to the PINOCCHIO AST. Once the input source code is loaded it is passed to the superclass \nof the MainInterpreter. Since the main inter\u00adpreter does not specialize any of the interpretation methods, \nthis comes down to executing the code directly on the C in\u00adterpreter. Its function is merely to provide \na location to put the prelude of an interactive interpreter.  3.2 Minimizing the Interpreter Stack Our \napproach of starting new interpreters on top of other interpreters is similar to, albeit the inverse \nof, the tower of .rst-class interpreters in Refci [36]. This has the advantage that we can use the same \napproach to minimize the height of the tower that is actually running at each point in time. For example, \nsince the MainInterpreter does not alter the interpretation behavior of the standard interpreter, the \nevaluation of the application can happen fully at the C level, dropping the MainInterpreter from the \nactive interpreter stack. It is important to never run on a stack bigger than necessary, since each extra \nlevel of interpretation has a steep price in terms of performance. In PINOCCHIO the height of the tower \nis pragmatically minimized by making the whole de.nition of the standard interpreter available as a .ne-grained \nset of natives installed on the Interpreter class (see Figure 1). Only the exten\u00adsions to the interpreter \nare evaluated meta-circularly. Since most custom interpreters will only partly alter the semantics of \nexisting native methods, the default implemen\u00adtation in charge of invoking natives, invokeNative, allows \ninterpreters to rely on meta-meta-level implementations of natives to provide the behavior to the base-level. \nIn other words, whenever an application ends up in code that invokes a native, the interpreter can ask \nits meta-interpreter to per\u00adform the actual invocation of the native. This temporarily drops the interpreter \nfrom the active stack of interpreters. Since natives are able to send messages back to the ap\u00adplication \nlevel, every call to invokeNative stores the in\u00adterpreter that triggered the actual native. To ensure \nthat the application always runs on the proper level of interpretation, when the native wants to send \na message back to the appli\u00adcation it .rst has to restore the stack of interpreters that was active before \ninvoking the native. An example of such a case is the native implementation of the at: method installed \non dictionaries. This method needs to be able to request the hash value of a key, and later compare it \nwith the keys in the dictionary using the = message. Both methods are within the control .ow of the native \nevaluation of the at: method. To evaluate both methods at the right level of interpretation, the stack \nof interpreters that was active before the at: was in\u00advoked needs to be reconstructed before their evaluation \nis started. 3.3 PINOCCHIO Metaobject Protocol Aside from providing access to user-de.nable and runtime \ninstantiatable .rst-class interpreters, PINOCCHIO provides a default metaobject protocol that is suf.cient \nfor many re\u00ad.ective use cases. From the point of view of the program\u00admer, the main interpreter is written \nas a meta-circular AST visitor. New semantics can easily be added to the language by replacing standard \napplication constructs such as meth\u00adods with custom metaobjects following the same metaobject protocol. \nThe following extension points are noteworthy. First-class AST nodes. New nodes can be de.ned by fol\u00adlowing \nthe visitor protocol. The new nodes could be gener\u00adated by extending the default parser and compiler. \nThis could for example be used to provide mutable AST nodes or link objects for partial behavioral re.ection \n(see subsection 6.2). Does not understand. Following Smalltalk-80, our core interpreter sends the doesNotUnderstand: \nmessage to any object that does not implement a method corresponding to the selector of a message sent \nto it. This is an important feature to make PINOCCHIO compatible with existing Small\u00adtalk code. First-class \nslots. Unlike most Smalltalk systems, which rely on magic numbers to encode the layout of instances, \nPINOCCHIO s class layouts are described using layout meta\u00adobjects. These metaobjects further rely on \nslot metaobjects that de.ne the semantics of instance variables. Whenever a reference to an instance \nvariable is made in the application s source code, the compiler directly inserts the corresponding slot \nmetaobject into the resulting method s AST. Every slot metaobject can override the AST node evalua\u00adtion \nprotocol to provide custom semantics for retrieving the instance variable. Custom semantics for the assignment \nto instance variables are implemented by overriding the proto\u00adcol provided by the interpretation of the \nAssign AST node. By providing explicit layout and slot metaobjects, appli\u00adcations can easily decide what \nkind of layout and accessing semantics to attach to speci.c classes. Special behavior such as .rst-class \nrelationships or singletons can cleanly be fac\u00adtored out into slot libraries to avoid cluttering of the \ncode referring to the slots.  4. Implementing Custom Interpreters In this section we present three \ndifferent customized inter\u00adpreters implemented in PINOCCHIO.We .rst introduce a simple debugger that \nabsorbs garbage collection and the object model, and relies on straightforward recursion to manage control \n.ow. The alias interpreter shows how in\u00adterpreters with custom object models are implemented. Fi\u00adnally \nwe outline how interpreters relying on access to the runtime stack are supported in PINOCCHIO through \nmodi\u00ad.able interpreters and the availability of .rst-class continu\u00adations. The full sources of these \nuse cases are available under Figure 3. Specializing a Pinocchio interpreter to the next message send, \nto inspect the current receiver, to step over the evaluation of the message send or to evaluate PINOCCHIO \nstatements. This is a typical subset of actions available in any debugger. As shown in Figure 3, to implement \nthe debugger in PINOCCHIO, we start by creating the stepping interpreter class as a subclass of the standard \nInterpreter.The step\u00adping interpreter overrides the methods in charge of evaluat\u00ading message sends. Rather \nthan directly executing a send, the stepping interpreter delays this behavior and .rst gives control \nto a stepBlock installed on the interpreter instance: send: message to: receiver class: class t stepBlock \nvalue: receiver value: class value: message value: [ super send: message to: receiver class: class ]. \nThe stepBlock of the interpreter can be used to .exi\u00adbly modify the message send semantics of the running \nin\u00adterpreter. Subclasses of the stepping interpreter can de.ne a custom default stepBlock and replace \nthe stepBlock at http://scg.unibe.ch/download/pinocchio/pinocchio_svn1397_mc196.zip.runtime. 4.1 A Simple \nDebugger To show how extensions to existing interpreters are imple\u00admented and used we .rst describe the \nimplementation of a simple debugger. It executes a program while allowing the user to pause evaluation \nat the level of message sends. In or\u00adder to start evaluating code using a debugger the user passes the \ncode to the debugger in the form of a closure: Debugger interpret: [ self runApplication ]. The debugger \ntakes control over the evaluation of the block. At each message send it allows the user to decide to \nstep The debugger itself is implemented by providing differ\u00adent kinds of blocks to the stepping interpreter. \nThe default stepBlock of the debugger is implemented as follows: defaultStepBlock t [ :receiver :class \n:message :action | self print: receiver class name, >> , message. self debugShellWithAction: action ]. \nIt .rst displays information about the current message send by printing out the receiver s class and \nthe message including the selector and arguments. Then the debug shell is launched asimple read-eval-print-loop \n(REPL) that accepts certain debug actions, as well as PINOCCHIO statements as input.  Since this REPL \nruns within the execution context of the interpreter, the current execution of the application is tem\u00adporarily \nhalted until the REPL eventually returns and decides to evaluate the action. Other types of debug actions \ncan be implemented using different stepping blocks. The follow method implements the step over behavior. \nIt lets the debugger execute an entire application-level recursive call without prompting the user about \nits evaluation. stepOver: overAction |result previousBlock| previousBlock := stepBlock. stepBlock := \n[ :receiver :class :message :action | action value ]. result := overAction value. stepBlock := previousBlock. \nt result It locally stores the previous stepping strategy and installs a block that skips all steps. \nWhenever the application .nishes the recursive call that triggered the current step the control .ow will \nautomatically end up back in this method restoring the block to the previous version and continuing. \nEvaluation This way of implementing a debugger is straight\u00adforward and only requires very little code \nto add new .exible features. The whole implementation of the debugger adds around 50 lines of code to \nthe stepping interpreter, which adds another 30 to the default interpreter. Since the debug\u00adger is just \nanother interpreter it can be passed in at any level of interpretation. As such it can be used not only \ndebug a user program, but also the interpreter running it. Naturally this allows for the debugger to \ndebug itself.  4.2 Alias Interpreter As second use case we show how to implement Object Flow Analysis \n[27] in PINOCCHIO. Object Flow Analysis is a dy\u00adnamic analysis that tracks the transfer of object references \nat runtime. It has been employed for various reverse engineer\u00ading approaches and for the implementation \nof an ef.cient back-in-time debugger [28]. The problem tackled by Object Flow Analysis is the fact that \nin code with assignments it is hard to track where a certain value comes from. A debugger only shows \nthe cur\u00adrent call stack and hence often does not reveal the context in which a .eld was assigned. While \nexecution traces show ex\u00adactly how the interpreter goes through the code they do not show how the values \nare stored and retrieved. For example, to understand where a certain value of an instance variable comes \nfrom, we need to look at all the source code that might have triggered a store. In an alias interpreter \n(the back-end used by Object Flow Analysis) object references are repre\u00adsented by real objects on the \nheap. These objects, referred to as aliases, keep track of the origin of each reference in memory. To \nknow where each value comes from the alias inter\u00adpreter alters the semantics of the interactions so that \nit gen\u00aderates aliases for: allocation of objects and their instance variables,  reading and writing \nof .elds,  passing of arguments,  returning of return values, and  evaluation of literals (constants). \n Rather than directly passing around actual values, in the interpreter objects are wrapped into alias \nobjects. We chose Object Flow Analysis as second use case be\u00adcause it requires deep changes in the interpreter \nand its ob\u00adject model. This case lets us evaluate how .exible our ap\u00adproach is for extending low-level \ndetails of the runtime and how much less effort is required to realise these changes compared to the \noriginal implementation. An Alias Example Suppose we have a class Person with one instance variable name \nand simple accessors for name, consider for example the following code: testMethod t AliasInterpreter \ninterpret: [ |person| person := Person new. person name: John . person name: Doe . person ]. In this \nexcerpt, the block is evaluated in the context of an alias interpreter. All the values used by the alias \ninterpreter are aliased. When the result is returned from the alias inter\u00adpreter it is not unwrapped \nso we can inspect the aliasing in the instance. The resulting alias graph, as shown in Figure 4, contains \nthe following information: return2 := self testMethod. self assert: (return2 isKindOf: ReturnAlias). \nself assert: (return2 environment selector = #testMethod ). person := return2 value. self assert: (person \nisKindOf: Person). return1 := return2 origin. self assert: (return1 isKindOf: ReturnAlias). self assert: \n(return1 environment selector = #new ). fieldWrite2 := person name. self assert: (fieldWrite2 self \nassert: (fieldWrite2 fieldWrite1 := fieldWrite2 self assert: (fieldWrite1 self assert: (fieldWrite1 \n allocation1 := fieldWrite1 self assert: (allocation1 isKindOf: FieldWriteAlias). value = Doe ). predecessor. \nisKindOf: FieldWriteAlias). value = John ). predecessor. isKindOf: AllocationAlias). parameter1 := fieldWrite1 \norigin. self assert: (parameter1 isKindOf: ParameterAlias). self assert: (parameter1 value = John ). \n  Figure 4. Alias Graph (origin denotes where an alias comes from, predecessor of a .eld write alias \nis the alias that was previously stored in this .eld) literal1 := parameter1 origin. self assert: (literal1 \nisKindOf: LiteralAlias). self assert: (literal1 value = John ). parameter2 := fieldWrite2 origin. self \nassert: (parameter2 isKindOf: ParameterAlias). self assert: (parameter2 value = Doe ). literal2 := parameter2 \norigin. self assert: (literal2 isKindOf: LiteralAlias). self assert: (literal2 value = Doe ). All the \ngathered information can be used by a debugger to provide means to navigate through the tracked .ow of \nobjects. This can easily be used to track for example where null-pointers come from, since all objects \nare accounted for by aliases. Linguistic Symbiosis To track aliasing the interpreter wraps all objects \ninto alias objects. This makes the object model of the alias interpreter differ signi.cantly from the \ndefault interpreter. PINOCCHIO s object model provides structural re.ection similar to that of Smalltalk. \nThis feature is a requirement for symbiotic re.ection [18, 43]: applications have to be able to start \na new interpreter and pass themselves as applications. The new interpreter starts by running at the base-level \nof the application, but as the application passes itself to the new interpreter it becomes part of the \nmeta-level of the application. The new interpreter makes use of base-level structural re.ection to interpret \nthe code of the application. Symbiotic re.ection is typically used when the language of the meta-level \ndiffers from that of the base-level, for example, when Java is used to interpret a dynamic language. \nObjects from the meta-level (e.g., Java) typically need to be wrapped before they can be used at the \nbase-level, and unwrapped to be manipulated at the meta-level. This process is known, respectively, as \nupping and downing. In PINOCCHIO the base-and the meta-languages gen\u00aderally differ only in limited ways \nat the meta-level leav\u00ading most of the base-level semantics unaltered. This allows many of the user-de.ned \ninterpreters to let objects .ow freely from the meta-level to the base-level and back, trans\u00adferring \nor sharing ownership of the same object without any wrapping or unwrapping. This is the case for the \ndebugger in the previous section. In case that the base-and meta-levels of a PINOCCHIO interpreter diverge \nsigni.cantly however, it is entirely up to the interpreter to correctly realize the required upping and \ndowning. The alias interpreter is such an example. Rather than directly passing objects from the meta-level \nto the base\u00adlevel, all objects passed around in the alias interpreter have to be wrapped into alias objects. \nWhen the base-level appli\u00adcation performs native actions on aliased objects they .rst need to be unwrapped \nby the interpreter. Aliasing in PINOCCHIO The implementation of an alias interpreter using PINOCCHIO \nis fairly straightforward. First all interpreter methods that are related to one of the tracked actions \n(object allocation, reading and writing of .elds, pass\u00ading as argument, evaluation of literals (constants) \nand return\u00ading from method) are overridden to generate the aliases. For example, the method that interprets \nmethods is overridden so that it returns a ReturnAlias instance wrapped around the result: interpretMethod: \naMethod | result | result := super interpretMethod: aMethod. t (ReturnAlias alias: result) environment: \nenvironment. Notice that the actual semantics of the interpretation of methods is just inherited from \nthe standard interpreter. All methods that need the actual values inside the aliases are overridden to \n.rst unwrap the aliases. Aside from meth\u00adods related to the evaluation of natives, all interpreter meth\u00adods \nonly need the value of the current self. This is shown in the following method that is invoked by the \ninterpreter whenever it evaluates an assignment to a slot. It assigns the actual value to the slot of \nthe current self by .rst unwrap\u00adping the aliased self and then wrapping the value in a FieldWriteAlias: \nassignSlot: aSlot to: anAlias | alias unwrappedSelf | unwrappedSelf := self currentSelf value. alias \n:= (FieldWriteAlias alias: anAlias) environment: environment. alias predecessor: (aSlot readFrom: unwrappedSelf). \nt aSlot assign: alias on: unwrappedSelf The alias interpreter uses a different object model for the base-level \nthan for the meta-level. As explained in the previ\u00adous paragraph this requires the alias interpreter \nto realize the upping and downing by itself. Every time an object moves from the meta-level to the base-level \nit needs to be wrapped to look like the other objects in the runtime (like aliases, in this case). There \nare two places where objects potentially .ow from the meta-level to the base-level. The .rst is the initial \nclosure passed to the interpreter. The closure is linked to an environ\u00adment that contains objects possibly \nreferred to by the code of the closure. Rather than directly sending value to the closure, we .rst have \nto pre-process it: interpret: aClosure t self send: (Message new selector: #value ) to: aClosure asAliased \nThe asAliased message will deep-clone the closure, and wrap the closure as well as all the values referred \nto by its environment into allocation aliases. We use allocation aliases since we are unsure of the origin \nof the objects. As it is the initial state of the alias interpreter, from the perspective of the alias \ninterpreter it is as if the objects were allocated at that point in time. This indicates that users of \ninterpreters that rely on a modi.ed object model have to be careful not to pass a closure along that \nhas references to huge object graphs or ensure that deep-cloning is not required by the interpreter. \nThe second place where objects .ow from the base-level to the meta-level and back is the evaluation of \nnatives. To support the interpretation of natives, the original alias inter\u00adpreter overrides most of \nthe supported methods and performs the correct action. Since not all natives have the same se\u00admantics, \nno single implementation can properly support the evaluation of all of them. To complete our implementation \nwe would also have to provide new implementations for the subset of operations we support. For this experiment, \nhow\u00adever, we limited ourselves to the general solution that works for most examples. Whenever a native \nis called the receiver as well as the arguments are downed and passed to the imple\u00admentation of the meta-interpreter. \nThe result returned from this native is upped by wrapping it into an allocation alias and passed to the \napplication. Evaluation The original Object Flow Analysis has been implemented by directly extending \nthe Pharo VM [3]. It required changes of a large amount of the VM code and took several weeks to implement. \nThe PINOCCHIO versiononthe other hand was implemented in less than one day. It is spread over 20 methods \nand 12 alias data classes. One of the main ideas behind the alias interpreter is that it allocates the \naliases on the heap so they are automatically garbage collected when their state becomes irrelevant to \nthe state of the application. Because the extension is at the VM level new objects have to be manually \ninstantiated at that level. Since referring to speci.c Smalltalk classes is cumber\u00adsome from within the \ninterpreter, the original interpreter just provides one class .tting all types of aliases. This class \nhas a special .eld designated to indicate the actual alias type. In PINOCCHIO, the alias interpreter \nis implemented in a stan\u00addard Smalltalk environment. This allows the programmer to rely on the full expressiveness \nof the language: all aliases are instances of classes representing their speci.c type. Since PINOCCHIO \ninterpreters absorb garbage collection from the main runtime it is also automatically used for collecting \nthe aliases. In contrast to the original alias debugger the PINOCCHIO version is fully hosted within \nthe language itself. This allows us to use the standard tools for implementing, and more im\u00adportantly, \nfor debugging the alias interpreter. Now that the alias interpreter is functional new tools or even alias \ninter\u00adpreters can be debugged using the current alias interpreter. This is not possible in the original \nSmalltalk version, since their alias interpreter extensions are written in C, and are thus not subject \nto the (modi.ed) Smalltalk interpreter.  4.3 Recursive Interpreters Behavioral re.ection in Smalltalk \nentails manipulation of the (rei.ed) runtime stack. In Smalltalk-80, the state of the computation is \nfully captured by the runtime stack. As a con\u00adsequence, the Smalltalk bytecode interpreter does not need \nto keep track of any control .ow itself and automatically adapts to re.ective changes to the runtime \nstack. The dis\u00adadvantage of this approach is that to be able to adapt to such re.ective changes easily, \nthe evaluation of the interpreter is completely decoupled from the evaluation of the application. Not \nonly must bytecodes explicitly manipulate the stack, but code that passes control from the meta-level \nto the base-level must be ripped into event handlers that can run to comple\u00adtion without blocking [2]. \nSince base-level code in Small\u00adtalk-80 can make arbitrary changes to the runtime stack, the bytecode \ninterpreter must be prepared to resume execution in any arbitrary context. If the interpreter wants to \nkeep track of state related to the evaluation of the application other than what is available in the \nstandard stack frames it also has to manually keep track of this data and keep it in sync with the application \ns execution. PINOCCHIO s use of .rst-class interpreters with auto\u00admatic stack management [2] greatly \nsimpli.es the expres\u00adsion of behavioral re.ection. Code that passes control from the meta-level to the \nbase-level can be straightforwardly im\u00adplemented by relying on recursive calls. PINOCCHIO inter\u00adpreters \ncan simply rely on recursion to keep track of any state related to the application s control .ow just \nlike any other Smalltalk application. The disadvantage of this approach is that it becomes im\u00adpossible \nto directly perform operations normally requiring explicit stack manipulations since there is no explicit \nstack. We identify two types of direct stack manipulation in Small\u00adtalk: applications need to be able \nto (i) capture a certain state of the stack and later restore it, and (ii) capture a stack and pass it \nto another program, a meta-circular interpreter, for re.ective evaluation of the application. In this \nsection we show that PINOCCHIO supports these two requirements re\u00adspectively through .rst-class continuations \n[9] and modi.\u00adable .rst-class interpreters.  Parallel Debugging An example of a situation where a user \nwould like to capture and restore the state of a stack is a parallel debugger. Unlike the normal debugger, \nwhich only evaluates one block at a time this special kind of debugger takes two blocks and interprets \nthem in parallel comparing the state of evaluation at each step. Consider the following failing test \ncase that we encoun\u00adtered during the development of PINOCCHIO: dict := SetBucket new. dict at: #key put: \nvalue . self assert: (dict includes: #key ). self assert: (dict includes: key ). The second assertion \n(last line) fails. This test was docu\u00admenting a bug that we had dif.culties to track down. Sym\u00adbols and \nstrings are considered equal ( #key = key )in Smalltalk and hence the second assertion should pass too. \nUsing the basic debugger described in subsection 4.1 to .nd the difference in execution of the two assertions \nis cum\u00adbersome. The manual approach would be to launch a sepa\u00adrate debugger for each of the assertions \nand step through the code until the states of the tests differ. Since we had dif.culties tracking down \nthe root cause of this bug we implemented a specialized debugger that we call parallel debugger. The \nuse of the parallel debugger for the previously mentioned test case looks as follows: ParallelDebugger \ninterpret: (Array with: [ dict includes: #key ] with: [ dict includes: key ]) The debugger runs the \ngiven blocks in parallel up to the point where the executions start to differ: SetBucket>>#includes: \nSetBucket>>#do: SmallInt(1)>>#to:do: BlockClosure>>#whileTrue: SmallInt(1)>>#<= SmallInt(1)>>#> --> \nfalse false>>#not --> true true>>#ifTrue: SetBucket>>#at: --> # key Symbol(# key )>>#== 1) (# key )--> \ntrue 2) ( key ) --> false Listing 1. Parallel debugger trace Looking at this trace immediately reveals \nthat both traces differ upon a strict equality check on a symbol. In the .rst case the comparison returns \ntrue, in the second case false. SetBucket incorrectly uses == (pointer equality) rather than = to compare \nkeys, rendering strings and sym\u00adbols distinct. The parallel debugger provides the minimal Figure 5. Thread-based \nparallel execution of two code parts in the parallel debugger. output needed to quickly identify the \nroot cause of the prob\u00adlem. To implement the parallel debugger we need to be able to evaluate multiple \nclosures at once. In an interpreter with manual stack management this is straightforward. Rather than \ninterpreting the code of one interpreter in a loop, one lets all interpreters do one step of evaluation \nbefore com\u00adparing their states. PINOCCHIO however relies on automatic stack management and thus relies \non recursion to evaluate the closures. This implies that the parallel debugger needs to be able to jump \nout of, and back into a certain recursion state. This problem is similar to implementing coroutines in \na recursive language. The only difference is that the paral\u00adlel debugger itself handles thread-switching \nbefore and after each message send. Coroutines and threads can easily be ac\u00adcommodated in recursive languages \nthrough the use of .rst\u00adclass continuations [20]. Just like the debugger described in subsection 4.1, \nthe parallel debugger is built as a subclass of the stepping in\u00adterpreter. The main difference is that \nthe stepping block is not used to control a single execution trace but to handle the interleaved execution \nof the given number of closures. Be\u00adfore and after each message send we store the state of the current \ngreen thread by capturing its continuation and the application s environment, and resume the next thread \nby restoring its application s environment continuing its con\u00adtinuation. Whenever we resume the .rst \nthread we compare the state of all the routines and continue with the .rst thread. The parallel debugger, \nlike the serial debugger presented in Section 3, directly reuses the object model of the under\u00adlying \nbase-level interpreter. As a consequence, no upping or downing is required, and objects can freely .ow \nbetween the base-and meta-levels. Even though interpreters are de.ned recursively as AST visitors, this \nposes no problem for expressing non-local .ow of control. Threads are easily simulated by capturing the \nneeded continuations and explicitly transferring control when needed. The parallel debugger is only possible \ndue to the support for continuations in PINOCCHIO. Without con\u00adtinuations we could not switch between \nthe execution of multiple closures. It would only be possible to continue the execution of the next closure \nfrom inside the current one. Runtime Modi.able Interpreters Meta-circular interpre\u00adters such as the Smalltalk \ndebugger are a second type of application that require direct access to an explicit stack. The Smalltalk \ninterpreter can pass control over the evalu\u00adation of an application to a debugger by passing its run\u00adtime \nstack to the debugger. The Smalltalk debugger how\u00adever is fully meta-circular and has to manually manage \nthis runtime stack for the evaluation of the application. The ad\u00advantage of this approach is that since \nthe meta-circular as well as the core interpreter are both decoupled from the state of the application \ns stack the meta-circular interpreter is given full control over the evaluation of the application. While \nPINOCCHIO s .rst-class interpreters only have con\u00adtinuous behavioral impact on the evaluation until the \nclosure .nishes, meta-circular interpreters with manual stack man\u00adagement can evaluate the program beyond \nthe continuation where the interpreter was started. This is a useful feature as is obvious from the Smalltalk \ndebugger. Whenever an error occurs, the Smalltalk debugger can take over the evaluation as if it had \nbeen running the application all along, although the core interpreter has mostly executed the program \nup to that point. If in PINOCCHIO we would like to start a new interpreter to change the interpretation \nsemantics, the change would be limited to the scope of the control .ow in which they were activated. \nThis is undesirable for debugging purposes since we would not be able to step through more of the program \nthan the recursion of the message send that caused the error. We rather want to change the semantics \nof an interpreter while it is running. In PINOCCHIO modi.able interpreters are accommo\u00addated by letting \nthe user specify which parts of an inter\u00adpreter are mutable. The stepping interpreter discussed in subsection \n4.1 is an example of an interpreter whose se\u00admantics can partly be modi.ed while it is running. Its stepBlock \nin.uencing the semantics of message sends is orthogonal to the control .ow of the application, leav\u00ading \nit unaffected by the interpreter exiting the control .ow where the stepBlock was installed. The semantics \nof the stepBlock is only bound to the scope in which its host interpreter is active. The following example \nis an extension method to the debugger described in subsection 4.1. It temporarily replaces the current \nstepping semantics for the duration of a variable number of message sends. It allows a user to specify \na speci.c number of steps to be skipped. skipBlock: count |skips previousBlock| skips := 0. previousBlock \n:= self stepBlock. t [ :receiver :class :message :action | skips := skips + 1. (skips >= count) ifTrue \n:[ self stepBlock: previousBlock ]. self executeAction: action ]. For the duration of the given number \nof message sends the user is not prompted concerning the evaluation. Once the steps are over, control \nis returned to the previously active stepping style. The skipBlock: method is a clear example of how \nthe stepBlock can be used to apply changes that potentially surpass the control .ow in which they were \nactivated. Even if the number of skipped steps is larger than the number of steps needed for the application-level \nrecursive call before which the block was installed, the block will stay active until the requested number \nof steps are over.  5. Performance The current implementation of the PINOCCHIO interpreter1 is only \nslightly optimized, but most optimization opportuni\u00adties are left open. The interpreter only implements \nthe evalu\u00adation of constants, variables, instance variables, assignment, closures and message sends with \nmonomorphic inline caches [21]. All boolean operations for example are implemented in high-level Smalltalk \nstyle as message sends to boolean objects with closures as arguments. None of these messages are currently \noptimized away by the compiler. Figure 6 com\u00adpares PINOCCHIO to other high-level language VMs in terms \nof message sends by running a Fibonacci benchmark. The results are presented relative to the speed of \nthe standard implementation of Fibonacci in Pharo 3.10-3. Since most of the other VMs have dedicated \nsupport for conditionals we created a second Fibonacci test (marked with all sends in Figure 6) enforcing \nmessage sends even for condition\u00adals. Since Python prohibits the addition of new behavior to built-in \ntypes we were unable to modify the benchmark ac\u00adcordingly. With this test we provide a fair comparison \nto the current implementation of PINOCCHIO which does not yet feature any of these optimizations. Based \non this test PINOCCHIO is slightly faster than Ruby 1.9 (with all mes\u00adsage sends) and magnitudes faster \nthan the older Ruby 1.8.7. 1 Revision r1397, http://pinocchio.unibe.ch/svn/pinocchio  Python 2.6.4 \n3.0 Ruby 1.8.7 14.8 Ruby 1.8.7 all sends 401.5 Ruby 1.9 1.4 Ruby 1.9 all sends 21.7 Pharo 3.10-3 1.0 \nPharo 3.10-3 all sends 7.9 Pinocchio 14.2 Pinocchio meta-circular 2516.8 Figure 6. Fibonacci benchmark \ntesting the speed of mes\u00adsage sends. Values are given relative to Pharo 3.10-3. Every added level of \ninterpretation in PINOCCHIO causes a constant overhead. Our Interpreter class should have the same speed \nas the C interpreter since it is a direct rei.\u00adcation of the C interpreter without any changed semantics. \nAt this time, however, this interpreter is still mostly meta\u00adcircular making it around 160 times slower \nthan the C inter\u00adpreter since all application-level actions including constant evaluation require at \nleast 3 message sends. Where the C interpreter performs 89 messages to calculate the sixth Fi\u00adbonacci \nnumber, the meta-circular interpreter internally per\u00adforms 9, 665 message sends to perform those 89 sends, \nthat is, around 108 times more message sends. 5.1 Inline Caching The overhead of the meta-circular interpreter \ncan be amor\u00adtized by linking all interpretation methods back to the C code. This would make the meta-circular \ninterpreter exactly as fast as the C interpreter. To let custom interpreters ben\u00ade.t from the same speedup \nthe C-level interpretation code should only meta-circularly evaluate the custom extensions to the interpreter. \nThe C-level interpreter can be made aware of such extensions by using C-level polymorphic inline caches \nat rei.ed functions that map classes of interpreters to their concrete implementation of the rei.ed method. \nIf the method is not overridden, the C-level interpreter continues evaluation at the C-level. Only when \na custom implemen\u00adtation is provided is the interpreter popped from the meta\u00adcontinuation and reactivated. \nThis limits the interpretation overhead of custom interpreters to their custom features. The stepping \ninterpreter for example needs 10, 995 mes\u00adsage sends to evaluate the sixth Fibonacci number. This is \n1, 330 sends more than the normal meta-circular interpreter, or 15 message sends per application-level \nmessage send. The number of extra message sends is not surprising given that even all boolean operations \nare currently imple\u00admented as message sends. General language optimizations such as avoiding message \nsends whenever possible dramat\u00adically decreases the number of sends on both the appli\u00adcation level as \nwell as the interpreter level. The message ifTrue:ifFalse: in combination with value sent to the closure \naccounts for 30 of the 89 application-level messages. In most Smalltalk implementations these messages \nare opti\u00admized away, thus already removing 34% of the steps. The same is true for the messages used in \nthe implementation of the stepping interpreter itself. 5.2 JIT Compilation Unlike the core interpreter, \nPINOCCHIO s interpreter exten\u00adsions are interpreted. It is interesting to look into dynamic optimization \ntechniques that can combine compiled versions of the extensions with the native version of the interpreter \ninto one fast customized interpreter. One can imagine running a JIT compiling interpreter that is hosting \nanother instance of the same class. This second in\u00adterpreter then runs the application. The .rst interpreter \nwill turn all extension methods of the second into native methods that are embedded into the native interpreter \nde.nition. This makes the second interpreter a native JIT compiling inter\u00adpreter. This interpreter would \nthen evaluate the actual appli\u00adcation and JIT compile the relevant parts. Customized interpreters would \nhowever not be able to directly bene.t from JIT compilation of the application. All the custom interpreters \nwould have to provide their own JIT compiler plug-ins so that the embedded semantics are correct. This \nwould call for another type of JIT strategy. Bolz et al. propose JIT compilation of the meta-level [5]. \nIn their approach, the meta-interpreter applies a tracing JIT to the interpreter between looping constructs \nof the interpreter de.nition. This automatically embeds the semantics of the interpreter into the application, \nsince the meta-interpreter is evaluating both at once.  6. Related Work We summarize several of the \nkey approaches to re.ection and elaborate the differences to PINOCCHIO. 6.1 AOP Aspect-Oriented Programming \n(AOP) [26] targets modular\u00adization of crosscutting concerns. It consists of two main parts, a set of \nadvices that change the behavior of programs and a pointcut language that declaratively de.nes where \nthe aspect system has to weave in the advices. The power of AOP mainly comes from the pointcut lan\u00adguage \nthat makes the way shadow points are selected for lo\u00adcal modi.cations easier and more understandable \nby being declarative. Since re.ection provides support for changing the struc\u00adture and behavior of programs, \nAOP can be seen as a princi\u00adpled, structured, and language-supported way of doing meta\u00adand re.ective \nprogramming [34]. AOP can be implemented by providing a pointcut language as a declarative front-end \nto re.ection [38]. The main difference between PINOCCHIO and AOP is that AOP is designed towards discrete \nre.ection while PINOCCHIO handles continuous re.ection.  6.2 Partial Behavioral Re.ection During a \nworkshop on re.ection Smith mentioned that in the wide spectrum of re.ective applications most applica\u00adtions \nonly need a fragment of the information that can be provided by the interpreter [22]. Since rei.cation \nof infor\u00admation is expensive due to wrapping into special objects, partial behavioral re.ection tries \nto limit the number of rei\u00ad.ed objects and message sends needed during the execution of a program. Partial \nbehavioral re.ection provides a re.ective model that enables local extensions to the code by attaching \nme\u00adtaobjects to operations through links. A link conditionally lets the metaobject decide over the evaluation \nof the opera\u00adtion that activated the link [40]. In the original model links are installed in the code \nat class-loading time. Unanticipated partial behavioral re.ection extended the model by allowing dynamic \ninstallation and retraction of links [35]. The model was also further re.ned to hook into the high-level \nAST rep\u00adresentations of the code rather than low-level bytecodes [10]. Both partial behavioral re.ection \nand AOP essentially ap\u00adply structural intercession to the base-level code: they do not alter the evaluation \nof the base-level code but rather change the code to incorporate the new behavior. The developers of \nAspectJ even take pains to distinguish the implementation of AspectJ from classical computational re.ection \n[26]. As explained in subsection 3.3, PINOCCHIO s .rst-class interpreters and partial behavioral re.ection \nare not mutually exclusive, on the contrary. Whenever a re.ective change only locally affects code the \nchange should only have a local overhead. PINOCCHIO does however cleanly solve problems that arise in \npure partial behavioral re.ection by avoiding meta-confusion in the .rst place and by providing a model \nfor global modi.cations. 6.3 Generating Interpreters Douance et al. [14] state it is useful to build \nnew interpreters that embed new re.ective capabilities in an effort to opti\u00admize the amount of information \nthat is actually rei.ed. They propose to implement speci.c changes by modifying a meta\u00adcircular interpreter \nthat is compiled to a new interpreter for each speci.c metaobject protocol. The idea of generating real-world \nVMs from meta\u00adcircular de.nitions has been explored to a greater extent in several projects [4, 23, 41]. \nThey split their energy into build\u00ading a meta-circular VM and building a compiler toolchain that can \noptimize the high-level meta-circular interpreter to be at least as fast as (and potentially faster than) \na manually written interpreter. The difference in the various projects lies in the language being implemented \nby the VM, and more importantly the expressiveness of the actual subset of the language used in the de.nition \nof the meta-circular VM. While this approach provides programmers with the abil\u00adity to change a high-level \nversion of the interpreter to incor\u00adporate new language features, these changes have to be ap\u00adplied at \ncompile-time. The semantics of the resulting inter\u00adpreter cannot be changed anymore from within applications \nrunning on them. This again results in multiple interpreter sources and applications are unable to use \ndifferent versions of the interpreter for different subparts of the applications. The expressiveness \nof the language accepted by the compiler has a great impact on the ease of development. Since also for \nPINOCCHIO a .rst interpreter that rei.es itself needs to be bootstrapped, the technique of compil\u00ading \nmeta-circular interpreters to standalone optimized in\u00adterpreters could be reused. In PINOCCHIO however \nall ex\u00adtensions to the interpreter are applied at runtime, avoid\u00ading the problems exhibited by the compile-time \nmodi.ca\u00adtion approaches. Modi.cations are easily implemented and tested through use of the complete expressiveness \nof the host-language. The modi.cations can be used in combina\u00adtion with other custom interpreters since \nthey live in different subparts of the same runtime. This setup does have impli\u00adcations on the direct \nperformance of the extensions, which are hopefully alleviated by the optimizations discussed in Section \n5.  6.4 Meta-circular Interpreters Meta-circular interpreters [1] such as the Smalltalk debugger and \nall uncompiled versions of the interpreters described in subsection 6.3 are a way of easily allowing \nchanges to the semantics of a language at runtime from within the language itself. They generally reify \na subset of features from the host\u00adlanguage, and absorb the complementary set of features. The .rst problem \nwith meta-circular interpreters is that to modify their semantics one generally needs to directly modify \nthe source code. No extension mechanisms are pro\u00advided by the interpreters themselves. PINOCCHIO on the \nother hand provides a clear protocol for extension through subclassing. The second problem is that meta-circular \ninterpreters im\u00adpose a large runtime overhead in comparison with standard interpreters. This problems \nis partly solved by compilation of the full interpreter, as discussed in subsection 6.3, but this results \nin a compile-time rather than runtime change, result\u00ading in immutable interpretation semantics at runtime. \nWhile in the current implementation of PINOCCHIO the Interpreter class is still mostly meta-circular \na clear strat\u00adegy of how performance can be greatly increased has been outlined. We explained how to \nrely as much as possible on the existing C-level interpreter, essentially removing the meta-circular \nlayer for all code except for the custom inter\u00adpreter extensions. Then we explained how these extensions \nto the interpreter can also be optimized at runtime through JIT compilation.  6.5 Tower Approach to \nFirst-Class Interpreters Of all re.ective interpreters, PINOCCHIO is most similar to the model proposed \nby Simmons et al. in their prototype Refci [36]. Just like PINOCCHIO, Refci provides access to .rst-class \nextensible interpreters. Rather than starting new extended interpreters the model proposed by Refci follows \nthe interpreter-model of re.ection. In Refci interpreters are extended at runtime with new features. \n The interface provided by PINOCCHIO for the extension of interpreters is much more .ne-grained and \npractical. Our interpreters follow the standard object-oriented extension strategy of subclassing. An \nadvantage of a more .ne-grained extension protocol is that smaller changes to the semantics can be more \neasily scoped without impacting the perfor\u00admance of the natively provided system. In Refci all code has \nto go through all extension points before ending up in the native code that handles it, even if no extensions \nto the semantics of that particular node were planned by the inter\u00adpreter extension in question. Unlike \nRefci interpreters, PINOCCHIO s interpreters are not tail-recursive continuation passing interpreters \n(by de\u00adfault). Instead they are normal recursive interpreters that rely on the continuation of the interpreter \nbelow to maintain its continuation. This greatly simpli.es the .nal de.nition of the actual interpreter \nsince control .ow is handled implicitly. It however does not restrict the power of the interpreter since \ncontinuations can be captured and restored. In Refci such an implementation would be unpractical since \ntail-recursion is used to ensure that the theoretically in.nite tower of inter\u00adpreters can be cut off \nto a .nite stack of actually running interpreters and an in.nite meta-continuation of waiting in\u00adterpreters. \nIn Section 4.3 we showed how PINOCCHIO interpreters can be made modi.able just like Refci s interpreters. \nIn PINOCCHIO the .rst-class interpreters themselves can de\u00adcide what is made modi.able while in the case \nof Refci the extensions themselves are in control. The modi.cations ap\u00adplied to an interpreter in PINOCCHIO \ncan have further extent than the recursion in which it was created. In Refci this no\u00adtion of extended \ncontinuations was merely noted as future work. Refci provides no model to share extensions between different \ninterpreters in the stack. Duplicate changes need to be installed manually in the levels where they are \nrequired. In PINOCCHIO subclassing takes care of the sharing of code. Since in PINOCCHIO interpreters \nare manually stacked these interpreters can be instances of the same interpreter thus automatically sharing \nextensions. No effort was made to outline how Refci can be made into a practical runtime. Since all interpreters \nin Refci are meta-circular it thus suffers from the problems explained in subsection 6.4.  6.6 Dealing \nwith In.nity Brown [42] is an extension of 3-Lisp that .rst introduced the meta-continuation as an explicit \nrepresentation of the in.-Figure 7. Finite Scope of the In.nite Tower of Interpreters nite tower of interpreters. \nAs shown in Figure 72,thetheo\u00adretically in.nite tower of interpreters can be implemented as a .nite stack \nof interpreters running on top of a level-shifting processor a non-re.ective processor that is able \nto shift up a level whenever a rei.cation occurs in the application. To stay ef.cient the processor is \nalso able to shift down when\u00adever a level of interpretation is not needed anymore. An ap\u00adplication should \nultimately never run at a level higher than is necessary. Shifting up is implemented in Brown by pop\u00adping \nan interpreter from the meta-continuation, a lazy in.\u00adnite stack of interpreters. Shifting down pushes \nthe unneeded interpreter back onto the meta-continuation. As explained in subsection 3.2, PINOCCHIO uses \nthis technique to minimize its .nite stack of interpreters.  7. Conclusion PINOCCHIO is a runtime for \nSmalltalk based on AST in\u00adterpreters rather than bytecode interpretation. PINOCCHIO eliminates the barrier \nbetween VM and runtime by fully reifying the core interpreter. Instead of providing only a MOP for structural \nre.ection, PINOCCHIO provides behav\u00adioral re.ection by specializing .rst-class interpreters. PINOCCHIO \ninherits its object model from Smalltalk ex\u00adcept for compiled methods which are represented as ASTs rather \nthan bytecode. Objects can freely .ow between base\u00adand meta-levels provided their structural representation \nre\u00admains the same. Otherwise the interpreter is responsible for upping and downing objects between levels. \nInterpreters are de.ned recursively, but have a .ne degree of control over program .ow due to their ability \nto capture and transfer control to .rst-class continuations. Garbage collection, and other native features \nprovided by the core interpreter can be simply reused by specialized interpreters. We have shown through \nseveral examples how behavioral re.ection provided by PINOCCHIO allows sophisticated be\u00adhavioral adaptations \nto be easily implemented. In addition to a serial and a parallel debugger we demonstrated how an alias \ninterpreter, which tracks object .ow for back-in-time debugging, can be easily implemented by a specialized \nin\u00adterpreter. This stands in contrast to a conventional approach 2 We turned the tower upside-down since \nit better matches the mental model that we have of applications and interpreters: applications run on \ntop of interpreters, not the other way around. in Smalltalk which required invasive changes to create \na spe\u00adcialized VM. PINOCCHIO is presently a proof-of-concept prototype. Although the core interpreter \nhas acceptable performance, no serious optimization effort has been undertaken yet. We have outlined \na number of promising tracks that we believe will signi.cantly reduce the overhead introduced by special\u00adizing \nan interpreter.  Acknowledgments We would like to thank Lukas Renggli and Marcus Denker for kindly reviewing \nearlier drafts of our paper. We gratefully acknowledge the .nancial support of the Swiss National Science \nFoundation for the project Bringing Models Closer to Code (SNF Project No. 200020-121594, Oct. 2008 -Sept. \n2010).  References [1] H. Abelson, G. J. Sussman, and J. Sussman. Structure and in\u00adterpretation of computer \nprograms. MIT electrical engineer\u00ading and computer science series. McGraw-Hill, 1991. ISBN 0-262-01077-1. \n[2] A. Adya, J. Howell, M. Theimer, W. J. Bolosky, and J. R. Douceur. Cooperative task management without \nmanual stack management. In ATEC 02: Proceedings of the General Track of the annual conference on USENIX \nAnnual Technical Con\u00adference, pages 289 302, Berkeley, CA, USA, 2002. USENIX Association. ISBN 1-880446-00-6. \n[3] A. Black, S. Ducasse, O. Nierstrasz, D. Pollet, D. Cassou, and M. Denker. Pharo by Example. Square \nBracket Associates, 2009. ISBN 978-3-9523341-4-0. [4] C. F. Bolz and A. Rigo. How to not write virtual \nmachines for dynamic languages. In 3rd Workshop on Dynamic Languages and Applications, 2007. [5] C. F. \nBolz, A. Cuni, M. Fijalkowski, and A. Rigo. Tracing the meta-level: Pypy s tracing jit compiler. In ICOOOLPS \n09: Proceedings of the 4th workshop on the Implemen\u00adtation, Compilation, Optimization of Object-Oriented \nLan\u00adguages and Programming Systems, pages 18 25, New York, NY, USA, 2009. ACM. ISBN 978-1-60558-541-3. \ndoi: 10.1145/1565824.1565827. [6] G. Bracha and D. Ungar. Mirrors: design principles for meta\u00adlevel facilities \nof object-oriented programming languages. In Proceedings of the International Conference on Object-Oriented \nProgramming, Systems, Languages, and Applica\u00adtions (OOPSLA 04), ACM SIGPLAN Notices, pages 331 344, New \nYork, NY, USA, 2004. ACM Press. [7] J. Brant, B. Foote, R. Johnson, and D. Roberts. Wrappers to the rescue. \nIn Proceedings European Conference on Object Oriented Programming (ECOOP 98), volume 1445 of LNCS, pages \n396 417. Springer-Verlag, 1998. [8] S. Chiba, G. Kiczales, and J. Lamping. Avoiding confusion in metacircularity: \nThe meta-helix. In K. Futatsugi and S. Mat\u00adsuoka, editors, Proceedings of ISOTAS 96, volume 1049 of Lecture \nNotes in Computer Science, pages 157 172. Springer, 1996. ISBN 3-540-60954-7. [9] C. T. H. Daniel P. \nFriedman and E. Kohlbecker. Programming with continuations. Technical Report 151, Indiana University, \nNov. 1984. [10] M. Denker. Sub-method Structural and Behavioral Re.ection. PhD thesis, University of \nBern, May 2008. [11] M. Denker, S. Ducasse, A. Lienhard, and P. Marschall. Sub\u00admethod re.ection. In Journal \nof Object Technology, Special Issue. Proceedings of TOOLS Europe 2007, volume 6/9, pages 231 251. ETH, \nOct. 2007. [12] M. Denker, M. Suen, and S. Ducasse. The meta in meta\u00adobject architectures. In Proceedings \nof TOOLS EUROPE 2008, volume 11 of LNBIP, pages 218 237. Springer-Verlag, 2008. doi: 10.1007/978-3-540-69824-1 \n13. [13] T. D Hondt. Are bytecodes an atavism? In Self-Sustaining Systems: First Workshop, S3 2008 Potsdam, \nGer\u00admany, May 15-16, 2008 Revised Selected Papers, pages 140 155. Springer-Verlag, Berlin, Heidelberg, \n2008. ISBN 978-3\u00ad540-89274-8. doi: 10.1007/978-3-540-89275-5 8. [14] R. Douence and M. S\u00a8A generic rei.cation \ntech\u00ad udholt. nique for object-oriented re.ective languages. Higher Order Symbol. Comput., 14(1):7 34, \n2001. ISSN 1388-3690. doi: 10.1023/A:1011549115358. [15] S. Ducasse. Evaluating message passing control \ntechniques in Smalltalk. Journal of Object-Oriented Programming (JOOP), 12(6):39 44, June 1999. [16] \nB. Ford. Parsing expression grammars: a recognition-based syntactic foundation. In POPL 04: Proceedings \nof the 31st ACM SIGPLAN-SIGACT symposium on Principles of pro\u00adgramming languages, pages 111 122, New \nYork, NY, USA, 2004. ACM. ISBN 1-58113-729-X. doi: 10.1145/964001. 964011. [17] A. Goldberg and D. Robson. \nSmalltalk 80: the Language and its Implementation. Addison Wesley, Reading, Mass., May 1983. ISBN 0-201-13688-0. \n[18] K. Gybels, R. Wuyts, S. Ducasse, and M. D Hondt. Inter\u00adlanguage re.ection a conceptual model and \nits implemen\u00adtation. Journal of Computer Languages, Systems and Struc\u00adtures, 32(2-3):109 124, July 2006. \ndoi: 10.1016/j.cl.2005.10. 003. [19] T. Harris and K. Fraser. Language support for lightweight transactions. \nIn Object-Oriented Programming, Systems, Lan\u00adguages, and Applications, pages 388 402. ACM Press, New \nYork, NY, USA, Oct. 2003. doi: 10.1145/949305.949340. [20] C. T. Haynes, D. P. Friedman, and M. Wand. \nContinuations and coroutines. In LFP 84: Proceedings of the 1984 ACM Symposium on LISP and functional \nprogramming, pages 293 298, New York, NY, USA, 1984. ACM. ISBN 0-89791-142-3. doi: 10.1145/800055.802046. \n[21] U. H\u00a8olzle, C. Chambers, and D. Ungar. Optimizing dynamically-typed object-oriented languages with \npolymor\u00adphic inline caches. In P. America, editor, Proceedings ECOOP 91, volume 512 of LNCS, pages 21 \n38, Geneva, Switzerland, July 1991. Springer-Verlag. [22] M. H. Ibrahim. Re.ection and metalevel architectures \nin object-oriented programming (workshop session). In OOP-SLA/ECOOP 90: Proceedings of the European conference \n on Object-oriented programming addendum: systems, lan\u00adguages, and applications, pages 73 80, New York, \nNY, USA, 1991. ACM Press. ISBN 0-89791-443-0. [23] D. Ingalls, T. Kaehler, J. Maloney, S. Wallace, and \nA. Kay. Back to the future: The story of Squeak, a practical Smalltalk written in itself. In Proceedings \nof the 12th ACM SIG-PLAN conference on Object-oriented programming, systems, languages, and applications \n(OOPSLA 97), pages 318 326. ACM Press, Nov. 1997. doi: 10.1145/263700.263754. [24] G. Kiczales. Beyond \nthe black box: Open implementation. IEEE Software, Jan. 1996. [25] G. Kiczales, J. des Rivi`eres, and \nD. G. Bobrow. The Art of the Metaobject Protocol. MIT Press, 1991. ISBN 0-262-11158-6. [26] G. Kiczales, \nE. Hilsdale, J. Hugunin, M. Kersten, J. Palm, and W. G. Griswold. An overview of AspectJ. In Proceed\u00adings \nECOOP 2001, number 2072 in LNCS, pages 327 353. Springer Verlag, 2001. [27] A. Lienhard. Dynamic Object \nFlow Analysis. Phd thesis, University of Bern, Dec. 2008. [28] A. Lienhard, T. G irba, and O. Nierstrasz. \nPractical object\u00adoriented back-in-time debugging. In Proceedings of the 22nd European Conference on Object-Oriented \nProgram\u00adming (ECOOP 08), volume 5142 of LNCS, pages 592 615. Springer, 2008. ISBN 978-3-540-70591-8. \ndoi: 10.1007/ 978-3-540-70592-5 25. ECOOP distinguished paper award. [29] P. Maes. Concepts and experiments \nin computational re.ec\u00adtion. In Proceedings OOPSLA 87, ACM SIGPLAN Notices, volume 22, pages 147 155, \nDec. 1987. [30] J. Malenfant, M. Jacques, and F.-N. Demers. A tutorial on behavioral re.ection and its \nimplementation. In Proceedings of Re.ection, pages 1 20, 1996. [31] J. McAffer. A Meta-level Architecture \nfor Prototyping Object Systems. Ph.D. thesis, University of Tokyo, Sept. 1995. [32] J. McAffer. Engineering \nthe meta level. In G. Kiczales, editor, Proceedings of the 1st International Conference on Metalevel \nArchitectures and Re.ection (Re.ection 96), San Francisco, USA, Apr. 1996. [33] L. Renggli, T. G irba, \nand O. Nierstrasz. Embedding languages without breaking tools. In T. D Hondt, editor, Proceedings of \nthe 24th European Conference on Object-Oriented Pro\u00adgramming (ECOOP 10), volume 6183 of LNCS, pages 380 \n404. Springer-Verlag, 2010. ISBN 978-3-642-14106-5. doi: 10.1007/978-3-642-14107-2 19. \u00b4 [34] L. Rodr\u00b4iguez, \nE. Tanter, and J. Noye.\u00b4Supporting dynamic crosscutting with partial behavioral re.ection: a case study. \nIn Proceedings of the XXIV International Conference of the Chilean Computer Science Society (SCCC 2004), \nArica, Chile, Nov. 2004. IEEE. \u00b4partial behavioral re.ection. In Advances in Smalltalk Proceedings of \n14th International Smalltalk Conference (ISC 2006), volume 4406 of LNCS, pages 47 65. Springer, 2007. \nISBN 978-3-540-71835-2. doi: 10.1007/978-3-540-71836-9 [35] D. R\u00a8othlisberger, M. Denker, and E. Tanter. \nUnanticipated 3. [36] J. W. Simmons, S. Jefferson, and D. P. Friedman. Language extension via .rst-class \ninterpreters. Technical Report 362, In\u00addiana University Computer Science Department, Sept. 1992. [37] \nB. C. Smith. Re.ection and Semantics in a Procedural Lan\u00adguage. Ph.D. thesis, MIT, Cambridge, MA, 1982. \n[38] A. Strauss. Dynamic aspects an AOP implementation for Squeak. Master s thesis, University of Bern, \nNov. 2008. \u00b4 Report TR/DCC-2009-13, University of Chile, Nov. 2009. [39] E. Tanter. Re.ection and open \nimplementations. Technical \u00b4 havioral re.ection: Spatial and temporal selection of rei.ca\u00adtion. In Proceedings \nof OOPSLA 03, ACM SIGPLAN Notices, pages 27 46, nov 2003. [40] E.Tanter,J.Noy\u00b4e, D. Caromel, and P. \nCointe. Partial be\u00ad [41] D. Ungar, A. Spitz, and A. Ausch. Constructing a metacircu\u00adlar virtual machine \nin an exploratory programming environ\u00adment. In OOPSLA 05: Companion to the 20th annual ACM SIGPLAN conference \non Object-oriented programming, sys\u00adtems, languages, and applications, pages 11 20, New York, NY, USA, \n2005. ACM. ISBN 1-59593-193-7. doi: 10.1145/ 1094855.1094865. [42] M. Wand and D. Friedman. The Mystery \nof the Tower Re\u00advealed: A Non-Re.ective Description of the Re.ective Tower. In P. M. North-Holland and \nD. Nardi, editors, Meta-level Ar\u00adchitectures and Re.ection, pages 111 134, 1988. [43] R. Wuyts and S. \nDucasse. Symbiotic re.ection between an object-oriented and a logic programming language. In ECOOP 2001 \nInternational Workshop on MultiParadigm Pro\u00adgramming with Object-Oriented Languages, 2001.  \n\t\t\t", "proc_id": "1869459", "abstract": "<p>To support development tools like debuggers, runtime systems need to provide a meta-programming interface to alter their semantics and access internal data. Reflective capabilities are typically fixed by the Virtual Machine (VM). Unanticipated reflective features must either be simulated by complex program transformations, or they require the development of a specially tailored VM. We propose a novel approach to behavioral reflection that eliminates the barrier between applications and the VM by manipulating an explicit tower of first-class interpreters. Pinocchio is a proof-of-concept implementation of our approach which enables radical changes to the interpretation of programs by explicitly instantiating subclasses of the base interpreter. We illustrate the design of Pinocchio through non-trivial examples that extend runtime semantics to support debugging, parallel debugging, and back-in-time object-flow debugging. Although performance is not yet addressed, we also discuss numerous opportunities for optimization, which we believe will lead to a practical approach to behavioral reflection.</p>", "authors": [{"name": "Toon Verwaest", "author_profile_id": "81388601470", "affiliation": "University of Bern, Bern, Switzerland", "person_id": "P2354144", "email_address": "", "orcid_id": ""}, {"name": "Camillo Bruni", "author_profile_id": "81470648839", "affiliation": "University of Bern, Bern, Switzerland", "person_id": "P2354145", "email_address": "", "orcid_id": ""}, {"name": "David Gurtner", "author_profile_id": "81470655336", "affiliation": "University of Bern, Bern, Switzerland", "person_id": "P2354146", "email_address": "", "orcid_id": ""}, {"name": "Adrian Lienhard", "author_profile_id": "81309510569", "affiliation": "University of Bern, Bern, Switzerland", "person_id": "P2354147", "email_address": "", "orcid_id": ""}, {"name": "Oscar Niestrasz", "author_profile_id": "81470653810", "affiliation": "University of Bern, Bern, Switzerland", "person_id": "P2354148", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869522", "year": "2010", "article_id": "1869522", "conference": "OOPSLA", "title": "Pinocchio: bringing reflection to life with first-class interpreters", "url": "http://dl.acm.org/citation.cfm?id=1869522"}