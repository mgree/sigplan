{"article_publication_date": "10-17-2010", "fulltext": "\n Ef.cient Modular Glass Box Software Model Checking Michael Roberson Chandrasekhar Boyapati Electrical \nEngineering and Computer Science Department University of Michigan, Ann Arbor, MI 48109 {roberme, bchandra}@eecs.umich.edu \nAbstract Glass box software model checking incorporates novel tech\u00adniques to identify similarities in \nthe state space of a model checker and safely prune large numbers of redundant states without explicitly \nchecking them. It is signi.cantly more ef\u00ad.cient than other software model checking approaches for checking \ncertain kinds of programs and program properties. This paper presents PIPAL, a system for modular glass \nbox software model checking. Extending glass box software model checking to perform modular checking \nis important to further improve its scalability. It is nontrivial because unlike traditional software \nmodel checkers such asJavaPathFinder (JPF) and CMC, a glass box software model checker does not check \nevery state separately instead, it checks a large setof states togetherin each step.We presenta solution \nand demonstrateP IPAL seffectiveness onavarietyof programs. Categories and Subject Descriptors D.2.4[SoftwareEngi\u00adneering]: \nSoftware/ProgramVeri.cation; D.2.5[Software Engineering]: Testing and Debugging; D.3.1 [Program\u00adming \nLanguages]: Formal De.nitions and Theory; F.3.1 [Logics and Meanings of Programs]: Specifying,Verifying, \nand Reasoning about Programs General Terms Algorithms, Reliability,Veri.cation Keywords Pipal, Software \nModel Checking 1. Introduction Model checking is a formal veri.cation technique that ex\u00adhaustively testsa \ncircuit/program on all possible inputs (usu\u00adally up to a given size) and on all possible nondeterministic \nschedules.For hardware, model checkers have successfully veri.ed fairly complex .nite state control circuits \nwith up toafew hundred bitsof state information;but not circuits in general that have large data paths \nor memories. Similarly, Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page.To copyotherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright c . 2010ACM 978-1-4503-0203-6/10/10...$10.00 \nfor software, model checkershaveprimarilyveri.ed control\u00adoriented programs with respect to temporal properties;but \nnot much work has been done to verify data-oriented pro\u00adgrams with respect to complex data-dependent \nproperties. Thus, while there is much research on software model check\u00aders[1,3 5,7,13,16,21,39,48]andon \nstate space reduction techniques for software model checkers such as partial or\u00adder reduction [15, 16] \nand tools based on predicate abstrac\u00adtion [19] such as Slam [1], Blast [21], or Magic [4], none of these \ntechniques seem to be effective in reducing the state spaceof data-oriented programs.Forexample, predicate \nab\u00adstraction relies on alias analysis that is often too imprecise. In recent previous work [8, 43], we \nintroduced glass box software model checking to address this problem. Our checker incorporates novel \ntechniques to identify similari\u00adties in the state space of a model checker and safely prune large numbers \nof redundant states without explicitly check\u00ading them. Thus, while traditional software model checkers \nsuch as Java PathFinder (JPF) [48] and CMC [39] sepa\u00adrately check every reachable state within a state \nspace, our glassbox checker checksa (usuallyverylarge)setof similar states in each step. This leads to \nseveral orders of magnitude speedups [8] over previous model checking approaches. This paper presents \nPIPAL, a system for modular glass box software model checking, to further improve the scalabil\u00adity of \nglass box software model checking. In a modular checking approach program modules are replaced with ab\u00adstract \nimplementations, which are functionally equivalent but vastly simpli.ed versions of the modules. The \nproblem of checking a program then reduces to two tasks: checking that each program module behaves the \nsame as its abstract implementation, and checking the program with its program modules replaced by their \nabstract implementations [6]. Extending traditional model checking to perform modular checkingistrivial.Forexample,JavaPathFinder \n(JPF)[48] or CMC [39] can check that a program module and an abstract implementation behave the same \non every sequence of inputs (within some .nite bounds) by simply checking every reachable state (within \nthose bounds). However,itis nontrivialtoextendglassbox model checking to perform modular checking, while \nmaintaining the signif\u00adicant performance advantage of glass box model checking over traditional model \nchecking. In particular,it is nontrivial toextendthepreviousworkonglassbox checking[8,43]to check that \na module and an abstract implementation behave the same on every sequence of inputs (within some .nite \nbounds). This is because, unlike traditional model checkers such as JavaPathFinder or CMC, our model \nchecker does not check every reachable state separately. Instead it checks a (usuallyverylarge)setof \nsimilar statesineachsinglestep. This paper presents a technique to solve this problem.  Note that like \nmost model checking techniques [3, 13, 16, 39,48],oursystemPIPAL (ineffect)exhaustively checksall states \nin a state space within some .nite bounds. While this doesnot guaranteethatthe programisbugfree becausethere \ncouldbebugsin larger unchecked states,in practice, almost allbugs areexposedby small program states. \nThis conjec\u00adture, known as the small scope hypothesis, has been experi\u00admentally veri.ed in several domains \n[27, 35, 42]. Thus, ex\u00adhaustively checking all states within some .nite bounds gen\u00aderatesahighdegreeof \ncon.dencethatthe programis correct (with respect to the properties being checked). Compared to PIPAL, \nformal veri.cation techniques that use theorem provers [2, 29, 40] are fully sound. However, these techniques \nrequire signi.cant human effort (in the form of loop invariants or guidance to interactive theorem provers). \nFor example, an unbalanced binary search tree implemented inJavacanbe checked usingPIPALwith less than20 \nlinesof extra Java code, implementing an abstraction function and a representationinvariant.Infact,itis \nconsidereda good pro\u00adgramming practice [34] to write these functions anyway, in which case PIPAL requires \nno extra human effort. However, checking a similar program using a theorem prover such as Coq[2] requires \nmore than 1000 linesofextra humaneffort. Compared to PIPAL, other model checking techniques are more \nautomatic because they do not require abstraction functions and representation invariants. However, P \nIPAL is signi.cantly more ef.cient than other model checkers for checking certain kinds of programs and \nprogram properties. We present PIPAL as a middle ground between automatic model checkers and program \nveri.ers based on theorem provers that require much more extensive human effort. We tested PIPAL on a \nvariety of programs. Our experiments indicate that the modular model checking technique is far more ef.cient \nthan checking programs as a unit. We also comparedPIPAL to Blast[21],JPF[48],andKorat[3]and found thatPIPAL \nis signi.cantly moreef.cient when check\u00ading data-oriented programs and data-dependent properties. The \nrest of this paper is organized as follows. Section2il\u00adlustrates our approach with anexample. Sections3describes \nour modular model checking approach. Section4presentsa formal description. Section5containsexperimental \nresults. Section6discusses relatedwork and Section7concludes. Figure 1. Glass box checkingagainst an \nabstraction.PIPAL checks that the states labeled a2 and a2. are equal. 2. Example Consider checking the \nJava program in Figure 2. This pro\u00adgram tracks the frequencyof integers received by its count method, \nstoring the most frequent in its most frequent i .eld. It internally uses a map data structure, implemented \nas a binary search tree shown in Figure 4. Thus the program has two modules: IntCounter and SearchTree. \nPIPAL s modular approach checks each of these independently. 2.1 Abstraction PIPAL .rst checks SearchTree \nagainst an abstract map implementation, and then uses the abstract map to check IntCounter. The abstract \nmap must implement the Map in\u00adterface, which includes the operations insert and get.(For simplicity, \nthis example omits other Map operations such as delete.) Figure 5 shows an AbstractMap implemen\u00adtation. \nIt stores map entries in an unsorted list and uses a simple linear search algorithm to implement the \nmap oper\u00adations. AbstractMap is not an optimized implementation, but its simplicity makes it ideal as \nan abstraction for ef.cient software model checking. Using AbstractMap in place of SearchTree signi.cantly \nimproves P IPAL s performance. Infact, AbstractMap can be used in place of anydata struc\u00adture that implements \nthe Map interface, including complex data structures such as hash tables and red-black trees. Note that \nAbstractMap usesa construct called PipalList. This is simply a linked list provided by PIPAL that is \nuse\u00adful in manyabstract implementations. Using PipalList en\u00adables PIPAL to arrange the list internally \nto achieve opti\u00admal performance during model checking. From the program\u00admer s perspective, it is just \na linked list data structure.  1 class IntCounter { 2 Map map = new SearchTree(); 3 int max_frequency \n= 0; 4 int most_frequent_i = 0; 5 6 public void count(int i) { 7 Integer frequency = (Integer)map.get(i); \n8 if (frequency == null) frequency = new Integer(0); 9 map.insert(i, new Integer(frequency+1)); 10 11 \nif (frequency >= max_frequency) { 12 max_frequency = frequency; 13 most_frequent_i = i; 14 } 15 } 16 \n17 public int get_most_frequent_i() { 18 return most_frequent_i; 19 } 20 21 public int get_max_frequency() \n{ 22 return max_frequency; 23 } 24 } Figure 2. IntCounter internally using a SearchTree.  2.2 Checking \nthe Abstraction PIPAL checks that SearchTree behaves the same as Ab\u00adstractMap. To do this it (in effect) \nexhaustively checks every valid state of SearchTree within some given .nite bounds against an equivalent \nstate of AbstractMap. Fig\u00adure 1 illustrates how PIPAL checks that SearchTree and AbstractMap have the \nsame behavior.PIPAL runs the same operation on a SearchTree state s1 and its abstraction a1 to obtain \nstates s2 and a2 respectively. PIPAL then checks that (1) the abstraction of s2 is equal to a2, and (2) \nthe re\u00adturnvalues are same.PIPALinvokesthe abstraction function to generate the abstractions of states \ns1 and s2. The abstrac\u00adtion function for SearchTree is in Figure 4. The method for testing equality of \ntwo AbstractMaps is shown in Figure 5. Given a bound of 3 on the height of the tree, Figure 3(a) shows \nsome possible states of SearchTree. PIPAL gener\u00adates states of AbstractMap by calling an abstraction \nfunc\u00adtion. It creates a PipalList and passes it as an argument to the constructor of AbstractMap. PIPAL \nprovides methods for generating PipalLists from several data structures, to make it convenient to implement \nabstraction functions. Be\u00adhind the scenes, PIPAL constructs a list long enough to hold the largest possible \ntree within thegiven bounds. Figure 3(b) shows the resultof generatingafew lists from trees. The list \nnodes in gray correspond to tree nodes that are not reachable. This arrangement facilitates the performance \nof the model checking algorithm described in Section 3. Consider checking an insert operation on state \nt1 in Fig\u00adure 3(a). After the operation, the resulting state is t1 . PI-PAL detects that the insert operation \ntouches only a small number of tree nodes along a tree path. These nodes are highlighted in the .gure. \nThus, if these nodes remain un\u00adchanged, the insert operation will behave similarly (e.g., on trees t2 \nand t3). PIPAL then determines that once it (a) (b)  Figure 3. (3a) Three search trees (code in Figure \n4), before an after an insert operation. The tree path touched by the operation is highlighted in each \ncase. Note that the tree path isthesameinallthree cases.OncePIPALchecksthe insert operation on tree t1, \nit determines that it is redundant to check the same insert operation on trees t2 and t3. (3b) The corresponding \nabstract maps (code in Figure 5). The list nodes in gray correspond to tree nodes that are not reachable. \nchecks the insert operation on tree t1, it is redundant to check the same insert operation on trees t2, \nt3, and the exponentially many trees where the highlighted nodes re\u00admain the same. PIPAL safely prunes \nthose trees from its search space, while still achieving complete coverage within the bounded domain. \nThus, for thisexample,PIPALonlyex\u00adplicitly checks each operation once on each unique tree path rather \nthan each unique tree. This leads to signi.cant reduc\u00adtion in the size of the search space. PIPAL s symbolic \nanal\u00adysis (c.f. Section 3.6) and static analysis (c.f. Section 3.7) techniques ensure that the presence \nof the abstract map does not increase the numberof states that areexplicitly checked.  2.3 Checking \nUsing the Abstraction Once PIPAL establishes that AbstractMap and Search-Tree have the same behavior, \nit uses AbstractMap in\u00adstead of SearchTree to simplify the checking of Int-Counter. For example, consider \nchecking the invariant of IntCounter, that most frequent i and max frequency correspond to the most frequent \ninteger in the map and its frequency, respectively. When checking IntCounter, PIPAL substitutes SearchTree \nwith AbstractMap. Oth\u00aderwise, the checking proceeds as above. PIPAL repeat\u00adedly generates valid states \nof IntCounter (including its AbstractMap), identi.es similar states, checks the similar statesinasinglestep,and \nprunesthemfromits search space.  1 class SearchTree implements Map { 2 static class Node implements \nPipalList.ListNodeSource { 3 int key; 4 Object value; @Tree Node left; 6 @Tree Node right; 7 8 Node(int \nkey, Object value) { 9 this.key = key; this.value = value; 11 } 12 13 AbstractMap.Node abstraction() \n{ 14 return new AbstractMap.Node(key, value); } 16 } 17 18 @Tree Node root; 19 Object get(int key) { \n21 Node n = root; 22 while (n != null) { 23 if (n.key == key) 24 return n.value; else if (key < n.key) \n26 n = n.left; 27 else 28 n = n.right; 29 } return null; 31 } 32 33 void insert(int key, Object value) \n{ 34 Node n = root; Node parent = null; 36 while (n != null) { 37 if (n.key == key) { 38 n.value = value; \n39 return; } else if (key < n.key) { 41 parent = n; 42 n = n.left; 43 }else{ 44 parent = n; n = n.right; \n46 } 47 } 48 49 n = new Node(key, value); if (parent == null) 51 root=n; 52 else if (key < parent.key) \n53 parent.left = n; 54 else parent.right = n; 56 } 57 58 @Declarative 59 boolean repOk() { return isOrdered(root, \nnull, null); 61 } 62 63 @Declarative 64 static boolean isOrdered(Node n, Node low, Node high) { if (n \n== null) return true; 66 if (low != null &#38;&#38; low.key >= n.key) return false; 67 if (high != null \n&#38;&#38; high.key <= n.key) return false; 68 if !(isOrdered(n.left, low, n )) return false; 69 if !(isOrdered(n.right, \nn, high)) return false; return true; 71 } 72 73 AbstractMap abstraction() { 74 return new AbstractMap(Pipal.ListFromTree_BF(root)); \n76 // ListFromTree_BF returns a PipalList corresponding 77 // to a breadth first traversal of the tree. \n78 } 79 } Figure 4. Asimple search tree implementation. 1 class AbstractMap implements Map { 2 static \nclass Node { 3 Object key; 4 Object value; 5 6 Node(Object key, Object value) { 7 this.key = key; 8 this.value \n= value; 9 } 10 11 @Declarative 12 boolean equalTo(Node n) { 13 return n.key.equals(key) &#38;&#38; n.value \n== value; 14 } 15 } 16 17 PipalList list; 18 19 AbstractMap(PipalList l) { 20 list = l; 21 } 22 23 Object \nget(Object key) { 24 PipalList.Node pnode = list.head(); 25 26 while (pnode != null) { 27 Node n = (Node)pnode.data(); \n28 if (n.key.equals(key)) { 29 return n.value; 30 } else { 31 pnode = pnode.next(); 32 } 33 } 34 } 35 \n36 void insert(Object key, Object value) { 37 PipalList.Node pnode = list.head(); 38 39 while (pnode \n!= null) { 40 Node n = (Node)pnode.data(); 41 if (n.key.equals(key)) { 42 n.value = value; 43 return; \n44 } else { 45 pnode = pnode.next; 46 } 47 } 48 49 list.add(new Node(key, value)); 50 } 51 52 @Declarative \n53 public boolean equalTo(AbstractMap m) { 54 return list.equalTo(m.list); 55 } 56 } Figure 5. An abstract \nmap implementation. Using AbstractMap instead of SearchTree has several advantages. First, our state \nspace reduction techniques are more effective on AbstractMap.In Figure3, a1,a2,anda3 are part of a larger \nset of similar states than t1, t2, and t3 (w.r.t. the insert operation). Second, AbstractMap has a smaller \nstate space to begin with. SearchTree encodes the shapeofthetreein additiontokey valuepairs.More com\u00adplex \ndata structures such as red-black trees have even larger state spaces. Third, AbstractMap has a simpler \ninvariant which translates to smaller formulas (c.f. Section 3.9). 3. Approach This section presents \nPIPAL s modular checking approach. Section4containsa formal descriptionof our approach.  Field root \nn0.left n0.right n1.left n1.right n2.left n2.right n0.key n1.key n2.key n3.key n4.key n5.key n6.key n0.value \nn1.value n2.value n3.value n4.value n5.value n6.value method get.key insert.key insert.value Figure 6. \nSearch space for the binary tree in Figure4with tree heightat most3andat most10keysand4 values. 3.1 Speci.cation \nGiven a program module M, programmers must .rst de.ne an abstraction A which is functionally equivalent \nto M but is presumably simpler than M. However, note that an abstrac\u00adtion needs to be de.ned only once \nper interface and can be shared by all program modules that implement the same in\u00adterface.Forexample, \nthe AbstractMap de.ned in Figure5 canbe sharedbyall implementationsofthe Map interface in\u00adcluding those \nthat implement the map using an unbalanced binary tree(asin Figure4), usingabalanced binary tree such \nas a red-black tree, using a hash table, or using a linked list. Every abstraction must also de.ne an \nequalTo method to check if two instances of the abstraction are equivalent. To check a program moduleM \nagainst an abstraction A, pro\u00adgrammers must specify the invariant of M, an abstraction function that \ngiven an instance of M returns an equivalent instance of A, and .nite bounds on the size of instances \nof M.For example, to check the binary search tree implemen\u00adtationinFigure4againstthe abstractmapinFigure5,pro\u00adgrammers \nonly need to specify the representation invariant of the search tree(repOk in Figure 4), the abstraction \nfunc\u00adtion(abstraction in Figure 4), and .nite bounds on the size of the search trees (similarly to [8]). \nPIPAL then checks that within the given bounded domain, the behavior of M is functionally equivalent \nto that of A on every sequence of in\u00adputs. Functional equivalence is de.ned in Section 3.10. Figure7. \nTwoelements of the search space in Figure 6. The .rst element represents insert(3,a) on an ordered tree. \nThe second element represents the same operation,but on an unordered tree.Valuesof unreachable .elds \nare left blank. The current implementationofPIPALchecksJava programs. However, our underlying checking \ntechnique is general and can be used to check programs in other languages as well. Note that in Figures \n4 and 5, the methods repOk and equalTo are annotated as Declarative. Declarative meth\u00adods are described \nin Section 3.9. Declarative methods use only a subset of Java and do not contain side effects. PIPAL \ntranslates declarative methods into boolean formulas for ef\u00ad.cient model checking. P IPAL requires that \nthe repOk and equalTo methods always be declarative. Finally, the Tree annotations in Figure4 denote \nthat the Nodes form a tree, similarly to [8]. Such annotations reduce PIPAL s search space because it \ndoes not have to check non-tree structures.  3.2 Search Space Traditional software model checkers [1, \n4, 7, 16, 21, 39, 48] explore a state space by starting from the initial state and systematically generating \nand checking every successor state. But this approach does not work (c.f. [8, 43]) for software model \ncheckers that use the glass box technique. Instead,PIPAL organizes its search space as follows. Consider \nchecking the binary search tree implementation in Figure4againstthe abstractmapinFigure5.SupposePIPAL \nmust check all trees of tree height at most 3, with at most 10 different possiblekeys and at most4 different \npossible values. The corresponding search space is shown in Figure 6. The tree may haveanyshape within \nits height bound because the pointers between nodes may be null. Every element in this search space represents \nan operation on a binary tree. Figure 7 shows two elements of this search space. root n0 n0.left n1 n0.right \nn2 n1.left n3 n1.right null n2.left null n2.right n6 n0.key 5 n1.key 2 n2.key 7 n3.key 0 n4.key n5.key \nn6.key 9 n0.value a n1.value d n2.value a n3.value b n4.value n5.value n6.value d method insert get.key \ninsert.key 3 insert.value a root n0 n0.left n1 n0.right null n1.left n3 n1.right null n2.left n2.right \nn0.key 6 n1.key 7 n2.key n3.key 4 n4.key n5.key n6.key n0.value b n1.value d n2.value n3.value c n4.value \nn5.value n6.value method insert get.key insert.key 3 insert.value a  1 void search( BoundedSearchSpace \nB ) { 2 S = Set of all valid elements in B 3 while ( S .= . ) { 4 s = Any element in S 5 Check the desired \nproperty on s 6 S. = Elements similar to s 7 Check the property on all elements in S. 8 if ( any s . \n. S. fails the check ) { 9 Print bug trace s . 10 } 11 S = S -S. 12 } 13 } Figure 8. Pseudo-code for \nthe glass box search algorithm. The .rst element represents the operation insert(3,a) on an ordered tree. \nThe second element represents the same operation on an unordered tree, because key 7 in node n1 is greater \nthankey6in node n0. The search space thus may include elements that violate the representation invariant. \n 3.3 Search Algorithm Figure8 presents the pseudo-code for the glass box search algorithm. Given a bounded \nsearch space B PIPAL .rst ini\u00adtializes the search space S to all valid states in B. For ex\u00adample, given \nthe bounded search space B in Figure6,PIPAL .rst initializes the search space S to all states in B on \nwhich repOk returns true. In Lines 3-12, P IPAL iterates until the search space S is exhausted. In each \niteration, it selects an unchecked state s from S and checks the desired property onit.Forexample, when \ncheckingthe binary search treein Figure4againstthe abstractmapinFigure5,Pipal checks that: executing \nthe operation on s preserves its representa\u00adtion invariant, the outputs of executing the operation on \ns and its abstraction are the same, and the abstraction of the .\u00adnal state is equal to the .nal state \nof executing the operation onthe abstraction(c.f.Figure1).InLine6itdiscoversaset S. of states similar \nto s using its dynamic analysis described in Section 3.6. In Line7it checks the entire set of states \nS. using its static analysis described in Section 3.7. If any of the statesfails the check,PIPAL prints \nanexplicitbug trace. Finally,PIPALremoves all the checked states S. from S. The following sections describe \nthe above steps in detail. 3.4 Search Space Representation In the above algorithm, PIPAL performs several \noperations on the search space, including choosing an unchecked ele\u00adment (Line 4 in Figure 8), constructing \na subset (Line 6), checking the subset (Line 7), and pruning the subset from the search space (Line 11). \nConsider checking the binary search treeinFigure4on treeswithatmost n nodes. The size of the search spaceisexponentialin \nn. However,our model check\u00ading algorithm described below completes the search in time polynomial in n. \nThus, if we are not careful and choose an Figure 9. Symbolic and concrete values of the branch conditions \nencountered during the execution of the insert(3,a) operation on the .rst element in Figure 7. The symbolic \nvalues are used to generate the path constraint. Line Symbolic Value of Concrete Value of Branch Condition \nBranch Condition 36 root.=null true 37 n0.key=key false 40 key<n0.key true 36 n0.left.=null true 37 n1.key=key \nfalse 40 key<n1.key false 36 n1.right.=null false 50 false false 52 key<n1.key false explicit representation \nof the search space, then search space management itself would take exponential time and negate the bene.ts \nof our search space reduction techniques. We avoid thisby choosinga compact representation.We repre\u00adsent \nthe search space as a .nite propositional logic formula (boolean formula).We use an incrementalSATsolver \nMini-Sat [14] to perform the various search space operations. For example, consider the search space \nin Figure 6. PIPAL encodes the value of each .eld using .log n. boolean vari\u00adables, where n isthesizeofthe \ndomainofthe .eld.SoPIPAL encodes n0.key with four boolean variables and n1.right with one boolean variable. \nA formula over these bits rep\u00adresentsa setof states.Forexample, the following formula represents the \nset of all trees of height one: root = n0 . n0.left = null . n0.right = null.PIPALinvokes theSATsolvertoprovideasatisfying \nassignmenttothevari\u00adablesofthe formulaandthen decodesitintoa concrete state. Line3in Figure8, checkingifa \nsetis empty, and Line4, choosing an element of a non-empty set, may be expensive operations because they \ninvoke the SAT solver. Line 11 in Figure 8, subtracting one set(S.)from another (the search space S), \ntakes linear time (w.r.t. size of S.)because it only injects clauses (in S.)into the incremental SATsolver. \n 3.5 Search Space Initialization In Line2of Figure8,givena bounded search space B,PIPAL .rst initializes \nthe search space S to the set of all valid states in B.For example, given the bounded search space B \nin Fig\u00adure6,PIPAL.rst initializesthe search space S to all states in B on which repOk returns true. This \nrequires constructing a boolean formula that represents all states that satisfy repOk. PIPAL accomplishes \nthis by translating the repOk method and the all the methods that repOk transitively invokes into sucha \nboolean formula,given the .nite bounds.Forexam\u00adple, translating the repOk method of the binary search \ntree in Figure4withatreeheightofatmostoftwoproducesthefol\u00adlowing boolean formula: root = null . ((n0.left \n= null . (n1.key < n0.key)) . (n0.right = null . (n2.key > n0.key))). Section3.9 describeshowPI-PAL translates \nsuch declarative methods into formulas.  Construct Restrictions Exception Conditions i<j i>j i<=j i>=j \ni+j i-j +i -i ~i i&#38;j i|j i^j x==y x!=y !a a||b a&#38;&#38;b if c return x else return y x=e x.m(..) \nx.f x[i] bis effect free c,x,y are effect free e is effect free m is declarative x.=null x.=null x.=null \n. iin bounds Figure 10. Java constructs that PIPAL executes symboli\u00adcally without generating path constraints \n(except for ex\u00adception conditions). The restrictions indicate the conditions under which PIPAL executes \nthese constructs symbolically without generating path constraints. The exception condi\u00adtions are constraints \nthat are added to the path constraint when no exception is thrown during the concrete execution.  3.6 \nDynamic Analysis Given an element of the search space, the purpose of the dynamic analysis (Line6in Figure8)isto \nidentifya setof similar states that can all be checked ef.ciently in a single step by the static analysis \ndescribed in Section 3.7. Consider checking the binary search tree implementation in Figure4 against \nthe abstract map in Figure 5. Suppose we aregiven the .rst elementin Figure7.PIPAL .rst constructs the \nstate, say s1, corresponding to thegiven element. Pipal then runs the corresponding insert(3,a) operation \non the state s1 to obtain the state s2.As shownin Figure1,PIPAL also runs the abstraction function (the \nmethod abstraction in Figure 4) on the states s1 and s2 to obtain the states a1 and a2. respectively, \nruns the same insert(3,a) operation on the state a1 to obtain the state a2, and checks if a2 and a2. \nare equal (using the method equalTo in Figure 5). As Pipal concretelyexecutes methods(insert, abstrac\u00adtion, \nand equalTo)in the above example, it also symboli\u00adcallyexecutes them[33]tobuilda path constraint. The \nsym\u00adbolic execution tracks formulas representing the values of variablesand .elds.Thepath constraintisa \nformula thatde\u00adscribes the states in the search space that follow the same path through the program as \nthe current concrete execu\u00adtion.Forexample,intheabove concreteexecution,the .rst branch point is on Line \n36 (in Figure 4), with branch condi\u00adtion n != null. At this program point, n has the concrete value of \nn0 and the symbolic value of root. The symbolic value of the branch condition is thus root .null. This \n= symbolic value is saved. The concrete value of the branch condition is true, so the control .ow proceeds \ninto the while loop. The next branch in the concrete execution is on Line 37, testing n.key == key. This \nsymbolically eval\u00aduates to n0.key = key, concretely to false. Execution continuesinthisway.Figure9summarizesallbranchcondi\u00adtions \nencountered during execution of the insert method. Field Symbolic Value list l0 l0.reachable root.=null \nl1.reachable root.=null . n0.left .=null l2.reachable root.=null . n0.right.=null l3.reachable root.=null \n. n0.left .=null . n1.left .=null l4.reachable root.=null . n0.left .=null . n1.right.=null l5.reachable \nroot.=null . n0.right.=null . n2.left .=null l6.reachable root.=null . n0.right.=null . n2.right.=null \nl0.key n0.key l1.key n1.key l2.key n2.key l3.key n3.key l4.key n4.key l5.key n5.key l6.key n6.key l0.value \nn0.value l1.value n1.value l2.value n2.value l3.value n3.value l4.value n4.value l5.value n5.value l6.value \nn6.value method (SearchTree.)method get.key (SearchTree.)get.key insert.key (SearchTree.)insert.key insert.value \n(SearchTree.)insert.value Figure 11. Symbolic state of the abstract map in Figure5 generatedbysymbolicallyexecuting \nthe abstraction function (abstraction in Figure4) on the .rst elementin Figure7.  PIPAL generates the \npath constraint by taking the conjunc\u00adtion of the symbolic branch conditions. (The false branch conditions \nare .rst negated.) All states satisfying the path constraint are considered similar to each other (Line \n6 in Figure 8). In the binary tree example, the insert method does not .nd key in the tree, so it inserts \na new node. The path constraint asserts that root and n0.left are not null, butn1.right is null. The \nparameter key must be less than n0.key and greater than n1.key. (The path constraint also asserts that \nthe method being checked is insert). In general, path constraints are not just branch conditions but \nincludevalues usedin instructions thatPIPAL cannot ef\u00ad.ciently execute symbolically. This includes parameters \nto external code and receiver objects of .eld assignments. In addition, instructions that may result \nin runtime exceptions also generate path constraints. Figure 10 summarizes Java constructs that P IPAL \nexecutes symbolically without gener\u00adating path constraints (except for exception conditions). Note from \nFigure 10 that Pipal executes calls to declara\u00adtive methods symbolically. Declarative methods do not \ncon\u00adtain side effects. Given a declarative method and the current symbolic program state, PIPAL generates \na symbolic return valueofthe declarativemethodbytranslatingthe declarative method (and the methods it \ntransitively invokes) into a for\u00admula (c.f. Section 3.9). The advantage of using declarative methods \nfor writing speci.cations is that branches in declar\u00adativemethods then do not generate anypath constraints. \nThis allowsPIPAL to identifyalargersetof similar states.  Field Value Field Value o1.value {null, \no1, o2, o3} o2.value {null, o1, o2, o3} o3.value {null, o1, o2, o3} method {foo} foo.p1 {o1, o2, o3} \nfoo.p2 {o1, o2, o3} foo.p3 {o1, o2, o3} Figure 12. Search space for checking a method foo with three \nformal parameters p1, p2, and p3 that can each be one of three objects o1, o2, and o3.   3.7 Static \nAnalysis The dynamic analysis above identi.es a set S. of similar states(Line6inFigure8)thatfollowthesame \nprogrampath duringexecution. But thefact that the codeworks correctly on one of the states does not necessarily \nimply that it works correctly on all of them.Forexample,abuggy get method ofa binary tree might correctly \ntraverse the tree,but return thevalueofthenode sparent insteadofthevalueofthenode itself. By chance P \nIPAL might have chosen a state where the two values are the same. That particular state would not expose \nthe bug, but most of the similar states would. The purpose of the static analysis is to check that the \ncode works correctly on all the states in S. (Line7in Figure8). Consider checking the binary search tree \nimplementation in Figure4againstthe abstractmapin Figure5.To check that the code works correctly on all \nthe states S. that follow the same program path, Pipal constructs the formula: S. . R . O . A. Recall \nFigure1for notation. R asserts that for every state s1 in S. , s2.repOk(). O asserts that the outputs \nof executing the operation on s1 and a1 are the same. A asserts that a2.equalTo(a2.). PIPAL uses a SAT \nsolver to .nd a counterexampletothis formula,or establishthat noneexists. Ifit .ndsacounterexample,PIPALdecodesit \nintoaconcrete state and presentsit as anexplicitbug trace. To generate the formulasA and R, PIPAL symbolically \nexe\u00adcutes the operations and abstraction functions as described in Section 3.6. After symbolic execution, \nevery .eld and vari\u00adable contains a symbolic value that is represented by a for\u00admula.Forexample, Figure11 \nshows the symbolic stateof the abstract mapin Figure5generatedby symbolicallyexe\u00adcuting the abstraction \nfunction (the method abstraction in Figure4)onthe .rst elementin Figure7. Section4formally describes \nour symbolic execution technique. Note that the above abstraction function calls the method ListFromTree \nBF, which createsa PipalList suf.ciently longtoholdthelargest possibletree withinthegiven bounds. It \ndoes so without generating path constraints to makemodel checking ef.cient. It adds a reachable bit to \neach node of PipalList that is set if the corresponding tree node is reachable.P IPAL provides similar \nmethods for conveniently generating PipalLists from several data structures. o1.value null o2.value null \no2.value null method foo foo.p1 o1 foo.p2 o2 foo.p3 o3 Figure 13. Two isomorphic elements of the search \nspace in Figure 12. The two elements are isomorphic because o1 and o2 are equivalent memory locations. \n o1.value null o2.value null o3.value null method foo foo.p1 o2 foo.p2 o1 foo.p3 o3  3.8 Isomorphism \nAnalysis Consider checking a method foo with three formal parame\u00adters p1, p2, and p3. Figure 12 presents \nan example of such a search space, where each method parameter can be one of three objects o1, o2, and \no3. Consider the two elements of the above search space in Figure 13. These two elements are isomorphic \nbecause o1 and o2 are equivalent memory loca\u00adtions. Therefore,oncePIPALchecksthe.rstelement,itisre\u00addundantto \ncheckthe second element.P IPALavoids checking isomorphic elements as follows. Consider the .rst element \nof the search space in Figure 13. Suppose the method foo reads only p1 and p2 and the analyses in the \nprevious sec\u00adtions conclude that all states where(p1=o1 . p2=o2)can be pruned. The isomorphism analysis \nthen determines that all states that satisfy the following formula can also be safely pruned:(p1 .{o2,o3}. \n(p1=o1 . p2 .{o3})). In general, given a program state s, PIPAL constructs such a formula Is denoting \nthe set of states isomorphic to s as follows. Recall from Section 3.6 that the symbolicexecution on s \nbuilds a path constraint formula, sayPs . Suppose dur\u00ading symbolic execution PIPAL encounters a fresh \nobject o by followinga .eld f that points to o. Suppose the path con\u00adstraintbuilt sofaris P. s . The \nisomorphism analysis includes in Is all states that satisfy(P. s . f=o.), for every o . in the domain \nof the .eld f thatis another fresh object.PIPALthen prunes all the states denoted by Is from the search \nspace. Note that some software model checkers also prune iso\u00admorphic program states using heap canonicalization \n[24, 37]. The difference is that in heap canonicalization, once a checker visits a state, it canonicalizes \nthe state and checks if the statehasbeenpreviously visited.In contrast, oncePIPAL checks a state s, it \ncomputes a compact formula Is denoting a (often exponentially large) set of states isomorphic to s, and \nprunes Is from the search space. PIPAL never visits the (often exponentially many) states in the set \nIs .  3.9 Declarative Methods andTranslation The above search algorithm relies on ef.ciently translating \ndeclarative methods into formulas. The ef.ciency must not only be in the speed of translation,but also \nin the compact\u00adnessofthe.nal formulasothatitcanbeef.cientlysolvedby a SATsolver.To achieve this, we restrict \ndeclarative meth\u00adods to use a subset of Java and be free of side effects.  Declarative methods in P \nIPAL have the @Declarative an\u00adnotation.Adeclarative method may not contain object cre\u00adations, assignments, \nloops, or exception handlers, and may only call declarative methods. Declarative methods may be overridden \nonly by other declarative methods. Note that declarativemethods can contain recursion, so our declarative \nsubsetofJavaisTuring complete.Ourexperience indicates that declarative methods are suf.ciently expressive \nto write program speci.cations (such as invariants and assertions). The translation process is somewhat \nsimilar to that of AAL [32]. However, because our declarative methods do not contain side effects, the \nformulas for declarativemethods that we generate are considerably simpler than the formulas for regular \nJava methods that AAL generates.We translate our declarative variant of Java directly into propositional \nlogic, unlike AAL which .rst translates Java into Alloy[26] and then translates Alloyinto propositional \nlogic. Section4 formally describes our translation process. Non-declarative methods may call declarative \nmethods. If PIPAL encounters a declarative method during symbolic ex\u00adecution, it symbolically executes \nthe declarative method by translating it into a formula on the current symbolic state. Branches in declarative \nmethods thus do not generate path constraints. Therefore, making methods declarative enables the checking \nand pruning of a larger set of states in each it\u00aderation of the loop in Figure 8. This is particularly \nuseful for methods that depend on a large part of the state, such as a method that returns the number \nof nodes in a tree. The above algorithm translates the same declarative method several times. For example, \nconsider checking the code in Figure 4. During search space initialization (c.f. Sec\u00adtion 3.5), the above \nalgorithm translates the invocation of the isOrdered method on each tree node. Subsequently, during each \niteration of the loop in Figure 8, it again trans\u00adlates the invocation of the isOrdered method on each \ntree node. However, note that each operation on the tree, such as an insert operation, changes only a \nsmall part of the tree. Thus, most invocations of the isOrdered method on the sametreenode returnthe \nsame formula.Tospeedup transla-tion,PIPAL caches the formulas generatedby translating the declarative \nmethods during search space initialization. The cache stores a different formula per combination of param\u00adeters \npassed to a declarative method. PIPAL also maintains a list of .elds that each cache entry depends on. \nIf any of these .elds changes during an operation, that cache entry is temporarily disabled, requiring \nthe declarative method to be translated again on the changed state. Sometimes a declar\u00adative method is \ncalled with the same parameters multiple times per iteration (of the loop in Figure 8). If the cache \nentryis disabledordoesnotexist,the methodmustbe trans\u00adlated every time. To avoid that, PIPAL uses a temporary \ncache. When a declarative method is called, PIPAL looks up the method and its parameters in the main \ncache. If the cache misses (because the entry is disabled or was never created) then PIPAL tries the \ntemporary cache. If that misses then PIPAL translates the method and stores the result in the tem\u00adporary \ncache. After every iteration, the temporary cache is cleared and all main cache entries are enabled. \nThis caching system improves the performanceofPIPAL considerably.  3.10 Checking Functional Equivalence \nA module M is said to be functionally equivalent to an ab\u00adstraction A if starting from an initial state \nof the module and the corresponding stateofthe abstraction,every sequenceof operations on M and A produce \nthe same outputs. To check the functional equivalence between a module M and an abstraction A within \nsomegiven .nite bounds,PIPAL checks the following two properties in those .nite bounds. The .rst property \nthat PIPAL checks is as follows. See Fig\u00adure 14 for notation. PIPAL checks that for every valid state \ns1 of the module, that is, on every state s1 on which repOk returns true: s2.repOk(), the outputs of \nexecuting the op\u00aderation on s1 and a1 are the same, and a2.equalTo(a2.). The second property that PIPAL \nchecks is as follows. See Figure 14 for notation. PIPAL checks that for every pair of states a2 and a2. \nof the abstraction that are equal, that is, for every pair of states a2 and a2. such that a2.equalTo(a2.): \nthe outputs of executing the same operation on a2 and a2. are the same and the resulting states a3 and \na3. are equal, that is, a3.equalTo(a3.). Checking this property checks that the equalTo method of the \nabstraction is implemented correctly with respect to the other methods in the abstraction.  cn m f x \n: : : : class name method name .eld name variable name P cd C T fd md vd ::= ::= ::= ::= ::= ::= ::= \ncd class cn extends C {fd md}cn | Object C | boolean T f; T m(vd) {e}T x e ::= ||||||||||||||| e ; e \ne.f e.f = e if e then e else while e do e new C e.m(e) x this null true false e &#38;&#38; e e || e !e \ne == e e Figure 15. Syntaxofa simpleJava-like language.We write cd as shorthand for cd1 cd2 ... cdn (with \nthe commas), write vd as shorthand for vd1, vd2, ..., vdn (without the commas), etc., similar to the \nnotation in [23].  The above two properties together imply functional equiva\u00adlence, assumingthatevery \ninitial stateofthe module satis.es repOk. Consider a sequence of two operations on a module state s1.See \nFigure14againfor notation. Property1asserts that the outputs of executing the .rst operation on s1 and \na1 are the same and that the outputs of executing the sec\u00adond operation on s2 and a2. are the same. Property1 \nalso asserts that a2.equalTo(a2.). Property2then asserts that the outputs of executing the second operation \non a2 and a2. are the same. Thus, together these properties assert that the outputs of executing the \nsequence of two operations on s1 and a1 are the same. Extending this argument to a sequence of operations \nof arbitrary length proves that the above two properties together imply functional equivalence. md ::= \n@Declarative T m(vd) {de} de ::= if de then de else de ||||||||||| de.f de.m(de) x this null true false \nde &#38;&#38; de de || de !de de == de Figure 16. Syntaxofa declarative subsetofthe languagein Figure \n15, showing the syntax of declarative methods.  Pipal checks the above two properties ef.ciently using \nthe search algorithm described in the above sections.To check the .rst property using the search algorithmin \nFigure8,PI-PAL creates a bounded search space B consisting of all in\u00adstances of the module within the \ngiven .nite bounds. An el\u00adement s of this search space is valid if s.repOk() returns true.To check the \nsecond propertyPIPAL createsa bounded search space B consisting of all pairs instances of the abstrac\u00adtion \nwithin the given .nite bounds. An element (a, a .) of this search spaceisvalidif a.equalTo(a.). ThisiswhyPI-PALrequires \nrepOk and equalTo to be declarative methods, so that theycan be ef.ciently translated into boolean formu\u00adlas \nduring search space initialization (c.f. Section 3.5). 4. Formalism This section formalizes parts of \nPIPAL s dynamic and static analyses for the simple Java-like language in Figure 15. This language resembles \nFeatherweight Java [23]but it also in\u00adcludes imperative constructs such as assignments to a mu\u00adtable \nheap. This section assumes that programs in this lan\u00adguage have been type checked so that all .eld accesses \nand method calls arevalid,except when accessed througha null pointer. Null pointer dereferencingisfatalin \nthis language. 4.1 SymbolicValues and Symbolic State Consider the simple Java-like language of Figure \n15. The concrete values of this language include the expressions true, false, null, and any object allocated \non the heap. We de.ne asymbolic value as a set of elements of the form c . ., where c is a boolean formula \nand . is a concrete value. Informally,the formula c isa condition that must hold for the corresponding \nconcrete value to be .. For a given symbolicvalue, we require that all conditions c are mutually exclusive, \nand that all concrete values . are distinct. As a notational convenience, we use {.} as an abbreviation \nfor the singleton set {true . .}, which is a symbolic value  RC-SEQ RC-FIELD-READ .H, P, e0. -. .H.,P \n. ,e . 0 .H, P, e0 ; e1. -. .H.,P . ,e ; e1. 0 .H, P, e0. -. .H.,P . ,e . 0 .H, P, e0.f. -. .H.,P \n. ,e 0.f. RC-FIELD-WRITE .H, P, e0. -. .H., P . , e . 0. .H, P, e0.f = e1. -. .H., P . , e . 0.f = e1. \nRC-FIELD-WRITE-2 .H, P, e1. -. .H., P . , e . 1. .H, P, v0.f = e1. -. .H., P . , v0.f = e . 1. RC-IF \n.H, P, e0. -. .H., P . , e . 0. .H, P, if e0 then e1 else e2. -. .H., P . , if e . 0 then e1 else e2. \nRC-CALL .H, P, e0. -. .H.,P . ,e . 0 .H, P, e0.m(e). -. .H.,P . ,e 0.m(e). RC-CALL-2 .H, P, ei. -. \n.H.,P . ,e . i .H, P, v.m(v0,...,vi-1,ei,... ). -. .H.,P . ,v.m(v0,...,vi-1,e i,... ). RC-OP .H, P, \ne0. -. .H.,P . ,e . 0 .H, P, e0 &#38;&#38; e1. -. .H.,P . ,e &#38;&#38; e1. 0 .H, P, e0 || e1. -. .H.,P \n. ,e || e1. 0 .H, P, !e0. -. .H.,P . , !e . 0 .H, P, e0 == e1. -. .H.,P . ,e == e1. 0 .H, P, v == \ne0. -. .H.,P . ,v == e . 0 Figure 17. Congruence reduction rules for the simple Java-like language in \nFigure 15. that represents a single concrete value .. Furthermore, we use {c . true} as an abbreviation \nfor the set {c . true, \u00acc . false}, which is a boolean symbolic value whose boolean concrete value corresponds \nto the formula c. For a symbolic value v and a concrete value ., let v = . denote c if (c . .) . v and \nfalse otherwise. Consider an assignment . of truth values to boolean vari\u00adables. During symbolic execution, \nsuch an assignment . is generatedbyaSATsolver(inLine4of Figure8).Then,let .(c) denote the truth value \nof the boolean formula c under ..For a symbolic value v, let .(v) denote . if .(v = .). We de.ne asymbolic \nstate as a triple .H, P, e., where H is the heap, P is the current path constraint, and e is the current \nexpression to evaluate. The heap H maps objects and .elds to symbolic values. Let H(f, .) denote the \nsymbolic value of the .eld f of the object . in H. Let H[(f, .) . v] denote a heap identical to H except \nthat it maps the .eld f of the object . to v.Tofacilitate dynamic semantics, weextend the expression \nsyntax of Figure 15 to include symbolic values: e ::= ... | v Initially,the symbolic state is .H0, true, \n{.0}.m(v).,where H0 is the initial heap of the .nite search space, .0 is the main object, m is a method \nto be run, and v are symbolic values of arguments to m. The initial heap H0 contains symbolic values \nfor each .eld of each object. Each symbolic value v = {c . .} de.nes a domain of n concrete values . \n(c.f. Figure 6). The formulas c are each in terms of .log n. fresh booleanvariables that mutually de.nea \nbinary index into ..  4.2 Symbolic Execution Figures 17 and 18 de.ne the small-step operational seman\u00adtics \nof symbolic execution. The reductions in Figure 17 are congruence rules for evaluating subexpressions. \nThe reduc\u00adtions in Figure 18 de.ne the rules for symbolic execution. The rules describehowexpressionsevaluateto \nsymbolicval\u00adues, and how expressions change the heap and the path con\u00adstraint.Forexample, the ruleR-FIELD-READ \nevaluates expressions of the form v.f, where v = {c . .} is a sym\u00adbolic value and f isa .eld.For each \nnon-null .i . ., the symbolic value H(f, .i) is the result of accessing .eld f through the object .i. \nThe result v. combines all such sym\u00adbolic values into one result. The rule requires that .(v), the concrete \nevaluation of v, is not null. If .(v) is null, then no evaluation rule applies. The evaluation reaches \nan error because of null pointer dereferencing. Otherwise, if .(v) is not null,thenthisfactisaddedtothepath \nconstraint.  R-SEQ R-FIELD-READ v = {c . .}v . = {d . . | d = . {ci . dj | (dj . .) . H(f, .i)}}.(v) \n.= null .H, P, v.f. -. .H, P . \u00ac(v = null), v .. R-FIELD-WRITE .H, P, v0.f .(v0) = . . .= null = v1. \n-. .H[(f, .) . v1], P . (v0 = .), v1. R-IF-T .H, P, if v then e1 .(v) = true else e2. -. .H, P . (v = \ntrue), e1. R-IF-F .H, P, if v then e1 .(v) = false else e2. -. .H, P . (v = false), e2. R-WHILE .H, P, \nwhile e0 do e1. -. .H, P, if e0 then e1 ; while e0 do e1 else {false}. R-NEW . is a fresh object of class \nC with .elds f. .H, P, new C. -. .H[(f, .) . {null}], P, {.}. R-CALL .(v) = . . .= null mbody(m, .) = \nx.e .H, P, v ; e. -. .H, P, e. .H, P, v.m(v). -. .H, P . (v = .),e[v/x, v/this]. R-EQUALS RD-FIELD-READ \n v0 = {c . .} v1 = {d . .}v . = { . {ci . di | .i = .i} . true}.H, P, v0 == v1. -. .H, P, v.. R-AND-T \n.H, P, v .(v) = true &#38;&#38; e. -. .H, P . (v = true), e. R-AND-F .H, P, v .(v) = false &#38;&#38; \ne. -. .H, P . (v = false), {false}. R-OR-T .(v) = true .H, P, v || e. -. .H, P . (v = true), {true}. \nR-OR-F .(v) = false .H, P, v || e. -. .H, P . (v = false), e. R-NOT v = {c . true}v . = {\u00acc . true}.H, \nP, !v. -. .H, P, v.. Figure 18. Small-step operational semantics of symbolic execution. The symbolic \nstate includes a heap H, a path constraint P , and an expression e. An assignment . is assumed to be \navailable for converting symbolic values v into concrete values ..   H \u00d8 de . (v, E) v = {c . .}v . \n= {d . . | d = . {ci . dj | (dj . .) . H(f, .i)}}H \u00d8 de.f . (v ., E . v = null) RD-IF H \u00d8 de0 . ({b . \ntrue}, E0) H \u00d8 de1 . ({c . .}, E1) H \u00d8 de2 . ({d . .}, E2) v = {g . . | g = . {b . ci | .i = .} . . {\u00acb \n. di | .i = .}}E = E0 . (b . E1) . (\u00acb . E2) H \u00d8 if de0 then de1 else de2 . (v, E) RD-CALL H \u00d8 de . ({c \n. .}, E) mbody(m, .) = x.de0 .i : H \u00d8 dei . (vi, Ei) H \u00d8 de0[v/x, {.}/this] . (v ., E.) H \u00d8 de.m(de) \n. (v ., E . . E . E.) . .= null RD-CALL-NULL H \u00d8 de . ({c . null},E) H \u00d8 de.m(de) . ({null}, true) RD-CALL-MULTI \n H \u00d8 de . ({c . ., c . .},E) H \u00d8 if {c . true} then {.}.m(de) else {c . .}.m(de) . (v ,E.) H \u00d8 de.m(de) \n. (v ,E . E.) RD-EQUALS H \u00d8 de0 . ({c . .},E0) H \u00d8 de1 . ({d . .},E1) . v = {{ci . di | .i = .i}. true} \nH \u00d8 de0 == de1 . (v, E0 . E1) RD-AND H \u00d8 de0 . ({c . true},E0) H \u00d8 de1 . ({d . true},E1) v = {c . d \n. true} H \u00d8 de0 &#38;&#38; de1 . (v, E0 . (c . E1)) RD-OR H \u00d8 de0 . ({c . true},E0) H \u00d8 de1 . ({d . \ntrue},E1) v = {c . d . true} H \u00d8 de0 || de1 . (v, E0 . (\u00acc . E1)) RD-NOT H \u00d8 de . ({c . true},E) v = \n{\u00acc . true}H \u00d8 !de . (v, E) Figure 19. Big-step operational semantics of declarative methods, used in \ntheir translation to formulas. Given a heap H an expression e evaluates to a value v with an error condition \nE. E holds true for concrete states that encounter an error. The ruleR-CALL performs method calls by \ninlining a method s body at the call site and substituting formal pa\u00adrameters with their actual symbolic \nvalues. The function mbody(m, .) denotes x.e, where e is the body of the method m of object . and x is \nthe list of formal method parameters.We use e[v/x] to denote the expression e with all instances of variable \nx replaced with symbolic value v. The rulesR-IF-T andR-IF-F for the if expressions de\u00adpend on the concrete \nvalue of the branch condition v. If the concrete value is true, then v = true is added to the path constraint. \nIf the concrete value is false, then v = false is added to the path constraint. Similarly, the rules \nfor the operators &#38;&#38; and || generate path constraints. The reason the rules for the if expressions \nand the&#38;&#38; and || operators generate path constraints is that these expressions and operators \nshort circuit and their operands might have side effects. For example, (true &#38;&#38; e) evaluates \ne but (false &#38;&#38; e) does not and e might have side effects. However, if the operands of if expressions \nand the &#38;&#38; and || operators do not have anyside effects then they can be executed symbolically \nwithout generating path constraints. We describe this process in Section 4.4.  4.3 Translation of Declarative \nMethods Figure 16 presents a declarative subset of the language in Figure 15, showing the syntax of declarative \nmethods. Declarative methods may not contain object creations, as\u00adsignments, or loops and may only call \ndeclarative methods. Figure 19 presents the big-step operational semantics of declarative methods that \nare used to translate them into for\u00admulas. Declarative methods do not have assignments or ob\u00adject creations, \nso they do not modify the heap H. Unlike non-declarative methods, the semantics of declarative meth\u00adodsdonotdependon \nconcretevalues,sotheydonotneedan assignment .. Furthermore, branches in declarative meth\u00adods do not generate \npath constraints, so the semantics of declarative methods do not use a path constraint. As with the non-declarative \nexpressions above, we extend the syntax of declarative expressions to include symbolic values:  de ::= \n... | v Judgments are of the form H . e . (v, E), indicating that under heap H, an expression e evaluates \nto a value v with an error condition E. The error condition E isa formula that holds true for concrete \nstates that encounter an error. The result of calling a declarative method is a symbolic value and error \ncondition (v, E). In the case of boolean methods (such as repOk and equalTo), v is of the form {c . true} \nwhere c.\u00acE holds for states where the method successfully returns true. Thus, this process translates \na boolean declarative method into a formula c that describes the conditions under which the method returns \ntrue.  4.4 Symbolic Execution of Declarative Expressions Recall from Figure 18 that the symbolic execution \nof the short circuiting operators &#38;&#38; and || generates path con\u00adstraints because of the possibility \nof side effects. However, the operands of these operators often do not have side ef\u00adfects.In such cases,PIPAL \nexecutes these operators symbol\u00adically without generating path constraints. The same applies to if statements. \nIn general, in addition to calls to declar\u00adative methods, Pipal symbolically executes declarative ex\u00adpressions \nwithout generating path constraints(except for the exception condition) according to the following rule: \nR-DECL e has declarative syntax H \u00d8 e . (v, E) .(E)= false .H, P, e. -. .H, P .\u00acE, v. A simple static \nanalysis determines if an expression has declarative syntax. By requiring .(E) tobefalse, the above rule \nonly applies when no errors are encountered. PIPAL updates the path constraint to re.ect this requirement. \n5. Experimental Results This section presents our experimental results. We implementedPIPAL as describedin \nthis paper.Weex\u00adtended the Polyglot [41] compiler to automatically instru\u00adment program modulesto perform \nour dynamic analysis.We used MiniSat [14] as our incremental SATsolver to perform our static analysis.We \nran all ourexperiments ona Linux Fedora Core8machine witha Pentium43.4 GHz processor and1GB memory using \nIcedTeaJava 1.7.0. We tested modules that implement the Map and Set inter\u00adfacesfromtheJava Collections \nFramework.We createdtwo abstract implementations, AbsMap and AbsSet and tested several modules for conformance \nto these implementations. Our AbsMap implementation is similar to AbstractMap from Figure 5.We tested \nthe Map interface on the methods put, remove, get, isEmpty, and clear and the Set in\u00adterface on the methods \nadd, remove, contains, isEmpty, and clear. All the JavaCollections Framework modules are from the source \ncode of the Java SE6JDK. Although Java generics do not pose anydif.culties to our technique, Poly\u00adglot \ncompiler does not fully support them. So we removed them from the source.We tested the following modules: \n TreeMap, which implements the Map interface using a red-black tree, which is a balanced binary tree. \n TreeSet, which implements the Set interface using an underlying TreeMap  HashMap, which implements \nthe Map interface using a hash table.  HashSet, which implements the Set interface using an underlying \nHashMap  We used PIPAL to exhaustively check module states up to a maximum of n nodes, with at most \nn different possible keys and eight different possible values. We checked the functional equivalence \n(c.f. Section 3.10) between the above modules and their abstractions. For comparison, we also checked \nthese properties using JPF [48], KORAT [3], and BLAST [21].We timed out allexperiments after an hour. \nThe results of these experiments are in Figure 20. PIPAL exhaustively checked all TreeMaps with up to \n63 nodes in under 15 minutes and all HashMaps with up to 64 nodes in under 40 minutes. The other checkers \ndid not scale nearly as well. In particular BLAST could .nd no new predicates and aborted its analysis. \nThis illustrates the ineffectiveness of most other techniques in checking these kinds of properties. \nNext, we tested the effectiveness of replacing the maps with the abstract map.We checked the following \nprograms: TreeSet and HashSet. Since they use a Map internally, they can be checked modularly.We again \nchecked func\u00adtional equivalence between these modules and AbsSet.  IntCounter from Figure 2, implemented \nwith a Tree\u00adMap.We checked that the .elds most frequent i and max frequency are consistent with the state \nof the map.  A two-layer cache, DualCache, similar to the one de\u00adscribed in Section 3.9, implemented \nusing two TreeMaps. One map is the permanent map and the other is the tem\u00adporary map. DualCache has some \ninternal consistency constraints, such as the property that no key can be in both maps at once.We checked \nthe following operations:   Module Max Number of Nodes Time (s) JPF KORAT BLAST PIPAL TreeMap 1 2 3 \n4 5 6 7 8 9 10 11 12 13 14 15 ... 31 63 1.218 5.556 memory out 0.608 0.613 0.676 0.732 1.251 4.721 23.547 \n2202.231 timeout aborted 0.188 0.244 0.392 0.485 0.670 0.751 0.985 1.124 1.491 1.670 2.303 2.555 3.142 \n3.435 4.571 ... 40.405 787.411 HashMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ... 32 64 0.674 6.514 memory \nout 0.465 0.497 0.539 0.810 0.735 0.819 0.997 3.077 18.972 150.932 1203.986 timeout aborted 0.176 0.227 \n0.258 0.305 0.373 0.422 0.494 0.599 0.675 0.780 0.953 1.162 1.356 1.708 2.143 2.879 ... 75.139 2004.723 \nTreeSet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ... 31 63 0.537 0.950 26.816 memory out 0.638 0.648 0.693 \n1.020 0.699 0.876 0.943 2.773 8.208 24.921 74.966 221.719 615.524 1706.41 timeout aborted 0.195 0.246 \n0.393 0.489 0.651 0.752 0.961 1.090 1.473 1.665 2.238 2.493 3.065 3.399 4.481 ... 39.789 796.955 HashSet \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ... 32 64 0.728 0.781 6.574 memory out 0.520 0.511 0.716 0.570 \n0.567 0.623 0.701 1.878 3.357 9.440 29.485 82.642 238.420 593.045 952.317 timeout aborted 0.171 0.221 \n0.248 0.299 0.363 0.414 0.478 0.579 0.644 0.773 0.948 1.068 1.344 1.608 2.029 2.816 ... 68.011 2543.034 \nFigure 20. Resultsof checking modulesagainst abstractions.P IPAL checks TreeMaps of up to 63 nodes in \nunder 15 minutes.  lookup : Looks up a value in the cache. If the value is not present, it computes \nit and adds it to the cache. remove :Removesavalue from the cache,ifitexists. enableTemporary :Causes \nfuture cache additions to go to the temporary map. disableTemporary : Clears the temporary map and causes \nfuture cache additions to go to permanent map. promote :Removes a value from the temporary map and adds \nit to the permanent map. demote : Removes a value from the permanent map and adds it to the temporary \nmap. WeusedPIPAL to checkthegiven implementationsof these programs.Wethen replaced the maps with abstract \nmaps and checked the programsagain withPIPAL.We checked maps with at most n nodes.We checked IntCounter \nwith at most n integersand frequencies rangingfrom0to7.We checked DualCache with at most n keys and at \nmost eight values. The results of these experiments are in Figure 21. Check\u00ading these programs with AbsMap \nis signi.cantlyfaster than checking them with a TreeMap or a HashMap. 6. RelatedWork This section presents \nrelatedwork on software model check\u00ading. Model checking is a formal veri.cation technique that exhaustively \ntests a circuit/program on all possible inputs (sometimes up to a given size) and on all possible nondeter\u00administic \nschedules. There has been much research on model checking of software. Verisoft [16] is a stateless model \ncheckerforCprograms.JavaPathFinder(JPF)[31,48]isa stateful model checker for Java programs. XRT[20] checks \nMicrosoft CIL programs. Bandera [7] and JCAT [9] trans\u00adlate Javaprograms into the input language of model \ncheckers like SPIN [22] and SMV [36]. Bogor [13] is an extensible framework forbuilding software model \ncheckers. CMC [39] is a stateful model checker for C programs that has been used to test large software \nincluding the Linux implemen\u00adtation of TCP/IP and the ext3 .le system. Chess [38] and CalFuzzer [28] \nhelp .nd and reproduce concurrencybugs. For hardware, model checkers have been successfully used toverifyfairly \ncomplex.nite state control circuits withupto afew hundred bitsof state information;but not circuits that \nhave large data paths or memories. Similarly, for software, model checkers have been primarily used to \nverify control\u00adoriented programs with respect to temporal properties;but not much work has been done \nto verify data-oriented pro\u00adgrams with respect to complex data-dependent properties. Thus, most of the \nresearch on reducing the state space of a software model checker has focused on checking temporal properties \nof programs.Tools such as Slam [1], Blast [21], and Magic [4] use heuristics to construct and check an \nab\u00adstraction of a program (usually predicate abstraction [19]). Module Max Number of Nodes Time (s) Original \nProgram Modules Replaced with Abstract Implementations TreeSet 1 2 3 4 5 6 7 ... 15 31 63 127 255 511 \n0.195 0.246 0.393 0.489 0.651 0.752 0.961 ... 4.481 39.789 796.955 timeout 0.122 0.153 0.167 0.185 0.207 \n0.246 0.251 ... 0.429 0.991 3.388 16.690 184.827 425.328 HashSet 1 2 3 4 5 6 7 ... 15 16 32 64 128 256 \n512 0.171 0.221 0.248 0.299 0.363 0.414 0.478 ... 2.029 2.816 68.011 2543.034 timeout 0.106 0.141 0.153 \n0.169 0.193 0.218 0.238 ... 0.412 0.451 0.989 3.464 17.071 91.629 754.426 IntCounter 1 2 3 4 5 6 7 ... \n15 31 63 127 255 0.198 0.279 0.469 0.579 0.815 0.918 1.182 ... 5.591 41.500 632.488 timeout 0.113 0.154 \n0.164 0.184 0.214 0.251 0.267 ... 0.539 1.867 10.794 93.276 946.091 DualCache 1 2 3 4 5 6 7 ... 15 31 \n63 127 255 0.203 0.283 0.503 0.589 0.828 0.950 1.207 ... 5.765 53.434 723.267 timeout 0.222 0.323 0.327 \n0.511 0.654 0.548 0.529 ... 1.015 4.057 26.192 215.521 2180.506 Figure 21. Experimental results of checking \nprograms that use a map internally. Replacing the map with an abstract implementation speeds up the checking \nconsiderably.  Abstractions that are too coarse generate false positives, which are then used to re.ne \nthe abstraction and redo the checking. This technique is known as Counter Example Guided Abstraction \nand Re.nement or CEGAR. There are also manystatic [16] and dynamic [15] partial order reduc\u00adtion systems \nfor concurrent programs. There are manyother symmetry-based reduction techniques as well (e.g., [25]). \nHowever, none of the above techniques seem to be effec\u00adtive in reducing the state space of a model checker \nwhen checking complex data-dependent properties of programs.  Our experiments comparing the performance \nof PIPAL to other model checkers support this observation. Tools such as Alloy [26, 30] and Korat [3] \nsystematically generate all test inputs that satisfy a given precondition. A version of JPF [31] uses \nlazy initialization of .elds to essentially simulate the Korat algorithm. Kiasan [10] uses a lazier initialization. \nHowever, these tools generate and test everyvalid state withinthegiven .nite bounds(or portionof state \nthat is used, in case of Kiasan) and so do not achieve as much state space reductionasPIPAL.In particular,unlikethe \nabove systems, our static analysis allows us to prune a very large number of states in a single step \nusing a SATsolver. ToolssuchasCUTE[17,44], Whispec[45],andaversionof JPF [47] use constraint solvers \nto obtain good branch cover\u00adage (or good path coverage on paths up to a given length) for testing data \nstructures. However, this approach could miss bugs even on small sized data structures. For exam\u00adple,abuggy \ntree insertion method that does not rebalance the tree might work correctly on a test case that exercises \na certain program path,butfail ona different unchecked test case that exercises the same program path \nbecause the sec\u00adond test case makes the tree unbalanced. Therefore, it seems to us that this approach \nis more suitable for checking control\u00addependent properties rather than data-dependent properties. Jalloy \n[46], Miniatur [12], and Forge [11] translate a Java program and its speci.cations into a boolean formula \nand check it with a SATsolver. In our experience with a similar approach, translating general Javacode \nusually leads to large formulas that take a lot of time to solve with a SATsolver. Our technique of translating \ndeclarative methods and using symbolic execution for general Java code is more ef.cient. This paper uses \nand extends our previous work on glass box software model checking. Our previous work focused on es\u00adtablishing \ndata structure invariants [8] and type soundness [43]. The work on data structure invariants could only \nef.\u00adciently check local properties of data structures, which relate a node to its immediate neighbors. \nThe work on type sound\u00adness improved on this by allowing nonlocal properties to be ef.ciently checked \nas well and applied it to the checking of type soundness. This paper extends our previous work to support \nmodular glass box checking. It also presents a for\u00admal description of our dynamic and static analyses. \n7. Conclusions We present PIPAL, a system for modular glass box software model checking.Aglass box software \nmodel checker does not checkevery state separatelybut instead checksa large set of states together in \neach step.Adynamic analysis dis\u00adcovers a set of similar states, and a static analysis checks all of themef.cientlyina \nsingle step usingaSAT solver.PI-PAL.rst checksaprogram moduleagainstan abstractimple\u00admentation, establishing \nfunctional equivalence. P IPAL then replaces the program module with the abstract implemen\u00adtation when \nchecking other program modules. Our experi\u00admental results indicate that the modular glass box software \nmodel checking approach is effectiveand it signi.cantly out\u00adperforms the earlier non-modular glass box \nsoftware model checking approach. A comparison of PIPAL to other state of the art software model checkers \ndemonstrates that PIPAL is signi.cantly more ef.cient in checking data-oriented pro\u00adgrams with respect \nto complex data-dependent properties. Acknowledgments This research was supported in part by the AFOSR \nGrant FA9550-07-1-0077. References [1]T. Ball,R. Majumdar,T. Millstein,andS.K. Rajamani. Au\u00adtomatic predicate \nabstractionofCprograms.In Programming Language Design and Implementation (PLDI), June 2001. [2]Y. Bertot \nandP. Casteran. Interactive Theorem Proving and Program Development. SpringerVerlag, 2004. [3] C.Boyapati,S. \nKhurshid, andD. Marinov.Korat: Automated testing based on Java predicates. In International Symposium \non SoftwareTesting and Analysis (ISSTA), July 2002. [4] S. Chaki,E. Clarke,A. Groce,S. Jha, andH.Veith. \nModular veri.cation of software components in C. In International Conference on Software Engineering \n(ICSE), June 2003. [5] E. M. Clarke, O. Grumberg, and D. A. Peled. Model Checking. MIT Press, 1999. [6] \nE. M. Clarke, E. A. Emerson, and J. Sifakis. Model checking: Algorithmic veri.cation and debugging. Communications \nof theACM (CACM) 52(11), 2009. [7] J. Corbett, M. Dwyer, J. Hatcliff, C. Pasareanu, Robby, S. Laubach, \nand H. Zheng. Bandera: Extracting .nite-state models from Java source code. In International Conference \non Software Engineering (ICSE), June 2000. [8] P. Darga and C. Boyapati. Ef.cient software model checking \nof data structure properties. In Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), \nOctober 2006. [9] C. DeMartini, R. Iosif, and R. Sisto. A deadlock detection tool for concurrent Java \nprograms. Software Practice and Experience (SPE) 29(7), June 1999. [10] X. Deng, J. Lee, and Robby. Bogor/Kiasan: \nA k-bounded symbolic execution for checking strong heap properties of open systems. In Automated Software \nEngineering (ASE), September 2006. [11] G. Dennis,F. Chang, andD. Jackson. Modularveri.cationof code \nwith SAT. International Symposium on SoftwareTesting and Analysis, 2006. [12]J.Dolby,M.Vaziri,andF.Tip. \nFindingbugsef.cientlywith a SAT solver. In European Software Engineering Confer\u00adence andFoundations of \nSoftware Engineering (ESEC/FSE), September 2007. [13] M. Dwyer, J. Hatcliff, M. Hoosier, and Robby. Building \nyour own software model checker using the Bogor extensible model checking framework. In Computer AidedVeri.cation \n(CAV), January 2005.  [14] N. Een and A. Biere. Effective preprocessing in SATthrough variable and clause \nelimination. In Theory and Applications of Satis.abilityTesting (SAT), June 2005. [15] C. Flanagan andP. \nGodefroid. Dynamic partial-order reduc\u00adtion for model checking software. In Principles of Program\u00adming \nLanguages (POPL), January 2005. [16] P. Godefroid. Model checking for programming languages using VeriSoft. \nIn Principles of Programming Languages (POPL), January 1997. [17] P. Godefroid, N. Klarlund, and K. Sen. \nDART: Directed automated random testing. In Programming LanguageDesign and Implementation (PLDI), June \n2005. [18] J. Gosling, B. Joy, G. Steele, and G. Bracha. TheJava Lan\u00adguage Speci.cation, ThirdEdition. \nAddison-Wesley, 2005. [19] S. Graf and H. Saidi. Construction of abstract state graphs with PVS. In Computer \nAidedVeri.cation (CAV), June 1997. [20]W. Grieskamp,N.Tillmann,andW. Shulte.XRT Exploring runtime for \n.NET: Architecture and applications. In Workshop on Software Model Checking (SoftMC), July 2005. [21] \nT. A. Henzinger,R. Jhala, and R. Majumdar. Lazy abstraction. In Principles of Programming Languages (POPL), \nJanuary 2002. [22] G. Holzmann. The model checker SPIN. Transactions on Software Engineering (TSE) 23(5), \nMay 1997. [23]A.Igarashi,B. Pierce,andP.Wadler. FeatherweightJava:A minimal core calculus for Java and \nGJ. In Object-Oriented Programming, Systems, Languages, and Applications (OOP-SLA), October 1999. [24] \nR. Iosif. Symmetry reduction criteria for software model checking. In SPIN workshop on Model Checking \nof Software (SPIN), April 2002. [25]C.N.IpandD. Dill. Betterveri.cation through symmetry.In Computer \nHardware Description Languages, April 1993. [26] D. Jackson. Software Abstractions: Logic, Language, \nand Analysis. MIT Press, 2006. [27] D. Jackson and C. Damon. Elements of style: Analyzing a software \ndesign feature witha counterexample detector. IEEE Transactions on SoftwareEngineering (TSE) 22(7),July \n1996. [28]P. Joshi,M.Naik, C.-S.Park,andK.Sen.Anextensibleactive testing framework for concurrent programs. \nComputer Aided Veri.cation (CAV), 2009. [29] M. Kaufmann, P. Manolios, and J. S. Moore. Computer-Aided \nReasoning: An Approach. Kluwer Academic Publish\u00aders, 2000. [30] S. Khurshid and D. Marinov. TestEra: \nSpeci.cation-based testing of Java programs using SAT. In Automated Software Engineering (ASE), November \n2001. [31] S. Khurshid, C. S. Pasareanu, and W. Visser. Generalized symbolic execution for model checking \nand testing. In Tools and Algorithms for Construction and Analysis of Systems (TACAS), April 2003. [32] \nS. Khurshid, D. Marinov, and D. Jackson. An analyzable an\u00adnotation language. In Object-Oriented Programming, \nSys\u00adtems, Languages, and Applications (OOPSLA), November 2002. [33] J. C. King. Symbolic execution and \nprogram testing. In CommunicationsoftheACM(CACM) 19(7), August 1976. [34] B. Liskov and J. Guttag. Abstraction \nand Speci.cation in Program Development. MIT Press, 1986. [35] D. Marinov, A. Andoni, D. Daniliuc, S. \nKhurshid, and M. Ri\u00adnard. An evaluation of exhaustive testing for data structures. Technical Report TR-921, \nMIT Laboratory for Computer Sci\u00adence, September 2003. [36] K. McMillan. Symbolic Model Checking. Kluwer \nAcademic Publishers, 1993. [37] M. Musuvathi and D. Dill. An incremental heap canonical\u00adization algorithm. \nIn SPIN workshop on Model Checking of Software (SPIN), August 2005. [38]M.Musuvathi,S.Qadeer,T.Ball,G. \nBasler,P.A. Nainar,and I. Neamtiu. Finding and reproducing heisenbugs in concur\u00adrent programs. Operating \nSystem Design and Implementation (OSDI), 2008. [39] M. Musuvathi, D. Y. W. Park, A. Chou, D. R. Engler, \nand D. Dill. CMC: A pragmatic approach to model checking real code. In Operating System Design and Implementation \n(OSDI), December 2002. [40] T. Nipkow, L. C. Paulson, and M. Wenzel. Isabelle/HOL: A Proof Assistant \nfor Higher-Order Logic. SpringerVerlag, 2002. [41] N. Nystrom, M. R. Clarkson, and A. C. Myers. Polyglot: \nAn extensible compiler framework for Java. In Compiler Construction (CC), April 2003. [42] J. Offutt \nand R. Untch. Mutation 2000: Uniting the orthogo\u00adnal. In Mutation 2000: MutationTestingin theTwentieth \nand theTwentyFirst Centuries, October 2000. [43] M. Roberson,M. Harries,P.T. Darga, andC.Boyapati. Ef.\u00adcient \nsoftware model checking of soundness of type systems. In Object-Oriented Programming, Systems, Languages, \nand Applications (OOPSLA), October 2008. [44]K.Sen,D. Marinov,andG.Agha. CUTE:Aconcolicunit test\u00ading \nengine for C. In European Software Engineering Confer\u00adence andFoundations of Software Engineering (ESEC/FSE), \nSeptember 2005. [45] D. Shao, S. Khurshid, and D. Perry. Whispec: White-box testing of libraries using \ndeclarative speci.cations. Library-Centric Software Design (LCSD), 2007. [46] M. Vaziri and D. Jackson. \nChecking properties of heap\u00admanipulating procedures using a constraint solver. In Tools and Algorithms \nfor Construction and Analysis of Systems (TACAS), April 2003. [47] W. Visser, C. S. Pasareanu, and S. \nKhurshid. Test input generation withJavaPathFinder.In International Symposium on SoftwareTesting and \nAnalysis (ISSTA), July 2004. [48]W.Visser,K.Havelund,G. Brat,andS.Park. Model check\u00ading programs. In \nAutomated Software Engineering (ASE), September 2000.   \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Glass box software model checking incorporates novel techniques to identify similarities in the state space of a model checker and safely prune large numbers of redundant states without explicitly checking them. It is significantly more efficient than other software model checking approaches for checking certain kinds of programs and program properties.</p> <p>This paper presents Pipal, a system for <i>modular</i> glass box software model checking. Extending glass box software model checking to perform modular checking is important to further improve its scalability. It is nontrivial because unlike traditional software model checkers such as Java PathFinder (JPF) and CMC, a glass box software model checker does not check every state separately---instead, it checks a large set of states together in each step. We present a solution and demonstrate Pipal's effectiveness on a variety of programs.</p>", "authors": [{"name": "Michael Roberson", "author_profile_id": "81331502480", "affiliation": "University of Michigan, Ann Arbor, MI, USA", "person_id": "P2353998", "email_address": "", "orcid_id": ""}, {"name": "Chandrasekhar Boyapati", "author_profile_id": "81319488571", "affiliation": "University of Michigan, Ann Arbor, MI, USA", "person_id": "P2353999", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869461", "year": "2010", "article_id": "1869461", "conference": "OOPSLA", "title": "Efficient modular glass box software model checking", "url": "http://dl.acm.org/citation.cfm?id=1869461"}