{"article_publication_date": "10-17-2010", "fulltext": "\n Type Classes as Objects and Implicits Bruno C. d. S. Oliveira ROSAEC Center, Seoul National University \n bruno@ropas.snu.ac.kr Abstract Type classes were originally developed in Haskell as a dis\u00adciplined alternative \nto ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to impor\u00adtant challenges \nin software engineering and programming languages such as, for example, retroactive extension of programs. \nThey are also recognized as a good mechanism for concept-based generic programming and, more recently, \nhave evolved into a mechanism for type-level computation. This paper presents a lightweight approach \nto type classes in object-oriented (OO) languages with generics using the CONCEPT pattern and implicits \n(a type-directed implicit pa\u00adrameter passing mechanism). This paper also shows how Scala s type system \nconspires with implicits to enable, and even surpass, many common extensions of the Haskell type class \nsystem, making Scala ideally suited for generic pro\u00adgramming in the large. Categories and Subject Descriptors \nD.3.2 [Programming Languages]: Language Classi.cations Functional Lan\u00adguages, Object-Oriented Languages \nGeneral Terms Languages Keywords Type classes, C++ concepts, Abstract datatypes, Scala 1. Introduction \nType classes were introduced in Haskell (Peyton Jones 2003) as a disciplined way of de.ning ad-hoc polymorphic \nabstrac\u00adtions (Wadler and Blott 1989). There are several language mechanisms that are inspired by type \nclasses: Isabelle s type classes (Haftmann and Wenzel 2006), Coq s type classes (Sozeau and Oury 2008), \nC++0X concepts (Gre\u00adgor et al. 2006), BitC s type classes (Shapiro et al. 2008), or JavaGI generalized \ninterfaces (Wehr 2009). Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright c . 2010 ACM \n978-1-4503-0203-6/10/10. . . $10.00 Adriaan Moors Martin Odersky EPFL {adriaan.moors, martin.odersky}@ep..ch \nL\u00a8 ammel and Ostermann (2006) show that type classes are useful to solve several fundamental challenges \nin software engineering and programming languages. In particular type classes support retroactive extension: \nthe ability to extend existing software modules with new functionality without needing to touch or re-compile \nthe original source. Type classes are also recognized (Bernardy et al. 2008; Garcia et al. 2007; Siek \nand Lumsdaine 2008) as a good mechanism for concept-based C++ style generic programming (Musser and Stepanov \n1988), and have more recently evolved into a mechanism for type-level computation (Chakravarty et al. \n2005b; Jones 2000; Schrijvers et al. 2008). Existing proposals for type-class-like mechanisms in OO languages \nare rather heavyweight. The JavaGI proposal is to extend Java with generalized interfaces and generalized \ninterface implementations. Similarly, the C++0X concepts proposal is to extend C++ with concepts and \nmodel (or concept-map) declarations to express concept-interfaces and their implementations. In some \nsense the additional con\u00adstructs in JavaGI and C++0X overlap with conventional OO interfaces and classes, \nwhich play similar roles for de.ning the interfaces of objects and their implementations. Type classes \ncomprise various language constructs that can be understood in isolation. The .rst role of type classes \nis to de.ne concepts: a set of requirements for the type pa\u00adrameters used by generic algorithms. For \nexample, a sorting algorithm on lists can be expressed generically, for any el\u00adements of type T, provided \nthat we know how to compare values of type T. One way to achieve this in an OO language with generics \nis to de.ne the sorting function as follows: def sort [T ](xs : List [T ]) (ordT : Ord [T ]) : List [T \n] In this de.nition, the role of ordT is to provide the compar\u00adison function for elements of type T. \nThe Ord [T ] interface, expressed as a trait in Scala, trait Ord [T ] { def compare (a : T,b : T) : Boolean \n } de.nes the ordering concept. Concepts are implemented for particular types by a model, which corresponds \nto a type class instance in Haskell, or an object in Scala.  object intOrd extends Ord [Int] { def compare \n(a : Int,b : Int) : Boolean = a . b } However, this simple OO approach has one important limitation \nin practice: constraints such as ordT have to be explicitly passed to generic algorithms, like any other \nargu\u00adments. While for the de.nition of sort above this may not look too bad, many generic algorithms \nrequire multiple con\u00adstraints on their type parameters, and passing all of these explicitly is cumbersome. \nThe second role of type classes is to propagate constraints like ordT automatically, making generic algorithms \nconve\u00adnient and practical to use. Scala took inspiration from type classes and introduced implicits: \na mechanism for implicitly passing arguments based on their types. Thus, in Scala, the ordering constraint \ncan be implicitly passed by adding an implicit quali.er before the argument: def sort [T ](xs : List \n[T ]) (implicit ordT : Ord [T ]) : List [T ] Likewise potential candidate models can be considered by \nthe compiler by being quali.ed with an implicit keyword: implicit object intOrd extends Ord [Int] ... \nThis allows a convenient use of sort scala > sort (List (3, 2,1)) List (1,2,3) just like the Haskell \nprogram using type classes. Further\u00admore, sort can be called with an additional ordering ar\u00adgument such \nas: sort (List (3,2,1)) (mySpecialOrd), where mySpecialOrd is another model of the ordering concept for \nintegers. This is useful for resolving ambiguities: it is rea\u00adsonable to have various orderings for the \nsame type. In a way type-class-style concepts provide a service like F-bounded polymorphism (Canning \net al. 1989), which is found in conventional OO languages like Java, C# or Scala. Unlike type-parameter \nbounds, which impose constraints directly on the values of the bounded type, concepts like Ord [T ] provide \nthe evidence that T satis.es the constraints externally. The drawback of concept-style constraints is \nthat dynamic dispatching over the instances of T is not available, but in return support for multi-type \nconcepts is better and retroactive modeling of concepts becomes possible. Contributions We describe a \nlightweight approach to type classes that can be employed in any object-oriented language that supports \ngenerics. We capture the essence of type class programming as the CONCEPT pattern, and show how im\u00adplicits \nmake the pattern practical to use. We illustrate our approach using several applications and offer an \nanswer to Cook (2009) s dinner quiz on the relation between objects and ADTs: in an OO language with \ngenerics, ADT signa\u00adtures can be viewed as a particular class of objects. We should note that implicits \nhave been part of Scala for a while now (Moors et al. 2008; Odersky et al. 2006) and, in the Scala community, \nthe encoding of type classes using im\u00adplicits is folklore. However, as so often with folklore, it was \nnever written down coherently, while the more advanced fea\u00adtures have not been documented at all: later \nsections of this paper describe Scala s answer to overlapping instances (Pey\u00adton Jones et al. 1997), \nassociated types (Chakravarty et al. 2005b), as well as how Scala s approach to type classes has surpasses \nHaskell type classes in some ways. These ad\u00advanced features are used to introduce the idea of specify\u00ading \nrelations on types using implicits, which is illustrated through several examples. Finally, we show that \nScala has excellent support for generic programming. Running the examples Most examples compile as-is \nus\u00ading Scala 2.8.0. Some of the more advanced ones rely on ex\u00adperimental support for dependent method \ntypes, which must be enabled using the -Xexperimental switch. Unfortunately, some examples are affected \nby bugs related to the interac\u00adtion between dependent method types and implicits. These are .xed in a \ndevelopment branch1, which will be merged into trunk shortly, and thus appear in nightly builds leading \nup to the 2.8.1 release. 2. Type Classes in Haskell This section introduces Haskell type classes as originally \nproposed by Wadler and Blott (1989), as well as some sim\u00adple, common extensions. 2.1 Single-parameter \ntype classes The original model of type classes consists of single parame\u00adter type classes, which enables \nthe de.nition of ad-hoc over\u00adloaded functions like comparison, pretty printing or parsing. class Ord \na where (.) :: a . a . Bool class Show a where show :: a . String class Read a where read :: String . \na A type class declaration consists of: a class name such as Ord, Show or Read; a type parameter; and \na set of method declarations. Each of the methods in the type class declara\u00adtion should have at least \none occurrence of the type param\u00adeter in their signature (either as an argument or as a return type). \nIf we think of the type parameter a in these type class declarations as the equivalent of the self argument \nin an OO language, we can see that a few different types of methods can be modeled: 1 http://github.com/adriaanm/scala/tree/topic/retire_ \ndebruijn_depmet  Consumer methods like show are the closest to typical OO methods. They take one argument \nof type a, and using that argument they produce some result.  Binary methods like . can take two arguments \nof type a, and produce some result. This appears to show some con\u00adtrast with OO programming, since it \nis well-known that binary (and n-ary methods in general) are hard to deal with (Bruce et al. 1995). However, \nwe should note that type class binary method arguments are only statically dispatched and not dynamically \ndispatched.  Factory methods such as read return a value of type a instead of consuming values of that \ntype. In OOP factory methods can be dealt with in different ways (for example, by using static methods). \n Type class declarations express generic programming concepts (Bernardy et al. 2008), and the models \n(or im\u00adplementations) of these concepts are given by type classes instances. For example instance (Ord \na,Ord b) . Ord (a, b) where (xa,xb) . (ya, yb)= xa < ya . (xa = ya . xb . yb) declares a model of the \nordering concept for pairs. In this case, the ordering model itself is parametrized by an order\u00ading model \nfor each of the elements of the pair. With the or\u00addering constraints we can de.ne a generic sorting function: \nsort :: Ord a . [a] . [a] This means sort takes a list of elements of an arbitrary type a and returns \na list of the same type, as long as the type of the elements is in the Ord type class, hence the Ord \na . context. A call to sort will only type check if a suitable type class instance can be found. Other \nthan that, the caller does not need to worry about the type class context, as shown in the following \ninteraction with a Haskell interpreter: Prelude > sort [(3,5),(2,4),(3,4)] [(2,4),(3,4), (3, 5)] One \ninstance per type A characteristic of (Haskell) type classes is that only one instance is allowed for \na given type. For example, the alternative ordering model for pairs instance (Ord a,Ord b) . Ord (a, \nb) where (xa,xb) . (ya, yb)= xa . ya . xb . yb in the same program as the previous instance is forbidden \nbecause the compiler automatically picks the right type class instance based on the type parameter of \nthe type class. Since in this case there are two type class instances for the same type, there is no \nsensible way for the compiler to choose one of these two instances.  2.2 Common extensions Multiple-parameter \ntype classes A simple extension to Wadler and Blott s proposal are multiple parameter type\u00adclasses (Peyton \nJones et al. 1997), which lifts the restriction of a single type parameter: class Coerce a b where coerce \n:: a . b instance Coerce Char Int where coerce = ord instance Coerce Float Int where coerce = .oor The \nclass Coerce has two type parameters a and b and de.nes a method coerce, which converts a value of type \na into a value of type b. For example, by de.ning instances of this class, we can de.ne coercions from \ncharacters to integers and from .oating point numbers to integers. Overlapping instances Another common \nextension of type classes allows instances to overlap (Peyton Jones et al. 1997), as long as there is \na most speci.c one. For example: instance Ord a . Ord [a] where ... instance Ord [Int] where ... Despite \ntwo possible matches for [Int], the compiler is able to make an unambiguous decision to which of these \nin\u00adstances to pick by selecting the most speci.c one. In this case, the second instance would be selected. \n3. Implicits This section introduces the Scala implementation of implic\u00adits and shows how implicits provide \nthe missing link for type class programming to be convenient in OO languages with generics. 3.1 Implicits \nin Scala Scala automates type-driven selection of values with the implicit keyword. A method call may \nomit the .nal argu\u00adment list if the method de.nition annotated that list with the implicit keyword, and \nif, for each argument in that list, there is exactly one value of the right type in the implicit scope, \nwhich roughly means that it must be accessible without a pre.x. We will describe this in more detail \nlater. To illustrate this, the following example introduces an implicit value out, and a method that \ntakes an implicit ar\u00adgument o : PrintStream. The .rst invocation omits this argu\u00adment, and the compiler \nwill infer out. Of course, the pro\u00adgrammer is free to provide an explicit argument, as illus\u00adtrated in \nthe last line. import java.io.PrintStream implicit val out = System.out def log (msg : String)(implicit \no : PrintStream) = o.println (msg) log (\"Does not compute!\")] log (\"Does not compute!!\")(System.err) \n  Note that the arguments in an implicit argument list are part of the implicit scope, so that implicit \narguments are propa\u00adgated naturally. In the following example, logTm s implicit argument o is propagated \nto the call to log. def logTm (msg : String)(implicit o : PrintStream) : Unit = log (\"[\" + new java.util.Date \n() + \"]\" + msg) The implicit argument list must be the last argument list and it may either be omitted \nor supplied in its entirety. However, there is a simple idiom to encode a wildcard for an implicit argument. \nTo illustrate this with our running example, sup\u00adpose we want to generalize logTm so that we can specify \nan arbitrary pre.x, and that we want that argument to be picked up from the implicit scope as well. def \nlogPre.x (msg : String) (implicit o : PrintStream,pre.x : String) : Unit = log (\"[\" + pre.x + \"]\" + msg) \n Now, with the following de.nition of the polymorphic method ?, def ?[T ](implicit w : T) : T = w which \nlooks up an implicit value of type T in the implicit scope, we can write logPre.x (\"a\")(?,\"pre\"), omitting \nthe value for the output stream, while providing an explicit value for the pre.x. Type inference and \nimplicit search will turn the call ? into ?[PrintStream](out), assuming out is in the implicit scope \nas before. Implicit scope When looking for an implicit value of type T, the compiler will consider implicit \nvalue de.nitions (de.nitions introduced by implicit val, implicit object, or implicit def), as well as \nimplicit arguments that have type T and that are in scope locally (accessible without pre.x) where the \nimplicit value is required. Additionally, it will consider implicit values of type T that are de.ned \nin the types that are part of the type T, as well as in the companion objects of the base classes of \nthese parts. The set of parts of a type T is determined as follows: for a compound type T1 with ... \nwith Tn, the union of the parts of Ti, and T,  for a parameterized type S [T1,...,Tn ], the union of \nthe parts of S and the parts of Ti,  for a singleton type p.type, the parts of the type of p,  for \na type projection S # U, the parts of S as well as S # U itself,  in all other cases, just T itself. \n Figure 1 illustrates the local scoping of implicits. Two models for Monoid [Int] exist, but the scope \neach of them is limited to the enclosing declaration. Thus the de.nition of sum in object A will use \nthe sumMonoid implicit. Similarly, in the object B, product will use the prodMonoid implicit. trait Monoid \n[A] {def binary op (x : A,y : A) : A def identity : A } def acc[A](l : List [A]) (implicit m : Monoid \n[A]) : A = l.foldLeft (m.identity) ((x,y) . m.binary op (x,y)) object A { implicit object sumMonoid extends \nMonoid [Int] {def binary op (x : Int,y : Int)= x + y def identity = 0 } def sum (l : List [Int]) : Int \n= acc (l) }object B {implicit object prodMonoid extends Monoid [Int] {def binary op (x : Int,y : Int)= \nx * y def identity = 1 } def product (l : List [Int]) : Int = acc (l) } val test : (Int, Int,Int)= {import \nA. import B. val l = List (1, 2,3,4,5) (sum (l),product (l),acc (l)(prodMonoid)) } Figure 1. Locally \nscoped implicits in Scala. Furthermore, both implicits can be brought into scope us\u00ading import and the \nuser can choose which implicit to use by explicitly parameterizing a declaration that requires a monoid. \nThus, the result of executing test is (15,120,120). Note that, if instead of acc (l)(prodMonoid) we had \nused acc (l) in the de.nition of test, an ambiguity error would be reported, because two different implicit \nvalues of the same type (prodMonoid and sumMonoid) would be in scope. Implicit search and overloading \nTo determine an implicit value, the compiler searches the implicit scope for the value with the required \ntype. If no implicit can be found for an implicit argument with a default value, the default value is \nused. If more than one implicit value has the right type, there must be a single most speci.c one according \nto the following ordering, which is de.ned in more detail by (Odersky 2010, 6.26.3). An alternative A \nis more speci.c than an alternative B if the relative weight of A over B is greater than the relative \nweight of B over A. The relative weight is a score between 0 and 2, where A gets a point over B for being \nas speci.c as B, and another if it is de.ned in a class (or in its companion ob\u00adject) which is derived \nfrom the class that de.nes B, or whose companion object de.nes B. Roughly, a method is as spe\u00adci.c as \na member that is applicable to the same arguments, a polymorphic method is compared to another member \nafter stripping its type parameters, and a non-method member is as speci.c as a method that takes arguments \nor type param\u00adeters.  Finally, termination of implicit search is ensured by keep\u00ading track of an approximation \nof the types for which an im\u00adplicit value has been searched already (Odersky 2010, 7.2).  3.2 Implicits \nas the missing link Implicits provide the type-driven selection mechanism that was missing for type class \nprogramming to be convenient in OO. For example, the Ord type class and the pair instance that was presented \nin Section 2 would correspond to: trait Ord [T ] { def compare (x : T,y : T) : Boolean } implicit def \nOrdPair [A,B] (implicit ordA:Ord [A], ordB:Ord [B]) = new Ord [(A, B)] { def compare (xs : (A,B),ys : \n(A,B)) = ... } Note that the syntactic overhead compared to Haskell (high\u00adlighted in gray) includes \nuseful information: type class in\u00adstances are named, so that the programmer may supply them explicitly \nto resolve ambiguities manually. The cmp function is rendered as the following method: def cmp [a](x \n: a,y : a)(implicit ord : Ord [a]) : Boolean = ord.compare (x,y) This common type of implicit argument \ncan be abbreviated using context bounds (highlighted in gray): def cmp [a:Ord ](x : a, y : a) : Boolean \n= ?[Ord [a]].compare (x,y) Since we do not have a name for the type class instance anymore, we use the \n? method to retrieve the implicit value for the type Ord [a]. Note that the same shorthand can be used \nin the OrdPair method above, reducing the syntactic noise. Furthermore, the cmp provides a slightly more \nterse interface to the Ord type class in the sense that a client can now call cmp ((3,4),(5,6)) instead \nof ?[Ord [(Int,Int)]].compare ((3,4),(5, 6)). The pimp-my-library pattern Neither cmp ((3,4),(5, 6)) \nor ?[Ord [(Int,Int)]].compare ((3,4),(5,6)) are idiomatic in OOP. The pimp my library pattern (Odersky \n2006) uses implicits to allow the more natural x.compare (y), assum\u00ading the type of x does not de.ne \nthe compare method. In trait Ord [T ] {def compare (x : T,y : T) : Boolean } class Apple (x : Int) {} \nobject ordApple extends Ord [Apple] { def compare (a1 : Apple,a2 : Apple)= a1.x . a2.x } def pick [T \n](a1 : T, a2 : T)(ordA : Ord [T ]) = if (ordA.compare (a1,a2)) a2 else a1 val a1 = new Apple (3) val \na2 = new Apple (5) val a3 = pick (a1, a2)(ordApple) Figure 2. Apples to Apples with the CONCEPT pattern. \nScala, implicit values that have a function type act as im\u00adplicit conversions. For a method call such \nas x.compare (y) to be well-typed, the type of x must either de.ne a suitable compare method, or there \nmust be an implicit conversion c in scope so that (c (x)).compare (y) is well-typed without further use \nof implicit conversions. Thus, it suf.ces to de\u00ad.ne an implicit method (the compiler converts methods \nto functions when needed) mkOrd that will convert a value of a type that is in the Ord type class into \nan object that has the expected interface: implicit def mkOrd [T : Ord](x : T) : Ordered [T ] = new Ordered \n[T ] {def compare (o : T)= ?[Ord [T ]].compare (x,o) } Leaving off the target of the comparison in the \ncompare method, which has been passed to the implicit conversion mkOrd, Ordered is de.ned as: trait Ordered \n[T ] { def compare (o : T) : Boolean } 4. The CONCEPT Pattern This section introduces the CONCEPT pattern, \nwhich is in\u00adspired by the basic Haskell type classes presented in Sec\u00adtion 2 and C++ concepts. This pattern \ncan be used in any OO language that supports generics, such as current versions of Java or C#. However, \nwithout support for implicits, some applications can be cumbersome to use due to additional pa\u00adrameters \nfor the constraints. 4.1 Concepts: type-class-style interfaces in OO The CONCEPT pattern aims at representing \nthe generic pro\u00adgramming notion of concepts as conventional OO interfaces with generics. Concepts describe \na set of requirements for the type parameters used by generic algorithms. Figure 2 shows a small variation \nof the apples-to-apples motivational example for concepts (Garcia et al. 2007). This example serves the \npurpose of illustrating the different actors in the CONCEPT pattern. The trait Ord [T ] is an example \nof a concept interface. The type argument T of a concept inter\u00adface is the modeled type; an Apple is \na concrete modeled type. Actual objects implementing concept interfaces such as ordApple are called models. \nFinally, whenever ambigu\u00adity arises, we will refer to methods in a concept interface as conceptual methods \nto distinguish them from conventional methods de.ned in the modeled type.  The CONCEPT pattern can model \nn-ary, factory and con\u00adsumer methods just like type classes. Concept interfaces for the type classes \nShow and Read presented in Section 2.1 are: trait Show[T ] { def show (x : T) : String } trait Read \n[T ] { def read (x : String) : T } The printf example in Section 2.1 presents an example of a concept-interface \nwith a factory method. Most of the examples in this paper involve consumer methods. Multi-type Concepts \nUsing standard generics it is possible to model multi-type concepts. That is, concepts that involve several \ndifferent modeled types. For example, the Coerce type class in Section 2.2 can be expressed as a concept \ninterface as: trait Coerce[A,B] { def coerce (x : A) : B } The zipWithN example (in Section 6.4) and \ngeneralized constraints (in Section 6.6) provide applications of multi\u00adtype concepts. Bene.ts of the \nCONCEPT pattern The CONCEPT pattern offers the following advantages: 1. Retroactive modeling: The CONCEPT \npattern allows mimicking the addition of a method to a class with\u00adout having to modify the original class. \nFor example, in Figure 2, the declaration of Apple did not require any knowledge about the compare functionality \nupfront. The ordApple model adds support for such method externally. 2. Multiple method implementations: \nIt is possible to have multiple implementations of conceptual methods for the same type. For example, \nan alternative ordering model for apples can be provided:  object ordApple2 extends Ord [Apple] {def \ncompare (a1 : Apple,a2 : Apple)= a1.x > a2.x } 3. Binary (or n-ary) methods: Conceptual methods can have \nmultiple arguments of the manipulated type. Thus a sim\u00adple form of type-safe statically dispatched n-ary \nmethods is possible. 4. Factory methods: Conceptual methods do not need an actual instance of the modeled \ntype. Thus they can be factory methods.  Limitations and Alternatives The main limitation of the CONCEPT \npattern is that all arguments of conceptual meth\u00adods are statically dispatched. Thus, conceptual methods \nare less expressive than conventional OO methods, which allow the self-argument to be dynamically dispatched, \nor multi\u00admethods (Chambers and Leavens 1995), in which all argu\u00adments are dynamically dispatched. Bounded \npolymorphism offers an alternative to type\u00adclass-style concepts. With bounded polymorphism the apples\u00adto-apples \nexample could be modeled as follows: trait Ord [T ] { def compare (x : T) : Boolean } class Apple (x \n: Int) extends Ord [Apple] ... The main advantage of this approach is that compare is a real, dynamically \ndispatched, method of Apple, and all the private information about Apple objects is available for the \nmethod de.nition. However, with this alternative, modeled types such as Apple have to state upfront which \nconcept in\u00adterfaces they support. This precludes retroactive modeling and makes it harder to support \nmultiple implementations of a method for the same object. Multi-type concepts are pos\u00adsible, but they \ncan be quite cumbersome to express and they can lead to a combinatorial explosion on the number of con\u00adcept \ninterfaces (J\u00a8 arvi et al. 2003). Factory methods can be supported with this approach through a static \nmethod, al\u00adthough this dictates a single implementation. Binary meth\u00adods such as compare are also possible, \nalthough they are asymmetric in the sense that the .rst argument is dynami\u00adcally dispatched, whereas \nthe second argument is statically dispatched. Language Support In languages such as Java or C# con\u00adcepts \nneed to be explicitly passed as in Figure 2. In Scala it is possible to pass concepts implicitly as shown \nin Sec\u00adtion 3.2. Additionally, in languages like Java or C#, there is some syntactic noise because the \nmethod cannot be invoked directly on the manipulated object: a = new Apple (3); a.compare (new Apple \n(5));  is invalid. Instead, we must write: a = new Apple (3); ordApple.compare (a,new Apple (5)); In \nScala, as discussed in Section 3.2, it is possible to elim\u00adinate this overhead using implicits. All that \nis needed is 1) mark the models (and any possible constraints) with implicit and 2) create a simple interface \nfor the comparison function that takes the ordering object implicitly. Thus provided that the apples-to-apples \nis modi.ed as follows: implicit object ordApple extends Ord [Apple] ... def cmp [A](x : A,y : A)(implicit \nord : Ord [A]) = ord.compare (x,y) Then we can write: a = new Apple (3); cmp (a, new Apple (5)); Modifying \npick similarly, def pick [T : Ord](a1 : T,a2 : T)= if (cmp (a1,a2)) a2 else a1 allows rewriting the \nvalue a3 as: val a3 = pick (a1,a2) In C#, extension methods provide language support for (stat\u00adically \ndispatched) retroactive implementations. Haskell type classes, JavaGI and the C++0X concepts proposal \nprovide direct language support for concept-style interfaces. Jav-aGI s generalized interfaces offer \nmore expressiveness than the CONCEPT pattern. JavaGI s retroactive implementations support multi-methods \non the instances of the manipulated types. The Scala approach to concept-style interfaces is to ex\u00adpress \nthem with the CONCEPT pattern and implicits. This makes the pattern very natural to use without an additional, \npattern-speci.c, language construct. 5. Applications and Comparison with Type Classes The CONCEPT pattern \nhas several applications, including some that go beyond concepts traditional application, con\u00adstrained \npolymorphism. The pattern is illustrated by exam\u00adple in the next few subsections. This section also compares \nthe programs written with the CONCEPT pattern with simi\u00adlar programs using type classes. To help in this \ncomparison, the signi.cant differences between the OO programs and the equivalent programs using type \nclasses are marked in gray. The corresponding Haskell code is available in Appendix A. trait Eq[T ] {def \nequal (a : T,b : T) : Boolean } trait Ord [T ] extends Eq[T ] {def compare (a : T,b : T) : Boolean def \nequal (a : T,b : T) : Boolean = compare (a, b) . compare (b,a) } class IntOrd extends Ord [Int] {def \ncompare (a : Int, b : Int)= a . b } class ListOrd [T ](ordD:Ord [T ]) extends Ord [List [T ]] {def compare \n(l1 : List [T ],l2 : List [T ]) = (l1,l2) match {case (x :: xs,y :: ys) . if (ordD.equal (x,y)) compare \n(xs,ys) else ordD.compare (x,y) case ( ,Nil) . false case (Nil, ) . true }} class ListOrd2[T ](ordD : \nOrd [T ]) { extends Ord [List [T ]] { private val listOrd = new ListOrd [T ](ordD) def compare (l1 : \nList [T ],l2 : List [T ]) = (l1.length < l2.length) . listOrd.compare (l1,l2) } Figure 3. Equality and \nordering concepts and some models. 5.1 Ordering concept Figure 3 shows how to implement an ordering \nconcept us\u00ading the CONCEPT pattern. This concept is similar to the one used in Figure 2, except that \nit introduces an equality con\u00adcept Eq [T ]. For convenience, we use subtyping to express the re.nement \nrelation between the concepts Eq and Ord, although delegation, which is closer to the typical Haskell \nimplementation (see Figure 7), would work as well. In con\u00adventional OO languages such as Java or C# the \ntraits Eq and Ord would correspond to interfaces. Thus, the default def\u00adinition for equality in the Ord \ntrait would not be de.nable directly on the interface. Scala traits offer a very convenient way to express \nsuch default de.nitions, but such functional\u00adity can be mimicked in other ways in Java or C#. The classes \nIntOrd, ListOrd and ListOrd2 de.ne three models of Ord; the .rst one for integers and the other two for \nlists.  def cmp[T ](x : T,y : T)(implicit ord : Ord [T ]) = ord.compare (x,y) implicit val IntOrd = \nnew Ord [Int] {...} implicit def ListOrd [T ](implicit ordD:Ord [T ]) = new Ord [List [T ]] {...} def \nListOrd2 [T ](implicit ordD : Ord [T ]) = new Ord [List [T ]] {...} Figure 4. Variation of the Ordering \nsolution using implicits. The three models illustrate the retroactive capabilities of the CONCEPT pattern: \nthe models are added after Int and List[T ] have been de.ned. The two models for lists illustrate that \nmultiple models can co-exist at the same time. Comparison with Type Classes The essential difference \nbetween the OO code in Figure 3 and the similar de.nitions using type classes (which can be found in \nFigure 13) is that models, and model arguments, need to be named. In Haskell, instances can be viewed \nas a kind of anonymous objects, which only the compiler gets direct access to. This partly explains why \nthe de.nition of ListOrd2 is grayed out: in Haskell two instances for the same modeled type are forbidden. \nIn the OO version, it is necessary to .rst create the models explicitly. For example: def sort [T ](xs \n: List [T ]) (ordT : Ord [T ]) : List [T ]= ... val l1 = List (7,2,6,4,5,9) val l2 = List (2,3) val test \n= new ListOrd (new IntOrd ()).compare (l1,l2) val test2 = new ListOrd2 (new IntOrd ()).compare (l1,l2) \nval test3 = sort (l1)(new ListOrd (new IntOrd ())) In the type class version, the equivalent code would \nbe: sort :: Ord t .[t] .[t] l1 =[7,2, 6,4,5,9] l2 =[2,3] test = compare l1 l2 test3 = sort l1 Clearly, \nin the OO version, the use of compare in test and test2 is less convenient than simply calling compare \nl1 l2, but it does offer the possibility of switching the implemen\u00adtation of the comparison operation \nin test2. In test3 creating the models explicitly is also somewhat verbose and inconve\u00adnient. Solution \nusing implicits The convenience of type classes can be recovered with implicits. Figure 4 shows a variation \ntrait Set [S] {val empty : S def insert (x : S,y : Int) : S def contains (x : S, y : Int) : Boolean def \nunion (x : S,y : S) : S } class ListSet extends Set [List [Int]] {val empty = List () def insert (x : \nList [Int], y : Int)= y :: x def contains (x : List [Int],y : Int)= x.contains (y) def union (x : List \n[Int],y : List [Int]) = x.union (y) } class FunctionalSet extends Set [Int . Boolean] {val empty =(x \n: Int) . false def insert (f : Int . Boolean,y : Int)= z . y.equals (z) . f (z) def contains (f : Int \n. Boolean,y : Int)= f (y) def union (f : Int . Boolean, g : Int . Boolean)= y . f (y) . g (y) } Figure \n5. An ADT signature and two implementations. of the code in Figure 3. Only the differences are shown: \nde.nitions are used instead of conventional OO classes to de.ne the models for Ord; and we use a de.nition \ncmp to provide a nice interface to the compare method. The .rst two models are implicit, but ListOrd2 \ncannot be made implicit because it would clash with ListOrd. The client code for the test functions is \nsimpli.ed, being comparable to the version with Haskell type classes. Furthermore, it is still possible \nto de.ne test2. val test = cmp (l1,l2) val test2 = cmp (l1,l2)(ListOrd2) val test3 = sort (l1)  5.2 \nAbstract data types Cook (2009) shows that type classes can be used to imple\u00adment what is effectively \nthe algebraic signature of an Ab\u00adstract Data Type (ADT). Programs using these type classes in a certain \ndisciplined way have the same abstraction ben\u00ade.ts as ADTs. Exploiting this observation, we now show \na simple and practical encoding of ADTs in an object-oriented language with generics using the CONCEPT \npattern. ADT signatures show an application of the pattern that is differ\u00adent from how concepts are traditionally \nused. Additionally, it illustrates why passing a model explicitly is sometimes de\u00adsirable. Figure 5 models \nan ADT signature for sets of integers using the CONCEPT pattern. The trait Set [S], the concept interface, \nde.nes the ADT signature for sets. The type S is the modeled type. The method empty is an example of \na factory method: a new set is created without any previous set instance. The methods insert and contains \nare examples of consumer methods: they act on existing instances of sets to achieve their goal. Finally \nunion provides an example of a binary method: two set instances are needed to take their union. Two alternative \nmodels are shown: ListSet, using a lists to model sets; and FunctionalSet, which uses a boolean predicate \ninstead.  The client programs using models of ADT signatures can be used in a very similar way to ADTs \nimplemented using ML modules (MacQueen 1984). For example: val setImpl1 = new ListSet () val setImpl2 \n= new FunctionalSet () def test1 [S](s:Set [S]) : Boolean = s.contains (s.insert (s.insert (s.empty,5),6),6) \nIn this case two different implementations of sets, setImpl1 and setImpl2, are created. The de.nition \ntest1 takes a set implementation and de.nes a program using that imple\u00admentation. Importantly, the set \nimplementation is polymor\u00adphic on S, which means that any subclass of Set [S] will be valid as an argument. \nIn particular, both test1 (setImpl1) and test1 (setImpl2) are valid arguments. A reasonable question \nto ask at this point is whether the programs written with ADT signatures are actually related to conventional \nprograms using ADTs. We discuss this issue next. Where is the existential? In their seminal paper on \nADTs, Mitchell and Plotkin (1988) show that abstract types have existential type . Formally an ADT can \nbe viewed has two distinct parts: the ADT signature and the existential encap\u00adsulating the type of the \nconcrete representation: SetADT = . S. Set [S] The trait Set[S] de.nes only the signature, but the existential, \nwhich provides information hiding, is missing. This means that certain programs can exploit the concrete \nrepresenta\u00adtion, breaking encapsulation. Still, as Cook observes, it is possible to enforce information \nhiding with some discipline and the help of the type system; if client programs do not exploit the concrete \nrepresentations of S then the same ben\u00ade.ts of ADTs apply. To see why this is the case consider the equivalent \ntype-theoretic version of the test1 program: test1 : SetADT . Boolean test1 = .s . s.contains (s.insert \n(s.insert (s.empty,5),6),6) Unfolding the SetADT type into its de.nition yields test1 : (. S. Set [S]) \n. Boolean and this type is isomorphic to test1 : . S. Set [S] . Boolean which is the type-theoretic type \ncorresponding to the Scala type of test1. In other words, test1 has the existential type that pro\u00advides \nthe information hiding of the equivalent program with ADTs. While it is certainly debatable whether or \nnot the ex\u00adistential should be placed in the actual ADT de.nition, con\u00adcept interfaces are a simple way \nto encode ADT-like pro\u00adgrams in any OO language with generics. This provides an alternative answer to \nCook s dinner quiz on the relationship between objects an ADTs: in an OO language with generics, ADT \nsignatures can be viewed as concept interfaces, and im\u00adplementations of these signatures can be modeled \nas objects. Comparison with Type Classes There are no signi.cant differences between the OO version of \nthe program and the Haskell version (which can be found in Figure 14), except that the models need to \nbe named. However, client code is more interesting to compare. While in the OO version we write: def \ntest1 [S](s:Set [S]) : Boolean = s.contains (s.insert (s.insert (s.empty, 5), 6),6) the Haskell version \nof this code test1 :: Set s . Bool test1 = contains (insert (insert empty 5) 6) does not work. The problem \nis that this program is ambigu\u00adous: since Haskell type classes work under the assumption that every dictionary \nis inferred by the compiler, there is no straightforward way to tell test1 which speci.c instance of \nSet is to be used. Programs using ADT-like structures show how certain programs do not .t well with the \nimplicit nature of type classes. To be more precise, ADTs .t very well within the class of programs that \ntype classes capture, however ex\u00adplicitly passing type class instances (the models of ADT signatures) \nis desirable. The CONCEPT pattern solution is better in this respect because the models can be explicitly \npassed.  5.3 Statically-typed printf Our .nal application of the CONCEPT pattern is a statically\u00adtyped \nversion of the C printf function similar to the one pre\u00adsented by (Kennedy and Russo 2005). This example \nshows that often it is possible to model structures resembling exten\u00adsible (in the sense that new constructors \ncan be added) gen\u00aderalized algebraic datatypes (GADTs) (Peyton Jones et al. 2006) using the CONCEPT pattern. \nFigure 6 shows the implementation of a simple version of the C-style printf function using the CONCEPT \npattern. The implementation exploits an insight by (Danvy 1998), who realized that by changing the representation \nof the for\u00admat string, it is possible to encode printf in a conventional  trait Format [A] {def format \n(s : String) : A } def printf [A](format:Format [A]) : A = format.format (\"\") class I [A](formatD:Format \n[A]) extends Format [Int . A] {def format (s : String)= i . formatD.format (s + i.toString) } class C \n[A](formatD:Format [A]) extends Format [Char . A] { def format (s : String)= c . formatD.format (s + \nc.toString) } class E extends Format [String] {def format (s : String)= s } class S [A](l : String, \nformatD : Format [A]) extends Format [A] { def format (s : String)= formatD.format (s + l) } Figure \n6. Printf as an instance of the CONCEPT pattern Hindley-Milner type system. The basic idea of the OO \nver\u00adsion is to use a concept interface Format to represent the format string of printf . Noteworthy, \nthe format conceptual method is a factory: it creates instances of the modeled types. Four different \nmodels are provided: one for integers, an\u00adother for characters, a termination string and string literals. \nOne advantage of this solution is that it is easy to introduce new format speci.ers simply by creating \na new model of the Format concept. Comparison with Type Classes Like with the previous two examples, \nthe models and model arguments need to be named in the OO version. An important difference is that, with \ntype classes, we cannot implement a corresponding instance for the S [A] model. The problem is that, \nto de.ne S,a String argument is required but type class instances can only take type class dictionaries \nin the instance constraints. Thus, the following is not allowed: instance (String,Format a) . Format \na where ... Another difference concerns the client code. In the OO ver\u00adsion, the formatting string needs \nto be explicitly constructed and passed. This has both advantages and disadvantages. The advantage is \nthat the format string can be chosen pre\u00adcisely, as it it the case for the standard printf function. \nval fmt : Format [Int . Char . String]= new S (\"Int: \",new I (new S (\" Char: \", new C (new S (\".\",new \nE))))) val test = printf (fmt)(3)( c ) For example, we can construct format strings using the instances \nof the S class. In Haskell, such .exibility is not eas\u00adily available. Nevertheless, if such .exibility \nis not required, the dictionary is inferred in Haskell, making the similar pro\u00adgrams more compact. test \n:: String test = printf (3 :: Int) c Finally, we should note that if we modify the OO version into a \nmore idiomatic version using Scala s implicits (as done for the ordering example in Section 5.1), then \nwe can also infer the same format strings as in the Haskell version.  5.4 Type class programs are OO \nprograms As we have seen so far, programs written with type classes seem to have a close correspondence \nwith OO programs. Still, how can we more precisely pinpoint the relationship between a Haskell type class \nprogram and an OO program? One answer to this question, which we describe next, lies on the relationship \nbetween the dictionary transla\u00adtion (Wadler and Blott 1989) of Haskell type classes and a simple form \nof the functional recursive records (Cook and Palsberg 1994) encoding of OO programs. The dictionary \ntranslation, which is used by most Haskell compilers, converts a program using type classes into a pro\u00adgram \nusing no type classes. This translation is necessary be\u00adcause type classes are a language mechanism of \nthe source language, but most Haskell compilers use core languages (usually a variant of System F), which \ndoes not have a native notion of type classes. Figure 7 shows how the program in Figure 13 looks like \nafter the dictionary translation. Like with the OO pro\u00adgrams, the parts that do not have direct correspondents \nin the Haskell type class code are highlighted in gray. Essentially what happens is that the type class \nOrd is translated into a program using a record. Each instance becomes a value (or, more precisely, a \nfunction that takes the dictionaries for the class contexts, if any) that represents the corresponding \ndic\u00adtionary. In the translated code, many of the characteristics of the OO version are present. One similarity \nis that the instances and the arguments need to be named. For example, the corre\u00adsponding value for the \nequality dictionary for lists is de.ned as: listOrd::Ord a . Ord [a] listOrd ordD = Ord ...  data Ord \na = Ord {eq :: a . a . Bool, compare :: a . a . Bool } intOrd::Ord Int intOrd = Ord { eq = . ab . compare \nintOrd a b . compare intOrd b a, compare = . xy . x . y } listOrd::Ord a . Ord [a] listOrd ordD = Ord \n{ eq = .ab . compare (listOrd ordD) ab . compare (listOrd ordD) ba, compare = . l1 l2 . case (l1,l2) \nof (x : xs,y : ys) . if (eq ordD xy) then compare (listOrd ordD) xs ys else compare ordD x y ( ,[]) . \nFalse ( , ) . True } Figure 7. Ordering after the dictionary translation. Here, listOrd is the name \nof the dictionary constructor and ordD is the name of the argument of the constructor. Another similarity \nis that in the invocations of the compare methods: the dictionary value for the method is also explicit. \nFor example, compare ordD x y As it turns out, the dictionary translation version of the Haskell program \nhas so much in common with the OO ver\u00adsion because it corresponds to a simple form of the recursive records \nfunctional encoding of the OO program. The only signi.cant difference between the dictionary translation \nversion and the OO version, highlighted in gray next, is that the Haskell version has some explicit recursive \ncalls on listOrd ordD: listOrd :: Ord a . Ord [a] listOrd ordD = Ord { ... compare = . l1 l2 . case (l1,l2) \nof (x : xs,y : ys) . if (eq ordD x y) then compare (listOrd ordD) xs ys else compare ordD x y ... The \nrecursive records interpretation of OO programs also helps explaining this (super.cial) difference. In \nthe OO program there is an implicitly passed self-argument in compare (xs,ys) (this is sugar for this.compare \n(xs, ys)) and this self-argument is a recursive call in the corresponding recursive records interpretation. \nWhat is happening in the dictionary translation is that recursive calls are directly used. In summary, \nthe relationship between type classes and OO programs is this: every type class program translated us\u00ading \nthe dictionary translation corresponds to a OO program encoded using a simple form of the recursive records \nfunc\u00adtional OO encoding. 6. Advanced Uses of Type Classes This section brie.y explains GHC Haskell s \nassociated types and shows in detail how they can be encoded in Scala using type members and dependent \nmethod types, which are also .rst introduced. The encoding of associated types and other advanced features \nof Scala (such as prioratized overlapping implicits) are illustrated with three examples: type-safe ses\u00adsion \ntypes, an n-ary version of the zipWith function, and an encoding of generalized constraints. We conclude \nthis sec\u00adtion with a description of the pattern that is common to all of these examples. 6.1 Associated \ntypes in GHC Haskell The Glasgow Haskell Compiler (GHC) (Peyton Jones et al. 2009) is a modern Haskell \nimplementation that provides a type class mechanism that goes well beyond Wadler s original proposal. \nOf particular interest is the use of type classes for type-level computation using extensions such as \nassociated types (Chakravarty et al. 2005b). Associated types are type declarations that are associated \nto a type class and that are made concrete in the class s instances, just like type class methods. For \nexample, the class Collects represents an interface for collections of type c with an associated type \nElem c, which denotes the type of the elements of c. class Collects c where type Elem c empty :: c insert \n:: c . Elem c . c toList :: c . [Elem c] Two possible instances are: instance Collects BitSet where \ntype Elem BitSet = Char ... instance (Collects c, Hashable (Elem c)) . Collects (Array Int c) where \n  type Elem (Array Int c)= Elem c ... The basic idea is that, for a BitSet collection, the associated \nelement type should be characters. For arrays of values of some type c, the type of the elements should \nbe the same as the type of the elements of c itself. Associated types require type-level computation. \nIn the Collects example this manifests itself whenever a value of type Elem c is needed. For example, \nwhen using insert the second argument has the type Elem c. For an array of bit sets Array Int BitSet \nthe type Elem (Array Int BitSet) should be evaluated to Char, in order for the type-checker to validate \nsuitable values for that call. This entails unfolding the asso\u00adciated type de.nitions to conclude that \nthe element type of an array of bit sets is indeed a character.  6.2 Implicits and type members Associated \ntypes fell out for free in Scala, with the introduc\u00adtion of implicits, due to existing support for type \nmembers. Before illustrating this, we brie.y introduce type members, path-dependent types and dependent \nmethod types. A type member is a type that can be selected on an object. Like its value-level counterpart, \na type member may be abstract, in which case it is similar to a type parameter, or it may be concrete, \nserving as a type alias. For type safety, an abstract type member may only be selected on a path (Odersky \net al. 2003), a stable (immutable) value. Technically, types may only be selected on types, but a path \np is readily turned into a singleton type p.type, which is the type that is inhabited by exactly one \nvalue: the object ref\u00aderenced by p. The type selection p.T, where T is a type mem\u00adber de.ned in the type \nof p, is syntactic sugar for p.type # T. We say that a type that contains the type p.type depends on \nthe path p. The type p.T is a path-dependent type. Since a method argument is considered a stable value, \na type may depend on it. A method type that depends on one or more of the method s arguments is called \na dependent method type. The simplest example of such a type arises in the following version of the identity \nmethod: def identity (x : AnyRef ) : x.type = x Since values are not allowed in paths (for now), this \nversion of identity must be limited to references. Using this identity, we can statically track that \ny and y2 are aliases: val y = \"foo\" val y2 : y.type = identity (y) For now, these types must be enabled \nexplicitly by the -Xexperimental compiler .ag in Scala 2.8. We can massage identity into a more precise \nversion of the implicit argument wildcard ? that we introduced earlier: def ?[T <: AnyRef ](implicit \nw : T) : w.type = w def add server = In {x : Int . In {y : Int . System.out.println (\"Thinking\") Out \n(x + y, Stop ())}} def add client = Out (3, Out (4, {System.out.println (\"Waiting\") In {z : Int . System.out.println \n(z) Stop ()}})) Figure 8. An example session. This version of ? may be used to access the implicit value \nof type T. Its additional precision will be essential in the examples below, which select type members \non implicit ar\u00adguments. The following examples illustrate that the combi\u00adnation of implicit search and \ndependent method types is an interesting recipe for type-level combination.  6.3 Session types As our \n.rst example, we port a type class encoding of ses\u00adsion types (Honda 1993) by Kiselyov et al. (2009) \nto Scala. Session types describe the relationship between the types of a pair of communicating processes. \nA process is composed of a sequence of smaller processes. For example, the server process in Figure 8 \ntakes two in\u00adtegers arguments as inputs and returns the sum of these two integers as output. The corresponding \nclient performs the dual of the server process. The example uses the elementary processes that are de.ned \nin Figure 9. The Stop process in\u00addicates the end of communication, whereas In and Out pro\u00adcesses are \npaired to specify the .ow of information during the session. An In[a,b] process takes an input of type \na, and continue with a process of type b.2 Since they are duals, add client and add server form a session. \nWe capture the notion of duality in Figure 9. The DualOf relation is de.ned in the comments using in\u00adference \nrules. It is rendered in Scala as the Session trait, which declares the relation on its type parameter \nS (which is aliased as Self for convenience) and its abstract type mem\u00adber Dual, which corresponds to \nan associated type. Thus, an instance of type Session [S] {type Dual = D} is evidence of S DualOf D; \nsuch a value witnesses this fact by describ\u00ading how to compose an instance of S with an instance of D \n(through the run method). StopSession, InDual and OutDual describe what it means for each of the atomic \nprocess types to be in a session with their respective duals by con\u00adstructing the witness at the corresponding \nconcrete types. 2 The + and - symbols denote, respectively, co-variance and contra\u00advariance of the type \nconstructor in these type parameters (Emir et al. 2006).  sealed case class Stop sealed case class In[-A,+B](recv \n: A . B) sealed case class Out [+A,+B](data : A,cont : B) trait Session[S] {type Self = S; type Dual \ntype DualOf [D]= Session [Self ] {type Dual = D}def run (self : Self ,dual : Dual) : Unit } /* StopDual \nStop DualOf Stop */ implicit object StopDual extends Session[Stop] {type Dual = Stop def run (self : \nSelf ,dual : Dual) : Unit = {} } /* Cont DualOf ContD InDual In[Data,Cont] DualOf Out [Data,ContD] */ \nimplicit def InDual[D,C](implicit cont : Session [C]) = new Session[In[D, C]] {type Dual = Out [D, cont.Dual \n] def run (self : Self ,dual : Dual) : Unit = cont.run (self .recv (dual.data ),dual.cont) } /* Cont \nDualOf ContD OutDual Out [Data, Cont] DualOf In[Data,ContD] */ implicit def OutDual [D,C](implicit cont \n: Session[C]) = new Session[Out [D,C]] {type Dual = In[D, cont.Dual ] def run (self : Self ,dual : Dual) \n: Unit = cont.run (self .cont, dual.recv (self .data )) } Figure 9. Session types. The expression InDual \nhas the type3: [D,C](implicit cont : Session[C]) Session[In [D,C]] {type Dual = Out [D, cont.Dual]} This \nis a polymorphic dependent method type, where [D,C] denotes the universal quanti.cation . D,C., (implicit \ncont : Session[C]) describes the argument list, and Session[In [D,C]] {type Dual = Out [D, cont.Dual]} \n3 Note that this type is not expressible directly in the surface syntax. case class Zero () case class \nSucc[N ](x : N) trait ZipWith[N,S] {type ZipWithType def manyApp : N . Stream[S] . ZipWithType def zipWith \n: N . S . ZipWithType = n . f . manyApp (n)(repeat (f )) } def zWith [N,S](n : N,s : S) (implicit zw \n: ZipWith [N,S]) : zw.ZipWithType = zw.zipWith (n)(s) implicit def ZeroZW [S]= new ZipWith[Zero, S] {type \nZipWithType = Stream[S] def manyApp = n . xs . xs } implicit def SuccZW [N,S,R] (implicit zw : ZipWith \n[N,R]) = new ZipWith[Succ[N ],S . R] { type ZipWithType = Stream[S] . zw.ZipWithType def manyApp = n \n. xs . ss . n match {case Succ (i) . zw.manyApp (i)(zapp (xs,ss)) } } Figure 10. N-ary zipWith. is the \nmethod s (inferred) result type, which depends on its cont argument. Using the DualOf type alias, the \nmodelled relation can be made more explicit: Session[In[D, C]] # DualOf [Out [D,cont.Dual]] The same \ntype alias is used in the context bound on runSession s D type parameter, which should be read as: D \nmust be cho\u00adsen so that S is the dual of D . In our mathematical notion, this is rendered as S DualOf \nD. To run the session, the evi\u00addence of S and D being in the DualOf relation is recovered using the ? \nmethod. def runSession[S,D : Session[S] # DualOf ] (session : S,dual : D)= ?[Session [S] # DualOf [D]].run \n(session, dual) def myRun = runSession (add server,add client)  6.4 Arity-polymorphic ZipWith in Scala \nTypically, functional programming languages like Haskell contain implementations of zipWith functions \nfor two list arguments:  zipWith :: (a . b . c) .[a] .[b] .[c] zipWith f (x : xs)(y : ys)= f xy : zipWith \nf xs ys zipWith f =[] McBride (2002) generalized such de.nition into an n-ary zipWith function. zipWithn \n:: (a1 . a2 . ... . an) . ([a1 ] .[a2 ] . ... .[an ]) In other words, zipWithn is a function that given \na function with n arguments and n lists, provides a corresponding ver\u00adsion of the n-ary zipWith function. \nSimilar challenges arise in OO libraries that model databases as collections of N-tuples, where the operations \non these tuples should work for any N. A more general variant of this problem is discussed by Kise\u00adlyov \net al. (2004). This example essentially performs type-level computa\u00adtion, since the return type [a1 ] \n. [a2 ] . ... . [an ] is com\u00adputed from the argument type (a1 . a2 . ... . an). Fig\u00adure 10 shows an implementation \nfor the n-ary zipWith func\u00adtion in Scala. The types Zero and Succ [N ] are Church en\u00adcodings of the natural \nnumbers at the type level. The ZipWith trait is a concept interface with two type arguments: N represents \na natural number; and S is the type of the function argument of zipWithn. The type member ZipWithType \ndetermines the return type. The zWith method is the interface for the n-ary zipWith function. The two \nde.nitions ZeroZW and SuccZW provide two models that, respectively, correspond to the base case (for \nN = 0) and the inductive case. The functions repeat and zapp, used in zipWith and manyApp are de.ned \nas: def repeat [A](x : A) : Stream[A]= cons (x,repeat (x)) def zapp[A,B](xs : Stream[A . B],ys : Stream[A]) \n= (xs, ys) match {case (cons (f ,fs),cons (s, ss)) . cons (f (s),zapp (fs,ss)) case ( , ) . Stream.empty \n} Some example client code is given next: def zipWith0 : Stream[Int]= zWith (Zero (), 0) def map[A,B](f \n: A . B) : Stream[A] . Stream[B]= zWith (Succ (Zero ()),f ) def zipWith3[A,B,C,D](f : A . B . C . D) \n: Stream[A] . Stream[B] . Stream[C] . Stream[D]= zWith (Succ (Succ (Succ (Zero ()))),f )  6.5 ZipWith \nusing prioritised overlapping implicits Scala offers another solution for the n-ary zipWith prob\u00adlem, \nwhich avoids the explicit encoding of type-level nat\u00adural numbers. This solution relies on Scala s support \nfor dis\u00adambiguating overlapping implicits by explicitly prioritizing trait ZipWith[S] { type ZipWithType \ndef manyApp : Stream[S] . ZipWithType def zipWith : S . ZipWithType = f . manyApp (repeat (f )) }class \nZipWithDefault {implicit def ZeroZW [S]= new ZipWith[S] {type ZipWithType = Stream[S] def manyApp = xs \n. xs }}object ZipWith extends ZipWithDefault {def apply [S](s : S)(implicit zw : ZipWith[S]) : zw.ZipWithType \n= zw.zipWith (s) implicit def SuccZW [S,R] (implicit zw : ZipWith [R]) = new ZipWith[S . R] {type ZipWithType \n= Stream[S] . zw.ZipWithType def manyApp = xs . ss . zw.manyApp (zapp (xs, ss)) }} Figure 11. N-ary \nzipWith using prioritised implicits. the implicits. Although type classes in Haskell support over\u00adlapping \ninstances, this solution is not directly applicable to Haskell. Figure 11 shows the alternative solution \nfor the n-ary zipWith problem. Notably, the trait ZipWith and the meth\u00adods manyApp and zipWith are not \nparameterised by natural numbers anymore. When several implicit values are found for a certain type, \ndisambiguation proceeds by the standard rules for static overloading. Finally, an additional tie-breaker \nrule is intro\u00adduced that gives priority to implicits that are de.ned in a subclass over those in a parent \nclass. That is why SuccZW will be preferred over ZeroZW in case of ambiguity. For example, both ZeroZW \nand SuccZW are possible matches when an implicit of type S . R is required. How\u00adever, the ambiguity is \nresolved because SuccZW is de.ned in a subclass of ZipWithDefault, which de.nes ZeroZW. Using this solution, \nde.nitions for zipWith0 and map are: def zipWith0 : Stream[Int]= ZipWith (0) def map[A,B](f : A . B) \n: Stream [A] . Stream [B]= ZipWith (f )  6.6 Encoding generalized constraints Generalized constraints \n(Emir et al. 2006) provide a way to describe what it means for a type to be a subtype of another type, \nand are used in practice in the Scala collection libraries (Odersky and Moors 2009). For example, a classic \nuse-case for generalized constraints is the .atten method of a collection with elements of type T: it \nis only applicable if T is itself a collection. However, methods cannot constrain the type parameters \nof the class in which they are de.ned. We can represent this subtyping constraint indirectly as a function \nfrom T to the collection type Traversable [U ]. This coercion can be seen as a witness to the subtype \nrelation. Clearly, the caller of the method should not have to provide this witness explicitly.  sealed \nabstract class <:<[-S,+T ] extends (S . T) implicit def conforms[A] : A <:< A = new (A <:< A) {def apply \n(x : A)= x} trait Traversable[T ] { type Coll[X ] def .atten[U ](implicit w : T <:< Traversable [U ]) \n: Coll[U ] } To address this problem in Scala, we encode generalized constraints using the type constructor \n<:<. The trick is to use variance to extend the fact A <:< A (witnessed by the implicit value conforms \n[A]) to the facts S <: T for any S and T, where S <: A and A <: T. According to the variance of the type \nconstructor <:<, a value of type A <: A can be used when a value of type S <: T is expected. When type \nchecking a call to .atten on a Traversable [List [Int]], for example, an implicit of type List [Int] \n<:< Traversable [?U ] is searched, where ?U denotes the type variable that is used to infer the concrete \ntype for U. Since conforms[List[Int]] is the only solution, ?U is inferred to be Int. Moreover, as <:< \nis a (higher-order) subtype of ., w is used as an implicit conversion in the body of .atten to convert \nexpressions of type T to expressions of type Traversable[U ]. This example shows that functional dependencies \n(Jones 2000) are speci.ed in Scala by the order of arguments and their grouping into argument lists. \nType inference proceeds from left to right, with constraints being solved per argument list, so that, \nonce a type variable is solved, the arguments in a later argument list have to abide. In implicit argument \nlists, the constraints that arise from the search for each implicit argument are solved immediately, \nso that implicit arguments must respect the instantiations of the type variables that result from these \nearlier arguments. Finally, as the implicit argument list must come last, implicit search cannot actively \nguide type inference in the explicit argument lists, although it can veto its results post factum.  \n6.7 Type theories using implicits To conclude this section, we brie.y discuss the pattern that underlies \nthe previous examples: the idea of describ\u00ading relations on types using implicits, which introduces a \nlightweight form of type-level computation. This pattern is applied in the Scala 2.8 collection library \n(Odersky and Moors 2009) to specify how transformations on collections affect the types of the elements \nand their containers. Speci.cally, the CanBuildFrom [From,El,To] relation is used to specify that the \ncollection To can store elements of type El after transforming a collection of type From. This relation \ncan be thought of as a function from the types From and El to the type of the derived collection To. \nThe crucial feature that makes de.ning these relations on types practical is the connection between implicit \nsearch and type inference. In fact, implicit search can be thought of as a generalization of type inference \nto values. Thus, a relation on types can be modeled by a type constructor of the same arity as the relation, \nwhere a tuple of types is considered in this relation if there is an implicit value of the type that \nresults from applying the relation s type constructor to the concrete type arguments in the tuple. To \nsummarize, the examples described in this section are modeled using several type-level relations: the \nduality of two sessions; the relation between the argument and return type of the n-ary zipWith function; \nand <:<, the generalized constraint relation. 7. Discussion and Related Work This section discusses the \nresults of this paper and presents some related work. Also, an existing comparison between different \nlanguages in terms of their support for generic programming in the large (Siek and Lumsdaine 2008) is \nrevised to include Scala and JavaGI. This comparison shows that Scala is very suitable for generic programming \nin the large. 7.1 Real-world applications Implicits are widely used by Scala programmers. The largest \nreal-world application of some of the techniques presented in this paper is probably the newly designed \nScala collec\u00adtions library that ships as part of Scala 2.8. Odersky and Moors (2009) report their experiences \nin redesigning the Scala collections and argue that implicits, and their ability to specify piece-wise \ntype-level functions, play a crucial role in their design. In retrospect, the results reported by Odersky \nand Moors are not too surprising. The C++ generic programming com\u00admunity has long learned to appreciate \nthe value of associ\u00adated types to de.ne such piece-wise functions for collec\u00adtion types. The developments \npresented in Section 6 show how associated types can be more naturally de.ned us\u00ading type members and \ndependent method types. The stan\u00addard template library (STL) (Musser and Saini 1995) and Boost (Boost) \nlibraries are prime examples of generic pro\u00adgramming with C++ templates. In some sense, Scala s 2.8 collections \ncan be viewed as the STL/Boost of Scala. In the functional programming communities the term generic programming \nis often used to mean datatype\u00adgeneric programming (DGP) (Gibbons 2003). DGP can be viewed as an advanced \nform of generic programming in which the structure of types is used to derive generic algo\u00adrithms. Oliveira \nand Gibbons (2008) show that Scala is par\u00adticularly well-suited for DGP and that it is, in some ways, \nbetter than Haskell. This is partly due to the .exibility of implicits in comparison with type classes. \n  7.2 Type classes, JavaGI and concepts Type classes Haskell type classes were originally designed as \na solution for ad-hoc polymorphism (Hall et al. 1996; Wadler and Blott 1989). Many languages have mechanisms \ninspired by type classes (Gregor et al. 2006; Haftmann and Wenzel 2006; Shapiro et al. 2008; Sozeau and \nOury 2008; Wehr 2009), and implicits are no exception. Implicits are the minimal delta needed to enable \ntype class programming in an OOPL with support for parametric polymorphism. This extension can be seen \nas untangling type classes into the (ex\u00adisting) OO class system, and a mechanism for type-directed implicit \nparameter passing. The most obvious downside of the untangling approach is that implicit values and implicit \narguments must play by the rules that also govern normal values and arguments: that is, they must be \nnamed. However, these names are useful when disambiguation is needed, and, at least for implicit arguments, \nthey can be eschewed using context bounds. Finally, the OO philosophy of limiting type inference to the \ninside of encapsulation boundaries entails that context bounds are not inferred, unlike in Haskell. Nevertheless, \nthis untangling has several bene.ts. Im\u00adplicit arguments may still be passed explicitly when nec\u00adessary, \nwhile Haskell requires duplication when the dictio\u00adnary needs to be passed explicitly. For example a \nsort func\u00adtion (in which the ordering dictionary is passed implicitly), and a sortBy function (in which \nthe ordering dictionary is passed explicitly) are needed in Haskell. Furthermore, since a type class \nis encoded as a .rst-class type, the language s full range of polymorphism applies. In Haskell, it is \nnot pos\u00adsible to directly abstract over a type class (Hughes 1999). Several authors noted that Haskell \ntype classes can be limiting for certain applications due to the impossibility of explicitly passing \narguments and abstracting over type classes (Dijkstra and Swierstra 2005; Hughes 1999; Kahl and Scheffczyk \n2001; L\u00a8ammel and Jones 2005; Oliveira and Gibbons 2008; Oliveira and Sulzmann 2008). Thus, there have \nbeen a number of proposals aimed at lifting some of these restrictions (Dijkstra and Swierstra 2005; \nKahl and Scheffczyk 2001; Orchard and Schrijvers 2010). However, none of these proposals has been adopted \nin Haskell. There is also a proposal for an ML-module system that allows modules to be implicitly passed \nbased on their types, thus allowing many typical type class programs to be recovered by suitably marking \nmodule parameters as implict (Dreyer et al. 2007). Type class extensions such as functional dependencies \n(Jones 2000), associated types (Chakravarty et al. 2005b), as\u00ad sociated datatypes (Chakravarty et al. \n2005a), and type\u00adfamilies (Schrijvers et al. 2008) provide simple forms of type-level computation. This \nwork shows that by combin\u00ading type members and dependent method types it is pos\u00adsible to encode associated \ntypes, which are a fundamen\u00adtal mechanism for supporting advanced forms of generic programming (Garcia \net al. 2007). Furthermore, prioritized overlapping implicits allow the de.nition of type-level func\u00adtions \nwith a default, catch-all case, that can be overridden by other cases in subclasses. This functionality \nprovides a limited form of concept-based overloading (Siek and Lums\u00addaine 2008). In Haskell such overlapping \nde.nitions are for\u00adbidden for associated types and type-families (Chakravarty et al. 2005b; Schrijvers \net al. 2008); and have limited appli\u00adcability with functional dependencies. Type-families allow a natural \nde.nition of type-level functions, whereas type members and dependent method types can only express such \nde.nitions indirectly. It would be interesting to explore a mechanism similar to type-families in the \ncontext of OO languages. JavaGI Inspired by L\u00a8ammel and Ostermann (2006), Wehr (2009) proposes JavaGI: \na variant of Java aimed at bring\u00ading the bene.ts of type classes into Java. JavaGI provides an alternative \nviewpoint in the design space of type-class\u00adlike mechanisms in OO languages. JavaGI has generalized interfaces \nand generalized interface implementations in ad\u00addition to conventional OO interfaces and classes. Scala, \non the other hand, models type-class-like mechanisms us\u00ading the conventional OO class system. JavaGI \nsupports a form of dynamic multiple dispatching in a similar style to multi-methods (Chambers and Leavens \n1995; Clifton et al. 2000). This allows JavaGI to express open classes (Clifton et al. 2000) through \nretroactive implementations. Scala is less expressive in this respect as it does not support dy\u00adnamic \nmultiple dispatching; only static multiple dispatching is supported. However, Scala supports fully modular \ntype\u00adchecking, which is not the case for JavaGI. Concepts Concepts (Musser and Saini 1995) are an impor\u00adtant \nnotion for C++ style generic programming. They de\u00adscribe a set of requirements for the type parameters \nused by a generic algorithm. Although concepts are widely used by the C++ community to document generic \nalgorithms, current versions of C++ have no representation for concepts within the C++ language. Nevertheless \nthe situation is likely to change. Gregor et al. (2006) proposed linguistic support for concepts in C++. \nMoreover, motivated by the lack of modu\u00adlar typechecking and separate compilation in C++, concepts have \nbeen studied in the FG calculus (Siek and Lumsdaine 2005) and the G language (Siek and Lumsdaine 2008). \nConcepts are closely related to type classes and there is a fairly accepted idea that type classes can \nbe viewed as an al\u00adternative language mechanism to express concepts (Bernardy et al. 2008). Indeed, in \nseveral comparative studies, type classes score very well when it comes to language sup\u00adport for generic \nprogramming (Garcia et al. 2007; Siek and Lumsdaine 2008) (see also Figure 12). However, there are some \ndifferences in purpose between type classes and im\u00adplicits, and concepts in C++. In C++ performance is \ncon\u00adsidered as a critical requirement, and the template mecha\u00adnism is designed so that, at compile-time, \ntemplated code is specialized. Thus a potential mechanism for expressing concepts in C++ should not jeopardize \nthese performance bene.ts (Dos Reis and Stroustrup 2006). In contrast, the main motivation for type classes \nand implicits is abstraction and convenience, providing additional .exibility through indirection, at \nthe potential cost of run-time performance. Although Scala already supports some user-driven type spe\u00adcialization \n(Dragos and Odersky 2009), further work needs to be done to investigate whether implicits could be adapted \nto a system supporting full compile-time specialization.  C++ SML OCaml Haskell Java C# Cecil C++0X \nG JavaGI Scala Multi-type concepts - . . . .2 .2 . . . . .2 Multiple constraints - . . . . . . . . . \n. Associated type access . . . . . . . . . . .1 Constraints on assoc. types - . . . . . . . . . .1 Retroactive \nmodeling - . . . . 2 . 2 . . . . .23 Type aliases . . . . . . . . . . . Separate compilation . . . . \n. . . . . . . Implicit arg. deduction . . . . . 5 . 5 . . . . .3 Modular type checking . . . . . . . \n. . . . Lexically scoped models . . . . . . . . . . . Concept-based overloading . . . . . . . . . . . \n4 Equality constraints - . . . . . . . . . . First-class functions . . . . . . . . . . . Figure 12. Level \nof support for generic programming in several languages. Key: .= good , . = suf.cient , .= poor support. \nThe rating - in the C++ column indicates that while C++ does not explicitly support the feature, one \ncan still program as if the feature were supported. Notes: 1) supported via type members and dependent \nmethod types 2) supported via the CONCEPT pattern 3) supported via implicits 4) partially supported by \nprioritized overlapping implicits 5) decreased score due to the use of the CONCEPT pattern  The CONCEPT \npattern is aimed at expressing concepts using a standard OO class system without the performance constraints \nof C++. In an OO language like Scala, the CON-CEPT pattern, combined with implicits and support for asso\u00adciated \ntypes through type members and dependent method types, provides an effective platform for generic program\u00adming \nin the large.  7.3 Generic programming in the large In studies by Garcia et al. (2007); Siek and Lumsdaine \n(2008), support for generic programming in several differ\u00adent languages is investigated, with particular \nemphasis on how such languages can model concepts. Figure 12 shows the level of support for generic programming \nin various lan\u00adguages. For the most part the scores are inherited from the study presented by Siek and \nLumsdaine (2008). We added the scores for JavaGI and Scala and adjusted a couple of scores in Java and \nC#. The scores for JavaGI are derived from the related work discussions by Wehr (2009); we did not do \nany experiments with JavaGI. These scores and ad\u00adjustments are discussed next. Adjustments on Java and \nC# scores In the original com\u00adparison, Siek and Lumsdaine (2008) give Java and C# bad scores at both \nmulti-type concepts and retroactive model\u00ading. The main reason for those scores is that concepts are \nmodeled by a conventional subtyping hierarchy. For exam\u00adple, the Comparable concept and the corresponding \nApple model, are implemented as follows: trait Comparable[T ] { def better (x : T) : Boolean } public \nclass Apple extends Comparable[Apple] {...} As discussed in Section 4 this solution is problematic for \nsupporting retroactive modeling and multi-type concepts. In contrast, if the CONCEPT is used, models \ncan be added retroactively and multi-type concepts can be expressed con\u00adveniently. The drawback of the \nCONCEPT solution in lan\u00adguages like Java or C#, as also discussed in Section 4, is that there is some \nadditional overhead to use conceptual meth\u00adods. This is re.ected in the score for retroactive modeling, \nwhich is only suf.cient, since support for this feature is not as natural as it could be. Also, the score \nfor implicit argu\u00adment deduction is affected by the use of the CONCEPT pat\u00adtern because the concept constraints \nhave to be passed ex\u00adplicitly. In Java and C#, the original solution using bounded polymorphism is better \nin this respect because no such over\u00ad  head exists. JavaGI Since JavaGI is a superset of Java, it inherits \nmost of its scores. In JavaGI retroactive modeling and multi-type concepts are naturally supported through \ngeneralized inter\u00adfaces. Wehr (2009) explicitly states that lexically scoped models and concept-based \noverloading are not supported. Furthermore, although type-checking is mostly modular, a .nal global check \nis necessary. Thus JavaGI only partially supports modular type-checking. Scala Using the CONCEPT pattern \nwe can model multi\u00adtype concepts, multiple constraints and support retroactive modeling. Furthermore, \nScala s support for implicits means that the drawbacks of the Java and C# solutions in terms of the additional \noverhead, do not apply to Scala. Thus, Scala scores well in both the implicit argument deduction and \nthe retroactive modeling criteria. Section 6 shows that associ\u00adated types are supported in Scala through \ntype members and dependent method types, and type members can also be used as type aliases. As shown \nin Section 3, Scala sup\u00adports lexically scoped models. Furthermore type-checking is fully modular. Prioritized \noverlapping implicits provide some support for concept-based overloading as illustrated by the zipWithN \nexample in Section 6.5. However, overlapping models have to be structured using a subtyping hierarchy, \nwhich may not always be desirable. Thus, the score for this feature is only suf.cient. Finally, Scala \nhas full support for .rst-class functions and it also supports equality constraints. In summary Scala \nturns out to be a language with excel\u00adlent support for generic programming features, managing to fare \nat the same level, or even slightly better, than G (which was specially designed as a language for generic \nprogram\u00adming in the large) or Haskell (which has been recognized has having very good support for generic \nprogramming). 8. Conclusion This paper shows that it is possible to have the bene.ts of type classes \nin a standard OO language with generics, by using the CONCEPT pattern to express type-class style pro\u00adgrams. \nHowever some convenience is lost, especially for tra\u00additional applications aimed at using type classes \nfor con\u00adstrained polymorphism. Implicits are a modest extension that can be added to stat\u00adically typed \nlanguages. Implicits bring back the convenience of use of type classes, but they have wider applicability \nand are useful in several other domains. With the improved sup\u00adport for type-inference that we are already \nseeing in main\u00adstream languages like Java or C#, it is only natural to expect that implicits will eventually \n.nd their way into those lan\u00adguages. Type members and dependent method types add extra power to the language \nand a combination of the two mech\u00adanisms allows associated types to be expressed. In combi\u00adnation with \nimplicits, type members and dependent method types make Scala an language ready for generic program\u00adming \nin the large. Acknowledgments This work bene.ted from several discussions that we had with William Cook. \nWe are grateful to Tom Schrijvers, Jonathan Shapiro and Marcin Zalewski for their useful com\u00adments. Bruno \nOliveira was supported by the Engineering Research Center of Excellence Program of Korea Ministry of \nEducation, Science and Technology (MEST) / Korea Sci\u00adence and Engineering Foundation (KOSEF) grant number \nR11-2008-007-01002-0. References J. P. Bernardy, P. Jansson, M. Zalewski, S. Schupp, and A. Priesnitz. \nA comparison of C++ concepts and Haskell type classes. In WGP 08, pages 37 48, 2008. Boost. The Boost \nC++ libraries. http://www.boost.org/, 2010. K. Bruce, L. Cardelli, G. Castagna, G. T. Leavens, and B. \nPierce. On binary methods. Theor. Pract. Object Syst., 1(3):221 242, 1995. P. Canning, W. Cook, W. Hill, \nW. Olthoff, and J. C. Mitchell. F\u00adbounded polymorphism for object-oriented programming. In FPCA 89, pages \n273 280, 1989. M. Chakravarty, G. Keller, S. Peyton Jones, and S. Marlow. Asso\u00adciated types with class. \npages 1 13, 2005a. M. Chakravarty, G. Keller, and Simon Peyton Jones. Associated type synonyms. In ICFP \n05, pages 241 253, 2005b. C. Chambers and G. T. Leavens. Typechecking and modules for multimethods. ACM \nTransactions on Programming Languages and Systems, 17(6):805 843, 1995. C. Clifton, G. T. Leavens, C. \nChambers, and T. Millstein. Multi-Java: modular open classes and symmetric multiple dispatch for Java. \nIn OOPSLA 00, pages 130 145, 2000. W. R. Cook. On understanding data abstraction, revisited. SIG-PLAN \nNot., 44(10):557 572, 2009. W. R. Cook and J. Palsberg. A denotational semantics of inheri\u00adtance and \nits correctness. Inf. Comput., 114(2):329 350, 1994. O. Danvy. Functional unparsing. J. Funct. Program., \n8(6):621 625, 1998. A. Dijkstra and S. D. Swierstra. Making implicit parameters ex\u00adplicit. Technical \nreport, Institute of Information and Computing Sciences, Utrecht University, 2005. URL http://www.cs.uu. \nnl/research/techreps/UU-CS-2005-032.html. G. Dos Reis and B. Stroustrup. Specifying C++ concepts. In \nPOPL 06, pages 295 308, 2006. I. Dragos and M. Odersky. Compiling generics through user\u00addirected type \nspecialization. In ICOOOLPS 09, pages 42 47, 2009. D. Dreyer, R. Harper, M. M. T. Chakravarty, and G. \nKeller. Modular type classes. In POPL 07, pages 63 70, 2007. B. Emir, A. Kennedy, C. V. Russo, and D. \nYu. Variance and generalized constraints for C# generics. In ECOOP, pages 279 303, 2006.  R. Garcia, \nJ. Jarvi, A. Lumsdaine, J. Siek, and J. Willcock. An extended comparative study of language support for \ngeneric programming. J. Funct. Program., 17(2):145 205, 2007. J. Gibbons. Patterns in datatype-generic \nprogramming. In The Fun of Programming, Cornerstones in Computing, pages 41 60. Palgrave, 2003. D. Gregor, \nJ. J\u00a8arvi, J. Siek, B. Stroustrup, G. Dos Reis, and A. Lumsdaine. Concepts: linguistic support for generic \npro\u00adgramming in C++. In OOPSLA 06, pages 291 310, 2006. F. Haftmann and M. Wenzel. Constructive type \nclasses in Isabelle. In TYPES, pages 160 174, 2006. C. V. Hall, K. Hammond, S. Peyton Jones, and P. Wadler. \nType classes in Haskell. ACM Trans. Program. Lang. Syst., 18(2): 109 138, 1996. K. Honda. Types for dynamic \ninteraction. In CONCUR 93, pages 509 523, 1993. J. Hughes. Restricted data types in Haskell. In Haskell \nWorkshop, 1999. J. J\u00a8arvi, A. Lumsdaine, J. Siek, and J. Willcock. An analysis of con\u00adstrained polymorphism \nfor generic programming. In MPOOL 03, page 87 107, 2003. M. P. Jones. Type classes with functional dependencies. \nIn ESOP 00, pages 230 244, 2000. W. Kahl and J. Scheffczyk. Named instances for Haskell type classes. \nIn Haskell Workshop, 2001. A. Kennedy and C. V. Russo. Generalized algebraic data types and object-oriented \nprogramming. OOPSLA 05, pages 21 40, 2005. O. Kiselyov, R. L\u00a8ammel, and K. Schupke. Strongly typed hetero\u00adgeneous \ncollections. In Haskell 04, pages 96 107, 2004. O. Kiselyov, S. Peyton Jones, and C. Shan. Fun with type \nfunctions, 2009. URL http://research.microsoft.com/en-us/um/ people/simonpj/papers/assoc-types/. R. L\u00a8ammel \nand S. P. Jones. Scrap your boilerplate with class: extensible generic functions. In ICFP 05, pages 204 \n215, 2005. R. L\u00a8ammel and K. Ostermann. Software extension and integration with type classes. In GPCE \n06, pages 161 170, 2006. D. B. MacQueen. Modules for Standard ML. In LISP and Func\u00adtional Programming, \npages 198 207, 1984. C. McBride. Faking it: Simulating dependent types in Haskell. J. Funct. Program., \n12(5):375 392, 2002. J. C. Mitchell and G. D. Plotkin. Abstract types have existential type. ACM Trans. \nProgram. Lang. Syst., 10(3):470 502, 1988. A. Moors, F. Piessens, and M. Odersky. Generics of a higher \nkind. In OOPSLA 08, pages 423 438, 2008. D. Musser and A. A. Stepanov. Generic programming. In Symbolic \nand algebraic computation: ISSAC 88, pages 13 25. Springer, 1988. D. R. Musser and A. Saini. The STL \nTutorial and Reference Guide: C++ Programming with the Standard Template Library. Addison Wesley Longman \nPublishing Co., Inc., Redwood City, CA, USA, 1995. M. Odersky, 2006. URL http://www.artima.com/weblogs/ \nviewpost.jsp?thread=179766. M. Odersky. The Scala Language Speci.cation, Version 2.8. EPFL, 2010. URL \nhttp://www.scala-lang.org/docu/files/ ScalaReference.pdf. M. Odersky and A. Moors. Fighting bit rot with \ntypes (experience report: Scala collections). In FSTTCS, pages 427 451, 2009. M. Odersky, V. Cremet, \nC.R\u00a8ockl, and M. Zenger. A nominal theory of objects with dependent types. In ECOOP03, pages 201 224. \nSpringer-Verlag, 2003. M. Odersky, P. Altherr, V. Cremet, I. Dragos, G. Dubochet, B. Emir, S. McDirmid, \nS. Micheloud, N. Mihaylov, M. Schinz, L. Spoon, E. Stenman, and M. Zenger. An Overview of the Scala Program\u00adming \nLanguage (2. edition). Technical report, EPFL, 2006. B. C. d. S. Oliveira and J. Gibbons. Scala for generic \nprogrammers. In WGP 08, pages 25 36, 2008. B. C. d. S. Oliveira and M. Sulzmann. Objects to unify type \nclasses and GADTs. April 2008. URL http://www.comlab.ox.ac. uk/people/Bruno.Oliveira/objects.pdf. D. \nOrchard and T. Schrijvers. Haskell type constraints unleashed. In FLOPS 10. Springer-Verlag, 2010. S. \nPeyton Jones, editor. Haskell 98 Language and Libraries The Revised Report. Cambridge University Press, \nCambridge, England, 2003. S. Peyton Jones, M. Jones, and E. Meijer. Type classes: exploring the design \nspace. In Haskell Workshop, 1997. S. Peyton Jones, D. Vytiniotis, S. Weirich, and G. Washburn. Sim\u00adple \nuni.cation-based type inference for GADTs. In ICFP 06, pages 50 61, 2006. S. Peyton Jones, S. Marlow, \net al. The Glasgow Haskell Compiler, 2009. URL http://www.haskell.org/ghc/. T. Schrijvers, S. Peyton \nJones, M. Chakravarty, and M. Sulzmann. Type checking with open type functions. In ICFP 08, pages 51 \n62, 2008. J. S. Shapiro, S. Sridhar, and M. S. Doerrie. BitC language speci\u00ad.cation, 2008. URL http://www.coyotos.org/docs/bitc/ \nspec.html. J. G. Siek and A. Lumsdaine. Essential language support for generic programming. In PLDI 05, \npages 73 84, 2005. J. G. Siek and A. Lumsdaine. A language for generic programming in the large. Science \nof Computer Programming, In Press, Cor\u00adrected Proof, 2008. URL http://www.sciencedirect. com/science/article/B6V17-4TJ6F7D-1/2/ \n7d624b842e8dd84e792995d3422aee21. M. Sozeau and N. Oury. First-class type classes. In TPHOLs 08, pages \n278 293, 2008. P. Wadler and S. Blott. How to make ad-hoc polymorphism less ad hoc. In POPL 89, pages \n60 76, 1989. S. Wehr. JavaGI: A Language with Generalized Interfaces. PhD thesis, University of Freiburg, \nDepartment of Computer Science, December 2009.  class Ord a where eq :: a . a . Bool compare :: a . \na . Bool instance Ord Int where eq a b = compare a b . compare b a compare x y = x . y instance Ord a \n. Ord [a] where eq a b = compare a b . compare b a compare l1 l2 = case (l1,l2) of (x : xs,y : ys) . \nif (eq x y) then compare xs ys else compare x y ( ,[ ]) . False ( , ) . True Figure 13. Ordering concept \nin Haskell (cf. Figure 3) class Set s where empty :: s insert :: s . Int . s contains :: s . Int . Bool \nunion :: s . s . s instance Set [Int] where empty =[] insert = . xy . y : x contains = . xy . elem y \nx union = . xy . List.union x y instance Set (Int . Bool) where empty = . x . False insert = . f yz . \ny = z . fz contains = . fy . fy union = . f gy . fy . gy Figure 14. A Set ADT using Type Classes (cf. \nFigure 5) A. Type Class Examples in Haskell This section shows the Haskell versions of the programs used \nin this paper. class Format a where format :: String . a printf :: Format a . a printf = format \"\" instance \nFormat a . Format (Int . a) where --I format s = . i . format (s ++ show i) instance Format a . Format \n(Char . a) where --C format s = . c . format (s ++ show c) instance Format String where --E format s \n= s Figure 15. Printf using Type Classes (cf. Figure 6) class Session a where type Dual a run :: a . \nDual a . IO () instance (Session b) . Session (In a b) where type Dual (In a b)= Out a (Dual b) run (In \nf )(Out a d)= fa >>= .b . d >>= .c . run b c instance (Session b) . Session (Out a b) where type Dual \n(Out a b)= In a (Dual b) run (Out a d)(In f )= fa >>= .b . d >>= .c . run c b instance Session Stop where \ntype Dual Stop = Stop run Done Done = return () Figure 16. Session types (cf. Figure 9) data Zero = Zero \ndata Succ n = Succ n class ZipWith n s where type ZipWithType n s manyApp :: n . [s] . ZipWithType n \ns zipWithN :: n . s . ZipWithType n s zipWithN n f = manyApp n (repeat f ) instance ZipWith Zero t where \ntype ZipWithType Zero t =[t] manyApp Zero fs = fs instance ZipWith n u . ZipWith (Succ n)(s . u) where \ntype ZipWithType (Succ n)(s . u)=[s] . ZipWithType n u manyApp (Succ n) fs = .ss . manyApp n (fs << ss) \nFigure 17. N-Ary zipWith using associated types (cf. Fig\u00adure 10)     \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Type classes were originally developed in Haskell as a disciplined alternative to ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to important challenges in software engineering and programming languages such as, for example, <i>retroactive extension</i> of programs. They are also recognized as a good mechanism for concept-based <i>generic programming</i> and, more recently, have evolved into a mechanism for type-level computation.</p> <p>This paper presents a lightweight approach to type classes in object-oriented (OO) languages with generics using the CONCEPT pattern and <i>implicits</i> (a type-directed implicit parameter passing mechanism). This paper also shows how Scala's type system conspires with implicits to enable, and even surpass, many common extensions of the Haskell type class system, making Scala ideally suited for generic programming in the large.</p>", "authors": [{"name": "Bruno C.d.S. Oliveira", "author_profile_id": "81310493622", "affiliation": "ROSAEC Center, Seoul National University, Seoul, South Korea", "person_id": "P2354072", "email_address": "", "orcid_id": ""}, {"name": "Adriaan Moors", "author_profile_id": "81381603100", "affiliation": "EPFL, Lausanne, Switzerland", "person_id": "P2354073", "email_address": "", "orcid_id": ""}, {"name": "Martin Odersky", "author_profile_id": "81100056476", "affiliation": "EPFL, Lausanne, Switzerland", "person_id": "P2354074", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869489", "year": "2010", "article_id": "1869489", "conference": "OOPSLA", "title": "Type classes as objects and implicits", "url": "http://dl.acm.org/citation.cfm?id=1869489"}