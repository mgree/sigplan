{"article_publication_date": "10-17-2010", "fulltext": "\n Supporting Dynamic, Third-Party Code Customizations in JavaScript Using Aspects Benjamin S. Lerner \n* Herman Venter Dan Grossman University of Washington Microsoft Research University of Washington blerner@cs.washington.edu \nhermanv@microsoft.com djg@cs.washington.edu Abstract Web sites and web browsers have recently evolved \ninto plat\u00adforms on top of which entire applications are delivered dy\u00adnamically, mostly as JavaScript \nsource code. This delivery for\u00admat has sparked extremely enthusiastic efforts to customize both individual \nweb sites and entire browsers in ways the original authors never expected or accommodated. Such cus\u00adtomizations \ntake the form of yet more script dynamically injected into the application, and the current idioms to \ndo so exploit arcane JavaScript features and are extremely brittle. In this work, we accept the popularity \nof extensions and seek better linguistic mechanisms to support them. We suggest adding to JavaScript \naspect-oriented features that allow straightforward and declarative ways for customiza\u00adtion code to modify \nthe targeted application. Compared to most prior aspect-related research, our work has a different motivation \nand a different target programming environment, both of which lead to novel design and implementation \ntech\u00adniques. Our aspect weaving is entirely integrated into a new dynamic JIT compiler, which lets us \nproperly handle advice to .rst-class functions in the presence of arbitrary aliasing, without resorting \nto whole-program code transformations. Our prototype demonstrates that an aspect-oriented approach to \nweb-application customization is often more ef.cient than current idioms while simplifying the entire \nprocess. Categories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features; \nD.3.4 [Pro\u00adgramming Languages]: Processors Compilers General Terms Languages, Design Keywords Aspects, \nextensions, JavaScript * Work done while at Microsoft Research Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, \nNevada, USA. Copyright c &#38;#169; 2010 ACM 978-1-4503-0203-6/10/10. . . $10.00 1. Introduction Web \nbrowsers and web applications have become indispens\u00adable software for end-users. Yet the software design, \ndevelop\u00adment, and deployment model for client-side web code is, for better or worse, very different than \nthe model for traditional desktop applications. Code is delivered in source form, at run\u00adtime, from multiple \nsources, and in a language (JavaScript, abbreviated JS) that is highly dynamic and encourages run\u00adtime \ncreation and evaluation of more code. Consider just the JS code that runs when a user visits a typical \nWeb 2.0 site. The main page will use JS to provide an interactive experience, probably incorporating \npopular third-party JS libraries. Ads on the side will contain sepa\u00adrately developed scripts. User-installed \nbrowser extensions or userscripts include yet more JS to affect browser function\u00adality and how pages \nare displayed. In fact, some browsers, most notably Firefox, now have large parts of the browsers themselves \nwritten in or modi.ed by JS. In short, the code running for a page is a run-time conglomeration of scripts \nfrom multiple sources with multiple purposes. Matters get worse: The entire purpose of some JS (e.g., \nin a browser extension) is to change the behavior of other JS (e.g., on a popular web page) in ways the \naffected code never expected. To do so, programmers (ab)use JS features such as the rede.nition of top-level \nfunctions and the ability to retrieve a function s source code at run-time using its toString() method, \nrewrite it in some manner, and evaluate the result. While it is easy to dismiss such shenanigans as unprincipled \nhacks unworthy of serious programming\u00adlanguages study, in this paper we choose instead to accept this \nreality. Third-party modi.cations are extremely popular, with tens of thousands of extensions run by \nmillions of users every day. We simply cannot expect web programmers to modify the behavior of web applications \nonly in ways the application writers allow and prepare for. 1.1 Aspects for JavaScript We propose adding \nto JS features that make third-party code modi.cations straightforward, with clear semantics that avoid \nthe pitfalls and awkwardness of current practice. Our ap\u00adproach adapts and extends mechanisms from aspect-oriented \nprogramming to the world of web applications and JS. Our motivation differs from the conventional motivation \nfor as\u00adpects: rather than better modularizing code by separating cross-cutting concerns, we use aspects \nto specify code modi\u00ad.cations by third parties concisely and accurately.  Our approach is the .rst JS \njust-in-time compiler with support for aspects, taking advantage of the ideas behind re\u00adcent advances \nin JIT compilation for JS [13]. Implementing aspects within the JIT offers better performance and com\u00adpleteness \nthan prior approaches. Most aspect systems stat\u00adically compile aspects into the code they modify. But \nthe web domain has too much code arriving and being gener\u00adated dynamically for this to make sense: aspect \nweaving at runtime lets us advise all JS code, regardless of its source. Moreover, aspects can be implemented \nmore ef.ciently via runtime support than via source-to-source transformation. JS web code is imperative \nand event-driven, with .rst\u00adclass functions and prototype-based object hierarchies. These features, combined \nwith the unusual scoping and evaluation\u00adorder rules of JS, form a very different substrate on which to \nde.ne aspects than more well-known efforts for object\u00adoriented or functional languages. We also demonstrate \nthat, despite efforts to the contrary, aspects cannot be properly provided as a JS library; support from \nthe JS implementation is needed. To evaluate our work, we have taken several popular third\u00adparty extensions \nand rewritten them using our aspects. The resulting code is shorter, simpler, and faster than existing \nidioms. To justify the features present in our language, we have examined twenty popular Firefox extensions, \nmeasuring the fraction of their code involved in aspect-like behavior and how frequently each type of \nadvice occurs. Our language supports nearly every idiom we encountered, and every feature of our design \nis used signi.cantly often. While our work required solving some technical issues peculiar to JS, many \nof our contributions transcend this language. Once one accepts that web applications will be changed \nand rewritten at run-time in unexpected ways by third-party scripts, one needs linguistic mechanisms \nto sup\u00adport such change in (relatively) robust ways. Our research focuses on JS because it is the predominant \nlanguage for today s web applications.  1.2 Outline Section 2 presents two examples of extensions one \nuser\u00adscript, one browser-level and the idiomatic hooks they use to install their code. Section 3 introduces \nthe key concepts of aspect-oriented programming and revises the examples to use aspects instead. Section \n4 lays out the key properties that an aspect system for JS should support, then presents our aspect language \nin full. Section 5 describes our imple\u00admentation. Section 6 evaluates effectiveness and ef.ciency. Section \n7 discusses related work. Section 8 discusses future work. Section 9 concludes. var oldP = unsafeWindow.P; \nunsafeWindow.P = function(iframe, data) { if (data[0] == \"mb\") data[1] = format(data[1]); return oldP.apply(iframe, \narguments); } Figure 1. Central hook used to install a text formatter into Gmail. Note: The common DOM \nwindow object is available via the unsafeWindow alias. 2. Extensible Web-Programming Examples To understand \nthe nature of code that modi.es web applica\u00adtions, we consider two examples. The .rst modi.es a web page \nrunning Gmail, Google s webmail client, to reformat the display of emails. The second modi.es the Firefox \nbrowser to change the behavior of opening a new tab. Section 3 revis\u00adits these examples to show how aspects \nprovide cleaner and more robust solutions. 2.1 Reformatting Messages in Gmail Many email clients detect \n/italic/, _underlined_ and *bold* text using punctuation and format the text appropri\u00adately. This functionality \nis not present in Gmail, so a user\u00adscript1 was written to add this feature, replacing, e.g., /text/ with \nUi)textU/i). A userscript de.nes code and a set of pages on which it should be run. When a page .nishes \nloading, all relevant userscripts are appended to the page and exe\u00adcuted. For instance, this userscript \nruns for URLs matching http://mail.google.com/mail/*. Browsers may sup\u00adport userscript loading directly \n(as in Chrome) or via an extension (as in Greasemonkey for Firefox). If all the email data were already \npresent in the page s DOM, it would be simple to identify messages and format them. But like all Ajax \napplications, Gmail fetches data lazily. All processing of that data begins with a function at global \nscope and so the userscript hooks into this function to preprocess the data. That crucial hook is shown \nin Figure 1. The basic idea is to replace Gmail s unsafeWindow.P function with a new function that formats \nthe data when a message body (\"mb\") arrives, and then proceeds to call the original code bound to P with \nthe modi.ed data. This technique is known as wrapping. The use of JS s apply method is necessary so that \nthe implicit this parameter of P is bound properly. This unintuitive idiom is common, but our approach \nusing aspects makes it largely unnecessary.  2.2 SpeedDial: Customizing New Tabs in Firefox The Opera \nand Safari browsers offer a home page showing a grid of the user s most frequently visited sites. This \nfeature is not built into Firefox, but two extensions have been written to add it. We investigated one2 \nthat takes care to interact with 1 http://userscripts.org/scripts/show/8178 2 https://addons.mozilla.org/en-US/firefox/addon/4810 \n  SpeedDial.init = function () { ... eval(\"getBrowser().removeTab =\"+ getBrowser().removeTab.toString().replace( \nthis.addTab(\"about:blank\"); , if (SpeedDial.loadInLastTab) {this.addTab( + \"chrome://speeddial/content/speeddial.xul\" \n+ )} else { this.addTab(\"about:blank\")} )); ... if (SpeedDial.clearURLBarOnLoad) { if (!SpeedDial.isFirefox3) \n{ ... } else { var newLocationChange = window.URLBarSetURI.toString().replace( /aURI.spec == \\\"about:blank\\\"/g, \naURI.spec == \"about:blank\" || + (aURI.spec.indexOf(\"chrome:// + speeddial/content\") == 0) ); eval( window.URLBarSetURI \n= + newLocationChange + ; ); } } } Figure 2. Central hook used to modify the Firefox blank tab. other \nfeatures of the browser: when a blank new tab appears, a page of thumbnails of frequently visited sites \nshould appear instead, but the browser s address bar should optionally (depending on user preference) \nremain blank (as it does for normal blank tabs). Figure 2 shows a simpli.ed version of the main hook \nthat installs this change, though understanding the details of this code is dif.cult and unnecessary. \nAs in the Gmail example, the code is rede.ning a method. However, it is doing so by rewriting the source-code \nstring of the original method using regular expressions to .nd and replace text and then calling eval \non the resulting string. This technique is error-prone and brittle, and it produces code that is dif.cult \nto analyze or maintain. Yet this precise sequence retrieve the source-code string, manipulate it, call \neval is so common that it has a name in web programming: monkey-patching. We know of dozens of browser \nextensions that use it. Our goal is to design an aspect system expressive enough to obviate this idiom. \n 2.3 Discussion The two examples above are typical representatives of exten\u00adsions. They interact with \nthe structure of the page or browser but need to patch the underlying scripts to enable their behav\u00adiors. \nSuch patches are more the rule than the exception: this is how things are done on the web. There are \nnearly 40,000 userscripts and over 6,000 Firefox extensions available, with millions of daily users: \nthis development model is successful and growing daily. Sometimes, patches such as these can drive application \nrevision. Thanks to the popularity of userscripts, Google has revised Gmail s code to provide some APIs \nfor userscripts to use. Similarly, some exceptionally popular extensions for Firefox have been merged \ninto the application s core as built\u00adin features, and new APIs have been introduced to streamline ungainly \nworkarounds used by many extensions. But not all web applications will be so accommodating, nor will \nusers wait for such support. In general, the underlying programs cannot be expected to plan for such \ndiverse extensions, nor can extension authors be expected to know about and plan for all other extensions. \nInstead, we have the opportunity to provide a more principled framework for writing and maintaining extensions. \nPerhaps the most distasteful facet of monkey-patches is their rampant violation of function abstractions \nthrough replace and eval. In an ideal world, such tricks would be unnecessary. However, when mainline \nprograms do not expose a particular value through a convenient abstraction boundary (as with the aURI.spec \nvariable in the Speed-Dial example in Figure 2), extension authors must resort to abstraction-violating \npatches to implement their features. Our aim in this paper is not to eliminate such hacks (which would \nbe futile), but rather to recognize and give structure to commonly-used idioms, preserving abstraction \nboundaries where possible. Wrapping and monkey-patching also make it dif.cult to analyze the impact extensions \nmay have on each other or the mainline program: due to aliasing, code paths that were identical may now \ndiverge, and of course all analyses are greatly complicated by the use of eval. By contrast, our aspects \ncan eliminate almost all uses of these idioms and so they may make such analyses feasible. 3. Using aspects \nfor extensions An extension is a self-contained unit of code that needs to insert itself into various \nplaces in the underlying applica\u00adtion to implement its functionality. An extension is similar to an aspect, \nthough extension-oriented programming and aspect-oriented programming are very different in motiva\u00adtion. \nAspects have traditionally been used for crosscutting concerns such as security monitors or loggers. \nWe propose that the mechanisms of aspects are well-suited to the use case of extending web applications. \nWe give a brief summary of the terms and concepts of aspect-oriented programming, then introduce our \naspect language for JS by rewriting the examples in the previous section. The examples here rely on an \ninformal description of our language constructs, with full and complete de.nitions following in Section \n4. 3.1 Key aspect-oriented concepts An aspect inserts new code into an existing mainline program to \nrun at speci.c times during that program s execution. The new code is called advice. Each speci.c time \nis called a joinpoint, and sets of joinpoints are called pointcuts. There are several kinds of pointcuts: \nfor example, one might be when function foo is called, while another might be when .eld bar is accessed \non object X. Aspects also need to specify the type of advice: for instance, before or after or around \nthe call to a function. Sometimes a pointcut might be too broad, describing too many moments during execution. \nA pointcut can therefore specify a .lter to restrict the joinpoint: for instance, all calls to function \nfoo, when called by function bar. Integrating advice into mainline code is called weaving: it incorporates \nthe advice into the mainline such that the advice is triggered at its speci.ed pointcut. Multiple aspects \nmay advise the same pointcut; the weaver uses precedence rules to order the aspects. Advice should rarely \ncall the advised code directly, but rather use a mechanism, usually called proceed, to refer to the next \ninstalled advice or the underlying mainline, as determined by the weaver.  3.2 Advice surrounding functions \nExamining the text-formatting example in Section 2.1, we see it is exactly what before advice accomplishes. \nThe new version of unsafeWindow.P inserts its preprocessing before executing the original function. We \ncan rewrite this example more concisely as at pointcut(callee(unsafeWindow.P)) before(iframe, data){ \nif (data[0] == \"mb\") data[1] = format(data[1]); } An aspect must de.ne a pointcut and advice. Here, our \npointcut is callee(unsafeWindow.P), and our advice is the before { } block. The name callee emphasizes \nthat the advice applies to the code inside unsafeWindow.P, rather than inside its caller. Unlike in the \nuserscript, which had to save a reference to and then manually call the original version of P, such explicit \nplumbing is unneeded. Instead, the advice examines and modi.es the actual arguments to the function: \nessentially, the advice is inlined into the body of P. Traditionally, advice takes a parameter giving \nre.ective access to the arguments of the advised code; our design avoids the indirection and speci.es \narguments explicitly.  3.3 Advice within functions The SpeedDial extension in Section 2.2 inserted two \nhooks into Firefox code, so we de.ne two aspects. Examining the .rst portion of the code, we see it is \nexecuting a particular statement only in certain conditions. There are several ways to translate this \nintent. Most literally, we might say: at pointcut( statement_containing(this.addTab(\"about:blank\")) &#38;&#38; \nwithin(getBrowser().removeTab)) around(...) { if (SpeedDial.loadInLastTab) this.addTab( \"chrome://speeddial/content/speeddial.xul\"); \nelse proceed; } This example shows a new type of pointcut, describing the nearest enclosing statement \ncontaining a particular subexpres\u00adsion. We surround that statement with advice that in some cases calls \nan entirely separate function, and in other cases proceeds with the original call. Since we do not want \nto rewrite every statement containing the speci.ed expression, we use a .lter to constrain it within \nthe lexical scope of the function getBrowser().removeTab. Perhaps the intention was more general: advise \nall calls to addTab to open the SpeedDial page instead: at pointcut(callee(this.addTab)) before(url) \n{ if (url == \"about:blank\" &#38;&#38; SpeedDial.loadInLastTab) url=\"chrome://speeddial/content/speeddial.xul\"; \n} The extension code, as currently written, gives no indication which of these meanings (or others) were \nintended. The second half of the SpeedDial code is actually bro\u00adken: the mainline code no longer contains \nthe expres\u00adsion (aURI.spec == \"about:blank\"). That means the replace() call becomes a no-op, and the \nmonkey patch silently fails. However, the mainline code does set a variable isBlank, which likely is \nthe original intent of this extension. We can express the patch as: at pointcut(field(isBlank) &#38;&#38; \nwithin(unsafeWindow.URLBarSetURI)) wrap { set { isBlank = (proceed || (uri.spec.indexOf( \"chrome://speeddial/content\") \n== 0)) } } This aspect uses the field pointcut to denote accessing variables or .elds of objects, again \n.ltered within the lexical scope of a particular function. The advice itself wraps the variable, in this \ncase only when it is being set. Depending on the situation, we might write get advice as well. Note that \nthe statement_containing and field ad\u00advice are fragile: they depend on the syntax of the method be\u00ading \nadvised. If a subexpression is no longer used or a variable is renamed (which is what broke the SpeedDial \ncode), our advice will fail to apply. We cannot prevent that brittleness when extensions need to modify \nthe internal logic of func\u00adtions, there may be no simpler alternative. However, unlike monkey patching, \nusing our aspects will result in a weaving warning indicating that no joinpoints were found. 4. Aspects \nas a new JS primitive In Section 4.1, we propose a more reasonable semantics for aspect weaving in JS \nthan is possible with wrapping or monkey-patching. Our approach ensures that functions may be advised \nregardless of when they are de.ned, and regardless of how they are referenced. Implementing this relies \non two key features: weaving should occur at runtime rather than compile-time, and should apply to closures \nrather than variables. These two together give us a third key feature, the ability to disable or re-enable \ninstalled advice dynamically. In Section 4.2, we show that neither wrapping, monkey\u00adpatching, nor any \nother idiom within the JS language can provide these guarantees. Section 4.3 describes our full language \nextensions to JS precisely.  4.1 Key features of an aspect primitive Dynamic weaving Aspect weaving \ndepends on naming functions as targets for advice. Weaving can happen at compile time or at runtime.3 \nWe argue that dynamic weaving is the only appropriate method for JS: code frequently de.nes anonymous \nfunctions, or creates closures at runtime. A static weaver would be unable to advise either of these \ntypes of functions, leading to an arti.cial and unintuitive split between advisable and non-advisable \nfunctions. A dynamic weaver has no trouble with dynamically created functions: instead of being triggered \nbased on the static name of the function, it is triggered by the contents of variables at runtime. Weaving \ninto closures Dynamic weaving exposes the dis\u00adtinction between variables and their values. Consider the \nfollowing snippet: var f = function(x) { return x*x; }; var g = f; Install Advice: before executing f, \nprint(x) var h = f; f(4); g(4); h(4); Suppose the last four lines were in separate Uscript/) sources \nwith an unknown loading order (e.g., as sub.les in a library, ads delivered to a page, or scripts in \nan application) following the .rst line. The intent is for f, g, and h to be aliases of one another. \nReasonably, one would expect that all three calls in the last line ought to trigger the advice: clearly \ncalling f should, and g and h are the same function. The fact that g was de.ned before the advice was \ninstalled should be hidden from the user since the loading order is likely unknown. Hence advice should \napply to the underlying closure, and not to a variable bound to the closure. In JS (or any higher-order \nlanguage), functions may not have unique names, and indeed frequently do have more than one (for instance, \nby de.ning a function and subsequently installing it as an event handler in a page). Usually, the developer \nwho uses aspects intends that such aliased functions be advised consistently. Similar conclusions have \nbeen reached by others [9]. The ability to advise closures marks our key departure from what is possible \nwithin JS: modifying closures cannot be expressed within JS. When this behavior is not desired (i.e., \nthe intended behavior does depend on particular aliases), the wrapping idiom is appropriate and still \navailable. 3 The expert JS programmer will note that compile-time is ambiguous, encompassing parsing \ntime and function hoisting time as distinct phases before executing the top-level script statements; \nmoreover this repeats for each (script/) on the page. All of these suffer from the same inability to \nadvise anonymous functions, so we consider them all compile-time here. Dynamic disablement Disabling \nadvice arises naturally in the extension setting as extensions provide multiple, mutually\u00adexclusive features \nthat can be selected at runtime by the user. Contrast this form of predicating the execution of advice \nwith the .lters mentioned earlier: .lters restrict advice to particular lexical or dynamic scopes; disablement \nrestricts advice based on arbitrary runtime decisions. Disabling advice can be implemented manually by \nwrap\u00adping all advice code in if-tests, but this is tedious, and the examples presented earlier only partially \nimplement it: the userscript makes no effort to do so, while the SpeedDial ex\u00adtension is inconsistent, \ninserting a guard around one piece of advice but not the other. Our aspects are expressions in the language \nthat appear as objects, and we equip them with a mu\u00adtable disabled .eld that selectively disables or \nre-enables individual advice. This .eld may be used easily and consis\u00adtently to turn off woven advice. \n 4.2 Aspects cannot be implemented as a library Both wrapping and monkey-patching rely on replacing \nthe closure bound to a given variable; nothing else is expressible with variables within JS. Hence they \nare incorrect in the presence of aliasing. They also suffer additional, distinct problems. Because wrapping \neventually calls the underlying function, it is limited to adding code before and after the function \nit cannot modify the internal control .ow of the function. Extensions frequently require this ability, \nmaking wrapping unsuitable for their needs. (For instance, the SpeedDial code cannot be written as a \nwrapper, as it must modify code in the middle of the target function.) Monkey patching fails in two other \ncritical ways. The essential difference between wrapping and monkey-patching is that the former calls \nthe original closure, while the latter discards it. Consequently, the new function does not close over \nthe same environment as the original function the eval happens in a different context. Consider this \nexample: function makeAdder(x) { return function(y){return x+y;}; } var addFive = makeAdder(5); // addFive.toString() \n== \"function(y){return x+y;}\" The closure addFive makes use of closed-over variables, but by evaling \nits source code we lose the closure environment: if we were to monkey-patch addFive, the new function \nwould use the global value for x, if it existed, or fail otherwise. It is impossible, using monkey patching, \nto determine if a function closed over local variables or not, and so this technique is fatally .awed. \nWhile monkey patching can modify the middle of func\u00adtions, it is challenging to write precisely the correct \nreplace\u00adment operations solely in terms of their textual representa\u00adtion (as opposed to their more structured \nabstract syntax). The code invariably is obscure, needing fairly long pattern matches to .nd the right \njoinpoints, and inserting poorly\u00ad  in place, we resolve the aliasing problem: all references to that \nclosure now contain the advice. This neatly includes recursive calls to e: if env contained an entry \npointing to this ::= e . EXPR a... retval proceed closure, it will subsequently see the now-mutated \nversion. a . ASPECTEXP ::= at pointcut(p) ad p . FILTEREDPC ::= b [&#38;&#38; f]*::= statement_containing(e) \n  p||p Proceed and retval Generalizing before and after, field(e)  around advice surrounds the mainline \ncode. To call the b . BASEPC callee(e) mainline code, around advice uses the proceed keyword. Semantically, \nwe again inline: given around advice s2 and mainline s1 as above, we de.ne s= s2[y1/x1,...,yn/xn]. 2 \nf . FILTER stack(sd)sd . STACKDESC ::= e[, sd] within(e) ::= !e[, sd] The woven code is then s2[s1/proceed]. \nad . ADVICE ::= params . PARAMS ::= before(params){s} It is common for after or around advice to refer \nto the return value of the mainline code. In the body of such advice, after(params){s}around(params){s}we \nbind the return value to the name retval, which then can wrap{[get{e}][set{e}]} be read or modi.ed as \nneeded. (Outside advice, retval is not a reserved keyword.) Any return statements become jumps [ident[, \nident]*] to subsequent advice; the last one sets the .nal return value, and the caller resumes control \nonly after all advice have run. Figure 3. Aspect syntax for JS Weaving order Overall, weaving for a particular \nclosure c is de.ned in terms of all pointcuts for which the expres\u00adsion e evaluates to c. We take the \noriginal, unadvised clo\u00ad sure Uenv, .(y1,...,yn){s}) and ordered lists for before (b1, ..., bi), after \n(a1, ..., aj), and around (r1, ..., rk) advice. (For simplicity, assume all aspects use the same parameter \nnames as the mainline function; in general we perform the same substitution on parameter names as above.) \nEach list is ordered by when the pointcut was encountered during pro\u00adgram execution. We then apply each \nadvice one at a time, starting with bi in order, then ai in reverse order, and then surrounding them \nby ri in order, similar to AspectJ s weaving order [14]. The woven result is then r1 [\u00b7\u00b7\u00b7 [rk [ {b1; \n\u00b7\u00b7\u00b7 ; bi; s; aj ; \u00b7\u00b7\u00b7 ; a1}/proceed] \u00b7\u00b7\u00b7 ] /proceed] This ordering semantics means that weaving cannot \nbe per\u00adformed eagerly when dynamically evaluating each aspect expression. Instead, our JIT (see Section \n5.3) stores the as\u00adpects for each closure with the closure and weaves while JITing when the closure is \ninvoked. When the collection of aspects for a closure changes, weaving/JITing is redone. The translation \nabove deliberately does not deal explic\u00aditly with exceptional control .ow. If any code (mainline or advice) \nthrows an exception, all subsequent code is skipped. However, because our advice is truly inlined into \nthe func\u00adtion, around advice may surround calls to proceed with a try-catch statement, and control .ow \nwill work prop\u00aderly. (In AspectJ terms, all after advice is really after returning, and we do not support \nafter throwing ad\u00advice.) Similarly, if before advice returns early, no main\u00adline code or subsequent advice \nruns, unless around ad\u00advice uses a try-finally statement. This modifying of control .ow by advice is \nsurprisingly common behavior by real-world extensions (c.f. Figure 7 and the usages of statement_containing \nadvice). formatted and potentially malformed strings as replacement code.4 Moreover, if the replace fails \nto match, it returns the original code unchanged, which means that monkey patches fail silently, making \nthem devilishly hard to debug.  4.3 Language Semantics Our language extensions to JS are shown in Figure \n3. We explain the language in stages, focusing on the semantics of each construct. Section 5 then shows \nhow we implement these features ef.ciently, avoiding extra work or code blowup that a na\u00a8ive implementation \nof the semantics might incur. 4.3.1 Advising functions: at pointcut(callee(e)) Operationally, the simplest \nform of advice applies to closures: in the grammar above, these are at pointcut(callee(e)) ad { s } expressions, \nwhere ad is one of before, after or around. Such advice is inlined into the advised clo\u00adsure. When encountered, \neach pointcut evaluates e to a (reference to) a closure c, which we represent here as Uenv, .(x1,...,xn){s}) \nwhere env is the environment when the closure was created. (If e does not evaluate to a closure, abort \nwith a runtime error.) We .rst de.ne weaving one aspect before explaining how full weaving is de.ned \nfor all the aspects for a closure. Given a closure Uenv, .(y1,...,yn){s1}) and advice before(x1,...,xn){ \ns2 }, de.ne the new statement s= s2[y1/x1,...,yn/xn]. Mutate the closure, replacing it 2 with Uenv, .(y1,...,yn){s2.; \ns1}).(After advice is analo\u00adgous; around advice requires slightly more effort.) Notice that the updated \nclosure uses the original environment, which avoids the rebinding-of-variables problem associated with \nmonkey patching. Moreover, because we update the closure 4 The expert JS programmer will note that poor \nformatting is not merely aesthetically problematic: problems may arise due to the interaction of patch \ncode containing newlines and the rules for semicolon insertion.  Runtime representation of aspects and \ndynamic disable\u00adment Aspects are expressions in our language, and when executed they evaluate to native \nobjects (much like built-in ob\u00adjects, e.g., Math or Array): aObj = at pointcut...{...};. These objects \nhave a mutable disabled .eld that turns off the advice. If the program sets aObj.disabled = true, then \neffectively aObj is removed from the installed-advice list in the closure, and the advice is rewoven. \nWhen the pro\u00adgram resets aObj.disabled = false, aObj is restored to its original position in that list. \nOur implementation does not actually reweave or re-JIT, but still provides these semantics. Named parameters \nNote that in the example above, and in the abstract syntax for advice, we give names to the parame\u00adters \nof the function. Advice parameters are resolved by posi\u00adtion, and do not have to match the parameter \nnames de.ned by the mainline function. This has the bene.t of letting aspects name parameters for native \nmethods (such as Math.sin), which do not have explicit JS names for their parameters. By permitting the \naspect author to name parameters, we enable a more natural coding style for advice.5 Traditional aspect \nstyle would use a re.ective parameters array; JS already in\u00adcludes this via the arguments array-like \nobject. However, for technical reasons, any usage of the re.ective arguments object prevents the JS engine \nfrom applying certain useful optimizations. Referencing the arguments object requires an additional object \ncreation and initialization per function call, and requires an extra indirection when referencing all \nparameters in that function.  4.3.2 Stack Filters Extensions frequently need to advise utility or library \nfunc\u00adtions so as to change behaviors of the program. But perhaps not every call to those function needs \nadvice; only ones with a particular call stack should be advised. To achieve this, we let developers \nspecify .lters to constrain which joinpoints match a pointcut: callee(e) &#38;&#38; stack(s). In our \nlanguage, the stack .lter generalizes AspectJ s cflow pointcut. It permits specifying multiple stack \nframes that must, or must not, be present when the advice is triggered. For example, a .lter stack(a, \n!b, c, d) states that functions a, c and d must be on the stack in that order, and that b must not be \non the stack between a and c. Our design is greedy a matches the deepest (i.e., oldest) a on the stack \nand permits arbitrary intervening stack frames between speci.ed frames. Thus, the pattern above will \nmatch the stack main, a,a,c, b, d, but will not match the stack main, a, b,a, c, d. This semantics .ts \nwell with extensions requirements: supporting unspeci.ed intervening frames lets stack patterns continue \nto match even if other extensions insert themselves into the call stack, while 5 This is similar to an \nidiomatic usage of AspectJ s args pointcut, though we do not support args as a pointcut for JS: all functions \ntake arguments of dynamic types and arities, which defeats the intention of args. the greediness of negative \nassertions permits defensively avoiding speci.c other extensions. To de.ne the semantics for stack .lters \nmore precisely, let S = e1 :: \u00b7\u00b7\u00b7 :: em :: T :: [] be a stack, where e1 is the deepest stack frame and \nT is added after em at the young end of the stack. Let F=f1::\u00b7\u00b7\u00b7 ::fn::T::[] be a stack .lter (again \nT is implicitly added). Inductively, F matches S in the following cases: 1. F = [] 2. F = !f1::\u00b7\u00b7\u00b7 ::!fn::h::F \n, S = e1 :: \u00b7\u00b7\u00b7 :: em :: g :: S , ei  = fj , ei= h, g = h and F matches S 3. F = f::F , S = e :: S , \ne= f and F matches S 4. F = f::F , S = e :: S , e = f and F matches S  Note that negative assertions \nare not quite symmetric with positive assertions: they accumulate until a positive assertion discharges \nthem. Case 2 therefore has to skip over (zero or more) stack frames ei until .nding the .rst one (g) \nthat matches the next positive assertion (h), and check that none of ei match any of the accumulated \nfj . Weaving with .lters Naturally we have to change our weav\u00ading de.nitions to accommodate .lters. For \na set of stack .lters f1,...,fn guarding some aspect, and a current stack S, we must check that all .lters \nmatch the stack S. For before advice b or after advice a, we de.ne b = if(match(S, f1) &#38;&#38; \u00b7\u00b7\u00b7 \n&#38;&#38; match(S, fn)) {b} a = if(match(S, f1) &#38;&#38; \u00b7\u00b7\u00b7 &#38;&#38; match(S, fn)) {a} For around \nadvice r, we must be sure to call subsequent advice: r = if(match(S, f1) &#38;&#38; \u00b7\u00b7\u00b7 &#38;&#38; match(S, \nfn)) {r} else{proceed} Weaving multiple pieces of advice proceeds as before. 4.3.3 Advising multiple \nfunctions simultaneously The construction at pointcut(p1||p2) ad is roughly syn\u00adtactic sugar for at pointcut(p1) \nad; at pointcut(p2) ad, and is evaluated in the obvious manner. This construct may nest arbitrarily: \np1||p2|| \u00b7 \u00b7 \u00b7 ||pn. The sole distinction between the parallel and desugared forms is that the former \nproduces only one aspect object a while the latter produces several. Thus the parallel construction lets \nprograms enable or disable the advice on all targets simultaneously. Each base pointcut pi must be the \nsame type of pointcut all callee, all field, or all statement_containing.  4.3.4 Advising within function \nbodies Our survey of popular extensions code emphasized that not all desired program modi.cations fall \nneatly at function boundaries. We therefore support two additional pointcuts in our language, advising \nhow variables are accessed within functions, and advising statements within function bodies.  Advising \nvariables As in AspectJ, it is useful to advise getting and setting variables and .elds. Extension code \noften modi.es local variables within a function, to in.uence its behavior. We therefore de.ne the field \npointcut and its corresponding wrap advice, which speci.es a getter or setter (or both) to be used instead \nof the designated variable or .eld. Since variable names are commonly reused within a program, it is \nundesirable to advise all accesses to that name everywhere in the program. Therefore any aspects using \nthe field pointcut also specify a within .lter which (like the callee pointcut itself) accepts an expression \nthat resolves to a closure at runtime; the advice is applied only to that closure. The advice code must \nbe an expression, just like the code it is replacing.6 To accommodate weaving multiple advice onto the \nsame variable or .eld, we use proceed to denote the next advice expression or the underlying expression \nas appropriate. Any expression of the form a.b.c.d can be used with the field pointcut, rather than just \nvariables. We do not support array indexing (e.g., field(a[e].f)), as the replacement advice may evaluate \ne at different (or potentially multiple) times, which may cause unintuitive side effects. For example, \nthe following code ensures that the prefs object never appears null during the config function: at pointcut(field(prefs) \n&#38;&#38; within(config)) wrap { get { prefs != null ? prefs : getPrefs() } } while the following advice \nensures that a variable containing a maximum value can never decrease: at pointcut(field(maxVal) &#38;&#38; \nwithin(computeStats)) wrap { set { maxVal = Math.max(maxVal, proceed) } } Note that in JS, assignments \nare expressions, so the code above assigns the correct value to maxVal, and then returns it to any surrounding \ncode. The semantics of field advice are straightforward: given an aspect at pointcut(field(x.y) &#38;&#38; \nwithin(f)){ get { g } set { s }}, evaluate f to some closure Uenv, .(y1,...,yn){b}). Replace all assignments \nx.y = e in b with s[e/proceed]. Replace all other occurrences of x.y with g[x.y/proceed]. The extension \nto multiple advice for the same x.y is analogous to callee advice. Note that the joinpoints are speci.ed \nonly by the mainline code b later advice does not apply to code introduced by earlier advice. Advising \nstatements The remaining type of advice is a new way to insert code into the body of a function, inserting \nnew statements before, after, or around existing statements within function code. Other than systems \nthat expose explicit labels for joinpoints, we are unaware of any aspect system that al\u00adlows this .exibility. \nThe challenge is isolating a suf.ciently expressive pointcut to identify individual statements. We de\u00ad.ne \nstatement_containing(e) as the smallest statement 6 If necessary, the programmer may wrap the advice \nin the (function(){...})() idiom to use statements and return instead. containing expression e, as matched \nby abstract syntax. This has some subtleties: in the statement while(x+1 >0){if(x <5 &#38;&#38;x >0){x--;}} \nthe pointcut statement_containing(x) matches each of the while loop, the if statement, and the decrement \nstate\u00adment, because each one contains an instance of x not con\u00adtained in any smaller statement. Conversely, \nit matches the if statement only once, despite the repeated usages of x, so that advice is not woven \nmultiple times at the same point. Once the pointcut selects statements, we can easily apply before, after, \nor around advice to them, replacing statements with statements. The proceed keyword executes the original \nstatement or subsequent advice. This pointcut is particularly useful with extensions where the original \ncode handled a certain set of behaviors and the extension adds a new, unexpected one. Suppose a mainline \nfunction assumes its argument is a member of some enumeration {A,B,C,D}, and throws an error otherwise. \nIf an extension adds a new member E to that enumeration, it must also add code that handles E and avoids \nraising the error. Such code can be inserted before each statement_containing that argument.  4.3.5 \nDiscussion This section considers additional aspect constructs one might contemplate adding and discusses \nhow our aspects language may interact with new features added in ECMAScript 5 [10]. All our pointcuts \nare constructed to select exactly one target via callee or within; the parallel p||p construction permits \nspecifying multiple pointcuts per advice. However, many aspect systems admit more free-ranging pointcuts, \nei\u00adther with wildcards, catchalls, or arbitrary pointcut-designator functions, that select an arbitrary \nnumber of targets. In the web-extension context, this .exibility is unused, either be\u00adcause it is truly \nunneeded or because no extant JS idiom can express it. In the twenty examples we examined in depth (see \nSection 6.2), each wrapper was uniquely applied to a single function, as was nearly every monkey-patch. \nThe few excep\u00adtions were either applied a .xed number of times essentially p||p or applied, one at a \ntime, to an ad-hoc array of func\u00adtions: it is unclear from the extensions code what broader pointcut \nthe developer might have intended that would select precisely those targets and no others. Missing from \nour set of pointcuts is caller, which inlines code at call sites rather than within the callee. There \nare technical and pragmatic reasons for this. The technical reason stems from the dynamic nature of JS: \nWe cannot know until runtime when a particular function is about to be called at which point, the caller \nhas already been compiled, which prevents us from inlining the advice at the call site. To overcome this, \nwe would have to insert conditional tests at every function call site, which would introduce signi.cant \noverhead to the common, unadvised case. Pragmatically, we have not seen advice-like idioms that try to \nemulate a caller pointcut. In the code we have examined, those usages that pick out particular call sites \n(e.g., advice that uses a stack .lter) modify the caller s code only in ways that are better expressed \nusing our field pointcut.  A larger survey of extensions might indicate further point\u00adcuts and .lters. \nExtensions may want to select only if state\u00adments, or only the nth occurrence of some statement, or use \nwildcards to select any statement_containing(_ > 0)). Supporting these poses no inherent challenges. \nThe ECMAScript 5 proposal includes ways to de.ne get\u00adter and setter functions for .elds. Once these abilities \nare implemented in JS engines, advising a .eld s accessor func\u00adtions using callee advice might seem to \nsubsume field advice. However, accessor functions are neither required nor implicitly de.ned; retaining \nthe explicit field pointcut lets users advise .elds whether or not they have accessors. JS is primarily \nhosted within the web setting, which may also inspire new constructs. With appropriate implemen\u00adtation \nhooks, our approach is already capable of advising DOM methods (e.g., Element.appendChild). New point\u00adcuts \nwould be required to advise event dispatch or other mo\u00adments in the lifecycle of a webpage [11]. New \n.lters might be useful to restrict advice to some subtree of the current page. 5. Implementation of advice \nweaving We implemented our extensions in the Microsoft Research JScript compiler[4]. This compiler is \na JIT that lazily com\u00adpiles target function bodies at call time, specialized for the dynamic types of \nthe arguments at that call-site. Our compila\u00adtion strategy leverages this behavior: when calling an advised \nfunction, we must JIT the function body anyway, so we weave the advice into the body just before JITing, \nwhich then com\u00adpiles the woven result. Additionally, since weaving happens entirely at runtime, our weaver \ncan produce special syntactic forms that are not available to concrete syntax: these spe\u00adcial forms are \ncrucial to our ef.ciency. Section 5.1 explains how our JIT compiles regular, unadvised code. Section \n5.2 explains the changes needed to compile aspect expressions. Section 5.3 explains the weaving process \nitself. 5.1 Compiling unadvised code When we encounter a JS function for the .rst time, we need to generate \nintermediate code that we can then execute. Because our JIT is lazy, we instead create a code generator, \nan object that encapsulates all the information needed (e.g., the current environment) to eventually \ncompile the source JS. The runtime representation of a closure contains a pointer to its associated code \ngenerator. When we encounter a function call expression f(e), we: 1. Evaluate f to a closure cf and let \ncgf := cf .codeGen. 2. Ask cgf to compile f, specialized to e s runtime type. 3. Jump to and execute \nthe compiled code.  The specialization in step 2 is straightforward to do at runtime, and is key to \nef.ciency. Since JITing is expensive, code gen\u00aderators memoize the compiled, specialized function bodies \nin a table cache : Ulist of argument types). CompiledCode. Further, code generators are shared among \nall closures with the same source (e.g., as with higher-order functions): all clo\u00adsures sharing a code \ngenerator run identical code. The effect is to compile identical functions as few times as possible. \n 5.2 Compiling aspect expressions Aspects rewrite their advised closures, which means we must erase \nthe closures code generators memoized compiled code. Normal JIT mechanisms will then recompile the closure \nwhen needed, at which point we can weave the advice. To achieve this invalidation, we add a timestamp \n.eld to both closures and code generators: if a closure s timestamp is newer than its code generator \ns, then the memo table is out of date. To make code generators aware of aspects, we add a list of installed \naspect expressions to each closure, which can then be used during weaving. In short, when a code generator \ncompiles an aspect expression a, it generates code that: 4. Evaluates the pointcut p to a closure cp. \n 5. Adds a pointer to a into cp s list of aspects. 6. Updates cp s timestamp.  When we encounter a \nfunction call f(e), we change step 2 above, since it now needs to account for the installed advice. First, \nwe must effectively change the memotable to be of type Ulist of aspects).Ulist of argument types). CompiledCode. \nSecond, we must check timestamps: if the code generator is out of date, we clear the cache and update \nthe timestamp. But clearing this entire cache is too coarse: other closures may share the code generator, \nbut may not share the same advice. We only need to clear the part of the cache keyed by the current installed \naspects. To do so, we leave the memotable as it was, and instead make a new code generator for the closure \nplus current advice . We want to maintain sharing when multiple closures with identical code generators \nare advised by the same aspect. We introduce a second table aspectCache : aspect . CodeGenerator. To \nuse this table, we continue after step 6: 7. Let cgp := cp.codeGen. 8. If cgp.aspectCache[a]= null, \nthen set cp.codeGen := cgp.aspectCache[a]. 9. Otherwise, set cp.codeGen := new CodeGenerator and cgp.aspectCache[a] \n:= cp.codeGen.  Suppose we have three closures cx, cy and cz sharing code generator cg1. When cx is \nadvised by aspect a, we create a new code generator cg2 for it to use; cg1 (with its cache) is still \nvalid for cy and cz. If cy is later advised by a, it .nds cg2 = cg1.aspectCache[a], and so reuses cg2 \nand its cache. Again, cz continues using cg1 and its cache. This sequence of operations is minimally \ninvasive on the critical path of function dispatch: in programs with no aspects, we add only a single \nbranch (comparing timestamps). More\u00adover, it is maximally sharing, creating the fewest number of distinct \ncode generators. The worst case behavior involves repeatedly advising a function and calling it once, \nwhich com\u00adpletely defeats any caching behavior. Even in this unrealistic, pathological example, our compilation \noverhead is lower than that of other techniques (see Section 6.1).  5.3 Weaving advice We now describe \nthe actual weaving process. Our weaving mechanism is essentially a function of type ASTNode \u00d7 AspectList \n. ASTNode, though we make use of ASTNode types that cannot be generated via concrete syntax. These synthetic \nnodes let us temporarily alias function parameters to match advice parameter names or manipulate the \nreturn address of the function without strange syntactic contortions. 5.3.1 Weaving callee advice Consider \na function f with body B, and lists bb, ba and br (of lengths l, m, and n) of installed before, after, \nand around advice. Assume for now that each advice came from a callee(f) pointcut with no .lters. Figure \n4 shows a sim\u00adpli.ed resulting woven body B . Before and around advice can be concatenated with the body \n(BA). Around advice is more complicated, as it may call proceed multiple times; we implement around advice \nby inlining the next around advice (Ri+1) into the current one. Labels L and Lai mark potential targets \nfor return statements. The net result is the outermost R1, along with some bookkeeping described below. \nNamed parameters To implement the renaming of function parameters, we must ensure that any names introduced \nas pa\u00adrameters in one piece of advice must be scoped only to that advice. Rather than rewrite advice \ns explicitly to substitute names, we temporarily introduce the named parameters as aliases for the parameters \nof the function, scoped only to the body of the advice. We surround the advice by a pair of directives \nRenameParams and UnRenameParams. These have no runtime effect (they do not appear in the compiled code), \nbut temporarily change how the code generator com\u00adpiles those identi.ers: instead of local variables, \nthey resolve to the appropriately positioned arguments on the stack. As\u00adsignments to these parameters \nvia these aliases are visible to subsequent advice and to the mainline code. The current implementation \nrequires that the arities of the function and advice must match; this is not a fundamental requirement \nand can be relaxed later if desirable. Retval and exceptions Because we inline our advice into the callee, \nwe have to pay careful attention to return values and targets. The calling conventions dictate where \na func\u00adtion s return value is located; the AST node retval (used by around or after advice) provides \na mutable way to describe that location. Advice can therefore change the return value by either assigning \nto retval or simply returning a new value. The calling conventions also dictate that return statements \nbranch to the function epilogue before resuming the caller. Let BA = For each Before advice bi (1 = i \n= l) in install-order RenameParams(bi.params) bi.body UnRenameParams(bi.params) InstallReturnLabel(Lam \n) B For each After advice ai (1 = i = m) in reverse order Lai : InstallReturnLabel(Lai-1 ) RenameParams(ai.params) \nai.body UnRenameParams(ai.params) Let Rn+1 = BA For each Around advice ri (1 = i = n) in install-order \nLet Ri = RenameParams(ri.params) ri.body[Let L be a fresh label in InstallReturnLabel(L) UnRenameParams(ri.params) \n Ri+1 RenameParams(ri.params) L /proceed] UnRenameParams(ri.params) Let B = R1 UninstallReturnLabels() \nreturn retval Figure 4. Weaving of callee aspects To recapture control .ow for after and around advice, \nwe must change which label the compiler thinks identi.es the epilogue: the InstallReturnLabel directive \ndoes precisely this, changing the return label from the epilogue to the next applicable advice. The original \nreturn label is reinstated by the UninstallReturnLabels directive. Proceed It is possible that multiple \naround aspects that each call proceed multiple times could lead to exponential code blowup. In practice \nthis is unlikely; none of the exten\u00adsions we examined made use of such constructions. To avoid the blowup, \nwe can compile proceed to a pair of jumps, similar to our construction for retval. 5.3.2 Weaving stack \n.lters Implementing our design for stack .lters is particularly ef.cient: though it appears we need to \nwalk the stack when the advised function is called, we can instead achieve the same effect using only \nO(1) work per function named by the .lter.7 A stack .lter is a simple state machine whose state must \nbe updated as each relevant function runs. To eval\u00aduate the .lter in the aspect at pointcut(callee(e) \n&#38;&#38; stack(f1,...,fm)) before {s}, we need to add code to the entries and exits of closures fi \nto update the state of the stack .lter. Speci.cally, let st be a runtime representation of a stack .lter. \nThen for each 1 = i = m, evaluate at pointcut(callee(fi)) around { enter(st, fi); try { proceed; } finally \n{ exit(st, fi) }}. Functions 7 We are not the .rst to recognize that stack inspection can be achieved \nmore ef.ciently; Wallach et al. [22] use a similar technique for Java.  enter and exit update the state \nof st to re.ect how far the stack pattern matches the current call stack, based solely on the current \nstack frame fi; using finally ensures that exit will run regardless of the mainline control .ow. Consider \na .lter stack(a, !b, c). When a is called, the .lter s state advances from Start to Expecting c . If \nc is called (i.e., the stack is a::\u00b7\u00b7\u00b7 ::c), the state advances to Success and the enabled-.lter counter \nis incremented. As c exits, the counter is decremented and the state reverts to Expecting c . However, \nif b is called before c (i.e., a::\u00b7\u00b7\u00b7 ::b::\u00b7\u00b7\u00b7 ::c), the .lter state is Fail until b exits. The remaining \ndetails elided from Figure 4 support stack .lters. Since aspects can have multiple stack .lters, we equip \nthem with a counter of currently-enabled .lters, main\u00adtained by the stack advice above. We surround advice \nwith an enablement check (shown here for after advice): Lai : if (isEnabled(ai)) { InstallReturnLabel(Lai-1 \n) RenameParams(ai.params) ai.body UnRenameParams(ai.params) } The isEnabled helper checks that the current \ncount equals the installed count. If the test passes, the advice runs as be\u00adfore; otherwise, control \nfalls through to the next installed advice. (Around advice cannot simply fall through; we in\u00adstead generate \nan else { proceed } branch.) Dynamic disablement To check whether the program has disabled an aspect \nat runtime (via aObj.disabled = true), we add that check to the isEnabled function. The weaving remains \nunchanged. Avoiding redundant overhead If an aspect has no stack .lters, or if the aspect expression \nis used as a statement (and therefore the aspect object is ignored), we can simplify or eliminate the \nisEnabled tests, leading to more ef.cient woven code (see Section 6.1). 5.3.3 Weaving wrap and statement_containing \nCompiling wrap or statement_containing advice is done by preprocessing the body before applying callee \nadvice. During preprocessing, .eld advice is rewritten before state\u00adment advice. Recall that neither \npointcut designates a function in which the rewriting should occur: this is speci.ed by the mandatory \nwithin .lter which, like the callee pointcut, evaluates its argument at runtime to a closure, and installs \nthe advice onto it. Such advice is therefore somewhat of a hybrid, as it is a syntactic (static) transformation \non a runtime\u00adspeci.ed (dynamic) closure. The current implementation has the small limitation that it \nis impossible to advise global variables while in the global scope. This is a minor restriction on expressiveness, \nas there is relatively little code at global scope. In practice, this has not been a stumbling block. \n(Resolving this would change how we compile global code and penalize the performance of unadvised code; \nwe do not feel there is enough interesting code in global scope to warrant this change.) 6. Evaluation \nThe MSR JScript compiler is written entirely in C# and con\u00adsists of a JS front-end and JIT code generators \ntargeting either a specialized bytecode or the .NET Common Intermediate Language (MSIL); the MSIL in \nturn is compiled by the CLR JIT. Our extensions were easily con.ned to the front end and the code generators; \nthe CLR JIT was unchanged. Be\u00adcause the backends target .NET, and because the runtime environments are \nimplemented in .NET, the CLR JIT can easily optimize JS code together with the runtime. We evaluate our \nframework on performance (using the MSIL backend) and on expressiveness. 6.1 Performance Recent work \nhas seen enormous improvements in the per\u00adformance of JS engines [13], so it is important that new constructs \nnot undo this progress. Our compiler is work in progress, so absolute performance numbers are preliminary. \nInstead, we measure the relative performance of 1) an un\u00adwoven base program for reference, 2) simple \nadvice de.ned using our aspects, along with equivalent monkeypatched, wrapped, and manually-woven versions, \nand 3) advice with a stack .lter de.ned by aspects, and monkeypatched, wrapped and manually-woven versions. \nWe choose a trivial baseline function and minimal advice, to pessimistically maximize the ratio of weaving \noverhead to useful runtime work: the aspect version of our test program is shown in Figure 5. The seemingly-extraneous \nfunction surrounding the advice is in\u00adcluded in the manual and monkey-patched versions too, to force \nthem to execute as many closures while weaving in ad\u00advice as the equivalent wrapper idiom, eliminating \none (large) source of runtime differences. This hurts the non-wrapper versions equally, slowing them \nto the weaving speed of wrap\u00adping, without impacting the performance of the advised code. In practice, \nreal code would not be written this way. To account for inter-run and system variability, we re\u00adport \nthe minimum time achieved for each technique: whereas system noise can slow down a test run, the minimum \ntime represents the fastest time actually achieved by any approach. In our setting, measuring performance \nmust distinguish two levels of JITing/caching: .Net JITing our compiler and our compiler JITing the JS \nprogram. Once the .Net cache warmed up (the .rst 10-20, out of 200 runs), variability was insigni.\u00adcant: \nthe averages and minima were nearly equal. Every test iteration started from a cold cache for our compiler. \nOur tests were run on a 2.8GHz Windows XP machine with 4GB of memory running .NET 3.5 SP1. Despite caching \nand JITing, no test had a working set greater than 35MB of memory. Results are shown in Figure 6, presented \nas ratios of the total runtimes of each test versus that of the unadvised code.  square = function(v) \n{ return v*v; }; callSquare = function(v) { var ret = square(v); return ret; }; (function() { at pointcut(call(square) \n&#38;&#38; stack(callSquare) ) before(v) { v++; }; })(); for (test = 0, incr = 1; test < N; test++, incr++) \nif (callSquare(test) != incr*incr) print(\"Test failed for test \", test); Figure 5. Test microbenchmarks, \nwithout and with stack .lters (boxed), written using advice. N is an integer literal that varies across \nthe x-axis in Figure 6. Solid lines show the un.ltered test; dashed lines show the .ltered one. The x-axis \ncounts how often the test function is called after being advised (the constant N): calling it only once \neffectively measures the overhead of the weaving process; calling it many times asymptotically approaches \nthe overhead of the woven code. For some techniques, the relative cost of weaving may be cheaper than \nthat of the woven advice, leading to some curves rising for larger N. In short, our weaving mechanism \nruns as fast as the un\u00ad.ltered manually-woven version, and 5 27% faster than the stack-.ltered manually-woven \nversion. Contrast this with wrapping (31 61% slower than the .ltered manual version), or with monkey-patching \n(1 63% slower). Wrapping s per\u00adformance is badly hampered by the extra function calls within the advice \n(recall we already accounted for the extra function calls within the weaving process itself). Monkey \npatching generates code identical to the manual version, but pays a large initial cost for eval. Our \nperformance parity in the non\u00ad.ltered case comes from simple optimizations that eliminate vacuous .lter-enablement \nchecks. Our performance gains in the .ltered case come from implementing the stack .lter in\u00adside the \nruntime, rather than with state variables in JS itself. Runtime weaving as implemented here provides \nhigher per\u00adformance and stronger semantics than existing idioms a win-win situation.  6.2 Expressiveness \nWe designed our aspect language to support extensions, but we deliberately did not examine a large selection \nof extensions in advance, to prevent over-.tting our language to awkward coding idioms or legacy code. \nInstead, after designing the language, we thoroughly examined the scripts of twenty other popular Firefox \nextensions. Note that because our engine is not embedded in Firefox, we have not yet implemented an aspect-enabled \nFirefox, but rather we show that extensions could easily be rephrased to use aspects instead. Our twenty \nextensions were drawn from a snapshot of the top 50 add-ons in each category from Mozilla s http://addons.mozilla.org, \nas of October 2008; the Figure 6. Overhead comparison for test in Figure 5, with (dashed) and without \n(solid) stack .lters. Lower is better. versions of these twenty extensions tested here all support Firefox \n3.0. The snapshot contains 350 distinct extensions, of which roughly 10% use monkey-patching; our twenty \nextensions were drawn from these. As such our sample may conservatively undercount the prevalence of \nwrapping in extension code. Our results are summarized in Figure 7. The .rst three columns measure the \namount of JS code in each extension, and the amount of code directly attributable to either monkey\u00adpatches \nor wrapping. We count as a monkeypatch any lines of code that call eval and replace on code, including \nthe string arguments as they are the contents of the patch. It is more dif.cult to precisely count the \nlines of code needed in wrapping, as sometimes a function is simply wholly replaced, rather than precisely \n.tting the wrapping idiom. In such cases, we choose to undercount and include only the single line that \nbinds the new function to the old name. In total, these twenty extensions contain 98,700 lines of JS \ncode (LOC), of which 2,713 LOC (2.8%) is a monkey-patch or wrapper. The extensions range in size from \n300 10,000 LOC, and subjectively range widely in their effects on the browser. The two are not correlated: \nTree Style Tab requires far more lines of monkey-patching code (894/6786 = 13%) than any other extension, \neven though it is less than half the size of TabMixPlus and even though subjectively it modi.es the browser \nless than SplitBrowser. Conversely, All-in-one Sidebar is nearly the same size overall, but has 5% the \namount of patching code, while NoScript is twice as large and profoundly impacts the browsing experience, \nyet needs merely 11 lines of patches. Regardless of size, patches are key to extensions behavior, and \nso simplifying them is helpful. The remaining columns of the table count and categorize each hook (both \nmonkeypatch and wrapping) as one or more of our advice types, or as other if we could not express it \nusing our advice language. We were carefully literal\u00adminded in these classi.cations: if a patch was not \nprecisely expressible as an aspect, even if a semantically equivalent patch could be so expressed, we \ncounted this patch as a failure. For example, Tree Style Tab includes seven patches that insert  Name \nJS LOC Monkeypatch LOC Wrapping LOC Function Field Stack Stmtcont Other Fission 1.0 367 5 5 2 TabRenamizer \n0.8.11 536 3 3 Compact Menu 2-2.2.0 586 7 1 1 1 1 Multirow Bookmarks Toolbar 2.9 587 53 2 2 2 Redirect \nRemover 2.5.5 926 20 2 2 2 1 Multiple Tab Handler 0.3.2008101801 2048 83 5 10 2 3 1 1 Img Like Opera \n0.6.17 2287 45 4 1 1 6 1 FireGestures 1.1.5.1 2455 6 4 2 1 Gladder 2.0.3.1 2558 49 4 1 All-in-one Gestures \n0.19.1 4056 4 1 Split Browser 0.5.2008101801 4519 333 269 71 48 20 14 Session Manager 0.6.2.4 4697 6 \n3 3 2 1 TabKit 0.4.3 5232 63 16 12 SpeedDial 0.7.2.5 5641 20 22 3 2 1 Tree Style Tab 0.7.2008101801 6786 \n894 5 45 32 13 26 7 All-in-one Sidebar 0.7.6 7079 38 23 22 9 3 Gmarks 0.9.9 7700 3 1 2 1 TorButton 1.2.0 \n10560 2 139 139 NoScript 1.8.3.3 10809 10 1 4 3 TabMixPlus 0.3.7.3 14278 551 30 90 21 51 23 5 Figure \n7. Comparing 20 Firefox extensions, showing code size, patch size, and counts of how many patches by \nadvice types. a new statement after the opening brace of an if-statement. None of our existing advice \nforms support this. However, in these cases the guards of the ifs are pure, and so using before statement_containing \nadvice that repeated the if-test would have the same semantic effect. Despite being so stringent, our \nlanguage as presented can express 621 out of 636 (97.6%) observed hooks. Of the remaining 15: seven add \na statement to the beginning of an if block; four change the condition of an if test; one changes a statement \nin the middle of an if body; one inserts a statement at the end of one case of a switch statement; one \nchanges a while loop into a for loop; and one is unknown and appears broken. Evident from the table is \nthat all forms of advice are actually used: function advice is by far the most common, but statement \nadvice accounts for over 10% of the advice. Of the 103 stack .lters, while most .lters were only one \nfunction deep, several instances used multiple patches to manually implement two-or three-function-deep \n.lters; these patches could all be subsumed into a single stack .lter. 7. Related Work 7.1 Aspects for \nobject-oriented languages AspectJ [18, 19] is probably the most well-known aspect\u00adoriented language. \nAspectJ was designed to support both static and load-time weaving. In Java all methods have statically \nknown names. Compiling AspectJ ef.ciently poses several challenges, particularly for cflow [3]. However, \nsince Java does not support .rst-class closures, aliasing issues simply do not arise. AspectJ employs \ncomplicated heuristics to de.ne how pointcuts match in the presence of inheritance, overridden methods, \nand interfaces. The rules are designed so that advising a method on some superclass will trigger that \nadvice on all subclasses, regardless of whether they override the method. But JS is a prototype-based \nobject-oriented language, making heuristics designed for class hierarchies unnatural. Our design of advising \nclosures re.ects that distinction: by triggering advice through all aliases to a closure, we ensure that \nall objects of a given prototype share advice applied to the prototype. However, if a new object overrides \na method from its prototype, it is a different kind of object, and advice does not implicitly attach \nto it. Some of the compelling power of aspect-oriented pro\u00adgramming derives from its freedom to tamper \nwith almost any part of the code. Aldrich [2] proposed an explicit open module approach to curtailing \nthat freedom. Many of these ideas may be directly applicable to aspects in JS: for in\u00adstance, functions \ncomputing trusted values (encryption, cook\u00adies, passwords, etc.) might be sealed from advice. Indeed, \nthe object-hardening proposals for ECMAScript 5 [10] ef\u00adfectively permit sealing functions from wrapping \nor monkey patching; our aspect system would need to support or inte\u00adgrate the same ability. Currently, \nour proposal focuses on expressiveness; restricting expressiveness is left to future work.  7.2 Aspects \nfor functional languages AspectML [8, 23] primarily focuses on the challenges in adapting an aspect system \nto a strongly-typed functional lan\u00adguage. The authors choose not to permit advising anonymous functions \nor .rst-class functions. We permit advising these functions, as functions are frequently aliased to new \nvariables or passed as arguments to functions. Our treatment of stack .lters is inspired by AspectML \ns stack patterns. AspectScheme [9] contends with the challenges of alias\u00ading in an aspect system for \na higher-order functional lan\u00adguage. Their aspects are fully .rst-class: a pointcut is simply a boolean \nScheme function on joinpoints. Additionally, they explore both static and dynamic scoping constructs \nfor advice; we focused solely on dynamic scoping. Their implementation depends heavily on Scheme s hygienic \nmacros and continua\u00adtion marks [6, 12], permitting a whole-program-transforming implementation (by rede.ning \nfunction application) within Scheme. While one could add continuation marks to a JS JIT [7], our approach \nexploits direct JIT integration instead.  Our handling of replacing variables with new getters and setters \nbears some resemblance to the map-closure oper\u00adation [17]: like that work, we provide a .rst-class mech\u00adanism \nfor JS to open closures and reveal and revise their code without disturbing their closed-over environments. \nThe authors note in their discussion that aspect systems and map-closure are related, though their scopes \nare different: aspects are applied globally, while map-closure can be ap\u00adplied to a dynamic scope. This \ndistinction is pragmatically eliminated by dynamic .lters such as our stack .lters.  7.3 Aspects within \nJavaScript AOJS [24] is a recent prototype that implements weaving statically in a proxy server that \nmodi.es scripts before the browser sees them. This approach has several shortcomings, however, largely \nstemming from the choice to de.ne weaving via preprocessing, rather than within JS. It supports two pointcuts \nvariable assignments and function calls, but not retrievals, callee, or .lters. Pointcuts are implemented \nby replacing the variable or function name with calls to wrapper closures that in turn execute the advice \nand the original expressions. The approach relies explicitly on names and so does not avoid the aliasing \nproblem, and it cannot handle anonymous or runtime-created functions. AspectScript [21] is a concurrent \nand independent project designing aspects for JS. Like us, they advise closures rather than variables, \nto avoid the aliasing problem. They also ex\u00adplore different scoping strategies (similar to our within \n.l\u00adter). However, their implementation is fundamentally differ\u00adent: weaving is implemented at runtime \nby parsing and rewrit\u00ading scripts from within JS to wrap every potential joinpoint with a function. These \nrei.er functions construct a context for the joinpoint and then call the weaver which in turn ex\u00adecutes \nthe relevant advice and the mainline code. All these rewritings and indirections come at cost: code is \nsubstantially larger and slower even when no aspects are deployed. For a browser whose interface is largely \nwritten in JS, and (de\u00adspite many extensions) largely unmodi.ed JS at that, such overhead is likely untenable. \nBy contrast, our weaver causes zero code bloat and minimal runtime overhead. Additionally, introducing \na second JS parser into a web browser is risky: it may not be bug-for-bug compatible with the underlying \nJS engine, leading to potentially incorrect results. Finally, AspectScript does not catch evaled code \nor code that was loaded without being processed by their rewriter library: such code is not visible to \ntheir joinpoints and is not advisable. In our system, advice can use an arbitrary run-time expression \nto identify the closure to be advised and there are no restrictions on which closures are advisable. \n 7.4 Web Extension in Practice Browser extensions are an exceptionally popular mechanism for users to \ncustomize and enhance their browser with fea\u00adtures that are useful to some users, but not suf.ciently \nso to warrant inclusion in the main product. We need to distinguish between extensions to the browser \nsuch as custom search toolbars, themes, download managers and plugins to the browser s supported content \ntypes such as PDF renderers or movie codecs. Most plugins are implemented as DLLs. By contrast, extensions \nare a downloadable module of code that modi.es the code of the underlying browser so as to im\u00adplement \na self-contained feature. We focus here on Firefox s extension model, as it is the most expressive and \npowerful for browsers to date. We have focused on JS, but extensions also include user interfaces written \nin the XML language XUL and styling written in CSS. There are currently over six thousand Firefox extensions \nused by over thirty million people daily [16]. These exten\u00adsions customize nearly every facet of the \nbrowser, changing tab handling, mouse interactions, .le downloading behavior, etc. Many of these extensions \nreplace existing functionality with new code, using the wrapping idiom where appropriate. Other extensions \nmerely modify existing code slightly, us\u00ading monkey-patching. Some actually modify each other to resolve \ncompatibility issues. This last usage motivated our field and statement_containing pointcuts: for example, \none extension (SplitBrowser8) modi.ed another (All-in-One Tabs9) by replacing all accesses to a local \nvariable with a .eld on a globally visible DOM node, so that it could see that interim state later as \nneeded. Moreover, a reference to the DOM node was introduced as a new local variable for brevity. Clearly, \nthese contortions are ad hoc and dif.cult to reason about without a more structured approach. The userscript \nmechanism is similarly popular: nearly 40,000 scripts exist to tweak individual applications such as \nGmail, YouTube, or Facebook, remove ads on popular pages, etc. The top .ve userscripts have each been \ninstalled over eleven million times. Like browser extensions, userscripts frequently interact with the \nstructure or style of the DOM of the page, in addition to modifying its script content. Analogously, \nthose latter modi.cations are better expressed and reasoned about using aspects. 8. Future work JS aspects \ncan also be used to good effect beyond extensions: Concurrent research by colleagues [15] examines using \naspects to enforce security policies along the lines of Caja [20] or ADsafe [1]. Much of the challenge \nin freezing objects in Caja, for instance, requires interposing on any aliases to member functions in \nthat object; our approach of advising the closure directly addresses this issue. 8 https://addons.mozilla.org/en-US/firefox/addon/4287 \n9 https://addons.mozilla.org/en-US/firefox/addon/12  Libraries such as Script.aculo.us or Prototype \nbuild upon existing JS objects to provide convenient, common func\u00adtionality for websites. Some of that \nfunctionality is fairly aspect-like; Prototype, for instance, de.nes functions to extend objects with \ngetters and setters, and explicitly thread through proceed functions to call the next in\u00adstalled code. \nAspects can help simplify their development while improving their performance. The declarative nature \nof aspects opens up the possibility of new analyses. For example, recent work has focused on staging \ninformation .ow analyses in the face of dynamic composition of scripts [5]. Precision is lost whenever \ncode is evaled; declarative aspects present more structure than eval strings, which may improve precision. \nFor another, web\u00adapplication and browser extensions are notoriously prone to breaking when certain other \nextensions are simultaneously installed, due in large part to the fragility of the code-injection idioms. \nNot only do aspects subsume all the weaving com\u00adplexity of extensions, but they permit identifying when \nmulti\u00adple extensions advise the same code and potentially con.ict, which could provide useful warnings. \n9. Conclusions Web applications and browsers are growing ever more com\u00adplex. Their broad, ad-hoc customizations \nhighlight the need for an expressive mechanism by which to program them. In this work, we have implemented \nthe .rst JIT for JS that supports aspects. We identi.ed key linguistic requirements in the web-application \nspace and described how they differ from prior aspect systems. Our aspect proposal for JS meets these \nrequirements, and we have shown that it offers better performance and cleaner semantics, thereby improving \nthe development of extensions. References [1] Adsafe, Nov. 2009. http://www.adsafe.org/. [2] J. Aldrich. \nOpen modules: Modular reasoning about advice. In European Conference on Object-Oriented Programming, \nvolume 3586 of Lecture Notes in Computer Science, 2005. [3] P. Avgustinov, A. S. Christensen, L. Hendren, \nS. Kuzins, J. Lhot\u00b4ak, O. de Moor, D. Sereni, G. Sittampalam, ak, O. Lhot\u00b4and J. Tibble. Optimising AspectJ. \nIn ACM SIGPLAN confer\u00adence on Programming Language Design and Implementation, 2005. [4] M. Bebenita, \nF. Brandner, M. Fahndrich, F. Logozzo, W. Schulte, N. Tillmann, and H. Venter. SPUR: A trace-based JIT \ncompiler for CIL. In 25th ACM SIGPLAN conference on Object-Oriented Programming Systems, Languages and \nApplications, 2010. [5] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner. Staged information .ow for \nJavaScript. In ACM SIGPLAN conference on Programming Language Design and Implementation, 2009. [6] J. \nClements. Portable and high-level access to the stack with Continuation Marks. PhD thesis, Northeastern \nUniv., 2005. [7] J. Clements, A. Sundaram, and D. Herman. Implementing con\u00adtinuation marks in JavaScript. \nIn 9th Scheme and Functional Programming Workshop, 2008. [8] D. S. Dantas, D. Walker, G. Washburn, and \nS. Weirich. As\u00adpectML: A polymorphic aspect-oriented functional program\u00adming language. ACM Trans. Program. \nLang. Syst., 30(3):1 60, 2008. [9] C. Dutchyn, D. B. Tucker, and S. Krishnamurthi. Semantics and scoping \nof aspects in higher-order languages. Sci. Comput. Program., 63(3):207 239, 2006. [10] ECMA International. \nECMAScript language speci.cation, 5th edition, Sept. 2009. http://www.ecmascript.org/. \u00b4application security. \nIn 11th USENIX workshop on Hot topics in Operating Systems, 2007. [11] U. Erlingsson, B. Livshits, and \nY. Xie. End-to-end web [12] M. Flatt, G. Yu, R. B. Findler, and M. Felleisen. Adding de\u00adlimited and composable \ncontrol to a production programming environment. In 12th ACM SIGPLAN International Conference on Functional \nProgramming, 2007. [13] A. Gal, B. Eich, M. Shaver, D. Anderson, D. Mandelin, M. R. Haghighat, B. Kaplan, \nG. Hoare, B. Zbarsky, J. Oren\u00addorff, J. Ruderman, E. W. Smith, R. Reitmaier, M. Bebenita, M. Chang, and \nM. Franz. Trace-based just-in-time type special\u00adization for dynamic languages. In ACM SIGPLAN conference \non Programming Language Design and Implementation, 2009. [14] G. Kiczales, E. Hilsdale, J. Hugunin, M. \nKersten, J. Palm, and W. G. Griswold. An overview of AspectJ. In 15th European Conference on Object-Oriented \nProgramming, 2001. [15] L. Meyerovich and B. Livshits. ConScript: Specifying and enforcing .ne-grained \nsecurity policies for JavaScript in the browser. In IEEE Symposium on Security and Privacy, May 2010. \n[16] J. Scott. How many Firefox users use add-ons?, Aug. 2009. http://blog.mozilla.com/addons/2009/08/11/ \nhow-many-firefox-users-use-add-ons/. [17] J. M. Siskind and B. A. Pearlmutter. First-class nonstandard \ninterpretations by opening closures. In 34th ACM SIGPLAN-SIGACT symposium on Principles of Programming \nLanguages, 2007. [18] The AspectJ Team. The AspectJ programming guide, 2003. http://www.eclipse.org/aspectj/doc/released/ \nprogguide/index.html. [19] The AspectJ Team. The AspectJ 5 development kit de\u00adveloper s notebook, 2005. \nhttp://www.eclipse.org/ aspectj/doc/next/adk15notebook/. [20] The Caja Team. Caja, Nov. 2009. http://code.google. \ncom/p/google-caja/. [21] R. Toledo, P. Leger, and E. Tanter. AspectScript: expressive aspects for the \nweb. In 8th International Conference on Aspect-Oriented Software Development, 2010. [22] D. S. Wallach, \nA. W. Appel, and E. W. Felten. SAFKASI: a security mechanism for language-based systems. ACM Trans. Softw. \nEng. Methodol., 9(4):341 378, 2000.  [23] G. Washburn and S. Weirich. Good advice for type-directed \n[24] H. Washizaki, A. Kubo, T. Mizumachi, K. Eguchi, programming: aspect-oriented programming and extensible \nY. Fukazawa, N. Yoshioka, H. Kanuka, T. Kodaka, N. Sug\u00adgeneric functions. In ACM SIGPLAN Workshop on \nGeneric imoto, Y. Nagai, and R. Yamamoto. AOJS: Aspect-oriented Programming, 2006. JavaScript programming \nframework for web development. In 8th workshop on Aspects, Components, and Patterns for Infras\u00adtructure \nSoftware, 2009.      \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Web sites and web browsers have recently evolved into platforms on top of which entire applications are delivered dynamically, mostly as JavaScript source code. This delivery format has sparked extremely enthusiastic efforts to customize both individual web sites and entire browsers in ways the original authors never expected or accommodated. Such customizations take the form of yet more script dynamically injected into the application, and the current idioms to do so exploit arcane JavaScript features and are extremely brittle. In this work, we accept the popularity of extensions and seek better linguistic mechanisms to support them.</p> <p>We suggest adding to JavaScript <i>aspect-oriented</i> features that allow straightforward and declarative ways for customization code to modify the targeted application. Compared to most prior aspect-related research, our work has a different motivation and a different target programming environment, both of which lead to novel design and implementation techniques. Our aspect weaving is entirely integrated into a new dynamic JIT compiler, which lets us properly handle advice to first-class functions in the presence of arbitrary aliasing, without resorting to whole-program code transformations. Our prototype demonstrates that an aspect-oriented approach to web-application customization is often more efficient than current idioms while simplifying the entire process.</p>", "authors": [{"name": "Benjamin S. Lerner", "author_profile_id": "81318490369", "affiliation": "University of Washington, Seattle, WA, USA", "person_id": "P2354075", "email_address": "", "orcid_id": ""}, {"name": "Herman Venter", "author_profile_id": "81384610324", "affiliation": "Microsoft, Seattle, WA, USA", "person_id": "P2354076", "email_address": "", "orcid_id": ""}, {"name": "Dan Grossman", "author_profile_id": "81405594870", "affiliation": "University of Washington, Seattle, WA, USA", "person_id": "P2354077", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869490", "year": "2010", "article_id": "1869490", "conference": "OOPSLA", "title": "Supporting dynamic, third-party code customizations in JavaScript using aspects", "url": "http://dl.acm.org/citation.cfm?id=1869490"}