{"article_publication_date": "10-17-2010", "fulltext": "\n What Can the GC Compute E.ciently? A Language for Heap Assertions at GC Time Christoph Reichenbach \nNeil Immerman Yannis Smaragdakis University of Massachusetts University of Massachusetts University of \nMassachusetts creichen@gmail.com neil.immerman@gmail.com yannis@cs.umass.edu Edward E. Aftandilian Samuel \nZ. Guyer Tufts University Tufts University eaftan@cs.tufts.edu sguyer@cs.tufts.edu Abstract We present \nthe DeAL language for heap assertions that are e.ciently evaluated during garbage collection time. DeAL \nis a rich, declarative, logic-based language whose programs are guaranteed to be executable with good \nwhole-heap locality, i.e., within a single traversal over every live object on the heap and a .nite neighborhood \naround each object. As a result, evaluating DeAL programs incurs negligible cost: for simple assertion \nchecking at each garbage collection, the end-to-end execution slowdown is below 2%. DeAL is integrated \ninto Java as a VM extension and we demonstrate its e.ciency and expressiveness with several applications \nand properties from the past literature. Compared to past systems for heap assertions, DeAL is distinguished \nby its very attractive expressiveness/e.ciency tradeo.: it o.ers a signi.cantly richer class of assertions \nthan what past systems could check with a single traversal. Conversely, past systems that can express \nthe same (or more) complex assertions as DeAL do so only by su.ering orders\u00adof-magnitude higher costs. \nCategories and Subject Descriptors D.2.5 [Testing and Debugging]; D.2.4 [Software/Program Veri.cation]: \nAsser\u00adtion checkers General Terms Algorithms, Reliability Keywords heap assertions, garbage collector, \nreachability, dominance Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright &#38;#169;c2010 \nACM 978-1-4503-0203-6/10/10. . . $10.00 1. Introduction Garbage collection (GC) is a widely popular \nmechanism in modern programming languages, employed in representa\u00adtives of virtually all language classes, \nfrom mainstream man\u00adaged languages (e.g., Java, C#), to dynamic languages (e.g., Perl, Python), and to \nthe language avant-garde (e.g., Haskell, OCaml). The traditional view on GC considers it a necessary \ncost. Our work is based on the observation that GC also rep\u00adresents a unique opportunity. GC necessitates \nan occasional traversal of all live program objects. If all objects are going to be traversed anyway, \nit is natural to consider using this traversal for more than computing liveness. With minimal machinery \nthat piggybacks on the GC traversal, the system can perform computation over a program s heap. Such com\u00adputation \nshould be side-e.ect free, but also similar in struc\u00adture to a garbage collection traversal, in order \nto exploit GC well without undue overhead. Furthermore, this computation should not compute results essential \nto the main program s control .ow, or it would cause much more frequent garbage collection than would \nbe otherwise necessary. Assertion checking is a good .t for these requirements. Ensuring program properties \nby way of programmer-de.ned assertions is a crucial technique in software development and forms the cornerstone \nof methodologies such as Design by Contract [13]. Virtually every programmer with modern training has \nbeen well-exposed to the idea that using asser\u00adtions to trigger program failures is an excellent way \nto reveal faults. Since assertion checking only queries program data but does not update them, it requires \nno computations with side e.ects. Additionally assertions should not alter the pro\u00adgram control .ow or \ncompute results that the program will later use. Performing assertion checking during GC time is not \nnew. The QVM Java virtual machine [3] allows heap probes, which check reachability and dominance properties \nat GC time. The GC Assertions system of Aftandilian and Guyer [1] describes a suite of assertions that \ncan be e.\u00adciently checked at GC time. The limitation of these past systems is that they either do not \no.er a general language for writing assertions or they require multiple GC traver\u00adsals to evaluate a \nsingle assertion. In this way, they sacri\u00ad.ce either e.ciency or expressiveness. For instance, the Af\u00adtandilian \nand Guyer system includes very speci.c kinds of assertions, such as assert-unshared(obj). Recent versions \nof the QVM system allow full JML assertions but cannot evaluate those in a single GC traversal, often \nresulting in nu\u00admerous heap traversals in the course of evaluating an asser\u00adtion. As a consequence, e.ciency \nfor QVM assertions relies on reducing the cost of every GC via parallelism. Still, per\u00adforming multiple \nGCs, even in parallel, is much more costly than piggybacking on a single GC (which would need to oc\u00adcur \nanyway). In contrast, we present a Declarative Assertion Language (DeAL), which ful.lls the requirements \nof computing during GC time: it only allows side-e.ect-free computations and it can only express assertions \nwhose object access patterns are a good .t for a GC traversal and incur constant overhead per object. \nOur approach is informed by Descriptive Complex\u00adity, where the important complexity classes (LOGSPACE, \nPTIME, NP, PSPACE, etc.) have been captured by logic\u00adbased languages [10]. Although the performance property \nwe are interested in does not correspond to a complexity class, one can view it as a limited case of \nlinear-time compu\u00adtation, where we have the extra guarantee that the program is evaluated in a single \ntraversal of the heap. This is not a prop\u00aderty that is well-expressed in complexity theory, but it is \nan often-cited property of good locality for garbage collectors. For instance, Wilson s GC survey [23] \ndistinguishes algo\u00adrithms based on their locality. A GC algorithm is considered to have good locality \nwhen it only needs to visit each ob\u00adject once. Algorithms that need to perform multiple passes over the \nheap have bad temporal locality, since they always access the data that have not been accessed the longest. \nThis behavior is a bad .t for LRU-based cache mechanisms, espe\u00adcially for traversals that revisit structures \nslightly larger than the cache. DeAL is a logic-based extension of Java and guarantees that any assertion \nexpressible in it runs by traversing each live heap object (and a constant-size neighborhood around it) \nexactly once. From a logic standpoint, DeAL is a single\u00advariable .rst order logic with predicates of \nthe form Rc/d(x), meaning that object x is reachable from object c without going through object d. For \ninstance, we can express the well-formedness property of a doubly-linked list d via a logical assertion: \n.x . Node : Rd(x) . (x.next.prev = x) The concrete DeAL syntax uses a textual representation of logical \noperators. For instance, the above property is written: forall Node x: reach[d](x) -> x.next.prev == \nx DeAL is an expressive language, as we will demonstrate with many examples. Its generality allows us \nto write com\u00adplex properties (which past systems needed to hard-code) as straightforward logical expressions. \nFor instance, we can write the property all Node objects are dominated by object d , i.e., no path to \nthem exists that does not pass through d: .x . Node : \u00acRr0/d(x) The special constant r0 refers to the \nroot set of the GC traversal. Therefore the property means that no Node object is reachable without going \nthrough d. Using standard boolean connectives we can write inter\u00adesting combinations of properties e.g., \nthe DeAL assertion: (.x . Node :(x.data > threshold) . Rhotcache(x)). (.y . Node : \u00acRhotcache(y) . y.next \n= null) (In words, every Node object with an above-threshold data value is in the hotcache data structure, \nand some Node object that is not in hotcache has no next link. ) Although non\u00adtrivial, this assertion \n(like any other legal DeAL program, as de.ned in Section 2) is evaluated in a single heap traversal, \nper DeAL s locality guarantees. Exploiting the GC allows DeAL assertions to be evalu\u00adated with very low \ncost. We implemented DeAL by extend\u00ading the Jikes RVM and Eclipse Java Compiler and evaluated its e.ciency \nextensively. The overhead of evaluating DeAL assertions of course varies with the complexity of the asser\u00adtion: \nif the assertion consists of comparing k .eld derefer\u00adence expressions that depend on the current object, \nit is in\u00adevitable to incur O(k) cost per object. For typical small prop\u00aderties, however, DeAL imposes \nat most a few percent over\u00adhead over the cost of garbage collection, resulting in near\u00adzero (sub-2%) \noverhead over the end-to-end execution time of applications. In summary, our paper makes the following \ncontributions:  We de.ne a declarative language for linear time, single\u00adtraversal computations, which \nresults in good locality for whole-heap traversals. To our knowledge, no past language has ever o.ered \nthis guarantee. The property that all legal programs visit each object exactly once is a general pro\u00adgram \nproperty, not limited to the domain of computing dur\u00ading GC. As such, our language design and overall \napproach may .nd even more applications in the future.  We designed our language, DeAL, as a natural \nJava exten\u00adsion for assertion checking and implemented it in a modern high-performance JVM. We demonstrate \nthe expressive\u00adness of our design with numerous examples, mostly from the recent research literature. \n We evaluate the practical e.ectiveness and e.ciency of DeAL over a suite of assertions and applications. \nOur results demonstrate that the idea of an expressive language for assertion checking at GC time has \nexcellent properties and promise for wide adoption.  DealAssertion ::= assertion(F) | assertDisjoint(F) \n| unsafeAssert(F) F . Formula ::= q | F . F | F . F |\u00acF | F . F | f . F q . QFormula ::= .x . T : b \n|.x . T : b b . BoolFormula ::= r | b . b | b . b |\u00acb | b . b | b . b r . RelExpr ::= o | o . T | o = \no | o < o | o > o | o = o | o = o | o -o | Rt(x) .-- . t . TraversalSrc ::= s/s | /s | t . t o . Obj \n::= v | o. f | c | x s . SourceObj ::= v | s. f x . LVar is a set of logic variable names v . JVar is \na set of Java variable names T . Typ ::= Java types c . Const ::= Java constants f . Field ::= Java \n.eld names Figure 1. DeAL syntax. Note the distinction between ex\u00adpressions that do and do not contain \nlogic variables (sets Obj and SourceObj, respectively). Their only di.erence is that the former cannot \nappear as traversal sources in an R predicate or be a Java constant. 2. TheDeAL Language We next present \nDeAL s syntax, semantics, and usage exam\u00adples. 2.1 Language Design Syntax. The full abstract syntax \nof the DeAL language is shown in Figure 1. Since DeAL s expressions are .rst\u00adorder logic formulas, we \nwill freely alternate between the logical and the concrete DeAL syntax, as convenient for presentation \npurposes. The reader should treat the logical notation as a shorthand for the text DeAL/Java syntax, \ni.e., .x . T , .x . T, Rt, ., ., \u00ac, ., =, ., ., -, =, = are synonyms of the actual DeAL operators forall \nT x, exists Tx, reach[t], &#38;&#38;, ||, !, instanceof, ==, ->, <->, !=, <=, >=, respectively. The language \nhas three primitives: assertion(F), assertDisjoint(F), and unsafeAssert(F), where F is a sentence in \n.rst order logic. All three primitives attempt to check whether the formula is true, but they have di.er\u00adent \nrequirements and soundness guarantees, discussed later. All the logical connectives have their usual \nmeaning, with forall/exists quanti.cation implicitly applying over all live heap objects. Objects can \nbe compared for equality and primitive-valued expressions can be compared with the stan\u00addard primitive \nrelational operators <, =, etc. There is a single kind of unary predicate, R, described below. There \nare some design decisions visible in the syntax that are key for establishing the property that each \nheap object is traversed once. The .rst important element is that our .rst order logic has only one variable. \nThis does not mean that we cannot use multiple logic variable names in a single formula for clarity (as \nwe did in our example in Section 1 with a (.x ...) . (.y ...) ), but that quanti.ers cannot be nested, \nhence all logic variables could be renamed to have the same name without changing the meaning of the \nformula. The second important element is that the unary pred\u00adicates of the DeAL logic have the form Rs1/o1,..., \noi . s2/oi+1,..., oj . ... . sn/ol+1,..., om(x). Note that the .s in the above, although logically designating \nan or , are part of the predicate name and should not be confused with the top-level logical or connective. \n(For instance, there are no and and not counterparts in predicate names.) The meaning of the above relation \nis that x is reachable from s1 (called a source) via a path that does not include any of the objects \no1,...,, oi or x is reachable from s2 via a path that does include any of the objects o1,..., oj or ...or \nx is reach\u00adable from sn via a path that does not include any of the ob\u00adjects o1,..., om. (Note that the \nset of excluded objects keeps growing monotonically: the objects speci.ed to be excluded for every new \nsource si are in addition to all previously ex\u00adcluded objects.) An empty source si is shorthand for the \nroot set r0 of the garbage collection; thus, we may rewrite our earlier example of all Node objects are \ndominated by d as .x . Node : \u00acR/d(x). Together, these design decisions ensure that we can eval\u00aduate \nqueries in a single pass through the heap. First, disal\u00adlowing nesting ensures that we disallow queries \nthat make us compare every heap object to every other heap object, which we cannot do in one pass in \ngeneral. Second, the construction of the R ensures that we can .nd a suitable heap traversal strategy. \nIntuitively, the key feature of using a single R predicate to link reachability properties only with \nan or connective is that the predicate value is determined regardless of which path in the object graph \nwas used to reach an object. That is, if we reach an object via one path, we do not need to later try \nto also reach it via other paths. We should point out precisely how the language of DeAL formulas, F, \nformally .ts the mathematical de.nition of a .rst order logic e.g., see [10]. From the logic perspective, \nJava object expressions are treated as logical constants e.g., a Java variable v is a constant from the \nperspective of the logic, since its meaning does not change for di.erent values of the logical variables. \nJava .elds are treated as functions for instance, the expression x.next is equivalent to a logical function \nnext applied to logical object x. Type Checking and Assertion Semantics. DeAL asser\u00adtions can appear \nas Java statements at any legal point in a Java+DeAL program. Each assertion (a member of DealAssertion \nin the syntax of Figure 1) is a separate DeAL program, evaluated independently. The DeAL guarantee is \nthat each assertion requires a single traversal over objects, and thus can be evaluated during a single \ngarbage collec\u00adtion. (In Section 2.2 we discuss in more detail the various options on how often assertions \nare evaluated and how they are integrated in our current implementation.) For a syntactically well-formed \nDeAL program to also be valid, it .rst needs to satisfy Java type constraints on its expressions. The \ntypes of .eld reference expressions (either j or o in Figure 1) have to be compatible with their uses \nwith operators =, =, etc. That is, a relational expression (r in the syntax) should be either a legal \nJava expression with type boolean or an instance of predicate R. More interestingly, DeAL imposes restrictions \non how the R predicates are used in di.erent kinds of asser\u00adtions. These restrictions are closely tied \nto the meaning of assertion vs. assertDisjoint vs. unsafeAssert. In instances of assertion(F), at most \none reacha\u00adbility relation, Rs1/o1,..., oi . s2/oi+1,..., oj . ... . sn/ol+1,..., om(x), may occur in \nF, although the same re\u00adlation may occur multiple times. An assertion primitive straightforwardly checks \nthe asserted condition in a single traversal over all live objects.  In instances of assertDisjoint(F), \nmultiple reachability relations may occur, but, if two such relations occur, then in addition to asserting \nF we are asserting that the domains of the two relations are disjoint. If there is a node that satis.es \nboth relations then we will detect this and report failure of the assertion. (If the domains are all \ndisjoint, we can evaluate F in a single run through the heap during garbage collection, and if the domains \nare not all disjoint then we will detect this during the single traversal of the heap.)  In instances \nof unsafeAssert(F), multiple R relations may occur without a claim of disjointness. In this mode, the \nDeAL system will behave as if the domains of the R relations mentioned are all disjoint, without checking \nthis property. If the relations are not disjoint, then we are not guaranteed to detect this, nor to actually \ncheck F. Speci.\u00adcally, DeAL will not correctly check formula F if the truth value of F depends on objects \nthat simultaneously satisfy multiple R relations. The reason is that DeAL will only traverse such objects \nonce, while processing one of the R relations and without knowing whether the object sat\u00adis.es other \nRs. Yet formula F may express di.erent re\u00adquirements for an object depending on which R it satis.es. \n  2.2 DeAL Language Usage We next discuss how the user interacts with the DeAL lan\u00adguage and o.er speci.c \nusage scenarios. We begin with speci.cs on the current DeAL integration in Java. Although these are largely \nengineering choices (which could change without altering the essence of the language) they are useful \nin order for the reader to establish a concrete model of usage. Integration. We have integrated DeAL \nto Java as a con\u00adservative extension. The DeAL language is hidden behind a library and the user invokes \nassertions by calling static meth\u00adods assertion, assertDisjoint, and unsafeAssert in the main DeAL class. \nThe method calls accept DeAL formulas as regular strings. For instance, the doubly-linked list con\u00adsistency \ninvariant is asserted as: assertion( \"forall Node x: reach[d](x) -> x.next.prev == x\"); This allows unsuspecting \nJava compilers to process DeAL programs by linking to a simple stub library. The DeAL compiler, however, \nfully parses and statically type checks the assertion string. (As indicated earlier, most of the examples \nin this paper use the equivalent DeAL syntax of Figure 1 instead of the concrete textual syntax. Accordingly, \nwe elide the quotes that delimit the assertion string.) In designing DeAL s assertion evaluation model, \nwe con\u00adsidered two questions: when to evaluate and whether to eval\u00aduate. Regarding when to evaluate, \nwe chose to execute asser\u00adtion statements at the point they are encountered, rather than delaying until \nthe time when garbage collection would oc\u00adcur anyway. Compared to past systems, this design decision \nresembles that of the QVM system [3], as opposed to the option followed by Aftandilian and Guyer [1], \nwhich puts o. assertion checking until GC time. The latter has the dis\u00adadvantage that the shape of the \nheap may have changed be\u00adtween the point of assertion statement and the point of its evaluation, resulting \nin incorrect evaluation (both unsound and incomplete). However, the issue with evaluating assertions \nat the point they are encountered is that if every assertion causes a garbage collection then GC will \noccur too frequently, with high overhead. Therefore, DeAL decides whether to eval\u00aduate an assertion by \nmeasuring the amount of time since the last GC. The assertion is evaluated only if a su.ciently long \ntime has elapsed. In this way, assertions can be ignored, resulting in incompleteness.1 By default, we \ntie our deci\u00adsion of whether an assertion is to be evaluated or not to the same internal metrics that \nthe Jikes RVM GC uses to decide whether to perform a collection. Thus, we evaluate an asser\u00adtion roughly \naround the time a GC would be due to happen anyway. This is what we view as the most likely mode of useof \nDeAL: assertion checking happens at low frequency but without imposing heavy overhead. We o.er the user \nthe option of throttling the evaluation frequency of assertions, up to executing every single assertion \nencountered and suf\u00adfering the resulting overhead. This allows us to enforce as\u00ad 1 We choose to view \nDeAL as a fault detector, hence the meanings of sound and complete are exactly inverse from what they \nwould be for a correctness veri.er. sertion checking even in pathological cases that our default heuristic \nwould always skip, such as when speci.ed right af\u00adter a call to System.gc(). Examples. There are several \npossibilities for using DeAL in the course of regular programming. These include local data structure \ninvariants, ownership and dominance prop\u00aderties, disjointness properties, reachability properties, and \ncombinations of those. We show below several DeAL as\u00adsertions, most of them taken from the recent literature \n[6 8, 11, 16, 17, 19]. One common kind of condition concerns type constraints. For instance, all objects \nin a data structure may need to be Serializable, and no instance of a subtype of Thread may be stored \nin the structure: assertion(.x . Node :RHttpSession(x) . x instanceof Serializable . \u00ac(x instanceof Thread)); \n(Note that although class Thread is not Serializable,a user-de.ned subclass of it may be.) Local invariants \nfor data structures are quite common and useful. We already saw a doubly-linked list invariant, and a \nsortedness invariant is equally easy to express: assertion(.x . Node : Rc(x) . x.data = x.next.data); \n(Note that we can ignore the case of x.next being null. If a subexpression of a .eld dereference expression \nis null DeAL ignores the corresponding value of the logical vari\u00adable.2) It is similarly easy to specify \nthat a data structure rooted at c should have a cycle: assertion(.x . Node : Rc(x) . x.next -null); In \nthe same way, we can state data structure invariants for binary and n-ary trees, heaps, and so on. More \ninteresting properties are those that require the reachability of all objects that satisfy a condition: \nassertion(.x . Node :(x.next = null) . Rleaves(x)); Such properties are not easily expressible in plain \nJava, be\u00adcause they refer to any possible live object (with a given type, in this case) and not just \nto objects in a speci.c struc\u00adture that could be traversed with a plain for loop. With an existential \nquanti.er, we can easily assert that a value satisfying certain properties is found, independently of \nwhich data structure contains it: assertion(.x . Node : x.data > 3.141.x.data < 3.142); 2 For example, \nif in the quanti.ed expression, Qx : ., x.next.data occurs in ., then the quanti.er is restricted to \nthe case that x.next \u00adnull, i.e, (Qx such that x.next -null): .. As mentioned brie.y in the Introduction, \nwe can express dominance properties as non-reachability if the dominator is excluded [22]. For instance, \nwe can evaluate a property over all dominated nodes: assertion(.x . Node : \u00acR/c(x) . x.data > 0); Dominance \nby a single object is an object ownership property. Combinations of dominance properties allow more complex \nconditions. For instance, we can specify that every object of type Person has to be dominated by the \ncombina\u00adtion of data structures males and females. That is, no path in the object graph should be able \nto reach a Person object without going through the object called males or the object called females in \nthe program: assertion(.x . Person : \u00acR/males,females(x)); Note that dominance by a set of sources is \nnot equivalent to any boolean combination of individual dominance prop\u00aderties. In particular, x is dominated \nby the combined objects males and females is equivalent to neither x is dominated by males AND x is dominated \nby females nor x is dom\u00adinated by males OR x is dominated by females . (Consider objects reachable from \nboth data structures, which are dom\u00adinated by neither one.) If we want to state that the two structures \nare disjoint, we can do so with an assertDisjoint statement, which will also allow us to combine other \nconditions on the objects. For instance, we can have: assertDisjoint(.x . Person : Rmales(x).Rfemales(x)); \nThis states that any object of type Person is reachable from one of the two data structures, though there \nmay also be other paths to it. Since an assertDisjoint allows multiple disjoint R predicates in the same \nassertion, we can easily strengthen the condition to express every Person is dominated by either males \nor females but not both , by combining the last two example formulas: assertDisjoint(.x . Person : (Rmales(x) \n. Rfemales(x)). \u00acR/males,females(x)); Disjointness conditions have a variety of applications, in\u00adcluding \nleak detection (data may be reachable by unexpected data structures) and detection of improper sharing \namong threads. For instance, we can state that trees from distinct compilation phases do not share structure: \nassertDisjoint(.x : \u00ac(RparseTree(x).RsyntaxTree(x))); The above examples are representative of simple \nbut pow\u00aderful DeAL assertions. The examples do not include uses of unsafeAssert, which allows more complex \nassertions but with few guarantees, as we describe next. Unsafe Assertions. The unsafeAssert primitive \ngives the user extra .exibility but at the cost of not guaranteeing cor\u00adrectness. We do not consider \nunsafeAssert to be a core part of the DeAL language, and we have not used it in prac\u00adtice. Nevertheless, \nit represents an escape clause for the user to specify richer properties than those that DeAL can stat\u00adically \nguarantee to check in a single traversal. It is the re\u00adsponsibility of the user to ensure that such properties \nmake sense under DeAL s single-traversal execution. Therefore, it is worth elucidating possible usage \npatterns, since correct\u00adness depends on understanding them. There are four possi\u00adbilities for the correctness \nof evaluating an unsafeAssert: The formula is evaluated soundly and completely, i.e., DeAL assertion \nfailures correctly indicate that the formula is false, and if the DeAL assertion evaluation does not \nfail, the formula is true. This is the case when the shape of the properties or of the heap ensures that \nthe truth value of the formula does not depend on which objects satisfy multiple Rs. For a simple example, \nconsider a formula that treats all objects reachable under two di.erent sets of conditions the same way: \n.x :(Rs1/o1(x) . x.data > 0) . (Rs2/o2(x) . x.data > 0).  The formula is evaluated soundly, i.e., DeAL \nassertion failures correctly indicate that the formula is false. This means that some DeAL warnings may \nbe missed, but this is likely practically acceptable. For example, the formula may contain two distinct \nR predicates with one of them implying stronger conditions than the other (e.g., .x : (Rs1(x) . x.data \n> 0) . (Rs2(x) . x.data = 0)). DeAL o.ers no guarantee as to which condition it will check for objects \nthat satisfy both Rs.  The formula is evaluated completely: there may be false assertion failures, but \nif no assertion fails then the formula was true at the point of evaluation. An example would be the complement \nof our previous unsound formula: .x : Rs1(x) . x.data = 0 . Rs2(x) . x.data < 0.  The formula is evaluated \nneither soundly nor completely e.g., it combines an incomplete and an un\u00adsound sub-formula. This scenario \nmay still be valuable if it turns out to detect failures often while issuing false re\u00adports rarely. Practical \nautomatic bug detectors are often unsound and incomplete the authors of ESC/Java have argued forcefully \nthat soundness and completeness are overrated properties compared to practical usefulness in catching \nbugs [9].  3. Single Traversal Property and Language Implementation We next state and prove DeAL s single \ntraversal property. This discussion also serves to introduce the way the DeAL compiler processes programs \nand the changes required to the runtime system so that assertions are evaluated as part of a GC traversal. \n 3.1 Single Traversal Evaluation DeAL assertions are guaranteed to be evaluated in a single traversal \nof live heap objects. Although in the rest of the paper we informally describe this property as each \nobject is traversed once , this assumes an implicit understanding that an object may be re-examined brie.y, \nonly to discover that it was visited earlier. Below we state the desired property more precisely. Theorem \n1. A valid, safe DeAL assertion (i.e., a sin\u00adgle assertion or assertDisjoint statement but not an unsafeAssert \nstatement) can be evaluated correctly in a single traversal that crosses each edge in the object graph \nexactly once and performs a constant amount of work per object. (This constant depends on the size of \nthe assertion.) Proof. Consider .rst the case of an assertion statement. According to Figure 1, an asserted \nformula is a boolean com\u00adbination of quanti.ed formulas (each starting with . or .), with each quanti.ed \nformula being a boolean combination of relational expressions, r. Since all quanti.cation is over live \nobjects, it is clear that we only need to evaluate every relational expression r once per object. All \nrelational expres\u00adsions of a form other than Rt(x) can be evaluated correctly in constant time for any \nobject. Thus, we can evaluate all such expressions (from the entire asserted formula) at what\u00adever time \nan object is visited. The di.culty lies in proving that we can de.ne a traversal (i.e., a loop over live \nobjects) for which expressions of the form Rt(x) are also correctly evaluated in constant time. If we \nalso show this, then our traversal needs to keep current truth values only for all quan\u00adti.ed formulas \nand at the end of the entire traversal perform their boolean combination for the .nal result. (An optimiza\u00adtion \nconsists of short-circuiting the evaluation of quanti.ed formulas. That is, if an . or . formula has \nalready had its truth value determined before the end of the traversal this can only be true for . and \nfalse for . there is no reason to evaluate for further objects the relational expressions r in the body \nof this quanti.ed formula.) Recall that, per the restrictions of Section 2.1, a valid assertion statement \ncan only contain instances of a sin\u00adgle Rt(x) predicate. The truth value of such a predicate can be computed \n(in constant time) for a traversal visit\u00ading every live object once. The full form of the predicate is \nRs1/o1,..., oi . s2/oi+1,..., oj . ... . sn/ol+1,..., om(x). We de.ne the traversal to satisfy the required \nproperty as follows: Mark objects o1,..., oi ignored. For example, for query Ra/b .c/d, e(x) in Figure \n2, we mark b as ignored.  Perform a standard reachability traversal starting at ob\u00adject s1. The traversal \nprocesses objects that are neither ignored nor visited and marks objects visited after pro\u00adcessing them. \nPredicate Rt(x) is true for each processed   Figure 2. Traversals for Ra/b . c/d, e(x), in order. \nobject, since it is reachable from object s1 without going through o1,..., oi. Thus, when processing \nan object, the traversal can evaluate (for the current object) all relational expressions r in the entire \nformula. For our example in Figure 2, we execute traversal 0, starting from a, ignoring b. Proceed in \nthe same manner for other sources and ex\u00adcluded objects. That is, mark objects oi+1,..., oj ignored, \nperform a standard reachability traversal starting at object s2, etc. In total there are n such steps \n(one for each object s1,..., sn). In our running example (Figure 2) we now ignore objects d and e and \nthen perform traversal *.  Remove the ignored .ag from all objects o1,..., om. In our running example \nwe now remove this .ag from b, d, and e.  Perform m reachability traversals, each starting at object \nok for 1 = k = m, followed by a reachability traversal starting at the root set (i.e., the default live \nobjects of the program s execution, such as the stack and the global re\u00adgion). Every traversal processes \nall non-visited objects and marks objects visited after processing them. During each of these m + 1 traversals, \npredicate Rt(x) is false for each processed object, by nature of the traversal: the object was not reachable \nby any si without going through the cor\u00adresponding excluded objects o1,..., om. When processing an object, \nthe traversal can evaluate (for the current object) all relational expressions r in the entire formula. \n In our running example, we .rst run traversals @ through 0, though 0 would be a no-op (since we already \nvisited d in 0 before ignoring it). Then we conclude with the root traversal <. Note that no edge in \nthe object graph (that is, a reference .eld of an object) is processed twice: the standard reachabil\u00adity \ntraversal follows edges out of an object exactly once, after marking the object visited, and the only \nfurther operation on a visited object is to check whether it is visited. We invert the meaning (i.e., \nmapping to a 0 or 1 bit) of visited after every collection. (This is a standard technique in mark\u00adsweep \ngarbage collection, avoiding a second visit of nodes just to reset them.) After collection no object \nis ignored (since no object is ignored initially.) The above traversal satis.es all requirements of the \nproof. It also requires space of two bits per object (one for the visited .ag and one for ignored).3 \nFrom the perspective of the visited .ag, the above traversal is a full replacement of a GC reachability \ntraversal with only the object visiting order modi.ed. The handling of statement assertDisjoint is quite \nsim\u00adilar. The di.erence is that, in addition to the visited and ignored .ags we maintain per object, \nwe need ilog(u)l bits per object, where u is the number of distinct predi\u00adcates Rt(x). These bits form \na traversalNum counter. The traversal proceeds by repeating all but the last step of the assertion traversal \nfor every Rt(x) predicate, with some small di.erences. First, while marking an object visited af\u00adter \nprocessing, the traversal sets traversalNum to the current traversal number, which is initially 0 and \nincremented for ev\u00adery Rt( x) predicate examined. Second, for each previously visited object encountered, \nthe traversal checks whether the visited object s traversalNum is equal to the current traver\u00adsal number \n(indicating a previously visited object during the current traversal) or lower (indicating a disjointness \nerror and causing an immediate assertion failure, unless the object is also ignored). The .nal traversal \n(from the root set and from excluded objects) uses a traversal number of 0, thereby avoiding disjointedness \nerrors. The above assertDisjoint traversal maintains the prop\u00aderties required for the proof. First, the \ntruth value of every R predicate is evident at the time of visit of each object, since the disjointness \nproperty guarantees that the only predicate R that is true for the object is the R predicate whose traversal \nreaches the object. Second, the visited .ag ensures no edge is crossed more than once, by the same argument \nas for the assertion traversal. D Although the above proof is not hard, this is largely due to the careful \ndesign of the DeAL language, which main\u00adtains the properties required for a single traversal evaluation \nof assertions. We note that it is quite easy to be misled with respect to predicates that can be evaluated \nin a single traver\u00adsal. For instance, a common mistake is to attempt to integrate the inverse of predicate \nRc(x) in a single traversal language: It is not possible to add to DeAL a predicate Pc(x) with the meaning \nx can reach c while maintaining the same single traversal property for arbitrary graphs. 3.2 DeAL Implementation \nThe proof of the single traversal theorem essentially lays out the principles of the DeAL implementation. \nEach traversal may need to touch the entire heap, so DeAL must interface with a whole-heap garbage collector, \nsuch as mark-sweep or the major collection of a generational collector (which performs whole-heap traversals). \n3 This requirement can be reduced to just one bit per object, by using the visited bit to also mean ignored, \nplus a second bit only for each of the m ignored objects. The reason for the second bit is that, during \nthe .nal traversal from the root set, it is necessary to remember whether an ignored object has been \nvisited or not. DeAL instructs this garbage collector to perform the traversals described in the proof \nfor assertion and assertDisjoint. Statement unsafeAssert is handled identi\u00adcally to assertion with the \nonly di.erence being that all but the last step of the assertion traversal are repeated for every Rt(x) \npredicate in the formula. Therefore, unsafeAssert visits every object exactly once but without guaranteeing \ncorrect evaluation of the assertion, since each object is vis\u00adited only as part of a traversal corresponding \nto a single R predicate. DeAL is implemented on top of Jikes RVM [2], modify\u00ading the included MarkSweep \ngarbage collector. The bulk of the implementation consists of changes to the runtime sys\u00adtem, and especially \ninterfacing with the collector. To pro\u00adduce a clean and general interface, we introduced a small trace-and-test \nlanguage inside the VM. A trace-and-test program instructs the garbage collector what to mark recur\u00adsively, \nwhat to test for, and what individual objects to ex\u00adpressly exclude or include in the traversal. The \ntrace-and\u00adtest language has primitives such as exclude-node(o) (to exclude an object from the traversal), \ninclude-node(o) (to unmark an object, so that it is processed when next en\u00adcountered), mark-traversal-id(x) \n(to increase the traver\u00adsal number), set-expressions(k1,..., kn) (to set up the sets of relational expressions \nthat need to be evaluated for ev\u00adery node, together with information, per set, on whether the expressions \nare in an existential or universal context), and trace(o) (to start a reachability traversal at object \no). The DeAL compiler translates an assertion into trace\u00adand-test language instructions, following closely \nthe traver\u00adsal structure described in the proof of Section 3.1. The rela\u00adtional expressions that need \nto be evaluated per-object are translated into plain Java methods that the runtime com\u00adpiles with the \nmaximum optimization level allowed by the Jikes just-in-time compiler. We altered the garbage collec\u00adtion \nlogic in the virtual machine to execute the trace-and-set instructions. For marking nodes, we employ \n4 bits per object that are currently unused by the runtime, resulting in a max\u00adimum of 8 R predicates \nper assertDisjoint formula (since one bit is occupied by the ignored .ag); in addition we ob\u00adtain the \nvisited .ag from a region in the object header re\u00adserved for the existing MarkSweep garbage collector. \nIn the future, the implementation could allocate extra space per ob\u00adject on a side structure, allowing \nunlimited R predicates. 4. Discussion: Expressiveness Limitations, Programming Patterns DeAL is an expressive \nlanguage but has by design some ex\u00adpressiveness limitations to support its single traversal guar\u00adantee. \nClearly, DeAL cannot express computations that are inherently non-linear, or non-single-traversal. Furthermore, \nDeAL occasionally cannot support computations that hap\u00adpen to be computable in a single traversal, if \ntheir structure obscures this fact. For instance, consider the property all Node objects directly referenced \nby array arr are dominated by arr . This is a property that can be evaluated in a single traversal, yet \nit is not expressible in DeAL. One can attempt to write the property straightforwardly as: assertDisjoint(.x \n. Node : Rarr(x) .\u00acR/arr(x)); Yet this is not the desired property: the Node objects directly referenced \nby arr are only a subset of all the objects reachable by arr. For instance, the Node objects referenced \nby arr may themselves refer to other objects that are not dominated by arr, causing a spurious disjointness \nerror. Intuitively, the desired property should be expressible in DeAL but is not because of a technicality: \nAlthough the property is local (it requires traversing just one link to tell that an object is directly \nreferenced by arr), it is not local from the perspective of the referenced object: when visiting a random \nobject it is not possible to know in constant time whether it is directly referenced by arr. These (as \nwell as many other) expressiveness limitations of DeAL can be overcome by combining Java computation \nwith DeAL assertion checking. The general programming pattern consists of having Java code compute a \nproperty of objects, summarize the results as a local property (for instance, by marking a .eld for all \nobjects satisfying the desired property) and invoke a DeAL assertion that checks whether the marked objects \nhave the expected structure. In our above example, if we add an otherwise unused .eld mark in class Node, \nwe can easily express the desired assertion by combining Java and DeAL evaluation: Object dummy = new \nObject(); for (Node n : arr) n.mark = dummy; assertion(.x . Node :(x.mark = dummy) .\u00acR/arr(x)); This \nprogramming pattern is quite powerful. It allows nearly arbitrary extension of the properties that can \nbe checked, at the expense of performing some of the work outside the DeAL traversal. Given the generality \nof the pat\u00adtern, we are considering adding language support for it in fu\u00adture versions of DeAL. Namely, \nwe can add a labelObject primitive to DeAL and allow the Java program to mark ob\u00adjects with a .nite set \nof labels, at any point in the execu\u00adtion. Then, when a DeAL assertion is checked, it can refer to whether \nan object has a certain label or not (labels are unary predicates). The markings will be cleared after \nevaluation of the assertion. This simple addition to the language is just a convenience feature that \nobviates the need for extra .elds, such as mark in our earlier example. The markings can be kept on a \nside structure that the DeAL traversal consults. We have not added such convenience features in our .rst \nversion of DeAL, preferring to concentrate on the core language in\u00adstead of on elements that can be easily \nemulated. 5. Experiments We evaluate the implementation of DeAL with several ex\u00adperiments: We evaluate \nthe assertions of Section 2.2 in a full heap of objects with no other computation performed in the application. \nThis is a controlled microbenchmark for the given assertions, intended to check how much the overhead \nvaries with the complexity of typical assertions and with the percentage of relevant objects.  We run \na wide spectrum of actual applications (includ\u00ading the DaCapo benchmarks [4], SPEC JVM98 [20], and pseudojbb \na .xed-workload version of SPEC JBB2000 [21]). We measure the overhead of simple (generic) DeAL assertion \nchecking, when assertions are evaluated with the same frequency as that of normal garbage collection \nin the course of the application. This is an end-to-end experiment establishing cost under condi\u00adtions \nwhere the user intends to achieve near-zero-overhead execution.  We analyze in more depth the overhead \nof a custom as\u00adsertion that reveals a (known) bug in pseudojbb. This is a close approximation of a real \nuse scenario.  All experiments con.rm that the overhead of DeAL is small and becomes negligible for \nassertion evaluation at roughly normal GC frequencies. 5.1 Methodology and Setup Our system is implemented \non top of Jikes RVM 3.1.0, so we compare our results to those of the unmodi.ed Jikes RVM 3.1.0, both \nusing the full-heap MarkSweep collector. We use the DaCapo benchmarks versions 2006-10-MR2 and 9.12-bach. \nFor SPEC JVM98, we use the large input size (-s100); for DaCapo 2006, DaCapo 9.12, and pseudojbb, we \nuse the default input size. Many of the DaCapo 9.12 benchmarks do not run on the unmodi.ed Jikes RVM \n3.1.0, so we provide results from only those that do. We perform our experiments on a Core 2 Duo E6750 \nmachine with 2 GB of RAM, running Ubuntu Linux 9.04. We use the adaptive con.guration of Jikes RVM, which \ndynamically identi.es frequently executed methods and re\u00adcompiles them at higher optimization levels. \nWe iterate each benchmark k times and record the results from the last it\u00aderation. For microbenchmarks \n(Section 5.2) k = 10, and for larger programs k = 4. We repeat this twenty times for each benchmark. \nAll numbers reported are means of the 20 runs, and our graphs also include 90% con.dence intervals. We \nexecute each benchmark with a heap size .xed at two times the minimum possible for that benchmark using \nthe MarkSweep collector. We vary the UNIX environment size to avoid measurement bias [14].  5.2 Controlled \nMicrobenchmarks The overhead of DeAL evaluation depends strongly on the complexity of assertions. For \ninstance, if the user asserts a property that is a function of the values of k neighbors of every live \nobject, then the runtime cost will necessarily be O(k). Therefore, the interesting question concerns \nthe overhead for typical assertions. We used as our evaluation set the example assertions of Section \n2.2 (which mostly emulate assertions from the recent research literature [6 8, 11, 16, 17, 19]). The \nassertions are applied to specially designed skeletal programs, with appropriate data structures for \neach assertion. The intention of these microbenchmarks is to show what can be expected as a worst-case \nexecution time for repre\u00adsentative assertions. These programs do nothing aside from building the data \nstructure and running an assertion on it. We used three di.erent input sizes, determining the num\u00adber \nof objects on the heap (counting only objects with types relevant to the assertion): small (10,000 objects), \nmedium (100,000 objects), and large (1 million objects).4 The com\u00adparison is to an unmodi.ed Jikes RVM \nthat runs a regular System.gc() every time DeAL would check an assertion. Figure 3 shows the GC time \noverhead results for all three input sizes. The large input size expectedly incurs the most over\u00adhead. \nThe geometric mean of the GC time overhead is 1.25. That is, assertion checking slows down garbage collection \nby just 25%. The absolute worst-case GC time slowdowns rise to 60-70%. Generally, assertions that access \n.elds perform worse than those that just check disjointedness or reacha\u00adbility properties. Note that \nthe object type provided in the assertion does not serve as an e.cient .lter, since the pro\u00adgram is specially \ndesigned to create only objects matching the type examined in the assertion. Thus, the .elds of vir\u00adtually \nevery program-generated object need to be examined. (This is unlikely to be the case in a realistic setting: \nobject types will be used to disqualify most objects without needing to examine their .elds.) The three \nworst performers are as\u00adsertions cyclic , doubly linked list , and sorted , repro\u00adduced here: assertion(.x \n. Node : Rc(x) . x.next -null); assertion(.x . Node : Rd(x) . (x.next.prev = x)); assertion(.x . Node \n: Rc(x) . x.data = x.next.data); As can be seen from Figure 3, even the worst case slow\u00addown is quite \nlow, considering that GC time is a small part of total program execution time. Indeed, even though these \n4 The choice of sizes follows the sizes of the DaCapo benchmarks. Across all DaCapo benchmarks, the geometric \nmean of the maximum number of live objects is roughly 100,000. The minimum is about 3,000 and the maximum \nis 3.2 million [4]. Therefore, our three setups have roughly the same spread of sizes as the DaCapo benchmarks. \n Figure 3. GC time overhead for representative assertions and skeletal programs, for small (top), medium \n(middle), and large (bottom) input sizes. skeletal programs do very little other than assertion check\u00ading, \nthe total execution time overhead (not shown in Fig\u00adure 3) has a geometric mean of 1.07 for the small \ncon.g\u00aduration, 1.08 for the medium, and 1.13 for the large i.e., assertion checking causes slowdowns \nof just 7, 8, and 13%, respectively.  5.3 End-to-end Simple Assertion Cost We ran a large suite of end-to-end \nbenchmarks to quantify the overall overhead of our system. Our suite of applica\u00adtions includes the DaCapo \nbenchmarks, SPEC JVM98, and a .xed-workload version of SPEC JBB2000 called pseudojbb. Clearly, the challenge \nof evaluating overheads over a wide range of applications is that real assertions are application\u00adspeci.c. \nTo overcome this di.culty, we added a generic assertion in our runtime that runs at the same frequency \nas normally-triggered GC. This assertion checks that there are no objects on the heap that are an instance \nof a certain un\u00adused class. Thus, the assertion should always return true, but it will cause an instanceof \npredicate to be tested on every live object. In addition, we allow this dummy assertion to be combined \nwith a traversal disjointness test, which incurs the cost of also writing and checking a traversal ID \nin the header of every live object. Figure 4 shows the overhead of DeAL on GC time for the benchmark \napplications. The .gure shows three con.gu\u00adrations: Base (unmodi.ed Jikes RVM), Assert (instanceof assertion), \nand AssertDisjoint (instanceof assertion + dis\u00adjointness check). Overall, the geometric mean of the slowdown \nin GC time for Assert is 9.10% and for AssertDisjoint is 11.96%. These overheads are quite low and become \nvanishingly small when computed as a percentage of total execution time, instead of just GC time: the \ngeometric mean of the total execution slowdown for both kinds of assertions is below 1.9%. (The mean \nnumber of garbage collections for these benchmarks is 20.3, with a standard deviation of 25.9.)  5.4 \nRepresentative Example To evaluate the overhead of a real use of DeAL, we sim\u00adulated, with pessimistic \nassumptions, the process by which DeAL would be used to detect a bug in practice. We picked the most \ncomplex of the bugs previously identi.ed in pseu\u00addojbb using heap assertions [1]. The bug consists of \nremov\u00ading Order objects from the orderTable data structure. These orders should then become unreachable \nand be garbage collected. However, the objects are also erroneously refer\u00adenced from Customer objects, \ncausing a memory leak. (The bug .x consists of unlinking Order objects from Customers when they are removed \nfrom the orderTable.) Our assertion checks whether the objects removed from orderTable can be reached. \nThis can be e.ected with a simple variant of the programming pattern of Section 4. Namely, once an object \nis removed from the orderTable we mark it by assigning a special value to one of its .elds. The DeAL \nassertion then becomes just .x . Order : x.field -specialValue. Since the . iteration is over live objects \nand we expect our removed objects to be unreachable, no live object should have the spe\u00adcial value. \nThe bug is hard to detect because Order objects are removed from the orderTable only at rare program \nin\u00adstances. Speci.cally, the orderTable is occasionally com\u00adpletely emptied and then destroyed. Since \nthe programmer might not know how often this happens, we measured the cost of employing DeAL at high \nfrequency: the assertion is evaluated once every 5 times it is encountered. The high fre\u00adquency of assertion \nchecking causes much more frequent GCs than normal program execution without DeAL: the mean of the number \nof GCs (over 20 executions) rises from 2.85 to 12.7, and the total GC cost is 3.37 times higher for the \nversion employing DeAL. However, even this high GC over\u00adhead is hardly noticeable in terms of total program \nexecution time. The slowdown is merely 6.1%: the assertion-checking program runs in 3.87s vs. 3.65s for \nthe original program run\u00adning on an unmodi.ed VM. 6. Related work Our work is related to a wide range \nof techniques, both static and dynamic, for checking properties of data structures. Research in static \nanalysis has yielded a signi.cant body of sophisticated techniques for modeling the heap and an\u00adalyzing \ndata structures at compile-time. The strength of static analysis is that it explores all possible paths \nthrough the program: a sound analysis algorithm can prove the ab\u00adsence of errors, or even verify the \nfull correctness of a data structure implementation. The weakness of static analysis is that many properties, \nparticularly those involving pointers and heap-based structures, are undecidable in principle [15], and \nextremely di.cult to approximate precisely in prac\u00adtice [5, 12, 18, 24]. These problems are particular \nsevere for languages such as Java, which include many hard-to-analyze features such as re.ection, bytecode \nrewriting, and dynamic class loading. Our work is most closely related to several recent tech\u00adniques \nfor dynamically analyzing heap data structures, in\u00adcluding two that check properties at garbage collection \ntime. GC Assertions provides a set of heap assertions that, like DeAL, are checked by the garbage collector \nat runtime [1]. This work di.ers from DeAL in two critical ways. First, it does not provide a full language \nfor heap properties, but rather a .xed set of assertions that cannot be composed. Sec\u00adond, it does not \ncheck assertions at the time they are encoun\u00adtered, but instead defers checking until the next regularly \nscheduled garbage collection. While this choice improves performance, it limits the kinds of heap properties \nto those that can be checked at any time, since they might, for exam\u00adple, be deferred to a point at which \nthey are knowingly but temporarily invalidated.  Figure 4. GC time overhead of our system for end-to-end \nbenchmarks. The QVM system provides a richer set of heap checks, called heap probes, which QVM performs \nusing garbage collector machinery at the point they are requested [3]. The PHALANX system extends on \nQVM to add checks for reachability and dominance [22] while parallelizing heap probe execution. Both \nsystems allow the checking of prop\u00aderties that can require multiple heap traversals to check, signi.cantly \nimpacting performance. The authors explore both sampling (at a user chosen rate) and parallelization \nto control the cost. We believe that DeAL represents a sweet spot between GC Assertions and QVM: unlike \nQVM, DeAL controls overhead by guaranteeing that all properties can be checked in a single heap traversal, \nand by only check\u00ading these properties at or near a regularly scheduled collec\u00adtion; but unlike GC Assertions, \nDeAL o.ers a full asser\u00adtion language and a clearer semantics regarding the timing of checks. The Ditto \nsystem reduces the cost of data structure check\u00ading by incrementalizing the checking code itself [19]. \nThis system provides a signi.cantly di.erent tradeo. than DeAL: it supports arbitrary checks written \nprocedurally in Java it\u00adself, but even with incrementalization incurs a signi.cant overhead (in the range \nof 3X to 10X slowdown). A number of systems developed for data structure re\u00adpair include a method for \ndetecting data structure errors. Al\u00adthough these checking subsystems are not the focus of the work, they \nhighlight the di.culty of detecting such errors. The STARC system uses programmer-written repOk meth\u00adods \nto detect errors, which incur a very substantial overhead (30X) when run frequently, and even a 20% overhead \nwhen run only at the point of failure [8]. Demsky et al. present a technique based on Daikon to detect \nheap invariants and re\u00adpair broken data structures [6]. While the checking overhead is di.cult to evaluate \n(since it is presented in milliseconds), the paper describes it as a rather large overhead. 7. Conclusions \nand Future Work We have presented the DeAL language for assertions that are evaluated in a single traversal \nof live objects, implemented as a variation of a garbage collection traversal. DeAL is a rich language \nthat can express many useful properties as logical combinations of reachability conditions and local \ncomparisons. At the same time, the overhead of DeAL on a program s total execution time remains very \nlow typically well below the 5% level. Our implementation of DeAL is available for public download 5. \nAlthough the current language forms a nicely closed set of features, there are clear directions of interesting \nfuture ex\u00adtensions. One possibility is to extend DeAL from an asser\u00adtion language to a general query \nlanguage that can produce new data structures. The typical way to de.ne a declarative query language \nis by allowing unbound logical variables. For instance, one can imagine a query primitive, used with \n.rst\u00adorder logic formulas. The matching values for unbound vari\u00adables become the tuples returned as the \nresult of the query. For example, one might produce a new Java set containing all positive elements of \na list by writing: Set posval = query(x.val, (x . Node . Rd(x)) . (x.val > 0)); The .rst part, x.val, \nof the above query determines the form of the result as a projection of the matched values, 5 http://www.cs.umass.edu/ \ncreichen/gcassert/index.html while the second contains the formula de.ning the desired x values. Such \na query language is easy to de.ne and can perform useful computation during garbage collection. The chal\u00adlenge, \nhowever, is that querying to produce results that are subsequently used in the Java program means that \nthe query evaluation can no longer be skipped. Thus, garbage collec\u00adtion overhead may need to be incurred \nquite often, mak\u00ading the approach ine.cient. A speci.c danger is that the user will employ the query \nmechanism for properties that can be evaluated much more e.ciently without a traversal of all live objects. \nTherefore, adding querying capabilities to a GC traversal requires careful thought. Either somehow the \nqueries need to be limited to expensive whole-heap properties, or the querying needs to be combined with \nsome mechanism for speculative execution, so that the Java pro\u00adgram can proceed correctly regardless \nof whether or not the query was evaluated. Another interesting possibility is that of allowing arbi\u00adtrary \nJava methods in assertions, as long as the methods al\u00adways terminate and do not have externally observable \nside\u00ade.ects. This property is hard to enforce statically (through language design or static analysis) \nbut can be enforced dy\u00adnamically via resource limits (e.g., sandboxing and time\u00adouts). Such methods will \nbe invoked on every visited ob\u00adject during a GC traversal and can use the values of DeAL s R predicates. \nAt an extreme, one can consider a variant of DeAL where all logical operations (i.e., ., ., boolean con\u00adnectives) \nare not part of the language. Instead, the language just o.ers the ability to call Java methods and have \nJava methods reference R predicates, in a co-routine fashion. In this way, the main ideas of DeAL can \nbe reduced to a mod\u00adi.ed GC traversal that guarantees every object is visited ex\u00adactly once and at visit \ntime the value of reachability predi\u00adcates is fully determined. This is an alternative design that maximizes \nlow-level control and expressiveness of the lan\u00adguage for local computations, yet loses the disciplined \nele\u00adgance of the declarative DeAL design. In all, we consider DeAL to be an excellent ambassador of several \ninteresting ideas and directions that are likely to be important in future research. These include, of \ncourse, DeAL s hallmark property of single-traversal computations, but also the smooth integration of \ndeclarative, logic-based, resource bounded languages in a general-purpose program\u00adming language. We believe \nthat the DeAL design will be multiply in.uential in such endeavors. Acknowledgments This work was funded \nby the NSF (CCF-0917774, CCF-0934631, CCF-0541018, CCF\u00ad0830174, CCF-0916810, and IIS-0915071) and by \nLog\u00adicBlox Inc. References [1] E. E. Aftandilian and S. Z. Guyer. GC assertions: using the garbage collector \nto check heap properties. In PLDI 09: Pro\u00ad ceedings of the 2009 ACM SIGPLAN conference on Program\u00adming \nlanguage design and implementation, pages 235 244, New York, NY, USA, 2009. ACM. [2] M. Arnold, S. Fink, \nD. Grove, M. Hind, and P. F. Sweeney. Adaptive optimization in the Jalape In OOPSLA no JVM. 00: Proceedings \nof the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and appli\u00adcations, \npages 47 65, New York, NY, USA, 2000. ACM. [3] M. Arnold, M. Vechev, and E. Yahav. QVM: an e.cient run\u00adtime \nfor detecting defects in deployed systems. In OOPSLA 08: Proceedings of the 23rd ACM SIGPLAN conference \non Object-oriented programming systems languages and appli\u00adcations, pages 143 162, New York, NY, USA, \n2008. ACM. [4] S. M. Blackburn, R. Garner, C. Ho.man, A. M. Khan, K. S. McKinley, R. Bentzur, A. Diwan, \nD. Feinberg, D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump, H. Lee, J. E. B. Moss, A. Phansalkar, \nD. Stefanovi\u00b4 c, T. VanDrunen, D. von Dincklage, and B. Wiedermann. The DaCapo benchmarks: Java benchmarking \ndevelopment and analysis. In OOPSLA 06: Proceedings of the 21st annual ACM SIGPLAN confer\u00adence on Object-Oriented \nPrograming, Systems, Languages, and Applications, pages 169 190, New York, NY, USA, Oct. 2006. ACM Press. \n[5] P. T. Darga and C. Boyapati. E.cient software model check\u00ading of data structure properties. In ACM \nConference on Object-Oriented Programming Systems, Languages, and Ap\u00adplications, pages 363 382, 2006. \n[6] B. Demsky, M. D. Ernst, P. J. Guo, S. McCamant, J. H. Perkins, and M. Rinard. Inference and enforcement \nof data structure consistency speci.cations. In ISSTA 06: Proceed\u00adings of the 2006 international symposium \non Software test\u00ading and analysis, pages 233 244, New York, NY, USA, 2006. ACM. [7] B. Elkarablieh, I. \nGarcia, Y. L. Suen, and S. Khurshid. Assertion-based repair of complex data structures. In ASE 07: Proceedings \nof the twenty-second IEEE/ACM interna\u00adtional conference on Automated software engineering, pages 64 73, \nNew York, NY, USA, 2007. ACM. [8] B. Elkarablieh, S. Khurshid, D. Vu, and K. S. McKinley. STARC: Static \nanalysis for e.cient repair of complex data. In ACM Conference on Object-Oriented Programming Systems, \nLanguages, and Applications, pages 387 404, 2007. [9] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. \nNelson, J. B. Saxe, and R. Stata. Extended static checking for Java. In Proc. ACM SIGPLAN Conference \non Programming Language Design and Implementation (PLDI), pages 234 245. ACM, June 2002. [10] N. Immerman. \nDescriptive Complexity. Springer, 1998. [11] D. Jackson. Object models as heap invariants. Programming \nmethodology, pages 247 268, 2003. [12] S. McPeak and G. Necula. Data structure speci.cations via local \nequality axioms. In Computer Aided Veri.cation, pages 476 490, 2005. [13] B. Meyer. Object-Oriented Software \nConstruction. Prentice Hall PTR, 2nd edition, 1997. [14] T. Mytkowicz, A. Diwan, M. Hauswirth, and P. \nF. Sweeney. Producing wrong data without doing anything obviously wrong! In ASPLOS 09: Proceeding of \nthe 14th interna\u00adtional conference on Architectural support for programming languages and operating systems, \npages 265 276, New York, NY, USA, 2009. ACM. [15] G. Ramalingam. The undecidability of aliasing. ACM \nTransactions on Programming Languages and Systems, 16(5):1467 1471, 1994. [16] D. Rayside and L. Mendel. \nObject ownership pro.ling: a technique for .nding and .xing memory leaks. In ASE 07: Proceedings of the \ntwenty-second IEEE/ACM international conference on Automated software engineering, pages 194 203, New \nYork, NY, USA, 2007. ACM. [17] D. Reimer, E. Schonberg, K. Srinivas, H. Srinivasan, J. Dolby, A. Kershenbaum, \nand L. Koved. Validating structural proper\u00adties of nested objects. In OOPSLA 04: Companion to the 19th \nannual ACM SIGPLAN conference on Object-oriented pro\u00adgramming systems, languages, and applications, pages \n294 304, New York, NY, USA, 2004. ACM. [18] M. Sagiv, T. Reps, and R. Wilhelm. Parametric shape analysis \nvia 3-valued logic. In ACM Symposium on the Principles of Programming Languages, pages 105 118, 1999. \n [19] A. Shankar and R. Bod\u00b4ik. DITTO: automatic incrementaliza\u00adtion of data structure invariant checks \n(in Java). In PLDI 07: Proceedings of the 2007 ACM SIGPLAN conference on Pro\u00adgramming language design \nand implementation, pages 310 319, New York, NY, USA, 2007. ACM. [20] Standard Performance Evaluation \nCorporation. SPECjvm98 Documentation, release 1.03 edition, 1999. [21] Standard Performance Evaluation \nCorporation. SPECjbb2000 Documentation, release 1.01 edition, 2001. [22] M. Vechev, E. Yahav, G. Yorsh, \nand B. Bloom. PHALANX: Parallel Checking of Expressive Heap Assertions. In ACM International Symposium \non Memory Management, 2010. [23] P. R. Wilson. Uniprocessor Garbage Collection Techniques. In Y. Bekkers \nand J. Cohen, editors, ACM International Work\u00adshop on Memory Management, number 637 in Lecture Notes \nin Computer Science, pages 1 42, St. Malo, France, Sept. 1992. Springer-Verlag. [24] K. Zee, V. Kuncak, \nand M. Rinard. Full functional veri.cation of linked data structures. In ACM Conference on Program\u00adming \nLanguages Design and Implementation, pages 349 361, 2008.   \n\t\t\t", "proc_id": "1869459", "abstract": "<p>We present the DeAL language for heap assertions that are efficiently evaluated during garbage collection time. DeAL is a rich, declarative, logic-based language whose programs are guaranteed to be executable with good whole-heap locality, i.e., within a single traversal over every live object on the heap and a finite neighborhood around each object. As a result, evaluating DeAL programs incurs negligible cost: for simple assertion checking at each garbage collection, the end-to-end execution slowdown is below 2%. DeAL is integrated into Java as a VM extension and we demonstrate its efficiency and expressiveness with several applications and properties from the past literature.</p> <p>Compared to past systems for heap assertions, DeAL is distinguished by its very attractive expressiveness/efficiency tradeoff: it o ers a significantly richer class of assertions than what past systems could check with a single traversal. Conversely, past systems that can express the same (or more) complex assertions as DeAL do so only by su ering orders-of-magnitude higher costs.</p>", "authors": [{"name": "Christoph Reichenbach", "author_profile_id": "81361606792", "affiliation": "University of Massachusetts, Amherst, MA, USA", "person_id": "P2354055", "email_address": "", "orcid_id": ""}, {"name": "Neil Immerman", "author_profile_id": "81408601113", "affiliation": "University of Massachusetts, Amherst, MA, USA", "person_id": "P2354056", "email_address": "", "orcid_id": ""}, {"name": "Yannis Smaragdakis", "author_profile_id": "81100614708", "affiliation": "University of Massachusetts, Amherst, MA, USA", "person_id": "P2354057", "email_address": "", "orcid_id": ""}, {"name": "Edward E. Aftandilian", "author_profile_id": "81350584830", "affiliation": "Tufts University, Medford, MA, USA", "person_id": "P2354058", "email_address": "", "orcid_id": ""}, {"name": "Samuel Z. Guyer", "author_profile_id": "81332502517", "affiliation": "Tufts University, Medford, MA, USA", "person_id": "P2354059", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869482", "year": "2010", "article_id": "1869482", "conference": "OOPSLA", "title": "What can the GC compute efficiently?: a language for heap assertions at GC time", "url": "http://dl.acm.org/citation.cfm?id=1869482"}