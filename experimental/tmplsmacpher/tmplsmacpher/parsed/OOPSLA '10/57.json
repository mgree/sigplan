{"article_publication_date": "10-17-2010", "fulltext": "\n Managing Ambiguity in Programming by Finding Unambiguous Examples Kenneth C. Arnold Henry Lieberman \nMIT Media Lab, MIT Mind Machine Project 20 Ames Street, Cambridge, MA 02139 USA {kcarnold, lieber}@media.mit.edu \nAbstract We propose a new way to raise the level of discourse in the programming process: permit ambiguity, \nbut manage it by linking it to unambiguous examples. This allows program\u00adming environments to work with \ninformal descriptions that lack precise semantics, such as natural language descriptions or conceptual \ndiagrams, without requiring programmers to formulate their ideas in a formal language .rst. As an ex\u00adample \nof this idea, we present Zones, a code search and reuse interface that connects code with ambiguous natural \nlanguage statements about its purpose. The backend, called ProcedureSpace, relates purpose statements, \nstatic code anal\u00adysis features, and natural language background knowledge. ProcedureSpace can search \nfor code given statements of pur\u00adpose or vice versa, and can .nd code that was never annotated or commented. \nSince completed Zones searches become an\u00adnotations, system coverage grows with user interaction. Users \nin a preliminary study found that reasoning jointly over natu\u00adral language and programming language helped \nthem reuse code. Categories and Subject Descriptors H.5.2 [Information In\u00adterfaces and Presentation]: \nUser Interfaces Natural lan\u00adguage; D.2.3 [Software Engineering]: Coding Tools and Techniques General \nTerms Design, Human Factors Keywords ambiguity, Blending, common sense, informal representation, natural \nlanguage, reuse 1. Introduction The process of authoring a program can be described as going from ambiguous \nand informal representations about purpose Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. Onward! 2010, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright \nc &#38;#169; 2010 ACM 978-1-4503-0236-4/10/10. . . $10.00 and approach (mostly contained in the minds \nof program\u00admers) to unambiguous, highly structured representations of instructions (mostly contained \nin computers). Code reading involves the reverse process: relating structured representa\u00adtions to general \nideas about what the program does and how. Current development environments provide great assistance \nwhen working with formal representations, through intelli\u00adgent completion, refactoring, and debuggers, \nfor example. But relating formal representations that computers can use with informal representations \nthat programmers can use remains, for the most part, the sole responsibility of the programmer. Perhaps \nthe scarcity of tools for working with informal representations is in part because informal representations \nare ambiguous. Since the end products of programming should be as unambiguous as possible, many programming \nresearchers have been understandably averse to allowing ambiguity even in high-level speci.cations. However, \nwe suggest that this aversion may be unhelpful because it tends to force program\u00admers to prematurely \ncommit to some particular and precise way of thinking before they can dialogue with computers about their \nprograms [Green 1989]. Instead, we suggest that programming environments could permit programmers to \ndescribe the desired program in more natural and informal terms, even if the terms themselves or the \nrelations between them are ambiguous, then assist the programmer in the task of concretizing the structure \nand content of the program into an unambiguous executable form. 2. Frontend: Zones In this paper, we \npresent one initial example of a system that can work with informal representations of software. Our \nin\u00adterface, called Zones, uses informal statements of the general purpose of code fragments to help programmers \n.nd and share reusable code. A Zone is an active association between a code fragment and a brief natural \nlanguage statement of its purpose What s this for? not unlike a comment. Pro\u00adgrammers can describe the \npurpose however they think about it; the statement need not be precise, comprehensive, or even grammatical. \nBy only giving one line, the Zones interface encourages purpose statements to be short. Figure 1 shows \nFigure 1. A Zone (black rectangle with .ag) associates a fragment of Scratch code with a statement of \nits purpose. The top-left button invokes the search sidebar.   Figure 2. Given a purpose statement, \nthe Zone sidebar (left) shows code that might ful.ll it. Selecting an implementation from the list on \nthe left shows its code on the right. As a simulation of future functionality, red boxes surround values \nthat vary among otherwise similar code, highlighting what might need to be changed. Figure 3. The Zone \nsidebar can suggest possible purpose statements for a code fragment (simulated for this illustra\u00adtion). \nan example where a programmer has used a Zone to annotate a short fragment of Scratch code. Other purpose \nstatements from our users, who were developing video games, include stay on path and Bounce ball around \nroom. Omitting either the purpose statement or the code turns annotation into search. If you provide \nan English statement of purpose and click the search button, the system searches for code that accomplishes \nthat purpose (see Figure 2). Alternatively, you can mark some code and then search, which means: .nd \nhow other people have generally described the purpose of code like this (see Figure 3). The search results \nare presented as a .oating sidebar. The code for selected results appears within the Zone. You can then \nimmediately try running the program with the transplanted code, make modi.cations .rst, or simply scroll \nthrough the results to get a general sense of different approaches to your task. Selecting the zeroth \nresult returns to whatever code was in the Zone before, if any. A second click on the search button collapses \nthe sidebar, leaving behind only the code and the search query, which then functions as an annotation, \nusing exactly the language you chose when looking for the code to begin with. In this way, search queries \nseamlessly become annotations; though the code may require further tweaking, the annotation remains unless \nthe programmer explicitly removes it. When the project is shared, that pair of annotation and code fragment \nis added to the database, either as new information or as a new explanation for existing code. Or, if \nin fact none of the search results were relevant (likely because the corpus of annotations is still small), \ncode built within the bounds of that annotation becomes the .rst example of how to do that. The next \nprogrammer to look for related code fragments or purposes will bene.t from the added annotated code. \nIt could be said that by capturing both successful and unsuccessful search interactions, Zones learns \nhow programmers describe purpose. 2.1 Scratch Programming Envorinment While informal software representations \nare applicable to a broad variety of programming scenarios, we focus in this paper on novice programmers. \nOur environment for these experiments is Scratch, a graphical programming language and development environment \ndesigned for use primarily by children and teens, ages 8 to 16 [Resnick et al. 2003]. Scratch programming \nlanguage components are represented by blocks that .t together like puzzle pieces to form expres\u00adsions; \nstacking code blocks vertically causes them to execute in sequence. Scratch code is mostly comprised \nof concrete instructions that cause sprites to move around a stage, change their appearance, play sounds, \nor manipulate a pen, in re\u00adsponse to various events, including user input and named messages from other \nsprites. The language includes control .ow statements, Boolean and mathematical expressions, and sprite-or \nproject-scoped variables. Though the detailed tech\u00adniques of this paper are somewhat tailored to Scratch, \nthe general approach should be adaptable to other languages. One main reason we chose to use Scratch \nfor these initial experiments is the ready availability of a large quantity of potentially reusable code \nfragments. Scratch projects all have the same general structure, and project context has a limited effect \non the behavior of individual lines of code, so Scratch code tends to be more reusable a priori, despite \nthe general lack of software engineering discipline in the programmer community. Also, while the language \nlacks procedures or functions in the traditional sense, the event handler design makes concurrent modularity \nidiomatic and greatly simpli.es task coordination, which tends to make a large amount of code reusable \nwithout signi.cant modi.cation. The Scratch website [Monroy-Hern\u00b4 andez and Resnick 2008] hosts over \n300,000 projects, many already reusing code from other projects, all shared under a free software license. \nA quality\u00ad.ltered sample of 6376 projects was used as the corpus for these experiments. Many of these \nprojects are simple video games, so that domain will .gure strongly in our examples.  2.2 Other Types \nof Interactions with Informal Software Representations The purpose-driven code reuse of Zones is one \nof many ways that a development environment capable of working with informal software representations \ncould help programmers. For example, a subgoal may be inferred from a higher-level goal and the code \nwritten so far by making analogies to the subgoals of other similar projects. Similar techniques could \napply to other artifacts as well: for example, a goal could map both to code and to behavioral tests \nthat partially evaluate whether code accomplishes that purpose. Each represent part of the concrete speci.cation \nof what it means for the code to satisfy the given goal. Second, insomuch as failed test cases or other \nbugs indi\u00adcate a failure of the concrete code to satisfy the programmer s goal, we can also think of \ndebugging in the context of infor\u00admal representations. For instance, we could collect examples of solutions \nto particular problems in particular situations, then analyze and generalize them to learn what problems \nmight come up in a certain situation and what types of code changes tend to .x them. The result would \nenable debug\u00adging by making analogies to problem-solving strategies or concrete .xes that were helpful \nin similar situations. Finally, the programming environment could help the programmer document and distribute \nthe result in a way that permits others to understand and utilize it. An informal survey of open-source \ncode repositories suggests that a large amount of code has similar goals and subgoals, but it was not \nreused, due perhaps to differences in environment, constraints, or libraries, or simply being unable \nor unwilling to .nd and incorporate that other code. A development environment that can recognize the \nsimilarity of the programmer s intent to code already written, especially before the programmer has committed \nto a structured encoding of the task at hand, might encourage and facilitate code reuse. And by additionally \ncapturing the process of re.nement of high-level goals and maintaining links between the subgoal tree \nand the code, the development environment would be better equipped to help the programmer adapt that \ncode to different scenarios or environments, even those that may come up at runtime. 3. Backend: ProcedureSpace \nThe Zones interface presents a unique set of requirements for its backend, called ProcedureSpace. Purpose \nstatements could be treated as code search queries, but they would in\u00adclude abstract characteristics \nthat would not match a keyword in an identi.er, type, or comment (if present). And though we assume that \nsome code fragments in the corpus have been annotated with one or more purpose statements, those annota\u00adtions \noften differ in word choice and level of detail from the purpose statement that is queried for, and few \ncode fragments are annotated. Finally, Zones searches may also go in reverse: from code to possible purpose \nstatements. These challenges preclude a straightforward or even multi\u00adstage information retrieval approach. \nAnd since we allow purpose statements to be informal and ambiguous, formal rea\u00adsoning techniques are \nparticularly ill-suited. ProcedureSpace approaches this challenge with an unconventional technique: it \nuses the sparse and imprecise relationships between sev\u00aderal different kinds of information to place \nthem all in the same vector space (hence the name), where search queries be\u00adcome simple vector operations. \nThis technique, called Blend\u00ading [Havasi et al. 2009], is similar to standard information retrieval techniques, \nbut uniquely illustrates a simple way of using multiple types of imprecise data together. The result \nis a representation that uni.es syntactic knowledge about programs with semantic knowledge about goals. \nBroadly speaking, ProcedureSpace aims to relate incom\u00adplete knowledge about two types of entities: purpose \nstate\u00adments and code fragments. Purpose statements are handled with simple natural language processing \ntechniques; code fragments are represented by characteristics from static anal\u00adysis. The knowledge about \npurpose statements is incomplete both because they are themselves ambiguous and because the system s \nunderstanding of natural language is limited. And knowledge about code fragments is incomplete in that \nit is generally not known what characteristics of the code are relevant to accomplishing the goal and \nwhat parts are merely implementation details. However, associations between code fragments and purpose \nstatements disambiguate each other: ProcedureSpace, in effect, learns about purpose statements from the \ncode they describe, and learns about code by study\u00ading how people describe its purpose. ProcedureSpace \naddi\u00adtionally uses semantic background knowledge about English words and phrases to help understand the \nnatural language statements. Figure 4 shows an overview of ProcedureSpace s reason\u00ading: it understands \nwords like follow and chase by re\u00adlating them to commonsense background knowledge (such as follow is \na kind of movement ), examples of code that people have said causes something to chase something else, \nand characteristics of the structure of that code. This paper does not seek to establish that these particular \nkinds of data are necessary and suf.cient for a natural language code reuse system, but rather to show \nhow to relate these disparate kinds of data. 4. ProcedureSpace Implementation ProcedureSpace uses the \nBlending technique of [Havasi et al. 2009] to relate English words and phrases, English purpose statements, \ncode, structural characteristics of that code, and background knowledge ( features ) about words. Blending \nworks by constructing a matrix containing aligned data of several types, then using an approximate matrix \nfactorization to represent each element (e.g., a code fragment or a purpose statement) as a vector. Relating \nelements to each other then reduces to simple vector operations, even for elements of Figure 5. A simpli.ed \ndiagram of the ProcedureSpace anal\u00adysis matrix, illustrating how purpose annotations bridge code static \nanalysis with natural language background knowledge.   different types. Figure 5 shows a simpli.ed \ndiagram of the matrix, illustrating how purpose annotations bridge code static analysis with natural-language \nbackground knowledge. This section describes how each sub-matrix is constructed, then shows how to combine \nthem to enable the queries that the Zones front-end requires. 4.1 Code Static Analysis While many advanced \ntechniques have been developed for static source code analysis, ProcedureSpace uses a deliber\u00adately simpli.ed \napproach, focusing instead on combining static code analysis with natural language. The result will be \nakin to a quick glance at the code, rather than an in-depth study. The basic goal of the code analysis \nis similarity detec\u00adtion: two annotations might be similar if the code fragments they apply to are similar. \nFor example, many different exam\u00adples of code that handles gravity (or falling ) all include a movement \ncommand conditioned on touching a color in the sky (or not touching a color on the ground). In other \nlan\u00adguages, such features could also include constraints about types (e.g., returns an integer ) or interactions \n(e.g., uses synchronization primitives ). In extracting structural features, ProcedureSpace treats the \ncode as a simpli.ed syntax tree. For each code fragment, ProcedureSpace extracts various types of simple \nstructural (FlagHat (doForever (pointTowards: hero ) (forward: 1))) (b) internal S-expression for\u00ad (a) \nas presented in the mat Scratch UI Figure 6. Example chase code fragment, taken from the Scratch project \nEnemy AI tutorial: Chase. Child doForever > pointTowards_ Containment FlagHat doForever Containment FlagHat \npointTowards_ Sibling forward_ ~ pointTowards_ Clump [forward_ pointTowards_] Presence pointTowards_ \n Table 1. Selected structural features for the example code fragment features about what kinds of code \nelements are present and how they are related: Presence A particular code element is present somewhere \nin the fragment Child A code element is the direct child of another code ele\u00adment, either as a parameter \nor as the body of a conditional or looping construct Containment A code element is contained within another \ncode element (generalizes Child ) Clump A clump of code elements occur in sequence Sibling A particular \ncode element is the sibling (ignoring order) of another code element Within these feature types, it is \nnot necessary to enumerate all possible features beforehand. Rather, for each feature type, an extraction \nroutine generates all the features of its type that apply to a particular code fragment. Consider the \ncode fragment in Figure 6, which makes a sprite chase or follow another sprite. Table 1 shows examples \nof the code structural features extracted for the example code. We construct a matrix CS that relates \ncode fragments to the structural features they contain. The rows of CS are the 14145 distinct code structure \nfeatures that were extracted; the columns are the 127473 analyzed code fragments. (The order of the rows \nand columns does not matter for this kind of analysis.) An entry CS(feature, fragment) is 1 if fragment \nhas feature, 0 otherwise. To keep long code fragments with large numbers of features from having a disproportionate \neffect, we normalize all code fragments to have unit Euclidean norm. Figure 7 shows a sample of the .nal \nmatrix CS.  CS = \u00b7\u00b7\u00b7 Clump [forward_ pointTowards_] Presence EventHatMorph . . . 0.27 0.27 \u00b7 \u00b7 \u00b7 0.11 \n0 \u00b7 \u00b7 \u00b7 . . . . . . . . . Figure 7. A sample of the code static analysis matrix CS  4.2 Annotations \nEach Zone is an annotation that links a code fragment with a statement of purpose. These annotations \nare collected into a matrix: AD(purpose, fragment) counts the number of times that fragment was annotated \nwith purpose. The purposes are actually stored as (Purpose, purpose) tuples to distinguish complete annotations \nfrom words that will later be extracted from them. The initial annotations were entered by one of the \nauthors. In various types of interactions with users, including the user study, other annotations were \ncontributed, for a total of 100 annotations at the time of these experiments. The matrix AD only accounts \nfor purpose statements that are equivalent with respect to string equality. To allow inexact matches \nof annotations and search queries, we construct a ma\u00adtrix AW that relates code fragments with words and \nphrases extracted from their purpose statements using standard natu\u00adral language processing techniques \n(e.g., lemmatization and stopword removal). Since similar annotations yield similar words and phrases, \nthey will be counted as more associated. To account for the sparsity of annotations and comments, ProcedureSpace \nalso extracts tokens from identi.ers: names of variables and events (analogous to function or method \nnames). Token extraction additionally includings splitting underscore joined and camelCased strings. \nEach element of the resulting word-code matrix, WC(token, fragment), counts the number of occurrences \nof token in fragment.. 4.3 Background Knowledge When people choose entirely different words to describe \ntheir goals (and in user studies we found they often do), most search systems would be left with no relevant \nresults. But ProcedureSpace incorporates background knowledge about how words relate. One kind of knowledge \nis knowledge speci.c to the target domain. For Scratch, many projects are games, so helpful domain-speci.c \nknowledge includes facts such as arrow keys are used for moving and moving changes position. Such knowledge \nwould enable us to relate an annotation about arrow keys with an annotation about position, for example. \nThe matrix DS encodes a small, manually entered knowledgebase about simple games. Another kind of knowledge \nis general world knowledge, such as balls can bounce and stories have a beginning. Without such knowledge, \nthe system may be entirely un\u00adaware that an annotation of bounce may be relevant to .nd code for moving \nthe ball. ConceptNet [Speer et al. 2008] provides a large database of broad intuitive world knowledge, \nexpressed in a semantic network representation (e.g., ball\\CapableOf/bounce). Rarely is a single Concept-Net \nrelation a critical link in connecting two concepts; rather, the broad patterns in ConceptNet, such as \nwhich features typically apply to things that people desire or can do, help to indicate how English concepts \nare similar to each other. Though many other lexical resources are available, Concept-Net uniquely provides \na broad coverage of goals and actions, in a plain-language form that is amenable to imprecise rea\u00adsoning \nand usage in a user interface. 4.3.1 Matrix Encoding Both ConceptNet and the domain-speci.c knowledge \nbase are expressed as triples: concept1\\relation/concept2. To form a matrix out of these triple representations, \nwe use the approach of [Speer et al. 2008]: for each triple, incre\u00adment both (concept1, \\relation/concept2) \nand (con\u00adcept2, concept1\\relation/ ) The columns of this matrix are called features. The double-encoding \nmeans that arrow keys\\UsedFor/moving, for example, contributes knowledge about both arrow keys and move. \nFor ConceptNet, con\u00adnections that the community rated more highly are given greater weight; for the domain-speci.c \nknowledge, all entries are weighted equally.  4.4 Blending Given the six matrices of relationships, \nwe then combine them using Blending. To apply the Blending technique to a set of matrices Di, align the \nlabels (.lling in zeros for missing entries), then add the matrices together: A =aiDi i where ai is \na weighting factor that is adjusted to maximize the interaction between the datasets. (For these experiments \nthe weighting factors were set manually, though [Havasi et al. 2009] presents an automated technique.) \nThen compute the Singular Value Decomposition (SVD), truncating to k singular values: A UkSkV T k The \nmatrices Uk and Vk represent each row and column of A as a vector giving its position along the k axes \nthat represent the highest-variance dimensions of the data. The entries along the diagonal of S weight \neach axis, roughly indicating its importance in describing the patterns of relationships among the items \nof the matrix. An important parameter for the Blending technique is the layout of the data matrices, \nsince that determines which elements overlap and thus how they can be related. CS relates code fragments \nto code structural features, while background knowledge relates English concepts to English features. \nThe Figure 8. Layout of the ProcedureSpace matrix in detail, showing the origin of each element  annotations \nlink the two disparate domains by relating code fragments to English concepts. Figure 8 details the layout \nof the ProcedureSpace matrix, showing where each entry in the matrix comes from. Effectively, the purpose \nannotations bridge the structural features derived from static analysis with the natural language background \nknowledge in ConceptNet.  4.5 Goal-Oriented Search Once we have used Blending to construct ProcedureSpace, \nthe search tasks required to power the Zones interface become straightforward vector operations. Each \nentity is a vector in the k-dimensional vector space: the U matrix gives the posi\u00adtion of each English \nword, purpose phrase, code feature; the V matrix locates code fragments and English features. Since that \nall entities are in the same vector space, search operations can be expressed as .nding vectors with \nhigh inner products. To .nd the vector pp of a purpose statement composed of En\u00adglish words wi, you simply \nsum the corresponding vectors: n pp = U [wi, :] i=0 where the : notation indicates a slice of an entire \nrow. Then to .nd how well that statement may apply to a particular code fragment, you take the dot product \nof pp and that code fragment s vector (given by its row in V ). In general, the weights for all code \nfragments are given by V pp, considering only rows of V that correspond to code fragments. The code fragments \nwith the highest values are returned as the annotation search results, after .ltering to remove code \nfragments that differ only in the values of constants. Likewise, to .nd possible annotations for a code \nfragment, you extract its structural features fi, form a vector pq = (a) gravity (b) follow player Figure \n9. Sample search results n U [fi, :], and .nd the words or annotations whose i=0 vectors have the highest \ndot product with pq. Or, to .nd which part of a given project performs a certain function, you compare \nthe ProcedureSpace vector for the purpose statement with the code fragments in that project.  4.6 Search \nResults Users of our system searched for a variety of goals and ex\u00adpressed them in a variety of ways. \nFigure 9 shows selected results for some queries that users performed. The .rst search, gravity, exactly \nmatched the annotation of a code fragment, so it was returned as a search result. This result illustrates \nthat indirect reasoning through code structure and natural lan\u00adguage background knowledge rarely disturbs \nexact matches. For follow player, neither of the two results were exact annotation matches. The example \ncode from Figure 6 was an\u00adnotated follow , but the .rst result is one that matches both those code features \nand the word follow. The second match is very interesting because it inexactly matches at least two different \nkinds of data. The only common code structure is the presence of pointTowards:, which evidently Procedure-Space \nfound to be associated with the behavior of follow\u00ading. But many code fragments contain pointTowards:; \nev\u00adidently this one was chosen because it also contained the word chase. Using a combination of common \nannotation data and background knowledge, ProcedureSpace related follow (the query word) and chase, and \nused this relationship to .nd a code fragment that is very different than what was annotated but nonetheless \nrelevant. 5. Preliminary User Experience Searching by goal is a really different way of programming, \nsaid one participant in our preliminary user study. We sought to understand whether the Zones interface \n(both concept and implementation) helps programmers make and use connec\u00adtions between natural language \nand programming language. All participants in our two-task user study successfully used the Zones interface \nto .nd code that they could use in their project, and annotated both new and existing code in a variety \nof ways. We were surprised by the number of different ways that people learned from their interactions \nwith Zones. After a sample task to familiarize the users with inter\u00adacting with the Zones interface, \nthey were presented with a project containing many sprites, each exhibiting some read\u00adily observable \nbehavior, and were instructed to duplicate the behavior of one or two sprites, using Zones if they wanted. \nThey were not given cues for how to describe that behavior so that their queries would be as natural \nas possible. All partici\u00adpants were able to successfully imitate at least one behavior with the help \nof reused code from Zones. Finally, all partici\u00adpants left Zone searches as new annotations, validating \nour search-as-annotation paradigm.  Though participants reused some code exactly, much more frequently \nthe code fragments would guide their thinking or point out Scratch functionality that they could use. \nOne participant saw a glide (timed movement) command in a search result, and exclaimed: Oh, it could \nbe gliding. . . I forgot [about] the glide function. We were surprised by the number of different ways \nthat people learned from their interactions with Zones. One novice programmer corrected a .aw in his \nunderstanding of code while studying the search results for the annotation he was about to give it. A \nmore experienced participant reported that the Zones interface encouraged her to think from a higher-level \nperspective. Frequently, participants appreciated learning something from seeing another person s code, \neven if their goals were different or their understanding incomplete. 6. Related Work 6.1 Code Search \nSystems Code search systems can be distinguished by how program\u00admers can query them. [Reiss 2009] includes \na good survey of code search techniques, including formal speci.cations, type systems, design patterns, \nkeywords, ontologies, tagging, and test cases. However, these code search systems have limited ability \nto reason about purposes that can be accomplished in a variety of ways, and their understanding of natural \nlan\u00adguage is limited at best. ProcedureSpace uses annotations to reason about purposes and leverages \nboth general and domain-speci.c natural language background knowledge. A task switch away from development \nto even a good search engine can be distracting. [Fry 1997] and [Ye 2001] introduce the paradigm of reuse \nwithin development, linking code search into the IDE based on both comment keywords and function signatures. \nMany systems are now integrated; a state-of-the-art example is Blueprint [Brandt et al. 2009]. Search-oriented \nsystems like CodeBroker and Blueprint only directly bene.t consumers of reusable software; users still \nhave to publish their completed code manually. Zones makes it natural to share adapted or newly written \ncode. 6.2 Programming in Natural Language Natural language has often been seen as desirable as a high\u00adlevel \nspeci.cation or programming language because it is a natural medium for communicating goals and ideas \nwith a human collaborator. Various attempts have been made to interpret natural language as computer \ninstructions directly, from COBOL to SQL to several modern attempts, including Pegasus [Kn\u00a8 oll and Mezini \n2006]. However, since programs must execute unambiguously, many previous attempts at nat\u00adural language \nprogramming have required the use of unnat\u00adurally precise wording. Natural language representations of \nprogram present many challenges, but we think that manag\u00ading ambiguity is a core challenge that has not \nyet received suf.cient attention. Several projects have informed our thinking in this regard. Keyword \nProgramming [Little and Miller 2007] matches key\u00adwords to commands and types in a function library. It \nis a useful tool for managing ambiguity on a low level: when a programmer knows what keywords should \nappear in a line of code but not exactly how to form that line of code, the Key\u00adword Programming system \ncan use search and type chaining techniques to disambiguate the keyword representation of that line of \ncode. However, the programmer s thinking must al\u00adready be precise enough to know almost exactly what \nshould happen at each line. Metafor [Liu and Lieberman 2005] and its successor MOOIDE [Lieberman and \nAhmad 2010] use sentence structure and mixed-initiative discourse to under\u00adstand compound descriptions. \nMOOIDE further showed that general background world knowledge helps to understand natural language input. \nProcedureSpace opens the possibil\u00adity for these natural-language programming systems to scale by learning \nboth statically from a corpus of code and dy\u00adnamically through the Zones user interface. While Zones \ncurrently does not use a natural language dialog paradigm, it could be very helpful for interactions \nwhere relating informal representations to code requires more than a single step.  6.3 Formal Speci.cations \nThere has been a lot of work in software engineering on the idea of formal speci.cations of code [Diller \n1990; Hierons et al. 2009]. This body of work shares with us the idea of having some representation of \nthe purpose of code at a higher, declarative level, that is independent from the code itself. It also \nhas the ambition to provide algorithmic help to the programmer in assuring that the code meets the speci.cation, \nor at least drawing the programmer s attention to discrepancies between the two representations. But \nformal speci.cations are expressed in a mathematical language that most programmers .nd dif.cult to write. \nSuch languages are also entirely unsuitable for beginning programmers, which are our target user community \nhere. Our aim is not to assure the code does what the speci.\u00adcations say, but to give the programmer \naccess to a body of alternative implementations of the speci.cations, and also the novel capability of \nreasoning backward from the code to speci.cations. By allowing programmers to express what may indeed \nbe informal speci.cations in natural language, we hope to improve the accessibility of speci.cations \nas a programming methodology. Logical reasoning systems used by formal speci.cation tools have the advantage \nthat they provide mathematical assurance of the validity of implementations. The downside is that their \nreasoning is not applicable to many practical programming problems. The approximate inference used by \nour system trades guarantees of correctness for the ability to make plausible inferences ef.ciently across \na wide variety of programming situations.  7. Conclusion We suggest that programming environments should \nbe able to help programmers work with the informal representations that are a natural part of the programming \nprocess. One particular dif.culty in working with informal representations of software is that they can \nbe ambiguous. We suggest that given today s large-scale code repositories, programming environments can, \ninstead of shunning ambiguity, manage it by relating ambiguous statements to concrete examples. We illustrate \nour suggestions with a prototype purpose\u00adoriented code reuse system. Its frontend, called Zones, demon\u00adstrates \nan integrated interface for connecting natural language with Scratch code fragments to make comments \nthat help pro\u00adgrammers .nd and share code. The ProcedureSpace backend demonstrates important concepts \nin how to relate ambigu\u00adous and unambiguous representations as it reasons jointly over static code analysis, \nZones annotations, and background knowledge to .nd relationships between code and the words people use \nto describe what it does. Marvin Minsky said, If you understand something in only one way, you don t \nunderstand it at all. We believe that when computers can work with programs both in natural language \ndescriptions and in code, they can come closer to really understanding what we want them to do. Acknowledgments \nWe thank Andr\u00b4andez and Rita Chen for pro\u00ad es Monroy-Hern\u00b4viding the parsed Scratch projects, Rob Speer \nand Catherine Havasi for helping with the Blending technique, and all our user study participants for \ntheir valuable input. References J. Brandt, M. Dontcheva, M. Weskamp, and S. R. Klemmer. Example-centric \nprogramming: Integrating web search into the development environment. Technical report, CSTR-2009-01, \n2009. A. Diller. Z: An Introduction to Formal Methods. John Wiley &#38; Sons, Inc., New York, NY, USA, \n1990. ISBN 047192489X. C. Fry. Programming on an already full brain. Com\u00admun. ACM, 40(4):55 64, 1997. \nISSN 0001-0782. doi: http://doi.acm.org/10.1145/248448.248459. T. R. G. Green. Cognitive dimensions of \nnotations. In Proceedings of the .fth conference of the British Computer Society, Human-Computer Interaction \nSpecialist Group on People and computers V, pages 443 460, New York, NY, USA, 1989. Cambridge University \nPress. ISBN 0-521-38430-3. C. Havasi, R. Speer, J. Pustejovsky, and H. Lieberman. Digital Intu\u00adition: \nApplying common sense using dimensionality reduction. IEEE Intelligent Systems, July 2009. R. M. Hierons, \nK. Bogdanov, J. P. Bowen, R. Cleaveland, J. Der\u00adrick, J. Dick, M. Gheorghe, M. Harman, K. Kapoor, P. \nKrause, G. L\u00a8 uttgen, A. J. H. Simons, S. Vilkomir, M. R. Woodward, and H. Zedan. Using formal speci.cations \nto support testing. ACM Comput. Surv., 41(2):1 76, 2009. ISSN 0360-0300. doi: http://doi.acm.org/10.1145/1459352.1459354. \nR. Kn\u00a8oll and M. Mezini. Pegasus: .rst steps toward a naturalistic programming language. In OOPSLA 06: \nCompanion to the 21st ACM SIGPLAN symposium on Object-oriented programming systems, languages, and applications, \npages 542 559, New York, NY, USA, 2006. ACM. ISBN 1-59593-491-X. doi: http://doi.acm.org/10.1145/1176617.1176628. \nH. Lieberman and M. Ahmad. Knowing what you re talking about: Natural language programming of a multi-player \nonline game. In M. Dontcheva, T. Lau, A. Cypher, and J. Nichols, editors, No Code Required: Giving Users \nTools to Transform the Web. Morgan Kaufmann, 2010. G. Little and R. C. Miller. Keyword programming in \nJava. In ASE 07: Proceedings of the twenty-second IEEE/ACM international conference on Automated software \nengineering, pages 84 93, New York, NY, USA, 2007. ACM. ISBN 978-1-59593-882-4. doi: http://doi.acm.org/10.1145/1321631.1321646. \nH. Liu and H. Lieberman. Programmatic semantics for natural language interfaces. In CHI 05: CHI 05 extended \nabstracts on Human factors in computing systems, pages 1597 1600, New York, NY, USA, 2005. ACM. ISBN \n1-59593-002-7. doi: http://doi.acm.org/10.1145/1056808.1056975. A. Monroy-Hern\u00b4and Resnick. Empowering \nandez M. kids to create and share programmable media. inter\u00adactions, 15(2):50 53, 2008. ISSN 1072-5520. \ndoi: http://doi.acm.org/10.1145/1340961.1340974. S. P. Reiss. Semantics-based code search. In ICSE 09: \nPro\u00adceedings of the 2009 IEEE 31st International Conference on Software Engineering, pages 243 253, Washington, \nDC, USA, 2009. IEEE Computer Society. ISBN 978-1-4244-3453-4. doi: http://dx.doi.org/10.1109/ICSE.2009.5070525. \nM. Resnick, Y. Kafai, and J. Maeda. A networked, media-rich programming environment to enhance technological \n.uency at after-school centers in economically-disadvantaged communities. Proposal to National Science \nFoundation, 2003. R. Speer, C. Havasi, and H. Lieberman. AnalogySpace: Reducing the dimensionality of \ncommon sense knowledge. Proceedings of AAAI 2008, October 2008. Y. Ye. Supporting Component-Based Software \nDevelopment with Active Component Repository Systems. PhD thesis, University of Colorado, 2001.   \n\t\t\t", "proc_id": "1869459", "abstract": "<p>We propose a new way to raise the level of discourse in the programming process: permit ambiguity, but manage it by linking it to unambiguous examples. This allows programming environments to work with informal descriptions that lack precise semantics, such as natural language descriptions or conceptual diagrams, without requiring programmers to formulate their ideas in a formal language first. As an example of this idea, we present Zones, a code search and reuse interface that connects code with ambiguous natural language statements about its purpose. The backend, called ProcedureSpace, relates purpose statements, static code analysis features, and natural language background knowledge. ProcedureSpace can search for code given statements of purpose or vice versa, and can find code that was never annotated or commented. Since completed Zones searches become annotations, system coverage grows with user interaction. Users in a preliminary study found that reasoning jointly over natural language and programming language helped them reuse code.</p>", "authors": [{"name": "Kenneth C. Arnold", "author_profile_id": "81100021470", "affiliation": "MIT, Cambridge, MA, USA", "person_id": "P2354179", "email_address": "", "orcid_id": ""}, {"name": "Henry Lieberman", "author_profile_id": "81100262805", "affiliation": "MIT, Cambridge, MA, USA", "person_id": "P2354180", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869531", "year": "2010", "article_id": "1869531", "conference": "OOPSLA", "title": "Managing ambiguity in programming by finding unambiguous examples", "url": "http://dl.acm.org/citation.cfm?id=1869531"}