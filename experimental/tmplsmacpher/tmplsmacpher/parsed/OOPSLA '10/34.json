{"article_publication_date": "10-17-2010", "fulltext": "\n Reasoning about Multiple Related Abstractions with MultiStar Stephan van Staden Cristiano Calcagno \nETH Zurich, Switzerland Imperial College, London and Monoidics Ltd Stephan.vanStaden@inf.ethz.ch ccris@doc.ic.ac.uk \n Abstract Encapsulated abstractions are fundamental in object-oriented programming. A single class may \nemploy multiple abstrac\u00adtions to achieve its purpose. Such abstractions are often re\u00adlated and combined \nin disciplined ways. This paper explores ways to express, verify and rely on logical relationships be\u00adtween \nabstractions. It introduces two general speci.cation mechanisms: export clauses for relating abstractions \nin in\u00addividual classes, and axiom clauses for relating abstractions in a class and all its descendants. \nMultiStar, an automatic veri.cation tool based on separation logic and abstract pred\u00adicate families, \nimplements these mechanisms in a multiple inheritance setting. Several veri.ed examples illustrate Mul-tiStar \ns underlying logic. To demonstrate the .exibility of our approach, we also used MultiStar to verify the \ncore iter\u00adator hierarchy of a popular data structure library. Categories and Subject Descriptors D.2.4 \n[Software Engi\u00adneering]: Software/Program Veri.cation; D.3.3 [Program\u00adming Languages]: Language Constructs \nand Features Classes and objects, Inheritance; F.3.1 [Logics and Mean\u00adings of Programs]: Specifying and \nVerifying and Reasoning about Programs General Terms Languages, Theory, Veri.cation Keywords Separation \nlogic, Multiple abstractions, Export clauses, Axiom clauses, Multiple inheritance 1. Introduction The \nuse of data abstractions is a hallmark of object-oriented (O-O) programming. A class is a typical example \nof such an abstraction. In interface or general multiple inheritance hierarchies, such as the one shown \nin Figure 1, a class can combine and maintain several abstractions offered by its par\u00adents. Although \nmost examples of this paper involve abstrac\u00adtions in connection with inheritance, not all data abstractions \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA/SPLASH \n10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright c &#38;#169; 2010 ACM 978-1-4503-0203-6/10/10. \n. . $10.00 Figure 1. The core Gobo cursor hierarchy. are directly coupled with language constructs. \nClasses use them for various purposes: to simplify how clients manipu\u00adlate a class, to separate various \nconcepts that are combined in a class, or to encourage or enforce particular call proto\u00adcols. For example, \na complex object with a long initializa\u00adtion phase can use the abstractions initializing and ready , \nwith methods applicable to an initializing object, others to a ready object, and some to both. Or algorithms \ncan ma\u00adnipulate a mutable data structure under an immutable ab\u00adstraction, even if there is no interface \nmaking this explicit. Relationships between data abstractions are important when reasoning about O-O \ncode. This paper explores the problem of relating abstractions in an information hiding setting, where \nimplementation details of abstractions are hidden from clients. Suppliers must therefore express and \nful.ll relationships between abstractions. If a class offers student and person abstractions (by using \ninheritance, or other means), for example, it might allow clients to convert a student abstraction into \na person one. Clients can then manipulate the person abstraction by calling e.g. library routines. After \nthe manipulation, they might be allowed to convert back and assume that the number of exams the stu\u00addent \nhas taken is still the same. Speci.cation mechanisms are needed to express and enforce the programmer \ns inten\u00adtions about such relationships. This is especially important in multiple inheritance hierarchies \nwhere classes combine multiple abstractions in complicated ways. A .exible mechanism for capturing data \nabstractions in O-O speci.cations is abstract predicate families, as intro\u00adduced in [25, 27]. An apf \n(abstract predicate family) P pro\u00advides a predicate name for an abstraction; each class C can de.ne an \nentry predicate PC . The de.nition of PC describes how class C implements the apf P, and is hidden from \nother classes. For example, apfs S and P can be used to provide an abstraction of students and persons \nin a program respec\u00adtively. Class STUDENT can de.ne the entries SSTUDENT and PSTUDENT , while other classes \ncan de.ne their apf en\u00adtries differently. The predicate x.S(age: a, exm: e) describes object x under \nthe student abstraction: its age is a and the number of exams taken is e . If the dynamic type of x is \nSTUDENT, then class STUDENT can use the fact that  x.S(age: a, exm: e) . x.SSTUDENT (age: a, exm: e) \nIn other words, the dynamic type of the .rst argument of an apf predicate (in this case the dynamic type \nof x) deter\u00admines which apf entry applies. Apf predicates can therefore be seen to mirror dynamic dispatch \nof O-O programs in the logic. The apf mechanism is modular and exercises informa\u00adtion hiding: only the \nclass de.ning an apf entry knows the de.nition and can relate its entry to the apf predicate. The relationship \ndescribed before, namely that a student abstraction can be converted into a person one, can be expressed \nas follows: x.S(age: a, exm: e) . x.P(age: a) Allowing the back conversion without affecting the number \nof exams requires a stronger property that uses separation logic s *-connective: x.S(age: a, exm: e) \n. [x.P(age: a) * x.RestStoP(exm: e)] (A) where RestStoP abstracts the parts of a student abstraction \nthat are independent from and not included in a person one. With this property, a client can now reason \nas the following proof outline shows: {x.S(age: a, exm: e)}{x.P(age: a) * x.RestStoP(exm: e)}{x.P(age: \na)}// Manipulation of person abstraction by library routines. {x.P(age: a+1)}{x.P(age: a+1) * x.RestStoP(exm: \ne)}{x.S(age: a+1, exm: e)} The Frame rule of separation logic guarantees that the dis\u00adjoint x.RestStoP(exm: \ne) remains unchanged. In essence, the client uses property (A) in combination with the Frame rule to \ninfer an S-based speci.cation for the library manipulation. It is not necessary to re-specify and re-verify \nthe library knowledge of the relationship saves speci.cation overhead and keeps reasoning modular. To \nwhich objects the property (A) applies is a design choice: a programmer might express that selected classes \nin a heterogeneous hierarchy ful.ll the relationship, or that all classes in a homogeneous hierarchy \nful.ll it. We introduce two general speci.cation mechanisms for the two cases: ex\u00adport clauses to express \nproperties that hold for individual classes, and axiom clauses to describe properties of entire hierarchies. \nIf class STUDENT speci.es export .x,a,e\u00b7 x : STUDENT . [x.S(age: a, exm: e) . [x.P(age: a) * x.RestStoP(exm: \ne)]] where {} then a client must know that an object s dynamic type is ex\u00adactly STUDENT before using \nthe information in reasoning. On the other hand, if class STUDENT speci.es axiom S P: .a,e\u00b7 S(age: a, \nexm: e) . [P(age: a) * RestStoP(exm: e)] then clients can use the stronger implication .x,a,e\u00b7 x <: STUDENT \n. [x.S(age: a, exm: e) . [x.P(age: a) * x.RestStoP(exm: e)]] Knowledge that the object s dynamic type \nis a subtype of STUDENT (including STUDENT) suf.ces to use the rela\u00adtionship. This is much more convenient \nfor clients: a sound O-O type system will guarantee that if a variable has static type STUDENT and references \nan object, then the object s dynamic type will always be a subtype of STUDENT. Axiom clauses offer a \ngeneral facility to constrain the implementation of abstractions in subclasses. For example, class STUDENT \ncan express that the number of exams a student has taken is always non-negative, and that all sub\u00adclasses \nshould use its implementation of the student ab\u00adstraction:  axiom exm non neg: .a,e\u00b7 S(age: a, exm: \ne) . 0 = e S constraint: .a,e\u00b7 S(age: a, exm: e) . SSTUDENT (age: a, exm: e) Axiom clause exm non neg \nguarantees clients that 0 = e whenever they know x.S(age: a, exm: e) and x <: STU-DENT. Subclass representation \nconstraints such as the one expressed in the S constraint clause are useful for ensur\u00ading safe interaction \nbetween statically and dynamically dis\u00adpatched calls on the same object a pervasive pattern in O-O 1 \nprograms. The claims made in export and axiom speci.cations must be checked to obtain sound reasoning. \nWhether or not a class ful.lls axiom clauses often depends on properties of particular other classes, \nsuch as its parents. For this reason our proof system has a layered assumption structure: axiom veri.cation \ncan use export information of all classes in a program, and method veri.cation can additionally use axiom \ninformation. Several examples in the paper show how export and axiom clauses are veri.ed and applied \nin veri.cation. The paper contains a formalization of our proof system that extends the one of Parkinson \nand Bierman [27] with ex\u00adport/axiom clauses, abstract classes, abstract methods and shared multiple inheritance2 \nwhere .elds and methods of 1 Matthew Parkinson pointed out in private communication that the informal \ndiscussion of representation constraints right before Section 5.1 and in Section 5.5 of [27] can be made \nrigorous by using export and axiom clauses. 2 Inheritance with virtual base classes in C++ terminology \n[9].  common ancestor classes are not replicated in the descen\u00addant [8]. Apart from the use of apfs \nto support abstraction and information hiding, Parkinson and Bierman s system has the attractive property \nthat it can verify a wide range of in\u00adheritance uses and abuses. Flexible handling of inheritance is \nvital in a proof system for multiple inheritance, since classes often interrelate methods and data from \nparents in compli\u00adcated ways: methods can intertwine ancestor abstractions as the example in Section \n2.1 shows, or abstractions can share parts in the case of diamond inheritance. Export and axiom clauses \nprovide .exible ways to relate abstractions, thereby giving clients an integrated view of how methods \naffect ab\u00adstractions from different inheritance paths. Very few proof systems exist for multiple inheritance, \nand no proof system we know of can facilitate reasoning about multiple related abstractions at the same \nlevel of abstraction as ours. We implemented our proof system in MultiStar a fully automatic veri.cation \ntool. MultiStar has a two-tier architec\u00adture: a GUI front-end that translates Eiffel code and speci.\u00adcations \ninto a simpler form for veri.cation, and a language\u00adindependent back-end based on jStar [5] for reasoning. \nThe front-end uses speci.cations written inside classes. It is eas\u00adier to use than jStar, which currently \ndoes not have a front\u00adend and requires separate code and speci.cations. Future front-ends for e.g. Java \nand C# can reuse the MultiStar back\u00adend: with its support for interface inheritance, export/axiom clauses, \nabstract classes and abstract methods, a wide range of programs can be veri.ed. As we shall see, the \nbene.ts of export and axiom clauses are not limited to multiple inher\u00aditance. Class DYNAMIC CURSOR of \nFigure 1 uses only single inheritance, but cannot be veri.ed with jStar because it relies on axiom information. \nAll the examples presented in this paper have been ver\u00adi.ed with MultiStar. To demonstrate the .exibility \nof our approach, we also used MultiStar to verify the Gobo data structure library s core iterator hierarchy \nof Figure 1. The complete code and speci.cations of the examples and Gobo case study are available online \n[10]. Outline Several examples illustrating the new speci.ca\u00adtion mechanisms and proof system follow \nin Section 2. Sec\u00adtion 3 presents the MultiStar tool, and Section 4 reports on the case study with Gobo \niterator classes. A formal exposi\u00adtion of our proof system appears in Section 5. Section 6 con\u00adcludes \nand mentions related work. The Appendix contains an overview of the formal semantics of our proof system, \nand a proof of soundness.  2. Examples The examples are written in a language resembling Eif\u00adfel [8]. \nA class is divided into top-level sections. The inherit section lists its parent classes, the de.ne section \nits apf entry de.nitions, the export and axiom sections its export and ax\u00adiom clauses respectively, and \nmethods and .elds are written in the feature section. Empty sections are simply omitted. Two reserved \nprogram variables Current and Result denote the current object ( this ) and the result of a function \ncall respectively. Current is never Void ( null ). Methods have both static and dynamic speci.cations. \nA speci.cation is written in pre-post form {P}{Q}, or alter\u00adnatively {P1}{Q1} also {P2}{Q2} to indicate \nthat both are satis.ed (Section 5.4 shows how the also form abbre\u00adviates a single pre-post speci.cation). \nA method s dynamic speci.cation must be satis.ed by all subclasses, and is used to verify dynamically-dispatched \ncalls. A static speci.cation describes properties about the particular method body, and is used to verify \nstatically-dispatched calls, including Pre\u00adcursor ( super or base ) calls and direct calls x.C::m(e)in \nC++ style. We omit the target of a method call or .eld assignment if it is Current. Similarly in the \nlogic, f '. e abbreviates Current.f '. e (meaning that the Current object s .eld f has value e), and \nif the .rst argument of an apf predicate or entry is Current then it is simply omitted. We also employ \nthe method speci.cation shorthands of [27]: if only a static speci.cation is listed, the dynamic speci.cation \nis assumed to be exactly the same, and if only a dynamic speci.cation is listed, then a static speci.cation \nis derived by replacing each apf predicate whose .rst argument is Current with the entry predicate of \nthe class. In other words, if the shorthand is used in class C, then p(t: e) is replaced with pC (t: \ne). Speci.cations of non-constructor methods are furthermore propagated down the hierarchy: if a class \ndoes not explicitly list an inherited method, then it is assumed to have the same static and dynamic \nspeci.cations as determined for the parent class. To avoid ambiguity, we require that if the method is \navailable in multiple parents, then they must all have identical speci.cations for it. The examples do \nnot discuss details that are uninterest\u00ading from this paper s perspective, such as proofs of correct\u00adness \nof simple ancestor classes. Readers interested in details are referred to the formalization in Section \n5; the paper of Parkinson and Bierman [27] also contains several examples. 2.1 Intertwining ancestor \nabstractions Classes CELL and COUNTER are shown in Figure 2. CELL models mutable integer-valued cells \nand uses apf Cell, while COUNTER uses apf Cn. The apfs provide log\u00adical abstractions of mutable cells \nand counters respectively. Class CCELL in Figure 3, the focus of this example, inherits from CELL and \nCOUNTER. It intertwines the functionality of its parents by overriding set value to store the value and \nincrement the count. It uses apf Cc to provide an abstrac\u00adtion of such objects in the logic, and grows \nCellCCELL to accommodate method set value, as we shall see. The single export clause of CCELL relates \nthe Cc, Cell and Cn abstractions. Only the predicate in front of where is exported for reasoning. Predicate \nde.nitions following where are used only to verify the clause and allow a class to hide implementation/representation \ndetails in its interface  class CELL de.ne x.CellCELL(val: v) as x.value '. v feature introduce CELL(v: \nint) dynamic {value '. }{Cell(val: v)} do value := v end introduce value(): int dynamic {Cell(val: v)}{Cell(val: \nv) * Result =v}do Result := value end introduce set value(v: int) dynamic {Cell(val: )}{Cell(val: v)} \ndo value := v end value: int end class COUNTER de.ne x.CnCOUNTER(cnt: c) as x.count '. c feature introduce \nCOUNTER() dynamic {count '. }{Cn(cnt: 0)} do count := 0 end introduce count(): int dynamic {Cn(cnt: \nc)}{Cn(cnt: c) * Result =c}do Result := count end introduce increment() dynamic {Cn(cnt: c)}{Cn(cnt: \nc+1)} do tmp: int; tmp := count; count := tmp + 1 end count: int end Figure 2. The CELL and COUNTER \nclasses. without introducing new predicate families. For example, if we modify the representation of \nclass CCELL, then the de.nition of Rest(x,v) can be changed without invalidating correctness proofs of \nclient code. To verify an export clause, we must prove that the ex\u00adported predicate follows from the \nstandard apf assumptions of the class and the predicate de.nitions after the where key\u00adword. The proof \nfor CCELL s export clause is trivial; for de\u00adtail about standard apf assumptions, the reader is referred \nto Section 5.10. Note that export clauses are not veri.ed for a particular dynamic type, since the standard \napf assump\u00adtions of a class do not assume a particular one. It is therefore sound to use exported information \nto verify axiom clauses and methods of other classes, as we will do in later exam\u00adples. However, nothing \nprevents the user from writing ex\u00adported predicates as implications where the antecedent is of the form \nx : Type (see the export clause of CCELL). In this case information in the consequent can be applied \nonly to objects satisfying this type constraint. For the constructor we have to prove that its body sat\u00adis.es \nthe static speci.cation (note that a Precursor call is syntactic sugar for a direct call): class CCELL \ninherit CELL COUNTER de.ne x.CellCCELL(val: v, cnt: c) as x.CcCCELL(val: v, cnt: c) x.CnCCELL(cnt: c) \nas x.CnCOUNTER(cnt: c) x.CcCCELL(val: v, cnt: c) as x.CellCELL(val: v) * x.CnCOUNTER(cnt: c) export \n.x\u00b7 x : CCELL . [.c,v\u00b7 x.Cc(val: v, cnt: c) . x.Cell(val: v, cnt: c) . (x.Cn(cnt: c) * Rest(x,v))] where \n{ Rest(x,v) = x.CellCELL(val: v) } feature introduce CCELL(v: int) dynamic {value '.* count '. }{Cc(val: \nv, cnt: 0)}do Precursor{CELL}(v); Precursor{COUNTER}() end inherit value(): int dynamic {Cc(val: v, cnt: \nc)}{Cc(val: v, cnt: c) * Result =v}also {Cell(val: v, cnt: c)}{Cell(val: v, cnt: c) * Result =v} override \nset value(v: int) dynamic {Cc(val: ,cnt:c)}{Cc(val: v, cnt: c+1)} also {Cell(val: ,cnt:c)}{Cell(val: \nv, cnt: c+1)} do CCELL::increment(); CELL::set value(v) end inherit count(): int dynamic {Cc(val: v, \ncnt: c)}{Cc(val: v, cnt: c) * Result =c}also {Cn(cnt: c)}{Cn(cnt: c) * Result =c} inherit increment() \ndynamic {Cc(val: v, cnt: c)}{Cc(val: v, cnt: c+1)}also {Cn(cnt: c)}{Cn(cnt: c+1)}end // In an arbitrary \nclass or library: use counter(c: COUNTER) dynamic {c.Cn(cnt: v)}{c.Cn(cnt: v+10)} use cell(c: CELL, v: \nint) dynamic {c.Cell(val: )}{c.Cell(val: v)} Figure 3. The CCELL class and two library methods. {value \n'.* count '.} CELL::CELL(v) {CellCELL(val: v) * count '.} Precursor{COUNTER}() {CellCELL(val: v) * CnCOUNTER(cnt: \n0)}{CcCCELL(val: v, cnt: 0)} The constructor body simply passes the needed .elds to parent constructors \nand treats their internal representations abstractly thereafter.3 Method value is respeci.ed in CCELL \nwith Cell and Cc speci.ciations. Since it inherits the body from CELL, we must prove that the new static \nspeci.cation is satis.ed as\u00adsuming the body s static speci.cation of CELL. This method proof obligation \nis called Inheritance in the formalization, and readers that are unfamiliar with speci.cation re.nement \nare referred to Section 5.4 for detail. By applying the Frame rule (with CnCOUNTER(cnt: c)) and then \nthe rule of Con\u00adsequence, we can derive each also-ed static speci.cation, 3 To simplify the formal presentation \nof proofs and make them more trans\u00adparent, we mention .elds explicitly in constructor preconditions. \nMultiStar injects them automatically see Section 3.1 for more discussion.  which is suf.cient to conclude \nthe proof4. Another proof obligation for value is Behavioral subtyping, where we must show that the dynamic \nspeci.cation listed in CELL follows from the new one, i.e. that CCELL maintains the old spec\u00adi.cation. \nFor the proof, we .rst choose the Cell dynamic spec5 and then remove the cnt tag by applying the Auxiliary \nVariable Elimination and Consequence rules. The applica\u00adtion of Auxiliary Variable Elimination quanti.es \nthe variable c existentially in the pre-and postcondition, and the applica\u00adtion of Consequence uses tag \nreduction information which is part of CCELL s standard apf assumptions. Behavioral subtyping of set \nvalue is similar. For its Body veri.cation obligation, we must prove that both CellCCELL and CcCCELL \nstatic speci.cations are satis.ed. The proof proceeds as follows: {CellCCELL(val: ,cnt:c)} CCELL::increment() \n{CellCCELL(val: ,cnt:c+1)}{CellCELL(val: ) * CnCOUNTER(cnt: c+1)} CELL::set value(v) {CellCELL(val: v) \n* CnCOUNTER(cnt: c+1)}{CellCCELL(val: v, cnt: c+1)} An application of Consequence proves the other also-ed \nstatic spec and completes the proof6. As the body oper\u00adates on state described by CellCELL and CnCOUNTER,the \nproof obligations and separation logic s faulting semantics demand that we grow CellCCELL to include \nboth state parcels. Now consider the two library routines at the bottom of Figure 3. The export clause \ncontains the necessary informa\u00adtion to prove the two triples: {true} cc := new CCELL(5); use counter(cc) \n{cc.Cc(val: 5, cnt: 10)}{true} cc := new CCELL(5); use cell(cc,20) {cc.Cc(val: 20, cnt: )} The proof \nof the second triple reduces and expands tags according to standard apf rules: {true} cc := new CCELL(5) \n{cc : CCELL * cc.Cc(val: 5, cnt: 0)} {cc : CCELL * cc.Cell(val: 5, cnt: 0)} {cc : CCELL * cc.Cell(val: \n5, cnt: )} {cc : CCELL * cc.Cell(val: 5)}use cell(cc,20) {cc : CCELL * cc.Cell(val: 20)} {cc : CCELL \n* cc.Cell(val: 20, cnt: )}{cc.Cc(val: 20, cnt: )}  Information about cnt is lost in the postcondition, \nwhich is unavoidable because use cell could call set value more than once. In a version of CCELL where \nCnCCELL is de.ned to include the CellCELL state and the equivalence of Cc, Cn and Cell is exported, information \nabout val will likewise be lost in the .rst triple. Also note that dynamic type informa\u00adtion is required \nto use the exported relationships, since the subclasses of CCELL are not obliged to implement them. 4 \nByLemma 2onpage13. 5 ByLemma 1onpage13. 6 ByLemma 3onpage13. class CCEL2 inherit CELL COUNTER de.ne x.CellCCEL2 \n(val: v, cnt: c) as x.CellCELL(val: v) * x.CnCOUNTER(cnt: c) x.CnCCEL2 (cnt: c) as x.CnCOUNTER(cnt: c) \nexport .x\u00b7 x : CCEL2 . [.v,c\u00b7 x.Cell(val: v, cnt: c) . x.Cn(cnt: c)] where {} feature introduce CCEL2(v: \nint) dynamic {value '.* count '. }{Cell(val: v, cnt: 0)}do Precursor{CELL}(v); Precursor{COUNTER}() end \ninherit value(): int dynamic {Cell(val: v, cnt: c)}{Cell(val: v, cnt: c) * Result =v} override set value(v: \nint) dynamic {Cell(val: ,cnt:c)}{Cell(val: v, cnt: c+1)} do CCEL2::increment(); CELL::set value(v) end \n inherit count(): int dynamic {Cell(val: v, cnt: c)}{Cell(val: v, cnt: c) * Result =c}also {Cn(cnt: c)}{Cn(cnt: \nc) * Result =c}end Figure 4. The CCEL2 class.  2.2 Access control and call protocols Our proof system \ncan enforce interesting access control pat\u00adterns in veri.ed programs. Consider class CCEL2 in Figure \n4 which has the same executable code as CCELL but different speci.cations. Its export clause relates \nthe Cell and Cn ab\u00adstractions in a one-directional way. The constructor produces a Cell apf predicate \nwith which methods value, set value and count can be called. Veri.ed clients cannot call increment with \nthe Cell predicate. They must use exported information to get a Cn predicate, yet they lack information \nto change back after the call: no export or axiom clause is available to do this, and every method producing \na Cell predicate re\u00adquires one. The following proof attempt where cc2 : CCEL2 shows the problem: {cc2.Cell(val: \nv, cnt: c)}{cc2.Cn(cnt: c)} cc2.increment() {cc2.Cn(cnt: c+1)}{???}{cc2.Cell(val: ,cnt: )} // The weakest \nrequirement of set value. cc2.set value(10) {cc2.Cell(val: ,cnt: )} While the client has a Cell predicate, \nthe argument tagged by cnt and returned by count re.ects precisely how many times the value has been \nset. If the client tries to manipulate the count by calling increment, then it can never regain the needed \ncapability to call value and set value, and must forever treat the object as a simple counter in the \ncode. The combination of abstract predicate relationships and method speci.cations enforces this protocol \nin veri.ed code.  2.3 Diamond inheritance Veri.cation of multiple inheritance requires proper handling \nof data from several parent classes. Diamond inheritance  class PERSON de.ne x.PPERSON (age: a) as x.age \n'. a export .x,a\u00b7 x.PPERSON (age: a) . x.age '. a where {}feature introduce PERSON(a: int) dynamic {age \n'. }{P(age: a)} do age:= a end introduce age(): int dynamic {P(age: a)}{P(age: a) * Result =a} do Result \n:= age end introduce set age(a: int) dynamic {P(age: )}{P(age: a)} do age:= a end introduce celebrate \nbirthday() static {P(age: a)}{P(age: a+1)} do tmp: int; tmp := age(); tmp := tmp+1; set age(tmp) end \n age: int end class STUDENT inherit PERSON de.ne x.PSTUDENT (age: a) as x.PPERSON (age: a) x.SSTUDENT \n(age: a, exm: e) as x.PSTUDENT (age: a) * x.exams '. e x.RestStoPSTUDENT (exm: e) as x.exams '. e export \n.x,a,e\u00b7 [x.PPERSON (age: a) * x.RestStoPSTUDENT (exm: e)] . x.SSTUDENT (age: a, exm: e) where {}axiom \nS P: .a, e\u00b7 S(age: a, exm: e) . [P(age: a) * RestStoP(exm: e)] feature introduce STUDENT(a: int, e: int) \ndynamic {age '.* exams '. }{S(age: a, exm: e)} do Precursor{PERSON}(a); exams := e end introduce exams(): \nint dynamic {S(age: a, exm: e)}{S(age: a, exm: e) * Result =e}do Result := exams end introduce take exam() \ndynamic {S(age: a, exm: e)}{S(age: a, exm: e+1)} do tmp: int; tmp := exams; exams := tmp + 1 end exams: \nint end Figure 5. The PERSON and STUDENT classes. complicates matters because common ancestor .elds are \nshared. This is unproblematic for our proof system, although the abstraction of the shared data is typically \nlost. Diamond inheritance can moreover require relationships between sev\u00aderal abstractions, which this \nexample achieves with axiom clauses. An axiom clause consists of a name and a predicate. The name identi.es \nthe clause and allows subclasses to re.ne the predicate. We propagate axiom clauses down the hierarchy \nto save speci.cation overhead: if a class does not list an axiom clause with the same name as one in \na parent, then it is assumed to list an identical clause. To avoid ambiguity in the presence of multiple \ninheritance, we require that if clauses with the same name are present in multiple parents, then they \nmust all be identical. An axiom clause copied in this way class SMUSICIAN inherit STUDENT MUSICIAN de.ne \n x.PSMUSICIAN (age: a) as x.PPERSON (age: a) x.SSMUSICIAN (age: a, exm: e) as x.SSTUDENT (age: a, exm: \ne) x.MSMUSICIAN (age: a, pfm: p) as x.MMUSICIAN (age: a, pfm: p) x.SMSMUSICIAN (age: a, exm: e, pfm: \np) as x.PPERSON (age: a) * x.RestStoPSTUDENT (exm: e) * x.RestMtoPMUSICIAN (pfm: p) x.RestStoPSMUSICIAN \n(exm: e) as x.RestStoPSTUDENT (exm: e) x.RestMtoPSMUSICIAN (pfm: p) as x.RestMtoPMUSICIAN (pfm: p) x.RestSMtoSSMUSICIAN \n(pfm: p) as x.RestMtoPMUSICIAN (pfm: p) x.RestSMtoMSMUSICIAN (exm: e) as x.RestStoPSTUDENT (exm: e) axiom \nSM S: .a, e, p\u00b7 SM(age: a, exm: e, pfm: p) . [S(age: a, exm: e) * RestSMtoS(pfm: p)] SM M: .a, e, p\u00b7 \nSM(age: a, exm: e, pfm: p) . [M(age: a, pfm: e) * RestSMtoM(exm: e)] feature introduce SMUSICIAN(a: int, \ne: int, p: int) dynamic {age '.* exams '.* performances '.} {SM(age: a, exm: e, pfm: p)} do Precursor{STUDENT}(a,e); \nPrecursor{MUSICIAN}(a,p) end introduce do exam performance() static {SM(age: a, exm: e, pfm: p)}{SM(age: \na, exm: e+1, pfm: p+1)} do take exam(); perform() end end Figure 6. The SMUSICIAN class. is not re.ned \nin the subclass and automatically consistent with its parent versions. In the general case where a subclass \nre.nes an axiom clause, Parent consistency must be proven as indicated in the formalization. The focus \nof this example is class SMUSICIAN, shown in Figure 6. It inherits from STUDENT and MUSICIAN, both which \ninherit from PERSON. The STUDENT and PERSON classes are shown in Figure 5; MUSICIAN is sim\u00adilar to STUDENT \nand not shown. A diamond is formed with PERSON at the top, and an instance of SMUSICIAN has one age .eld, \none set age method, etc. under shared multi\u00adple inheritance semantics. The classes use axiom clauses \nto specify relationships between abstractions P, S, M and SM. Since SMUSICIAN is non-abstract, we must \nprove that axiom SM S holds for its direct instances. This proof obliga\u00adtion for axiom clauses is called \nImplication in the formaliza\u00adtion. It holds indeed, since under the standard apf assump\u00adtions of SMUSICIAN, \nexported information of all classes, and the assumption Current : SMUSICIAN, we have: SM(age: a, exm: \ne, pfm: p) . // Standard apf assumptions, Current : SMUSICIAN SMSMUSICIAN (age: a, exm: e, pfm: p) . \n// Standard apf assumptions. PPERSON (age: a) * RestStoPSTUDENT (exm: e) * RestMtoPMUSICIAN (pfm: p) \n . // Exported information from STUDENT. SSTUDENT (age: a, exm: e) * RestMtoPMUSICIAN (pfm: p)  . // \nStandard apf assumptions. SSMUSICIAN (age: a, exm: e) * RestSMtoSSMUSICIAN (pfm: p)  . // Standard apf \nassumptions, Current : SMUSICIAN S(age: a, exm: e) * RestSMtoS(pfm: p)   The export clause in STUDENT \nis not closely connected to multiple inheritance. In fact, any class C inheriting from STUDENT which \nde.nes PC to be PPERSON and SC to be SSTUDENT will need the export clause to prove Implication of S P, \nwhich we omit here for SMUSICIAN. Axiom veri.\u00adcation frequently requires exported information of this \nkind. What is vital about the export clause in the shared multiple inheritance setting is that it isolates \nthe shared ancestor state of SMUSICIAN, namely PPERSON . This allows SMUSI-CIAN to relate ancestor abstractions \nin a fairly abstract way. Only the constructor s Body veri.cation proof needs the ex\u00adport clause in PERSON7: \n{age '.* exams '.* performances '.} Precursor{STUDENT}(a,e) {SSTUDENT (age: a, exm: e) * performances \n'.}{PPERSON (age: a) * RestStoPSTUDENT (exm: e) * performances '.}{age '. a * RestStoPSTUDENT (exm: e) \n* performances '.} Precursor{MUSICIAN}(a,p) {MMUSICIAN (age: a, pfm: p) * RestStoPSTUDENT (exm: e)}{PPERSON \n(age: a) * RestMtoPMUSICIAN (pfm: p) * RestStoPSTUDENT (exm: e)}{SMSMUSICIAN (age: a, exm: e, pfm: p)} \nNote that class SMUSICIAN would not have needed ex\u00adported information if it ignored the parent constructors \nand simply overrode everything. The same is true for proof sys\u00adtems with less abstraction where method \nbodies are reveri\u00ad.ed in subclasses. Since Current in SMUSICIAN will always reference an object whose \ndynamic type is a subtype of SMUSICIAN, the Body veri.cation proof of do exam performance can use axiom \ninformation to infer SM-specs for take exam and perform: {SM(age: a, exm: e, pfm: p)} {S(age: a, exm: \ne) * RestSMtoS(pfm: p)} take exam() {S(age: a, exm: e+1) * RestSMtoS(pfm: p)}{SM(age: a, exm: e+1, pfm: \np)}{M(age: a, pfm: p) * RestSMtoM(exm: e+1)} perform() {M(age: a, pfm: p+1) * RestSMtoM(exm: e+1)}{SM(age: \na, exm: e+1, pfm: p+1)} The speci.cation overhead incurred by axiom clauses is off\u00adset by speci.cation \ninference gains: SM, S and M speci.ca\u00adtions can be inferred for age, set age and celebrate birthday, \nwhile SM speci.cations can be inferred for exams, take \u00adexam, performances and get performance a total \nof 13 speci.cations for methods of SMUSICIAN. These inferred speci.cations are guaranteed to be implemented \nby all sub\u00adclasses, and no dynamic type information is needed to use them8. Yet the system is still .exible \n a subclass can always 7 Unless a class manipulates .elds of its ancestors directly, this export clause \nwould not be needed in languages where constructors of common ancestor classes cannot be called more \nthan once. 8 The technique used by Chin et al. [4] of inheriting static method speci\u00ad.cations and deriving \ndynamic speci.cations from them implements in\u00adternal speci.cation inference , i.e. a class infers and \npublishes dynamic speci.cations for its methods which external clients can use. In con\u00ad choose to satisfy \nsuch constraints vacuously by de.ning se\u00adlected apf entries as false. Class DCell in [27] provides an \nexample of this.  3. MultiStar This section sketches notable aspects of the MultiStar imple\u00admentation. \nMultiStar has a two-tier architecture: a front-end that translates Eiffel programs and speci.cations \ninto a sim\u00adpler form for veri.cation, and a language-independent back\u00adend based on jStar [5] which implements \nour proof system. 3.1 Front-end The front-end provides a graphical user interface within the EVE integrated \ndevelopment environment, and is part of the standard EVE download [10]. It translates Eiffel code and \nspeci.cations into the back-end s input format, and pro\u00advides access to veri.cation results. Veri.cation \nis triggered by picking and dropping an annotated class on the Multi-Star tool. Class annotations consist \nof apf entry de.nitions, export/axiom clauses and method speci.cations. To simplify the proofs and formalization \nin this paper, constructor preconditions explicitly mention .elds and break information hiding. The front-end \ntranslation of MultiStar injects them automatically. For example, a user would write the speci.cation \nof CCELL s constructor as dynamic {true}{Cc(val: v, cnt: 0)} instead of dynamic {value '.* count '. }{Cc(val: \nv, cnt: 0)} In detail, the front-end facilitates this by: 1. Using jStar s new statement, whose speci.cation \nis given by the triple {true}x:= new C{x:C}. This allows us to omit the .elds in the dynamic precondition9. \n 2. Adding all .elds (including ancestor ones) to the static precondition when checking Body veri.cation, \nand con\u00adsuming all .elds of a parent class and its ancestors right before the parent constructor is called. \nThis is commu\u00adnicated to the back-end by emitting special instructions, and allows us to omit the .elds \nin the static precondition.  The Dynamic dispatch proof obligation, which checks that the static and \ndynamic speci.cations are consistent with each other, is unaffected because .elds are omitted in both \ntrast to this, the technique of equipping classes with export/axiom clauses implements external speci.cation \ninference , i.e. clients infer speci.\u00adcations for methods based on published export/axiom information. \nA bene.t of the external approach is that clients can infer valid speci.\u00adcations for library code without \nre-verifying it. For example, knowing only the inferred speci.cations for methods of class SMUSICIAN \nis not enough for proving the triple {x.SM(age: a, exm: e, pfm: p)}use stu\u00addent(x){x.SM(age: a+1, exm: \ne+4, pfm: p)} without looking at the imple\u00admentation of the library routine use student(st: STUDENT) \nwhose dynamic speci.cation is {st.S(age: a, exm: e)}{st.S(age: a+1, exm: e+4)}. 9 The dynamic speci.cation \nof the constructor is used for object initializa\u00adtion. x := new C(e) abbreviates x := new C; x.C(e) if \nx is not free in e.  static and dynamic preconditions. In languages where no .elds are shared by ancestors, \nor constructors of common ancestors are called only once, the manipulation does not have to add ancestor \n.elds to the static precondition and consume .elds when a parent constructor is called. This is the approach \njStar uses for Java veri.cation. A front-end for C++ can use a similar technique because every ancestor \nconstructor is called exactly once when virtual base classes are used [9].  3.2 Back-end The MultiStar \nback-end extends jStar with support for export and axiom clauses, abstract classes and multiple inheritance. \nThe latter two demand generalized method proof obligation checking. 3.2.1 Export and axiom clauses The \nbackground theory used by the jStar theorem prover is encoded as a list of sequent rules. A sequent is \nof the form P | Q f R, meaning (P * Q) . (P * R). Each sequent rule has the form A | B f C if D | E f \nF If the prover is trying to prove a sequent that matches the rule s conclusion A | B f C, it suf.ces \nto prove the sequent where the rule s premise D | E f F replaces the matched predicates. A new proof \ngoal is thus obtained, and the proof is complete when the goal is of the form G | H f . For details the \nreader is referred to [5]. Exported information is written as sets of implications. Before verifying \nan export clause, the background theory is temporarily extended with the de.nitions of all predicates \nin its where part. For each de.nition of the form w(x) = P, the following two rules are generated: | \nw(x) f |f w(x) if if | P f |f P After all exported implications in the clause have been checked, the \nde.nitions are removed from the background theory. After all export clauses have been veri.ed, each ex\u00adported \nimplication P . (Q1 * ... * Qn) is added to the back\u00adground theory as a set of n rules, where rule i \n. 1..n has the form | P f Qi if Qi | Q1 * ... * Qi-1 * Qi+1 * ... * Qn f This rule form retains information \nabout Qi in its premise, and removal of Qi from the goal sequent s right-hand side brings the proof closer \nto completion. The background theory augmented with export informa\u00adtion is then used to verify axiom \nclauses. The predicates in axiom clauses are written as implications. After all ax\u00adiom clauses have been \nveri.ed, an axiom implication P . (Q1 * ... * Qn) written in class C is encoded as n rules, with rule \ni . 1..n of the form | P f Qi if Qi | Q1 * ... * Qi-1 * Qi+1 * ... * Qn f x <:C where x is the pattern \nvariable substituted for Current. The background theory augmented with export and ax\u00adiom information \nis then used for method veri.cation. 3.2.2 Method proof obligations The back-end accommodates abstract \nclasses and abstract methods in addition to shared multiple inheritance. An ab\u00adstract method has no body \nand hence no static speci.cation. The back-end takes this into account when expanding spec\u00adi.cation shorthands. \nAfter shorthand expansion, veri.cation of method m in class C proceeds as follows (the formaliza\u00adtion \ncontains details about the proof obligations): If m has a static speci.cation and C can be instantiated \n (i.e. is non-abstract), then check Dynamic dispatch.  If m has a body in C, then check Body veri.cation. \n Always check Behavioral subtyping. This succeeds triv\u00adially if m is introduced in C: the set of dynamic \nspeci.\u00adcations for m in C s parents is empty, and therefore all its elements are preserved by the new \nspeci.cation.  If m has a static speci.cation but no body in C, then check Inheritance.  The treatment \nsubsumes interface inheritance interfaces are treated as abstract classes with only abstract methods \nand no .elds.  4. Case study The Gobo data structure library [11] is an open-source Eiffel library \ncovering data structures and algorithms. It contains classic data structures such as lists, stacks and \nsets, and pro\u00advides several implementations of each structure. The library is stable and a popular choice \namong Eiffel developers. Data structures such as lists and sets can be traversed with iterators. The \niterator (or cursor) hierarchy is characterized by relatively simple algorithms and extensive use of \nmultiple inheritance, which makes it an ideal candidate for evaluating the novel aspects of our proof \nsystem and its implementa\u00adtion. The core classes are shown in Figure 1: a LINEAR -CURSOR can traverse \na data structure forwards, a BILIN-EAR CURSOR can traverse both forwards and backwards, an INDEXED CURSOR \noffers random data structure access with an integer position or index, and a DYNAMIC CUR-SOR can modify \nthe data structure being traversed. We successfully veri.ed the core cursor hierarchy of Fig\u00adure 1 with \nMultiStar. The overall effort for speci.cation and veri.cation was .ve person-days. Most of the time \nwas spent on .nding and revising speci.cations, since we did not mod\u00adify the code. Table 1 shows the \nexperimental results. The to\u00adTable 1. Experimental results of the Gobo iterator case study. LOC1 and \nLOC2 denote the lines of code before and after speci.cation respectively. MultiStar was executed on a \n Class LOC1 LOC2 Time(s) BILINEAR CURSOR 99 124 1.306 BILINEAR SET CURSOR 44 50 0.841 CURSOR 130 158 \n1.039 DYNAMIC CURSOR 50 66 1.070 INDEXED CURSOR 46 57 0.698 LINEAR CURSOR 98 123 1.327 LIST CURSOR 238 \n271 1.643 SET CURSOR 38 44 0.738 8 classes 743 893 8.662 2.53 GHz Intel Core 2 Duo with 4 GB RAM. abstract \nclass DYNAMIC CURSOR [G] inherit CURSOR [G] feature introduce abstract replace(v: G) dynamic {Cursor(ds: \nd) * d.DS(content: c1, iters: i) * d.IsOff(res: False, ref: Current, iters: i, content: c1)}{Cursor(ds: \nd) * d.DS(content: c2, iters: i) * d.Replaced(ref: Current, value: v, newcontent: c2, oldcontent: c1, \niters: i)} inherit item(): G static {Cursor(ds: d) * d.DS(content: c, iters: i) * d.IsOff(res: False, \nref: Current, iters: i, content: c)} {Cursor(ds: d) * d.DS(content: c, iters: i) * d.ItemAt(res: Result,ref: \nCurrent, iters: i, content: c)} introduce swap(other: DYNAMIC CURSOR [G]) static {Cursor(ds: d) * d.DS(content: \nc1, iters: i) * other.Cursor(ds: d) * d.IsOff(res: False, ref: Current, iters: i, content: c1) * d.IsOff(res: \nFalse, ref: other, iters: i, content: c1)} {Cursor(ds: d) * d.DS(content: c2, iters: i) * other.Cursor(ds: \nd) * d.Swapped(ref1: Current, ref2: other, iters: i, oldcontent: c1, newcontent: c2)}do v:G;w: G; v := \nitem(); w := other.item(); replace(w); replace(v) end end Figure 7. A simpli.ed extract of DYNAMIC CURSOR \ntal time taken by MultiStar is reported, which includes trans\u00adlating Eiffel code, expanding speci.cation \nshorthands and checking all proof obligations. Since iterators rely on properties of the data structures \n(containers) they traverse, we annotated the container classes with the required speci.cations. Particularly \ninteresting are the axiom clauses that iterators demand. Consider for exam\u00adple the simpli.ed extract \nof DYNAMIC CURSOR in Fig\u00adure 7. The [G] denotes that DYNAMIC CURSOR has a generic parameter G. Method \nswap takes another cursor ref\u00aderencing the same container, and additionally requires that there are data \nelements (items) at both cursor positions (the cursors are not off ). The Body veri.cation proof of swap \nuses several properties of containers that can be expressed as axioms, including the following one: . \nr1,r2,iter1,iter2,i,c1,c2,c3 \u00b7 [ItemAt(res: r1, ref: iter1, iters: i, content: c1) * ItemAt(res: r2, \nref: iter2, iters: i, content: c1) * Replaced(ref: iter1, value: r2, newcontent: c2, oldcontent: c1, \niters: i) * Replaced(ref: iter2, value: r1, newcontent: c3, oldcontent: c2, iters: i)] . Swapped(ref1: \niter1, ref2: iter2, iters: i, oldcontent: c1, newcontent: c3) This invariant property relates the ItemAt, \nReplaced and Swapped abstractions. Informally, it states that if a data structure has items r1 and r2 \nat iterators iter1 and iter2, and we replace the item at iter1 with r2 and the item at iter2 with r1, \nthen the resulting data structure has the same contents as the original one except that the items at \niter1 and iter2 have been swapped. The example involves neither multiple inheritance nor splitting of \nsuperclass and subclass state, and illustrates the generality and expressive power of axiom clauses. \nThe complete speci.cations and code of the case study are included in the download [10].  5. Formalization \nThis section contains a formal treatment of the programming language with speci.cations and its proof \nsystem. The lan\u00adguage features abstract classes and multiple inheritance. Ex\u00adport and axiom speci.cations \nare supported. The proof sys\u00adtem is based on the one of Parkinson and Bierman in [27]. For space reasons \nwe focus mostly on the new extensions. 5.1 Language syntax The grammar of our kernel language with multiple \ninheri\u00adtance and speci.cations is shown in Figure 8. A sequence of c s is denoted by c. The letters G \nand H are used for class names, p for apf names, t for tag names, w for auxiliary pred\u00adicate names, a \nfor axiom names, m for method names, and f for .eld names. Variables are denoted by u, x, y and z. Separate \nnamespaces exist for class names, p, w, a, m and f. The type system ensures absence of clashes when names \nare introduced. This precludes method overloading and .eld shadowing, for instance, and guarantees that \nmeth\u00adods or .elds with the same name in parent classes stem from common ancestors. A constructor in our \nformalization is simply an intro\u00adduced method m where m is a class name. Except for the re\u00adstriction \nthat subclasses cannot inherit or override construc\u00adtors, no special treatment is needed otherwise. To \nprovide subclasses with the opportunity to respecify a method and to simplify the proof rules that follow \nlater, we require a subclass to inherit or override explicitly all non-constructor methods present in \nits parents (in MultiStar and the examples, speci.cation shorthands are employed to achieve this). The \nshared semantics of multiple inheritance is used, which is popular in Eiffel [8] and known as inher\u00aditance \nwith virtual base classes in C++ [9]. Common an\u00ad  L ::= Ab class G inherit H de.ne D export E axiom \nA feature MF end Ab ::= abstract | E D ::= x.pG (t: y) as P De.ne clause E ::= P where {W} Export clause \nW ::= w(x)=P Where clause A ::= a: P Axiom clause M ::= introduce m(Args) Rt Sd Ss B Method declaration \n| override m(Args) Rt Sd Ss B | inherit m(Args) Rt Sd Ss | introduce abstract m(Args) Rt Sd | inherit \nabstract m(Args) Rt Sd F ::= f: Type Field declaration Sd ::= dynamic Spec Dynamic speci.cation Ss ::= \nstatic Spec Static speci.cation Spec ::= {P}{Q}|{P}{Q} also Spec Speci.cation B ::= do s end Method body \ns ::= x: Type Local variable declaration | x:=e Assignment | x:=y.f Field lookup | x.f:= e Field assignment \n| x:=y.m(e) | y.m(e) Dynamically dispatched call | x := y.G::m(e) | y.G::m(e) Direct method call | x:= \nnew G Object allocation e ::= x | e+e | e=e | Void | 0 | 1 | 2 | ... Expression Type ::= int | bool | \nG Args ::= x: Type Formal arguments Rt ::= E | : Type Return type Figure 8. The kernel language grammar. \ncestor .elds are shared, and method overriding overrides all ancestor versions. To avoid ambiguity, a \nclass can inherit a method only if its body (if there is one) is the same along all inheritance paths. \nDirect method calls can encode language mechanisms which allow a particular ancestor implementa\u00adtion \nto be chosen, so no generality is lost. We assume the formal argument names of methods stay the same \nin subclasses. This simpli.es the proof rules that follow, which would otherwise need additional substitutions. \n 5.2 Operational semantics The shared semantics of multiple inheritance ensures that 1) only dynamic \ntype information is needed at runtime (in contrast to what select clauses of Eiffel s replicated inher\u00aditance \ndemand), and 2) the usual semantics of casts can be adopted (in contrast to replicated inheritance in \nC++, where casting can change pointer values [9]). The operational semantics is therefore similar to \ne.g. Java s and omitted. Con.gurations contain a stack, a heap and a sequence of statements under execution. \nThe stack maps variables to values which include object ids. The heap maps object ids to records containing \na dynamic type G and .eld-value mappings. 5.3 Logic syntax and semantics The predicates used in speci.cations \nand proofs have the following grammar. P,Q,S, T, . ::= .x\u00b7P | P.Q | false | e=e' | x:G | x <:G | x.f \n'. e | P * Q | x.p(t: e) Apf predicate | x.pG (t: e) Apf entry | w(x) Auxiliary predicate The predicate \nx : G means x references an object whose dynamic type is exactly G, and x <: G means x references an \nobject whose dynamic type is a subtype of G. In both cases x = Void, and x : G . x <: G holds. Within \na context, if x is declared of type G then x <: G whenever x = Void. The .rst argument of an apf predicate \nor entry is written as a pre.x. For apf predicates it is never Void because of the standard apf assumptions \nneeded to produce an apf predicate from an entry (these are detailed in Section 5.10 below). Other arguments \nare tagged with names and form a set (i.e. they are order-independent), which is especially useful in \nthe multiple inheritance setting. The reader is referred to [27] for an in-depth treatment of apfs. Other \npredicates have the usual intuitionistic separation logic semantics. Informally the predicate x.f '. \ne means that the f .eld of object x has value e, and P * Q means that P and Q hold for disjoint portions \nof the heap. Readers are referred to [24, 26, 28] for a formal treatment of separation logic. Symbols \nsuch as ., \u00ac, true, ., . and . are encoded in the standard way. Every occurrence of in a predicate denotes \na fresh existentially quanti.ed variable, where the quanti.er is placed in the innermost position. FV(P) \ndenotes the free variables of P; every method precondition P must satisfy Result ./FV(P). In the rest \nof the formalization, the symbols P, Q, S and T are used for assertions and predicates, and . for assumptions. \n 5.4 Speci.cation re.nement We expand on Parkinson and Bierman s formalization of speci.cation re.nement \n[27]. If the speci.cation {P1}{Q1}is re.ned by {P2}{Q2}, then any s that satis.es {P1}{Q1}also satis.es \n{P2}{Q2}. Under the assumptions .,the speci.cation {P1}{Q1} is re.ned by {P2}{Q2} if we can prove . f{P1}{Q1} \n=.{P2}{Q2}, i.e. provide a proof tree with leaves . f{P1}{Q1} and root . f {P2}{Q2} built with the structural \nrules of separation logic (Consequence, Frame, Auxiliary Variable Elimination, Dis\u00adjunction, and others). \nIn the context of method speci.cation re.nement, . contains the standard apf assumptions of a class as \nwell as export and axiom information of all other classes, and the Consequence and Frame rules are given \nby: ..(P'.P) . f{P}{Q} ..(Q.Q') Consequence . f{P'}{Q'} . f{P}{Q} Frame . f{P * T}{Q * T} The Frame rule \nis applicable whenever Result ./FV(T), and expresses that disjoint portions of the heap stay un\u00adchanged. \n Method speci.cations can be combined with also (De.\u00adnition 1 in [27]): def {P1}{Q1} also {P2}{Q2} = \n{(P1 . x=1) . (P2 . x =1)}{(Q1 . x=1) . (Q2 . x=1)} where x denotes a fresh auxiliary variable. The speci.\u00adcations \n{P1}{Q1} and {P2}{Q2} are equivalent w.r.t. . iff both . f{P1}{Q1} =.{P2}{Q2} and . f {P2}{Q2} =.{P1}{Q1}. \nTwo speci.cations are equiv\u00adalent iff they are equivalent w.r.t. all .. It can be shown that also is \ncommutative, associative and idempotent mod\u00adulo equivalence with identity {false}{true}. The notation \nalsoi.I {Pi}{Qi} denotes the speci.cation {Pe1 }{Qe1 }also ... also {Pem }{Qem }, where e1 ...em are \nthe elements of set I. Furthermore, when I is the empty set: def alsoi.\u00d8 {Pi}{Qi} = {false}{true} It \nalways holds that . f{P}{Q} =.{false}{true}. Other useful lemmas involving also are given in Section \n5.11. Finally, we use the abbreviation Current :G . f{P1}{Q1} =.{P2}{Q2}def =. f{P1}{Q1} =.{P2 * Current \n:G}{Q2} in the formalization of the Dynamic dispatch proof obliga\u00adtion for methods in Section 5.9.  \n5.5 The speci.cation environment Most of the proof rules that follow use an environment G, which maps \naxiom and method names to their speci.cations for all classes in a program: G ::= G.a . P Axiom speci.cation \n| G.m . (x,{P}{Q}) Method dynamic speci.cation | G::m . (x,{S}{T}) Method static speci.cation | G The \nx in a speci.cation of m denote its formal argument names. G is guaranteed to be a partial function for \nwell\u00adtyped programs, and we write G(G.a) = P for G.a . P . G, G(G.m) = (x,{P}{Q})forG.m . (x,{P}{Q}) \n. G, and G(G::m) = (x,{S}{T}) for G::m . (x,{S}{T}) . G. 5.6 Export information veri.cation A class \ncan make information about itself available to other classes in an export clause. Export clauses are \nfrequently used to specify relationships between apfs or their entries, and to expose apf entry de.nitions. \nInformation can be hid\u00adden in predicates de.ned after the keyword where: the def\u00adinitions are not exported, \nso other classes must treat these predicates abstractly. Export information must be veri.ed since other \nclasses use it for reasoning. Under the predicate de.nitions follow\u00ading where, the assumptions about \na class must imply ex\u00adported information. This is captured by the following proof rule: [. . (.x1 \u00b7 w1(x1) \n. Q1) . ... . (.xn \u00b7 wn(xn) . Qn)] . P . fe P where {w1(x1)=Q1; ...; wn(xn)=Qn} Since the assumptions \nabout a class do not include as\u00adsumptions about the exact dynamic type of Current, export information \ncan be used to verify axioms and methods of other classes in a program. 5.7 Axiom veri.cation Information \nabout a class and all its subclasses can be made available in an axiom clause. This knowledge can be \nused later to verify methods. To simplify the treatment, we require that a class explicitly lists all \naxiom clauses applicable to it (in MultiStar and the examples, speci.cation shorthands achieve this). \nIn the rule for axiom veri.cation, the assumptions . include information about class G and export information \nfrom all other classes. A subclass must preserve all axioms of its parents and may re.ne the predicate \nassociated with an axiom name (the Parent consistency [P.c.] obligation). A non-abstract class must also \nshow that the predicate holds for its direct instances (the Implication [Imp.] obligation). .i . I\u00b7 G(Hi.a) \n= Qi ..j . (1..n \\ I)\u00b7 Hj.a ./dom(G) (. . P) . i.I Qi [P.c.] Ab [Imp.] =E . (. . Current :G).P .; G fa \na: PinAbG parentsH1 ...Hn  5.8 Statement veri.cation The assumptions . used to verify statements contain \ninfor\u00admation about the enclosing class as well as export and axiom information from all other classes. \nThe rules for most state\u00adments are standard (see e.g. [26, 27]). For allocation: all.elds(G) = {f1,f2,...,fn} \n.; G fs {true} x:= new G {x.f1 '.* x.f2 '.* ... * x.fn '.* x:G} where all.elds(G) denotes the set of \n.eld names listed in G and all its ancestors. Dynamically dispatched calls use the dynamic specs of methods \nin G, while direct calls use the static ones. Provided x is not y and x is not free in e, the rules for \nresult-returning calls are: G(G.m) = (u,{P}{Q}) .; G fs {P[y, e/Current, u] * y <:G}x:=y.m(e) {Q[y, e, \nx/Current, u, Result]} G(G::m) = (u,{S}{T}) .; G fs {S[y, e/Current, u] * y = Void}x := y.G::m(e) {T[y, \ne, x/Current, u, Result]} Two important structural rules here are Frame and Con\u00adsequence. The Frame rule \nis the key to local reasoning. Pro\u00advided s modi.es no variable in FV(T): .; G fs {P}s{Q} Frame .; G fs \n{P * T}s{Q * T} The rule of Consequence allows the use of assumptions .: ..(P' .P) .; G fs {P}s{Q} ..(Q.Q') \nConsequence .; G fs {P ' }s{Q ' }  5.9 Method veri.cation The rules for method veri.cation in [27] \nare extended here to the multiple inheritance case. As for statement veri.cation, the assumptions . used \nto verify method de.nitions contain information about the method s enclosing class as well as export \nand axiom information from all other classes. The rule for method introduction shown below requires no \nmodi.cation for multiple inheritance. A newly introduced method s static and dynamic speci.cations must \nbe consis\u00adtent10 if the class is non-abstract, and its body must satisfy the static speci.cation. These \ntwo requirements are captured by the Dynamic dispatch [D.d.] and Body veri.cation [B.v.] proof obligations \nrespectively. B= do s end Sd = dynamic {PG}{QG} Ss = static {SG}{TG} Current :G Ab=E . . f{SG}{TG} =.{PG}{QG} \n[D.d.] .; G fs {SG}s{TG} [B.v.] .; G fm introduce m(Args) Rt Sd Ss B in Ab G parents H An abstract method \ncan be introduced without any proof obligations, since there is only a dynamic speci.cation and no method \nbody. .; G fm introduce abstract m(Args) Rt Sd in Ab G parents H The next rule is used whenever an abstract \nmethod is im\u00adplemented or a method body is rede.ned. Consistency must be proven between the new dynamic \nspeci.cation and those in parent classes; this is embodied in the Behavioral sub\u00adtyping [B.s.] proof \nobligation. The other proof obligations are identical to those for method introduction above. The H1 \n...Hn are the immediate superclasses of G. .i . I\u00b7 G(Hi.m) = (x,{PHi}{QHi}) .j . (1..n \\ I)\u00b7 Hj.m ./dom(G) \nB= do s end Sd = dynamic {PG}{QG} Ss = static {SG}{TG} . f{PG}{QG} =. (alsoi.I {PHi}{QHi}) [B.s.] Current \n:G Ab=E . . f{SG}{TG} =.{PG}{QG} [D.d.] .; G fs {SG}s{TG} [B.v.] .; G fm override m(Args) Rt Sd Ss B \nin Ab G parents H1 ...Hn When a non-abstract method is inherited, its static spec\u00adi.cation must follow \nfrom those in parents. The Inheritance [Inh.] obligation ensures that this will be the case. The Be\u00adhavioral \nsubtyping and Dynamic dispatch obligations serve the same purposes as mentioned before. 10 We establish \nthat the dynamic speci.cation follows from the static one when the dynamic type of Current is G. If the \ndynamic type of x is G, then the body of m in G will be executed if x.m is called. The static and dynamic \nspeci.cations must be consistent with each other in this case, since the dynamic speci.cation is used \nfor reasoning about the call statement, whereas the body was veri.ed only w.r.t. the static speci.cation. \n.i . I\u00b7 G(Hi.m) = (x,{PHi}{QHi}) .k . (1..n \\ I)\u00b7 Hk.m ./dom(G) .j . J\u00b7 G(Hj::m) = (x,{SHj}{THj}) .l \n. (1..n \\ J)\u00b7 Hl::m ./dom(G) Sd = dynamic {PG}{QG} Ss = static {SG}{TG} . f{PG}{QG} =. (alsoi.I {PHi}{QHi}) \n[B.s.] . f (alsoj.J {SHj}{THj}) =.{SG}{TG} [Inh.] Current :G Ab=E . . f{SG}{TG} =.{PG}{QG} [D.d.] .; \nG fm inherit m(Args) Rt Sd Ss in Ab G parents H1 ...Hn The next rule applies whenever an abstract method \nis inherited or a non-abstract method is inherited and made abstract. Such a method has no static speci.cation, \nso only the consistency of its dynamic speci.cation w.r.t. those in parent classes is required with the \nBehavioral subtyping proof obligation. .i . I\u00b7 G(Hi.m) = (x,{PHi}{QHi}) .j . (1..n \\ I)\u00b7 Hj.m ./dom(G) \nSd = dynamic {PG}{QG} . f{PG}{QG} =. (alsoi.I {PHi}{QHi}) [B.s.] .; G fm inherit abstract m(Args) Rt \nSd in Ab G parents H1 ...Hn  5.10 Class and program veri.cation For class veri.cation, different assumptions \nare used to verify the various class sections. The formula .AP F con\u00adtains class-speci.c information \nand is used to verify export clauses. The assumptions .E contain export information from all classes, \nand are used together with .AP F to verify axioms. The formula .A contains axiom information of all classes, \nand is used with .AP F and .E in method de.nition veri.cation. .Ei . E \u00b7 .AP F fe Ei .Ai . A \u00b7 (.AP F \n. .E ); G fa Ai in Ab G parents H .Mi . M \u00b7 (.AP F . .E . .A); G fm Mi in Ab G parents H .AP F , .E , \n.A;G fc Ab class G inherit H de.ne D export E axiom A feature MF end Finally, here is the rule for program \nveri.cation: .i . 1..n\u00b7 Li = ... class Gi ... export Ei axiom Ai feature ... end .E = exportinfo(Eik \n) i.1..n .Ei Eik .A = .Ai axiominfo(Gi,Aik ) i.1..n Aik G = specs(L1 ...Ln) .i . 1..n\u00b7 apf (Li), .E , \n.A;G fc Li .E . .A;G fs {true}s{true} fp L1 ...Ln s exportinfo(P where ...) def P = def axiominfo(G, \na: P) = .x <:G \u00b7 P[x/Current], where x is fresh. Predicate de.nitions following the where keyword are \nhidden by exportinfo, and the de.nition of axiominfo re.ects the fact that subclasses preserve axioms. \nThe function apf translates the abstract predicate family de.nitions of a class into a formula its standard \napf as\u00adsumptions. It is adapted from [27] for tagged arguments:  def apf (Ab class G... de.ne D1 D2 \n...Dn export ... end) = apf G(D1) . ... . apf G(Dn) def apf G(x.pG (Y) as P) = FtoE(p,G,Y) . EtoD(x.pG \n(Y) as P) . (.x <: G \u00b7 TR(p,x,Y)) def FtoE(p,G,t: y) = .x,y\u00b7 x:G . [x.p(t: y) . x.pG (t: y)] EtoD(x.pG \n(t: y) as P) def = .x,y\u00b7 x.pG (t: y) . P def TR(p,x,t: y) = +t '' .y ' \u00b7 x.p(t ' :y ') . x.p(t ' :y \n' : ) t.:y. +t..:y.. = t:y MultiStar and the examples assume that every class im\u00adplicitly exports tag \nreduction information. In other words, for every entry (x.pG(Y) as P) in the de.ne section of a class \nG, (.x <: G \u00b7 TR(p,x,Y) where {}) is implicitly exported. Theorem. The program veri.cation rule is sound. \n(The proof, sketched in the Appendix, depends on the layered as\u00adsumption structure of export and axiom \nclauses that avoids circularity in reasoning11.)  5.11 Useful lemmas Lemmas 1 and 2 are frequently used \nin proofs of Behavioral Subtyping and Inheritance: Lemma 1. . f (alsoi.I {Pi}{Qi}) =.{Pk}{Qk} for all \nk . I. Lemma 2. If . f{P}{Q} =.{Si}{Ti} for all i . I, then . f{P}{Q} =. (alsoi.I {Si}{Ti}). For Body \nVeri.cation: Lemma 3. If .; G fs {Si}s{Ti} for all i . I, then under assumptions . and G, s satis.es \n(alsoi.I {Si}{Ti}).  6. Conclusions and related work The presented proof system supports two complementary \nmechanisms that can express relationships between abstrac\u00adtions in the logic. Such relationships are \npervasive in O-O programs, and facilitate .exible client reasoning, access con\u00adtrol, speci.cation inference, \nand constraints on the imple\u00admentation of abstractions. Moreover, the system offers a sound way to verify \nvarious forms and uses of shared multi\u00adple inheritance. By virtue of extending Parkinson and Bier\u00adman \ns system, the examples in [27] illustrate that it can also deal with behavior extension, restriction \nand modi.cation, as well as representation replacement in subclasses. It is mod\u00adular and every method \nbody is veri.ed only once. MultiStar implements these features in an automatic tool that, as the Gobo \ncase study shows, holds good promise for verifying real-world software. 11 The layered assumption structure \ndoes not rule out axioms that depend on other axioms. If we want an axiom Q in class C2 that depends \non axiom P in class C1, we can write the axiom (.x <: C1\u00b7 P[x/Current]) . Q in class C2 instead, where \nx is a fresh variable. After axiom veri.cation, method and statement veri.cation can use (.y <: C2\u00b7 Q[y/Current]) \nwhere y is fresh. The proof system enables the speci.cation and veri.cation of invariants for aggregate \nstructures involving multiple objects of different types. We are not aware of any other proof system \nor tool that can verify our examples and case study. Nevertheless, there are many relationships with \nother work: Axiom clauses We do not know of any existing speci.ca\u00adtion mechanisms that are closely related \nto axiom clauses. Class invariants form the basis of several O-O speci.\u00adcation and veri.cation approaches, \nincluding Spec# [1] and JML [19]. Two main .avors of class invariants exist: private invariants, as exempli.ed \nby the object invariants of Spec#, and public invariants [18], which include JML s derived in\u00advariants \nand the invariants of Jacobs and Piessens for de\u00adscribing relationships between inspector methods [12]. \nClass invariants, like axiom clauses, constrain subclasses. How\u00adever, there are several important differences \nbetween them. Class invariants either de.ne exactly when an object is con\u00adsistent (private invariants), \nor describe abstract properties of consistent objects (public invariants). Axiom clauses have no notion \nof object consistency. Class invariants are expected to hold at particular points in a program and may \nbe broken at others, according to the employed invariant protocol [7]. Axiom clauses are true invariants \nin the sense that they hold everywhere. The relationships they describe cannot be vio\u00adlated by assignment \nstatements, and hence there are no prob\u00adlems with e.g. method callbacks [20, 21]. Class invariants are \nexpressed in terms of .elds (including model .elds) and pure method calls. Public invariants constrain \noperations that must establish or preserve them. Private invariants constrain the pure methods they use \nand indirectly also other oper\u00adations by depending on the private invariant. Axioms are expressed as \nlogical predicates, and they constrain logical abstractions of data. The veri.cation of class invariants \nin\u00advolves the inspection of method bodies (private invariants for the proof obligations see e.g. [22]), \nor private invariants and the speci.cations and/or bodies of pure methods (public invariants). Axiom \nclauses are veri.ed prior to methods and do not depend on methods in any way. The main differences between \nclass invariants and axiom clauses are summarized in Table 2. Export clauses There is some correspondence \nbetween the class axioms of Kassios [15, 16] and apfs/export clauses. Class axioms can be used to axiomatize \nthe speci.cation and program attributes of a class. In a class implementation, class axioms typically \ndescribe abstract state (represented by speci.cation attributes) as a function of the concrete im\u00adplementation \nstate (represented by program attributes). This corresponds loosely to the way apf entry de.nitions relate \nthe concrete state to apf arguments. Furthermore, class ax\u00adioms can describe consequences of a speci.cation \nattribute such as a class invariant, which typically include framing properties and relationships between \nother speci.cation at\u00adtributes. This corresponds somewhat to export clauses that describe properties \nof apf arguments or relationships be\u00adtween them. The framework of class axioms does not in\u00adclude inheritance, \nso despite the similar names, it is best to  Class invariants Axiom clauses Related to object consistency \nHold at particular program points Expressed i.t.o. .elds and pure method calls Constrain operations Veri.cation \ninvolves methods No notion of object consistency Hold everywhere Expressed as logical predicates Constrain \nlogical abstractions of data Veri.cation cannot involve methods Table 2. The main differences between \nclass invariants and axiom clauses. compare them with export and not axiom clauses. Class ax\u00adioms can \nalso de.ne method speci.cations/implementations, which apfs and export clauses are incapable of. In jStar \n[5], the modi.er export can be added to an apf entry de.nition to expose it to all other classes. Even \nthough our export clauses are more general and .exible than this mechanism, MultiStar supports it as \na useful shorthand. The rules for lossless casting by Chin et al. [4] describe relationships between \npredicates that provide full and par\u00adtial views of objects. A view predicate describes the con\u00adtents \nof the .elds of an object directly: a full view of object o provides full knowledge of all o s .elds, \nwhile a partial view with respect to class C describes only values of .elds introduced by C and its ancestors. \nView predicates and re\u00adlationships between them are generated automatically. The relationships do not \nhave to be veri.ed and do not constrain subclasses. Krishnaswami et al. use so-called static speci.cations \nin [17] to specify relationships between abstract predicates. Although not presented in an O-O context, \nthese relation\u00adships must be satis.ed by implementations and are thus re\u00adlated to our export clauses. \nThe lemma functions of VeriFast [13] record proofs of relationships between predicates. The relationships \nare then used in reasoning; the proof of the Composite pattern in [14] provides a good example. Lemma \nfunctions, like export clauses, do not constrain subclasses. Multiple inheritance Surprisingly few systems \nexist for reasoning about multiple inheritance. The system in [23] also uses separation logic, but without \nabstraction mecha\u00adnisms such as apfs. Most of the paper is devoted to elemen\u00adtary separation logic proof \nrules that also apply in a single\u00adinheritance context. Diamond inheritance is never treated, and the \nbodies of inherited methods are reveri.ed in sub\u00adclasses. The focus of [6] is on behavioral subtyping. \nIt proposes to verify behavioral subtyping of methods lazily, i.e. only to the extent demanded by client \ncode. Supplier code is then continually re-veri.ed as a client s use of it grows. The restricted form \nof interface inheritance is easily han\u00addled by our proof system: an interface is simply an ab\u00adstract \nclass with only abstract methods and no .elds. Many veri.cation tools for object-oriented programs, including \nSpec# [1] and the JML toolset [2], provide support for spec\u00adifying and verifying interface inheritance. \nBoth Spec# and JML use pure expressions of the programming language for speci.cation, and follow a class \ninvariant-based approach to veri.cation.  A. Proof system semantics An outline of the semantics and \nsoundness proof follows. Our system s semantics is similar to that of Parkinson and Bierman s system \nin [27]. The most interesting difference is the treatment of export and axiom information in the soundness \nproof of the program veri.cation rule (Theorem 11 below). The semantics of the logical formula is de.ned \nin terms of a state s, an interpretation of predicate symbols I, and an interpretation of logical variables \nL. The interpretation I maps predicate names to their de.nitions, whereas a de.ni\u00adtion maps a list of \narguments to a set of states: I : Preds . (Vals * .P(S)) L : Vars . Vals Predicates are de.ned in the \nstandard way: s, I, L|= pred(X) . s . (I(pred)(L(X))) De.nition 4. I|=. iff s, I, L|=. for all s and \nL. Under mild syntactic restrictions, obeyed in this paper and detailed in [26], one can show that every \nset of disjoint predicate de.nitions is satis.able: Lemma 5. For any set of de.nitions W1,...Wm,D1,...Dn \nwhere Wi has form wi(xi)=Qi and Dj is listed in class Gj, there exists an interpretation I such that \nI|= [..xi \u00b7 .i.1..m wi(xi) . Qi] . [apf Gj (Dj)] provided that no two j.1..n distinct de.nitions in the \nset de.ne the same predicate. The semantics of our proof system s judgements is de\u00ad.ned next. We do not \nde.ne the semantics of fe and fa explicitly, since we work with their premises (valid logical formulae \nwhose existence is guaranteed) instead. For triples, the usual partial-correctness semantics for separation \nlogic is used: if the precondition holds in the start state, then 1) the statements will not fault (access \nunallocated memory, for ex\u00adample), and 2) if the statements terminate, then the postcon\u00addition holds \nin the resulting state. De.nition 6. I|= n {P}s{Q} iff whenever s, I, L|= P then .m = n\u00b7  1. s,s -.m \nfault does not hold, and 2. if s,s -.m s',E then s', I, L|= Q  The index n deals with mutual recursion \nin method de.\u00adnitions. I|= n G means that all methods in G meet their spec\u00adi.cations when executed for \nup to n steps. De.nition 7 (Method veri.cation semantics). If m in G is non-abstract, let s denote its \nbody. I, G |= 0 G.m . (x,{P}{Q}) always holds. I, G |= n+1 G.m . (x,{P}{Q})iff I|= n G .I|= n+1 {P * \nCurrent :G}s{Q} if G is non-abstract and true otherwise. I, G |= 0 G::m . (x,{S}{T}) always holds. I, \nG |= n+1 G::m . (x,{S}{T})iff I|= n G .I|= n+1 {S}s{T} I|= n G iff .methodspec . G\u00b7I, G |= n methodspec \nWe next de.ne the semantics of the statement judgement. De.nition 8. .; G |= {P}s{Q} iff for all I and \nn, if I|=. and I|= n G, then I|= n+1 {P}s{Q} In other words, for all interpretations which satisfy the \nassumptions ., if all methods in G meet their speci.cations for up to n steps, then s meets its speci.cation \nfor up to n + 1 steps. The judgements are sound with respect to their semantics. Lemma 9. 1. If .; G \nfm ...m ..., then .I\u00b7 if I|=. then for all n and every spec of m we have I, G |= n spec 2. If .; G fs \n{P}s{Q} then .; G |= {P}s{Q} Whenever a judgement is derivable under weak assump\u00adtions, it can also be \nderived under stronger ones. Lemma 10. 1. If .; G fm ...m ...and .' . ., then .'; G fm ...m ... 2. If \n.; G fs {P}s{Q} and .' . ., then .'; G fs {P}s{Q} 3. If .AP F , .E , .A;G fc L and .' . .AP F , then \n.', .E, .A;G fc L  Finally, here is the soundness statement and detailed proof sketch of the program \nveri.cation rule. Theorem 11. If a program and its main body s can be proved with the program veri.cation \nrule, then .I,n\u00b7I|= n {true}s{true}. Proof. 1. The goal. We have to prove .I,n\u00b7I|= n {true}s{true}, \nwhich abbreviates .I,n\u00b7 whenever s, I, L|= true, then .m = n\u00b7 1) s,s -.m fault does not hold, and 2) \nif s,s -.m s',E then s', I, L|= true. This can be simpli.ed to .n\u00b7 s,s -.n fault does not hold. def . \n2. Strengthened assumptions.Let .T = apf (Li), i.1..t where L1 ...Lt are all classes in the program. \nBy Lemma 10, we can strengthen the assumptions under which all classes and the main body have been veri.ed. \nFor every class Li,wehave .T , .E, .A; G fc Li, and .T ..E . .A; G fs {true}s{true} also holds for the \nmain body s. 3. The interpretation I'. Since .T . .E . .A; G fs {true}s{true}, Lemma 9 guarantees .T \n. .E . .A; G |= {true}s{true}. This abbreviates .I,n\u00b7 if I|= .T ..E ..A and I|= n G, then I|= n+1 {true}s{true}, \nwhich can be simpli.ed to .I,n\u00b7 if I|=.T . .E . .A and I|= n G, then .m = n+1\u00b7 s,s -.m fault does not \nhold. Now if we can .nd an I' such that I' |= .T . .E . .A and .n\u00b7I' |= n G, then we can instantiate \nI to I' in the formula and simplify to obtain .n\u00b7 s,s -.n fault does not hold. Therefore I' serves as \na witness that s will never fault, which is exactly our goal. Let I' be the interpretation whose existence \nis guaranteed by Lemma 5 for all the where and de.ne clauses in the program. Clearly I' |=.T . We next \nprove I' |=.E and then I' |=.A. 4. Satis.ability of .E . Consider an arbitrary export clause E=P where \n{w1(x1)=Q1; ...; wn(xn)=Q.n} in class  L. Since apf (L) fe E, we know [apf (L) . (.xi i.1..n \u00b7 wi(xi) \n. Qi)] . P. The interpretation I' satis.es the antecedent, so we also have I' |= P. Therefore I' |=.E \n, and I' |=.T . .E. 5. Satis.ability of .A. We prove this by induction. If class G has children H1 ...Hk,let \nlevel(G) def 1 + max(0, = level(H1), ..., level(Hk)). Furthermore, P(n) def . Gin = the program such \nthat level(G) = n and for all axiom clauses a: P in the listing of G, (.T . .E) . axiom\u00adinfo(G, a: P). \nBase case. Consider an arbitrary class G with level(G) = 1 and an axiom clause a: P appearing in it. \nG has no subclasses, and (a) If G is abstract, there are no objects with dynamic type G or a subtype \nthereof, thus axiominfo(G, a: P) holds vacuously and .T . .E implies it. (b) If G is non-abstract, then \nthe only objects whose dynamic type is a subtype of G are direct instances of G. Since (.T . .E . Current \n: G) . Pby the Implication premise, we therefore also know (.T . .E) . axiominfo(G, a: P).  Thus P(1) \nholds. Step case. Suppose P(n) holds. Now consider a class G at level n+1 with axiom clause a: P. Every \nchild H of G must list a, say a: Q. By the induction hypothesis we know (.T ..E) . axiominfo(H, a: Q), \nand by the Parent Consistency premise of a: Q we know (.T . .E . Q) . P. Therefore (.T ..E) . axiominfo(H, \na: P). We have (.T ..E) . axiominfo(G,a:P)ifGis abstract, and the same holds if G is non-abstract since \nthe Implication premise of a: P guarantees (.T ..E .  Current : G) . P. Thus P(n+1) holds. ' So I|=.T \n. .E . .A. ' 6. Wrapping up. We still have to prove .n\u00b7I |= n G. Let m be an arbitrary method in the \nprogram. Since .T . .E . .A; G fm m, by Lemma 9 we know for ' all n and every spec of m that I , G |= \nn spec. Thus ' .n \u00b7.methodspec . G\u00b7I , G |= n methodspec, in other ' words .n\u00b7I |= n G. .  Acknowledgments \nSpecial thanks to Matthew Parkinson, Peter O Hearn, Bertrand Meyer, Sebastian Nanz, Carlo Furia and Martin \nNordio for feedback on early versions of this work. Matthew Parkinson also helped with the implementation \nof MultiStar s back\u00adend. Van Staden is supported by ETH Research Grant ETH\u00ad15 10-1. Calcagno is partially \nfunded by EPSRC.  References [1] M.Barnett,K.R.M.Leino,andW.Schulte. TheSpec# programming system: An \noverview. In CASSIS 05, volume 3362 of LNCS, pages 49 69. Springer, 2005. [2] L. Burdy, Y. Cheon, D. \nR. Cok, M. D. Ernst, J. R. Kiniry, G. T. Leavens, K. R. M. Leino, and E. Poll. An overview of JML tools \nand applications. International Journal on Software Tools for Technology Transfer (STTT), 7(3):212 232, \n2005. [3] L. Cardelli. A semantics of multiple inheritance. Inf. Comput., 76(2-3):138 164, 1988. [4] \nW.-N. Chin, C. David, H. H. Nguyen, and S. Qin. Enhancing modular OO veri.cation with separation logic. \nIn POPL 08: Proceedings of the 35th annual ACM SIGPLAN-SIGACT symposium on Principles of programming \nlanguages, pages 87 99, New York, NY, USA, 2008. ACM. [5] D. Distefano and M. J. Parkinson J. jStar: \ntowards practical veri.cation for Java. In OOPSLA 08: Proceedings of the 23rd ACM SIGPLAN conference \non Object-oriented programming systems languages and applications, pages 213 226, New York, NY, USA, \n2008. ACM. [6] J. Dovland, E. B. Johnsen, O. Owe, and M. Steffen. Incre\u00admental reasoning for multiple \ninheritance. In IFM 09, pages 215 230, Berlin, Heidelberg, 2009. Springer. [7] S. Drossopoulou, A. Francalanza, \nP. M\u00a8uller, and A. J. Sum\u00admers. A uni.ed framework for veri.cation techniques for ob\u00adject invariants. \nIn J. Vitek, editor, ECOOP, volume 5142 of LNCS, pages 412 437. Springer, 2008. [8] ECMA International. \nStandard ECMA-367. Eiffel: Analysis, Design and Programming Language. 2nd edition, June 2006. [9] M. \nA. Ellis and B. Stroustrup. The annotated C++ refer\u00adence manual. Addison-Wesley Longman Publishing Co., \nInc., Boston, MA, USA, 1990. [10] EVE. The Eiffel Veri.cation Environment. http://eve. origo.ethz.ch/. \n[11] Gobosoft. The Gobo Eiffel Structure Library. http://www. gobosoft.com/eiffel/gobo/structure/index.html. \n[12] B. Jacobs and F. Piessens. Inspector methods for state abstrac\u00adtion. Journal of Object Technology, \n6(5):55 75, June 2007. [13] B. Jacobs and F. Piessens. The VeriFast program veri.er. Technical Report \nCW-520, Katholieke Universiteit Leuven, August 2008. [14] B. Jacobs, J. Smans, and F. Piessens. Verifying \nthe composite pattern using separation logic. SAVCBS Composite pattern challenge track, 2008. [15] I. \nT. Kassios. Dynamic frames: Support for framing, depen\u00addencies and sharing without restrictions. In J. \nMisra, T. Nip\u00adkow, and E. Sekerinski, editors, FM, volume 4085 of LNCS, pages 268 283. Springer, 2006. \n[16] I. T. Kassios. The dynamic frames theory. Formal Aspects of Computing, 2010. To appear. [17] N. \nR. Krishnaswami, L. Birkedal, J. Aldrich, and J. C. Reynolds. Idealized ML and Its Separation Logic. \nDraft available online at http://www.cs.cmu.edu/~neelk/ idealized-ml-draft.pdf. 2006. [18] G. T. Leavens \nand P. M\u00a8uller. Information hiding and visibility in interface speci.cations. In ICSE, pages 385 395. \nIEEE Computer Society, 2007. [19] G. T. Leavens, A. L. Baker, and C. Ruby. Preliminary design of JML: \na behavioral interface speci.cation language for Java. SIGSOFT Softw. Eng. Notes, 31(3):1 38, 2006. [20] \nG. T. Leavens, K. R. M. Leino, and P. M\u00a8uller. Speci.cation and veri.cation challenges for sequential \nobject-oriented pro\u00adgrams. Formal Aspects of Computing, 19(2):159 189, 2007. [21] K. R. M. Leino and \nP. M\u00a8uller. Object invariants in dynamic contexts. In M. Odersky, editor, ECOOP, volume 3086 of LNCS, \npages 491 516. Springer, 2004. [22] K. R. M. Leino and W. Schulte. A verifying compiler for a multi-threaded \nobject-oriented language. Software System Reliability and Security, 9:351 416, 2007. [23] C. Luo and \nS. Qin. Separation logic for multiple inheritance. Electr. Notes Theor. Comput. Sci., 212:27 40, 2008. \n[24] P. W. O Hearn, J. C. Reynolds, and H. Yang. Local reasoning about programs that alter data structures. \nIn CSL 01, volume 2142 of LNCS, pages 1 19. Springer, 2001. [25] M. Parkinson and G. Bierman. Separation \nlogic and abstrac\u00adtion. In POPL 05: Proceedings of the 32nd annual ACM SIGPLAN-SIGACT symposium on Principles \nof programming languages, pages 247 258, New York, NY, USA, 2005. ACM. [26] M. J. Parkinson. Local reasoning \nfor Java. PhD thesis. Tech\u00adnical Report UCAM-CL-TR-654, University of Cambridge, Computer Laboratory, \nNovember 2005. [27] M. J. Parkinson and G. M. Bierman. Separation logic, abstrac\u00adtion and inheritance. \nIn POPL 08: Proceedings of the 35th annual ACM SIGPLAN-SIGACT symposium on Principles of programming \nlanguages, pages 75 86, New York, NY, USA, 2008. ACM. [28] J. C. Reynolds. Separation logic: A logic \nfor shared mutable data structures. In LICS 02: Proceedings of the 17th Annual IEEE Symposium on Logic \nin Computer Science, pages 55 74, Washington, DC, USA, 2002. IEEE Computer Society.  \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Encapsulated abstractions are fundamental in object-oriented programming. A single class may employ multiple abstractions to achieve its purpose. Such abstractions are often related and combined in disciplined ways. This paper explores ways to express, verify and rely on logical relationships between abstractions. It introduces two general specification mechanisms: <i>export clauses</i> for relating abstractions in individual classes, and <i>axiom clauses</i> for relating abstractions in a class and all its descendants. MultiStar, an automatic verification tool based on separation logic and abstract predicate families, implements these mechanisms in a multiple inheritance setting. Several verified examples illustrate MultiStar's underlying logic. To demonstrate the flexibility of our approach, we also used MultiStar to verify the core iterator hierarchy of a popular data structure library.</p>", "authors": [{"name": "Stephan van Staden", "author_profile_id": "81470654292", "affiliation": "ETH Zurich, Zurich, Switzerland", "person_id": "P2354096", "email_address": "", "orcid_id": ""}, {"name": "Cristiano Calcagno", "author_profile_id": "81100047402", "affiliation": "Imperial College, London and Monoidics Ltd, London, United Kingdom", "person_id": "P2354097", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869501", "year": "2010", "article_id": "1869501", "conference": "OOPSLA", "title": "Reasoning about multiple related abstractions with MultiStar", "url": "http://dl.acm.org/citation.cfm?id=1869501"}