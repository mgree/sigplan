{"article_publication_date": "10-17-2010", "fulltext": "\n The Two-State Solution Native and Serializable Continuations Accord Jay A. McCarthy PLT Computer Science \nDepartment Brigham Young University Provo, UT, USA jay@cs.byu.edu Abstract Continuation-based Web servers \nprovide advantages over traditional Web application development through the in\u00adcrease of expressive power \nthey allow. This leads to fewer errors and more productivity for the programmers that adopt them. Unfortunately, \nexisting implementation techniques force a hard choice between scalability and expressiveness. Our technique \nallows a smoother path to scalable, continuation\u00adbased Web programs. We present a modular program trans\u00adformation \nthat allows scalable Web applications to use third-party, higher-order libraries with higher-order argu\u00adments \nthat cause Web interaction. Consequently, our system provides existing Web applications with more scalability \nthrough signi.cantly less memory use than the traditional technique. Categories and Subject Descriptors \nD.3.3 [Language Constructs and Features]: Control structures General Terms Languages, Performance, Theory \nKeywords Delimited Continuations, Stack Inspection, Web Applications 1. Introduction Web computations \nare described by the capture and resump\u00adtion of continuations on the Web server. This is accepted wisdom \nnow in the functional programming community (Hughes 2000; Queinnec 2000; Graham 2001). Furthermore, it \nis the theoretical basis for many practical Web application development frameworks (Matthews et al. 2004; \nDucasse Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA/SPLASH \n10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright &#38;#169; 2010 ACM 978-1-4503-0203-6/10/10. \n. . $10.00 et al. 2004; Pettyjohn et al. 2005; Thiemann 2006; Cooper et al. 2006; Krishnamurthi et al. \n2007; McCarthy 2009). Unfortunately, these frameworks rely on techniques that force users to make all-or-nothing \ntrade-offs between pro\u00adgram expressiveness and industrial scalability. Whole pro\u00adgram compilers achieve \nscalability but sacri.ce interaction with third-party libraries (Matthews et al. 2004; Cooper et al. \n2006). Modular compilation techniques (Pettyjohn et al. 2005; McCarthy 2009) achieve scalability but \nsacri\u00ad.ce higher-order interaction with third-party libraries. First\u00adclass continuation-based Web servers \n(Ducasse et al. 2004; Krishnamurthi et al. 2007) do not achieve scalability (Welsh and Gurnell 2007), \nbut do not sacri.ce any expressiveness. Worse still, each of these techniques must essentially be used \nin isolation; it is not possible to gradually control the trade-off between expressiveness and scalability. \nWe present an implementation technique, and its formal model, that allows controlled scalability for \nWeb applica\u00adtions that use higher-order third-party libraries and total scal\u00adability for those that do \nnot use these libraries. This allows Web applications written using our system to use drastically less \nmemory than before without sacri.cing expressiveness.  2. Background The central problem of Web application \nimplementation is caused by the statelessness of HTTP: when the server re\u00adsponds to a client s request, \nthe connection is closed and the server program exits. If the client needs to communicate with the server \nprogram, its next request must contain enough in\u00adformation to resume the computation. All Web programmers \nunderstand this problem, but func\u00adtional programmers understand that this resumption infor\u00admation is \nthe continuation. This is easily demonstrated by porting a small application from the command-line to \nthe Web.1 1 All program examples are written in Racket (Flatt and PLT June 7, 2010). (de.ne (get-number \ni) (prompt \"Please provide number # a:\\n\" (add1 i))) (de.ne (sum how-many) (de.ne the-sum (num-sum (build-list \nhow-many get-number))) (printf \"Sum of a is a.\\n\" how-many the-sum)) The program sum, when given an integer, \nrequests that many numbers from the user and returns their sum. When the user is providing the third \nof four numbers, the continuation is (de.ne the-sum (num-sum (list* 42 1830 [] (build-list 1 get-number)))) \n(printf \"Sum of a is a.\\n\" 4 the-sum) where [] represents the hole. This is the continuation that must \nbe captured and given to the client in a Web application version to resume the computation appropriately. \nTraditional Web programmers manually produce code that makes this continuation explicit, and many whole \npro\u00ad (de.ne (sum how-many) (de.ne the-sum (num-sum (build-list how-many get-number))) (format \"Sum of \na is a.\\n\" how-many the-sum)) This is possible because web-prompt captures the precise continuation that \nresumes the computation when the user s input is available. Unfortunately, .rst-class continuation\u00adbased \nWeb application frameworks have much worse scala\u00adbility properties than other approaches (see Welsh and \nGur\u00adnell (2007) for an anecdote.) The heart of the problem is that in many languages, espe\u00adcially those \nthat mix a high-level language with a C-based infrastructure, continuation serialization is simply not \nex\u00adpressible2. Thus native continuations are typically stored in the server s memory and the client is \nprovided with a unique identi.er for each continuation. These continuations are per\u00adsession server state \nand their unique identi.ers are new GC roots. Because there is no sound way to reclaim these con\u00adtinuations, \nthey must be retained inde.nitely or unsoundly deleted. gram transformation-based Web application frameworks \n(Matthews Luckily, there is at least one more functional implementa\u00ad et al. 2004) automatically compile \ncode that represents this continuation. Both the programmers and the tools produce code like: (de.ne \n(get-number/k i k) (web-prompt k \"Please provide number # a:\\n\" (add1 i))) (de.ne (got-numbers how-many \nl) (num-sum/k l (make-kont got-sum (list (cons how-many how-many))))) (de.ne (got-sum how-many sum) (format \n\"Sum of a is a.\\n\" how-many sum)) (de.ne (sum how-many) (build-list/k how-many get-number/k (make-kont \ngot-numbers (list (cons how-many how-many))))) This code is striking because the third-party libraries \nnum-sum and build-list must be rewritten to be in continuation\u00adpassing style (CPS) (Fischer 1972) in \nthe form of the new functions num-sum/k and build-list/k. This is only accept\u00adable when all the source \ncode for the application is available for programmer rewriting or compiler transformation. In contrast, \nmost .rst-class continuation-based Web ap\u00adplication frameworks support the original program with only \nsmall modi.cations. The Racket Web Server (Krishnamurthi et al. 2007) version is almost identical to \nthe original: (de.ne (get-number i) ( web-prompt \"Please provide number # a:\\n\" (add1 i))) tion strategy \nfor continuation-based Web applications: mod\u00adular program transformation based on continuation marks \n(Pettyjohn et al. 2005; McCarthy 2009). These work by transforming part of the code to duplicate the \ncontinua\u00adtion components (stack frames) into continuation marks (Clements et al. 2001). Continuation \nmarks are a general\u00adization of the stack inspection found in other languages (for example, Java security \nthrough stack inspection or excep\u00adtion handling). By copying the continuation into the marks, the continuation \ncan be extracted when user interaction is required and there is representation freedom, so they can be \nserialized to the client. Unfortunately, this strategy relies on the insertion of marks during the entire \ncontext up to continuation capture. The implication of this is that continuations can only be cap\u00adtured \nin transformed contexts, such as during the evaluation of higher-order arguments to higher-order third-party \nlibrary functions. Our example does this in the call to build-list,so if we use the mark-based serialization \nstrategy we would need to reimplement build-list to expose it to the transformation. Our code is close \nto the original version: (de.ne (get-number i) ( web-prompt \"Please provide number # a:\\n\" (add1 i))) \n(de.ne (sum how-many) (de.ne the-sum (num-sum ( my-build-list how-many get-number))) (format \"Sum of \na is a.\\n\" how-many the-sum)) 2 Of course, some systems (Cejtin et al. 1995) do support native continua\u00adtion \nserialization. Given that so many system do not allow this, our work is widely applicable.  Strategy \nScalable Automated num-sum Unchanged build-list Unchanged Manual Yes Yes CPS Yes Yes First-Class Yes \nYes Yes Modular Yes Yes Yes Two-State Yes Yes Yes Yes Table 1. Web Application Implementation Options \nCompared to whole-program transformations, this strat\u00adegy is a win because only build-list needs a reimplementa\u00adtion \n(my-build-list), not num-sum. At this point we have exhausted existing implementation choices. Our options \nare depicted in Table 1. Obviously we need a strategy that is scalable and automated, and does not require \nus to rewrite any third-party libraries. We present such an implementation technique. In the end, our \nprogram will look like: (de.ne (get-number i) (native.serial (web-prompt \"Please provide number # a:\\n\" \n(add1 i)))) (de.ne (sum how-many) (de.ne the-sum (num-sum (serial.native (build-list how-many get-number)))) \n(format \"Sum of a is a.\\n\" how-many the-sum)) Intuitively, we use delimited continuations to capture \nthe native continuations that the mark-based serializable con\u00adtinuations cannot capture. The functions \nserial.native and native.serial correspond, respectively, to with-continuation\u00adpromp and call-with-delimited-continuation. \nThus, we use two different kinds of state: server-side state for the small native delimited continuations \nand client\u00adside state for the larger serializable continuations. Our two\u00adstate solution is much more \nscalable than the .rst-class con\u00adtinuation approach and only slightly worse than the modular approach. \nIt provides an essential way point between native (.rst-class) continuations and serializable (modular) \ncontin\u00aduations for developers to use when reimplementation and re\u00adcompilation is not possible or is otherwise \nprohibitive.  3. Intuition Our implementation can be seen as an extension to our prior work on modular \nserializable continuations (McCarthy 2009); however, the essence is captured by an extension to the work \nthat our work was based on: the Pettyjohn et al. (2005) transformation. Therefore, we will present our \nintu\u00adition and formalism in that context, even though the actual implementation supports our continuation \nmark extensions. The Pettyjohn et al. (2005) transformation relies on the modular A-Normal Form (ANF) \ntransformation to name con\u00adtinuation components (Flanagan et al. 2004) and stack in\u00adspection through \ncontinuation marks to provide the captur\u00ading part of call/cc. ANF is a canonical form that requires all \nfunction argu\u00adments to be named. This has the implication that the en\u00adtire program is a set of nested \nlet expressions with simple function calls for bodies. If the lets are expanded into .s, then the continuation \nof every expression is syntactically ob\u00advious. Any expression can be modularly transformed into ANF without \nmodifying the rest of the program in contrast to na\u00a8ive CPS. Many programming languages and environments \nal\u00adlow access to the run-time stack in one way or another. Examples include Java security through stack \ninspection, privileged access for debuggers in .NET, and exception handlers in many languages. An abstraction \nof all these mechanisms is provided by Racket in continuation marks (Clements et al. 2001). Using the \nwith-continuation-mark (w-c-m) language form, a developer can attach values to the control stack. Later, \nthe stack-walking primitive current\u00adcontinuation-marks (c-c-m) can retrieve those values from the stack. \nContinuation marks are parameterized by keys and do not interfere with Racket s tail-call optimization. \nThese two mechanisms allow marks to be used without interfering with existing code. A pedagogic example \nof continuation mark usage is pre\u00adsented in Figure 1. fact is the factorial function with instru\u00admentation \nusing continuation marks: w-c-m records function arguments on the stack with the fact mark, even function \nar\u00adguments on the stack with the even mark, and c-c-m collects both mark values in the base case. In \nthe result of c-c-m stack frames that have no even mark are recorded as #f to ensure that the relation \non the stack between the different marks is discernible. fact-tr is a tail-recursive version of factorial \nthat appears to be an identical usage of continuation marks, but because they preserve tail-calling space \nusage, the interme\u00addiate marks are overwritten, leaving only the .nal mark for fact and the only mark \nfor even. The main insight of Pettyjohn et al. (2005) was that c-c-m can capture the continuation, just \nlike call/cc,if the com\u00adponents of the continuation are installed via w-c-m.Their transformation does \nthis by duplicating the continuation into  (de.ne-syntax-rule (mark-if-even n e) (if (even? n) (w-c-m \neven ne) e)) (de.ne (fact n) (if (zero? n) (begin (display (c-c-m fact even)) 1) (mark-if-even n (w-c-m \nfact n (* n (fact (sub1 n))))))) (fact 3) .. console output: (#(1#f) #(22) #(3#f)) computed value: 6 \n(de.ne (fact-tr n a) (if (zero? n) (begin (display (c-c-m fact even)) a) (mark-if-even n (w-c-m fact \nn (fact-tr (sub1 n)(* na)))))) (fact-tr 31) .. console output: (#(12)) computed value: 6 Figure 1. Factorial \nwith Continuation Marks marks. This is easy because ANF makes these continuations obvious, and the tail-calling \nproperty of marks mirrors that of continuations themselves, so the two stay synchronized. Function applications, \nlike (ka), are transformed as (k (w-c-m SQUARE ka)) where SQUARE is a special key known only to the transfor\u00admation. \nThis effectively duplicates the continuation in a spe\u00adcial mark. Then call/cc is de.ned as (de.ne (call/cc \ne) (de.ne ks (c-c-m SQUARE)) (e (. (x)(abort (resume ks x))))) where . constructs a serializable closure \nby generating a fresh structure that runs its .-lifted (Johnsson 1985) body when applied; and resume \nrestores the continuation record from the SQUARE marks into an actual control stack. resume must also \nreinstall the SQUARE marks so subsequent invoca\u00adtions of call/cc are correct. (de.ne (resume l x) (match \nl [(list) x] [(consk l) (k (w-c-m SQUARE k (resume l x)))]))  This transformation produces RESTful Web \napplications, because standard modular .-lifting and defunctionalization transformations encode all values \ninto serializable represen\u00adtations that can be sent to the client. The main de.ciency of this transformation \nis that call/cc is useless when called from an untransformed context. For example, in the program (+ \n1 (build-list how-many (. (i)(call/cc (. (k) ...))))) where build-list is not available to the transformation, \nthe continuation k is generated from the SQUARE marks and therefore does not contain the code for build-list, \nbecause it was never transformed to create SQUARE marks. That is, the continuation is recreated as (+ \n1 []) rather than the true context inside build-list. The .rst step will be to formalize the implementation \nPettyjohn et al. (2005) used to detect such problematic uses of call/cc.3 The second step will be to \nuse this detection technique as a hook to eliminate the problem and provide access to the actual part \nof the native continuation that was not captured by the mark-based transformation. 3.1 Third-Party Higher-Order \nLibraries with Higher-Order Arguments That Capture Continuations The essence of the problem is that when \nuntransformed code is called, it is unsafe to try and capture the continuation in its dynamic context, \nbecause the SQUARE marks are not avail\u00adable. Therefore, we need to learn when a call/cc attempt oc\u00adcurs \nin the dynamic context of untransformed code. The real question, then, is how do we observe our dynamic \ncontext? This, of course, is the purpose of continuation marks. We can create a continuation mark key \ncalled SAFE?that marks whether the context is safe for continuation capture. Our implementation of call/cc \nwill extract these marks and ensure that each is true: (de.ne (call/cc e) (de.ne ks (c-c-m SQUARE)) (de.ne \nsafe? (c-c-m SAFE?)) (if (safe-context? safe?) (e (. (x)(abort (resume ks x)))) (error call/cc \"Unsafe \ncontext\"))) (de.ne (safe-context? safe?-marks) (andmap identity safe?-marks)) This, however, assumes \nthat we mark unsafe contexts by wrapping them in SAFE? continuation marks. But how do we know if a context \nis unsafe before entering it? In an implementation there are many options, such as looking at the exporting \nmodule of a function s de.nition and a .ow-analysis to determine if lexical identi.ers are 3 The intuitive \ndescription of this implementation is found in item 2 of the list at the end of section 4.1 of their \npaper, roughly on page 8.  bound to third-party functions. But in our theory, we can be conservative \nand assume that all contexts are unsafe, but explicitly mark contexts that we know are safe. We wrap \nall function application in a continuation mark that signi.es its unsafety: the application (ka) is transformed \nas (w-c-m SAFE? false (k (w-c-m SQUARE ka))) This mark will be available in the dynamic context of k \nto detect that the context is unsafe. Of course, not all contexts are unsafe so we must explicitly mark \nthe safe context as such. The safe contexts are inside safe functions; and the safe functions are the \nones that are transformed, so if we transform all function de.nitions, we will track safety. The function \n(. (x ...) expr ...) will be transformed to (. (x ...) (w-c-m SAFE? true expr ...)) When a transformed \nfunction is called, it adds a safety mark to its context. If the function is called from a safe (transformed) \ncontext, then there is already an unsafety mark on the context; but the tail call property of continuation \nmarks ensures that the safety mark will overwrite the un\u00adsafety mark, so call/cc will succeed. In contrast, \nwhen a transformed function is called from an unsafe (third-party) context, unless the call is in tail \nposition, the continuation frame does not contain an unsafety mark, so the safety mark does not override \nany marks. However, call/cc will fail because when it captures the SAFE?marks with c-c-m, it will extract \na list like (list ... false true ...) where the frames between false and true were the third-party context. \nAn interesting subtle point is that continuation capture is safe in the higher-order arguments to third-party \nhigher\u00adorder functions if they are always called from tail-position. At this point, we have an account \nof how to detect and avoid continuation capture when the context is not trans\u00adformed and does not contain \nthe SQUARE marks that make capture safe and sound. In the next section, we will trans\u00adform unsafe contexts \ninto safe contexts. 3.2 Delimiting the Native Continuation In the previous section, we effectively used \nthe SAFE?mark to delimit the part of the continuation where the transforma\u00adtion was not run and thus \nwhere the SQUARE marks are not available. This allows us to detect that the user-level call/cc, implemented \nby extracting SQUARE marks, would fail be\u00adcause it misses part of the continuation during reconstruc\u00adtion. \nIn the context of Web applications all is not lost, be\u00adcause we can always capture a native continuation \nand store it on the server. However, that severely limits our scalability. If we were to capture a complete \nnative continuation, we d be doing something even worse: capturing native ver\u00adsions of continuation components \nthat are serializable. For instance, in this program (+ 5 (map (. (x)(native-call/cc ...)) (list 1))) \nif map were not transformed but the rest of the program were, then the native continuation captured by \nnative-call/cc would be: (+ 5 (w-c-m SQUARE (. (x)(+ 5 x)) (w-c-m SAFE? false (list [])))) Even though \nwe have a serializable representation of the application of +, we would still capture that part of the \ncontinuation natively. Fortunately for us, practical implementations of delim\u00adited continuations are \nalready well developed (Gasbichler and Sperber 2002; Dyvbig et al. 2007; Flatt et al. 2007). While a \nfull continuation captures the entire program con\u00adtext, delimited continuations provide two operations: \nwith\u00adcontinuation-prompt, which installs a prompt that serves as the upper bound of delimited capture, \nand call-with\u00addelimited-continuation, which captures the context up to the nearest dynamic prompt.4 What \nwe need is not just to mark delimited contexts as safe, but rather capture those contexts for later use. \nWe require that programmers explicitly specify that they are willing to pay for this behavior by annotating \nthe entry into untransformed code with serial.native and the return to transformed code with native.serial. \nFor example, (+ 5 (serial.native (map (. (x)(native.serial (call/cc ...))) (list 1)))) Intuitively, serial.native \nis with-continuation-prompt and native.serial is call-with-delimited-continuation,but there are some \nsubtleties. Here is a .rst attempt at the trans\u00adformation: (+ 5 (w-c-m SAFE? false (with-continuation-prompt \n(map (. (x) (w-c-m SAFE? true (call-with-delimited-continuation (. (dc)(call/cc ...)))) (list 1)))) But, \nof course, we need to communicate the delimited con\u00adtinuation (dc) to the serializable call/cc implementation: \n(+ 5 (w-c-m SAFE? false (with-continuation-prompt (map (. (x) (w-c-m SAFE? true (call-with-delimited-continuation \n(. (dc) (w-c-m UNSAFE-PART dc (call/cc ...)))) (list 1)))) 4 In most implementations, including Racket \ns, continuation prompts are tagged to support multiple distinct prompts.  This sets things up so that \ncall/cc canextractthe UNSAFE-PART marks in addition to the SQUARE marks. These native contin\u00aduations \ncan then be stored on the server in a global hash ta\u00adble, like normal native continuations are; synthetic \nSQUARE marks can be generated that look up and execute these native continuations: (de.ne (call/cc e) \n(de.ne ks+unsafe (c-c-m SQUARE UNSAFE-PART)) (de.ne ks (store-unsafe-on-server ks+unsafe)) (de.ne safe? \n(c-c-m SAFE?)) (if (andmap identity safe?) (e (. (x)(abort (resume ks x)))) (error call/cc \"Unsafe context\"))) \n (de.ne store-unsafe-on-server (match-lambda [(list)(list)] [(list (vector k #f) l) (cons k (store-unsafe-on-server \nl))] [(list (vector #f unsafe) l) (de.ne cont-id (store-on-server! unsafe)) (cons (. args (apply (lookup-on-server \ncont-id) args)) (store-unsafe-on-server l))])) where store-on-server! stores a value on the server and \nre\u00adturns a serializable value that can be used to fetch the value later. Our implementation of resume \ndoes not need to change because store-unsafe-on-server perfectly prepares the native continuations for \nuse as if they are serializable, as it expects. However, there is still one problem: we are still refusing \nto construct the continuation, because all the SAFE? marks are not true. We must adapt so that false \nSAFE? marks only mat\u00adter if they are not immediately followed by UNSAFE-PART marks. We rede.ne safe? \nin call/cc as: (de.ne safe? (c-c-m SAFE? UNSAFE-PART)) and rewrite safe-context? as: (de.ne (safe-context? \nsafe?+unsafe-part-marks) ; We start off in a non-native context (safe-context?/native-context safe?+unsafe-part-marks \nfalse)) (de.ne (safe-context?/native-context safe?+unsafe-part-marks in-native?) (match safe?+unsafe-part-marks \n; We cannot end in a non-native context [(list)(not in-native?)] [(cons (vector safe? unsafe-part) rest) \n  (and  ; If we are in a native context, then we must have ; captured a native continuation. Otherwise, \nthis ; context is unsafe. (if in-native? unsafe-part true) ; If this part of the context is safe, we \nrecur; safe? ; tells us if the context is native or transformed. (safe-context?/native-context rest (not \nsafe?)))])) We now have all the machinery in place to allow contin\u00aduation capture in the higher-order \narguments to third-party higher-order libraries. The key is a two-state solution, where some parts of \nthe state stay on the server, while other parts are serialized to the client. Delimited continuations \nallow us to simply specify the part of the context that must remain on the server. Existing machinery \nfor managing server-sided resources can be applied to these delimited native continua\u00adtions.  4. Formal \nTreatment In this section, we formalize the transformation where cap\u00adturing continuations in unsafe contexts \nis detectable. 4.1 Source Language Figure 2 presents grammar for the source language (SL). It is a modi.ed \nversion of A-Normal form (ANF) (Flanagan et al. 2004) because the continuation is always syntactically \nobvious (in the .rst w of applications.) It uses . rather than let and has applications of arbitrary \nlength. The language is extended with call/cc, pattern matching on algebraic data types, and letrec for \nrecursive binding. Identi.ers bound by letrec (s,e.g. map) are typeset differently than normal identi.ers \n(x,e.g. map) to easily distinguish them. Instances of algebraic data types are created with con\u00adstructors \n(K) and destructured with match. Constructors (e.g. CONS) are typeset differently than identi.ers (e.g. \ncons) to easily distinguish them. The most signi.cant non-standard aspect of the language is the presence \nof .. These represent functions that are from third-party libraries where the source code is unavailable. \nThey behave identically to normal functions, but provide a cue to the transformation. When we discuss \nthe transforma\u00adtion (Section 4.3), we will point out that the transformation does not apply to their \nbodies. The operational semantics is speci.ed via the rewriting system in Figure 3 (top and middle.) \nThe . is used to denote reduction; the . is used to denote reduction that is invariant on the store; \nand the . is used to denote reduction in a context (E) that is invariant on the store. The semantics \nis heavily based on source language se\u00admantics of Pettyjohn et al. (2005). The [beta] and [beta (unsafe)] \nrules are the standard \u00dfv-rewriting rule for call-by-value languages (Plotkin 1975). The [match] rule \nhandles pattern  e . e . E[e] .E[e ] e . e . S,e . S,e . Shared reductions ((. (x ... ) e) v ... ) \n(match (K v ... )[(K x ... ) . e] l ... ) (match (K1 v ... )[(K2 x ... ) . e] l ... ) (match v [else \n. e] l ... ) S, E[(letrec ([sv] ... ) e)] S, E[(s v ... )] S, E[(match s l ... )] SL reductions . . . \nwhere . . . . e[x . v] ... e[x . v] ... (match (K1 v ... ) l ... ) K1 .= K2 e S[s .. v] ..., E[e] S, \nE[(S(s) v ... )] S, E[(match S(s) l ... )] [beta] [match] [match (next)] [match (else)] [letrec] [s + \napply] [s + match]  ((. (x ... ) e) v ... ) . e[x . v] ... [beta (unsafe)] E[(call/cc v)] .E[(v..E)] \n[call/cc] E1[(..E2 v)] .E2[v][cont invoke] TL reductions E[(abort e)] . e [abort] E[(wcm ([vk1 vv1] \n... )(wcm ([vk2 vv2]) e))] .E[(wcm merge[([vk1 vv1 ] ... [vk2 vv2 ] ... )] e)] [wcm (merge)] where E \n=.E[(wcm ([vk v ] ... ) [])] v E[(wcm ([vk vv] ... ) vret)] . vret [wcm (return)] where E =.E[(wcm ([vk \nv ] ... ) [])] v E[(ccm vk ... )] .E[extract[E,vk ... ]] [ccm] merge[([vki vvi] ... )] = ([vk .(vk)] \n... ) where . = \u00d8[vki .. vvi] ... vk = dom(.) extract[[],vt ... ]=(NIL) extract[(v ... E),vt ... ]= extract[E,vt \n... ] extract[(wcm ([vk vv] ... ) F),vt ... ]=(CONS (VECTOR vi ... ) extract[F,vt ... ]) where vi =(SOME \nvv) for each vk = vt and (NONE) otherwise Figure 3. Reductions e ::= a | (w ...e) | (letrec ([sv]) \ne) | (matchwl ... ) | (call/cc w) l ::= [(K x ... ) . e] | [else . e] a ::= w | (K a ... ) w ::= v | \nx v ::= s | (. (x ... ) e) | (. (x ... ) e) | (K v ... ) | ..E S ::= \u00d8 | S[s .. v] E ::= [] | (v ... \nE) Figure 2. SL grammar matching; [match (next)] handles unused cases; [match (else)] handles the default \ncase of a pattern matching. The [letrec], [s + apply], and [s + match] rules specify the semantics of \nletrec. Bindings established by letrec are maintained in a global store, S. For simplicity, store references \n(s)are dis\u00adtinct from identi.ers bound in lambda expressions (Felleisen and Hieb 1992). Furthermore, \nto simplify the syntax for evaluation contexts, store references are treated as values, and de-referencing \nis performed when a store reference ap\u00adpears in an application ([s + apply]) or in a match expression \n([s + match]). The .nal rules for continuations are standard.  4.2 Target Language The target language \n(Figure 4) is similar to the source lan\u00adguage, except that . and call/cc are removed, while wcm, ccm,and \nabort have been added. The semantics (top and bottom of Figure 3) is similar to the source language s \nas well, except that because of continuation marks the evaluation contexts are structured to avoid adjacent \nmarks. There are four new reduction rules that make use of a few meta-functions (Figure 3, bottom). The \n.rst rule implements abort by abandoning the context. The second implements e ::= a | (w ...e) | (letrec \n([sv]) e) | (matchwl ... ) | (wcm ([ww] ... ) e) | (ccmw ... ) | (abort e) l ::= [(K x ... ) . e] | [else \n. e] a ::= w | (K a ... ) w ::= v | x v ::= s | (. (x ... ) e) | (K v ... ) S ::= \u00d8 | S[s .. v] E ::= \n(wcm ([vv] ... ) F) |F F ::= [] | (v ... E) Figure 4. TL grammar the tail-calling semantics of wcm, where \nadjacent marks are collapsed and overridden. The meta-function merge replaces outer marks by inner marks \nwhen their keys are equal. The rule is applied whenever the structured evaluation context forces adjacent \nwcms to be treated as a redex. The third new rule returns .nal values from wcm bodies. These two rules \nare deterministic because the side-condition on E forces [wcm (merge)] to be applied from outside to \ninside. The rule for ccm uses the meta-function extract to extract the marks from the context in the \nformat: marks ::= (NIL) | (CONS markset marks) markset ::= (VECTOR maybe ... ) maybe ::= (NONE) | (SOME \nv) 4.3 Continuation Mark Transformation Translating from SL to TL follows Pettyjohn et al. (2005) with \nthe CMT (Continuation Mark Transformation) shown in Figure 5. The translation when applied to full expressions \n (letrec (CMTe[]) .rst decomposes a term into a context and a redex ([resume by the grammar (. (lv) (match \nl r ::= (w ... a) | (letrec ([sw]) e) | (matchwl ... ) | (call/cc w) E ::= [] | (w ... E) The decomposition \nis unique and thus the translation is well-de.ned. Lemma 1 (Unique Decomposition). Let e . SL. Either \ne . a or e = E[r] for a single redex r and context E. The translation relies on particular de.nitions \nfor resume and call/cc, given in Figure 6. The translation rules are mostly straightforward. Continuation \nvalues are converted directly into functions that apply resume, but the captured SL context must be translated \ninto a set of marks that match the format expected by resume. This is handled by the E case of the CMT[] \nmeta-function. Safe .s are translated by translating their bodies and annotating the body context with \na safety mark, as discussed in Section 3.1. In contrast, the bodies of .sare not translated. (This makes \nthe translation or call/cc. We discuss this below.) The next interesting rule is for function application \n((w...a)); in this rule, the call has to be explicitly marked as unsafe in case the function applied \nis an .. Direct calls to call/cc are replaced with calls to the TL implementation of call/cc. Finally, \ncontext compositions ((w...E)) are replaced with applications where the syntactic continuations are du\u00adplicated \ninto the (SQUARE) marks to communicate with the implementation of call/cc. We now turn our attention \nto the de.nitions of resume and call/cc (Figure 6). resume works by reconstructing the evaluation context \nfrom the list of (SQUARE) marks, includ\u00ading restoring the marks themselves. call/cc works by ex\u00adtracting \nthe (SAFE?) marks and calls all-safe? with that list. all-safe? ensures that every frame is marked as \nsafe. call/cc then extracts the (SQUARE) marks and constructs a contin\u00aduation value (a . that calls resume) \nbefore giving it to its argument, f.  4.4 Correctness We de.ne reasonable SL programs as those where \nthe bodies of .s are syntactically TL expressions and do not override the standard library functions \nresume and call/cc, or the functions they rely on. This is a low standard of rea\u00adsonableness; we are \nnot hiding triviality behind this de.ni\u00adtion. Furthermore, these constraints ensure that SL programs \n     [(NIL) . v] [(CONS cm l) . (match cm [(VECTOR mk) . (match mk [(SOME k) . (k (wcm ([(SQUARE) \nk]) (resume lv)))])])]))] [all-safe? (. (marks) (match marks [(NIL) . (TRUE)] [(CONS ml) . (match m \n[(VECTOR s) . (match s [(SOME v) . (match v [(TRUE) . (all-safe? l)] [(FALSE) . (FALSE)])])])]))] [call/cc \n(. (f ) ((. (is-safe?) (match is-safe? [(TRUE) . ((. (k)(fk)) ((. (m) (. (x)(abort (resume mx)))) (ccm \n(SQUARE)))] [(FALSE) . (abort (UNSAFE CONTEXT))])) (all-safe? (ccm (SAFE?)))))]) ... ) Figure 6. CMT \nlibrary more closely model the reality that unsafe programs will not include fragments of safe programs. \nTheorem 1. For every reasonable SL program e,if \u00d8,e reduces to a value, v,then CMTe[e] reduces to CMTv[v] \nor (UNSAFE CONTEXT). This theorem states that the transformation preserves the meaning of the program \nor errors because the program cap\u00adtures a continuation in an unsafe context. We de.ne pure SL programs \nas those that do not con\u00adtain .s and that do not override the standard library functions resume, call/cc,or \nall-safe?. This corresponds to real world programs that do not interact with third-party libraries. \n CMTv[..E]=(. (x)(abort (resume CMTE[E] x)) CMTv[(. (x ... ) e)] = (. (x ... )(wcm ([(SAFE?)(TRUE)]) \nCMTe[e]))  CMTv[(. (x ... ) e)] = (. (x ... ) e) CMTv[s]= s CMTv[(K v ... )] = (K CMTv[v] ... ) CMTw[x]= \nx CMTw[v]= CMTv[v]  CMTa[w]= CMTw[w] CMTa[(K a ... )] = (K CMTa[a] ... ) CMTl[[(K x ... ) . e]] = [(K \nx ... ) . CMTe[e]] CMTl[[else . e]] = [else . CMTe[e]] CMTr[(w ... a)] = (wcm ([(SAFE?)(FALSE)]) (CMTw[w] \n... CMTa[a])) CMTr[(letrec ([sw] ... ) e)] = (letrec ([s CMTw[w]] ... ) CMTe[e]) CMTr[(call/cc w)] = \n(call/cc CMTw[w]) CMTr[(matchwl ... )] = (match CMTw[w] CMTl[l] ... ) CMTE[[]] = []  CMTE[(w ... E)] \n= (. (wcm ([(SQUARE) .]) CMTE[E])) where . =(. (x)(CMTw[w] ... x)) CMTe[a]= CMTa[a] CMTe[E[r]] = CMTE[E][CMTr[r]] \n   CMTE[[]] = (NIL) CMTE [(v ... E)] = (CONS (VECTOR (SOME (. (x)(CMTv[v] ... x)))) CMTE[E]) Figure \n5. CMT de.nition Theorem 2. For every pure SL program e,if \u00d8,e reduces to a value, v,then CMTe[e] reduces \nto CMTv[v].  5. Real World Issues Once third-party higher-order library functions can be called with \narguments that capture continuations, there are still a few practical problems and extensions that can \nbe made to make real Web programming easier and scalable. In this section, we discuss a few. 5.1 Native \nFunction Interfaces The two-state solution allows us to write code like (serial.native (build-list how-many \n(. (i) (native.serial (web-prompt \"Please provide number # a:\\n\" (add1 i)))))) where the native part \nof the continuation is captured sep\u00adarately and stored on the server. This increases expressiv\u00adity, but \nit is overly verbose and forces programmers to think about how functions are implemented whenever they \nare used. This additional cognitive task is valuable, because server resources are scarce, but it is \noften too inconvenient for the prototyping stage. For that reason, the Racket Web frame\u00adwork supports \nthe de.ne-native form for creating a wrapper. de.ne-native is given a new identi.er to bind, a speci.cation \nof which higher-order arguments may capture continuations, and a native implementation. For example, \nthe wrapper for build-list is de.ned: (de.ne-native (build-list/safe ho) build-list) Programmers can \nthen write: (build-list/safe how-many (. (i) (web-prompt \"Please provide number # a:\\n\" (add1 i)))) \nThis simple macro is incredibly effective at reducing the burden on Web programmers that seek scalability \nand con\u00advenience. 5.2 Managing Native Continuations The fundamental problem for scalability with native \ncon\u00adtinuations is that they cannot be removed from memory or reclaimed because references to them may \nbe stored by users in untraceable ways. For example, users can book\u00admark a page or otherwise remember \na URL inde.nitely, yet expect the page to be available whenever they request it. This creates a serious \nresource management problem for continuation-based Web applications that mirrors the ses\u00adsion state management \nproblem of traditional Web applica\u00adtions. The standard scalability technique is to time out ses\u00adsions \nafter periods of inactivity and provide seamless ways for users to authenticate and restore their session. \n The two-state solution does not remove the server-state management problem, but it does minimize it \nby storing only the smallest necessary delimited continuations. There\u00adfore, we have to have some policy \nfor managing the server resources consumed by native components in the two-state solution. The Racket \nWeb framework associates a manager with each Web program. This manager is essentially a hash table mapping \nunique, serializable identi.ers with opaque, non\u00adserializable values, like continuations. When each value \nis stored, it is given an expiration-handler that is returned when the manager reclaims the value s resources. \nOne other com\u00adplicating factor is that the values are stored indexed by in\u00adstance (distinct invocation \nof the application); this is use\u00adful because it allows an instance to explicitly remove values from the \nmanagers (such as on logout). Programmers often write their own custom managers, but there are a few \nstandard managers. The null manager never uses server resources and always returns the expiration handler. \nThis manager is the default for scalable Web applications and must be explicitly removed. It is useful \nto ensure that native continuations are not acciden\u00adtally stored. The timeout manager implements the \nstandard timeout policy: instances and values are reclaimed after a con.g\u00adurable number of seconds have \nelapsed since their last ac\u00adcess. This is very problematic for large deployments because the behavior \ndoes not change in response to observed use. The LRU manager implements a more sophisticated tech\u00adnique: \neach value has a life count that is initialized to start, if it ever reaches 0, then the value is reclaimed. \nThe life count is decremented by one whenever the reclamation routine is run. The reclamation routine \nruns every collect seconds and every check seconds when check? returns true. These four parameters (start, \ncollect, check,and check?) allow a wide array of management policies. A common policy con.guration is \nthe threshold policy: start is 24, collect is 10 minutes, check is 5 seconds, and check? de\u00adtermines \nif the memory used by the manager is greater than threshold megabytes. This ensures that values are available \nfor at most four hours and at least two minutes. It also en\u00adsures that a particular memory limit is never \nexceeded for long, because once it is, old values are rapidly reclaimed un\u00adtil the problem is defeated. \nWe .nd that in practice the LRU threshold policy is essen\u00adtial for running scalable and reasonable Web \napplications. This practical .nding is backed up by experimental results discussedinSection6.  5.3 Soft \nState Managers allow stateless Web applications to interact seam\u00adlessly with server state when it is \ninconvenient or impossible to serialize that state to the Web clients. Once this mecha\u00adnism is in place, \nit is tempting to use it to access other kinds of state, such as data that is too large to transmit or \ntoo sen\u00adsitive to put in the hands of the untrusted. For example, it is common for Web applications to \nmake use of soft state : state that is stored on the server, but can be recomputed when necessary so \nit is allowed to be forgotten at any time. A com\u00admon use is a cache of a user s information from a database. \nOur implementation of soft state provides two calls: (soft\u00adstate expr), which creates a piece of soft \nstate that has the same value as expr,but expr may be evaluated many times to compute it; and (soft-state-ref \nss), which extracts the value of the soft state bound to ss and may evaluate the soft state expression \nto compute it. The implementation uses managers to store the value of the soft-state such that the expiration \nhandler recomputes the value if the manager reclaims it. The soft-state serializes to the manager s identi.er \nand a serializable thunk that recom\u00adputes the value, rather than the value itself, ensuring that the \nsoft-state can be safely serialized to the client and recom\u00adputed as needed. This implementation is entirely \nlocal and requires no additional cooperation from the rest of the Web application.  6. Evaluation The \nformal model of Section 4 helps to establish the sound\u00adness of the two-state implementation technique, \nbut it cannot tell us anything about the savings or costs of its use. Since the use of the two-state \nsolution cannot be divorced from the use of server-side state managers, we evaluate their perfor\u00admance \nas well. 6.1 Managers We measured the performance of server-side state managers on two metrics. First, \nwe measured what percentage of all continuations ever stored on the server were available as the application \nran. If this percentage is high, then users will not follow links or bookmarks and .nd the page unavailable. \nIf this percent\u00adage is low, then they will, unless the application has estab\u00adlished other ways to restore \na user s session. It is important to realize, however, that users may not actually care about one of \nthese expired values. For example, after users have totally .nalized their online purchase, they have \nno need to access the continuation that sets the shipping address. Thus this per\u00adcentage establishes \nan imperfect bound on user happiness; a low percentage does not, in practice, mean the application is \nunusable. Second, we measured the total memory used by the server. If this is high or is proportional \nto server use, then the server is unlikely to be scalable because memory will invariably be exhausted \nduring periods of high activity. All measurements of managers are based on logs of the use of the CONTINUE \nconference manager by an elite con\u00adference during the periods of its highest activity: just before the \npaper and review submission deadlines. These periods of activity were characterized as a six hour window \nwith 30 active users at any time performing a total of about 3,000 interactions distributed throughout \nthe entire period. In these experiments, the default LRU manager was con\u00ad.gured with a threshold that \nlimits the number of continu\u00adations to approximately 2000 and the timeout manager was used with a one \nhour, two hour, and four hour timeout. These experiments do not constitute stress tests; they are just \nenough activity to identify and compare the trends of each manager. Continuation Availability. Figure \n7 (top) presents the per\u00adcentage of available continuations that were available to users at a number \nof points in the run. The X-axis shows the progress of time, while the Y-axis show the percentage of \nall continuations ever stored that were available for in\u00advocation by users. Naturally, every manager \nstarts off with 100% of the continuations available, but the timeout man\u00adagers slowly lose availability \nas more continuation timeouts expire. In contrast, the LRU manager delivers 100% avail\u00adability approximately \nas long as the 2-hour timeout manager, but loses availability more slowly before leveling out. Memory \nUsage. Figure 7 (bottom) presents the amount of memory used by the managers at each sampled point in \nthe run. The graphs show the usage of the LRU manager and one of the timeout managers. The .rst row shows \nthe 1-hour and 2-hour timeout managers. The second row shows the 4\u00adhour and 6-hour timeout managers. \n(The oscillation in these graphs are a side-effect of the sampling thread competing with the manager \nthread, because Racket does not have truly concurrent threads. Since the higher timeout threads do less \nwork, they compete less and therefore the sampler takes more samples.) The LRU manager uses consistently \nless memory, despite giving better availability than the 1-and 2-hour timeout managers always and the \n4-hour manager after the timeout. The 6-hour timeout manager (not shown on top because it always has \n100% during the 6-hour experiment) shows the memory cost of never expiring server-side continuations. \nThese experiments show that while the timeout manager can guarantee 100% availability before the timeout, \nthe LRU provides strong memory bounds without sacri.cing avail\u00adability too severely. For example, the \n4-hour timeout man\u00adager has 100% availability until 4 hours, whereas the LRU manager only has 50%; but \nafter 2 more hours, both man\u00adagers have the same availability. 75% 50% 25%  20 MB  20 MB 15 MB 15 \nMB 10 MB 10 MB 5 MB 5 MB 1hr 2hr 3hr 4hr 5hr 1hr 2hr 3hr 4hr 5hr 20 MB  20 MB 15 MB 15 MB 10 MB 10 \nMB 5 MB 5 MB 1hr 2hr 3hr 4hr 5hr 1hr 2hr 3hr 4hr 5hr  Figure 7. Memory Usage of Different Managers \n 6.2 Two-State Solution We measured four different comparisons between native continuations, two-state \ncontinuations, and serializable con\u00adtinuations. First, we repeated the manager tests after special\u00adizing \nthem for each of these techniques, then we performed two separate timing tests. Continuation Availability. \nWe ran a native and two-state version of the same Web application through the workload above. The average \ncontinuation size of the native version was approximately 2KB, whereas the server-part of the two\u00adstate \ncontinuations were on average only 512B.The LRU manager was used for both versions and was con.gured \nwith a memory threshold of 4MB. Figure 8a presents the availability of continuations during the test. \nIt veri.es our expectation that the two-state solution provides more access to server state, by reducing \nthe size of each continuation, but after the threshold is reached, the two have similar performance. \nIt does not make sense to compare these to serializable continuations, because all serializable continuations \nare al\u00adways available. Memory Usage. Figure 8b shows the memory usage for the same experiment. It veri.es \nthat the native continuations   1hr 2hr 3hr 4hr 5hr 1hr 2hr 3hr 4hr 5hr (a) (b) Figure 8. Native and \nTwo-State Continuation Availability and Memory Usage take more space on the server, but that the LRU \nmanager controls memory usage regardless of what the server state is. It may seem surprising that the \ntwo-state solution some\u00adtimes uses more memory than the native solution, such as between two and three \nhours. This has to do with when recla\u00admation occurs. Since the native solution exhausts the mem\u00adory limit \nfaster, it causes a reclaiming just before the two\u00adhour mark. At that point the two-state solution uses \nmore memory because it hasn t expired anything. Once it does (around three hours), it use less memory \nthan native con\u00adtinuations, until the process repeats just before four hours. It does not make sense \nto compare these to serializable continuations, because serializable continuations do not con\u00adsume server \nmemory resources. Compilation Time. The two-state solution relies on a com\u00adplex transformation that intuitively \nincreases compilation time relative to using native continuations. We measured this by compiling three \nversions of the our example application from Section 2 one hundred times and averaging the compi\u00ad lation \ntimes. Native 661 ms Two-State 1007 ms Serial 1048 ms Native compilation is almost .fty percent faster \nthan ei\u00adther transformation-based compilations, while the two-state compilation is only slightly faster \npresumably because there is less code to compile since third-party higher-order library functions are \nnot examined. In our experience, the increased compilation time for us\u00ading non-native continuations is \nquickly noticed by program\u00admers but easy to ignore during development. Execution Time. The two-state \nsolution uses a combina\u00adtion of serializable closures and native delimited continua\u00adtions to simulate \nfull continuations that are implemented na\u00adtively. It is natural to assume that the Racket compiler and \nruntime perform better with native continuations than simu\u00adlated continuations, because they have been \noptimized over many years, while these simulated continuations have not. This assumption is true for \ncontinuation invocation,but false for continuation capture. We created a micro-benchmark that captures \n200 contin\u00aduations and averaged 1,000 runs per implementation. Native 1.5975 ms Two-State 0.1528 ms Serial \n0.6744 ms It is ten times cheaper to capture our simulated continu\u00adations. The intuitive explanation \nis that the native continua\u00adtion capture has to copy large parts of the stack and check if previous stack \ntails have already been captured so they may share and thus reduce the overall space consumed by continuations. \nA tail-sharing continuation representation re\u00adduces space consumption in most Web applications because \nmany intermediate computations return to the same points. For example, each stage of a purchase returns \nto the same Shipping Con.rmation page generator. The simulated continuation capture is faster because \nit only inspects the stack and copies a few small pointers that were set up when the continuation component \nwas added in a continuation mark. There would be no space savings if we were to implement tail sharing, \nbecause these continuations are not stored on the server and the entire continuation must be serialized \nto the client. A different implementation of native continuation capture may not have this performance \ndifference (Hieb et al. 1990; Clinger et al. 1999). The difference that exists, however, can be signi.cant \nbecause most Web applications capture many more continuations than they invoke, because most pages have \nmany links and the majority are not chosen. We created a micro-benchmark that captures and invokes 200 \ncontinuations and averaged 1,000 runs per continuation implementation. Native 1.7609 ms Two-State 49.6306 \nms Serial 13.8949 ms It is almost thirty times more expensive to invoke our simulated continuations \nthan native continuations, especially when we also must install a continuation prompt and capture and \ninvoke a native delimited continuation. Despite these micro-benchmarks, none of these differ\u00adences are \nactually observable by end users of Web applica\u00adtions, given the already long network delays users are \naccus\u00adtomed to. A 50ms delay is dwarfed by the typical network latency over the Internet. Ease of Use. \nA frustrating aspect of the two-state solu\u00adtion is that foreign code must be explicitly identi.ed and \ncall must be wrapped in serial.native and the higher-order ar\u00adguments must be wrapped in native.serial. \nThis limits the ease of porting a code-base from the purely native continua\u00adtion technique to the two-state \nsolution. Fortunately, it is safe to insert paired calls to serial.native and native.serial anywhere. \nTherefore, we have experi\u00admented with automatically inserting them around every call to a function from \nanother module the only functions that could be foreign. We measured two situations where this could \nimpose costs. First, we tested when the possibly foreign function doesn t actually have higher-order \narguments, so there is no reason to use serial.native. We timed and averaged 20,000 calls with this pro.le. \nWithout Wrapping 0.0843 ms Wrapping 0.0860 ms There is only about a 2% performance penalty and the abso\u00adlute \nvalues are tiny. This essentially is a measurement of the cost of serial.native. Second, we tested when \nthe possibly foreign function has higher-order arguments, but they don t capture continu\u00adations. We timed \nand averaged 20,000 calls with this pro.le. Without Wrapping 0.0841 ms Wrapping 0.0905 ms There is about \nan 8% performance penalty for extraneous uses of both serial.native and native.serial. These experiments \nsuggest that it is not prohibitive to run\u00adtime performance to automatically use the two-state solu\u00adtion. \nHowever, we are philosophically opposed to obscuring when server state is used from programmers and prefer \nthat this decision be made explicitly with an idea to the overall scalability of the Web application. \n  7. Conclusion We presented an implementation technique that allows scal\u00adable and stateless Web programs \nwritten in direct style to make use of third-party higher-order library functions with higher-order arguments \nthat capture continuations and cause user interaction. We have presented a formal model of a por\u00adtion \nof this implementation technique. We have discussed extensions necessary for real deployment and additional \nfa\u00adcilities easily provided by this infrastructure. We have evalu\u00adated this work and found that it increases \nscalability com\u00adpared to purely native continuations and reduces the bur\u00adden of reimplementation compared \nto purely serial contin\u00aduations. Overall, the two-state solution works. This work relies on the state-of-the-art \nin stack inspec\u00adtion and manipulation continuation marks and delimited continuations therefore it is \nonly directly applicable to pro\u00adgramming languages in the Racket family. Acknowledgments We thank Matthew \nFlatt for his su\u00adperlative work on Racket, where our implementation lives. We thank Robby Findler for \nhis fabulous work on Redex, where our model lives. We thank Casey Klein for his work on the randomized \ntesting facility of Redex, which aided our model development effort.  References Henry Cejtin, Suresh \nJagannathan, and Richard Kelsey. Higher\u00adorder distributed objects. ACM Transactions on Programming Languages \nand Systems, September 1995. John Clements, Matthew Flatt, and Matthias Felleisen. Modeling an algebraic \nstepper. In European Symposium on Programming, April 2001. William D. Clinger, Anne H. Hartheimer, and \nEric M. Ost. Imple\u00admentation strategies for .rst-class continuations. Higher Order and Symbolic Computation, \n12(1):7 45, 1999. Ezra Cooper, Sam Lindley, Philip Wadler, and Jeremy Yallop. Links: Web programming \nwithout tiers. In Formal Methods for Components and Objects, 2006. St\u00b4ephane Ducasse, Adrian Lienhard, \nand Lukas Renggli. Seaside a multiple control .ow web application framework. In Euro\u00adpean Smalltalk User \nGroup -Research Track, 2004. R. Kent Dyvbig, Simon Peyton Jones, and Amr Sabry. A monadic framework for \ndelimited continuations. Journal of Functional Programming, 17(6):687 730, 2007. Matthias Felleisen and \nRobert Hieb. The revised report on the syntactic theories of sequential control and state. Theoretical \nComputer Science, 102:235 271, 1992. M. J. Fischer. Lambda calculus schemata. ACM SIGPLAN No\u00adtices, 7(1):104 \n109, 1972. In the ACM Conference on Proving Assertions about Programs. Cormac Flanagan, Amr Sabry, Bruce \nF. Duba, and Matthias Felleisen. The essence of compiling with continuations. SIG-PLAN Notices, 39(4):502 \n514, 2004. Matthew Flatt and PLT. Reference: Racket. Tech\u00adnical Report PLT-TR2010-1, PLT Inc., June 7, \n2010. http://racket-lang.org/tr1/. Matthew Flatt, Gang Yu, Robert Bruce Findler, and Matthias Felleisen. \nAdding delimited and composable control to a production programming environment. In International Conference \non Functional Programming, 2007. URL http://www.cs.utah.edu/plt/delim-cont/. Martin Gasbichler and Michael \nSperber. Final shift for call/cc:: direct implementation of shift and reset. SIGPLAN Notices,37 (9):271 \n282, 2002. Paul Graham. Lisp for web-based applications, 2001. http://www.paulgraham.com/lwba.html. Robert \nHieb, R. Kent Dybvig, and Carl Bruggeman. Representing control in the presence of .rst-class continuations. \nIn ACM SIGPLAN Conference on Programming Language Design and Implementation, 1990. John Hughes. Generalising \nmonads to arrows. Science of Computer Programming, 37(1 3):67 111, May 2000. Thomas Johnsson. Lambda \nlifting: transforming programs to re\u00adcursive equations. In Functional Programming Languages and Computer \nArchitecture, pages 190 203, 1985. Shriram Krishnamurthi, Peter Walton Hopkins, Jay McCarthy, Paul T. \nGraunke, Greg Pettyjohn, and Matthias Felleisen. Im\u00adplementation and Use of the PLT Scheme Web Server. \nHigher-Order and Symbolic Computation, 2007. Jacob Matthews, Robert Bruce Findler, Paul T. Graunke, Shriram \nKrishnamurthi, and Matthias Felleisen. Automatically restruc\u00adturing programs for the Web. Automated Software \nEngineering, 11(4):337 364, 2004. Jay McCarthy. Automatically restful web applications or, marking modular \nserializable continuations. In International Conference on Functional Programming, 2009. Greg Pettyjohn, \nJohn Clements, Joe Marshall, Shriram Krishna\u00admurthi, and Matthias Felleisen. Continuations from general\u00adized \nstack inspection. In International Conference on Functional Programming, September 2005. Gordon D. Plotkin. \nCall-by-name, call-by-value, and the .\u00adcalculus. Theoretical Computer Science, 1975. Christian Queinnec. \nThe in.uence of browsers on evaluators or, continuations to program web servers. In International Confer\u00adence \non Functional Programming, pages 23 33, 2000. Peter Thiemann. Wash server pages. Functional and Logic \nPro\u00adgramming, 2006. Noel Welsh and David Gurnell. Experience report: Scheme in com\u00admercial web application \ndevelopment. In International Confer\u00adence on Functional Programming, September 2007.  \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Continuation-based Web servers provide advantages over traditional Web application development through the increase of expressive power they allow. This leads to fewer errors and more productivity for the programmers that adopt them. Unfortunately, existing implementation techniques force a hard choice between scalability and expressiveness.</p> <p>Our technique allows a smoother path to scalable, continuation-based Web programs. We present a modular program transformation that allows scalable Web applications to use third-party, higher-order libraries with higher-order arguments that cause Web interaction. Consequently, our system provides existing Web applications with more scalability through significantly less memory use than the traditional technique.</p>", "authors": [{"name": "Jay A. McCarthy", "author_profile_id": "81329490606", "affiliation": "Brigham Young University, Provo, UT, USA", "person_id": "P2354106", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869506", "year": "2010", "article_id": "1869506", "conference": "OOPSLA", "title": "The two-state solution: native and serializable continuations accord", "url": "http://dl.acm.org/citation.cfm?id=1869506"}