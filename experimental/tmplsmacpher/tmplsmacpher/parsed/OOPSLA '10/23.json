{"article_publication_date": "10-17-2010", "fulltext": "\n A Graph-based Approach to API Usage Adaptation Hoan Anh Nguyen,1a Tung Thanh Nguyen,1b GaryWilson Jr.,2c \nAnhTuan Nguyen,1d Miryung Kim,2e Tien N. Nguyen1f Iowa State University1 andTheUniversityofTexasat Austin2 \n {hoana,tungb,anhntd,tienf }@iastate.edu, gwilson@austin.utexas.educ, miryung@ece.utexas.edue Abstract \nReusing existing library components is essential for re\u00adducing the cost of software development and maintenance. \nWhen library components evolve to accommodate new fea\u00adture requests, to .x bugs, or to meet new standards, \nthe clients of software libraries often need to make correspond\u00ading changes to correctly use the updated \nlibraries. Existing API usage adaptation techniques support simple adaptation such as replacing the target \nof calls to a deprecated API, however, cannot handle complex adaptations such as creat\u00ading a new object \nto be passed to a different API method, or adding an exception handling logic that surrounds the updated \nAPI method calls. This paper presents LIBSYNC that guides developers in adapting API usage code by learning \ncomplex API usage adaptation patterns from other clients that already migrated toanewlibraryversion (and \nalso from the API usages within the library s test code). LIBSYNC uses several graph-based techniques \n(1) to identify changes to API declarations by comparingtwolibraryversions,(2)toextract associatedAPI \nusage skeletons before and after library migration, and (3) to compare the extracted API usage skeletons \nto recover API usage adaptation patterns. Using the learned adaptation pat\u00adterns, LIBSYNC recommends \nthe locations and edit opera\u00adtions for adapting API usages. The evaluation of LIBSYNC on real-world software \nsystems shows that it is highly cor\u00adrectand usefulwithaprecisionof100%anda recallof91%. Categories and \nSubject Descriptors D.2.7[Software En\u00adgineering]: Distribution, Maintenance, and Enhancement General \nTerms Algorithm, Design, Experimentation, Re\u00adliability Keywords Software Evolution, API Usage Model, \nAPI Evolution, API Usage Adaptation, Program Differencing Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, \nrequires prior speci.c permission and/or a fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, Nevada, \nUSA. 1. Introduction Reusing existing software components by accessing their implementations through \ntheir Application Programming In\u00adterfaces (APIs) can reduce the cost of software development and maintenance. \nWhen libraries provide their functionality through public interfaces (e.g., types, methods, and .elds \nin Java), clientsareexpectedto respectthe contract assumedby thelibrariesby using the correct namesof \nthe APIs, passing the right arguments, following the intended temporal orders of API invocations, etc. \nWhen library components evolve to accommodate new feature requests, to .x bugs, and to meet new standards, \nchanges in API declarations in libraries could cause exist\u00ading clients to break. For example, when an \nAPI signature modi.cation requires more input parameters or a different return type, clients need to \npass additional input arguments or to process a returned object differently. Existing analysis techniques \nthat can be used for adapt\u00ading API usage code in client applications have the follow\u00ading limitations. \nFirst, existing research techniques such as CatchUp! [15] and MolhadoRef [11] require library main\u00adtainers \nand client application developers to use the same development environment to record and replay refactor\u00adings. \nOther techniques require library developers to man\u00adually write expected adaptations in client code as \nrules [7]. Second, existing API usage modeling and extraction tech\u00adniques[1,12,37,39] are limitedbysimpli.ed \nrepresentations such as a sequence of method calls. Thus, theycannot cap\u00adture the complex control and \ndata dependencies surrounding the useof APIs.Forexample, SemDiff[8] models API us\u00adages in terms of method \ncalls, so it can support changing the target of calls to modi.ed APIsbut cannot add the control structure \nthat surrounds the calls to a new replacement API. Hypothesizing that changes to API usage caused by \nthe evolution of library components may involve complex changes, we developed a set of graph-based models \nand al\u00adgorithms that can capture updates in evolving libraries and updates in client applications associated \nwith changes in the libraries, and an algorithm that generalizes common edit op\u00aderationsfromasetofAPIusagecode \nfragments beforeand after library migration. c Copyright . 2010ACM 978-1-4503-0203-6/10/10...$10.00 \n Our API usage code adaptation framework takes as in\u00adput the current version of a client application, \nboth the old version and the new version of a library under focus, and a set of programs that already \nmigrated to the new library ver\u00adsion. Our framework consists of four main components: (1) anORIGINANALYSISTOOL(OAT)that \nmaps corresponding code elements betweentwoversions,(2)a CLIENT APIUS-AGE EXTRACTOR (CUE)that extracts \nAPI usage skeletons from client code and the use of APIs within the library,(3) an APIUSAGEADAPTATIONMINER(SAM)that \nautomatically infers adaptation patterns from a set of API usage skeletons before and after the migration \nfrom the old libraryversion to the new library version, and (4) LIBSYNC that recommends which API usage \ncode needs to be adapted and how those code fragments need to be updated by locating API usage fragments \nin the client that need to be adapted and suggest\u00ading edit operations required for adaptation. OAT models \na Java program as a project tree, in which nodes represent code elements (packages, classes, interfaces, \nmethod-headers, .elds, and method-bodies). It uses a tree\u00adbased alignment and differencing algorithm \nto map code elements and detect addition, deletion, renaming, moving, and modi.cation of those elements. \nCUEextractstheskeletonofAPIusagecodein clientsys\u00adtems and the test code of the APIs.We make the assump\u00adtion \nthat client systems use library components by access\u00ading their APIs via invocation directly calling API \nmeth\u00adods or instantiating objects from API classes and via in\u00adheritance declaring classesin the clientby \nsubtyping API classes.Wecall thosetwowaysofusingAPIsasAPI i-usage (invocation) and API x-usage (extension). \nWe also use the term API usage to refer to both types of API usages. In particular, CUE extends Nguyen \net al. s graph-based object usage model (GROUM) [25] that represents both con\u00adtrol and data dependencies \namong method calls and .eld ac\u00adcesses.In orderto captureAPI usage,weextendedGROUM to explicitly note \nthe usages of external APIs via invoca\u00adtion and extension by modeling the types of objects passed to \nAPIs as arguments and by modeling overriding and in\u00adheritance relationships between client methods and \nmethods provided by external API types. In particular, CUE repre\u00adsents API i-usages by an invocation-based, \ngraph-based ob\u00adject usage model, iGROUM, in which, action nodes repre\u00adsent method invocations, control \nnodes represent surround\u00ading control structures, and data nodes represent use of types provided by external \nlibraries. The edges represent depen\u00addencies between the nodes, for example, usage orders, input and \noutput relations. CUErepresents API x-usagebyanother graph-based model called xGROUM, in which each node \nrepresentsamethod-headerandtwokindsofedges represent overriding and inheritance relationships between \na method\u00adheader in the client and a method-header in the library. SAMuses an approximate graph alignment \nand differenc\u00ading algorithm to map nodes between twousage models based on their similarity of labels \nand neighborhood structures, and calculates the editing operations based on the alignment.For example, \nthe aligned nodes having different attributes are considered as replaced or updated, while unaligned \nnodes are considered as deleted or added. Since API usage changes are detectedaschangesetsofediting operations, \nSAMmines the frequent subsets of such change sets using a frequent item set mining algorithm [2] and \nconsiders them as API us\u00adage adaptation patterns. LIBSYNC has a knowledge base of API usage adaptation \npatterns for each library version. Given a client system and the desired version of library to migrate \nto, LIBSYNC identi\u00ad.es the locations of API usages in the client system that are associated with changed \nAPIs. It then matches each usage with the best matched API usage pattern in its knowledge base and derives \nthe edit operations for adapting API usages. We have conducted an empirical evaluation of LIBSYNC on \nthree large open-source subject systems, each uses up to 300 libraries.Wehave doneseveralexperimentstoevaluate \nthe correctness and usefulness of our tool in two usage sce\u00adnarios: (a) API usage adaptation in different \nlocations within a client program, and (b) adaptation in different branches of a client program (e.g. \nback-porting). The evaluation shows that OAT and CUE detect changes to API declarations and API usages \nwith high accuracy, and LIBSYNC provides use\u00adful recommendation in most cases, even when API usage adaptation \ninvolves complex changes to the control logic surrounding API usages. Thekeycontributionsof the paper \ninclude: 1. OAT, a tree-based origin analysis technique to automati\u00adcally identify corresponding APIs \nbetween two versions ofa library and .nd corresponding usage code fragments in client systems. 2. CUE, \na graph-based representation that models the con\u00adtext of API usages by capturing control and data depen\u00addencies \nsurrounding API usages; in particular,it supports API usages via method invocations and subtyping of \nthe API types provided by an external library under focus.  3.SAM,agraph alignment algorithmthat identi.esAPIus\u00adage \nchanges in client applications and an API usage adap\u00adtation pattern mining algorithm that generalizes \ncommon edit operations from multiple API usage skeletons before and after migration. 4. LIBSYNC, a tool \nthat takes as input a client system and a given library version to be migrated to, and recommends the \nlocations and potential edit operations for adapting API usage code in the client. 5. An empirical evaluation \nfor the correctness and useful\u00adness of LIBSYNC in adapting API usage code.  Section2presents motivatingexamples \nthat require complex API usage adaptation in client applications that are caused byupdatesto libraries. \nSections3,4,5,and6detailindivid\u00ad  1 2 3 4 5 6 XYSeries set = new XYSeries(attribute,false, false ); \nfor (int i=0;i < data.size(); i++) set.add(new Integer(i), (Number)data.get(i)); DefaultTableXYDataset \ndataset = new DefaultTableXYDataset(set false ); dataset.addSeries(set) ; JFreeChart chart = ChartFactory.createXYLineChart(..., \ndataset,...); Figure 1. API usage adaptation in JBoss caused by the evolution of JFreeChart ual models \nand algorithms that we have developed tobuild LIBSYNC. Section7shows the empiricalevaluationof LIB-SYNC. \nSection8describes relatedwork and Section9 sum\u00admarizes this paper s contributions. 2. Motivating Examples \nJBoss [31] is a large project that has been developed more than6yearsago,with47 releases.Ithasabout40,000meth\u00adods \nand uses up to 262 different libraries. Using the Subver\u00adsion [32] and code search functionality in Eclipse, \nwe man\u00adually scanned the version history of JBoss and the external libraries usedby JBoss.Weexamined \nmore than 200 meth\u00adods that changed due to the modi.cation of external APIs based on associated documentation, \nchange logs, andbug re\u00adports. This section presents API usage adaptation examples that motivate our approach. \n2.1 Examples of API Usage via Method Invocations Figure 1 illustrates an API usage adaptation example \nin JBoss with respect to the use of JFreeChart library. The code changes are represented with added code \nand deleted code. The changes from JBoss version 3.2.7 to 3.2.8 were due to the modi.cation of external \nAPIs, XYSeries and DefaultTableXY\u00adDataset,in JFreeChart fromversion 0.9.15 to 0.9.17.To en\u00adablea new \nauto-sorting feature, the XYSeries constructor with two input arguments is deprecated and a new constructor \nwith three input arguments is provided instead. The Default-TableXYDataset constructor that accepts XYSeries \nas an input is also deprecated. The new constructor accepts a boolean input to activate the new auto-pruning \nfeature for data points in DefaultTableXYDataset. It implies that the XYSeries object must be added after \nthe initialization of the DefaultTableXYDataset object. Thus, the parameter set is replacedbyavalue false, \nand a call to DefaultTable XYDataset.addSeries is added. This example illus\u00adtrates the following: 1. \nJBoss uses JFreeChart via creating objects from API classes (e.g. XYSeries, DefaultTableXYDataset) and \ncalling API methods (e.g. DefaultTableXYDataset.addSeries, ChartFactory.createXY-LineChart). Since an \nobject instantiation is represented as a constructor call to an external API type, we consider this type \nof API usage as an usage via invocation. 2. API usage must follow speci.c protocols due to the dependencies \nbetween API elements.Forexample,a Default-TableXYDataset object needs to be created before any XYSeries \n SnmpPeer peer=new SnmpPeer(this.address ,this.port, this.localAddress, this.localPort ); peer.setPort(this.port); \npeer.setServerPort(this.localPort); Figure 2. API usage adaptation in JBoss caused by the evolution of \nOpenNMS object could be added to the set.Achart needs to be created with an object of Dataset. 3. As \nAPI evolves, such usage protocols could change, requiring corresponding API usage adaptations.Forexam\u00adple, \nthe calls to deprecated methods are replaced with newly provided ones, or new method calls are added, \netc. In this example, the following edit operations occurred in the client code: replacement (e.g. the \nconstructor of XYSeries), addition (e.g. DefaultTable XYDataset.addSeries), and update of input/out\u00adput \ndependencies (e.g. the object XYSeries no longer imme\u00addiately depends on DefaultTableXYDataset.<init> \nbut instead on DefaultTableXYDataset.addSeries). This example shows that existing state-of-the-art adap\u00adtation \napproaches (e.g. SemDiff [8], CatchUp [15]) could not support the API usage adaption because they assume \nthat the adaptation needed in client code is simply individ\u00adual method-call replacements or type declarations. \nTheydo not consider the context of API usages, the dependencies be\u00adtween method calls, and the differences \nbetween the exten\u00adsion and invocation of API methods. Figure 2 shows another API usage adaptation example. \nFrom version 1.6.10 to 1.7.10, in the OpenNMS library, a new constructor with four parameters is added \nfor initializ\u00ading SnmpPeer. Such API change requires adding a call to the new constructor and the removal \nof two subsequent calls to setter methods as in Figure 2. This adaptation from JBoss version 3.2.5 to \n3.2.6, although simple in meaning, is com\u00adplex in term of edit operations: it involves one constructor\u00adcall \nreplacement and twomethod-call deletions. Importantly, all edited calls are dependent. SemDiff[8] could \nsuggest the replacement of the old constructor call, however, it does not suggest the setter method-call \ndeletions because it does not consider the usage context when recommending adaptations.  2.2 Examples \nof API Usage via Inheritance Figure3shows an API usageexample via inheritance. The API class Serializer \nin the org.apache.axis.encoding package pro\u00advides the writeSchema method. The AttributeSerializer class \nin JBoss inherits the Serializer class and overrides the writeSchema method. When the input signature \nof the writeSchema is changedbyrequiringa Class type argument and returning Ele\u00adment instead of boolean,the \nsignatureoftheoverriding method needs to be updated accordingly to properly override the writeSchema \nmethod. Figure4 shows another example. Class C=EJBProvider in JBoss inherits the class with the same \nname A=EJBProvider in  Change in Apache Axis API Change in Apache Axis API package org.apache.axis.encoding; \nclass Serializer ...{ public abstract boolean Element writeSchema( Class c, Types t)... ... Change in \nJBoss package org.jboss.net.jmx.adaptor; class AttributeSerializer extends Serializer { public boolean \nElement writeSchema( Class clazz, Types types)... ... class ObjectNameSerializer extends Serializer \n{ public boolean Element writeSchema( Class clazz, Types types)... ... Figure 3. API usage adaptation \nin JBoss caused by the evolution of Axis the Apache Axis library. The method method m=getNewService-Object \nof A was renamed into makeNewServiceObject. Thus, its overriding method C.m is also renamed accordingly. \n 2.3 Observations We make the following observations based on API usage adaptation examples. First, \nin object-oriented programming (OOP), there are two common ways to use the API func\u00adtionality (1) via \nmethod invocation, i.e. directly calling to API methods or creating objects of API classes; and (2) via \ninheritance, i.e. declaring classes in client code that inherit from the API classes and override their \nmethods. Second, to use APIs correctly, client code must follow speci.c or\u00adder of method calls or override \ncertain methods. Thus, API usage model and API usage adaptation model must capture complexcontext surrounding \nAPI usages: (1) data and order\u00ading dependencies among API usages, (2) control structures around API usages, \nand (3) the interaction among multiple objects of different types. Those observations imply the necessity \nof a recommen\u00addation tool that helps developers in API usage adaptation to cope with evolving libraries. \nThe tool should provide rec\u00adommendations regarding where and how to do API usage adaptation. That is, \ngiven a client program using libraries and the changes toexternal API declarations, the tool should identify \nthe locations to update and suggest adaptations. 3. Origin AnalysisTool(OAT) This section discusses the \norigin analysis technique we have developed to map corresponding code elements (packages, classes, and \nmethods) between two program versions. This technique is used for two different purposes: to identify \nmodi.cation to API declarations between two versions of a library and to map corresponding API usage \ncode fragments between two versions of a client. This origin analysis works at or above the level of \nmethod-headers since API usages via both invocation and inheritance only refer to classes package org.apache.axis.providers.java; \nclass EJBProvider ... { protected Object getNewServiceObject makeNewServiceObject (...) ... Change in \nJBoss package org.jboss.net.axis.server; class EJBProvider extends org.apache.axis.providers.java.EJBProvider \n{ protected Object getNewServiceObject makeNewServiceObject (...) ... Figure 4. API usage adaptation \nin JBoss caused by the evolution of Axis and methods. OAT views a program P (either a library or client) \nas a project tree T (P ), where each node represents a package, class, interface, or method. Each node \nhas the following set of attributes: Declaration(declare(u)):Fora package node,itisa fully quali.ed \nname.Fora class node,itisa simple name fol\u00adlowed by the names of the classes and interfaces that the \nnodeextends or implements.Fora method node,itisa simple name, a list of parameter types, all modi.ers, \na set of exceptions, a return type, and associated annota\u00adtions such as deprecated.  Parent(parent(u)): \nIt refers a node s container element.  Content(content(u)): It represents a set of descendant nodes.Fora \nmethod node,it represents the bodyof the method. When the source code is available, it represents the \nabstract syntax tree of the method body. Otherwise, it represents a sequence of byte code instructions \nextracted from a jar .le.  For a client systemP ,OATviews each used library L as a sub-system, and represents \nL as a project tree T (L). Thus, each client program is represented as a forest of several project trees. \nFigure 8 shows an example of a project tree of org.apache.axis.providers. Due to space limit, we show \nonly a subset of methods of EJBProvider with some of their attributes: name, parameter types, and visibility \n(red square for private, yellow rhombus for protected and green circle for public). Section 3.1 describes \nthe types of transformations that OATsupports, Section 3.2 describes similarity measures that were used \nto derive one-to-one mapping between tree nodes, and Section 3.3 describes our tree alignment algorithm \nthat maps tree nodes and derives the tree transformations from the alignment result. 3.1 TransformationTypes \nSuppose that two versions Pi and Pj of a program P are represented as two trees T (Pi) and T (Pj ). The \nchanges between2versions are represented as the following typesof transformations from one tree to another: \nadd(u), delete(u), move(u) changes to the location of node u, and update(u)\u00adchanges to u s attributes. \nAn updated node could also be moved.Foraclass,anupdatecanbe performedonitsname, its superclass, or its \ninterfaces.Fora method, the update can be change to its name, return type, visibility modi.ers, or input \nsignature. Those types of transformations are derived from an alignment resultby considering unmapped \nnodes as added or deleted, and mapped nodes as moved or updated.  Figure8shows anexampleof changes foundin \nthe Axis library. Neither packages nor classes were deleted or added. Under the EJBProvider class, its \nmethod getContext was added, its method getNewServiceObject was renamed to makeNewServiceOb\u00adject, the \ninput signature of its methods getServiceClass and getE-JBHome was changed to take an additional SOAP \ntype argu\u00adment, and its method getStrOption changed its visibility from private to protected.  3.2 Similarity \nMeasures The similarity score betweentwonodesis computedbysum\u00adming up their declaration attribute similarity, \nsd, and their content attribute similarity sc, which are de.ned differently for each type of nodes. MethodLevel \nSimilarity. sd is computed based on weighted sum of textual similarities of return types, method names, \nand a list of parameter types: ' sd(u, u ) = 0.25 * strSim(returntype, returntype ) +0.5 *seqSim(name, \nname ) +0.25 *seqSim(parameters, parameters ) in which seqSim computesthe similarity betweentwoword \nsequences using the longest common subsequence algorithm [16], and strSim computesa token-level similarity \nbetween two strings by using an idea from our prior work (Kim et al. [18] sAPI matching).Forexample,giventhetwo \nmeth\u00adods, getNewServiceObject(Context,String) and makeNewServiceObject(\u00ad SOAP,Context,String), sd is \n0.875. ' sd(u, u ) = 0.25 * strSim(Object,Object) +.5 *seqSim(getNewServiceObject,makeNewServiceObject) \n+.25 *seqSim([Context,String],[Context,String]) = 0.25* (1/1)+0.5* (3/4)+0.25* (2/2) = 0.875 If the content \nis represented as an AST, sc is computedby extractingacharacteristicvectorv(u) fromamethod u using our \nprior work Exas [24]. Exas is a method to approximate the structural informationof labeled treesandgraphsbyvec\u00adtors \nand to measure the similarity of such trees and graphs via vector distance. If the content consists of \nbyte code in\u00adstructions, its characteristic vector v(u) is an occurrence\u00adcounting vector of all the opcodes. \nThen, the similarity be\u00ad ' tween2methods u and u is computed as follows: ' 2 * ||Common(v(u),v(u ' ))||1 \nsc(u, u )= ||v(u)||1 + ||v(u ')||1 in which v(u) avector representation of the method content, and Common(V, \nV ' ) is de.ned as Common(u, v)[i]= min(u[i],v[i]). This formula is the ratio of the common part over \ntheir average size to measure the similarity. ClassandPackageLevel Similarity. The declaration simi\u00adlarity \nsd is de.ned similarly to that for methods. The content similarity sc is computed based on how manyof \ntheir chil\u00addren can be mapped. 2 *|MaxMatch(content(C), content(C ' ), sim)|sc(C, C ' )= |content(C)| \n+ |content(C')| The MaxMatch function takes twosets of entities C and ' C and returns a set of pairs \nsuch that sim(u, u ' ) is greater '' than a chosen threshold and there exists no u such that sim(u, u \n'' ) > sim(u, u ' ).  3.3 Mapping Algorithm OATtakes two project trees as input, aligns them, and com\u00adputes \nthe transformations from one tree to another. It maps nodes in a top-down order, mapping parent nodes \nbefore ' their children. When method m is class C s child and C is mapped to C, we .rst try to map m \nto C ' s child. If a match is not found, we assume that m is moved to another class. We adopted this \nstrategy from UMLDiff[41] to reduce the number of candidate matches that need to be examined. At any \ntime, each node is placed in one of three sets: (1) AM, it is already mapped to another node, (2) PM, \nits parent nodeis mappedbutitisnot mappedtoanynode,and (3) UM, the node and its parent are not mapped. \nOATmaps nodes in UM .rst and the children of mapped ones are put in PM for further consideration.Forexample, \nwhena package is mapped, its sub-packages are put in PM. The mapped ones are moved to AM, and the remaining \nones that were not mapped to their parent s children are put back to UM for later processing.  When \nthere are a large number of unmapped nodes, a pairwise comparison of all nodes in UM would be inef.\u00adcient. \nTo overcome this problem, OAT uses the following hash-based optimizations: OAT.rst hashesthe nodesin \nUM by their name and only compares the nodes with the same name to .nd the mapped nodes in UM.For the \nremaining nodes in UM,it then hashes those nodesin each setby their structural characteristic vectors \nusing the Locality Sensitive Hashing scheme (LSH) [4]. This LSH-based .ltering helps OATdivide the remaining \nnodes in UM into the subsets with the same hashcode, and apply the MaxMatch function on the nodes in \neach subset. The characteristic vector of a class is summed-up from the normalized vectors of their methods. \nWe normalize methods vectorstohavethe same lengthof1before sum\u00admingthemuptobuildthevectorofthe containing \nclassto avoid the problem of unbalanced sizes between those meth\u00adods. However, in other cases for comparing \nmethods, their corresponding vectors will not be normalized. When mapping method nodes in UM, in addition \nto sub-dividing the nodes using their hash values, we also use sd to quickly identify methods with a \nsimilar declaration. Figures5and6summarize our origin analysis algorithm.  1 function MaxMatch(C, C \n' , sim)// .nd maximum weighted match 1 2 L = \u00d8 2 3 for(u, u ' ) . C \u00d7 C ' 3 4 if(sim(u, u ' ) = <) \n 4 5 ' ) L = L . (u, u 5 6 sortDescendingly(L) 6 7 while(L . = \u00d8) 7 8 (u, u ' ) = L.top() 8 9 M = \nM . (u, u ' ) '' ' 10 for(v, v ):(v, u ) . L . (u, v ) . L 9 11 L.remove((v, v ' )) 10 11 12 Figure \n5. Greedy Matching Algorithm 13 14 Figure 8 illustrates a matching process between two 15 project trees. \nTwo package nodes org.apache.axis.providers.java 16 17 and org.apache.axis.providers.java are mapped \n.rst, and OAT then 18 maps their class nodes. When EJBProvider classes are mapped, 19 OAT maps their \nmethod nodes such as getNewService and mak\u00ad 20 eNewService based on their declaration and content similarity. \n21 22 23 4. Client API Usage Extractor(CUE) 24 25 This section describes CUE, a client API usage extractor. \n 26 Section 4.1 presents the model and extraction algorithm for 27 API usages via invocation. Section \n4.2 presents the model 28 and extraction algorithm for API usages via inheritance. 29 4.1 API Usage via \nInvocation This section presents our graph-based representation for API usages via invocation and the \ncorresponding extraction. 4.1.1 i-Usage Model An API provides the functionality via its elements. Those \nel\u00adements provide the computation (via methods) or the storage of data (via objects).To usea function \nprovidedby an API, a client could call the computational elements (e.g. invoking a method) or process \nthe data elements (e.g. initializing an object, using it as an input/output parameter). When multi\u00adple \nAPI methods/objects are used, the relations, e.g. the or\u00adders and dependencies, among those elements \nare important because theymust follow the intended API usage speci.ca\u00adtions. Such usages are often related \nto the control structures (e.g. if, while)due to the branching or repetition of the compu\u00adtation and \ndata processing. CUE represents the API i-usages in clients via a graph\u00adbased model called iGROUM (invocation-based, \nGRaph\u00adbasedObjectUsageModel).In general, each usageis repre\u00adsentedbya labeled, directed,acyclic graph,in \nwhich,the us\u00adages of API elements are represented as nodes, while the de\u00adpendencies are modeledbyedges.An \naction node represents a method invocation (i.e. a usage of an API computation el\u00adement).A data node \nrepresents an object (i.e. a usage of an API data element). The label of each node is the fully qual\u00ad \nfunction Map(T,T ')// .nd mapped nodes and change operations UM.addAll(T,T ') forpackages p . T , p ' \n. T ' // map on exact location if location of u and u ' is identical then Map(p, p ') forpackages p \n. T n UM, p ' . T ' n UM // unmapped pkgs if Sim(p, p ' ) = < then SetMap(p, p ')// map on similarity \nforeach mapped pairs of packages (p, p ' ) . M MapSets(Children(p), Children(p '))) // map parent-mapped \nclasses forclasses C . T n UM, C ' . T ' n UM // unmapped classes if (C and C ' are in a text-based/LSH-based \n.ltered subset and sim(C, C ' ) = <)then SetMap(C, C ')// map on similarity foreach mapped pairs of classes \n(C, C ' ) . M MapSets(Children(C), Children(C '))) // parent-mapped meths formethods m . T n UM, m ' \n. T ' n UM // unmapped meths if (m and m ' are in a text-based or LSH-based .ltered subset and sim(m, \nm ' ) = < and dsim(m, m ' ) = \u00b5 then SetMap(m, m ')// map on similarity Op = ChangeOperation(M) return \nM, Op function SetMap(u, u ')// map two nodes M.add((u, u ' )) UM.remove(u, u ') PM.add(content(u), content(u \n')) function MapSets(S, S ')// map two sets of nodes M2 = MaxMatch(S, S ' , sim)// use greedy matching \nforeach (u, u ' ) . M2 SetMap(u, u ') Figure 6. Tree-based Origin Analysis Algorithm i.ed name and the \nsignature of the corresponding method or class. An edge from an action node to another node repre\u00adsents \nthe control and data dependencies.Anedge fromadata node to an action node shows that the corresponding \nobject is used as an input of the corresponding call. Similarly, an edge with the opposite direction \nshows an output relation. Action nodes have some attributes to represent their input signature (e.g. \na list of parameter types, modi.ers, a return type, and exceptions that could be thrown). DEFINITION \n1 (iGROUM). An invocation-based, graph\u00adbased object usage model is a directed, labeled, acyclic graph \nin which: 1. Eachaction node represents a method call; 2. Eachdata node represents a variable; 3. Eachcontrol \nnode represents the branching point of a control structure (e.g. if,for, while,switch); 4. An edge connecting \ntwo nodes x and y represents the control and data dependencies between x and y;and 5. The label of an \naction, data, control, and operator node is the name, data type, or expression of the corresponding method, \nvariable, control structure, or operator, along with the type of the corresponding node.   Figure \n7. API i-Usage models in JBoss before and after migration to a new JFreeChart library version Figure7 \nshows two graph-based API usage modelsex\u00adtracted from the code in Figure 1. The usage changes be\u00adtweentwomodelsare \nillustratedbythegraynodeswithbold edges.For simplicity,in the .gure,a labelis displayed with only class \nand method names, even though our model actu\u00adally retains the fully quali.ed class name and the signature \nof a method. In Figure 7b, an edge from the action node '' y =DefaultTableXYDataset.<init> to the action \nnode z =DefaultTable\u00adXYDataset.addSeries represents that y ' is used before z '. An edge from the action \nnode x=XYSeries.<init> to the data node s=XY-Series shows that s is used to store the output of x. An \nedge coming out of s changes its target from y to z '. That means, '' s is now used as an input to z \ninstead of y '. Note that x ' and x represent different API elements x is a deprecated ' constructor \nwith two parameters while x is a new construc\u00adtor with three parameters. The .gure also shows a for loop \nrelated to the invocation of method XYSeries.add.  4.1.2 i-Usage Extraction CUE extends our prior work \n(Nguyen et al. s graph-based object usage model [25]) to build API usage models from each method in client \ncode. It parses the source code into Abstract SyntaxTrees (AST), traverses the trees to analyze the AST \nnodes of interest within a method such as method invocations, object declarations and initializations, \nand con\u00adtrol statements (e.g. if,while,for),andbuilds the corresponding action, data, and control nodes \nalong with control and data dependencies between them. Static methods, type casting, and type checking \noperations of a class are considered as special invocations of the corresponding objects. After ex\u00adtraction, \nCUE removes all action and data nodes and the edges that do not represent the usages of API elements \nor have no dependencies with those API elements. In other words, CUE determines a sub-graph of the original \nobject usagemodelthatisrelevanttotheusageofAPI elementsby performing program slicing from the API usage \nnodes via control and data dependencyedges. Moreover, since a par\u00adticularAPIcouldbeusedbymultiple methodsinclient, \nCUE uses a set of iGROUM models to represent API i-usages. Whilebuilding an iGROUM, CUEalso takes into \naccount subtyping information, which is described in details in Sec\u00adtion 4.2. CUEusesthe inheritance \ninformationofthe system to create nodesand labels more precisely.Forexample,ifa method C.m is calledin \nan iGROUM, CUEchecks whether C.m is inherited from a method A.m, i.e., C.m is not ex\u00adplicitly declared \nin the body of the class C. If that is the case, the action node corresponding to the call would be a \nnode with the labelbuilt from A.m, rather than from C.m. If C.m overrides A.m, the labelisbuilt from \nC.m. Furthermore, CUE also performs an intra-procedural analysis on object instantiation, assignment, \nand type cast\u00ading statementstokeep trackofthe typesofvariables used withina method.Forexample,ifit encountersa \nmethod call o.m with o being an object declared with type C, and later .nds that o is casted into an \nobject of class C ', then the label ' of action node for o.m isbuilt from C .m, rather than C.m.  4.2 \nAPI Usage via Inheritance This section presents our graph-based representation for API usages via inheritance \nand the corresponding extraction. 4.2.1 Method Overriding and Inheritance Assume that class C in a client \ncode directly inherits from an API class A. Method C.m overrides a non-static method A.m if C.m is declared \nin class C and has the same signature with A.m. In Object-Oriented Programming, method A.m is not considered \nto be overridden in C when the method C.m with the same signature as A.m is not explicitly declared in \n C. However, because C.m could still be invoked, CUE still considers that C.m exists and inherits from \nA.m. If A.m and C.m are static, CUE does not consider that C.m over\u00adrides A.m because they are called \nbased on the declaring types. If A.m is static and C.m is not explicitly declared in C,CUEdoes not consider \nthe existence of C.m.  1. If C.m inherits A.m, a call to C.m will be a call to A.m. Thus, if A.m is \nchanged, not only the calls to A.m need to be adapted in response to the change of A.m,but also all the \ncalls to C.m need to be considered for adaptation.  Figure 8. API x-Usage models in JBoss before and \nafter migration to a new Axis library version For example, if A.m has a newly added parameter, all method \ncalls to A.m and C.m must be considered for the adaptation of adding a new parameter. Otherwise, the \nprogram might not be compiled or such calls might be accidentally dispatched as a call to another method \nthat has the same-signature as A.m (e.g. a parent method Ao.m of A.m). 2. If C.m overrides A.m, theyneed \nto have the same signa\u00adture. Thus, if A.m is changed, C.m needs to be consid\u00aderedtobe changed correspondingly(see \nFigures3and4). 3.A call to A.m might be a call to C.m in run-time due to dynamic dispatching. Thus, if \nC.m is changed, not only all the calls to C.m and C1.m, with C1 being a de\u00adscendant class of C, are considered \nfor adaptation corre\u00adspondingly,but also all calls to A.m must be taken into consideration. In CUE, the \noverriding and inheritance relationships are de.ned in the same way as above among the methods of two \nAPI classes A and A1 in which A1 inherits from A, and among the methods of two client classes C and C1 \nin which C1 inherits from C.  4.2.2 x-Usage Model Now, let us describe the model and extraction algorithm \nfor API usagesvia inheritance. CUEusesxGROUM(Extension\u00adbased, GRaph-basedObjectUsageModel) to represent \nall API x-usages in the client system and and all libraries by considering each library a sub-system \nof the client system under investigation. An xGROUM is a directed, labeled, acyclic graph in which each \nnode represents a class or a method in the client system and its libraries. The label of a node is its \nfully quali.ed name and signature. Interfaces are considered as special classes. Edges between class \nnodes represent subtyping relations. Edges from class nodes to method nodes represent the con\u00adtainment \nrelations. Between method nodes, there are two kinds of edges: o-edge(overriding)andi-edge(inheriting): \nAn o-edge from a node C.m to A.m shows that C.m overrides A.m. This means that C inherits from A, and \nC.m is declared in C and has the same signature as A.m. An i-edge from a node C.m to A.m shows that C.m \ninherits from A.m. This means that C inherits from A, and C.m is notexplicitly declared in C even though \nC.m could be invoked and has the same signature as A.m. C.m is called an i-node in xGROUM, and other \nmethod nodes are called o-nodes. Figure 8 illustrates the xGROUM for Figure 4. Fig\u00adures 8L and 8C show \nthe API class A=EJBProvider in package org.apache.axis.providers.java and the client class C=EJBProvider \nin package org.jboss.net.axis.server. Figures 8L and 8C show those two classes in their new versions. \nThe o-edges and o\u00adnodes, such as C.getNewServiceObject, are illustrated with solid double lines, meaning \nthat they are of interest. The i-nodes such as C.getEJBHome and the i-edges are shown in dashed lines, \nmeaning that they are just placeholders and not being really declared or created. Added nodes such as \nA.getContext(Properties) are painted in gray color. Updated nodes are represented in double lines along \nwith bi-directional arrows between them in the graphsoftwoversions.Forexample,an arrowwiththela\u00ad  bel \nrename from node A.getNewServiceObject (in Figure 8L) to 1 function GroumDiff(U, U ')// align and differ \ntwo usage models A.makeNewServiceObject (in Figure 8L ) shows that those two 2 forall u . U, v . U ' \n// calculate similarity between u and v nodes represent a renamed method. An arrow from node based on \nlabel and structure A.getServiceClass(Context, String) in Figure 8L to node A.getService\u00ad 3 sim(u, v) \n= a lsim(u, v) + ( nsim(u, v) Class(String, SOAP, Context) in Figure 8L signi.es the change in 4 M \n=MaximumWeightedMatching(U, U ' , sim) // matching the parameter list of the corresponding method. As \nshown in Figure 8C , class C in JBoss is adapted accordingly to the changes to class A in Axis. To build \nxGROUM,CUE extends the inheritance hierar\u00adchy by adding o-edges between methods. The i-nodes and i-edges \nare not explicitly created, but being computed on demand. Note that only one xGROUM is built for the \nen\u00ad 5 6 7 8 9 10 11 12 foreach (u, v) . M: if sim(u, v) < a then M.remove((u, v)) //remove low matches \nelse switch // derive change operations on nodes case Attr(u) .= Attr(v):Op(u)= Op(v)= replaced case \nAttr(u) = Attr(v), nsim(u, v) < 1:Op(u)= updated default:Op(u)= unchanged foreach u . U, u .. M:Op(u)= \n deleted // unaligned nodes foreach v . U ' , v .. M:Op(v)= added // are deleted/added tire client \nsystem and its libraries. 13 Ed = EditScript(Op) 14 return M, Op, Ed 5. Usage Adaptation Miner (SAM) \nThis section describes our API usage adaptation miner, Figure 9. API Usage Graph Alignment Algorithm \nSAM. SAM uses iGROUMs to represent API i-usages in any client code as well as in the library s test and \ndemo code. Thus, the adaptation of API usages could be modeled as a generalization of changes to the \ncorresponding individ\u00adual iGROUMs. SAMalso uses a graph alignment algorithm to identify API i-usage changes \nthat are caused by changes to APIs, and a mining algorithm that generalizes common edit operations from \nmultiple API usage changes to .nd API usage adaptation patterns. LIBSYNC uses such patterns to recommend \nthe locations and edit operations. Levenshtein distance [17]. It also takes into account the re\u00adnamed \nAPI elements: the similarity level of the labels rep\u00adresenting renamed or moved API elements is set as \nhigh as that for unchanged ones. Neighborhood structures of nodes is approximated by Exas characteristic \nvectors [24], thus, their similarity measurement nsim(u, v) is based on the dis\u00adtance of such vectors. \nGroumDiff calculates and combines the similarity of labels and neighborhood structures of all pairs of \nnodes u and v between two graphs as sim(u, v) = 5.1 i-Usage Change Detection Using OAT, LIBSYNC derives \nsets .L and .P containing the changed entities (including packages, classes, methods) of the library \nand the client program respectively. It is able to align such code entities between two versions as well. \nThus, for anymethod m E .P , LIBSYNC builds two iGROUMs U and U ' for m in two corresponding versions. \nThen, it uses GroumDiff, our graph-based alignment and differencing al\u00adgorithm, to .nd the changes between \nthe corresponding us\u00adage models U and U ' . Our graph alignment algorithm, GroumDiff, maps the nodes \nbetween two iGROUMs such that the aligned nodes represent the unchanged, updated, or replaced nodes while \nunmapped nodes represent the added/deleted nodes. Let us illustrate the pseudo-code of our GroumDiffalgorithm \n(Fig\u00adure 9) via the example in Figure 7. The mapped nodes in Figure 7 would be the ones with identical \nlabels (e.g. x and x ' ,y and y ').Newnodes likez ' ,b1,b2 would not be mapped. As we could see, mapped \nnodes tend to have highly similar labels and structures. For example, unchanged API elements would have \nidentical names; replaced ones tend to have sim\u00adilar names; and both types tend to havesimilar neighborhood \nstructure with the others. The idea of GroumDiff algorithm is to map the nodes between two graphs based \non the similarity of their labels a lsim(u, v) + f nsim(u, v) (line 3). Since each node u in a graph \nshould be mapped to only one node v that has the highest possible similarity, GroumDiff .nds the max\u00adimum \nweighted matching on such nodes using the calcu\u00adlated similarity values as weights (line 4). The resulting \npairs of matched nodes are the alignment results (lines 7-10). Matched nodes having little similarity \nwould be reported as unmapped nodes (lines 11-12). Then based on the alignment results, SAM derives a \nse\u00adquence of graph edit operations. That is, the un-aligned (un\u00admapped) nodes are considered added or \ndeleted (lines 11\u00ad12). Aligned nodes with different labels, or the same la\u00adbels but different structures \nor attributes are considered up\u00addated or replaced (lines 8-9). Other nodes are considered unchanged (line \n10). From this information, GroumDiffde\u00adrives an edit script to describe the changes as a sequence of \ngraph operations (line 13). This edit script is then used to mine the API usage adaptation patterns. \nLet us revisit Figure 7. GroumDiffaligns nodes with iden\u00adtical names in Figures 7a and 7b. Node z ' = \nDefaultTableXY-Dataset.addSeries and two nodes, boolean b1 and b2, are not mapped; thus, they are considered \nas added. The nodes with the label <init> (x and x ')are replaced. The node s=XYSeries is updated because \nits neighboring nodes changed. Thus, the derived editing script is and neighborhood structures with other \nnodes. The simi- Replace XYSeries.<init>(..., boolean) larity of node labels, lsim(u, v), is based on \nstring-based XYSeries.<init>(..., boolean, boolean) 1 protected JFreeChartcreateXyLineChart() throws \nJRException { 2 ChartFactory.setChartTheme(StandardChartTheme.createLegacyTheme()); 3JFreeChartjfreeChart=ChartFactory.createXYLineChart(..., \ngetDataset(),...); ... 4 return jfreeChart } 5 6 Figure 10. API Usage Changes in JasperReports 7 8 \n9 Replace DefaultTableXYDataset.<init>(XYSeries) DefaultTableXYDataset.<init>(boolean) Add DefaultTableXYDataset.addSeries(XYSeries) \nImprovement. To improve the alignment accuracy and to deal with renamed nodes, SAMusesOATto .nd API meth\u00adods \nand classes whose declaration changed. Then, it makes the action nodes representing the calls to them \nto have the same labels in two iGROUMs under comparison. That is, if m is updated into m ' in the library \nthrough renaming, the la\u00ad ' bel of an action node representing an invocation of m is re\u00adplacedby the \nlabelbuilt from m. Note that those two nodes must also have similar neighborhoods. In brief, SAM uses \nthe knowledge of the origin analysis result to improve the alignment of nodes in the corresponding iGROUMs. \n5.2 x-Usage Change Detection Changes to an xGROUM are detected by OAT and rep\u00adresented as editing operations: \n(1) Add/Delete nodes and edges: e.g., a new class is added, a method is deleted, or an overriding edge \nchanges its target method; (2) Replace/Up\u00addate nodes and edges: e.g an edge is changed from i-edge to \no-edge when a new method overrides a parent method. It is changed from o-edge to i-edge when an overriding \nmethod is deleted. Notethatwhenthe signatureofa method C.m is changed into C.m ' that overrides some \nparent method A.m ' , SAM considers this change as the addition of a new o-node for C.m ',the old nodeC.m \nhaving the same signature with A.m will become an i-node.  5.3 Usage AdaptationPattern Mining Given \na library L and a client system P ,SAMidenti.es the locations and edit operations required to adapt API \nusages when migrating to the version i of L. Since individual API usages can have different edit operations \nbetween two cor\u00adresponding iGROUMs, SAM.ndsa common subsetof edit operations that occur frequently among \nmultiple API usages. We call such frequent edit operations anadaptation pattern. Forexample, JasperReportsversion \n3.5.0 migrated to use JFreeChart API version 1.0.12. Analyzing JasperReports code, we found that the \naddition of the invocation statement ChartFactory.setChartTheme(StandardChartTheme.createLegacyTheme()); \nbefore the call to ChartFactory.create*Chart occurs in 53 methods (Figure 10). That is, JFreeChart at \nversion 1.0.12 has a new function ChangePattern(.Pi, .Li)//mine usage change patterns foreach (U, U ' \n) . UsageChange(.Pi, .Li)//compute changes Add(GroumDiff(U, U ')) intoE // add to dataset of sets of \nops F = MaximalFrequentSet(E, \u00df)//mine maximal frequent subset of edit operations foreach f . F : Find \nU, U ' : f . GroumDiff(U, U ')//.nd usageschangedbyf Extract (Uo(f),U o' (f)) from (U, U ' ) // extract \nref models Add (Uo(f),U o' (f)) into Ref(f)// addtoreference set forf return F, Ref Figure 11. AdaptationPattern \nMining Algorithm feature, which speci.es the style or theme of a chart object. This new feature requires \nthat the instantiation of a chart object needs to create a ChartTheme object .rst. JFreeChart s ChartFactory, \nthefactory class for creating chart objects, now hasanewmethod ChartFactory.setChartTheme to set the \ntheme for a chart object. JFreeChart also provides a class StandardChart-Theme as the default implementation \nof ChartTheme which has a method named StandardChartTheme.createLegacyTheme() to cre\u00adate and return a \nChartTheme that does not apply anychanges to the JFreeChart defaults. Mining Algorithm. The algorithm \nto recover the API i\u00adusage adaptation patterns is illustrated in Figure 11. It re\u00adceives two inputs: \n(1) .Li is the set of API elements that changed at or before version i and (2) .Pi contains pro\u00adgram \nentities in client code that changed after migration to the version i of L. The change set, .Li,is computedby \nap\u00adplyingOATtotheversion historyofthe library L backward from the version i. Similarly, .Pi is computed \nby running OAT on two versions of the client program before and after migration to Li. The .rst step \nis to determine all API i-usages that changed due to the changes .Li (UsageChange(.Pi,.Li)in line 2). \nThis step is necessary since some i-usage changes are irrelevant to theAPI changes.Todo that, SAMdeterminesall \nmethodsin both L and P that are affected by the change in Li by using the information produced from the \nlocation detection algo\u00adrithm (Section 6.2.1 will detail this algorithm). More specif\u00adically, it uses \nthe output of that algorithm, i.e. the change set IU(P, .Li) that contains the methods and classes in \nthe clientcodeand librarythatareaffectedbytheAPI s changes at version i via method overriding and inheritance \nrelations. Then,SAMremoves API i-usage changes thathave nothing to do with the set IU(P, .Li). Next, \nfor eachof such usage changes, SAMextracts from the corresponding surrounding code the pairs of usage \nmod\u00adels (U, U ' ) before and after the change at version i (line 2). To do this, for each changed methodm \nE .Pi containing such usage changes, SAM builds the corresponding usage ' models (U, U ' ), and determines \nwhether U and/or U have anyaction nodes that represent anymethod(s) in the change set IU(P, .Li).Ifsuchapairexists, \ntheirchangeswouldbe related to the API changes. SAMuses GroumDiffto .nd the  ' changes between U and \nU in term of a set of graph editing operations. That set of operations is added into the set E of API \nusage changes caused by the API s changes (line 3). Then,SAMminesthe maximal frequent subsetof editing \noperations for all the sets in E, using the frequent itemset mining algorithm in [2]. This algorithm \n.nds every set f that occurs in the sets in E with a relative frequency (i.e. con.dence) at least \u00df, \nwith \u00df isa chosen threshold, and with itssizeaslargeas possible(line4).Foreachofsuch f,SAM .nds all pairs \n(U, U ' ) whose change operations include f (line6).For eachpair (U, U ' ),itextractsthe usageskeletons \n' Uo(f) and U (f) (line 7). This pair of usage skeletons are o called reference models, which provide \nthe context of the change f (will be explained next). Then, it adds that pair into a set Ref(f) for each \nmined frequent subset f (line 8), which is now considered as an adaptation pattern of API usages (i.e. \nfrequent changes on API usage models). Relative frequency. The relative frequency of a set of change \noperation f is calculated as follows. Assume that ' f is a subset of edit operations from U to U . F \nreq(f) de\u00adnotes the frequencyof f, i.e. the number of sets of change operations in E contain f. NUsage(f) \nis the number of API usages of the nodes affected by f, i.e. the number of all iGROUMs containing U(f). \nThen, the relative frequencyof f is de.ned as F req(f)/NUsage(f). Reference model. Uo(f) is de.ned as \nthe set of mapped nodes in U that are affected by f and their dependent nodes ' via control and data \ndependencies. U (f) is similarly de\u00ad o ' .ned. Uo(f) and U (f) provide the contextual information o on \nthe change f. Thus, they are called the reference mod\u00adels of f. If another usage V contains Uo(f), one \ncould con\u00adsider that V also has a context that could be adapted by the ' frequent adaptation f. Thus, \nUo(f) and U (f) are used to o model the usage skeletons corresponding to the adaptation pattern f. Figure \n12 shows an adaptation pattern and its reference models found in JasperReports with respect to JFreeChart \nlibrary migration. The pattern includes the addition of two method calls StandardChar tTheme.createLegacyTheme \nand Chart\u00adFactory.SetChartTheme, which lead to the addition of two new action nodes and one data node, \nalong with the associated edges, and the addition of an edge from the data node Chart-Factory. Since \nsetChartTheme and createAreaChart use the same data node ChartFactory, SAM derives the reference models \nof '' this change as U0 and U as in Figure 12. U contains not 00 only the added sub-graphbut also the \nnodes having depen\u00addencies with the changed nodes. The use of reference model is also useful in the cases \nof newly added API elements. Suppose that m is a newly added method in the new version of a library and \na call to m is added in U '. In this case, no node in U can be mapped to the data node m. However, there \nmight have some other currently existing nodes that are dependent on m and they could be mapped back \nto U. Thus, SAM could use those ' nodes as referenced nodes for mapping between U and U in the case of \nnewly added nodes. In such cases, SAM will also add those dependent nodes into the reference model for \nlater mapping. Improvements.To improve the accuracyof the mined pat\u00adterns of usage changes, .Pi contains \nthe code taken from different sources: client code on different systems, or test code and demo code provided \ninside the API s source code. The threshold \u00df willbe slightly different.Forexample, on test code and \ndemo code, a usage pattern might be tested or demonstrated for only once. Therefore, we could choose \nsmall \u00df.Test code might contain the initialization of test data and the assertion of test results, which \nmight not be parts of API usage speci.cations.To improve the quality of mined protocols, SAM discards \nsuch initializations and assertions whenbuilding the iGROUMs on the test code. 6. Recommending Adaptations \nSections6.1and6.2 discusshow LIBSYNC suggeststhe code locations to be adapted and edit operations required \nfor those API usage adaptations. 6.1 API i-Usage Adaptation Recommendation After detecting API changes \nvia OAT and mining usage adaptation patterns on relevant codebases viaSAM,LIB-SYNC has a knowledge base \nof API usage skeletons and corresponding adaptation patterns for an API L of inter-est.For eachversion \ni of the library L, the knowledge base contains the set of usage adaptation patterns F at that ver\u00adsion. \nEach pattern f has a set of reference usage models ' Ref(f)=(U0,U 0). It also contains .Li,the set of \nchanged entities of L from any two consecutiveversions.With this knowledge, LIBSYNC provides API usage \nadaptation recom\u00admendations on any given client code Q that needs to be adapted to a version i of L. \n 6.1.1 Location Recommendation First, LIBSYNC determines the code locations in the client system Q that \npotentially need adaptation to Li. Using .Li and xGROUM model of Q at that version, LIBSYNC computes \ntwo change sets of methods XU(Q, .Li) and IU(Q, .Li) that are potentially affected by the changed entities \nin .Li. Details of the method to derive those two change sets will be explained in Section 6.2.2. IU(Q, \n.Li) is the set of methods and classes in L and Q that are af\u00adfectedby changed entitiesin .Li (includingoverridden \nand inherited methods). XU(Q, .Li) is the set of methods and classes in Q that areaffectedby the changed \nentitiesin .Li via method overriding and inheritance. Every code location that uses an entity in IU(Q, \n.Li) will be considered for adaptation to the changes .Li of L.We use AU(Q, .Li) to denote the set of \nthe corresponding iGROUMs of such code locations.  To improve the performance, LIBSYNC uses some pre\u00adprocessing \ntechniques. Based on text-based .ltering, it .nds the source .les that could involve the usages of L. \nEach source .le is tokenized. If a .le does not contain anytoken similar to the names of classes/methods \nin IU(Q, .Li), it will be discarded from further processing. In the next step, the remaining source .les \nare parsed andextracted tobuild API i-usage models. For each model V , LIBSYNC checks whether V contains \nsome nodes representing the usages of anyentity in IU(Q, .Li). If that is the case, it will report V \nas a location for consideration of adaptation, i.e. V will be added to AU(Q, .Li). Let us revisit the \nexample in Figures 1 and 7: L = JFreeChart, i = 0.9.17, Q = JBoss 3.2.7. Assume that JBoss is currently \nusing JFreeChart 0.9.15. Using OAT, LIBSYNC could detect IU(Q, .Li)= {A, B, x, x ' , y, y ' } with the \nfollowing information: Id Label Change A XYSeries modi.ed class B DefaultTableXYDataset modi.ed class \n x XYSeries.<init>(String,boolean) deprecated ' x XYSeries.<init>(String, boolean, boolean) added y DefaultTableXYDataset.<init>(XYSeries) \ndeprecated ' y DefaultTableXYDataset.<init>(boolean) added Usingtext-based .ltering, LIBSYNCdetectsthatthe \nsource .le ManageSnapshotServlet.java inQ = JBoss 3.2.7 has some to\u00adkens XYSeries and DefaultTableXYDataset. \nExtracting iGROUMs from this .le for further analyzing, it .nds that the iGROUM V of method doit has \nthe nodes whose labels appear in IU(Q, .Li) (Figure 7). Thus, it reports V asacode location that may \nneed the adaptation, and adds V to AU(Q, .Li) for further operation recommendation. Figure 12. API Usage \nChangePatterns and Reference Models 1 function Adapt(V, F )//adapt API usage based on change patterns \n2 foreach Uo . Ref(F )://for each change pattern f:calculate similarity to reference models 3 Relevant(V, \nUo)= sim(GroumDiff(V, Uo)) 4 (f * ,U o * ) = Max(Relevant) //.nd the most suitable 5 Ed = GroumDiff(U \n* ,U '*)//derive referenced change operations oo 6 Recommend(Ed, V )//and recommend Figure 13. Usage \nAdaptation Recommending Algorithm  6.1.2 Operation Recommendation LIBSYNC uses the API i-usage change \npatterns in its knowl\u00adedge base to derive the recommended operations for each iGROUM V in the set AU(Q, \n.Li) of usage models that are considered for adaptation. Figure 13 illustrates the algorithm for this \ntask. First, LIBSYNC determines the change pattern f* that is most suitable for V (lines 2-3).For each \npair of ' reference models (Uo,U ) in the set of all reference mod\u00ad o els in the knowledge base Ref(F \n), LIBSYNC maps Uo and V using the GroumDiffalgorithm (Figure 9), and computes the relevant degree between \nV and Uo based on the number of matched nodes over the size of Uo (line 4). Next, it ranks them to .nd \nthe reference model Uo* that is best matched to V (i.e. with highest relevance) (line 4). At last, LIBSYNC \n.nds the changes of the best matched reference model U* (line5) and recommends such changes as edit operations \non iGROUM V (line 6). Notes. Since a usage model could use many usage proto\u00adcols, LIBSYNC may .nd more \nthan one usage change pat\u00adterns f that could be mapped against V . Thus, it ranks them based on their \nsimilarity with V and their frequencies (the higher the frequencyis, the more correct the recommenda\u00adtion \nwould be). If no change pattern is suitable (e.g. the sim\u00adilarity is too little), V will be considered \nas an API usage irrelevant to API changes in .Li.  After processing all usage models, for each model \nV in recommended list AU(Q, .Li), LIBSYNC reports its loca\u00adtion, its ranked usage adaptation patterns \nfs (with similarity levels and frequencies). It also provides with each pattern a code skeleton that \nwas collected during the usage pattern mining process. If users choose a code location and a usage change \npattern for adaptation, LIBSYNC provides the recom\u00admendation for adaptation at that location. Let us \nrevisit the example in Figures 10 and 12 for L = JFreeChart, i = 1.0.12, Q = JasperReports 3.5.0. LIBSYNC \ndetects the changed set .Li of JFreeChartat thatversion as: Id Label Change A StandardChar tTheme added \nclass B ChartFactory added class a StandardChar tTheme.createLegacyTheme added b ChartFactory.setChartTheme \nadded Mining on the code base P = JasperReports, LIBSYNC recovers the change pattern f = [Add a, Add \nb]with 53 pairs of reference models (one pair is the iGROUMs (U, U ' ) for code fragments in Figure 10). \nIn Q,LIBSYNC determines that iGROUM V uses a method of class ChartFactory. Since ChartFactory is in .Li, \nit is put into IU(Q, .Li), and thus, V is put into AU(Q, .Li), meaning that it should be adapted. Matching \nV with the change patterns and reference mod\u00adels,LIBSYNC.nds U as the best match for V with the change \npattern f. In the matching, it also .nds the maps between the action nodes for twomethod calls c and \nd with the label Chart\u00ad ' Factory.createXYLineChart in U and V . Differencing U and U gives the operations \nEd = [Add a, Add b]. Thus, LIBSYNC recommends to add those two method calls, a and b, into V , along \nwith their dependencies: a is called before b and the output of a is the input of b;b is called before \nc due to such dependencies in U.Tohelpin adaptation, LIBSYNC alsopro\u00advides the reference code in JasperReports \n(Figure 10).  6.2 API x-Usage Adaptation Recommendation This section describes how LIBSYNC recommends \nadapta\u00adtions for inheritance-based library usages. 6.2.1 Location Recommendation To .nd the changes \nof xGROUM and recommend relevant adaptation, LIBSYNC starts with the change set of API .L and the change \nset .P of classes and methods in the client code.Thosetwochangesetsare obtainedfromtheexecution ofOATontwoversionsofbothAPIand \nclient sides. The outputs of this location recommendation algorithm are two change sets XU(P, .L) and \nIU(P, .L) of classes and methods thatwouldbeaffectedbythe changesin .L in the API, taking into account \nx-usages and i-usages respec\u00adtively. Thus, they are also classes and methods that could need the adaptation. \nThis algorithm is carried out as follows: If A.m E .L, any method C.m overriding A.m is considered to \nbe adapted. Thus, as A.m changes, C.m is added into XU (P, .L). C.m is also added into IU(P, .L) for \nthe consideration of usage adaptation.  If A.m E .L, anymethod D.m inheriting A.m is also considered \nfor adaptation for API usages via invocation,  i.e. D.m is added into IU(P, .L),becauseamethod call \nto D.m could be actually a call to A.m. If A.m E .L, and if C.m E .P and C.m overrides A.m, then A.m \nand anyancestor method Ao.m of A.m (i.e. overridden or inherited) is also considered to be adapted (i.e. \nA.m and Ao.m are added to IU(P, .L)), because a call to Ao.m or A.m might be dynamically dispatched as \na call to C.m. Let us take an example with P = JBoss, L = Axis. The changes are in Figures 3, 4, and \n8. The set .L contains the following classes and methods: Id Label Change A EJBProvider modi.ed class \nin Axis B Serializer modi.ed class in Axis A.n EJBProvider.getNewServiceObject renamed A.p EJBProvider.getContext \nadded A.q EJBProvider.getEJBHome changed in parameter B.m Serializer.writeSchema changed in parameters, \nRetType ... ... Then, based on the xGROUM, two methods D.m and E.m (overridingB.m)and the methodC.n (overridingA.n) \nare considered to be adapted, i.e. added to XU(P, .L) (see the Table below for the ids). Their corresponding \nclasses are also added to XU(P, .L). Thus, the set XU (P, .L) contains the following classes/methods: \nId Label Change C EJBProvider extend modi.ed class in JBoss D AttributeSerializer extend modi.ed class \nin JBoss E ObjectNameSerializer extend modi.ed class in JBoss C.n EJBProvider.getNewServiceObject should \nbe renamed  C.q EJBProvider.getEJBHome should be changed in paras D.m AttributeSerializer.writeSchema \nchange in paras, RetType E.m ObjectNameSerializer.writeSchema change in paras, RetType ... ... They are \nalso added to IU(P, .L), along with A.p (newly added method) and other i-nodes, i.e. the placehold\u00aders \nsuch as C.p. The IU(P, .L) set contains the followings: Id Label Change A EJBProvider modi.ed class in \nAxis B Serializer modi.ed class C EJBProvider modi.ed class in JBoss D AttributeSerializer modi.ed class \nin JBoss E ObjectNameSerializer modi.ed class in JBoss A.n EJBProvider.getNewServiceObject renamed C.n \nEJBProvider.getNewServiceObject should be renamed A.p EJBProvider.getContext added C.p EJBProvider.getEJBHome \ninherited from added method  C.q EJBProvider.getEJBHome should be changed in paras D.m AttributeSerializer.writeSchema \nchange in paras, RetType E.m ObjectNameSerializer.writeSchema change in paras, RetType ... ... The outputs \nXU(P, .L) and IU(P, .L) are used in the mining algorithm (Figure 11), in location/operation recom\u00admendation \nfor API i-usages (Section 6.1.1), and operation recommendation for x-usages (Section 6.2.2).   6.2.2 \nOperation Recommendation After detecting XU(P, .L), LIBSYNC will recommend for adaptation of API x-usages \nfor the methods in XU(P, .L). Currently, the recommendation for x-usages is as follows: Pointing out \nthe classes/methods that need API x-usage adaptation.Forexample,twomethods AttributeSerializer.write-Schema \nand ObjectNameSerializer.writeSchema in Figure 3.  Showing the changes to the API classes and methods \nin use. For example, it shows the changes to Serial\u00adizer.writeSchema with two operations: Add a new parameter \nand Replace the return type.  Suggesting the operation of classes and methods in client code that need \nadaptation. For example, it suggests to Add a parameter of type Class, and to Replace return type into \norg.w3c.dom.Element. It recommends fully quali.ed names to help the developers to use correct packages. \n 7. Evaluation This section presents theevaluationof our framework.For OAT, the parameter setting, < \n=0.75 and \u00b5 =0.625, is used.For SAM, the parameter setting, a =0.5, f =0.5 and a =0.5 is used in GroumDiff \nalgorithm, and \u00df =0.5 is used in ChangePattern. 7.1 Precision and Recall of Origin Analysis To evaluate \nthe quality of change detection in OAT, we conducted two experiments. First, we manually checked the \nresults. Second, we compared our results with Kim et al. s API matching results [18], which has been \ncompared with a number of origin analysis tools [19, 38, 40, 41]. In the .rst experiment, weexecuted \nOATon four differentversion pairs of JHotDraw(seeTable1). JHotDrawwas chosenduetothe availability of \nsource code and its rich set of documentation. The result is shown in Table 1. Columns Mapped and Checked \nshow the numbers of method-level matches that were returned from our tool OAT and the ones that were \nman\u00adually checked respectively. Between two versions 5.4b2\u00ad6.0b1,OATreturned 3,250 pairs, and we checked \nrandomly\u00ad selected 100 pairs. Columnsand X display the correctly and incorrectly detected matches. Precision \nshows the preci\u00adsion value, which is the ratio between the number of cor\u00adrectly detected pairs over the \ntotal number of checked, de\u00adtected pairs. The precision of OAT is very high with only a couple of incorrect \npairs. For two versions 5.4b1-5.4b2, there are only 9 method-level matches because those ver\u00adsions are \nbeta releases with minor changes. In other cases, OAT s precision ranges from 97% to 100%. In the second \nexperiment, we executed both OAT and Kim stoolonseveral consecutiveversionpairsof JFreeChart and JHotDraw. \nFrom the outputs of two tools, all method\u00adlevel matches weren compared to .nd the common set of matches \n(column ), and to identify a set of matches that were returnedby OAT but notby Kim s (columnOAT-Kim), \nTable 1. Precisionof Origin AnalysisTool OAT v Version Pairs Mapped Checked X Precision 5.2-5.3 71 71 \n69 2 97% 5.3-5.4b1 70 70 68 2 97% 5.4b1-5.4b2 9 9 8 1 89% 5.4b2-6.0b1 3,250 100 100 0 100% anda setof \nmatches that were foundby Kim sbut notby OAT(column Kim-OAT).Those differences were further man\u00ad ually \nchecked to see if theyare correct (column),incorrect (column X)or undecidable (column ?).For each group, \nwe also computed the number of correct pairs and incorrect pairs over the total number of pairs: column \nTP (True Posi\u00adtive) and FP (False Positive) respectively.Table2shows the comparison results.Onaverage, \nOATreportsfewer pairsbut its accuracy is often higher. In addition, the gap between (TP + FP ) to 100% \nis smaller in OAT than Kim s tool. This means that OAT produced fewer cases that were hard to determine \nthe correctness of the involved matches.  7.2 Adaptation of i-Usage We evaluated the quality ofLIBSYNC \nin recommending API i-usage adaptations. In order to recommend API i-usage adaptation, LIBSYNC needs \nto detect API i-usage changes and derive adaptation patterns. The experiments were carried out on large-scale, \nreal\u00adworld systems in different application domains with long histories of development. Table 3 shows \nthe details about those subject systems.Forexample, JBossisa middle-ware framework that has been developed \nfor more than 6 years with more than 40 releases. It has about 40 thousand meth\u00adods and uses hundreds \nof different libraries. 7.2.1 Detection of i-Usage Changes In thisexperiment, ourevaluation questions \nare(1) can CUE detect API usage changes correctly? and (2) are the client\u00adside, API usage changes detectedby \nCUE andSAM indeed causedby theevolutionof libraries usedby the client? We ran our tool on those three \nsubject client systems to report all API usage changes along with edit operations. For each client, we \nrandomly picked 30 to 40 of the API usage changes. We manually checked the correctness of detected edit \noperations in API usage skeletons. In addition, we also examined whether the identi.ed API usage changes \nare indeed caused by the changes to APIs. Table 4 shows the result of this investigation. Column Changes \nshows the number of checked cases in detected API usage changes. Column Libs shows the number of libraries \ninvolved in those reported usage changes. The next two columns(Operations)display the numbers of correctly \n(see column v) and incorrectly detected API i-usage changes (column X)respectively. Similarly,the last \ntwocolumns (col\u00adumn API)show how correctly our tool relates an API usage change to the changes to API(s). \n Table 2. Comparisonof Origin AnalysisTools n JFreeChart Pairs OAT Kim . v OAT-Kim . v Kim -OAT X ? \nTP FP X ? TP FP 0.9.5-0.9.6 5 5 5 0 0 0 0 100% 0% 0 0 0 0 100% 0% 0.9.6-0.9.7 368 366 364 4 2 1 1 50% \n25% 2 0 0 2 0% 0% 0.9.7-0.9.8 3157 3158 3121 36 36 0 0 100% 0% 37 7 30 0 19% 81% 0.9.9-0.9.10 144 159 \n130 14 3 10 1 21% 71% 29 14 2 13 48% 7% 0.9.10-0.9.11 9 7 7 2 2 0 0 100% 0% 0 0 0 0 100% 0% 0.9.11-0.9.12 \n66 66 35 31 12 10 9 39% 32% 31 19 6 6 61% 19% 0.9.12-0.9.13 134 133 133 1 1 0 0 100% 0% 0 0 0 0 100% \n0% 0.9.13-0.9.14 84 96 74 10 6 3 1 60% 30% 22 12 6 4 55% 27% 0.9.14-0.9.15 6 12 6 0 0 0 0 100% 0% 6 6 \n0 0 100% 0% 0.9.15-0.9.16 79 75 65 14 13 0 1 93% 0% 10 2 4 4 20% 40% 0.9.16-0.9.17 205 240 171 34 4 30 \n0 12% 88% 69 27 42 0 39% 61% 0.9.17-0.9.18 36 45 36 0 0 0 0 100% 0% 9 0 9 0 0% 100% 0.9.18-0.9.19 140 \n282 102 38 30 8 0 79% 21% 180 41 139 0 23% 77% Avg. 341.00 357.23 326.85 14.15 8.38 4.77 1.00 73% 21% \n30.38 9.85 18.31 2.23 51% 32% n JHotDraw Pairs OAT Kim . v OAT-Kim . v Kim -OAT X ? TP FP X ? TP FP 5.2-5.3 \n71 77 66 5 3 2 0 60% 40% 11 2 4 5 18% 36% 5.3-5.4b1 70 69 56 14 12 1 1 86% 7% 13 5 6 2 38% 46% 5.4b1-5.4b2 \n9 13 8 1 1 0 0 100% 0% 5 3 1 1 60% 20% 5.4b2-6.0b1 3,250 3,239 3,239 11 11 0 0 100% 0% 0 0 0 0 100% 0% \nAvg. 850 849.5 842.25 7.75 6.75 0.75 0.25 86% 12% 7.25 2.5 2.75 2 54% 26% Table 3. Subject Systems NumberAxis \nyAxis = new NumberAxis(yTitle); yAxis.setMinimumAxisValue(-0.2); yAxis.setMaximumAxisValue(0.4); Client \nLife Cycle Releases Methods Used APIs JBoss (JB) 10/2003 -05/2009 47 10-40K 45-262 JasperReports (JR) \n01/2004 -02/2010 56 1-11K 7-47 Spring (SP) 12/2005 -06/2008 29 10-18K 45-262 Table 4. Precision of API \nUsage Change Detection Client Changes Libs Operationsv APIv X X JasperReports 30 5 30 0 27 3 JBoss 40 \n17 38 2 38 2 Spring 30 15 30 0 30 0 In most cases, our tool correctly detected the edit op\u00aderations \nand correctly related the API usage changes on the client-side and the library-side changes (see twocolumns \n). In 93 cases out of 100 checked cases, our tool correctly de\u00adtected API usage changes and related them \nto library-side API declaration changes. Example 1. Let us discuss an interesting case in Figure 14. \nThis usage of JFreeChart creates a NumberAxis object and sets up its range and ticking unit. In the versions \nbefore 0.9.12 of JFreeChart, setting up the range of a NumberAxis object is carried out by invoking two \nmethods setMinimumAxisValue and setMaximumAxisValue. However, from version 0.9.12, those two methods \nare deprecated, a new method setRange is added and should be used instead. SAMcorrectly identi.ed API \nusage skeletonsbut did make some mistakes in deriving edit op\u00aderations for adaptation. Instead of reporting \ntwo deletions and one addition, it reported one replacement and one ad\u00addition. Importantly, however, \nSAM is able to recognize and correlate that the API usage change is due to the change in JFreeChart API \nspeci.cation. yAxis.setRange(-0.2, 0.4) ; DecimalFormatformatter = new DecimalFormat( 0.##% ); yAxis.setTickUnit(new \nNumberTickUnit(0.05,formatter)); Figure 14. Creating NumberAxis in JFreeChart In some other cases, our \ntool wrongly related client-side updates with library-side updates even though the library\u00adside updates \ndid not affect the corresponding usage in the client code such asamethod saccess visibility modi.cation. \nAnother case is when the API method changes the types of exceptions that could be thrown,but the client \ncode always catches the general exception type, Exception. Another one is when the API method changes \nthe type of one parameter into its super-type (e.g. from String to Comparable). In those cases, there \nwere some changes to those API usages but these changes were irrelevant to changes in the declaration \nof the API. Our tool mistakenly related them. Let us explain another interesting case of API usage changes \ndue to the evolution of a library. Example 2. Ruby,a scripting language/framework forWeb applications, \nprovides a new method parse in the version 0.8.0. This method accepts two string inputs: one referring \nto the piece of code required to compile and one referring to the compiling con.guration.It returnsa \nNode as the root node of the parse-tree. Using this newly added feature of Ruby, developers of Spring \nchanged their implementation of the method createJRubyObject, which receives a string scriptSource as \nthe input script, and returns an Object created by that script. Intheoldversionof this method,it callsthe \nevalScript method  a) ... IRubyObject rubyObject = ruby.evalScript(scriptSource); //direct evaluatation \nif (rubyObject instanceof RubyNil) { throw new ScriptCompilationException(...); ... Table 5. Accuracyof \ni-Usage Location Recommendation v API -Client Version Rec. Hint X Miss JFree -Jasper 3.0.1 -3.1.0 12 \n9 3 0 0 Mondrian -Jasper 1.3.4 -2.0.0 3 3 0 0 0 Axis -JBoss 3.2.5 -4.0.0 8 5 1 2 0 Hibernate -JBoss 4.2.0 \n-4.2.1 29 25 0 3 1 JDO2 -Spring 2.0m1 -2.0m2 8 8 0 0 0 JRuby -Spring 2.0.3 -2.0.4 7 7 0 0 0 b) ... Node \nscriptRootNode = ruby.parse(scriptSource, ); //parse the script IRubyObject rubyObject = ruby.eval(scriptRootNode); \n// eval the parse-tree if (rubyObject instanceof RubyNil) { //if cannot eval the whole script String \nclassName = .ndClassName(scriptRootNode); //just .nd class name rubyObject = ruby.evalScript( \\n +className+ \n.new ); //to create an object }if (rubyObject instanceof RubyNil) { throw new ScriptCompilationException(...); \n... Figure 15. API usage changes in Spring with respect to the evolution of Ruby directly on scriptSource. \nThis direct evaluation could have a disadvantage in which the script is not well-formed, or more severely,is \ncraftedas malicious code thatexploits some vul\u00adnerabilities of the system. In the new version (Figure \n15b)), Spring code .rst calls parse to parse the scriptSource intoa tree, and then calls the eval method \nto execute this parsed code. If the script is ill-formed or maliciously crafted, the parsing will not \nreturn a well-formed parse tree and the eval method simply does not execute, thus, resolving the above \nvulnera\u00adbility issue. LIBSYNC was able to mine this API usage adap\u00adtation pattern based on the API usage \nchanges in the client codeof Springat2.0(JRubyScriptUtils.java).  7.2.2 Recommendation of Adaptation \nLocations This section describes the evaluation of LIBSYNC in recom\u00admending the code locations for adaptation \nto a target library version. We chose six pairs of a library and its client. For each pair, let VC and \nVA be the versions of the client sys\u00adtem and the library respectively.For each VA, we selected another \nversion VA ' of the library such that the client sys\u00adtem had been changed in a later version than VC \n. We ran LIBSYNC on VA and V ' to detect library-side changes and A client-side API usage updates. LIBSYNC \nwas run to rec\u00adommend the locations for adaptation. Then, we manually checked in the history of the client \ncode after that version VC to see whether the code at those locations have been ac\u00adtually updated to \nwork with the new library version VA' . Table5shows the result.JFree and Jasper are used as ab\u00adbreviations \nfor JFreeChart and JasperReports, respectively. Column Version shows the pairs of versions of the library \nand the client system. Column Rec. shows the number of the rec\u00adommended locations. Columns , X, Miss \nshow the correctly, incorrectly, and missed detected locations respectively. Col\u00adumn Hint represents \nthe cases in JasperReports corresponding to the changes of JFreeChart in which the API methods are deprecated,but \ndevelopers have not updated yet. As shown, LIBSYNC provides highly correct locations. It missed in only \none case out of 67 recommendation locations in total. Table 6. Accuracyof i-Usage Operations Recommendation \nv Mine on Adapt to Usages Rec. Miss 3.2.5-3.2.8 3.2.5-4.0.5 6 4 4 2 4.0.5-4.2.3 4.0.5-5.0.1 26 25 25 \n1  7.2.3 Recommending Edit Operationsfor Adaptation In this experiment, LIBSYNC was run on a development \nbranch in JBoss history to mine adaptation patterns for all libraries used by JBoss. We then ran LIBSYNC \nfor adapta\u00adtion recommendation on another branch which derives from the same branching point with the \n.rst branch but are in\u00addependently developed onward. We manually checked the recommended operations against \nthe actual adaptations in the second branch.Arecommendationis considered correct if it has at least one \ncorrect operation at a correct location. Table 6 shows the result. The .rst two columns show the development \nbranches on which LIBSYNC mined the adaptation patterns and applied adaptation recommenda\u00adtions respectively. \nColumn Usages shows the number of us\u00adage adaptations. Column Rec shows the numbers of recom\u00admended adaptations.AsshowninTable6, \nLIBSYNCprovides highly correct recommendations. The recommended opera\u00adtions were correct as developers \nchanged all of them except for three missing cases in which old usages were completely abandoned and \ntotally new usages were used. LIBSYNC was able to correctly recommend the adaptation forallexamplesin \nthis paper.Forexample, LIBSYNC could recommend the correct adaptation for the case of JFreeChart in JBoss \nin Figure 1. This change happened in JBoss 3.2.8 in the branch from version 3.2.5 to 3.2.8 and was learned \nto adapt from version 4.0.1 to 4.0.2 in the branch from version 3.2.5 to 4.0.5. Those two changes were \nactually the patches to .xabugof NullPointerException when using the deprecated constructor of DefaultTableXYDataset. \n  7.3 Adaptation of x-Usage This section describes our evaluation of LIBSYNC in recom\u00admending the code \nlocations for the adaptation of x-usages in JBoss.We useda wide rangeofversionsin JBossasde\u00adscribedinTable3.For \neach changein JBoss fromversion i to j, we used OAT to collect all changed APIs into the change set .L.We \nidenti.ed a set XU(P, .Li), all meth\u00adods in JBoss at version i that override some API s methods. Each \nmethod in XU(P, .Li) is considered for adapta\u00adtion recommendation with the same operations as those op\u00aderations \nthat are detected on the overridden method in the API.A recommendation toa method atversion i was con\u00ad \n Table 7. Accuracyof x-Usage Recommendation v Rec. X Name 6 4 2 Class name 1 1 0 Package name 2 2 0 \nDeprecated 3 3 0 Change parameter type 4 4 0 Del parameter 7 7 0 Change return type 6 6 0 Change exception \n1 1 0 Add parameter-Change Exception 1 1 0 Add parameter-Change Return type 2 2 0 sidered correctifthatmethodwasreallychangedinthesame \nway in the version j, otherwise, it was marked incorrect. The result is shown inTable 7. Each row represents \none particular type of changes in the external API(s). For ex\u00adample, the row Name is only for the methods \nwith changed names. The row of Add parameter-Change Exception is for the methods changing in both parameter \nand exception that could be thrown. Therefore, the numbers in a column are exclusive from row to row. \nColumn Rec shows the number of recommended locations. Columns and X respectively show the correctly and \nincorrectly detected locations for x\u00adusage adaptation. LIBSYNC provides highly correct recommendations. \nIt is incorrect in only two cases out of the total of 33 cases. These two wrong cases have the same nature \nin which they are both caused by the incorrect mapping results from OAT when detecting the changes of \nthe class Persis\u00adtenceInfoImpl in javax API that is used in JBoss from version 4.0.3SP1 to 4.0.4GA. Instead \nof reporting two deleted meth-ods(getPersistenceXmlFileUrl and setPersistenceXmlFileUrl), and two added \nmethods (getPersistenceUnitRootUrl and setPersistenceUnit-RootUrl), OAT reported two renaming operations. \nTherefore, the recommendationwas two renaming operations while the correct adaptation should be two deletions \nand two addi\u00adtions.For other types of changes, the recommendations are all correct. 8. RelatedWork This \nsection describes related work on API evolution, API usage modeling, and adaptation. 8.1 Library Evolution \nand Client Adaptation There are severalexisting approaches to support client adap\u00adtations to cope with \nevolving libraries. Chow and Notkin [7] proposed a method for changing client applications in re\u00adsponse \nto library changes a library maintainer annotates changed functions with rules that are used to generate \ntools that will update client applications. Henkel and Diwan s CatchUp [15] records and stores refactorings \nin an XML .le that can be replayed to update client code. However, its up\u00addate support is limited to \nthree refactorings: renaming oper\u00adations (e.g. types, methods, .elds), moving operations (e.g. classes \nto different packages, static members), or change op\u00aderations (e.g. types, signatures). Thekey idea of \nCatchUp, record-and-replay, assumes that the adaptation changes in client code are exact or similar to \nthe changes in the library side.Thus,itworkswellfor replaying renameormoverefac\u00adtorings or supporting \nAPI usage adaptations via inheritance. However, CatchUp cannot suggest programmers how to ma\u00adnipulate \nthe context of API usages in client code such as the surrounding control structure, or the ordering between \nmethod-callssuchastheexampleshownin Section2. More\u00adover,CatchUp requires that library and client application \nde\u00advelopers use the same development environment to record API-level refactorings, limiting its adoption \nin practice. SemDiff[8] mines API usage changes from other client code or the evolution of library itself, \nsimilar to our work. The key difference of LIBSYNC from SemDiff is that our work uses a graph-based representation \nto capture the con\u00adtext of an API usage, including the dependencies among method calls and with a surrounding \ncontrol logic. In our work, an adaptation pattern is captured in term of a frequent set of graph editing \noperations that are common to multiple API usage skeletons before and after library migration. In contrast, \nSemDiffde.nes an adaptation pattern asa frequent replacement of a method invocation. That is, if a method \ncall to A.m is changed to B.n in several adaptations, B.n is likely to be a correct replacement for the \ncalls to A.m. As SemDiffmodels API usages in terms of method calls, it can\u00adnot support complex adaptations \nthat involve multiple ob\u00adjects and method calls and that require the knowledge of the surrounding contextof \nthose calls. LIBSYNC skeydeparture point is that when a library s API declarations are modi.ed, such \nevolution often involves coordinating uses of multiple objects and multiple method calls under certain \ncontexts. Xing and Stroulia s Diff-CatchUp [43] automatically rec\u00adognizes API changes of the reused framework \nand suggests plausible replacements to the obsolete APIs based on work\u00ading examples of the framework \ncodebase. Dig et al. s Mol\u00adhadoRef [11] uses recorded API-level refactorings to resolve merge con.icts \nthat stem from refactorings; this technique can be used for adapting client applications in case of sim\u00adple \nrename and move refactorings occurred in a library. Tansey and Tilevich s approach [33] infers generalized \ntransformation rules fromgivenexamples so that application developers use the inferred rules to refactor \nlegacyapplica\u00adtions. However, this approach focuses on annotation refac\u00adtorings that replace the type \nand naming requirements to the annotation requirementsofatarget framework. Furthermore, this approach \ndoes not focus on updating client applications to cope with evolving libraries. Andersen and Lawall [3] \nproposed spdiff that identi.es commonchangesmadeinasetof .les.APIdeveloperscould use spdiff to extract \na generic patch and apply it to other clients. Their approach models the changes at the level of text-line \nchanges. On the other hand, LIBSYNC uses a graph\u00adbased representation to capture more thorough syntactic \nand semantic information for adapting API usages. SmPL [21, 27]isa domain-speci.c source transformation \nlanguage that capturestextual patches witha more semantic descriptionof program changes.However,it does \nnotexplicitly distinguish API changes from their usage changes.  8.2 Program Differencing and Origin \nAnalysis Existing differencing techniques use similarities in names and structures to match code elements \nat a particular gran\u00adularity: (1) lines and tokens [35], (2) abstract syntax tree nodes[13,23],(3) control.owgraph \nnodes[5],(4) program dependence graph nodes [6], etc. For example, diff com\u00adputes line-level differences \nper .le using the longest com\u00admon subsequence algorithm [17]. Our API usage compari\u00adson algorithm is \nsimilar to program differencing algorithms that it detects changes between two versions of an internal \nprogram representation using name-, content-and structure\u00adbased similarities. Zou and Godfrey[47] .rst \ndeveloped an origin analysis techniqueto support softwareevolution anal\u00adyses by mapping corresponding \ncode elements between two programversions.Several other techniques[10,18,19,38,41, 47] improved and extended \nprior origin analysis techniques; some of these derive refactoring transformations move a method, renamea \nclass, add an input parameter, etc. based onthe matching result betweentwoversions. OATis similar to \nthese techniques in that it maps corresponding code API declarations and API usage code fragments. 8.3 \nAPI Usage Speci.cation Extraction There exist several approaches for extracting API usage speci.cations. \nThe forms of recovered API usage speci.\u00adcations and patterns include .nite state automaton [37, 46], \npairs of method calls [22, 39], partial orders of calls [1,34], ComputationTree Logic formulas [36]. \nThe API usage rep\u00adresentations in those static approaches are still limited, for example, the patterns \nare without control structures and in\u00advolve only individual objects belonging to one class. Our graph-based \nAPI usage representation captures multi-object API usage patterns with control structures. In contrast \nto those static approaches, dynamic approaches recover the speci.cations by investigating the execution \ntraces of programs [14, 28 30, 44]. These dynamic ap\u00adproaches require a huge amount of execution traces. \nOur graph-based representation, iGROUM, captures API usage patterns with control and data dependencies \namong method calls, and surrounding control logic such as while loop and if statement. The API usage \nrepresentations in this paper ex\u00adtend our prior work on GrouMiner [25] to tailor the original multi-object \nusage representation in order to capture the rel\u00adevant context surrounding the use of external APIs. \nIn par\u00adticular, iGROUMexplicitly captures API types and methods that appear in action and data nodes, \nso that program slic\u00ading can isolate only a sub-graph that is relevant to the use ofa particular library.We \nalso createda new model called xGROUM to represent overriding and inheritance relation\u00adships between \nclient methods and API methods.  8.4 Empirical Studies of API Evolution Dig and Johnson [9] manually \ninvestigated API changes us\u00ading the change logs and release notes to study the types of library-side \nupdates that break compatibility with existing client code, and discovered that 80% of such changes are \nrefactorings. Xing and Stroulia [42] used UMLDiffto study API evolution in several systems, and found \nthat about 70% of structural changes are refactorings. Kim et al. s signa\u00adture change pattern analysis \n[20] categorizes API signature changesin termsof data-.owinvariant.Yokomori et al. [45] investigated \nthe impact of library evolution on client code applications using component ranking measurements.Padi\u00adoleau \net al. [26] found that API changes in the Linuxker\u00adnel lead to subsequent changes on dependent drivers, \nand such collateral evolution could introduce bugs into previ\u00adously mature code. These studies motivate \nthe need for sup\u00adporting complexclient adaptations beyond replaying library\u00adside refactorings in client \ncode. 9. Conclusion and FutureWork This paper presents LIBSYNC that guides developers in adapting API \nusages in client code to cope with evolving libraries. LIBSYNC uses several graph-based techniques to \nrecover the changes of API usage skeletons from codebase of other client systems, and recommends the \nlocations and edit operations for adapting API usage code. The evaluation of LIBSYNC on real-world software \nsystems shows that it is highly correct and useful. Especially, LIBSYNC can recover and recommend on \ncomplex API usage adaptations, which current state-of-the-art approaches are hardly able to sup\u00adport. \nOne limitation of our approach is that it requires a set of programs that already migrated to a new library \nversion under focus or adequate amount of API usages within the library itself. As it is not straightforward \nto identify which version of a library is used by client systems, we are cur\u00adrently in the process of \ndeveloping a co-evolution analysis framework that can automatically extract the versioning in\u00adformation \nof libraries used by client systems in order to buildalarge corpusofAPI usageskeletonsandtobuilda repository \nof API usage adaptation patterns. References [1] M. Acharya,T. Xie, J. Pei, and J. Xu. Mining API patterns \nas partial orders from source code: from usage scenarios to speci.cations. In ESEC-FSE 07: Proceedings \nof the 6th joint meeting of the European software engineering conference and the ACM SIGSOFT symposium \non The foundations of software engineering, pages 25 34.ACM Press, 2007. [2] R. Agrawal and R. Srikant. \nFast algorithms for mining asso\u00adciation rules in large databases. In VLDB 94: Proceedings of the 20th \nInternational Conference onVery Large Data Bases, pages 487 499. Morgan Kaufmann Publishers Inc., 1994. \n[3] J. Andersen and J. Lawall. Generic patch inference. In ASE 08: Proceedings of the 23rdIEEE/ACM International \nConference onAutomated SoftwareEngineering,2008,pages 337 346. IEEE Computer Society, 2008.  [4] A. \nAndoni and PiotrIndyk. E2 lsh 0.1 user manual. http://web.mit.edu/andoni/www/LSH/manual.pdf. [5]T. Apiwattanapong,A.Orso, \nandM.J. Harrold.Adifferenc\u00ading algorithm for object-oriented programs. In ASE 04: Pro\u00adceedings of the \n19th IEEE International Conference onAu\u00adtomated Software Engineering, pages 2 13. IEEE Computer Society, \n2004. [6] D. Binkley, S. Horwitz, and T. Reps. Program integration for languages with procedure calls. \nACM Transactions on Software Engineering and Methodology, 4(1):3 35, 1995. [7] K. Chow and D. Notkin. \nSemi-automatic update of appli\u00adcations in response to library changes. In ICSM 96: Pro\u00adceedings of the \n1996 International Conference on Software Maintenance, page 359. IEEE Computer Society, 1996. [8] B. \nDagenais and M.P. Robillard. Recommending adaptive changes for framework evolution. In ICSE 08: Proceedings \nof the 30th International Conference on Software Engineer\u00ading, pages 481 490.ACM Press, 2008. [9] D. \nDig and R. Johnson. The role of refactorings in API evo\u00adlution. In ICSM 05: Proceedings of the 21st IEEE \nInterna\u00adtional Conference on Software Maintenance, pages 389 398. IEEE Computer Society, 2005. [10] \nD. Dig and R. Johnson. Automated detection of refactorings in evolving components. In ECOOP 06: Proceedings \nof Eu\u00adropean Conference on Object-Oriented Programming, pages 404 428. Springer, 2006. [11]D.Dig,K. \nManzoor,R.Johnson,andT.N.Nguyen.Refactoring\u00adaware con.guration management for object-oriented pro\u00adgrams. \nIn ICSE 07: Proceedings of the 29th International Conference on Software Engineering, pages 427 436. \nIEEE Computer Society, 2007. [12] D. Engler, D. Y. Chen, S. Hallem, A. Chou, and B. Chelf. Bugs as deviant \nbehavior: a general approach to inferring errors in systems code. In SOSP 01: Proceedings of the eighteenthACM \nsymposium on Operating systems principles, pages 57 72.ACM Press, 2001. [13] B. Fluri, M.W\u00a8Changeursch, \nM. Pinzger, and H. C. Gall. distilling tree differencing for .ne-grained source code change extraction. \nIEEE Transactions on Software Engi\u00adneering, 33(11):18, November 2007. [14] M. Gabel and Z. Su. Javert: \nfully automatic mining of gen\u00aderal temporal properties from dynamic traces. In SIGSOFT 08/FSE-16: Proceedings \nof the 16thACM SIGSOFT Inter\u00adnational SymposiumonFoundationsof software engineering, pages 339 349.ACM \nPress, 2008. [15] J. Henkel and A. Diwan. CatchUp!: capturing and replaying refactorings to support API \nevolution. In ICSE 05: Proceed\u00adings of the 27th International Conference on Software Engi\u00adneering, pages \n274 283.ACM Press, 2005. [16] J.W. Hunt andM. Mcilroy. An algorithm for differential .le comparison. \nTechnical report, 1976. [17]J.W.HuntandT.G. Szymanski. Afast algorithmfor com\u00adputing longest common subsequences. \nCommunications of theACM, 20(5):350 353, 1977. [18] M. Kim, D. Notkin, and D. Grossman. Automatic inference \nof structural changes for matching across program versions. In ICSE 07: Proceedings of the 29th International \nConference on Software Engineering, pages 333 343. IEEE Computer Society, 2007. [19] S. Kim,K.Pan, andJ.E. \nJames Whitehead. When functions change their names: Automatic detection of origin relation\u00adships. In \nWCRE 05: Proceedings of the 12thWorking Con\u00adference on Reverse Engineering, pages 143 152. IEEE Com\u00adputer \nSociety, 2005. [20] S. Kim, E. J. Whitehead, and . J. Bevan, Jr. Properties of signature change patterns. \nIn ICSM 06: Proceedings of the 22nd IEEE International Conference on Software Mainte\u00adnance, pages 4 13. \nIEEE Computer Society, 2006. [21] J. L. Lawall, G. Muller, and N.Palix. Enforcing the use of API functions \nin Linux code. In ACP4IS 09: Proceedings of the 8th workshop on Aspects, components, and patterns for \ninfrastructure software, pages 7 12.ACM Press, 2009. [22]B.LivshitsandT. Zimmermann. Dynamine: .nding \ncommon error patterns by mining software revision histories. SIG-SOFT Softw. Eng. Notes, 30(5):296 305, \n2005. [23] I. Neamtiu,J.S.Foster, andM. Hicks. Understanding source code evolution using Abstract Syntax \nTree matching. In MSR 05: Proceedings of the 2005 Mining Software Reposi\u00adtoriesWorkshop, pages 2 6.ACM \nPress, 2005. [24] H. A. Nguyen,T.T. Nguyen, N. H. Pham, J. M. Al-Kofahi, and T. N. Nguyen. Accurate and \nef.cient structural char\u00adacteristic feature extraction for clone detection. In FASE 09: Proceedings of \nthe International Conference on Funda\u00admental Approaches to Software Engineering, pages 440 455. SpringerVerlag, \n2009. [25]T.T. Nguyen,H.A. Nguyen,N.H. Pham,J.M. Al-Kofahi, andT. N. Nguyen. Graph-based Mining of Multiple \nObject UsagePatterns. In ESEC/FSE 09: Proceedings of the 17th ACM SIGSOFT Symposium on theFoundations \nof Software Engineering.ACM Press, 2009. [26]Y.Padioleau,J.L.Lawall,andG. Muller. Understandingcol\u00adlateral \nevolution in Linux device drivers. SIGOPS Operating Systems Review, 40(4):59 71, 2006. [27]Y.Padioleau,J.L.Lawall, \nandG. Muller. SmPL:Adomain\u00adspeci.c languagefor specifying collateralevolutionsin Linux device drivers. \nElectronic Notes Theoretical Computer Sci\u00adence, 166:47 62, 2007. [28] M. Pradel andT. R. Gross. Automatic \ngeneration of object usage speci.cations from large method traces. In ASE 09: Proceedings of the 24th \nIEEE/ACM International Conference on Automated Software Engineering, pages 371 382. IEEE Computer Society, \n2009. [29] M. K. Ramanathan, A. Grama, and S. Jagannathan. Path\u00adsensitive inference of function precedence \nprotocols. In ICSE 07: Proceedings of 29th international conference on Soft\u00adware Engineering, pages 240 \n250. IEEE CS, 2007. [30] S. Shoham, E.Yahav, S. Fink, and M. Pistoia. Static speci\u00ad  .cation mining \nusing automata-based abstractions. In ISSTA 07: Proceedings of the international symposium on Software \ntesting and analysis, pages 174 184.ACM Press, 2007. [31] JBoss: An open source, standards-compliant, \nJ2EE based ap\u00adplication server. http://sourceforge.net/projects/jboss/. [32] Subversion.tigris.org. http://subversion.tigris.org/. \n[33]W.TanseyandE.Tilevich. Annotation refactoring: inferring upgrade transformations for legacyapplications. \nIn OOPSLA 08: Proceedings of the 23rdACM SIGPLAN conference on Object-oriented programming systems languages \nand appli\u00adcations, pages 295 312.ACM Press, 2008. [34] S. Thummalapenta and T. Xie. Alattin: Mining alternative \npatterns for detecting neglected conditions. In ASE 09: Pro\u00adceedings of the 24th International Conference \nonAutomated Software Engineering, pages 283 294. IEEE Computer Soci\u00adety, 2009. [35] W. F. Tichy. The \nstring-to-string correction problem with block moves. ACM Transactions on Computer Systems, 2(4):309 \n321, 1984. [36] A.Wasylkowski and A. Zeller. Mining temporal speci.ca\u00adtions from object usage. In ASE \n09: Proceedings of the 24th IEEE/ACM International Conference onAutomated Software Engineering, pages \n295 306. IEEE Computer Society, 2009. [37] A.Wasylkowski, A. Zeller, and C. Lindig. Detecting object \nusage anomalies. In ESEC-FSE 07: Proceedings of the 6th joint meeting of the European software engineering \nconfer\u00adence and theACM SIGSOFT symposium onFoundations of software engineering, pages 35 44.ACM Press, \n2007. [38] P. Weissgerber and S. Diehl. Identifying refactorings from source-code changes. In ASE 06: \nProceedings of the 21st IEEE/ACM International Conference onAutomated Software Engineering, pages 231 \n240. IEEE Computer Society, 2006. [39]C.C.WilliamsandJ.K. Hollingsworth. Automaticminingof source code \nrepositories to improvebug .nding techniques. IEEETrans. Softw. Eng., 31(6):466 480, 2005. [40]W.Wu,Y.-G. \nGueheneuc,G. Antoniol,andM. Kim. Aura:A hybrid approach to identify framework evolution. In ICSE 10: \nProceedings of the 32nd International Conference on Software Engineering.ACM Press, 2010. [41] Z. Xing \nand E. Stroulia. UMLDiff: an algorithm for object\u00adoriented design differencing. In ASE 05: Proceedings \nof the 20th IEEE/ACM International Conference onAutomated Software Engineering, pages 54 65.ACM Press, \n2005. [42] Z. Xing and E. Stroulia. Refactoring practice: How it is and how it should be supported -an \nEclipse case study. In ICSM 06: Proceedings of the 22nd IEEE International Conference on Software Maintenance, \npages 458 468. IEEE Computer Society, 2006. [43] Z. Xing and E. Stroulia. API-evolution support with \nDiff-Catchup. IEEETrans. Softw. Eng., 33(12):818 836, 2007. [44] J.Yang, D. Evans, D. Bhardwaj,T. Bhat, \nand M. Das. Per\u00adracotta: mining temporal API rules from imperfect traces. In ICSE 06: Proceedings of \nthe 28th international conference on Software engineering, pages 282 291.ACM Press, 2006. [45] R. Yokomori, \nH. Siy, M. Noro, and K. Inoue. Assessing the impact of framework changes using component ranking. In \nICSM 09: Proceedings of the International Conference on Software Maintenance, pages 189 198. IEEE Computer \nSociety, 2009. [46] H. Zhong, L. Zhang,T. Xie, and H. Mei. Inferring resource speci.cations from natural \nlanguage API documentation. In ASE 09: Proceedings of the 24th IEEE/ACM International Conference onAutomated \nSoftwareEngineering,ACM Press, 2009. [47] L. Zou and M.W. Godfrey. Using origin analysis to detect merging \nand splitting of source code entities. IEEETransac\u00adtions on Software Engineering, 31(2):166 181, 2005. \n      \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Reusing existing library components is essential for reducing the cost of software development and maintenance. When library components evolve to accommodate new feature requests, to fix bugs, or to meet new standards, the clients of software libraries often need to make corresponding changes to correctly use the updated libraries. Existing API usage adaptation techniques support simple adaptation such as replacing the target of calls to a deprecated API, however, cannot handle complex adaptations such as creating a new object to be passed to a different API method, or adding an exception handling logic that surrounds the updated API method calls.</p> <p>This paper presents LIBSYNC that guides developers in adapting API usage code by learning complex API usage adaptation patterns from other clients that already migrated to a new library version (and also from the API usages within the library's test code). LIBSYNC uses several graph-based techniques (1) to identify changes to API declarations by comparing two library versions, (2) to extract associated API usage skeletons before and after library migration, and (3) to compare the extracted API usage skeletons to recover API usage adaptation patterns. Using the learned adaptation patterns, LIBSYNC recommends the locations and edit operations for adapting API usages. The evaluation of LIBSYNC on real-world software systems shows that it is highly correct and useful with a precision of 100% and a recall of 91%.</p>", "authors": [{"name": "Hoan Anh Nguyen", "author_profile_id": "81435597381", "affiliation": "Iowa State University, Ames, IA, USA", "person_id": "P2354065", "email_address": "", "orcid_id": ""}, {"name": "Tung Thanh Nguyen", "author_profile_id": "81418592614", "affiliation": "Iowa State University, Ames, IA, USA", "person_id": "P2354066", "email_address": "", "orcid_id": ""}, {"name": "Gary Wilson", "author_profile_id": "81470647156", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P2354067", "email_address": "", "orcid_id": ""}, {"name": "Anh Tuan Nguyen", "author_profile_id": "81464668863", "affiliation": "Iowa State University, Ames, IA, USA", "person_id": "P2354068", "email_address": "", "orcid_id": ""}, {"name": "Miryung Kim", "author_profile_id": "81335492829", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P2354069", "email_address": "", "orcid_id": ""}, {"name": "Tien N. Nguyen", "author_profile_id": "81418592616", "affiliation": "Iowa State University, Ames, IA, USA", "person_id": "P2354070", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869486", "year": "2010", "article_id": "1869486", "conference": "OOPSLA", "title": "A graph-based approach to API usage adaptation", "url": "http://dl.acm.org/citation.cfm?id=1869486"}