{"article_publication_date": "10-17-2010", "fulltext": "\n METAFJIG A Meta-Circular Composition Language for Java-like Classes * Marco Servetto Elena Zucca Dipartimento \ndi Informatica e Scienze dell Informazione Universit\u00e0 di Genova {servetto,zucca}@disi.unige.it Abstract \nWe propose a Java-like language where class de.nitions are .rst class values and new classes can be derived \nfrom exist\u00ading ones by exploiting the full power of the language itself, used on top of a small set of \nprimitive composition operators, instead of using a .xed mechanism like inheritance. Hence, compilation \nrequires to perform (meta-)reduction steps, by a process that we call compile-time execution. This approach \ndiffers from meta-programming techniques avail\u00adable in mainstream languages since it is meta-circular, \nhence programmers are not required to learn new syntax and id\u00adioms. Compile-time execution is guaranteed \nto be sound (not to get stuck) by a lightweight technique, where class com\u00adposition errors are detected \ndynamically, and conventional typing errors are detected by interleaving typechecking with meta-reduction \nsteps. This allows for a modular approach, that is, compile-time execution is de.ned, and can be imple\u00admented, \non top of typechecking and execution of the under\u00adlying language. Moreover, programmers can handle errors \ndue to composition operators. Besides soundness, our technique ensures an additional important property \ncalled meta-level soundness, that is, typ\u00ading errors never originate from (meta-)code in already com\u00adpiled \nprograms. Categories and Subject Descriptors D.3 Programming Languages [ D.3.3 Language Constructs and \nFeatures] General Terms Languages Keywords Java, meta-programming, module composition * This work has \nbeen partially supported by MIUR DISCO -Distribution, Interaction, Speci.cation, Composition for Object \nSystems. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA/SPLASH \n10 October 17 21, 2010, Reno/Tahoe, Nevada, USA Copyright c . 2010 ACM 978-1-4503-0203-6/10/10. . . $5.00 \n 1. Introduction The recognized need of going beyond inheritance has led to a variety of proposals for \nimproving the .exibility and expressivity of object-oriented programming, such as, e.g., mixin classes \n[15, 3], virtual classes [11, 12], generic classes as in Java 5, mixin modules [13, 4] and other proposals \nfor adding a module/component level [24, 1], traits [10, 27, 14, 23]. All these proposals share a common \nlimitation: users are provided with a .xed set of composition mechanisms. A natural way to overcome this \nlimitation is to allow pro\u00adgrammers to write (meta-)code that can be used to generate customized code. \nHowever, meta-programming techniques provided in mainstream Java-like languages,1 such as tem\u00adplate meta-programming \nin C++, can be very dif.cult to understand, since their syntax and idioms are esoteric com\u00adpared to conventional \nprogramming, and well-formedness of generated code can only be checked a posteriori , making the whole \nprocess hard to debug. In this paper, instead, we propose a limited and sound meta-circular2 approach. \nThat is: Class de.nitions3 are .rst-class values, hence new classes can be derived from existing, rather \nthan by a .xed mech\u00adanism like inheritance, by exploiting the full power of the language on top of a \nsmall set of primitive composition operators, as in [7, 6, 20]. Hence, compilation of a class table requires \nto perform (meta-)reduction steps, by a process that we call compile-time execution.  Well-formedness \nof generated code is checked during compile-time execution itself, making the process easy to debug. \n  Here, rather than guaranteeing soundness employing (only) static checks, that would require a sophisticated \ntype system with structural types for meta-expressions, we pro\u00ad 1 By Java-like languages we mean object-oriented \nclass-based languages with nominal types, such as Java, C++ and C#. 2 Meta-circular languages are also \ncalled homogeneous, see, e.g., [29]. 3 But not other kinds of language terms: in this sense the meta-programming \napproach is limited. pose a lightweight solution, called checked compile-time execution, where typechecking \nat the conventional level is the standard one. However, meta-reduction steps are always perfomed on typechecked \ncode, hence are safe. Type check\u00ading at the level of class composition operators, instead, is dynamic, \nthat is, performed during meta-reduction. The mo\u00adtivation is twofold: to allow a modular approach, that \nis, compile-time execution is de.ned, and can be implemented, on top of typechecking and execution of \nthe underlying lan\u00adguage; and to allow programmers to handle composition errors, e.g., by relying on \nthe Java exception mechanism. Besides soundness, our technique ensures an additional important property \ncalled meta-level soundness. Intuitively, typing errors found during compile-time execution never originate \nfrom library (meta-)code, that is, programs which have already been compiled. This is not granted by \nother approaches like C++ templates. We formally describe our approach by de.ning a calcu\u00adlus, called \nMETAFJIG, where class de.nitions are .rst-class values which can be combined by using four primitive \nop\u00aderators, namely sum, restrict, alias, and redirect. The con\u00adventional (that is, excluding meta-level \nfeatures) fragment of METAFJIG is a subset of FJIG [21, 20], a Java-like calculus in the spirit of Featherweight \nJava [17] (FJ for short), where inheritance has been generalized to the much more .exible notion originally \nproposed in Bracha s Jigsaw framework [7]. Here, for sake of simplicity, we have omitted some FJIG features \nwhich are not relevant for the present work. To show the effectiveness of our technique, we have im\u00adplemented \na prototype compiler, which can be downloaded (along with its sources and some examples) at: http://www.disi.unige.it/person/ServettoM/MetaFJig/. \nThis prototype compiler supports a superset of the lan\u00adguage used in the formal description, including \nprimi\u00adtive types int and boolean, prede.ned classes Object, RuntimeException and String, arrays, void \nmethods, statements, if, while, try-catch, for-each, variable declaration and assignment. Execution of \na program is con\u00adventionally started from a special main statement. The conventional and meta-level features \nof METAFJIG are informally presented in Section 2.1 and Section 2.2, re\u00adspectively, whereas Section 2.3 \nshows some applications. The examples are written in the extended syntax supported by the prototype compiler, \nhence they can all be tested. Sec\u00adtion 3 contains the de.nition of the calculus. Section 4 for\u00admally \nde.nes checked compile-time execution and states its properties. Section 5 describes how the prototype \ncompiler works, notably explaining how it is built on top of Java com\u00adpiler and Java Virtual Machine. \nFinally, Section 6 outlines related and further work. The Appendix contains proofs and technical details. \nA very preliminary presentation of the ideas in this paper has been given in [19, 22]. 2. An informal \nintroduction 2.1 Primitive composition operators In METAFJIG, a class declaration associates an expression \nof primitive type class with a class name. The simplest form of such an expression is a class constant, \nwhich is sim\u00adilar to a Java class body and contains, besides other com\u00adponents explained later on, abstract \nor de.ned member (.eld or method) declarations. The following example shows two class declarations where \nclass constants are directly associated to class names. class A={ abstract int m1(); int m2() { return \nm1() + 1; } } class B={ abstract int m2(); int m1() { return 1 + m2(); } } These two classes are abstract \n(hence cannot be instantiated). Compound expressions of type class can be constructed using primitive \ncomposition operators. For instance, a con\u00adcrete class can be obtained from those above by applying the \nsum operator as follows: class Sum = A[+] B This declaration is reduced to the following: class Sum = \n{ int m1() { return 1 + m2(); } int m2() { return m1() + 1; } } Con.icting de.nitions for the same member \nare not permit\u00adted, whereas abstract members with the same name are shared. Besides sum, METAFJIG provides \nother three primitive composition operators: restrict, alias, and redirect, which take as arguments a \nclass and one or two (member) names, that is, expressions of primitive type name: The restrict operator \nremoves a de.nition, making the corresponding member abstract.  The alias operator adds a de.nition \nfor an either abstract or new member, duplicating that of an existing member.  The redirect operator \nreplaces all the internal references (in method bodies or .eld initialization expressions) to an abstract \nmember name by a different name, and removes its declaration (unless it is a member of a supertype, see \nlater on).  For instance, class Restrict = Sum[restrict $m1] class Alias = A[alias $m2 to $m1] class \nRedirect = A[redirect $m1 to $m2] is reduced to class Restrict = { abstract int m1(); int m2() { return \nm1() +1; } } class Alias = { int m1() { return m1() +1; } int m2() { return m1() +1; } } class Redirect \n= { int m2() { return m2() +1; } } The notation $n is used for the constant of type name corre\u00adsponding \nto name n. These four primitive operators are a minimal, yet very expressive set. Sum, restrict and alias \nare very similar to the trait operators de.ned in [10], with the difference that they uniformly work \non .elds as well, as shown below. Restrict is called exclude in trait literature; here we prefer to stick \nto the original name in Jigsaw [7]. Other trait-based languages [6, 26] also include a rename operator. \nWe prefer to have the redirect operator since it is conceptually more primitive, and it allows to express \nmany different forms of renaming, see the examples in Section 2.2. In order to get a simpler and more \nfocused presentation, we have not included in METAFJIG some FJIG features which do not raise signi.cant \nnew issues when integrated with the meta-level. Notably, in Jigsaw and FJIG de.ned members can be vir\u00adtual, \nfrozen or local, whereas here they are all implicitly virtual. As a consequence, METAFJIG does not include \nthe freeze primitive operator which allows to express, e.g., mem\u00adber hiding. Hence, in the language presented \nin this paper the only way to remove a member entirely from a class is to redi\u00adrect it to another one \nof the same type. This is needed since some method implementation could refer to it. Moreover, the reduct \noperator of FJIG, handling maps from names into names, has been replaced by three operators which handle \nsingle names (restrict, alias and redirect). They provide the same expressive power and are more convenient \nfor the meta-level. In METAFJIG, as in FJIG, the modi.er abstract applies to .elds as well, as shown \nby the following example which also illustrates how constructors work. class A1= { abstract int f1; int \nf2; constructor(int x){ f2 = x; } int m() { return f1 + f2; } } class B1= { int f1; abstract int f2; \nconstructor(int x){ f1 = x + 1;} } [+] A1 is reduced to class A1 = { ... } class B1 = { int f1; int \nf2; constructor(int x) { f1 = x + 1; f2 = x; } } A class constant de.nes one4 constructor which speci.es \na sequence of parameters and a sequence of initialization ex\u00adpressions, one for each non-abstract .eld. \nWe assume a de\u00adfault constructor with no parameters for classes having no de.ned .elds. In order to be \ncomposed by the sum operator, two classes should provide a constructor with the same pa\u00adrameter list. \nThe effect is that the resulting class provides a constructor with the same parameter list, that executes \nboth of the original constructors. Classes composed by sum can share the same .eld, pro\u00advided it is de.ned \nin (at most) one. Note that this corre\u00adsponds to sharing .elds as in, e.g., [5]; however, in our framework \nwe do not need an ad-hoc notion. METAFJIG keeps the Java nominal approach, that is, types are class names. \nHowever, desired subtyping relations must be explicitly written by the programmer, by declaring a set \nC1 ... Cn of supertypes, introduced by the keyword implements, in a class constant. This is also used \nto type\u00adcheck occurrences of this inside method bodies, see rule (THIS-T) in Figure 6, as illustrated \nby the example below. class C={ abstract int m1(); abstract int m2(); } class D= implements C{ abstract \nint m1(); int m2() { return 1 + m1();} C m() { return this;} } The type system checks, for each Ci, \nthat the subtyping relation can be safely assumed, that is, members of Ci are members of the class constant \nas well, formally, that the type of this is subtype of the structural type of Ci, see rule (CLASS-T) \nin Figure 5. We assume as default supertype the prede.ned class Object with no members. To conclude this \noverview of the conventional features of METAFJIG, note that m(...) is not a shortcut for this.m(...), \nbut a different form of invocation, called internal, whereas this.m(...) is a special case of client \ninvocation where the receiver is the current object. Only the former is affected by composition operators. \nFor instance, with C as above: class D2 = implements C{ abstract int m1(); abstract int m2(); int m3(D2 \nx){ return m1() + x.m1()+ this.m1(); 4 As in FJ and differently from Java, overloading is not allowed. \n } }[$m1 redirect $m2] is reduced to class D2 = implements C{ abstract int m1(); abstract int m2(); int \nm3(D2 x){ return m2() + x.m1()+ this.m1(); } } However, this difference is no longer relevant when all \nclass de.nitions have been reduced to class constants. This last example also shows that method m1 is \nnot en\u00adtirely removed, but rather becomes abstract. Indeed, since D2 implements (that is, must be a subtype \nof) C, remov\u00ading method m1 would break the subtyping relation, see rule (REDIRECT) in Figure 2.  2.2 \nMeta-level features Since class is a primitive type of the language, a class de.nition can be the result \nof a method. For instance, in the following meta-program5 class C={ class m() { return { int one() { \nreturn 1;} }; } } class D= new C().m() method m returns a value of type class. This value is a class \nconstant declaring the method one. Class D is de.ned by an expression that has to be evaluated in order \nto obtain the corresponding class constant. In this example, the de.nition of D is the value returned \nby the method m of C, so this program could be equivalently written as: class C= /* ...as before... */ \nclass D={ int one() { return 1;} } One very basic use of this mechanism allows to obtain con\u00additional \ncompilation. For instance: class C={ class m() { if (DEBUG) return /*debug version*/; else return /*release \nversion*/; } } Another simple example is the following method: class mixinFoo(class parent) { return \n{ /* ... */ } [+] parent; } 5 A METAFJIG meta-program is an arbitrary sequence of class declarations, \nwhereas a program is a sequence where all right-hand-sides are class con\u00adstants. which behaves like \na mixin class, extending in some way a parent class passed as argument6. The class to be used as parent \ncould be constructed, having a class ClassList implementing lists of classes, by chaining an arbitrary \nnumber of classes: class chain(ClassList parents){ if (parents.isEmpty()) return {}; else return parents.head() \n[+] chain(parents.tail()); } This is indeed similar to mixin composition, with the advan\u00adtage that the \noperands of this arbitrarily long composition do not have to be statically known. We show now how to \nderive other useful composition op\u00aderators from the primitive ones. To this end, we use an ad\u00additional \nprimitive operator members which returns the array of member names of a class, omitted in the formalization \nin Section 3 since it poses no signi.cant new technical prob\u00adlems. This operator allows to emulate a \ntype-driven transla\u00adtion. Moreover, we use the following class class IsDefined = { boolean apply(class \nc, name n) { try{ c=c[restrict n]; return true;  } catch(RestrictException e){ return false; } } } which \nde.nes an operator which checks whether a member is de.ned (that is, declared and non abstract) in a \nclass. This operator can be derived from the restrict operator, which throws an exception when invoked \non a non de.ned member. In this and the following examples some choices are due to the fact that we want \nto stick to the syntax implemented in the current prototype. For instance, we use arrays rather than \nlists since the prototype does not assume prede.ned classes except Object, RunTimeException and composition \nop\u00aderator exceptions. Moreover, operators should better be im\u00adplemented as static methods, but these \nare not supported yet, hence we write a class for each operator, with an apply method that represents \nthe operator application. The following class de.nes the override operator, corre\u00adsponding to Java extends, \nas the composition of restrict and symmetric sum, as originally shown in [7]. class Override = { class \napply(class h,class p){ for(name n:h[members]) if (new IsDefined().apply(h,n) &#38;&#38; new IsDefined().apply(p,n)) \n6 Instead of sum, we should more appropriately use the derived override operator described in the sequel. \n p=p[restrict n]; try{return h [+] p;} catch(SumException se){ throw new OverrideException(\"...\"); } \n} } class OverrideException= implements CompositionException{...} For all members which are de.ned both \nin heir h and in parent p, the de.nition in p has to be removed. An excep\u00adtion can still be raised if \nsome member is declared in both with different types, see rule (SUM-ERROR) in Figure 2. The prede.ned \nCompositionException should be a supertype of all the exceptions modeling composition errors. The following \nclass de.nes a rename operator as, e.g., in [6]. class Rename = { class apply(class c, name o, name n){ \nif(!isIn(o,c[members])) throw new RenameException(\"...\"); if(o==n)return c; if(isIn(n,c[members])) throw \nnew RenameException(\"...\"); if(new IsDefined().apply(c,o)) c=c[alias o to n][restrict o]; return c[redirect \no to n]; } boolean isIn(name n,name[] ns){...} } The operator can be applied only if the old name o \nis de\u00adclared in c and the new name n is not. If o is de.ned, then its de.nition is moved to n. Finally, \nthe occurrences of (now certainly abstract) o as internal references are replaced by n. The following \nclasses de.ne two less standard operators. class StrongAlias = { class apply(class c, name o, name n){ \ntry{ return c[alias o to n][restrict o] [redirect o to n][ alias n to o]; } catch(CompositionException \nce){ throw new StrongAliasException(\"...\"); } } } class Unbind = { class apply(class c, name o, name \nn){ try{ return new StrongAlias() .apply(c,o,n)[restrict n]; } catch(CompositionException ce){ throw \nnew UnbindException(\"...\"); } } } The former is a variant of alias which also replaces internal references. \nA similar operator is de.ned in [23], but only af\u00adfects internal references appearing in the body of \nthe method itself. This operator works in four steps: duplicates the def\u00adinition of o as n, removes the \nde.nition of o, redirects the (now abstract) name o to n, and .nally restores the original de.nition \nof o. The latter replaces internal references to a de.ned mem\u00adber o by a new name n. This effect can \nbe obtained by .rst applying StrongAlias, then removing the de.nition of n. This operator has been introduced \nin [4] to deal with unan\u00adticipated code modi.cation due to poor design. The converse operator, which \nbinds internal references to an existing de\u00ad.ned member, is a special case of redirect. 2.3 Real world \nexamples The following example is a graphical library that adapts it\u00adself with respect to its execution \nenvironment, without re\u00adquiring any extra-linguistic mechanisms. To keep the exam\u00adple compact, we do \nnot detail all the named classes, and we simply assume that they are declared elsewhere. class GraphicalLibrary \n= { class produceLibrary() { class result = BaseGraphicalLibrary; String producer = new System().getProperty( \n\"sys.vcard.brand\"); if (producer.equals(\"NVIDIA\")) result = NVIDIASupport [+] result; else if (producer.equals(\"ATI\")) \nresult = ATISupport [+] result; else throw new UnsupportedHardwareException( \"No compatible hardware \nfound\"); if (System.getProperty(\"os.name\") .contains(\"Windows\")) result = new CygwinAdapter() .adapt(result); \nreturn result; } } The method produceLibrary builds a platform-speci.c li\u00adbrary by combining the base \nlibrary BaseGraphicalLibrary with the brand-speci.c drivers (represented by the two classes NVIDIASupport \nand ATISupport) and wrapping the result, if required on the speci.c platform, with the class CygwinAdapter, \nwhich emulates a Linux-like environment on Windows operating systems. In this way the compilation of \nthe same source produces customized versions of the library depending on the execu\u00adtion platform. In \nother words, this approach can be used to write active libraries [8], that is, libraries that interact \ndy\u00adnamically with the compiler, providing better services, as meaningful error messages, platform-speci.c \noptimizations and so on. Finally, one simple and interesting application is in man\u00adaging at compile-time \nexternal applications like databases. For instance, the following class DBRecord provides the method \ncreate that, given a table name, produces a class which mimics the structure of the table. class DBRecord \n= { StringClassMap map=... //{\"int\" -> {int n;constructor(){n=0;}}, //\"String\"->{String n;constructor(){n=\"\";}}, \n// ...}; class create(String table){ TableStructure structure= new DB().getTableStructure(table); class \nresult={}; for(Column c:structure.getColumns()) result=result [+] new Rename().apply( map.get(c.type),$n,c.myName); \nreturn result; } } The create method takes the name of a table, and for all the Column c of such table \nadds to the class stored in result a .eld with the type and name of c. Many applications rely on the \nfact that the shape of some database table is known and immutable, but with conven\u00adtional approaches \nthe programmer needs to duplicate the structure of the external table in the code, and checks on the \ntable shape are performed only at runtime. With our approach, instead, a class de.ned by class Foo = \nnew DBRecord().create(\"Foo\") will have the shape of the table \"Foo\" in the DB. That is, the following \ncode: int m(Foo x){return x.bar;} will be successfully compiled only if the table \"Foo\" has a .eld bar \nof type int. That is, checks on the table shape are performed at compile-time.7 The two examples above \nalso show that our approach allows, in a statically typed setting, an expressive power which is typical \nof dynamically typed languages. 3. The language 3.1 Syntax and reduction rules In Figure 1 we give the \nsyntax of METAFJIG. We use the bar notation for sequences, e.g., d is a sequence of declarations d. We \nassume in.nite sets of class names C , (member) names n, and variables x. As in FJ, variables include \nthe special variable this, with the conventional meaning. A meta-program is a sequence of class declarations, \nwhere an expression is associated to a class name. A pro\u00adgram is a meta-program where all these expressions \nare class constants. 7 However, since the table shape can change after compilation, the code that reads \nthe table will perform integrity checks at runtime. mp ::= class C =e meta-program p ::= class C =c program \nc k kh ::= ::= ::= implements C {k d}kh{fe}constructor(T x) class constant constructor constructor header \nfe ::= f =e; .eld expression d ad ::= ::= ad | fd | md abstract fd declaration abstract declaration fd \n| abstract mh; ::= T f ; .eld de.nition mh ::= T m(T x) method header md ::= mh{return e;} method de.nition \nT ::= C | name | class type e f ::= x | e.f | e.m(e) | f | m(e) | new C (e) | C (fe) | n | C | c | e1[+]e2 \n| e1[alias e2 to e3] | e1[restrict e2] | e1[redirect e2 to e3] ::= n expression (conventional) expression \n(pre-object) expression (meta-level) .eld name m ::= n method name v fv ::= ::= C (fv) | n | c f =v; \nvalue .eld value Figure 1. Syntax A class constant declares a sequence of supertypes,a constructor, \nand a sequence of (member) declarations, which can be either abstract or non abstract (member de.nitions). \nThe .rst component means that the type of this must be a subtype of (the structural type of) C for each \nclass name C in the sequence. This information is needed to typecheck occurrences of this in method bodies. \nThere is no overloading, hence a class has only one con\u00adstructor. However, differently from FJ, where \nthis unique constructor has a canonical form, there is no a priori relation between the parameter list \nand the constructor body which is a sequence of .eld expressions associating (initialization) expressions \nto .eld names. Members can be .elds or meth\u00adods, and member declarations are in the style of FJ. Sequences \nof class declarations, this supertypes, decla\u00adrations, and .eld expressions are considered as sets, that \nis, order and repetitions are immaterial. Moreover, in a well\u00adformed (meta-)program, a class name cannot \nbe declared twice, that is, a (meta-)program is a map from class names to expressions, hence we can safely \nuse the notation mp(C ). Analogously, no member can be declared twice in a class constant. This implies \nthat, differently from Java, there is no method overloading, and there is no overloading between .eld \nand method names. However, for better readability, we will use the metavariable f when a name is used \nfor a .eld, m for a method. A parameter name cannot be declared twice in a constructor or method header. \nFinally, a .eld name can\u00adnot appear twice in a sequence of .eld expressions, hence we can safely use \nthe notation fe(f ), and there is exactly a .eld expression in the constructor for each non abstract \n.eld. Types are class names and the primitive types name of names and class of classes. Expressions \nin method bodies include conventional con\u00adstructs, pre-objects, and meta-expressions. Conventional constructs \nare similar to those of FJ. We omit cast for simplicity since it is not relevant for our tech\u00adnical treatment; \nmoreover, we distinguish between external .eld accesses and method invocations, which have an ex\u00adplicit \nreceiver, and internal .eld accesses and method invo\u00adcations, which have the current object as implicit \nreceiver. As explained at the end of Section 2.1, only internal refer\u00adences are affected by composition \noperators. Pre-objects are runtime expressions which cannot be written in programmer s code, but are \nobtained by reducing a constructor invocation. Indeed, since the constructor has no canonical form, we \nneed two different syntactic forms [21, 20], differently from FJ. Meta-expressions are names, class names, \nclass con\u00adstants, or are constructed by the four operators sum, reduct, alias, and redirect. The behaviour \nof these operators will be described when explaining the corresponding reduction rules. In the concrete \nsyntax used by the prototype, we use the notation $n for the constant meta-expression denoting the name \nn, which needs to be distinguished from the conven\u00adtional expression n, which is an internal .eld access \nex\u00adpected to be bound to a .eld name existing in the current scope. Values are objects, names and class \nconstants. Objects are pre-objects where all .eld expressions are (recursively) values. In Figure 2 we \ngive the rules which de.ne the reduction of an expression e in the context of a program p. We omit standard \nrules for contextual closure and error propagation. We use the following notations, informally de.ned \nfor brevity (formalization is straightforward): mbody(C , m) gives parameters and body of method m p \nin class C in p; e is the expression obtained from e by replacing internal references (that is, internal \n.eld accesses and method invocations) by the corresponding external versions with receiver this; names(d), \nabs(d) and def (d) is the set of all, ab\u00adstract and de.ned names declared in d, respectively; names(p, \nC )=names(d) if p(C )=implements _{_ d};  if n.names(d), then mtype(n, d) is its type (member types \nare de.ned in Figure 3);  d.d means that d and d are non con.icting, that is,  def (d)ndef (d )=\u00d8, \nand coherent, that is, for all n.names(d)nnames(d ), mtype(n, d)=mtype(n, d ); d\\n is obtained from \nd by removing the declaration of n, if any; this notation is generalized to set of names;  d[restrict \nn] is obtained from d by making abstract the non abstract declaration of n, if any; analogously, fe[restrict \nn] is obtained from fe by removing the .eld expression for n, if any;  d[alias n to n.] is obtained \nfrom d by adding a de.\u00adnition for n. equal to that for n, and removing the abstract declaration for n., \nif any; analogously, fe[alias n to n.]  is obtained from fe by adding a .eld expression for n equal \nto that for n, if any; d[redirect n to n.] is obtained from d by replacing internal references to n in \nmethod bodies by n., and adding an abstract declaration for n. if n../names(d). The .rst three rules \nde.ne reduction of conventional con\u00adstructs. There are no reduction rules for variables (parameter names) \nand internal .eld accesses and method invocations since those appearing in a method body are replaced \nat invo\u00adcation time8, see (CLIENT-INVK). Rules (CLIENT-FIELD) and (CLIENT-INVK) are as in FJ, with the \ndifference that, since there is no inheritance, method look-up (modeled by mbody) is trivial, and method \nbody e is transformed in e . Rule (OBJECT-CREATION) is straightforward and re\u00adduces a constructor invocation \ninto the pre-object obtained by replacing parameters by corresponding arguments in the constructor s \nbody. Note that only classes with no abstract members can be instantiated. The following rules de.ne \nreduction of meta-expressions, that is, expressions of type class. Rule (C-NAME) reduces the name of \na class declared in the program into the corresponding de.nition. For each composition operator there \nare two rules, the latter corresponding to the case when the operator cannot be performed, hence an error \nis raised. In the prototype com\u00adpiler, of course, a different prede.ned exception is thrown for each \noperator. The sum operator merges two class constants, as shown in rule (SUM). The arguments must have \nthe same constructor 8 Indeed, as explained at the end of Section 2.1, the difference between, say, f \nand this.f is only relevant for composition operators, notably redirect. mbody(C , m)=x; e (CLIENT-FIELD) \nfv(f )=v (CLIENT-INVK) p v=C(_) C (fv).f -.p vv.m(v) -.p e [v/x][v/this] p(C)=implements _{constructor(_ \nx1 ... _ xn){fe} d} (OBJ-CREATION) new C (v) -.p C (fe[v/x]) abs(d) = \u00d8 x=x1 . . . xn d1.d2 (C-NAME) \nC -.p c p(C)=c (SUM) implements C 1{kh{fe1} d1}[+]implements C 2{kh{fe2} d2}-.p implements C 1C 2{kh{fe1fe2} \nd1d2} . . d1 =d1\\def (d2) . d2 =d2\\def (d1) . kh1.=kh2 or (SUM-ERROR) implements _{kh1{_} d1}[+]implements \n_{kh2{_} d2} -.p error d1.d2 (RESTRICT) n.def (d) implements C {kh{fe} d}[restrict n] -.p implements \nC {kh{fe[restrict n]} d[restrict n]} (RESTRICT-ERROR) n./def (d) implements _{_ d}[restrict n] -.p error \nn.def (d) (ALIAS) n ./def (d).  implements C {kh{fe} d}[alias n to nn ..abs(d) implies mtype(n, d)=mtype(n \n, d) -.p implements C {kh{fe[alias n to n.]} d[alias n to n.]} n./def (d) or (ALIAS-ERROR) n ..def (d) \nor implements _{_ d}[alias n to n.] -.p error mtype(n, d)., d) =mtype(n . n.abs(d) n ..names(d) implies \nmtype(n, d)=mtype(n , d) (REDIRECT) . .] . d[redirect n to n ]\\n if n./names(p, C ) for all C.C , implements \nC {kd}[redirect n to nd = d[redirect n to n .] otherwise -.p implements C {kd } n./abs(d) or (REDIRECT-ERROR) \nmtype(n, d)., d)=mtype(n . implements C {_ d}[redirect n to n.] -.p error Figure 2. Reduction rules \nheader9, non con.icting and coherent declarations, that is, no member can be de.ned in both and, if declared \nin both, it must have the same type. Then, the result has the constructor header of the arguments, the \n(disjoint) union of the .eld ex\u00adpressions, the (disjoint) union of the de.ned members, and the union \nof the declared members, which are abstract only if abstract in both arguments. Note that the side conditions \nensure well-formedness of the result. If one of the side con\u00additions does not hold, then rule (SUM-ERROR) \nis applied. 9In order to make equal the constructor header of two classes, FJIG [21, 20] provides a constructor \nwrapper operator, omitted here for simplicity. The restrict operator replaces the de.nition of n by \nthe corresponding abstract declaration, as shown in rule (RE-STRICT). If n is a .eld, its initializiation \nexpression is re\u00admoved as well. If n is not de.ned, then rule (RESTRICT-ERROR) is applied. The alias \noperator adds a de.nition for n., by duplicat\u00ading that existing for n. The name n. can be either new \nor abstract, in which case the de.nition replaces the previous abstract declaration, and the two must \nbe coherent. If n is a .eld, then the initialization expression is duplicated as well. Note also that, \nif n is a method, then recursive internal ref\u00aderences to n in its body are not affected when the body \nis Figure 3. Type environments . ::= C :CT class type environment CT ::= C ; T ; ck; S class type ck \nS ::= ::= a | \u00aca n:MT class kind signature MT . ::= ::= T | T . T x:T member type parameter type environment \n duplicated for n.. If n is not de.ned, or n. is already de\u00ad.ned, or its declaration is not coherent \nwith the de.nition of n, then rule (ALIAS-ERROR) is applied. The redirect operator replaces internal \nreferences to ab\u00adstract member n in method bodies by n.. If n. was not a member yet, then a corresponding \nabstract declaration for n. is added. Otherwise, the declaration of n. must be coher\u00adent with that of \nn. The abstract declaration for n is removed, unless it is required by the assumption that, for all C \n.C , C can be safely assumed as supertype for this, that is, all members of C have a (coherent) declaration \nin d as well. If n is not abstract, or the declaration of n is not coherent with that of n., then rule \n(REDIRECT-ERROR) is applied.  3.2 Type system Type environments are de.ned in Figure 3. A class type \nenvironment is a sequence of associations from class names to class types, assumed to be a map. A class \ntype is a 4-tuple, consisting of the supertypes (a se\u00adquence of class names), constructor type (the sequence \nof constructor parameter types), the class kind (abstract or non abstract) and the class signature. A \nsignature is a sequence of associations from member names to member types, assumed to be a map. A .eld \ntype is just a type, whereas a method type is a pair consisting of the sequence of parameter types and \nthe result type. Finally, a parameter type environment is a sequence of associations from variables (parameter \nnames) to types, assumed to be a map. We distinguish two notions of typing for METAFJIG pro\u00adgrams: (standard) \nwell-typedness and deep well-typedness. The difference is illustrated by the following example. In the \nprogram class D={int foo(){return 0;}} class C={int m(){return new D().bar();}} the class constant used \nas de.nition of C is ill-typed (there is no method bar in class D), hence the whole program is ill\u00adtyped. \nHowever, a similar program where the ill-typed class constant is only used as meta-expression, as the \nfollowing: class D = {int foo(){return 0;}} class C = {class m(){return { int n(){return new D().bar();} \n} } } is considered well-typed, but not deeply well-typed. (C-CONST-T0) C.dom(.) 0 .; _; _; _.implements \nC {__}:class . . c (C-CONST-T.) .; _; _; _.. c:class Figure 4. The two typing rules for class constants \n We denote the two typing judgments by .0 and .. , respec\u00adtively, to suggest that class constants must \ndenote well-typed classes in the former case only when used as class de.nitions (that is, at level 0), \nin the latter case at any inner meta-level. Well-typedness is enough to guarantee (standard) soundness, \nsee Theorem 1. Deep well-typedness is needed to guarantee meta-level soundness, an additional important \nproperty dis\u00adcussed later on, see Theorem 7. Formally, the only difference in the de.nition of the two \njudgments is in the rule for typing class constants, whose two versions are given in Figure 4. In order \nto be a well-typed class meta-expression, the only condition a class constant must satisfy is that class \nnames appearing as this supertypes actually exist, as shown in rule (C-CONST-T0). This condition is necessary \nto per\u00adform the check required in rule (REDIRECT), otherwise re\u00adduction could go stuck. Instead, rule \n(C-CONST-T.) states that a class constant is a deeply well-typed meta-expression if it is well-typed \nas class. The other rules are given in Figure 5 and Figure 6, where . must be replaced by .0 and .., \nrespectively. We use the following notations: Sd is the signature extracted from d, that is, Sd (n)=mtype(n, \nd);  CT c is the class type extracted from c, that is, CT c =C ; T1 ... Tn; ck;Sd if c=implementsC{constructor(T1 \nx1...Tn xn){_} d}, with ck=a if abs(d). =\u00d8, ck=\u00aca otherwise;  .p is the class type environment extacted \nfrom p, that is, .p(C )=CT c if p(C )=c;  if .(C )=C ; T ; ck;S, then ktype(., C )=T , sig(., C )=S, \nkind(., C )=ck;  mtype(., C , n)=sig(., C )(n).  Rules in Figure 5 de.ne the typing judgment . . \np, mean\u00ading that program p is well-typed w.r.t. the class type envi\u00adronment ., modeling external libraries, \nand the typing judg\u00adments for classes, method de.nitions and constructors. The rules are straightforward. \nNote the side-condition in rule (CLASS-T) checking that the signature of the class is actually a subtype \nof the signature of all this supertypes.10 The (standard) de.nitions of the nominal subtyping rela\u00ad 10 \nAnalogously to implemented interfaces in Java. ..p . ci .i.1..n (PROGRAM-T) p=class _=c1 ... class _=cn \n. . p .; Sfd . k .; Sd ; C . md d = ad fd md (CLASS-T) . . Sd =sig(., C) .C.C . .implements C {kd} .; \nS; G; C . e:T . G= x1:T1 ... xn:Tn (METHOD-T) Tx = T1 x1 ... Tn xn .; S; C . Tm(Tx){ . . T.=T return \ne;} .; \u00d8; G; \u00d8. ei:T . .i.1..k G= x1:T1 ... xn:Tn i (CONS-T) Tx = T1 x1 ... Tn xn .; S . constructor(Tx){ \n. . T.=S(fi) .i.1..k i f1=e1 ... fk=ek} Figure 5. Typing rules for programs and classes tion . . T =T \n. and of the structural subtyping relation . . S=S. are given in the Appendix, Figure 11. Also note, \ncomparing the form of typing judgment for expressions ex\u00adplained below with the premise of rule (CONS-T) \nthat, as expected, .eld expressions can neither contain internal ref\u00aderences (S=\u00d8), nor this (C =\u00d8). \nRules in Figure 6 de.ne the typing judgment .; S; .; C . e:T , meaning that expression e has type T w.r.t.: \n the class type environment ., needed to typecheck client .eld accesses and method invocations, and constructor \ninvocations;  the signature S, needed to typecheck internal .eld ac\u00adcesses and method invocations; \n the parameter type environment ., needed to typecheck variables;  and the sequence of class names C \n, needed to typecheck this occurrences.  The rules are straightforward. Note that the type system uses \nnominal types (class names), except for internal .eld accesses and method invocations, which are typechecked \nlooking at the structural type of this, that is, the signature S. In particular, note the difference \nbetween an external .eld access of form this.f , where this has a nominal type, hence is well-typed if \nf is a .eld of one of the supertypes C , and an internal .eld access f , which is well-typed if f is \na .eld in S (and analogously for a method invocation). A similar approach is taken in [6, 21]. The type \nsystem is sound, as formally stated by the fol\u00adlowing standard theorem. e -.p e (META-RED) p class C \n=e mp -. p class C =emp Figure 7. Compile-time execution Theorem 1 (Soundness). If \u00d8.0 p, .p; \u00d8; \u00d8; \n\u00d8.0 e:T , and e -.p e., then either eis a value, or eis error, or e. -.p e.. for some e. As usual, soundness \ncan be derived from progress and subject reduction properties. Theorem 2 (Progress). If \u00d8.0 p and .p; \n\u00d8; \u00d8; \u00d8.0 e:T , then either e is a value, or e is error, or e -.p e. for some e. Theorem 3 (Subject reduction). \nIf \u00d8.0 p, .p; \u00d8; \u00d8; \u00d8.0 e:T , 0 .:T . and e -.p e., then .p; \u00d8; \u00d8; \u00d8.efor some T . s.t. .p . T .=T . \nThe proofs are a simpli.ed version of those for FJ. In\u00addeed, METAFJIG programs can be roughly seen as \nFJ pro\u00adgrams with no inheritance and two primitive types. 4. Checked compile-time execution We consider \nnow meta-programs, that is, sequences of class declarations where arbitrary expressions, rather than \nclass constants, are associated to class names. A meta-program can be reduced to a program by a process \nthat we call compile-time execution, formally modeled by the relation mp -. mp. de.ned in Figure 7. As \nmodeled by (META-RED), the right-hand-side of a class declaration can be re\u00adduced in the context of the \nprogram part of the current meta\u00adprogram. However, soundness of compile-time execution is not guaranteed, \nthat is, reduction could get stuck, or produce as right-hand-side of a class declaration a value different \nfrom a class constant, or a class constant denoting an ill-typed class. To prevent these error situations, \ndifferent approaches are possible. In this paper, rather than guaranteeing soundness by (only) static \nchecks, which would require a sophisticated type system with structural types, we propose a simple so\u00adlution, \ncalled checked compile-time execution, which inte\u00adgrates meta-reduction with typechecking steps. If typecheck\u00ading \nfails, then the program reduces to errorT. The advan\u00adtage is that the technique can be modularly de.ned \n(and im\u00adplemented, as explained in Section 5) on top of an arbitrary Java-like language. More in detail, \nduring checked compile-time execution each class declaration class C =e in the meta-program passes throughout \nthe following states: 1. initial state, no check has been performed yet; 2. we have checked that e is \na well-typed expression of type class; hence, e can be safely reduced, until getting a class constant \nc; 3. we have checked that c denotes a well-typed class.   (VAR-T) .(x)= T (THIS-T) C.C _; _; .; _ \n. x:T _; _; _; C . this:C .; S; .; C . e:C .; S; .; C . e:C .; S; .; C . e:T mtype(., C, m)= T. T (CLIENT-FIELD-T) \nmtype(., C , f )= T (CLIENT-INVK-T) . . . T=T .; S; .; C . e.f :T .; S; .; C . e.m(e):T .; S; .; C . \ne:T S(m)= T. T (INT-FIELD-T) S(f )= T (INT-INVK-T) . . . T=T _; S; _; _ . f :T .; S; .; C . m(e):T \nkind(., C )= \u00aca .; S; .; C . e:T . (NEW-T) ktype(., C)= T .; S; .; C . new C (e):C . . T=T. .; S; .; \nC . ei:Ti .i.1..n sig(., C)= f1:T1 . ... fn:T. , m:MT n (OBJ-T) . . Ti=T. .i.1..n i .; S; .; C . C \n(f1 =e1 ... fn =en):C (NAME-T) (CLASS-NAME-T) C .names(.) _; _; _; _ . n:name .; _; _; _ . C :class \n.; S; .; C . e1:class .; S; .; C . e1:class .; S; .; C . e2:class .; S; .; C . e2:name (SUM-T) (RESTRICT-T) \n .; S; .; C . e1[+]e2:class .; S; .; C . e1[restrict e2]:class .; S; .; C . e1:class .; S; .; C . e1:class \n.; S; .; C . e2:name .; S; .; C . e2:name .; S; .; C . e3:name .; S; .; C . e3:name (ALIAS-T) (REDIRECT-T) \n.; S; .; C . e1[alias e2 to e3]:class .; S; .; C . e1[redirect e2 to e3]:class (ERROR-T) .; S; .; C . \nerror:T Figure 6. Typing rules for expressions Checked compile-time execution is formally de.ned on \ncon.gurations s, which are either error or errorT or triples of the form p|mp|mpwhere p, mp and mpare \nthe class declarations in state (3), (2), and (1), respectively, hence the initial confuguration for \nmeta-program mp is \u00d8|\u00d8|mp. We assume that con.gurations are closed, that is, only class names which are \ndeclared can appear in expres\u00adsions. In the rules we use the clientship -.p and dependency =.p;mp relations \nde.ned in Figure 8. 0 Here, e.C means that (a subexpression of) e is of form C or new C (_). The superscript \n0 suggests that occurrences of C in class constants in e are not taken into account. For instance, if \ne is new C().m({ D n() { return new D(); } }) 00. then e.C holds, but not e.D. On the other hand, c.C \nmeans that C occurs in (an inner class constant in) c. The c.C . (CLIENT-DIRECT) p(C)=c (CLIENT-REFL) \nC -.pC . C -.pC C . C .. C -.pC .-.p (CLIENT-TRANS) C .. C -.p 0C .. e.C . C .-.pmp(C )=e (DEPEND-DIRECT) \nC .. C ...dom(mp) C =.p;mp C . C .C .. C =.p;mp=.p;mp (DEPEND-TRANS) C .. C =.p;mp Figure 8. Clientship \nand dependency relations  0. trivial formal de.nitions of e.C and c.C are given in the Appendix, in \nFigure 12. Clientship is analogous to the same notion in Java. That is, C is client of C . if C (transitively) \nuses C . either as type or as instance generator. Note that C . can occur at any inner level in the class \nconstant de.ning C . Moreover, we assume that any class is client of itself for technical convenience. \nIn order to determine whether a program p is deeply well\u00adtyped, if C is a client of C . then C . must \nbe in p itself or already typechecked. In Java, this relation is indeed used when the compiler is invoked \nto determine the full set of classes to be compiled or present in bytecode form. Dependency, instead, \nis a novel notion, de.ned on class names in a meta-program. Class C may depend on some other class only \nif its de.ning expression e is non constant, that is, still needs to be (typecheked and) reduced. In \nthis case, C depends on all the classes which need to be reduced and typechecked in order to determine \nwhether e is well\u00adtyped and of type class. Moreover, we use the following abbreviations: 0 closed(p, \ne)={C .|e.C , C -.pC .}.dom(p), hence we can determine whether or not e is a well-typed ex\u00adpression of \ntype class w.r.t .p;  closed(p, p.) if, for all C .dom(p.), {C .|C -.p. C .}.dom(pp.), hence we can \ndetermine whether or not p. is a deeply well-typed program w.r.t  .p . Rules de.ning checked compile-time \nexecution are given in Figure 9. Each pair of rules models a normal reduction step and the corresponding \nabnormal termination. In rule (META-CHECK), class declaration class C =e passes from state (1) to (2), \nsince e is of type class w.r.t. the already typechecked program portion p. In rule (META-CHECK-ERROR), \na type error is raised in two cases: either there exists class C =e in state (1) for which we have all \nthe information needed to typecheck e, and e is ill-typed, or we detect a cyclic dependency among classes \nin state (1), hence there is no hope to be able to typecheck all of them in the future.11 In rule (META-RED), \nclass declaration class C =e makes a meta-reduction step w.r.t. the already typechecked program portion \np. In rule (META-RED-ERROR), the meta-reduction step raises a composition error. In rule (CHECK), a program \nportion p. passes from state (2) to (3), since it is well-typed w.r.t. the already typechecked program \nportion p. In rule (CHECK-ERROR), praises a typechecking error, since we have all the needed information \nto typecheck it, and it is ill-typed. We show now some examples illustrating how checked compile-time \nexecution works. 11 For example class C= new C().m(). Example 1 First we give an example of successful \nreduc\u00adtion. The program \u00d8|\u00d8| class C={class m(){return{int k(){return 1;}};}} class D={ int m(){return \nnew E().k();}} class E=new C().m() reduces by two applications of (META-CHECK) to \u00d8| class C={class m(){return{int \nk(){return 1;}};}} class D={int m(){return new E().k();}}|class E=new C().m() reduces by (CHECK) to class \nC={class m(){return{int k(){return 1;}};}}|class D={int m(){return new E().k();}}|class E=new C().m() \nreduces by (META-CHECK) to class C={class m(){return{int k(){return 1;}};}}| class D={int m(){return \nnew E().k();}} class E=new C().m()| \u00d8 reduces by (META-RED) to class C={class m(){return{int k(){return \n1;}};}}| class D={int m(){return new E().k();}} class E={int k(){return 1;}}| \u00d8 reduces by (CHECK) to \nclass C={class m(){return{int k(){return 1;}};}} class D={int m(){return new E().k();}} class E={int \nk(){return 1;}} | \u00d8|\u00d8 Note that, after checking class C, it is not possible to check class D, since \nit depends on class E whose de.nition is not a class constant yet. Hence, expression new C().m() is checked \nto be of type class. At this point, reduction of this expression can take place, and .nally the resulting \nclass constant is checked to be well-typed, together with class D. Example 2 The second example shows \na case when checked compile-time execution terminates with an errorT. \u00d8|\u00d8 | class C={} class D=new C().k() \nreduces by (META-CHECK) to \u00d8| class C={} | class D=new C().k() reduces by (CHECK) to class C={} |\u00d8| class \nD=new C().k() reduces by (META-CHECK-ERROR) to errorT. Class C is checked, and then expression new C().k() \nis checked to be of type class. This is not the case, since class C has no method named k. Since new \nC().k() is closed w.r.t. class C an errorT is raised. 0 (META-CHECK) . .p ; \u00d8; \u00d8; \u00d8.e:class p|mp|class \nC =e mp. -. p|mp class C =e|mp mp(C )= e 0 (META-CHECK-ERROR) closed(p, e) and .p ; \u00d8; \u00d8; \u00d8..e:class \np|p.|mp -. errorT or =.cyclic p.;mp e -.p ee -.p error (META-RED) (META-RED-ERROR) p|class C =e mp|mp. \n-. p|class C =emp|mpp|class C =e mp|mp. -. error (CHECK) .p .p (CHECK-ERROR) closed(p, p ) and .p ..p \np|pmp|mp. -. pp.|mp|mpp|pmp|mp. -. errorT Figure 9. Checked compile-time execution Example 3 The program \n\u00d8|\u00d8| class C={class m(class x){return x [+] {int k(){return 1;}};}} class D=new C().m({int h(){return \nnew D().k();}}) reduces by (META-CHECK) to \u00d8| class C={class m(class x){return x [+] {int k(){return \n1;}};}} | class D=new C().m({int h(){return new D().k();}}) reduces by (CHECK) to class C={class m(class \nx){return x [+] {int k(){return 1;}};}} | \u00d8| class D=new C().m({int h(){return new D().k();}}) reduces \nby (META-CHECK) to class C={class m(class x){return x [+] {int k(){return 1;}};}} | class D=new C().m({int \nh(){return new D().k();}}) | \u00d8 reduces by (META-RED) to class C={class m(class x){return x [+] {int k(){return \n1;}};}} | class D={ int h(){return new D().k();}} [+] { int k(){return 1;}} | \u00d8 reduces by (META-RED) \nto class C={ class m(class x){return x [+] { int k(){return 1;}};}} |class D={ int h(){return new D().k();} \nint k(){return 1;}} |\u00d8 reduces by (CHECK) to class C={ class m(class x){return x [+] { int k(){return \n1;}};}} class D={ int h(){return new D().k();} int k(){return 1;}} | \u00d8| \u00d8 Class C is checked, then the \nexpression new C().m({ int h(){return new D().k();}})@ is checked to be of type class, and then reduced. \nFinally, the resulting class D is checked. This example also illustrates why only (standard) type\u00adchecking \nis used in (META-CHECK). Indeed, the fact that the expression new D().k() is well-typed can only be de\u00adtected \nwhen the result of {int h(){return new D().k();}} +{int k(){return 1;}} is associated to D. We can state \ntwo signi.cant properties for METAFJIG checked compile-time execution: soundness (Theorem 4) and meta-level \nsoundness (Theorem 7). The former means that checked-compile time execution never gets stuck, and is \na standard property which we also proved for preliminary versions of our work [19, 22]. The latter is \na novel and very important property which allows the programmer to safely use compiled libraries. We \nwill discuss its meaning in detail later on. In order to express soundness, we .rst of all de.ne which \nare the .nal results of checked compile-time execution. We say that a con.guration s is a value if all \nclass declarations are in state (3), formally s = p|\u00d8|\u00d8. Theorem 4 (Soundness). If \u00d8|\u00d8|mp -. s, then \neither s is a value or s = error or s = errorT or s -. s. for some s. . Soundness of checked compile-time \nexecution can be proved, as usual, as a consequence of progress and subject reduction properties, where \nin the latter the invariant which is preserved by reduction is that, in p|mp|mp., class dec\u00adlarations \nin p and mp are in state (3) and (2), respectively, where only well-typedness (not deep well-typedness) \nis re\u00adquired. Formally, we write: ..0 mp:class if ..0 e:class for all class _=e in mp.  .0s if either \ns = error, or s = errorT, or s = 00 p|mp|mp. and \u00d8.p, .p.mp:class. This judgment triv\u00adially holds in \nan initial con.guration \u00d8|\u00d8|mp. Theorem 5 (Progress). If .0s, then either s is a value or s = error or \ns = errorT or s -. s. for some s. . 0 Theorem 6 (Subject reduction). If .s and s -. s. then .0s. . Proofs \nof Theorem 5 and Theorem 6 are given in the Ap\u00adpendix. They rely on progress (Theorem 2) and subject \nre\u00adduction (Theorem 3) for expression reduction, respectively. We now state and discuss meta-level soundness. \nAnalo\u00ad gously as above, we write ..mp:class if ..e:class for all class _=e in mp. Theorem 7 (Meta-level \nsoundness). If \u00d8.p and .p.mp:class, then p|mp|\u00d8.-.errorT. In the statement of the theorem, a meta-program \nmp is compiled in the context of a program p, which plays the role of a library, obtained by a previous \ncompilation. Meta-level soundness means that, if p is deeply well\u00adtyped, then Java typechecking errors \nare never fault of p, but always originate from some class _=e in the meta-program mp, as modeled by \nthe fact that judgment ..e:class does not hold. This can happen for two possible reasons: either e is \nill-formed as expression of type class, or it contains some class constant which cannot be typechecked \nw.r.t. the library p. For instance, in Example 3, in the beginning p and mp are empty. After the .rst \ntwo steps, (META-CHECK) and (CHECK), class C becomes part of the library p, and is deeply well-typed. \nAfter the third step, (META-CHECK), class D be\u00adcomes part of mp, that is, we know that its de.ning expres\u00adsion \nis a well-typed expression of type class, but is not deeply well-typed. This means that Java typechecking \nerrors could still be raised, since expression de.ning D refers to a class which is not in the library \n(D itself). However, the re\u00adsult of compilation of D could be a well-typed Java class, as it is in this \ncase indeed: after steps 4 and 5, which are two (META-RED) steps, D is typechecked (step 6) and is deeply \nwell-typed. If k() were replaced with, say, k (), then step 6 would be (CHECK-ERROR). From now on, compilation \nof another class declaration, say E=e, using C and D as li\u00adbrary will only raise Java typechecking errors \ndue to E itself. With a non deeply well-typed12 library p, e.g., the exam\u00adple already shown in Section \n3.2 class D={int foo(){return 0;}} class C={class m(){return { int n(){return new D().bar();} } } } 12 \nWhich, however, cannot be obtained as the result of checked compile\u00adtime compilation. compiling another \nclass declaration mp, say class E= new C().m() could raise typechecking errors which are not fault of \nE. This property is not granted by other approaches like C++ templates. Indeed, in C++ a template instantiation \ncan raise type errors caused by the code of the template itself. Meta-level soundness can also be proved \nby progress and subject reduction properties, with an invariant analogous to that used above. However, \nhere we require deep well\u00ad typedness. Formally, we de.ne .s if either s = error or s = p|mp|\u00d8 and \u00d8.p, \n.p.mp:class. Theorem 8 (Meta-level progress). If .s, then either s is a value or s = error or s -. s. \nfor some s. . This theorem is a corollary of Theorem 5, see the Ap\u00adpendix. In order to prove meta-level \nsubject reduction, we need a different version, referring to deep well-typedness rather than well-typedness, \nof the subject reduction property stated in Theorem 3 for expression reduction. This property is stated \nin Theorem 10, and its proof is based on Lemma 9, which states that by (successfully) applying a composition \noperator to deeply well-typed classes we always get a deeply well-typed class. Lemma 9. If \u00d8.p, ..c1:CT \n1, and ..c2:CT 2, then 1. c1[+]c2 -.p c implies ..c:CT , 2. c1[restrict n] -.p c implies ..c:CT , 3. \nc1[redirect n1 to n2] -.p c implies ..c:CT , 4. c1[alias n2 to n1] -.p c implies ..c:CT .  Theorem \n10 (Deep subject reduction). If \u00d8.p, .p; \u00d8; \u00d8; \u00d8.e:T , and e -.p e., then .p; \u00d8; \u00d8; \u00d8.e:T . for some \nT . s.t. .p . T .=T . The proof is analogous to that for Theorem 3, by using Lemma 9. Theorem 11 (Meta-level \nsubject reduction). If .s and s -. s. then ..s. . The proof, which relies on Theorem 10, is given in \nthe Appendix. 5. Implementation As already mentioned, our approach allows a modular im\u00adplementation, \nrelying on typechecking and execution of the conventional language. This is effectively shown by our \npro\u00adtotype compiler, which is built on top on the standard Java compiler and virtual machine. In this \nsection, we describe in some more detail how this modular implementation works. We will use the metavariables \neJ and pJ for plain Java ex\u00adpressions and programs, respectively; moreover, mpJ stands for a sequence \nclass C =eJ. First of all, in order to reuse the standard Java compiler, it is clear that we need a translation \nstep which transforms METAFJIG expressions e and programs p into plain Java expressions eJ and programs \npJ, respectively. Notably, primitive types class and name are not avail\u00adable in plain Java, but are \nencoded by two classes MFJClass and MFJName, respectively. The former offers a method for each composition \noperator. We denote by n and c the values of type MFJName and MFJClass which are the Java repre\u00adsentation \nof a name n and a base class c, respectively. We omit the details of this representation, which are not \nrele\u00advant, and only assume that it is invertible. If p=class C =c is a METAFJIG program, then we denote \nby p the sequence class C =c , which is a special case of mpJ. More precisely, the compilation uses two \ndifferent trans\u00adlation functions, formally de.ned in Figure 13 in the Ap\u00adpendix: .e.0 and .p... The former \ntranslates e into the cor\u00adresponding eJ, while the latter translates p into the corre\u00adsponding pJ. Two \ndifferent functions are needed since well-typedness of the Java code obtained by the translation should \nen\u00adcode METAFJIG well-typedness and METAFJIG deep well\u00adtypedness of the source METAFJIG code, respectively. \nFor\u00admally, the two translations ensure that the following proper\u00adties hold: if .p.. is de.ned, then \n.p =..p.. ,  .; \u00d8; \u00d8; \u00d8.e:class if and only if .; \u00d8. .e.0:MFJClass, where .; . . eJ:T is the typing \njudgment for Java ex\u00adpressions,  ..p if and only if . . .p.., where . . pJ is the typing judgment for \nJava programs,  .p . C =C . if and only if .p .IC =IC. , where IC is the Java interface name which translates \nC (see Figure 13 in the Appendix).  0 Figure 10 contains the implementation-oriented version of checked \ncompile-time execution. The rules are analogous to those in Figure 9, except that: Con.gurations are \nnow of the form pJ|mpJ|mp.  In steps (META-CHECK) and (META-CHECK-ERROR) (.rst case in the side condition), \nthe METAFJIG expres\u00adsion e is .rst translated into a Java expression and then passed to the Java compiler. \nIf compilation is successful, then the generated bytecode (source and bytecode form are identi.ed here) \nis added to the second portion of the con.guration.  In steps (CHECK) and (CHECK-ERROR), the METAFJIG \nprogram represented by p is .rst translated into a Java program and then passed to the Java compiler. \nIf compi\u00adlation is successful, then the generated bytecode is added to the .rst portion of the con.guration. \n In steps (META-RED) and (META-RED-ERROR), the Java (bytecode) expression eJ is evaluated by the JVM. \nWe  use the . arrow to model that JVM execution continues until getting a .nal result or an exception. \n 6. Conclusion We have de.ned a framework for composing classes, where classes are .rst-class values \nand new classes can be derived from existing ones by exploiting the full power of the lan\u00adguage itself, \nused on top of a small set of primitive com\u00adposition operators, instead of using a .xed mechanism like \ninheritance. We summarize below the key features and ad\u00advantages of our approach. First of all, thanks \nto meta-circularity, programmers do not need to learn esoteric syntax and idioms. Soundness is guaranteed \nby a lightweight technique, where class composition errors are detected dynamically, and conventional \ntyping errors are detected by interleaving typechecking with meta-reduction steps. As mentioned in the \nIntroduction, an alternative approach could be a purely static typechecking phase, as, e.g., in MetaML \n[30], taking place before non checked compile-time execution shown in Figure 7. This would of course \nrequire a sophisticated type system with structural types for meta-expressions, for instance constrained \ntypes as in [25, 2]. This alternative di\u00adrection is certainly interesting. However, the lightweight so\u00adlution \nproposed in this paper has the advantage of simplicity and modularity, since it allows to just reuse \nthe type sys\u00adtem of the conventional language, and the usual advantage of dynamic type systems that more \nprograms can be typed, which is even more signi.cant in a meta-programming con\u00adtext. For instance, no \nstatic type system could ever type the DBRecord example in Section 2.2, since the shape of classes produced \nby the create method depends by the shape of the corresponding table in the database. On the other hand, \ncompared with approaches which check generated code only a posteriori , we adopt an in\u00adcremental typechecking \nwhere errors are detected, either by the conventional type-checker or dynamically for composi\u00adtion errors, \nas soon as they appear. Hence, error detection is earlier and more informative error messages can be \npro\u00advided. Even more importantly, conventional reduction can be safely reused as it is, since no expression \nis executed before having been typechecked, hence dynamic errors like message not understood cannot be \nraised. Again, this is an advantage in terms of modularity, which allows the language to be implemented \non top of the Java Virtual Machine. Composition errors are modeled by exceptions, hence programmers can \ncustomize error messages and error han\u00addling, e.g., taking an alternative action when the composition \nof some classes fails. Finally, meta-level soundness (Theorem 7) guarantees that errors found by the \nconventional type-checker are al\u00adways due to programmers code, and not to the code of a library, differently \nfrom what happens, e.g., for C++ tem\u00adplates. This property holds thanks to the fact during compile\u00ad \n.pJ ; \u00d8. .e.0:MFJClass (META-CHECK) pJ|mpJ|class C =e mp -. pJ|mpJ class C =.e.0|mp mp(C)= e (META-CHECK-ERROR) \nclosed(pJ, .e.0) and .pJ ; \u00d8 .. .e.0:MFJClass pJ|p |mpJ -. errorT or =.p;mp cyclic eJ -.pJ c eJ -.pJ \nerror (META-RED) (META-RED-ERROR) pJ|class C =eJ mpJ|mp -. pJ|class C cmpJ|mp =eJ mpJ|mp -. error = pJ|class \nC (CHECK) .pJ . .p .. (CHECK-ERROR) closed(pJ, p ) and .pJ .. .p .. p mpJ|mp -. pJ .p ..|mpJ|mp pmpJ|mp \n-. errorT pJ| pJ| Figure 10. Implementation of checked compile-time execution time execution we cannot \ngenerate arbitrary code, but only compose class constants which were explicitly written in the library. \nMetaprogramming approaches can be classi.ed by two properties: whether the meta-language coincides with \nthe conventional language (the so-called meta-circular approach), and whether the code generation happens \nduring com\u00adpilation. MetaML [30], Prolog [28], OpenJava [31], and JavaMint [32] are meta-circular languages, \nwhile C++ [18], D [9], Meta-trait-Java [26] and MorphJ [16] use a special\u00adized meta-language.13 Almost \nany dynamically typed lan\u00adguage allows some sort of meta-circular facility, typically by offering an \neval function. Such a function allows to run arbitrary code, represented by an input string. Regarding \ncode generation, JavaMint, MetaML and Prolog perform the computation at run time, while C++, D, Meta-trait-Java, \nMorphJ and OpenJava use compile-time execution. Again, dynamically typed languages providing an eval \nfunction al\u00adlow runtime meta-programming.14 The work presented in this paper lies in the area of meta-circular \ncompile-time ex\u00adecution. Among the above mentioned approaches, [31] is the one showing more similarities \nwith ours. OpenJava offers the ability to de.ne new language constructs, on top of Java, using meta-circular \ncompile-time execution. Programmers can de.ne new constructs by writing meta-classes, that is, particular \nJava classes which instruct the OpenJava com\u00adpiler on how to perform the type-driven translation. These \nmeta-classes use the re.ection-based Meta Object Protocol (MOP) to manipulate the source code and provide \nits trans\u00adlation. However, their approach is de.nitely lower level than ours and we have a very different \nlong-term goal: that is, to bring compile-time execution in the realm of an already fa\u00ad 13 The latest \nversion of D seems to include a limited form of meta-circular compilation. 14 Some dynamic languages \nlike Groovy and Lisp allow also compile-time meta-programming.  miliar programming language, rather \nthan to allow program\u00admers to de.ne their own extensions of an existing language. The comparison with \nJavaMint [32] is also interesting, since our work is specular in many ways: JavaMint generates code at \nruntime, which consists of expressions only, and whose type is statically known. Instead, we generate \ncode at compile-time, consisting of class de.nitions only, and typechecking is (partially) dynamic. We \nplan to investigate extensions of our framework in two directions: type system re.nement and nested classes. \nIn the current model, typechecking steps during checked compile-time execution always require code to \nbe closed, that is, type information on all class names appearing in code must be available. Hence, typing \nerrors can be detected only at this time. We plan to de.ne a constraint-based type system, as in [2], \nwhere code can be typechecked separately, that is, even in absence of some used class, allowing earlier \nerror detection. A feature of Java-like languages whose impact on our approach seems challenging are \nnested classes. Among non\u00adtrivial issues are the generalization of primitive operators and the order \nof typechecking. A. Appendix Proof of Theorem 5. If s is neither a value, nor error, nor errorT, then \nit has the form p|mp.|mp where mp. mp = \u00d8. By cases: Assume .rst that there exists class C =e . mp. \nwith e not a value. Since .0s implies .p.0 e:class, by Theo\u00adrem 2 we have that e -.p e., hence s reduces \nby either (META-RED) or (META-RED-ERROR).  Otherwise, s has the form p|p.|mp with pmp .\u00d8.  = Assume \nmp = \u00d8. Then, since s is closed, closed(p, p.) clearly holds, hence s reduces by either (CHECK) or (CHECK-ERROR). \n C new C .(e) if C = C . or e if ee.m(e) . C . C . C . C . C . C . C . C . C  0 constructor(T1 \nx1 ... Tn xn) .C .C .C . C or e.C . C . C or e.C . C or e.C . C or e1.C .C . C or e1.C . C  \n .C . C C . T1 ... Tn .C if e.fe if e[+]e e 0 C .C if e[restrict e e 00 new C .(e).C if C = C . or e.C \nif e[alias e1 to e2] e 000 e.m(e).C if e.C or e.C or e2 00 e.f .C if e.C if e[redirect e1 to e2] e . \n00. 0 e[+]e.C if e.C or e.C or e2 00. 0 .].C if e.C or e.C if e[restrict eimplements C {kd} C . C or \nd 000 .C if e.C or e1.C or k e[alias e1 to e2] or e2 if {f1=e1 ... fk=ek} 000 e[redirect e1 to e2].C \nif e.C or e1.C or e1 ... ek 0 or e2.C . C . C  .C Tm(T1 x1 ... Tn xn) .C Cf abstract Cf if C . T , \nT1 ... Tn abstract Tm(T1 x1 ... Tn xn); if {return e;} .C C . T , T1 ... Tn 0 Figure 12. De.nition \nof e.C and e . . MT i=MT . . . n1:MT 1 ... nk:MT k= i .i . 1..h Otherwise, there exists a node C with \nno entrant edges. 1 = h = k (=-SIG) That is, there exists class C =e.mp s.t. the set n1:MT . .MT:n... \nh1h ...=.=. TT . TT ()=METHODTYPE\u00ad . . T . T = T . . T . (=-REFL) . . T =T .(C)= C; _; _; _ (=-DIRECT) \nC ..C . . C =C . . . C .=C .. . . C =C . (=-TRANS) . . C =C .. Figure 11. Subtyping Otherwise, consider \nthe graph with nodes dom(mp) and an edge from C . into C if C =.p.;mpC . is a di\u00adrect dependence, that \nis, holds by (DEPEND-DIRECT). If the graph is cyclic, then s reduces by (META-CHECK-ERROR). 0 C={C ..|e.C \n. , C .-.p. C ..} is a subset of dom(pp.). Assume C. dom(p). Then, closed(p, e) holds, hence s reduces \nby either (META-CHECK) or (META-CHECK-ERROR). Otherwise, let p.. be the maximal subset of p. s.t. dom(p.C. \nClearly closed(p, p..) holds, hence s reduces by either (CHECK) or (CHECK-ERROR). 0 00 Lemma 12. If \n\u00d8.p and .p.p., then \u00d8.pp. Proof. Easy check. Proof of Theorem 6. By cases on the applied rule: If the \napplied rule is (META-CHECK), then the thesis follows from the side condition of the rule.  If the applied \nrule is (CHECK), then the thesis follows from the side condition of the rule by Lemma 12.  If the applied \nrule is (META-CHECK-ERROR), (META-RED-ERROR) or (CHECK-ERROR), then the thesis triv\u00adially holds.  If \nthe applied rule is (META-RED), then, since .p.0 e:class holds, the thesis follows from Theorem 3.  \n .new C (e).0 = new CC (.e.0) = c .c.0 = n .n.0 .e1 + e2.0 = .e1.0.sumOp(.e2.0) .e1[redirect e2 to \ne3].0 = .e1.0.redirectOp(.e2.0 , .e3.0) .e1[alias e2 to e3].0 = .e1.0.aliasOp(.e2.0 , .e3.0) .e1[restrict \ne2].0 = .e1.0.restrictOp(.e2.0) = CC .thisRepr .C .0 .class C1=c1 ... class Cn =cn.. = .C1, c1.. ... \n.Cn, cn.. .C , c.. = .C , c..C1, c1. ... .Ck, ck. with extract.(c)= c1 ... ck and C1 ... Ckfresh .C , \nc. = public [abstract] class CC implements IC { .C , k..ad..fd..md. public static MFJClass thisRepr= \nc; } public interface IC extends I{ .ad.. .fd.. } C with c = implements C {k ad, fd, md}and [abstract] \nis present if ad . = \u00d8 .C , constructor(T1 x1 ... Tn xn){f1=e1 ... fk=ek}. = CC ( IT1 x1 ... ITn xn){ \nf1 = .e1.0; ... fk = .ek.0; } .Tf . = IT f; public IT f(){return f;} .abstract Tf . = public abstract \nIT f(); .abstract Tm(T1 x1 ... Tn xn);. = public abstract IT m(IT1 x1 ... ITn xn ); .Tm(T1 x1 ... Tn \nxn){return e;}. = IT m(IT1 x1 ... ITn xn ){return .e.0 ;} .abstract Tf . = IT f(); .Tf . = IT f(); .abstract \nTm(T1 x1 ... Tn xn);. = IT m(IT1 x1 ... ITn xn); .Tm(T1 x1 ... Tn xn){return e;}. = IT m(IT1 x1 ... ITn \nxn); Auxiliary functions (informally de.ned):  for each METAFJIG class name C , IC and CC are a Java \ninterface name and class name, respectively, where the functions I and C have disjoint codomains.  extract.(c) \nextracts all the inner class constants in c.  Figure 13. Translation functions Proof of Theorem 8. \nSince ..s clearly implies .0s, by Theo\u00adrem 5 we know that either s = errorT or the thesis holds. However, \ns = errorT cannot hold since .s. Lemma 13 (Weakening). If .; S; C .md then ., _;S, _; C , _.md. Lemma \n14 (Substitution). If .; S; C .md then .; S[n./n]; C .md[n./n]. Proof of Lemma 9. 1. We have that implements \nC 1{k1 d1}[+]implements C 2{k2 d2}-.p implements C {kd} with di = adi fdi mdi. Since we have applied \n(CLASS-T), we know that .; Sfd .k1 .; Sd1 ; C 1.md1, and analogously for k2 and md2. Moreover, since \nwe have applied (SUM), d1.d2 holds, hence Sd1 Sd2 is well-formed, and, by Lemma 13, .; Sd1 Sd2 ; C 1 \nC 2.md1md2 holds. Premises for (CONS-T) on k are the union of the premises for (CONS-T) on k1 and k2. \nThe last side condition of (SUM) of the result is the union of the last side condi\u00adtions of (SUM) of \nthe subcomponents. This implies that implements C {kd} is well-typed by (CLASS-T) 2. We have that implements \nC 1{k1 d1}[restrict n] -.p implements C {kd} with d1 = ad1 fd1 md1. Since we have applied (CLASS-T), \nwe know that .; Sfd .k1 and .; Sd1 ; C 1.md1. Moreover by (RESTRICT), d is obtained from d1 by removing \na member de.nition, hence Sd =Sd1 . Then, implements C {kd} is well\u00adtyped by (CLASS-T). 3. We have that \nimplements C 1{kd1}[redirect n1 to n2] -.p implements C {kd} with d1 = ad1 fd1 md1. Since we  have applied \n(CLASS-T), we know that .; Sfd .k1 and Principles of Programming Languages 2005. ACM Press, .; Sd1 ; \nC 1. by Lemma 14, the redirect operator removes the abstract declaration for n1 only if not needed to \nsatisfy the last sideconditionof (CLASS-T),hence implements C {kd}is well-typed by (CLASS-T). 4. We have \nthat implements C 1{k1 d1}[alias n1 to n2] -.p implements C {kd} with d1 = ad1 fd1 md1. Since we have \napplied (CLASS-T), we know that .; Sfd .md1. Method bodies preserve their types January 2005. [3] Davide \nAncona, Giovanni Lagorio, and Elena Zucca. Jam designing a Java extension with mixins. ACM Transactions \non Programming Languages and Systems, 25(5):641 712, September 2003. [4] Davide Ancona, Giovanni Lagorio, \nand Elena Zucca. Flexible type-safe linking of components for Java-like languages. In JMLC 06 -Joint \nModular Languages Conference, volume 4228 of Lecture Notes in Computer Science, pages 136 154. k1 Springer, \n2006. and .; Sd1 ; C 1.by adding one member de.nition. By side condition of md1. Moreover, d is obtained \nfrom d1 [5] Alexandre Bergel, St\u00e9phane Ducasse, Oscar Nierstrasz, and Roel Wuyts. Stateful traits and \ntheir formalization. Comput. rule (ALIAS), Sd1 n2:mtype(n1, md1) is well-formed, Lang. Syst. Struct., \n34(2-3):83 108, 2008. and by Lemma 13 .; Sd1 n2:mtype(n1, md1); C 1.The new method/expression n2 is also \nwell-typed since md. [6] Viviana Bono, Ferruccio Damiani, and Elena Giachino. On traits and types in \na Java-like setting. In TCS 08 -IFIP Int. its body is the same of n1, hence we can conclude that Conf. \non Theoretical Computer Science. Springer, 2008. implements C {kd} is well-typed by (CLASS-T). 1. If \n\u00d8.p and .p. [7] Gilad Bracha. The Programming Language JIGSAW: Mixins, Modularity and Multiple Inheritance. \nPhD thesis, p., then \u00d8.pp Lemma 15. . Department of Comp. Sci., Univ. of Utah, 1992. 2. If .p.:class, \nthen .p. [8] Krzysztof Czarnecki, Ulrich Eisenecker, Robert Gluck, Proof. David Vandevoorde, and Todd \nVeldhuizen. Generative programming and active libraries (extended abstract), pages 1. Easy check. 25 \n39. Number 1766 in Lecture Notes in Computer Science. p p . 2. Since, for all class C =c . pc:class has \nbeen , .p. deduced by rule (CLASS-CONSTANT-T*). [9] Digital Mars. D programming language, 2007. http://www.digitalmars.com/. \nProof of Theorem 11. By cases depending on the applied [10] St\u00e9phane Ducasse, Oscar Nierstrasz, Nathanael \nSch\u00e4rli, rule: Roel Wuyts, and Andrew Black. Traits: A mechanism for Springer, 2000.  (META-CHECK) and \n(META-CHECK-ERROR) cannot be .ne-grained reuse. ACM Transactions on Programming applied since ..|mp implies \nmp = \u00d8.  If the applied rule is (META-RED), then, since  .p. p|mp Languages and Systems, 28(2):331 \n388, 2006. [11] Erik Ernst. Family polymorphism. In J.L. Knudsen, editor, e:class holds, the thesis \nfollows from Theorem 10. ECOOP 01 -European Conference on Object-Oriented Programming, number 2072 in \nLecture Notes in Computer If the applied rule is (META-RED-ERROR), then the thesis Science, pages 303 \n326. Springer, 2001. trivially holds. [12] Erik Ernst. Higher-order hierarchies. In L. Cardelli, editor, \nIf the applied rule is (CHECK), then the thesis follows ECOOP 03 -Object-Oriented Programming, number \n2743 from the side condition of the rule by Lemma 15-(1). in Lecture Notes in Computer Science, pages \n303 328. Springer, 2003. (CHECK-ERROR) cannot be applied by Lemma 15-(2), since . mp.|mp implies .p.p \n[13] Robert Bruce Findler and Matthew Flatt. Modular object\u00ad p|p :class. oriented programming with units \nand mixins. In Intl. Conf. on Functional Programming 1998, 1998. Acknowledgments We warmly thank the \nanonymous referees for many helpful comments. References [1] Jonathan Aldrich, Craig Chambers, and David \nNotkin. Architectural reasoning in ArchJava. In Boris Magnusson, editor, ECOOP 02 -Object-Oriented Programming, \nnumber 2374 in Lecture Notes in Computer Science, pages 334 367. Springer, 2002. [2] Davide Ancona, Ferruccio \nDamiani, Sophia Drossopoulou, and Elena Zucca. Polymorphic bytecode: Compositional compilation for Java-like \nlanguages. In ACM Symp. on [14] Kathleen Fisher and John Reppy. A typed calculus of traits. In FOOL 04 \n-Intl. Workshop on Foundations of Object-Oriented Languages, 2004. [15] Matthew Flatt, Shriram Krishnamurthi, \nand Matthias Felleisen. Classes and mixins. In ACM Symp. on Prin\u00adciples of Programming Languages 1998, \npages 171 183. ACM Press, 1998. [16] Shan Shan Huang, David Zook, and Yannis Smaragdakis. Morphing: Safely \nshaping a class in the image of others. In ECOOP 07 -Object-Oriented Programming, pages 399 424. Springer, \nAugust 2007. [17] Atsushi Igarashi, Benjamin C. Pierce, and Philip Wadler.  Featherweight Java: A minimal \ncore calculus for Java and GJ. In ACM Symp. on Object-Oriented Programming: Systems, Languages and Applications \n1999, pages 132 146. ACM Press, 1999. [18] International Organization for Standardization. ISO/IEC 14882:2003: \nProgramming languages C++. International Organization for Standardization, 2003. [19] Giovanni Lagorio, \nMarco Servetto, and Elena Zucca. Cus\u00adtomizable composition operators for Java-like classes (ex\u00adtended \nabstract). In ICTCS 09 -Italian Conf. on Theoretical Computer Science, 2009. [20] Giovanni Lagorio, Marco \nServetto, and Elena Zucca. Feath\u00aderweight Jigsaw -a minimal core calculus for modular com\u00adposition of \nclasses. In Sophia Drossopoulou, editor, ECOOP 2009 -Object-Oriented Programming, number 5653 in Lec\u00adture \nNotes in Computer Science. Springer, 2009. [21] Giovanni Lagorio, Marco Servetto, and Elena Zucca. Flat\u00adtening \nversus direct semantics for Featherweight Jigsaw. In FOOL 09 -Intl. Workshop on Foundations of Object-Oriented \nLanguages, 2009. [22] Giovanni Lagorio, Marco Servetto, and Elena Zucca. A lightweight approach to customizable \ncomposition operators for Java-like classes. Electronic Notes in Theoretical Com\u00adputer Science, 263:161 \n177, 2010. FACS 09 -International Workshop on Formal Aspects of Component Software. [23] Luigi Liquori \nand Arnaud Spiwack. FeatherTrait: A modest extension of Featherweight Java. ACM Transactions on Programming \nLanguages and Systems, 30(2), 2008. [24] Sean McDirmid, Matthew Flatt, and Wilson C. Hsieh. Jiazzi: New \nage components for old fashioned Java. In ACM SIGPLAN Conference on Object-Oriented Programming, Systems, \nLanguages and Applications (OOPSLA 2001). ACM Press, 2001. SIGPLAN Notices. [25] N. Nystrom, V. A. Saraswat, \nJ. Palsberg, and C. Grothoff. Constrained types for object-oriented languages. In OOPSLA 2008, pages \n457 474, 2008. [26] John Reppy and Aaron Turon. Metaprogramming with traits. In Erik Ernst, editor, ECOOP \n07 -Object-Oriented Programming, number 4609 in Lecture Notes in Computer Science, pages 373 398. Springer, \n2007. [27] Nathanael Sch\u00e4rli, St\u00e9phane Ducasse, Oscar Nierstrasz, and Andrew P. Black. Traits: Composable \nunits of behaviour. In ECOOP 03 -Object-Oriented Programming, volume 2743 of Lecture Notes in Computer \nScience, pages 248 274. Springer, 2003. [28] Leon Shapiro and Ehud Y. Sterling. The Art of PROLOG: Advanced \nProgramming Techniques. The MIT Press, April 1994. [29] Tim Sheard. Accomplishments and research challenges \nin meta-programming. In 2nd Int. Workshop on Semantics, Applications, and Implementation of Program Generation, \nvolume 2196 of Lecture Notes in Computer Science, pages 2 44. Springer, 2000. [30] Walid Taha and Tim \nSheard. MetaML and multi-stage pro\u00adgramming with explicit annotations. Theoretical Computer Science, \n248(1-2):211 242, 2000. [31] Michiaki Tatsubori, Shigeru Chiba, Marc-Olivier Kilijian, and Kozo Itano. \nOpenJava: A class-based macro system for Java. In Walter Cazzola, Robert J. Stroud, and Francesco Tisato, \neditors, Re.ection and Software Engineering, Lecture Notes in Computer Science, pages 117 133. Springer, \n2000. [32] Edwin Westbrook, Mathias Ricken, Jun Inoue, Yilong Yao, Tamer Abdelatif, and Walid Taha. Mint: \nJava multi\u00adstage programming using weak separability. In PLDI 10 -ACM Conf. on Programming Language Design \nand Implementation. ACM Press, 2010.   \n\t\t\t", "proc_id": "1869459", "abstract": "<p>We propose a Java-like language where class definitions are first class values and new classes can be derived from existing ones by exploiting the full power of the language itself, used on top of a small set of primitive composition operators, instead of using a fixed mechanism like inheritance.</p> <p>Hence, compilation requires to perform (meta-)reduction steps, by a process that we call <i>compile-time execution</i>. This approach differs from meta-programming techniques available in mainstream languages since it is meta-circular, hence programmers are not required to learn new syntax and idioms.</p> <p>Compile-time execution is guaranteed to be sound (not to get stuck) by a lightweight technique, where class composition errors are detected dynamically, and conventional typing errors are detected by interleaving typechecking with meta-reduction steps. This allows for a modular approach, that is, compile-time execution is defined, and can be implemented, on top of typechecking and execution of the underlying language. Moreover, programmers can handle errors due to composition operators.</p> <p>Besides soundness, our technique ensures an additional important property called <i>meta-level</i> soundness, that is, typing errors never originate from (meta-)code in already compiled programs.</p>", "authors": [{"name": "Marco Servetto", "author_profile_id": "81442615068", "affiliation": "Universit&#224; di Genova, Genova, Italy", "person_id": "P2354092", "email_address": "", "orcid_id": ""}, {"name": "Elena Zucca", "author_profile_id": "81100312049", "affiliation": "Universit&#224; di Genova, Genova, Italy", "person_id": "P2354093", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869498", "year": "2010", "article_id": "1869498", "conference": "OOPSLA", "title": "MetaFJig: a meta-circular composition language for Java-like classes", "url": "http://dl.acm.org/citation.cfm?id=1869498"}