{"article_publication_date": "10-17-2010", "fulltext": "\n Specifying and Implementing Refactorings Max Sch\u00e4fer Oege de Moor Oxford University Computing Laboratory, \nUK {max.schaefer, oege.de.moor}@comlab.ox.ac.uk Abstract Modern IDEs for object-oriented languages like \nJava pro\u00advide support for a basic set of simple automated refactor\u00adings whose behaviour is easy to describe \nintuitively. It is, however, surprisingly dif.cult to specify their behaviour in detail. In particular, \nthe popular precondition-based ap\u00adproach tends to produce somewhat unwieldy descriptions if advanced \nfeatures of the object language are taken into account. This has resulted in refactoring implementations \nthat are complex, hard to understand, and even harder to maintain, yet these implementations themselves \nare the only precise speci.cation of many refactorings. We have in past work advocated a different approach \nbased on sev\u00aderal complementary notions of dependencies that guide the implementation, and on the concept \nof microrefactorings that structure it. We show in this work that these concepts are powerful enough \nto provide high-level speci.cations of many of the refactorings implemented in Eclipse. These speci.cations \nare precise enough to serve as the basis of a clean-room reimplementation of these refactorings that \nis very compact, yet matches Eclipse s for features and outper\u00adforms it in terms of correctness. Categories \nand Subject Descriptors D.3.4 [Programming Languages]: Processors General Terms Languages Keywords Refactoring, \nspeci.cation, language extensions 1. Introduction A refactoring can only be useful if it is easy to understand \nfor the programmer, and if it encapsulates operations that programmers .nd themselves doing over and \nover again. Indeed, most basic refactorings available in modern IDEs are easily explained in terms of \none or two simple examples. Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright c \n&#38;#169; 2010 ACM 978-1-4503-0203-6/10/10. . . $5.00 But describing a refactoring precisely is a perhaps \nunex\u00adpectedly dif.cult task. The complexities of real-world pro\u00adgramming languages conspire to make it \na formidable task to account for all corner cases and always produce output programs that are both syntactically \ncorrect and semantically equivalent to the input program. Popular textbooks on refactorings [Fow00, Ker05] \nhence tend to gloss over the .ner details and advise the program\u00admer to rely on frequent testing to ensure \nbehaviour preserva\u00adtion. Even the more precise descriptions in Opdyke s classic work [Opd92] are only \nloosely based on a simpli.ed subset of C++ and make no attempt to account for all eventualities. But \nit seems that the imprecision of these descriptions is directly re.ected in the sometimes very low standards \nof cor\u00adrectness [SEEV10] of popular refactoring implementations like those of Eclipse and IntelliJ [Fou10, \nJet10] even for lan\u00ad guages like Java where automated refactoring tools enjoy great popularity. These \nimplementations are hard to under\u00adstand and even harder to maintain: for example, a seemingly rather \nstraightforward bug in Eclipse s INLINE METHOD refactoring has gone un.xed for almost .ve years. 1 Without \nprecise descriptions, it is hard to answer even very simple questions about refactorings. For example, \nthe .rst author recently found himself trying to judge which of Eclipse s built-in refactorings could \npotentially move a .eld access out of a synchronized block, which is unsafe in the face of concurrency. \nWith existing speci.cations being too general and vague and implementations being too compli\u00adcated and \nlowlevel, there is no good source for gaining the sort of in-depth understanding of individual refactorings \nthat is needed to answer such questions. This work takes a step towards remedying the situation by providing \nhighlevel speci.cations of common refactor\u00adings that are brief and concise, yet aim to be precise enough \nto cover all features of the Java 5 language. We further\u00admore present an implementation of these speci.cations \nas part of a refactoring engine based on the JastAddJ Java com\u00adpiler [EH07a] and evaluate its correctness \nusing Eclipse s internal test suite.2 1 See https://bugs.eclipse.org/bugs/show_bug.cgi?id=112100. 2 The \nimplementation, including its test suite, is available for download from http://jastadd.org/refactoring-tools. \n void m() { int[] xs = {23, 42 }; } void n() { int[] xs; xs = new int[] { 23, 42 }; } Figure 1. Array \ninitialisers and array creation expressions To provide such descriptions, we choose not to follow the \ntraditional precondition-based approach. While precon\u00additions are valuable for specifying shallow conditions \nthat must hold in order for the refactoring to make sense at all, they are not the right tool to ensure \nbehaviour preservation in the face of issues related to name capture or control and data .ow preservation. \nAs we have argued in previous work [SEdM08, SVEdM09, SDS+10], such problems are much easier to tackle \nif they are expressed as dependency preservation problems. For ex\u00adample, in many refactorings we want \nto ensure that name bindings do not change, or that a name binds to a given declaration. We accommodate \nthis by introducing a name binding dependency that is tracked by the refactoring engine. After the refactoring \nhas performed its code transformations, the engine checks whether all tracked dependencies are still \npresent, i.e. whether the name still binds to the intended dec\u00adlaration. If this is not the case, the \nengine either adjusts the name to restore its binding (for instance by qualifying it to escape shadowing), \nor aborts the whole refactoring. Con\u00adtrol and data .ow preservation is treated in a very similar manner. \nBesides these deep issues, refactoring engines also have to account for a host of much shallower issues \nrelated to irregularities or idiosyncrasies of the object language. For example, Java allows so-called \narray initialisers to occur in variable initialisations. They are, however, not .rst-class expressions \nand cannot occur in many other places, where they have to be elaborated into slightly more complex array \ncreation expressions. An example is given in Fig. 1, which shows two meth\u00ad ods m and n that both declare \na local integer array xs and initialise it. But while m initialises xs directly in its declara\u00adtion and \ncan hence use an array initialiser, n initialises the variable using an explicit assignment and has to \nuse an ar\u00adray creation expression. Obviously, the methods are seman\u00adtically equivalent, and indeed the \nsame bytecode is generated for both. Any refactoring that moves an expression from a variable initialisation \nto some other place in the code has to be aware of this problem and wrap array initialisers accordingly. \nIt would certainly be much preferable to encapsulate this issue and handle it once and for all. To address \nthis kind of problem, we use the approach of lightweight language extensions [SVEdM09]: while our refactoring \nimplementations work on Java programs and produce Java programs as output, intermediate steps can work \non a richer language that provides additional features to facilitate implementation, which are then translated \naway into pure Java. These features are lightweight extensions in the sense that they are transparent \nto the user of the refac\u00adtoring tool and never appear in the refactored program. A particularly simple \nextension is to make array initialisers .rst-class expressions; translating this extension away is, of \ncourse, achieved by wrapping them into array creation ex\u00adpressions. Other refactorings require more complicated \nextensions, such as anonymous methods [SVEdM09] or with state\u00adments [SdM09]. One might then worry that \nevery refactoring needs different language extensions, leading to a prolifera\u00adtion of potentially similar \nyet incompatible language exten\u00adsions. It is one of our aims in this work to allay these fears by showing \nthat just a handful of fairly simple extensions suf\u00ad.ce to implement many major refactorings, and can \nindeed often be shared between different refactorings. Just as many refactoring steps are more easily \nexpressed by allowing them to output programs in an extended lan\u00adguage, it is often convenient for refactorings \nto assume that their input programs are written in a restricted language that does not contain certain \nfeatures that would otherwise need special treatment. For example, the synchronized modi\u00ad.er on methods \nin Java turns out to be rather troublesome since it hides a dependency on the implicit monitor associ\u00adated \nwith the receiver object. Strictly speaking, this modi.er is not needed, since it can be replaced by \na synchronized block around the body of the method, which makes the dependency explicit. We can simplify \nour implementation by .rst translating the modi\u00ad.er away in this manner, and then reintroducing it where \npossible after the refactoring [SDS+10]. Indeed, the long\u00ad standing Eclipse bug alluded to above hinges \non this issue. One major bene.t of using language extensions and re\u00adstrictions is that it often allows \nus to decompose a refactor\u00ading into several smaller refactorings, so-called microrefac\u00adtorings, that \ncan be speci.ed, implemented, and tested in isolation. While earlier work [SVEdM09] has shown that such \na decomposition is possible for certain refactorings, the present work extends this to many other refactorings. \nIn summary, the main contributions of this work are as follows: We show that the previously introduced \ntechniques of de\u00adpendency preservation, language extensions and restric\u00adtions, and microrefactorings \nare suf.ciently powerful to give high-level, yet precise speci.cations of many refac\u00adtorings that easily \n.t within half a page, but handle the full Java 5 language.  class A{ class A{ int f; void m() { void \nm() { int f = 23; . f = 23; ... ... }} }} Figure 2. A simple use of PROMOTE TEMP TO FIELD We demonstrate \non some examples that these speci.ca\u00adtions are highly modular and that microrefactorings and language \nextensions are reusable between refactorings.  We present an extensive case study to show that the speci.cations \ngive rise to concise, high-quality imple\u00admentations of all the refactorings offered in recent ver\u00adsions \nof Eclipse3, which perform very well on Eclipse s own test suite.  The rest of the paper is structured \nas follows: Section 2 in\u00ad troduces the relevant techniques of dependencies, language extensions, and \nmicrorefactorings with the PROMOTE TEMP TO FIELD refactoring as the running example. Section 3 ex\u00ad plains \nhow to use these techniques to provide speci.cations of refactorings and how these can be implemented; \nSec\u00adtion 4 discusses speci.cations for PUSH DOWN METHOD and MOVE MEMBER TYPE TO TOPLEVEL in more detail. \nSection 5 relates our experience with providing speci.ca\u00ad tions and implementations for other Eclipse \nrefactorings and pitches our implementation against Eclipse s on their own test suite. Section 6 puts \nour work in the context of related work, and Section 7 concludes. 2. Dependencies and Language Extensions \nTo make the presentation self-contained, this section will introduce the different kinds of dependencies \nused in our approach, as well as the concepts of language extensions and microrefactorings on the example \nof the PROMOTE TEMP TO FIELD refactoring. The PROMOTE TEMP TO FIELD refactoring, offered by both Eclipse \n(as Convert Local Variable to Field ) and In\u00adtelliJ (as Introduce Field ), converts a local variable \ninto a .eld, for example as the .rst step of the REPLACE METHOD WITH METHOD OBJECT refactoring [Fow00]. \nA very sim\u00ad ple example is shown in Fig. 2, where the local variable f is promoted to a .eld. We use \nthis example to establish some notational con\u00adventions: When presenting an example of how a refactor\u00ading \nis performed, we will always display the input program (or fragment) on the left, and the refactored \nprogram on the right, connected by a heavy arrow. For clarity, the piece of code in the original program \nthe refactoring is applied to (the 3 We leave aside a handful of refactorings that have already been \nstudied in the literature. class Super { class Super { int f = 42; int f = 42; }} class A class A extends \nSuper { extends Super { int f; int f() { . int f() { return f; return super.f; }} void m() { void m() \n{ int f; f=23; f=23; }} }} Figure 3. Example of a naming issue with PROMOTE TEMP TO FIELD local variable \nin this example) is highlighted in dark grey, whereas the changed code in the resulting program is marked \nin light grey. Based on this example, the refactoring is indeed easy to describe: if the local variable \nis initialised, turn its initiali\u00adsation into an assignment; then move the declaration of the local variable \ninto the surrounding type so that it becomes a .eld. Figure 3 gives an example of a naming problem that \nmay complicate the refactoring: here, a .eld f is inherited from the super class and used in method f. \nPromoting the local variable f of method m to a .eld hides the inherited .eld f within class A, and in \nparticular within method f. The solution is, of course, to qualify f with super to circumvent this shadowing. \nEclipse neglects to do this, while IntelliJ warns that a .eld of the same name is declared in the super \nclass (which is arguably not the essence of the problem), but does not insert a quali.cation either. \nLet us consider the general case, where we want to turn a local variable f into a .eld of class A. Should \nwe always qualify every unquali.ed reference to any .eld f from within A with super? This is neither \ncorrect nor suf.cient: if the reference is within a static method, super is not available; on the other \nhand, even references in subclasses or nested classes of A may be in.uenced by the refactoring. Instead, \nwe can view this as a dependency preservation problem. One necessary condition for PROMOTE TEMP TO FIELD \nto be behaviour preserving is certainly that all refer\u00adences to the former local variable f now bind \nto the intro\u00adduced .eld f, and all other name bindings stay the same. In past work [SEdM08] we have introduced \na framework of locked names that allow us to achieve this: before promot\u00ading, we lock every access to \nany .eld of name f within the  class A{ int f(int y) { if(y<= 1) return 1; . int x = y; return f(y-1) \n* x; } } Figure 4. Example of a data .ow issue with PROMOTE TEMP TO FIELD whole program4, i.e. we compute \nthe declaration it binds to and store it along with the name. In the same vein, all refer\u00adences to the \nlocal variable f are locked to the new .eld. After promoting, we check for every name whether it still \nbinds to the declaration it was locked on, and adjust it if it does not. The details of this adjustment \nprocess are beyond the scope of the present paper; suf.ce it to say that in the above example we would \nadjust the reference to f by qualifying it with super, as expected. A somewhat thornier issue is presented \nin Fig. 4. Here e y we have a function that computes k for every input k=1 y, storing the value of y \n(somewhat arti.cially) in a local variable x. The point of this example is that if we blindly promote \nx to a .eld (as Eclipse and IntelliJ both do), its value will be clobbered by the recursive invocation, \nand the function will instead compute max(2y-1 , 1). Indeed, it does not seem that x is a very good candidate \nfor being turned into a .eld, so a refactoring tool would arguably be justi.ed in rejecting the proposed \nrefactoring, as indicated by the lightning symbol. But should we always disallow promoting local variables \nof recursive methods? For one, it is in general undecidable whether a method is recursive in the presence \nof dynamic dispatch. But even if we have a conservative check for re\u00adcursive invocations, disallowing \npromotion in the presence of recursion altogether seems overly drastic. For instance, if we slightly \nmodify the above example by swapping the operands of the multiplication, the recursion becomes harm\u00adless \nand we can promote x without dif.culty. The solution is, again, to track dependencies. In the orig\u00adinal \nprogram of Fig. 4, the reference to x in the return statement has a single reaching de.nition, namely \nthe as\u00adsignment to x in its initialisation. If we were to turn x into a .eld, it would pick up an additional \nreaching de.nition from the recursive invocation of f, whereas reaching de.nitions would remain unchanged \nin the variant with swapped multi\u00adplicands. So we introduce a .ow dependency from every variable to every \none of its reaching de.nitions, and require, just as 4 Names other than f obviously will not change their \nbinding. A performance-conscious implementation may, of course, try to limit the scope in which to lock \nnames. for name bindings, that .ow dependencies for accesses to the promoted local variable are preserved. \nBut while we can often adjust a name to repair a broken name binding, this is generally hard to do for \n.ow dependencies. We choose the simpler option of just aborting the refactoring if .ow dependencies change. \nFinally, even if naming and .ow dependencies are pre\u00adserved, PROMOTE TEMP TO FIELD can still change the \nbe\u00adhaviour of multi-threaded programs, since it does nothing to prevent multiple threads from concurrently \naccessing and updating the promoted variable. Two possible solutions to this problem are as follows: \n Make the method from which the variable was promoted synchronized. Since even the promoted variable \nis still only accessed from within that method, we can thus prevent multiple threads from accessing it \nconcurrently. However, this solution drastically changes the concur\u00adrent behaviour of the program and \nmight easily introduce deadlocks.  Wrap the promoted .eld into a ThreadLocal, and then use an escape \nanalysis to determine whether the wrapper can safely be removed. This requires rewriting accesses to \nthe variable to go through the ThreadLocal API.  The second solution is obviously preferable, and is \nagain amenable to dependency-based reasoning. In addition to naming and .ow dependencies, we keep track \nof synchroni\u00adsation dependencies [SDS+10] which capture ordering con\u00ad straints between synchronisation \nconstructs and accesses to shared state. In particular, accesses to local variables gener\u00adate no constraints \n(since local variables are never shared be\u00adtween threads), and neither do ThreadLocal objects (which \nare not shared either), so from a concurrency perspective the refactoring becomes a no-op. For the sake \nof simplicity we will not elaborate this solution in detail. Incidentally, neither Eclipse nor IntelliJ \ntry to address the problem of concurrency in their implementations of PROMOTE TEMP TO FIELD. With the \ndeep issues related to naming, control and data .ow, and concurrency taken care of, it remains to tackle \nmore shallow problems engendered by the syntactic pecu\u00adliarities of our object language Java. In the \n.rst step of our present refactoring, we need to split off any initialiser of the variable to be promoted \ninto an independent assignment. As discussed earlier, the result of this transformation could contain \n.rst-class array initialisers. Also note that the variable could be declared together with several other \nvariables in a compound declaration like this: int x, y = f(),z = g(); If we want to promote variable \ny to a .eld, we should .rst translate this fragment into the equivalent int x; int y = f(); int z = g(); \n  before splitting off the assignment and proceeding as above. It would not do to insert the assignment \nafter the entire compound declaration, since this might change the order in which initialising expressions \nare evaluated, possibly chang\u00ading behaviour. Converting between compound declarations and their expansion \nis, of course, easy to do, so we can simply regard it as a language restriction and formulate our refactoring \non the restricted language of Java without com\u00adpound declarations. Based on the framework of dependency \npreservation and language extensions and restrictions, we can now give an in\u00adformal, yet precise description \nof the refactoring. For modu\u00adlarity and reusability, we split the refactoring into four steps, three \nof which are themselves microrefactorings: 1. SPLIT DECLARATION. Given a local variable declaration d \nfor a variable x with initialising expression e (where d must not be compound), ensure that d is a statement \nin a block (not, for example, the initialising statement of a for loop). Remove its initialiser and instead \ninsert a new statement a of the form x= e; after d, where the name x is locked to d. The output of this \nmicrorefactoring may make use of .rst-class array initialisers. 2. INSERT FIELD. Insert a declaration \nd' for a .eld x with the same type as the local variable x into the surrounding class. If the local variable \noccurs in a static context, the .eld should be static as well. Check that there is not already a .eld \nwith the same name in the same class, and ensure that bindings are preserved. 3. For every use of the \nlocal variable x, lock its .ow depen\u00addencies, and make its name binding locked onto d'. 4. REMOVE DECLARATION. \nIf there are no remaining ref\u00aderences to d, delete it.  3. Speci.cation and Implementation Prose descriptions \nlike that of PROMOTE TEMP TO FIELD in the previous section tend to be quite hard to read, so we will \nintroduce a number of conventions to enable us to cast our descriptions into more concise pseudocode. \nThis will allow us to successfully tackle several more complicated refactorings. Algorithm 1 corresponds \nto the prose description of PRO-MOTE TEMP TO FIELD given before. We specify refactor\u00adings as imperative \nprocedures that modify the input pro\u00adgram s abstract syntax tree. They may take arguments (such as argument \nd of PROMOTE TEMP TO FIELD) and return results (although this one does not). Both arguments and re\u00adsults \nare given informal types, for example d is supposed to be an AST node representing a local variable declaration. \nA full list of the node types used in this paper is given in Fig. 7 in Appendix A, where we also summarise \nsyntactic conven\u00ad tions used in our pseudocode speci.cations. As the .rst part of the speci.cation, we \nlist the input and output language of every refactoring, indicating whether it Algorithm 1 PROMOTE TEMP \nTO FIELD(d : LocalVar) Input Language: Java Output Language: Java . locked dependencies 1: lSPLIT DECLARATIONJ(d) \n2: d' . new private .eld of same type and name as d 3: make d' static if d is in static context 4: lINSERT \nFIELDJ(hostType(d),d') 5: for all uses u of d do 6: lock u onto d' 7: lock reaching de.nitions of u 8: \nREMOVE DECL(d) requires any restrictions on the former or extensions of the latter. For this refactoring, \nfor instance, the output program may still contain locked name bindings and .ow dependen\u00adcies, which \ncan be eliminated as described in the previous section. Since this elimination process is not refactoring-speci.c, \nwe do not consider it part of the speci.cation proper. Indeed, as we shall see, it is sometimes useful \nto preserve extended features in the output program if the refactoring is invoked as part of a larger \nrefactoring. Hence we leave it up to the caller whether language extensions in the output program should \nbe eliminated or not. The main body of the implementation closely follows the prose description given \nabove: .rst, we invoke the mi\u00adcrorefactoring SPLIT DECLARATION to strip off d s ini\u00adtialiser, if any. \nWe put .oor brackets l\u00b7J around the invo\u00adcation of this microrefactoring to indicate that any language \nextensions in the output program it produces should be im\u00admediately eliminated. We then construct a new \nnode d' corresponding to the new .eld, which has the same name and type as d (an imple\u00admentation may \nneed to use the locked naming framework to build a concrete type access that binds to this type). If \nd appears in a static context (i.e., either in a static method or a static initialiser), the promoted \n.eld is made static as well to ensure that it is accessible. Then we in\u00advoke the microrefactoring INSERT \nFIELD to insert the pro\u00admoted .eld into the closest lexically enclosing type around d, which we assume \nto be computed by the utility function hostType. Again, we require any language extensions to be eliminated. \nAs we shall see, INSERT FIELD may fail if it cannot perform its assigned task, for instance if there \nalready is a .eld of the same name in the type. By default this means that the whole refactoring fails; \nan actual implementation would need to provide descriptive error messages and roll back any changes to \nthe syntax tree. Now we lock every use of d onto the .eld d' and also lock its .ow dependencies, before \n.nally invoking REMOVE DECL to remove the old declaration d if possible. Finally, the remaining locked \nnames and .ow dependencies can be unlocked, which may cause the refactoring to fail.  Let us now consider \nthe constituent microrefactorings of PROMOTE TEMP TO FIELD. The .rst one, SPLIT DECLA-RATION is speci.ed \nas Alg. 2. It also takes a LocalVar as argument, and its output program may contain locked names and \n.rst-class array initialisers. As mentioned above, we re\u00adstrict the input programs to this microrefactoring \nto disal\u00adlow compound declarations that declare several variables at once. In contrast to language extensions \nin the output pro\u00adgram, which may be allowed to persist after the end of a microrefactoring, language \nrestrictions are always enforced when a refactoring begins to execute. We leave this implicit in the \nspeci.cation, since the input language speci.cation makes it clear which restrictions to enforce. If \nthe declaration d does not have an initialiser, SPLIT DECLARATION does not need to do anything. Otherwise, \nit constructs a new assignment a that assigns the initialising expression of d to the variable declared \nin d, inserts it as the next statement after d (or fails if d is not immediately surrounded by a block), \nand then removes its initialiser. In spite of its simplicity, SPLIT DECLARATION is an im\u00adportant building \nblock for other refactorings; besides PRO-MOTE TEMP TO FIELD, it is also used in the implementation of \nEXTRACT METHOD and INLINE TEMP [SVEdM09]. Algorithm 2 SPLIT DECLARATION(d : LocalVar) Input Language: \nJava \\ compound declarations Output Language: Java . locked names, .rst-class array init 1: if d has \ninitialiser then 2: x . variable declared in d 3: a . new assignment from initialiser of d to x 4: insert \na as statement after d 5: remove initialiser of d The next refactoring is INSERT FIELD, which inserts \nthe declaration d of a .eld into a type declaration T , ensuring that the output is syntactically valid \nand the binding structure is undisturbed. It uses assertions to check several preconditions; if any of \nthem are violated, the refactoring cannot be meaningfully executed and is aborted. In particular, it \nchecks that no other .eld of the same name is already declared in T , which would lead to a syntactically \nincorrect program; that d does not have an initialiser, since an initialiser might have side effects \nthat change program behaviour; and that we are not trying to insert a static .eld that is not a compile-time \nconstant into an inner class, which is disallowed by the language speci.cation. Note that the latter \ntwo checks are unnecessary in the context of the PROMOTE TEMP TO FIELD refactoring (the promoted .eld \nnever has an initialiser, and if the .eld is static, then so is the method it is promoted from, so the \nhost type cannot have been an inner class to begin with), but we include them for modularity and since \nwe want INSERT FIELD to be a behaviour-preserving refactoring on its own. If all the checks pass, the \nrefactoring locks all accesses to types or variables with the same name as d: we assume that name gives \nus the name of a declaration, and that lockNames performs the locking. Finally, the .eld is in\u00adserted \ninto the syntax tree of T . Like SPLIT DECLARATION, INSERT FIELD is quite ver\u00adsatile, and is also used \nas part of the EXTRACT CON-STANT, MOVE MEMBERS, and MOVE MEMBER TYPE TO TOPLEVEL refactorings. Algorithm \n3 INSERT FIELD(T : ClassOrInterface,d : Field ) Input Language: Java Output Language: Java . locked names \n1: assert T has no local .eld with same name as d 2: assert d has no initialiser 3: assert if T is inner \nand d is static, then d is a constant 4: lockNames(name(d)) 5: insert .eld d into T The .nal microrefactoring \nREMOVE DECL (which also plays a role in INLINE TEMP) is now easily described as Alg. 4: If d has no initialiser \nand is not referenced anywhere, we remove it from the AST; otherwise we do nothing. Algorithm 4 REMOVE \nDECL(d : LocalVar) Input Language: Java \\ compound declarations Output Language: Java 1: if d has no \ninitialiser and is not used then 2: remove d Note that our speci.cation of PROMOTE TEMP TO FIELD does \nnot allow for the promoted local variable s initialiser to be promoted into an initialiser of the .eld. \nDoing so not only requires moving an expression across method boundaries, which is hardly ever behaviour \npreserving, but also might change the order in which assignments to the variable occur. Eclipse, which \noffers this feature, performs almost no checks to guarantee behaviour preservation in this case, which \nwe consider unacceptable. While the speci.cations we have given so far are in pseu\u00addocode, they are not \nvery dif.cult to implement. Our own implementation of PROMOTE TEMP TO FIELD and the other refactorings \ndiscussed in the sequel is based on the JastAddJ compiler frontend, which provides the general AST infras\u00adtructure \nand some basic analysis capabilities, such as name lookup and control .ow analysis. The required utility \nfunc\u00adtions are either already provided by the compiler frontend or are very easy to implement on top \nof it. Earlier work has al\u00adready discussed how we implement the dependency tracking  public void VariableDeclaration \n.promoteToField() { split(); Modifiers mods = new Modifiers(\"private\"); if(inStaticContext()) mods.addModifier(\"static\"); \nTypeAccess ta = type().createLockedAccess(); FieldDeclaration f = new FieldDeclaration(mods, ta, name()); \nhostType().insertField(f); for(VarAccess va : uses()) { va.lock(f); va.lockReachingDefs(); } flushCaches(); \nremove(); } public void VariableDeclaration .doPromoteToField() { Program root = programRoot(); promoteToField(); \nroot.eliminate(LOCKED_NAMES, LOCKED_FLOW); } Figure 5. JastAdd implementation of PROMOTE TEMP TO FIELD \nframework used for name binding, .ow, and synchronisa\u00adtion preservation. Utilising this framework, the \nimplementa\u00adtion of a given refactoring can closely follow its pseudocode speci.cation and is generally \nnot much longer. As an example, we show our implementation of PRO-MOTE TEMP TO FIELD in Fig. 5. The implementation, \njust like the JastAddJ compiler it is based on, is written in Jast-Add [EH07b], an attribute grammar \nsystem that extends Java with support for circular reference attribute grammars. The refactoring is implemented \nas a method promoteToField on class VariableDeclaration us\u00ading an inter-type declaration. We also provide \na wrap\u00adper method doPromoteField, which simply calls method promoteToField and then eliminates language \nextensions from the resulting program. Extensions are implemented as visitors (LOCKED_NAMES and LOCKED_DATAFLOW) \nthat tra\u00adverse the syntax tree and rewrite it into plain Java. Method promoteToField follows the speci.cation \nin Alg. 1 quite closely, in particular the three subrefactorings are invoked as methods split, insertField, \nand remove. The construction of .eld f is somewhat more verbose than in the pseudocode, since we need \nto explicitly construct the syntax tree nodes that the declaration is composed of. Note in particular \nthat we use method createLockedAccess, which is part of the naming framework, to construct a locked access \nto the .eld s type. The only part of the implementation that does not im\u00admediately correspond to the \nspeci.cation is the call to flushCaches in the penultimate line. This is where the underlying JastAdd \nimplementation shines through: the in\u00adformation computed by attributes such as type or uses is automatically \ncached, and needs to be .ushed manually whenever the syntax tree has changed. In this example, the value \nof attribute uses has become stale, since we have changed all uses of the local variable being promoted \nto bind to the f. If we did not .ush the attribute s value, RE-MOVE DECL would conclude that references \nto the variable still exist and refrain from deleting it. Altogether, eight lines of pseudocode speci.cation \ntrans\u00adlate into about 20 lines of implementation, which is a rea\u00adsonable ratio given the verbosity of \nJava syntax. 4. PUSH DOWN METHOD and MOVE MEMBER TYPE TO TOPLEVEL While PROMOTE TEMP TO FIELD is an important \ntool, it is a fairly simple and small-scale refactoring. In this section we show that the techniques \nused for its speci.cation in the pre\u00advious section carry over to more complicated refactorings by giving \nspeci.cations of PUSH DOWN METHOD and MOVE MEMBER TYPE TO TOPLEVEL. The next section will then provide \nfurther empirical consolidation by discussing, albeit not in as much detail, many other refactorings. \n 4.1 PUSH DOWN METHOD The PUSH DOWN METHOD refactoring pushes a method m from a class A to all its subclasses \nB1,...,Bn; it then either removes the de.nition of m from A or turns it into an abstract method. A simple \nexample is shown in Fig. 6, which demonstrates how we can view PUSH DOWN METHOD as being com\u00adposed of \nthree simpler operations: We .rst introduce trivial overriding methods into each of the subclasses which \njust invoke the overridden method through super calls, then we inline these calls, and .nally remove \nthe original method. Where it is impossible to remove the method outright, we can instead turn it into \nan abstract method. The beauty of this approach lies in devolving the per\u00adhaps most tricky part of the \nrefactoring, actually copying the code from the superclass to the subclass without changing its meaning, \nto the well-known INLINE METHOD refactor\u00ading. All that remains is to implement the .rst step, which is \nitself a refactoring we call TRIVIALLY OVERRIDE, and the third step, which is a choice between the two \nrefactor\u00adings REMOVE METHOD and MAKE METHOD ABSTRACT. Note, however, that the decomposition we have given \nhere only works for virtual methods (i.e. non-private instance methods). We will brie.y consider the \ncase of non-virtual methods below. We start with the speci.cation of TRIVIALLY OVERRIDE, given in Alg. \n5. It takes the method m to produce an override  class int int } A { f(int m() i){ { return return i+19; \n} f(23); } class int int } A { f(int m() i){ { return return i+19; } f(23); } class } B extends A { . \nclass int } B extends f(int i){ A { return super.f(i); } . class } C extends A { class int } C extends \nf(int i){ A { return super.f(i); } class int int } A { f(int m() i){ { return return i+19; } f(23); } \nabstract class A { abstract int f(int i); int m() { return f(23); } } class int } B extends f(int i){ \nA { return i+19; } . class int } B extends f(int i){ A { return i+19; } class int } C extends A { f(int \ni) { return i+19; } class int } C extends f(int i){ A { return i+19; } Figure 6. Applying PUSH DOWN \nVIRTUAL METHOD to push f from A to B and C for and the type B in which to insert the overriding method, \nand returns the node corresponding to the created super call. As we shall see, such a call is not created \nin all cases, so the refactoring has return type option MethodCall and returns either None (if no call \nwas created), or Some c, where c is the created call. Algorithm 5 TRIVIALLY OVERRIDE(B : Type,m : VirtualMethod): \noption MethodCall Input Language: Java \\ implicit method modi.ers Output Language: Java + locked names, \nreturn void 1: assert m is not final 2: if m not a member method of B then 3: return None ' 4: m . copy \nof m with locked names 5: if m is abstract then ' 6: insert method m into B 7: return None 8: else ' \n9: xs . list of locked accesses to parameters of m 10: c . super.m(xs) ' 11: set body of m to return \nc; ' 12: insert method m into B 13: return Some c The refactoring .rst checks for several special cases. \nOb\u00adviously, we cannot override a .nal method, so this case is excluded right away. If m is not a member \nmethod of B (for example be\u00adcause B already contains an overriding de.nition of m), the refactoring does \nnot need to do anything and simply returns None. If m is abstract we cannot introduce a super call to \nit, either. Instead, the refactoring creates a copy m ' of m, where ' all names within m are locked to \nensure they keep their original bindings, and inserts it into B. As before, None is returned. It remains \nto handle the case where a super call is ac\u00adtually created. We construct a list xs with locked accesses \nto the parameters of m ', which becomes the argument list ' for the super call c. Finally, the body of \nm is replaced by ' a single statement returning c, and m is inserted as a body declaration into B. Like \nmany of its brethren, TRIVIALLY OVERRIDE pro\u00adduces programs with locked names. It also makes use of a \nfurther language extension: Recall from Fig. 6 that the refac\u00ad toring constructs a method of the form \n int f(int i) { return super.f(i); } Obviously, this is only well-formed if the overridden method returns \na value. If it had return type void, we would have to omit the return. This situation arises frequently \nenough to be a bit of a nuisance, so we introduce a language extension: The refactoring will on occasion \nproduce state\u00adments of the form return e; where e is of type void. Such statements can simply be translated \ninto e; return; (note that all expressions of type void are statement expres\u00adsions, and hence can can \nform statements on their own).  As a .nal .nesse, TRIVIALLY OVERRIDE assumes that all method modi.ers \nin its input (or at least on method m) are explicit. For example, if B were a class and A an interface, \nthen m would be public and abstract whether or not it carries the corresponding modi.ers, but the modi.ers \nhave to be made explicit in B. Our life becomes much easier if we assume instead that the modi.ers are \nalways explicit. Let us brie.y pause to convince ourselves that this mi\u00adcrorefactoring indeed preserves \nprogram semantics, in par\u00adticular that the semantics of method calls does not change. Consider an invocation \nof a virtual method n on an object of dynamic type T in the original program. If T is not a de\u00adscendant \nof A or n does not have the same signature as m, the call will be dispatched to the same method in the \nnew program as in the original program. Otherwise, if the orig\u00adinal call dispatched to m, the new call \nwill either dispatch to m as well, or to the newly inserted method m ', which immediately invokes m. \nIn either case, the semantics stays unchanged. The next step of the PUSH DOWN METHOD refactoring is to \ninline the super call if one was created. This will copy the body of m into the subclass, ensuring in \nparticular that names in m will not inadvertently change their binding. Since INLINE METHOD has already \nbeen discussed in the context of our framework [SVEdM09], we will not give its precise speci.cation here. \nThe .nal step is to remove m from A if possible, or else to make it abstract. The two factors to consider \nhere are whether m is referenced outside its own body, i.e. whether there is any method call in the program \n(outside m itself) that statically resolves to m, and whether m could be dy\u00adnamically called from any \ncall site in the program (again, outside its own body). If neither is the case, the method can safely \nbe removed. If only the former is the case, it cannot be removed altogether, but can be made abstract. \nIn all other cases, the method must stay. While it is straightforward to determine the set uses(m) of \nall calls that statically resolve to m, determining the calls that might at runtime resolve to m is quite \nanother matter. The coarser this analysis the oftener the refactoring will refuse to remove a pushed-down \nmethod, making it abstract instead. The speci.cation of the refactoring, however, is independent of the \ndetails of this analysis; we simply require that its results are available as calls(m).5 5 Our implementation \nof calls assumes that a virtual method call may resolve either to its static target or to any method \nthat (transitively) overrides it. Algorithm 6 REMOVE METHOD(m : Method ) Input Language: Java Output \nLanguage: Java 1: assert (uses(m) . calls(m)) \\ below(m)= \u00d8 ' 2: o .{m | m<: m ' } '' 3: if o= \u00d8..m . \no.m is abstract then 4: for all types B that inherit m do 5: MAKE TYPE ABSTRACT(B) 6: remove m It is \nnow quite easy to write out a speci.cation for RE-MOVE METHOD (Alg. 6): The refactoring fails if there \nare any calls to m that do not originate in the set below(m) of nodes inside the de.nition of m itself. \nOtherwise, it consid\u00ad ' ers the set o of all methods m that m overrides (which we write as m<: m '). \nIf there is at least one such method, and furthermore they are all abstract6, the host type of m (and \nany other type that inherits m without overriding it) will now inherit an abstract method and hence has \nto be made abstract itself. When making a method m abstract (Alg. 7), we check that it cannot actually \nbe called, and then make every type abstract that inherits m before putting an abstract mod\u00adi.er onto \nit. Of course, a type can only be made abstract (Alg. 8) if it is either an interface (and hence already \nab\u00ad stract), or it is a class that is not instantiated anywhere. Algorithm 7 MAKE METHOD ABSTRACT(m : \nMethod ) Input Language: Java Output Language: Java 1: assert calls(m) \\ below(m)= \u00d8 2: for all types \nB that inherit m do 3: MAKE TYPE ABSTRACT(B) 4: make m abstract Algorithm 8 MAKE TYPE ABSTRACT(T : Type) \nInput Language: Java Output Language: Java 1: if T is not an interface then 2: assert T is class and \nnever instantiated 3: make T abstract The speci.cation of PUSH DOWN VIRTUAL METHOD, shown as Alg. 9, \nis now simply a matter of plugging together the previously speci.ed microrefactorings. We use the oper\u00adator \nor to indicate an alternative of several refactorings to try from left to right until the .rst one succeeds. \nID, of course, is the identity refactoring that does nothing and never fails. 6 Remember that there could \nbe several such mI, e.g. one from the super\u00adclass and the others from implemented interfaces.  Algorithm \n9 PUSH DOWN VIRTUAL METHOD(m : VirtualMethod) Input Language: Java Output Language: Java . locked names \n1: for all types B<: hostType(m) do 2: c . lTRIVIALLY OVERRIDEJ(B, m) 3: if c = None then 4: INLINE METHOD(c) \n 5: REMOVE METHOD(m) 6: or MAKE METHOD ABSTRACT(m) 7: or ID() Note that INLINE METHOD is invoked without \n.oor brackets, so any locked names introduced by it are not un\u00adlocked immediately, which can be helpful \nif they refer to methods that are hidden by m. Let us now brie.y consider the case of non-virtual meth\u00adods. \nThere is probably not much sense in pushing down a private method, since it can only be referenced by \nmem\u00adbers of the same class, and these references will be broken if the method is pushed into a child \nclass. Static methods can be handled in almost the same way as virtual methods, ex\u00adcept that instead \nof introducing an overriding method with a super call we introduce a hiding method that directly in\u00advokes \nthe hidden method on the super class. The rest of the refactoring need not change. One feature that this \nspeci.cation does not provide for is to push several inter-dependent methods at the same time, or indeed \nto determine which other methods have to be pushed together with the selected method. We leave this extension \nto future work.  4.2 MOVE MEMBER TYPE TO TOPLEVEL We now turn to a type-level refactoring, MOVE MEMBER \nTYPE TO TOPLEVEL, which converts a member type that is nested within one or more other types to a toplevel \ntype. This refactoring, which incidentally must be performed by a Java compiler as part of the translation \nto bytecode, makes for an interesting example in our framework since it reuses a language extension that \nwas originally introduced for a different refactoring: As explained in [SdM09], the MOVE METHOD and MAKE \nMETHOD STATIC refactorings can be implemented rather easily by going through an en\u00adriched language featuring \na JavaScript-like with construct. In a nutshell, the compound statement with(en, ..., e0) s should be \nunderstood to mean that statement s is executed with the value of e0 as its zeroth enclosing instance \n(i.e., the value of this), e1 as the .rst enclosing instance, and so on. No enclosing instances beyond \nen are available. Moving a static member type to the toplevel is easy, since it cannot access any non-static \ndata of its enclosing types. So all we need to do is to ensure that names still bind to their intended \ndeclaration. This is the gist of the speci.cation in Alg. 10. Algorithm 10 MOVE MEMBER TYPE TO TOPLEVEL(M \n: MemberType) Input Language: Java Output Language: Java . locked names 1: if M is not static then 2: \nlMAKE TYPE STATICJ(M) 3: p . hostPkg(M) 4: lock all names in M 5: remove M from its host type 6: INSERT \nTYPE(p, M) We use an ancillary refactoring INSERT TYPE (Alg. 11) to actually insert type M into its target \npackage p, which is very similar to INSERT FIELD: We need to check that p does not already contain a \ntype or subpackage of the same name. Then we globally lock all accesses to types of the same name to \nensure that they will not become shadowed. We remove modi.ers that are inapplicable for toplevel types \nfrom T , and .nally insert it into the syntax tree. Algorithm 11 INSERT TYPE(p : Package,T : ClassOrInterface) \nInput Language: Java Output Language: Java . locked names 1: assert no type or subpackage of same name \nas T in p 2: lockNames(name(T )) 3: remove modi.ers static, private, protected from T 4: insert T into \np Things are more complicated for non-static member types, since they can access enclosing instances. \nWe use an\u00adother refactoring MAKE TYPE STATIC to make the member type static .rst. Applied to a type M, \nthis refactoring adds to M one .eld for each enclosing instance, say this$i for the ith enclosing instance, \nand surrounds the body of every constructor and method in B by with(this$n, ..., this$1, this) {... } \nThe .elds corresponding to the enclosing instances, of course, have to be properly initialised, which \naccounts for most of the complexity of the speci.cation in Alg. 12. This initialisation has to happen \nin M s constructors, which there\u00adfore need to be equipped with additional parameters to pass in the enclosing \ninstances, which again means that all calls to the constructors have to be updated to provide corresponding \narguments.  Algorithm 12 MAKE TYPE STATIC(M : MemberType) Input Language: Java Output Language: Java \n. with, locked names 1: [An; ... ; A1] . enclosing types of M 2: for all i .{1,...,n} do 3: f . new .eld \nof type Ai with name this$i 4: INSERT FIELD(M, f) 5: for all constructors c of M do 6: p . parameter \nof type Ai with name this$i 7: assert no parameter or variable this$i in c 8: insert p as .rst parameter \nof c 9: if c is chaining then 10: add this$i as .rst argument of chaining call 11: else 12: a . new assignment \nof p to f 13: insert a after super constructor call 14: for all constructors c of M do 15: for all non-chaining \ninvocations u of c do 16: es . enclosing instances of u 17: assert |es| = n 18: insert es as initial \narguments to u 19: discard quali.er of u, if any 20: put modi.er static on M 21: for all callables m \nof M do 22: if m has a body then 23: surround body of m by with(this$n, ..., this$1, this) {...} Let \nus go through the speci.cation step by step. We .rst have to introduce .elds for the enclosing instances. \nLet A1,...,An be the enclosing types of M; we consider each Ai in turn. First we create a .eld f to hold \nthe enclosing instance, which has type Ai and name this$i, and insert it into M using the INSERT FIELD \nrefactoring. We then cre\u00adate a corresponding parameter p for every constructor c of M. This parameter \nhas the same type and name as f, and is added to the constructor s parameter list; the refactoring will \nfail if c has a parameter or local variable with name this$i. We now need to make sure that every constructor \nini\u00adtialises f to the value of its parameter p. This happens in one of two ways, depending on what kind \nof constructor c is. If c is a chaining constructor that invokes another constructor of the same class \nby means of a this(...) constructor invo\u00adcation, we add p to the argument list of that call, and rely \non the invoked constructor to initialise the .eld. Otherwise we insert an assignment from p to f into \nthe body of c. Now we have added the required instance .elds to M and set up its constructors to initialise \nthem, but of course we need to adjust all invocations of constructors of M to actually provide values \nfor the extra parameters. So we again consider every constructor c of M and its every invocation u in \nturn. Since we have already treated this(...) calls in the previous step, we do not have to consider \nthem again. For any other invocation, we obtain the list es of expres\u00adsions that provide values for the \nenclosing instances of M and add them as arguments to the call. If the invocation was quali.ed, then \nthat quali.er was the single enclosing instance of the invocation which we have already added to the \nargument list and can hence discard. Finally, we wrap the bodies of all constructors and meth\u00adods of \nM (collectively referred to as callables) in with blocks, and give M a static modi.er. Notice that we \ndid not wrap .eld initialisers (or indeed instance initialisers) of M into with blocks. Hence, if an \ninitialiser contains a reference to a .eld f of an enclosing class Ai, that reference will simply be \nlocked, but unless f is static it cannot be successfully unlocked after M is moved to the toplevel, so \nthe refactoring will fail. Eclipse and IntelliJ both treat variable uses in .eld ini\u00adtialisers the same \nas variable uses in methods, so in the ex\u00adample the reference will be quali.ed with the .eld holding \nthe ith enclosing instance. This, however, is wrong: initialis\u00aders are evaluated before constructor bodies, \nso the .eld is not initialised yet and a null pointer exception will result at runtime. Java compilers \navoid this problem by inlining .eld ini\u00adtialisers into constructor bodies .rst, but this seems an overly \ndrastic transformation for a refactoring engine to attempt. Likewise, our speci.cation does not make \nany special ar\u00adrangements for accessing private members of enclosing classes; unlocking references to \nsuch members will fail, thus aborting the whole refactoring. Eclipse tackles this issue by increasing \nthe visibility of the referenced members, but, as shown by Steimann et al. [ST09], adjusting accessibility \nis quite a tricky problem in itself. A better solution might be to introduce getter and setter methods \nas is usually done by Java compilers. 5. Towards a Full-Featured Refactoring Engine In order to show \nthat the techniques introduced so far pro\u00advide a suf.cient basis for implementing a refactoring engine, \nwe set ourselves the goal of implementing all the refactor\u00adings offered by Eclipse 3.5 and validating \nthem against their publicly available test suite. We decided to exclude the type-based refactorings EX-TRACT \nINTERFACE, EXTRACT SUPERCLASS, GENERAL-IZE DECLARED TYPE, USE SUPERTYPE WHERE POSSI-BLE, and INFER GENERIC \nTYPE ARGUMENTS, as these have been thoroughly explored in the literature [Tip07]. Also excluded from \nconsideration was CHANGE METHOD SIGNATURE, since its implementations in Eclipse performs very few semantic \nchecks. Various aspects of this refactor\u00ading, such as adding, removing, or permuting parameters can be \nimplemented in a safe way using our framework, but in its full generality CHANGE METHOD SIGNATURE is \nper\u00ad  Refactoring total # of tests inap\u00adplicable missing feature we reject Eclipse rejects same result \nlines of code Eclipse we CONVERT ANONYMOUS TO NESTED 45 4 1 0 1 39 997 220 EXTRACT CLASS 24 2 1 1 1 19 \n760 243 EXTRACT CONSTANT 60 13 9 10 0 28 683 42 EXTRACT TEMP 133 1 28 5 1 98 854 107 INLINE CONSTANT \n38 11 0 8 0 19 827 44 INLINE TEMP 55 12 5 2 1 35 381 82 INTRODUCE FACTORY 49 3 1 0 0 45 799 81 INTRODUCE \nINDIRECTION 31 0 1 5 0 25 933 61 INTRODUCE PARAMETER 20 1 1 5 0 13 448 26 INTRODUCE PARAMETER OBJECT \n19 0 6 0 0 13 628 61 MOVE INNER TO TOPLEVEL 94 15 0 10 1 68 1427 125 MOVE INSTANCE METHOD 54 4 0 14 4 \n32 2038 99 MOVE MEMBERS 90 5 8 20 5 52 945 120 PROMOTE TEMP TO FIELD 55 19 14 0 0 22 829 62 PULL UP 143 \n36 5 0 1 101 1694 208 PUSH DOWN 95 27 10 4 1 53 872 374 SELF-ENCAPSULATE FIELD 36 0 3 0 0 33 751 85 \nTable 1. Evaluation of the correctness of our refactoring engine on Eclipse s test suite haps best described \nas a general code transformation, not as a behaviour preserving refactoring. Table 1 summarises the performance \nof our refactoring engine when applied to the internal test suite of Eclipse s refactoring engine, as \navailable from the Eclipse source dis\u00adtribution. We exclude test cases for the various RENAME refactorings, \nresults of which are reported in [SEdM08], and for EXTRACT METHOD and INLINE METHOD, which have been \ntreated in [SVEdM09]. For the remaining 17 refactorings7 the table shows the total number of test cases \nin the .rst column, and the number of test cases where our engine produced the same results as Eclipse, \nmodulo trivial differences, in the sixth column. The other columns categorise sources of disagreement. \nThe second column lists the number of test cases that we could not test our engine on, either because \nthey were dis\u00adabled or because they were not valid Java programs. Since our refactoring engine is implemented \nas an extension to the JastAddJ compiler frontend, we can only process programs that successfully pass \nsyntactic and semantic checks. We in\u00adclude in this category test cases whose expected result is ar\u00adguably \nwrong, as well as tests that pertain to non-functional aspects of the Eclipse refactoring engine. The \nthird column shows the number of test cases where our implementation produces output programs that are \ncor\u00adrect and behave the same as the input program, but where we do not perform all the refactoring steps \nthat Eclipse does. Many of the failures here relate to clone detection: for 7 Space restrictions prevent \nus from presenting detailed speci.cations of these refactorings; they are, however, available as part \nof the distribution of our refactoring engine. example, the EXTRACT CONSTANT and EXTRACT TEMP refactorings \nin Eclipse extract all copies of the selected ex\u00adpression, whereas our engine only extracts the selected \none. While an ad hoc extension of our engine could presumably refactor most or all of these test cases, \nwe leave the imple\u00admentation of a principled clone detector and its integration with the refactoring \nprocess to future work. Further, columns four and .ve summarise the test cases where one engine produced \nresults while the other rejected the refactoring. The latter gives the number of test cases where Eclipse \nrejects a refactoring which our engine is able to perform. Conversely, the former tallies the number \nof spurious rejections by our engine. For the refactorings INLINE CONSTANT and INTRODUCE PARAMETER, these \nrejections are generally due to the quite conservative data.ow analysis of our implementation. In some \ncases a more precise analysis would be able to prove that the refactoring can go ahead. Another possible \nsolution would be to push this kind of issue into the UI, reporting failures of .ow preservation to the \nuser as warnings instead of aborting the refactoring outright. In any case, Eclipse s current hands-off \napproach in which almost no analysis is performed seems quite unsatisfactory. Another major source of \nrejection, affecting INTRODUCE INDIRECTION, MOVE INNER TO TOPLEVEL and MOVE INSTANCE METHOD, is visibility \nadjustment. When mov\u00ading members between types, it is sometimes necessary to increase the visibility \nof referenced members for them to remain accessible after the refactoring. Eclipse has some heuristics \nfor doing this, but as shown by Steimann and Thies [ST09] these heuristics are rather crude and can easily \nlead to subtle changes in behaviour.  Our refactoring engine does not attempt to solve this problem. \nThe locked naming framework does, however, check that names only bind to accessible declarations, and \naborts the refactoring if this is not the case. Hence our im\u00adplementation never produces output programs \nthat violate accessibility rules, although it may on occasion reject refac\u00adtorings that could be performed \nif the visibility were ad\u00adjusted. To improve on this, we plan to integrate Steimann and Thies system \nof accessibility constraints with our name unlocking mechanism. In summary, while there is certainly \na lot of disagreement in detail between our refactoring engine and Eclipse, we think that the results \nshow that our techniques are powerful enough to be applied to the implementation of just about any refactoring \nand can produce high-quality implementations with comparatively little effort. This is brought into sharp \nrelief if we compare the source code size of the two implementations, given in the last two columns.8. \nFor Eclipse, we measured the size of the *Refactoring.java or *Processor.java .les, respec\u00adtively, for \neach refactoring. These .les only form the core of the implementation, and contain neither shared utility \ncode nor user-interface related functionality. For our implemen\u00adtation, we give the size of the refactoring \nimplementation including all microrefactorings, but again excluding utility code. As can be seen, our \nimplementations are always more compact, in some cases dramatically so. This is partly due to JastAdd \ns aspect-oriented features that enable us to much more cleanly separate the essence of the refactoring \nimple\u00admentation from supporting code. Adding up the line counts in the last column, one would obtain \na size of about 2100 lines of code for the core of our implementation. This would, however, count reused \nmi\u00adcrorefactorings once for every refactoring that uses them. The actual amount of code, counting every \nrefactoring only once, is only slightly more than 1300 lines, which attests to the reusability of the \nmicrorefactorings. This tally does not include the naming framework, at about 1400 lines of code, as \nwell as the .ow dependency framework, at about 300 lines, both of which have already been discussed in \nprevious papers. A further 800 lines pro\u00advide functionality for introducing and removing the lan\u00adguage \nrestrictions and extensions used by the refactorings. Pleasingly, no further major language extensions \nbesides with and anonymous methods are needed for the above refactorings. The .ve other extensions provided \nare all very simple ones, like the .rst-class array initialisers mentioned in the introduction. As for \nlanguage restrictions, we have mentioned restrictions on compound variable declarations, the synchronized \nmodi.er and implicit method modi.ers. Two other restrictions of a similar kind are used by other refactorings \nand are likewise quite easy to realise. 8 This data was generated using David A. Wheeler s SLOCCount \n. In total, the complete source code of our refactoring en\u00adgine, including all of the above as well as \nsupporting and utility code (but excluding the JastAddJ frontend and its con\u00adtrol .ow analysis package, \nwhich are independent projects) amounts to about 6250 lines of code. This is just a little more than \nthe combined size of the core implementations of the four largest refactorings of Table 1 in Eclipse. \nWe do, however, want to point out two major weaknesses of our refactoring engine in comparison with Eclipse: \nIt is currently not integrated into an IDE, and hence not usable for developers, and it is somewhat lacking \nin performance. Refactorings on even very small programs can take up to .ve seconds, which is perhaps \nacceptable for a prototype imple\u00admentation but excludes the possibility of using our engine in a production \nenvironment. This is partly due to the general approach of decomposing refactorings into smaller units, \nbut a more important factor is the choice of implementation lan\u00adguage. While attribute grammar systems \nlike JastAdd excel at tasks involving the computation of information on im\u00admutable trees, as is typical \nin compiler frontends, updates to the syntax tree, as they are performed by refactorings, necessitate \nfrequent .ushing and recomputation of cached information. While in some cases it is possible to pinpoint \nprecisely which attributes need to be invalidated, this is a Sisyphean task in general and can lead to \nextremely subtle bugs. Hence our implementation elects to always .ush all at\u00adtributes whenever the syntax \ntree has changed, which incurs a heavy performance penalty. A principled solution to this problem requires \nsigni.cant engineering, which we leave to future work. 6. Related Work This work is inspired by a long \nline of work on the speci.ca\u00adtion and implementation of refactorings. The classical work in this area \nis surely Opdyke s thesis [Opd92], which pro\u00ad vides a catalogue of refactorings for C++. While the actual \ntransformations are described only informally, the precondi\u00adtions that ensure behaviour preservation \nare spelled out in more detail, although only for a restricted subset of the ob\u00adject language. It is \nnot clear how easy the given conditions would be to implement. Another important source of inspiration \nis Griswold s thesis [Gri91]. In contrast to Opdyke, he does not present his refactorings primarily in \nterms of preconditions, but rather views them in terms of their effects on the program de\u00adpendence graph \n(PDG), presenting them as the composi\u00adtion of meaning-preserving PDG transformations. This is, of course, \nvery close to our approach emphasising depen\u00addency preservation and the decomposition of larger refac\u00adtorings \ninto smaller microrefactorings. The object language for which Griswold describes his refactorings is \na .rst-order subset of Scheme. The choice of such a simple language with such a simple and regular syntax \ngreatly simpli.es the pre\u00adsentation of his refactorings.  The composition of smaller refactorings into \nlarger ones is also the focus of work by Kniesel and Koch [KK04]. Their work is concerned with composing \nthe pre-and post\u00adconditions of constituent refactorings, which does not di\u00adrectly apply to our dependency \nbased presentation. There has been some interest in providing executable speci.cations of refactorings. \nFor instance, L\u00e4mmel [L\u00e4m02] shows how refactorings can be implemented very concisely by means of rewriting \nstrategies, with the syntax tree rep\u00adresented as a generic data type that abstracts away from peculiarities \nof the object language. It is, however, unclear if these techniques are usable beyond the very simple \nrefactor\u00adings and simple object languages discussed in the paper. Rewriting is also the technique used \nby Garrido and Meseguer [GM06], who give executable speci.cations of several Java refactorings in the \nrewrite logic-based system Maude. Again, however, the refactorings covered are of a very simple and local \nnature. The JunGL language proposed by Verbaere [Ver08] is speci.cally aimed at making it easy to implement \nrefactor\u00adings. The language s unique combination of functional and logic programming features, in particular \nthe concept of path queries, are well-suited for specifying the kind of static se\u00admantic analyses needed \nfor refactorings. Many refactorings can be described elegantly in JunGL [VEdM06], and even complex type-based \nrefactorings are within reach of the lan\u00adguage [Pay06]. Recently, a series of papers by Tip and others \n[TKB03, BTF05, Tip07, KETF07] have examined a number of type\u00ad based refactorings such as EXTRACT INTERFACE \nand IN-FER GENERIC TYPE ARGUMENTS. They make pervasive use of type constraints to ensure behaviour preservation, \nbut while the constraint rules are given in great detail, the actual refactorings are only described \ninformally. The implemen\u00adtation of type-based refactorings in Eclipse is based on this work. Steimann \nand Thies [ST09] introduce accessibility con\u00ad straints that can be used to systematically adjust the \nvisibil\u00adity of program elements that are no longer accessible due to code movement. Again, the constraint \nrules are presented formally, whereas the refactorings are only given prose de\u00adscriptions. Both lines \nof work use similar concepts of constraints that can be seen as a natural extension of our dependency \nedges, which are just single constraints to be solved in iso\u00adlation. Layering a more advanced constraint \nsolving mech\u00adanism that can take accessibility and type constraints into account on top of this existing \nframework is an intriguing perspective. Kegel and Steimann [KS08] give a very thorough precon\u00ad dition-based \ndescription of the REPLACE INHERITANCE WITH DELEGATION refactoring that tries to account for all features \nof the Java language. Being given in prose only, the description is somewhat verbose and hard to grasp. \nDe\u00adspite all their efforts, the authors report that whenever we believed that we had made correctness \nof the refactoring plausible, testing it on a new project revealed a new problem we had not previously \nthought of , and refrain from arguing for the correctness of their speci.cation. The only work that we \nare aware of which actually presents pseudocode speci.cations of refactorings for Java is the recent \npaper by Wloka et al. on refactoring programs for reentrancy [WST09], which describes a transformation \nfor wrapping static state into ThreadLocal .elds. Their speci.cations concentrate on issues relevant \nto the proposed refactoring, and ignore possible problems arising, e.g., from naming con.icts. Recent \nwork by Soetens [Soe09] takes the other direction: instead of giving a speci.cation and then using it \nas the basis for an implementation, he takes the implementations of PULL UP METHOD, ENCAPSULATE FIELD \nand EXTRACT CLASS in Eclipse, and reverse-engineers their speci.cation, in particular their preconditions. \nThe problem of how to ef.ciently compute attribute val\u00adues without introducing stale values is a mainstay \nof the at\u00adtribute grammar literature, and there is a large amount of work on incremental evaluation of \nattributes that handles this issue transparently. The classic work of Demers, Reps, and Teitelbaum [DRT81] \nshows how to solve this problem for traditional attribute grammars without reference attributes or circular \nattributes by computing dependencies and prop\u00adagating changes along them. Work by Pennings and oth\u00aders \n[PSV92, SSK00] concentrates on caching attribute val\u00ad ues, but again for traditional attribute grammars \nwithout ref\u00aderence attributes. The doctoral thesis of Maddox [Mad97] presents an in\u00ad cremental attribute \ngrammar system with some more ad\u00advanced features, although the eclectic nature of the system makes it \nhard to judge how much of the results would ap\u00adply to JastAdd. More recently, Boyland has proposed an \nin\u00adcremental evaluation mechanism for remote attribute gram\u00admars [Boy02], which are somewhat similar \nto reference at\u00ad tribute grammars. These two papers might make a good starting point for exploring the \nincremental evaluation of JastAdd attribute grammars, although the power of the sys\u00adtem (which allows \narbitrary Java code in attribute equations) makes it unrealistic to expect that a fully automated ap\u00adproach \nwould work well in practice. On the other end of the spectrum, Acar and others have recently published \na series of papers on self-adjusting com\u00adputation [AAB08], which generalises the problem of incre\u00ad mental \nevaluation to a much broader class of programs, in\u00adcluding stateful computations. It seems, however, \nthat their approach incurs a certain performance penalty as well, and it is unclear whether it would \nscale to a system the size of JastAddJ, on which our refactoring engine is based.  7. Conclusions We \nhave presented a case study showing the feasibility of a new approach to the implementation of refactorings, \nwhich is based on the concepts of dependency preservation, lan\u00adguage extensions, and microrefactorings. \nWe have shown that this approach allows us to give clean, modular speci.cations of important refactorings \nthat are pre\u00adcise enough to serve as the basis of a reimplementation of the majority of refactorings \noffered in recent versions of Eclipse. We have tested our implementation on Eclipse s own exten\u00adsive \ntest suite, and presented the results showing that our implementation is on par with industrial-strength \nrefactor\u00ading engines with regard to features, and often surpasses them with regard to correctness. These \nresults notwithstanding, our present work does not claim to give completely bug-free speci.cations that \naccount for all corner cases. While this is our ultimate goal which we believe to have made good progress \ntowards achieving, some cases may very well not be covered by the current speci.cations. But one of the \nadvantages of modular speci.cations of refactorings is exactly this: a refactoring can be understood \npart by part, and we can reason about its correctness in a modular way. If a bug is found, we do not \nneed to content ourselves with a half-baked .x in one particular implemen\u00adtation that may exploit some \nidiosyncrasies of the system to provide an ill-.tting bandaid. Instead we can amend the high-level speci.cation \nof the refactoring, so that every im\u00adplementation based on it can reap the bene.ts. A. De.nitions  A.1 \nPseudocode Conventions We give our speci.cations in generic, imperative pseu\u00addocode. Parameters and return \nvalues are informally typed, with syntax tree nodes having one of the types from Fig. 7. Additionally, \nwe use an ML-like option type with con\u00adstructors None and Some for functions that may or may not return \na value. Where convenient, we make use of ML-like lists, with list literals of the form [1; 2; 3] and \n|xs| indicating the length of list xs. The names of refactorings are written in SMALL CAPS, whereas utility \nfunctions appear in monospace. A list of utility functions with brief descriptions is given in Fig. 8. \nAn invocation of a refactoring is written with .oor-brackets lLIKE THISJ() to indicate that any language \nextensions used in the output program produced by the refactoring should be eliminated before proceeding. \nWe write A<: B to mean that type A extends or imple\u00ad ' ments type B, and m<: m to mean that method m \nover\u00ad ' rides method m . Node Type Description ClassOrInterface either a class or an interface; is a \nType Field .eld declaration LocalVar local variable declaration MemberType type declared inside another \ntype; is a Type Method method declaration MethodCall method call Package package Type type declaration \nVirtualMethod non-private instance method; is a Method Figure 7. Node Types Name Description below(n) \nreturns the set of all nodes below n in the syntax tree calls(m) returns all calls that may dynamically \nresolve to method m; can be a conser\u00ad vative over-approximation hostPkg(e) returns the package of the \ncompilation unit containing e hostType(e) returns the closest enclosing type dec\u00ad laration around e lockNames(n) \nlocks all names anywhere in the pro\u00ad gram that refer to a declaration with name n name(e) returns the \nname of program entity e uses(m) returns all calls that statically bind to method m Figure 8. Utility \nFunctions References [AAB08] Umut A. Acar, Amal Ahmed, and Matthias Blume. Imperative Self-Adjusting \nComputation. In POPL, pages 309 322, 2008. [Boy02] John Boyland. Incremental Evaluators for Remote Attribute \nGrammars. Electr. Notes Theor. Comput. Sci., 65(3), 2002. [BTF05] Ittai Balaban, Frank Tip, and Robert \nFuhrer. Refactoring support for class library migration. In OOPSLA, pages 265 279, 2005. [DRT81] A. Demers, \nT. Reps, and T. Teitelbaum. Incremental Evaluation for Attribute Grammars with Applica\u00adtions to Syntax-directed \nEditors. In Proceedings of the ACM Symposium on Principles of Programming Languages, pages 105 116. ACM \nPress, 1981. [EH07a] Torbj\u00f6rn Ekman and G\u00f6rel Hedin. The JastAdd Extensible Java Compiler. In OOPSLA, \n2007.  [EH07b] Torbj\u00f6rn Ekman and G\u00f6rel Hedin. The JastAdd system -modular extensible compiler construction. \nSci. Comput. Program., 69(1-3):14 26, 2007. [Fou10] Eclipse Foundation. Eclipse 3.5. http://www.eclipse.org, \n2010. [Fow00] Martin Fowler. Refactoring: improving the design of existing code. Addison Wesley, 2000. \n[GM06] Alejandra Garrido and Jos\u00e9 Meseguer. Formal Speci.cation and Veri.cation of Java Refactorings. \nIn SCAM, 2006. [Gri91] William G. Griswold. Program Restructuring as an Aid to Software Maintenance. \nPh.D. thesis, University of Washington, 1991. [Jet10] JetBrains. IntelliJ IDEA 9.0.1. http://www.jetbrains.com, \n2010. [Ker05] Joshua Kerievsky. Refactoring to Patterns. Addison Wesley, 2005. [KETF07] Adam Kiezun, \nMichael D. Ernst, Frank Tip, and Robert M. Fuhrer. Refactoring for Parameterizing Java Classes. In ICSE, \npages 437 446, 2007. [KK04] G\u00fcnter Kniesel and Helge Koch. Static Compo\u00adsition of Refactorings. The Science \nof Computer Programming, 52(1-3):9 51, 2004. [KS08] Hannes Kegel and Friedrich Steimann. Systemati\u00adcally \nRefactoring Inheritance to Delegation in Java. In International Conference on Software Engineer\u00ading (ICSE), \npages 431 440. ACM Press, 2008. [L\u00e4m02] Ralf L\u00e4mmel. Towards Generic Refactoring. In Rule-based Programming \n(RULE), pages 15 28. ACM Press, 2002. [Mad97] William Harry Maddox. Incremental Static Seman\u00adtic Analysis. \nPh.D. thesis, University of California, Berkeley, 1997. [Opd92] William F. Opdyke. Refactoring Object-Oriented \nFrameworks. PhD thesis, University of Illinois at Urbana-Champaign, 1992. [Pay06] Arnaud Payement. Type-based \nRefactoring using JunGL. Master s thesis, Oxford University Comput\u00ading Laboratory, 2006. [PSV92] M. Pennings, \nD. Swierstra, and H. Vogt. Using cached functions and constructors for incremental attribute evaluation. \nIn PLILP, pages 130 144. Springer Verlag, 1992. [SdM09] Max Sch\u00e4fer and Oege de Moor. Of Gnats and Dragons \n Sources of Complexity in Implementing Refactorings. In WRT, 2009. [SDS+10] Max Sch\u00e4fer, Julian Dolby, \nManu Sridharan, Frank Tip, and Emina Torlak. Correct Refactoring of Concurrent Java Code. In Theo D Hondt, \neditor, ECOOP, 2010. [SEdM08] Max Sch\u00e4fer, Torbj\u00f6rn Ekman, and Oege de Moor. Sound and Extensible Renaming \nfor Java. In Gregor Kiczales, editor, OOPSLA. ACM Press, 2008. [SEEV10] Max Sch\u00e4fer, Torbj\u00f6rn Ekman, \nRan Ettinger, and Mathieu Verbaere. Refactoring bugs. http://progtools.comlab.ox.ac.uk/ projects/refactoring/bugreports, \n2010. [Soe09] Quinten David Soetens. Formalizing Refactorings Implemented in Eclipse. Master s thesis, \nUniversity of Antwerp, 2009. [SSK00] J. Saraiva, S. D. Swierstra, and M. F. Kuiper. Functional incremental \nattribute evaluation. In Compiler Construction, pages 279 294, 2000. [ST09] Friedrich Steimann and Andreas \nThies. From Public to Private to Absent: Refactoring Java Programs under Constrained Accessibility. In \nSophia Drossopoulou, editor, ECOOP, 2009. [SVEdM09] Max Sch\u00e4fer, Mathieu Verbaere, Torbj\u00f6rn Ekman, and \nOege de Moor. Stepping Stones over the Refactoring Rubicon Lightweight Language Extensions to Easily \nRealise Refactorings. In Sophia Drossopoulou, editor, ECOOP, 2009. [Tip07] Frank Tip. Refactoring Using \nType Constraints. In SAS, pages 1 17, 2007. [TKB03] Frank Tip, Adam Kiezun, and Dirk B\u00e4umer. Refac\u00adtoring \nfor Generalization using Type Constraints. In OOPSLA, pages 13 26, 2003. [VEdM06] Mathieu Verbaere, Ran \nEttinger, and Oege de Moor. JunGL: a Scripting Language for Refactoring. In Dieter Rombach and Mary Lou \nSoffa, editors, International Conference on Software Engineering (ICSE), pages 172 181. ACM Press, 2006. \n[Ver08] Mathieu Verbaere. A Language to Script Refactor\u00ading Transformations. D.Phil. thesis, Oxford Univer\u00adsity \nComputing Laboratory, 2008. [WST09] Jan Wloka, Manu Sridharan, and Frank Tip. Refactoring for Reentrancy. \nIn ESEC/SIGSOFT FSE, pages 173 182, 2009.   \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Modern IDEs for object-oriented languages like Java provide support for a basic set of simple automated refactorings whose behaviour is easy to describe intuitively. It is, however, surprisingly difficult to specify their behaviour in detail. In particular, the popular precondition-based approach tends to produce somewhat unwieldy descriptions if advanced features of the object language are taken into account. This has resulted in refactoring implementations that are complex, hard to understand, and even harder to maintain, yet these implementations themselves are the only precise \"specification\" of many refactorings. We have in past work advocated a different approach based on several complementary notions of dependencies that guide the implementation, and on the concept of microrefactorings that structure it. We show in this work that these concepts are powerful enough to provide high-level specifications of many of the refactorings implemented in Eclipse. These specifications are precise enough to serve as the basis of a clean-room reimplementation of these refactorings that is very compact, yet matches Eclipse's for features and outperforms it in terms of correctness.</p>", "authors": [{"name": "Max Schaefer", "author_profile_id": "81381592942", "affiliation": "Oxford University Computing Laboratory, Oxford, United Kingdom", "person_id": "P2354063", "email_address": "", "orcid_id": ""}, {"name": "Oege de Moor", "author_profile_id": "81100198102", "affiliation": "Oxford University Computing Laboratory, Oxford, United Kingdom", "person_id": "P2354064", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869485", "year": "2010", "article_id": "1869485", "conference": "OOPSLA", "title": "Specifying and implementing refactorings", "url": "http://dl.acm.org/citation.cfm?id=1869485"}