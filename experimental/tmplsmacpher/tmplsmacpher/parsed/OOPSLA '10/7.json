{"article_publication_date": "10-17-2010", "fulltext": "\n A Domain-Speci.c Approach to Architecturing Error Handling in Pervasive Computing Julien Mercadal* \nQuentin Enard*\u00a7 Charles Consel* Nicolas Loriant* *INRIA LaBRI ENSEIRB \u00a7Thales Bordeaux, France .rst-name.last-name@inria.fr \nAbstract The challenging nature of error handling constantly escalates as a growing number of environments \nconsists of networked devices and software components. In these environments, er\u00adrors cover a uniquely \nlarge spectrum of situations related to each layer ranging from hardware to distributed platforms, to \nsoftware components. Handling errors becomes a daunt\u00ading task for programmers, whose outcome is unpredictable. \nScaling up error handling requires to raise the level of ab\u00adstraction beyond the code level and the try-catch \nconstruct, approaching error handling at the software architecture level. We propose a novel approach \nthat relies on an Architec\u00adture Description Language (ADL), which is extended with error-handling declarations. \nTo further raise the level of ab\u00adstraction, our approach revolves around a domain-speci.c architectural \npattern commonly used in pervasive comput\u00ading. Error handling is decomposed into components dedi\u00adcated \nto platform-wide, error-recovery strategies. At the ap\u00adplication level, descriptions of functional components \nin\u00adclude declarations dedicated to error handling. We have implemented a compiler for an ADL extended \nwith error-handling declarations. It produces customized programming frameworks that drive and support \nthe pro\u00adgramming of error handling. Our approach has been vali\u00addated with a variety of applications for \nbuilding automation. Categories and Subject Descriptors D.2.11 [Software En\u00adgineering]: Software Architectures \nDomain-speci.c archi\u00adtectures General Terms Design, Languages Keywords Domain-Speci.c Languages, Architecture \nDe\u00adscription Languages, Exception, Pervasive Computing Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA/SPLASH 10, October 17 21, 2010, Reno/Tahoe, Nevada, USA. \nCopyright &#38;#169; 2010 ACM 978-1-4503-0203-6/10/10. . . $10.00 1. Introduction Pervasive computing \nsystems coordinate a wide range of entities (devices and software components), communicate using a variety \nof network protocols, rely on intricate dis\u00adtributed systems technologies, and invoke a host of complex \nAPIs. As a result, a pervasive computing system needs to ad\u00address a uniquely large spectrum of errors \npertaining to a va\u00adriety of levels including physical infrastructure (e.g., power loss), hardware (e.g., \ndevice malfunction), operating system (e.g., resource exhaustion), network (e.g., protocol timeout), \nmiddleware (e.g., remote invocation), and API (e.g., im\u00adproper inputs). Detecting and recovering from \nthese errors is critical to make a pervasive computing system reliable. To do so, a systematic and rigorous \napproach to handling errors is required. Much progress has been achieved in middleware to ab\u00adstract over \nunderlying technologies. However, even the ones dedicated to the pervasive computing domain (e.g., [29] \nand [28]), cannot abstract over errors: whether low level or high level, errors need to be propagated \nto trigger application-speci.c treatments. A systematic treatment of these errors comes at the price \nof polluting the entire appli\u00adcation code with error-handling computations. Typically, a try-catch block \nis introduced when invoking an operation (or a group of them) that may fail. The resulting code is bloated \nand entangled, as demonstrated by Lippert and Lopes [20]. Even when errors are systematically addressed, \nthe error\u00adhandling logic is often ad hoc and local, precluding system\u00adwide reasoning. Because of a lack \nof high-level program\u00adming support, writing error-handling logic is a daunting task, neglected by most \nprogrammers. This situation results in the implementation of crude error-handling strategies, defeating \nthe purpose of these errors (e.g., log and ignore an error, or signal a different error). An inherent \nfeature of the try-catch block is that it ad\u00addresses error-recovery concerns at two different levels: \nlo\u00adcally, by enabling execution to resume whenever possible, and globally, by taking action to preserve \nsystem-wide con\u00adsistency. In the former case, the exception is not propagated and, if a value is missing, \nit may be replaced by a default one. Hereafter, this kind of error handling is said to be ap\u00adplication \nlevel. Alternatively, the programmer may choose a system-level handling of an error where the erroneous \ncom\u00adputation is aborted and the control transferred to a system\u00adwide error-recovery handler. Such handler \nmay replace a faulty sensor by a backup one, for example. The con.ict be\u00adtween application-level and \nsystem-level handling of errors is exacerbated by the device-intensive nature of a pervasive computing \nsystem. Furthermore, real-size pervasive comput\u00ading systems require to cope with a host of potential \nerrors, making it critical to raise the level of abstraction beyond the try-catch block. Scaling up \nerror handling requires to raise the level of ab\u00adstraction beyond the code level and the try-catch construct, \napproaching error handling at the software architecture level. This level permits a software system to \nbe decomposed into components (e.g., [31]), paving the way for the architec\u00adturing of error handling \ntreatments. Addressing error han\u00addling at system-design time provides information to guide and support \nthe implementation process, and to generate run\u00adtime support. Our approach To architecture error handling, \nwe introduce an Architecture Description Language (ADL) that is extended with error\u00adhandling declarations. \nTo further raise the level of abstrac\u00adtion, our approach revolves around a domain-speci.c archi\u00adtectural \npattern, commonly used in pervasive computing. In doing so, we provide domain-speci.c declarative and \npro\u00adgramming support for error handling. In our approach, an error can be treated both at the application \nand system level, allowing it to be compensated locally and managed globally by platform-wide strategies. \nSpeci.cally, our extended ADL allows to decompose a pervasive computing system into functional components \nand error-handling components. Declaring a functional compo\u00adnent includes specifying what errors are \nhandled at the ap\u00adplication level, and how they are handled. These declara\u00adtions make the .ow of errors \nexplicit in an architecture de\u00adscription, enabling high-level reasoning. Error-extended ar\u00adchitecture \ndescriptions are used to generate customized pro\u00adgramming frameworks. These frameworks guide and sup\u00adport \nthe implementation of a component logic, as well as its application-level handling of errors. For example, \na software architecture may require a component to fully handle device\u00adrelated errors, shielding client \ncomponents from these con\u00adcerns. To de.ne platform-wide strategies for managing errors, we further extended \nour ADL, allowing system-level com\u00adponents to be declared. These components handle classes of errors \nthat are relevant to a given strategy. Raising the level of abstraction at which strategies are described \nis a key en\u00adabler to enforce global constraints. For example, occupants of a building may need to be \nevacuated if a massive fail\u00adure of .re detection devices occurs. To make this constraint explicit in \nthe architecture, one can introduce a component that requires to receive all malfunction-related errors \nfrom these devices. Ensuring this constraint then amounts to ver\u00adifying that the component implementation \ntakes appropriate actions when a failure rate is reached. Because the underly\u00ading programming framework \nis generated from the architec\u00adture description, our system-level component is guaranteed to be sent \nerrors of the required types. To implement our approach, we have enriched an ADL dedicated to the pervasive \ncomputing domain with error\u00adhandling declarations. We have extended its framework gen\u00aderator to include \nsupport for error handling. We validated our approach by architecturing and implementing various building-automation \napplications. Our contributions Our contributions can be summarized as follows. Architecturing error \nhandling. We propose a novel ap\u00adproach that raises the level of abstraction of error han\u00addling from programming \nto architecturing. Our approach allows reasoning, and programming is driven by this ex\u00adtended form of \nsoftware descriptions.  An extended domain-speci.c ADL. We have extended a domain-speci.c ADL with declarations \ndedicated error handling. These architecture-level declarations provide a separation between functional \nand error-handling con\u00adcerns. Furthermore, error handling is made speci.c by decomposing it into application \nand system compensa\u00adtion strategies.  Programming support for error handling. Architecture descriptions \nare processed by a compiler that generates dedicated programming frameworks in Java. We have ex\u00adtended \nthis compiler to produce additional programming support for signaling, propagating and treating errors \nthat originate as Java exceptions. This support makes the pro\u00adgramming of error handling more rigorous \nand system\u00adatic.  Validation. We have used our approach to develop a vari\u00adety of dependable applications \nin areas including home/ building automation and healthcare. Our largest case study is a system for managing \na 13 500-square meter building, amounting for more than 3 000 LOC.  Outline The rest of this paper \nis organized as follows. Sec\u00adtion 2 identi.es the key requirements to architecturing error handling. \nSection 3 presents our error handling model. Sec\u00adtion 4 examines our implementation. In Section 5, we \nde\u00adscribe the evaluation of our approach. Related works are dis\u00adcussed in Section 6 and conclusions are \ngiven in Section 7. 2. Requirements to error handling This section introduces DiaSpec, a domain-speci.c \narchitec\u00adture description language dedicated to pervasive computing systems [6], and identi.es key requirements \nfor handling er\u00adrors in this domain. DiaSpec is domain speci.c in that it is dedicated to de\u00adscribing \npervasive computing systems and it relies on an ar\u00adchitectural pattern commonly used in the pervasive \ncomput\u00ading domain [12]. The DiaSpec language is introduced using a working example: a .re management \napplication. This ap\u00adplication is part of a larger software system aimed to fully automate the management \nof an engineering school build\u00ading [4]. Our building management system consists of a set of ap\u00adplications, \neach of which manages a range of situations. For example, our working example is dedicated to managing \n.re situations; it detects a .re by analyzing data produced by smoke and temperature sensors that populate \nthe building. When a .re occurs, the .re management application is re\u00adsponsible for triggering sprinklers \nand alarms, and releasing .re doors. In DiaSpec, a pervasive computing system is described in two stages: \n(1) a taxonomy of entities is de.ned for a target area (e.g., building automation), and (2) an architecture \nis described for each application of the pervasive computing system (e.g., .re management), given a taxonomy \nde.nition. DiaSpec provides a language layer for each stage. 2.1 De.ning an application area DiaSpec \noffers a language layer that abstracts over heteroge\u00adneous entities, whether hardware or software. It \nis a taxon\u00adomy language dedicated to describing classes of entities that are relevant to a given application \narea. An entity declaration models sensing capabilities that produce data, and actuating capabilities \nthat provide actions. Speci.cally, a declaration includes a data source for each one of its sensing capabilities. \nAn actuating capability corresponds to a set of method dec\u00adlarations. Additionally, attributes are included \nin an entity declaration to characterize properties about instances (e.g., their location). Entity declarations \nare organized hierarchi\u00adcally, allowing entity classes to inherit attributes, sources, and actions. Let \nus now illustrate the taxonomy language with the .re management area. An extract of this taxonomy is \nshown in Figure 1. Entity classes are introduced by the device keyword. For simplicity, note that the \nsame keyword is used to introduce both software and hardware entities. At the root of our taxonomy is \nthe Device node (lines 1 to 3). It introduces the location attribute. Attributes are used as area-speci.c \nvalues to discover entities in a pervasive computing environment. The sensing capabilities of an entity \nclass are declared by the source keyword. For example, the TemperatureSensor entity class de.nes the \ntemperature data source of type Temperature (lines 9 to 12). Interestingly, the source dec\u00adlaration abstracts \nover how the data are supplied, that is, whether the data are pushed into the application, or pulled \nfrom the entity by the application. 1 device Device { 2 attribute location as Location; 3} 4 device \nFireSensor extends Device {} 5 device FireActuator extends Device {} 6 device SmokeDetector extends FireSensor \n{ 7 source smoke as Smoke; 8} 9 device TemperatureSensor extends FireSensor { 10 attribute accuracy \nas Accuracy; 11 source temperature as Temperature; 12 } 13 device Sprinkler extends FireActuator { 14 \naction OnOff; 15 } 16 device FireDoor extends FireActuator { 17 action Release; 18 } 19 device Alarm \nextends Device { 20 action Activation; 21 } 23 action OnOff { 24 on(); 25 off(); 26 } 27 action Activation \n{ 28 activate(type as AlarmType); 29 deactivate(); 30 } 31 action Release { 32 release(); 33 } 34 35 \nenumeration LockedStatus {LOCKED, UNLOCKED} 36 enumeration AlarmType {FIRE, INTRUSION} 37 enumeration \nTemperatureUnit {CELSIUS, FAHRENHEIT} 38 enumeration Accuracy {LOW, NORMAL, HIGH} 40 structure Temperature \n{ 41 value as Integer; 42 unit as TemperatureUnit; 43 } 44 structure Smoke { 45 isDetected as Boolean; \n46 } Figure 1. Extract of the .re management taxonomy Actuating capabilities are declared by the action \nkey\u00adword. As an example, consider the Sprinkler declaration (lines 13 to 15). This entity class de.nes \nthe OnOff action interface to be invoked by an application to activate sprin\u00adklers. An action interface \nconsists of the signatures of meth\u00adods supported by an entity class (lines 23 to 33). Requirements. The \nentities of a pervasive computing sys\u00adtem are off-the-shelf software components and devices that may \nfail, raising a variety of errors [7]. For example, enti\u00adties may become unavailable due to malfunction \n(e.g., power losses) or network failures. They may also operate incor\u00adrectly due to bugs (e.g., faulty \nsensors [19]). Entities may directly raise an error when they are capable of diagnos\u00ading a malfunction. \nAlternatively, the runtime environment  Figure 2. DiaSpec architectural style may raise an error if \nit cannot operate an entity because of platform-related problems. In the spirit of an IDL (e.g., WSDL \n[8]), the declaration of an entity class should expose the errors it may raise to ensure that its clients \nprovide appropriate treatments. Yet, we need to go beyond this approach because such error declarations \ndo not take into account the usage context of its clients. For example, an error raised by a temperature \nsensor is declared once regardless of whether the sensor is used for informational purposes or is part \nof a safety\u00adcritical application. A more accurate approach should allow an entity client to express requirements \non entity errors to take into account the usage context.  2.2 Architecturing an application To architecture \napplications, the DiaSpec language provides an ADL layer. It is based on an architectural pattern depicted \nin Figure 2. This pattern decomposes an application into context and controller components. Context components \nare fueled by sensing entities, declared by the taxonomy. These components interpret, .lter and aggregate \nthese data to make them amenable to the application needs. Controller com\u00adponents receive application-level \ndata from context compo\u00adnents and determine the actions to be triggered on entities. Let us illustrate \nthe ADL layer of DiaSpec with the architecture description of our .re management example. The overall \nfunctional architecture of this application is graphically represented in Figure 3. The corresponding \nDia-Spec architecture declarations are presented in Figure 4. At the bottom of this architecture are \nthe smoke detec\u00adtors and the temperature sensors, declared in the taxonomy. These sensors respectively \ndetect the presence of smoke and calculate the temperature of a room in the building. These data are \nrespectively sent to the SmokeDetected and AverageTemperature components, declared using the context \nkeyword. In particular, consider the Smoke-Detected context (lines 1 to 4). This component is re\u00adsponsible \nfor determining whether a given room of the building is .lled with smoke. To do so, it aggregates and \nprocesses sources of information from smoke detectors de\u00adployed in the building. These sources are declared \nusing the source keyword that takes an identi.er and a class of entities (line 3). As a result of this \ndeclaration, the SmokeDetected context takes a smoke data source as input, produced by Figure 3. A data \n.ow view of the .re management archi\u00adtecture extract  1 context SmokeDetected as Boolean 2 indexed by \nlocation as Location { 3 source smoke from SmokeDetector; 4 } 5 context AverageTemperature as Temperature \n6 indexed by location as Location { 7 source temperature from TemperatureSensor; 8 } 9 context FireState \nas Boolean 10 indexed by location as Location { 11 context SmokeDetected; 12 context AverageTemperature; \n13 } 15 controller FireController { 16 context FireState; 17 action Release on FireDoor; 18 action OnOff \non Sprinkler; 19 action Activation on Alarm; 20 } Figure 4. Extract of the .re management architecture \n the SmokeDetector entities. The SmokeDetected com\u00adponent signals the presence or the absence of smoke \nin a room by producing a value of type Boolean. To facilitate the use of this information by other components, \neach out\u00adput value is attached an index, namely the location of the room where the smoke is detected. \nThis is done by declar\u00ading the SmokeDetected component as being indexed, using the indexed by keyword \n(line 2). The FireState compo\u00adnent combines the output of the SmokeDetected compo\u00adnent with the average \ntemperature of the target room, pro\u00advided by the AverageTemperature context. This infor\u00admation determines \nwhether a .re is occurring in the target room; it is passed to the FireController component, de\u00adclared \nusing the controller keyword (lines 15 to 20). This component is responsible for extinguishing the .re \nand per\u00adforming other emergency tasks. To do so, it operates sprin\u00adklers, alarms, and .re doors; using \nthe action keyword, it declares invoking the OnOff action on the Sprinkler entity class, the Activation \naction on the Alarm entity class, and the Release action on the FireDoor entity class (lines 17 to 19). \n Requirements. As shown in our .re management example, context and controller components are dependent \non entities, whether or not directly. Entities are the main point of ori\u00adgin of errors. Furthermore, \nthey may need to be propagated throughout the application data .ow, impacting a chain of components. \nRather than delegating the handling of errors to the implementation, a high-level approach should lever\u00adage \ncomponent declarations. Enriched declarations could en\u00adable default treatments to be generated automatically \nand the development of speci.c treatments to be enforced dur\u00ading component implementation. Such declarative \napproach would raise the level of abstraction of error handling, al\u00adlowing reasoning at the architecture \nlevel, generating error\u00adhandling code in default cases, and providing guidance to the programmer for \nother situations. Considering our .re management system, there are a number of situations that could \nbe expressed in the decla\u00adrations of context and controller components. For example, the building designer \nmay not provide an alternative to the failure of FireDoor entities. Consequently, the pervasive\u00adcomputing \nsystem architect could take this situation into account by declaring a FireController component that \nignores errors from FireDoor entities. For another example, the SmokeDetector entities should be considered \nas critical to the safety of the building occupants. Consequently, the software architect should be able \nto require the developer of the SmokedDetected component to implement code to compensate for errors at \nthe application level. Alternatively, the software architect could also provide a declaration that precludes \nany error handling within a given component, pro\u00adviding a complete spectrum to the architect. In addition \nto application-speci.c processing, there is a need to de.ne error-handling strategies that are consis\u00adtent \nover an entire pervasive computing platform. Doing so requires global handlers that would centralize \nthe treat\u00adment of a given range of errors and provide a system-wide treatment that complements the application-level \nprocess\u00ading. For example, an unreachable entity not only requires an application-level treatment to compensate \nfor the miss\u00ading value, but it also necessitates system-level measures that could be factorized.  2.3 \nImplementing a pervasive computing system The DiaSpec compiler generates a Java programming frame\u00adwork \nwith respect to a taxonomy de.nition and an architec\u00adture description. This dedicated framework contains \nan ab\u00adstract class for each DiaSpec declaration (entity, context and controller) that includes generated \nmethods to support the implementation (e.g., operations for entity discovery and en\u00adtity invocation). \nThe generated abstract classes also include abstract method declarations to allow the developer to pro\u00adgram \nthe application logic (e.g., triggering entity actions). Implementing a DiaSpec-declared object, whether \nentity or component, is done by sub-classing the corresponding gen\u00aderated abstract class. This enables \nto precisely guide the pro\u00adgrammer in the development process. Figure 5 presents an excerpt of the implementation \nof the SmokeDetected context declaration. This implementation is done by extending the corresponding \ngenerated abstract class. Because this context is declared as taking a Smoke in\u00adput source from smoke \ndetectors, the generated framework provides the required methods to discover, select, and inter\u00adact with \ninstances of this entity class. Speci.cally, all avail\u00adable smoke detectors are discovered by invoking \nthe all-SmokeDetectors method (line 4); events of type Smoke are published by calling the setSmokeDetected \nmethod (line 11) for a given location; the Smoke source of this con\u00adtext component is accessed in the \npull mode via getSmoke (line 10), and the push mode via smokeChanged (line 7). 1 public class MySmokeDetected \nextends SmokeDetected 2{ 3 public MySmokeDetected() { 4 allSmokeDetectors().subscribeSmoke(this); 5} \n6 @Override 7 public void smokeChanged(SmokeDetector smokeDetector, Smoke smokeDetected) { 8 ... 9 try \n{ 10 if (sd.getSmoke().isDetected) { 11 setSmokeDetected(location, new Smoke(true)); 12 } 13 } catch \n(DiaGenCommunicationException e) {...} 14 ... 15 } 16 } Figure 5. An implementation of the SmokeDetected \ncon\u00adtext component Requirements. Because entities are extensively invoked by an application, their potential \nerrors propagate the need to guard against these errors throughout most application com\u00adponents. A key \nproblem with existing approaches is that, when implementing the handling of an error, the program\u00admer \nis left wondering whether it should be ignored or com\u00adpensated for; whether it requires system-wide actions \nor can be treated locally; whether it is fatal to the system or can be recovered from. The nature of \nthe error is informally speci\u00ad.ed and often requires thorough code examination. As a con\u00adsequence, developers \nmay ignore errors or provide inappro\u00adpriate treatments. Let us illustrate these issues by considering \nagain the SmokeDetected context implementation (Figure 5). The call to a smoke detector (line 10) is \nguarded against an error. However, the try-catch construct offers a very crude mecha\u00adnism, considering \nthe many issues to address. For example, depending on the error type, a system-wide treatment may be \nrequired given the safety-critical nature of the sensor. For another example, depending on whether the \nerror is found to be transient, a default value could compensate for the miss\u00ading temperature value. \nHow errors are handled should not be optionally and in\u00adformally communicated to the programmer. Instead, \npro\u00adgramming should be driven by architecture design decisions. The architecture description should be \na repository of these architecture decisions, providing a system-wide view of er\u00adror handling, down to \nits constituent parts. These issues are speci.c to the constituent parts of the architecture of a software \nsystem and should be speci.ed at that level. The implementation should then be closely driven by the \ndesign choices made in the architecture. 3. Error-Handling Model We now present our error-handling model \nthat addresses the requirements discussed earlier. This model is introduced in the context of DiaSpec \nand is illustrated by the .re manage\u00adment example. We .rst describe how errors are characterized using \nthe taxonomy de.nition of a pervasive computing en\u00advironment. Then, we explain how to extend an ADL such \nas DiaSpec to architecture error-handling at both the applica\u00adtion and system level. Finally, we examine \nthe programming support generated by our architecture-driven approach to fa\u00adcilitate the implementation \nof the declared components. 3.1 Characterizing errors Typically, errors occur during interactions with \nentities. We have extended our DiaSpec taxonomy language with decla\u00adrations for specifying that a data \nsource or an action method may throw exceptions. Figure 6 revisits the taxonomy for .re management, dec\u00adorating \nentity declarations with exception information. Ex\u00adceptions raised by a data source are introduced by \nthe raises keyword. In our example, an exception of type Measure-Exception is raised by temperature sensors \nwhen an error occurs during the computation of the temperature measure (line 3). Exceptions raised by \nan action method are also in\u00adtroduced by the raises keyword. In our example, an excep\u00adtion of type WaterPressureException \nis raised by sprin\u00adklers when an error occurs during their opening (line 9). Other exceptions that are \nnot directly related to sensing and actuating capabilities of entities, can be raised by the 1 device \nTemperatureSensor extends FireSensor { 2 attribute accuracy as Accuracy; 3 source temperature as Temperature \nraises MeasureException; 4} 5 device Sprinkler extends FireActuator { 6 action OnOff; 7} 8 action OnOff \n{ 9 on() raises WaterPressureException; 10 off(); 11 } Figure 6. Fire management taxonomy with exception \ndec\u00adlarations Figure 7. Hierarchy of built-in exceptions runtime environment during an access to a \ndata source or a method call. These exceptions enable to signal errors coming from the pervasive computing \nplatform. For example, when an entity is unavailable due to a network failure, an exception of type NetworkException \nis raised. We call such excep\u00adtions built-in; they form a hierarchy shown in Figure 7. Our two-level \napproach to error handling results in sig\u00adnaling an error at both the application level and the system \nlevel. At the application level, the error handling logic is only concerned about compensating for the \nerror, not repair\u00ading the malfunction. At the system level, error handling is aimed to analyzing the \ncause of an error and determining re\u00adpair policies that preserve global consistency. Conceptually, both \napplication and system-level error handling logic are executed simultaneously, when both levels are impacted \nby an error. When an error is detected proactively (e.g., an ex\u00adpired regisration lease for an entity), \nit can be handled by a system-level component, prior to any application invocation, allowing a recovery \nthat is transparent to the application. 3.2 Architecturing error handling By addressing errors at the \nsoftware-architecture level, our approach abstracts over the wide spectrum of errors occur\u00adring in a \npervasive computing system, and provides infor\u00admation to guide and support the implementation of error\u00adhandling \ncode. We leverage the DiaSpec architecture lan\u00adguage presented in Section 2 to architecture errors at \nboth application and system level. Note that our approach can ap\u00adply to other ADLs that are based on \nour architectural pattern. 3.2.1 At the application level Architecturing errors at the application level \nconsists of specifying how an exception impacts the control .ow of the architecture components. More \nprecisely, the architect determines at system-design time (1) whether the developer of a given component \nmust de.ne the logic to handle an exception, continuing execution transparently; (2) whether handling \nthis exception is optional, amounting to a Java unchecked exception; (3) whether the exception should \nbe automatically propagated to the calling component; or (4) whether no exception can occur. To express \nthese policies we have introduced four new keywords in DiaSpec, respec\u00adtively: mandatory catch, optional \ncatch, skipped catch, and no catch. These extensions allow the architect to re\u00adquire an error to be handled \ndifferently depending on its criticality in the pervasive computing system. 1 context SmokeDetected \nas Boolean 2 indexed by location as Location { 3 source smoke from SmokeDetector [skipped catch]; 4} \n5 context AverageTemperature as Temperature 6 indexed by location as Location { 7 source temperature \nfrom TemperatureSensor [mandatory catch]; 8} 9 context FireState as Boolean 10 indexed by location as \nLocation { 11 context SmokeDetected [mandatory catch]; 12 context AverageTemperature [no catch]; 13 } \n15 controller FireController { 16 context FireState [no catch]; 17 action Release on FireDoor [skipped \ncatch]; 18 action OnOff on Sprinkler [optional catch]; 19 action Activation on Alarm [mandatory catch]; \n20 } Figure 8. The .re management architecture with exception declarations Let us illustrate these extensions \nwith our .re manage\u00adment example. To do so, a revised version of the archi\u00adtecture description with exception \ndeclarations is displayed in Figure 8. In this description, the architect considers the FireState component \nas being central to determining a .re situation in the building. Consequently, error handling of smoke \ndetectors is not delegated to the SmokeDetected component. This design decision is expressed in line \n3, where the SmokeDetected component is declared as not being allowed to process errors from smoke detectors. \nThis task is assigned to the FireState component, where the treatment of smoke-detector errors is declared \nas mandatory (line 11). In contrast, the AverageTemperature component is as\u00adsumed to serve various purposes, \nincluding heating control. Its role is secondary in the .re management application: it is only used \nto corroborate the information delivered by the SmokeDetected component. As such, the Average-Temperature \ncomponent is declared as one that compen\u00adsates for errors from temperature sensors (line 7), always providing \na value, even at the expense of accuracy. Be\u00adcause errors from temperature sensors are fully treated \nby the AverageTemperature component, the FireState compo\u00adnent does not have to consider the reliability \nof this context component, as is declared in line 12. Our exception declarations also play a key role \nin con\u00adtroller components to interact with actuators. They express design decisions regarding what the \nimplementation of a component should do in case the invocation of an actuator fails. If a failure cannot \nbe compensated for at the applica\u00adtion level, the exception can be ignored (line 17). If alterna\u00adtive \nstrategies to a failure can be chosen at the application level, the mandatory declaration is used to \nenforce an im\u00adplementation (line 19). If no speci.c treatment is de.ned at design time, the optional \ndeclaration is used (line 18). Note that the no catch declaration can be inferred: when a component is \nrequired to treat errors (line 7), its clients can automatically assigned a no catch declaration (line \n12). Furthermore, a syntactic veri.cation is performed to check the consistency of the exception declarations. \n 3.2.2 At the system level Architecturing errors at the system level takes the form of DiaSpec context \nand controller components that process DiaSpec events signaling errors. These DiaSpec events are called \nexceptional events1; they are of the same type of the original Java exceptions, providing all the information \nabout the causes of the error. System-level context components differ from ordinary DiaSpec components \nin that they take as input exceptional events from entities. They process these events and re.ne them \ninto application-speci.c values. Con\u00adtroller components receive these re.ned values and execute a repair \nstrategy by invoking actuators. In doing so, platform\u00adwide repair strategies are raised to an architectural \nlevel: they are decomposed into context and controller compo\u00adnents. This approach enables system-wide \nreasoning about errors in a pervasive computing system, enabling stringent implementation constraints \nto be enforced. To illustrate our approach, consider the system level of the error-handling architecture \nfor our working example dis\u00adplayed in Figure 10; the data .ow view of this architecture is showed in \nFigure 9. Conceptually, a system-level con\u00adtext component is dedicated to handling errors that are re\u00adlated \nfrom an application viewpoint. For example, we de\u00adclare a context component dedicated to handling failures \nof .re detection devices and another component addressing 1 This distinction is purely conceptual. Exceptional \nevents are declared as such but are actually implemented as DiaSpec events (see Section 4 for details). \n Figure 9. Extract of the .ow of exception handling in the .re management application 1 context FireExtinctionFailure \nas Boolean 2 indexed by location as Location { 3 exception WaterPressureException from Sprinkler; 4 exception \nBatteryException from Sprinkler; 5 exception PowerException from FireActuator; 6 exception NetworkException \nfrom FireActuator; 7 exception UnregisterException from FireActuator; 8} 9 context FireDetectionFailure \nas Boolean 10 indexed by location as Location { 11 exception MeasureException from TemperatureSensor; \n12 exception PowerException from FireSensor; 13 exception NetworkException from FireSensor; 14 exception \nUnregisterException from FireSensor; 15 } 17 controller EmergencyController { 18 context FireExtinctionFailure; \n19 context OpeningHours; 20 action Activation from Alarm; 21 action PhoneSomeone from Phone; 22 } 23 \ncontroller DetectionController { 24 context FireDetectionFailure; 25 action PhoneSomeone from Phone; \n26 } Figure 10. Extract of the error-handling architecture at the system level for the .re management \nexample failures of .re extinction devices (FireDetectionFailure and FireExtinctionFailure, respectively). \nThese spe\u00adci.c components analyze the input errors and publish a sta\u00adtus information, whenever measures \nneed to be taken. For example, occupants of a building may need to be evacuated when there is a massive \nfailure rate of .re extinction devices. To do so, the implementation of the FireExtinction-Failure component \nshould, among other tasks, keep track of faulty .re-extinction devices. When a failure threshold is reached, \nit should publish a failure alert. As declared in line 18 of Figure 10, the EmergencyController compo\u00adnent \nis a client of this information and may trigger an evac\u00aduation alarm (line 20), if a failure alert occurs \nduring of.ce hours (line 19). Similarly, the FireDetectionFailure component de\u00adtermines whether every \nroom of the building has function\u00ading devices for detecting a .re (e.g., smoke detectors) by handling \nthe exceptional events related to this device class. Let us examine further the declarations of system-level \ncomponents in Figure 10. Using the exception keyword, the FireExtinctionFailure component (lines 1 to \n8) de\u00ad.nes as input exceptional event types from various entities: WaterPressureException and BatteryException \nfrom Sprinkler, and PowerException, NetworkException and UnregisterException from FireActuator. Whereas \nsome declarations directly draw errors from an entity class (e.g., Sprinkler), others leverage the hierarchy \nof the tax\u00adonomy of entities, allowing handlers to be de.ned at the appropriate level of granularity \n(e.g., FireActuator). A system-level component, whether context or controller, processes both exceptional \nevents and ordinary values, pro\u00adduced by context components, whether or not functional. This is illustrated \nby the EmergencyController compo\u00adnent whose logic depends on the OpenHours component (line 19).  3.3 \nImplementing error handling Given a taxonomy de.nition and architecture declarations, a domain-speci.c \nprogramming framework is generated, pro\u00adviding support for the implementation of components (i.e., entities, \ncontexts and controllers) of a pervasive comput\u00ading system. We have developed an extended version of \nthe DiaSpec compiler to address error handling. This extended compiler generates frameworks with programming \nsupport to ease and guide the development of error handling code at both the application and system level. \n 1 public class TemperatureSensorProxy { 2 ... 3 // only generated if annotated mandatory or optional \n4 public Temperature getTemperature (TemperatureContinutation tc) { 5 ... // code generated by the DiaSpec \ncompiler 6 } 7 public interface TemperatureContinuation { 8 public Temperature onError (); 9 } 10 } Figure \n11. Extract of the TemperatureSensorProxy proxy class generated for the AverageTemperature com\u00adponent \n 3.3.1 At the application level At the application level, error handling essentially amounts to compensate \nfor either a missing value from a data source or a failed invocation of an entity action; This is done \nwith\u00adout considering the nature of the error. Error handling is trig\u00adgered by a unique exception called \nthe application-level ex\u00adception. This exception only retains the control .ow effect of the exception \nmechanism, allowing the error to be propa\u00adgated up the call stack. To handle the application-level exception, \nwe propose a continuation-style approach to compensate for a missing value. In this approach, if the \ncomponent being implemented is declared as handling errors, the developer must pass a typed continuation \ncode as an additional input to the opera\u00adtion. If error handling is declared as being disallowed, there \nis no continuation parameter. This continuation-passing style approach requires the developer to provide \ncompensation code on a per-operation basis. This constrasts with the try\u00adcatch construct that can cover \na group of operations. Because the programming framework is generated with respect to an architecture \ndescription, the entity interfaces provided to the developer are compliant to their error-handling declarations. \nLet us examine the TemperatureSensorProxy proxy class generated for the AverageTemperature component2. \nAn extract of this proxy class is displayed in Figure 11. This class provides a method named getTemperature \n(line 4) to request the temperature source provided by the tempera\u00adture sensors. Because this source \nwas declared as manda\u00adtory catch in the AverageTemperature component, the generated proxy requires the \nprogrammer to compensate for a missing value in case of failure. To do so, a continuation parameter is \nintroduced in the getTemperature method; it corresponds to recovery code to be executed in case of fail\u00adure. \nSince the Java programming language does not support continuations per se, they are mimicked by generated \ninter\u00adfaces (lines 7 to 9) declaring an onError method, whose 2 A proxy class is generated for each component \ninteraction declared in the DiaSpec architecture. return type is the same as the overloaded method (i.e., \nTem\u00adperature). The following code presents examples of contin\u00aduations for the getTemperature method in \ncase the invo\u00adcation of the sensor fails. The .rst continuation provides a default value. The second \ncontinuation retries to query the sensor once; if it fails again, a default value is returned. 1 // default \nvalue 2 Temperature temperature = t.getTemperature ( 3 new TemperatureContinuation () { 4 public Temperature \nonError () { 5 return new Temperature(21, TemperatureUnit.CELCIUS); 6} 7} 8 ); 10 // retry + default \nvalue 11 Temperature temperature = t.getTemperature ( 12 new TemperatureContinuation () { 13 public Temperature \nonError () { 14 return t.getTemperature( 15 new TemperatureContinuation() { 16 public Temperature onError() \n{ 17 return new Temperature(21, TemperatureUnit.CELCIUS); 18 } 19 } 20 ); 21 } 22 } 23 ); If the client \ncomponent had declared the Temperature source as skipping errors (i.e., skipped catch), the gener\u00adated \nproxy would only include a method without a continua\u00adtion parameter, disallowing the programmer to handle \nerrors. In this case, when an error occurred, the application-level exception would automatically be \npropagated to the calling components until one caught it. Because pervasive comput\u00ading systems typically \nrely on a reactive-execution model, the application-level exceptions ignored by the top-level call\u00ading \ncomponent, can be soundly intercepted by our error\u00adhandling model, without aborting the application. \nIn doing so, the developer is not forced to write error-handling code, nor does he need to modify every \nmethod signature where an exception is not handled to declare its propagation, as is done in Java. Alternatively, \nthe client could have declared this source as optionally treating errors (i.e., optional catch). In this \ncase, both methods, with and without the continuation parameter, would have been generated in the proxy, \ndelegating to the developer whether to handle errors. For another example of continuation consider the \nsprin\u00adkler actuator, invoked by the FireController component. This interaction is declared as optional \ncatch. As a result, the programmer may either invoke the OnOff method with\u00adout a continuation, letting \nthe exception propagate in case of an error, or consider that the FireController component should continue \ntaking actions to extinguish the .re, ignor\u00ading the error. The latter option is achieved by the continua\u00adtion \nshown below. 1 // do nothing 2 sprinkler.on ( 3 new OnContinuation () { 4 public void onError () { 5 \n// do nothing 6} 7} 8 );  3.3.2 At the system level System-level error handling takes the form of contexts \nthat re.ne exceptional events, originating from Java, into application-speci.c values. These values are \nused by con\u00adtrollers to maintain the platform consistency by invoking entity actuators. These context \nand controller components are implemented by extending the corresponding abstract class generated by \nthe DiaSpec compiler. This is illustrated by the implementation of the FireExtinctionFailure context, \nshown in Figure 12. It is aimed to detect loca\u00adtions where there is no functioning devices to extinguish \na .re. Its implementation is done by extending the generated abstract class, named FireExtinctionFailure. \nBecause this context is declared as catching PowerException and WaterPressureException from .re actuators \nand sprin\u00adklers respectively (Figure 10, line 5 and line 3), the gener\u00adated framework provides support \nto discover .re actuators and sprinklers, and to monitor the exceptions they raise. For example, the \ngenerated allFireActuators method dis\u00adcover all .re actuators and is used to subscribe to Power-Exception \nfrom .re actuators (Figure 12, line 4). Similarly, the generated allSprinklers method is used to subscribe \nto WaterPressureException from sprinklers (line 5). The MyFireExtinctionFailureImpl class implements \nthe abstract methods (e.g., onNewWaterPressureException) that are called upon exceptions (lines 8 to \n15). 4. Implementation The DiaSpec compiler, named DiaGen, is implemented us\u00ading the ANTLR parser generator \n[25]. A DiaSpec-speci.ed software system is agnostic to the target distributed-systems technology. To \ndo so, DiaGen leverages existing distributed\u00adsystems technologies by generating glue code to customize \nthem with respect to the needs of pervasive computing. Cur\u00adrently, DiaGen offers back-ends for the following \ntargets: Web Services [9], RMI [13], SIP [30] and CORBA [24]. Our error-handling model extends the DiaSpec \ntaxonomy and architecture languages, the DiaSpec framework genera\u00adtor, and the DiaSpec runtime. Most \nof these extensions are mapped directly into existing DiaSpec concepts. For exam\u00adple, system-level context \ncomponents rely on the publish\u00adsubscribe paradigm, leveraging the implementation of Dia-Spec sources \nand contexts. This seamless integration strat\u00adegy allows to transparently reuse existing DiaSpec tools, \nsuch as the existing back-ends and DiaSim a simulator for pervasive computing systems [4]. 1 public \nclass MyFireExtinctionFailureImpl extends FireExtinctionFailure 2{ 3 public MyFireExtinctionFailureImpl() \n{ 4 allFireActuators().subscribePowerException(); 5 allSprinklers().subscribeWaterPressureException(); \n6 ... 7} 8 @Override 9 public void onNewPowerException(FireActuator .reActuator, PowerException power) \n{ 10 setFireExtinctionFailure(.reActuator.getLocation(), noMoreCorrectFireActuator(.reActuator.getLocation())); \n11 } 12 @Override 13 public void onNewWaterPressureException(Sprinkler sprinkler, WaterPressureException \nwaterPressure) { 14 setFireExtinctionFailure(sprinkler.getLocation(), noMoreCorrectFireActuator(sprinkler.getLocation())); \n15 } 16 ... 17 } Figure 12. Extract of the FireExtinctionFailure con\u00adtext implementation class We now \nbrie.y describe the implementation of our er\u00adror handling model. We examine how an error is trans\u00adformed \ninto the application-level exception and an excep\u00adtional event. Then, we discuss how they are propagated \nthrough components. 4.1 Handling errors Java exceptions, regardless of their origin, are intercepted \nby an intermediate layer, between the entity client and the entity implementation. This layer is part \nof the DiaSpec generated framework. It provides a uniform treatment of exceptions, converting them into \nthe application-level exception and an exceptional event. An error may either be user-de.ned or built-in. \nUser\u00adde.ned errors correspond to taxonomy-declared exceptions; they are raised by entity implementations, \nusing the Java throw statement. If not taxonomy-declared, an exception is considered built-in. For example, \nwhen a networked entity becomes unreachable, an exception is raised by the client proxy. In addition, \nDiaGen generates a number of error de\u00adtection mechanisms (e.g., watchdog and heartbeat). These mechanisms \nallow system-level components to handle er\u00adrors proactively (i.e., prior to any application invocation), \nimproving the reliability of the pervasive computing plat\u00adform. The layer between a client proxy and \nthe implementa\u00adtion of a TemperatureSensor entity is displayed in Fig\u00adure 13. The MeasureException Java \nexception is mapped into both an exceptional event (line 4) and the application\u00adlevel exception (line \n5). Similarly, the built-in Java exception of type Exception is published (line 7) and propagated as \nthe application-level exception (line 8). As can be noticed, the transport of exceptional events at \nthe system level leverages DiaSpec events: each ex\u00adceptional event is published as a DiaSpec source (lines \n4 and 7). Source noti.cation follows the publish-subscribe paradigm. This paradigm is mapped by DiaGen \ninto the tar\u00adget distributed-systems technology [6] (i.e., Web Services, RMI, SIP, and CORBA). 1 try \n{ 2 return temperatureSensor.getTemperature(); 3} catch (MeasureException e) { // user-de.ned 4 publishMeasureException(e); \n5 throw new ApplicationLevelException(); 6} catch (Exception e) { // built-in 7 publishUndeclaredException(new \nUndeclaredException(e)); 8 throw new ApplicationLevelException(); 9} Figure 13. Mapping errors into \nthe DiaSpec model  4.2 Propagating errors Once converted into an exceptional event, an error is re\u00ad.ned \nby context components. These components interpret, aggregate and transform information to produce application\u00adspeci.c \nvalues, combining exceptional events with other data sources. This re.nement process propagates informa\u00adtion \nthrought context components until values can be used by controller components to take actions. At the \napplication level, the application-level exception is either propagated or handled in a continuation. \nIt is prop\u00adagated up the call stack, when the corresponding excep\u00adtion was declared as skipped. In case \nof an optional or mandatory declaration, the DiaSpec compiler generates a method that catches the application-level \nexception and exe\u00adcutes the continuation as illustrated in the following. 1 public Temperature getTemperature(TemperatureContinuation \ntc) { 2 try { 3 return this.getTemperature(); 4} catch (ApplicationLevelException e) { 5 return tc.onError(); \n6} 7} 5. Assessment We applied our error handling model on three existing per\u00advasive computing applications \ndeveloped in our research group. These applications are part of a larger project aimed to automate a \n13,500-square meters building, hosting an en\u00adgineering school [4]. This project combines six different \nap\u00adplications involving 21 entity classes, 20 components and over 400 entity instances, amounting for \nmore than 3,000 LOC written in Java.. The .re manager is one of these appli\u00adcations. We now brie.y describe \nthe two others, namely the newscast manager and the intrusion manager. We identify errors pertaining \nto these applications, and we give bene.ts provided by our error-handling approach. Then, we discuss \nhow errors would be handled without our approach, directly using Java exceptions. 5.1 Newscast Manager \nThis application manages information displayed on screens deployed in the engineering school. Information \nsuch as news from RSS feeds or daily class schedules are selected according to surrounding student pro.les, \nincluding their dominating department af.liation. Badge readers are located near screens to detect proximity \nof students and their iden\u00adtities. Finally, a pro.le database is queried to obtain student pro.les from \ntheir identity. Figure 14 (left part) presents the part of the applica\u00adtion architecture that displays \nclass schedules on screens. The ProfileProximity component uses entities of type BadgeReader and ProfileDataBase \nto provide the pro\u00ad.les of nearby students to the LeadingDepartment compo\u00adnent. In turn, this component \nde.nes a process that combines the pro.les of the surrounding students, delivering to the ClassScheduleSelection \ncomponent the leading pro.le. This information is used to request the class schedule of the corresponding \nclass from the ClassSchedule component, and is provided to the NewscastManager component. The class schedule \nis obtained from the ScheduleDatabase en\u00adtity. Error handling strategies. Badge readers can stop work\u00ading \ndue to hardware or network failures. Yet, accurately monitoring people in the proximity of a screen is \nnot re\u00adquired in the context of the newscast manager: missing the detection of a badge is unlikely to \nchange the leading pro.le in an area. Thus, the ProfileProximity context can delegate error handling \nto LeadingDepartment con\u00adtext, which can compensate for the application-level er\u00adror by willingly ignoring \nit. This is expressed in the ar\u00adchitecture by annotating with the skipped catch keyword the edges between \nProfileProximity and its children, namely, BadgeReader and ProfileDatabase. Addition\u00adally, we annotate \nwith mandatory catch the edge between LeadingDepartment and ProfileProximity. Similarly, the ClassScheduleSelection \ncontext can compensate failures of the ScheduleDatabase entity with a default value. When all error \n.ow paths to a component have been assigned a mandatory treatment, the remaining edges can be annotated \nwith the no catch keyword. At this point, the architecture description, enriched with error-handling \ndeclarations, can be used to generate a new programming framework. The Java compiler then points the \nprogrammer to errors that are due to missing continuations for calls to entities requiring a mandatory \ncompensation. Badge readers and databases errors are now compensated at the application level. Yet, it \nis necessary to deal with faulty entities to prevent further problems. In our approach, this can be done \nwithout polluting the code of the newscast ap\u00adplication. For example, consider repairing database corrup\u00adtions \nusing database built-in repair features (e.g., rollback). This strategy is addressed by system-level \ncomponents: the DatabaseFailure context abstracts over database errors and instructs the DatabaseManager \ncontroller to perform repair operations on database entities. These system-level components do not impact \nthe ap\u00adplication level implementation. Generating the framework from a software architecture, extended \nwith error-handling declarations, introduces only new abstract classes that must be subclassed to implement \nthe system-level error recovery logic.  5.2 Intrusion Manager This application is responsible for securing \nthe engineering school. It de.nes what areas needs to be secured and de\u00adtects intrusions in the secured \nones using motion detectors deployed in the engineering school. When an intrusion is detected, alarms \nare triggered and the supervisor of the en\u00adgineering school is alerted by displaying a warning message \nwith a picture taken by a camera covering the intrusion area on his supervision screen. An extract of \nthe functional architecture of this applica\u00adtion is graphically represented in Figure 15 (left part). \nWhen the entities of type MotionDetector detect a motion in an area of the engineering school, the IntrusionDetected \ncomponent requests the SecuredArea component to deter\u00admine whether the motion is occurring in an area \nidenti.ed as secured by the SecurityService entity. If so, the infor\u00admation is passed to the IntrusionManager \ncomponent; it acts on the Alarm, Camera, and Screen entities to report the intrusion to the supervisor. \n Error handling strategies. Similarly to the FireState component in the .re management application, \nthe archi\u00adtect considers the IntrusionDetected component as be\u00ading central to determining an intrusion \nsituation in the en\u00adgineering school. Consequently, it must compensate for the application-level errors \nof the MotionDetector enti\u00adties. This is expressed by annotating with the mandatory catch keyword the \nedge between MotionDetector and IntrusionDetected. Moreover, the SecuredArea context can compensate failures \nof the SecurityService entity with a default value (i.e., the area is secured), implementing a conservative \nsecurity strategy. Because motion detectors are considered as critical to the safety of the engineering \nschool, dealing with their failure is essential. To that end, a repair strategy must be introduced and \naddressed by system-level components. The Motion-DetectionFailure component keeps track of faulty mo\u00adtion \ndetectors. When a failure threshold is reached, it in\u00adstructs the IntrusionDetectionController component \nto trigger alarms and to display an error report on the main\u00adtenance board. 5.3 Revisiting our use cases \nwith Java exceptions Let us now discuss the issues one would encounter in adding error handling in our \nuse cases, solely using Java exceptions. A system-level recovery strategy handles various errors from \nmultiple entities. Doing this in Java requires developers to duplicate code for each occurrence of the \ncorresponding exceptions. One may wonder whether letting these excep\u00adtions propagate higher up the call \nstack would enable factor\u00adizing the system-level error recovery strategy. In fact, such propagation prevents \nthe application logic from compensat\u00ading for an error and resuming normal execution. For exam\u00adple, implementing \nthe database repair strategy in the news\u00adcast manager inside the ClassScheduleSelection com\u00adponent would \nprevent from compensating for the Profile\u00adDatabase exceptions in the LeadingDepartment compo\u00adnent. Since, \ncontinuous execution is important in pervasive computing systems, developers should systematically per\u00adform \nsystem-level recovery strategies at the closest loca\u00adtion from the exception source and rethrow exceptions \nto application-level strategies. Our model automates this repet\u00aditive and error-prone task by generating \nthe glue code that systematically signals exceptions at the system level. In the intrusion management \napplication, the data pro\u00advided by the motion detectors may only be pushed into the application, and \nnever pulled. Consequently, there is no try\u00adcatch block used in the implementation of the Intrusion-Detected \ncomponent to deal with faulty motion detectors. This situation may lead developers to neglect critical \nerrors for the pervasive computing system. Moreover, dealing with these errors requires developers to \nwrite ad hoc code for de\u00adtecting and signaling potential failures of motion detectors. By providing failure \ndetection mechanisms (e.g., heartbeat) that raise proactively built-in exceptions (e.g., Unregister-Exception), \nour approach ensures that device failures are systematically signaled at the system level. Another issue \nstems from the fact that Java provides no guidance as to where and how exceptions should be han\u00addled. \nA common mistake is to mask an exception by catch\u00ading it early or with a wrong type (e.g., a parent class), \nwith\u00adout rethrowing it. This may forbid an appropriate exception handler up the call stack to compensate \nfor the exception. For example, in the newscast manager application, Java does not prevent developers \nto handle ScheduleDatabase ex\u00adceptions in the ClassSchedule component. It can make it impossible for \nsome exceptions to be treated appropriately. In contrast, our approach lets the software architect declare \nat design time where exceptions should be propagated and where they should be handled. 6. Related Work \nWe now review existing approaches for handling errors in software systems, whether or not pervasive computing. \nTo the best of our knowledge, there does not exist tool-based approaches to architecturing, declaring \nand supporting error handling, decomposing treatment into an application and system level. Architecture. \nADLs specify the structure and the behav\u00adior of a software system, whether or not distributed, to en\u00adsure \nsome properties both at compile time and run time. Al\u00adthough most of them target speci.c aspects of a \nsoftware sys\u00adtem [3, 21, 22], few ADLs focus on the speci.cation of error .ow in architecture descriptions. \nFilho et al. [15] propose a conceptual framework, named Aereal, to describe and ana\u00adlyze exceptions that \n.ow between architectural components in a given architectural style. In contrast, our approach goes beyond \nveri.cation in that a programming framework is gen\u00aderated from an architecture description. Such programming \nframework implements the exception declarations, ensuring that the resulting software system is compliant \nwith them. Our generative approach is made possible by the domain\u00adspeci.c nature of DiaSpec. Exception \npatterns. The Portland Pattern Repository [1] proposes a set of exception pattern descriptions in the \ncon\u00adtext of general-purpose programming languages. This repos\u00aditory is organized into categories: de.ning \nexception types, raising exceptions, handling exceptions, etc. These pattern descriptions are work in \nprogress that can be freely extended and discussed. Our approach combines, adapts and auto\u00admates two \nof these patterns to the needs of error handling in pervasive computing systems. The application-level \nexception, proposed in our ap\u00adproach, can be seen as a BottomPropagation pattern in which an exception \ncarries no information. It is also similar to the Maybe Monad3 in Haskell. As for exceptional events \nat the system level, they are typically implemented with an ExceptionReporter pattern. This approach \nenables to decou\u00adple the treatment of errors from the control .ow, allowing for example exceptions to \nbe treated by multiple handlers. This exception pattern adapts the publish-subscribe [14] model for error \nreporting. Not only does our approach revolve around both the BottomPropagation and ExceptionReporter \nexception pat\u00adterns, but it automates their implementation in the generated programming framework. Middleware \nand programming languages. Many soft\u00adware layers dedicated to the pervasive computing domain have been \nproposed to provide programming support for error handling [7, 26, 27]. For example, the one.world project \n[27] proposes a check-pointing mechanism that al\u00adlows developers to capture the execution state of a \ncompo\u00adnent, and later to restore it to gracefully resume the execution of the component after a failure, \nsuch as power loss. It also enhances the robustness of pervasive computing systems by providing transaction-level \npersistence. Our error han\u00addling model is complemented to this approach. In fact, we plan to enrich DiaSpec \nfurther by integrating fault-tolerance declarations, generating built-in error recovery strategies in \nprogramming frameworks. Dedecker et al. [10] have proposed a domain-speci.c lan\u00adguage, called AmbientTalk, \ndedicated to developing applica\u00adtions in the context of a mobile network. In particular, they introduce \na distributed exception-handling mechanism [23] to deal with mobile hardware characteristics [10], such \nas connection volatility. This mechanism consists of a set of language constructs that enables to handle \nexceptions at dif\u00adferent levels of granularity in the application code: message, block and collaboration. \nA key difference with our approach is that AmbientTalk still relies on a form of try-catch block that \ndoes not allow a separation between application and system-level error handling. 3 http://www.haskell.org/all_about_monads/html/maybemonad.html \n Various communication paradigms have been used to de\u00advelop mobile computing applications, whether data-based \n(e.g., tuple spaces [16]), or control-based (e.g., the ac\u00adtor model [2]). These paradigms enable to decouple \ncom\u00admunications between networked entities from their spatial and temporal dimension. This strategy improves \nfailure re\u00adsilience through error isolation and prevents a range of errors from being propagated. However, \nthese approaches are re\u00adstricted to network-related errors. In contrast, our approach tackles a range \nof errors, from faulty devices to platform er\u00adrors. Also, it leverages an existing general-purpose program\u00adming \nlanguage, namely Java, raising the level of abstraction of error handling by introducing extensions to \nan ADL. Demsky and Dash [11] have proposed a task-based lan\u00adguage, called Bristlecone, for developing \nrobust systems. Their approach places a premium on continued execution and can tolerate some degradation \nfrom a speci.c designed behavior. The Bristlecone runtime uses task speci.cations to determine what task \nto execute. Because tasks in Bristlecone have a transactional semantics, when a task fails due to soft\u00adware, \nhardware or user errors, the Bristlecone runtime aborts the task s transaction. To avoid re-triggering \nthe same under\u00adlying fault, the Bristlecone runtime records the combination of tasks that caused the \nfailure, and executes other tasks. In that respect, Bristlecone relies on a unique strategy to handle \nerrors at the granularity of a task. In contrast, our approach can recover from a faulty entity without \naborting the execu\u00adtion of a component. The recovery logic is de.ned at both application and system level, \nenabling the implementation of a range of recovery strategies. Aspect-oriented programming. The tangling \nbetween the functional and exceptional code in software systems is one of the consequences of the lack \nof programming support to handle exceptions. Aspect-Oriented Programming (AOP) is a programming technique \nfor modularizing concerns that cross-cut the programs [17], such as exception handling. Lipper and Lopes \nstudied the reengineering of exception handling code using the AOP language, AspectJ [18]. Their study \ndemonstrates that AOP reduces code tangling related to exception handling, and greatly reduces the corresponding \nportion of code. Our approach also modularizes and factorises the system\u00adlevel error-handling logic. \nIt keeps application-speci.c error\u00adhandling logic in the application code, allowing context\u00adspeci.c treatments. \nAlso, the AOP approach is speci.c to a target program, making it dif.cult to apply weaving actions to \na range of programs. Cacho et al. [5] have proposed an aspect-oriented ap\u00adproach, called EJFlow, that \nextends AspectJ and enables developers to modularize system-level exception-handling code. To do so, \nmechanisms are introduced to associate ex\u00adception handlers with exceptional .ows in Java code. Un\u00adlike \nour generative approach, AOP does not provide devel\u00adopers with programming support and guidance to implement \nexception-handling logic. 7. Conclusion and Future Work In this paper, we have presented a domain-speci.c \napproach to architecturing and supporting error handling. We have ex\u00adtended an ADL with error handling \ndeclarations and showed that these declarations facilitate the separation between error handling and \nthe application logic. We have demonstrated that our approach makes the programming of error handling \nmore rigorous and systematic. Our approach was successfully applied to the develop\u00adment of realistic \npervasive computing applications for man\u00adaging a building. We have illustrated our approach with three \napplications from this large project and discussed its bene\u00ad.ts. This work is being actively expanded \nin various direc\u00adtions. One of them consists of using fault tolerance strate\u00adgies at the architectural \nlevel to generate more support for error handling. Another direction is to widen the scope of our approach \nto other non-functional concerns like security and performance. Availability The tools from this paper \nare available at http://diasuite. inria.fr Acknowledgments We thank Damien Cassou and Benjamin Bertran \nfor devel\u00adoping DiaGen. We thank all the members of our research group for insightful discussions and \ncareful reading of ear\u00adlier versions of this paper. We thank R\u00e9mi Douence, Ju\u00adlia Lawall, Anne-Fran\u00e7oise \nLe Meur, and Jacques Noy\u00e9 for their helpful comments. We also thank the anonymous refer\u00adees for their \nvaluable feedback. Julien Mercadal is supported by a fellowship from the French ministry of research. \nReferences [1] Portland pattern repository, 1995. URL http://c2.com/ cgi/wiki?ExceptionPatterns. [2] \nG. Agha. Actors: a Model of Concurrent Computation in Distributed Systems. MIT Press, Cambridge, MA, \nUSA, 1986. ISBN 0-262-01092-5. [3] R. Allen and D. Garlan. A formal basis for architectural connection. \nACM Tansactions on Software Engineering and Methodology, 6(3):213 249, 1997. ISSN 1049-331X. doi: 10.1145/258077.258078. \n[4] J. Bruneau, W. Jouve, and C. Consel. DiaSim, a parameter\u00adized simulator for pervasive computing applications. \nIn Pro\u00adceedings of the 6th IEEE International Conference on Mobile and Ubiquitous Systems: Computing, \nNetworking and Ser\u00advices (Mobiquitous 09), Toronto, CAN, jul 2009. ICST/IEEE. [5] N. Cacho, F. C. Filho, \nA. Garcia, and E. Figueiredo. EJFlow: Taming exceptional control .ows in aspect-oriented program\u00adming. \nIn Proceedings of the 7th International Conference on Aspect-Oriented Software Development (AOSD 08), \npages 72 83, New York, NY, USA, 2008. ACM Press. ISBN 978-1\u00ad60558-044-9. doi: 10.1145/1353482.1353492. \n [6] D. Cassou, B. Bertran, N. Loriant, and C. Consel. A genera\u00adtive programming approach to developing \npervasive comput\u00ading systems. In Proceedings of the 8th International Confer\u00adence on Generative Programming \nand Component Engineer\u00ading (GPCE 09), pages 137 146, Denver, CO, USA, 2009. ACM Press. doi: 10.1145/1621607.1621629. \n[7] S. Chetan, A. Ranganathan, and R. Campbell. Towards Fault Tolerant Pervasive Computing. IEEE Technology \nand Society Magazine, 24(1):38 44, 2005. [8] E. Christensen, F. Curbera, G. Meredith, and S. Weerawarana. \nWeb Services Description Language (WSDL) 1.1, 2001. [9] W. W. W. Consortium. Web services architecture, \n2004. URL http://www.w3.org/TR/ws-arch/. [10] J. Dedecker, T. V. Cutsem, S. Mostinckx, T. D Hondt, and \nW. De Meuter. Ambient-oriented programming in Ambi\u00adentTalk. In Proceedings of the 20th European Conference \non Object-Oriented Programming (ECOOP 06), pages 230 254, Berlin, Heidelberg, 2006. Springer-Verlag. \nISBN 3-540\u00ad35726-2. [11] B. Demsky and A. Dash. Bristlecone: A language for ro\u00adbust software systems. \nIn Proceedings of the 22nd European Conference on Object-Oriented Programming (ECOOP 08), pages 490 515, \nBerlin, Heidelberg, 2008. Springer-Verlag. ISBN 978-3-540-70591-8. [12] A. K. Dey, G. D. Abowd, and D. \nSalber. A conceptual framework and a toolkit for supporting the rapid prototyping of context-aware applications. \nHuman-Computer Interaction, 16(2):97 166, 2001. ISSN 0737-0024. [13] T. B. Downing. Java RMI: Remote \nMethod Invocation. IDG Books Worldwide, Inc., Foster City, CA, USA, 1998. ISBN 0764580434. [14] P. Eugster, \nP. A. Felber, R. Guerraoui, and A.-M. Kermarrec. The many faces of publish/subscribe. ACM Computer Survey, \n35(2):114 131, 2003. ISSN 0360-0300. doi: 10.1145/857076. 857078. [15] F. C. Filho, P. H. Brito, and \nC. M. F. Rubira. Speci.cation of exception .ow in software architectures. Journal of Systems and Software, \n79(10):1397 1418, 2006. doi: 10.1016/j.jss. 2006.02.060. [16] D. Gelernter. Generative communication \nin Linda. ACM Transactions on Programming Languages and Systems, 7(1): 80 112, 1985. ISSN 0164-0925. \ndoi: 10.1145/2363.2433. [17] G. Kiczales, J. Lamping, A. Mendhekar, C. Maeda, C. V. Lopes, J.-M. Loingtier, \nand J. Irwin. Aspect-oriented pro\u00adgramming. In Proceedings of the 11th European Conference on Object-Oriented \nProgramming (ECOOP 97), pages 220 242, 1997. [18] R. Laddad. AspectJ in Action: Practical Aspect-Oriented \nProgramming. Manning Publications Co., Greenwich, CT, USA, 2003. ISBN 1930110936. [19] L. Lamport, R. \nShostak, and M. Pease. The Byzantine Gener\u00adals problem. ACM Transactions on Programming Languages and \nSystems, 4(3):382 401, 1982. ISSN 0164-0925. doi: 10.1145/357172.357176. [20] M. Lippert and C. V. Lopes. \nA study on exception detection and handling using aspect-oriented programming. In Proceed\u00adings of the \n22nd International Conference on Software Engi\u00adneering (ICSE 00), pages 418 427. ACM Press, 2000. [21] \nD. C. Luckham and J. Vera. An event-based architecture de.\u00adnition language. IEEE Transactions on Software \nEngineering, 21(9):717 734, Sept. 1995. doi: 10.1109/32.464548. [22] J. Magee and J. Kramer. Dynamic \nstructure in software ar\u00adchitectures. Proceedings of the 4th ACM SIGSOFT Sympo\u00adsium on Foundations of \nSoftware Engineering (SIGSOFT 96), 21(6):3 14, 1996. ISSN 0163-5948. doi: 10.1145/250707. 239104. [23] \nS. Mostinckx, J. Dedecker, E. G. Boix, T. V. Cutsem, and W. D. Meuter. Ambient-oriented exception handling. \nIn C. Dony, J. L. Knudsen, A. B. Romanovsky, and A. Tripathi, editors, Advanced Topics in Exception Handling \nTechniques, volume 4119 of Lecture Notes in Computer Science, pages 141 160. Springer, 2006. ISBN 3-540-37443-4. \n [24] OMG. The common Object Request Broker: Architecture and speci.cation. Technical Report 2.0, Object \nManagement Group, 1995. [25] T. Parr. The De.nitive ANTLR Reference: Building Domain-Speci.c Languages. \nThe Pragmatic Bookshelf, Raleigh, 2007. [26] S. R. Ponnekanti, B. Johanson, E. Kiciman, and A. Fox. Porta\u00adbility, \nextensibility and robustness in iROS. In Proceedings of the First IEEE International Conference on Pervasive \nCom\u00adputing and Communications (PerCom 03), page 11, Wash\u00adington, DC, USA, 2003. IEEE Computer Society. \nISBN 0\u00ad7695-1893-1. [27] G. R. One.world: Experiences with a pervasive computing architecture. IEEE Pervasive \nComputing, 3(3):22 30, 2004. ISSN 1536-1268. doi: 10.1109/MPRV.2004.1321024. [28] A. Ranganathan, S. \nChetan, J. Al-Muhtadi, R. H. Campbell, and M. D. Mickunas. Olympus: A high-level programming model for \npervasive computing environments. In Proceed\u00adings of the 3rd IEEE International Conference on Pervasive \nComputing and Communications (PerCom 05), pages 7 16, Washington, DC, USA, 2005. IEEE Computer Society. \nISBN 0-7695-2299-8. doi: 10.1109/PERCOM.2005.26. [29] M. Rom\u00e1n, C. Hess, R. Cerqueira, A. Ranganathan, \nR. H. Campbell, and K. Nahrstedt. A middleware infrastructure for active spaces. IEEE Pervasive Computing, \n1(4):74 83, 2002. ISSN 1536-1268. doi: 10.1109/MPRV.2002.1158281. [30] J. Rosenberg, H. Schulzrinne, \nG. Camarillo, A. Johnston, J. Peterson, R. Sparks, M. Handley, and E. Schooler. SIP: Session Initiation \nProtocol. Technical report, RFC 3261, Aug. 2002. URL http://www.ietf.org/rfc/rfc3261.txt. [31] R. N. \nTaylor, N. Medvidovic, and E. M. Dashofy. Software Architecture: Foundations, Theory, and Practice. Wiley \nPub\u00adlishing, 2009. ISBN 0470167742, 9780470167748.    \n\t\t\t", "proc_id": "1869459", "abstract": "<p>The challenging nature of error handling constantly escalates as a growing number of environments consists of networked devices and software components. In these environments, errors cover a uniquely large spectrum of situations related to each layer ranging from hardware to distributed platforms, to software components. Handling errors becomes a daunting task for programmers, whose outcome is unpredictable. Scaling up error handling requires to raise the level of abstraction beyond the code level and the try-catch construct, approaching error handling at the software architecture level.</p> <p>We propose a novel approach that relies on an Architecture Description Language (ADL), which is extended with error-handling declarations. To further raise the level of abstraction, our approach revolves around a domain-specific architectural pattern commonly used in pervasive computing. Error handling is decomposed into components dedicated to platform-wide, error-recovery strategies. At the application level, descriptions of functional components include declarations dedicated to error handling.</p> <p>We have implemented a compiler for an ADL extended with error-handling declarations. It produces customized programming frameworks that drive and support the programming of error handling. Our approach has been validated with a variety of applications for building automation.</p>", "authors": [{"name": "Julien Mercadal", "author_profile_id": "81381604111", "affiliation": "INRIA/LaBRI, Bordeaux, France", "person_id": "P2354005", "email_address": "", "orcid_id": ""}, {"name": "Quentin Enard", "author_profile_id": "81470654792", "affiliation": "INRIA/Thales, Bordeaux, France", "person_id": "P2354006", "email_address": "", "orcid_id": ""}, {"name": "Charles Consel", "author_profile_id": "81100552270", "affiliation": "INRIA/LaBRI/ENSEIRB, Bordeaux, France", "person_id": "P2354007", "email_address": "", "orcid_id": ""}, {"name": "Nicolas Loriant", "author_profile_id": "81100190816", "affiliation": "INRIA, Bordeaux, France", "person_id": "P2354008", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869465", "year": "2010", "article_id": "1869465", "conference": "OOPSLA", "title": "A domain-specific approach to architecturing error handling in pervasive computing", "url": "http://dl.acm.org/citation.cfm?id=1869465"}