{"article_publication_date": "10-17-2010", "fulltext": "\n Homogeneous Family Sharing Xin Qi Facebook Inc. xqi@facebook.com Abstract Recent work has introduced \nclass sharing as a mechanism for adapting a family of related classes with new functional\u00adity. This paper \nintroduces homogeneous family sharing, im\u00adplemented in the J&#38;h language, in which the sharing mecha\u00adnism \nis lifted from class-level sharing to true family-level sharing. Compared to the original (heterogeneous) \nclass sharing mechanism, homogeneous family sharing provides useful new functionality and substantially \nreduces the an\u00adnotation burden on programmers by eliminating the need for masked types and sharing declarations. \nThis is achieved through a new mechanism, shadow classes, which permit ho\u00admogeneous sharing of all related \nclasses in shared families. The new sharing mechanism has a straightforward seman\u00adtics, which is formalized \nin the J&#38;h calculus. The soundness of the J&#38;h type system is proved. The J&#38;h language is \nim\u00adplemented as an extension to the J&#38; language. To demon\u00adstrate the effectiveness of family sharing, \nthe Polyglot com\u00adpiler framework is ported to J&#38;h. Categories and Subject Descriptors D.3.2 [Language \nClassi.cations]: Object-oriented languages; D.3.3 [Lan\u00adguage Constructs and Features]: Classes and objects, \nframe\u00adworks, inheritance, modules, packages General Terms Languages Keywords family inheritance, views, \nshadow classes 1. Introduction The goal of adaptation is to add new functionality to existing objects \nwithout modifying the original class de.nition. The premise of this work is that language support for \nadaptation provides expressiveness needed for the extension, evolution, and reuse of software systems, \nso programmers can build extensible systems from code that is simpler and clearer. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA/SPLASH 10, October \n17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright c . 2010 ACM 978-1-4503-0203-6/10/10. . . $10.00 Andrew \nC. Myers Department of Computer Science Cornell University andru@cs.cornell.edu The adapter design pattern \n[17] supports limited forms of adaptation, but it adapts only a single object at a time. In general, \nprogram behavior is implemented by data structures composed of interacting objects. Adapting program \nbehav\u00adior to add new functionality therefore requires coordinated changes to objects in multiple, related \nclasses. However, most language mechanisms that support adaptation, such as open classes [10], aspect \nbinders [23], classboxes [3], and expanders [45] operate on individual classes and con\u00adsequently cannot \nsupport these coordinated changes. In the context of inheritance rather than adaptation, co\u00adordinated \nchanges to multiple classes are supported by fam\u00adily inheritance mechanisms developed in recent work, \ne.g., [15, 20, 22, 28, 30]. Family inheritance enables a group of classes contained in a common namespace \nthe base family to be extended together to form a new group of new classes the derived family while preserving \nthe relation\u00adships that the classes had in the base family. In this work, we build on the family inheritance \nmechanism of nested inheri\u00adtance [28]. However, family inheritance does not support adaptation, because \ninheritance does not affect the objects of the base family. The new mechanism introduced in this paper, \nho\u00admogeneous family sharing, does support adaptation at the family level. With homogeneous family sharing, \na derived family may be declared to share with a base family. Just as with nested inheritance, the derived \nfamily inherits from the base family. Unlike nested inheritance, the base family also inherits from the \nderived family, acquiring any new function\u00adality that the derived family adds. Thus, sharing is a bidirec\u00adtional \ninheritance mechanism. New functionality, new state, and even new classes introduced in the derived family \nare also present in the base family. Homogeneous family sharing gives the ability to adapt families of \ninteracting classes in a type-safe, modular way. It enables new ways to safely extend software systems, \neven at run time as dynamic updates. This paper introduces homo\u00adgeneous family sharing in the J&#38;h \nlanguage1, which extends the J&#38; language [30]. Class sharing as an adaptation mechanism was .rst \nin\u00adtroduced in the J&#38;s language [36]. In J&#38;s, sharing is a re\u00ad 1 pronounced jet-h  lationship \nbetween individual classes, with some coordina\u00adtion at the family level. Unlike with homogeneous sharing, \nJ&#38;s families need not share all of their nested classes; we call this heterogeneous sharing because \nclasses are not uni\u00adformly shared between families. This work addresses some of the shortcomings of heterogeneous \nsharing. The principle of scalable extensibility [28] says that the code needed to make a change should \nbe proportional to the change in functionality. One shortcoming of heterogeneous sharing is a lack of \nscalability that arises because, in general, sharing must be declared for each class individually. Homo\u00adgeneous \nfamily sharing is more scalable because sharing can be declared at the family level. A second shortcoming \nof heterogeneous sharing is that to handle unshared classes safely, additional type-level mecha\u00adnisms \nare needed: masked types [35] and sharing constraints. By contrast, in homogeneously shared families, \nall classes and all inheritance and sharing relationships are shared. As a result, J&#38;h programs have \nlighter-weight type annotations than in J&#38;s; in particular, J&#38;h dispenses with masked types and \nsharing constraints. The contributions of this paper are, in summary: A clean generalization of sharing \nto families of classes. Compared to the previous work on heterogeneous class sharing, homogeneous family \nsharing offers simpler typ\u00ading mechanisms, requires simpler reasoning from pro\u00adgrammers, and improves \nscalable extensibility.  Shadow classes, a new mechanism needed for safe ho\u00admogeneous sharing. Shadow \nclasses also provide a new kind of extensibility unavailable in previous work: anal\u00adogously to open classes \n[10], families become open, al\u00adlowing nested classes to be added without modifying the code of the family. \n A core language for homogeneous sharing, which is sig\u00adni.cantly simpler than the J&#38;s calculus, \nand a proof of the soundness of its type system.  An ef.cient implementation of homogeneous sharing, \nsupporting shadow classes.  An description of how to use J&#38;h to implement various kind of extensibility, \nand a report on experience using J&#38;h to build a version of the Polyglot compiler frame\u00adwork [29]. \n The rest of the paper is organized as follows. Section 2 in\u00adtroduces sharing for individual classes. \nSection 3 describes the core mechanisms underlying homogeneous family shar\u00ading. Section 4 formalizes \nthe semantics of family sharing, and sketches the proof of soundness. Full proofs are avail\u00adable elsewhere \n[38]. Section 5 presents the language imple\u00admentation, and Section 6 describes experience with it. Sec\u00adtion \n7 discusses related work, and Section 8 concludes. class Button { void draw(...) { ... } } class PrettyButton \nextends Button { void draw(...) { ... draw the shadow ... } } Figure 1. A GUI button class and its extension \n2. Sharing and adaptation 2.1 From inheritance to sharing In an object-oriented language, inheritance \noffers a way to reuse and extend existing code. For example, in the Java code of Figure 1, a graphical \nuser interface (GUI) library contains a Button class with a method draw for drawing the button. Suppose \nthe programmer wants but\u00adtons with a shadow underneath. The programmer could declare a PrettyButton class \nthat extends the original Button class through inheritance. In Figure 1, the subclass PrettyButton overrides \nthe draw method, originally in\u00adtroduced in the superclass Button, so that when the draw method is called \non an object of PrettyButton, the over\u00adriding version in the subclass is executed. However, inheritance \ndoes not make the new shadow functionality available to the objects of the existing Button class. An \napplication that creates instances of the Button class cannot enjoy the prettier GUI element without \ncode changes, nor can a running application with Button objects be easily upgraded to the new look. Adaptation \nis the ability to augment existing objects with new functionality. The adapter design pattern [17] uses \nwrappers to implement adaptation, but in general, it requires the programmer to write error-prone code \nrelying on stati\u00adcally unsafe type casts. The programmer also has to man\u00adually manage the relationship \nbetween the wrapper and the adapted object, which becomes especially awkward for data structures made \nof objects requiring adaptation. Sharing provides a language-based solution to the prob\u00adlem of adaptation. \nIn J&#38;h, the new PrettyButton class may be declared to share with the Button class, rather than to \nin\u00adherit it: class PrettyButton shares Button { ... } The meaning of the declaration is twofold: .rst, \nthat PrettyButton is a subtype of Button, just as with or\u00addinary inheritance; but second, that every \nButton object is also an object of PrettyButton. Because Button and PrettyButton share the same set of \nobject instances, the functionality implemented in PrettyButton is available to every object of Button \neven to objects created before PrettyButton was loaded into a running program when the programmer explicitly \nchanges the view from Button to PrettyButton on the object.  An object of either of the two classes \ninherits function\u00adality from the other class, and each class may also override the other. Although classes \nshare the same instances, the be\u00adhavior of an object depends on which class an object is be\u00ading viewed \nfrom. If viewed as a Button, an object created as a PrettyButton may still access the original version \nof the draw method. Sharing provides bidirectional adaptation while preserving object identity. A sharing \ndeclaration establishes a sharing relationship between the two classes. All the sharing declarations \nto\u00adgether induce an equivalence relation on classes that is the re.exive, symmetric, and transitive closure \nof the declared sharing relationships. We write T1 . T2 for two types that are (transitively) shared. \nTo represent a sharing relationship that holds between just the two classes A and B but not be\u00adtween \nany subclasses of A or B, we use exact types [5]. The exact type A! represents just A, but not its subclasses. \nThere\u00adfore Button! . PrettyButton! signi.es a sharing rela\u00adtionship on just these two classes. Class \nsharing was introduced in J&#38;s [36], but its origi\u00adnal, heterogeneous form has limitations: .rst, \nJ&#38;s only al\u00adlows sharing between corresponding classes classes of the same name and related through \noverriding from different families. Second, unlike family sharing in J&#38;h, class shar\u00ading in J&#38;s \nis a relationship on the shared classes themselves; it does not cause sharing of classes nested inside \nthe shar\u00ading classes. The homogeneous sharing mechanism proposed in this paper removes both of these \nlimitations, and thereby adds expressive power.  2.2 Views and view changes When two classes are shared, \nan instance of either is also an instance of the other. Each class is a distinct view of that object, \nwhich de.nes the run-time behavior of the object. At run time, an object reference may be modeled as \na pair ..,C!. of a heap location . and an exact type C! specifying the view. The view controls how methods \nare dispatched on the object being accessed through the reference. For example, an object created as \na Button would use the overriding version of the draw method if accessed through a reference with the \nview PrettyButton!. One object may simultaneously have several references, each with a different view. \nFor an object to obtain a new reference with a new view, we use a view change operation, written (view \nT )e, where T is the target type, and e is the source expression. For example, a Button object may obtain \na new reference b2, through which the new draw method can be called, although the receiver object is \nstill the same: Button! b1 = new Button(...); PrettyButton! b2 = (view PrettyButton!)b1; b1.draw(...); \n// the old draw method in Button b2.draw(...); // the new draw method in PrettyButton package GUI; class \nButton {...} class RadioButton extends Button {...} class Window { Button close; ... } ... package xlucentGUI \nextends GUI; class Button { void draw(...) {...} } class Window { void draw(...) {...} } ... Figure 2. \nA base GUI family and an extension Although view changes look like dynamic type casts, view change operations \nare type-safe. They are type-checked statically using the sharing relation. In J&#38;h, a reference ..,C!. \nis a .rst-class value whose view component C! is determined dynamically. For example, after the view \nchange above, if the value in b2 is passed to code expecting type Button, the value will still behave \nas an object of PrettyButton: class Renderer { void render(Button b) { b.draw(...); } } ... Renderer \nr; r.render(b2); // the PrettyButton draw method is called // from render() Therefore, view changes may \nupdate the behavior of an existing object, even when, as in the body of render, the new shared class \nis not statically in scope. In both J&#38;s and J&#38;h, a concrete (i.e., not abstract) class cannot \nbe declared to share with an abstract class or an interface. This restriction ensures that an object \nhas only concrete views, and therefore view-based method dispatch does not have message-not-understood \nerrors. 3. Homogeneous family sharing 3.1 Family inheritance Homogeneous family sharing builds on prior \nfamily-level extensibility mechanisms: nested inheritance [28] and nested intersection [30]. Nested inheritance \nis inheritance at the granularity of a namespace (a package or a class), which de.nes a family in which \nrelated classes are grouped. When a namespace inherits from another (base) namespace, all the namespaces \nnested in the base namespace are inherited, and the derived namespace can override, or further bind [21] \nin\u00adherited namespaces, changing nested class declarations, sim\u00adilarly to virtual classes [9, 13, 16, \n21, 22]. Nested intersec\u00adtion supports composing families with generalized intersec\u00adtion types [11, 39] \n a mechanism for multiple inheritance at the family level.  Family inheritance is useful, because in \nreal software sys\u00adtems, the functionality that needs to be extended often spans multiple classes that \nare related to each other through either inheritance or mutual references. For example, as in Fig\u00adure \n2, the GUI library should also include classes for vari\u00adous GUI elements, including the Button class \nof Figure 1. Suppose we want to extend the entire GUI library to support translucent widgets. With the \nJ&#38;h language, the extension can be declared at the family level, as shown on the bottom of Figure \n2. Every class in the base package GUI has a cor\u00adresponding subclass with the same class name in the \nderived package xlucentGUI. J&#38;h supports scalable extensibility [28], because there is no need to \ndeclare cross-family inheritance for individual classes, and the code that needs to be written in the \nderived family is proportional to the changes in functionality. The relationships between classes in \nGUI are preserved in xlucentGUI with late binding of type names. For example, the Window class has a \n.eld for a button named close, with type Button. In GUI.Window, the name Button refers to the Button \nclass in GUI, whereas in xlucentGUI.Window, it refers to the corresponding class of xlucentGUI. Even \nclasses that are not mentioned explicitly in the derived name\u00adspace are inherited as implicit classes \nto which late binding applies. For example, package xlucentGUI contains an im\u00adplicit class RadioButton \nwhose superclass is the Button in xlucentGUI rather than the one in GUI. The type safety of late-bound \ntype names is ensured with pre.x types and dependent classes: in GUI.Window, the unquali.ed .eld type \nButton is sugar for the pre.x type GUI[this.class].Button, which means that the package containing Button \nis a subtype of GUI that encloses the run\u00adtime class of the special variable this. By indexing the class \nof close by the Window object that points to it, we ensure that the window and its close button always \ncome from the same family. J&#38;h preserves all three kinds of relationships in the de\u00adrived family: \nreferencing, subclassing, and sharing. Because class sharing in J&#38;s is heterogeneous, sharing relationships \nare not guaranteed to be preserved; therefore, J&#38;s requires sharing constraints for type safety. \n 3.2 Family sharing Homogeneous family sharing generalizes sharing to family granularity analogously \nto the way that nested inheritance generalizes inheritance to the family granularity. For exam\u00adple, in \norder to adapt existing objects from the GUI family with the new drawing methods declared in xlucentGUI, \nthe following family sharing declaration may be used, with the rest of the code shown in Figure 2 remaining \nthe same: package xlucentGUI shares GUI; With the sharing declaration, xlucentGUI is a derived family \nof GUI, just as with the inheritance declaration in Figure 2. Therefore, the shared derived family xlucentGUI \ninherits all the nested classes from the base family GUI, and preserves all the relationships among them, \ninclud\u00ading sharing relationships. If the GUI package contains a PrettyButton class that shares with Button, \nthen they are still shared in the xlucentGUI package. The difference from nested inheritance is that \ncorrespond\u00ading classes from the two families (e.g., GUI.Button and xlucentGUI.Button) also become shared, \nand therefore objects of classes from one family are also instances of classes from the other family. \nView changes can be used to move an object from one family to another. For example, a Window object from \nthe GUI family acquires translucency when viewed from the xlucentGUI family: GUI!.Window w1 = ...; xlucentGUI!.Window \nw2 = (view xlucentGUI!.Window)w1; Moreover, .eld accesses in J&#38;h automatically and lazily trigger \nimplicit view changes. Therefore, any object reach\u00adable from the Window object (e.g., the one stored \nin the .eld close in the Window class) will also obtain a view in xlucentGUI, when it is accessed. In \nJ&#38;h, a sharing relationship between two namespaces recursively applies to all their corresponding \nnested name\u00adspaces. Thus family sharing is homogeneous. This compares to the heterogeneous class sharing \n[36], which is declared for individual pairs of classes between two families. The J&#38;s language does \nprovide an adapts declaration as syn\u00adtactic sugar for declaring sharing between all corresponding classes \nof two families, but this only causes sharing one level down, rather than recursively, and can only be \nused when the families agree completely on the set of nested classes. Having homogeneous sharing at the \nfamily level allows the J&#38;h type system to be modularly type-safe without com\u00adplicated mechanisms \nlike masked types and sharing con\u00adstraints [36], simplifying programming.  3.3 Shadow classes and shadow \nmethods Shadow classes are the key to homogeneous sharing. In the J&#38;h language, a derived family \nmay introduce new nested classes not present in a shared base family. In order to keep view changes type-safe, \nthese new nested classes in general need to be shared as well. Shadow classes are introduced in the base \nfamily to make this possible. Figure 3 shows a simple example that illustrates the situ\u00adation. The derived \nfamily enclosed in A2 is shared with the base family in A1. Class A2 inherits the nested class B from \nA1, and introduces a new class C that is a subclass of A2.B. Because sharing is homogeneous, the two \ntypes A1!.B and A2!.B are shared, and therefore a view change from A2!.B to A1!.B is allowed. But as \nshown in following code, the source expression b2 with static type A2!.B may actually refer to an object \nof class A2.C at run time. A2!.B b2 = new A2.C(); A1!.B b1 = (view A1!.B)b2; b1.m(); // invokes the shadow \nmethod  class A1 { class B { void m() {...} } } class A2 shares A1 { class C extends B { // adds shadow \nclass in A1 shadow void m() {...} // a shadow method } } Figure 3. Shadow classes and shadow methods \nFor the view change to work, A1 must contain a class shared with A2.C. J&#38;h introduces shadow classes \nto enable view changes like this one. When a shared derived family (e.g., A2) adds a new nested class \n(e.g., A2.C), the base family also acquires a class with the same name (here, A1.C). The derived family \nintroducing the new nested class is called the originating family for the shadow class, and the nested \nclass is called the originating class. The shadow class is shared with its originating class, and inherits \nall the .elds and relationships from the originating family. Thus, the shadow class is a class that the \nbase family inherits from the derived family. The J&#38;h language not only supports enhancing the shared \nbase family with new shadow classes, but also allows the programmer to de.ne how the shadow class should \nbehave in the base family. The originating class may declare shadow methods, with the modi.er shadow. \nThe semantics of a shadow method is as if it were de.ned within an explicit declaration of the shadow \nclass in the base family. As a result, A2.C in Figure 3 could also declare its own version of method \nm() without the shadow keyword. This vesion would override the shadow method as if it had been inherited \nfrom the shadow class A1.C. On the other hand, there is no need to declare shadow .elds , because the \nshadow class shares all .elds declared in the originating class.  3.4 Modular type checking of shadow \nclasses Because shadow classes are not explicitly declared with a class body, the type system needs to \nknow the originating class before a shadow class is mentioned. For example, in\u00adside class A1 in Figure \n3, the type name C is meaningless if A2 has not been created. Modularity of the type system re\u00adquires \nthat a base family can be type-checked without know\u00ading derived families, unless they are used explicitly \nby the base family. Therefore, if the code in A1 does not explicitly use the shadow class, the compiler \nshould be able to type\u00adcheck A1 without knowing about A2.C. J&#38;h ensures the modularity of the type \nsystem by dis\u00adallowing direct naming of a shadow class in source code. For example, given the declarations \nin Figure 3, one cannot mention A1.C, the fully quali.ed name of the shadow class, anywhere in the source \ncode, nor can one mention just C in the context of A1. Instead, the language overloads the dis\u00adambiguation \nusage of pre.x types [30] to provide an indirect way of naming a shadow class that embeds the name of \nthe originating class. In the J&#38;h source code, a shadow class is referred to as P[T ].C, where P \nis the originating family, T is a type in the same family as the shadow class, including the family itself, \nand C is the simple name of the originat\u00ading class. Therefore, the shadow class in Figure 3 may be denoted \nas A2[A1.B].C or just A2[A1].C. This scheme also solves the problem of accidental name con.icts between \nshadow classes. Suppose that in addition to the declarations in Figure 3, there is another shared de\u00adrived \nfamily A3, which introduces a new nested class that happens to be named C as well: class A3 shares A1 \n{ class C extends B {...} } Then there will be two different shadow classes in A1 with the same name \nC it is not sensible to combine them into one shadow class and there is no modular way to de\u00adtect this \nsituation. However, indirect naming in J&#38;h pre\u00advents the potential name con.ict, by naming the two \nshadow classes differently, as A2[A1.B].C and A3[A1.B].C respec\u00adtively. Therefore, the two (unrelated) \nshadow classes can be used independently of each other. (The J&#38;h compiler also mangles the names \nof the two shadow classes differently.) Although the syntax for naming shadow classes looks somewhat \nheavy, it is unlikely to be used frequently (see Section 3.5 for an example of the syntax). We expect \nshadow classes normally to be used as a way to introduce new sub\u00adclasses of some known, ordinary class \nin the base family. The base family would generally use objects of the shadow class through the known \nsuperclass, without explicitly men\u00adtioning the shadow class. The pre.x syntax is also not nec\u00adessary \nin the originating family, including inside the decla\u00adration of a shadow method, where the syntax coincides \nwith the automatic desugaring of unquali.ed type names.  3.5 Open families Shadow classes and shadow \nmethods provide a new kind of extensibility: open families, which are analogous to open classes [10]. \nAn existing family can be extended in a modu\u00adlar way with new functionality, including new classes, with\u00adout \nmodifying the code of the family. This contrasts both with heterogeneous sharing [36] and with nested \ninheri\u00adtance [30], where families are locally closed worlds that can\u00adnot be extended with new nested \nclasses without modifying existing code. This kind of extensibility is different from sharing-based adaptation, \nwhich modularly adds new functionality to ob\u00adjects that belong to an existing family, but makes new be\u00adhavior \naccessible only by viewing the objects in the shared derived family. By contrast, shadow classes are \navailable in the base family. For example, the shadow method m() de\u00adclared by A2.C in Figure 3 may be \ninvoked through a re\u00adFigure 4. Sketch of the IMP compiler structure. Shadow classes in dashed boxes. \n  ceiver object of static type A1!.B de.nitely in the base family if the receiver object is an instance \nof the shadow class A2[A1.B].C.  3.6 Example: in-place translation To show the extensibility provided \nby homogeneous sharing and open families, let us consider using them to build a simple language translation. \nA compiler built using many passes often includes translation passes that leave most of the abstract \nsyntax tree (AST) alone. One would like to avoid creating an entirely new AST for the target language, \nbut this is not possible if the source and target of the translation have different AST types. In-place \ntranslation solves this problem. If the source family and the target family are shared, one can simply \napply view changes to objects that do not need translation, avoiding the generation of many new objects, \nwhile still ensuring the entire data structure behaves consistently in the target family. Figure 4 sketches \nthe class hierarchy of a compiler for a small imperative language and two extensions. The base family \nIMP describes a simple core language with\u00adout any loop construct. The two derived families IMP for and \nIMP while respectively extend IMP with for-loops and while-loops. The compiler translates a program from \nIMP for to IMP while, rewriting for-loops to while-loops. Figure 5 illustrates J&#38;h code that does \nin-place transla\u00adtion from IMP for to IMP while. The two derived families are both shared with the base \nfamily IMP, and by transi\u00adtivity, they are also shared with each other. The class For in IMP for and \nthe class While in IMP while both intro\u00adduce shadow classes in IMP, which are then inherited by the other \nderived family. On line 31, with the syntax described in Section 3.4, the type IMP while[this.class].While \nrep\u00adresents the shadow class While in the IMP for family. This allows the translation code to safely \ngenerate an While ob\u00adject still in the IMP for family. Translation of If (lines 19 24) lazily generates \na new If node only if its children have changed. After the recursive translation is done on an AST, 1 \n2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package IMP; \nabstract class Node { ... } ... class If extends Stmt { Exp cond; Stmt body; If(cond, body) { this.cond \n= cond; this.body = body; } } package IMP_for shares IMP; abstract class Node { Node translate() { return \nthis; // by default, no translation } } class If extends Stmt { Stmt translate() { // covariant return \ntype Exp cond = this.cond.translate(); Stmt body = this.body.translate(); if (cond != this.cond || body \n!= this.body) return new If(cond, body); else return this; } } class For extends Stmt { Exp init, cond, \ninc; Stmt body; Stmt translate() {  ... new IMP_while[this.class].While(...); ... } } Figure 5. In-place \ntranslation for loop statements a single view change operation applied to the root moves the entire AST \nto the IMP while family: IMP_for!.Node source = ...; IMP_for!.Node temp = source.translate(); IMP_while!.Node \ntarget = (view IMP_while!.Node)temp; In this example, the use of shadow classes facilitates the translation, \nwhich goes directly between two sibling fam\u00adilies. Heterogeneous sharing, and other adaptation mecha\u00adnisms, \ncannot support in-place translation across the hierar\u00adchy of familes.  3.7 Homogeneous vs. heterogeneous \nsharing Homogeneous family sharing has several advantages over heterogeneous sharing: Scalable sharing. \nThere is no need to declare sharing for individual pairs of classes from two different families, which \ncan be tedious and result in errors. This also makes the sharing mechanism more scalable, because if \na class only needs to be shared but not overridden, its declaration may be omitted from the source code \nof the derived family.  Modular type checking with reduced annotation burden. In particular, homogeneous \nsharing does not require sharing constraints, because it is easier to prove that two types are shared. \nIf two types T1 and T2 are shared, all corresponding nested types are also shared, that is, T1.C . T2.C. \nFor example, a variable b1 of type GUI!.Button might point to an object of the GUI.RadioButton class \nor to one of the GUI.PrettyButton class. In either case, the view change (view xlucentGUI!.Button)b1 \nis type-safe, be\u00adcause sharing is declared between GUI and xlucentGUI and therefore, all classes in GUI \nthat are subtypes of GUI!.Button have shared counterparts in xlucentGUI. On the contrary, with heterogeneous \nsharing, in order to prove that a view change (view T )e is valid, the type system has to inspect all \nthe subclasses of both the source type (the type of e) and the target type T , and it has to recheck \nthe view change every time the code is inherited by a different family. Therefore, heterogeneous sharing \nin J&#38;s uses sharing con\u00adstraints to make type-checking modular. With homogeneous sharing, these constraints \nare super.uous. Straightforward support for coordinated view changes on interconnected objects. As in \nheterogeneous sharing, .eld accesses in J&#38;h trigger implicit view changes, which allows a data structure \nconsisting of multiple interconnected objects to safely change its view from one family to another. However, \nin heterogeneous sharing, a shared class may contain a .eld with an unshared type often as the result \nof a new class in the derived family (e.g., the For class in Figure 18) in which case the .eld actually \nhas several du\u00adplicates, one for each class that is shared with the class that declares the .eld. Masked \ntypes are used to ensure unshared objects stored in these .elds do not leak into incompatible families. \nThis adds to the annotation burden, and compli\u00adcates reasoning about the code. Homogeneous family shar\u00ading \ndoes not need masked types for this purpose, because shadow classes ensure that a data structure can \nalways be homogeneously moved to a shared family. The compiler example of Section 3.6 shows that J&#38;h \npresents a different trade-off in language design than J&#38;s. The type system of heterogeneous sharing \nin J&#38;s does more checking to prevent objects from leaking into other fami\u00adlies by mistake. For example, \nif a translation from IMP for to IMP is implemented in J&#38;s, the type system would en\u00adsure that no \nFor object is left untranslated in the target AST. However, J&#38;s achieves this family-closedness guarantee \nat the expense of heavyweight language mechanisms like shar\u00ading constraints and masked types. J&#38;h \ninstead introduces shadow classes to ensure that shared families always have homogeneous structures. \nAl\u00adthough a view change is guaranteed to move a data structure completely into the new family from the \ntype perspective, the type system no longer checks for un.nished translation. For example, if a For object \nis left untranslated, it will end up as an object of the shadow class For in the target family programs \nPr ::= .L, e. class declarations L ::= class C ES {LFM} superclass declarations ES ::= extends T | shares \nT .eld declarations F ::=[final] Tf = e method declarations M ::=[shadow] Tm(Tx) {e} types T ::= .| \n. | T.C | p.class | P[T ] | T ! classes P ::= .| . | P.C values v ::= ..,P!. access paths p ::= v | x \n| p. f expressions e ::= v | x | e. f | e0. f = e1 | e0.m(e) | e1; e2 | new T ( f = e) | (view T )e \ntyping environments G ::= 0/ | G, x:T | G, p1 = p2 Figure 6. Syntax of J&#38;h either IMP or IMP while \nbut this is still type-safe in J&#38;h. The payoff is a simpler, easier-to-use language. Moreover, shadow \nclasses also introduces a new kind of extensibility, as shown in Section 3.5. Therefore, we believe homogeneous \nsharing makes a better trade-off for most applications. 4. Formal semantics This section formalizes homogeneous \nfamily sharing in the J&#38;h calculus. Not all the features of the J&#38;h language are modeled in J&#38;h \ncalculus, in order to focus on sharing. For example, virtual types, explicit multiple inheritance and \nin\u00adtersection types are omitted. 4.1 Syntax Figure 6 shows the syntax of the J&#38;h calculus. The notation \na is used for both the list a1,...,an and the set {a1,...,an}, for n = 0,and #(a) represents the size \nof a. A program Pr is a pair .L,e. of a set of class declarations L and an expression e (the main method). \nEach class C has a superclass declaration, which is either a normal superclass declaration extends T \n, or a shared superclass declaration shares T . Note that there is only one superclass, because J&#38;h \nonly models single inheritance. There are two special classes: . is the superclass of all the other classes, \nsimilar to Object in Java; . is the single top-level class that all other classes are nested within. \nMethod declarations may have an extra modi.er shadow for declaring shadow methods. Fields may be declared \nfinal, which means they cannot be changed after initial\u00adization, as in Java. J&#38;h supports explicit \nexact types, and exactness applies to the entire type preceding the symbol ! . T !.C! is con\u00adsidered \nequivalent to T.C!, and T ! is equivalent to T if T is already exact. A value v, also called a reference, \nis a pair of a heap location . and the associated view P!, which is a class in its exact form. Expressions \nare mostly standard, with the addition of a view change operation (view T )e.  Shared subclassing . \nP1 .P2 . super(P.C)= shares T . P1 .* PT { 0/; P1/this} = P2 (SHARE-DECL) . P1.C . . P2 . P1 . P2 . (SHARE-FB) \n. P1.C . P2.C . Subclassing . P1 .P2 super(P.C)= extends T . P1 .* PT { 0/; P1/this} = P2 (SC-DECL) . \nP1.C .P2 . P1 .P2 (SC-FB) . P1.C .P2.C . P1 . . P2 (SC-SHARE) . P1 .P2 Figure 7. Sharing and subclassing \nFor simplicity, we omit the null value from the J&#38;h calculus, and require that all .eld declarations \ncome with default initializations. The typing environment contains aliasing information about access \npaths. An entry p1 = p2 means p1 and p2 are aliases that also have the same run-time view. As in [9], \nthis kind of information is just used by the soundness proof.  4.2 Sharing and subclassing Subclassing \nrelationships among classes are de.ned in Fig\u00adure 7. The judgment . P1 .P2 states that P1 is a shared \nsub\u00ad . class of P2. With homogeneous family sharing, when two classes are declared to be shared, all \nthe nested classes are also automatically shared, according to SHARE-FB. On the other hand, . P1 .P2 \nstates that P1 is a subclass of P2, either shared or not.  4.3 Lookup functions The class table CT, \nde.ned in Figure 8, contains the decla\u00adration for any explicit or implicit class that is not a shadow \nclass. The extended class table CT. contains synthesized declarations for all the shadow classes, in \naddition to the declarations in CT. CT.-SHADOW introduces a shadow class P.C in every shared superclass \nP of P., if P. declares a nested class C. Note that the originating class P. .C must not be inherited \nfrom any (direct or overriding) superclass of P.. CT.-PROP states that shadow classes are also inherited, \nwhich allows them to be propagated to sibling families, as Class table CT(P) Pr = .L, e. (CT-OUT) CT(.)= \nclass . extends .{L} CT(P)= class C. ES {LFM}Li = class C ... (CT-EXP) CT(P.C)= Li CT(P)= class C. ... \n{LFM} class C ... .. L . P .P. CT(P. .C)= class C ES {...} (CT-IMP) CT(P.C)= class C ES {} Extended class \ntable CT.(P) CT(P) . = . (CT.-NORM) CT.(P)= CT(P) . P. .* P . CT(P. .C)= class C ES {LFM}.P.. . P. .P.. \n. CT (P.. ..C)= . M. = shadowMethods(P. .C) (CT.-SHADOW) CT.(P.C)= class C ES {M.} CT(P.C)= .. P .* \nP. CT.(P. .C)= class C ES {...} (CT.-PROP) CT .(P.C)= class C ES {} Figure 8. Class lookup illustrated \nin Section 3.5. Both CT and CT. are assumed to be global information. Figure 9 shows auxiliary functions \nfor looking up vari\u00adous class members like .elds and methods: super(P) gives the superclass declaration \nof P, either a normal superclass or a shared one; shadowMethods(P) collects all the shadow method declarations \nfrom P, with the shadow modi.er re\u00admoved; the functions .elds(P) and methods(P) collect all the .eld \nand method declarations from P and its super\u00adclasses; fnames(F) is the set of all .eld names in .eld \ndec\u00adlarations F; ftypedecl (G,T, f ) returns the declared type of .eld f , which might be a type dependent \non this, and whether the .eld is .nal or not; ftype(G,T, f ) substitutes the receiver type T for this.class; \nmbodies(P,m) looks up all the declarations of a method m that are not overrid\u00adden; mtype(G,T,m) looks \nup the method signature. For any well-typed class P, mbodies(P,m) never contains more than one element \n(see L-OK in Figure 13). Note that although shadow methods do not appear in ownMethods(P) of their declaring \nclass P, they are concep\u00adtually treated as normal methods declared in shadow classes originated from \nP, and then inherited and invoked just as  Member lookup pre.xExactk(.)= false pre.xExactk(.)= true \nCT.(P)= class C ES {LFM} super(P)= ES ownFields(P)= F false if k = 0 pre.xExactk(T.C)= pre.xExactk-1(T \n) otherwise ownMethods(P)= M - shadowMethods(M) pre.xExactk(p.class)= trueshadowMethods(P)= {M.| shadow \nM.. M} pre.xExactk(P[T ])= pre.xExactk+1(T ) pre.xExactk(T !)= true Figure 10. Pre.x exactness [ .elds(P)= \nownFields(Pi) .P.*Pi [ methods(P)= ownMethods(Pi) .P.*Pi F =[final] Tf = e fnames(F)= f G . T . P .elds(P)= \nF Fi =[final] Tf f = e ftypedecl (G, T, f )=[final] Tf  4.4 Pre.x types A non-dependent pre.x type P[P.] \nsigni.es either a sub\u00adclass of P in which P. is nested, or a shared superclass of P in which P. is nested, \nas captured in the auxiliary func\u00adtion pre.x(P,P.). J&#38;h generalizes pre.x types to include the second \ncase, for naming shadow classes (see Section 3.4). [final] T decl = ftypedecl (G,T, f ) f ftype(G,T, \nf )= T decl { G; T /this}  f pre.x(P,P.)= . .. .. P.. P.. * P.. if P. = P.. .C.. P . . . if P. = P.. \n.C.. P.. .* P otherwise Mi = ... m(...) ... Mi . ownMethods(Pi) .P. . P .* P. .+ Pi . ... m(...) ... \n.. ownMethods(P.) As in [31], we only consider pre.x types P[T ] where the index T is exactly one level \ndeeper in the nesting hierarchy mbodies(P, m)= M than the bound P. However, more general pre.x types \ncan be encoded. G . T . P mbodies(P)= {M}M = Tn+1 m(Tx) {e} mtype(G,T,m)=(x:T ) . Tn+1 Figure 9. Class \nmember lookup normal methods. This is speci.ed in CT.-SHADOW, where the synthesized shadow class P.C \ncontains all the shadow method declarations from its originating class P. .C, as if they are normal method \ndeclarations in P.C. CT.-SHADOW also states that the originating family P. of the shadow class P.C must \nbe the class that introduces C, i.e., the originating class P. .C cannot override any non-shadow class. \nThis ensures that every shadow class has exactly one originating class, and therefore no con.ict between \nshadow method declarations may happen. For simplicity, we assume there are no accidental name con.icts \nin J&#38;h, that is, all the .eld declarations use dif\u00adferent .eld names, unrelated methods have different \nnames, and classes that do not override each other also have dif\u00adferent names. This can be achieved with \nname mangling. In particular, shadow classes introduced by different originat\u00ading classes are always \ntreated as unrelated, different classes, as described in Section 3.4, and their names are assumed to \nhave been mangled differently.  4.5 Type substitution The rules for type substitution are shown in Figure \n11. Type substitution T { G; Tx/x} substitutes Tx for x.class in T in the context of G. The typing context \nG is used to look up .eld types when substituting a non-dependent class into a .eld-path dependent class. \nFor type safety, type substitutions on the right-hand side of a .eld assignment or on the parameters \nof method calls must preserve the exactness of the declared type. There\u00adfore, only values from the family \nthat is compatible with the receiver are assigned to .elds or passed to method code. Exactness-preserving \ntype substitution T { G; Tx/x!} substi\u00adtutes Tx for x.class in T and preserves the exactness of T : T \n{ G; Tx/x} = T . .k. pre.xExactk(T ) . pre.xExactk(T .) T { G; Tx/x!} = T . Exactness is de.ned using \npre.xExactk(T ), as in Figure 10, which means that the k-th pre.x of T is an exact type.  4.6 Static \nsemantics The static semantics of J&#38;h is summarized in Figure 12 and Figure 13. Figure 12 shows rules \nfor type sharing G . T1 .  .{ G; Tx/x} = . .{{G; Tx/x} = . T.C{ G; Tx/x} = T { G; Tx/x} .C T { G; Tx/x} \n= T . P[T ]{ G; Tx/x} = P[T .]  T { G; Tx/x} = T . T !{ G; Tx/x} = T .! x.class{ G; Tx/x} = Tx x . = \ny y.class{ G; Tx/x} = y.class v.class{ G; Tx/x} = v.class p.class{ G; Tx/x} = p.class p. f .class{ G; \nTx/x} = p. f .class p.class{ G; Tx/x} = Tp Tp ..class = pftype(G,Tp, f )= Tf p. f .class{ G; Tx/x} = \nTf Figure 11. Type substitution T2, subtyping G . T1 = T2, and expression typing G . e:T . Figure 13 \nde.nes program well-formedness. Rules for type well-formedness G . T , non-dependent type bound G . T \n. P, .nal path typing G ..nal p:T , and .nal path equality G . p1 = p2 are not much different from those \nin previous work [37], except for the simpli.cation of removing masked types and intersection types, \nand there\u00adfore are omitted here. Please see the companion technical report [38] for the complete semantics. \nSharing relationships between types. The sharing judg\u00adment G . T1 . T2, shown in Figure 12, states that \na value of type T1 may become a value of T2 through a view change, and vice versa. SH-NEST states that \nsharing is between fam\u00adilies: when two classes are shared, all the corresponding nested types are also \nshared. SH-DECL collects sharing re\u00adlationships from class declarations. Shadow classes ensure that the \ntwo shared families are symmetric in the sharing relation, and therefore J&#38;h does not need directional \nsharing relationships as in the J&#38;s calculus, simplifying the semantics. The sharing relation is \nre.exive, symmetric, and transi\u00adtive, as shown by SH-REFL, SH-SYM, and SH-TRANS. This implies that although \neach class in J&#38;h or the J&#38; language can only declare at most one shared superclass, it is still \npos\u00adsible to encode any sharing relation among classes. Subtyping. The subtyping judgment G . T1 =T2 \nstates that T1 is a subtype of T2 in context G, and type equivalence G . T1 T2 is sugar for a pair of \nsubtyping judgments. Most subtyping rules are similar to those in the J&#38;s cal\u00adculus, but without \nany rule about masked types or intersec\u00adtion types. S-SHARE states that the subtyping relationships are \npreserved by a shared family, and implies that shadow classes in the base family inherit subtyping relationships \nfrom the originating family. Expression typing. The rules for expression typing G . e:T (Figure 12) are \nmostly standard, with the addition of T-VIEW, which states a view change expression is valid when the \nsource and the target types are shared. Several rules (T-SET, T-NEW, and T-CALL) use exactness-preserving \ntype substitution T { G; Tx/x!} . See Section 4.5 for its de.nition. Program typing. Program typing rules \nare shown in Fig\u00adure 13. P-OK states the rule for a program to be well-formed; L-OK, F-OK, and M-OK are \nthe rules for declarations of classes, .elds, and methods to be well-formed, respectively. EXT-OK and \nSH-OK are the well-formedness rules for in\u00adheritance and sharing declarations. For simplicity, covariant \nreturn types are not modeled. The rules in Figure 13 uses a simple auxiliary function paths(T ), which \nrepresents the set of all the access paths p in dependent types p.class that are part of type T . For \nexample, paths(P[this.class].C)= {this}.  4.7 Operational semantics A small-step operational semantics \nfor J&#38;h is shown in Fig\u00adures 14 and 15. A heap H is a function mapping pairs .., f . of memory locations \nand .eld names to values v. Heap up\u00addates are represented as H[.., f . := v]. A reference set R, which \ncontains all the references v that have been generated during evaluation, no matter whether or not they \nare reachable from references in e, is also part of the evaluation con.guration e, H, R. The set R is \nonly for the proof of soundness: it prevents us from losing path equalities needed in the proof. The \nevaluation rules (Figure 15) take the form e, H, R -. e. ,H. ,R.. Most of them are standard. R-GET shows \nthat .eld accesses implicitly trigger view changes, which ensures that objects that reference each other \nalways behave consistently. Type evaluation. Types in new expressions and view change expressions may \nbe dependent, and therefore need to be evaluated according to the type evaluation contexts TE (Figure \n14) and the type equivalence rules (Figure 12). A fully evaluated type has the form P!.C, which is a \nsimple class that has an exact pre.x and is not dependent on any ac\u00adcess path. There is always an exact \npre.x, because . is exact. Dependent class ..,P!..class evaluates to P!. Pre.x types are evaluated according \nto rules S-PRE-E1 and S-PRE-E2, which can be seen as normalization rules, reducing the types on the left-hand \nside of to those on the right-hand side. View changes. The auxiliary function view de.nes the op\u00aderational \nsemantics for view changes. Because sharing is ho\u00admogeneous, the generated run-time view P. .C.! is well \nde\u00ad  Type sharing G . T1 . T2 G . T1 . T2 G . T1 . T2 G . T2 . T3 G . T . T (SH-REFL) (SH-SYM) (SH-TRANS) \nG . T2 . T1 G . T1 . T3 G . T . P G . T1 . T2 super(P.C)= shares T . G . T1 . T2 G . T2.CT .{ G; T /this} \n= T .. (SH-EXACT) (SH-NEST) (SH-DECL) G . T.C! . T ..! G . T1! . T2! G . T1.C . T2.C Subtyping G . T1 \n= T2 G . T1 = T2 G . T2 = T3 G . T =. (S-TOP) G . T = T (S-REFL) (S-TRANS) G . T1 = T3 G ..nal p:T \nG ..nal p:T ! G . p1 = p2 (S-FIN) (S-FIN-EXACT) (S-ALIAS) G . p.class = T G . p.class T ! G . p1.class \n p2.class G . P[T.C] G . P[T ] = T . G . T.C! = T !.C (S-EXACT) (S-PRE-E1) (S-PRE-E2) G . P[T.C] T G \n. P[T !] T .! G . T G . T . P G . T1 = T2 G . T2.C G . T1 . T2 G . T1.C = T1.C. (S-BOUND) (S-NEST) \n(S-SHARE) G . T = P G . T1.C = T2.C G . T2.C = T2.C. G . T1 = T2 . P1 .P2 G . T . P super(P.C)= ... T \n. G . P[T1] G . P[T2] G . P1[T ] G . P2[T ] T .{ G; T /this} = T .. (S-PRE-I) (S-PRE-B) (S-DECL) G . \nT.C = T ..G . P[T1] = P[T2] G . P1[T ] P2[T ] Expression typing G . e:T G ..nal p:T G . e:T G . T = \nT . (T-FIN) G . p:p.class G . e:T . G . e:T G . e:T G . T . T . ftype(G,T, f )= Tf (T-VIEW) G . (view \nT .)e:T . G . e. f :Tf G . T G . e:T ftypedecl (G, T, f )=[final] T . T = T .{ G; T !/this!} (T-NEW) \nG . new T ( f = e):T ! G . e1:T1 G . e2:T2 (T-SUB) (T-SEQ) G . e1; e2:T2 G . x:T ftypedecl (G, T, f \n)= T decl f T decl { G; T /this!} = Tf G . e:Tf(T-GET) f (T-SET) G . x. f = e:Tf n = #(e)= #(x) G . \ne0:T0 G . e:T . mtype(G,T0,m)=(x:T ) . Tn+1 .i . 1..n + 1. Ti{ G; T0/this!} = T . i (T-CALL) G . e0.m(e):T \n. n+1 Figure 12. Static semantics .ned, shares with the original view P.. .C.!, and is a subtype of \nthe target type P.!.C. Therefore, as long as the source type and the target type are shared, a view change \nexpression is well-formed. view(..,P!.,P.!.C)= ..,P. .C.!. where P = P.. .C. and . P.! . P..!  4.8 Soundness \nIn the soundness proof, expressions are typed using a typing environment .H,R. constructed from the heap \nH and the ref\u00aderence set R, which contains aliasing information for .elds. Figure 16 shows the de.nition \nof .H, R.. A run-time con.guration is well-formed, represented as . e, H, R, shown in Figure 17, if e \nhas no free variables, all the references in e are included in R, references with the same location in \nR have shared views, and the type of the value stored in a .eld is consistent with at least one view \nof the containing object. We prove the following soundness theorem of the J&#38;h core language, using \nthe standard technique of proving progress and subject reduction [46]. THEOREM 4.1. (Soundness) If ..L,e. \nok, and . e:T , and e,0/,0/ .* e. ,H,R, then either .v, such that e. = v and .H, R.. v:T, or .e.. ,H. \n,R., such that e. , H, R -. e.. ,H. ,R. . LEMMA 4.2. (Progress) If . e,H,R, and .H,R.. e:T, then either \n.v, such that e = v, or .e. ,H. ,R., such that e,H,R -. e,H. ,R. .  e,H, R -. e,H. ,R. .. L ok 0/ . \ne:T 0/ . T .+ acyclic (P-OK) ..L,e. ok .C. . CT.(P.C.C.)=... P.C . CT.(P.C.C.) ok P.C . F ok P.C . ownMethods(P.C) \nok P . ES ok .Pi. . P.C .+ Pi .. P.C conforms to Pi .m. #(mbodies(P,m)) = 1 (L-OK) P . class C ES {LFM} \nok T .this:P . T = . paths(T ) .{this}\u00acpre.xExact0(T ) (EXT-OK) P . extends T ok this:P . TT { 0/; P/this} \n= P.C (SH-OK) P . shares T ok CT.(P)= class C ES {LFM}CT.(P.)= class C. ES.{L. F. M.} Li = class D ESi \n... .i, j. . ESi = ES. .L. = class D ES. ... j jj Mi = Tn+1 m(Tx) {e} .i, j. .M. = T . .}. P . Mi overrides \nM. j n+1 m(T . x.) {e j . P conforms to P. M = Tn+1 m(Tx) ... {e} M. = Tn. +1 m(T . x.) ... {e.} #(x)= \n#(x.)= #(y) y n (x . x.)= 0/ G = this:P,y:T {y/x}. G ok G . T {y/x} T .{y/x.} G . Tn+1{y/x} Tn. +1{y/x.} \n P . M overrides M. this:P . T paths(T ) .{this} \u00acpre.xExact0(T ) this:P . e:T (F-OK) P . [final] Tf \n= e ok G = this:P,x:T . G ok n = #(x) x0 = this G . Tn+1 G . e:Tn+1 FV(e) .{x0,x} paths(T ,Tn+1) .{this} \n (M-OK) P . Tn+1 m(Tx) {e} ok Figure 13. Program typing heaps H ::= 0/ | H,.., f . .. v reference sets \nR ::= 0/ | R,v evaluation contexts E ::=[\u00b7] | E. f | E. f = v | E; e | E.m(e) | v.m(v, E,e) | new TE( \nf = e) | new P!.C( f = v, f = E, f . = e) | (view TE)e | (view P!.C)E  type evaluation contexts TE ::= \nTE.C | E.class | P[TE] | TE! Figure 14. De.nitions for operational semantics e,H,R -. e, H. ,R. (R-CONG) \nE[e],H,R -. E[e.],H. ,R. H(., f )= v ftype(0/ , P!, f )= P.!.C R. = R,view(v,P.!.C) (R-GET) ..,P!.. f \n, H, R -. view(v,P.!.C),H,R. H. = H[.., f . := v] (R-SET) ..,P!.. f = v,H,R -. v,H. ,R mbodies(P,m)= \n{Tn+1 m(Tx) {e}} n = #(v)= #(x) ..,P!..m(v),H,R -. e{..,P!./this, v/x},H,R (R-CALL) . fresh H. = H[(., \nf ) := v] R. = R,..,P.C!. (R-ALLOC) new P!.C( f = v), H,R -. ..,P.C!.,H. ,R. v; e,H,R -. e, H,R (R-SEQ) \nR. = R,view(v,P!.C) (R-VIEW) (view P!.C)v,H,R -. view(v,P!.C),H,R. Figure 15. Small-step operational \nsemantics ..,P!.. R . ftype(0/ ,P, f ) . Pf ... ,P.!. = view(H(., f ),Pf ) final Tf f = e . .elds(P) \n ..,P!.. f = ... ,P.!...H,R. Figure 16. Runtime typing environments FV(e)= 0/ refs(e) . R .l,P!.,.l,P.!.. \nR .. P! . P.! H(., f )= v ..P . ..,P!.. R.. v:ftype(0/,P!, f ) . e,H,R Figure 17. Runtime con.guration \nwell-formedness LEMMA 4.3. (Subject reduction) If . e,H,R, and .H,R.. e:T, and e,H,R -. e. ,H. ,R., then \n. e. ,H. ,R. and .H. ,R.. . e.:T. Lemma 4.2 is proved by structural induction on e. In order to prove \nLemma 4.3, we need to .rst prove several preliminary lemmas, some of which are more related to sharing \nthan others. J&#38;h contains dependent types, and a value substitution (substituting a value for a variable, \ne.g., for evaluating a method call) might affect the types as well. Lemma 4.4 states that value substitutions \ndo not change sharing relationships between types. LEMMA 4.4. If G,x:Tx . T1 . T2, and G,x:Tx . v:Tx, \nthen G{v/x}. T1{v/x}. T2{v/x}.  PROOF: By induction on the derivation of G,x:Tx . T1 . T2. As mentioned \nin Section 4.7, the auxiliary function view that implements the semantics of view changes works when \nthe source type and the target type are shared. For explicit view change operations, this is ensured \nby T-VIEW. For implicit view changes that are triggered by .eld accesses (see R-GET in Figure 15), Lemma \n4.5 ensures that they are also safe. LEMMA 4.5. If . P! . P.!, and ftype(0/,P!, f )= Tf, and ftype(0/,P.!, \nf )= Tf ., then . Tf . Tf . . PROOF: It is trivial, if the declared type of .eld f is not dependent. \nOtherwise, it can be proved using Lemma 4.6. . LEMMA 4.6. If . P1!.C1 . P2!.C2, and . P[P1!.C1], and \n. P[P2!.C2], then . P[P1!.C1] . P[P2!.C2]. PROOF: By induction on the derivation of . P1!.C1 . P2!.C2. \n. With these lemmas, subject reduction (Lemma 4.3) is proved by induction on the derivation of .H,R.. \ne:T . Then the soundness theorem follows directly. The proofs can be found in the companion technical \nreport [38]. 5. Implementation We have implemented a prototype compiler for the J&#38;h language using \nthe Polyglot compiler framework [29]. The compiler is a 4700-LOC (lines of code, excluding empty lines, \ncomments, and automatically generated parser code) extension of the J&#38; compiler [30]. The target \nlanguage of the compiler is Java. There is also a 4600-LOC run-time system, most of which is a custom \nclassloader implemented using the ASM bytecode manipulation framework [7]. The compiler and the run-time \nsystem are generally sim\u00adilar to those of the J&#38;s language, though simpli.ed by the absence of masked \ntypes and sharing constraints. Synthesis of shadow classes by the run-time system is a new feature but \nis similar to the synthesis of implicit classes [28]. 5.1 Type checking Type checking is similar to that \nin the J&#38; compiler, except that the type system needs to prove sharing relationships be\u00adtween types. \nThe type system collects sharing relationships from sharing declarations, recursively establishes sharing \nre\u00adlationships to all known nested classes and packages, and forms the sharing relation via the re.exive, \nsymmetric, and transitive closure. Type checking is modular and sound. It is also conservative: a true \nsharing relationship might not be recognized by the type system if it requires knowing the dec\u00adlarations \nin some derived family that has not been checked yet. In that case, the programmer must break a complex \nview change operation into multiple view changes that take smaller steps. This arguably has some documentation \nvalue. 5.2 Synthesizing shadow classes Translation in the J&#38;h compiler is scalable, in the sense \nthat the amount of code generated by the compiler is proportional to the size of the source code. Therefore, \nno Java target code is produced for shadow classes. Instead, this is done lazily at run time. When a \nnested class is loaded at run time, the classloader in the run-time system checks whether it is an originating \nclass. If so, code for a shadow class is synthesized in each base family that is shared with the originating \nfamily. The implementation does not copy shadow-method code into shadow classes, but only generates one-line \ndispatch meth\u00adods that call corresponding shadow methods contained in the originating class. Recall from \nSection 3.4 that shadow classes are named specially in the source code, with the name of the originating \nclass embedded in the syntax. For each explicit occurrence of a shadow class, the compiler generates \ncode that calls the run-time system to load the originating class, triggering run-time synthesis of the \nshadow class. Moreover, the name of a shadow class is mangled to include the name of the originating \nclass, to avoid name con.icts. 5.3 Supporting views The compiler and run-time system supports views \nand view changes in a way that is almost identical to J&#38;s. Each J&#38;h object is referenced indirectly \nthrough a reference object, which contains a pointer to the run-time representation of the view associated \nwith the reference. A view change operation is translated to generating a new reference object pointing \nto the same J&#38;h object, with a new view that is compatible with the target type. Reference objects \nare cached to improve performance. The behavior of the J&#38;h object is determined by the view. Method \ncalls are dispatched on the views, and run-time type inspection is also based on the views. The only \nexception is .eld accesses. With heterogeneous sharing, a .eld with an unshared type has multiple copies, \neach for a view of the containing object, and therefore .eld accesses depend on views. However, with \nhomogeneous sharing, every .eld is shared, and there is only one copy to access regardless of the view. \nTherefore .eld accesses in J&#38;h are faster, while other operations have performance similar to that \nin J&#38;s. See Section 6.1 for some performance results.  5.4 Optimization of .eld accesses As formalized \nin R-GET in the operational semantics, .eld accesses in J&#38;h may trigger implicit view changes. However, \nnot every access requires a view change, so the J&#38;h com\u00adpiler implements a static analysis to identify \nimplicit view changes that may be elided without breaking type safety.  A .eld access does not need \nan implicit view change in several cases: The .eld type does not depend on the view of the con\u00adtainer \nobject.  An explicit view change is applied immediately after the .eld access.  The .eld is used at \na place where its exact view is not important. For example, in an expression x.f.g, the .eld access x.f \nmay not need an implicit view change, as long as the second .eld g is declared in a class that does not \nhave a shared superclass.   5.5 Run-time type inspection Sharing allows an object to have several different \nviews at run time. J&#38;h supports view casts and the viewableas op\u00aderator, which are similar to type \ncasts and the instanceof operator, to dynamically inspect different views of a J&#38;h ob\u00adject. These \noperators are illustrated in the following code based on the example from Section 2.1: List l = new ArrayList(); \nl.add(new Button()); Object o = l.get(0); if (o viewableas PrettyButton!) { PrettyButton! b = (viewcast \nPrettyButton!)o; b.draw(); // the new method in PrettyButton } The static type of the object stored \nin the list is Object, which is not a shared type of PrettyButton!, so a view cast has to be used for \nthe J&#38;h run-time system to attempt the view change to PrettyButton!. Like type casts in Java, view \ncasts in J&#38;h can fail at run time with an exception if the current view of the object and the target \ntype are not shared. By contrast, a statically type-checked view change never fails at run time, whether \nexplicitly written or implicitly triggered by a .eld access.  5.6 Java compatibility The J&#38;h implementation \nhas roughly the same Java com\u00adpatibility as the J&#38;s implementation. A J&#38;h program may use existing \nJava code, and a J&#38;h class may extend a Java class or implement Java interfaces. However, shared \nclasses in J&#38;h must extend the same Java class, due to the absence of multiple inheritance in Java. \nArrays of J&#38;h objects are treated as objects having .elds of the same type, and therefore, array \naccesses may also trigger implicit view changes. The current J&#38;h implementation does not support \nmost of the Java 1.5 features, which seem to be orthogonal to shar\u00ading. Covariant return types are supported, \npartly because the underlying Java standard library already has covariant return types. Support for generics \nwould help replace view casts with type-safe view changes. In the previous code example, if the list \nl were declared with type List.Button!., the Table 1. Microbenchmarks: average time per operation, in \nns. view change virtual call static call .eld read .eld write allo\u00adcation J&#38;s 17.6 10.3 1.09 5.92 \n5.31 26.1 J&#38;h 18.3 9.26 1.09 3.13 2.97 26.3 view cast operation could then be replaced with a statically \ntype-safe view change operation. Adding support for gener\u00adics to J&#38;h appears feasible, but we leave \nthis as future work. 6. Experience 6.1 Performance results Microbenchmarks. We compare the performance \nof the J&#38;h implementation against J&#38;s, using some microbench\u00admarks to measure individual object \noperations. Every mi\u00adcrobenchmark runs one operation 108 times in a loop. Ta\u00adble 1 shows the results. \nThe testing hardware is a Thinkpad X200 with Intel L9400 CPU and 2GB memory, and the soft\u00adware environment \nconsists of Windows Vista, Cygwin, and JVM 1.6.0 13. The results con.rm that object operations in the \nimple\u00admentations of J&#38;s and J&#38;h have similar performance, but .eld accesses with homogeneous \nsharing are almost twice as fast as J&#38;s .eld accesses. With homogeneous sharing, .eld accesses are \nno longer view-dependent, and therefore acces\u00adsor methods can be implemented in the same class where \n.elds are located. Jolden benchmarks. We tested the J&#38;h implementations with the jolden benchmarks \n[8] to study the performance overhead for code that does not use the new extensibility fea\u00adtures of class \nsharing. All ten benchmarks, with few changes, are tested with .ve language implementations: Java, J&#38; \n[30], J&#38; with the custom classloader, J&#38;s [36], and J&#38;h with ho\u00admogeneous family sharing. \nTable 2 compares the results. The testing environment is the same as that for the mi\u00adcrobenchmarks. The \nresults of the jolden benchmarks con.rm that homo\u00adgeneous family sharing has a lower performance overhead \ncompared to heterogeneous sharing. The J&#38;s times show a 25% slowdown versus the classloader-based \nJ&#38; (with\u00adout sharing) implementation, and 100% versus Java. On the other hand, J&#38;h has a better \nperformance compared to J&#38;s: the two overhead numbers drop to 17% and 88%. This is consistent with \nthe microbenchmarking results. The current implementation of J&#38;h still introduces no\u00adticeable overhead \ncompared to Java, because of more com\u00adplex subtyping relationships, indirections through reference objects, \nand the translation of .eld accesses into accessor method calls. Having Java as a target language does \nlimit performance. For J&#38;s [36], we suggested that performance could be improved with a lower-level \ntarget language, al\u00ad  bh bisort em3d health mst perimeter power treeadd tsp voronoi Java 1.30 0.34 0.16 \n0.26 0.63 0.21 0.64 0.14 0.08 0.29 J&#38; [30] 13.39 1.48 0.33 6.11 4.06 2.93 2.10 2.10 0.22 6.96 J&#38; \nwith classloader 1.78 0.45 0.24 0.55 0.93 0.47 0.83 0.21 0.12 0.57 J&#38;s [36] 2.20 0.58 0.24 0.85 1.26 \n0.45 0.89 0.38 0.14 0.75 J&#38;h 2.01 0.55 0.22 0.79 1.21 0.47 0.82 0.37 0.13 0.64 Table 2. Results \nfor the jolden benchmarks. Average time over ten runs, in seconds. lowing implementation techniques similar \nto those used for C++; the same should also apply to the J&#38;h implementation.  6.2 Lambda compiler \nWe experimented with in-place translation in a .-calculus compiler. This is not a large example, but \nuses the language features in a sophisticated way combining multiple levels of sharing and family-level \nintersection. The example is in\u00adspired by the Polyglot framework, and it encapsulates most of the interesting \nissues that arise in making Polyglot exten\u00adsible, while demonstrating the advantages of homogeneous family \nsharing. Implementing translations for sums and pairs. The com\u00adpiler example translates the .-calculus \nextended with sums and pairs to the simple lambda calculus. A way to accom\u00adplish this goal as an in-place \ntranslation was .rst demon\u00adstrated for heterogeneous sharing [36], so this example of\u00adfers a way to compare \nthe expressive power of homogeneous and heterogeneous sharing. The compiler is implemented as four families \nof classes. The base family describes simple .-calculus as the target language. Two derived families, \nsum and pair, share AST classes with the base family but extend it with sums and pairs respectively. \nThey also implement in-place translation to the simple .-calculus. The last derived family, sumpair, \ncomposes the sum and pair families, leading to a compiler that supports both sums and pairs. Homogeneous \nvs. heterogeneous sharing Figure 18 shows the structures of the compiler when implemented with heterogeneous \nsharing and with homogeneous sharing. The J&#38;s version has about 250 lines. Sharing is declared between \nindividual pairs of classes, represented with dashed arrows that go across family boundaries. The class \nhierarchy is more complex with these interfamily relationships, and several class declarations have to \nbe written just to declare sharing, making the code less scalable. Out of the 23 class declarations, \n12 are just for sharing declarations. Moreover, the existence of new subclasses (Pair and Case) in the \npair and sum families means the Exp type cannot be shared. Therefore, all subexpression .elds with type \nExp must be masked in sharing relationships. There are in total 17 masked types in the J&#38;s code, \nand 3 sharing constraints. The extra syntax increases the annotation burden for the programmer. The J&#38;h \nversion has about 200 lines. There are only three sharing declarations, shown in the right-hand side \nof Figure 18, and they are all between families. None of the 12 class declarations in the J&#38;s version \nthat were needed for declaring sharing are necessary, so extending is simpler and more scalable. For \nexample, the declaration of sumpair is reduced to just one line: class sumpair extends pair &#38; sum \nshares base { } In addition, none of the masked types and sharing constraints from the J&#38;s version \nare needed. The sharing declaration shares base enables sumpair to share with base, as well as with pair \nand sum, because of transitivity. Without this declaration, sumpair would inherit from pair and sum, \nbut would not adapt them. The comparison shows that homogeneous sharing is sim\u00adpler and more scalable, \nand has a lower annotation burden. The annotation burden is low even in an absolute sense given what \nis achieved. Therefore, homogeneous sharing seems more likely to be adopted by ordinary programmers. \n 6.3 Polyglot Following the same implementation strategy just outlined, we ported the Polyglot compiler \nframework version 2.4.0, originally written in Java, to J&#38;h. We also ported two small Polyglot-based \nlanguage extensions to explore using homo\u00adgeneous sharing to implement compiler translations. (Pre\u00advious \nwork [30] presents a port of Polyglot 1.x to the J&#38; language, for the purpose of demonstrating extension \ncom\u00adposition, but it cannot support in-place translation). The Java version of the base Polyglot compiler \nhas 59 kLOC. The J&#38;h port is substantially shorter, at 48 kLOC. The code becomes shorter through \nthe elimination of the delegate and extension-object design patterns [29] that sup\u00adport extensibility. \nWith family inheritance and homogeneous sharing, even more extensibility is obtained than from these \ndesign patterns, because the extensibility mechanism applies throughout the compiler rather than just \nwhere the design patterns were used. As in the lambda compiler example, homogeneous shar\u00ading allows us \nto declare an extension that is shared with the base compiler. For example, we implemented a covarRet \nextension, which extends the base compiler with covariant return types. Because it extends the type system, \nthis exten\u00adsion makes a particularly interesting example. The extension is implemented by the covarRet \npackage, declared to share with the base compiler:   package covarRet shares polyglot; The covarRet \nextension parses source code, which may include methods declared with covariant return types, gen\u00aderates \nan AST (built of source family objects), type-checks it, and then translates away any covariant return \ntypes to ob\u00adtain an AST in the base language (the target family), which is Java 1.4. The translated AST \nis then type-checked in the base language, and .nally output is generated. As in the IMP example of Section \n3.5, the translation from covarRet to the base language happens in two steps. First, the AST is transformed \nto remove covariant return types, but the generated objects remain in the covarRet family. Shadow classes \nensure this can always be done, even if the target language is a sibling family with additional AST nodes \nnot present in the source language. Second, a view change from the source family to the target family \nis applied to the root of the translated AST. The view change lazily moves the whole AST, including type \nannotations, to the target family. Subsequent type checking and post\u00adprocessing in the compiler uses \nthe base language view, which (correctly) does not support covariant returns. Homogeneous sharing offers \nsome advantages for im\u00adplementing this extension. First, the extension is somewhat shorter than the original \nJava implementation of the same extension: 166 rather than 226 lines for covarRet, as the result of eliminating \ndesign patterns. Second, the Java im\u00adplementation must reconstruct the types of all expressions after \ntranslation, in order to type-check the translated AST. This reconstruction is avoided in the J&#38;h \nimplementation, because the .nal view change automatically shifts source\u00adlanguage objects representing \ntypes to the corresponding tar\u00adget language classes. This shows that homogeneous shar\u00ading provides more \nscalable extensibility than was possible through the Polyglot design patterns, which apply mainly to \nAST nodes. Another ported extension was carray, which supports constant arrays. Compared to covarRet, \nwhich just extends the type system, carray also extends the grammar, and introduces a new AST node class \nConstArrayTypeNode. If we were to port carray with J&#38;s, this new AST node class would make the code \nmuch more complicated. All the .elds that might store an instance of ConstArrayTypeNode would have to \nbe masked, because heterogeneous sharing does not allow two corresponding types to be shared if one of \nthem has a new subclass. By contrast, with a shadow class implicitly added into the base family, homogeneous \nsharing makes porting carray quite simple: the J&#38;h version has 214 LOC, and the Java version has \n217 LOC, both excluding comments, empty lines, and automatically generated parser code. In the case the \nJ&#38;h code does not become signi.cantly shorter, because the original extension does not implement \nany translation. The performance of the J&#38;h version of Polyglot is rea\u00adsonable. Because Polyglot \nhas many classes, and the current J&#38;h run-time system needs to produce bytecode for gener\u00adated classes, \nstartup overhead for class loading in the cur\u00adrent system is high compared to Java. To ignore this arti.\u00adcial \ndiscrepancy, we compared the compile time of the two compilers on some small programs after class loading \nwas complete. The Java version took 149ms on average to com\u00adpile these programs, whereas the J&#38;h \nversion took 207ms. The performance hit is modest, while writing the compiler in J&#38;h adds even more \nextensibility. 7. Related work 7.1 Heterogeneous sharing The most closely related work is our previous \nwork on the J&#38;s language, which has heterogeneous class sharing [36]. Section 3.7 compares the two \napproaches to sharing in detail.  7.2 Adaptation The adapter design pattern [17] is a protocol for \nimplement\u00ading adaptation. However, this and other related patterns are tedious and error-prone to implement, \nrely on statically un\u00adsafe type casts, and do not preserve object identity or provide bidirectional adaptation, \nas sharing does. Expanders [45] are a mechanism for adaptation. New .elds, methods, and superinterfaces \ncan be added into ex\u00adisting classes. Expanders are more expressive than open classes [10], which can \nonly add methods. Method dispatch is statically scoped, so expanders do not change the behavior of existing \nclients. J&#38;h supports upgrading existing clients without code change by allowing the shared derived \nfam\u00adily to override classes in the base family, and by providing shadow classes in the base family. CaesarJ \n[1, 23] is an aspect-oriented language that sup\u00adports adaptation with wrappers called aspect binders. \nWrap\u00adpers and expanders are similar. They both can extend wrapped classes with new states, operations, \nand superin\u00adterfaces; no duplicate wrappers are created for objects; and dynamic wrapper selection is \nsimilar to expander overrid\u00ading. They also share the similar limitation that existing client code cannot \nacquire the extended behavior without code change. Multiple inheritance in CaesarJ makes wrapper se\u00adlection \nambiguous; J&#38;h disambiguates via views. FickleIII [12] has a re-classi.cation operation for objects \nto change their classes. Re-classi.cations are similar to view changes in J&#38;h, but directly change \nthe behavior of all exist\u00ading references to the object; therefore, effects are needed to track the change, \nadding to the annotation burden. FickleIII does not support class families. Chai3 [41] allows traits \nto be dynamically substituted to change object behaviors, similar to view changes. However, Chai3 does \nnot support families, and the fact that traits do not have .elds makes it harder to support manipulation \nof data structures. Some previous work on adaptation, including pluggable composite adapters [24], object \nteams [18], and delegation layers [34], also has some notion of families of classes. However, these mechanisms \neither do not support method overriding and dynamic dispatch between the adapter and adaptee families \n[24], or have a weaker notion of families in which programmers have to manually wire relationships between \nthe base family and the delegation family [18, 34]. These mechanisms all use lifting and lowering, introduced \nin [24], to convert between adapter and adaptee classes. Lifting and lowering are similar to view changes, \nbut are not symmetric and do not support late binding, as they are based on the static type of the object. \n 7.3 Family inheritance Several different mechanisms have been proposed to sup\u00adport family inheritance, \nincluding virtual classes, nested in\u00adheritance, variant path types, mixin layers, etc. In all these mechanisms, \nfamilies of classes are disjoint, and in-place ex\u00adtensibility is not provided. Virtual classes [9, 13, \n16, 21, 22] are inner classes that can be overridden just like methods. Path-dependent types are used \nto ensure type safety, proved in [16] and [9]. Nested inheritance [28] supports overriding of nested \nclasses, which are similar to virtual classes. Nested inter\u00adsection [30] adds and generalizes intersection \ntypes [11, 39] in the context of nested inheritance to provide the ability to compose extensions. A family-level \nmultiple inheritance mechanism based on virtual classes has been explored by Ernst in the context of \ngbeta [14]. Variant path types [20] support family inheritance with\u00adout dependent types, using a different \nstyle of exact types and relative path types to ensure type safety. Mixin layers [40] generalize mixins \n[4], which are classes that can be instantiated with different superclasses. Mixin layers are mixins \nthat encapsulate other mixins. Mixin lay\u00aders support family inheritance: when a mixin layer is instan\u00adtiated, \nall the inner mixins are instantiated correspondingly. However, they do not provide family polymorphism. \nVirtual types [6, 19, 43, 44] are type declarations that can be overridden. Virtual types are more limited \nthan vir\u00adtual classes: they provide family polymorphism but not family inheritance. Scala [32, 33] supports \nfamily poly\u00admorphism and composition through virtual types, path\u00addependent types, and mixin composition. \nViews in Scala do not provide adaptation; they are implicitly-called conversion functions that create \nnew instances in their target types. Nielsen and Ernst [27] present a virtual machine that na\u00adtively \nsupports family inheritance. It would also be interest\u00ading to explore native implementation of family \nsharing.  7.4 Dynamic software updating J&#38;h supports safe dynamic software updating without down\u00adtime, \nin much the same way as in J&#38;s. Objects of the base family may be upgraded to new views in the derived \nfam\u00adily, and therefore obtain new behaviors while the software system is still running. Usually only \na few root objects need to be explicitly upgraded, while other objects that are reach\u00adable from them \nwill be automatically updated when they are accessed. This makes the updating code easier to write. On \nthe other hand, mechanisms for dynamic software updating [2, 25, 26, 42], by design do not preserve the \nold behavior of the software before the update, whereas sharing captures both the existing and the updated \nbehaviors in the form of views. Sharing therefore provides additional functionality: safe switching between \ndifferent behaviors at run time. Barr and Eisenbach [2] propose a framework for dynamic update of Java \ncomponents, which also includes a custom classloader. The goal is to provide a tool that keeps Java libraries \nup to date, rather than to improve the extensibility of the language.  JVOLVE [42] supports dynamic \nsoftware updating with no overhead during steady-state execution, but it requires changes to many different \ncomponents of the Java virtual machine, rather than to just the classloader as in J&#38;h. Ginseng [26] \nuses static analysis to .nd proper timing for a given global update, and is later generalized to work \nwith multi-threaded programs [25]. Abstract and concrete types in Ginseng bear some resemblance to inexact \nand exact types in J&#38;h: abstractly typed variables allow values of different concrete types, and \ninexactly typed variables may store objects with different exact views. 8. Conclusions Homogeneous family \nsharing generalizes class sharing so that it operates at the level of families of interacting classes, \nanalogously to the way nested inheritance generalizes ordi\u00adnary class inheritance. Shadow classes and \nother new mech\u00adanisms enable a derived family to safely and homogeneously share with a base family, while \nstill extending the base fam\u00adily with new classes. Shadow classes also make families open, providing \nnew kinds of extensibility. Homogeneous sharing is formalized in a simpli.ed language that focuses on \nsharing, and the type system is proved sound. Homoge\u00adneous sharing avoids complicated language mechanisms \nlike masked types or sharing constraints that were needed by the previous heterogeneous sharing mechanism. \nThis ease of use made it feasible to port and evaluate some substantial soft\u00adware and extensions to it. \nOur experience is that homoge\u00adneous family sharing gives expressive power comparable to that of heterogeneous \nsharing, but is simpler, more concise, and easier to reason about. Acknowledgments We thank Anthony Jawad \nfor helping develop the port of Polyglot to J&#38;h. We also thank Robert Grimm and the anonymous reviewers \nfor their useful comments. This research was supported in part by ONR Grant N00014-09-1-0652, by NSF \nGrants 0541217 and 0627649, and by a grant from Microsoft Corporation. The views and conclusions here \nare those of the authors and do not neces\u00adsarily re.ect those of ONR, the Navy, the NSF, or Microsoft. \nThe U.S. Government is authorized to reproduce and dis\u00adtribute reprints for Government purposes, notwithstanding \nany copyright annotation thereon. References [1] Ivica Aracic, Vaidas Gasiunas, Mira Mezini, and Klaus \nOstermann. An overview of CaesarJ. In Awais Rashid and Mehmet Aksit, editors, Lecture Notes in Computer \nScience: Transactions on Aspect-Oriented Software Development I, pages 135 173. Springer-Verlag, 2006. \n[2] Miles Barr and Susan Eisenbach. Safe upgrading without restarting. In Proceedings of 19th International \nConference on Software Maintenance (ICSM), pages 129 137, 2003. [3] Alexandre Bergel, St\u00b4ephane Ducasse, \nand Oscar Nierstrasz. Classbox/J: Controlling the scope of change in Java. In Proc. ACM OOPSLA 2005, \npages 177 189, San Diego, CA, USA, October 2005. [4] Gilad Bracha and William Cook. Mixin-based inheritance. \nIn Norman Meyrowitz, editor, Proc. ACM OOPSLA 90, pages 303 311, Ottawa, Canada, 1990. ACM Press. [5] \nKim B. Bruce. Safe static type checking with systems of mutually recursive classes and inheritance. Technical \nreport, Pomona College, 1997. http://www.cs.pomona.edu/ ~kim/ftp/RecJava.ps.gz. [6] Kim B. Bruce, Martin \nOdersky, and Philip Wadler. A statically safe alternative to virtual types. In European Conference on \nObject-Oriented Programming (ECOOP), number 1445 in Lecture Notes in Computer Science, pages 523 549. \nSpringer-Verlag, July 1998. [7] Eric Bruneton, Romain Lenglet, and Thierry Coupaye. ASM: A code manipulation \ntool to implement adaptable systems, 2002. http://asm.objectweb.org/current/asm-eng. pdf. [8] B. Cahoon \nand K. S. McKinley. Data .ow analysis for software prefetching linked data structures in Java. In International \nConference on Parallel Architectures and Compilatio n Techniques (PACT), September 2001. [9] Dave Clarke, \nSophia Drossopoulou, James Noble, and Tobias Wrigstad. Tribe: A simple virtual class calculus. In AOSD \n07: Proceedings of the 6th International Conference on Aspect-Oriented Software Development, pages 121 \n134, 2007. [10] Curtis Clifton, Gary T. Leavens, Craig Chambers, and Todd Millstein. MultiJava: Modular \nopen classes and symmetric multiple dispatch for Java. In Proc. 15th ACM Conference on Object-Oriented \nProgramming Systems, Languages and Applications (OOPSLA), pages 130 145, 2000. [11] Adriana B. Compagnoni \nand Benjamin C. Pierce. Higher or\u00adder intersection types and multiple inheritance. Mathematical Structures \nin Computer Science, 6(5):469 501, 1996. [12] Ferruccio Damiani, Sophia Drossopoulou, and Paola Gian\u00adnini. \nRe.ned effects for unanticipated object re-classi.cation: FickleIII. In ICTCS, pages 97 110, 2003. [13] \nErik Ernst. gbeta a Language with Virtual Attributes, Block Structure, and Propagating, Dynamic Inheritance. \nPhD thesis, Department of Computer Science, University of Aarhus, Aarhus, Denmark, 1999. [14] Erik Ernst. \nPropagating class and method combination. In Proc. Thirteenth European Conference on Object-Oriented \nProgramming (ECOOP 99), number 1628 in Lecture Notes in Computer Science, pages 67 91. Springer-Verlag, \nJune 1999. [15] Erik Ernst. Family polymorphism. In Proc. 15th European Conference on Object-Oriented \nProgramming (ECOOP), LNCS 2072, pages 303 326, 2001. [16] Erik Ernst, Klaus Ostermann, and William R. \nCook. A virtual class calculus. In Proc. 33rd ACM Symp. on Principles of Programming Languages (POPL), \npages 270 282, Charleston, South Carolina, January 2006. [17] Erich Gamma, Richard Helm, Ralph Johnson, \nand John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison Wesley, Reading, \nMA, 1994.  [18] Stephan Herrmann. Object teams: Improving modularity for crosscutting collaborations. \nIn Proc. Net Object Days, 2002. [19] Atsushi Igarashi and Benjamin Pierce. Foundations for virtual types. \nIn Proc. Thirteenth European Conference on Object-Oriented Programming (ECOOP 99), number 1628 in Lecture \nNotes in Computer Science, pages 161 185. Springer-Verlag, June 1999. [20] Atsushi Igarashi and Mirko \nViroli. Variant path types for scalable extensibility. In Proc. 22nd ACM Conference on Object-Oriented \nProgramming Systems, Languages and Applications (OOPSLA), pages 113 132, New York, NY, USA, 2007. ACM. \n[21] O. Lehrmann Madsen, B. M\u00f8ller-Pedersen, and K. Nygaard. Object Oriented Programming in the BETA \nProgramming Language. Addison-Wesley, June 1993. [22] Ole Lehrmann Madsen and Birger M\u00f8ller-Pedersen. \nVirtual classes: A powerful mechanism for object-oriented program\u00adming. In Proc. ACM OOPSLA 89, pages \n397 406, October 1989. [23] Mira Mezini and Klaus Ostermann. Conquering aspects with Caesar. In Proc. \n2nd International Conference on Aspect-Oriented Software Development (AOSD), pages 90 100, Boston, Massachusetts, \nMarch 2003. [24] Mira Mezini, Linda Seiter, and Karl Lieberherr. Component integration with pluggable \ncomposite adapters. Software Architectures and Component Technology, 2000. [25] Iulian Neamtiu and Michael \nHicks. Safe and timely dynamic updates for multi-threaded programs. In Proc. SIGPLAN 2009 Conference \non Programming Language Design and Implementation, pages 13 24, June 2009. [26] Iulian Neamtiu, Michael \nHicks, Gareth Stoyle, and Manuel Oriol. Practical dynamic software updating for C. In Proc. SIGPLAN 2006 \nConference on Programming Language Design and Implementation, pages 72 83, June 2006. [27] Anders Bach \nNielsen and Eric Ernst. Virtual class support at the virtual machine level. In VMIL 09: Proceedings of \nthe third workshop on Virtual Machines and Intermediate Languages, October 2009. [28] Nathaniel Nystrom, \nStephen Chong, and Andrew C. Myers. Scalable extensibility via nested inheritance. In Proc. ACM OOPSLA \n2004, pages 99 115, October 2004. [29] Nathaniel Nystrom, Michael R. Clarkson, and Andrew C. Myers. Polyglot: \nAn extensible compiler framework for Java. In Proc. 12th International Compiler Construction Conference \n(CC 03), pages 138 152, April 2003. LNCS 2622. [30] Nathaniel Nystrom, Xin Qi, and Andrew C. Myers. J&#38;: \nNested intersection for scalable software composition. In Proc. ACM OOPSLA 2006, pages 21 36, October \n2006. [31] Nathaniel Nystrom, Xin Qi, and Andrew C. Myers. Nested intersection for scalable software \ncomposition. Technical report, Computer Science Dept., Cornell University, Septem\u00adber 2006. http://www.cs.cornell.edu/nystrom/ \npapers/jet-tr.pdf. [32] Martin Odersky, Philippe Altherr, Vincent Cremet, Bu\u00adrak Emir, Sebastian Maneth, \nSt\u00b4ephane Micheloud, Niko\u00adlay Mihaylov, Michel Schinz, Erik Stenman, and Matthias Zenger. An overview \nof the Scala programming lan\u00adguage, June 2004. http://scala.epfl.ch/docu/files/ ScalaOverview.pdf. [33] \nMartin Odersky and Matthias Zenger. Scalable component abstractions. In Proc. ACM OOPSLA 2005, pages \n41 57, October 2005. [34] Klaus Ostermann. Dynamically composable collaborations with delegation layers. \nIn Proc. 16th European Conference on Object-Oriented Programming (ECOOP), volume 2374 of Lecture Notes \nin Computer Science, pages 89 110, M\u00b4 alaga, Spain, 2002. Springer-Verlag. [35] Xin Qi and Andrew C. \nMyers. Masked types for sound object initialization. In Proc. 36th ACM Symp. on Principles of Programming \nLanguages (POPL), pages 53 65, January 2009. [36] Xin Qi and Andrew C. Myers. Sharing classes between \nfam\u00adilies. In Proc. SIGPLAN 2009 Conference on Programming Language Design and Implementation, pages \n281 292, 2009. [37] Xin Qi and Andrew C. Myers. Sharing classes between families: technical report. Technical \nreport, Computing and Information Science, Cornell University, March 2009. http://hdl.handle.net/1813/12141. \n[38] Xin Qi and Andrew C. Myers. Homogeneous family sharing: technical report. Technical report, Computing \nand Information Science, Cornell University, July 2010. http://hdl.handle.net/1813/15845. [39] John C. \nReynolds. Design of the programming language Forsythe. Technical Report CMU-CS-96-146, Carnegie Mellon \nUniversity, June 1996. [40] Yannis Smaragdakis and Don Batory. Mixin layers: An object-oriented implementation \ntechnique for re.nements and collaboration-based designs. ACM Transactions on Software Engineering and \nMethodology, 11(2):215 255, April 2002. [41] Charles Smith and Sophia Drossopoulou. Chai: Traits for \nJava-like languages. In Proceedings of 19th European Conference on Object-Oriented Programming (ECOOP \n05), pages 453 478, 2005. [42] Suriya Subramanian, Michael Hicks, and Kathryn S. McKin\u00adley. Dynamic software \nupdates: A VM-centric approach. In Proc. SIGPLAN 2009 Conference on Programming Language Design and Implementation, \nJune 2009. [43] Kresten Krab Thorup. Genericity in Java with virtual types. In Proc. European Conference \non Object-Oriented Programming (ECOOP), number 1241 in Lecture Notes in Computer Science, pages 444 471. \nSpringer-Verlag, 1997. [44] Mads Torgersen. Virtual types are statically safe. In 5th Workshop on Foundations \nof Object-Oriented Languages (FOOL), January 1998. [45] Alessandro Warth, Milan Stanojevi\u00b4c, and Todd \nMillstein. Statically scoped object adaptation with expanders. In Proc. 21st ACM Conference on Object-Oriented \nProgramming Systems, Languages and Applications (OOPSLA), Portland, OR, October 2006. [46] Andrew K. \nWright and Matthias Felleisen. A syntactic approach to type soundness. Information and Computation, 115(1):38 \n94, 1994.     \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Recent work has introduced class sharing as a mechanism for adapting a family of related classes with new functionality. This paper introduces homogeneous family sharing, implemented in the J&#38;<sub>h</sub> language, in which the sharing mechanism is lifted from class-level sharing to true family-level sharing. Compared to the original (heterogeneous) class sharing mechanism, homogeneous family sharing provides useful new functionality and substantially reduces the annotation burden on programmers by eliminating the need for masked types and sharing declarations. This is achieved through a new mechanism, shadow classes, which permit homogeneous sharing of all related classes in shared families. The new sharing mechanism has a straightforward semantics, which is formalized in the J&#38;<sub>h</sub> calculus. The soundness of the J&#38;<sub>h</sub> type system is proved. The J&#38;<sub>h</sub> language is implemented as an extension to the J&#38; language. To demonstrate the effectiveness of family sharing, the Polyglot compiler framework is ported to J&#38;<sub>h</sub>.</p>", "authors": [{"name": "Xin Qi", "author_profile_id": "81322503996", "affiliation": "Facebook Inc., Palo Alto, CA, USA", "person_id": "P2354098", "email_address": "", "orcid_id": ""}, {"name": "Andrew C. Myers", "author_profile_id": "81100011022", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P2354099", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869502", "year": "2010", "article_id": "1869502", "conference": "OOPSLA", "title": "Homogeneous family sharing", "url": "http://dl.acm.org/citation.cfm?id=1869502"}