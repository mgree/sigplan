{"article_publication_date": "10-17-2010", "fulltext": "\n Random Testing for Higher-Order, Stateful Programs Casey Klein Matthew Flatt Robert Bruce Findler Northwestern \nUniversity University of Utah Northwestern University clklein@eecs.northwestern.edu m.att@cs.utah.edu \nrobby@eecs.northwestern.edu Abstract Testing is among the most effective tools available for .nd\u00ading \nbugs. Still, we know of no automatic technique for gener\u00adating test cases that expose bugs involving \na combination of mutable state and callbacks, even though objects and method overriding set up exactly \nthat combination. For such cases, a test generator must create callbacks or subclasses that ag\u00adgressively \nexercise side-effecting operations using combina\u00adtions of generated objects. This paper presents a new \nalgorithm for randomly test\u00ading programs that use state and callbacks. Our algorithm ex\u00adploits a combination \nof contracts and environment bindings to guide the test-case generator toward interesting inputs. Our \nprototype implementation for Racket (formerly PLT Scheme) which has a Java-like class system, but with \n.rst\u00adclass classes as well as gbeta-like augmentable methods uncovered dozens of bugs in a well-tested \nand widely used text-editor library. We describe our approach in a precise, formal notation, borrowing \nthe techniques used to describe operational se\u00admantics and type systems. The formalism enables us to \npro\u00advide a compact and self-contained explanation of the core of our technique without the ambiguity \nusually present in pseudo-code descriptions. Categories and Subject Descriptors D.2.5 [Testing and Debugging]: \nTesting tools; D.2.4 [Software/Program Ver\u00adi.cation]: Assertion checkers General Terms Veri.cation, Reliability \nKeywords Software Testing, Random Testing, Automated Test Generation, Racket 1. Introduction Extensibility \nis the hallmark of object-oriented program\u00adming. The ability to pass objects of unknown, and possibly \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA/SPLASH \n10 October 17 21, 2010, Reno/Tahoe, Nevada, USA. Copyright &#38;#169; 2010 ACM 978-1-4503-0203-6/10/10. \n. . $10.00 not yet written classes as arguments to methods is a power\u00adful form of openness that enables \nprogrammers to more eas\u00adily abstract and write reusable code. The book Design Pat\u00adterns (Gamma et al. \n1994) is full of examples for exploiting this power. IBM s San Francisco project (Rubin et al. 1998), \nwhich claims to be the largest Java development effort in the world, is predicated on such extensibility. \nThe .exibility of an open system incurs a commensu\u00adrate cost: effective testing is dif.cult, because \nthe space of behaviors for the systems is large and complex. Automated testing should be able to help; \nindeed, there hundreds of pa\u00adpers containing techniques for automatically testing object\u00adoriented programs. \nFew of those techniques, however, create objects with new behavior to supply to the program under test. \nThe vast majority of systems assume instead that the program is closed (i.e., that the tester is supplied \nwith all possible classes), or they are even more limited, supporting only methods that operate on .rst-order \ndata. We have developed a new algorithm for automated test\u00ading that addresses the problem of generating \nobjects with new behaviors. Our approach follows precedents in using programmer-supplied contracts (Findler \nand Felleisen 2002) to guide test generation and in building up pools of objects to use as test inputs. \nBy synthesizing and generalizing those precedents, we arrived at an algorithm whose core can be described \nby just a few simple test-generation rules. We validated our algorithm by applying it to the im\u00adplementation \nof DrRacket (Findler et al. 2002), the pro\u00adgramming environment for Racket (Flatt and PLT 2010). DrRacket \ns text editor is implemented by a class that sup\u00adports an extensible set of editable items, as well customiza\u00adtion \nthrough method overriding. Editing, drawing, measur\u00ading, copying, and con.guring the text editor each \ninvolve a myriad of methods over multiple objects. Many methods ad\u00adjust the internal state of the editor, \nand many state transfor\u00admations require calling multiple methods, any of which can be overridden. Designing \nclasses and methods that enable extensibility while maintaining the integrity of the editor s state is \na formidable task. Our random-testing algorithm un\u00adcovered upwards of 58 previously unknown bugs, more \nthan half of which could only be caught by synthesizing new sub\u00adclasses that exercise the editor API \nin particular ways.  interface BoundedStackI { void push(Object item); //@ requires this.capacity() \n>= 1; //@ ensures !this.empty(); Object pop(); //@ requires !this.empty() void push_n(int n, Object \nitem); //@ requires this.capacity() >= n; void add_obs(ObserverI o); int capacity(); boolean empty(); \n } interface ObserverI { void after_push(BoundedStackI s, Object item); //@ requires !s.empty(); //@ \nensures !s.empty(); } Figure 1: Bounded Stack Contract  2. Contracts as oracles and generators A contract \nis a complement to a type system and a gen\u00aderalization of pre-/post-condition checking. A contract on \na function or method re.nes the type of each argument by placing additional run-time checks on it. Simple \nchecks can be performed immediately, while other checks must be de\u00adlayed until the argument is used. \nFor example, if a function receives as an argument another function or an object, then constraints on \nthe behavior of the function or object apply only when the function is called or the object s methods \nare invoked. A key property of these checks in a contract system is the proper tracking of blame: when \na contract check fails, the responsible party can be correctly identi.ed. Contracts are a natural stepping \nstone for random test generation. In particular, blame assignment for a contract vi\u00adolation determines \nwhether the corresponding contract can play the role of a test generator or an oracle. To see how this \nworks, consider .gure 1. It contains a contract speci.\u00adcation for a stack module, written using JML notation. \nThe BoundedStackI interface supports six methods: push, pop, push_n, add_obs, capacity,and empty.The \npush and pop methods perform the usual addition and re\u00admoval of objects in the stack. The push method \nhas a pre\u00adcondition that states that there must be at least one more place in the stack and has a post-condition \nstating that the stack is not empty. The pop method has a pre-condition that the stack not be empty and \nno post-condition. The push_n method provides a shorthand for .lling the stack with multi\u00adple copies \nof item. The add_obs method registers an observer for the stack. The .nal two methods, capacity and empty, \nquery the internal state of the queue, accepting no arguments, and returning the number of available \nslots in the stack and whether the stack is empty, respectively. Finally, the ObserverI interface has \na single method, after_push, that is called each time the push method is invoked. The after_push method \nis supplied the in\u00adstance of the BoundedStackI interface whose push method was invoked and the value \nthat was pushed. Since it is called after the push was invoked, its pre-condition indicates that it will \nreceive a non-empty stack. To guar\u00adantee push s post-condition, however, after_push has is own post-condition \nthat guarantees that the result is also non-empty. The contracts tell us a lot about the behavior of \nany imple\u00admentation of the BoundedStackI interface. The contracts also indicate who is at fault when \na contract violation occurs. On one hand, if the post-condition of the push method fails, then the BoundedStackI \nimplementation is to blame. On the other hand, if the pre-condition of pop fails, then the client of \nthe BoundedStackI method is to blame. Thus, if we wanted to test a BoundedStackI implementation, the \npre-condition contract limits the space of the interesting inputs, implicitly giving us a test case generator, \nwhile the post-condition contract gives us a test oracle. In general, the blame assignment from a contract \nviola\u00adtion directly corresponds to the contract s role of as a test case generator or as a test oracle. \nIf the program being tested would be blamed for a contract violation, the contact is a test oracle. If \nthe test harness we generate is blamed for a con\u00adtract violation, the failure provides information about \nhow to generate test inputs. As another example, if we test clients of a BoundedStackI implementation, \nthen the roles of the oracle and generator are reversed, again matching blame assignment. The correspondence \nbetween blame, test-case generators, and oracles generalizes to higher-order interactions between components. \nFor example, imagine that we are interested in testing how BoundedStackI objects interact with their \nobservers. Speci.cally, consider the pre-and post-condition contracts on the after_push method. Since \nthe test case generator constructs new observer objects, it is not respon\u00adsible for their pre-conditions, \nbut instead is responsible for their post-conditions. Following the correspondence with blame, the pre-condition \nis now playing the role of a test oracle, not a test-case generator. In general, pre-conditions and post-conditions \nare not a priori tied to either oracles or test-case generators. The con\u00additions swap roles in correspondence \nwith the number of times the object has appeared as an input. In our stack ex\u00adample, the stack s pre-conditions \nand post-conditions are matched up with generators and oracles. In the case of the observer, because \nthe observer is an input to the stack, the roles reverse, making pre-conditions oracles and the post-conditions \ngenerators. Of course, observers also accept stacks as inputs, and thus, for those stack objects, the \nroles reverse one more time, making pre-conditions generators and post-conditions oracles again.  In \na manner similar to function-argument contravariance, contracts that are in negative positions (i.e., \nappearing an odd number of times to the left of a function arrow) play the role of generators, and contracts \nthat are in positive positions (i.e., appearing an even number of times to the left of a function arrow) \nplay the role of test oracles.  3. Test-generation strategy At a high level, our strategy for automatically \ntesting code can be represented as a function that accepts an environment (mapping identi.ers to types) \nand a type. It randomly gener\u00adates a program that uses the given environment and has the given type. \nOur strategy uses two basic techniques for generating programs. The .rst technique creates a value directly, \nignor\u00ading the environment. For base types like int or boolean, this means picking a random value of the \ngiven type. For function types, this means adding the parameter of the func\u00adtion to the environment and \nthen using the larger envi\u00adronment to generate a function body with the type of the codomain. For object \ntypes, we .rst derive a new class, which amounts to overriding a subset of the methods in the object \ns class, where creating each overriding method is analogous to creating a new function; once we have \nthe new class, we instantiate it to create an object. The second technique involves the environment. \nOur strategy might use a variable directly from the environment, if one with the right type is available. \nAlternatively, it might pick an arbitrary a function or a method in the environment, recursively build \nsomething of the argument s type, invoke the function or method, bind the result to a new variable, and \nrecur with the extended environment (still aiming to gener\u00adate a program of the desired type). Note that \nthe latter option is independent of the type being generated, and we are effec\u00adtively hoping that the \nresult of the function or method call is useful or that the function or method call changes the state \nof some object in an interesting way. To see our strategy in action, consider a buggy revision of the \nObserverI interface and BoundedStack,which is a buggy implementation of the BoundedStackI interface, \nshown in .gure 2. Imagine that the goal is to build an int, and that the environment initially contains \nonly the Bound\u00adedStack class. Initially, the test generator s only options are to produce an int directly \nor to create an object BoundedStack and put it into the environment. Once the test generator builds an \nobject, however, several other options become available. Imagine that the generator decides to invoke \nthe push_n method. To do that, it must build an int for the n argument, class BoundedStack implements \nBoundedStackI { int bound=10000; Object[] buffer = new Object[bound]; int tos = -1; Set<ObserverI> observers \n= new HashSet<ObserverI>(); public Object pop() { tos--; return buffer[tos+1]; } public void push(Object \nitem) { tos++; buffer[tos]=item; for (ObserverI o : observers) o.after_push(this,item); } public void \npush_n(int n, Object item) { for (int i=0;i<n;i++) push(item); } public void add_obs(ObserverI o) { \n observers.add(o); } public int capacity() { return bound-tos; } public boolean empty() { return tos==-1; \n} } interface ObserverI { void after_push(BoundedStack s, Object item); } Figure 2: Buggy bounded stack \nand observer as well as an Object for the item argument. For the item argument, the generator could use \nthe environment and pick the stack itself. For the n argument, the generator may decide to call the capacity \nmethod. Assuming that the generator makes at least these deci\u00adsions, it produces a program like the following, \nwhich trig\u00adgers the .rst bug, an array bounds error. BoundedStackI s = new BoundedStack(); s.push_n(s.capacity(),s); \n  e ::= .x. e t ::= x:t,e x:t,e e(e) Int x Bool let x = e in e die(msg) if (e) { e } else { e } true \nfalse integer Figure 3: Grammar To .x this bug, the capacity method should return bound-tos-1. This \nbug is relatively easy to .nd. Our algorithm .nds it 1 in 12 tries, or about once every three quarters \nof a second on a 3 GHz iMac. To discover the bug in the revision of the ObserverI interface, the generator \nmust decide to call the add_obs method, which would trigger the decision to create an imple\u00admentation \nof the ObserverI interface. In the body of the generated ObserverI s after_push method, the gener\u00adator \nmust invoke the stack s pop method. Finally, the gen\u00aderator would have to decide to push something onto \nthe ob\u00adserved stack. Putting all of that together, the generator would produce code something like the \nfollowing: class Observer implements ObserverI { public void after_push(BoundedStack s, Object item) \n{ s.pop(); } } BoundedStackI s = new BoundedStack(); s.add_obs(new Observer()); s.push(\"item\"); This \ncode signals an error blaming the BoundedStack s push method for failing to establish its post-condition. \nThe .x is to restore the pre-and post-condition contracts in the ObserverI interface, properly shifting \nthe blame to the observer. While this second bug requires the generator to make several fortuitous choices, \nour experiments suggest that it does so about 1 in 250 tries, i.e., about once every one and a half minutes \non the same machine. To .nd this bug, the generator must construct and evaluate larger programs than \nwere required to .nd the .rst bug; consequently, it performs fewer tests per second.  4. Formal model \nThis section makes the intuitive description in section 3 pre\u00adcise via a formal model. Central to our \nmodel are judgments of the form G f t . e This judgment is derivable when our technique could gener\u00adate \nthe expression e of type t from an environment G.For agiven G and t, derivations for many different e \nare typi\u00adcally possible, corresponding to the many different expres\u00adsions that a random generator might \nproduce. 4.1 Language Figure 3 shows a simple functional language that we use for our formal model. This \nlanguage does not include an object system or state, which we omit to simplify the formal pre\u00adsentation. \nSection 5 discusses the generalization to objects and state. For now, it is enough that . produces a \nparticu\u00adlarly simple form of an object one with a single method, where its .elds are implicit in its \nenvironment.1 Beyond ., our formal language contains application ex\u00adpressions, variables, let expression \nto bind temporary vari\u00adables, die expressions that terminate the program with a .xed message, if expressions \n(analogous to ...?...:... expres\u00adsions in Java and C), integers, and the booleans true and false. We \nomit the operational semantics for this language, as it is standard (Felleisen et al. 2009, Ch. 4). \n 4.2 Types The type system for the simple functional language layers contracts on top of a standard type \nsystem. Base types are either Int or Bool. Function types combine a standard arrow type with pre-condition \nand post-condition expressions of type Bool. The domain portion x1:t1,e1 of an arrow type consists of \nthe domain s type t1 as well as a boolean-valued pre-condition expression e1.The variable x1 is bound \nto the input to the function and is visible in e1 but not in t1.The codomain portion x2:t2,e2 of the \narrow type is similar, with t2 being the codomain type and e2 the post-condition. Both variables x1 and \nx2 are bound in the post-condition, and the variable x1 is bound in the type t2. For example, assuming \na few more numeric operations, the type d:Int,d = 0 . r:Int,abs(d*d-r) = 0.01 describes the sqrt function. \nTo capture the various constraints about free variables, and to make sure that the expressions embedded \nin types are well-formed, we de.ne the judgment Gf t as shown in .gure 4. It determines when a type t \nis well\u00adformed, given an environment G that maps variables to their types, and it refers to the typing \nrules for expressions em\u00adbedded in types. Similarly, the judgment f G 1 While this point of view may \nlead you astray for other aspects of relating functional and object-oriented languages, it works well \nfor the purposes of our random test case generation algorithm.  G+{x1:t1} e: t2 G x1:t1,e1 x2:t2,e2 \nG e : x1:t1,e1 x2:t2,e2 G e' : t1 G(x) = t G (.x. e2)(e1) : t G .x1. e : x1:t1,e1  x2:t2,e2 G e(e') \n: t2 G x: t G let x = e1 in e2 : t G e1 : Bool G e2 : t G e3 : t G t G integer : Int G if (e1) { e2 \n} else { e3 } : t G true : Bool G false : Bool G die(tag): t  GG t \u00d8 G+{x:t} G t1 G+{x1:t1} t2 G+{x1:t1} \ne1 : Bool G+{x1:t1, x2:t2} e2 : Bool G  Bool G Int G x1:t1,e1 x2:t2,e2 Figure 4: Typing rules G(x) \n= t G(f) = x1:t1,e1  x2:t2,e2 G t1 . e' G+{x2:t2} t3 . e3 [Var] [Call] G t . x G t3 . let x1 = e' in \nlet x2 = if (e1) { f(x1) } else { die(gen)} [True] in if (e2) { e3 } else { die(prog)} G  Bool . true \nt2 . e' [False] G+{x1:t1} [Fn] G  Bool . false G x1:t1,e1  x2:t2,e2 . .x1. if (e1) { let x2 = e' in \nif (e2) { x2 } else { die(gen)}} [Number]  else { die(prog)} G Int . integer Figure 5: Test case generation \nrules holds when G contains only well-formed types. The remaining rules in .gure 4 give types to expressions, \nand are standard, except that they use G f t judgments to ensure that programs have only well-formed \ntypes.  4.3 Generating programs The core system is given in .gure 5. The rules are divided into two \ngroups. The upper two rules use the environment to generate new expressions. The upper-left rule [Var] \nsim\u00adply says that if the environment contains a variable bound to the type to be synthesized, then the \ngenerator s result can be a reference to that variable. The upper-right rule [Call] optimistically generates \na call to some function in the envi\u00adronment to see if that will help with generation. Speci.cally, it \nsays that if f is bound to a function of type x1:t1,e1 . x2:t2,e2, and if generating a value of type \nt1 succeeds, then the generator can try to produce a t3 (the original goal) using an environment that \ncontains a binding of x2 to some value of type t2. Since the [Call] rule generates a call to a function \nin the environment, it must verify that the pre-condition holds, so it produces an if expression that \ntests the pre-condition. When it fails, we know that the generator produced a bad test case, and thus \nthe else branch of the if blames the generator. Dually, when the called function returns, we test the \nfunction s post-condition to see if the call reveals bug. If so, the test case aborts, blaming the function. \nThe remaining rules generate expressions directly, with\u00adout using the environment. The [True], [False],and \n[Num\u00adber] rules generate base values. The .nal rule [Fn] generates a function by adding the parameter \nto the function to the environment and generating a body expression of the range type. Of course, the \nfunction may not live up to its post\u00adcondition. In that case, the generated expression is bad, and the \ntest case will abort while blaming the generator to indi\u00adcate a test-generation failure. If the pre-condition \nfails, how\u00adever, then the program being tested supplied a bad input to  [Base] [Base] [Var] G+{d1:Int} \n Int . 2 G+{g:Doubling} Int . 2 G+{g:Doubling, r2:Int} Int . r2 [Fn] [Call] G  Increasing . G+{g:Doubling} \nInt . let d2 = 2 .d1. let r1 = 2 in let r2 = g(d2) in if (d1 = r1) { r1 } in if (2*d2 = r2) { r2 } else \n{ die(gen)} else { die(prog)} [Call] G Int . let g = f(.d1. let r1 = 2 in if (d1 = r1) { r1 } Shorthands \nIncreasing = d1:Int r1:Int,d1 = r1 Doubling = d2:Int r2:Int,2*d2 = r2 G = {f:Increasing Doubling} else \n{ die(gen) }) in let d2 = 2 in let r2 = g(d2) in if (2*d2 = r2) { r2 } else { die(prog)}  Figure 6: \nExample derivation the function, and so the test case also aborts but this time blaming the program to \nindicate a bug.  4.4 An example To get a better feel for how the rules work, consider the ex\u00adample \nderivation in .gure 6. The derivation uses a number of shorthands to avoid clutter. Speci.cally, if any \nof the pre\u00ador post-conditions are just true, then they are omitted; sim\u00adilarly any if expressions that \nwould have been generated to test such pre-or post-conditions are also omitted. In addi\u00adtion, the three \nshorthands in the box are used throughout. The derivation starts by trying to generate an Int using an \nenvironment that contains a single function f. The func\u00adtion f accepts a monotonic function, speci.ed \nvia the type Increasing. It returns another function that promises to re\u00adturn something larger than twice \nits input, as speci.ed via the type Doubling. The .rst step of the derivation uses the [Call] rule, pick\u00ading \nf from the environment. The left-hand derivation sub-tree generates the argument to pass to f, and the \nright-hand sub\u00adtree uses the larger environment to generate the original goal, an expression of type \nInt. First, consider the generation of f s argument. It must gen\u00aderate something of the type Increasing, \nsince that is the type of f s argument. To do so, this derivation uses the [Fn] rule, which extends the \nenvironment with something of the input type and generates a function body. In this case, the derivation \nuses the [Base] rule to generate the result of the function, namely the number 2. Once the body of the \nfunc\u00adtion is generated, it can be packaged into the .-expression by the [Fn] rule, along with a check \nof Increasing s post\u00adcondition. Having completed the derivation of the the argument to f, turn to the \nother half of the main derivation, which is the second occurrence of the [Call] rule. This time, the \nderiva\u00adtion uses the [Call] rule to generate a call to g, the variable it chose for the result of the \ncall to f. Thus, g has the type Dou\u00adbling. This time, the premises of the [Call] are ful.lled with a \nuse of the rule [Base] and a use of the rule [Var].The .rst builds the argument to g, and the second \nbuilds the overall result of the program, using the result of the call to g. Notice that there are two \nnon-trivial contracts embedded in in the original type for f. One appears as the post-condition to f \ns input, and the other appears as the post-condition to f s result. In the .nal program generated by \nthe derivation, there are two uses of die, one corresponding to each contract. The .rst use of die comes \nfrom the post-condition of f s input; since it appears an odd number of times to the left of the arrow, \nthe blame lies with the test case, so we see gen. The second use of die comes from the post-condition \nof f s result; since it appears an even number of times to the left of the arrow (i.e., zero times), \nthe blame lies with the function, so we see prog. Finally, if f were the function .g.g(2)*10, then the \ntest case would abort with the blame assigned to the generator. If, on the other hand, f were .g..x.g(g(x)), \nthen the test case would abort with the blame assigned to the program, detecting a bug.  4.5 A theorem \nUsing a formal system to de.ne our generation strategy lets us establish some properties. For example, \na natural question about this system is whether all generated terms indeed have the types they should. \nFormally, we can express the answer as a theorem. Theorem. If f G and G f t . e, then G f e: t The proof \nof this theorem is a straightforward induction on the structure of the derivation of G f t . e. If the \n[Var] rule is the last rule in the derivation, then we can use the type checking rule for variables, \nsince the premises match. If the [Call] rule is used, then, by induction, we have derivations of G f \ne: t1 and G+{x2:t2}f e3 : t3. Also, since f G, we know that the expressions e1 and e2 both have type \nBool . Given that, and the rules for typing expressions, we can construct a derivation that the right-hand \nside of the [Gen] has type t3. In the base type cases, we know that the generated term type checks, and \nthe [Fn] rule follows a similar argument to the [Call] rule.  4.6 The value of a formal model Most \nof the testing literature uses algorithmic pseudocode (or sometimes just prose) to describe its techniques. \nWe in\u00adstead follow the established conventions of the type systems and operational semantics literature \nand use a formal system to describe the tests our technique can create. We believe this shift bene.ts \nboth readers and authors. A formal model provides readers a more precise and, in our opinion, a clearer \naccount of our technique than we could give with pseudocode, which easily hides subtle but impor\u00adtant \ndetails. Precision and clarity bene.t authors too. Con\u00adstructing a formal model helped us better understand \nour own technique even after implementing a working proto\u00adtype. For example, consider the [Call] rule \nin Figure 5. The .nal premise generates e3 using an environment that does not include x1, though that \nresult could fruitfully contribute to e3. We devised the rule in the .gure by examining the prototype \ns implementation, but only after seeing the bind\u00ading structure in the rule s precise notation did it \nbecome ob\u00advious that the generated programs could make better use of intermediate results.  5. From \n. to a real language Our prototype tool converts the rules of section 4 into a test-generation algorithm. \nIt also scales the test-generation rules to handle many features of Racket, including con\u00adtracts (Findler \nand Felleisen 2002), classes (Flatt et al. 2006), richer function-calling conventions (Flatt and Barzi\u00adlay \n2009), and the Scheme numeric tower. Finally, it ad\u00addresses the practical problems of avoiding bad test \ncases and dealing with non-termination. 5.1 A full-.edged programming language Generalizing from the \nsimple programming language in sec\u00adtion 4 to Racket requires a number of extensions to the rules. The \nprimary extension adds support for Racket s object sys\u00adtem. Like Java, Racket has a class-based object \nsystem; un\u00adlike Java, classes in Racket are .rst-class values, and the ob\u00adject system supports a wide \nrange of method combinations. Like Java, subclasses may override methods; unlike Java, subclasses may \naugment methods, a la gbeta (Ernst 1999; Flatt et al. 2006). To support Racket s object system, we extend \nthe type system to allow class types and object types. A new rule, similar to the [Fn] rule, allows the \nsystem to generate a subclass of an existing class. Another new rule, similar to the [Call] rule, generates \na method invocation. In addition, we generalize the [Call] rule to support Racket s more sophisticated \nfunction-call conventions: multi\u00adarity functions that support optional arguments and keyword arguments, \nas well as a case-lambda form that allows dispatching on the number of arguments at a call site. Sup\u00adport \nfor these function forms mostly requires bee.ng up the [Call] rule (and the rule for method invocation). \n Figure 7: Subyping Finally, we add many new rules like the ones for base types, to handle generation \nof expressions satisfying the contracts that commonly appear in the Racket codebase. 5.2 Subtyping Racket \ninherits Scheme s sophisticated number system, in\u00adcluding complex numbers, exact rationals, and IEEE \n.oat\u00ading point numbers. The library that we tested required only some of the many different number types \nin Racket; .gure 7 shows the precise ones that we used and their subtyping re\u00adlationships. The library \nwe tested also used many other more conventional subtyping relationships, such as the contravari\u00adant \nrelationship for function types, the class inheritance hier\u00adarchy, and the normal relationships between \npairs, lists, and other compound types. Adding subtyping to the system amounts to changing the [Var] \nrule so that it allows picking a type out of the environment that is a subtype of the desired type. \n 5.3 An algorithmic version of the rules The rules in section 4 admit a wide range of possible pro\u00adgrams, \nand they allow multiple derivations for most combi\u00adnations of a particular type and an environment. To \nbuild an algorithm for generating a program, we use three techniques: randomness to choose a rule when \nmultiple rules (or multiple instances of a given rule) apply, a depth bound to limit the size of derivations, \nand continuation-passing style to support backtracking when some part of a generation fails.  Our top-level \ngenerator function has the signature generate : type env depth (expression -> X) (-> X) -> X The \n.rst two arguments match the rules. The third argument speci.es a depth bound; when it reaches zero, \nthe generator fails. The .nal two arguments are success and failure contin\u00aduations. When the generator \nsucceeds, it invokes the success continuation with the expression that it built. When the gen\u00aderator \nfails, it invokes the failure continuation. Using con\u00adtinuations in this manner make it easy to implement \nback\u00adtracking.2 For example, the generator may attempt to use the [Call] rule and perhaps even succeed \nto build one of the argu\u00adments to the function or method, but then fail to build a later argument. In \nthat case, the failure continuation will abort the entire attempt to use [Call] rule and try something \nelse. Our algorithm gives priority to the [Call] rule, special\u00adized to imperative methods and functions. \nIt will, with 80% chance, pick an imperative-looking method or function from the environment and use \nthe [Call] rule to invoke that method or function. We use a simple test to determine if a method or function \nis imperative: its name ends with ! or begins with set-(these being standard conventions in the Racket \ncode\u00adbase) or it produces a result of type void. For the remain\u00ading 20% of the time, the generator chooses \nequally among the other three rules or a use of the [Call] rule that invokes a function or method that \ncan produce a subtype of the goal type. (This second sort of use of the [Call] rule is what would have \ntriggered the derivation shown in section 4.4.) The depth bound is important for controlling the size \nof generated expressions. For example, suppose that the goal type is integer and that the environment \ncontains an impera\u00adtive function on integers. Choosing to call this function dou\u00adbles the size of the \ngeneration problem we now need to construct two integers: one as an argument to the imper\u00adative function, \nand one to satisfy the initial goal. Choos\u00ading to double the problem size 80% of the time can easily \nproduce an expression whose representation consumes hun\u00addreds of megabytes of memory. To avoid such a \ndistribution, we decrement the depth bound each time we apply a rule that can increase the number of \ngoals; if the bound reaches zero, we avoid such rules. 2 In our experience, backtracking does not substantially \nincrease the gener\u00adator s running time. For example, in generating a batch of programs with average length \n120 LOC, our algorithm invokes 150 failure continuations per program on average.  5.4 Trying harder \nto avoid failure The rules contain two expression templates that signal errors assigning blame to the \ngenerated program. In both cases, an if expression guards the failure. In our prototype, we use that \nconditional to make a few additional attempts to try to satisfy the pre-condition. The failure that blames \nthe generator in the [Fn] case matches the generator s failure when our prototype tries to construct \nthe result of a method. Our generator often constructs methods to override other methods. In that case, \nthe generated expression can avoid signaling blame directly, and instead try to make a call to a super \nmethod. Of course, the super call may also fail and blame the generator if the pre-condition of the method \nfails, but that kind of failure is much less likely. A failure in the [Call] rule is also easily avoided \nin prac\u00adtice. Speci.cally, the generator creates a backup expression that it puts in place of the expression \nthat blames the gen\u00aderated program. When the depth is too low to generate a backup expression, the generator \naborts the entire call at\u00adtempt. 5.5 Non-terminating programs When overriding a methods that involves \ncallbacks, the test generator can easily produce an in.nite loop. For example, with the bounded stack \nexample from section 3, overrid\u00ading the after_push to invoke the stack s push method would produce a \nprogram that loops forever. To avoid in.\u00adnite loops, the generator adds a counter to every generated \nmethod and function; each time the method or function is called, the counter decrements. If the counter \nreaches zero, the program aborts with a message indicating why, and we discard the test case.  6. Evaluation \nTo evaluate our random-testing technique, we applied it to the implementation of DrRacket s editor class. \nThe editor implementation is more .exible and open than a typical text editor. As with a conventional \neditor, it supports linear sequences of text, but it abstracts over the objects that can appear in an \neditor, insisting only that they be derived from the snip% class. Beyond simple string snips, images \nand even nested editors can appear inside an editor. (DrRacket uses nested editors to allow, for example, \nembedded XML code inside a Racket program). The editor classes are also extensible in the way that the \nsnips are positioned. The text% class implements an editor that arranges the snips in lines and inserts \nnewlines as needed to make the content .t. The pasteboard% class allows snips to .oat in a free-form \nmanner (which DrRacket uses to display graphs and to implement a GUI-layout editor). All of this extensibility \nmakes the editor classes a perfect opportunity to test our randomized-testing tool.  Bug category Requires \noverriding Number of bugs documentation bugs no 16 .rst-order bugs no 13 system dependence on default \nimplementation yes 1 missing state .ag-based pre-condition yes lots (>20) methods that should have been \n.nal yes 7 state .ags wrong during object initialization yes 1 Total: lots + 38 Figure 8: Bug summary \nThe results of our evaluation are summarized in .gure 8. Each row corresponds to a certain category of \nbugs, showing a brief description of the bugs, whether the bugs require overriding, and the number of \nbugs found in that category. The categories are ordered by increasing complexity. The .rst row contains \nbugs that we are embarrassed to report. Speci.cally, the Racket contract system does not yet support \nthe language s higher-order class system. Conse\u00adquently, the contracts on editor classes were written \nonly in the documentation; separate, hand-rolled checks are in the implementation. To run our prototype, \nwe wrote a parser that builds contracts from the documentation source. If the resulting contracts were \nadded in a checkable way instead of just to documentation, we believe that all of the errors in these \ncontracts would have been found by simply starting up DrRacket.3 The second row in the table represents \nbugs that could have been found by many existing random-testing tools. Here is an example of a (simpli.ed) \ntest case for one of those bugs: (define sl (new style-list%)) (define bs (send sl basic-style)) (define \njs (send sl find-or-create-join-style bs bs)) (send sl new-named-style \"The Name\" js) Finding this \nbug requires only that the testing tool be able to call methods and put their results together. The remaining \nfour lines correspond to bugs that, to the best of our knowledge, can be found automatically only by \nour tool. The .rst of these lines represents a bug where a derived editor class, scheme:text%, overrides \nthe get-keymap 3 Happily, we expect this implementation .aw to be remedied soon (Strick\u00adland and Felleisen \n2010. To Appear). method from the text% classinsucha waythat it never returns #f (even though its contract \nallows that). Other parts of the same subclass assume that get-keymap never re\u00adturns #f, but the subclass \ndoes not prohibit future exten\u00adsions to the get-keymap method. To expose the bug, the test generator \ncreated an example like the following, making get-keymap return #f; simply creating an instance of the \nderived class triggers the error. (define t% (class scheme:text% (define/override (get-keymap) #f) (super-new))) \n (new t%) The .nal three lines in .gure 8 concern bugs that incor\u00adrectly cope with the locking mechanism \nin the text% class. A text editor uses four different levels of locking: unlocked, where any method can \nbe called; .ow locked, where methods that can change the locations of soft line breaks are forbid\u00adden; \nwrite locked, where methods that change the content of the editor are forbidden; and read locked, where \nnearly all of the methods are forbidden. Each of these modes has a match\u00ading boolean-valued method (that \ncan always be called) that exposes whether the editor is in the corresponding mode. The most common bug \nin these categories concern in\u00adaccurate method pre-conditions. For example, this program triggers a contract \nviolation of the delete method s pre\u00adcondition: (define t% (class text% (define/augment (on-insert x \ny) (send this clear)) (super-new))) (send (new t%) insert \"y\") The delete s method can only be called \nin the unlocked state, but during the dynamic extent of clear, the editor is write locked. The bug is \nthat the clear method s pre\u00adcondition should say that it can only be called in the un\u00adlocked state. We \nfound 7 bugs where methods that were public should have been .nal. For example, the in-edit-sequence? \nmethod queries some internal state of an object. If it is overridden to return a bogus version of the \nstate, then this program will fail. (define t% (class text% (define/override (in-edit-sequence?) #f) \n(super-new))) (send (new t%) undo)  This program fails because the contract for the undo method calls \nend-edit-sequence, whose contract is phrased in terms of the overridden method, in-edit-sequence?. Since \nthat method is now returning bogus values, the con\u00adtract fails when it should not. Five of the other \nbugs in this category are similar to this one, where the overridden method fails to accurately report \nsome internal state of the object. The remaining bug, however, required the paragraph-start-position \nmethod to be overridden. That method s job is to return the position in the text% object where a paragraph \nbegins, i.e., a position just after a newline in the editor. When it fails to do so, it causes the line-breaking \nalgorithm to fail internally with an array-indexing error. Finally, the remaining bug was that the text% \nstate vari\u00adables were not initialized properly during the dynamic extent of the call to the constructor. \nThe object should have been completely locked during this time and, once the constructor .nished, it \nshould have been unlocked. Discovering this bug requires the test case generator to override a method \nthat is called during the dynamic extent of the constructor, like the default-style-name method is in \nthis case: (define t% (class text%  (define/override (default-style-name) (send this line-paragraph \n1) \"Standard\") (super-new))) (new t%) The other editor class, pasteboard%, does not suffer from this \nbug, because it does not invoke any overridable methods during its initialization.  7. Related Work \nThe test generation literature is vast. To narrow the discus\u00adsion, we restrict our attention to techniques \nthat test imper\u00adative object-oriented programs using a sequence of method and constructor calls. This \ndistinction excludes tools such as DART (Godefroid et al. 2005), CUTE (Sen and Agha 2006), and EXE (Cadar \net al. 2006), which test a program by gen\u00aderating its top-level input, since our focus is unit-level \ntests of stateful, reusable components. Even within this restricted class, testing techniques vary widely. \nRostra (Xie et al. 2004) and JPF (Visser et al. 2006) perform bounded exhaustive testing, using state \nmatching to avoid generating redundant sequences. Symstra (Xie et al. 2004), and PEX (Tillmann and Halleux \n2008) choose sequences based on symbolic execution and constraint solv\u00ading. A recent re.nement of Pex \n(Barnett et al. 2009) uses .rst-order contracts to guide symbolic execution and detect bugs. Crash n \nCheck (Csallner and Smaragdakis 2005) and its successor DSD-Crasher (Csallner and Smaragdakis 2006) use \na constraint solver to extract concrete tests from warnings produced by ESC/Java (Flanagan et al. 2002). \neToc (Tonella 2004) evolves test sequences using a ge\u00adnetic algorithm based on coverage. JCrasher (Csallner \nand Smaragdakis 2004) and Randoop (Pacheco et al. 2007) con\u00adstruct sequences at random. Others, such \nas Evacon (Inkum\u00adsah and Xie 2009) and MSeqGen (Thummalapenta et al. 2009), combine several techniques. \nOur technique builds on the generation strategies em\u00adployed in JCrasher and Randoop. The generation rules \nin .g\u00adure 5, which allow tests to construct arguments by combin\u00ading values in the environment, can be \nseen as an extension of the parameter-graph JCrasher uses to select method ar\u00adguments. Following Randoop, \nour generation algorithm of\u00adfers two improvements over JCrasher. First, our rules give names to (some) \nintermediate results, allowing generation of sequences like the following: BoundedStack s = new BoundedStack(); \n s.push_n(s.capacity()); As Pacheco et al. note, JCrasher s algorithm cannot pro\u00adduce a BoundedStack \nin this con.guration because the objects it constructs as method arguments .ow only to the corresponding \ncall sites, without contributing to any other expression. Second, JCrasher s algorithm never chooses \nto call a method returning void, in order to reduce the size of its search space; our algorithm, on the \nother hand, deliber\u00adately generates calls to methods with side-effects (identi.ed heuristically according \nto their name and result type). This is crucial for generating the methods of a class whose objects are \nused as callbacks. Unlike our algorithm, which promises to generate an ex\u00adpression of a requested type, \nRandoop generates sequences that result in a value of a random type. Its algorithm gener\u00adates a sequence \nby iteratively appending a call to a method chosen at random, without regard for its result type. For \nmany classes, this strategy works well, due to Randoop s feedback-directed heuristics, but because it \ndoes not seek a result of any particular type, its sequences cannot be used as method bodies, as those \nrequire a result of a speci.ed type. To the best of our knowledge, none of the aforemen\u00adtioned tools \ngenerate tests for open classes such as Bound\u00adedStack, where a method takes an instance of an ab\u00adstract \nclass of which implementations do not exist or rep\u00adresent only a small portion of possible use cases. \nJSCon-Test (Heidegger and Thiemann 2010), a contract-driven ran\u00addom test generator for JavaScript, offers \nsome support for testing open classes in the form of higher-order functions, but the functions it constructs \nas test inputs do not have side-effects and do not make use of their arguments (except to check their \ncontracts). Kiasan/KUnit (Deng et al. 2007), another contract-driven tool supporting open classes, con\u00adstructs \nmore sophisticated inputs using symbolic execution and constraint solving, but the mock objects it constructs \nas inputs have no side-effects except the ones prescribed by their contracts. This restriction hides \nthe stack observer bug, where a loose contract is precisely the problem.  QuickCheck (Claessen and Hughes \n2000), a random test\u00ading library for Haskell, provides .exible support for testing higher-order functions. \nGiven user-de.ned speci.cations of a program s types, QuickCheck automatically derives gen\u00aderators for \nfunctions that consume and produce those types. Although targeted at pure functional programs, QuickCheck \nworks with imperative programs too (Claessen and Hughes 2002). The approach Claessen and Hughes describe \nis likely to reveal the stack observer bug, but .nding the off-by-one error is more dif.cult. QuickCheck \nis less automated than the above tools, and its effectiveness depends substantially on user con.guration. \nFor example, QuickCheck is unlikely to .nd the off-by-one error unless the user has the insight that \nthe capacity method produces interesting arguments to the stack s other operations.  8. Conclusion Testing \nopen object-oriented systems is dif.cult because un\u00adknown classes may drive them in surprising ways. \nWe de\u00adscribe a new algorithm for testing such systems which works by randomly constructing new subclasses \nbased on the con\u00adtracts speci.ed for their interface. Our experience shows that our technique works well, \n.nding dozens of bugs in Dr-Racket, and is easy to implement. Still, our experience suggests some improvements. \nFirst, the test cases produced by our prototype are often unneces\u00adsarily large. The algorithm described \nin section 5.3 takes as input a bound on the depth of program derivations to con\u00adsider, and the test \nprograms it produces tend to grow expo\u00adnentially with this bound. Often, a derivation of depth 5 is necessary \nto uncover a bug, but typically only one particu\u00adlar branch of the derivation actually requires this \ndepth. We speculate that using a different strategy for limiting the size of the generated terms (e.g., \nrandomly divving up a bound between subderivations to limit the tree s size instead of its depth) would \nenable us to .nd the same bugs, but without generating such large programs. Second, as discussed in sec\u00adtion \n4.6, our prototype would likely be more effective if the programs it produced reused more intermediate \nresults.  Bibliography Mike Barnett, Manuel Fahndrich, Peli de Halleux, Francesco Lo\u00ad gozzo, and Nikolai \nTillmann. Exploiting the Synergy between Automated-Test-Generation and Programming-by-Contract. In Proc. \nIntl. Conf. Soft. Eng.: Companion Volume, pp. 401 402, 2009. Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, \nDavid L. Gill, and Dawson R. Engler. EXE: Automatically Generating Inputs of Death. In Proc. ACM Conf. \nComputer and Communications Security, pp. 322 335, 2006. Koen Claessen and John Hughes. QuickCheck: A \nLightweight Tool for Random Testing of Haskell Programs. In Proc. ACM Intl. Conf. Functional Programming, \npp. 268 279, 2000. Koen Claessen and John Hughes. Testing Monadic Code with QuickCheck. In Proc. ACM \nSIGPLAN Haskell Wksp., pp. 47 59, 2002. Cristoph Csallner and Yannis Smaragdakis. JCrasher: An Auto\u00admatic \nRobustness Tester for Java. Software Practice &#38; Ex\u00adperience 34(11), pp. 1025 1050, 2004. Cristoph \nCsallner and Yannis Smaragdakis. DSD-Crasher: A Hy\u00adbrid Analysis Tool for Bug Finding. In Proc. Intl. \nSymp. Soft. Testing and Analysis, pp. 245 254, 2006. Cristoph Csallner and Yannis Smaragdakis. Check \nn Crash: Com\u00adbining Static Checking and Testing. In Proc. Intl. Conf. Soft. Eng. , pp. 422 431, 2005. \nXianghua Deng, Robby, and John Hatcliff. Kiasan/KUnit: Auto\u00admatic Test Case Generation and Analysis Feedback \nfor Open Object-Oriented Systems. In Proc. Testing: Academia &#38; Indus\u00adtry Conference Practice &#38; \nResearch Techniques, pp. 3 12, 2007. Erik Ernst. gbeta a Language with Virtual Attributes, Block Structure, \nand Propagating, Dynamic Inheritance. PhD disser\u00adtation, Department of Computer Science, University of \nAarhus, Denmark, 1999. Matthias Felleisen, Robert Bruce Findler, and Matthew Flatt. Se\u00admantics Engineering \nwith PLT Redex. MIT Press, 2009. Robert Bruce Findler, John Clements, Cormac Flanagan, Matthew Flatt, \nShriram Krishnamurthi, Paul Steckler, and Matthias Felleisen. DrScheme: A programming environment for \nScheme. J. Functional Programming 2(12), pp. 159 182, 2002. Robert Bruce Findler and Matthias Felleisen. \nContracts for Higher-Order Functions. In Proc. ACM Intl. Conf. Functional Program\u00adming, pp. 48 59, 2002. \nCormac Flanagan, K. Rustan M. Leino, Mark Lillibridge, Greg Nelson, James B. Saxe, and Raymie Stata. \nExtended Static Checking for Java. In Proc. ACM Conf. Programming Language Design and Implementation, \npp. 234 245, 2002. Matthew Flatt and Eli Barzilay. Keyword and Optional Arguments in PLT Scheme. In Proc. \nScheme and Functional Programming, pp. 94 102, 2009. Matthew Flatt, Robert Bruce Findler, and Matthias \nFelleisen. Scheme with Classes, Mixins, and Traits (invited tutorial). In Proc. Asian Symp. Programming \nLanguages and Systems, pp. 270 289, 2006. Matthew Flatt and PLT. Reference: Racket. June 7, 2010. http://www.racket-lang.org/tr1/ \n Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns. Addison-Wesley Publishing \nCompany, 1994. Patrice Godefroid, Nils Karlund, and Koushik Sen. DART: Di\u00adrected Automated Random Testing. \nIn Proc. ACM Conf. Pro\u00adgramming Language Design and Implementation, pp. 213 223, 2005. Phillip Heidegger \nand Peter Thiemann. JSConTest -Contract-Driven Testing of JavaScript Code. In Proc. Intl. Conf. Objects, \nModels, Components, Patterns, pp. 154 172, 2010. Kobi Inkumsah and Tao Xie. Improving Structural Testing \nof Object-Oriented Programs via Integrated Evolutionary Testing and Symbolic Execution. In Proc. IEEE/ACM \nIntl. Conf. Auto\u00admated Soft. Eng. , pp. 297 306, 2009.  Carlos Pacheco, Shuvendu K. Lahiri, Michael \nD. Ernst, and Thomas Ball. Feedback-Directed Random Test Generation. In Proc. Intl. Conf. Soft. Eng. \n, pp. 75 84, 2007. B.S. Rubin, A. R. Christ, and K. A. Bohrer. Java and the IBM San Franscisco project. \nIBM Systems Journal 37(3), pp. 365 371, 1998. Koushik Sen and Gul Agha. CUTE and jCUTE: Unit Testing \nand Explicit Path Model-Checking Tools. In Proc. Intl. Conf. Com\u00adputer Aided Veri.cation, pp. 419 423, \n2006. T. Stephen Strickland and Matthias Felleisen. Contracts for First-Class Classes. In Proc. Dynamic \nLanguages Symposium, 2010. To Appear. Suresh Thummalapenta, Tao Xie, Nikolai Tillmann, Jonathan de Halleux, \nand Wolfram Schulte. MSeqGen: Object-Oriented Unit-Test Generation via Mining Source Code. In Proc. Joint \nEuro. Soft. Eng. Conf. and ACM Symp. Foundations of Soft. Eng. , pp. 193 202, 2009. Nikolai Tillmann \nand Jonathan de Halleux. Pex White Box Test Generation for .NET. In Proc. Intl. Conf. Tests and Proofs, \npp. 134 153, 2008. Paolo Tonella. Evolutionary Testing of Classes. In Proc. Intl. Symp. Soft. Testing \nand Analysis, pp. 119 128, 2004. Willem Visser, Corina S. Pasareanu, and Radek Pelanek. Test Input Generation \nfor Java Containers using State Matching. In Proc. Intl. Symp. Soft. Testing and Analysis, pp. 37 48, \n2006. Tai Xie, Darko Marinov, and David Notkin. Rostra: A Framework for Detecting Redundant Object-Oriented \nUnit Tests. In Proc. IEEE Intl. Conf. Automated Soft. Eng. , pp. 196 205, 2004. Tai Xie, Darko Marinov, \nWolfram Schulte, and David Notkin. Symstra: A Framework for Generating Object-Oriented Unit Tests using \nSymbolic Execution. In Proc. Intl. Conf. Tools and Algorithms for the Construction and Analysis of Systems, \npp. 365 381, 2004.  \n\t\t\t", "proc_id": "1869459", "abstract": "<p>Testing is among the most effective tools available for finding bugs. Still, we know of no automatic technique for generating test cases that expose bugs involving a combination of mutable state and callbacks, even though objects and method overriding set up exactly that combination. For such cases, a test generator must create callbacks or subclasses that aggressively exercise side-effecting operations using combinations of generated objects.</p> <p>This paper presents a new algorithm for randomly testing programs that use state and callbacks. Our algorithm exploits a combination of contracts and environment bindings to guide the test-case generator toward interesting inputs. Our prototype implementation for Racket (formerly PLT Scheme) - which has a Java-like class system, but with first-class classes as well as gbeta-like augmentable methods - uncovered dozens of bugs in a well-tested and widely used text-editor library.</p> <p>We describe our approach in a precise, formal notation, borrowing the techniques used to describe operational semantics and type systems. The formalism enables us to provide a compact and self-contained explanation of the core of our technique without the ambiguity usually present in pseudo-code descriptions.</p>", "authors": [{"name": "Casey Klein", "author_profile_id": "81470648816", "affiliation": "Northwestern University, Evanston, IL, USA", "person_id": "P2354103", "email_address": "", "orcid_id": ""}, {"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "University of Utah, Salt Lake City, UT, USA", "person_id": "P2354104", "email_address": "", "orcid_id": ""}, {"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "Northwestern University, Evanston, IL, USA", "person_id": "P2354105", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1869459.1869505", "year": "2010", "article_id": "1869505", "conference": "OOPSLA", "title": "Random testing for higher-order, stateful programs", "url": "http://dl.acm.org/citation.cfm?id=1869505"}