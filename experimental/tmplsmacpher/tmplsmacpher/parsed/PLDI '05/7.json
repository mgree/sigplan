{"article_publication_date": "06-12-2005", "fulltext": "\n Semantic Type Quali.ers Brian Chin Shane Markstrum Todd Millstein University of California, Los Angeles \n {naerbnic,smarkstr,todd}@cs.ucla.edu Abstract We present a new approach for supporting user-de.ned type \nre\u00ad.nements, which augment existing types to specify and check ad\u00additional invariants of interest to \nprogrammers. We provide an ex\u00adpressive language in which users de.ne new re.nements and as\u00adsociated type \nrules. These rules are automatically incorporated by an extensible typechecker during static typechecking \nof programs. Separately, a soundness checker automatically proves that each re\u00ad.nement s type rules ensure \nthe intended invariant, for all possible programs. We have formalized our approach and have instantiated \nit as a framework for adding new type quali.ers to C programs. We have used this framework to de.ne and \nautomatically prove sound a host of type quali.ers of different sorts, including pos and neg for integers, \ntainted and untainted for strings, and nonnull and unique for pointers, and we have applied our quali.ers \nto ensure important invariants on open-source C programs. Categories and Subject Descriptors D.2.4 [Software/Program \nVeri.cation]: reliability, validation; D.3.m [Miscellaneous]; F.3.1 [Specifying and Verifying and Reasoning \nabout Programs]: invariants, mechanical veri.cation, speci.cation techniques General Terms Languages, \nReliability, Veri.cation Keywords type quali.ers, extensible typechecking, type sound\u00adness 1. Introduction \nType systems are a natural discipline for ensuring that programs maintain certain run-time invariants. \nAs a simple example, if an expression can be given the type int, the programmer is assured (modulo type-unsafe \nfeatures like casts) that the expression will only ever evaluate dynamically to an integer value. Recent \nwork in our community has shown how to re.ne the types in traditional type systems to ensure other important \nkinds of run-time invariants, including memory safety (e.g., [38, 33, 23]), invariants about point\u00aders \nand their aliasing relationships (e.g., [8, 5, 1, 15]), and invari\u00adants about the interactions of threads \nin concurrent programs (e.g., [16, 4, 18]). The re.nements are achieved by augmenting standard types \nwith annotations that represent the additional properties of interest and augmenting standard type rules \nto check these annota\u00adtions statically. Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 05, June 12 15, 2005, Chicago, Illinois, USA. Copyright 2005 ACM \n1-59593-056-6/05/0006...$5.00. Of course, language designers cannot anticipate all the run\u00adtime invariants \nthat programmers will want to specify and check. Language designers also cannot anticipate all of the \npractical ways in which types may be re.ned in order to enforce a particular invariant. Therefore, it \nis desirable to provide a framework for user-de.ned type re.nements, whereby programmers can easily augment \na language s type system with new type annotations to ensure invariants of interest. For example, Foster \net al. describe CQUAL [19, 20], a system that allows programmers to de.ne new type quali.ers, such as \nnonnull and untainted, for C programs, and Mandelbaum et al. [27] provide a theory of type re.nements \nto specify and check properties, like temporal protocols, that depend on effectful computations. Despite \ntheir bene.ts, existing frameworks for user-de.ned type re.nements have important limitations that hinder \ntheir util\u00adity. First, they use a .xed set of type rules across all type re.ne\u00adments. Type-re.nement-speci.c \ninformation is provided by anno\u00adtating each program to indicate when the typechecker should as\u00adsume or \ncheck that a re.nement holds on some program fragment. While such annotations can simulate a limited \nform of re.nement\u00adspeci.c type rules, they are not expressive enough to handle many common situations. \nFor example, it would be dif.cult to simulate a type rule for some expression that depends recursively \non the types of subexpressions. Second, while existing frameworks ensure that programs re\u00adspect user-de.ned \ntyping disciplines, the type-re.nement designer must take responsibility for ensuring that his new typing \ndiscipline in fact guarantees the desired run-time program invariants. Any errors in the user-de.ned \ntyping discipline are undetected by the framework. For example, a program that is improperly annotated \nwith nonnull assumptions can typecheck in CQUAL but nonethe\u00adless cause a variable declared nonnull to \nhave the value NULL at run time. In this paper, we address these limitations of prior frameworks via \na novel approach to user-de.ned type re.nements: A language for type-re.nement rules. We provide an \nexplicit language in which users write type rules for their new re.ne\u00adments. This language enables the \nnatural expression of user\u00adde.ned typing disciplines, and it is much more expressive than the program \nannotations used by prior frameworks. An exten\u00adsible typechecker automatically incorporates user-de.ned \ntype rules during static typechecking of programs, in order to en\u00adforce users typing disciplines.  Semantic \nguarantees. We allow users to explicitly specify the run-time invariant that a type re.nement is meant \nto represent. We observe that for many interesting cases such invariants are quite natural and simple. \nA soundness checker automatically proves that each re.nement s type rules ensure the intended invariant, \nfor all possible programs.  We have instantiated our approach as a framework for adding user-de.ned \ntype quali.ers to C programs. The extensible type\u00ad 1. value qualifier pos(int Expr E)  2. caseEof  \n3. decl int Const C:  4. C,whereC>0  5. | decl int Expr E1, E2:  6. E1 * E2, where pos(E1) &#38;&#38; \npos(E2)  7. | decl int Expr E1:  8. -E1, where neg(E1)  9. invariant value(E) > 0  Figure 1. A user-de.ned \ntype quali.er and associated type rules for positive integers. int pos gcd(int pos n, int pos m); int \npos lcm(int pos a, int pos b) {int pos d = gcd(a, b); int pos prod =a*b; return (int pos) (prod / d); \n} Figure 2. Example code using the pos type quali.er. checker is implemented in the CIL [32] front end \nfor C. The sound\u00adness checker implements a proof strategy that requires a handful of proof obligations \nto be discharged. Our implementation employs Simplify [14], the automatic theorem prover from the Extended \nStatic Checker for Java (ESC/Java) [17], to automatically discharge these proof obligations. We have \nused our framework to de.ne and automatically prove sound a host of type quali.ers: quali.ers that restrict \nthe value of an expression, including nonnull, nonzero, pos, and neg; quali.ers that restrict the .ow \nof values through a program, including tainted and untainted [36]; and quali.ers that restrict a program \ns aliasing relationships, including unique and unaliased. We have used our quali.ers to ensure important \nprogram invariants on open-source C programs. In the next section, we overview our framework for user-de.ned \ntype quali.ers informally via a number of examples. Sections 3 and 4 describe the implementations of \nour extensible typechecker and soundness checker, respectively. Section 5 summarizes the formal details \nof our approach. Section 6 describes experience using our framework to check C programs. Section 7 compares \nwith related work, and section 8 concludes and discusses future directions. 2. Semantic Type Quali.ers \nOur framework supports two common classes of quali.ers, which are discussed in turn below. Value quali.ers, \nsuch as pos and nonnull, pertain only to the value of an expression. Reference quali.ers, such as unique \nand unaliased, (additionally) pertain to the address of an l-valuable expression (or l-value). Distinguishing \nbetween these classes of quali.ers allows us to provide specialized support for each one, making it easier \nfor users to de.ne quali.ers and for our framework to reason about them automatically. 2.1 Value Quali.ers \nFigure 1 illustrates a de.nition of the value quali.er pos in our framework, which can be used to statically \ntrack positive integers. Line 1 of the .gure declares pos to be a new value quali.er applicable to expressions \nof type int. It also declares a variable E, which is used in the rest of the quali.er s de.nition. Each \nvariable declaration includes a type and a classi.er. The declared classi.er Expr for E indicates that \nduring typechecking of a C program, E will be instantiated with side-effect-free program expressions. \nThe declared type for E constrains such expressions to have type int. In addition to the classi.er Expr, \nour framework supports the classi.ers Const, LValue, and Var, which represent C constants, l-values, \nand variables, respectively. Our implementation performs quali.er checking over programs in CIL s intermediate \nlanguage, which cleanly distinguishes expressions, which are side-effect-free, from instructions [32]. \nGiven the declaration in line 1 of .gure 1, programmers may now annotate their programs with the pos \nquali.er, as shown in the C code in .gure 2. The lcm procedure in the .gure computes the least-common \nmultiple of two integers. The pos quali.er is used to specify that the two arguments should be positive \nintegers and to ensure that the return value is also positive. To handle nested quali.ers unambiguously, \nwe use a post.x notation, whereby a quali.er quali.es the entire type to its left. A type may be annotated \nwith multiple user-de.ned quali.ers; their order is irrelevant. 2.1.1 Type Rules Line 1 of .gure 1 declares \nthe new pos quali.er, but it does not indicate how this quali.er should be used during typechecking. \nThis is the role of the case block beginning on line 2, which uses a form of pattern matching to indicate \na subset of expressions that can be given the type int pos. For example, the clause in lines 3\u00ad4 indicates \nthat a positive integer constant may be given the type int pos. The clause .rst declares the variable \nC, which ranges over integer constants from the underlying program, for use in the rest of the clause. \nIt then speci.es the pattern C, to indicate the syntactic form of the expression. Finally, the predicate \nC>0 further constrains an expression that matches the pattern. Type rules like the .rst case clause of \n.gure 1 can be simulated in systems like CQUAL [19] by annotating all positive integers in a program \nwith a pos assumption. However, the case clauses in our framework are more general. For example, the \nclause on lines 5-6 speci.es that an expression that is a product of two expressions of type int pos \ncan also be given the type int pos. This kind of recursive type rule would be quite dif.cult to manually \nencode using pos assumptions. The .nal case clause illustrates that the de.nition of a quali.er can depend \non other quali.ers. That clause speci.es that a negation expression can be given type int pos if the \nnegated expression can be given type int neg, where neg is another user-de.ned quali.er. In fact, quali.er \nde.nitions can be mutually recursive. For example, the de.nition of neg (not shown) has rules that refer \nto pos. The syntax for expression patterns in case clauses is de.ned by the following grammar: P ::= \nX |*X |&#38;X |new |uop X |X bop X Here X ranges over variable patterns, which have a declared type and \nclassi.er (e.g., int Expr) restricting the kinds of program fragments that may match. The pattern newmatches \nagainst calls to memory allocation routines like malloc1. Various unary and binary operations may also \nbe matched against; for simplicity we restrict their argument patterns to be variable patterns. The predicate \nafter (the optional) where in a case clause may include operations on constants and on variable patterns \nwith classi.er Const, quali.er checks on expressions and patterns, and conjunctions and disjunc\u00adtions \nof these kinds of predicates. Each clause of a case block can be viewed as an introduction type rule \nfor a quali.ed type, since the clause speci.es conditions under which an expression may be assigned that \nquali.ed type. As 1 Procedure calls, including malloc, are not in general side-effect-free and so are \nnot considered expressions by CIL. However, it is critical for some quali.ers that pertain to pointers, \nfor example unique, that we allow malloc to be matched against in quali.er de.nitions. value qualifier \nnonzero(int Expr E) case E of decl int Const C: C, where C != 0 | decl int Expr E1: E1, where pos(E1) \n | decl int Expr E1, E2: E1 * E2, where nonzero(E1) &#38;&#38; nonzero(E2) restrict decl int Expr \nE1, E2: E1 / E2, where nonzero(E2) invariant value(E) != 0 Figure 3. A type quali.er and associated \ntype rules for nonzero integers. discussed in section 5, we have formalized this semantics of the case \nclauses. Our framework includes an extensible typechecker, which uses the type rules de.ned by case blocks, \nalong with a set of standard rules for typechecking constructs like variable references, proce\u00addure calls, \nand assignments, to perform quali.er checking. Such checking validates the quali.er annotations supplied \nby the pro\u00adgrammer, which represent the programmer s assumptions about when particular invariants hold. \nConsider again the lcm procedure in .gure 2. As usual, type\u00adchecking an assignment statement involves \nobtaining the types of each side and checking that they match. The assignment to d type\u00adchecks successfully \nbecause both sides of the assignment have type int pos: the right-hand side is shown to have this type \nby the stan\u00addard type rule for procedure calls, given the declared type signature of gcd. The assignment \nto prod also typechecks successfully, be\u00adcause the caseclause on lines 5-6 allows a*bto be given the \ntype int pos. Because of their declared types, we statically know that both prodand dare positive, but \nthis information is not suf.cient to show that the expression (prod / d) is also positive. Indeed, the \ntype rules for pos are not able to derive the type int pos for that expression. Therefore, the programmer \nmust insert a cast to satisfy the typechecker, because of the declared return type of lcm. A caseblock \nspeci.es when an expression may be given a qual\u00adi.ed type. Users may then want to employ expressions \nhaving qual\u00adi.ed types to enhance the precision of existing typechecks from the base type system. Our \nframework provides a restrict block for this purpose, an example of which is shown in the de.nition for \na nonzero quali.er in .gure 3. The syntax of a restrict clause is identical to that of a case clause. \nA restrict clause speci.es that any expression in a given program that matches the clause s pattern must \nalso satisfy the clause s predicate. The restrict clause for nonzero augments the base rule for typechecking \ndivision expres\u00adsions to require that the denominator have the type int nonzero (rather than simply int). \nIn this way, division-by-zero errors can be detected statically instead of dynamically. For example, \nconsider again the lcm procedure in .gure 2. If the extensible typechecker is given the de.nition of \nnonzero in addition to that of pos, it will use nonzero s restrict clause to check the division in the \nlast statement of lcm s body. The restrict clause requires that d have the type int nonzero.By the second \ncase clause for nonzero in .gure 3, any expression of type int pos also has the type int nonzero. Since \nd is declared to have the type int pos, that case clause allows the restrict check to succeed. The restrict \nclause plays a role analogous to quali.er asser\u00adtions in CQUAL [19]. For example, the restrict type rule \nin .g\u00adure 3 could be simulated by annotating the denominator in each division in a program with a nonzero \nassertion. However, the restrict clause is more general. For example, the predicate in a restrict clause \nmay contain conjunctions and disjunctions of quali.er checks. 2.1.2 Subtyping It is natural to consider \nint pos to be a subtype of int. Subtyping provides more .exibility, for example allowing the following \ncode to typecheck: int pos x = 3; int y = x; Our extensible typechecker considers all value-quali.ed \ntypes to be subtypes of their associated unquali.ed types. More precisely, if q is a value quali.er and \nt is a (possibly quali.ed) type, then t q is considered to be a subtype of t. The rest of the subtyping \nrules are standard. As usual, care must be taken in the presence of pointers [19]. For example, it would \nbe unsound to consider int pos* to be a subtype of int*, because that would allow the following code, \nwhich stores a negative num\u00adber in a variable of type int pos, to typecheck: int pos x = 3; int* p = \n&#38;x; *p = -1; Section 5 contains the formal de.nition of our subtype relation. Our language for de.ning \nquali.ers does not support explicit subtype declarations between two user-de.ned quali.ers. However, \nsuch subtype relationships can be encoded using the case block. For example, the second clause in the \ncase block of nonzero s de.nition in .gure 3 effectively declares pos to be a subtype of nonzero: any \nexpression of type int pos may also be considered to have type int nonzero. 2.1.3 Soundness A user-de.ned \nquali.er and its associated type rules constitute a typing discipline, which is enforced by our extensible \ntypechecker. Often such typing disciplines are intended to ensure a particular run-time invariant. For \nexample, the typing discipline de.ned by the pos quali.er and associated type rules in .gure 1 is intended \nto guarantee that certain expressions only evaluate to positive integers at run time. However, the extensible \ntypechecker enforces user-de.ned typ\u00ading disciplines in a purely syntactic manner, without knowledge \nof the intended invariants. For example, suppose the pattern in the second case clause in the de.nition \nof pos in .gure 1 were erro\u00adneously speci.ed as E1-E2 instead of E1*E2. In that case, our typechecker \nwould happily use this revised type rule to check pro\u00adgrams, even though this can cause pos s intended \ninvariant to be violated at run time. Rather than forcing users to take responsibility for the correct\u00adness \nof their quali.ers, our framework supports automated sound\u00adness checking. A quali.er de.nition may optionally \nspecify the quali.er s associated invariant. The framework then automatically proves, independent of \nany particular program to be typechecked, that the quali.er s type rules establish this invariant. For \nexample, consider the de.nition of pos in .gure 1. Line 9 uses the invariant clause to provide the quali.er \ns associated run-time invariant. The invariant is a predicate that is implicitly de.ned in the context \nof an arbitrary run-time execution state. Let us denote this execution state by .. The valuepredicate \nis provided by our framework and represents the value of a given expression in .. Therefore, the invariant \nfor pos indicates that the value of an expression of type int pos should be greater than zero, in any \nrun-time execution state. value qualifier untainted(T Expr E) value qualifier tainted(T Expr E) case \nE of E Figure 4. Specifying a taintedness analysis in our framework. Given this invariant, our soundness \nchecker generates one proof obligation for each case clause and automatically discharges these obligations \nvia an off-the-shelf automatic theorem prover. Each clause s obligation simply requires that if an expression \nmatches the clause s syntactic pattern and satis.es the clause s predicate, interpreted in the context \nof an arbitrary run-time execution state ., then the quali.er s invariant also holds in .. For example, \nconsider the .rst case clause for pos in .gure 1. The soundness checker generates the following proof \nobligation: if an expression E is an integer constant that is greater than zero, then the value of E \nin an arbitrary execution state . is greater than zero. This obligation is easily proven, given the evaluation \nsemantics of integer constants. Now consider the second case clause for pos. The soundness checker generates \nthe following proof obligation: if an expression E has the form E1 * E2 and both E1 and E2 satisfy pos \ns invariant in an arbitrary execution state ., then Ealso satis.es pos s invariant in .. This obligation \nis easily proven by the semantics of multipli\u00adcation. On the other hand, if the pattern in that clause \nwere erro\u00adneously speci.ed as E1 -E2, the soundness checker would catch the error and warn the programmer, \nsince the associated proof obli\u00adgation would fail: it is not possible to prove that the difference of \ntwo arbitrary positive integers is also positive. The restrict clauses do not affect whether or not an \nexpression of quali.ed type satis.es its quali.er s invariant, so restrict clauses are ignored by the \nsoundness checker. The limitations of our language for writing type rules, and of static typechecking \nin general, will sometimes require program\u00admers to insert casts in order for quali.er checking to succeed. \nTo re\u00adtain soundness in this case, our extensible typechecker instruments programs with a run-time check \nfor each cast to a value-quali.ed type. Each run-time check tests whether the expression being cast satis.es \nthe cast-to quali.er s invariant. In our current implementa\u00adtion, a fatal error is signaled if the test \nfails. For example, consider the cast in the last statement of lcmin .gure 2. At run time, a check ensures \nthat the value of (prod / d) is in fact greater than zero. 2.1.4 Flow Quali.ers Some common kinds of \nquali.ers are used solely to restrict the .ow of values in a program. For example, a taintedness analysis \nuses quali.ers untainted and tainted to respectively tag data coming from trustworthy and potentially \nuntrustworthy sources. For soundness, the only requirement is that tainted data never .ows where untainted \ndata is expected. Taintedness quali.ers can help to statically detect format-string vulnerabilities in \ncalls to printf and related procedures [36]. As another example, .ow quali.ers user and kernel can be \nused to statically ensure that user pointers are never dereferenced in kernel space [24]. Figure 4 speci.es \nthe taintedness analysis in our framework. The untainted quali.er can qualify any type T. Flow quali.ers \nlike untainted are a degenerate form of value quali.er in our framework. Since the untainted quali.er \nhas no case block, the only way to introduce an expression of type T untainted is with a cast, to explicitly \nmark the expression as being trustworthy. The quali.er also lacks an explicit run-time invariant. Proper \nvalue .ow is guaranteed for free because T untainted is a subtype of T but not vice versa. Therefore, \nuntainted data can .ow where arbitrary data is expected, but not vice versa. ref qualifier unique(T* \nLValue L) assign L NULL | new disallow L invariant value(L) == NULL || (isHeapLoc(value(L)) &#38;&#38; \n forall T** P: *P = value(L) => P = location(L)) Figure 5. A type quali.er for unique pointers. As mentioned \nearlier, the untainted quali.er can help .nd errors in calls to printf and related procedures. The .rst \nargument to printf is a format string that speci.es the number and types of the remaining arguments. \nC does not verify, either at compile time or run time, that printf is always called with the appropriate \nnumber and types of arguments, as directed by the format-string argument. To ensure some measure of reliability \nfor format strings, the programmer can use a type signature for printf requiring the .rst formal parameter \nto have type char* untainted. Therefore, only strings that are known to be trustworthy can be used as \nformat\u00adstring arguments [36]. For example, suppose buf is some arbitrary (and untrusted) buffer of type \nchar*. Then the following code typechecks: char* untainted fmt = (char* untainted) \"%s\"; printf(fmt, \nbuf); However, the invocation printf(buf) fails to typecheck, since buf is not known to be untainted. \nIndeed, if buf contains format speci.ers, this call to printf will attempt to read nonexistent arguments \noff the stack. It may be useful to explicitly annotate some expressions as being possibly tainted. The \nde.nition of tainted in .gure 4 has the desired behavior. The lone caseclause allows any expression to \nbe considered tainted, effectively making T tainteda supertype of T (and hence also of T untainted). \nBecause of the implicit subtyping relation for value quali.ers, it is also the case that T tainted is \na subtype of T, so those types are essentially equivalent. Although the versions of tainted and untainted \nin .gure 4 are degenerate, they could easily be augmented. For example, a user could decide that all \nconstants should be trusted, adding a case clause to the de.nition of untainted as follows: case E of \ndecl T Const C: C This rule would, for example, obviate the need for the cast in the assignment to fmt \nin the code snippet shown above.  2.2 Reference Quali.ers Figure 5 de.nes a reference quali.er unique, \nwhich intuitively speci.es that an l-value either has the value NULL or is the only reference to some \nmemory location. Reference quali.ers pertain in part to an expression s address, so we require each reference \nquali.er to be applicable only to l-values or variables, rather than to arbitrary expressions. 2.2.1 \nType Rules The assign type rules for reference quali.ers are analogous to the case type rules for value \nquali.ers. The assign block allows users to specify the allowable right-hand-side expressions in assignments \nto a quali.ed l-value. These type rules are also used to typecheck implicit assignments to quali.ed l-values, \nthrough procedure calls and returns. The assignclauses for uniquein .gure 5 specify that a unique l-value \nmay be assigned either the value NULL or the result of mem\u00ad int* unique array; void make array(int \nn) {array = (int*)malloc(sizeof(int) * n); for(int i = 0; i < n; i++) array[i] = i; } Figure 6. Code \nthat uses the unique quali.er. ref qualifier unaliased(T Var X) ondecl disallow &#38;X invariant forall \nT** P: *P != location(X)  Figure 7. A type quali.er for unaliased variables. ory allocation. Consider \nthe code in .gure 6. The assignment to array in make array typechecks by the second assign clause, since \nC s mallocfunction matches the pattern new(the cast to int* in the assignment to array is ignored for \nthe purposes of pattern matching). The assign block for unique pertains only to assign\u00adments to the unique \nl-value itself. Assignments to dereferences of a unique l-value, such as the assignment to array[i] in \n.gure 6, are unrestricted. Because reference quali.ers pertain in part to an l-value s ad\u00address, they \ndo not make sense in the context solely of an l-value s contents. Therefore, top-level reference quali.ers \nin an l-value s type are not considered to be part of the l-value s r-type, which is the type used by \nthe typechecker when the l-value appears on the right-hand side of an assignment (and in other expressions \nlike con\u00additionals). However, it may still be necessary to restrict the ways in which an l-value s contents \nmay be used, to ensure soundness. For example, without any restrictions, the following code snippet would \ntypecheck: int* unique p = ...; int* q = p; The second statement is allowed because the r-type of p is \nsimply int*, but it causes p and q to point to the same memory location, violating p s uniqueness. The \ndisallow clause in a reference quali.er s de.nition ad\u00addresses this problem by restricting how a quali.ed \nl-value may be used on the right-hand side of an assignment (or an implicit as\u00adsignment via procedure \ncalls and returns). A disallow clause may prevent a quali.ed l-value from being referred to and/or from \nhav\u00ading its address taken. The disallow clause for unique in .gure 5 prevents a quali.ed l-value from \nbeing referred to. Therefore, the assignment to q in our code snippet above fails to typecheck, as desired, \nsince the right-hand side violates this disallow clause. A unique l-value may still be dereferenced on \nthe right-hand side of an assignment, so the following code typechecks and is perfectly safe: int* unique \np = ...; int i = *p; Another example of a reference quali.er is shown in .gure 7, representing unaliased \nvariables. The ondecl keyword speci.es that any variable can be given the quali.er unaliased at the point \nof its declaration. The keyword indicates that unaliased is a prop\u00aderty only of a variable s address; \nthe variable s contents are irrele\u00advant. Therefore, an assign block is unnecessary for unaliased: implicitly, \nan unaliased variable is allowed to hold any type\u00adcorrect value. The disallow clause for unaliased ensures \nthat an unaliased variable cannot have its address taken. Our current framework for reference quali.ers \nis just a .rst step, and we are actively exploring extensions to make it more expressive. For example, \nintuitively we can assign a unique l\u00advalue any expression that is fresh, meaning that the expression \nevaluates to a previously unreferenced memory location. In turn, a uniquelocal variable returned from \na procedure may be considered fresh. We cannot currently express this rule in our framework because patterns \ncannot mention procedure calls or returns. As another example, we are considering allowing quali.er de.nitions \nto directly refer to liveness information. This would allow, for example, a variable to safely be considered \nunique as long as all aliases are dead [5]. 2.2.2 Subtyping Unlike for value quali.ers, there is in \ngeneral no sound sub-or su\u00adpertype relationship between an arbitrary reference-quali.ed type and its \nassociated unquali.ed type. Therefore, we assume no rela\u00adtionship between these two types. However, the \nimplicit stripping of reference quali.ers from the r-type of an l-value, as described earlier, allows \nexpressions of these types to interact in useful (and still sound) ways. 2.2.3 Soundness As with value \nquali.ers, our framework automatically proves the soundness of reference quali.ers. Consider the invariant \nclause for unique in .gure 5. The built-in location function returns the address of an l-value in a given \nexecution state ., and the built\u00adin predicate isHeapLoc indicates that a memory location is on the heap \n(i.e., it was dynamically allocated) rather than the stack. We allow the invariants for reference quali.ers \nto universally quantify over all memory locations Pof the appropriate type in the execution state ., \nand *P denotes the contents of location P in .. The assign type rules are proven sound in a manner analogous \nwith how the case rules are proven sound for value quali.ers. The proof obligation for an assign clause \nensures that assigning some l-value l an expression matching the assign clause establishes q s associated \ninvariant for l. For example, consider the .rst assign clause for unique in .gure 5. The soundness checker \nrequires an automatic theorem prover to show that if some l-value l is assigned NULL, then unique s invariant \nwill hold for l. This follows easily by the .rst disjunct in the invariant. The obligation for the second \nassign clause is proven by the semantics of the new construct. The proof obligation for ondecl is similar \nto that for an assign clause, requiring the quali.er s invariant to hold for a variable upon declaration. \nThe proof obligations for assign and ondecl ensure that a ref\u00aderence quali.er s invariant is properly \nestablished. Our soundness checker must also show that the invariant is properly preserved across assignments. \nAccordingly, we generate the following proof obligation: if l is an l-value satisfying the invariant \nof some refer\u00adence quali.er q and we execute an arbitrary assignment to some other l-value l , then l \nwill still satisfy the quali.er s invariant in the resulting execution state. We require the arbitrary \nassignment considered in the obligation to obey the disallow block for q,if any is speci.ed. The automatic \ntheorem prover proves this obligation via a case analysis on the different forms of right-hand sides \nconsistent with a quali.er s disallow clause. If the disallow clause for unique were erroneously omitted, \none case in proving unique s preserva\u00adtion obligation would require showing that if l is unique and we \nstore the value of l in l , then l is still unique. Because this case is not provable, the soundness \nchecker would correctly inform the user of the potential unsoundness. Unlike for value quali.ers, our \nextensible typechecker does not instrument programs with run-time checks for casts involving ref\u00aderence \nquali.ers. Such casts remain unchecked, as with traditional casts in C. As our examples illustrate, the \ninvariants for reference quali.ers typically require universal quanti.cation over all mem\u00adory locations, \nmaking the associated run-time checks dif.cult to implement correctly and ef.ciently.  3. Extensible \nTypechecking Our extensible typechecker takes a C program and a set of qual\u00adi.er de.nitions in the language \ndescribed in the previous section. The extensible typechecker then performs quali.er checking on the \nprogram as directed by the quali.er de.nitions type rules. The ex\u00adtensible typechecker also uses value \nquali.ers declared invariants to instrument the program with run-time checks for casts involving value \nquali.ers, as mentioned in section 2.1.3. Our extensible typechecker is implemented as a module in CIL \n[32], a front end for C written in OCaml [35]. CIL parses C code into an abstract syntax tree (AST) format \nand provides a framework for performing passes over this AST. After quali.er checking, the AST is output \nas C code and the gcc compiler per\u00adforms ordinary C typechecking and code generation. In this section, \nwe discuss the implementation of our extensible typechecker. First we describe how C programs are annotated \nwith user-de.ned quali.ers. Then we illustrate how user-de.ned type rules are represented and used in \nour CIL implementation. Finally, we discuss some details of handling C programs. 3.1 Annotating Programs \nTo annotate a C program with quali.ers, we take advantage of gcc attributes, which are tags that can \nbe associated with types (and other program entities). CIL supports gcc attributes and maintains them \nin the generated AST for a program. A type attribute follows the type name and has the following syntax: \nattribute ((attribute name)) We typically use macros instead of writing the unwieldy attribute syntax \ndirectly. Such macros are used in our examples of section 2. For example, the quali.er posused in .gure \n2 is de.ned as follows: #define pos attribute ((pos))  3.2 Quali.er Checking with CIL Our quali.er checker \ntraverses the given CIL AST, applying user\u00adde.ned type rules to applicable program fragments. Any type \nerrors found during quali.er checking are provided to the programmer as warnings, but compilation is \nallowed to continue. To implement quali.er checking, we have created OCaml datatypes to represent the \nexpression patterns and predicates that are allowed in user-de.ned type rules. For example, consider \nthe case clause on lines 5-6 in .gure 1. The expression pattern is rep\u00adresented internally as follows: \nBinop(Mult, Expr(\"E1\"), Expr(\"E2\")) The clause s predicate is similarly represented as follows: And(Qual(\"pos\", \nExpr(\"E1\")), Qual(\"pos\", Expr(\"E2\"))) Consider the application of this type rule to the right-hand side \nof the assignment to prodin .gure 2. First we match our expression pattern against the CIL AST for a*b. \nThe match succeeds and produces bindings for variables in the pattern: E1 is bound to the expression \na and E2 is bound to the expression b. Finally, the rule s predicate is evaluated, after replacing each \npattern variable with the C program fragment to which it is bound. In our example, the predicate is satis.ed \nif aand bcan recursively be given the quali.er pos. The other kinds of type rules are represented and \nchecked similarly.    3.3 Interacting with C We allow types to be annotated with quali.ers wherever \nthey ap\u00adpear. For example, the types of struct .elds may be quali.ed, and our quali.er checker will check \nthat they obey the user-de.ned type rules. Fields of unions may also be given quali.ed types, but the \nusual unsoundness for C unions makes our quali.er checking in this case unsound as well. As is often \nthe case for C program analyses, we assume a logical model of memory. In particular, we assume that the \ntype of p+i, where p is a pointer and i is an integer, is the same as the type of p. This assumption \nis unsound, but in practice it removes a large source of spurious type errors, for example arising from \npointer arithmetic for array indexing. Another source of spurious type errors arises from invoking pro\u00adcedures \nin the C standard library, since their argument and result types are not annotated with user-de.ned quali.ers. \nWe currently solve this problem by writing header .les that contain alternate sig\u00adnatures for library \nprocedures, which replace the procedures ordi\u00adnary signatures via gcc command-line macros. We plan to \ndevelop a standardized mechanism for incorporating quali.er annotations in library code as directed by \nuser-provided speci.cation .les. Macros from the standard library are also problematic. When these macros \nare expanded by the C preprocessor, our quali.er checker produces type errors because the macros bodies \nare not properly annotated. Short of creating our own versions of these macros, we have little recourse. \nOur quali.er checker can also be unsound because it, like C, allows variables to be used before being \ninitialized. Finally, our checker is unsound in the presence of arithmetic over.ow. Because of these \nunsoundnesses, our extensible typechecker for C can be used to statically detect potential errors but \ncannot guarantee the absence of errors of a particular kind. However, the ideas underlying our framework \nare not speci.c to C and could be applied to other languages. For example, a version of our extensible \ntypechecker for a typesafe language like Java [2, 22] would remove most of these sources of unsoundness. \n 4. Automated Soundness Checking Our soundness checker takes a quali.er de.nition, generates the necessary \nproof obligations for each user-de.ned type rule, and automatically discharges these obligations using \nSimplify [14], a Nelson-Oppen-style automatic theorem prover [34]. Simplify con\u00adtains decision procedures \nfor several decidable theories, including linear arithmetic and equality for uninterpreted function symbols. \nSimplify s input language accepts .rst-order formulas over these theories. This section details the implementation \nof our soundness checker. First we describe the axioms we provide Simplify so it can reason about C programs, \nand then we describe the obligations that are proven in the context of these axioms. We have used our \nsound\u00adness checker to automatically prove the soundness of a variety of type quali.ers. The value quali.ers \nnonnull, nonzero, pos, and neg are each proven sound by our checker in under one second. The reference \nquali.ers unique and unaliased are each proven sound in under 30 seconds. 4.1 Axioms We use axioms to \nformalize the dynamic semantics of programs in CIL s intermediate language. The state of a program is \nrepresented by an execution state . =(p,.,e,s), where p is a program, . is an index pointing to the statement \nabout to be executed, e is the environment, which maps variable names to memory locations, and s is the \nstore, which maps locations to values. We de.ne several function symbols for constructing and ma\u00adnipulating \nexecution states. The state function symbol takes a pro\u00adgram, index, environment, and store, and it constructs \nan execution state. The function symbols getStmt, getEnv, and getStore take a state and respectively \nreturn the statement about to be executed, the environment, and the store. Environments and stores are \nrep\u00adresented as maps. Simplify has built-in function symbols that rep\u00adresent operations on maps. For \nexample, the built-in select func\u00adtion symbol takes a map and a key and returns the key s associ\u00adated \nvalue. Finally, we represent C program expressions and state\u00adments using additional function symbols. \nFor instance, the state\u00adment *x := &#38;y is encoded as assign(deref(var(x)),addr(var(y))). Given this \nrepresentation, we de.ne axioms for a function sym\u00adbol evalExpr, which evaluates an expression in a given \nstate. For instance, the following axiom formalizes evaluation of variable ref\u00aderences2: ..,e,x.(e = \nvar(x) . evalExpr(.,e)= select(getStore(.),select(getEnv(.),x))) We similarly de.ne axioms for a function \nlocation, which takes an l-value and returns its address, and a function stepState, which takes a program \nstate and returns the state resulting from executing the current statement. Our axioms only formalize \nthe subset of the CIL intermediate language necessary for reasoning about expression patterns. For ex\u00adample, \nwe do not currently axiomatize the semantics of procedure calls, since they cannot be pattern-matched \nagainst. We do, how\u00adever, explicitly model memory allocation, via a new function sym\u00adbol. 4.2 Proof \nObligations To produce a quali.er s proof obligations, .rst we de.ne a predi\u00adcate to represent the quali.er \ns invariant. Built-in function symbols like value in quali.er de.nitions are translated to their counterpart \nfunction symbols in the axioms. For example, the invariant for pos from .gure 1 is de.ned as follows: \npos(.,e)=(evalExpr(.,e) >0) Proving the soundness of a quali.er q also requires access to the invariants \nof all quali.ers q that are referred to in q s type rules. Given these invariants it is straightforward \nto represent our proof obligations in Simplify. For example, the obligation for the second case clause \nof pos in .gure 1 is de.ned as follows: ..,e1,e2.(pos(.,e1) . pos(.,e2)) . pos(.,multExpr(e1,e2)) As \nanother example, the obligation for the second assign clause of unique in .gure 5 is de.ned as follows: \n..,l.(getStmt(.)= assign(l,new)) . unique(stepState(.),l)  5. Formalization We have formalized our extensible \ntype system for value quali.ers and have proven that the obligations generated by our soundness checker \nare suf.cient to ensure type soundness for such quali.ers. This section overviews these formal details; \nthe complete formal\u00adization for value quali.ers is available in a companion technical report [7]. Stmts \nExprs Consts s e c ::= ::= ::= e | s1 s2 | let x = s1 in s2 | ref s | s1 := s2 c | () | x | .x.s |!e \ninteger constants Vars x ::= variable names Types Quali.ers t q ::= ::= unit | int | t1 . t2 | ref t \n| t q user-de.ned value quali.ers Figure 8. The syntax of the formalized language. SUBVALQUAL SUBQUALREORDER \nt q = tt q1 q2 = t q2 q1 t = t t = t SUBREF SUBTRANS t = tt = t t t2 = t 1 = t1 2 SUBFUN t1 . t2 = t \n1 . t 2 Figure 9. Formal rules for subtyping. G f e : t G f e1: t1 q1 ... G f en : tn qn each ei is a \nsubexpression of e T-QUALCASE G f e : t q Figure 10. A formal template for user-de.ned case clauses. \n5.1 Syntax and Semantics We formalize our framework in the context of a simply-typed lambda calculus \naugmented with ML-style references [29] and user-de.ned type quali.ers. The syntax for this language \nis shown in .gure 8. It is useful to distinguish statements, which are poten\u00adtially side-effecting, from \nexpressions, which are side-effect-free, but this separation causes no loss of expressiveness. The static \nsemantics is de.ned, as usual, by a judgment of the form G f s : t, where G is a type environment mapping \nvariable names to types. The inference rules de.ning this judgment include all the standard rules for \nthe simply-typed lambda calculus with references. We augment these rules with the standard subsumption \nrule and with an associated subtyping relation, which is shown in .gure 9. Rule SUBVALQUAL allows a value-quali.ed \ntype to be a subtype of the associated unquali.ed type. Rule SUBQUALRE-ORDER formalizes the fact that \nthe order of quali.ers on a type is irrelevant. The other rules are standard. There is no rule for sub\u00adtyping \nunderneath ref types, so the type ref t is only a subtype of itself. To complete the static semantics, \n.gure 10 formalizes the user\u00adde.ned case clauses in a value quali.er s de.nition. The rule T-QUALCASE \nis actually a rule template: each quali.er is assumed to have zero or more rules of this form. The template \nallows an expression to be given a quali.ed type if the expression has the as\u00adsociated unquali.ed type \nand some of the expression s subexpres\u00adsions have particular quali.ed types. For example, the second \ncase clause in the de.nition of pos in .gure 1 would be formalized by the following rule, which matches \nthe template: 2 Throughout this section, we elide portions of axioms and proof obligations that involve \ntyping predicates, which are used to restrict the domains of function symbols. Q-INT Q-UNIT G;int f< \ns,c > G;unit f< s,() > G f .x.s : t1 . t2 Q-FUN G;t1 . t2 f<s,.x.s > G f l : ref tG;t f< s,s(l) > l \n. dom(s) Q-REF G;ref t f<s,l > [[q]](v) G;t f<s,v > Q-QUAL G;t q f<s,v > Figure 11. Semantic conformance \nof a value to a type. G f e1 * e2: int q G f e1: int pos G f e2: int pos  G f e1 * e2: int q pos The \nrestrictrules of a value quali.er do not affect soundness, so we have not included these rules in our \nformalization. The dynamic semantics of our language is completely standard and is formalized via a big-step \noperational semantics. Programs are evaluated to values de.ned by the following grammar: Values v ::= \nc | () | .x.s | l Locations l ::= memory locations A store s maps memory locations to values. The evaluation \nrela\u00adtion has the form < s,s >.< s ,v >, indicating that evaluating statement s in store s produces value \nv and a new store s . Since expressions are side-effect-free, their evaluation is formalized by a relation \nof the form <s,e >. v. 5.2 Invariants and Proof Obligations We model a value quali.er q s associated \ninvariant as a unary predicate on values, denoted [[q]]. For example, the invariant clause for pos in \n.gure 1 would be formalized as the predicate [[pos]](v) = v > 0. We overload the [[q]] notation to lift \nthese predicates from values to arbitrary expressions: [[q]](s,e,v) = (< s,e >. v . [[q]](v)) Finally, \nwe formalize the proof obligation generated by our soundness checker for each user-de.ned type rule: \nDEFINITION 5.1. A type rule matching the template T-QUALCASE from .gure 10 is locally sound if the following \nproof obligation is true: .s,v1,...,vn,v. ([[q1]](s,e1,v1) . .... [[qn]](s,en,vn)) . [[q]](s,e,v) 5.3 \nType Soundness We have proven the soundness of our extensible type system for value quali.ers. Intuitively, \nsoundness means that if the proof obli\u00adgations generated by our soundness checker are all true, then \nany well-typed program fragment will satisfy its quali.ers invariants at run time. We formalize this \nnotion of type soundness via a few auxil\u00adiary de.nitions. The relation G;t f< s,v >, de.ned in .gure \n11, represents semantic conformance of a value to a type. Intuitively, G;t f< s,v > holds if G f v : \nt and v additionally satis.es all of the associated invariants for quali.ers in t. The .rst three rules \nin .gure 11 are the standard typechecking rules for integers, unit, and functions, respectively. Rule \nQ-QUAL checks that a value of quali\u00ad.ed type satis.es the quali.er s invariant. Rule Q-REF checks that \nvalue qualifier nonnull(T* Expr E) case E of decl T LValue L: &#38;L restrict decl T* Expr E: *E, where \nnonnull(E) invariant value(E) != NULL Figure 12. The nonnull value quali.er. a location l is well-typed \nand recursively checks semantic confor\u00admance of the value that l points to in the given store. As others \nhave done [19], for purposes of the static semantics we treat locations as variables. Next we lift this \nnotion of semantic conformance to a relation between a store and a type environment: DEFINITION 5.2. \nWe say that G ~ s if both of the following con\u00additions hold: 1. dom(G)= dom(s) 2. .l . dom(G).(G;G(l) \nf<s,l >)  In other words, G ~ s if every memory location is well typed and satis.es its quali.ers invariants. \nFinally we can state our type soundness theorem, which is a variant of the standard type preservation \ntheorem [39]: THEOREM 5.1. If G ~ s and G f s : t and <s,s >.<s ,v > and all user-de.ned type rules are \nlocally sound, then there exists some G . G such that G ~ s and G ;t f<s ,v >. The proof of this theorem \ncan be found in our technical report [7].  6. Experience This section reports on experience using our \nframework for user\u00adde.ned type quali.ers. We describe its usage on existing C pro\u00adgrams to statically \ndetect NULL dereferences, violations of unique\u00adness invariants, and improper format strings. In all of \nthe experi\u00adments described below, the extra compile time for performing qual\u00adi.er checking in CIL is \nunder one second. 6.1 Null Dereferences Figure 12 shows the de.nition of a nonnull value quali.er, which \nis automatically proven sound by our soundness checker. The sole case clause indicates that the address \nof an l-value can be consid\u00adered nonnull. The restrict clause requires all dereferences in a program \nto be to nonnull expressions. We used this nonnull quali.er to statically ensure the absence of NULL \ndereferences in the grep search utility program (version 2.5). We annotated the .les dfa.c and dfa.h, \nwhich comprise the core string-matching algorithm and related data structures. The .les consist of 2287 \nnon-blank, non-comment lines of code. We applied nonnull annotations to variables in an iterative fashion. \nRunning our extensible typechecker on the unannotated .les produced an error message for each dereference, \ndue to the nonnull quali.er s restrict clause. These errors were removed by annotating some variables \nwith nonnull, which could in turn cause error messages on assignments to the newly-annotated vari\u00adables, \nleading to more annotations. In addition to formal parameters and local variables, we documented several \n.elds of structures as being nonnull through this process. There were situations where the type rules \nfor nonnull were insuf.cient and we were forced to insert casts. The major source of Table 1. Results \nfrom the nonnull experiment. Table 2. Results from the untainted experiment. program: grep .les: dfa.c, \ndfa.h lines: 2287 dereferences: 1072 annotations: 114 casts: 59 errors: 0 program: bftpd mingetty identd \nlines: 750 293 228 printf calls: 134 23 21 annotations: 2 1 0 casts: 0 0 0 errors: 1 0 0 static struct \ndfa * nonnull unique dfa; static int charclass index (charclass s) {int i; for (i = 0; i < dfa->cindex; \n++i) if (equal(s, dfa->charclasses[i])) return i; REALLOC IF NECESSARY(dfa->charclasses, charclass, \ndfa->calloc, dfa->cindex); ++dfa->cindex; copyset(s, dfa->charclasses[i]); return i; }  Figure 13. \nA use of unique in grep. such imprecision is due to the .ow-insensitivity of our type system. An example \nfrom grep follows: if ((t = d->trans[works]) != NULL) {works = t[*p]; \u00b7\u00b7\u00b7 } The index into array t is \nsafe because it is guarded by the check for NULL, but our type system cannot deduce this fact. We plan \nto extend our typechecking algorithm to incorporate .ow-sensitivity, borrowing ideas from CQUAL [20]. \nA related source of imprecision occurs when access to a NULL\u00adterminated array is guarded by a test that \nthe index is less than the value of a variable holding the array s length. Statically deducing the invariant \nbetween the array and that variable may be dif.cult. One possibility would be to piggyback our quali.er \nchecker on top of CCured [33], which (among other things) can sometimes statically deduce array bounds. \nTable 1 summarizes the results of our experiment. In order for the restrict clause in nonnull to succeed \non all 1072 derefer\u00adences, we had to provide 114 nonnullannotations and 59 nonnull casts.  6.2 Uniqueness \nThe implementation of grep makes use of several global data structures, which are manipulated by a variety \nof procedures. It would be nice to statically ensure that each global variable is the sole reference \nto the data structure to which it points. In this way, we can guarantee that each data structure cannot \nbe updated unexpectedly through other pointers. We annotated several global variables in dfa.cwith the \nunique quali.er, using the de.nition of unique from .gure 5. We had the most success with the global \nvariable dfa, which contains the cur\u00adrent deterministic .nite-state automaton (DFA) being constructed. \nOur assign rules were not suf.cient to statically validate the ini\u00adtialization of dfa, since it is initialized \nto a pointer passed in from the parser module. However, the extensible typechecker validated all 49 subsequent \nreferences to dfa as preserving the variable s uniqueness. Our annotated declaration of dfa and a representative \nprocedure manipulating dfa are shown in .gure 13. Other global variables were not able to be proven unique \nusing our quali.er, because the variables are passed as arguments to procedures. This idiom violates \nthe disallow clause for unique in .gure 5. Indeed, this idiom is a violation of uniqueness: inside a \nprocedure where a global is passed, the global is no longer unique. It is possible that we could statically \ncheck this idiom by relaxing our unique quali.er to support lent references [1], which allow a unique \nreference to be temporarily aliased. 6.3 Untainted Format Strings Our .nal experiment used the untaintedquali.er \nto ensure proper format-string arguments to printf. We used the simple version of untainted de.ned in \n.gure 4, augmented with a case clause that de.nes all constants to be untainted: case E of decl T Const \nC: C We used this quali.er to annotate and check three of the pro\u00adgrams tested by Shankar et al. [36], \nwho performed a taintedness analysis using CQUAL. The programs are bftpd (version 1.0.11), an FTP server; \nmingetty (version 0.9.4), a remote terminal utility; and identd (version 1.0), a network identi.cation \nservice. For all three programs, we were able to reproduce the results of Shankar et al. Our results \nare shown in table 2. Running our quali.er checker on bftpd indicated two procedure parameters that are \nnecessary to annotate as untainted, since they are used as format strings for printf. Re-running the \nquali.er checker then revealed an ex\u00adploitable error that had been previously identi.ed [3, 36]. The \nof\u00adfending code is shown below: int sendstrf(int s, char * untainted format, ...); \u00b7\u00b7\u00b7 sendstrf(s, entry->d \nname); The d name .eld of entry is a .le name and should not be con\u00adsidered a proper format string. \nThe extensible typechecker ap\u00adpropriately signals an error since the .eld has not been declared untainted. \nThe other two test programs were veri.ed to have no format\u00adstring vulnerabilities. In addition, no casts \nwere required for any of the three test programs; the simple case clause de.ned above was suf.cient to \ninfer the untaintedness of all format-string arguments.  7. Related Work Our framework is inspired \nby the CQUAL system of Foster et al. [19]. As mentioned in the introduction, our language for user\u00adde.ned \ntype rules is novel; a limited form of type rules is simulated in CQUAL via quali.er assertions and assumptions. \nCQUAL also does not support automated soundness checking to ensure that a quali.er establishes its intended \ninvariant. Like our system, CQUAL distinguishes between value and reference quali.ers. CQUAL sup\u00adports \nexplicit subtyping relationships among quali.ers, which our framework lacks. However, subtyping in CQUAL \nis declared by the programmer and trusted to be correct, while we prove the se\u00admantic soundness of subtyping \nin our framework. CQUAL supports quali.er inference and quali.er polymorphism, neither of which our framework \nsupports. Follow-on work extended CQUAL s type system to be .ow-sensitive [20], while our type system \nis .ow\u00adinsensitive. The type-re.nement framework of Mandelbaum et al. [27] sup\u00adports a sophisticated \ntype system that is .ow sensitive and precise in the face of computational effects, allowing temporal \nprotocols similar to those expressible in the Vault language [12] to be stati\u00adcally checked. Both the \nframework of Mandelbaum et al. and Vault also support a form of polymorphism for re.nements. However, \nthose systems lack a language for user-de.ned type rules and lack automated soundness checking with respect \nto run-time invariants. Fugue [13] is an adaptation and extension of Vault s type sys\u00adtem to perform \nstatic checking of temporal protocols for C# [6]. Among other innovations, Fugue allows a class s typestates, \nwhich are the analogues of our quali.ers, to be given an interpretation as a predicate over the class \ns .elds. Such predicates are used during static typechecking to ensure that each method in the class \nprop\u00aderly implements its declared speci.cation. In this way, the Fugue typechecker directly ensures that \ntypestates respect their intended invariants. These invariants appear to be similar in expressiveness \nto ours, except that Fugue s predicate language does not support quanti.cation. Further, Fugue s type \nsystem relies heavily on built\u00adin annotations and associated type rules for nonnull references as well \nas for several kinds of aliasing relationships among objects, while these kinds of quali.ers are user-de.ned \nin our framework. Some type systems, including the calculus of constructions [10], Nuprl [9], and type \nsystems [37, 11] for Proof-Carrying Code (PCC) [31] and Typed Assembly Language [30], use a form of de\u00adpendent \ntypes [28] to allow predicates to be directly encoded as types. However, the proof that a predicate holds \non some program fragment cannot in general be produced automatically and must instead be supplied by \nthe programmer. Our framework is less ex\u00adpressive than these systems, since predicates can only be proven \nindirectly via type quali.ers and their associated type rules. How\u00adever, the separation of typechecking, \nwhich is simple and purely syntactic, from soundness checking, which formally connects the type system \nto the desired predicates, allows these proofs to be per\u00adformed automatically. Dependent ML (DML) [40, \n41] allows ML types to depend upon integers with linear inequality constraints. This limited form of \ndependent types can be used to automatically prove arithmetic program invariants, including those provable \nby our integer qual\u00adi.ers like pos and nonzero. DML s types can also express arith\u00admetic invariants that \nrelate multiple program expressions, which are not supported in our framework. The technical details \nof our approach build on our previous work on the Cobalt and Rhodium languages [25, 26]. These lan\u00adguages \nallow users to implement data.ow analyses that can be au\u00adtomatically proven sound by discharging proof \nobligations with an automatic theorem prover. Our case and assign rules are sim\u00adilar to Rhodium s syntax \nfor .ow functions; our restrict and disallow rules have no analogue in Cobalt or Rhodium. Because our \nwork is based on type systems rather than data.ow analy\u00adsis, our framework s implementation and formalization \nare quite distinct from those of Cobalt and Rhodium. Our framework also must handle new issues, including \nsubtyping and the distinction between value and reference quali.ers. On the other hand, Cobalt and Rhodium, \nbeing based on data.ow analysis, are naturally .ow sensitive. 8. Conclusions and Future Work We have \npresented a new approach for supporting user-de.ned type re.nements. We allow programmers to supply explicit \ntype rules for new re.nements, enabling the expression of common typing disciplines that would be dif.cult \nor unnatural to express in prior frameworks. An extensible typechecker executes these rules on programs, \nand a soundness checker validates the correctness of these rules once, for all possible programs. We \nhave demonstrated the approach through a framework for adding type quali.ers to C programs. Our framework \nsupports the expression of a variety of quali.ers, and we have used these quali.ers to statically ensure \ninteresting run-time invariants in open-source C programs. We plan to explore several directions to increase \nthe expressive\u00adness and practicality of the approach. First, we will incorporate techniques to make existing \nquali.ers more .exible. We are cur\u00adrently extending the pattern language to support special-purpose behavior \nfor procedure calls and returns, to make use of the se\u00admantics of variable scoping. Other extensions \ninclude support for quali.er inference to decrease the annotation burden and support for a form of .ow \nsensitivity. Second, we will extend our framework to handle new kinds of quali.ers. Flow sensitivity \nwill allow us to explore the speci.cation and checking of temporal protocols. We will also target quali.ers, \nlike const, whose associated invariants are naturally expressed as predicates over execution traces. \nReasoning automatically about execution traces is a challenge for our soundness checker. We plan to convert \ntrace-based invariants into predicates on a single execution state by allowing users to conservatively \ninstrument a program s dynamic semantics to record extra information [26]. Also, more work is needed \nto .nd the right primitives that allow a wide variety of practical reference quali.ers to be speci.ed \nand proven sound automatically. Finally, it is possible that our approach can be used beyond type quali.ers, \nfor example to support program checking with semantic guarantees for higher-level programming idioms \nsuch as design patterns [21]. 9. Acknowledgments This research was supported in part by NSF ITR award \n#0427202 and by a generous gift from Microsoft Research. Thanks to Craig Chambers, Jeff Foster, Sorin \nLerner, Jens Palsberg, and Ben Titzer for helpful comments on the paper.  References [1] J. Aldrich, \nV. Kostadinov, and C. Chambers. Alias annotations for program understanding. In Proceedings of the 17th \nACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications, pages 311 \n330. ACM Press, 2002. [2] K. Arnold, J. Gosling, and D. Holmes. The Java Programming Language Third Edition. \nAddison-Wesley, Reading, MA, third edition, 2000. [3] C. Bailleux. More security problems in bftpd-1.0.12. \nbugtraq mail\u00ading list post of December 8, 2000. http://www.securityfocus. com/archive/1/149977. [4] C. \nBoyapati, R. Lee, and M. Rinard. Ownership types for safe pro\u00adgramming: Preventing data races and deadlocks. \nIn Proceedings of the 17th ACM SIGPLAN conference on Object-oriented program\u00adming, systems, languages, \nand applications, pages 211 230. ACM Press, 2002. [5] J. Boyland. Alias burying: Unique variables without \ndestructive reads. Softw. Pract. Exper., 31(6):533 553, 2001. [6] C# Language Speci.cation, Second Edition. \nECMA International, Standard ECMA-334, Dec. 2002. [7] B. Chin, S. Markstrum, and T. Millstein. Semantic \ntype quali.ers. Technical Report CSD-TR-40045, UCLA Computer Science Depart\u00adment, November 2004. [8] \nD. G. Clarke, J. M. Potter, and J. Noble. Ownership types for .exible alias protection. In Proceedings \nof the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications, \npages 48 64. ACM Press, 1998. [9] R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F. \nCremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. \nF. Smith. Implementing Mathematics with the Nuprl Proof Development System. Prentice-Hall, Englewood \nCliffs, NJ, 1986. [10] T. Coquand and G. Huet. The calculus of constructions. Inf. Comput., 76(2-3):95 \n120, 1988. [11] K. Crary and J. C. Vanderwaart. An expressive, scalable type theory for certi.ed code. \nIn Proceedings of the seventh ACM SIGPLAN international conference on Functional programming, pages 191 \n205. ACM Press, 2002. [12] R. DeLine and M. Fahndrich. Enforcing high-level protocols in low\u00adlevel software. \nIn Proceedings of the ACM SIGPLAN 2001 conference on Programming language design and implementation, \npages 59 69. ACM Press, 2001. [13] R. DeLine and M. Fahndrich. Typestates for objects. In Proceedings \nof the 2004 European Conference on Object-Oriented Programming, LNCS 3086, Oslo, Norway, June 2004. Springer-Verlag. \n[14] D. Detlefs, G. Nelson, and J. B. Saxe. Simplify: A theorem prover for program checking. Technical \nReport HPL-2003-148, HP Labs, 2003. [15] M. Fahndrich and K. R. M. Leino. Declaring and checking non-null \ntypes in an object-oriented language. In Proceedings of the 18th ACM SIGPLAN conference on Object-oriented \nprograming, systems, languages, and applications, pages 302 312. ACM Press, 2003. [16] C. Flanagan and \nS. N. Freund. Type-based race detection for Java. In Proceedings of the ACM SIGPLAN 2000 conference on \nProgramming language design and implementation, pages 219 232. ACM Press, 2000. [17] C. Flanagan, K. \nR. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. Extended static checking for Java. \nIn Proceedings of the ACM SIGPLAN 02 Conference on Programming Language Design and Implementation, June \n2002. [18] C. Flanagan and S. Qadeer. A type and effect system for atomicity. In Proceedings of the ACM \nSIGPLAN 2003 conference on Programming language design and implementation, pages 338 349. ACM Press, \n2003. [19] J. S. Foster, M. F\u00a8ahndrich, and A. Aiken. A Theory of Type Quali.ers. In Proceedings of the \n1999 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 192 203, Atlanta, \nGeorgia, May 1999. [20] J. S. Foster, T. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. In Proceedings \nof the ACM SIGPLAN 2002 Conference on Programming language design and implementation, pages 1 12. ACM \nPress, 2002. [21] E. Gamma, R. Helm, R. E. Johnson, and J. Vlissides. Design Patterns: Elements of Reusable \nObject-Oriented Software. Addison-Wesley, Massachusetts, 1995. [22] J. Gosling, B. Joy, G. Steele, and \nG. Bracha. The Java Language Speci.cation Second Edition. The Java Series. Addison-Wesley, Boston, Mass., \n2000. [23] D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and J. Cheney. Region-based memory management \nin Cyclone. In Proceedings of the ACM SIGPLAN 2002 Conference on Programming language design and implementation, \npages 282 293. ACM Press, 2002. [24] R. Johnson and D. Wagner. Finding user/kernel pointer bugs with \ntype inference. In Proceedings of the 13th USENIX Security Symposium, pages 119 134, 2004. [25] S. Lerner, \nT. Millstein, and C. Chambers. Automatically proving the correctness of compiler optimizations. In Proceedings \nof the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation, pages 220 231. \nACM Press, 2003. [26] S. Lerner, T. Millstein, E. Rice, and C. Chambers. Automated soundness proofs for \ndata.ow analyses and transformations via local rules. In Proceedings of the 32nd ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages. ACM Press, 2005. [27] Y. Mandelbaum, D. Walker, and R. Harper. \nAn effective theory of type re.nements. In Proceedings of the eighth ACM SIGPLAN international conference \non Functional programming, pages 213 225. ACM Press, 2003. [28] P.Martin-L\u00a8of.Constructivemathematicsandcomputerprogramming. \nIn Sixth International Congress for Logic, Methodology, and Philosophy of Science, pages 153 175, Amsterdam, \n1982. North-Holland. [29] R. Milner, M. Tofte, R. Harper, and D. MacQueen. The De.nition of Standard \nML (Revised). The MIT Press, 1997. [30] G. Morrisett, D. Walker, K. Crary, and N. Glew. From System F \nto typed assembly language. ACM Trans. Program. Lang. Syst., 21(3):527 568, 1999. [31] G. C. Necula. \nProof-carrying code. In Proceedings of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages, pages 106 119. ACM Press, 1997. [32] G. C. Necula, S. McPeak, S. P. Rahul, and W. Weimer. \nCIL: Intermediate Language and Tools for Analysis and Transformation of C Programs. In Proceedings of \nCC 2002: 11 th International Conference on Compiler Construction. Springer-Verlag, Apr. 2002. [33] G. \nC. Necula, S. McPeak, and W. Weimer. CCured: Type-safe retro.tting of legacy code. In Proceedings of \nthe 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 128 139. ACM Press, \n2002. [34] G. Nelson and D. C. Oppen. Simpli.cation by cooperating decision procedures. ACM Trans. Program. \nLang. Syst., 1(2):245 257, 1979. [35] D. R\u00b4emy and J. Vouillon. Objective ML: An effective object-oriented \nextension of ML. Theory and Practice of Object Systems, 4(1):27 52, 1998. [36] U. Shankar, K. Talwar, \nJ. S. Foster, and D. Wagner. Detecting Format String Vulnerabilities with Type Quali.ers. In Proceedings \nof the 10th Usenix Security Symposium, Washington, D.C., Aug. 2001. [37] Z. Shao, B. Saha, V. Trifonov, \nand N. Papaspyrou. A type system for certi.ed binaries. In Proceedings of the 29th ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, pages 217 232. ACM Press, 2002. [38] M. Tofte and J.-P. \nTalpin. Implementation of the typed call-by-value .-calculus using a stack of regions. In Proceedings \nof the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 188 201. ACM Press, \n1994. [39] A. K. Wright and M. Felleisen. A syntactic approach to type soundness. Information and Computation, \n115(1):38 94, 15 Nov. 1994. [40] H. Xi and F. Pfenning. Eliminating array bound checking through dependent \ntypes. In Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation, pages \n249 257, Montreal, June 1998. [41] H. Xi and F. Pfenning. Dependent types in practical programming. In \nProceedings of the 26th ACM SIGPLAN Symposium on Principles of Programming Languages, pages 214 227, \nSan Antonio, January 1999. \n\t\t\t", "proc_id": "1065010", "abstract": "We present a new approach for supporting user-defined type refinements, which augment existing types to specify and check additional invariants of interest to programmers. We provide an expressive language in which users define new refinements and associated type rules. These rules are automatically incorporated by an <i>extensible typechecker</i> during static typechecking of programs. Separately, a <i>soundness checker</i>automatically proves that each refinement's type rules ensure the intended invariant, for all possible programs. We have formalized our approach and have instantiated it as a framework for adding new type qualifiers to C programs. We have used this framework to define and automatically prove sound a host of type qualifiers of different sorts, including pos and neg for integers, tainted and untainted for strings, and nonnull and unique for pointers, and we have applied our qualifiers to ensure important invariants on open-source C programs.", "authors": [{"name": "Brian Chin", "author_profile_id": "81100656814", "affiliation": "University of California, Los Angeles, CA", "person_id": "P728829", "email_address": "", "orcid_id": ""}, {"name": "Shane Markstrum", "author_profile_id": "81100292142", "affiliation": "University of California, Los Angeles, CA", "person_id": "P669741", "email_address": "", "orcid_id": ""}, {"name": "Todd Millstein", "author_profile_id": "81100018064", "affiliation": "University of California, Los Angeles, CA", "person_id": "PP14019523", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1065010.1065022", "year": "2005", "article_id": "1065022", "conference": "PLDI", "title": "Semantic type qualifiers", "url": "http://dl.acm.org/citation.cfm?id=1065022"}