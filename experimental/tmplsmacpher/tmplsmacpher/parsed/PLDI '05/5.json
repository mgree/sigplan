{"article_publication_date": "06-12-2005", "fulltext": "\n Checking Type Safety of Foreign Function Calls * Michael Furr University of Maryland, College Park \n furr@cs.umd.edu Abstract We present a multi-lingual type inference system for checking type safety \nacross a foreign function interface. The goal of our system is to prevent foreign function calls from \nintroducing type and mem\u00adory safety violations into an otherwise safe language. Our system targets OCaml \ns FFI to C, which is relatively lightweight and illus\u00adtrates some interesting challenges in multi-lingual \ntype inference. The type language in our system embeds OCaml types in C types and vice-versa, which allows \nus to track type information accu\u00adrately even through the foreign language, where the original types \nare lost. Our system uses representational types that can model multiple OCaml types, because C programs \ncan observe that many OCaml types have the same physical representation. Furthermore, because C has a \nlow-level view of OCaml data, our inference sys\u00adtem includes a data.ow analysis to track memory offsets \nand tag information. Finally, our type system includes garbage collection information to ensure that \npointers from the FFI to the OCaml heap are tracked properly. We have implemented our inference system \nand applied it to a small set of benchmarks. Our results show that programmers do misuse these interfaces, \nand our implementation has found several bugs and questionable coding practices in our benchmarks. Categories \nand Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features Foreign Function \nIn\u00adterfaces; D.2.4 [Software Engineering]: Software/Program Veri.\u00adcation Validation; F.3.2 [Logics and \nMeanings of Programs]: Semantics of Programming Languages Program analysis; D.2. 12 [Software Engineering]: \nInteroperability General Terms Languages, Veri.cation Keywords foreign function interface, FFI, foreign \nfunction calls, representational type, multi-lingual type system, multi-lingual type inference, .ow-sensitive \ntype system, data.ow analysis, OCaml 1. Introduction Many programming languages contain a foreign function \ninterface (FFI) that allows programs to invoke functions written in other lan\u00ad * This research was supported \nin part by NSF CCF-0346982 and CCF\u00ad0430118. Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. PLDI 05, June 12 15, 2005, Chicago, Illinois, USA. Copyright 2005 \nACM 1-59593-056-6/05/0006...$5.00. Jeffrey S. Foster University of Maryland, College Park jfoster@cs.umd.edu \nguages. Such interfaces are important for accessing system-wide libraries and legacy components, but \nthey are dif.cult to use cor\u00adrectly, especially when there are mismatches between native and foreign \ntype systems, data representations, and run-time environ\u00adments. In all of the FFIs we are aware of, there \nis little or no consis\u00adtency checking between foreign and native code [4, 8, 15, 16, 17]. As a consequence, \nadding an FFI to a safe language potentially provides a rich source of operations that can violate safety \nin subtle and dif.cult-to-.nd ways. This paper presents a multi-lingual type inference system to check \ntype and garbage collection safety across foreign function calls. As far as we are aware, our paper is \nthe .rst that attempts checking richer properties on the foreign language side between two general purpose \nprogramming languages. Our system targets the OCaml [16] foreign function interface to C [1], though \nwe believe that our ideas are adaptable to other FFIs. OCaml is a strongly-typed, mostly-functional language \nthat in\u00adcludes garbage collection. C is a type-unsafe imperative language with explicit allocation and \ndeallocation. Clearly these two lan\u00adguages have signi.cant differences, and it is these differences that \nmake multi-lingual type inference challenging. In the OCaml FFI, most of the work is done in C glue code, \nwhich uses various macros and functions to deconstruct OCaml data and translate it to and from C representations. \nIt is easy to make mistakes in this code, which is fairly low-level, because there is no checking that \nOCaml data is used at the right type. For example, one could treat unboxed (integer) types as pointers \nor vice-versa. Our type inference system prevents these kinds of errors using an extended, multi-lingual \ntype language that embeds OCaml types in C types and vice-versa. In the OCaml FFI, C programs can observe \nthat many OCaml types have the same physical representation. For example, the value of OCaml type unit \nhas the same representation as the OCaml integer 0, nullary OCaml data constructors are represented using \nintegers, and OCaml records and tuples can be silently injected into sum types if they have the right \ndynamic tag. Thus to model OCaml data from the C perspective, we introduce representational types that \ncan model any or all of these possibilities (Section 2). Con.ating types in the foreign language is a \ncommon design. For example, the Java Native Interface [17] distinguishes a few primitive Java types in \nC, but the rest are represented with a single structure type. One key feature of our type inference system \nis that it smoothly integrates .ow-insensitive uni.cation of type structure with precise .ow-sensitive \nanalysis of local information (Section 3). To under\u00adstand why we need both, observe that OCaml data types \nare, by de.nition, .ow-insensitive. For example, it would not make sense for a C FFI function to change \nthe type of data in the OCaml heap, since that would likely lead to incorrect behavior. Thus our system \nuses uni.cation to infer the structure of the OCaml types expected by C code. However, to access OCaml \ndata, C programs perform dynamic tag tests and compute offsets into the middle of OCaml records and tuples. \nIn order to model these operations, we use an iterative .ow-sensitive data.ow analysis to track offset \nand tag in\u00adformation precisely within a function body. Our data.ow analysis is fairly simple, which turns \nout to be suf.cient in practice because most programs use the FFI in a simple way, in part to avoid making \nmistakes. In our system, the results of data.ow analysis (e.g., where a pointer points in a structured \nblock) inform uni.cation (e.g., what the type of that element in the block is). We have proven that a \nre\u00adstricted version of our type system is sound (Section 4), modulo certain features of C such as out-of-bounds \narray accesses or type casting. Finally, recall that OCaml is a garbage-collected language. To avoid \nmemory corruption problems, before a C program calls OCaml (which might invoke the garbage collector), \nit must no\u00adtify the OCaml runtime system of any pointers it has to the OCaml heap. This is easy to forget \nto do, especially when the OCaml run\u00adtime is called indirectly. Our type system includes effects to track \nfunctions that may invoke the OCaml garbage collector and ensure that pointers to the OCaml heap are \nregistered as necessary. Most programs include helper C functions that take OCaml values, but are not \ncalled directly from OCaml. Thus we construct an inference system that can infer types for functions \nthat have no declared OCaml types and can also check functions with annotated types from the FFI. To \ntest our ideas, we have implemented our in\u00adference system and applied it to a small set of 11 benchmarks. \nOur implementation takes as input a program written in C and OCaml and performs type inference over both \nlanguages to compute multi\u00adlingual types. In our experiments we have found 24 outright bugs in FFI code, \nas well as 22 examples of questionable coding practice. Our results suggest that multi-lingual type inference \nis a bene.cial addition to an FFI system. In summary, the contributions of this work are as follows: \n We develop a multi-lingual type inference system for a foreign function interface. Our system mutually \nembeds the type sys\u00adtem of each language within the other. Using this information, we are able to track \ntype information across foreign function calls.  Our type system uses representational types to model \nthe mul\u00adtiple physical representations of the same type. In order to be precise enough in practice, our \nanalysis tracks offset and tag information .ow-sensitively, and it uses effects to ensure that garbage \ncollector invariants are obeyed in the foreign language. We have proven that a restricted version of \nour system is sound.  We describe an implementation of our system for the OCaml to C foreign function \ninterface. In our experiments, we found a number of bugs and questionable practices in a small bench\u00admark \nsuite.  2. Multi-Lingual Types We begin by describing OCaml s foreign function interface to C and developing \na grammar for multi-lingual types. In a typical use of the OCaml FFI, an OCaml program invokes a C routine, \nwhich in turn invokes a system or user library rou\u00adtine. The C routine contains glue code to manipulate \nstructured OCaml types and translate between the different data representa\u00adtions of the two languages. \nFigure 1 shows the source language types used in our sys\u00adtem. OCaml (Figure 1a) includes unit and int \ntypes, product types (records or tuples), and sum types. Sums are composed of type constructors S, which \nmay optionally take an argument. OCaml also includes types for updatable references and functions. Other \nOCaml types are not supported by our system; see Section 5.1 for a discussion. C (Figure 1b) includes \ntypes void, int, and the type mltype ::= unit | int | mltype \u00d7 mltype | S + \u00b7\u00b7\u00b7 + S | mltype ref | mltype \n. mltype S ::= Constr | Constr of mltype (a) OCaml Type Grammar ctype :: void | int | value | ctype * \n| ctype \u00d7 ... \u00d7 ctype . ctype (b) C Type Grammar Figure 1. Source Type Languages value, to which all \nOCaml data is assigned (see below). C also includes pointer types, constructed with post.x *, and functions. \nTo invoke a C function called c name, an OCaml program must contain a declaration of the form external \nf : mltype = c name where mltype is an OCaml function type. Calling f will invoke the C function declared \nas value c name(value arg1, ..., value argn ); As this example shows, all OCaml data is given the single \ntype value in C. However, different OCaml types have various physical representations that must be treated \ndifferently, and there is no protection in C from mistakenly using OCaml data at the wrong type. As a \nmotivating example, consider the following OCaml sum type declaration: type t= Wofint| X|Yofint*int | \nZ This type has nullary (no-argument) constructors X and Z and non\u00adnullary constructors W and Y. Each \nnullary constructor in a sum type is numbered from 0 and is represented in memory directly as that integer. \nThus to C functions, nullary constructors look just like OCaml ints, e.g., X and 0:int are identical. \nAdditionally, the value of type unit is also represented by the OCaml integer 0. The low-order bit of \nsuch unboxed values is always set to 1 to distinguish them from pointers. C routines use the macro Val \nint to convert to such tagged integers and Int val to convert back. There are no checks, however, to \nensure that these macros are used correctly or even at all. In particular, in the standard OCaml distribution \nthe type value is a typedef (alias) of long. Thus one could mistakenly apply Int val to a boxed value \n(see below), or apply Val int to a value. In fact, we found several examples of these sorts of mistakes \nin our benchmarks (see Section 5.2). Each non-nullary constructor in a sum type is also numbered separately \nfrom 0. These constructors are represented as boxed val\u00adues or pointers to structured blocks on the heap. \nA structured block is an array of values preceded by a header that contains, among other things, a tag \nwith the constructor number. For example, the constructor Y of our example type t is represented as \nPointer Products that are not part of a sum are represented as structured blocks with tag 0. Boxed values \nare manipulated using the macro Field(x,i), which expands to *((value*)x+i), i.e., it accesses the ith \nelement in the structured block pointed to by x. There are no checks to prevent a programmer from applying \nField to an unboxed value or from accessing past the end of a structured block. 1 if(Is long(x)) { 2 \nswitch(Int val(x)) { 3 case 0: /* X */ break; 4 case 1: /* Z */ break; 5 }} else { 6 switch(Tag val(x)) \n{ 7 case 0: /* W */ break; 8 case 1: /* Y */ break; 9 }} Figure 2. Code to Examine a value of Type t \nct ::= void | int | mt value | ct * | ct \u00d7\u00b7\u00b7\u00b7\u00d7 ct .GC ct GC ::= . | gc | nogc mt ::= a | mt . mt | ct \ncustom | (., S) . ::= . | n |T S ::= s |\u00d8| .+S . ::= p |\u00d8| mt \u00d7 . Figure 3. Multi-Lingual Type Language \nClearly a value of type t may have many different represen\u00adtations, depending on its constructor. OCaml \nprovides a series of macros for testing tags and for determining the boxedness of a value. For example, \ncode to examine a value of type t is shown in Figure 2. Here, Is long() on line 1 checks whether a value \nis a pointer (by examining the low-order bit). If it is un\u00adboxed, Int val() on line 2 is used to extract \nthe tag, otherwise Tag val() is used on line 6 where x is known to be boxed. In addition to using OCaml \ndata at the correct type, C FFI func\u00adtions that call the OCaml runtime must notify the garbage collec\u00adtor \nof any C pointers to the OCaml heap. To do so, C functions use macros CAMLparam and CAMLlocal to register \nparameters and locals, respectively. If a function registers any such pointers, it must call CAMLreturn \nupon exiting to release the pointers. We have found in our experiments that it is easy to forget to use \nthese macros, especially when functions only indirectly call the OCaml runtime (Section 5.2). All of \nthe macros described above are left unchecked in part because the correct OCaml types are not available \nin the C code. Thus, our goal is to accept the kind of code presented in Figure 2 and infer the possible \nOCaml types for x. Since a single C value could represent several OCaml types, a more expressive type \nsys\u00adtem is required than that of either C or OCaml. Furthermore, we wish to only accept C code that does \nnot violate OCaml s garbage collector invariants. In order to achieve these goals, we have devel\u00adoped \na combined, multi-lingual type language, shown in Figure 3, that integrates and generalizes the types \nin Figure 1. Our grammar for C types ct embeds extended OCaml types mt in the type value, so that we \ncan track OCaml type information through C. Additionally, we augment function types with an effect GC, \ndiscussed below. Our grammar for OCaml types mt includes type variables a1 as well as function types \nand custom types (see below). All of the other OCaml types from Figure 1a unit, int, prod\u00aducts, sums, \nand references are modeled with a representational 1 a is a monomorphic type variable. Our system does \nnot support polymor\u00adphic OCaml types since they seem to be uncommon in foreign functions in practice. \ntype (., S). In this type, . bounds the unboxed values of the type. For a sum type, . is an exact value \nn counting the number of nullary constructors of the type. Integers have the same physical representation \nas nullary constructors but could have any value, so for this case . is T. . may also be a variable .. \nThe S compo\u00adnent of a representational type describes its possible boxed values, if any. S is a sequence \nof products ., one for each non-nullary constructor of the type. The position of each . in the sequence \ncorresponds to the constructor tag number, and each . itself con\u00adtains the types of the elements of the \nstructured block. For exam\u00adple, the OCaml type t presented above has representational type (2, (T, \u00d8)+(T, \n\u00d8)\u00d7(T, \u00d8)))). Here, .=2 since t has two nullary constructors (X and Z). Also, S contains two product \ntypes, the in\u00adteger type (T, \u00d8) for W, and the integer pair type (T, \u00d8) \u00d7 (T, \u00d8) for Y. Notice in Figure \n2 that our C code to examine a value of type t does not by itself fully specify the type of x. For example, \nthe type could have another nullary constructor or non-nullary constructor that is not checked for. Thus \nour grammars for S and . include variables s and p that range over sums and products [21], which we use \nto allow sum and product types to grow during inference. Only when an inferred type is uni.ed with an \nOCaml type can we know its size exactly. Our type language also annotates each function type with a garbage \ncollection effect GC, which can either be a variable ., gc if the function may invoke the OCaml runtime \n(and thus the garbage collector), or nogc if it de.nitely will not. GC naturally forms the two-point \nlattice with order nogc . gc Note that we reserve = for the total ordering over the integers and use \n. for other partial orders. Our type system ensures that all necessary variables are registered before \ncalling a function with effect gc. Finally, sometimes it is useful to pass C data and pointers to OCaml. \nFor example, glue code for a windowing library might return pointers representing windows or buttons \nto OCaml. It is up to the programmer to assign such data appropriate (distinct) opaque OCaml types, but \nthere is no guarantee that different C types will not be con.ated and perhaps misused. Thus our grammar \nfor OCaml types mt includes types ct custom that track the C type of the embedded data. Our inference \nsystem checks that OCaml code faithfully distinguishes the C types, so that it is not possible to perform \na C type cast by passing a pointer through OCaml.  3. Type System In this section, we present our multi-lingual \ntype inference system. Our inference system takes as input a program written in both OCaml and C and \nproceeds in two stages. We begin by analyzing the OCaml source code and converting the source types of \nFFI functions into our multi-lingual types (Section 3.1). The second stage of inference begins with a \ntype environment containing the converted types and applies our type inference algorithm to the C source \ncode (Section 3.2) to detect any type errors (Section 3.3). 3.1 Type Inference for OCaml Source Code \nThe .rst stage of our algorithm is to translate each external func\u00adtion type declared in OCaml into our \nmulti-lingual types. We only analyze the types in the OCaml source code and not the instructions since \nthe OCaml type checker ensures that the OCaml source code does not contain any type errors. We then combine \nthe converted types into an initial type environment GI , which is used during the second stage. We construct \nGI using the type translation F given in Figure 4, which converts OCaml function types into representational \ntypes. In this de.nition, we implicitly assume that mltypen is not con\u00adstructed with ., i.e., the arity \nof the function is n - 1. F is de.ned in terms of helper function .. The translation . gives unit and \nint F(external mltype1 .\u00b7 \u00b7\u00b7. mltype)= n .(mltype1) value \u00d7\u00b7 \u00b7\u00b7\u00d7 .(mltypen-1) value .. .(mltype) value \nn . fresh .(unit) = (1, \u00d8) .(int)=(T, \u00d8) .(mltype ref) = (0,.(mltype)) .(mltype1 . mltype2)= .(mltype1) \n. .(mltype2) .(L1 | L2 of mltype) = (1,.(mltype)) .(mltype1 \u00d7 mltype2) = (0,.(mltype1) \u00d7 .(mltype2)) \nFigure 4. Translation Rules for OCaml Types type s = P of int ref | R | Q external fML : int . s . unit \n= fC (a) OCaml Program GI = {fC :(T, \u00d8) \u00d7 (2, (0, (T, \u00d8))) .. (1, \u00d8)} (b) Initial Environment Figure \n5. First Stage Example both pure unboxed types, with no S component. Since unit is a singleton type, \nwe know its value is 0, and we assign it type (1, \u00d8). This is the same as the representational type for \na degenerate sum type with a single nullary constructor, e.g., type t = A. This is correct because that \none nullary constructor has the same represen\u00adtation as unit. In contrast, int may represent any integer, \nand so it is not compatible with any sum types. The . function encodes mutable references as a boxed \ntype with a single non-nullary constructor of size 1. Regular function types are converted to mt function \ntypes. Finally, rather than give the general case for sums and products, we illustrate the transla\u00adtion \nwith two sample cases. Sum types are handled by counting the nullary constructors and mapping each non-nullary \nconstruc\u00adtor to a product type representing its arguments. In the de.nition of . in Figure 4, we show \nthe translation of a sum type with one nullary constructor and one non-nullary constructor. Product types \nare handled by making an appropriate boxed type with no nullary constructors and a single non-nullary \nconstructor of the appropriate size. Figure 5a gives an example OCaml program that declares an FFI function. \nFigure 5b shows the initial environment GI created by applying F to the function type in the OCaml program. \nThe en\u00advironment maps the function fC to its representational type. The .rst argument of type int is \nrepresented as (T, \u00d8). The sum argu\u00adment has one non-nullary constructor and two nullary constructors. \nThe non-nullary constructor takes as its argument a reference to an integer which is converted to (0, \n(T, \u00d8)). Therefore the type for s is (2, (0, \u00d8)). Finally, the return type of fC is unit, which is repre\u00adsented \nas (1, \u00d8) as in Figure 4. 3.2 C Source After we have applied the rules in Figure 4 to the OCaml source \ncode, we begin the second phase of our system, which infers types for C source code using the information \ngathered in the .rst phase. We present our algorithm for the C-like language shown in Fig\u00adure 6, based \non the intermediate representation of CIL [20], which we used to construct our implementation. In this \nlanguage, expres\u00adsions e are side-effect free. We include integers n, pointer derefer\u00adences *e, as well \nas the usual arithmetic operators. L-values lval are the restricted subset of expressions that can appear \non the left\u00ad e ::= n | *e | e aop e | lval | e +p e | (ct) e | Val int e | Int val e lval ::= x | *(e \n+p n) aop ::= + | -| * | == |\u00b7 \u00b7\u00b7 s ::= L: s | s ; s | lval := e | lval := f(e, . . . , e) | goto L | \nif e then L | if unboxed(x) then L | if sum tag(x) == n then L | if int tag(x) == n then L | return e \n| CAMLreturn(e) d ::= ctype x = e | CAMLprotect(x) f ::= function ctype f(ctype x, . . . , ctype x) d \n* s | function ctype f(ctype x, . . . , ctype x) P ::= f * Figure 6. Simpli.ed C Grammar hand side of \nan assignment, namely, variables x and pointer deref\u00aderences. Expressions include pointer arithmetic \ne1 +p e2 for computing the address of offset e2 from the start of the structured block pointed to by \ne1. In C source code, pointer arithmetic can be distin\u00adguished from other forms using standard C type \ninformation. Our system allows values to be treated directly as pointers, though in actual C source code \nthey are .rst cast to value *. Our system in\u00adcludes type casts (ct) e, which casts e to type ct. Our \nformal sys\u00adtem only allows certain casts to and from value types; other casts are modeled using heuristics \nin the implementation. We also in\u00adclude as primitives the Val int and Int val conversion functions. Note \nthat we omit the address-of operation &#38;. Variables whose ad\u00address is taken are treated as globals \nby the implementation, and uses of &#38; that interact with * are simpli.ed away by CIL. Statements s \ncan be associated with a label L, and sequencing is written with ;. We also have assignment statements \nlval := e and lval := f(e, . . . , e), the latter of which stores in lval the result of invoking function \nf with the speci.ed arguments. A branch goto L unconditionally jumps to the statement labeled L; we assume \nthat labels are unique within a function, and jumping across function boundaries is not allowed. Conditional \nbranches if e then L jumps to the statement labeled L if the integer e evaluates to a non\u00adzero number. \nLoop constructs and switch statements are omitted because CIL transforms these into if and goto statements. \nWe include as primitives three conditional tests for inspecting a value at run time. The conditional \nif unboxed(x) checks to see whether x is not a pointer, i.e., its low-order bit is 1. The conditional \nif sum tag(x) tests the runtime tag of a structured block pointed to by x. Similarly, the conditional \nif int tag(x), used for nullary constructors, tests the runtime value of unboxed variable x. In actual \nC source code, these tests are made by applying Tag val or Int val, respectively, and then checking the \nresult. Statements also include return e, which exits the current function and returns the value of e. \nThe special form CAMLreturn is used for returning from a function and releasing all variables registered \nwith the garbage collector. This statement should be used in place of return if and only if local variables \nhave been registered by CAMLprotect, our formalism for CAMLlocal and CAMLparam. We restrict occurrences \nof CAMLprotect to the top of a function so that the set of registered variables is constant throughout \nthe body of a function. Programs P consist of a sequence of function declarations and de.nitions f . \nWe omit global variables, since our implementation forbids (via a warning message) values from being \nstored in them (see Section 5.1). We assume all local variables are de.ned at the top-level of the function. \n 3.3 Type Inference for C Source Code The second phase of our type inference system takes as input C \nsource code and the initial environment GI from the .rst phase of the analysis (Section 3.1). Recall \nthe example code in Figure 2 for testing the tags of a value. In order to analyze such a program, we \nneed to track precise information about values of integers, offsets into structured blocks, and dynamic \ntype tags for sum types. Thus our type system infers types of the form ct{B, I, T }, where B tracks boxedness \n(i.e., the result of if unboxed), I tracks an offset into a structured block, and T tracks the type tag \nof a structured block or the value of an integer (Section 3.3.1). In our type system, B, I, and T are \ncomputed .ow-sensitively, while ct is computed .ow-insensitively. Our inference algorithm computes B, \nI, and T using a standard .xpoint data.ow analysis, in which we iteratively apply the type rules in our \nformalism below. Our inference algorithm computes ct by solving .ow-insensitive type constraints. Our \nalgorithm gen\u00aderates four kinds of constraints: uni.cation constraints ct = ct. , mt = mt. , p = p', \nor s = s'; inequality constraints T = . that give lower bounds on the number of primitive tags of a represen\u00adtational \ntype; inequality constraints GC GC. among garbage collection effects; and conditional constraints GC \nGC. . P . P . . 3.3.1 Flow Sensitive Types In our system, the .ow-sensitive type elements B, I, and \nT are given by the following grammar: B ::= boxed | unboxed |T|. I,T ::= n |T|. I and T are lattices \nwith order . n T, and we extend arithmetic on integers to I as T aop I = T, . aop I = ., and similarly \nfor T . B also forms a lattice with order . boxed T and . unboxed T. Intuitively, T is used for an unknown \ntype and . is used for unreachable code, for example following an unconditional branch. We de.ne ct{B, \nI, T } ct'{B',I',T '} if ct = ct. , BB. , II', and TT '. We use . to denote the least upper bound operator, \nand we extend . to types ct{B, I, T }similarly. Notice that B, I, and T do not appear in the grammar \nfor ct in Figure 3, and thus our analysis does not try to track them for values stored in the heap. In \nour experience, this is suf.cient in practice. In our type rules, we allow T to form constraints with \n. from our representational types; the main difference between them is that . may be a variable . that \nis solved for during uni.cation, whereas T is computed .ow-sensitively by iteratively applying our type \nrules. The meaning of ct{B, I, T } depends on ct. If ct is value, then B represents whether the data \nis boxed or unboxed. If B is unboxed, then T represents the value of the data (which is either an integer \nor nullary constructor), and I is always 0. For example, on line 3 of Figure 2, x has type ct{unboxed, \n0, 0}. If B is boxed, then T represents the tag of the structured block and I represents the offset into \nthe block. For example, on line 8 of Figure 2, x has type ct{boxed, 0, 1} since it represents constructor \nY. Otherwise, if ct is int, then B is T, I is 0, and T tracks the value of the integer, either . for \nunreachable code, a known integer n, or an unknown value T. For example, the C integer 5 has type int{T, \n0, 5}. Finally, for all other ct types, B = T = T and I =0. We say that a value is safe if it is either \nunboxed or a pointer to the .rst element of a structured block, and we say that any other ct that is \nnot value is also safe. In our type system, data with a 1 // x : a value{T, 0, T} 2 if unboxed(x) { \n// a =(., s) value 3 // x : a value{unboxed, 0, T} 4 if int tag(x) == 0 // 1 = . 5 /*X*/ // x : a value{unboxed, \n0, 0} 6 if int tag(x) == 1 // 2 = . 7 /*Z*/ // x : a value{unboxed, 0, 1} 8 } else { 9 // x : a value{boxed, \n0, T} 10 if sum tag(x) == 0 // s = p0 + s. 11 /*W*/ // x : a value{boxed, 0, 0} = p1 + s'' 12 if sum \ntag(x) == 1 // s. 13 /*Y*/ // x : a value{boxed, 0, 1}14 } // x : a value{T, 0, T} Figure 7. Example \nwith types type where I =0 is safe. Intuitively, a safe value can be used directly at its type, and for \nboxed types the header can be checked with the regular dynamic tag tests. This is not true of a value \nthat points into the middle of a structured block. Our type system only allows offsets into OCaml data \nto be calculated locally within a function, and so we require that any data passed to another function \nor stored in the heap is safe. Additionally, none of our type rules allow I = T, and if that occurs during \ninference the program will not type check. Finally, recall that the type translation F converts OCaml \nfunc\u00adtions to representational types (., S). Since all data passed from OCaml is safe, these types are \nconverted to our full multi-lingual types by adding the .ow-sensitive tags {T, 0, T} to each converted \ntype.  3.3.2 Example To motivate our discussion of the type inference rules, we present in Figure 7 \nthe example from Section 2 written in our grammar. To enhance readability we omit labels and jumps, and \ninstead show control-.ow with indentation. We have annotated the example with the types assigned by our \ninference rules. The variable x begins on line 1 with an unknown type a value{T, 0, T}. B and T are T \nhere because the boxedness and tag of x are unknown at this program point. I is set to zero since all \ndata passed from OCaml is safe. Upon seeing the if unboxed call, a uni.es with the representational type \n(., s). Here . and s are variables to be solved for based on the constraints generated in the remaining \ncode. On the true branch, we give x an unboxed type but still an unknown tag. Line 4 checks the unboxed \nconstructor for x and adds the constraint that 1 = ., which models the fact that x can only be a constructor \nof a sum with at least 1 nullary constructor. Thus on line 5, x is now fully known, and can safely be \nused as the nullary type constructor X. Similarly, on line 7, x is known to be the constructor Z and \nwe generated the constraint 2 = . from the tag test on line 6. On the false branch of the if unboxed \ntest, our type rules give x a boxed type with offset 0 (since x is safe). After testing the tag of x \nagainst 0 on line 10, we know that x has at least one non-nullary constructor, which we enforce with \nthe constraint s = p0 + s. . On line 11, then, x can be safely treated as the constructor W (tag 0), \nand if we access .elds of x in this branch they will be given types according to p0. Similarly, on line \n13 we know that x has constructor Y (tag 1). At line 14, we join all of the branches together and lose \ninformation about the boxedness and tag of x. When we solve the uni.cation constraints on a and inequality \nconstraints on ., we will discover a =(., p0 + p1 + s'') with 2 = ., which correctly uni.es with our \noriginal type t. When this occurs, we will also discover that s'. = \u00d8. 3.3.3 Expressions Figure 8 gives \nour type rules for expressions. These rules include type environments G, which map variables to types \nct{B, I, T }, and a protection set P , which contains those variables that have been registered with \nthe garbage collector by CAMLprotect. Our rules for expressions prove judgments of the form G,P f e : \nct{B, I, T }, meaning that in type environment G and protection set P , the C expression e has type ct, \nboxedness B, offset I, and value/tag T . We discuss the rules brie.y. In all of the rules, we assume \nthat the program is correct with respect to the standard C types, and that full C type information is \navailable. Thus some of the rules apply to the same source construct but are distinguished by the C types \nof the subexpressions. We also distinguish between rules based on the .ow-sensitive type of a subexpression \nas explained below. The rule (INT EXP) gives an integer the appropriate type, and (VAR EXP) is standard. \n(VAL DEREF EXP) extracts a .eld from a structured block. To assign a type to the result, e must have \na known tag m and offset n, and we use uni.cation to extract the .eld type. Notice that the resulting \nB and T information is T, since they are unknown, but the offset is 0, since we will get back safe OCaml \ndata. This rule, however, cannot handle the case when records or tuples that are not part of sums are \npassed to functions, because their boxedness is not checked before dereferencing. We use (VAL DEREF TUPLE \nEXP) in this case, where B is T. This rule requires that the type have one, non-nullary constructor and \nno nullary constructors. The rule (C DEREF EXP) follows a C pointer. Notice that the resulting B and \nT are T. (AOP EXP) performs the operation aop on T and T ' in the types. (ADD VAL EXP) computes an offset \ninto a structured block. Notice that it must be possible to safely dereference the resulting pointer \nas the offset cannot be larger than the width of the block. While this is not strictly necessary (we \ncould wait until the actual dereference to enforce the size requirement), it seems like good practice \nnot to form invalid pointers. We use (ADD VAL TUPLE EXP) for computing offsets into tuples that are notpartofsums.Similarto(VAL \nDEREF TUPLE EXP),weallow B to be T, but add the constraint that the type have one, non-nullary constructor \nand no nullary constructors. (ADD C EXP) performs pointer arithmetic on C types other than value. (CUSTOM \nEXP) casts a C pointer to a value type, and the result is given a ct * custom value type with unknown \nboxedness and tag. (VAL CAST EXP) allows a custom type to be extracted from a value of a known pointer \ntype ct *. Notice that this is the only rule that allows casts from value, which are otherwise forbidden. \nWe omit other type casts from our formal system; they are handled with heuristics in our implementation \n(Section 5.1). (VAL INT EXP) and (INT VAL EXP) translate between C and OCaml integers. When a C integer \nis turned into an OCaml integer with Val int, we do not yet know whether the result represents an actual \nint or whether it is a nullary constructor. Thus we assign it a fresh representational type (., s), where \nT +1 = .. This con\u00adstraint models the fact that e can only be a constructor of a sum with at least T \nnullary constructors. Similar to (VAL DEREF TU-PLE EXP), (INT VAL UNBOXED EXP) handles the case where \na value is used immediately as an integer without a boxedness test. The (APP) rule models a function \ncall. Technically, function calls are not expressions in our grammar, but we put this rule here to make \nthe rules for statements a bit more compact. To invoke a function, the actual types and the formal types \nare uni.ed; notice that the Bi and Ti are discarded, but we require that all actual arguments are safe \n(Ii =0). Additionally, we require that GC' GC, since if f might call the garbage collector, so might \nthe current function cur func. INT EXP VAR EXP x . dom(G) G,P f n : int{T, 0,n} G,P f x : G(x) VAL DEREF \nEXP G,P f e : mt value{boxed, n, m} mt =(., p0 + \u00b7\u00b7\u00b7 + pm + s) pm = a0 \u00d7 ... \u00d7 an \u00d7 p .,pi, s, ai,p fresh \n G,P f *e : an value{T, 0, T} VAL DEREF TUPLE EXP G,P f e : mt value{T, n, T }mt = (0,a0 \u00d7\u00b7 \u00b7\u00b7\u00d7 an \u00d7 \np) ai,p fresh G,P f *e : an value{T, 0, T} C DEREF EXP G,P f e : ct *{T, 0, T} G,P f *e : ct{T, 0, T} \nAOP EXP G,P f e1 : int{T, 0,T } G,P f e2 : int{T, 0,T '} G,P f e1 aop e2 : int{T, 0,T aopT '} ADD VAL \nEXP G,P f e1 : mt value{boxed, n, n'} G,P f e2 : int{T, 0,m} mt =(., p0 + \u00b7\u00b7\u00b7 + p' + s) n p' = a0 \u00d7\u00b7\u00b7\u00b7\u00d7 \nan+m \u00d7 p .,pi, s, ai,p fresh n G,P f e1 +p e2 : mt value{boxed,n + m, n'} ADD VAL TUPLE EXP G,P f e1 \n: mt value{T, n, n'}G,P f e2 : int{T, 0,m} mt = (0,p0 + \u00b7\u00b7\u00b7 + pn' + s) n= a0 \u00d7\u00d7 an+m \u00d7 p p' \u00b7\u00b7\u00b7 pi, s, \nai,p fresh G,P f e1 +p e2 : mt value{boxed,n + m, n'} ADD C EXP G,P f e1 : ct *{T, 0, T} G,P f e2 : int{T, \n0,T } G,P f e1 +p e2 : ct *{T, 0, T} CUSTOM EXP G,P f e : ct *{T, 0, T} G,P f (value)e : ct * custom \nvalue{T, 0, T} VAL CAST EXP G,P f e : mt value{B, I, T } mt = ct * custom G,P f (ct *) e : ct{T, 0, T} \nVAL INT EXP G,P f e : int{T, 0,T } T +1 = . .,s fresh G,P f Val int e :(., s) value{unboxed, 0,T } INT \nVAL EXP G,P f e : mt value{unboxed, 0,T } G,P f Int val e : int{T, 0,T } INT VAL UNBOXED EXP G,P f e \n: mt value{T, 0,T } mt =(., \u00d8) . fresh G,P f Int val e : int{T, 0,T } APP '' G,P f f : ct1 \u00d7\u00b7 \u00b7\u00b7\u00d7 ct.GC' \nct n ' G,P f ei : cti{Bi, 0,Ti} cti = cti . 1..n i G,P f cur func : \u00b7.GC \u00b7 GC' c GC gc c GC . (ValPtrs(G) \nn live(G)) . P G,P f f(e1,...,en): ct{T, 0, T} Figure 8. Type Inference for C Expressions The last hypothesis \nin this rule is a constraint that requires that if this function may call the garbage collector, every \nvariable that points into the OCaml heap and is still live must have been registered with a call to CAMLprotect. \nHere ValPtrs(G) is the set of all variables in G with a type (., S) value where |S| > 0, i.e., the set \nof all variables that are pointers into the OCaml heap. (These sets are computed after uni.cation is \ncomplete.) The set live(G) is all variables live at the program point corresponding to G. We omit the \ncomputation of live, since it is standard. Solving these GC constraints is discussed in Section 3.3.5. \n 3.3.4 Statements Judgments for statements are .ow-sensitive, which we model by al\u00adlowing the type environment \nto vary from one statement to another, even in the same scope. Intuitively, this allows us to track data.ow \nfacts about local variables. In order to support branches, our rules will use a label environment G mapping \nlabels to type environ\u00adments. In particular, G(L) is the type environment at the beginning of statement \nL. As inference proceeds, the type rules may update G, which we write with the := operator. Our analysis \niteratively applies the type rules to a function body using a worklist algorithm until G has reached \na .xpoint (Section 3.3.5). Since type environments are .ow-sensitive, some of our type rules need to \nconstrain type environments to be compatible with each other. Let dom(G) = dom(G ' ). Then we de.ne GG \n' if G(x)G ' (x) for all x . dom(G), and we de.ne (G . G ' )(x)= G(x) . G ' (x) for all x . dom(G). Also, \nfor the fall-through case for an unconditional branch our rules need to reset all .ow-sensitive information \nto .. We de.ne reset(G)(x)= ct{., ., .}, where G(x)= ct{B, I, T }. Finally, recall that only plain ctypes \nare available in the source code. Hence, analogously to F in Figure 4, we de.ne a function . to translate \nctypes to cts: .(void)= void .(int)= int .(value)= a value a fresh .(ctype *)= .(ctype) * We do not translate \nC function types because they are not .rst class in our language. Figure 9 gives our type rules for statements, \nwhich prove judg\u00adments of the form G, G, P f s, G ' , meaning that in type environ\u00adment G, label environment \nG, and protection set P , statement s type checks, and after statement s the new environment is G ' . \nThe (SEQ STMT) rule is straightforward, and the (LBL STMT) rule constrains the type environment G(L) \nto be compatible with the current environment G. The (GOTO STMT) rule updates G if necessary. If G is \nupdated at L, we add L to our standard .xpoint worklist so that we continue iterating. (RET STMT) uni.es \nthe type of e with the return type of the current function. We also require that e is safe and that P \nis empty so that any variables registered with the garbage collector are released. (CAMLRET STMT) is \nidentical to (RET STMT) except that we require P to be non-empty since it must be paired with at least \none CAMLprotect declaration. In each of (GOTO STMT), (RET STMT), and (CAMLRET STMT), we use reset to \ncompute a new, unconstrained type environment following these statements, since they are unconditional \nbranches. (LSET STMT) typechecks writes to memory. We abuse nota\u00adtion slightly and allow e2 on the right-hand \nside to be either an expression or a function call, which is checked with rule (APP) in Figure 8. Notice \nthat since we do not model such heap writes .ow\u00adsensitively, we require that the type of e2 is safe, \nand that the output type environment is the same as the input environment. In contrast, (VSET STMT) models \nwrites to local variables, which are treated .ow-sensitively. Again, we abuse notation and allow the \nright-hand side to be a function application checked with (APP). (VAR DECL) binds a local variable to \nthe environment. This rule uses our map\u00adping . to generate ct types from ctypes. (CAMLPROTECT DECL) takes \na variable in the environment and adds it to the protection set P . Recall that this can only occur at \nthe top-level of a function, and therefore P is constant throughout the body of a function. The rule \n(IF STMT) models a branch on a C integer. (IF UN-BOXED STMT) models one of our three dynamic tag tests. \nAt label L, we know that local variable x is unboxed, and in the else branch (the fall-through case), \nwe know x is boxed. We can only apply if unboxed to expressions known to be safe. In particular, in the \nelse branch we must know the offset of the boxed data is 0, to allow us to do further tag tests. Similarly, \nin (IF SUM TAG STMT) we set x to have tag n at label L. Notice that this test is only valid if we already \nknow (e.g., by calling if unboxed) that x is boxed and at offset 0, since otherwise the header cannot \nbe read. In the else branch, nothing more is known about x. In either case, we require that if this test \nis performed, then mt must have at least n possible tags. While omitting this last requirement would \nnot create a runtime error, it may imply a coding error, since the program would be testing for more \nconstructors than are de.ned by the type. Therefore our heuristic is to warn about this case by including \nthat clause in our rules. In (IF INT TAG STMT), variable x is known to have value n at label L. Analogously \nwith the previous rule, we require x to be unboxed, and with the constraint n +1 = . we require that \nx must have at least n +1 nullary constructors (. is the count of the constructors, which are numbered \nfrom 0). Similarly to (VAL DEREF TUPLE EXP) and (INT VAL UNBOXED EXP), our implementation includes analogous \nvariations on (IF SUM TAG STMT) and (IF INT TAG STMT) that allow B = T in exchange for stricter constraints \non mt. These rules are not shown since they add no new issues. Finally, rules (FUN DECL) and (FUN DEFN) \nbind function names in the environment. As with (VAR DECL), these rules use . to generate ct types from \nctypes. Notice that in (FUN DEFN), the function type is not added to the environment; for simplicity, \nwe assume all functions are declared before they are used. We also assume that all parameters are safe, \nwhich is enforced in (APP). The label environment G ' is initialized to fresh copies of Gm for each label \nin the function body, and P is initialized to the empty set.  3.3.5 Applying the Type Inference Rules \nWe apply the type rules in Figures 8 and 9 to C source code beginning in type environment GI from phase \none. There are three components to applying the type rules. First, the rules generate equality constraints \nct = ct ' and mt = mt ' , which are solved with ordinary uni.cation. When solving a constraint (., \u00b7) \n= (. ' , \u00b7), we require that . and . ' are the same, i.e., n does not unify with T. We are left with \nconstraints of the form T +1 = . from (VAL INT EXP) and (IF INT TAGSTMT). Recall that these ensure that \nnullary constructors can only be used with a sum type that is large enough. Thus in this constraint, \nif T is negative, we require .= T, since negative numbers are never constructors. After uni.cation and \n.xpoint iteration (see below), we can simply walk through the list of these constraints and check whether \nthey are satis.ed. Next, when computing G f f, G ' for a function de.nition f, recall that label environment \nG may be updated. When this happens for G(L), we add L to a worklist of statements. We iteratively re-apply \nthe type inferences rules to statements on the worklist until we reach a .xpoint. This computation will \nclearly terminate because updates monotonically increase facts about B, I, and T , which are .nite height \nlattices, and because re-applying the type inference rules produces strictly more uni.cation constraints. \n SEQ STMT LBL STMT GOTO STMT G, G, P f s1, G ' G ' , G, P f s2, G '' G(L), G, P f s, G ' G c G(L) G := \nG[L . G(L) U G] G, G, P f s1 ; s2, G '' G, G, P f L: s, G ' G, G, P f goto L, reset(G) RET STMT CAMLRET \nSTMT LSET STMT G,P f e : ct{B, 0,T } G,P f e : ct{B, 0,T } G,P f *(e1 +p n): ct{T, 0, T} ' ' G f cur \nfunc : \u00b7.GC ct G,P f cur func : \u00b7.GC ct G,P f e2 : ct ' {B, 0,T } '' ' ct = ct P = \u00d8 ct = ct P ct = \u00d8 \n= ct G, G, P f return e, reset(G) G, G, P f CAMLreturn(e), reset(G) G, G, P f *(e1 +p n) := e2, G CAMLPROTECT \nDECL VSET STMT VAR DECL G,P f x : ct{B, I, T }G,P f e : ct{B, I, T } G,P f e : ct{B, I, T } ct = .(ctype) \nP := P .{x} G, G, P f x := e, G[x . ct{B, I, T }]G,P f ctype x = e, G[x . ct{B, I, T }]G, G, P f CAMLprotect(x), \nG IF UNBOXED STMT G,P f x : mt value{B, 0,T } IF STMT G ' = G[x . mt value{unboxed, 0,T }] G,P f e : \nint{T, 0,T } G := G[L . G(L) U G] G := G[L . G(L) U G ' ] G, G, P f if e then L, GG, G, P f if unboxed(x) \nthen L, G[x . mt value{boxed, 0,T }] IF SUM TAG STMT G,P f x : mt value{boxed, 0,T } IF INT TAG STMT \nmt =(., p0 + \u00b7\u00b7\u00b7 + pn + s)G,P f x : mt value{unboxed, 0,T } mt =(., s) G ' = G[x . mt value{boxed, 0,n}] \nn +1 = . G ' = G[x . mt value{unboxed, 0,n}] G := G[L . G(L) U G ' ] ., pi,s fresh G := G[L . G(L) U \nG ' ] ., s fresh G, G, P f if sum tag(x) == n then L, G G, G, P f if int tag(x) == n then L, G FUN DEFN \nFUN DECL G0 = G[xi . .(ctypei){T, 0, T},cur func . G(f)] ct = .(ctype1) \u00d7 ... \u00d7 .(ctype) .. .(ctype)Gi-1,P \nf di, Gi i . 1..m P := \u00d8 P, G fresh f . dom(G) . ct = G(f) . fresh .L . body of f,G(L) := reset(Gm)Gm, \nG, P f s, G ' n G f function ctype f(ctype1 x, . . . , ctypex), G ' [f . ct]G f function ctype f(ctype1 \nx1,..., ctypexn) d1 ...dm; s, G n n Figure 9. Type Inference for C Statements Finally, we are left with \nconstraints GC GC ' . These atomic subtyping constraints can be solved via graph reachability. Intu\u00aditively, \nwe can think of the constraint GC GC ' as an edge from GC to GC ' . Such edges form a call graph, i.e., \nthere is an edge from GC to GC ' if the function with effect GC is called by the function with effect \nGC ' . To determine whether a function with effect variable . may call the garbage collector, we simply \ncheck whether there is a path from gc to . in this graph, and using this information we ensure that any \nconditional constraints from (APP) are satis.ed for gc functions.   4. Soundness We now sketch a proof \nof soundness for a slightly simpli.ed ver\u00adsion of our multi-lingual type system that omits function calls, \ncasting operations, and CAMLprotect and CAMLreturn. Full de\u00adtails are presented in a companion technical \nreport [10]. We be\u00adlieve these features can be added without dif.culty, though with more tedium. Thus \nour proof focuses on checking the sequence of statements that forms the body of a function, with branches \nbut no function calls. The .rst step is to extend our grammar for expressions to in\u00adclude C locations \nl, OCaml integers {n}, and OCaml locations {l + n} (a pointer on the OCaml heap with base address l and \noffset n). We write {l + -1} for the location of the type tag in the header block. We de.ne the syntactic \nvalues v to be these three forms plus C integers n. As is standard, in our soundness proof we overload \nG so that in addition to containing types for variables, it contains types for C locations and OCaml \nlocations. We also add the empty statement () to our grammar for statements. Our operational semantics \nuses three stores to model updatable references: SC maps C locations to values, SML maps OCaml locations \nto values, and V maps local variables to values. In order to model branches, we also include a statement \nstore D, which maps labels L, to statements s. Due to lack of space, we omit our small\u00adstep operational \nsemantics, which de.ne a reduction relation of the form '' '' (SC ,SML,V,s).(SC ,S ML,V ,s ) Here, a \nstatement s in state SC , SML, and V , reduces to a new statement s ' and yields new stores S ' ML, and \nV ' . We de.ne C , S ' . * as the re.exive, transitive closure of .. To show soundness, we require that \nupon entering a function, the stores are compatible with the current type environment: DEFINITION 1 (Compatibility). \nG is said to be compatible with SC , SML, and V (written G ~(SC ,SML,V \u00bb) if 1. dom(G) = dom(SC ) . dom(SML) \n. dom(V ) 2. For all l . SC there exists ct such that G f l : ct *{T, 0, T} and G f SC (l): ct{T, 0, \nT}.  3. For all {l + n}. SML there exist ., S, j, k, m, .0,..., .j , mt0,..., mtk such that G f{l + \nn} : (., S) value{boxed, n, m} S=.0 + \u00b7\u00b7\u00b7 +.j , m = j  .m = mt0 \u00d7\u00b7\u00b7\u00b7\u00d7 mtk, n = k  G f SML({l + n}): \nmtn value{T, 0, T}  SML({l + -1})= m  4. For all x . V , G f V (x) : G(x) DEFINITION 2. A statement \nstore D is said to L-compatible with a label environment G, written D ~L G, if for all L . D there exists \nG such that G(L),G f D(L), G. DEFINITION 3. D is said to be well formed if for all L . D, D(L) is a statement \nof the form L : s. The standard approach to proving soundness is to show that re\u00adduction of a well-typed \nterm does not become stuck. In our system, this corresponds to showing that every statement either diverges \nor eventually reduces to (), which we prove in the technical report [10]. THEOREM 1 (Soundness). If G \nf s, G ' , G ~(SC ,SML,V ), D ~L G and D is well formed, then either (SC ,SML,V,s)diverges, or (SC ,SML, \nV, s). * (S ' ML,V ' C ,S ' , ()).  5. Implementation and Experiments We have implemented the inference \nsystem described in Section 3. We .rst discuss the details of our implementation that are not covered \nby our formal system, and then present the results of analyzing a small benchmark suite with our tool. \n5.1 Implementation Our implementation consists of two separate tools, one for each language. The .rst \ntool, based on the camlp4 preprocessor, ana\u00adlyzes OCaml source programs and extracts the type signatures \nof any foreign functions. Because ultimately C foreign functions will see the physical representations \nof OCaml types, the tool resolves all types to a concrete form. In particular, type aliases are replaced \nby their base types, and opaque types are replaced by the concrete types they hide, when available. If \nthe concrete type is not avail\u00adable, the opaque type is assigned a fresh type variable, and our tool \nsimply checks to ensure it is used consistently. As each OCaml source .le is analyzed, the tool incrementally \nupdates a central type repository with the newly extracted type information, beginning with a pre-generated \nrepository from the standard OCaml library. Once this .rst phase is complete, the central repository \ncontains the equivalent of the initial environment GI , which is fed into the second tool. The second \ntool, built using CIL [20], performs the bulk of the analysis. This tool takes as input the central type \nrepository and a set of C source programs to which it applies the rules in Figures 8 and 9. The tool \nuses syntactic pattern matching to identify tag and boxedness tests in the code. One feature of C that \nwe have not fully discussed is the address\u00adof operator. Our implementation models address-of in different \nways, depending on the usage. Any local variable with an integer type (or local structure with a integer \n.eld) that has its address com\u00adputed is given the type int{T, 0, T} everywhere. This conserva\u00adtively \nmodels the fact that the variable may be updated arbitrarily through other aliases. It has been our experience \nthat variables used for indexing into value types rarely have their address taken, so this usually does \nnot affect our analysis. Similarly, we produce a warning for any variable of type value whose address \nis taken (or any variable containing a .eld of type value), as well as for any global variable of type \nvalue. When encountering a call through a C function pointer, our tool currently issues a warning and \ndoes not generate typing constraints on the parameters or return type. We also treat unsafe type casts \nspecially in our implementation. Our system tries to warn programmers about casts involving value types, \nbut in order to reduce false positives we use heuristics rather than be fully sound. For instance, any \ncast through a void * type is ignored, as well as any signed-unsigned type differences. In addition to \nthe types we have described so far, OCaml also includes objects, polymorphic variants, and universally \nquanti.ed types. Our implementation treats object types in the same way as opaque types, with no subtyping \nbetween different object types. We have not seen objects used in FFI C code. Our implementation does \nnot handle polymorphic variants, which are used in FFI code, and this leads to some false positives in \nour experiments. Finally, recall that our analysis of C functions is monomorphic. Therefore, if our F \nfunction from Figure 4 encounters a polymor\u00adphic type variable, F assigns it the representational type \n(., p + s) where ., p and s are fresh variables with the constraint 1 = .. Since a polymorphic type could \nbe either boxed or unboxed, this prevents a C function from using the polymorphic type directly as an \ninteger or a boxed type without at least performing a boxed\u00adness test. We also cannot infer universally \nquanti.ed types for C helper functions that are polymorphic in OCaml value parame\u00adters. Instead, we allow \nthem to be hand-annotated as polymorphic, which prevents typing constraints between any of its actual \nand for\u00admal arguments. Such C functions appear to be rare in practice, as we only added these annotations \n4 times in our benchmark suite.  5.2 Experiments We ran our tool on several programs that utilize the \nOCaml foreign function interface. The programs we looked at are actually glue libraries that provide \nan OCaml API for system and third-party libraries. All of the programs we analyzed were from a tested, \nreleased version, though we believe our tool is also useful during development. Figure 10 gives a summary \nof our benchmarks and results. For each program, we list the lines of C and OCaml code, and the running \ntime (three run average) for our analysis on a 2GHz Pentium IV Xeon Processor with 2GB of memory. Recall \nfrom Section 3.1 that we do not directly analyze OCaml function bodies. Thus the bulk of the time is \nspent analyzing C code. Also, our analysis is done as the program is compiled, so these .gures also include \ncompilation time. The next three columns list the number of errors found, the number of warnings for \nquestionable programming practice, and the number of false positives, i.e., warnings for code that appears \nto be correct. The last column shows the number of places where the implementation warned that it did \nnot have precise .ow-sensitive information (see below). The total number of warnings is the sum of these \nfour columns. We found a total of 24 outright errors in the benchmarks. One source of errors was forgetting \nto register C references to the OCaml heap before invoking the OCaml runtime. This accounts for one error \nin each of ftplib, lablgl, and lablgtk. Similarly, the one error in each of ocaml-mad and ocaml-vorbis \nwas registering a local parameter with the garbage collector but then forgetting to release it, thus \npossibly leaking memory or causing subtle memory corruption. The 19 remaining errors are type mismatches \nbetween the C code and the OCaml code. For instance, 5 of the lablgtk errors and all ocaml-glpk and ocaml-ssl \nerrors were due to using Val int instead of Int val or vice-versa. Another error was due to one FFI function \nmistreating an optional argument as a regular argument. Here, the function directly accessed the option \nblock as if it were the expected type rather than an option type containing the expected type. Thus, \nthe C code will most likely violate type safety. The other type errors are similar. In addition to the \n24 errors, our tool reported 22 warnings cor\u00adresponding to questionable coding practices. A common mistake \nis declaring the last parameter in an OCaml signature as type unit even though the corresponding C function \nomits that parameter in its declaration: OCaml : external f : int . unit . unit = f C : value f(value \nx); Program C loc OCaml loc Time (s) Errors Warnings False Pos Imprecision apm-1.00 124 156 1.3 0 0 \n0 0 camlzip-1.01 139 820 1.7 0 0 0 1 ocaml-mad-0.1.0 139 38 4.2 1 0 0 0 ocaml-ssl-0.1.0 187 151 1.5 4 \n2 0 0 ocaml-glpk-0.1.1 305 147 1.3 4 1 0 1 gz-0.5.5 572 192 2.2 0 1 0 1 ocaml-vorbis-0.1.1 1183 443 2.8 \n1 0 0 2 ftplib-0.12 1401 21 1.7 1 2 0 1 lablgl-1.00 1586 1357 7.5 4 5 140 20 cryptokit-1.2 2173 2315 \n5.4 0 0 0 1 lablgtk-2.2.0 5998 14847 61.3 9 11 74 48 Total 24 22 214 75 Figure 10. Experimental Results \n While this does not usually cause problems on most systems, it is not good practice, since the trailing \nunit parameter is placed on the stack. The warnings reported for ftplib, ocaml-glpk, ocaml-ssl, lablgl, \nand lablgtk were all due to this case. The warning in gz is an interesting abuse of the OCaml type sys\u00adtem. \nThe gz program contains an FFI function to seek (set the .le position) on .le streams, which have either \ntype input channel or output channel. However, instead of taking a sum type as a parameter (to allow \nboth kinds of arguments), the function is de\u00adclared with the polymorphic type a as its parameter. OCaml \n: external seek : int . a . unit = seek C : value seek(value pos, value chan){ FILE *strm = Field(chan,0); \nfseek(strm,...); Clearly using chan in this way is very dangerous, because OCaml will allow any argument \nto be passed to this function, including unboxed integers. In this case, however, only the right types \nare passed to the function, and it is encapsulated so no other code can access the function, and so we \nclassify this as questionable programming practice rather than an error. Our tool also reported a number \nof false positives, i.e., warnings for code that seems correct. One source of false positives is due \nto polymorphic variants, which we do not handle. The other main source of false positives is due to pointer \narithmetic disguised as integer arithmetic. Recall that the type value is actually a typedef for long. \nTherefore if v is an OCaml value with type t * custom, then both ((t*)v + 1) and (t*)(v + sizeof(t*)) \nare equivalent. However, our system will not type check the second case because direct arithmetic is \nperformed on a value type. Finally, in several of the benchmarks there are a number of places where our \ntool issued a warning because it does not have precise enough information to compute a type. For instance, \nthis may occur when computing the type of e1 +p e2 if e2 has the type int{T, 0, T}, since the analysis \ncannot determine the new offset. We also classify warnings about global value types and the use of function \npointers as imprecision warnings. However, these did not occur very often, only 10 and 8 times respectively. \nOne interesting direction for future work would be eliminating these warnings and instead adding run-time \nchecks to the C code for these cases.  6. Related Work Most languages include a foreign function interface, \ntypically to C, since it runs on many platforms. For languages with semantics and runtime systems that \nare close to C, foreign function calls to C can typically be made using simple interfaces. For languages \nthat are further from C, FFIs are more complicated, and there are many interesting design points with \ndifferent tradeoffs [4, 8, 15, 16, 17]. For example, Blume [4] proposes a system allowing arbitrary C \ndata types to be accessed by ML. Fisher et al [9] have developed a framework that supports exploration \nof many different foreign interface policies. While various interfaces allow more or less code to be \nwritten natively (and there is a trend towards more native code rather than glue code), the problem of \nvalidating usage of the interface on the foreign language side still remains. Recently, researchers have \ndeveloped systems to check that dynamically-generated SQL queries are well-formed [6, 7, 11]. In a sense, \nthese systems are checking a foreign-function interface between SQL and the source language. In order \nto model SQL queries, the systems focus on string manipulations rather than stan\u00addard type structure, \nand so they are considerably different than our type system. Trifonov and Shao [22] use effects to reason \nabout the safety of interfacing multiple safe languages with different runtime resource requirements \nin the same address space. Their focus is on ensuring that code fragments in the various languages have \naccess to nec\u00adessary resources while preserving the languages semantics, which differs from our goal \nof checking types and GC properties in FFIs. Systems like COM [12] and SOM [13] provide interoperabil\u00adity \nbetween object-oriented frameworks. Essentially, they are for\u00adeign function interfaces that incorporate \nan object model. Typically these systems include dynamic type information that is checked at runtime \nand used to .nd methods and .elds. We leave the problem of statically checking such object FFIs to future \nwork. Our type system bears some resemblance to systems that use physical type checking for C [5, 19], \nin that both need to be con\u00adcerned with memory representations and offsets. However, our sys\u00adtem is considerably \nsimpler than full-.edged physical type check\u00ading systems simply because OCaml data given type value is \ntypi\u00adcally only used in restricted ways. One way to avoid foreign function interfaces completely is to \ncompile all programs down to a common intermediate representa\u00adtion. For example, the Microsoft common-language \nruntime (CLR) [14, 18] includes a strong type system and is designed as the tar\u00adget of compilers for \nmultiple different languages. While this so\u00adlution avoids the kinds of programming dif.culties that can \narise with FFIs, it does not solve the issue of interfacing with programs in non-CLR languages or with \nunmanaged (unsafe) CLR code. An\u00adother approach used by SWIG [2], is to automatically generate glue code \nfor the low level language based on an interface speci.cation .le. This has the advantage of eliminating \nthe need for custom glue code (and thus eliminate safety violations), but it exposes all of the low level \ntypes to the high level language, creating a possi\u00adbly awkward interface. All of the programs in our \nbenchmark suite contained custom glue code written without the use of an interface generator, suggesting \nthat hand writing FFI code is still a popular approach. 7. Conclusion We have presented a multi-lingual \ntype inference system for check\u00ading type and GC safety across the OCaml-to-C foreign function interface. \nOur system embeds the types of each language into the other, using representational types to model the \noverlapping phys\u00adical representations in C of different OCaml types. Our type infer\u00adence algorithm uses \na combination of uni.cation to infer OCaml types and data.ow analysis to track offset and tag information. \nWe use effects to track garbage collection information and to ensure that C pointers to the OCaml heap \nregistered with the garbage col\u00adlector. Using an implementation of our algorithm, we found sev\u00aderal errors \nand questionable coding practices in a small benchmark suite. We think our results suggest that multi-lingual \ntype inference can be an important part of foreign function interfaces, and we be\u00adlieve these same techniques \ncan be extended and applied to other FFIs.  References [1] ANSI. Programming languages C, 1999. ISO/IEC \n9899:1999. [2] D. M. Beazley. SWIG: An easy to use tool for integrating scripting languages with C and \nC++,. [3] N. Benton and A. Kennedy, editors. BABEL 01: First International Workshop on Multi-Language \nInfrastructure and Interoperability, volume 59 of Electronic Notes in Theoretical Computer Science, Firenze, \nItaly, Sept. 2001. http://www.elsevier.nl/locate/ entcs/volume59.html. [4] M. Blume. No-Longer-Foreign: \nTeaching an ML compiler to speak C natively . In Benton and Kennedy [3]. http://www.elsevier. nl/locate/entcs/volume59.html. \n[5] S. Chandra and T. W. Reps. Physical Type Checking for C. In Proceedings of the ACM SIGPLAN/SIGSOFT \nWorkshop on Program Analysis for Software Tools and Engineering, pages 66 75, Toulouse, France, Sept. \n1999. [6] A. S. Christensen, A. M\u00f8ller, and M. I. Schwartzbach. Precise Analysis of String Expressions. \nIn R. Cousot, editor, Static Analysis, 10th International Symposium, volume 2694 of Lecture Notes in \nComputer Science, pages 1 18, San Diego, CA, USA, June 2003. Springer-Verlag. [7] R. DeLine and M. F\u00a8 \nahndrich. The Fugue Protocol Checker: Is your software Baroque? Technical Report MSR-TR-2004-07, Microsoft \nResearch, Jan. 2004. [8] S. Finne, D. Leijen, E. Meijer, and S. P. Jones. Calling hell from heaven and \nheaven from hell. In Proceedings of the fourth ACM SIGPLAN International Conference on Functional Programming, \npages 114 125, Paris, France, Sept. 1999. [9] K. Fisher, R. Pucella, and J. Reppy. A framework for interoperability. \nIn Benton and Kennedy [3]. http://www.elsevier.nl/locate/ entcs/volume59.html. [10] M. Furr and J. S. \nFoster. Checking Type Safety of Foreign Function Calls. Technical Report CS-TR-4627, University of Maryland, \nComputer Science Department, Nov. 2004. [11] C. Gould, Z. Su, and P. Devanbu. Static Checking of Dynamically \nGenerated Queries in Database Applications. In Proceedings of the 26th International Conference on Software \nEngineering, pages 645 654, Edinburgh, Scotland, UK, May 2004. [12] D. N. Gray, J. Hotchkiss, S. LaForge, \nA. Shalit, and T. Weinberg. Modern Languages and Microsoft s Component Object Model. Communications of \nthe ACM, 41(5):55 65, May 1998. [13] J. Hamilton. Interlanguage Object Sharing with SOM. In Proceedings \nof the Usenix 1996 Annual Technical Conference, San Diego, California, Jan. 1996. [14] J. Hamilton. Language \nIntegration in the Common Language Runtime. ACM SIGPLAN Notices, 38(2):19 28, Feb. 2003. [15] L. Huelsbergen. \nA Portable C Interface for Standard ML of New Jersey. http://www.smlnj.org//doc/SMLNJ-C/smlnj-c.ps, 1996. \n[16] X. Leroy. The Objective Caml system, Aug. 2004. Release 3.08, http://caml.inria.fr/distrib/ocaml-3.08/ocaml-3. \n08-refman.pdf. [17] S. Liang. The Java Native Interface: Programmer s Guide and Speci.cation. Addison-Wesley, \n1999. [18] E. Meijer, N. Perry, and A. van Yzendoorn. Scripting .NET using Mondrian. In J. L. Knudsen, \neditor, ECOOP 2001 -Object-Oriented Programming, 15th European Conference, volume 2072 of Lecture Notes \nin Computer Science, pages 150 164, Budapest, Hungary, June 2001. Springer-Verlag. [19] G. Necula, S. \nMcPeak, and W. Weimer. CCured: Type-Safe Retro.tting of Legacy Code. In Proceedings of the 29th Annual \nACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 128 139, Portland, Oregon, \nJan. 2002. [20] G. C. Necula, S. McPeak, S. P. Rahul, and W. Weimer. CIL: Intermediate Language and Tools \nfor Analysis and Transformation of C Programs. In R. N. Horspool, editor, Compiler Construction, 11th \nInternational Conference, volume 2304 of Lecture Notes in Computer Science, pages 213 228, Grenoble, \nFrance, Apr. 2002. Springer-Verlag. [21] D. R\u00b4emy. Typechecking records and variants in a natural extension \nof ML. In Proceedings of the 16th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, \npages 77 88, Austin, Texas, Jan. 1989. [22] V. Trifonov and Z. Shao. Safe and Principled Language Interoperation. \nIn D. Swierstra, editor, 8th European Symposium on Programming, volume 1576 of Lecture Notes in Computer \nScience, pages 128 146, Amsterdam, The Netherlands, Mar. 1999. Springer-Verlag. \n\t\t\t", "proc_id": "1065010", "abstract": "We present a multi-lingual type inference system for checking type safety across a foreign function interface. The goal of our system is to prevent foreign function calls from introducing type and memory safety violations into an otherwise safe language. Our system targets OCaml's FFI to C, which is relatively lightweight and illustrates some interesting challenges in multi-lingual type inference. The type language in our system embeds OCaml types in C types and vice-versa, which allows us to track type information accurately even through the foreign language, where the original types are lost. Our system uses <i>representational</i> types that can model multiple OCaml types, because C programs can observe that many OCaml types have the same physical representation. Furthermore, because C has a low-level view of OCaml data, our inference system includes a dataflow analysis to track memory offsets and tag information. Finally, our type system includes garbage collection information to ensure that pointers from the FFI to the OCaml heap are tracked properly. We have implemented our inference system and applied it to a small set of benchmarks. Our results show that programmers do misuse these interfaces, and our implementation has found several bugs and questionable coding practices in our benchmarks.", "authors": [{"name": "Michael Furr", "author_profile_id": "81408592409", "affiliation": "University of Maryland, College Park, MD", "person_id": "P728837", "email_address": "", "orcid_id": ""}, {"name": "Jeffrey S. Foster", "author_profile_id": "81338488852", "affiliation": "University of Maryland, College Park, MD", "person_id": "PP42049823", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1065010.1065019", "year": "2005", "article_id": "1065019", "conference": "PLDI", "title": "Checking type safety of foreign function calls", "url": "http://dl.acm.org/citation.cfm?id=1065019"}