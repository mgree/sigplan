{"article_publication_date": "06-12-2005", "fulltext": "\n Essential Language Support for Generic Programming Jeremy Siek Andrew Lumsdaine Open Systems Lab, Indiana \nUniversity Open Systems Lab, Indiana University jsiek@osl.iu.edu lums@osl.iu.edu Abstract Concepts are \nan essential language feature for generic program\u00adming in the large. Concepts allow for succinct expression \nof con\u00adstraints on type parameters of generic algorithms, enable systematic organization of problem domain \nabstractions, and make generic al\u00adgorithms easier to use. In this paper we present the design of a type \nsystem and semantics for concepts that is suitable for non-type\u00adinferencing languages. Our design shares \nmuch in common with the type classes of Haskell, though our primary in.uence is from best practices in \nthe C++ community, where concepts are used to document type requirements for templates in generic libraries. \nCon\u00adcepts include a novel combination of associated types and same\u00adtype constraints that do not appear \nin type classes, but that are sim\u00adilar to nested types and type sharing in ML. Categories and Subject \nDescriptors D.3.3 [Programming Langua\u00adges]: Language Constructs and Features abstract data types, con\u00adstraints, \npolymorphism; D.2.13 [Software Engineering]: Reusable Software reusable libraries; D.3.2 [Programming \nLanguages]: Language Classi.cations multiparadigm languages General Terms Languages, Design Keywords \ngeneric programming, polymorphism, C++, Standard ML, Haskell 1. Introduction In the 1980 s Musser and \nStepanov developed a methodology for creating highly reusable algorithm libraries [25,39], using the \nterm generic programming for their work. They applied this method\u00adology to the construction of sequence \nand graph algorithms in Ada, C, and Scheme [28, 40, 58]. In the early 1990 s they applied their work \nto C++ and took advantage of templates [60] to construct the Standard Template Library [59] (STL). The \nSTL became part of the C++ Standard [18], which brought generic programming into the mainstream. Since \nthen, generic programming has been suc\u00adcessfully applied to the creation of generic libraries for numerous \nproblem domains [2,29,49,53,56,62,64]. A distinguishing characteristic of generic programming is that \ngeneric algorithms are expressed in terms of properties of types, rather than in terms of a particular \ntype. A generic algorithm can be used (more importantly, reused) with any type that has the neces- Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 05, June 12 \n15, 2005, Chicago, Illinois, USA. Copyright 2005 ACM 1-59593-056-6/05/0006...$5.00. sary properties. \nAlthough a statically typed language must therefore provide type parameterization ( generics ) to support \ngeneric pro\u00adgramming, generic programming as a development methodology is much richer than simply type \nparameterization. A fundamental issue in providing language support for generic programming is how to \nexpress the set of admissible types for a given algorithm, or equivalently, how to design a type system \nthat can check calls to a generic (type-parameterized) algorithm and separately check the implementation \nof the algorithm. An impor\u00adtant complementary issue is providing the run-time mechanism by which user-de.ned \noperations, such as multiplication for a BigInt type, are connected with uses of operations inside a \ngeneric algo\u00adrithm, such as a call to x * x in an algorithm parameterized on the number type. In today \ns programming languages there are four ap\u00adproaches to addressing these issues: subtype bounds, type classes, \nstructural matching, and by-name operation lookup. We describe each of these approaches below and show \nexamples in Figure 1. Subtype Bounds (Figure 1 (a)) In object-oriented languages, constraints on type \nparameters are typically expressed via subtyp\u00ading [6, 7, 47]. When a generic function constrains a type \nparameter to be a subtype of an interface, objects passed to the generic func\u00adtion must carry along the \nnecessary operations in a virtual table. This approach is used in Eiffel [35] and in the generics extensions \nto Java [4] and C# [27, 36]. Type Classes (Figure 1 (b)) In Haskell, type classes are used to describe \nthe set of admissible types to a generic function [63]. A type class contains a list of required operations, \nand a type is declared to belong to a type class through an instance declaration that provides implementations \nof the required operations. If a type parameter to a generic function is constrained to be an instance \nof a type class, operations from the appropriate instance declaration are implicitly passed into the \ngeneric function at a call site. A type class is similar to an object-oriented interface in that it speci.es \na set of required operations. However, unlike interfaces, type classes are not themselves types (e.g., \none cannot declare a variable with a type class as its type). Structural Matching (Figure 1 (c)) Many \nlanguages take a structural approach to expressing constraints: the name of an in\u00adterface does not matter \n(as it does for a type class), only the content of the interface matters (which operations must be provided). \nThis is the case for CLU type sets [32, 33], ML signatures [37], and O Caml object types [31]. In CLU, \npolymorphic functions are ex\u00adplicitly instantiated on particular types, and the corresponding clus\u00adter \nde.nitions for those types must supply the operations required in the where clause. In ML, a functor \nis explicitly instantiated with a structure, and the structure must match the required signature. In \nO Caml, the type of the object passed into a polymorphic function must structurally match the parameter \ns object type, and if success\u00adful the polymorphic function is implicitly instantiated. By-Name Operation \nLookup (Figure 1 (d)) In Cforall [10, 11] and C++, the operations used in a generic function are not \nnecessarily class methods, but can be free-standing functions. In public interface Number<U> {public \nU mult(U other); } public class BigInt implements Number<BigInt> {public BigInt mult(BigInt x) { ... \n}... } public class Square {<T extends Number<T>> T square(T x) { return x.mult(x); } public static void \nmain(String[] args) { square(BigInt(4)); }} (a) Subtyping: BigInt is a subtype of the Number interface \n(Java). number = { u | u has mul: proctype (u,u) returns (u) signals (under.ow,over.ow) } square = proc[t:type](a: \nt) returns (t) where t in number return (t$mul(a, a)) end square start up = proc() out:stream := stream$primary \noutput() stream$putl(out,int$unparse(square[int](4))) end start up (c) Structural matching: type int \nhas static methods for all operations in the number type set (CLU). class Number u where mult :: u .u \n.u square :: Number t .t .t square x = mult x x instance Number Int where mult = (*) main = square (4::Int) \n(b) Type classes: Int is an instance of the Number type class (Haskell). spec number(type U) { U mult(U, \nU); }; forall(type T | number(T)) T square(T x) { return mult(x,x); } int mult(int x, int y) { return \nx * y; } int main() {return square(4); } (d) By-name operation lookup: a function named mult is de.ned \nfor type int (Cforall). Figure 1. Some approaches to realizing generic programming. Cforall, constraints \nare speci.ed in terms of function signatures and in C++ they are speci.ed in the accompanying documentation \nin terms of valid expressions. In either case, when a call is made to a generic function, the compiler \ntries to locate function declarations with the appropriate name and signature. In [14] we implemented \na generic graph library (based on the Boost Graph Library [54]) using programming languages in each of \nthe above four categories. We carefully evaluated each language with respect to support for generic programming \nand found that although these approaches were able to support generic program\u00adming to varying degrees, \nnone was ideal. The primary limitation was that existing languages do not fully capture the essential \nfea\u00adture of generic programming, namely, concepts. In the parlance of generic programming, concepts are \nused to express sets of admissible types to an algorithm. More speci.cally, a concept is a list of requirements \nwhich denotes a set of conform\u00ading types. A function speci.ed in terms of concepts can be used with any \ntypes satisfying the requirements given by those concepts. Concepts as speci.cations were formalized \nin the generic program\u00adming literature [23, 24, 65], but are more widely known through their use in the \ndocumentation of C++ template libraries [3, 57]. Contributions. The current practice of generic programming \nis impeded because no existing language provides all the features and abstractions needed to support \ngeneric programming. In this paper we capture the essence of the necessary language abstrac\u00adincludes \nconcepts. Our design of FG re.ects a decade of experi\u00adence in generic library construction in C++. Technically, \nSystem FG is unique because 1) it provides scoped instance declarations, 2) concepts integrate nested \ntypes and type sharing in a type class\u00adlike feature, and 3) it explores the design space of type classes \nfor non-type-inferencing languages. Road map. Concepts have a number of similarities to the type classes \nof Haskell [17,63] and FG has a number of similarities (and differences) with existing work, which we \ndiscuss in Section 2. We split our presentation of FG into two parts to simplify the presentation and \nthe technical development. The .rst part adds concepts, models, and where clauses to System F. We informally \nintroduce the syntax and semantics in Section 3 and present some examples that demonstrate its characteristics. \nWe provide a formal semantics in Section 4 with a translation from FG to System F that preserves typing \n(similar to the translation of type classes to System F in [17]). The second part of our presentation \nadds support for associated types, which turns out to be a non-trivial addition to the language. In Section \n5 we discuss the motivation for associated types and then extend the syntax of FG and the translation \nto System F to handle associated types. The language FG omits a number of important but less essential \nfeatures for generic programming due to the scope (and page limit) of this paper. We brie.y describe \nthose features in Section 6 where we also discuss directions for future work. tions in a small formal \nsystem. Our primary contribution is System FG, a simple language based on System F [15, 52] that explicitly \n 2. Related Work Of existing language features, Haskell s type classes are the most similar to concepts. \nThey are based purely on parametric polymor\u00adphism, as are concepts. A fundamental difference between \nour ap\u00adproach and that of type classes is that we target languages without Hindley-Milner style type \ninference. This gives our design more freedom in other aspects. For example, in FG two concepts may share \nthe same member name (as do classes in object-oriented lan\u00adguages) whereas in Haskell two type classes \nin the same module may not. In addition, our design is based on experience in the .eld of generic library \nconstruction. One of the primary lessons learned from that experience is the need for modularity, especially \nfor good scoping rules. As a result, concepts and models in FGare expressions, not declarations (as are \ntype classes and instances in Haskell), and they obey the usual lexical scoping rules. Dif.culties arising \nfrom this difference are described in Section 3.2. Another lesson learned was the importance of language \nsupport for associated types. In our study [14] we found that without asso\u00adciated types, interfaces of \ngeneric algorithms become cluttered with extra type parameters to the point of causing scalability problems, \nand internal helper types of abstract data types must be exposed, thereby breaking encapsulation. In \nresponse to [14], Chakravarty et al proposed an extension to Haskell for associating algebraic data types \nwith type classes [8]. Our work differs from theirs in three ways. First, our associated types are not \nalgebraic data types but simply requirements for a type de.nition, which is all that is nec\u00adessary for \ngeneric algorithms. The second difference is that we in\u00adclude same-type constraints, which are vital \nfor generic algorithms that use associated types, as we explain in Section 5. Third, we include concept \ninheritance (re.nement) in our formalism. Earlier extensions to Haskell [9,21] address some of the same \nissues solved by associated types, but they did not address the problems of clutter and encapsulation. \nA rough analogy can be made between ML signatures [37] and FG concepts, and between ML structures and \nFG models. How\u00adever, there are signi.cant differences. First, functors are module\u00adlevel constructs and \ntherefore provide a more coarse-grained mech\u00adanism for parameterization than do generic functions. More \nim\u00adportantly, functors require explicit instantiation with a structure, thereby making their use more \nheavyweight than generic functions in FG, which perform automatic lookup of the required model or instance. \nThe associated types and same-type constraints of FG are roughly equivalent to types nested in ML signatures \nand to type sharing respectively. We reuse some implementation techniques from ML such as a union/.nd-based \nalgorithm for deciding type equality [34]. There are numerous other languages with parame\u00adterized modules \n[1, 16, 50] that require explicit instantiation with a structure. In some sense, our work combines some \nof the best features of Haskell and ML relative to generic programming. However, there are non-trivial \ndetails to combining these features and these details are discussed in depth in this paper. As discussed \nin the introduction, many object-oriented lan\u00adguages choose to express bounds on type parameters via \nsubtyp\u00ading [4, 7, 26, 27, 35, 36]. For a detailed account of the problems we encountered with the subtype-based \napproach we refer the reader to our study [14]. One of the problems was the inability to group constraints \non several types. Scala [44, 45] and gbeta [12, 13] have some support for associ\u00adated types in the form \nof object-dependent types. This differs from FG, where types are associated with a model which is a static \nentity. A model could be represented with an object in Scala or gbeta, how\u00adever FG provides the convenience \nthat models are implicitly passed to generic functions. Further, we found it dif.cult to express the \nFigure 2. Types and Terms of System F s, t . Type Variables x, y, d . Term Variables n . N d, s, t, . \n::= t | fn t . t | t \u00d7\u00b7 \u00b7\u00b7\u00d7 t |.t. t f ::= x | f(f) | .y : t. f | .t. f | f[t ] | let x = f in f | (f, \n. . . , f) | nth fn Figure 3. Higher Order Sum in System F let sum = (. t. .x (. sum : fn(list t, fn(t,t).t, \nt).t. .ls : list t, add : fn(t,t).t, zero : t. if null[t](ls) then zero else add(car[t](ls), sum(cdr[t](ls), \nadd, zero)))) in let ls = cons[int](1, cons[int](2, nil[int])) in sum[int](ls, iadd, 0) accumulate function \nin Section 5, especially the return type, us\u00ading Scala s nested abstract types. Scala s view construct \nis similar to model in FG: it allows for retroactive conformance of a type to an interface. However in \nScala, member operations must have the modeling type as a parameter, so operations such as identity elt \nof the Monoid concept (see Section 3) can not be expressed. O Caml s object types [31,51] and polymorphism \nover row vari\u00adables provide fairly good support for generic programming. How\u00adever, O Caml lacks support \nfor associated types so it too suffers from clutter due to extra type parameters. PolyTOIL [5], with \nits match-bound polymorphism, provides similar support for generic programming as O Caml but also lacks \nassociated types. Type sets in CLU [32, 33] are analogous to concepts in FG, and of course the where \nclause of FG was inspired by by CLU s where clause. Type sets differ from concepts in that they rely \non structural matching whereas concepts use nominal conformance established by a model de.nition. Also, \nFG provides a means for composing concepts via re.nement whereas CLU does not provide a means for composing \ntype sets. Finally, CLU does not provide support for associated types. 3. FG = System F + Concepts System \nF, the polymorphic lambda calculus, is the prototypical tool for studying type parameterization [15, \n52]. The syntax of System F is shown in Figure 2. We omit the type rules for System F as they are standard. \nThe variable f ranges over System F expressions; we reserve e for System FG expressions. We use an over-bar, \nsuch as t , to denote repetition: t1,...,tn. We use mult-parameter functions and type abstractions in \nSystem F to ease the translation from FG to F. We also include a let expression with the following type \nrule. S f1 : s S,x : s f2 : t (LET) S let x = f1 in f2 : t It is possible to write generic algorithms \nin System F, as is demonstrated in Figure 3, which implements a polymorphic sum function. The function \nis written in higher-order style, passing the type-speci.c add and zero as parameters. However, this \napproach does not scale: algorithms of any interest typically require dozens of type-speci.c operations. \nFigure 4. Types and Terms of FG c . Concept Names s, t . Type Variables x, y, z . Term Variables ., s, \nt ::= t | fn (t ) . t |.t where c<s>. t e ::= x | e(e) | .y : t. e | .t where c<s>. e | e[t ] | concept \nc<t>{re.nes c<s>; x : t; } in e | model c<t> {x = e; } in e | c<t>.x 3.1 Adding Concepts FG adds support \nfor generic programming through the addition of concepts, models, and where clauses to System F. The \nconcept fea\u00adture is a mechanism for grouping and organizing requirements. The model feature establishes \nthat a type meets the requirements of a concept. The where clause, which is written in terms of concepts, \nconstrains how a polymorphic function may be instantiated and du\u00adally introduces models that may be used \ninside a polymorphic func\u00adtion. Figure 4 shows the abstract syntax of the basic formulation of FG. Associated \ntypes and same-type constraints are added to FG in Section 5. To illustrate the features of FG, we evolve \nthe sum function. To be generic, the sum function should work for any element type that supports addition, \nso we will capture this requirement in a concept. Mathematicians already have a name for slightly more \ngeneralized concept: a Semigroup is some type together with an associative binary operation. In FG, the \nSemigroup concept is de.ned as follows. concept Semigroup<t> { binary op : fn(t,t).t; } The generic sum \nfunction requires more than just addition; it also requires a zero object of the appropriate type. Again, \nmathe\u00admaticians have a name for this concept: a Monoid, which is a Semi\u00adgroup with an identity element. \nIn generic programming terminol\u00adogy, we say that Monoid is a re.nement of Semigroup and de.ne Monoid \nin FG accordingly. concept Monoid<t> { re.nes Semigroup<t>; identity elt : t; } Note that the mathematical \nde.nition of monoid is quite general it only requires a binary operation and an identity element with \nrespect to that operation. That operation need not be addition and the identity element need not be zero. \nThe integers with multipli\u00adcation as the binary operation and one as the identity element also form a \nmonoid. To completely re.ect the mathematical de.nition of a monoid, the identity elt must satisfy the \nfollowing axioms for any object x of type t. Unfortunately, expressing this requirement is presently \noutside the scope of the FG type system. binary op(identity elt, x) = x = binary op(x, identity elt) \nA particular type, such as int, is said to model a concept if it satis.es all of the requirements in \nthe concept. In FG, an explicit declaration is used to introduce a model of a concept (correspond\u00ading \nto an instance declaration in Haskell). The following declares int to be a model of Semigroup and Monoid, \nusing integer addition for the binary operation and 0 for the identity element. The type system checks \nthe body of the model against the concept de.ni\u00adtion to ensure all required operations are provided and \nthat there are model declarations in scope for each re.nement. model Semigroup<int> { binary op = iadd; \n} model Monoid<int> { identity elt = 0; } A model can be found via the concept name and type, and members \nof the model can be extracted with the dot operator. For example, the following would return the iadd \nfunction. Monoid<int>.binary op With the Monoid concept de.ned, we are ready to write a generic sum function. \nThe function has been generalized to work with any type that has an associative binary operation with \nan iden\u00adtity element (no longer necessarily addition), so a more appropriate name for this function is \naccumulate. As in System F, type param\u00adeterization in FG is provided by the . expression. FG adds a where \nclause to the . expression for listing requirements. let accumulate = (. t where Monoid<t>. /*body*/) \nThe concepts, models, and where clauses collaborate to provide a mechanism for implicitly passing operations \ninto a generic func\u00adtion. As in System F, a generic function is instantiated by providing type arguments \nfor each type parameter. accumulate[int] In System F, instantiation substitutes int for t in the body \nof the .. In FG, instantiation also involves the following steps: 1. int is substituted for t in the \nwhere clause. 2. For each requirement in the where clause, the lexical scope of the instantiation is \nsearched for a matching model declaration. 3. The models are implicitly passed into the generic function. \n Consider the body of the accumulate function listed below. The model requirements in the where clause \nserve as proxies for actual model declarations. Thus, the body of accumulate is type-checked as if there \nwere a model declaration model Monoid<t> in the enclosing scope. The dot operator is used inside the \nbody to access the binary operator and identity element of the Monoid. let accumulate = (. t where Monoid<t>. \n.x (. accum : fn(list t). t. .ls : list t. let binary op = Monoid<t>.binary op in let identity elt = \nMonoid<t>.identity elt in if null[t](ls) then identity elt else binary op(car[t](ls), accum(cdr[t](ls))))) \nIt would be more convenient to write binary op instead of the explicit member access: Monoid<t>.binary \nop. However, such a statement could be ambiguous without the incorporation of over\u00adloading. For example, \nsuppose that a generic function has two type parameters, s and t, and requires each to be a Monoid. Then \na call to binary op might refer to either Monoid<s>.binary op or Monoid<t>.binary op. While the convenience \nof function over\u00adloading is important, we did not wish to complicate FG with this additional feature. \nWe discuss future work on function overloading in Section 6. The complete program for this example is \nin Figure 5. As with System F, FG is an expression-oriented programming language. The concept and model \ndeclarations are like let: they add to the lexical environment for the enclosed expression (after the \nin). Figure 5. Generic Accumulate concept Semigroup<t> { binary op : fn(t,t).t; } in concept Monoid<t> \n{ re.nes Semigroup<t>; identity elt : t; } in let accumulate = (. t where Monoid<t>. .x (. accum : fn(list \nt). t. .ls : list t. let binary op = Monoid<t>.binary op in let identity elt = Monoid<t>.identity elt \nin if null[t](ls) then identity elt else binary op(car[t](ls), accum(cdr[t](ls))))) in model Semigroup<int> \n{ binary op = iadd; } in model Monoid<int> { identity elt = 0; } in let ls = cons[int](1, cons[int](2, \nnil[int])) in accumulate[int](ls)  3.2 Lexically Scoped Models and Overlapping The lexical scoping of \nmodels declarations is an important feature of FG, and one that distinguishes it from Haskell. We illustrate \nthis distinction with an example. There are multiple ways for the set of integers to model Monoid besides \naddition with the zero identity element. For example, in FG, the Monoid consisting of integers with multiplication \nfor the binary operation and 1 for the identity element would be declared as follows. model Semigroup<int> \n{ binary op = imult; } model Monoid<int> { identity elt = 1; } Borrowing from Haskell terminology, this \ncreates overlapping model declarations, since there are now two models declarations for the Semigroup<int> \nand Monoid<int> concepts. Overlap\u00adping model declarations are problematic since they introduce ambi\u00adguity: \nwhen accumulate is instantiated, which model (with its cor\u00adresponding binary operation and identity element) \nshould be used? In FG, overlapping models declarations can coexist so long as they appear in separate \nlexical scopes. In Figure 6 we create sum and product functions by instantiating accumulate in the presence \nof different models declarations. This example would not type check in Haskell, even if the two instance \ndeclarations were to be placed in different modules, because instance declarations implicitly leak out \nof a module when anything in the module is used by another module.  4. Translation of FG to System \nF We describe a translation from FG to System F similar to the type\u00addirected translation of Haskell type \nclasses presented in [17]. The translation described here is intentionally simple; its purpose is to \ncommunicate the semantics of FG and to aid in the proof of Figure 6. Intentionally Overlapping Models \nlet sum = model Semigroup<int> { binary op = iadd; } in model Monoid<int> { identity elt = 0; } in accumulate[int] \nin let product = model Semigroup<int> { binary op = imult; } in model Monoid<int> { identity elt = \n1; } in accumulate[int] in let ls = cons[int](1, cons[int](2, nil[int])) in (sum(ls), product(ls)) \nFigure 7. Dictionaries for Semigroup<int> and Monoid<int>. type safety. We show that the translation \nfrom FG to System F preserves typing, which together with the fact that System F is type safe [48], ensures \nthe type safety of FG. The main idea behind the translation is to represent models with dictionaries \nthat map member names to values, and to pass these dictionaries as extra arguments to generic functions. \nHere, we use tuples to represent dictionaries. Thus, the model declarations for Semigroup<int> and Monoid<int> \ntranslate to a pair of let expressions that bind freshly generated dictionary names to the dictionaries \n(tuples) for the models. We show a diagram of the dictionary representation of these models in Figure \n7 and we show the translation to System F below. model Semigroup<int> { binary op = iadd; } in model \nMonoid<int> { identity elt = 0; } in /* rest */ =. let Semigroup 61 = (iadd) in let Monoid 67 = (Semigroup \n61,0) in /* rest */ The accumulate function is translated by removing the where clause and wrapping \nthe body in a . expression with a parameter for each model requirement in the where clause. let accumulate \n= (. t where Monoid<t>. /*body*/) =. let accumulate = (. t. (. Monoid 18:(fn(t,t).t)*t. /* body */) \nThe accumulate function is now curried, .rst taking a dictionary argument and then taking the normal \narguments. accumulate[int](ls) =. ((accumulate[int])(Monoid 67))(ls) In the body of accumulate there \nare model member accesses. These are translated into tuple member accesses. let binary op = Monoid<t>.binary \nop in let identity elt = Monoid<t>.identity elt in =. let binary op = (nth (nth Monoid 18 0) 0) in let \nidentity elt = (nth Monoid 18 1) in The formal translation rules are in Figure 9. We write [t . s]t \nfor the capture avoiding substitution of s for t in t . We write [t . s]t for simultaneous substitution. \nThe function FTV returns the set of free type variables and CV returns the concept names occurring in \nthe where clauses within a type. We write distinct t to mean that each item in the list appears at most \nonce. We subscript a nested tuple type with a non-empty sequence of natural numbers to mean the following: \n(t1 \u00d7 ... \u00d7 tk)i = ti (t1 \u00d7 ... \u00d7 tk)i,n =(ti)n The environment G consists of four parts: 1) the usual \ntype assignment for variables, 2) the set of type variables currently in scope, 3) information about \nconcepts and their corresponding dic\u00adtionary types, and 4) information about models, including the iden\u00adti.er \nand path to the corresponding dictionary in the translation. The (MEM) rule uses the auxiliary function \nb(c, ., n, G) to obtain a set of concept members together with their their types and the paths (sequences \nof natural numbers) to the members through the dictionary. A path instead of a single index is necessary \nbecause dictionaries may be nested due to concept re.nement. b(c, ., n, G) = M := \u00d8 for i =0,..., |c \n'|- 1 M := M . b(ci', [t ..].'i, (n, i), G) for i =0,..., |x|- 1 M := M .{xi : ([t ..]si, (n, |c '| \n+ i))}return M where concept c<t>{re.nes c'<.'>; x : s; } . d . G The (TABS) rule uses the auxiliary \nfunction bw to collect proxy model de.nitions from the where clause of a type abstraction and also computes \nthe dictionary type for each requirement. The function bm, de.ned below, is applied to each concept requirement. \nbw ([], G) = (G, []) bw((c<.>, c'<.'>), G) = generate fresh d (G,d) := bm(c, ., d, [], G) (G,d') := bw(c'<[t \n..].'>, G) return (G, (d, d')) where concept c<t>{re.nes c'<.'>; x : s; } . d . G The function bm(c, \n., d, n, G) collects the model de.nitions and dictionary type for the model c<.>. The model information \ninserted into the environment includes a dictionary name d and a path n that gives the location inside \nd for the dictionary of c(t). bm (c, .,d, n, G) = check G . - t := [] for i =0,..., |c '|- 1 (G,d') \n:= bm(ci', [t ..].'i, d, (n, i), G) Figure 8. Well-formedness of FG types and translation to System F \ntypes. Formation of dictionary types. G t t' t . G (TYVAR) G t t G s s' G t t ' (TYABS) G fn s . t fn \ns' . t' (G',d)= bw(c<.>, (G,t)) G' t t ' (TYTABS) G .t where c<.>. t .t. fn d . t' Figure 10. Well-formed \nFG environment that is in correspondence with a System F environment. G S G SG t t ' G S \u00d8 \u00d8 G,x : t \nS,x : t' G,t S,t G S(-,d)= bm(c, t, -, -, G) G, (model c<t> . (d, [])) S,d : d G S0 < |n| d : d . S(-,dn)= \nbm(c, t, -, -, G) G, (model c<t> . (d, n)) S G S (G',d')= bw(c'<t>, (G,t)) G' s s' G, (concept c<t>{re.nes \nc'<t>; x : s; } . d'@s') S t := t,d' t := t @[t ..]s G := G, (model c<.> . (d, n)) return (G,t ) where \nconcept c<t>{re.nes c'<.'>; x : s; } . d . G Figure 8 de.nes the translation from FG types to System \nF types. We now come to our main result for this section: translation produces well typed terms of System \nF, or more precisely, if G e : t f and S is a System F environment corresponding to G, then there exists \nsome type t ' such that S f : t'. Figure 10 de.nes what we mean by correspondence between an FG environment \nand System F environment. Several lemmas are used in the theorem. The proofs of these lemmas are omitted \nhere but appear in the accompanying technical report [55]. The technical report formalizes the lemmas \nand the\u00adorem in the Isar proof language [42] and the Isabelle proof assis\u00adtant [43] was used to verify \nthe proofs. The .rst lemma relates the type of a model member returned by the b function to the member \ntype in the dictionary for the model given by the bm . Figure 9. Type Rules for FG and Translation to \nSystem F G e : tf ' distinct t (G ' , -)= bw(c ' <.>, (G,t)) G ' tt d = ([t ' .. ' ]d ' )@t ' G, (concept \nc<t>{re.nes c ' <.>; x : t ; } . d) e : tfc .. CV(t) (CPT) G concept c<t>{re.nes c ' <.>; x : t; } in \ne : tf concept c<t>{re.nes c ' <. ' >; x : t ; } . d . GG .t ' G e : sf model c ' <[t..]. ' > . (d ' \n,n) . G x :[t..]t . y : sd fresh G, (model c<.> . (d, [])) e : tf d'' =( nth ... ( nth d' n1) ...nk) \n (MDL) G model c<.> {y = e; } in e : t let d =(d''@[y .f]x) in f distinct tt n FTV(G) = \u00d8 (G ' ,d)= \nbw(c<.>, (G,t)) G ' e : tf (TABS) G.t where c<.>. e : .t where c<.>. t .t. .d : d. f G ss ' G e : .t \nwhere c<.>. t f model c<[t.s].> . (d, n) . G (TAPP) G e[s]:[t .s]tf[s ' ]( nth ... ( nth dn1) ...nk) \nG .. ' (model c<.> . (d, n)) . G(x :(t, n ' )) . b(c, ., n, G) x : t . G (MEM) (VAR) G c<.>.x : t ( nth \n... ( nth dn ' 1) ...n k' )G x : tx G,x : se : tf G ss ' G e1 : fn s . tf1 G e2 : sf2 (ABS) (APP) G .x \n: s. e : fn s . t .x : s ' .f G e1(e2): tf1(f2) LEMMA 1. If (x:(t, n ')) . b(c, ., n, G) and (-,dn)= \nbm(c, ., -, -, G) then G td n. The next lemma states that the type of the dictionaries in the environment \nmatch the concept s dictionary type d. The purpose of the sequence n is to map from the dictionary d \nfor a derived concept to the nested tuple for the super concept c. LEMMA 2. If (model c<t> . (d, n)) \n. G and GS and (-,d)= bm(c, t, -, -, G) then S( nth ... ( nth dn1) ...nk): d The following lemma states \nthat extending the FG environment with proxy models from a where clause, and extending the System F environment \nwith d : d, preserves the environment correspon\u00addence. LEMMA 3. If GS and (G ' ,d)= bw(c<.>, G) then \nG ' S,d:d We now state the main result. The proof is in the Appendix. THEOREM 1 (Translation preserves \nwell typing). If G e : tf and GS ' '' then there exists t such that S f : t and G tt  5. Associated \nTypes and Same-Type Constraints Associated types are types that play a role in the operations of a concept, \nthat may vary from model to model, and that are deter\u00admined by the type parameters of the concept. An \nexample of an associated type is the pointed-to type of an iterator. In Standard ML, associated types \nare typically represented with nested types within a signature. Similarly, in FG nested types within \na concept are used to represent associated types. The following Iterator con\u00adcept declares a requirement \nfor a nested type named elt. concept Iterator<Iter> { types elt; next : fn(Iter).Iter, curr : fn(Iter).elt, \nat end : fn(Iter).bool; } Any model of the Iterator concept must provide a type assignment for elt. model \nIterator<list int> { types elt = int; next = (. ls : list int. cdr[int](ls)), curr = (. ls : list int. \ncar[int](ls)), at end = (. ls : list int. null[int](ls)); } In the following code the accumulate function \nis modi.ed to take an iterator as input instead of a list. The function is now parameterized on the iterator \ntype, not on the element type of the list. However, accumulate still needs a way to refer to the element \ntype, for example, to write the return type and to state the requirement that the element type must model \nMonoid. We extend the model member access syntax to apply to associated Figure 11. FG with Associated \nTypes and Same Type Constraints c . Concept Names s, t . Type Variables x, y . Term Variables ., s, t \n::= t | fn t . t |.t where c<s>; s = t .t | c<t>.t e ::= x | e(e) | .y : t. e | .t where c<s>; s = t \n.e | e[t] | concept c<t> { types s; re.nes c<s>; x : t; s = t; } in e | model c<t> { types t = s; x \n= e; } in e | c<t>.x | type t = t in e types: Iterator<Iter>.elt. The accumulate function can now be \nexpressed as follows. let accumulate = (. Iter where Iterator<Iter>, Monoid<Iterator<Iter>.elt>. .x (. \naccum : fn(Iter) .Iterator<Iter>.elt. .iter : Iter. /* body */)) From inside a generic function, associated \ntypes are opaque, that is, no information is known about them unless otherwise speci.ed. For example, \nassociated types from different models are assumed to be different types. However, an algorithm may need \ntwo associated types to be the same type, such as in the merge algorithm shown below, where the element \ntype of the two iterators must be the same type. To accommodate this, we introduce same-type constraints. \nlet merge = (. Iter1, Iter2, OutIter where Iterator<Iter1>, Iterator<Iter2>, OutputIterator<OutIter, \nIterator<Iter1>.elt>, LessThanComparable<Iterator<Iter1>.elt>; Iterator<Iter1>.elt = Iterator<Iter2>.elt. \n/* body */) 5.1 Syntax and Typing Rules The syntax of FG with associated types and same-type constraints \nis given in Figure 11 with the additions highlighted in gray. The syntax for concepts is extended to \ninclude requirements for asso\u00adciated types and for type equalities. We add type assignments to models \ndeclarations. In addition, where clauses are extended with type equalities. We have also added an expression \nfor creating type aliases. Type aliases were singled out in [14] as an important feature and the semantics \nof type aliases is naturally expressed using the type equality infrastructure for same-type constraints. \nType checking is complicated by the addition of same-type con\u00adstraints because type equality is no longer \nsyntactic equality: it must take into account the same-type declarations. We extend en\u00advironments to \ninclude type equalities, and introduce a new type equality relation G s = t . This relation is the congruence \nthat includes all the type equalities in G. Deciding type equality is equivalent to the quanti.er free \ntheory of equality with uninter\u00adpreted function symbols, for which there is an ef.cient O(n log n) time \nalgorithm [41]. We pre.x operations on sets of types and type assignments with G because type equality \nnow depends on the environment G. Figure 13 gives the typing rules for FG with associated types and same-type \nconstraints and the translation to System F. The (MDL) rule must check that all required associated types \nare given type assignments and that the same-type requirements of the con\u00adcept are satis.ed. Also, when \ncomparing the model s operations to the operations in the concept, in addition to substituting . for \nthe concept parameters t, occurrences of associated types must be re\u00adplaced with their type assignments \nfrom the body of the model and from models of the concepts c re.nes. The (TABS) and (TAPP) rules are \nchanged to introduce same-type constraints into the en\u00advironment and to check same-type constraints respectively. \nThe (APP) rule has been changed from requiring syntactic equality be\u00adtween the parameter and argument \ntypes to requiring type equality based on the congruence of the type equalities in the environment. The \nnew rule (ALS) for type aliasing checks the body in an envi\u00adronment extended with a type equality that \nexpresses the aliasing.  5.2 Translation The main idea of the translation is to turn associated types \ninto extra type parameters on type abstractions, an approach we .rst outlined in [19] and which is also \nused in [8]. The following code shows an example of this translation. The copy function requires a model \nof Iterator, which has an associated type elt. let copy = (. Iter, OutIter where Iterator<Iter>, OutputIterator<OutIter, \nIterator<Iter>.elt>. /* body */) An extra type parameter for the associated type is added to the translated \nversion of copy. let copy = (. Iter, OutIter, elt. (. Iterator 21:(fn(Iter).Iter)*(fn(Iter).elt)*(fn(Iter).bool), \nOutputIterator 23:(fn(OutIter,elt).OutIter). /* body */) However, there are two complications here that \nare not present in [8]: same-type constraints and concept re.nement. Due to the same-type constraints, \nall type expressions in the same equivalence class must be translated to the same System F type. Fortunately, \nthe congruence closure algorithm for type equality [41] is based on a union-.nd data structure which \nmaintains a representative for each type class. Therefore the translation outputs the representative \nfor each type expression. The translation of the merge function shows an example of this. There are two \ntype parameters elt1 and elt2 for each of the two Iterator constraints. Note that in the types for the \nthree dictionaries, only elt1 is used, since it was chosen as the representative. let merge = (. In1, \nIn2, Out, elt1, elt2. (. Iterator 78:(fn(In1).In1)*(fn(In1).elt1)*(fn(In1).bool), Iterator 80:(fn(In2).In2)*(fn(In2).elt1)*(fn(In2).bool), \nOutputIterator 84:(fn(Out,elt1).Out), LessThanComparable 88:(fn(elt1,elt1).bool). /* body */)) The second \ncomplication is the presence of concept re.nement. As mentioned in [8], this causes there to be extra \ntype parameters for not just the associated types of a concept c mentioned in the where clause, but also \nan extra type parameter for every associated type in concepts that c re.nes. Furthermore, there may be \ndiamonds in the re.nement diagram. To preclude duplicate associated types we keep track of which concepts \n(with particular type arguments) have already been processed. Figure 13 presents the translation from \nFG with associated types and same-type constraints to System F. We omit the (Mem), (Var), and (Abs) rules \nsince they do not change. The functions b and bm need to be changed to take into account associated types \nthat may appear in the type of a concept member or re.nement. For example, in the body of function below, \nthe expression <B(r)>.bar(x) has type <B(r)>.z, not just z. Also, the re.nement for A(z) in B translates \nto <B(r)>.z modeling A. concept A<u> { foo : fn(u).u; } in concept B<t> { types z; re.nes A<z>; bar : \nfn(t).z; } in (. r where B<r>. .x:r. A<B<r>.z>.foo(B<r>.bar(x))) We de.ne a function ba to collect all \nthe associated types from a concept c and from the concepts re.ned by c and map them to their concept-quali.ed \nnames. ba (c, t) = S := s : c<t>.s for i =0,..., |c '|- 1 ' S := S, ba(ci' ,S(t i)) return S where concept \nc<t>{types s ; re.nes c ' <t ' >; x : s; . = .'}. G Here is the new de.nition of b. b(c, t, n, G) = S \n:= ba(c, t),t : t M := \u00d8 for i =0,..., |c '|- 1 M := M . b(ci' ,S(t' i), (n, i), G) for i =0,..., |x|- \n1 M := M .{xi :(S(si), (n, |c '| + i))}return M where concept c<t>{types s ; re.nes c ' <t ' >; x : \ns; . = . '}. G We used bm in Section 4 to collect the the models from a concept c and the concepts that \nc re.nes. We change bm to also collect the same-type constraints from the concepts. In addition, for \nevery associated type s in c we generate a fresh type variable s ' and add the same-type constraint s \n' = <c(t)>.s. The function bm also returns a substitution mapping the associated type names to these \ngenerated type variables. bm(c, ., d, n, G) = check G . - and generate fresh variables s ' G := G,s ' \n= c<.>.s A := ba(c, .),t : . t := [] for i =0,..., |c '|- 1 (G, s, d ' ) := bm(c ' i,A(. ' i), d, (n, \ni), G) t := t,d ' t := t @A(s) G := G,A(.)= A(. ' ) G := G, model c<.> . (d, n, A) return (G, (s, s '),t \n) where concept c<t>{types s ; re.nes c ' <.' >; x : s; . = .'}. G The where clause of a type abstraction \nis processed sequentially so that later requirements in the where clause can refer to require\u00adments (e.g., \ntheir associated types) that appear earlier in the list. bw ([], G) = (G, []) Figure 12. Well-formed \nFG types (now with associated types and same-type constraints) and translation to System F types. G tt \n' t . G (TYVAR) G t [t]G G ss' G tt ' (TYABS) G fn s . t fn s ' . t ' G '' (G ' , s, d)= bw(c<.>, (G,t)) \ntt (TYTABS) G .t where c<.>, . = . ' .t .t, s. fn d . t ' G ..' G model c<.> . . . . G (TYASC) G c<.>.x \n[c<.>.x]G bw((c<.>, c ' <. ' >), G) = generate fresh d (G, s, d) := bm(c, ., d, [], G) (G,s ' ,d') := \nbw(c ' <[t..].' >, G) return (G, (s, s ' ), (d, d ' )) where concept c<t>{types s ; re.nes c ' <.' >; \nx : s; . = .'}. G Figure 12 shows the changes to the translation of FG types to Sys\u00adtem F types. Type \nvariables and member access types are mapped to their representative, written as [-]G. The proof that \nthe translation to System F preserves well typing can be modi.ed to take into account the changes we \nhave made for associated types and same-type constraints and will appear in the .rst author s Ph.D. thesis. \nTHEOREM 2 (Translation preserves well typing). If G e : tf and GS ' '' then there exists t such that \nS f : t and G tt  6. Conclusion The main contribution of this paper is the development of a lan\u00adguage, \nnamed FG, that provides .rst-class support for concepts, thereby capturing the essence of language support \nfor generic pro\u00adgramming. We present a formal type system for the language and provide semantics via \na translation to System F. We prove that the translation preserves typing, and thus type soundness for \nFG . There are several language features that are important for generic programming that we do not cover \nin this paper due to space considerations as well as a desire to provide an uncluttered presentation \nof concepts. Those features include: Nested Requirements. Concepts often include requirements on associated \ntypes. For example, a container s associated iterator a would be required to model the Iterator concept. \nThis form of concept composition is slightly different from re.nement but close enough that we did not \nwish to clutter our presentation of FG . Figure 13. Type Rules for FG with Associated Types and Same-Type \nConstraints and Translation to System F G e : tf . '' distinct t distinct s concept c ' <t ' >{...} \n. d ' . GG,t,s . G,t,st t G,t,ss . G,t,s s' .' d = ([t ' ..']d')@t ' G, (concept c<t>{types s ; re.nes \nc ' <.>; x : t ; s = s'} . d) e : tf (CPT) G concept c<t>{types s ; re.nes c ' <.>; x : t ; s = s '} \nin e : tf concept c<t>{types s ' ; re.nes c ' <.' >; x : t ; . = .'} . d . GG .t ' G ..' G e : sf ' '' \n s . sS = t : ., s :[s ..]s G model c ' <S(. ' )> . (d ' ,n, A ' ) . G S ' = S, .A ' G x : S'(t ) . y \n: s G S'(.)= S'(.') d fresh G, (model c<.> . (d, [], e : tf d'' =( nth ... ( nth d' n1) ...nk) (MDL) \n G model c<.> { types s = .; y = e} in e : t let d =(d''@[y .f]x) in f G '' distinct tt n FTV(G) = \u00d8 \n(G ' , s, d)= bw(c<.>, (G,t)) ,t = te : tf (TABS) G.t where c<.>, t .e : .t where c<.>, t .t .t, s..d \n: d. f G ss' G e : .t where c<.>, . = .' .t f G model c<[t .s].> . (d,n, s : . ) . G G[t.s]. =[t .s]. \n' (TAPP) G e[s]:[t.s]tf[s ' ,. ]( nth ... ( nth dn1) ...nk) t/. FTV(G) G,t = te : tf G e1 : fn s . tf1 \nG e2 : s ' f2 G s = s ' (ALS) (APP) G type t = t in e : tf G e1 e2 : tf1(f2) Implicit instantiation of \ntype abstractions. Ideally we would introduce a subsumption rule based on Mitchell s containment rela\u00adtion \n[38]. However, that relation is undecidable [61]. There are two interesting restrictions that are decidable: \nno coercion under a func\u00adtion arrow [30] and restriction of type arguments to monomorphic types [46]. \nWe plan further investigation in this area. Statically resolved function overloading, as in C++ and Java. \nThis feature is needed to remove the clutter of model member access such as Monoid<t>.binary op. Named \nmodels, as in [22]. This feature provides a mechanism for managing overlapping models, and would be a \nstraightforward addition to FG . Parameterized models (equivalent to parameterized instances in Haskell) \nare important for the case when the modeling type is parameterized, such as list<T>. Defaults for concept \nmembers (as in Haskell) provide a mech\u00adanism for implementing a rich interface in terms of a few functions. \nAlgorithm specialization is used in C++ to provide automatic dispatching to different versions of an \nalgorithm based on prop\u00aderties of a type, such as an iterator providing random access. The natural way \nto add this to FG would be to have function overloading based on the where clauses of generic functions \n[20].  A. Appendix PROOF. (of Theorem 1) The proof is by induction of the derivation of G e : tf. Cpt \nLet G ' =G, concept c<t>{re.nes c ' <.>; x : t; }. By inversion we have: concept c ' <t ' >{...} . d \n. G (1) G,tt t ' (2) G ' e : tf (3) c .. CV(t ) (4) From the assumption GS and from (1) and (2) we have \nG ' S. Then by (3) and the induction hypothesis we have S f : t ' and G ' tt ' . Then from (4) we have \nG tt ' . Mdl Let G ' =G, (model c<.>) . (d, []). We have the following by inversion: G e : sf (5) model \nc ' <[t..]. ' > . (d ' , n ' ) . G (6) x : [t ..]t . y : s (7) ' G e : t f (8) concept c<t>{re.nes c \n' <.' >; x : t ; } . d . G (9) Let S such that GS. With (5) and the induction hypothesis there exists \ns ' such that S f : s' and G ss'. Next, let r =( nth ... ( nth d ' n ' 1) ...n ' k) bw ' From GS and \n(9) we have (-,d ' )= (c <. ' >, G). and therefore (-, [t . .]d')= bw(c ' <[t ..].' >, G). Together with \n(6) and Lemma 2 we have S r :[t . .]d '. With (7) we have a well typed dictionary: S (r@[y .f]x): d (10) \nLet S ' be S,d : d so G ' S ' . Then with (8) and the induction hypothesis there exists t ' such that \nS ' f : t ' and G ' t t ' . From (10) we show S let d =(r@[y .f]x) in f : t ' . TAbs By inversion we \nhave: (G ' ,d)= bw(c<.>, (G,t)) (11) G ' ,t,M e : tf (12) From the assumption GS we have G,t S,t. Then \nwith (11) we apply Lemma 3 to get G ' S, t, d : d. We then apply the induction hypothesis with (12), \nso there exists t ' such that S, t, d : d f : t ' and G ' t t ' . Hence we have S, t .d : d. f : fn d \n. t ' and therefore S.t. .d : d. f : .t. fn d . t ' . Also, from G ' tt ' we have G,tt t ' . Then with \n(11) we have G .t where c<.>. t .t. fn d . t ' . TApp By inversion of the (TAPP) rule we have: G ss ' \n(13) G e : .t. where c<.>. t f (14) model c<[t.s].> . (d, n) . G (15) From (14) and the induction hypothesis \nthere exists t ' such that S f : t ' and G .t where c<.>. t t ' . By inversion there exists d, t '' , \nand G ' such that t ' = .t. fn d . t '' (16) (G ' ,d)= bw(c<.>, G) (17) G ' '' tt (18) Using (16) we \nhave S f[s']:[t .s']( fn d . t '' ) (19) From (17) and (13) we have (G ' , [t.s']d)= bw(c<[t .s].>, G)) \n(20) Let d' =( nth ... ( nth dn1) ...nk). From the assumption GS, (15), and (20) we apply Lemma 2 to \nget S d ' :[t . s']d. Then with (19) we have S f[s'](d'):[t . s]t '' and from (13) and (18) we have G[t \n.s]t [t .s']t '' . Mem By inversion we have (model c<t> . (d, n)) . G (21) x :(t, n ' ) . b(c, t, n, \nG) (22) From the assumption GS and (21), we have the following by inversion. (d : d) . S (23) (-,dn)= \nbm(c, t, -, -, G) (24) From (23) we have S d : d and with (22) we show S( nth ... ( nth dn 1' ) ...n \nk' ): d n. From (22), (24), and Lemma 1 we have G td n. . Var, Abs, App The proofs of these cases are \nstraightforward and omitted for brevity.  Acknowledgments We would like to thank Ronald Garcia, Jeremiah \nWillcock, Doug Gregor, Jaakko J\u00a8 arvi, Dave Abrahams, Dave Musser, and Alexan\u00adder Stepanov for many discussions \nand collaborations that in\u00adformed this work. This work was supported by NSF grant EIA\u00ad0131354 and by \na grant from the Lilly Endowment. References [1] Ada 95 Reference Manual, 1997. [2] J.-D. Boissonnat, \nF. Cazals, F. Da, O. Devillers, S. Pion, F. Rebufat, M. Teillaud, and M. Yvinec. Programming with CGAL: \nthe example of triangulations. In Proceedings of the .fteenth annual symposium on Computational geometry, \npages 421 422. ACM Press, 1999. [3] Boost. Boost C++ Libraries. http://www.boost.org/. [4] G. Bracha, \nN. Cohen, C. Kemper, S. Marx, et al. JSR 14: Add Generic Types to the Java Programming Language, April \n2001. http://www.jcp.org/en/jsr/detail?id=014. [5] K. B. Bruce, A. Schuett, and R. van Gent. PolyTOIL: \nA type\u00adsafe polymorphic object-oriented language. In W. Olthoff, editor, Proceedings of ECOOP 95, number \n952 in Lecture Notes in Computer Science, pages 27 51. Springer-Verlag, 1995. [6] P. Canning, W. Cook, \nW. Hill, W. Olthoff, and J. C. Mitchell. F-bounded polymorphism for object-oriented programming. In Proceedings \nof the fourth international conference on functional programming languages and computer architecture, \n1989. [7] L. Cardelli and P. Wegner. On understanding types, data abstraction, and polymorphism. ACM \nComputing Surveys, 17(4):471 522, 1985. [8] M. Chakravarty, G. Keller, S. P. Jones, and S. Marlow. Associated \ntypes with class. In Proceedings of the 32nd ACM-SIGACT Symposium on Principles of Programming Languages, \nPOPL 2005, Long Beach, California, pages 1 13. ACM, Jan. 2005. [9] K. Chen, P. Hudak, and M. Odersky. \nParametric type classes. In LISP and Functional Programming, pages 170 181, 1992. [10] G. J. Ditch.eld. \nContextual polymorphism, 1994. [11] G. J. Ditch.eld. Cforall reference manual and rationale, 1997. [12] \nE. Ernst. gbeta a Language with Virtual Attributes, Block Structure, and Propagating, Dynamic Inheritance. \nPhD thesis, Department of Computer Science, University of Aarhus, \u00b0 Arhus, Denmark, 1999. [13] E. Ernst. \nFamily polymorphism. In ECOOP, volume 2072 of Lecture Notes in Computer Science, pages 303 326. Springer, \nJune 2001. [14] R. Garcia, J. J\u00a8arvi, A. Lumsdaine, J. Siek, and J. Willcock. A comparative study of \nlanguage support for generic programming. In Proceedings of the 18th ACM SIGPLAN conference on Object\u00adoriented \nprograming, systems, languages, and applications, pages 115 134. ACM Press, Oct. 2003. \u00b4 de l Arithmtique \nd Ordre Suprieur. Thse de doctorat d tat, Universit Paris VII, Paris, France, 1972. [15] J.-Y. Girard. \nInterprtation Fonctionnelle et Elimination des Coupures [16] J. A. Goguen, T. Winker, J. Meseguer, K. \nFutatsugi, and J.- P. Jouannaud. Introducing OBJ. In Applications of Algebraic Speci.cation using OBJ. \nCambridge University Press, 1992. [17] C. V. Hall, K. Hammond, S. L. P. Jones, and P. L. Wadler. Type \nclasses in Haskell. ACM Trans. Program. Lang. Syst., 18(2):109 138, 1996. [18] International Standardization \nOrganization (ISO). ANSI/ISO Standard 14882, Programming Language C++. 1 rue de Varemb\u00b4 e, Case postale \n56, CH-1211 Gen`eve 20, Switzerland, 1998. [19] J. J\u00a8 An analysis of arvi, A. Lumsdaine, J. Siek, and \nJ. Willcock. constrained polymorphism for generic programming. In K. Davis and J. Striegnitz, editors, \nMultiparadigm Programming in Object-Oriented Languages Workshop (MPOOL) at OOPSLA, Anaheim, CA, Oct. \n2003. [20] J. J\u00a8arvi, J. Willcock, and A. Lumsdaine. Algorithm specialization and concept constrained \ngenericity. In Concepts: a Linguistic Foundation of Generic Programming. Adobe Systems, Apr. 2004. [21] \nM. P. Jones. Type classes with functional dependencies. In European Symposium on Programming, number \n1782 in LNCS, pages 230 244. Springer-Verlag, March 2000. [22] W. Kahl and J. Scheffczyk. Named instances \nfor Haskell type classes. In R. Hinze, editor, Proc. Haskell Workshop 2001, volume 59 of ENTCS, 2001. \nSee also: http://ist.unibw-muenchen.de/ Haskell/NamedInstances/. [23] D. Kapur and D. Musser. Tecton: \na framework for specifying and verifying generic system components. Technical Report RPI 92 20, Department \nof Computer Science, Rensselaer Polytechnic Institute, Troy, New York 12180, July 1992. [24] D. Kapur, \nD. R. Musser, and X. Nie. An overview of the tecton proof system. Theoretical Computer Science, 133:307 \n339, Oct. 1994. [25] D. Kapur, D. R. Musser, and A. Stepanov. Operators and algebraic structures. In \nProc. of the Conference on Functional Programming Languages and Computer Architecture, Portsmouth, New \nHampshire. ACM, 1981. [26] D. Katiyar, D. Luckham, and J. Mitchell. A type system for prototyping languages. \nIn Conference Record of POPL 94: 21st ACM SIGPLAN SIGACT Symposium of Principles of Programming Languages, \nPortland, Oregon, pages 138 150, 1994. [27] A. Kennedy and D. Syme. Design and implementation of generics \nfor the .NET Common Language Runtime. In Proceedings of the ACM SIGPLAN Conference on Programming Language \nDesign and Implementation (PLDI), pages 1 12, Snowbird, Utah, June 2001. [28] A. Kershenbaum, D. Musser, \nand A. Stepanov. Higher order imperative programming. Technical Report 88-10, Rensselaer Polytechnic \nInstitute, 1988. [29] U. K\u00a8othe. Handbook on Computer Vision and Applications, volume 3, chapter Reusable \nSoftware in Computer Vision. Acadamic Press, 1999. [30] D. Le Botlan and D. R\u00b4emy. MLF: Raising ML to \nthe power of System- F. In Proceedings of the International Conference on Functional Programming (ICFP \n2003), Uppsala, Sweden, pages 27 38. ACM Press, aug 2003. [31] X. Leroy, D. Doligez, J. Garrigue, D. \nRemy, and J. Vouillon. The Object Caml Documentation and User s Manual, September 2003. [32] B. Liskov, \nR. Atkinson, T. Bloom, E. Moss, C. Schaffert, B. Schei.er, and A. Snyder. CLU reference manual. Technical \nReport LCS-TR\u00ad225, Cambridge, MA, USA, October 1979. [33] B. Liskov and J. Guttag. Abstraction and speci.cation \nin program development. MIT Press, Cambridge, MA, USA, 1986. [34] D. MacQueen. An implementation of Standard \nML modules. In Proceedings of the 1988 ACM Conference on LISP and Functional Programming, Snowbird, UT, \npages 212 223, New York, NY, 1988. ACM. [35] B. Meyer. Eiffel: the Language. Prentice Hall, New York, \nNY, .rst edition, 1992. [36] Microsoft Corporation. Generics in C#, September 2002. Part of the Gyro \ndistribution of generics for .NET available at http: //research.microsoft.com/projects/clrgen/. [37] \nR. Milner, M. Tofte, and R. Harper. The De.nition of Standard ML. MIT Press, 1990. [38] J. C. Mitchell. \nPolymorphic type inference and containment. Information and Computation, 76(2-3):211 249, 1988. [39] \nD. R. Musser and A. Stepanov. Generic programming. In ISSAC: Proceedings of the ACM SIGSAM International \nSymposium on Symbolic and Algebraic Computation, 1988. [40] D. R. Musser and A. A. Stepanov. A library \nof generic algorithms in Ada. In Using Ada (1987 International Ada Conference), pages 216 225, New York, \nNY, Dec. 1987. ACM SIGAda. [41] G. Nelson and D. C. Oppen. Fast decision procedures based on congruence \nclosure. J. ACM, 27(2):356 364, 1980. [42] T. Nipkow. Structured Proofs in Isar/HOL. In H. Geuvers and \nF. Wiedijk, editors, Types for Proofs and Programs (TYPES 2002), volume 2646, pages 259 278, 2003. [43] \nT. Nipkow, L. C. Paulson, and M. Wenzel. Isabelle/HOL A Proof Assistant for Higher-Order Logic, volume \n2283 of LNCS. Springer, 2002. [44] M. Odersky and al. An overview of the scala programming language. \nTechnical Report IC/2004/64, EPFL Lausanne, Switzerland, 2004. [45] M. Odersky, V. Cremet, C. R\u00a8ockl, \nand M. Zenger. A nominal theory of objects with dependent types. In Proc. ECOOP 03, Springer LNCS, 2003. \n[46] M. Odersky and K. Laufer. \u00a8Putting type annotations to work. In Proceedings of the 23rd ACM SIGPLAN-SIGACT \nsymposium on Principles of programming languages, pages 54 67. ACM Press, 1996. [47] B. C. Pierce. Intersection \ntypes and bounded polymorphism. Mathematical Structures in Computer Science, 11, 1996. [48] B. C. Pierce. \nTypes and Programming Languages. MIT Press, 2002. [49] W. R. Pitt, M. A. Williams, M. Steven, B. Sweeney, \nA. J. Bleasby, and D. S. Moss. The bioinformatics template library: generic components for biocomputing. \nBioinformatics, 17(8):729 737, 2001. [50] E. Poll and S. Thompson. The Type System of Aldor. Technical \nRe\u00adport 11-99, Computing Laboratory, University of Kent at Canterbury, Kent CT2 7NF, UK, July 1999. [51] \nD. R\u00b4emy and J. Vouillon. Objective ML: An effective object-oriented extension to ML. Theory And Practice \nof Object Systems, 4(1):27 50, 1998. A preliminary version appeared in the proceedings of the 24th ACM \nConference on Principles of Programming Languages, 1997. [52] J. C. Reynolds. Towards a theory of type \nstructure. In B. Robinet, editor, Programming Symposium, volume 19 of Lecture Notes in Computer Science, \npages 408 425, Berlin, 1974. Springer-Verlag. [53] J. Siek, L.-Q. Lee, and A. Lumsdaine. The generic \ngraph component library. In Proceedings of the 1999 ACM SIGPLAN conference on Object-oriented programming, \nsystems, languages, and applications, pages 399 414. ACM Press, 1999. [54] J. Siek, L.-Q. Lee, and A. \nLumsdaine. The Boost Graph Library: User Guide and Reference Manual. Addison-Wesley, 2002. [55] J. Siek \nand A. Lumsdaine. Essential language support for generic programming: Formalization part 1. Technical \nReport 605, Indiana University, December 2004. [56] J. G. Siek and A. Lumsdaine. Advances in Software \nTools for Scienti.c Computing, chapter A Modern Framework for Portable High Performance Numerical Linear \nAlgebra. Springer, 2000. [57] Silicon Graphics, Inc. SGI Implementation of the Standard Template Library, \n2004. http://www.sgi.com/tech/stl/. [58] A. Stepanov. gclib. http://www.stepanovpapers.com, 1987. [59] \nA. A. Stepanov and M. Lee. The Standard Template Library. Technical Report X3J16/94-0095, WG21/N0482, \nISO Programming Language C++ Project, May 1994. [60] B. Stroustrup. Parameterized types for C++. In USENIX \nC++ Conference, October 1988. [61] J. Tiuryn and P. Urzyczyn. The subtyping problem for second-order \ntypes is undecidable. Information and Computation, 179(1):1 18, 2002. [62] M. Troyer, S. Todo, S. Trebst, \nand A. F. and. ALPS: Algorithms and Libraries for Physics Simulations. http://alps.comp-phys. org/. [63] \nP. Wadler and S. Blott. How to make ad-hoc polymorphism less ad\u00adhoc. In ACM Symposium on Principles of \nProgramming Languages, pages 60 76. ACM, Jan. 1989. [64] J. Walter and M. Koch. uBLAS. Boost. http://www.boost.org/ \nlibs/numeric/ublas/doc/index.htm. [65] J. Willcock, J. J\u00a8arvi, A. Lumsdaine, and D. Musser. A formalization \nof concepts for generic programming. In Concepts: a Linguistic Foundation of Generic Programming at Adobe \nTech Summit. Adobe Systems, Apr. 2004.  \n\t\t\t", "proc_id": "1065010", "abstract": "<i>Concepts</i> are an essential language feature for generic programming in the large. Concepts allow for succinct expression of constraints on type parameters of generic algorithms, enable systematic organization of problem domain abstractions, and make generic algorithms easier to use. In this paper we present the design of a type system and semantics for concepts that is suitable for non-type-inferencing languages. Our design shares much in common with the type classes of Haskell, though our primary influence is from best practices in the C++ community, where concepts are used to document type requirements for templates in generic libraries. Concepts include a novel combination of associated types and same-type constraints that do not appear in type classes, but that are similar to nested types and type sharing in ML.", "authors": [{"name": "Jeremy G. Siek", "author_profile_id": "81100437231", "affiliation": "Indiana University, Bloomington, IN", "person_id": "PP31053469", "email_address": "", "orcid_id": ""}, {"name": "Andrew Lumsdaine", "author_profile_id": "81100082403", "affiliation": "Indiana University, Bloomington, IN", "person_id": "P18130", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1065010.1065021", "year": "2005", "article_id": "1065021", "conference": "PLDI", "title": "Essential language support for generic programming", "url": "http://dl.acm.org/citation.cfm?id=1065021"}