{"article_publication_date": "06-12-2005", "fulltext": "\n Programming Ad-hoc Networks of Mobile and Resource-Constrained Devices * Yang Ni Ulrich Kremer Adrian \nStere Liviu Iftode Department of Computer Science Rutgers University Piscataway, NJ 08854 {yangni,uli,adrianst,iftode}@cs.rutgers.edu \nAbstract Ad-hoc networks of mobile devices such as smart phones and PDAs represent a new and exciting \ndistributed system architec\u00adture. Building distributed applications on such an architecture poses new \ndesign challenges in programming models, languages, com\u00adpilers, and runtime systems. This paper discusses \nSpatialViews, a high-level language designed for programming mobile devices connected through a wireless \nad-hoc network. SpatialViews allows speci.cation of virtual networks with nodes providing desired ser\u00advices \nand residing in interesting spaces. These nodes are discovered dynamically with user-speci.ed time constraints \nand quality of re\u00adsult (QoR). The programming model supports best-effort seman\u00adtics, i.e., different \nexecutions of the same program may result in correct answers of different quality. It is the responsibility \nof the compiler and runtime system to produce a high-quality answer for the particular network and resource \nconditions encountered during program execution. Four applications, which exercise different fea\u00adtures \nof the SpatialViews language, are presented to demonstrate the expressiveness of the language and the \nef.ciency of the com\u00adpiler generated code. The applications are an application that col\u00adlects and aggregates \nsensor data in network, an application that performs dynamic service installation, a mobile camera applica\u00adtion \nthat supports computation of.oading for image understanding, and an augmented-reality (AR) Pacman game. \nThe ef.ciency of the compiler generated code is veri.ed through simulation and physi\u00adcal measurements. \nThe reported results show that SpatialViews is an expressive and effective language for ad-hoc networks. \nIn ad\u00addition, compiler optimizations can signi.cantly improve response times and energy consumption. \nCategories and Subject Descriptors D.3.0 [PROGRAMMING LANGUAGES]: General General Terms Design, Languages \n* This work was partially supported by NSF-ITR/SI award ANI-0121416. Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 05, June 12 15, 2005, Chicago, Illinois, \nUSA. Copyright 2005 ACM 1-59593-056-6/05/0006...$5.00. Keywords Ad-hoc Networks, MANET, Location-Awareness, \nSer\u00advice Discovery, Quality of Result  1. Introduction An ad-hoc network, a.k.a. MANET (Mobile Ad-hoc \nNetwork)[19], is a dynamic network spontaneously formed among mobile nodes without support from any infrastructure[38, \n21, 8]. Ad-hoc net\u00adworks are becoming a promising new target platform, with the pro\u00adliferation of smart \ndevices, i.e., small wireless devices with sig\u00adni.cant computing power, memory, and sensory capabilities. \nTyp\u00adical examples of such devices are state-of-the-art smart phones and PDAs. These devices are able \nto provide information about their surrounding physical environment using sensors (e.g.: light, motion, \ntemperature, pressure, speed), cameras, and microphones. Since not all their resources are used all the \ntime, ad-hoc network nodes can potentially share cycles, memory, and sensors. The no\u00adtion of sharing \nover a distributed platform has been successfully used in the context of peer-to-peer systems [13, 32, \n24] and net\u00adworks of workstations (NOW) [4]. Figure 1 illustrates an ad-hoc network. Smart phones and \nPDAs carried by pedestrians com\u00admunicate via short-range wireless networking such as 802.11 or Bluetooth. \nComputer devices embedded in cars, buildings, or .xed structures such as a traf.c light may also be part \nof the wireless network. The structure of the network changes dynamically as cars and people move, entering \nor leaving it. Additionally, the network shown in this .gure may be part of a bigger ad-hoc network, \nper\u00adhaps spanning the entire city or some larger geographical area. In contrast to the P2P and NOW distributed \nsystem architec\u00adtures, the location of a network node in the physical space may be crucial for a distributed \napplication executed on an ad-hoc net\u00adwork. Nodes are interesting for an application due to the hardware \nand software services that they provide and their particular loca\u00adtion. Therefore, a programming model \nfor ad-hoc networks must be able to describe spaces and desired services within such spaces. Since most \nsuch devices rely on battery power, any sharing will involve energy consumption, which will lead to a \nshortened bat\u00adtery life. As a result, applications should be able to set limits on their resource usage, \ntrading off the quality of the produced an\u00adswer for a reduction in the resource usage necessary to compute \nthe answer. This tradeoff can be expressed as the desired quality of result (QoR). The quality of result \nis de.ned by the programmer and it is application speci.c in most cases. Due to the volatile and dynamic \nnature of the network, a program execution can return a range of correct answers, which must be partially \norderable ac\u00adcording to one or more quality criteria. An implementation of such a programming model should \nfollow best-effort semantics to pro\u00adduce a high-quality answer under the particular network conditions, \nFigure 1. An envisioned ad-hoc network at a busy street corner. while respecting user-speci.ed resource \nconstraints. Developing a formal best-effort semantics model is a new and important open problem, but \nis beyond the scope of this paper. In this paper, we discuss SpatialViews, a programming lan\u00adguage for \nad-hoc networks. The goal of SpatialViews is to pro\u00advide a high-level programming model, which allows \napplication programmers to easily develop and maintain their ad-hoc network applications. Each node in \nthe network is assumed to have substan\u00adtial computation and communication capabilities, and is aware \nof its spatial location. The location of a node can be queried by the user level program, i.e., a particular \nlocation may determine the ac\u00adtions performed by a program. Severely resource-constrained sen\u00adsor networks \nare not the main target of SpatialViews. Examples for target network nodes are state-of-the-art smart \nphones, PDAs, notebooks, and laptop computers. The SpatialViews language is a vehicle to study different \nlan\u00adguage, compiler optimizations, and performance/QoR/energy trade offs. Clearly, not all conceivable \napplications may be implemented within the framework of this programming model. Our goal is to provide \na high-level programming model for a large class of appli\u00adcations for mobile ad-hoc networks that hides \nmany details of the underlying volatile target networks. In this sense, SpatialViews is complementary \nto lower level languages such as nesC [14], SP [6] and SM [22]. A case study are presented in this paper, \nusing four different applications implemented in SpatialViews. These appli\u00adcations are (a) an application \nthat collects and aggregates sensor data in network, (b) an application that performs dynamic service \ninstallation, (c) a mobile camera application that supports com\u00adputation of.oading for face detection \nto a server discovered on\u00addemand, and (d) an augmented-reality (AR) Pacman game that in\u00advolves multiple \nplayers in a physical space tagged with virtual objects. The AR Pacman game application was inspired \nby the Hu\u00adman Pacman project[11] and the Pac-Manhattan game[37]. These applications exercise different \nSpatialViews features and have been chosen to illustrate the expressiveness of the language, and the \nef\u00adfectiveness of our prototype compiler to produce ef.cient code. The performance of the compiler generated \ncode were evaluated through simulation and physical measurements. Other applications such as Traf.cView[12] \nand EasyCab[49] can also be implemented in SpatialViews, but we did not evaluate them for this study. \nIn our previous work[35], we provided a straightforward serial implementation of SpatialViews. A single \nprogram walks around the network and executes on each encountered node, one node af\u00adter another. The \nserial implementation has scalability and robust\u00adness issues. When the network size increases, the execution \ntime increases linearly at best. Even partial network disconnection or failures of single network nodes \nmay lead to the loss of the pro\u00adgram, resulting in no answers being reported. In [36], we performed an \ninitial bene.ts study of different parallelization and replication techniques and their impact on program \nresponse time, energy con\u00adsumption, and quality of result. The discussed techniques were based on .ooding, \nspanning-tree construction, and bounded pro\u00adgram replication. Only a single sensor network application \nwas used in that previous study. The contributions of this paper are as follows: 1. A detailed discussion \nof the SpatialViews language and its features. 2. An evaluation of the expressiveness and performance \nof Spa\u00adtialViews and its prototype compiler for four application pro\u00adgrams that stress different features \nof the language. Evaluation is done in terms of QoR, response time, and energy consump\u00adtion. Physical \nmeasurements were performed on a network of 12 HP iPAQ handheld PCs running Linux and communicating through \na wireless 802.11 network connection. Simulation re\u00adsults were obtained for up to 64 network nodes. \n3. A discussion and evaluation of compiler optimizations used to implement a core SpatialViews construct, \nnamely the spatial view iterator.  The reported results show that the language model is expressive and \nallows ef.cient implementations. The authors are very aware that the success of any new language model \nwill ultimately be mea\u00adsured in terms of its acceptance by users who try to run applications they care \nabout on ad-hoc networks. A .rst version of the Spa\u00adtialViews compiler, runtime system, and debugging/visualization \nenvironment is publicly available1. We believe that this paper makes a strong case for viewing ad-hoc \nnetworks as an interesting distributed computing target platform with exciting and wide-open application \npotential. Part of this potential can be easily accessed through the use of our SpatialViews programming \nlanguage. In ad\u00addition, SpatialViews has proven itself as a research infrastructure into new compiler \noptimizations for ad-hoc networks. 2. SpatialViews Language The programming target of SpatialViews is \na network of nodes em\u00adbedded in the physical world. A node in the physical world may be of interest because \nit is at a speci.c place (location) at a speci.c time, providing a speci.c service. Therefore, location \nand time are crucial concepts for a programming model for ad-hoc networks, in addition to node functionality. \nA .rst-class abstraction in Spa\u00adtialViews is a virtual network explicitly named by the services and locations \nof its nodes, and instantiated across time. The actual net\u00adwork embedded in the physical world consists \nof many such vir\u00adtual networks. For each virtual network, computation is speci.ed. The computation is \nperformed on individual nodes of the speci\u00ad.ed virtual network, with computation migrating from one node \nto another. It is desirable to support computation replication and par\u00adallelization, which allows computation \nto be performed on several nodes or migrate between nodes at the same time. A virtual network is declared \nas a spatial view, and instantiated using a spatial view iterator. A spatial view declaration requires \na set of services and a space. An iterator instantiates a spatial view by discovering those nodes that \nprovide the services and reside in the space, and by migrating computation to them. The iteration procedure \nmay be limited by a time constraint which represents a time budget that once expired will lead to the \ntermination of the iteration procedure. The virtual network is thus the collection of nodes that provide \nthe speci.c services and are con.ned to a 1 SpatialViews web site http://www.cs.rutgers.edu/spatialviews \nspace-time region de.ned by a spatial view and an iterator. To write a program in SpatialViews is to \nde.ne spatial views and their iterators. SpatialViews is an extension to Java. Computation is de.ned \nin each iterator as in standard Java. For the remainder of this paper, a node is assumed to be a virtual \nnode unless explicitly speci.ed otherwise. A virtual node is bound to a physical node within a space\u00d7time \nregion. Spa\u00adtialViews allows the speci.cation of space and time granularities of this space\u00d7time region. \nThese granularities are closeness metrics in terms of space and/or time, respectively. Every node in \nthe vir\u00adtual network has to be distinct from any other node either in terms of space or time. This language \nfeature allows the programmer to control the density of a virtual network that is spread across time \nand space, making tradeoffs possible between performance, energy consumption, and quality of result (QoR). \nAs time changes, the same physical node may represent differ\u00adent nodes in a virtual network. If a physical \nnode occupies multiple locations due to its mobility, it may also represent different nodes at the same \ntime, i.e., within the same time granularity. The .nest granularity that can be chosen by an application \nin terms of time and space depends on the location and timing technologies avail\u00adable in the physical \nnetwork. No bindings between virtual nodes and physical nodes can be made explicit or permanent, because \nsuch bindings may change over time and space. For this reason, a virtual network can only be accessed \nby dynamically instantiating a spatial view using an iterator. A more detailed description of the SpatialViews \nlanguage can be found elsewhere [26]. 2.1 Spatial View De.nition A spatial view is a collection of virtual \nnodes each of which pro\u00advides a given set of services and resides in a given space. A spatial view de.nes \na virtual network over the real, physical network. A virtual node is the programming abstraction for \na physical node, which can be denoted as a tuple (services, location, time). The ser\u00advices are provided \nby the physical node. The location is the location of the physical node. The time is the time when the \nprogram starts its execution on the physical node representing the virtual node. A virtual node is an \nexecution environment in which a program has access to the denoted services at the denoted location and \ntime. To simplify our discussion, we will assume for the remainder of the paper that each virtual node \nspeci.es only a single service. A service is named by a Java interface. The name of the inter\u00adface, the \nmethod list of the interface, and the semantics of all the methods are agreed upon by all the participants \nof the network. An object is said to provide a service if it implements its interface. A physical node \nis said to provide a service if it hosts an object that does. A physical node may provide multiple services, \neither by hosting multiple objects or one object implementing multiple inter\u00adfaces. Such a physical node \nis represented by more than one virtual node. Installation of services will be discussed in Section 2.3. \nA space is represented by a space type object. A space type is class Space or its derived class. Class \nSpace has a single ab\u00adstract method contains, which takes a location as an argument and returns a boolean \nvalue true if the space contains the lo\u00adcation, and false if not. The derived classes of Space include \nCircle, Rectangle, etc. SpaceUnion, SpaceIntersection, and SpaceDiff derived classes of Space allow \ncomposition of complicated spaces using simple spaces. A location is repre\u00adsented as a Location object. \nDerived classes of Location may represent locations in different formats, including GPS locations, MIT \nCricket locations[39], or fake locations appropriate for a particular simulation purpose. Usually, such \na Location object is returned by querying the location service. The current implementa\u00adtion of the SpatialViews \nruntime library supports GPS and Cricket locations. For instance, a call to method createGPSLocation \ncre\u00adates a Location object from longitude, latitude, and, optionally, attitude. A space granularity .s \ncan be de.ned for a spatial view. It de\u00ad.nes the spatial density of the virtual network. Speci.cally, \nthe expected density for a spatial view with space granularity .s is O(.s -2) for 2D spaces, i.e., one \nnode every .s 2 area. In 3D spaces, the expected density is O(.s -3). Beyond density, the speci.cation \nof .s requires virtual nodes to be approximately uni\u00adformly distributed across the entire space. Space \ngranularity gives the programmer control over QoR, and provides the compiler and runtime system an opportunity \nto make tradeoffs among perfor\u00admance, resource usage, and QoR. Spatial views are de.ned using the spatialview \nstatement. The following statements de.ne two spatial views. Space granu\u00adlarity .s is de.ned using a \n% (per) operator in a spatialview statement. spatialview sv1 = Camera @ BuildingC.Floor3; spatialview \nsv2 = LightSensor @ CampusB % 100; Camera and LightSensor are class names for two Java inter\u00adfaces. BuildingC.Floor3 \nand CampusB are variable names for two space type objects. They are de.ned as following. Rectangle CampusB=new \nRectangle(...); class CBuildingC extends Rectangle { //constructors omitted ... //arguments omitted public \nRectangle Floor3=new Rectangle(...); } CBuildingC BuildingC = new CBuildingC(...); These space de.nitions \ncan be put into a library and imported into an application program. For spatial view sv2, the space granularity \nis set to be 100 meters. For sv1, since no space granularity is explicitly speci.ed, it is assumed to \nbe the .nest accuracy needed to distinguish two physical nodes, or the .nest achievable with the available \npositioning technology. 2.2 Spatial View Iterator Once a spatial view is de.ned, an iterator can be \napplied to it. The iterator discovers the virtual nodes in the spatial view, gets access to their services, \nand migrates program execution to them. In SpatialViews, an iterator is expressed as a visiteach state\u00adment. \nFor example, visiteach x : sv1 { Picture p=x.getPicture(); ... } where sv1 is the spatial view of cameras \nde.ned above, and x is an object which is an instance of the service (de.ned by the Camera interface \nin this example). When the control .ow reaches the visiteach statement, the program should have mi\u00adgrated \nto a node that provides the service and is in the speci.ed space(BuildingC.Floor3 in this example), and \nx should have been initialized as an object of type Camera to access the service. The program continues \nits execution on the new node, until the end of the iterator. One execution of the iterator body on a \nnode is called a visit to the node. After visiting one node, the program will try to visit another virtual \nnode. If no more nodes can be found, the program will migrate back to the node where it migrated from \nbefore the program execution reached the iterator. The order in which the program visits the nodes is \nnot known a priori. In fact, the program may replicate itself and execute on multiple nodes in program \nnode (service) Figure 2. The SpatialViews memory model: The program space is part of a program s execution \nstate and migrates with the program; the node or service space is a resilient memory area and does not \nmigrate. Objects in program space are allocated using the new con\u00adstruct. The register creates objects \nin the service space. Service variables have a speci.ed, maximal life time (100 seconds in this example) \nand can be accessed by other SpatialViews programs, thereby allowing exchange of information between \nprograms. parallel. However, only one instance of the program remains after the iterator has .nished. \nDuring an iteration, unique virtual nodes are visited. Unique\u00adness requires that the location or time \nof a virtual node differ from other nodes. The difference should be at least an amount speci.ed by the \nspace or time granularity. Space granularity is speci.ed in the spatial view de.nition. Time granularity \nis speci.ed in the iter\u00adator. Different physical nodes can be visited, as long as they have distinguishable \nlocations, or are visited at different times. A sin\u00adgle physical node can be revisited in .t time after \nthe previous visit, where .t is the time granularity. It can also be revisited if it changes its location \nat least .s, where .s is the space granularity. In practice, the desired spatial and temporal distribution \nmay be ap\u00adproximated. The current implementation uses a relaxed model that considers virtual nodes different \nif they are in different .s \u00d7 .t subgrids of the original space\u00d7time target region. In.nite iteration \nis possible, because the target virtual network could be in.nite. There are two reasons. First, new physical \nnodes may join the network. Second, with time change or movement, the same physical nodes can be reused, \nand keep appearing as new virtual nodes in our spatial view. Although in.nite spatial view iterations \nhave their applications, it is often desirable to avoid them. The time constraint on an iterator can \nbe used for this purpose. A time constraint is a time budget for an iteration. After each visit to a \nvirtual node, the remaining budget will be checked. If the budget is exhausted, further visit to new \nnodes will be prevented. The time granularity .t is speci.ed in the every clause. An every clause is \nalways followed by a within clause or forever keyword. For example. visiteach x:sv1 every 3 within 600 \n{...} visiteach x:sv1 every 5 forever {...} where every 3 within 600 means: .t =3seconds and the time \nconstraint is 600 seconds, and every 5 forever means: .t =5 seconds and the time constraint is in.nity. \nA within clause or a forever keyword is always used after an every clause and never used alone. If no \nevery, within,or forever clauses are used in the iterator, the programmer indicates that as many virtual \nnodes as possible should be visited without using a physical node more than once. In other words, an \nunquali.ed iterator produces a snapshot of the network that can be greedily discovered in one try. 2.3 \nMemory Model Every variable in a SpatialViews program is either a program vari\u00adable or a service variable. \nProgram variables migrate as part of the program execution state from one virtual node to another. Service \nvariables do not migrate. The main motivation for service variables is the support of cooperation among \nSpatialViews programs, and the access to services provided by and residing on physical nodes, e.g. hardware-speci.c \nfunctionality such as access to sensors or cameras. Program variables are stored in the program space, \nand service variables are stored in the node (service) space. Program variables are created using the \nnew operator or are of basic type, and service variables are allocated using the register operator. Figure \n2 shows the partitioned memory model for SpatialViews programs. Service Variables A service variable \nis declared in an iterator. It can only be accessed in that iterator, but not in any nested iterators. \nA register operation creates a service object in the node space from a class that implements one or more \nservice interfaces. That service object can be used later through a service variable. For any created \nobject, a register operation generates one or more entries in the service table of the hosting node. \nThe service table is a data structure that maps service names (interfaces) to service objects. An object \ns names are all the interfaces that it implements, directly or through inheritance. Once created, a service \nobject can be found by an iterator through its names in the service table, and can be bound to a service \nvariable. The register operator contains a parameter that speci.es the lifetime of the created object \nin seconds. This lifetime is a hint for garbage collection in the node space. The runtime system does \nnot guarantee that the registered service will be available for its speci.ed, maximal lifetime. The host \nnode may decide at any time to temporarily suspend access to service variables, or to permanently delete \nservice variables. Program Variables There are three categories of program vari\u00adables in a SpatialViews \nprogram. Each category has speci.c access constraints, giving opportunities for different optimizations \nsuch as parallel execution of the iterations of a spatial views iterator using structured communication \npatterns [36]. Without such restrictions, race conditions could occur during parallel execution. By default, \nall program variables are assumed to be local. SpatialViews pro\u00adgram variables can be of one of the following \ncategories: 1. local: a local variable is read/write within the de.ning iteration, and read-only within \nnested iterators. 2. container: a container variable represents a collection of ob\u00adjects. It is read/write \nwithin the de.ning iteration, and write\u00adonly within nested iterators. The corresponding abstract data \ntype is that of a set of elements of a particular type. Write\u00adonly means that objects can only be inserted \ninto the collec\u00adtion, but not read or removed. A container variable must be an instance of the prede.ned \nContainer class. 3. reduction: a reduction variable is speci.ed together with a com\u00admutative and associative \noperation. It is read/write within the de.ning iteration, and apply-reduction-operation-only within nested \niterations. The initial SpatialViews language will only support a rather small subset of reductions, \nsuch as sum and product reductions. Reduction variable declarations start with the keywords sumreduction \nor productreduction.  There are no global, shared variables without any access restric\u00adtions in the \nSpatialViews language. If a variable cannot be classi\u00ad.ed as either one of the three types of program \nvariables or as a service variable, a compile-time error will occur. The compiler and runtime system \nwill enforce the access restrictions for the program variables. public interface LightSensor { public \nfloat read(); ... } public interface SpaceDefs { public static final Space CampusB=new Rectangle(...); \n... } public class AverageLighting { public void static main(String[] args) { sumreduction float s=0; \nsumreduction int n=0; spatialview sv=LightSensor @ SpaceDefs.CampusB % 320; visiteach x : sv { s += x.read(); \nn++; } if (n>0) System.out.println(Float.toString(s/n)); } } Figure 3. An average sensor reading program. \n 2.4 Example Program Figure 3 shows an example program that collects readings from light sensors and \ncalculates the average. The program contains a single spatial view that speci.es a virtual network of \nlight sensors on a university campus, with a desired density of one sensor every 320\u00d7320 square meters. \nThe iterator declares a service variable x. When the program visits a node, x will be bound to an object \nthat implements the LightSensor interface on the visited node. The service object lives in the node space, \nallowing accesses to the light sensor installed on the node. In this example, the space de.nition is \nassumed to be provided by the space de.nition class SpaceDefs. This class may be written by the user \nor may be imported from a library of space de.nitions. Since the iterator does not contain any clauses, \nthe program will try to .nd and migrate to as many virtual nodes as it can while observing the space \nconstraint, and then return to the program injecting node, i.e., the machine that started the execution \nof the entire program. The body of the iteration, namely {s += x.read(); n++;}, is executed on each visited \nvirtual node. Both s and n are reduction variables. They are allocated in the program space and migrate \nwith the program. Since the values of the reduction variables cannot be read in the iterator, the compiler \nhas the option of generating code that exploits the parallelism in this program, for instance, using \nof geographic .ooding as discussed in Section 3.1.2. Once the iterator terminates, the values of s and \nn will have been appropriately updated. The average light sensor reading is calculated from s and n, \nand printed on the injecting node.  3. Implementation The current implementation includes the SpatialViews \ncompiler, virtual machine, runtime library, and debugging/visualization en\u00advironment. The runtime library \nimplements different iteration ap\u00adproaches that are selected through compiler options. Based on the selected \niteration approach, the compiler generates code that ex\u00adtends classes in the appropriate library. The \ncurrent prototype com\u00adpiler performs type checking for access restrictions on program and service variables, \nbut does not support any interprocedural analysis yet. The virtual machine provides support for program \nmigration. Figures 4 and 5 show the compiler and runtime system, respec\u00adtively. The debugging and visualization \nenvironment is a program that emulates ad-hoc networks of mobile nodes, on which a pro\u00adgrammer can run \nand debug compiled SpatialViews programs be\u00adfore deploying them to real networks. 3.1 Compiler The prototype \nSpatialViews compiler extends javac in Java De\u00advelopment Kit (JDK) 1.3.1 from SUN Microsystems, Inc. \nA .ow graph is given in Figure 4 for the compiler. The parser was changed to accept new statements such \nas spatialview and visiteach, and the corresponding new intermediate representations (IR) were added. \nProgram analysis or transformation at the IR level are im\u00adplemented as translators (a.k.a. passes). The \nSpatialViews compiler added two main translators to the SUN Java compiler. One translator veri.es that \nvariables are ac\u00adcessed as declared in an enclosed iterator, i.e., non-local variables are never written, \nreduction or container variables are never read, and service variables are never written or read. If \nthis check fails, a compile-time error will be reported. The other translator performs optimizations \nsuch as parallelization of spatial view iterators based on the user selected iteration strategy. For \nall updates on reduction variables and container variables, the translator generates code that does local \ncomputation and code that merges partial results. In ad\u00addition, this translator generates code to implement \ntransparent pro\u00adgram migration on top of the SmartMessages[22] virtual machine. 3.1.1 Migration SpatialViews \nsupports transparent program migration. The current implementation does not allow recursive calls from \nwithin an itera\u00adtor. Migration is implemented at two levels. At the lower level, the SmartMessages[22] \nvirtual machine supports explicit migration. At the upper level, the compiler generates code to make \nmigration ap\u00adpear transparent. The SmartMessages system is an extension to the Java 2 Plat\u00adform, Micro \nEdition (J2ME)[41]. The Kilobyte Virtual Machine (KVM)[42] and the Connected, Limited Device Con.guration \n(CLDC) class library were modi.ed to implement light-weight migration. J2ME has been widely used in today \ns cell phones. The memory budget is in the range of 160KB to 512KB. The migration provided by SmartMessages \nis explicit, opposite to transparent full-process migration. Only a very limited amount of information \nabout the program execution state, including the in\u00adstruction pointer, stack pointer, etc., is automatically \ntransferred to the new node. No program data are automatically transferred. Instead, a collection of \ndata are explicitly allocated (called a data brick) for the program to carry in a migration. If the value \nof some variable is needed after migration, the program should copy it into the data brick. It is the \nSmartMessages program s responsibility to restore the variable with the value from the data brick after \na migra\u00adtion. At the upper level, the SpatialViews compiler transparently decides what data items have \nto be migrated, packs and unpacks the resulting data bricks, and thereby hides all the above discussed \nde\u00adtails. As a result, at the SpatialViews language level, a programmer does not explicitly deal with \nprogram migration, and no migration primitive is provided. 3.1.2 Iteration Spatial view iteration is \nend-to-end migration among the injecting node and virtual nodes that provide the service in the space. \nDiffer\u00adent iteration approaches can be chosen with a command line option for the SpatialViews compiler. \nEach approach represents a differ\u00adent tradeoff among performance, resource usage, and QoR. The set of \ncurrently supported approaches is discussed below. Simple Iteration approaches do not make use of location \ninfor\u00admation in the process of searching for new nodes and the routes to them. Location information is \nonly used to decide whether a found node is part of the spatial view or not. A straightforward imple\u00admentation \nof spatial view iteration is a serial implementation as discussed in [35, 36]. In a serial iteration, \na single program mi\u00adgrates from one node to another. To improve its failure resilience or Figure 4. \nThe SpatialViews compiler. SpatialViews/SmartMessages Library SmartMessages Virtual Machine Operating \nSystem Figure 5. The SpatialViews runtime environment. performance, a program may be replicated. The \nreplica may work independently, each of which performs a serial iteration, or they may cooperate with \neach other. Experiments showed that coopera\u00adtive approaches are more failure resilient and more energy \nef.cient. In a cooperative approach, a program clones itself on a new node. The clones are propagated \nto nodes immediately (one hop) reach\u00adable from the current node. The clones then clone themselves and \npropagate to more nodes, and so on. The clones mark nodes so that they do not visit a node that has been \nvisited by another clone. When a limit in the node discovery strategy is reached or the time constraint \nexceeded, the clones migrate back. The partial results of reduction variables and container variables \nare merged on inter\u00admediate nodes while clones are converging back. After the partial results are merged, \nthe clones that produced the partial results ter\u00adminate. In the end, the original program continues on \nthe node that initiated the iteration and all clones terminated. The program has the .nal results of \nall reduction and container variables. This ap\u00adproach is called .ooding.A tree-based approach is similar \nto .ood\u00ading, but remembers the spanning tree of visited nodes for the spatial view. Subsequent iteration \nover the same spatial view will reuse the spanning tree. The tree-based approach can be more ef.cient \nthan a .ooding approach. However, the tree-based approach does not allow the discovery of new nodes and/or \nroutes. A more detailed discussion of these approaches can be found elsewhere [36]. Geographic Iteration \napproaches use location information. Two geographic iteration approaches are proposed in this paper. \nBoth approaches use a quadtree[40] to represent the target space. A quadtree is a recursive division \nof a minimal square cover of the target space. For 3D spaces, octrees can be used. However, a dis\u00adcussion \nof octrees is beyong the scope of this paper. To construct a quadtree for a space, a minimal square cover \nhas to be found. This square is divided into four smaller squares. The four smaller squares are divided \ninto even smaller squares, and so on. This divi\u00adsion process continues until the size of the smallest \nsquares is less than .s as de.ned in the spatial view. The smallest squares in this division are called \ncells. The cells that are not located the original target space can be ignored. The largest square is \nrepresented by the root of the quadtree. It has four children, which are four smaller squares that the \nroot is divided into. They are at the .rst level of the quadtree. The smallest squares (cells) are the \nleaves of the quadtree. Given the quadtree, a geographic iteration should visit one node in each cell, \nif there exists such a node. This way, the density of the virtual nodes is O(.s -2), and they are evenly \ndistributed over the target space. In the Geographic Serial Iteration approach, an iteration is modeled \nas a multi-stage dynamic planning problem and solved using a greedy strategy. The program remembers all \nvisited cells. After visiting every node, the program migrates to a neighbor, if and only if that neighbor \nminimizes the program s distance to unvisited cells. That distance is de.ned as the shortest among the \ndistances from the program s running node to all unvisited cells. As a special case, if a physical node \nis located in an unvisited cell, this distance is zero. After the program has visited all the cells in \na quadtree, it migrates back to the injecting node, using geographic routing. Backtracking maybe necessary \nin sparse networks. If a cell does not contain any virtual node, the algorithm will only detect this \nfact after exhausting all possible alternative routes to reach a node in the cell. This results in a \nsigni.cant overhead and may make this approach less ef.cient than simple serial iteration. Geographic \nFlooding, the second approach, is similar to sim\u00adple .ooding. The difference is that the program is propagated \nover spatial topology instead of network topology. Speci.cally, the pro\u00adgram .rst migrates into the root \nof the quadtree, i.e., any node in the minimal square cover of the target space. Subsequently, the pro\u00adgram \nforks into four clones, each of which migrates to the next level of the quadtree, i.e., the sub-squares \nof the current square. This pro\u00adcess repeats recursively until the program clones propagate into all \nthe cells. If the .rst physical node visited by the program in a cell does not provide the service, a \nsimple serial iteration con.ned to that cell has to be performed to .nd another physical node that does. \nAnd this extra serial iteration will stop on the .rst of such nodes. Finally, all the clones migrate \nup the quadtree back to the starting node. Partial results are merged on the way back. In this approach, \ngeographic routing is used to migrate from one node to a speci.ed square region.  3.2 Programming Environment \nOur SpatialViews development environment also contains a de\u00adbugging/simulation/visualization component \ndesigned to facilitate testing SpatialViews code on an emulated mobile ad-hoc network. Mobility is emulated \nby feeding dynamically generated location and topology information to a collection of KVM processes run\u00adning \non the same PC. The debugger can be used to inject code into the network, observe its behavior, and interact \nwith the sys\u00adtem through a graphical user interface. The same compiler gener\u00adated code can be executed \non a real target system, for instance a collection of HP iPAQs, or on an emulated network using the de\u00adbugging/simulation/visualization \nenvironment. Currently, the debugger can display a schematic view of the network topology and tracking \nthe movement of individual nodes, inject SpatialViews code into the network through a user-selected node, \nand display program output and migration information. Planned features include the ability to recreate \nreal-life network con.gurations based on location data gathered experimentally, more extensive control \nover the parameters of the synthetically\u00adgenerated network con.gurations, and a more structured presen\u00adtation \nof debugging information gathered from KVM processes. Figure 6. Debugger/Visualization Prototype for \nSpatialViews A general replay mechanism will allow the understanding and debugging of a particular program \nexecution. Such a replay mech\u00adanism is important since the particular program/system behavior may not \nbe reproducable. A preliminary version of the debugger which allows remote real-time interaction with \nseveral example SpatialViews programs running on an emulated network hosted on our servers is available \nas a Java applet. Figure 6 shows a screen snapshot of the current implementation. Each gray dot represents \na node in the emulated network. Each node has an associated display area which shows the node s spatial \nposition (top) and the last few lines of that node s output. The user interface panel on the right allows \nthe user to (1) control several parameters of the network, (2) select a program from a list of compiled \nSpatialViews programs available on the system and inject it into the network, and (3) overlay information \nabout signal ranges and code migration paths onto the main display window.  4. Experimental Results \nWe will illustrate the expressiveness of the SpatialViews program\u00adming model and the performance of the \ncompiler generated code based on four example applications. Each application exercises dif\u00adferent features \nof the language. 4.1 QoR vs. Resource Usage Tradeoffs Most SpatialViews target applications are location \nsensitive, i.e., location information is required by the applications. In some cases, it may be unnecessary \nor wasteful to visit every node in a dense network if an acceptable program answer can be computed by \nonly visiting a representative subset of the network nodes. For exam\u00adple, this representative subset \nare nodes that are evenly distributed across the target space. As a rule of thumb, the fewer nodes are \nvisited, the faster the program will return and the lesser network and node resources are used. This \ncomes at the price of a potential reduction in the quality of the produced answer. The space granularity \nin a spatial view de.nition allows the user to express a QoR vs. resource usage vs. performance tradeoff. \nWe evaluated both geographic approaches with simulations and experiments. The reported results used the \nlight sensor program as shown in Figure 3. The experimental platform was a network of 12 H3700 or H3800 \niPAQs each running the SmartMessages virtual machine under Familiar Linux. The simulation environment \nwas a PC running 64 KVMs under RedHat 9 Linux. The KVMs in the simulation environment were the same as \nthose running on the iPAQs except that they were built for the x86 ISA. The compiler generated the same \nbytecode for both simulations and experiments. The simulated network topology is shown in Figure 7(a). \nThe target space was 1000m\u00d71000m. The nodes were randomly dis\u00adtributed over the space with a wireless \nnetwork signal range of 250m. Each pair of nodes that are within the signal range of each other are connected \nwith an edge in the .gure. Figure 7(b) shows the trace of the program migrating with the geographic serial \nap\u00adproach. Figure 7(c) shows the trace using geographic .ooding. Iso\u00adlated nodes without any edges were \nnot visited at all. Only 24 nodes were visited using either approach. If the simple serial or network \n.ooding approaches are used, all the 64 nodes will be visited. These simulation results imply that geographic \napproaches will improve response time and save energy consumption over simple iteration approaches. We \ndid physical measurements of energy consumption and re\u00adsponse time on 12 HP iPAQs using both geographic \nand simple iteration approaches. We connected the 12 iPAQs to a single DC power supply in parallel. An \noscilloscope was used to measure the current at the output of the power supply. The current readings \nwere collected by a data acquisition PC. Figure 9 shows a diagram of the testbed setup. We calculated \nthe power dissipation of all the iPAQs from the current readings and the input voltage of 5V. Since all \nbatteries were fully charged before the experiments and since the iPAQs DC/DC converters are highly ef.cient, \nthe observed power dissipation is very close to the actual power dissipation of the net\u00adwork. Energy \nconsumption was calculated by integrating the power over the execution time. In the reported results, \nenergy consump\u00adtion of idle state was deducted. In other words, only the extra dy\u00adnamic energy consumption \ncaused by the program execution is re\u00adported. Since all iPAQs were connected to a common power supply \nin the experiments, their physical distribution was limited by the length of their power cables. As a \nresult, all iPAQs were able to di\u00adrectly communicate through their wireless connection. Even when we \nshielded each individual iPAQ with metal foil, the radio sig\u00adnals were still able to travel along the \npower supply cable to all iPAQs. To get a more interesting network topology, we disabled the dynamic \nnetwork neighbor discovery in these experiments, and instead used static con.gured neighbor lists. Figure \n8(a) shows the used network topology. The target space was 625m\u00d7625m with a wireless network signal range \nof 250m. The node locations were simulated, i.e., statically con.gured. The program was injected from \na laptop computer which is not shown in the .gures. Fig\u00adure 8(b) shows the trace for geographic serial \niteration, and Fig\u00adure 8(c) the trace for geographic .ooding. Figure 10 reports energy consumption, response \ntime, and number of visited nodes for the four approaches. Compared to simple iteration, geographic itera\u00adtion \nsaved 50% or more energy and ran at least twice as fast in our experiments. These savings were achieved \nby visiting only a spatially representative subset of nodes that cover the entire target space. Depending \non the application, this may only slightly impact the quality of the produced result. Our example application \nhas this property. As pointed out in Section 3.1.2, the effectiveness of geo\u00adgraphic iteration also depends \non the network density and may not work well for sparse networks.  4.2 User-De.ned Services An every \nclause in a spatial view iterator allows a physical node to be visited again as a new virtual node every \n.t time interval. This feature can be used to specify and deploy a user-de.ned service which provides \nautomatically refreshed information within every .t time interval. Figure 11 shows such a SpatialViews \nprogram that installs and updates a location service. The program installs an Injecting Node Injecting \nNode 1000m 1000m 1000m 750m 750m 750m 500m 500m 500m 250m 250m 250m 0  0 0 250m 500m 750m \n1000m 0 250m 500m 750m 1000m 0 250m 500m 750m 1000m (a) Network topology(b) Trace of geographic serial \niteration(c) Trace of geographic .ooding Figure 7. Simulation on 64 nodes with the average sensor reading \nprogram (Figure 3). 625m 625m 625m  312.5m 312.5m 312.5m 0 0  0 0 312.5m 625m 0 312.5m 625m 0 \n312.5m 625m (a) Network topology(b) Trace of geographic serial iteration(c) Trace of geographic .ooding \nFigure 8. Experiments on 12 iPAQs with the average sensor reading program (Figure 3). Power Supply Current \n Oscilloscope  Samples 30 Energy (joules) iPAQ Execution Time (seconds) 26 Data Number of Visited \nNodes 25 Via Ethernet iPAQ 20 Data Acquisition ... Computer iPAQ 15 11.9 12 12 Figure 9. The energy \nmeasurement setup. 9.83 10 7.8 6.16 6.2 66 3.7 3.8 eager location service on every node within a hallway \nthat peri-5 odically queries a positioning system based on MIT Crickets [39]. The Cricket system may \ntake up to four seconds to acquire a loca-0 tion reading. If a program running on a node in the hallway \nneeds Serial Geographic Serial Flooding Geographic Flooding to know its location, an on-demand, i.e., \nlazy query of the Crickets Figure 10. The measurements for the average sensor reading pro\u00admay lead to \na signi.cant performance bottleneck, for instance dur\u00adgram running on 12 iPAQs. ing the execution of \na spatial view iterator [36]. The latency of the Crickets may be hidden from an application by using \nan eager loca\u00adtion service instead. The eager service can be written and deployed by the SpatialViews \nprogrammer, i.e., the user. public interface LocationService { public Location currentLocation(); } public \nclass EagerLocationService implements LocationService { Location l; public EagerLocationService(l) {this.l=l}; \npublic Location currentLocation() { returns l; } } public class DedicatedLocationService { public void \nstatic main(String[] args) { float dt = Float.valueOf(args[0]).floatValue(); spatialview sv = @ Hallway; \nvisiteach x : sv every dt forever { CricketLocationService ls= new CricketLocationService(); Location \nloc=ls.currentLocation(); register(dt) EagerLocationService(loc); } } } Figure 11. A user-de.ned service \nexample. 65 4 3 2 1 0 Service time granularity .t (seconds) User program execution time (seconds) Figure \n12. Overall execution times of the average sensor reading program (Figure 3) on 6 iPAQs using the user-de.ned \neager loca\u00adtion service (Figure 11) with different time granularities .t (= dt in Figure 11). We conducted \nexperiments with this eager, self-updating loca\u00adtion service. We ran the service on 6 iPAQs. As an application \npro\u00adgram, we ran the light sensor program shown in Figure 3 using .ooding and a fully-connected network \ntopology. We measured the overall execution times of the light sensor application using the ea\u00adger location \nservice with .t values ranging from 4 seconds to 1 minute. The results are reported in Figure 12. When \nthe application used the Cricket service directly, i.e., in a lazy fashion, the execu\u00adtion time was 8 \nseconds. In contrast, the execution times using the eager service were signi.cantly lower, ranging from \n0.6 to 5.8 sec\u00adonds. The eager service will compete with the application for CPU time. The more frequently \na service runs, the less responsive the overall system will be and the more resources will be used. From \na programmer s perspective, the choice of .t represents a trade\u00adoff between QoR ( freshness in this case), \nsystem responsiveness, and resource usage. public class ShootAndDetect { public static void main(String[] \nargs) { Container result = new Container(); spatialview CameraView = Camera @ BuildingC.Floor3; visiteach \nc : CameraView { Picture p = c.getPicture(); spatialview DetectorView = FaceDetector; visiteach d : \nDetectorView { result.addElement(d.detect(p)); } } int i=0; for (Enumeration e=result.elements(); e.hasMoreElements();) \n{ Picture p=(Picture)e.nextElement(); p.savePNMFile(\"PIC\"+(i++)+\".pnm\"); } } } Figure 13. A camera and \nface detection example.  4.3 Cooperating Nested Virtual Networks Multiple spatial views cooperating \nwith each other is a very use\u00adful feature of SpatialViews. This feature is usually expressed via nested \niterators. Based on conditions encountered during program execution, additional service discovery is \ninitiated. Figure 13 shows a SpatialViews program that .nds nodes with cameras within a building, instructs \nthe cameras to take pictures, and then initiates face detection on server nodes that provide face detection. \nWe ran the program on the 12 iPAQs shown in Figure 8(a) and a laptop computer. Only one iPAQ had a camera \nsleeve and therefore provided the Camera service. In the .rst experiment, the face detection service \nwas available on a single iPAQ. If a face was found in the picture, the response time of the program \nwas 75 seconds. If no face was detected, the response time was 159 seconds. The face detection code uses \nan image pyramid that is exhaustively searched. Once a face is found, the face detector terminates. This \nexplains why the detector takes longer if no face can be found. In the second experiment, we ran the \nsingle face detection service on the 800MHz laptop. Depending on whether a face was found or not, the \noverall response time was 70 and 72 seconds, respectively. This example shows that it may be useful to \nallow a spatial view iterator to return after a .nite number of virtual nodes have been visited. For \ninstance, if the face detection service is replicated in the network, the nested iterator will try to \n.nd each face detector and apply it to the picture p. Clearly, this is redundant work unless the detectors \nare of different qualities. We plan to extend the language to allow users to specify an upper bound on \nthe number of visited nodes by a spatial view iterator. In the case of the discussed example, the upper \nbound of 1, which means visiting at most one detector, is a reasonable choice. 4.4 Augmented-Reality \nGaming Multi-player on-line gaming on the Internet has become increas\u00adingly popular and has developed \ninto a pro.table business, as well as new area of academic research. In fact, prototype systems have \nalready been developed that support multi-player games on wire\u00adless ad-hoc networks with handheld devices. \nFigure 14 and Fig\u00adure 15 show an augmented-reality (AR) Pacman game for ad-hoc networks of mobile devices. \nThis game is a new version of the pop\u00adular 1980 s pacman game. Each player has a GPS enabled PDA, which \npresents an interface as in Figure 14, with virtual obstacles, pellets (food for pacman to eat), ghosts \n(played by opponent play\u00aders), and pacman (the player). The player eat pellets by moving across their \nlocations. The goal for the pacman is to win by eat\u00ading all the pellets without being caught. He/she \nwill lose if caught by a ghost. The Human Pacman project[11] developed a prototype system to play this \ngame in a wide outdoor area. The core of this game can easily be written in SpatialViews. Figure 15 \nshows a SpatialViews implementation. Each player runs this program on his/her PDA. The outer iterator \npropagates the program to all player nodes (PDAs). Every 4 seconds, the program initiates the collection \nof the current locations of all players, and updates the display. The inner iterator does the location \ncollection. If the collection takes longer than 4 seconds (the time constraint), the results can be discarded. \nThe show method in the Pacman interface renders a graphical interface on the PDA, showing the playground, \nobstacles, pellets, and all players locations. Obstacles and pellets are supposed to be generated and \nmaintained by the show method. We did some .rst experiments for this location collection code with the \nhelp of 5 student participants. Each student carried an iPAQ handheld PC and a Garmin geko 201 GPS. The \nGPS device was connected to each iPAQ s serial port. The iPAQs communi\u00adcated through 802.11b in ad-hoc \nmode. The students were playing the game in two parking lots of about 100m\u00d7100m each.The exper\u00adiments \nshowed that an update rate of 4 seconds was feasible for our program and hardware. The GPS receivers \nprovided an accuracy of 2.5 meters to 5.5 meters.  5. Discussion In this section, we discuss miscellaneous \nissues in the design, implementation, and evaluation of SpatialViews. 5.1 New Language vs. Library Effective \nprogramming for ad-hoc networks requires abstractions that do not exist in traditional models. These \nabstractions are needed to represent dynamic grouping, space, location and time resolution, discovery, \nrouting, and in-network reduction. A li\u00adbrary may provide a rapid implementation for a new programming \nmodel, because it does not require new tool chains or learning new language constructs. However, a new \nlanguage is able to provide better support for the new programming model in terms of effec\u00adtiveness of \ncompiler-time analyses and opportunities for compiler optimizations. As a result, we expect compiler \ngenerated code to be more ef.cient than the corresponding program version based on a library (API) implementation \nof the programming model. New language abstracts are expressed explicitly, making the code more readable \nand maintainable. Finally, SpatialViews was also designed to serve as a vehicle to investigate different \nlanguage fea\u00adtures and compiler optimizations. public interface Pacman { // Render a graphical interface \nincluding // pacman, ghosts, peletts, and obstacles. public void show(Container c); // Get the role of \nthe player: pacman or ghost. public Role getRole(); } public class PacmanGame { public static void main(String[] \nargs) { spatialview sv = Pacman @ SpaceDefs.PlayGround; visiteach x : sv every 4 forever { Container \nc = new Container(); visiteach y : sv within 4 { Location l = System.currentLocation(); c.add(new Player(y.getRole(),l); \n} x.show(c); } } } class Player { Location l; Role r; public Player(Role r, Location l) { this.r=r; \nthis.l=l; } } Figure 15. An AR Pacman game program. 5.2 Units of Measurements Units of measurements \nare currently not explicitly speci.ed in SpatialViews. The current language assumes that length is always \nspeci.ed in meters and time always in seconds. This is a de.ciency of the language that will be addressed \nin a future language release. The lack of units may initially lead to some confusion, but allowed the \nrapid development of our prototype with focus on the major design issues such as location-aware service \ndiscovery and quality of results. Explicit speci.cation of units with enhanced language features, such \nas proposed in [2], will be investigated as part of a future language release. 5.3 High-Level Iteration \nTransformations An interesting analogy can be made between .s or .t speci.\u00adcation and traditional index-set \nsplitting[3]. The target space in a spatial view de.nition can be thought of as the iteration space of \na traditional loop. The geographic evenly distributed iteration has a similar .avor as traditional index-set \nsplitting. Based on this obser\u00advation, other traditional loop transformations may be applicable in the \ncontext of spatial view iterations. An example is loop .atten\u00ading. Using a straightforward implementation, \nthe code in Figure 16 requires one .ooding of the network to .nd lighting sensors, fol\u00adlowed by additional \n.ooding to .nd cameras. If loop .attening is performed, only one .ooding is necessary, which will collect \nboth sensor readings and camera images, and select the correct results in the end. Preliminary experiments \nwith one laptop computer and three HP iPAQs showed that the transformed version using loop .attening \nmay run up to .ve times faster than the original version. Other loop based compiler optimizations such \nas loop interchange and loop fusion are currently under investigation. 5.4 Security and Privacy Security \nand privacy are important issues in ad-hoc networks, where mostly unidenti.ed nodes join and leave transparently. \nThese issues become more important in a network running mobile code such as SpatialViews programs. Security \nand privacy are impor\u00adtant for the migrating program as well as the participating nodes in Container \nc = new Container(); spatialview SensorView = LightingSensor @ CampusB; visiteach s : SensorView { if \n(s.read()>0.5) { Location loc = System.currentLocation(); spatialview CameraView = Camera @ new Circle(loc,5); \nvisiteach cam : CameraView c.addElement(cam.getPicture()); } } Figure 16. An example program for loop \n.attening. the network: A migrating program carrying user data needs to be protected from a malicious \nnode, and a node needs to be protected from malicious migrating code. These issues are challenging not \nonly for the language design, but also for the design of the whole system involving almost all other \nlayers, including runtime library, virtual machines, operating systems, and hardware. Our current working \nassumption is that SpatialViews applications are going to be used in either a network of trusted members \nor on top of a trustworthy virtual machine or operating system that provides the protection needed. Providing \nsecurity in a SmartMessages virtual machine is currently under investigation[48].  6. Related Work Programming \nof ad-hoc networks has become a research focus in the past decade. Jini[43] is an architecture that supports \nser\u00advice discovery and spontaneous networking. SpatialViews shares with Jini the same approach of naming \nservices with Java inter\u00adfaces. However, in contrast to Jini and other service discovery architectures[1], \nSpatialViews does not assume the existence of network-wide lookup services or service directories. In \nrecent years, programmability of sensor networks has be\u00adcome a hot research area[5, 47, 44, 14, 17, 28, \n30, 7]. TinyOS[17] and nesC[14] provide a component-based event-driven program\u00adming environment for Berkeley \nMotes. nesC is an extension to C that supports and re.ects TinyOS s design. TinyOS and nesC use Active \nMessages, which is similar to program migration in SpatialViews, but uses non-migrating handlers instead \nof migrat\u00ading code. Mat\u00b4 e[28] is a tiny virtual machine built over TinyOS for sensor networks. It allows \ncapsules in bytecode to forward themselves through a network with a single instruction, which en\u00adables \non-line software upgrading for large-scale sensor networks. Impala[30] also provides an event-based programming \nmodel, and emphasizes issues such as on-line software updates and adaptabil\u00adity. SensorWare[7] provides \nlightweight mobile scripts for sensor networks and is very similar to SmartMessages. Hood[47] and Ab\u00adstract \nRegions[44] provide similar abstractions as SpatialViews, i.e., grouping nodes based on their properties. \nBlum et al.[5] pro\u00adposed the concept of entity for an addressable group of sensors that monitor an event. \nTAG[31] considers a sensor network as a database, and provides a high-level SQL-like language to query \nit. Location is one property of the database about which queries can be made. Programming models for \nmassive networks of tiny embedded systems have also been studied. Such a network may contain mil\u00adlions \nof nodes, each of which is as small as a grain of sand. Nagpal presented a high-level language to program \na sheet of agents simi\u00adlar to epithelial cells to form a global-speci.ed shape just through local computation \nand communication[33]. Butera designed a pro\u00adgramming model for paintable computers, which are small \nenough to mix with paint[9]. The major abstraction is process fragments migrating among nodes as the \nbasic elements of a self-assembly process. Migratory execution as seen in SpatialViews and implemented \nby SmartMessages has been extensively studied in the literature, especially in the context of mobile \nagents[10, 46, 27, 16, 15, 45]. Unlike a typical mobile agent system which makes migration a programming \nprimitive, SpatialViews hides it in an iteration of virtual nodes named by properties. Ad-hoc networking \nhas been extensively studied[38, 21, 8]. It\u00aderation in SpatialViews were implemented based on the same \nba\u00adsic ideas of those ad-hoc network routing algorithms. In particu\u00adlar, it is not novel to use georgraphic \ninformation for addressing and routing. Navas and Imielinski proposed GeoCast for both ge\u00adographic unicast \nand geographic multicast over the Internet[34]. Ko and Vaidya improved GeoCast for mobile ad-hoc networks[25]. \nKarp et al. proposed perimeter forwarding to recover from local maximal in greedy routing using node \nlocations[23]. Li et al. pro\u00adposed GLS, a location database that uses of geographic hierarchy to serve \nlocation queries with a server close to the querier in geo\u00adgraphic routing[29]. And there have been also \nworks for geographic multicast after GeoCast. Huang et al. proposed mobicast to dissem\u00adinate packets \ninto a moving and changing delivery zone[18]. Com\u00adpared to those works, the geographic iteration in SpatialViews \nis different in that the expected node density can be speci.ed for the target region, allowing redundant \nnodes to be avoided. SpatialViews deals with time constraint. However, the time constraint in SpatialViews \nis signi.cantly different from previous systems with strict time constraints, e.g. the time constraints \nin the Time Warp OS[20]. In Time Warp OS, the messages generated by a parallel discrete event simulation \nsystem have to be received in a nondecreasing timestamp order. This restriction can never be vio\u00adlated \nin order to guarantee the correctness of the simulation. Time Warp OS uses a process rollback mechanism \nto implement the time constraints. In contrast, the time constraint in SpatialViews is a soft deadline \nwhich should be better described as a budget. It is the amount of time that a programmer is willing to \nspend to .nish a spatial view iteration. If the program spends more than the budget, further iteration \nwill be prevented, but no rollback is necessary if ever possible. The time constraint in SpatialViews \nis one way for the programmer to tune the trade-off between the iteration time and the quality of results. \n 7. Conclusions and Future Work Ad-hoc networks are an exciting new target platform with a wide open \napplication potential. SpatialViews is a simple yet expres\u00adsive high-level programming language for ad-hoc \nnetworks. The language tries to hide enough details about the underlying volatile target system while \ngiving a programmer suf.cient control over the ef.ciency and resource usage of the program as well as \nthe qual\u00adity of the computed result. A wide range of applications can be implemented in SpatialViews, \nindicating the expressiveness of the language. This paper discusses four applications together with pos\u00adsible \noptimizations. Simulation results and physical measurements showed the ef.ciency of the compiler generated \ncode. The language can also serve as a testbed to investigate different compiler and run\u00adtime optimizations, \nand allows insights into the characteristics and requirements of programs executing on a volative, dynamic, \nand heterogeneous network. Future challenges include compiler and runtime optimizations that take advantage \nof particular network characteristics such as network topology, degree of dynamic behavior, and node \nand com\u00admuncation failure rates. Investigating the mathematical founda\u00adtions of best-effort semantics \nis another important future chal\u00adlenge. It is not clear whether approaches used to specify non\u00addeterministic \nlanguages can be extended to incorporate a best-effort model. A prototype version of our SpatialViews \ncompiler, run\u00adtime system, and debugging/visualization environment is available at http://www.cs.rutgers.edu/spatialviews. \nAcknowledgment We would like to thank Marios Dikaiakos and the anonymous reviewers for their insightful \ncomments.  References [1] W. Adjie-Winoto, E. Schwartz, H. Balakrishnan, and J. Lilley. The design and \nimplementation of an intentional naming system. In SOSP, 1999. [2] Eric Allen, David Chase, Victor Luchangco, \nJan-Willem Maessen, and Guy L. Steele Jr. Object-oriented units of measurement. In OOPSLA, Vancouver, \nBritish Columbia, Canada, October 2004. [3] Randy Allen and Ken Kennedy. Optimizing compilers for modern \narchitectures. Morgan Kaufmann, 2001. [4] T.E. Anderson, D. E. Culler, and D. A. Patterson. A case for \nnetworks of workstations: NOW. IEEE Micro, 15(1):54 64, February 1995. [5] Brian Blum, Prashant Nagaraddi, \nAnthony Wood, Tarek Abdelzaher, Sang Son, and Jack Stankovic. An entity maintenance and connection service \nfor sensor networks. In MobiSys, 2003. [6] C. Borcea, C. Intanagonwiwat, P. Kang, U. Kremer, and L. Iftode. \nSpatial programming using Smart Messages: Design and implementa\u00adtion. In International Conference on \nDistributed Computing Systems (ICDCS 04), Tokyo, Japan, March 2004. [7] A. Boulis, C. Han, and Mani Srivastava. \nDesign and implementation of a framework for ef.cient and programmable sensor networks. In MobiSys, 2003. \n[8] Josh Broch, David A. Maltz, David B. Johnson, Yih-Chun Hu, and Jorjeta Jetcheva. A performance comparison \nof multi-hop wireless ad hoc network routing protocols. In MobiCom, 1998. [9] William J. Butera. Programming \na paintable computer. PhD thesis, MIT, February 2002. [10] Luca Cardelli. A language with distributed \nscope. In POPL, 1995. [11] Adrian David Cheok, Siew Wan Fong, Kok Hwee Goh, Xubo Yang, Wei Liu, and Farzam \nFarbiz. Human pacman:a mobile entertainment system with ubiquitous computing and tangible interaction \nover a wide outdoor area. In Fifth International Symposium on Human Computer Interaction with Mobile \nDevices and Services, 2003. [12] S. Dashtinezhad, T. Nadeem, B. Dorohonceanu, C. Borcea, P. Kang, and \nL. Iftode. Traf.cView: A driver assistant device for traf.c monitoring based on car-to-car communication. \nIn IEEE Semiannual Vehicular Technology, Milan, Italy, May 2004. [13] eDonkey. homepage. http://www.edonkey2000.com. \n[14] David Gay, Phil Levis, Robert von Behren, Matt Welsh, Eric Brewer, and David Culler. The nesC language: \nA holistic approach to networked embedded systems. In PLDI, 2003. [15] Robert S. Gray. Agent Tcl: A .exible \nand secure mobile-agent system. PhD thesis, Dartmouth College, June 1997. [16] Robert S. Gray, George \nCybenko, David Kotz, Ronald A. Peterson, and Daniela Rus. D Agents: Applications and performance of a \nmobile-agent system. Software: Practice and Experience, May 2002. [17] Jason Hill, Robert Szewczyk, Alec \nWoo, Seth Hollar, David Culler, and Kristofer Pister. System architecture directions for network sensors. \nIn ASPLOS, 2000. [18] Qingfeng Huang, Chenyang Lu, and Gruia-Catalin Roman. Spa\u00adtiotemporal multicast \nin sensor networks. In SenSys, 2003. [19] The IETF Mobile Ad-hoc Networks (manet) Working Group. homepage. \nhttp://www.ietf.org/html.charters/manet-charter.html. [20] D. Jefferson, B. Beckman, F. Wieland, L. Blume, \nM. DiLoreto, P. Hontalas, P. Laroche, K. Sturdevant, J. Tupman, V. Warren, J. Wedel, H. Younger, and \nS. Bellenot. Distributed simulation and time warp operating systems. In SOSP, 1987. [21] David B Johnson \nand David A Maltz. Dynamic source routing in ad hoc wireless networks. In Imielinski and Korth, editors, \nMobile Computing, volume 353. Kluwer Academic Publishers, 1996. [22] P. Kang, C. Borcea, G. Xu, A. Saxena, \nU. Kremer, and L. Iftode. Smart messages: A distributed computing platform for networks of embedded systems. \nThe Computer Journal, Special Issue on Mobile and Pervasive Computing, 47(4), January 2004. [23] Brad \nKarp and H.T. Kung. GPSR: Greedy perimeter stateless routing for wireless networks. In MobiCom, 2000. \n[24] Kazaa. homepage. http://www.kazaa.com. [25] Young-Bae Ko and Nitin H. Vaidya. Location-aided routing \n(lar) in mobile ad hoc networks. In MobiCom, 1998. [26] U. Kremer, Y. Ni, and A. Stere. Spatial Views \nlanguage speci.cation, version 1.0. Technical Report DCS-TR-563, Department of Computer Science, Rutgers \nUniversity, November 2004. [27] Danny B. Lange and Mitsuru Ishima. Programming and deploying Java mobile \nagents with Aglets. Addison-Wesley, 1998. [28] Philip Levis and David Culler. Mat\u00b4 e: A tiny virtual \nmachine for sensor networks. In ASPLOS, 2002. [29] Jinyang Li, John Jannotti, Douglas S. J. De Couto, \nDavid R. Karger, and Robert Morris. A scalable location service for geographic ad hoc routing. In MobiCom, \n2000. [30] Ting Liu and Margaret Martonosi. Impala: a middleware system for managing autononmic parallel \nsensor systems. In PPoPP, 2003. [31] S. Madden, M. J. Franklin, J. Hellerstein, and W. Hong. TAG:a Tiny \nAGregation service for ad-hoc sensor networks. In OSDI, 2002. [32] Mutella. homepage. http://mutella.sourceforge.net. \n[33] Radhika Nagpal. Programmable self-assembly using biologically\u00adinspired multiagent control. In AAMAS, \nBologna, Italy, July 2002. [34] J.C. Navas and T. Imielinski. geocast geographic addressing and routing. \nIn MobiCom, 1997. [35] Yang Ni, Ulrich Kremer, and Liviu Iftode. Spatial Views: Space\u00adaware programming \nfor networks of embedded systems. In The 16th International Workshop on Languages and Compilers for Parallel \nComputing (LCPC 2003), October 2003. [36] Yang Ni, Ulrich Kremer, and Liviu Iftode. A programming language \nfor ad-hoc networks of mobile devices. In The 7th Workshop on Languages, Compilers, and Run-time Support \nfor Scalable Systems (LCR 2004), Houston, TX, October 2004. [37] Pac-Manhattan. homepage. http://pacmanhattan.com. \n[38] Charles. E. Perkins. Ad hoc networking. Addison-Wesley, 2001. [39] Nissanka B. Priyantha, Allen \nK. L. Miu, Hari Balakrishnan, and Seth J. Teller. The cricket compass for context-aware mobile applications. \nIn MobiCom, 2001. [40] Hanan Samet. The Design and Analysis of Spatial Data Structures. Addison-Wesley, \nReading, MA, 1990. [41] Sun Microsystems, Inc. Java 2 Platform, Micro Edition (J2ME). http://java.sun.com/j2me. \n[42] Sun Microsystems, Inc. The K virtual machine. a white paper available at http://java.sun.com/products/cldc/wp/. \n[43] Jim Waldo. The Jini architecture for network-centric computing. ACM Communications, July 1999. [44] \nMatt Welsh and Geoff Mainland. Programming sensor networks using abstract regions. In NSDI 2004, March \n2004. [45] D. Wetheral. Lessons from a Capsule-based system. In SOSP, 1999. [46] James E. White. Telescript \ntechnology: mobile agents, 1996. General Magic, Inc. White Paper. [47] Kamin Whitehouse, Cory Sharp, \nEric Brewer, and David Culler. Hood: A neighborhood abstraction for sensor networks. In Mobisys 2004, \nJune 2004. [48] Gang Xu, Cristian Borcea, and Liviu Iftode. Toward a security architecture for smart \nmessages: Challenges, solutions, and open issues. In Proceedings of the First International Workshop \non Mobile Distributed Computing, May 2003. [49] P. Zhou, T. Nadeem, P. Kang, C. Borcea, and L. Iftode. \nEZCab: A cab booking application using short-range wireless communication. In Proceedings of the 3rd \nIEEE International Conference on Pervasive Computing and Communications (PerCom), March 2005.  \n\t\t\t", "proc_id": "1065010", "abstract": "Ad-hoc networks of mobile devices such as smart phones and PDAs represent a new and exciting distributed system architecture. Building distributed applications on such an architecture poses new design challenges in programming models, languages, compilers, and runtime systems. This paper discusses SpatialViews, a high-level language designed for programming mobile devices connected through a wireless ad-hoc network. SpatialViews allows specification of virtual networks with nodes providing desired services and residing in interesting spaces. These nodes are discovered dynamically with user-specified time constraints and quality of result (QoR). The programming model supports \"best-effort\" semantics, i.e., different executions of the same program may result in \"correct\" answers of different quality. It is the responsibility of the compiler and runtime system to produce a high-quality answer for the particular network and resource conditions encountered during program execution. Four applications, which exercise different features of the SpatialViews language, are presented to demonstrate the expressiveness of the language and the efficiency of the compiler generated code. The applications are an application that collects and aggregates sensor data in network, an application that performs dynamic service installation, a mobile camera application that supports computation offloading for image understanding, and an augmented-reality (AR) Pacman game. The efficiency of the compiler generated code is verified through simulation and physical measurements. The reported results show that SpatialViews is an expressive and effective language for ad-hoc networks. In addition, compiler optimizations can significantly improve response times and energy consumption.", "authors": [{"name": "Yang Ni", "author_profile_id": "81325489808", "affiliation": "Rutgers University, Piscataway, NJ", "person_id": "PP26001359", "email_address": "", "orcid_id": ""}, {"name": "Ulrich Kremer", "author_profile_id": "81339510457", "affiliation": "Rutgers University, Piscataway, NJ", "person_id": "PP43125724", "email_address": "", "orcid_id": ""}, {"name": "Adrian Stere", "author_profile_id": "81100270464", "affiliation": "Rutgers University, Piscataway, NJ", "person_id": "P686316", "email_address": "", "orcid_id": ""}, {"name": "Liviu Iftode", "author_profile_id": "81100300273", "affiliation": "Rutgers University, Piscataway, NJ", "person_id": "PP39036675", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1065010.1065040", "year": "2005", "article_id": "1065040", "conference": "PLDI", "title": "Programming ad-hoc networks of mobile and resource-constrained devices", "url": "http://dl.acm.org/citation.cfm?id=1065040"}