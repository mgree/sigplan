{"article_publication_date": "06-12-2005", "fulltext": "\n Permission-BasedOwnership:EncapsulatingState inHigher-OrderTypedLanguages NeelKrishnaswamiandJonathanAldrich \nCarnegieMellonUniversity {neelk+, aldrich+}@cs.cmu.edu Abstract Today s module systemsdo not effectively \nsupportinforma\u00adtionhidinginthepresence ofsharedmutable objects, causing seriousproblemsinthedevelopment \nand evolution oflarge software systems. Ownership types have been proposed as a solutiontothisproblem,but \ncurrent systemshave ad-hoc access restrictions and arelimited toJava-likelanguages. In this paper, we \ndescribe System Fown, an extension of SystemF with referencesand ownership.Ourdesignshows both how ownership \n.ts into standard type theory and the encapsulationbene.tsit canprovideinlanguageswith.rst\u00adclassfunctions, \nabstractdatatypes, andparametricpolymor\u00adphism.Bylookingat ownershipinthesettingofSystemF, we were able \nto develop a design that is more principled and .exible than previous ownership type systems, while also \nprovidingstronger encapsulationguarantees. Categories and Subject Descriptors D.3[ProgrammingLan\u00adguages]:LanguageConstructs \nandFeatures GeneralTerms Languages,Theory,Veri.cation Keywords Ownership Types, Domains, System F, Type \nTheory, State,Modularity,LambdaCalculus,Permissions 1. Modularity and State Modularity is at the core \nof software engineering. A well\u00addesigned module system allows developers to break a pro\u00adgram intoparts,butmore \nimportantly serves tohide design decisionsmadewithineach ofthoseparts.Thisinformation hiding aspect of \nmodules is the key criterion that supports separate understanding, separate development, and ease of \nchangeinlarge software systems[25]. Unfortunately, today s module systemsdo not effectively support information \nhiding in the presence of shared mu\u00adtable state. The critical problem is aliasing: if a client gets an \nalias to a module s internal state, then information about how that state is represented and used within \nthe moduleis nolongerhidden.Thusthe client maybe affectedby changes Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish,topost on servers orto redistributetolists, \nrequiresprior speci.c permission and/or a fee. PLDI 05, June12 15,2005,Chicago,Illinois,USA. Copyright \n2005 ACM 1-59593-056-6/05/0006...$5.00. class Class { private Object signers[]; /* clients cannot call \na method * returning an owned list */ public Object [] getSigners() { return signers; } } Figure 1. \nIn an early version of the JDK, the Class.getSigners method returned the internal list of signers rather \nthan a copy, allowing untrusted clients to pose as trustedcode. inthe representation ofthe module,interferingwith \nseparate understanding, separatedevelopment, and software change. Furthermore,the clientmay violate representationinvariants \nofthemodule,causing softwaredefects orsecurityholes. 1.1 JavaEncapsulationDefect For example, Figure \n1 illustrates a security hole that was present in an early release of the Java development kit, version \n1.1. In this defect, the security system function Class.getSigners returns a pointer to an internal array \nholding the principals that have signed a class. Clients can thenmodifythecontents ofthearray,compromisingtheJava \nsecurity model andpotentially allowing malicious appletsto pose as trustedcode. The key issue that led \nto the defect was that Java s mod\u00adule system is too weak to effectively encapsulate the array withinthesurrounding \nclass object.Although thearray was stored in a private .eld, it was all too easy for the devel\u00adoper to \nmake a careless mistake that exposed the array to untrusted clients.Unfortunately,thisproblemis not unique \nto Java; other module systems may include more advanced mechanisms for hiding the visibility of members, \nbut none provides a guarantee that aliases to those members do not escape to untrusted clients. 1.2 \nOwnershipTypes Ownership types have been proposed as a practical mech\u00adanism for encapsulating internal, \nstateful objects within a surrounding owner object[22,10,8,2,9]. In an ownership type system, each type \nin the program is annotated with its owner object, and the type system ensures that only the ownercanaccessthe \nownedobject.Forexample,inFigure1 thesignersarray couldhavebeen marked owned,inwhich casethe compiler \nwouldhave .agged anerror whenthe code returns the array to clients. Ownership is a stronger prop\u00aderty \nthan the visibility controlprovided by module systems, because it protects the owned object, not the \nvariable that points toit. In contrast to conventional module systems, ownership types provide a static \nguarantee that clients cannot refer to owned objects. Initial experience with ownership types has also \nshown that recent systems are .exible enough to apply to existing code withfew changes[2]. 1.3 Contributions \nDespite the promise of ownership for encapsulating state in object-oriented systems, existing ownership \ntype systems have a number of signi.cant weaknesses, which we address in thispaper. Formal Models. The \nsemantics of ownership has only been exploredinthecontext of objectcalculi[11,8] and models ofJava[10,9,4,6,2,1] \nwhichlack adirect connection to mathematicallogic.Inthispaper, weintroduce SystemFown, anewformal modelthat \nnaturally extendsthetypetheoryof SystemF[18] with referencesand ownershiptypes. In our system ofpermission-based \nownership, an owner\u00adship domain represents a collection of references, functions, and existential packages. \nEach domain has a kind that ex\u00adpresses two forms of inter-domain access permission: the permission to \ncreate references, functions, and existential packages in another domain, and the permission to deref\u00aderence \nreferences, call functions, and unpack packages in another domain. Our type system statically enforces \nthese access permissions, ensuring the encapsulation of mutable state. Advanced Language Features. Thus \nfar, ownership types have only been integrated into Java-like languages that lack crucial advanced language \nfeatures, such as .rst-class func\u00adtions andML-style abstractdatatypes.Ourformalmodel ex\u00adplains how ownership \ncan bene.t advanced object-oriented languagessuchas Scala[23] thatincludethesefeatures. Expressiveness. \nExisting ownership systems rely on intu\u00aditivenotionsofencapsulationthat areusefulbut overly con\u00adservative.Inthispaper, \nwe showthatguiding thisintuition withtypetheoreticprinciplesyields a systemthatisfar more .exible, yet \ncan enforce the stronger encapsulation guaran\u00adtees thanprevious systems.For example: Our system can \nexpress challenging higher-order design patterns suchasiterators and event callbacksin a cleaner way \nthanprevious systems, while ensuring that the state accessed via the iterator or callback is protected \nfrom clients.  Oursystemusesabstractdatatypestoallowtheclients of a moduleto refertoprivate state while \nensuringthey can\u00adnot access it via pointer dereferences. Previous systems only support aweakerform ofADTsviainnerclasses. \n Our system s bounded existential quanti.cation allows clients to use a domain to which they have access, \neven if they cannot name thatdomain,providing considerable practical.exibilitycompared toprevious ownership \nsys\u00adtems.  Our system allows a module to pass its private state to library functions, while ensuring \nthat those library func\u00adtions do not retain a persistent reference to the private  Figure 2. A conceptual \nview of ownership domains. The rounded, dashed rectangles represent ownership domains. Solid rectangles \nrepresent existential packages or objects, parallelograms representfunctions, anddiamonds represent reference \ncells.Dashed arrows represent accesspermissions, which allow arrows representing accesses, and double \nar\u00adrows represent permission to create entities in another do\u00admain. state. Our system provides stronger \nencapsulation than previous work, in that it ensures that these library func\u00adtionsdo not report information \nabout theprivate state to clients throughglobal variables. 1.4 Outline The outlineoftherestofthispaperisasfollows.Inthenext \nsection,wedescribePermission-BasedOwnership,the own\u00adership model on which our design is built. Section \n3 intro\u00adduces the syntax of System Fown, a formal model that inte\u00adgrates ownership seamlessly with type \ntheory. We illustrate theexpressiveness ofSystemFown through a series of exam\u00adples. Section 4 gives the \nstatic and dynamic semantics for System Fown and states type soundness and encapsulation properties. \nSection 5 discusses related work, and Section 6 concludes. 2. Permission-BasedOwnership Thepurpose ofPermission-BasedOwnershipistogivesoft\u00adware \nengineers the ability to express and enforce high-level policiesforencapsulation.Thegoalof oursystemistoencap\u00adsulate \nstate;however, webelieve that effectively encapsulat\u00adingstatealsorequirestheencapsulation offunctionsandob\u00adjects1 \nthat usethat state.Theintuitionbehindthisgoalisthat the defect in Figure 1 would be the same if the array \nwere insteadrepresented asaListobject orapairofaccessorfunc\u00adtions.To .xthedefect,we would needto encapsulatetheList \njustas carefully as we would the corresponding array. Anencapsulationpolicyisaset ofrulesthatcontrolwhen \na function can access or create a conceptually encapsulated entity such asanotherfunction,areferencecell, \noranobject. In this de.nition access means calling a function, derefer\u00adencing or assigning to a reference, \nor selecting a member of 1Inthissectionwe usetheterm object informally.Inlatersections, objects are representedby \nexistentialpackagesin the standard way. an object. Creation means de.ning a new function, allo\u00adcating \na new reference cell, or creating a new object that is within an encapsulationboundary. A .ne-grainedpolicy \napproach mightattempttospecify access and creation permissions between every pair of en\u00adtities in the \nsystem. However, such a policy would be pro\u00adhibitively expensive to specify and enforce.Instead, wepro\u00advide \nmorehigh-levelpolicy speci.cationsthat relategroups offunctions,referencesand objects.Thesegroupsarecalled \nownershipdomains. 2.1 OwnershipDomains An ownership domain represents a group of conceptually\u00adrelatedfunctions, \nreference cells, and objects(or morefor\u00admally, existentialpackages).Ownershipdomains canbe cre\u00adated at \nany time during program execution, and unlike re\u00adgions in other systems, domains can outlive the scope \nin which they are declared. In our examples we will assume a domain world that contains standard library \nfunctions, but thereis nothing special about thisdomain. Figure 2 illustrates the Permission-Based Ownership \nmodel used in System Fown. In the .gure, domains are rep\u00adresented by dashed, rounded rectangles. Objects \nare shown as solid rectangles, functions are represented by parallelo\u00adgrams,and reference cells are represented \nasdiamonds. The somewhat anthropomorphic example in Figure 2 shows how ownership domains might be used \nto encapsu\u00adlate statein abankingapplication.Inthis application, a num\u00adber of customersinteractwith accessorfunctionsinthebank\u00adinginterface, \nwhichin turn read and modify thedata stored in thebank s vaults.Animportant security constraintis that \ncustomers may not access the bank s vaults directly, but in\u00adstead mustgo through theinterfacefunctions. \nWe model this system using three ownership domains. The world domain contains the customer objects. The \nbank domain includes the accessor functions for the bank, while the vault domain contains reference cells \nstoring the amount ofmoneyineach account. Solid arrowsshowthecallsmade from the customerobjects to thebank \nfunctions, as well as the accessesfromthebankfunctionstothedatainthe vaults. The customerobjectispart \nofthe world domain.It may call functions such as deposit and withdraw that are de\u00adclared in the bank \ndomain, which represents the interface to thebank.Thesefunctionsin turn access statein the vault do\u00admain. \n 2.2 PolicySpeci.cations We want to ensure that the customer objects cannot directly access thedatain \nthebank s vaults.Permission-BasedOwn\u00adership allowsengineerstospecify twokinds ofpermissions allowing \nonedomaintoaffect another: Access Permission. If one domain has access permission to another domain, \nthen functions in the .rst domain can dereference or assign to references, call functions, or select \namember ofan object(i.e.unpack anexistential) inthesec-onddomain.InFigure2, accesspermissionis representedby \na single dashed arrow. Thus, functions that are part of the customer objects in the world domain can \ncall functions in the bank domain, and these functions can in turn access the statein the vault domain. \nAccesspermissionisnot transitivein oursystem,ensuring that even though the world domain has access permission \nto the bank domain and the latter has access to the vault domain, the world domain does not have access \nto the vault domain. Thus, customer objects cannot access data in the vaultsdirectly. Creation Permission. \nIf a customer object could create a function in the bank domain, it could simplyhave that func\u00adtion access \nthe vaults on its behalf, bypassing the accessor functions provided by the bank. Therefore, we restrict \nthe abilitytocreatefunctions, referencecells, andobjectsin other domains usingcreationpermissions. In \nFigure 2, the bank domainhas creationpermissionfor the vault domain(shown with adouble arrow), allowing \nthe accessor functions to create reference cells for newly created bankaccounts. Permission Assignment. \nWhen a new domain is created, thecreating entity assignsall oftheaccessand creationper\u00admissions to and \nfrom that new domain. To ensure that do\u00admain creation cannot be used to circumvent access restric\u00adtions, \nour system ensures that the creating entity can only givethe newly createddomainthepermissionsthatititself \npossesses. For example, functions in the world domain can createnewdomainsthathaveeitheraccess orcreationper\u00admissioninthe \nworld domain(since eachdomainhaspermis\u00adsionto access and createinitself) and accesspermissionfor the \nbank domain. These new domains, however, cannot be given any access to the vault domain, nor canthey \nbegiven creationpermissionfor the bank domain. StaticChecking.SystemFown statically veri.esthat nointer\u00addomaincreations \noraccesses occurunlessthesourcedomain hastheappropriatepermissiontocreatein oraccessentities inthetargetdomain.Although \nourdynamicsemanticspre\u00adserve ownership informationin ordertoeasilyproveaper\u00admission soundness theorem, \nownership has no effect on the run-time semantics and canbe erasedduring compilation.  3. SystemFown \nIn this section, we present System Fown, an extension of SystemF[18] thatincorporates references andpermission\u00adbased \nownership. Although we work in a functional con\u00adtext, many of our examples are inspired by object-oriented \nsystems, where ownership types were .rst developed. For example, one of the well-known challenges for \nownership types is iterators in a collection library, and we will show how oursystemhandlesthisexample. \nBecause we are workinginthe constructs of standardtype theory, we do not explicitly model inheritance, \nbut it can be encoded using existentialsinthe usual way.Inthediscussion below, we will use the terms \nobject and existential package interchangeably. 3.1 Syntax Figure 3 shows the source syntax of the System \nFown lan\u00adguage. SystemFown is aformalcorelanguageinspiredbyGi\u00adrard andReynolds SystemF[18].We take SystemF, \ninclud\u00adingpolymorphicfunctions andexistentialtypes, and add ref\u00aderences anddomain annotations. Functions \nin the language are of the form .dx:t. t, where the annotation d represents the ownership domain to which \nthe function belongs. Reference expressions of the form ref dt are annotated with the domain in which \nthe reference is created. Modules are represented us\u00ading existential packages, with an expression of \nthe form Terms t ::= | | | | | | ()|.dx:t. t |x |t1 t2 ref d t |!t |t1 := t2 pack(.,t)as .dx:K. t unpack \n(a,x)= t1 in t2 .da:K. t |.a:K. t |t[.] letdomainz : domain(P)int letdomainz : domain(P)into t Types \nt ::= | | unit |t .d t' |ref d t .da:K. t |.da:K. t .a:domain(P). t |a Domain .,d ::= a,\u00df,. . . . ::= \nt |d Kinds K ::= domain(P)|type Permissions P ::= | | P,_ . d |P,d . _ |P,_ . _ P,_ . d |P,d . _ |P,_ \n. _ E Figure3. SystemFown Source Syntax pack (.,t)as .da:K. t . Again, they have a domain anno\u00adtation. \nSystem Fown supports explicitparametricpolymorphism with anexpression oftheform .da:K. t.Thesetypelambdas \nare as usual annotated with adomain,in whichtheirbodyis typechecked,and canquantify overbothtypesanddomains. \nFor each type binding, a kind is given. Our system has two families of kinds. The .rst is the kind of \ntypes, which we usefor conventionalparametricpolymorphism.We also have another family of kinds for domains, \nwith a domain kindforeachpossibleset ofaccesspermissions.Permissions include accesspermission(.)and creationpermission(.) \nto andfrom adomain(d . _ vs. _ . d). Using kinds to treat types and domains in a uni.ed way allows universal \nand existentialquanti.cationtobeused overboth. Normally,functions(and typefunctions) can onlybecre\u00adated \nin a domain to which the current entity has creation permission.This restriction,however,prevents usfrom \nwrit\u00adinglibraryfunctionsthatcanact onarbitrary clientdomains. Therefore, System Fown provides a special \nform of domain polymorphism .a:domain(P).t that can be invoked from (nearly)any domain, but whose body \nis typechecked in the argument domain a. We ensure that this form cannot be abused by restricting P to \ncontain only access and creation permission for thedomaina (i.e.,Pmay only contain _ . _ and _ . _). \nDomains are created using the letdomain constructs. An expression letdomain a : K into t or letdomain \na : K in t creates a new domain with the permissions speci\u00ad.ed in K, and binds it to the variable a. \nThe difference be\u00adtween the into and in forms is whether the body t is typechecked in the newly-created \ndomain, or in the current domain.In ordertoavoidprivilegeescalation,westatically check letdomain forms \nto ensure that the newly-created do\u00admains cannotbegiven anypermissionsthatits creatordoes nothave. FollowingMitchellandPlotkin,SystemFown \nusesexisten\u00adtialquanti.cation to modeltype abstraction[20].In addition val increment =.d : domain(_ . \n_). .d x : ref dint . x := (!x)+ 1; !x val COUNTER = letdomain pub : domain(world . _,_ . _,_ . _)into \n letdomain owned : domain(pub . _,pub . _,_ . _)in pack(pub, pack(ref ownedint, {init = ref pub 0, create \n= .pub x : unit . ref owned (!init), inc = .pub x : ref ownedint .increment ownedx} )as ... )as .world \npublic : domain(world . _,_ . _,_ . _). .world t : type . {init : ref publicint, create : unit .public \nt, inc : t .public int} Figure4. Acounter abstractdata typein SystemFown. tothefamiliarcase ofexistential \ntypes,SystemFown permits us to write expressions with existential domains. We make useofthisfeaturetoexportdomains \noutofthelexical scope of a letdomainexpression. Types t include arrow types, reference types, universal \ntypes, and existentials.Just asfunction, reference andpoly\u00admorphic and existential terms are annotated \nwith domains, so too are their types. Arrows, reference types, and univer\u00adsal and existential types are \nall annotated with the domain to which they belong. The sole exception to this is the spe\u00adcial universaltypecorrespondingtothespecialdomainpoly\u00admorphismterm; \naterm ofthistypemust runinanydomain, and so we don t need to specially annotate it with a home domain. \nLikeSystemF(and unlike coreML),SystemFown sup\u00adports impredicative polymorphism; that is, type variables \ncanrange overpolymorphictypes.Thismeanswecanmodel simple forms of ML-style functors and .rst class modules \nwithfunctions that return existentialpackages.The most so\u00adphisticated uses of functors, which rely on \nfull dependent sums,donot .tintothismodel. 3.2 Expressiveness We demonstrate the expressiveness of System \nFown through a series of examples. Some of our examples assume records, case statements, etc., which \ncan be encoded in the standard way. Counter. Figure 4 shows a COUNTER module de.ning a counterabstractdatatype.Thismoduleillustrateshow \nown\u00adership domains can be used to encapsulate internal state eveninthepresence ofabstracttypes,state-manipulatingli\u00adbraryfunctions,andreferencesthatareshared \nacrossmodule boundaries. The counter module de.nes a pub domain that will hold itspublicfunctionsandreference \ncells,and an owned domain thatwillholdthe reference cells usedtoimplementthe coun\u00adters. Thepermissions \nfor the pub domain,for example,give the world domain accesspermission topub (world . _), and give pub \ncreate and accesspermissiontoitself(_ . _ and _ . _).The modulede.nes an abstracttype tforthe counter, \nimplemented as a reference cellin the owned domain. rec val map : .d : domain(_ . _). .d a,b : type . \n(a .d b).d (alist .d blist) =.d : domain(_ . _). .d a : type . .d b : type . .d f : a .d b. .d l : alist \n. case l of nil => nil |x::xs => (fx) :: mapd abf xs Figure5. Apolymorphic mapfunctionin SystemFown. \nWhen a client wants to create a counter, they will .rst store the initial value of the counter into the \ninit reference cell, then call create toget a new counter.Theimplementa\u00adtion of create simply creates \na fresh reference initialized to the value storedin init. The counter can be incremented by calling the \ninc func\u00adtion. The implementation of inc calls the increment library function, whichispolymorphicin thedomain \ndof the refer\u00adence cellsitincrements. Discussion. Although simple, this example illustrates sev\u00aderal \nwaysinwhich ourdesignismore.exibleyetprovides more encapsulation than any previous ownership type sys\u00adtem.Onthe \n.exibility side,weareabletoimplementtheab\u00adstract type t in terms of a reference, allowing clients to \nrefer directlytothatreference,butensuringthattheycannotderef\u00aderencethat reference, sinceitstypeisheld \nabstract andin any case,itsdomainisinaccessible.Noprevious ownership type system supports abstract types \nof this form, although inner classescanprovidesome oftheexpressiveness[8,6]. Ontheencapsulationside,like \nother ownership typesys\u00adtems,oursystemprovidesaclearguaranteethat noclientcan access the hidden references \ndirectly. Simply observing that the counter references are annotatedwiththe owned domain, andthatthe \nworld domaindoes nothave accesstotheowned domain,issuf.cienttoguaranteethis.If theimplementor of theCOUNTERmodule \nmade a mistakethat would expose an internalreference for example,just using the initreference when creating \na counter instead of creating a new reference initialized to the same value the type system would notice \nthe inconsistent domain annotations and would .ag the er\u00adror. Our type system goes further than previous \nownership systems, however, in that it allows developers to pass ref\u00aderences to domain-polymorphic functions \nwithout the dan\u00adger that those functions might break the module s abstrac\u00adtion guarantee. The increment \nfunction is de.ned with the specialdomainpolymorphismform,sothatthebody ofthe functionistypecheckedasifit \nwere withinthe argumentdo\u00admain. This gives increment permission to dereference and assign to the referencespassedtoit. \nHowever, because the bodyof increment is typechecked asifitwereinadomainthathas onlypermissiontoaccess \norcreateinitself,thebodyofthefunctionlosesaccesstoany other domains that were previously in scope. For \nexample, the increment function would not be able to access state in theworld domain.This ensuresthatalthough \nincrementhas access to the internal state of the COUNTER module, it can\u00adnot expose that state to clients, \nor even report any informa\u00adtion about the state to clients throughglobal references. Ourtype system s \nsupportfor writing domainpolymor\u00adphicfunctions thatdo not violate abstractionis essentialnot only for \nusing library code safely, but also for many other commonprogramming idiomsincluding callbackfunctions \nandpluginmodules.Incomparison,allprevious ownership type systems eitherprohibitfullypolymorphicfunctionslike \nincrement, orelseallowsuchfunctionstobreaktheabstrac\u00adtion of COUNTERbystoringthereferenceinanobject[2], \nor reportinginformation aboutthe referencesto clientsthrough globalstate[8,6].  Comparison toConventionalSystems. \nIn this simple example, it is easy to see that the counter reference is never accessed outside functions \nin the COUNTER module anddomainpolymorphicfunctionslike increment. However, the JDK bug described earlier \nshows that checking encapsulation properties like these is non\u00adtrivialinlarger systems.Checkingthispropertyin \na conven\u00adtional module system would be considerably more dif.cult. For example, checking to make sure \nthat the COUNTER in\u00adterface contains no references is insuf.cient, because the in\u00adterfacedoeshave such \na reference one must also checkthat the references usedfor countersdon t aliastheinitreference. We cannot \nuse an effect system to ensure that clients don t access the reference because in fact we want to allow \nthem to do so as long as they access it through the interface of COUNTER.Evendoing an escape analysisisinsuf.cient,be\u00adcause \nthe counter reference actually escapes twice: to clients throughthe abstract type t, and to the incrementlibrary. \nIn other module systems, it would be necessary to manually verify that clients cannot use some function \nin COUNTER to convert a t into the underlying reference, and also to check that increment does not expose \nthe reference toclients.Thesechecksareautomaticallyguaranteedby our type system.As mentionedabove, since \nclients cannot access the owned domain inside COUNTER, there is no way they canpossibly read orwritetheunderlying \nreference. Map. Figure 5 shows a map function that ispolymorphic in the argument type, return type, and \ndomain of the function to be mapped. As with the increment function above, Sys\u00adtemFown stypesystemrestrictsthedirect \nside-effects of map to callingfunctions and accessing referencesindomain d (in this case, of course, \nmap calls the function f). This exam\u00adpledemonstrates that SystemFown can express animportant functionalprogrammingidiom,but \nalso shows how System Fown sdomainshelpinreasoning abouttheeffects ofafunc\u00adtion we can tell from the \ntype that map cannot have any side-effects except those that arise through calling its argu\u00admentfunction \nf. Note that unlike an effect system, we restrict only the di\u00adrect effects of map, not the transitive \nside-effects that could occur through the call to f. This feature makes our sys\u00adtem morelightweightinpractice \ncomparedto effect systems, which musttrack thetransitiveeffects ofeachfunction. Object-OrientedSequenceADT. \nAlthoughpresentedin the contextofSystemF, ourtypesystemcanalsoexpresstypical object-orientedidiomsthatpresent \nchallengesto manypre\u00advious ownership typesystems.Forexample,Figure6 shows a polymorphic sequence abstract \ndata type, SEQ. The ADT is implemented in a typical object-oriented style, with mu\u00adtator functions like \nadd and support for iterating over the sequence with an iterator object. The diagram shows the in\u00ad val \nITER =.iter : domain(_ . _). .iter owned : domain(iter . _,iter . _). .iter t : type . .iter head : tlist \n. let cur = ref owned head in {hasNext = .iter x : unit .isCons (!cur) next = .iter x : unit . letv = \nhd(!cur)in cur := tl(!cur); v } val SEQ =.world t : type . letdomain public : domain(world . _,_ . _,_ \n. _)into letdomain owned : domain(public . _,public . _)in let head = ref owned nil in pack(public, {add \n= .public x : t . head := cons x (!head), iter = .public x : unit . ITERpublic ownedt (!head)} )as .world \npublic : domain(world . _). {add : t .public unit, iter : unit .public {hasNext : unit .public bool, \nnext : unit .public t } } Figure 6. The SEQ module implements a polymorphic se\u00adquenceabstractdatatype.Iterators \noverthesequencearede\u00ad.nedbythe ITERmodule. tendeddesign ofthesystem, whichissimilartothebank ex\u00adamplegiven \nearlier:the client can accessthe sequence andits iterators, and the iterators can access the underlying \nlinked list,but the client should notbe able toget to the underlying listdirectly. The SEQ module is \nparametric in the type t of elements in the sequence.Like the COUNTERmodule above, the SEQ module de.nes \na public domain accessible from world, and a owned domain for the private state in the sequence. That \nstate is represented by a reference cell in the owned domain whichpointstothehead ofthelist. The module \nitself is implemented as a package that ex\u00adposes thepublic domain as well as two functions in that do\u00admain. \nThe add function mutates the sequence by adding an\u00adotherelementtothefront ofthesequence.The iter function \nreturnsaniterator overthesequence, usingthe ITERmodule de.nedabove. The iterator is implemented with \nthe special domain\u00adpolymorphism form, just like the increment function in the previous example, thus \nensuring that the iterator im\u00adplementation will not break the abstraction boundary of the sequence. The \nnested polymorphic function illustrates bounded domainpolymorphism: the owned domainpassed in must allow \nthe iter domain to create and access state in Values v ::= ()|l |.mx:t. t | pack (.,v)as .ma:K. t | .ma:K. \nt |.a:domain(). t Expr t ::= ts |v |t@m Store \u00b5 ::= E |\u00b5, l : v Store typ. S ::= E |S,l : t Environment \nG ::= E |G,x : t |G,a : K Contexts C ::= D|C t |v C | |C [.]|ref d C | pack(.,C)as .da:K. t | unpack \n(a,x)= C in t Figure7. SystemFown IntermediateForms andValues it. When the iterator is used, the iter \nand owned domains are instantiated with the public and owned domains of the sequence, respectively. The \niterator is also polymorphic in the element type be\u00ading iterated over. Finally, a function acting as \nthe iterator constructor accepts the list to iterate over as an argument. This list is stored as the \nreference cur, which is part of the owned domain.Theimplementation of hasNext and next is straightforward, \nassumingthe existence offunctions isCons, hd, and tl for accessing lists. The next function not only \nre\u00adturns the current element,but also advances the cur pointer to refer to the next cellin thelist. \n4. Formal Semantics Weformulatethesemantics ofSystemFown as a set of small\u00adstep reduction rules together \nwith syntax-directed typing rules. A number of auxiliary judgment forms are used to reason about type \nand domain equality, access permissions betweendomains,and sub-kinding.We .rstpresentthedy\u00adnamic semantics, \nthen the typing rules before considering type soundness. 4.1 DynamicSemantics Figure 7 shows the value \nand intermediate computation forms for System Fown, and Figure 8 shows the reduction rules. During execution,wekeep \ntrack ofthecurrentdomain d, representing thedomain thatis responsiblefor the currently executing code. \n'' The reduction relation is of the form d f \u00b5;t . \u00b5;t. Thisisread as Indomain d, the store \u00b5and the \nexpression t '' reducein onestep toanewstore \u00b5and new expression t. We represent reference values with \nlocations l, and index the store \u00b5 with locations. As the program reduces, new domains can be created \nby letdomain expressions, and we ensure they are distinct by using an alpha-conversion convention. Furthermore,wedistinguishbetweenlambdaexpressions \ninthe sourceprogram andlambda valuesbymarking values with an overbar, in order to create a distinction \nbetween the ability to create a function and the ability to invoke it. As discussedin section2,thetypingrulefor \na sourcelevelfunc\u00adtion requires that the current domain include a permission to create newfunctionsin \nthedomain d of thefunction.Once a function .dx:t. t reduces to .dx:t. t, we no longer make this check;instead, \nwe check(atfunction application) that the currentdomainhas apermission to access d. EFun d f \u00b5;..x:t.t \n\u00b5;..x:t. t EAppR d f \u00b5;(..x:t. t)v\u00b5;([v/x]t)@. . f \u00b5;t\u00b5 ' ;t ' EAtC d f \u00b5;t@.\u00b5 ' ;t ' @. EAtR d f \u00b5;v@.\u00b5;v \n\u00b5 ' = \u00b5,l : vl .. domain(\u00b5) ERefR d f \u00b5;ref .v \u00b5 ' ;l EDeefR d f \u00b5;!l\u00b5;\u00b5(l) \u00b5 ' =[\u00b5|l = v] EAssignR d \nf \u00b5;l := v\u00b5 ' ;() ETAppR d f \u00b5;(..a:K. t)[t] \u00b5;([t/a]t)@. EForall d f \u00b5;.za:K.t \u00b5;.za:K. t v ' =pack(s,v)as \n..a:K.t EPackR d f \u00b5;pack(s,v)as ..a:K.t \u00b5;v ' ' d f \u00b5;letdomain d v f = pack(s,v)as ..a:K. t \u00b5;unpack \n(a,x)= v ' int2 EUnpackR \u00b5;[v/x][s/a]t2 EDmIn z : K int\u00b5;t EDmInto d f \u00b5;letdomainz : K intot\u00b5;t@z d \nf \u00b5;t\u00b5 ' ;t ' EContext d f \u00b5;C[t] \u00b5 ' ;C[t ' ] Figure8. Dynamic Semantics Expressions are also extended \nwith locative expressions t@., which represents an expression evaluating in the con\u00adtext of a domain \n.. We use this locative in order to identify codeadomain otherthanthecurrentdomain forexample, when weperform \nafunction application (.mx:t. t) v using the EAppR rule, we substitutetheformalparameter with a value, \nand then mark the substituted expression [v/x]t with the domain m. The locative marker lets us distinguish \nthe body of the function from the context it evaluates in, which greatlysimpli.es the soundnessproof. \nInformally,locatives are relatedto stackinspection,inthat they change a principal for the lifetime of \na dynamic ccall. However, our locatives could be eliminated in a real im\u00adplementation(as an examination \nof the EAtR rule should demonstrate),becausehavenocomputationalimpact there is no wayfor aprogramtotestwhichdomainitisin.In \naddi\u00adtion to function applications, both forms of type application and the letdomain z : K into t expression \ncreate locatives (in rulesETApp1, ETApp2, and EDmInto, respectively). Finally, we have two letdomain \nconstructs, which we use to introduce new domains. The onlydifference between them is that the letdomain \nz : K into t evaluates its DCreator G,z : domain(P,_ . d,P ' )f z . d DCreated G,z : domain(P,d . _,P \n' )f d . z DCrRefl G,z : domain(P,_ . _,P ' )f z . z DAccessor G,z : domain(P,_ . d,P ' )f z . d DAccessed \nG,z : domain(P,d . _,P ' )f d . z DAcRefl G,z : domain(P,_ . _,P ' )f z . z Figure9. DomainDe.nition,Creation, \nandAccessRules subexpression t in the new domain z it just created, and letdomain z : K in t evaluates \nt in the current domain. It is worth noting that repeated evaluations of a letdomain ex\u00adpression(forexample,ifitispart \nofafunctionbody) will produce different domains. We enforce this by assuming an alpha-conversion convention \nsimilar to the one for variable bindings. The rules for reference creation, assignment, and deref\u00aderence \nare completely standard.Finally, the congruence rule EContext allows reduction toproceed within an evaluation \ncontext. 4.2 DomainAccessRules We begin with the most interesting component of the static semantics:the \nrules showing when adomainhaspermission tocreate oraccessreferenceswithinadomain. Wehavetwojudgments: \n.rst, G f d . ., determines whetherdomain dhaspermissiontocreate references or code in domain ., and \nsecond, G f d . ., determines whether domain d can access objectsindomain ..1 We can read either judgmentas \ngivenadomainheap D and a variable context G,domain d has the abilityto touchdomain. . The .rst rule, \nDCreator, establishes that a domain z can can create functions and references in another domain, and \nconversely, DCreated grants anotherdomainpermissionto create objects in z. The DCrSelf rules is used \nto determine whetheraparticulardomainisre.exive whetherit cancre\u00adate objectsinitself.There are aparallel \nsetof rulesfordomain access, with DAccessor granting z permission to access an\u00adotherdomain, DAccessedgrantinganotherdomainthe \nright to access z, and DAcReflgrantingz re.exive access. It s worth observing once again that the access \nrules are not transitive. However, if domain . has both create and access permission to domain d, then \nit can access anything d can access simply by creating a new function in d and then calling it. Thus, \ncreate permission effectively enables onedomaintoimpersonate another, and soit shouldbe used with care. \n 4.3 TypingRules Figures 10 and 11 show the typing rules for System Fown. Thetypingrelationis oftheform \n.;S;G f e : t, read, In the 1Recallthat to access . means to read or writepointersfrom ., or toinvokefunctions \nor to openpackagesinit. x : t . G Varref d;S;G f x : t .;S;G,x : t f t : t ' G f d . . Lambda d;S;Gf \n..x:t. t : t .. t ' .;S;G,x : t f t : t ' LambdaVal d;S;G f ..x:t.t : t .. t ' d;S;Gf t1 : t .. t ' d;S;Gf \nt2 : t G f d . . App d;S;Gf t1 t2 : t ' .;S;G f t1 : t G f d . . At d;S;Gf t1@. : t l : ref .t . S Label \nd;S;Gf l : ref .t d;S;Gf t : t G f d . . Ref d;S;Gf ref .t : ref .t d;S;G f t : ref .t G f d . . DeRef \nd;S;G f!t : t d;S;Gf t1 : ref .t d;S;Gf t2 : t G f d . . Assign d;S;Gf t1 := t2 : unit .;S;G,z : K f \nt : t G f d . . G f K : kind .1 d;S;Gf ..z:K. t : ..z:K.t .;S;G,z : K f t : t G f K : kind .1 d;S;Gf \n..z:K. t : ..z:K.t z;S;G,z : domain(P)f t : t fv(P)= \u00d8 .2 d;S;G f .z:domain(P).t : .z:domain(P).t z;S;G,z \n: domain(P)f t : t fv(P)= \u00d8 .2 d;S;G f .z:domain(P).t : .z:domain(P).t d;S;Gf t : ..a:K.t G f K ' = K \nd;S;Gf . : K ' G f d . . TApp1 d;S;Gf t[.]:[./a]t d;S;G f t : .a:domain(P).t d;S;G f . : K G f K = domain() \nG f d . . if _ . _ . P G f d . . if _ . _ . P TApp2 d;S;G f t[.]:[./a]t Figure10. Static Semantics context \nof domain ., store type S and type environment G, expression e has typet. Most of the typing rules are \nfairly straightforward, with the maindifferencesbetween SystemFown and the standard typing rules lying \nin the addition of checks to verify access permissions. For example, notice that Lambda checks for a \ncreation permission, and that LambdaVal does not, as dis\u00adcussed earlier, and that the .1 and .I rulesboth \nhave corre\u00adsponding creation permission checks and value forms. The Ref ruleis standard, with an extra \ncheckfor creation rights, and the App, DeRef and Assign rules are the familiar rules for function application, \ntype application, dereference and assignment, with an additional checkfor accesspermissions. (The.1 and \nrelated rules also checkfor the well-formedness of types and domains. There is nothing unexpected in \nthis judgment,and weelideitforreasons ofspace.) The TApp1 rule alsofollowsthispattern, withthe addi\u00adtionalfeaturethatitpermitsasubkind \nofitsexpected argu\u00adment.The subkinding relationisde.nedinFigure13; essen\u00adtially, we de.ne a domain d \nto be a subkind of . if it offers atleastthepermissions of .. This lets uspass domains with morepermissions \nas arguments to functions that want ado\u00admainwith someset ofpermissions. The typing rule for .2 differs \nfrom this pattern, because it checks its body in an environment in which its domain is changed to its \nargument, a domain about which no as\u00adsumptions about any other domains are made the condi\u00adtion fv(P)= \n\u00d8 meansthat only thepermissions _ . _ and _ . _ canbein P.If thebody typechecks with this minimal assumption,thenit \ncan safelybe runin anydomain withthe permissionsP.Thus, the application rule TApp2 also varies from the \nestablished pattern. We require that the argument passedtoitbe onethatthecurrentdomainhavepermissions \nfor,becausethebodyofa.2 can,given a rich enough P, cre\u00adatereferences oraccesspointersinthedomainitwasgiven \nas an argument. Consider .a:domain(_ . _). ref a () which has the type .a:domain(_ . _). ref a unit \n. If the currentdomaindid nothavepermission to create references in thedomainitwasgiven as an argument, \naccessprotection couldbe violated. Finally, we have the DmIn and DmInto rules. Both of these create a \nnewdomain and typecheck the body with the assumptionthatthisdomainisavailable, varying onlyinthe question \nof which domain the body is checked in. Both also check that their domain z is creatable, which is a \ncheck that z isgiven nopermissionsthatthe currentdomaindoes not have.ThisjudgmentisinFig12. One .nal \nquestion remains: the typing and reduction judgments require adomain,buthow can wegetsuch ado\u00admain before \nthe program starts evaluating? Our solution is to begin evaluation in a context with initial domain G= \nd : domain(_ . _,_ . _), and we typecheck against thisinitial domain. Figure 13 shows the main rules \nfor subkinding in our system.Thetypekindis a subkindofitself, andtwodomains domain(P)and domain(Q)are \nin a subkind relationship if Q . P (i.e., ifP grants at least the permissions of Q). We retainthisjudgmentin \nordertoshowthatitispossibleto actuallyinvoke ourdomain-universalform. 4.4 Soundness We prove the soundness \nof System Fown with the standard combination ofprogressand typepreservationtheorems.  Theorem1(Progress) \nIf d;S;E f t : t and S f \u00b5, then either t is a value or d f \u00b5;t\u00b5 ' ;t ' . Proof: We prove progress with \na conventional induction over the structure of the typing derivation. The progress proof is wholly conventional; \nall of the interesting structure .;S;G f t :[s/x]t G f d . . .I d;S;G f pack(s,t)as ..x:K.t : ..x:K. \nt .;S;Gf v :[s/x]t .I d;S;G f pack(s,v)as ..x:K.t : ..x:K. t d;S;Gf t : ..x:K.t d;S;G,a : K,x : t f t \n' : s G f d . . .E d;S;Gf unpack (a,x)= t int ' : s d;S;G,z : K f t : td;Gf K creatable DmIn d;S;Gf \nletdomain z : K in t : t .;S;G,z : K f t : td;Gf K creatable DmInto d;S;G f letdomainz : K int : t Figure11. \nMore Static Semantics d;G f P accessible Base d;G f domain(P)creatable AccessEmpty d;G f Eaccessible \nG f d. . {.,.} d;G f P accessible AccessFrom d;Gf P,_ . accessible G f .d . {.,.} d;Gf P accessible \n AccessTo d;G f P,. _ accessible G f dd . {.,.} d;Gf P accessible AccessRefl d;Gf P,_ _ accessible Figure12. \nCreatability SType G f type = type G f P = P ' SDomain G f domain(P)= domain(P ' ) SEmpty G f E = E G \nf P,f,Q = P ' SShrink G f P,Q = P '  Figure13. Subtyping isin the typepreservation theorem. . Theorem2(TypePreservation) \nIfd;S;Gd f t : t, and S f \u00b5, and d f \u00b5;t\u00b5 ' ;e ' , then there exists S ' . S and Gd ' . Gd such that \nd;S ' ;G ' f t ' : t and S '' f \u00b5 . Proof: Wedothisproofby aninduction onthederivation relation. The \nunusual features of this proof, relative to the soundnessproof ofSystemF,arethat .rst,weneed toprove \na domain valuelemmato showthata closed, well-typed value is well-typedat anydomain, andthatthe substitutionlemma \nonly holds when substituting values for variables, which means that the soundness proof for System Fown \nends up relying critically onthelanguagebeing call-by-value. Secondly, our type preservation lemma allows \nGd to growastheprogramevaluates.However,thiscontext only contains domains, which have no term representation, \nso none of the problems of evaluating open terms ever arise. (Ifdesired, a separate contextfordomains \ncouldbe created.) Once wehave a soundnessproof,we can useitprovethat the accesspermissions are always \nrespected: Theorem3(AccessCorrectness) Ifthereis aderivationC = d;S;Gd fE[t]: t, andif t =!l (withS(l)= \nref .s),  t = l := v (withS(l)= ref .s),  t =(..x:t. t)v,  t =(..a:K. t ' )[.],  or t = unpack (a,x)= \nv int ' (withv =pack(.,v)as ..a:K.t), and d f \u00b5;E[t] \u00b5 ' ;E[t ' ], then there exists a domain . such \nthat there is a derivation .;S;G ' d;t : s which is a subderivation of C, and G ' d f . . .. Here, E \nrepresent contexts that can go inside locatives (E ::= ... |E@m ' )unlike the evaluation contexts de.ned \nearlier. 5. RelatedWork Ownership. Anumber ofearly researchprojects,including Islands[17] andBalloons[3],provided \na way to encapsu\u00adlate oneobject withinanother.Theterm ownership isdue to theFlexibleAliasProtectionproject[22,10], \nwhich added ownershipparametersin ordertosupportobject-orientedid\u00adioms like collection classes. Early \nownership systems all en\u00adforcedastrong encapsulationpropertyknownas owners-as\u00addominators: an owned object \nis dominated by its owner, in the sense that all paths in the heap from external objects to the ownedobject \nmustgothroughits owner.Inpractice,this propertyistoo restrictive:idiomssuchas object-orientediter\u00adators, \ncallbackfunctions, and calls to the standardlibrary all may require more .exible heap structures. A number \nof so\u00adlutionshavebeenproposedfor thisproblem,including sup\u00adporting stack-based aliasesto ownedobjects[9],capability\u00adbased \nencapsulation [2], or allowing inner objects to have privilegedaccesstothestate oftheirenclosingobjects[8,6]. \nSeveral systemsbuild onthe owners-as-dominatorsprop\u00aderty to provide secondary properties including safe \ncon\u00adcurrency [6], safe memory management [7], reasoning about effects [9], and abstraction [4]. While \nthe owners\u00adas-dominators property loses its meaning in System Fown (which is not object-oriented), we \nbelieve thatour system in principlecanenablesimilarkinds ofreasoning animportant directionforfuture work. \nClarke et al. s Simple Ownership Types system intro\u00adduced the idea of ownership contexts, which provided \nad\u00additional .exibility by decoupling ownership from individ\u00adual objects, and studied ownership in a foundational \nob\u00adjectcalculus[11,8].OurpreviousworkonOwnership Do\u00admains builds on ownership contexts by introducing \nowner\u00adshipdomains with user-de.ned accesspermissions, but cre\u00adationpermissions andahierarchyofdomainswere \nstillhard\u00adwired[1]. Our system is simpler, more uniform, and more .exible than ourpreviouswork,becausewehaveadded \nexplicit cre\u00adationpermissions,doneaway with theidea ofdomainhier\u00adarchy,andpermitthecreation ofnewdomainsatwill.Asa \nresult, theprevious systems canbe encodedin SystemFown. Furthermore, unlike the previous work, we work \nin an im\u00adperative version of System F, rather than in an object calcu\u00adlus.Thislets us workin a simpler \nandbetter-understood sys\u00adtem, and opens the door to using ownership in functional andprocedurallanguages. \nRegion andEffectSystems.Region-basedmemory manage\u00admentsystemsgroup referencesinto ownership-domain-like \nregions [28, 7]. Our system differs from region systems in several ways. First of all, in order to accurately \ntrack access permissions, our domains include not only references but alsofunctions and existentialpackages. \nSecond, region systems are intended to support statically checkable explicit memory management,requiringthese \nsys\u00adtems to restrict inter-region references according to a stack\u00adlike discipline or linear logic. Our \nsystem s goal of enforc\u00adingencapsulation allows usto support moregeneral aliasing patterns,accordingtothe \naccesspolicies speci.edbythepro\u00adgrammer. Type and effect systems[27] are another way of tracking access \nto state. The main difference is that such systems are usually track the transitive closure all possible \neffects, and while System Fown tracks access, which is not a transitive property. Thus, while effect \nsystems verify that a function only affectsagivenpart oftheprogram sstate,SystemFown veri.es that any \neffects a functionhas are mediated through theproperinformation-hiding interface.Tracking only local \naccessalsoallows ourannotationstoremainsmall compared to a system that tracks transitive effects. Other \nRelated Work. Grossman et al. s syntactic type ab\u00adstraction is similar to our work in tagging data with \nlabels that representtheprincipalsthat ownthedata[16].Thedo\u00admainsof our ownership systemresembletheprincipals,ex\u00adcept \nthat new domains can arise dynamically during pro\u00adgram execution, rather than partitioning the program \nstati\u00adcally. Furthermore, our notion of locatives bears a strong re\u00adsemblancetothework onstackinspection[14].Weuseloca\u00adtives \nof the form e@d in ordertoidentify thebodies offunc\u00adtion invocations and keep track of their permissions. \nThis closely resembles the dynamic grant of permissions in a stack-inspection calculus. SystemFown differsfrom \nstackin\u00adspectioninthatit supportsanunbounded number ofprinci\u00adpals,eachofwhichprotectsits owndatafromotherprinci\u00adpals \naccordingto a well-de.ned accesspolicy. Adoption is another mechanism, similar to ownership, that can \nbe used to encapsulate one object within an\u00adother[12].Although adoption can enforce strong encapsula\u00adtioninthepresenceofstate,itisless.exiblethan \nownership in theprogrammingidiomsthatitallows for example,itera\u00adtorandcallbackobjectswouldbeforbiddeninthisapproach. \nCon.ned types[5] restrict aliases of an object to within a particular package, a weaker but more lightweight \nno\u00adtion comparedtothe object-basedencapsulationprovidedby ownershipdomains. Systemslike alias types[29] \nand separationlogic[26]pro\u00advide a .ner control of aliasing compared to ownership do\u00admains,but are also \nmuch moreintricate, requiring moredec\u00adlarations for the same level of reasoning about aliasing. As future \nwork, we plan on encoding ownership domains in separation logic, to more precisely characterize how they \nmodularizetheuse ofstate[24]. Leino et al. s datagroups[19] and Greenhouse et al. s re\u00adgions[15] aresimilarto \nownershipdomains. Heregroups and regions refer to sets of .elds rather than sets of objects, references, \nand functions, and are used to reason about ef\u00adfects ratherthan aliasing.Banerjee andNaumann[4] make \nuse ofthismethodology toproveanabstractiontheoremfor a speci.cation-based ownership technique. ThefunctionallanguageHaskellhastheconcept \nofastate monad, whichis atype representing computations with state. This idea has strong connections \nto region systems, which canberegarded[13] asawayofcreatingindexedfamilies of state monads.We speculate \nthatfuture work could relate the two via a mutual connection to modal logic. Monads give rise to the \ndiamond modality in constructive modal logic. Our permissions form a globally-visible access control \nlist, asininformation .owanalysis,and soit maybepossibleto modelthis with abox modality asin[21]. 6. \nConclusion This paper has shown how an ownership type system can beintegratedwiththetypetheoryofSystemF,including \nab\u00adstract data types, .rst-class functions, and universal and ex\u00adistentialquanti.cation.The resulting \nsystemis simpler and more.exiblethanprevious ownershiptypesystems,yetpro\u00advides stronger encapsulationguarantees. \nIn future work, we plan to integrate this design into a user-level language that will combine the bene.ts \nof own\u00adership and advanced language constructs. We are currently working onsupportinglocaltypeinferencefor \nownershipin the setting of object-oriented languages. Finally, we would liketoinvestigateconnectionsbetween \nownershipandlogic. 7. Acknowledgments Thanks to John Boyland, David Clarke, Karl Crary, Aleks Nanevski,KevinDonnelly,JoshuaDun.eld,DanGrossman, \nRobert Harper, Donna Malayeri, Kevin Watkins, and the anonymousreviewersfortheircomments onimproving \nthis paper. This work was supported in part by the High De\u00adpendabilityComputingProgram from NASA Ames \ncooper\u00adative agreement NCC-2-1298 and National Science Founda\u00adtionGrantsCCR-0204242 andCCR-0204047. \n References [1] J.Aldrich andC.Chambers. OwnershipDomains:Separating Aliasing Policy from Mechanism. \nIn European Conference on Object-OrientedProgramming,June2004. [2] J.Aldrich,V.Kostadinov, andC.Chambers. \nAliasAnnotations for Program Understanding. In Object-Oriented Programming Systems,Languages, andApplications,November2002. \n[3] P. S. Almeida. Balloon Types: Controlling Sharing of State in Data Types. In European Conference \non Object-Oriented Programming,June1997. [4] A. Banerjee and D. A. Naumann. Representation Indepen\u00addence, \nCon.nement, and Access Control. In Principles of Pro\u00adgrammingLanguages,January2002. [5] B. Bokowski \nand J. Vitek. Con.ned Types. In Object-Oriented InformationandComputation,132(2):109 176,1997. Programming \nSystems, Languages, and Applications, November [29] D. Walker and G. Morrisett. Alias Types for Recursive \nData 1999. [6] C. Boyapati, R. Lee, and M. Rinard. Ownership Types for Safe Programming: PreventingData \nRaces and Deadlocks. In Object-Oriented Programming Systems, Languages, and Applica\u00adtions,November2002. \n[7] C. Boyapati, A. Salcianu, J. William Beebee, and M. Rinard. OwnershipTypes forSafeRegion-BasedMemoryMangement \nin Real-Time Java. In Programming Language Design and Implementation,June2003. [8] D. Clarke. Object \nOwnership &#38; Containment. PhD thesis, University ofNewSouthWales,July2001. [9] D. Clarke and S. Drossopoulou. \nOwnership, Encapsulation, and the Disjointness of Type and Effect. In Object-Oriented Programming Systems, \nLanguages, and Applications, November 2002. [10] D. G. Clarke, J. M. Potter, and J. Noble. Ownership \nTypes for Flexible Alias Protection. In Object-Oriented Programming Systems,Languages, andApplications,October1998. \n[11] D. G. Clarke, J. M. Potter, and J. Noble. Simple Ownership TypesforObjectContainment.InEuropeanConferenceon \nObject\u00adOrientedProgramming,2001. [12] M. Fahndrich and R. DeLine. Adoption and focus: Practical linear \ntypes for imperative programming. In Programming Language Design and Implementation,pages 13 24. ACM \nPress, 2002. [13] M. Fluet and G. Morisett. Monadic regions. In International Conference onFunctionalProgramming,2004. \n[14] C. Fournet and A. D. Gordon. Stack inspection: theory and variants. In Symposium onPrinciples ofProgrammingLanguages, \npages307 318,2002. [15] A. Greenhouse and J. Boyland. An Object-Oriented Effects System. InEuropeanConferenceon \nObject-OrientedProgramming, June1999. [16] D. Grossman, G. Morrisett, and S. Zdancewic. Syntactic Type \nAbstraction. Transactions on Programming Languages and Systems,22(6):1037 1080,November2000. [17] J. \nHogg. Islands: Aliasing Protection in Object-Oriented Languages. InObject-OrientedProgrammingSystems,Languages, \nandApplications,October1991. [18] Y. L. J-Y Girard and P. Taylor. Proofs and Types. Cambridge UniversityPress,1989. \n[19] K. R. M. Leino, A. Poetzsch-Heffter, and Y. Zhou. UsingData Groups to Specify and Check Side Effects. \nIn Programming Language DesignandImplementation,June2002. [20] J.C.MitchellandG.D.Plotkin. Abstracttypeshaveexistential \ntype. Transactions on Programming Languages and Systems, 10(3):470 502,1988. [21] K.MiyamotoandA.Igarashi. \nA modalfoundationforsecure information .ow. In Workshop on Foundations of Computer Security,pages187 \n203,2004. [22] J. Noble, J. Vitek, and J. Potter. Flexible Alias Protection. In EuropeanConferenceon \nObject-OrientedProgramming,1998. [23] M. Odersky. Programming in Scala. Book draft available at http://scala.ep..ch/,2004. \n[24] P. W. O Hearn, H. Yang, and J. C. Reynolds. Separation and information hiding. In Principles of \nProgramming Languages, 2004. [25] D.L.Parnas. OntheCriteriatobe UsedinDecomposingSys\u00adtems into Modules. \nCommunications of the ACM, 15(12):1053 1058,December1972. [26] J. C. Reynolds. Separation Logic: a Logic \nfor Shared Mutable DataStructures. InLogicinComputerScience,July2002. [27] J.-P. Talpin and P. Jouvelot. \nThe type and effect discipline. In Information andComputation,pages245 296,1994. [28] M.TofteandJ.-P.Talpin. \nRegion-based memory management. Structures. In International Workshop on Types in Compilation, September2000. \n  \n\t\t\t", "proc_id": "1065010", "abstract": "Today's module systems do not effectively support information hiding in the presence of shared mutable objects, causing serious problems in the development and evolution of large software systems. Ownership types have been proposed as a solution to this problem, but current systems have ad-hoc access restrictions and are limited to Java-like languages.In this paper, we describe System F<i><inf>own</inf></i>, an extension of System F with references and ownership. Our design shows both how ownership fits into standard type theory and the encapsulation benefits it can provide in languages with first-class functions, abstract data types, and parametric polymorphism. By looking at ownership in the setting of SystemF, we were able to develop a design that is more principled and flexible than previous ownership type systems, while also providing stronger encapsulation guarantees.", "authors": [{"name": "Neel Krishnaswami", "author_profile_id": "81320491252", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "P728838", "email_address": "", "orcid_id": ""}, {"name": "Jonathan Aldrich", "author_profile_id": "81100454133", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP14159584", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1065010.1065023", "year": "2005", "article_id": "1065023", "conference": "PLDI", "title": "Permission-based ownership: encapsulating state in higher-order typed languages", "url": "http://dl.acm.org/citation.cfm?id=1065023"}