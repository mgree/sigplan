{"article_publication_date": "06-12-2005", "fulltext": "\n Jungloid Mining: Helping to Navigate the API Jungle * David Mandelin Lin Xu Rastislav Bod\u00b4ik University \nof California, Berkeley {mandelin,lin xu,bodik}@cs.berkeley.edu  Abstract Reuse of existing code from \nclass libraries and frameworks is often dif.cult because APIs are complex and the client code required \nto use the APIs can be hard to write. We observed that a common scenario is that the programmer knows \nwhat type of object he needs, but does not know how to write the code to get the object. In order to \nhelp programmers write API client code more easily, we developed techniques for synthesizing jungloid \ncode fragments automatically given a simple query that describes that desired code in terms of input \nand output types. A jungloid is simply a unary expression; jungloids are simple, enabling synthesis, \nbut are also versatile, covering many coding problems, and composable, com\u00adbining to form more complex \ncode fragments. We synthesize jun\u00adgloids using both API method signatures and jungloids mined from a \ncorpus of sample client programs. We implemented a tool, PROSPECTOR, based on these tech\u00adniques. PROSPECTOR \nisintegratedwiththeEclipseIDEcodeassis\u00adtance feature, and it infers queries from context so there is \nno need for the programmer to write queries. We tested PROSPECTOR on a set of real programming problems \ninvolving APIs; PROSPECTOR found the desired solution for 18 of 20 problems. We also evaluated PROSPECTOR \nin a user study, .nding that programmers solved pro\u00adgramming problems more quickly and with more reuse \nwhen using PROSPECTOR than without PROSPECTOR. Categories and Subject Descriptors D.2.6 [Software Engineer\u00ading]: \nProgramming Environments Integrated Environments; D.2.13 [Software Engineering]: Reusable Software Reuse \nModels; I.2.2 [Arti.cial Intelligence]: Automatic Programming Program synthesis General Terms Experimentation, \nLanguages Keywords reuse, program synthesis, mining * This work is supported in part by the National \nScience Foundation, with grants CCF-0085949, CCR-0105721, CCR-0243657, CNS-0225610, CCR\u00ad0326577, an award \nfrom University of California MICRO program, the Okawa Research Award, as well as donations from IBM \nand Intel. This work has also been supported in part by the Defense Advanced Research Projects Agency \n(DARPA) under contract No. NBCHC020056. The views expressed herein are not necessarily those of DARPA \nor IBM. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n05, June 12 15, 2005, Chicago, Illinois, USA. Copyright 2005 ACM 1-59593-056-6/05/0006...$5.00. Doug \nKimelman IBM Corporation dnk@us.ibm.com 1. Introduction When implementing common software features, \nsuch as HTML parsing, developers prefer to reuse existing libraries and frame\u00adworks. Unfortunately, the \nsame features that make libraries potentially reusable tend to make library APIs dif.cult for pro\u00adgrammers. \nThe .rst feature is API size. For example, J2SE, the Java standard library, exposes a wide range of reusable \ncompo\u00adnents as thousands of classes with 21,000 methods, too many to learn or remember easily. The second \nfeature is .exibility. In order to make libraries .exible while keeping them main\u00adtainable, designers \npackage functionality as small composable units. Often the programmer must .nd and integrate several \nsuch units to use even basic features of the library. Consider the programming task of parsing a Java \nsource code .le using the Eclipse IDE framework version 2.1, as\u00adsuming the .le is represented by an IFile \nobject. Two of the authors encountered this problem independently, and in each case it took several hours \nto arrive at the desired code, which is shown here. IFile file = ...; ICompilationUnit cu = JavaCore.createCompilationUnitFrom(file); \nASTNode ast = AST.parseCompilationUnit(cu, false); This example illustrates some of the dif.culties program\u00admers \noften encounter. First, a programmer unfamiliar with the framework would not think to look at class JavaCore, \nyet JavaCore is a crucial link: one of its static methods converts one type of .le handle, IFile, to \nanother, ICompilationUnit, that can be used by the parser. Second, the programmer may look for clues \nusing the class browsing features provided by object-oriented IDEs, but that will not help here: the \nIDE can easily show members of IFile, but the .rst step is a static method of a different class. Finally, \nalthough a programmer might know that the result of parsing is an ASTNode, and might therefore grep for \nmethods returning ASTNode, the method parseCompilationUnit would not be found be\u00adcause its return type \nis actually CompilationUnit, a subclass of ASTNode. Issues such as these make it hard for programmers \nto write the code they need in order to use complex APIs. To help programmers use APIs more easily and \nthus achieve more of the potential of reuse, we have developed techniques for synthesizing API client \ncode automatically. As an applica\u00adtion of these techniques, we have implemented PROSPECTOR, a tool that \nlooks to the user like a programmer s search en\u00adgine packaged inside Eclipse s code completion assistant. \nA programmer trying to write code for an API can express his needs to PROSPECTOR as a simple query, and \nPROSPECTOR will synthesize a list of candidate code snippets like the one above. These snippets refer \nto variables in the user s program, and they are suitable for immediate insertion into the user s source \ncode. Like familiar text search engines, PROSPECTOR does not guarantee that the results are exactly what \nthe user wanted, but given a short list of examples from PROSPECTOR, it is not too dif.cult for the user \nto select a result and verify it manually. An experiment found that PROSPECTOR was able to answer 18 \nof 20 queries derived from real problems, and in each case, the user found the answer to the original \nprogram\u00adming problem after looking at fewer than 5 code snippets. For the synthesis results to be accurate, \nthe query language must be speci.c, but it must also let the programmer express her needs easily and \nnaturally, otherwise writing the queries will be more effort than writing the code by hand. For ex\u00adample, \ndescribing parsing exactly is almost as much effort as writing a parser, and requires much more text \nthan the code to be generated. In our query language, which balances speci\u00ad.city with ease of use, a \nquery is a pair (tin,tout), where tin and tout are class types. An answer to the query is a synthe\u00adsized \ncode snippet that takes a single input object of type tin and returns a single output object of type \ntout. Code snippets that satisfy these queries solve many programming problems involving reuse, as we \nwill explain later. In our parsing ex\u00adample, once the programmer learns that ASTs are represented by \nASTNode objects, she can describe parsing a .le with the query (IFile,ASTNode). Many programming problems, \nes\u00adpecially those arising during reuse attempts, can be expressed fairly naturally as a query of this \nform, including but not limited to converting between data representations, traversing object schemas, \nand .nding replacements for code containing depre\u00adcated methods. Note that a query expresses only a part \nof the program\u00admer s intent, so some code snippets that satisfy the query may not solve the programmer \ns problem. Most classes are speci.c enough so that the results match the programmer s intent, but some \nclasses have multiple meanings. For example, if the user has a String representing the name of a Java \nsource code .le he wants to parse, he might run the query (String,ASTNode), which describes the desired \ncode, but also describes code that parses Java source contained in a String. However, the pro\u00adgrammer \ncan easily .nd the desired result in a short list, and this is much easier than writing a query that \ndescribes the de\u00adsired result exactly. Some programming problems that are not directly express\u00adible in \nour query language can still be reduced to one or more queries. In particular, the programmer may know \nonly that he needs an object of type tout. For example, a programmer writing a GUI may need the active \nwindow, which is repre\u00adsented by a Shell object, without knowing or caring what in\u00adput object to use. \nWe reduce this problem to our base prob\u00adlem by collecting the set of types of objects lexically visi\u00adble \nat the current point, {t0,...,tk}, and generating queries (t1,tout),...,(tk,tout). This reduction is \nespecially useful because it allows PROSPECTOR to be integrated with code completion. Code completion \nis a feature supported by many IDEs that the user can invoke while typing to view a list of suggestions \nand insert a selected suggestion automatically. For example, if the programmer invokes code completion \njust after typing the text myList., code completion will show a list of members of myList. With PROSPECTOR, \nwhen the user is typ\u00ading code that requires a value of a certain type, e.g., when the cursor is on the \nright-hand side of an assignment, code comple\u00adtion suggests complete code snippets for computing the \nvalue, so there is no need for the user to even know that there is a query language. Having described \nour query language, we now turn our attention to the code snippets we synthesize in response to queries. \nThe desired answer to a query could use almost any features of the programming language, but we have \nfound that the answer often has a single input object and a single output object, with a chain of intervening \nobjects obtained with method calls. We call this kind of code snippet a jungloid.1 When programmers get \nstuck writing API client code, the desired code is often a jungloid: an informal study of 16 cases where \na programmer got stuck attempting reuse found that in 9 cases the desired code was a jungloid, and in \n3 others the desired code could be decomposed into multiple jungloids. Not only do jungloids cover many \nproblems, but their sim\u00adple form makes synthesizing them easy. Observe that the ba\u00adsic expressions that \nform jungloids are unary expressions, such as calls to unary methods. The set of such basic expressions \nsupported by an API can be derived from its signatures.2 A directed graph can then be formed, in which \neach class is rep\u00adresented by a node, and each basic expression is represented by an edge from its input \ntype to its output type. Thus, every jungloid supported by the API is represented as a path in the graph. \nWe .nd jungloids in response to a query (tin,tout) by searching the graph for paths from tin to tout. \nBecause there can be many paths, we rank the jungloids using a heuristic, placing jungloids more likely \nto be wanted by the programmer at the top of the list. This list is presented to the user, who se\u00adlects \nthe desired jungloid, which is then inserted into the user s code. However, some jungloids cannot be \nsynthesized using sig\u00adnatures alone because they contain features not precisely de\u00adscribed by the static \ntype system, such as downcasts. Here is an example, which retrieves an IResource object represent\u00ading \na .le selected by the user in the Eclipse GUI: SelectionChangedEvent event = ... IStructuredSelection \nsel = (IStructuredSelection) event.getSelection(); IResource res = (IResource) sel.getFirstElement(); \nThe type of the value returned by getFirstElement() is determined at run time by a con.guration .le, \nso the method signature must declare return type Object. In order to use the returned value, the programmer \nmust provide its type in the form of a downcast.3 Because signatures do not contain enough information \nabout which downcasts are legal at run time, we turn to another source of information: examples. Existing \nAPI client code con\u00adtains many examples of using downcasts correctly. Thus, we can mine a corpus of working \ncode for snippets containing downcasts and expect these snippets to function properly if inserted into \nother programs. In fact, .nding and copying ex\u00ad 1 A jungloid consists of just the chain of objects and \nmethod calls you need to get from something you have (e.g. an IFile) to something you need (e.g. an ASTNode), \nlike a monkey swinging from vine to vine through the jungle. 2 We use the term more generally here to \nrefer to all the elements of the static type system: method signatures, .eld declarations, and class \nhierarchy declarations. 3 Because the type is determined at run time, unless Eclipse is substantially \nredesigned, the cast in this example would be required even with Java 5 Generics. amples is a common \ncoding technique used by programmers even for APIs that do not require downcasts. Unfortunately, programmers \noften .nd examples hard to understand and make errors adapting the example to their own code, because \nexam\u00adples in real code are often woven together with other code and spread across multiple methods and \n.les. Our automatic tech\u00adniques do not suffer from these problems, because we convert examples to jungloids, \nwhich are simple, concise summaries of API usages. However, a collection of example jungloids by itself \ndoes not provide enough information to answer many jungloid queries. First, simply searching a collection \nof examples for references to tin and tout would miss a relevant example that yields a subclass of tout. \nSecond, examples are often too short, showing only a part of the task. Consider our parsing query (IFile,ASTNode): \nif all the available examples of calling parseCompilationUnit() take ICompilationUnit as input instead \nof IFile, then even if searching .nds examples, they will not show how to solve the problem completely. \nWe have seen two ways of discovering jungloids, synthesiz\u00ading from signatures and searching for examples, \neach of which has unique advantages. Signatures can be used to form a sim\u00adple representation of all jungloids \nthat type check, but they provide little information about how downcasts behave at run time. Examples \nallow us to .nd downcasts that are likely to pass run-time type checking, but an example is often only \na partial solution to a reuse problem. In order to combine these advantages, we have developed a common \nrepresentation that allows ef.cient, precise query processing, the jungloid graph. Signatures are represented \nas explained earlier, in a directed graph where the nodes are types and edges are expressions de\u00adrived \nfrom signatures. Examples are extracted from their con\u00adtext as jungloids, converted to paths, and added \nto the graph. The result is a graph with re.ned types, which indicate more accurately which downcasts \nwill succeed at run time. We can run the same search and ranking algorithms developed for the signature \ngraph on the jungloid graph to synthesize jungloids from signatures and any number of examples. We can \neven synthesize code snippets that are more general than jungloids, in particular snippets that call \nmethods with more than one input. Such code snippets can be built up from several jungloids, each synthesized \nin response to a separate user query. A typical scenario is that the .rst query returns a jungloid in \nwhich the second argument of a method has not been synthesized. We can generate such a jungloid simply \nby pretending during synthesis that multi-input methods have only one input. To complete the code, the \nuser simply issues another query with the type of the second argument as tout. Finally, we tested whether \nprogrammers are able to reuse code more effectively with PROSPECTOR. We asked program\u00admers to complete \nfour programming problems that could be solved by reuse, solving two problems with PROSPECTOR and two \nwithout. We found that, on average, programmers using PROSPECTOR solved the problems twice as fast as \nthe base\u00adline programmers. We also found that when programmers had PROSPECTOR they solved the problems \nby reuse, but without PROSPECTOR they often resorted to reimplementation. Thus, PROSPECTOR helps programmers \nsolve problems faster while writing better code. The main contributions of this work are as follows: \n We designed an easy-to-use, yet suf.ciently speci.c, query language for describing object-oriented API \nclient code, and identi.ed an easily synthesized kind of query result, jungloids.  We developed a representation \nfor combining two sources of information about API usage, signatures and examples, along with algorithms \nthat operate on this representation to synthesize jungloids from queries.  We constructed PROSPECTOR, \na practical Eclipse plugin tool based on these ideas. We performed a user study that found that programmers \ncan solve reuse problems twice as fast with PROSPECTOR then without. PROSPECTOR is available for download \nat:  www.cs.berkeley.edu/~mandelin/prospector The rest of this paper is organized as follows. Section \n2 presents de.nitions of our terms and the jungloid synthesis problem. Section 3 describes our solution \nbased on the signa\u00adture graph to the jungloid synthesis problem for jungloids that do not contain downcasts. \nSection 3 also explains how we rank jungloids to make it easier for the user to .nd the desired solu\u00adtion. \nSection 4 explains how to synthesize jungloids that con\u00adtain downcasts using jungloid mining. Section \n5 describes the implementation of PROSPECTOR. Section 6 describes the de\u00adsign of our experiments, and \nSection 7 lists and discusses the results. Section 8 surveys related work and Section 9 concludes the \npaper. 2. The Jungloid Synthesis Problem This section de.nes the jungloid synthesis problem formally. \nWe begin with de.nitions of queries, jungloids and the search problem. Then, we present a real programming \nproblem and show how queries and jungloids are used to solve the problem. 2.1 De.nitions We start by \nde.ning the query that acts as a partial speci.cation of the jungloid to be synthesized. DEFINITION 1. \nA jungloid query is a pair (tin,tout), where tin and tout are class types.4 Jungloids are formed by composing \nelementary jungloids, de.ned as follows. DEFINITION 2. An elementary jungloid is a typed unary ele\u00admentary \nexpression .x.e : tin . tout, where tin and tout are class types. Elementary jungloids may contain free \nvariables. Free vari\u00adables cannot be bound during jungloid synthesis; they can be bound only after the \njungloid is inserted into user code. Be\u00adcause free variables are not used for synthesis, we allow them \nto be of any type, including primitive types. For Java, we de.ne six kinds of elementary jungloids. Field \nAccess. If class T declares a .eld of type U, Uf, then there is an elementary jungloid .x .x.f : T . \nU. 4 In our Java implementation, tin and tout may be any reference type, which includes class, interface, \nand array types. The only types we exclude are primitive types such as int, which could represent anything \nfrom an array bound to a cryptographic key. Static method or constructor invocation. If class C de\u00adclares \na static method (or constructor) with at least one class-typed parameter, U m(...,T a,...), then there \nis an elementary jungloid .x.C.m(..., x, ...): T . U. The other parameters are free variables. There \nis one elementary jungloid for each class-typed parameter of m(). If class C declares a static method \n(or constructor) with no parameters, T m(), there is an elementary jungloid .x.C.m() : void . T . Using \nvoid in this way extends jungloids to cover expressions with no input values, such as constructor invocations \nwith no arguments.  Instance method invocation. Instance methods are han\u00addled like static methods, with \nthe receiver treated as another parameter. For example, if there is an instance method U T.m(), then \nthere is an elementary jungloid .x .x.m() : T . U.  Widening reference conversion. In Java, a widening \nrefer\u00adence conversion (henceforth widening) is a conversion from a reference type T to one of its supertypes. \nWidening has no syntax; the compiler inserts widening conversions automat\u00adically as needed for method \nand constructor arguments. We use a widening elementary jungloid to connect a jungloid that outputs a \nT to a jungloid that inputs a supertype of T. If T is a subtype of U (T extends U or T implements U), \nthen there is an widening elementary jungloid .x .x : T . U.  Downcast.5 If U is a subtype of T, then \nthere is an elemen\u00adtary jungloid .x . (U ) x : T . U .  DEFINITION 3. A jungloid is a well-typed composition \nof el\u00adementary jungloids. Well-typed means that the output type of each elementary jungloid (except the \noutermost) is the same as the input type of the elementary jungloid it is composed with. DEFINITION 4. \nA solution jungloid for the query (tin,tout) is a jungloid .x.e : tin. . tout. such that tin. = tin and \ntout. = tout. The jungloid synthesis problem is the problem of .nding so\u00adlution jungloids for queries. \nOur solution to the search problem is described in Sections 3 and 4. Also, Section 3.2 describes techniques \nfor ranking jungloids, with the goal of identifying solution jungloids that are likely to satisfy the \naspects of the user s intent not expressed in the query. 2.2 Programming with Jungloids We will illustrate \nthe preceding de.nitions on a simpli.ed version of Eclipse FAQ 270 [3], a common problem in practice. \nEclipse JDT is an extensible Java IDE with a complex API, with which developers can create visual editors \nfor different kinds of programs and data. New developers are often stumped by the question How do I manipulate \nthe data in my visual editor? The .rst step is to learn that the visual aspects of the editor are represented \nby an IEditorPart object and the underlying data is manipulated through an IDocumentationProvider object. \nA programmer can .nd this out by searching documen\u00adtation and class libraries. (Finding these classes \nis an important part of answering the question, and has been addressed by prior work, such as CodeBroker \n[16]. In this paper, we focus on the 5 The Java speci.cation calls downcasts narrowing reference conversions, \nbut this paper uses the more familiar term downcast. problem of synthesizing the code to coordinate these \nclasses, once the classes are known.) Given the class names, the developer can re.ne the question to: \nWhat code takes an IEditorPart as input and returns an IDocumentationProvider object that represents \nthe data contained in the editor? The query (IEditorPart, IDocumentationProvider) expresses this question, \nbut only partially, because the query does not describe the desired semantic relationship between the \nobjects. We can build up one of the solution jungloids for the query by composing the following two elementary \njungloids, which is legal because the output type of the .rst is the same as the input type of the second. \n1. .x. x.getEditorInput() : IEditorPart . IEditorInput  2. .x. dpreg.getDocumentProvider(x): IEditorInput \n. IDocumentProvider  Here is the solution jungloid, which contains a free variable, dpreg: .x. dpreg.getDocumentProvider(x.getEditorInput()): \nIEditorPart . IDocumentProvider Assuming that the user has declared a variable named ep of type IEditorPart \nfor the input object, we would translate the solution jungloid to the following Java code: IEditorInput \ninp = ep.getEditorInput(); DocumentProviderRegistry dpreg; // free variable IDocumentProvider dp = dpreg.getDocumentProvider(inp); \nWe generated a variable declaration for the free variable so that the user knows he needs to create another \nobject. The best way to do this is with a query that expresses the output type only, because the user \ndoes not necessarily know from what values the object should be computed. As mentioned in the introduction, \nsuch a query can be reduced to jungloid queries by using the types of lexically visible objects as input \ntypes. Assuming there are no other declarations, the visible objects are IEditorPart ep and IEditorInput \ninp. The resulting jungloid queries are: (IEditorPart, DocumentProviderRegistry) (IEditorInput, DocumentProviderRegistry) \n(void, DocumentProviderRegistry) We include void so that if none of the visible objects can be used to \ncompute a DocumentProviderRegistry, we can try to compute one from constructors and static methods. In \nfact, the .rst two queries have no solution jungloids, and the void query is the one that returns the \ndesired jungloid: .x. DocumentProviderRegistry.getDefault() : void . DocumentProviderRegistry Translating \nthis jungloid to Java .nishes the problem: IEditorInput inp = ep.getEditorInput(); DocumentProviderRegistry \ndpreg = DocumentProviderRegistry.getDefault(); IDocumentProvider dp = dpreg.getDocumentProvider(inp); \nThus, we have seen how a dif.cult programming problem can be decomposed into two jungloid queries, and \nhow the solution jungloids for the queries can be used to generate the required Java code. In the next \nsection, we describe how to synthesize solution jungloids for queries.  3. Finding Jungloids Using \nSignatures In this section, we describe how to .nd solution jungloids that do not contain downcasts. \nOur techniques use API signatures only; we make no use of method implementations or client code. In the \n.rst part, we describe the signature graph, a rep\u00adresentation of the jungloids of an API constructed \nfrom its sig\u00adnatures, and how it is used to .nd solution jungloids. In the second part, we explain why \nsome solution jungloids are better than others and describe ranking a heuristic for identifying the best \njungloids. 3.1 The Signature Graph The class declarations, .eld declarations, and method signa\u00adtures \nof an API determine the set of elementary jungloids pro\u00advided by the API. (See Section 2.1.) In turn, \nthese elementary jungloids determine the complete set of jungloids that may be written using the API. \nWe represent this set of jungloids using the signature graph. The nodes of the signature graph are the \nclass types declared by the API (including array types that ap\u00adpear in declarations). The edges represent \nthe elementary jun\u00adgloids of the API: for each non-downcast elementary jungloid .x.e: T . U there is \na labeled edge (T,U,.x.e). Figure 1 shows a small part of the signature graph con\u00adstructed from the Java \nstandard libraries and the Eclipse API, including the jungloid used in our parsing example from Sec\u00adtion \n1. The set of solution jungloids for the query (tin,tout) cor\u00adresponds exactly to the set of paths from \ntin to tout. Thus, solution jungloids can be enumerated by standard graph search algorithms. Note that \nthere may be in.nitely many paths from (tin,tout), but all the desired solution jungloids we have ob\u00adserved \nso far are acyclic, so we limit our search to acyclic paths, which are .nite in number.  3.2 Ranking \nJungloids In general, a query has multiple solution jungloids, and not all of these jungloids are equally \ndesirable for the user. First, in\u00adstead of returning a value of the requested type, some solution jungloids \nreturn a null value or throw an exception. This is be\u00adcause some API methods require state properties \nof their argu\u00adments that are not expressed by their types, e.g., that .eld foo is non-null. Second, some \njungloids return a value of the re\u00adquested type, but the relation between input and output does not satisfy \nthe programmer s intent. For example, if a programmer wants to parse code stored in a named .le, he might \nissue the query (String, ASTNode), but a solution jungloid may parse code stored in the string itself. \nFinally, among jungloids that do satisfy the user s intent, some are simpler, more ef.cient, or more \nconcise than others. Ideally, we want to show the pro\u00adgrammer the simplest jungloid that satis.es his \nintent. We cannot evaluate how well a jungloid satis.es the user s intent using Java types, so we will \nshow the jungloids to the user and ask him to select one. Unfortunately, some queries have too many jungloids \nto examine by hand (in the worst case, factorially many in the size of the signature graph). This situation \nis similar to that encountered by a text search engine, which can .nd millions of documents in response \nto a query. Search engines solve this problem by ranking the documents according to their likelihood \nof being relevant to the user s original question. Similarly, we rank jungloids, with the goal of minimizing \nthe number of jungloids the programmer must examine before .nding the desired one. Because user intent \nis hard to analyze, our ranking relies on a heuristic: ordering jungloids by length, assigning the top \nranks to the shortest jungloids. Although simple, this heuristic is very effective, for several reasons. \nFirst, between two jun\u00adgloids that satisfy the user s intent, the more concise one is pre\u00adferred. Second, \na shorter jungloid is less likely to fail by throw\u00ading an exception or returning a null value: if we \nassume that each elementary jungloid fails with .xed probability p, then a shorter jungloid has a lower \nprobability of failing. Finally, shorter jungloids are more likely to satisfy the programmer s intent. \nIn particular, a programmer would not be able to under\u00adstand a jungloid with too many method calls, and \nthus would never intend to write such a jungloid. Also, we conjecture that well-designed libraries allow \nprogrammers to express common tasks with concise code. Experience backs this conjecture: In an informal \ntest of an early prototype of PROSPECTOR that returned an arbitrarily chosen shortest jungloid, the result \nsatis.ed the programmer s intent in 9 trials out of 10. Thus, .nding a single shortest path in the signature \ngraph is an effective, practical algorithm for .nding a single solution jungloid. However, we use the \nmore effective approach of presenting several jungloids sorted in length order. The programmer can examine \neach one in turn, and will most likely .nd the desired jungloid after looking at a small number (see \nour experimental results in Section 7). Note that we do not count widening elementary jungloids in computing \nthe length. Widening has no syntax, so it does not increase code size or complexity for the programmer. \nAlso, widening never throws an exception. Jungloid length does not apply directly to jungloids with free \nvariables because they are not complete programming so\u00adlutions: more code must be generated to compute \nthe values of the free variables, making a larger code snippet. The length heuristic must be extended \nto account for this; the proper ex\u00adtension seems to be to estimate the total number of elementary jungloids \nin the complete code snippet. Our current implemen\u00adtation assumes that each free variable will require \na jungloid of size two, because with this value ranking appears to perform well empirically. More precise, \nsystematic estimation is left for future work. For a few queries, there are many shortest jungloids, \nand some are simpler than others. For example, a program\u00admer who wants to read lines from a .le may issue \nthe query (FileInputStream,BufferedReader), which has 20 shortest jungloids, including the following: \n new java.io.BufferedReader( new java.io.InputStreamReader(in))  new org.apache.lucene.demo.html.HTMLParser(in) \n.getReader()  Both of these perform as desired, but the .rst one is the standard programming idiom, \nwhile the second one does more than what was intended and has software-engineering disad\u00advantages. Generalizing \nfrom this and other examples, we in\u00adferred that jungloids that cross many Java package boundaries  Figure \n1. Part of the signature graph. The jungloid for our parsing example is shown in bold face. Widening \nedges, such as the one from IClassFile to IJavaElement, allow the graph to represent jungloids that use \ninheritance, such as classFile.getResource(). are less likely to be useful, and we re.ned our heuristic \nso that it ranks jungloids of equal length according to the number of package boundaries they cross. \nAnother observation we made is that a jungloid that returns a subclass of the type the user requested \nmay also perform more than was asked for. For example, say that the programmer wants a jungloid that \nreturns the active Eclipse visual editor, so she speci.es IEditorPart as the output type. A jungloid \nthat returns an XMLEditor would be too speci.c, assuming that if the programmer wanted an XML editor \nspeci.cally she would have asked for it. Therefore, for jungloids of equal length, we assign a higher \nrank to the one that returns the more general output type. Our heuristic is ef.cient and easy to implement. \nIt is also effective; usually the top-ranked jungloids return a non-null value without throwing an exception \nwhen inserted into the user s code. A major limitation is that although the heuristic rules out very \nlong jungloids that would never satisfy the user s intent, it ranks shorter, more reasonable jungloids \narbitrarily. Consider the (String, ASTNode) example from the beginning of this section: parsing code \nfrom a named .le and parsing code in the string are both reasonable. The heuristic favors the lat\u00adter \nbecause its code happens to be shorter. Fortunately, there are usually not too many reasonable jungloids. \nExperimentally, we have found that a programmer using the search tool imple\u00admented with the signature \ngraph and this heuristic can .nd use\u00adful jungloids quickly, usually after examining fewer than .ve jungloids \n(see Section 7).  4. Re.ning the signature graph with examples In this section, we expand our solution \nto cover jungloids with downcasts. First, we discuss why the signature graph is not effective for .nding \njungloids with downcasts. Next, we describe our solution, which is based on jungloid mining. Finally, \nwe discuss the accuracy and limitations of jungloid mining. 4.1 Jungloids containing downcasts Some APIs \nrequire the user to write client code containing downcasts. Such code is particularly hard to write manually \nor to synthesize, because the library signatures do not docu\u00adment which downcasts are legal. Thus, we \nexcluded downcast elementary jungloids from the signature graph. Including downcast elementary jungloids \nin the signa\u00adture graph is not a practical way of synthesizing jungloids with downcasts. The resulting \ngraph would represent all jungloids with downcasts, but most of these jungloids are IDebugView debugger \n= ...; Viewer viewer = debugger.getViewer(); IStructuredSelection sel = (IStructuredSelection) viewer.getSelection(); \nJavaInspectExpression expr = (JavaInspectExpression) sel.getFirstElement(); Figure 2. A jungloid containing \ndowncasts, which cannot be syn\u00adthesized from the signature graph. not useful to a programmer because \nthey always throw ClassCastException. Consider class Object: Every class T is a subclass of Object, so \nfor every T there is a down\u00adcast elementary jungloid .x . (T ) x : Object . T . Thus, for every method \nfoo declared to return Object, there are jun\u00adgloids casting the result of foo to every class T , while \nusually there are only a few different classes that foo can return. These jungloids are particularly \nbad because they are short, so they are favored by the ranking heuristic. We cannot simply give up on \nsynthesizing jungloids with downcasts because downcasts are important in many APIs. Many existing APIs \nrequire downcasts because they use legacy collections instead of Java 5 Generics. Also, APIs for espe\u00adcially \ncomplex systems such as Eclipse will continue to require downcasts, because they use design features \n(e.g. creating ob\u00adjects dynamically through re.ection instead of with a call to a statically typed constructor) \nthat cannot be described exactly even by Java 5 parameterized types. Figure 2 shows an example of a jungloid \ncontaining a down\u00adcast taken from Eclipse code. This jungloid gets the watch ex\u00adpression currently selected \nin the GUI of the Java debugger. A programmer trying to write this jungloid by hand would run into dif.culty \nright away because the class representing the de\u00adbugger, IDebugView, has no methods for getting the selec\u00adtion. \nBrowsing methods manually, he might .nd the jungloid getViewer().getSelection(), but this jungloid returns \nan ISelection object, which has no Javadoc documentation and only a single method, getEmpty(). ISelection \nappears to be a dead end, although a cast, a method call, and another cast will complete the desired \njungloid. Figure 3 shows what happens if we try to represent the jun\u00adgloid in Figure 2 by adding all \ndowncast elementary jungloids to the signature graph. The resulting graph represents our jun\u00adgloid, but \nalso many short, useless jungloids, such as this one: (JavaInspectExpression) debugger.getViewer().getInput() \n Figure 3. Part of the signature graph with all downcast elementary jungloids added. This represents \nmany undesired jungloids, such as those casting any object to JavaInspectExpression. We call such a jungloid \ninviable, by which we mean that it always either throws an exception or returns null. A jungloid is viable \nif there is at least one environment (i.e., combination of global program state and input values) that \nmakes the jungloid return normally, which means it has the possibility of satisfy\u00ading the programmer \ns intent. In order to obtain useful search results, we must solve the problem of adding as many viable \njungloids containing downcasts to the graph as possible, while adding only a few inviable jungloids. \n 4.2 Jungloid mining Our solution is based on the observation that jungloids previ\u00adously written by programmers \nin well-tested programs are al\u00admost always viable. This suggests that we can learn a set of viable jungloids \ncontaining casts from a set of example pro\u00adgrams. We call this approach jungloid mining because it learns \nfrom a corpus of example programs rather than analyzing the API implementation directly. Extracting Jungloids. \nThe key idea behind extracting jun\u00adgloids containing downcasts from a corpus is that there are certain \nsequences of calls that establish the state in which the downcast will succeed, and the corpus contains \nexamples of these sequences, which we call example jun\u00adgloids. For example, most Objects cannot be downcast \nto JavaInspectExpression, but an Object obtained by the jungloid in Figure 2 can. Figure 4 shows part \nof an Eclipse cor\u00adpus method (from production code) containing this jungloid. Note that we do not need \nto extract all jungloids containing downcasts, only those that end in downcasts. We assume that an object \nthat is successfully downcast can be used like any other object of the same type, so calls after the \ndowncast can be synthesized from the signature graph. Our implementation extracts a superset approximation \nof the example jungloids ending in casts that the corpus can execute given any input. The algorithm is \nclosely related to protected IJavaObject getObjectContext() { IWorkbenchPage page= JDIDebugUIPlugin.getActivePage(); \nIWorkbenchPart activePart= page.getActivePart(); IDebugView view = (IDebugView) activePart.getAdapter(IDebugView.class); \nISelection s = view.getViewer().getSelection(); IStructuredSelection sel = (IStructuredSelection) s; \nObject selection = sel.getFirstElement(); JavaInspectExpression var = (JavaInspectExpression) selection; \n... } Figure 4. Sample API client code containing a downcast. slicing: for each cast, we take a backward, \ninterprocedural, .ow-insensitive slice using a conservative approximation of the call graph based on \nthe type hierarchy. Then, we follow each acyclic data-.ow path going backward from the cast un\u00adtil it \nreaches a zero-argument expression (such as a constructor call), collecting the sequence of elementary \njungloids as an ex\u00adample jungloid. Note that call sites in the slice can be interpreted in two ways. \nFirst, a call can be interpreted as an elementary jungloid connecting its input to its output. Alternatively, \na call can be interpreted as transferring data .ow, effectively inlining the method body at the call \nsite. An example will illustrate this: C clientMethod1() { B a2b(A a) {A a = new A(); G g = a.getG(); \nB b = a2b(a); return new B(g); return (C) b; } } Using the two different interpretations, we extract: \n(C) a2b(new A()) // a2b as elementary jungloid (C) new B(new A().getG()) // inlining a2b  We treat \nAPI methods as elementary jungloids, and if method implementations are available, we inline them as well. \nClient methods are always inlined, because they are not ele\u00admentary jungloids (only API methods are). \nNote that the number of example jungloids extracted for a given cast may be very large. The backward \ndata-.ow path branches when it reaches either a variable that is assigned into multiple places or an \nelementary jungloid with multiple argu\u00adments. The path also branches when we apply both interpreta\u00adtions \nto an API method call. In some client methods, branching causes extraction to take many hours and generate \nseveral gi\u00adgabytes of example jungloids. Our implementation avoids this by stopping after a de.ned maximum \nnumber of example jun\u00adgloids is extracted for a given cast expression in the corpus. Fortunately, this \nhappens for only a small fraction of the down\u00adcasts in the corpus, and the maximum number is a reasonable \nsample of examples reaching a cast. Adding jungloids to the graph. Once we have extracted a set of example \njungloids, we transform the signature graph to rep\u00adresent the examples, so they can be used in synthesis. \nFor each example jungloid .x . (U )e : T . U , we create a new path connecting existing nodes T and U, \nbut creating fresh nodes for all intermediate objects in the example jungloid. The new nodes represent \ntypestates [12] in which casts or jungloids end\u00ad  Figure 6. Part of the jungloid graph, showing the \nexample jungloid from Figure 5. ing with casts will complete without throwing cast exceptions. The transformed \ngraph, called the jungloid graph, represents all jungloids that can be formed by composing jungloids \nin the signature graph and any number of example jungloids. Figure 6 shows part of the jungloid graph, \nincluding the path for the example jungloid in Figure 5. Notice that if we had not created the new node \nObject-1, the jungloid graph would rep\u00adresent jungloids casting any Object to JavaInspectExpression; \nmost of these jungloids are inviable, and the example does not suggest that they are viable. Note also \nthat instead of adding the entire example, we added only the suf.x necessary for the .nal downcast to \nsucceed; we will explain later in this section how to identify the necessary suf.x. Generalizing example \njungloids. As Figure 5 hints, exam\u00adple jungloids often contain more elementary jungloids than needed, \nmaking them less effective for synthesizing jungloids. Figure 7. Example jungloids with unneeded pre.xes, \nshown with dashed lines. The list returned by Project.getTargets() con\u00adtains Target objects, regardless \nof the methods called to obtain the Project. The entire jungloid in Figure 5 is not necessary to make \nthe downcasts succeed: we need only the suf.x jungloid starting with IDebugView. The suf.x jungloid can \nbe composed with any other jungloid that returns an IDebugView, so it represents not only the example \njungloid, but also the set of jungloids produced by composing the suf.x with other viable jungloids. \nThus, the suf.x is more general than the original example jun\u00adgloid, and we will be able to synthesize \nmore viable jungloids if we apply a transformation that generalizes our example jun\u00adgloids. However, \nwe must take care not to overgeneralize to a suf.x that represents inviable jungloids. Consider the extreme \ncase of generalizing to a suf.x consisting of a single elementary jun\u00adgloid, the .nal downcast: this \nsuf.x represents all jungloids containing that downcast, most of which are inviable, as dis\u00adcussed in \nSection 4.1. Note that generalization is not the only source of inviable jungloids (e.g., one of the \noriginal examples might be inviable because of a bug in the corpus), but we do not want generalization \nto introduce more inviable jungloids. Thus, we de.ne the goal of generalizing an example jungloid J as \n.nding the shortest suf.x that does not represent inviable jungloids (other than inviable jungloids represented \nby J). We have devised an algorithm that approximates general\u00adization given a set of examples. The algorithm \nis based on our notion that the jungloid before the downcast determines which downcasts may succeed: \nthus, we .nd the shortest suf.x that is suf.cient to distinguish an example jungloid from other ex\u00adample \njungloids that end in different casts. Consider Figure 7. Since jungloids (b) and (c) end in different \ncasts, we must keep a long enough suf.x to distinguish them. The parts of the jun\u00adgloids in area III \nof the .gure match exactly, so we must retain area II and everything after it, but we do not need area \nI. The rule followed by the algorithm is as follows: If there are two example jungloids \u00df.a.a.(T ) and \n..b.a.(U ) where a = b and T = U, then we must retain a.a.(T ) and b.a.(U ) (a, b are elementary jungloids, \na, \u00df, . are jungloids, and T,U are types, and (T ) is a downcast elementary jungloid). The algorithm \n.nds the shortest suf.x that obeys all constraints. We implement this algorithm in time O(nk), where \nn is the number of elementary jungloids in the example set and k is the number of types that appear in \ncasts, by storing examples in a trie and removing subtries all of whose examples end in the same casts. \nIn the remainder of this subsection, we formally de.ne the set of jungloids represented by an example \njungloid and from this de.nition deduce the conditions required to guarantee that a suf.x truly is a \ngeneralization of the original example. Speci.cally, we show that if we form the jungloid graph from \nthe signature graph and some suf.x of every example jungloid, each suf.x represents all of the jungloids \nrepresented by the example it was derived from and is thus a generalization. For brevity, we write jungloids \nas sequences, with variables a, b, c ranging over elementary jungloids, a, \u00df, ., d over jun\u00adgloids, and \nS, T, U over classes. A downcast elementary jun\u00adgloid is written (T ). The composition that feeds the \noutput of jungloid a to the input of jungloid \u00df is written a.\u00df. The input type of a jungloid a is denoted \nin(a), and the output type is denoted out(a). First, we de.ne the set of jungloids represented by an \nex\u00adample jungloid, which is simply the set of jungloids formed by composing the example jungloid with \nanother jungloid. To make this de.nition precise, we must specify the set of jun\u00adgloids that can be composed \nwith the example. For now, simply let the set be an arbitrary set E, and de.ne the set of jungloids represented \nby an example jungloid J as: def repE (J)= {d.J |d .Eandout(d)=in(J)} Now can de.ne generalization: J' \nis a generalization of J if repE (J').repE (J). Now, we will determine the conditions under which a suf.x \nJ is a generalization of J by trying to show that repE (J'). repE (J)in the process discovering what \nconditions are re\u00adquired to .nish the argument. Let J be an example jungloid ending in a cast and J' \na non-empty suf.x of J, so that J =a.\u00df.(U)and J' =\u00df.(U). Substituting the expressions for J and J' into \nthe de.nition of repE ,wehave: repE (J)= {d.a.\u00df.(U)|d .Eandout(d)=in(a)} repE (J')= {d.\u00df.(U)|d .Eandout(d)=in(\u00df)} \nConsider any d.a.\u00df.(U) . repE (J). To show that d.a.\u00df.(U).repE (J'), we must show (i) out(d.a)=in(\u00df) \nand (ii) d.a .E. For (i), observe that a.\u00df is a jungloid, so out(a)=in(\u00df)and thus out(d.a)=in(\u00df)as well. \nIf we can also show (ii), then d.a.\u00df.(U).repE (J), and therefore repE (J') . repE (J). To complete this \nargument, we need only to show (ii) d.a .E. Because we know little about about a and E, we will need \nto introduce some additional assump\u00adtions. We can gain some insight about these assumptions by rea\u00adsoning \nat the level of the original jungloid generalization prob\u00adlem: informally, we are simply trying to ensure \nthat there is a jungloid in Ethat can be composed with J' to form J, so that we do not lose any jungloids \nby using J' instead. First, con\u00adsider the simplest case, where J contains no downcasts other than the \none at the end. In this case, we can form J by com\u00adposing J' with a jungloid in the signature graph. \nWe can state this more generally: assuming that Econtains all jungloids rep\u00adresented by the signature \ngraph, if a (from above) contains no downcasts, then d.a contains no downcasts, d.a is represented by \nthe signature graph, and d.a .E. Thus, if we restrict our generalization so that J' contains all the \ndowncasts in J (so that a contains no downcasts), then J' is a generalization of J if Econtains all jungloids \nrepresented by the signature graph. Now, consider the case where a contains a downcast. Then a is not \ncontained by the signature graph, so we must try to cover a using other example jungloids. Because our \nexam\u00adple jungloids end in downcasts, we break down a as a = a1.(V ).a2 such that a2 has no casts, so \na2 is represented by the signature graph. a1.(V )ends in a cast, and our example jungloid extraction \n.nds jungloids going backward from every cast in the corpus, so our set of example jungloids must contain \na1.(V ). Now, we are trying to show that d.a1.(V ).a2 .E, where d .E, a1.(V )is in our set of example \njungloids, and a2 is in the signature graph. Thus, J' is guaranteed to be a generalization of J if Econtains \nthe jungloids in the signature graph and the extracted example jungloids and is closed under composition, \ni.e., if .1 .E, .2 .E, and out(.1)=in(.2), then .1..2 .E. This is not quite the condition we want because \nwe gener\u00adalize all example jungloids, so the Ewe actually use contains the jungloids in the signature \ngraph and some suf.x of every example jungloid, and is closed under composition. However, this Eis suf.cient \nas well, because we can show that for a .E for any example jungloid J =a.\u00df by strong induction on the \nnumber of casts in a. In the base case, a has no casts, so a is in the signature graph, and thus a .E. \nIn the inductive case, a has n +1casts. Write a = a1.(V ).a2, where a2 has no casts. Now, a1.(V )was \nextracted from the corpus as part of a, and we extract example jungloids from every cast in the corpus, \nso our set of examples contains a1.(V )as well. Because Econtains some suf.x of this example, we can \nwrite a1.(V )=a'1...(V )where ..(V ).E. The number of casts in a'is at most n, so by the inductive hypothesis, \na'.E. 11 As already stated, ..(V ).E, and a2 .Ebecause a2 has no casts. Therefore, a =a'1...(V ).a2 .E. \n 4.3 Other applications of jungloid mining Downcasts are not the only API feature that cannot be handled \nwell by the signature graph. In particular, for methods with input arguments of type Object or String, \nusually not any Object or String is acceptable. For example, some meth\u00adods in Eclipse take as input model \nclasses, which are classes that represent data underlying a visual component, such as a class hierarchy \nbrowser. To make the interface more .exible, Eclipse allows model classes to be of any type, so the method \nparameters are declared as Object. Thus, although the decla\u00adration suggests that any object may be used \nas input, we would like to synthesize only jungloids that use objects of appropriate model classes as \ninput. Many String method parameters have similar restrictions, e.g., the string should be a URL. As \na re\u00adsult, many jungloids that call methods with Object or String parameters are inviable. We believe \nthat jungloid mining can be used to .nd viable jungloids that end by calling these methods, although \nwe have not tested this application of jungloid mining. The algorithms would be the same, with methods \nhaving Object or String parameters playing the role of downcasts. 4.4 Accuracy of jungloid mining This \nsection discusses the accuracy of mining-based jungloid synthesis. We have two desired accuracy properties. \nFirst, we want jungloid synthesis to be complete, by which we mean that any viable jungloid can be synthesized \nas a solution jungloid. Second, we want synthesis to be precise, by which we mean that inviable jungloids \nare not synthesized. Because the synthe\u00adsis results depend entirely on the set of jungloids represented \nby the jungloid graph, we can restate these properties in terms of the graph: a complete graph contains \nall viable jungloids, and a precise graph contains only viable jungloids. These prop\u00aderties are too strict \nto satisfy, or even verify. However, the jun\u00adgloid graph does in fact approach these properties as the \ncorpus and mining extraction algorithm approach certain ideal condi\u00adtions. We will .rst discuss these \nproperties for mining without generalization, and then we will extend our analysis to cover mining with \ngeneralization. Without generalization. The jungloid graph is complete if the corpus contains all viable \njungloids that end in casts. The jungloid graph is as precise as the corpus and the under\u00adlying jungloid \nextraction algorithm. That is, inviable jungloids are added to the jungloid graph only if (a) the corpus \nmay throw ClassCastException (usually indicating a bug), or (b) the extraction algorithm .nds jungloids \nthat correspond to infeasi\u00adble paths. Our extraction algorithm can follow infeasible paths because it \nis .ow-insensitive and because it conservatively ap\u00adproximates the call graph. As would be expected, \na large corpus with many usage ex\u00adamples leads to a complete jungloid graph, and a precise (i.e., not \nbuggy) corpus and extraction algorithm lead to a precise jungloid graph. In practice, the corpus may \nnot be large enough to closely approximate completeness, necessitating generaliza\u00adtion. With generalization. \nMining with generalization yields a complete jungloid graph if (i) the corpus contains some viable suf.x \nof every viable jungloid that ends with a cast, and (ii) the extracted examples do not contain inviable \njungloids (be\u00adcause of corpus bugs or extraction imprecision) that share a suf.x with a viable jungloid \nbut end with a different cast. The .rst condition simply states that all the desired examples are present \nin the corpus. The second condition illustrated by this example: 1 (T) a.getB().getP() // viable 2 (U) \na.getC().getQ() // viable 3 (U) a.getD().getP() // inviable Assume that the jungloid (T) b.getP() is \nalso viable, which means we wish to generalize example 1 to (T) b.getP(), which we will do if the example \nset contains only examples 1 and 2. If the example set contains all three jun\u00adgloids, then generalization \nwill not generalize example 1, in order to distinguish its cast from example 3. Condition (i) is roughly \nequivalent to requiring that the corpus contain an ex\u00adample of each API usage ending in a cast. This \ncondition is reasonable because a corpus could very well contain all the short viable suf.xes of jungloids \nthat end in casts, and we have not observed very long jungloids to be the desired answers for a user \nquery. Condition (ii) is dif.cult to characterize, but we do not expect it to be a major issue. Mining \nwith generalization is as precise as mining without generalization on the same corpus if (a) the corpus \ncontains some viable suf.x of every viable jungloid that ends with a cast and (b) for every jungloid \nending with a downcast a.a.(T ) that is minimal (i.e., no proper suf.x is viable), there is some viable \njungloid b.a.(U ). Condition (a) is the same as for com\u00adpleteness. Condition (b) is a technical property \nof the API that prevents overgeneralization, as shown by these example jun\u00adgloids: 1 (T) a.getB().getP() \n// viable 2 (U) a.getC().getP() // may be viable or inviable Assume that example 1 is minimal. If example \n2 is present in the corpus, example 1 will not be generalized further, which is correct. However, if \nexample 2 is not present, then example 1 will be imprecisely generalized to (T) b.getP(). Example 2 could \nfail to be present because of a violation of either condition (a), with the corpus simply not containing \nexample 2, or condition (b), with the API disallowing example 2. This might happen if T is the sole subclass \nof P (the return type of getP()) and getP() returns a T only when called in the jungloid getB().getP(). \nWe expect such situations to be rare.  5. Implementation The core of our implementation is a representation \nof the jun\u00adgloid graph and a library for searching the graph and synthe\u00adsizing code from paths. We have \ndeployed the implementation in several environments: a test harness, an web demonstration, and the PROSPECTOR \nprogramming tool. PROSPECTOR itself is an Eclipse plugin that integrates jun\u00adgloid synthesis results \nwith Eclipse Java content assist. Content assist is a feature that the user can invoke while typing code \nto get suggestions for what to type next. Content assist can also in\u00adsert a selected suggestion automatically. \nFor example, standard content assist can complete variable names or suggest methods that can be called \non a given variable. PROSPECTOR extends content assist to suggest jungloids that output a value of type \ntout required by the code surrounding the point of the cursor, which we call the context. Our current \nimplementation invokes jungloid synthesis for two contexts, variable initializers (Type var = |, where \n| indicates cursor position) and the right-hand sides of assign\u00adment statements (var = |). The type of \nthe variable assigned is taken as tout. The set of types of variables visible at the cur\u00adsor point is \nused as a set of tin classes. Conceptually, we run one query per tin class. The implementation actually \nruns all queries at once by using multiple starting points in its graph search, which takes approximately \nthe same amount of time as running a single query. We conclude this section with some performance measure\u00adments. \nAll times were recorded on a 2.26 GHz Pentium 4 with 1 GB RAM. The graph representation occupies 8 MB \nof space on disk and 24 MB when loaded into memory. Loading the graph takes 1.5 seconds. Table 1 gives \nthe time taken to process a variety of queries. All queries were answered in under 1.1 seconds, and 85% \nof were answered in under 0.5 seconds. It should be noted that for these tests we con.gured the graph \nsearch library to construct all paths of length less than or equal to m +1where m is the length of the \nshortest path for the query. We used the same con.guration for the experiments de\u00adscribed in Section \n6. We used this particular setting because we found it to balance speed and quantity of paths found. \nHaving this particular con.guration parameter is a detail of how we implemented the k-shortest-paths \nsearch and is not required by our techniques in general. 6. Experiments We performed two experiments: \na test of PROSPECTOR s query processing engine, and a study of the performance of develop\u00aders using PROSPECTOR. \nQuery Processing. The query processing test measures whether PROSPECTOR can solve programming problems \nthat can be expressed as jungloid queries. In this test, we collected a set of programming problems, \nand for each problem, expressed it as a jungloid query, ran the query, and read the results in or\u00adder \nuntil we found a jungloid that gave the desired solution to the problem. The desired solution was de.ned \nas the most concise, ef.cient solution possible as judged by a human pro\u00adgrammer. This test measures \nboth whether PROSPECTOR can synthesize the desired answer, and how many jungloids a pro\u00adgrammer needs \nto read to .nd the answer. The underlying fac\u00adtors necessary to achieve good results are query speci.city \nand accurate ranking. The main dif.culty with this experiment is selecting the set of test problems. \nThe ideal set would be obtained by distrib\u00aduting a production-quality implementation and recording what \nqueries are run by real developers. We approximated a sam\u00adple of this set by collecting 20 problems that \nwe encountered during our own development, found in the Eclipse FAQs [3] or on javaalmanac.com, an online \nJava programming resource, or were reported to us by PROSPECTOR testers. When we se\u00adlected the problems, \nwe knew that they could be expressed as jungloid queries, but we did not know whether PROSPECTOR could \nsolve them. Note that we cannot say what fraction of pro\u00adgramming problems can be expressed as jungloid \nqueries, be\u00adcause programming problem is not a precisely de.ned con\u00adcept, but we can say that 12 of 16 \nproblems that we encoun\u00adtered when trying to write code in order to reuse a library were expressible \nas jungloid queries. User Study. The user study measures whether developers .nish programming tasks involving \nreuse more reliably and quickly when they use PROSPECTOR. To measure this, we de\u00adsigned a set of four \nprogramming problems that can be solved by reuse and assigned them to a group of test users. Each user \nattempted two problems without using PROSPECTOR and two problems with PROSPECTOR. We assigned the problems \nto be solved using PROSPECTOR randomly to each user. We recorded the users answers and the time spent \non each prob\u00adlem. We manually classi.ed the answers as being correct based on reuse, correct without \nreuse (i.e., reimplementing), and in\u00adcorrect. We provided each user a tutorial brie.y explaining when \nand how to use PROSPECTOR. We did not provide a hands\u00adon training session. No other training was provided, \nand none of the users had ever used PROSPECTOR before performing the study. The users were a mixture \nof undergraduates who had taken at least one course involving Java programming, TopCoder Java programmers, \nand graduate students. The programming problems were designed to somewhat vague, in order to approximate \nreal programming. For some of the problems, we did not give the users the desired output type. The experiment \ntests whether users are able to identify an opportunity to use PROSPECTOR, identify the desired output \ntype, understand the query results, and select the best result. As noted in Section 5, users do not need \nto specify input types explicitly. Here are the problems we assigned for the user study: Problem 1. \nIn Java 1.2, Enumeration was depre\u00adcated in favor of Iterator. An old Java API, written be\u00adfore Java \n1.2, has returned an Enumeration. Convert itto an Iterator. (Can be answered by the query (Enumeration, \nIterator).)  Problem 2. The Java API supports reading URLs as if they were .les. Java also has support \nfor playing sound .les or audio clips. I want to play a sound .le at a par\u00adticular URL: String url. (Can \nbe answered by the query (String, AudioClip).)  Problem 3. In Eclipse, the visual representation of \neditors \u00adthe actual window you see on the screen -are represented by subclasses of IEditorPart. For example, \nthe Java editor which edits Java .les is called JavaEditor. Often times in plugins you want to retrieve \nthe currently active editor. How do I get the editor part that represents the active editor from IWorkbench \n(which represents the entire UI)? (Can be answered by the query (IWorkbench, EditorPart).)  Problem \n4. Often Eclipse plugins use common images, which are placed in a shared image class, and ex\u00adposed to \nother plugins. One example is the menu im\u00adages that are shown in Eclipse menus. I want to get an image \nfrom the shared image cache, which is of type ImageRegistry. (Can be answered by the query (IWorkbench, \nImageRegistry).)   7. Experimental Results The results of the query processing accuracy test are shown \nin Table 1. PROSPECTOR found the desired answer to 18 of the 20 queries, and in each case the programmer \nhad to look at fewer than 5 jungloids to .nd the correct answer. In 11 cases, the desired jungloid was \n.rst on the list. The query (IWorkspace, IFile),forwhich PROSPECTOR did not .nd the desired answer, reveals \na limitation of our tech\u00adniques. The classes referred to by that jungloid are connected by many methods, \nso there are a large number of similar par\u00adallel jungloids, crowding out the desired jungloid from the \ntop of the results. Future work may be able to solve this problem by identifying clusters of similar \njungloids and presenting to the user only one representative of the cluster. PROSPECTOR failed to .nd \nthe answer for one other query, (AbstractGraphicalEditPart, ConnectionLayer), be\u00adcause the desired jungloid \nincludes a call to a protected method, and our current implementation supports only public methods. To \nhandle protected methods, we would only need to determine what protected methods are visible at the point \nof the cursor and allow synthesis to use those methods. Figure 8 shows the time taken by each programmer \non each problem in the user study. In every problem except Problem 4, PROSPECTOR users on average .nished \nthe problem twice as fast as the baseline users. The study is not large enough to measure the difference \nwith statistical signi.cance, but the averages and the distributions shown in the chart suggest that \nPROSPECTOR often helps users solve problems faster. In fact, we also found that individual users usually \nsolved their own problems faster when using PROSPECTOR. Ideally, we would like to compare how long a \ngiven user takes to solve the same problem with PROSPECTOR and without, but of course this is impossible. \nInstead, we simply compared the time Programming problem tin tout Time (s) Rank Read lines from an input \nstream (Tester) InputStream BufferedReader 0.32 1 Open a named .le for memory-mapped I/O (Al- String \nMappedByteBuffer 0.17 1 manac) Get table widget from an Eclipse view (FAQs) TableViewer Table 0.04 1 \nGet the active editor (Eclipse FAQs) IWorkbench IEditorPart 0.16 1 Retrieve canvas from scrolling viewer \n(Author) ScrollingGraphicalViewer FigureCanvas 0.08 1 Get window for MessageBox (Author) KeyEvent Shell \n0.09 1 Convert legacy class (Author) Enumeration Iterator 0.06 1 Get selection from event (Author) SelectionChangedEvent \nISelection 0.02 1 Get image handle for lazy image loading ImageRegistry ImageDescriptor 0.08 1 Iterate \nover map values (Tester) Map Iterator 0.17 1 Add menu bars to a view (Eclipse FAQs) IViewPart MenuManager \n0.21 1 Set captions on table columns (Author) TableViewer TableColumn 0.37 2 Track selection changes \nin another widget (Eclipse IEditorSite ISelectionService 0.01 2 FAQs) Read lines from a .le (Almanac) \nString BufferedReader 0.17 3 Find out what object is selected (Eclipse FAQs) IWorkbenchPage IStructuredSelection \n0.15 3 Manipulate document of visual editor (Eclipse IWorkbenchPage IDocumentProvider 1.07 3 FAQs) Convert \n.le handle to .le name (Author) IFile String 0.11 4 Get an Eclipse view by name (Eclipse FAQs) IWorkbenchWindow \nIViewPart 0.61 4 Set graph edge routing algorithm (Author) AbstractGraphicalEditPart ConnectionLayer \n0.08 No Retrieve .le from workspace (Author) IWorkspace IFile 0.59 No Average Time 0.23 Table 1. Query \nprocessing experiment results. (tin, tout) is the query that was run to try to solve the problem. Time \nis the time in seconds taken by PROSPECTOR to return the query results. Rank is the rank of the desired \nsolution in the results, or No if not in the results. each user spent on his two problems with PROSPECTOR \nagainst the time he spent on his two problems without PROSPECTOR. We found that 10 of the 13 users were \nfaster using PROSPEC-TOR, with one user being 8 times as fast. Two users took the same amount of time \nwith PROSPECTOR and without. One user was 1.5 times slower when using PROSPECTOR: that user re\u00adported \nto us that he did not really understand how to use it until after completing the study.6 Note also that \nthe three users who were not faster with PROSPECTOR were all assigned to solve Problem 2, the hardest \nproblem, with PROSPECTOR, and Prob\u00adlem 1, the easiest, without. The average speedup over all users was \n1.9. An informal .nding was that on Problem 1 (converting an Enumeration to an Iterator), of 8 non-PROSPECTOR \nusers, only 2 found the expected, concise, ef.cient solution based on reusing a wrapper class, while \n3 found a less ef\u00ad.cient solution based on copying the elements into a list, and the last 3 reimplemented \na wrapper class. One program\u00admer reimplemented Iterator incorrectly: calling remove() silently fails, \nwhile the speci.cation requires the method ei\u00adther to remove an element or throw an exception indicating \nthat remove() is not implemented. While the user s solution still passed our test, in a real programming \nenvironment some other programmer might write buggy code by attempt to reuse the reimplementation according \nto the library speci.cation. In con\u00adtrast, all 5 PROSPECTOR users solved the problem with reuse. On \nProblem 2, one of the non-PROSPECTOR users copied Figure 8. Time spent coding in the performance study. \nHorizontal a large chunk of code found on the web. Another solved the lines indicate average and one \nstandard deviation intervals. 6 Other users also told us that they thought they understood how to use \nPROSPECTOR after the study. This suggests that solving three or four problems with PROSPECTOR is enough \nto learn how to use it. problem with reuse, but wrote much more code than the best solution required. \nAll PROSPECTOR users found the best solu\u00adtion for this problem. All users solved Problem 3 by reuse, \nbut 4 out of 7 non-PROSPECTOR solutions to question 3 exhibited the same sub\u00adtle bug, in which the code \nwould throw an exception if the cur\u00adrently highlighted window in Eclipse was not an editor. In our user \nstudy setup, users did not have the opportunity to test their answers to question 3, so in a real situation \nthey may have even\u00adtually found the correct solution, but testing could easily miss this bug. Even if \ntesting would have caught the bug, the users would have had to spend even more time .nding the correct \nsolution. In contrast, all of the PROSPECTOR users found the correct solution. On Problem 4, PROSPECTOR \nusers took approxi\u00admately the same length of time as non-PROSPECTOR users. Many non-PROSPECTOR users \nfound the jungloid workbench.getSharedImages().getImage(imgName), which can be found quickly without \nPROSPECTOR because it is short and consists of instance methods with easily under\u00adstood names. This jungloid \ndid not actually solve the problem we posed, which asked the users to use an ImageRegistry object in \ntheir solution, but we accepted it as a reasonable solution to the general problem posed.  8. Related \nWork There is a body of work on .nding reusable code based on declarative queries. We list a only a selection \nof papers in this area. One major area of this work is signature matching, which .nds reusable units \nsuch as classes or methods that match a sig\u00adnature given by the user. Rittri s signature matching [10] \n.nds ML library functions that closely match a signature, allowing variations in the order of arguments \nand other minor aspects. Zaremski and Wing [18] de.ne a more general query language for ML signature \nmatching consisting of composable operators and extend matching to cover modules. Stringer-Calvert [11] \napplies signature matching to Ada. Ye and Fisher s CodeBro\u00adker [16] .nds Java classes and methods using \nsignature match\u00ading as well as textual similarity of comments. Other areas .nd reusable units based on \ncomplete speci.cations [19]. All of the preceding share the common features of a query language and a \nsystem that .nds complete units, such as func\u00adtions or classes, that match the query. Our work has a \nquery language as well that is similar to a function signature. Our re\u00adsults are different: jungloids \nare snippets of code, which may be complete units, extracted examples, or synthesized code. Ko, Myers, \nand Aung [6] provide a classi.cation of barriers to learning programming system that helps explain how \nthe prob\u00adlem we solve is different from that of the preceding work. Sig\u00adnature matching and related work \nfocus on selection barriers, where the user knows what he wants to do but doesn t know which unit to \nselect. Our work attacks two other barriers. First, we help the user get past use barriers, which occur \nwhen he has selected the correct unit but does not know how to use it. In lan\u00adguages such as Java, once \nthe user passes a selection barrier by selecting the right class, he often encounters a use barrier be\u00adcause \nthe class requires special con.guration. Second, we help with coordination barriers, where the user knows \nwhat units to use, but not how to make them work together. These barriers are common in large systems \nbuilt from several frameworks and libraries. There is some related work on the coordination problem. \nThe Demeter Project [8, 9] designed a programming environ\u00adment that allowed the user to write a PROSPECTOR-like \nquery as part of the source code and would generate code to traverse the object schema accordingly. Yellin \nand Strom [17] show how to generate adapters to connect components with de.ned temporal interfaces that \nare semantically compatible but syn\u00adtactically incompatible. These papers and our work both try to generate \ncode to connect program units, but the kinds of code are completely different, and also our work does \nnot rely on any speci.cations outside of the source code. At a higher level, the problem is that reusable \ncomponents such as classes are dif.cult for programmers to con.gure and connect, and PROSPECTOR solves \nthis problem by generating the needed code. Other work solves the same problem by creat\u00ading a high-level, \ndeclarative, domain-speci.c language (DSL) and a compiler that con.gures and connects components ac\u00adcording \nto the program. There has been much work in this area, such as Amphion [13]. Turning to the technology \nenabling PROSPECTOR, mining the jungloid graph is related to work on extracting models from source code. \nWhaley, Martin, and Lam [15] and Alur et al. [1] extract temporal interfaces from Java source code by \nstatic analysis rather than mining. Jungloid mining is related to backward slicing [14, 4, 5] and program \ndependence graphs (PDGs), because a jungloid is like a single data-.ow path from a PDG. Also, PDGs have \nbeen used to extract procedures from code [7]. This is related to jun\u00adgloid extraction, but the extracted \nprocedures contain control .ow, which jungloids do not. Also, the extracted procedure is used directly, \nour extracted jungloids are combined with other sources of information to make other jungloids. Because \nPDGs can be general graphs, unlike jungloids, which have a linear shape, PDGs can represent some data-.ow \nstructures that jungloids cannot, namely converging data-.ow paths as in (T) f(g(a),h(a)), where this \nis an example of code using an API that constrains both arguments to come from the same a. We have found \nthese structures to be uncommon for the APIs for which we are trying to mine code, so we used jungloids, \nwhich are simpler, and thus easier to represent and search in a graph. Finally, authors of this paper \nhave done previous work on mining temporal speci.cations for APIs from sample client code with Strauss \n[2]. This work includes mining, but there are substantial differences: Strauss learn temporal speci.cations \nfrom dynamic slices, while PROSPECTOR learns jungloids, which are simpler and hence can be handled more \neffectively with simpler algorithms. 9. Conclusion This paper described jungloids, which often need \nto be written in order to reuse code, but are dif.cult to write. We described techniques for automatically \n.nding jungloids in response to user queries. We implemented these techniques in a tool, which was shown \nto be effective in experimental tests.  Acknowledgements We thank Mark Wegman for discussion and comments, \nand Brian Fields, AJ Shankar, and Manu Sridharan for comments on drafts of this paper and helping test \nPROSPECTOR. References [1] R. Alur, P. .y, P. Madhusudan, and W. Nam. Synthesis of interface Cern\u00b4 speci.cations \nfor java classes. [2] G. Ammons, R. Bod\u00b4ik, and J. Larus. Mining speci.cations. ACM SIGPLAN Notices, \n37(1):4 16, Jan. 2002. [3] J. Arthorne and C. Laffra. Of.cial Eclipse 3.0 FAQs. Addison-Wesley Professional, \n2004. [4] J. Ferrante, K. J. Ottenstein, and J. D. Warren. The program dependence graph and its use in \noptimization. ACM Trans. Program. Lang. Syst., 9(3):319 349, 1987. [5] S. Horwitz and T. Reps. The use \nof program dependence graphs in software engineering. In Proceedings of the 14th international conference \non Software engineering, pages 392 411. ACM Press, 1992. [6] A. J. Ko, B. A. Myers, and H. H. Aung. Six \nlearning barriers in end-user programming systems. [7] R. Komondoor and S. Horwitz. Effective, automatic \nprocedure extraction. In Proceedings of the 11th IEEE International Workshop on Program Comprehension, \npage 33. IEEE Computer Society, 2003. [8] K. J. Lieberherr. Component enhancement: An adaptive reusability \nmechanism for groups of collaborating classes. In J. van Leeuwen, editor, Information Processing 92, \n12th World Computer Congress, pages 179 185, Madrid, Spain, 1992. Elsevier. [9] K. J. Lieberherr, W. \nH\u00a8ursch, I. Silva-Lepe, and C. Xiao. Experience with a graph-based propagation pattern programming tool. \nIn G. F. et al., editor, International Workshop on CASE, pages 114 119, Montr\u00b4eal, Canada, 1992. IEEE \nComputer Society. [10] M. Rittri. Retrieving library identi.ers via equational matching of types, Jan. \n24 1997. [11] D. W. Stringer-Calvert. Signature Matching for Ada Software Reuse. Master of engineering, \nDepartment of Computer Science, University of York, Mar. 1994. [12] R. E. Strom and S. Yemini. Typestate: \nA programming language concept for enhancing software reliability. IEEE Trans. Softw. Eng., 12(1):157 \n171, 1986. [13] J. van Baalen, P. Robinson, M. R. Lowry, and T. Pressburger. Ex\u00adplaining synthesized \nsoftware. In Automated Software Engineering, pages 240 248, 1998. [14] M. Weiser. Program slicing. In \nProceedings of the 5th international conference on Software engineering, pages 439 449. IEEE Press, 1981. \n[15] J. Whaley, M. C. Martin, and M. S. Lam. Automatic extraction of object-oriented component interfaces, \nJuly 11 2002. [16] Y. Ye and G. Fischer. Supporting reuse by delivering task-relevant and personalized \ninformation. In Proceedings of the 24th International Conference on Software Engineering (ICSE-02), pages \n513 523, New York, May 19 25 2002. ACM Press. [17] D. M. Yellin and R. E. Strom. Protocol speci.cations \nand component adaptors. ACM Trans. Program. Lang. Syst., 19(2):292 333, 1997. [18] A. M. Zaremski and \nJ. M. Wing. Signature matching: a tool for using software libraries, July 22 1996. [19] A. M. Zaremski \nand J. M. Wing. Speci.cation matching of software components, Dec. 11 1997.  \n\t\t\t", "proc_id": "1065010", "abstract": "Reuse of existing code from class libraries and frameworks is often difficult because APIs are complex and the client code required to use the APIs can be hard to write. We observed that a common scenario is that the programmer knows what type of object he needs, but does not know how to write the code to get the object.In order to help programmers write API client code more easily, we developed techniques for synthesizing <i>jungloid</i> code fragments automatically given a simple query that describes that desired code in terms of input and output types. A jungloid is simply a unary expression; jungloids are simple, enabling synthesis, but are also versatile, covering many coding problems, and composable, combining to form more complex code fragments. We synthesize jungloids using both API method signatures and jungloids <i>mined</i> from a corpus of sample client programs.We implemented a tool, <sc>prospector</sc>, based on these techniques. <sc>prospector</sc> is integrated with the Eclipse IDE code assistance feature, and it infers queries from context so there is no need for the programmer to write queries. We tested <sc>prospector</sc> on a set of real programming problems involving APIs; <sc>prospector</sc> found the desired solution for 18 of 20 problems. We also evaluated <sc>prospector</sc> in a user study, finding that programmers solved programming problems more quickly and with more reuse when using <sc>prospector</sc> than without <sc>prospector</sc>.", "authors": [{"name": "David Mandelin", "author_profile_id": "81100521702", "affiliation": "University of California, Berkeley", "person_id": "P517403", "email_address": "", "orcid_id": ""}, {"name": "Lin Xu", "author_profile_id": "81100196158", "affiliation": "University of California, Berkeley", "person_id": "PP31031605", "email_address": "", "orcid_id": ""}, {"name": "Rastislav Bod&#237;k", "author_profile_id": "81100033082", "affiliation": "University of California, Berkeley", "person_id": "P517421", "email_address": "", "orcid_id": ""}, {"name": "Doug Kimelman", "author_profile_id": "81100165368", "affiliation": "IBM Corporation", "person_id": "P69495", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1065010.1065018", "year": "2005", "article_id": "1065018", "conference": "PLDI", "title": "Jungloid mining: helping to navigate the API jungle", "url": "http://dl.acm.org/citation.cfm?id=1065018"}