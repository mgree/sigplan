{"article_publication_date": "01-01-2002", "fulltext": "\n The First-Order Theory of Subtyping Constraints Zhendong Su* Alexander Aiken* Joachim Niehren Tim Priesnitz \nComputer Science Division Programming Systems Lab University of California Universit\u00a8at des Saarlandes \nBerkeley, CA 94720 Saarbr\u00a8ucken, Germany http://www.cs.berkeley.edu/~{zhendong,aiken} http://www.ps.uni-sb.de/~{niehren,tim} \n Ralf Treinen LRI, Universit\u00b4e Paris-Sud F91405 Orsay cedex, France http://www.lri.fr/~treinen Abstract \nWe investigate the .rst-order theory of subtyping con\u00adstraints. We show that the .rst-order theory of \nnon\u00adstructural subtyping is undecidable, and we show that in the case where all constructors are either \nunary or nullary, the .rst-order theory is decidable for both structural and non\u00adstructural subtyping. \nThe decidability results are shown by reduction to a decision problem on tree automata. This work is \na step towards resolving long-standing open problems of the decidability of entailment for non-structural \nsubtyping. 1 Introduction In this paper we present the .rst decidability and undecid\u00adability results \nfor the .rst-order theory of subtyping. Before describing our results, we begin with a capsule history \nof subtyping, which motivates the .rst-order theory of subtyp\u00ading as an interesting topic to study. Since \nthe original results of Mitchell [24], type check\u00ading and type inference for subtyping systems have received \nsteadily increasing attention. The primary motivations for studying these systems today are program analysis \nalgo\u00adrithms based on subtyping (see, for example, [2, 5, 14, 16, 22, 31, 37]) and, more speculatively, \nricher designs for typed languages ([29]). Subtyping algorithms invariably involve systems of sub\u00adtype \nconstraints t1 = t2, where the ti are types that may * This research was supported in part by the National \nScience Foundation grant No. CCR-0085949 and NASA Contract No. NAG2\u00ad1210. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or dis\u00adtributed for pro.t or commercial advantage and that copies bear this \nnotice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers or \nto redistribute to lists, requires prior spe\u00adci.c permission and/or a fee. POPL 02, Jan. 16-18, 2002 \nPortland, OR USA c&#38;#169; 2002 ACM ISBN 1-58113-450-9/02/01...$5.00 contain type variables. There \nare two interesting questions we can ask about a system of subtyping constraints C: 1. Does C have solutions \n(and what are they)? 2. Does C imply (or entail) another system of constraints  C'? That is, is every \nsolution of C also a solution of C'? For (1), the basic algorithms for solving many natural forms of \nsubtyping constraints are by now quite well un\u00adderstood (e.g., see [36]). For (2), there has been much \nless progress on subtype entailment, although entailment is as important as constraint resolution in \napplications of subtyp\u00ading. For example, a type-based program analysis extracts some system of constraints \nC from a program text; these constraints are the model of whatever program property is being analyzed. \nA client of the analysis (e.g., a program optimization system) interacts with the analysis by asking \nqueries: Does a particular constraint t1 = t2 hold in C? Or in other words, does C entail t1 = t2? As \nanother example, in designing a language with expressive subtyping relation\u00adships, checking type interfaces \nalso reduces to a subtype en\u00adtailment problem. While no mainstream language has such expressive power \ntoday, language researchers have encoun\u00adtered just this problem in designing languages that blend ML-style \npolymorphism with object-oriented style subtyp\u00ading, which leads to polymorphic constrained types (see, \nagain, discussion in [29]). There are two natural choices of subtype relation in the literature. Structural \nsubtyping requires that types have ex\u00adactly the same shape read as trees, t1 = t2 cannot hold unless \nthe corresponding branches of t1 and t2 are equal in length. For example if a = b in the subtype ordering, \nthen C(a, a) = C(b, b) for some covariant constructor C, but a = C(b, b). Non-structural subtyping has \nboth a least type . and a greatest type T, so that .= t =T for any t. More details on structural and \nnon-structural subtyping can be found in [4, 19, 24]. Despite extensive e.ort over many years, the exact \ncom\u00adplexity and even the decidability of entailment is open for non-structural subtyping constraints \n[3, 12, 13, 17, 18, 22, 27, 28, 33, 34, 36, 42]. As we show in Section 2, the natural versions of entailment \nand subtyping constrained types can be encoded easily in the .rst-order theory of subtyping, so to gain \ninsight into and take a step towards resolving these di.cult problems, we study the full .rst-order theory \nin this paper. The major contributions of this paper are summarized as follows: We show that the .rst-order \ntheory of non-structural subtyping constraints is undecidable via a reduction from the Post s Correspondence \nProblem (PCP). The result is shown for both simple and recursive types (Theorems 7 and 9). The result \nholds also for in.\u00adnite trees. In addition, this result yields a technical separation of structural subtyping \nand non-structural subtyping (Theorem 10).  We show that the .rst-order theory of subtyping con\u00adstraints \nwith unary function symbols is decidable by an automata-theoretic construction. This result holds for \nall combinations of the structural versus non\u00adstructural, and simple versus recursive cases (Theo\u00adrem \n17).  The automata-theoretic construction bridges tree au\u00adtomata theory and subtyping problems, suggesting \nan alternative way of tackling the problems (see Sec\u00adtion 5.3 for a discussion).  We leave open the \ndecidability of the full .rst-order the\u00adory of structural subtyping. We .rst present background information \non subtyping (Section 2), and show that the .rst-order theory of non\u00adstructural subtyping entailment \nis undecidable (Section 3). Next we give an automata-theoretic construction for sub\u00adtyping constraints \nand show that the .rst-order theory of subtyping constraints with unary function symbols is decid\u00adable \n(Section 5). We then discuss related work (Section 6) and conclude (Section 7). An example encoding of \nan en\u00adtailment problem is given in Appendix A. 2 Subtyping Constraints and Their First-Order Theories \nWe present an overview of subtyping systems and introduce the problems we consider in this paper. 2.1 \nPreliminaries on Subtyping Subtyping systems are generalizations of the usual equality\u00adbased type systems \nsuch as the Hindley/Milner type system of ML [23]. We consider the following type language t ::= .|T| \na | t1 . t2 | t1 \u00d7 t2 where . and T are the smallest and largest type respectively, a is chosen from \na countable set of type variables V, . is the function type constructor, and \u00d7 is the product type constructor. \nTypes in this language form a lattice with the following ordering .= t =T, for any t ; ''' ' t1 . t2 \n= t1 . t2 i. t1 = t1 and t2 = t2, for any types t1, t2, t1' , and t2' ; ''' ' t1 \u00d7 t2 = t1 \u00d7 t2 i. t1 \n= t1 and t2 = t2, for any types t1, t2, t1' , and t2' . This is the non-structural ordering on types, \nsince related types need not have the same shape, e.g., .=..T. The corresponding notion of structural \nordering requires two types to be related only if they have the same shape. In structural ordering, there \nis no smallest or largest type. Another dimension is whether a type language allows recursive types, \ni.e., in.nite types which are solutions to recursive type equations such as a = a ... Recursive types \nare interpreted over regular trees, which are possibly in.nite trees with .nitely many subterms. We also \nconsider general in.nite trees. We write T (F) to denote the set of .nite ground types (types without \nvariables), where F is the alphabet {., T, \u00b7.\u00b7, \u00b7 \u00d7 \u00b7} The set T (F, V) denotes the set of all types \nbuilt with vari\u00adables drawn from V. A subtype constraint is an inequality of the form t1 = t2.A subtype \nconstraint system is a .nite set of subtyping constraints. When clear from context, we drop subtype and \njust say a constraint or a constraint system. For a constraint system C, the type variables in C are \ncalled the free variables of C, denoted fv(C). A valuation . is a function mapping type variables V to \nground types T (F). A valuation . is sometimes referred to as a ground substitution. As is standard, \nwe extend val\u00aduations homomorphically to substitutions from T (F, V) to T (F). A valuation . satis.es \na constraint t1 = t2, written . . t1 = t2 if .(t1) = .(t2) holds in the lattice T (F). A valuation . \nsatis.es a constraint system C, written . . C, if . satis.es all the constraints in C. A constraint system \nC is satis.able if there is a valuation . such that . . C. The set of valuations satisfying a constraint \nsystem C is the solution set of C, denoted by S(C). We denote by S(C) |E the set of solutions of C restricted \nto a set of variables E. The satis.ability problem for a constraint language is to de\u00adcide whether a \ngiven system of constraints is satis.able. It is well-known that the satis.ability of a constraint system \ncan be decided in polynomial time by a test for consistency of the given constraint set according to \na set of syntactic rules [20, 30, 33]. Corresponding to polymorphic type schemes in Hind\u00adley/Milner style \ntype systems, polymorphic subtype systems have so-called constrained types, in which a type is restricted \nby a system of constraints [1, 3, 42]. An ML style poly\u00admorphic type can be viewed as a constrained type \nwith no constraints. For example, a . \u00df\\{a = int . int, int . a = \u00df} is a constrained type. Let t \\C \nbe a constrained type, and let . be a satisfying valuation for C. The ground type .(t ) is called a instance \nof t \\C. There are a few important problems associated with con\u00adstrained types in polymorphic subtype \nsystems. In practice, constrained types can be large and compli\u00adcated. Thus it is important to simplify \nthe types [12, 22, 33] to make the types and the associated constraints smaller. Type and constraint \nsimpli.cation is related to the following decision problem of constraint entailment: A constraint system \nC entails a constraint t1 = t2, written C . t1 = t2, if for every satisfying valuation . of C, we have \n. . t1 = t2. The notion of existential entailment, written C1 F .E.C2, is a more powerful notion of \nentailment.1 The entailment holds if for every valuation . F C1, there exists a valuation . ' F C2 such \nthat . and . ' agree on variables fv(C2) \\ E. We assume w.l.o.g. that fv(C1) n E = \u00d8. This notion is \ninteresting because usually for a constrained type, we are only interested in variables appearing in \nthe type, and there are often many internal variables in the constraints we may wish to eliminate. This \nnotion of entailment allows more powerful simpli.cation and is likely to be more expensive.  In polymorphic \nsubtype systems, we may need to de\u00adtermine whether one constrained type is a subtype of another constrained \ntype [42]. Let t1\\C1 and t2\\C2 be two constrained types. We wish to check whether t1\\C1 = t2\\C2 which \nholds if for every instance t of t2\\C2, there exists an instance of t ' of t1\\C1 such that t ' = t . \nWe assume w.l.o.g. that C1 and C2 do not have any variables in common. In addition, we can restrict t1 \nand t2 to variables because  t1\\C1 = t2\\C2 i. a\\(C1 .{a = t1}) = \u00df\\(C2 .{\u00df = t2}) where a and \u00df are \nfresh variables not in C1 or C2. Although extensive research has directed at these prob\u00adlems [3, 12, \n13, 17, 18, 22, 27, 28, 33, 34, 36, 42], their decidability has been open for many years. In this paper, \nwe present results on the .rst-order theory of subtyping con\u00adstraints, which we believe is a step in \nresolving these open problems.  2.2 First-Order Theory of Subtyping Constraints We .rst de.ne the .rst-order \ntheory of subtyping constraints. First-order formulae w.r.t. to a subtype language are: f ::= true | \nt1 = t2 |\u00acf | f1 . f2 |.x.f where t1 and t2 are type expressions and x is a .rst-order variable ranging \nover types. Notice that we do not need equality because = is anti-symmetric. As usual, for convenience, \nwe also allow disjunction ., implication . , and universal quanti.cation .. We write t1 i t2 for \u00ac(t1 \n= t2). A formula is quanti.er free if it has no quanti.ers. A formula is in prenex normal form if it \nis of the form Q1 ...Qn.f where Qi s are quanti.ers and f is a quanti.er free formula. We adopt the usual \nnotion of a free variable and a closed and open formula. We next show how the open entailment problems \ndis\u00adcussed in Section 2.1 .t in the .rst-order theory of subtyp\u00ading. 2.2.1 Entailment is in the .-Fragment \nThe universal fragment consists of all the closed formulae ..f, where . consists of a set of universal \nquanti.ers, and f is a quanti.er free formula. The entailment problem C F x = y is in the universal fragment. \nNotice that C is a conjunction of basic constraints 1 Existential entailment is also called restricted \nentailment, writ\u00adten C1 FE' C2, where E' = fv(C2) \\ E. and the entailment C F x = y holds i. the universal \nformula .x1,...,xn.(C . (x = y)) is valid, where the xi s are the variables free in C .{x = y}. 2.2.2 \nExistential Entailment is in the ..-Fragment The ..-fragment consists of all the closed formulae ...f, \nwhere f is a quanti.er free formula. Existential entailment C1 F .E.C2 is expressed by the following \nformula: .a1,...,an.(C1 ..E.C2) where the ai s are the variables in fv(C1) . (fv(C2) \\ E). Because we \nassume fv(C1) n E = \u00d8, there is an equivalent formula in the ..-fragment .a1,...,an..E.(C1 . C2)  2.2.3 \nSubtype Constrained Types is in the ..-Fragment Let a\\C1 and \u00df\\C2 be constrained types. We express a\\C1 \n= \u00df\\C2 as the formula .\u00df1,...,\u00dfn.(C2 ..a1,...,am.(C1 . a = \u00df)) where the ai s and \u00dfj s are the variables \nfree in C1 and C2 respectively. Because C1 and C2 have disjoint sets of variables (see de.nition of constrained \ntypes above), this is equivalent to .\u00df1,...,\u00dfn..a1,...,am.(C2 . (C1 . a = \u00df)) In fact, we can show that \nsubtype constrained types can be polynomially reduced to existential entailment. Proposition 1 Subtype \nconstrained types is polynomially reducible to existential entailment. Proof. We have the following equivalences \na\\C1 = \u00df\\C2 .{ by defn. of a\\C1 = \u00df\\C2 } S(C2) |{\u00df} . S(a = \u00df . C1) |{\u00df} .{ by defn. of existential \nentailment with E = fv(C1) } C2 F .E.(a = \u00df . C1) o 3 Undecidability of the First-Order Theory In this \nsection, we show that the .rst-order theory of non\u00adstructural subtyping is undecidable for any type language \nwith a binary type constructor and the bottom element . (or dually, the top element T). The formula we \nexhibit is in the ......-fragment. The proof is via a reduction from the Post s Correspon\u00addence Problem \n(PCP) [32] to a .rst-order formula of non\u00adstructural subtyping. Since PCP is undecidable [32], the .rst-order \ntheory of non-structural subtyping is undecidable as well. The proof follows the framework of Treinen \n[40] and is inspired by the proof of undecidability of the .rst-order theory of ordering constraints \nover feature trees [25]. Recall that an instance of PCP is a .nite set of pairs of words (li,ri) for \n1 = i = n. The words are drawn from the alphabet {1, 2}. The problem is to decide whether there is a \nnon-empty .nite sequence of indices s1 ...sm (where 1 = si = n for 1 = i = m) and the sequence constitutes \na pair of matched words: ls1 \u00b7\u00b7\u00b7 lsm = rs1 \u00b7\u00b7\u00b7 rsm where words are concatenated. For non-structural subtyping, \nwe consider both .nite types and recursive types. We .rst describe the subtype logic that we use. We \nconsider any subtype language with at least a bottom element . and a binary type constructor. We show \nthat for any such language, the .rst-order theory of non-structural subtype entailment is undecidable. \nFor the rest of the paper, we consider the simple expres\u00adsion language: t ::= .| f(t, t ) where f is \ncovariant in both of its arguments. It is straight\u00adforward to modify our construction to allow type construc\u00adtors \nwith contravariant .eld(s) and with arity greater than two. 3.1 Representing Words as Trees PCP is a \nword problem but types are trees. As a .rst step, we describe how to encode words in {1, 2} using types. \n3.1.1 Words as f-Spines We .rst describe how to represent words over {1, 2} as trees over a binary constructor \nf and the constant .. We use f\u00adspines to represent words. Intuitively, an f-spine is simply a tree with \na spine of f s and all other positions labelled .. De.nition 2 (f-Spine) A .nite tree t (in f and .) \nis an f-spine if there is exactly one maximal path with labels f . On this maximal path, a left child \nrepresents 1 and a right child represents 2. Example 1 (The word E) The empty word E is repre\u00adsented \nby the term f (., .). See Figure 1a. Example 2 (The word 1) The word 1 is represented by the term f(f(., \n.), .). See Figure 1b. Example 3 (The word 21221) The word 21221 is repre\u00adsented by the term f(.,f(f(.,f(.,f(f(., \n.), .))), .)). See Figure 1c. 3.1.2 Enforcing a Word Tree We want to enforce with a .rst-order formula \nof subtyping constraints that a tree t is an f-spine, i.e., that it represents a word w. Any f-spine \nt satis.es three properties: 1. Only f and . appear in t (Lemma 3). 2. There is exactly one maximal \npath of f s (Lemma 4). 3. t is not . (because . does not represent a word).  Lemma 3 A tree t contains \nonly f and . i. .x.((x = f(x, x)) . (t = x)) f \\ \\/\\2 / / . f \\ 1 /\\ f \\ / 1/ \\\\\\/ //f . f \\ \\2 / \\\\\\f \n. // \\ //\\\\/ /\\ //. f .. \\\\ .. /\\2 // . f \\ 1/ \\\\ // f . / \\\\\\ // .. (a) The word E. (b) The word 1. \n(c) The word 21221. Figure 1: Some example representations of words. Proof. Suppose t contains only f \nand .. Let h be the height of t, which is the length of the longest branch of t. The full binary tree \ns of height h where all the leaves are labelled . and all the internal nodes are labelled f satis.es \ns = f(s, s) and t = s. On the other hand, suppose for some s with s = f(s, s), we have t = s. It su.ces \nto show that s contains only f and .. For the sake of argument, assume on some shortest path p from the \nroot, s is labelled with g, i.e., every path strictly shorter than p is labelled either f or .. Now consider \nthe path p in f(s, s). If p exists in f(s, s), then it must be labelled either f or . in f(s, s). If \np does not exist in f(s, s), then a pre.x of p exists in f(s, s) and must be labelled with .. In both \ncases, a contradiction is reached since s = f(s, s). o Lemma 4 For any non-. tree t with f and ., there \nis exactly one maximal path of f s i. the subtypes of t form a chain w.r.t. =. Proof. If t has exactly \none maximal path of f s, then clearly that all the subtypes of t form a chain. On the other hand, if \nt has at least two maximal paths of f s. The two subtypes of t where we replace f by . at the respective \npaths are incomparable. o Thus we can enforce a tree to represent a word. We shorthand the formula by \nword(t), that is def dom-closure(t) = .x.((x = f(x, x)) . (t = x)) chain(t) def = .t1, t2.(((t1 = t) \n. (t2 = t)) . ((t1 = t2) . (t2 = t1))) word(t) def = dom-closure(t) . chain(t) . (t = .)  3.1.3 Prepending \nTrees In the following discussion, we use words and trees that represent words interchangeably, since \nthe context should make the distinction clear. To construct a solution to a PCP instance, we need to \nconcatenate words. Thus we want to express with con\u00adstraints that a word w1 is obtained from w2 by prepending \nw. We express this with a family of predicates prependw, one f \\\\\\2 /// . f f 1 /// \\\\\\ 1 \\\\\\ /// f . \nf . 1 /// \\\\\\ \\\\\\2 /// f . \\\\\\2 . f /// \\\\\\ /// . f \\\\\\ .. /// .. (a) The word 12. (b) The word 2112 \n= 21 \u00b7 12. Figure 2: Tree prepending example. for each constant word w. The predicate prependw(t1,t2) \nis true if the word represented by t1 is obtained by prepending w to the word for t2. Note that this \nis su.cient, because in PCP, the words are constant. We de.ne the predicate recursively def prependE(t1,t2)=(t1 \n= t2) def .t ' .((t1 = f(t ' , .)) . prepend1w(t1,t2)= ' prependw(t ,t2)) def .t ' .((t1 = f(.,t ' )) \n. prepend2w(t1,t2)= ' prependw(t ,t2)) Example 4 (Prepending example) We prepend the word 21 onto the \nword 12 (Figure 2a) to get the word 2112 (Figure 2b).  3.2 Reducing PCP to FOT of Subtyping In this \nsection, we describe how to reduce an instance of PCP to a .rst-order formula of subtyping constraints. \n3.2.1 Outline of the Reduction We construct a formula that accepts the representations of all the solutions \nof a PCP instance. We .rst describe a solution to a PCP instance as a tree. Recall that a PCP instance \nP consists of n pairs of words (l1,r1),..., (ln,rn), where li,ri .{1, 2} * . A so\u00adlution s = s1 \u00b7\u00b7\u00b7 sm \nto P is a non-empty .nite sequence of indices 1 through n, i.e., s .{1, \u00b7\u00b7\u00b7 ,n}+ , such that ls1 \u00b7\u00b7\u00b7 \nlsm = rs1 \u00b7\u00b7\u00b7 rsm . One can represent a solution s as the tree t shown in Figure 3. In the tree t, the \nvalues of E, ls1 , rs1 , ..., lsm \u00b7\u00b7\u00b7 ls1 , and rsm \u00b7\u00b7\u00b7 rs1 are represented by their corresponding word \ntrees. The tree is constructed as follows. We start with the empty word pair (E, E). At each step, we \nprepend a particular pair from the PCP in\u00adstance (lsi ,rsi ) to the previous pair of words. At the end, \nls1 \u00b7\u00b7\u00b7 lsm = rs1 \u00b7\u00b7\u00b7 rsm , i.e., we have found a solution to P. Notice that the solutions are constructed \nin the reverse order because we use prepend instead of append. 2 2 We use prepend because append is \njust not as convenient to ex\u00adpress. f ff   EEf f     . lsm rsm f . .   lsm-1 lsm rsm-1 rsm \nf  f.   ls1 \u00b7\u00b7\u00b7 lsm rs1 \u00b7\u00b7\u00b7 rsm Figure 3: A PCP solution viewed as a tree. With this representation \nof PCP solutions as trees, we can reduce an instance of PCP to the validity of a .rst\u00adorder formula of \nsubtyping constraints by expressing that there exists a tree t such that 1. The tree t is of the particular \nform in Figure 3. (Sec\u00adtion 3.2.2) Our construction does not require the branches of the solution tree \nto be in the order shown in Figure 3. Any order is .ne. 2. We have a valid PCP construction sequence. \n(Sec\u00adtion 3.2.3) Each left branch f(wi,w i' ) is either the pair of empty words or there exists another \nleft branch f(wj ,w j ' ) such that prependlk (wi,wj ) and prependrk (wi' ,w j ' ) for some k. In addition, \none of the left branches is of the form 3 f (w, w) with w non-empty.This ensures that we have a non-empty \nsequence. We next express these requirements with .rst-order for\u00admulae of subtype constraints.  3.2.2 \nCorrect Form of the Tree To ensure the correct form of the tree t, we require that each left branch represents \ntwo words conjoined with the root labelled with f, i.e., we have f(w, w ' ) for some trees representing \nwords w and w ' . In order to achieve this, we construct trees of the form shown in Figure 4a, which \nis a branch of the tree representing a PCP solution shown in Figure 3. Let t be the tree representing \na PCP solution. We can\u00adnot extract a branch directly from t because subtyping con\u00adstraints cannot express \nremoving something from a tree. However, we observe that a branch is a supertype of the main spine shown \nin Figure 4b with some additional prop\u00aderties, which we enforce separately. We .rst express the main \nspine s of t. Two properties are needed for s: 3We assume for any PCP instance, li ri for any i. Otherwise, \n= the instance is trivially solvable. f f / // . . . . /// . f / //  f //// \\\\\\ . . . /// \\\\\\\\ wi w \n' i . . f //// \\\\\\ . . . /// wi w ' i f //// \\\\\\ f / //  wi w ' i f //// \\\\\\ . . . /// \\\\\\\\ wi w ' i \n. . (a) A branch. (b) An expanded branch. Figure 5: Extracting words from a branch. f . . . . /// . \nf / //  f //// \\\\\\ . . . /// \\\\\\\\ f / // \\\\ . . . . /// \\\\ \\ . . ' wi wi . . (a) A branch. (b) The main \nspine. Figure 4: The branch of a solution tree. 1. The main spine s is of the form shown in Figure 4b. \nWe simply require s = f(.,s). 2. The tree s is a subtype of t and among all possible spines, it is the \nlargest such tree.  This is easily expressed as (s = t) ..x.(((x = f(.,x)) . (x = t)) . (x = s)) We \nintroduce the shorthand that s is the main spine of t by def (s = f(.,s)) . (s = t) spine(s, t)= (.x.(((x \n= f(.,x)) . (x = t)) . (x = s))) We observe that a branch b of t is a subtype of t and a proper supertye \nof the main spine s with two additional properties: 1. Exactly one left branch of the main spine is of \nthe form f(wi,w i' ). 2. All the other left branches of the main spine are labelled with ..  We can \nexpress that b is a proper supertype of the main spine s by def s<b = ((s = b) . (s = b)) We express \n(1) and (2) by observing that b is a maximal tree such that the set of all the subtypes of b that are \nproper supertypes of the main spine s have a unique minimal ele\u00adment, i.e., the set {x | s<x = b} has \na unique minimal element. We use is-min(u, v, w) to express that u is a mini\u00admal element of the subtypes \nof v that are proper supertypes of w, that is def (u = v) . (w<u) . is-min(u, v, w)= .x.(((x = v) . (w<x)) \n. (u = x)) In addition, uniq-min(u, w) expresses that all the subtypes of u that are proper supertypes \nw have a unique minimal element, that is def .x.(is-min(x, u, w) . uniq-min(u, w)= .y.(is-min(y, u, w) \n. (x = y))) With that, we can express the requirements on b by the following formula (b = t) .def branch(b, \nt)= .s.(spine(s, t) . (s<b) . uniq-min(b, s) ..x.((b<x = t) .\u00acuniq-min(x, s))) We establish the correctness \nof branch(b, t) in Lemma 5. Lemma 5 A tree b is a branch of t as shown in Figure 4a i. branch(b, t). \nProof. It is straightforward to verify that if b is a branch of t then branch(b, t). For the other direction, \nassume branch(b, t). Then we know that b is a subtype of t and a proper supertype of the main spine s. \nSince uniq-min(b, s), i.e., all the subtypes of b strictly larger than s have a unique minimum, b cannot \nhave two left sub-branches labelled with f. Thus b must be a subtype of a branch. However, since b is \nthe largest tree such that uniq-min(b, s), itmustbea branch. o  3.2.3 Correct Construction of the Tree \nThe previous section describes how to extract a branch of the tree t. However, that is not su.cient, \nsince we ultimately need the two words wi,w i ' associated with a branch. We must ensure that for each \nbranch the two words wi and w ' are empty or are constructed from the words of an\u00ad i other branch wj \nand w ' by prepending lk and rk respec\u00ad j tively, for some k. For a branch b, we need to extract the \ntwo words wi and wi' . The trick is to duplicate the non-. left child of b to all the left children of \nb preceding this non-. child. In particular, this would have the e.ect of duplicating the two words at \nthe .rst child of the branch. We give an example. Consider the branch b shown in Figure 5a. We would \nlike to build from b the expanded tree b ' shown in Figure 5b. If we can construct such a tree b ' , \nthen it is easy to extract the two words wi and wi ' simply by the constraint .u.f(f(wi,w i' ),u)= b \n' . We now show how to construct b ' from b. Observe that the right child of b ' is a subtype of b ' \nitself, i.e., if we let b ' = f(u, v), then v = b ' . In addition, observe that of all supertypes of \nb, b ' is the smallest tree with this property. We write the shorthand recurse(t1,t2) for the formula \ndef (t1 = t2) . recurse(t1,t2)= .x1,x2.(t2 = f(x1,x2)) . (x2 = t2) which says that t1 is a subtype of \nt2 and the right child of t2 is a subtype of t2 itself. Now we can express the duplication of b to get \nb ' through the following formula ' def recurse(b, b ' ) .dup-branch(b, b )= .t.(recurse(b, t) . (b ' \n= t)) We establish the correctness of dup-branch(b, b ' ) in Lemma 6. b ' the non-. sub-branch of b (as \nshown in Figure 5) i. dup-branch(b, b ' ). Lemma 6 Let b be a branch of t. A tree duplicates Proof. It \nis straightforward to verify that if b ' duplicates the non-. sub-branch of b, then dup-branch(b, b ' \n). For the other direction, assume dup-branch(b, b '' ). Since b ' (shown in Figure 5b) meets the condition \nrecurse(b, b ' ), by de.nition of dup-branch we have b '' = b ' . We also have b = b '' because recurse(b, \nb '' ) holds. With a simple induction on the height of the left spine of f s of b, we can show that b \n'' must be the same as b ' . Thus, b '' duplicates the non-. sub-branch of b. o We introduce a few shorthands \nnext. The formula wordpair(w1,w2, b, t) expresses that for a branch b of a solu\u00adtion tree t, w1 and w2 \nare the pair of words associated with that branch. wordpair(w1, w2, b, t) def = word(w1) . word(w2) . \n.b ' .(dup-branch(b, b ' ) . .u.(f(f(w1, w2), u) = b ' )) The formula onestep(wi,w i' ,wj ,w j ' ) expresses \na step in the PCP construction, i.e., the concatenation of a pair of words onto the current pair. It \nsays that the words wi and wi ' are obtained from the words wj and wj ' by respectively prepending some \nwords lk and rk of the PCP instance. def (prependlk (wi,wj ) '' 1=k=n onestep(wi,w i,wj ,w j )= '' . \nprependrk (wi,w j )) We can now express that the tree t represents a solution of a PCP instance. Recall \nthat we must express that for each wi and wi' , either wi and w ' are the empty words, i or there exist \nwj and wj ' such that prependlk (wi,wj ) and prependrk (wi' ,w j ' ). Consider the PCP instance P in \nwhich we have (l1,r1),..., (ln,rn), where li and ri are words in {1, 2}. We construct a .rst-order formula \nsolvable(P ) which is valid i. P is solvable. The formula expresses the existence of a tree representing \na solution to P. We introduce a few more shorthands. The formula empty(w) tests whether a word w is E. \nThe formula construct(w1,w2,b ' ,t) ensures that w1 and w2 are obtained from some branch b ' of t by \na one step construction. We use valid-branch(b, t) for saying that the words w1 and w2 are either E or \nare obtained by a construction step of PCP from another branch b ' . Finally, we use the formula accept-branch(b, \nt) to say that for some branch, the two words associated with that branch are the same and not the empty \nwords E. def empty(w)= w = f(., .) branch(b ' ,t) . def '' '' construct(w1,w2,b ' ,t)= .w1,w 2.(wordpair(w1,w \n2,b ' ,t) . onestep(w1,w2,w 1' ,w 2' )) (.w1,w2.wordpair(w1,w2, b, t) def valid-branch(b, t)= . ((empty(w1) \n. empty(w2)) ..b ' .construct(w1,w2,b ' ,t))) branch(b, t) . def accept-branch(b, t)= .w.(wordpair(w, \nw, b, t) . \u00acempty(w)) The formula solvable(P ) now can be given as def .t.(.b.(branch(b, t) . valid-branch(b, \nt))solvable(P )= ..b.accept-branch(b, t)) The correctness of the reduction from PCP to the .rst\u00adorder \ntheory of subtyping constraints is established in The\u00adorem 7. Theorem 7 (Soundness and Completeness) \nA PCP instance P has a solution i. the formula solvable(P ) is valid. Proof. It is easy to verify that \nif P has a solution, then any representation of the solution sequence in terms of a tree t shown in Figure \n3 meets the requirement .b.(branch(b, t) . valid-branch(b, t)) ..b.accept-branch(b, t) On the other hand, \nsuppose we have such a t, then it is also easy to extract a solution sequence from t. Start with the \nbranch bm such that the two words associated with bm are the same. Since bm is a branch and the two words \nare not E, there must be another branch bm-1 such that we have a PCP construction step. This process \nmust terminate, since t is a .nite tree. This reasoning can be easily formalized with an induction on \nthe number of branches of t (or equivalently the size of t). o  3.3 Recursive Types In this section, \nwe show that the construction can be adapted to recursive types. Recall that in recursive types, types \nare interpreted as regular trees over f and .. To adapt our construction, notice that it is su.cient \nto restrict all the types (trees) to be .nite trees. That is, we need only express that a tree t is .nite. \nIt turns out that only the words we get from a branch of t must be .nite. The other trees in the construction \nf / / /// f ff \\ /\\/ /\\// / f . \\ w1 w2 f . \\\\ \\ // \\\\ / ww w1 w1 (a) Failed attempt one. (b) Failed \nattempt two. Figure 6: Failed attempts for recursive types. can be in.nite. For words, if we do not restrict \nthem to be .nite, the existence of such a tree t as in Figure 3 may not correspond to a solution to the \nPCP problem. To see this, consider the PCP instance {(11, 1)}. Clearly, it has no solution. However, \nconsider the tree (f(f(w, w), .) shown in Figure 6a, where w is the in.nite regular tree such that w \n= f(w, .), i.e., the in.nite word 1. . One may wonder whether we can instead require that a construction \nstep must use two di.erent branches, and that the words for the two branches are not the same at the \nrespective positions. This does not work either. Con\u00adsider the PCP instance {(E, 1), (E, 2)}, which has \nno solution. Now consider the tree f(f(w1,w2),f(f(w1,w1), .)) shown in Figure 6b, where w1 = f(w2, .) \n. w2 = f(.,w1), i.e., w1 is the in.nite word (12). and w2 is the in.nite word (21). . We take the approach \nof restricting the words extracted from a branch to be .nite. This can be achieved by simply requiring \nthat the set of proper subtypes of w has a largest element, i.e., def '' ' has-max(w)= .t.(t<w ..t.(t \n<w . t = t) Lemma 8 A tree t representing a word is .nite i. has-max(t). Proof. Let t be a word tree. \nIf t is .nite, then the set of proper subtypes of t forms a chain. The set is .nite, and thus has a largest \nelement. On the other hand, if the tree is in.nite, then all its proper subtypes are .nite trees truncated \nfrom t, i.e., the set of trees representing the .nite pre.xes of word denoted by t (except .). This set \nforms an in.nite ascending chain, and thus it does not have a largest element. o We can now directly \nuse the construction in Section 3, except we require in the formula wordpair(w1,w2, b, t) that w1 and \nw2 are .nite: word(w1) . word(w2) . def has-max(w1) . has-max(w2) . wordpair(w1,w2, b, t)= .b ' .(dup-branch(b, \nb ' ) . .u.(f(f(w1,w2),u)= b ' )) Thus, we have shown that the .rst-order theory of non\u00adstructural subtyping \nconstraints over recursive types (and in.nite trees) is undecidable. Theorem 9 The .rst-order theory \nof non-structural sub\u00adtyping constraints over recursive types (and in.nite trees) is undecidable for \nany type language with a binary type sym\u00adbol and .. Proof. Follows from Lemma 8 and Theorem 7. o 4 Structural \nSubtyping: A Comparison We show that the .rst-order theory of structural subtyping constraints over the \ntype language over f and . is decid\u00adable. This result provides a clear contrast between the ex\u00adpressiveness \nof structural and non-structural subtyping. In addition, it provides another, and in some sense more \nappar\u00adent, distinction between these two alternative interpretation of subtypes. In fact, we show that \nthe .rst-order theory of structural subtyping constraints with a signature containing one constant symbol \nis decidable. Theorem 10 The .rst-order theory of structural subtyp\u00ading constraints with a single constant \nsymbol is decidable for both simple and recursive types (and in.nite trees). Proof. This can be easily \nshown by noticing that in a type language with only one constant (i.e., .), the subtype relation is the \nsame as equality. Thus we can simply turn any constraint t1 = t2 into t1 = t2. Since the .rst-order theory \nof equality is decidable both for .nite and regular trees (and in.nite trees) [21], the theorem follows \nimmediately. o 5 Decidability of FOT with Unary Symbols In this section, we show that if we restrict \nour type language to unary function symbols and constants, the .rst-order the\u00adory is decidable. This \nresult shows that the di.culty in the whole .rst-order theory lies in binary type constructors. The idea \nof the proof is to reduce the problem to the tree automata emptiness problem. Note that word automata \nwould su.ce for encoding the case with unary function symbols. However, because our approach is extensible \nto type languages over arbitrary sig\u00adnatures for the existential or universal fragments (see Sec\u00adtion \n5.3), we present our results in terms of tree automata. 5.1 Background on Tree Automata We recall some \nde.nitions and results on tree automata. Tree automata generalize word automata by accepting trees instead \nof words. Let F be a ranked alphabet, and let Fn denote the set of symbols of arity n. De.nition 11 (Finite \nTree) A .nite tree t over a ranked alphabet F is a mapping from a pre.x-closed set pos(t) . N* into F. \nThe set of positions pos of t satis.es pos(t) is nonempty and pre.x-closed.  For each p . pos(t), if \nt(p) .Fn, then pi . pos(t) for 1 = i = n.  De.nition 12 (Finite Tree Automata (NFTA)) A .\u00adnite tree \nautomaton (NFTA) over F is a tuple A =(Q, F,QF , .) where Q is a .nite set of states, F is a .nite set \nof ranked alphabet, QF . Q is a set of .nal states, and . is a set of transition rules of the form f(q1,...,qn) \n-. q where n = 0, f .Fn, q, q1,...,qn . Q. The above de.nes a bottom-up tree automaton, since an automaton \nstarts at the leaves and works up the tree in\u00adductively. The move relation of a tree automaton A = (Q, \nF,QF , .) can be de.ned as tree rewriting rules t -. t ' . A We say that t -. t ' if t ' can be obtained \nfrom t by replac- A ing f(q1,...,qn) with q for some f(q1,...,qn) -. q . .. * We denote the re.exive \nand transitive closure of -. by -. . AA A term (or a tree) is accepted by a NFTA A = * (Q, F,QF , .) \nif t -. q for some .nal state q in QF . A Example 5 (tree automaton) Consider the automaton where Q = \n{q, qf } F = {a, b, f(\u00b7, \u00b7)} {qf } .. QF = .. For example, consider F = {a, f(\u00b7, \u00b7)}, where a is a constant \nand f is a binary symbol. Then is the F2 set of symbols {aa,af,an,fa,ff,fn,na, nf, nn} and is {af,fa,ff,fn, \nnf}. F22 Example 6 (tuple encoding) ff ff \\ \\\\/\\\\\\ // /// ///// f .T ffT.f \\\\ /// \\\\\\ /// \\\\\\ // \\\\// \n\\\\ // TT .TTn Tnn. nT (a) t1 (b) t2 (c) encoding of (t1,t2) De.nition 13 (Tree Automata on Tuples) Let \nF be a ranked alphabet. A .nite tree automaton on n-tuples over F is a tree automaton A =(Q, Fn,QF , \n.) over Fn (de.ned above), where Q is a .nite set of states, QF . Q is a set of .nal states, and . is \na set of transition rules of the form a -. q f(q1,...,qm) -. q .= b -. qf .. where n = 0, f .Fn . Q. \nm, q, q1,...,qm f(q, qf ) -. qf Example 7 (automaton on tuples) Consider the au- The automaton accepts \nthe smallest tree language L sat\u00ad tomaton where isfying (1) b . L, and (2) if t . L then f(a, t) . L. \nFor example, it accepts the term f(a, b) since Q = {qf }F = {a, f(\u00b7, \u00b7)}fff -. -. -. qf {qf } QF = \\\\\\ \n\\\\\\ \\\\\\ /// /// /// aa -. qf qf .= b q b q a ff(qf ,qf ) -. qf Our goal is to use tree automata to encode \nthe solu\u00adtions of subtyping constraints. The solutions of a con\u00adstraint system are an n-ary relation, \nassociating with each type variable a component in the relation. Thus, the so\u00adlutions of a constraint \nsystem of m variables can be repre\u00adsented as a set of m-tuples of trees. For example, the tuple (f (f(T, \nT), .),f(T,f (., T))) is a solution to the constraint x = y. We use a standard encoding to represent \ntuples [9]. We .rst give an example to illustrate how the encoding works. Consider tuples of words over \nthe alphabet {0, 1}. We can construct an automaton to accept the (encoding of) lan\u00adguage L of pairs (w, \nw ' ) such that lwl = lw 'l (lwl denotes the length of the word w) and wi = wi ' for 1 = i =lwl, i.e., \nwe .ip 0 s and 1 s in w and w ' . One possible encoding is to stack the two words, i.e., put one on top \nof the other, and 0011 we consider the product alphabet {1}. With this en\u00ad 0, 1, 0, coding, we can easily \nconstruct an automaton that accepts L, for example, the automaton with one state q and q is both initial \nand .nal, having transitions (q, 10) -. q and (q, 01) -. q. This idea can be extended to tree automata \non tuples with overlapping of the terms. For any .nite ranked alphabet F, we de.ne = (F.{n})n , where \nn is a Fn new symbol of arity 0. We consider only binary terms, since general n-ary symbols can be simulated \nwith a lin\u00adear number of binary symbols in the arity of the sym\u00adbol. We de.ne the arity of the symbols \nas the maximum of the arities of the components, i.e., arity(f1,...,fn)= max{arity(f1),..., arity(fn)}. \nSince n is of arity 0, the sym\u00adbol (n,...,n) is of arity 0, i.e., a constant. We denote by Fn m the set \nof symbols in Fn of arity m. One can verify that this automaton accepts the tree lan\u00adguage {(t, t) | \nt . T (F)}. Let t =(f1,...,fi,...,fn). De.ne ti = fi (the i-th com\u00adponent of t) and t-i =(f1,...,fi-1,fi+1,...,fn) \n(the i-th projection of t). We now de.ne two important operations on relations, projection and cylindri.cation. \nDe.nition 14 (Projection and Cylindri.cation) If R . T (F)n (n = 1) and 1 = i = n, then the i-th projection \nof R is the relation Ri . T (F)n-1 de.ned by Ri(t1,...,tn-1) ..t . T (F).R(t1,...,ti-1, t, ti,...,tn-1) \nIf R . T (F)n (n = 0) and 1 = i = n + 1, then the i-th . T (F)n+1 cylindri.cation of R is the relation \nRi de.ned by Ri(t1,...,ti-1, t, ti,...,tn) . R(t1,...,ti-1,ti,...,tn) We summarize here results on tree \nautomata that we use. More details can be found in [9, 15]. Theorem 15 (Decidable Emptiness) The emptiness \nproblem for tree automata is decidable. In fact, it can be decided in linear time in the size of the \nautomaton. Theorem 16 (Closure Properties) Tree automata are closed under intersection, union, complementation, \ncylindri\u00ad.cation, and projection. One can view intersection as the equivalent of Boolean and ., union \nas the Boolean or ., complementation as the Boolean negation \u00ac, projection as existential quanti.ca\u00adtion \n.. Cylindri.cation is used to ensure that two automata represent solutions over a common set of variables, \nso that their intersection can be taken.  5.2 A Decision Procedure Recall that we consider a monadic \nsignature in this section. We reduce the validity of a formula f to the emptiness deci\u00adsion of a tree \nautomaton. We proceed by structural induc\u00adtion on the formula f. We assume the formula is normalized \nso that it uses only the connectives ., \u00ac, and .. In addition, w.l.o.g., we assume the literals of the \nformula are of the form x = y, x = ., x = T, and x = f(y). .x.f Let A1 be the automaton for f. We construct \nan au\u00adtomaton A for .x.f by taking the projection of A1 w.r.t. the x component of the tuple.4 \u00acf Let \nA1 be the automaton for f. We construct an au\u00adtomaton A for \u00acf by complementing A1. f1 . f2 Let A1 and \nA2 be the automata for f1 and f2. We construct A ' 1 and A ' 2 for f1 and f2 by cylindrifying A1 and \nA2 so that A ' 1 and A ' 2 agree on all the components. Then construct A for f1 . f2 by intersecting \nA ' 1 and A ' 2. The following are for the base predicates. x = . We construct the automaton A =({qf \n}, F1 , {qf }, {. -. qf }) x = T We construct the automaton A =({qf }, F1 , {qf }, {T -. qf }) x = f(y) \nWe illustrate the construction for the case where there is one other unary function symbol g in addition \nto f . The constants are . and T. We construct the following automaton A =({qf ,qg,q.,q.,q.}, F2 , {qf \n}, .) to accept all the pairs of (x, y) where x = f(y). We give a recursive construction of the transitions. \nWe use qs as the state in which we are expecting a s for the x-component (the .rst component). Here are \nthe cases where we expect a f for the x com\u00adponent and in which we accept. f.(q.) -. qf fT(q.) -. qf \nff(qf ) -. qf fg(qg) -. qf 4Notice that only trees that are encodings of tuples of trees are considered \nduring an automata projection. Here are the cases where a g is expected for the x com\u00adponent. g.(q.) \n-. qg gT(q.) -. qg gf(qf ) -. qg gg(qg) -. qg Here are the base cases. .n -. q. Tn -. q. One can easily \nshow with an induction that the con\u00adstructed automaton accepts the language {(x, y) | x = f (y)}. x = \ny We illustrate the construction for f. We assume f is covariant in its argument. The construction is \neasily extensible to the case with more function symbols, with function symbols of binary or greater \narities, and with function symbols with contravariant arguments. For a = \u00df to hold, we have the following \ncases a is .;  \u00df is T;  a = f(a1) and \u00df = f(\u00df1), where a1 = \u00df1.  We construct the automaton A =({ql,qr,qf \n}, F2 , {qf }, .) The transition relation . is constructed in pieces. We have the atomic cases where \na and \u00df are either . or T .. -. qf .T -. qf TT -. qf Then we have the cases where a = . and \u00df = f(\u00df1) \nor \u00df = T and a = f(a1). .f(ql) -. qf fT(qr) -. qf The state ql is used to signify that the left component \ncan only be n, i.e., the component isn t there. We still need to complete the right component. For ql, \nwe have the rules n. -. ql nT -. ql nf(ql) -. ql The case for qr is symmetric, and we have the rules \n.n -. qr Tn -. qr fn(qr) -. qr Finally we have the case where a = f(a1) and \u00df = f(\u00df1). In this case, \nwe require the subterms to be re\u00adlated. Thus we have the rule ff(qf ) -. qf One can easily verify that \nthe automaton indeed rec\u00adognizes the solutions of a = \u00df. Thus the .rst-order theory of non-structural \nsubtyping restricted to unary function symbols is decidable. In addi\u00adtion, note that for structural subtyping, \nthe only changes are in the case x = y, and can be easily expressed with tree automaton. By using an \nacceptor model for in.nite trees and using top-down automata, we can easily adapt this con\u00adstruction \nfor in.nite words. Theorem 17 The .rst-order theory of non-structural sub\u00adtyping with unary function \nsymbols is decidable. This holds both for the .nite and in.nite words and for structural sub\u00adtyping as \nwell. Proof. Follows immediately from the above construction and the properties of tree automata. o \n 5.3 Extending to Arbitrary Signatures We now discuss the issues with extending the described ap\u00adproach \nto arbitrary signatures. There are two related di.\u00adculties in extending our approach to the full .rst-order \nthe\u00adory over arbitrary signatures. First, although we can easily express the solutions to x = y with \nstandard tree automata, we cannot express the solutions to x = f(y, z) with stan\u00addard tree automata for \nany binary symbol f, because the set {(t1,t2,t3)| t1 = f(t2,t3)} is not a regular set [9]. An extended \nform of tree automata on tuples is required, tree automata on tuples with component-wise tests (TACT); \nsuch automata allow machines to test relationships between tuple components [41]. Because this class \nof tree automata is not closed under projection, it does not extend to the full .rst\u00adorder theory. However, \nthis class of automata is still inter\u00adesting because it can encode the existential or equivalently the \nuniversal fragments of the .rst-order theory. There\u00adfore, we can reduce non-structural subtype entailment \nto the emptiness problem on a restricted class of TACT. We believe this reduction is a promising direction \nin resolving the decidability of non-structural subtype entailment. 6 Related Work There are a few previous \nresults on constraint simpli.cation regarding subtyping and set constraints. Henglein and Re\u00adhof consider \nthe problem of subtyping constraint entailment of the form C F a = \u00df, where C is a constraint set with \nsub\u00adtyping constraints and a and \u00df are type variables [17, 18]. The types are constructed from a .nite \nlattice of base ele\u00adments with the function (.) and product (\u00d7) constructors. They prove the following \nresults: 1. Structural subtype entailment over .nite types is coNP\u00adcomplete [17]. 2. Structural subtype \nentailment over recursive types is PSPACE-complete [18]. 3. Non-structural subtype entailment over .nite \ntypes is PSPACE-hard [18]. 4. Non-structural subtype entailment over recursive types is PSPACE-hard \n[18].  Niehren and Priesnitz consider the problem of non\u00adstructural subtype entailment. They show that \na natu\u00adral subproblem is PSPACE-complete [27] and character\u00adize non-structural subtype entailment over \nthe signature {f(, ), ., T} with so-called P-automata [28]. They leave open the decidability of non-structural \nsubtype entailment for this particular signature. Furthermore, it is not known whether this approach \ncan be extended to work on arbitrary signatures. Niehren et al. consider the entailment problem of atomic \nset constraints, a restricted class of set constraints without union and intersections and interpreted \nover the Herbrand universe. They show entailment of the form C F a . \u00df is PSPACE-complete for atomic \nset constraints [26]. Flanagan and Felleisen consider the problem of simplifying a variant of atomic \nset constraints. They show restricted entailment C1 FE C2 for this class of constraints is decidable \n(in ex\u00adponential time) by reducing restricted entailment to regular tree grammar containment and PSPACE-hard \nby a reduc\u00adtion from nondeterministic .nite state automata contain\u00adment [13]. They do not give an exact \ncharacterization of the complexity of the problem. Entailment problems for conditional equality con\u00adstraints \n[38] (a weaker form of non-structural subtyping con\u00adstraints) are studied in [39]. Both entailment and \nrestricted entailment are PTIME-complete. This is in contrast to a simple extension, for which entailment \nis still PTIME\u00adcomplete, but restricted entailment is coNP-complete. A few researchers consider semantic \nnotions for subtyp\u00ading constraint simpli.cation. The most powerful one is the notion of observational \nequivalence de.ned in [42]. Intu\u00aditively, observational equivalence says that from the analy\u00adsis point \nof view replacing one constraint set with an equiv\u00adalent one does not change the observable behavior \nof the constraint system. A similar notion is used in [33] for sim\u00adplifying subtyping constraints. There \nis also related work in term rewriting and con\u00adstraint solving over trees in general [8, 10]. The work \nin this paper is inspired by work in this area. Maher shows the .rst-order theory of .nite trees, in.nite \ntrees, and rational trees is decidable by giving a complete axiomatization [21]. Many researchers consider \nvarious order relations among trees, similar to the subtype orders. Venkataraman study the .rst-order \ntheory of subterm ordering over .nite trees. The existential fragment is shown to be NP-complete and \nthe ..-fragment to be undecidable [43]. M\u00a8uller et al. study the .rst order theory of feature trees and \nshow it undecid\u00adable [25]. Comon and Treinen show the .rst-order theory of lexicographic path ordering \nis undecidable [11]. Automata\u00adtheoretic constructions are used to obtain decidability re\u00adsults for many \ntheories. B\u00a8uchi uses .nite word automata to show the decidability of WS1S and S1S [7]. Finite automata \nare also used to construct alternative proofs of decidability of Presburger arithmetic [6, 44], and Rabin \ns decidability of WS2S and S2S are based on tree automata [35]. Conclusion In this paper, we have shown \nthat the .rst-order theory of non-structural subtyping constraints is undecidable via a reduction from \nthe Post s Correspondence Problem (PCP). The result holds both for .nite and in.nite trees and for any \ntype signature with at least one binary type construc\u00adtor and a least element .. This result yields a \ntechnical separation of structural subtyping and non-structural sub\u00adtyping. We have also shown that the \n.rst-order theory of subtyping constraints with unary function symbols is de\u00adcidable. The automata-theoretic \nconstruction bridges au\u00adtomata theory and subtyping problems. This provides us with an alternative way \nof tackling of the problems. We consider this work a step towards resolving the long\u00adstanding open questions \nabout subtyping. The most out\u00adstanding problems are the decidability of non-structural sub\u00adtype entailment \nand subtyping constrained types. References [1] A. Aiken and E. Wimmers. Type Inclusion Constraints and \nType Inference. In Proceedings of the 1993 Confer\u00adence on Functional Programming Languages and Com\u00adputer \nArchitecture, pages 31 41, Copenhagen, Den\u00admark, June 1993. [2] A. Aiken, E. Wimmers, and T.K. Lakshman. \nSoft Typ\u00ading with Conditional Types. In Proceedings of the 21th Annual ACM SIGPLAN-SIGACT Symposium on \nPrin\u00adciples of Programming Languages, pages 163 173, Jan\u00aduary 1994. [3] A. Aiken, E. Wimmers, and J. \nPalsberg. Optimal Rep\u00adresentations of Polymorphic Types with Subtyping. In Proceedings of 3rd International \nSymposium on Theo\u00adretical Aspects of Computer Software (TACS 97), pages 47 76, 1997. [4] R. Amadio and \nL. Cardelli. Subtyping Recursive Types. ACM Transactions on Programming Languages and Systems, 15(4):575 \n631, 1993. [5] L. O. Andersen. Program Analysis and Specialization for the C Programming Language. PhD \nthesis, DIKU, University of Copenhagen, May 1994. DIKU report 94/19. [6] A. Boudet and H. Comon. Diophantine \nequations, Pres\u00adburger arithmetic and .nite automata. In Proceedings of Trees in Algebra and Programming \n(CAAP 96), vol\u00adume 1059 of Lecture Notes in Computer Science, pages 30 43. Springer-Verlag, 1996. [7] \nJ. B\u00a8uchi. Weak second order logic and .nite automata. Z. Math. Logik, Grundlag. Math., 5:66 62, 1960. \n[8] H. Comon. Solving symbolic ordering constraints. In\u00adternational Journal of Foundations of Computer \nSci\u00adence, 1(4):387 411, 1990. [9] H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison, \nand M. Tommasi. Tree Au\u00adtomata Techniques and Applications. Available on: http://www.grappa.univ-lille3.fr/tata, \n1999. [10] H. Comon and R. Treinen. Ordering constraints on trees. In S. Tison, editor, Colloquium on \nTrees in Alge\u00adbra and Programming, volume 787 of Lecture Notes in Computer Science, pages 1 14, Edinburgh, \nScotland, 11-13 April 1994. Springer Verlag. [11] H. Comon and R. Treinen. The .rst-order theory of lexicographic \npath orderings is undecidable. Theoretical Computer Science, 176:67 87, April 1997. [12] M. F\u00a8ahndrich \nand A. Aiken. Making Set-Constraint Based Program Analyses Scale. In First Workshop on Set Constraints \nat CP 96, Cambridge, MA, August 1996. Available as Technical Report CSD-TR-96-917, University of California \nat Berkeley. [13] C. Flanagan and M. Felleisen. Componential Set-Based Analysis. In Proceedings of the \n1997 ACM SIGPLAN Conference on Programming Language Design and Im\u00adplementation, June 1997. [14] C. Flanagan, \nM. Flatt, S. Krishnamurthi, S. Weirich, and M. Felleisen. Catching Bugs in the Web of Program Invariants. \nIn Proceedings of the 1996 ACM SIGPLAN Conference on Programming Language Design and Im\u00adplementation, \npages 23 32, May 1996. [15] F. G\u00b4ecseg and M. Steinby. Tree Automata. Akademiai Kiado, 1984. [16] N. \nHeintze. Set Based Analysis of ML Programs. In Proceedings of the 1994 ACM Conference on LISP and Functional \nProgramming, pages 306 17, June 1994. [17] F. Henglein and J. Rehof. The Complexity of Subtype Entailment \nfor Simple Types. In Proceedings of the 12th Annual IEEE Symposium on Logic in Computer Science (LICS), \npages 352 361, 1997. [18] F. Henglein and J. Rehof. Constraint Automata and the Complexity of Recursive \nSubtype Entailment. In Pro\u00adceedings of the 25th International Colloquium on Au\u00adtomata, Languages, and \nProgramming (ICALP), pages 616 627, 1998. [19] D. Kozen, J. Palsberg, and M.I. Schwartzbach. E.cient \nRecursive Subtyping. In Proceedings of the 20th Annual ACM SIGPLAN-SIGACT Symposium on Principles of \nProgramming Languages, pages 419 428, 1993. [20] D. Kozen, J. Palsberg, and M.I. Schwartzbach. E.cient \nInference of Partial Types. Journal of Computer and System Sciences (JCSS), 49(2):306 324, 1994. [21] \nM.J. Maher. Complete axiomatizations of the algebras of the .nite, rational and in.nite trees. In Proceedings \nof the Third IEEE Symposium on Logic in Computer Science, pages 348 357, Edinburgh, UK, 1988. Com\u00adputer \nSociety Press. [22] S. Marlow and P. Wadler. A Practical Subtyping Sys\u00adtem For Erlang. In Proceedings \nof the International Conference on Functional Programming (ICFP 97), pages 136 149, June 1997. [23] R. \nMilner. A theory of type polymorphism in pro\u00adgramming. Journal of Computer and System Sciences, 17(3):348 \n375, December 1978. [24] J.C. Mitchell. Type Inference with Simple Types. Jour-[39] Z. Su and A. Aiken. \nEntailment with conditional equal\u00ad nal of Functional Programming, 1(3):245 285, 1991. ity constraints. \nIn Proceedings of European Symposium on Programming, pages 170 189, April 2001. [25] M. M\u00a8uller, J. Niehren, \nand R. Treinen. The .rst-order theory of ordering constraints over feature trees. Dis-[40] R. Treinen. \nA new method for undecidability proofs of crete Mathematics and Theoretical Computer Science, .rst order \ntheories. Journal of Symbolic Computation, 4(2):193 234, September 2001. 14(5):437 457, November 1992. \n[26] J. Niehren, M. M\u00a8uller, and J. Talbot. Entailment of [41] R. Treinen. Predicate logic and tree automata \nwith Atomic Set Constraints is PSPACE-Complete. In Pro-tests. In J. Tiuryn, editor, Foundations of Software \nSci\u00ad ceedings of the 14th Annual IEEE Symposium on Logic ence and Computation Structures, volume LNCS \n1784, in Computer Science (LICS), pages 285 294, 1999. pages 329 343. Springer, 2000. [42] V. Trifonov \nand S. Smith. Subtyping Constrained [27] J. Niehren and T. Priesnitz. Entailment of Non- Types. In Proceedingsofthe3rdInternationalStaticStructuralSubtypeConstraints. \nIn AsianComputing . .. . Analysis Symposium, pages 349 365, September 1996. Science Conference, number \n1742 in LNCS, pages 251 265. Springer, December 1999. [43] K.N. Venkataraman. Decidability of the purely \nexisten\u00adtial fragment of the theory of term algebras. Journal of [28] J. Niehren and T. Priesnitz. Non-Structural \nSubtype the ACM, 34(2):492 510, April 1987. Entailment in Automata Theory. In Proceedings of 4th International \nSymposium on Theoretical Aspects of [44] P. Wolper and B. Boigelot. An automata-theoretic ap- Computer \nSoftware (TACS 01), number 2215 in LNCS, proach to presburger arithmetic constraints. In Static pages \n360 384. Springer, 2001. Analysis Symposium, pages 21 32, 1995. [29] M. Odersky and P. Wadler. Pizza \ninto Java: Translat\u00ading theory into practice. In Proceedings of the 24th An- A An Example nual ACM SIGPLAN-SIGACT \nSymposium on Princi\u00adples of Programming Languages, pages 146 159, Paris, We give an example in this \nsection to demonstrate our France, January 1997. automata construction in Section 5. Consider the alpha\u00ad \n [30] J. Palsberg and P. O Keefe. A Type System Equivalent bet F = {., T,g(\u00b7)}. We want to decide the \nentailment {x = g(y),g(x) = y} F x = y. to Flow Analysis. ACM Transactions on Programming This entailment \nholds. We reason with a proof by con-Languages and Systems, 17(4):576 599, 1995. tradiction. Suppose \nthe entailment does not hold. Then [31] J. Palsberg and M. I. Schwartzbach. Object-Oriented there exist \ntwo trees t1 and t2 such that (1) t1 = g(t2) Type Inference. In Proceedings of the ACM Conference and \ng(t1) = t2; and (2) t1 i t2. Choose t1 and t2 to on Object-Oriented programming: Systems, Languages, \nbe trees such that lt1l + lt2l is minimized. Notice that ' ''' and Applications, pages 146 161, October \n1991. t1 = g(t1) and t2 = g(t2) for some t and t2, other\u00ad 1 wise, t1 and t2 cannot witness the non-entailment. \nHow\u00ad [32] E.L. Post. A Variant of a Recursively Unsolvable Prob-' ''' ever, then we have g(t1) = g(g(t2)), \ni.e., t1 = g(t2) and lem. Bull. of the Am. Math. Soc., 52, 1946. '''' '' g(g(t1)) = g(t2), i.e., g(t1) \n= t2. Furthermore, t1 i t2 since '' '' t1 = g(t1) i g(t = t2. Thus, t and t also witness the [33] F. \nPottier. Simplifying Subtyping Constraints. In 2) 12 non-entailment, a contradiction. Proceedings of \nthe 1996 ACM SIGPLAN International We demonstrate that the entailment holds with the tech- Conference \non Functional Programming (ICFP 96), nique presented in this paper. After .attening the con\u00adpages 122 \n133, May 1996. straints, we consider the equivalent entailment [34] F. Pottier. Simplifying subtyping \nconstraints: a the\u00ad '' '' {x = g(x),y = g(y),x = y ,x = y} F x = y ory. To appear in Information &#38; \nComputation, August 2000. The above entailment is equivalent to deciding whether the '' '' constraints \n{x = g(x),y = g(y),x = y ,x = y, x i y} are [35] M.O. Rabin. Decidability of Second-Order Theories unsatis.able. \nand Automata on In.nite Trees. Transactions of the We construct an automaton for each of the .ve con- \nAmerican Mathematical Society, 141:1 35, 1969. straints. [36] J. Rehof. The Complexity of Simple Subtyping \nSystems. ' x = g(x) PhD thesis, DIKU, 1998. [37] O. Shivers. Control Flow Analysis in Scheme. In Pro-Consider \nthe automaton where ceedings of the 1988 ACM SIGPLAN Conference on Q Programming Language Design and \nImplementation, = {q1,q2,qf } pages 164 174, June 1988. F = {., T,g(\u00b7)}2 {qf } QF = [38] B. Steensgaard. \nPoints-to Analysis in Almost Lin- Time. In Proceedings of the 23rd Annual ACM n. -. ear q1 . .. . . \n.. Tg(q2) -. qf gg(qf ) -. qf . .. The .rst component is for x, and the second component is a shorthand \nfor the two rules is for x ' . f1f2(q) -. q ' y ' = g(y) and This is the same automaton as for x ' = \ng(x), with the f1f3(q) -. q ' .rst component for y and the second component for y ' . ' For x = g(x), \nconsider the automaton where x = y ' Q = {q1,q2,qf } Consider the automaton where F = {., T,g(\u00b7)}4 {qf \n} . .. . . . . . . . . . . . . . . . . . . QF = Q = {q1,q2,qf } {., T,g(\u00b7)}2 {qf } . .. . . . . . .. \n. .. . . . . . . . . . . . . . . . . . . /* derived from n. -. q1 */ F = n(n |.|T).(n |.|T) -. q1 ng.(n \n|.|T| g)(q1) QF = -. q1 . .. . . . . . .. ng.(n |.|T| g)(q2) -. ng.(n |.|T| g)(qf ) .. -. q1qf -..T -. \nq1qf n(n |.|T).g(q1) -. n(n |.|T).g(q2) TT -. q1qf -.n. -. q1q1 n(n |.|T).g(qf ) -.nT -. q1q1 ng(q1) \n-. q1 .= /* derived from .g(q1) -. qf */ .g(q1) -. qf .. . . . . . .. .. . . . . . .. .g(q1) -..n -. \nqfq2 .(n |.|T| g)g(n |.|T| g)(q1) -.Tn -. qfq2 gn(q2) -. q2 /* derived from nT -. q2 */ gT(q2) -. .= \nqf .. . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . n(n |.|T)T(n |.|T) -. \nngT(n |.|T| g)(q1) gg(qf ) -. q2qf -. q2 The .rst component is for x, and the second component is for \ny ' . x ' = y This is the same automaton as for x = y ' , with the .rst component for x ' and the second \ncomponent for y. x i y Consider the automaton where ngT(n |.|T| g)(q2) -. q2 ngT(n |.|T| g)(qf ) -. q2 \nn(n |.|T)Tg(q1) -. q2 n(n |.|T)Tg(q2) -. q2 n(n |.|T)Tg(qf ) -. q2 /* derived from Tg(q2) -. qf */ T(n \n|.|T| g)g(n |.|T| g)(q2) -. qf /* derived from gg(qf ) -. qf */ g(n |.|T| g)g(n |.|T| g)(qf ) -. qf Q \n= {q1,q2,qf } This automaton is obtained from the automaton for x ' = F = {., T,g(\u00b7)}2 g(x) above by \napplying cylindri.cation twice. The tuples '' . = {qf } are QF ordered by x, y, x , and y , i.e., the \n.rst component . corresponds to x, the second component corresponds to y, T. -. qf and so on. The other \nfour cases are treated in exactly the same man\u00ad ner. . . . . . . . . . . . . n. -. q1 nT -. q1 ng(q1) \n-. q1 Tg(q1) -. qf ' . y = g(y) ' x = y ' x = y = .n -. q2 Tn -. q2 gn(q2) -. q2 g.(q2) -. qf .. . . \n. .. .. . . . .. gg(qf ) -. qf The .rst component is for x, and the second component is for y. Now we \napply cylindri.cation to the automata above. 5 We use the following shorthand for transition rules: f1(f2 \n| f3)(q) -. q ' 5Before applying cylindri.cation, we need to make these automata complete. Because of \nspace limitations and the tediousness of the construction, we simply use the original automata to illustrate \nhow cylindri.cation works. The basic construction is the same regardless whether the automata are complete \nor not. x i y Then we can construct the intersection of the .ve au\u00adtomata obtained through cylindri.cation \nand verify that the language accepted by the intersection is empty. With that, we conclude that the entailment \ndoes indeed hold. Due to space limitations, the rest of the construction is left to the reader.   \n\t\t\t", "proc_id": "503272", "abstract": "We investigate the first-order of subtyping constraints. We show that the first-order theory of non-structural subtyping is undecidable, and we show that in the case where all constructors are either unary or nullary, the first-order theory is decidable for both structural and non-structural subtyping. The decidability results are shown by reduction to a decision problem on tree automata. This work is a step towards resolving long-standing open problems of the decidability of entailment for non-structural subtyping.", "authors": [{"name": "Zhendong Su", "author_profile_id": "81100108298", "affiliation": "University of California, Berkeley, CA", "person_id": "PP14047875", "email_address": "", "orcid_id": ""}, {"name": "Alexander Aiken", "author_profile_id": "81100399954", "affiliation": "University of California, Berkeley, CA", "person_id": "P13911", "email_address": "", "orcid_id": ""}, {"name": "Joachim Niehren", "author_profile_id": "81100448425", "affiliation": "Universit&#228;t des Saarlandes, Saarbr&#252;cken, Germany", "person_id": "PP31042693", "email_address": "", "orcid_id": ""}, {"name": "Tim Priesnitz", "author_profile_id": "81100250693", "affiliation": "Universit&#228;t des Saarlandes, Saarbr&#252;cken, Germany", "person_id": "P343135", "email_address": "", "orcid_id": ""}, {"name": "Ralf Treinen", "author_profile_id": "81100446488", "affiliation": "Universit&#233; Paris-Sud, F91405 Orsay cedex, France", "person_id": "PP14156582", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/503272.503292", "year": "2002", "article_id": "503292", "conference": "POPL", "title": "The first-order theory of subtyping constraints", "url": "http://dl.acm.org/citation.cfm?id=503292"}