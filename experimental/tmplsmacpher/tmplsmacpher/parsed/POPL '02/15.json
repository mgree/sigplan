{"article_publication_date": "01-01-2002", "fulltext": "\n Representation Independence, Con.nement and Access Control [extended abstract] * Anindya Banerjee David \nA. Naumann Computing and Information Sciences Computer Science Kansas State University Stevens Institute \nof Technology Manhattan KS 66506 USA Hoboken NJ 07030 USA ab@cis.ksu.edu naumann@cs.stevens-tech.edu \nABSTRACT Denotational semantics is given for a Java-like language with pointers, subclassing and dynamic \ndispatch, class oriented visibility control, recursive types and methods, and privilege\u00adbased access \ncontrol. Representation independence (rela\u00adtional parametricity) is proved, using a semantic notion of \ncon.nement similar to ones for which static disciplines have been recently proposed. 1. INTRODUCTION \nFor scalable systems, scalable system-building tools, and scalable development methods, abstraction is \nessential. Ab\u00adstraction means that for reasoning about an individual com\u00adponent it is su.cient to consider \nother components in terms of their behavioral interface rather than the internals that implement the \ninterface. Abstraction is needed for the au\u00adtomated reasoning embodied in static analysis tools, e.g., \nbytecode veri.ers, and it is needed for formal and informal reasoning about functional correctness during \ndevelopment and validation. Modular reasoning has always been a cen\u00adtral issue in software engineering \nand in static analysis, but with the ascendancy of mobile code it has become absolutely essential. Abstraction \nis only sound to the extent that implementa\u00adtion internals are encapsulated. For example, the privilege\u00adbased \naccess control system of Java [11] is intended to en\u00adsure certain security properties, but its proper \nfunctioning depends on language-based encapsulation, e.g., type safety. Visibility controls, such as \nprivate .elds and opaque types, ensure certain information hiding properties. The classical way to give \na precise analysis of such properties is in terms of representation independence [33, 24]: client programs \nof a component are insensitive to di.erences in data representa\u00ad * Supported by NSF grants EIA-9806835 \nand CCR-0093080 Supported by NSF grant INT-9813854 Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 02 Jan. 16 18, 2002 Portland, OR USA Copyright 2002 ACM 1-58113-450-9/02/01 \n...$5.00. tion, provided the representation is private and the behavior of the component through its \nvisible interface is the same. The main proof technique for representation independence is so fundamental \nthat it has appeared in many places, with a variety of names, e.g., simulation, logical relations, ab\u00adstraction \nmappings, relational parametricity (e.g., [31, 35, 20, 8]). Our main result, an abstraction theorem, \nsays that simulation can be used for a rich fragment of Java. The result is given using a denotational \nsemantics in the man\u00adner of Scott-Strachey [39]. We apply the result to one of the Meyer-Sieber equivalences \n[21] that was a longstanding challenge for the semantics of Algol-like languages [30]. We discuss relational \nproofs of the equivalence of security pass\u00ading style [42] with the lazy stack inspection implementa\u00adtion \nof Java s privilege-based access control mechanism [11], and then extend our language to include access \ncontrol. We give an abstraction theorem for this extended language. The need for con.nement. Language-based \nencapsulation often runs afoul of aliasing. For variables and parameters, aliasing can be prevented through \nsyntactic restrictions that are tolerable in practice. Aliasing via pointers is an unavoid\u00adable problem \nin object oriented programming where shared mutable objects are pervasive. Here is the problem: Suppose \nclass A has a private .eld f that points to a mutable object intended to be an encapsulated part of the \nrepresentation of A. If a client program can also reference the object, the client can behave in representation-dependent \nways. More\u00adover, if it updates the object s state, an invariant of A may be violated. In simply typed \nlanguages, typed pointers help somewhat: pointer variables x, y are not aliased if they have di.erent \ntypes. This help is undercut by subclass polymorphism: in Java, a variable x of type Object can alias \ny of any type. The need for con.nement is ubiquitous and pressing in practice [17] (for the academic \nreader, evidence can be found in the number of recent OOPSLA and ECOOP papers on the topic). To achieve \nencapsulation for heap-allocated objects, there have been many proposals for con.nement. For exam\u00adple, \n.elds can be designated as unshared or read-only. Quite a few con.nement disciplines have been proposed \n(e.g., see [40, 7, 27, 4] and citations therein). Most have signi.cant shortcomings; they are too restrictive \nfor practical use, or not e.ciently checkable. Few have been formally justi.ed. Existing justi.cations \nuse disparate techniques such that it is quite hard to assess and compare con.nement disciplines [7, \n25, 18]. One of our contributions is to show how standard semantic techniques can be used for such assessments. \nThe challenges. A widely held view seems to be that clas\u00adsical techniques based on denotational semantics \nand logical relations are inadequate in the face of the complex language features of interest. The combination \nof local state with higher order procedures makes it di.cult to prove represen\u00adtation independence even \nfor Algol, where procedures can be passed as arguments but not assigned to state variables [29]; objects \nexhibit similar features. If procedures can be stored in state variables or in heap objects, the resulting \ndomain equations become quite challenging to solve. For applications in security and automated static \nchecking, it is important to devise robust, comprehensible models that support not only the idealized \nlanguages of research studies but also the full languages used in practice. Di.culties with denotational \nsemantics led to consider\u00adable advances using small-step operational semantics [12]. One of the most \nrelevant works is that of Grossman et al. [13] where representation independence is approached using \nthe notion of principal from the literature on security. To prove that clients are independent from the \nrepresentation of an abstraction provided by a host program, a wrapper construct is used to tag code \nfragments with their owner principal (e.g., client or host), and to provide an opaque type for the client \ns view of the abstraction. This is a promising approach, although their results seem rather limited: \nit is shown that if no host code is involved, the client cannot dis\u00adtinguish between di.erent values \nof the abstract type. This sort of result is used in analysis of information .ow, and can be proved using \nlogical relations [1]: a client is shown to preserve the complete (everywhere-true) relation on con\u00ad.dential \ndata. But logical relations are more powerful: the client can actually use host code, and its behavior \ncan de\u00adpend on values of the abstract type. A strong representation independence result says that, although \nthe behavior can depend on the abstract values, it cannot depend on their internal representations [22, \n23, 24]. Among the many uses of strong representation independence are program transfor\u00admations and justi.cation \nof logics for reasoning about data abstraction and modi.cation of encapsulated state. Although Grossman \net al. o.er their work as a simpler al\u00adternative to domain theoretic semantics, the technical treat\u00adment \nis somewhat intricate by the time the language is extended to include references, recursive and polymorphic \ntypes. Except for parametric polymorphism, we treat all these features, as well as subclassing and privilege-based \nac\u00adcess control. Results. Using an idealized Java-like language, our abstrac\u00adtion theorem says that if \ntwo implementations are given for a class A, and methods of these implementations preserve a given relation \non A-objects together with their con.ned rep\u00adresentation objects, then there are induced relations for \nall environments and heaps, and those relations are preserved by all client programs. An abstraction \ntheorem can be used to prove equivalence or re.nement of class implementations, general program equivalences, \nand correctness of static anal\u00adyses. e.g., secure information .ow. The proof technique has three steps. \n(1) Give a relation describing the way in which two class declarations implement the same abstraction \n, and show that it is preserved by all methods of the class. (2) Show that the induced (family of) relations \nare preserved by all client programs (the abstraction theorem). (3) Show that, for programs in which \nthe abstraction is encapsulated (e.g., in private .elds or local variables), the relation is the identity \n(the identity extension lemma).1 As we have formulated the abstraction theorem, it can be applied directly \nto prove command and class equivalences, and we give some examples. For applications in static anal\u00adysis, \nthe problem is usually to show that a syntax directed system of types and e.ects approximates some property \nlike secure information .ow. Such results are also proved using relations, and it was our own work on \nsecurity analysis [3] that gave us the courage to tackle parametricity for Java. We have not attempted \nto formulate an abstraction theorem general enough to apply directly in such analyses; they use analysis-speci.c \ntyping systems rather than the language s own types and syntax. But the essence of our result is that \nthe language is relationally parametric, given suitable con\u00ad.nement conditions. It is clear, for example, \nthat our static analysis for Java access control will extend to the language treated in the sequel. Why \nthe results are achievable. Our core language is quite rich. We include recursive classes and methods, \nand inheritance and casts as in Featherweight Java (FJ) [15] but with private visibility for .elds. We \nalso include mutable state, pointers, and type tests (instanceof). Our work grew out of a study of Java \ns stack-based access control mechanism. We used an idealized language similar to related work in the \narea [38, 42] and were surprised to .nd that a straightforward denotational semantics could be used to \nprove strong results using simulation. But the mech\u00adanism itself just protects calls to certain methods. \nTo prove, for some program using the mechanism, that some intrinsic security property holds, one needs \nto show that information does not leak. So we wanted to prove a general parametric\u00adity result that could \nbe applied to information .ow, and we wanted to include references. The problem is that, to get an adequate \ninduction hypoth\u00adesis, parametricity needs to be imposed on the latent e.ects of procedure abstractions.2 \nThese conditions are most easily expressed in terms of a denotational model, but if procedures can be \nstored in the heap on which they act, di.cult domain equations must be solved and the resulting complexity \nthen pervades the theory. Domain equations must also be solved to interpret most languages with recursive \ntypes. Although Java syntax seems less elegant than, say, lambda calculus, it has several features that \nease the di.culties. Owing to name-based type equivalence and subtyping, and the bind\u00ading of methods \nto objects via their class, we can use simple domains. The absence of pointer arithmetic means we need \nonly a mild assumption about the memory allocator. The fact that type names are semantically relevant \nlets us use them to formulate in semantic terms a con.nement condi\u00adtion similar to those in the literature \n[40, 25, 7] (but to keep things simple, we do not distinguish read-only access). Our results are proved \non the basis of this semantic condition. A modular static analysis, which does not require code anno\u00adtations, \ncan be derived from the semantic de.nition [2]. 1In the case of re.nement, identity is replaced by inequality \n[28]. In this paper we do not emphasize re.nement. 2As a property to be proved or, ideally, as an intrinsic \nfea\u00adture of the semantic model [34, 29]. Overview of the paper. Section 2 introduces the language with \nan example showing the necessity of con.nement. Then typing and semantic de.nitions are given; we defer \nthe ac\u00adcess control facility to Section 6. Section 3 formulates the basic situation to which the abstraction \ntheorem applies, in\u00adcluding con.nement, and de.nes the induced relations. Sec\u00adtion 4 gives the theorem \nand 5 applies it a Meyer-Sieber equivalence. Section 6 adds access control to the core lan\u00adguage and \nextends the abstraction theorem accordingly. The results are discussed in Section 7.  2. CORE LANGUAGE \nThe concrete syntax is based on that of Java, with some restrictions for ease of formalization; for example, \nreturn statements appear only at the end of a method, and e.ects like object construction (new) occur \nin commands rather than expressions. There are a couple of minor deviations from Java, e.g., the keyword \nvar marks local variable dec\u00adlarations. We retain the format Tx for declaration of a variable x of type \nT, while writing x:T in typing rules. 2.1 Examples A program consists of a collection of class declarations \nlike the following one. class Boolean extends Object { bool f; unit set(bool x){ this.f := x; return \nunit } bool get(){ skip; return this.f } } Instances of class Boolean have a private .eld f with the \nprimitive type bool. There is no constructor; .elds of new objects are given their Java defaults (null, \nfalse). Fields are considered to be private to their class and methods public: .elds are only visible \nto methods declared in this class, but methods are visible to all classes. Fields are accessed in expressions \nof the form this.f, using this to refer to the current object; a bare identi.er x is either a parameter \nor a local variable. Every method has a return type; unit corresponds to Java s void and is used for \nmethods like set that are called only for their e.ect on object state. In subsequent examples we omit \nreturns for the unit value, and sometimes omit this . Object types are implicitly pointers, so assignments \ncreate aliases. The built-in equality test == compares references. A convenient simpli.cation is to preclude \nside e.ects in expressions. We make no such restriction on the syntax, but the semantics discards e.ects \nof expressions, so our results are only interesting for programs that do not exploit expres\u00adsion e.ects. \nFor example, the get method above is useful in expressions, but not set. Here is a class that uses a \nBoolean for its private state. class A0 extends Object { Boolean g; unit init(){ this.g:= new Boolean(); \ng.set(true)} unit setg(bool x){ g.set(x) } bool getg(){ return g.get() } } An alternative implementation \nof A0 uses an isomorphic rep\u00adresentation to achieve the same behavior. class A0 extends Object { Boolean \ng ; unit init(){ this.g := new Boolean(); g .set(false) } unit setg(bool x){ g .set(not(x)) } bool getg(){ \nreturn not(g .get()) } }  Let us consider, informally, how representation indepen\u00addence is formulated \nand used for the example. First, we give a relation between states of objects o and o for the two implementations.3 \nWe say o and o are related just if either o.g = null = o .g or o.g = null o .g and o.g.f = \u00ac(o .g .f). \nIf o,o are newly constructed, o.g = null = o .g holds. Invocations of setg and getg clearly maintain \nthe relation. According to the abstraction theorem, the relation is main\u00adtained by all client programs. \nAnd this implies that a client using o in a local variable or .eld cannot be distinguished from one using \no . However, such a conclusion is unwar\u00adranted unless o,o are suitably con.ned. For example, sup\u00adpose \nwe add to A0 a method Object bad(){ return g } (For the second, primed version of A0, let it return \ng .) A client class C can exploit method bad using a (Boolean) cast: varA0z :=nullin z := new A0(); var \nBoolean w := (Boolean) z.bad() in if (w.get()) then skip else diverge; Although the .eld g of A0 is \nnot visible to methods in class C, method bad leaks a reference to the representation object. The command \ndiverges if the primed implementation of A0 is chosen, but does not diverge with the .rst implementation. \n 2.2 Syntax To formalize the language, we adapt some notations from FJ [15]. To avoid burdening reader \nwith straightforward technicalities we deliberately confuse surface syntax with abstract syntax, and \nwe do not distinguish between classes and class types. We also confuse syntactic categories with names \nof their typical elements. Barred identi.ers like T in\u00addicate .nite lists, e.g., Tf stands for a list \nf of .eld names with corresponding types T . The bar has no semantic im\u00adport; T has nothing to do with \nT . The grammar is based on given sets of class names (with typical element C), .eld names (f), method \nnames (m), and variable/parameter names x (including this). T ::= bool | unit | C CL ::= class C extends \nC { Tf; M } M ::= Tm(Tx){S; return e} S ::= x := e | x.f := e | x := new C() | x.m(e) | if eS1 else S2 \n| var Tx := e in S | S; S e ::= x | e.f | e.m(e) | e==e | (C) e | null | e instanceof C Well formed \nclass declarations are speci.ed by rules below and in Table 1. A judgement of the form G; C f e : T 3In \npractice, one would show that this relation is established by the constructors. Our omission of constructors \nmeans that examples may need initialization methods and extra .elds to track whether initialization has \nbeen done. In the case at hand, nullity of g su.ces. Table 1: Typing rules for expressions and commands \nG; C f x :Gx G; C f null : B G; C f e : DB = D mtype(m, D)=(x : T ) . T G; C f (B) e : B G; C f e : \nD G; C f e1 : T Tf . d.elds C G; C f e : UU = T G; C f e2 : T G; C f e : C G; C f e : DB = D G; C f \ne.m(e): T G; C f e1 ==e2 : bool G; C f e.f : T G; C f e instanceof B : bool x Gx = C Tf . d.elds C mtype(m, \nGx)=(x : T ) . T = this x B = Gx = this G; C f e : TT = G x G; C f e : UU = T G; C f e : UU = T G; C \nf x := new B(): com G; C f x := e : com G; C f x.f := e : com G; C f x.m(e): com G; C f e : bool G; C \nf S1 : com G; C f e : U U = T G; C f S1 : com G; C f S2 : com G; C f S2 : com (G, x : T ); C f S : com \nG; C f if e S1 else S2 : com G; C f S1; S2 : com G; C f var T x := e in S : com says that e has type \nT in the context of a method of class C, with parameters and local variables declared by G. A judgement \nG; C f S : com says that S is a command in the same context. A complete program is given as a class table \nCT that associates each declared class name with its declaration. The typing rules make use of several \nauxiliary notions that are de.ned in terms of CT ; dependence on CT is elided in the notation. Because \ntyping of each class is done in the context of the full table, methods can be mutually recursive, and \nso can .eld types. The rules for .eld access and update enforce privacy. Slight desugaring is needed \nto express the examples, e.g., g.set(x) is short for var Boolean y := this.g in y.set(x). Subsumption \nis built in to the rules using the subtyp\u00ading relation = on T speci.ed as follows. For base types, bool \n= bool and unit = unit. For classes C and D, we have C = D i. either C = D or the class declaration for \nC is class C extends B { ... } for some B = D. To de.ne some auxiliary notation, let M be in M, with \nCT (C)= class C extends D { Tf; M } M = Tm(Tx){S; return e} Then we de.ne mtype(m, C)=(x : T ) . T . \nFor the de\u00adclared .elds, we de.ne d.elds C = Tf and type(f,C)= T . To include inherited .elds, we de.ne \n.elds C = d.elds C . .elds D, and assume f is disjoint from the names in .elds D. The undeclared class \nObject has no methods or .elds. Note that mtype(m, C) is unde.ned if m is not declared or inher\u00adited \nin C. Here is the typing rule for method declarations: (x : T, this : C); C f S : com (x : T, this : \nC); C f e : UU = T  mtype(m, D) is unde.ned or equals (x : T ) . T C extends D f Tm(Tx){S; return e} \nA class declaration is well formed if all of its methods are: C extends D f M for each M . M f class \nC extends D { Tf; M }  2.3 Semantics The state of a method in execution is comprised of a heap h, which \nmaps locations to object states, and an environ\u00adment ., which assigns locations and primitive values \nto local variables and parameters. Every environment of interest in\u00adcludes this which points to the target \nobject. We assume that a countable set Loc is given, along with a distinguished entity nil not in Loc. \nA heap h is a .nite partial function from Loc to object states. To streamline no\u00adtation, we treat object \nstates as mappings from .eld names to values. We also need to track the object s class, which is not \nmutable. As a harmless coding trick, we assume given a function loctype : Loc . ClassNames such that \nfor ev\u00adery class C there are an in.nite number of locations f with loctype f = C. We write locs C for \n{f | loctype f = C} and locs(C.) for {f | loctype f = C}. One of the shortcomings of classical Scott-Strachey \nse\u00admantics is its sensitivity to choice of locations. If two en\u00adcapsulated data representations take \ndi.erent amounts of memory, it is quite possible that a real memory allocator will return di.erent addresses \neven in states where the two representations are related. One way to deal with this is\u00adsue is to consider \nall possible allocators, and then quotient the resulting model. We choose a simpler solution; we just \nassume that a parametric allocator is given. De.nition 1. An allocator is a function fresh such that \nloctype(fresh(C, h)) = C and fresh(C, h) . dom h, for all C, h. An allocator is parametric provided that \nfor all classes C and heaps h1,h2 dom h1 n locs C = dom h2 n locs C . fresh(C, h1)= fresh(C, h2) For \nexample, if Loc = Nthe function fresh(C, h)= min{f |loctype f = C . f . dom h} is a parametric allocator. \nCapa\u00adbility-based systems provide locations as abstract values in order to achieve parametricity for \nsecure information .ow. Table 2 gives the semantic domains. There are several auxiliary domains, such \nas Heap and C state, elements of which are not directly denotable. We describe these seman\u00adtic categories \n. in a grammar, for use later in the de.nition of the induced relations. We write -for .nite partial \nfunc\u00adtions. It is easy to show if T = U then [ T ] . [ U]]. Table 3 gives the semantics of expressions, \ndependent on an arbitrary method environment \u00b5 in [ MEnv]]. Table 4 gives the semantics of commands. \nIt is straightforward to show that, as in Java, no program constructs create dangling pointers. One might \nexpect us to con.ne attention to heaps that are closed, in the sense that every location in the range \nis in the domain. But this would add unenlightening complications to some de.nitions. Table 2: Semantic \ndomains. . ::= T | G | C state | Heap | (C, (x : T ) . T ) | MEnv | .. | . \u00d7 . [ bool] = {true, false} \n[ unit] = { } [ C] = {nil}.{f | f . Loc . loctype f = C} . . [[G]] . dom . = dom G ..x . dom ...x . [[G \nx] s . [ C state] . dom s = .elds C ..f . .elds C . sf . [ type(f, C)]] h . [ Heap] . dom h . Loc ..f \n. dom h . hf . [[(loctype f) state] [ C, (x : T ) . T ] =[ x : T, this : C] . [ Heap] . ([[T ] \u00d7 [ Heap]]). \n[ MEnv] =(C : ClassNames) -(m : MethodNames) -[ C, mtype(m, C)]] [ .1 \u00d7 .2] = [ .1] \u00d7 [ .2] [ ..] = [ \n.] . (we assume . isnotin [ .]]) Meanings of expressions: [[G; C f e : T ] . [ MEnv] . [[G]] . [ Heap] \n. [ T ] . Meanings of commands: [[G; C f S : com] . [ MEnv] . [[G]] . [ Heap] . ([[G]] \u00d7 [ Heap]]). So \nthe semantics is de.ned even for heaps with dangling pointers. Like cast failures, dereferences of dangling \npoint\u00aders and nil are considered an error. Rather than modelling exceptions, we identify all errors, \nand divergence, with the improper value .. The semantic de.nitions use a metalanguage construct, let \nd = E1 in E2, with the following meaning: If the value of E1 is . then that is the value of the entire \nlet expression; otherwise, its value is the value of E2 with d bound to the value of E1. Function update \nis written, e.g., [. | x .d]. The semantic de.nitions are given with respect to an ar\u00adbitrary method \nenvironment, but we are really interested in the method environment given as a .xpoint, properly inter\u00adpreting \nmutually recursive methods. Toward this end, it is convenient to de.ne the semantics of method declarations. \nIf, in class C, we have M = Tm(Tx){S; return e}, then for any \u00b5, de.ne [ M] \u00b5 . [[(C, (x : T . T ))]] \nby [ M] \u00b5.h = let (.0,h0) = [[(x : T , this : C); C f S : com] \u00b5.h in let d = [[(x : T , this : C); C \nf e : T ] \u00b5.0h0 in (d, h0) We only take .xpoints for method environments; these are ordered pointwise, \nin terms of method meanings. The latter are function spaces [ C, (x : T ) . T ] into lifted sets. Thus, \nto get pointed complete partial orders for method environ\u00adments, it su.ces to use equality as the order \non [ Heap]], [ bool]], [ C]], and [ C state]]. We de.ne an ascending chain \u00b5 . N . [ MEnv] as follows. \n\u00b50 Cm = ... .h. . \u00b5j+1 Cm =[ M] \u00b5j if m declared as M in C \u00b5j+1 Cm = \u00b5j+1 Bm if m inherited from B in \nC The semantics of the class table is the least upper bound, \u00b5 , of this chain.  3. SIMULATION AND \nCONFINEMENT The aim of this section is to formulate the (indexed family of) relations de.ned inductively, \nbased on a given relation connecting two representations for an instance of a class A. After introducing \nconvenient notation for heaps, from BI a relation is given. Then we formalize con.nement and the induced \nrelation. We say heaps h1 and h2 are disjoint if dom h1 n dom h2 = \u00d8. Let h1 * h2 be the union of h1 \nand h2 if they are dis\u00adjoint, and unde.ned otherwise. To say that no objects in h1 contain references \nto objects in h2, we de.ne4 h1 h2 ..f . dom h1 . rng(h1 f) n dom h2 = \u00d8 It is crucial for our formulation \nof con.nement that we work with partitions h1 *h2 where h1 and h2 have dangling point\u00aders (as in the \npioneering work of Reynolds [36]). In our formalization, representation objects for A all have a common \nsupertype Rep. We shall partition the heap as h = hA * hRep * hOut where hA contains just the object \nof class A being abstracted, hRep contains zero or more objects of class Rep that comprise the representation \nof A, and hOut contains all other objects. Beware that we use multi-letter identi.ers like hA that beg \nto be (wrongly) parsed as an application hA of h to A. Our use of class names depends on the assumption \nthat Rep = A and Rep = A, and the same for Rep'. It also precludes use of, say, a library class both \nin representions and in outside objects. But these convenient coding tricks are easily circumvented (e.g., \nas in [25]). De.nition 2. A basic simulation is given by: well formed class tables CT,CT ' that are identical \nsave for their values on A, where CT (A)= class A extends B { Tg; M } CT '(A)= class A extends B { T \n' g'; M' } We write f, f' for the typing relations determined by CT,CT ' respectively, and [ -] , [ -] \n' for the semantics. two distinguished classes Rep, Rep' relation R such that R . [ Heap] \u00d7 [ Heap] \n'  4One might think it better to de.ne the positive notion that all pointers from h1 are into h2, but \nthis is less convenient pointer logic [16], we formalize the basic situation in which because we allow \ndangling pointers. Table 3: Semantics of expressions. [[G; C f x : T ] \u00b5.h = .x [[G; C f null : B] \u00b5.h \n= nil [[G; C f e1 ==e2 : bool] \u00b5.h = let d1 = [[G; C f e1 : T ] \u00b5.h in let d2 = [[G; C f e2 : T ] \u00b5.h \nin (d1 = d2) [[G; C f e.f : T ] \u00b5.h = let f = [[G; C f e : C] \u00b5.h in if f . dom h then . else hff [[G; \nC f e.m(e): T ] \u00b5.h = let f = [[G; C f e : D] \u00b5.h in if f . dom h then . else let (x : T ) . T = mtype(m, \nD) in let d = \u00b5(loctype f)m in let d = [[G; C f e : U] \u00b5.h in let (d0,h0)= d[x . d, this . f]h in d0 \n[[G; C f (B) e : B] \u00b5.h = let f = [[G; C f e : D] \u00b5.h in if f . dom h . loctype f = B then f else . [[G; \nC f e instanceof B : bool] \u00b5.h = let f = [[G; C f e : D] \u00b5.h in f . dom h . loctype f = B for any h, \nh ' , if Rhh ' then there are partitions h = hA * hRep and h ' = hA ' * hRep ' and location f with loctype \nf = A, such that  dom hA = {f} = dom hA ' ,  dom(hRep) . locs(Rep.) (and for hRep ' , Rep ' ),  R \n(type(f, loctype f)) (hff)(h ' ff) for all .elds f . .elds(loctype f) with f . g (see below).   default \nstates are related: for any f . locs(A.), R relates [f . [.elds(loctype f) . defaults]] to [f . [.elds \n' (loctype f) . defaults ' ]]  Relation R is used to connect the private .elds of a pair of objects \nfor the two implementations of A, along with the representation objects referenced by those .elds. The \ncon\u00addition involving R is a healthiness assumption imposed on inherited .elds and subclass .elds. It \nis formulated using the induced relations R of De.nition 5. This forward refer\u00adence introduces no circularity \nin our de.nitions. In fact the condition simply requires hff = ff, because R T is the h ' identity for \nevery data type T , but we feel that explicit use of R is conceptually more clear. The induced relations \nR handle objects other than Rep objects. We say C is a non-rep class i. C = Rep and C = Rep ' . We extend \nthis to categories . so that C state and (C, (x : T ) . T ) are non-rep i. C is. Examples. For the example \nof A0 in Section 2.1, we take Rep, Rep ' to be Boolean,Boolean where Boolean is a fresh Table 4: Semantics \nof commands [[G; C f x := e : com] \u00b5.h = let d = [[G; C f e : T ] \u00b5.h in ([. | x.d],h) [[G; C f x.f := \ne : com] \u00b5.h = let f = .x in if f . dom h then . else let d = [[G; C f e : U] \u00b5.h in (., [h | f.[hf | \nf .d]]) [[G; C f x := new B(): com] \u00b5.h = let f = fresh(B, h) in ([. | x.f], [h | f .[.elds B . defaults]]) \n[[G; C f x.m(e): com] \u00b5.h = let f = .x in if f . dom h then . else let (x : T ) . T = mtype(m, Gx) in \nlet d = \u00b5(loctype f)m in let d = [[G; C f e : U] \u00b5.h in let (d0,h0)= d[x . d, this . f]h in (., h0) \n[[G; C f if eS1 else S2 : com] \u00b5.h = let b = [[G; C f e : bool] \u00b5.h in if b then [[G; C f S1 : com] \u00b5.h \nelse [[G; C f S2 : com] \u00b5.h [[G; C f S1; S2 : com] \u00b5.h = let (.0,h0) = [[G; C f S1 : com] \u00b5.h in [[G; \nC f S2 : com] \u00b5.0h0 [[G; C f var Tx := e in S : com] \u00b5.h = let d = [[G; C f e : U] \u00b5.h in let (.0,h0) \n= [[(G,x : T ); C f S] \u00b5[. | x .d]h in (.0.x, h0) copy of Boolean. We de.ne R to relate h, h ' just \nif 5 h = [f1 . [g . nil]] and h ' =[f1 . [g ' . nil]], or h =[f1 . [g . f2],f2 . [f . d]] h '' =[f1 . \n[g . f3],f3 . [f .\u00acd]] for some boolean d and locations f1,f2,f3. As another example, consider a class \nA2 that is to contain a non-negative integer. In one version, this is stored as a primitive int in a \n.eld named f. In the other version, .eld f ' points to a singly linked, nil-terminated list of objects \nof class Node. We take Rep arbitrary and Rep ' = Node, and R relates h, h ' just if h is a singleton \nheap [f . [f . j]] for some j = 0, and h ' =[f . [f ' . f1]] * h ' 1 where h1 ' contains a singly linked \nlist of length j starting with some f1. Con.nement. Con.nement is imposed on the heap, which can contain \nmultiple instances of the related class A, each with zero or more associated representation objects. \nWe require that in every state the heap can be partitioned as shown in Figure 1, with references restricted \nas in the pic\u00adture. In practice, it is important to distinguish read-only references, e.g., if the Rep \nobjects are used as nodes in a data structure representing a container or set, these nodes 5If A0 has \nsubclasses, the relation on their .elds is deter\u00admined by the healthiness assumption for basic simulations. \nshould be able to point to the outside objects in hOut, but only for reading [25]. But this would complicate \nour presentation; our aim is to show a set-up in which one can formalize con.nement disciplines, compare \nthem, and prove that syntactic restrictions do ensure the desired semantic con.nement. Figure 1: Con.nement \nexample. Dotted references disallowed. De.nition 3. An admissible partition of heap h is a set of pairwise \ndisjoint heaps hOut,hA1,hRep1,...,hAk,hRepk with h = hOut * hA1 * hRep1 * ... * hAk * hRepk and for all \ni dom hAi . locs(A.) and size(dom hAi)=1  dom hRepi . locs(Rep.)  dom hOut n (locs(A.) . locs(Rep.)= \n\u00d8  Note that a heap may have several admissible partitions, e.g., if there are inaccessible Rep objects. \nThe reader can check that the de.nitions and results do not depend on choice of partition in these cases. \nThe condition hOut hRepi is clearly needed to pre\u00adclude representation-dependent behavior as in the example \nin Section 2.1 using the bad method. We also need to impose the condition hRepi hOut to prevent Rep objects \nfrom de\u00adpending on outside objects that could be changed by clients; such changes need not preserve the \nbasic simulation relation. Similar conditions are ensured by module-based notions of con.nement in the \nliterature (e.g., [40]). But our notion of simulation is instance-based, so we also require that A objects \nare isolated from each other and each other s rep\u00adresentations. This is similar to the ownership model \n[7, 25] and notions of unique references such as [4]. De.nition 4. We say heap h is con.ned, and write \nconf h, i. h has an admissible partition such that for all i, j hOut hRepi  hRepi hOut  i = j . hAi \n* hRepi hAj * hRepj  Con.nement of an environment . depends on the heap and on the class in which the \nenvironment is used. For non-rep C di.erent from A, de.ne conf C.h i. rng . n locs(Rep.)= \u00d8. For A, de.ne \nconf A.h i. there is a partition with rng . n (locs(Rep.) . locs(A.)) . dom(hRepj * hAj ) for some j \nwith dom(hAj )= {. this}. Method environment \u00b5 is con.ned, written conf \u00b5, i. for all non-rep C, and \nall m, h, ., if conf h and conf C.h then \u00b5Cm.h = .. let (d, h0)= \u00b5Cm.h in conf h0 . d . locs(Rep.) For \ncommands, we say, for non-rep C, that G; C f S : com is con.ned i. for any con.ned h, \u00b5 and . con.ned \nin C, h: [[G; C f S : com] \u00b5.h = .. let (.0,h0) = [[G; C f S : com] \u00b5.h in conf h0 . conf C.0 h0 For \nexpressions, for non-rep C = A we say G; C f e : T is con.ned i. for any con.ned h and \u00b5, and . con.ned \nin C, h: [[G; C f e : T ] \u00b5.h . locs(Rep.) For A, we say G; A f e : T is con.ned i. for any con.ned \nh and \u00b5, and . con.ned in A, h: [[G; A f e : T ] \u00b5.h = .. let d = [[G; A f e : T ] \u00b5.h in d . (locs(A.) \n. locs(Rep.)) . d . dom(hAj * hRepj ) for some j with dom(hAj )= {. this}. Finally, CT is con.ned i. \n(i) for every non-rep C = A and every M in CT (C) of form Tm(Tx){S; return e}, it is the case that S, \ne, and all constituents thereof are con.ned; (ii) for every Tm(Tx){S; return e} declared in A, both S \nand e are con.ned; and (iii) for every C, m with mtype(m, C)=(x : T ) . T we have (a) = Rep . T> = Rep \nC = A . T> = A . T> (b) C = A . C = Rep . T>= Rep The relation > = T2 . T1 = T2 .T1 = T2. = is de.ned \nby T1 >Note that T1 >. [ T1] n [ T2] = \u00d8. = T1 to = T2 We write T>express that T>for all T in T . = T1 \n Con.nement for CT involves syntactic conditions which ensure con.nement of method calls, e.g., a client \nobject can\u00adnot pass to one A.-object a reference to another A.-object. This is di.cult to express in \nterms of the semantics. At .rst glance the syntactic conditions may appear rather strong, but we have \nnot found non-trivial examples that violate the conditions without also violating heap con.nement. Else\u00adwhere \n[2] we give mild syntactic conditions that su.ce for con.nement of a class table, e.g., methods of non-rep \nclass C = A cannot construct new Rep objects. In practice, Rep would be local to a module not containing \nC. As an example, let A be class A0 in Section 2.1, and let Rep be Boolean. Consider an initial heap \nwith no objects of these types; it is con.ned. If x is a variable of type A0, the command x := new A0() \nin a method of some client class C = A is con.ned, as the new object has x.g initially null. A subsequent \ncall x.init() is also con.ned, as the newly constructed Boolean object is not leaked. All of the methods \nin both versions of A0 are con.ned. However, if the bad method is added, the example command using it \nis not con.ned, due to the expression z.bad(). And the bad method violates (iii)(a) in the de.nition \nof con.ned class table. In an earlier version of this paper, we erroneously used the con.nement condition \nfor A-environments for subclasses of A, misled by considerations about inheritance. The follow\u00ading result \nis the key to reasoning about con.nement of calls to inherited methods. Lemma 3.1. For nonrep C, B, if \nC = B and conf C.h then conf B.h, for all environments . for parameters of methods of B. For the main \nLemma 4.2, we need constituents of non-A methods to be con.ned, hence the separate cases (i) and (ii) \nin the de.nition of con.ned class table. For the following result we only need that method bodies are \ncon.ned. Lemma 3.2. Suppose CT is con.ned. Then the environ\u00adment \u00b5 obtained as a .xpoint is con.ned, \nas is each \u00b5i in the approximation chain. Induced relation. Finally, we can de.ne the induced rela\u00adtion \nR. For non-rep categories . we have R . . [ .] \u00d7 [ .] ' . De.nition 5. For heaps h, h ' , we de.ne R \nHeap hh ' i. conf h and conf h ' and there exist admissible partitions of h, h ' , of the same size, \nsuch that for the given R R (hAi * hRepi)(hAi ' * hRepi' ) for all i, and dom(hOut)= dom(hOut ' ), and \n.f . dom(hOut) . R ((loctype f) state)(hf)(h ' f). For other categories, we de.ne R . as follows. R bool \ndd ' . d = d ' R unit dd ' . d = d ' R Cff ' . f = f ' R G .. ' ..x . dom G . R (Gx)(.x)(. ' x) R (C \nstate) ss ' . .f . .elds C. R (type(f, C)) (sf)(s ' f), for C = A R (C, (x : T ) . T ) dd ' ..d, d ' \n, h, h ' ,f. (R T dd ' .R Heap hh ' . conf C.h . conf C. ' h ' ) .R (T \u00d7 Heap). (d.h)(d ' . ' h ' ) where \n. =[x . d, this . f],. ' =[x . d ' , this . f] R MEnv \u00b5\u00b5 ' . for all non-rep C .m. R (C, mtype(m, C)) \n(\u00b5Cm)(\u00b5 ' Cm) R (..) aa ' . (a = . = a ' ) . (a = . = a ' .R .aa ' ) Note that we do not need to de.ne \nR (C state) ss ' for C = A; the relation on states is only used in de.ning the relation on heaps, and \nthere only for non-rep C = A. Fact 3.3. For all h, h ' and f . (locs(Rep.).locs(Rep ' .)), if R Heap \nhh ' then f . dom h . f . dom h ' . Fact 3.4. For any data type T , R T is the identity rela\u00adtion. As \na corollary, if U = T and R Udd' then R T dd' .  4. THE ABSTRACTION THEOREM Theorem 4.1. Suppose we \nare given a basic simulation, with CT,CT ' con.ned. Suppose further that for every con\u00ad.ned \u00b5, \u00b5 ' , \nand for every method declaration M in CT (A) (respectively M ' in CT ' (A)), we have ' ] '' (*) R MEnv \n\u00b5\u00b5 ' .R (A, mtype(m, A)) ([[M] \u00b5) ([[M\u00b5 ) Then R (C, mtype(m, C)) ( \u00b5Cm) ( \u00b5 ' Cm) for every m and non-rep \nC, that is, R MEnv \u00b5 ' , where \u00b5 ' are the .x\u00ad \u00b5 \u00b5, points for CT,CT ' . Proof. First, we show by induction \nthat for every i we have R MEnv \u00b5i \u00b5 ' i. For the base case, for every C, m we have R (C, mtype(m, C)) \n(\u00b50 Cm)(\u00b50 ' Cm) because . relates to .. For the induction step, suppose R MEnv \u00b5i \u00b5i' . We consider \ncases on whether C = A. For C = A, we apply Lemma 4.2, below, to \u00b5i,\u00b5i' . For C = A and m declared in \nA, we have R (A, mtype(m, A)) (\u00b5i+1 Am)(\u00b5i' +1 Am) by hypothesis (*) and de.nition of \u00b5i+1. For m inherited \nin A from B = A, we use Lemma 3.1 and the de.nition of R to show that R (A, mtype(m, A)) (\u00b5i+1 Am)(\u00b5i' \n+1 Am) follows from R (B, mtype(m, A)) (\u00b5i+1 Bm)(\u00b5i' +1 Bm). Now, \u00b5 ' \u00b5, are the least upper bounds \nof the chains we just showed are related. It remains to show that .i. R (C, mtype(m, C)) (\u00b5i Cm)(\u00b5i ' \nCm) implies R (C, mtype(m, C)) (i\u00b5i Cm)(i\u00b5i ' Cm). This is routine. To serve as an induction hypothesis, \nthe statement of the lemma is a little complicated. In essence, it says that each constituent expression \ne and command S of each method outside class A preserves the relation. Lemma 4.2. Suppose a basic simulation \nis given, such that CT and CT ' are con.ned. Then, for all non-rep classes C = A, all constituent expressions \nG; C f e : T and com\u00admands G; C f S : com in methods declared in C, and all con.ned \u00b5, \u00b5 ' , the following \nholds. For all con.ned heaps h (resp. h ' ) and environments . con.ned for C, h (resp. . ' for C, h ' \n), if R MEnv \u00b5\u00b5 ' , R Heap hh ' , and R G .. ' then R (T.) ([[G; C f e : T ] \u00b5.h) ([[G; C f ' e : T ] \n' \u00b5 ' . ' h ' ) S] '' . ' h ' R (G \u00d7 Heap). ([[G; C f S] \u00b5.h) ([[G; C f ' \u00b5 ) Proof. For lack of space, \nwe consider only the case of method call as a command, using identi.ers as in the seman\u00adtic de.nition \nin Table 4 (and their primed counterparts). By R G . , we have R (G x) f , hence f = by . ' f ' f ' \nFact 3.4. By conf C.h and C = A we have f . locs(Rep.) and f . locs(Rep ' .). Hence, by Fact 3.3, if \nf . dom h then f . dom h ' , in which case both semantics are . and R (G \u00d7 Heap). ... It remains to consider \nthe case f . dom h n dom h ' . By induction on e, either [[G; C f e : U] \u00b5.h = . and ' . ' [[G; C f \ne : U] ' \u00b5h ' = ., and thus we get the result be\u00ad cause R (G \u00d7 Heap). .., or neither is .. In the latter \ncase, let .0 =[x . d, this . f] (resp. .0' ) where d, d ' are as in the semantic de.nition. Since R MEnv \n\u00b5\u00b5 ' , we have R ((loctype f), (x : T ) . T )(\u00b5(loctype f)m)(\u00b5 ' (loctype f)m) by de.nition R(MEnv). \nSince R Heap hh ' and assuming we can show conf (loctype f) .0 h (resp. conf (loctype f) .0 ' h ' ) and \nR T dd ' , we have R (T \u00d7 Heap). (\u00b5(loctype f).0h)(\u00b5(loctype f).0' h ' ), by def\u00adinition R((loctype f), \n(x : T ) . T ) and loctype f = Rep. Now, either \u00b5(loctype f).0h = . = \u00b5(loctype f).0' h ' , in which \ncase we have related results, or R Heap h0 h ' 0, whence R (G \u00d7 Heap). (., h0)(. ' ,h ' 0), where h0,h0 \n' are the heaps returned by \u00b5(loctype f).0h, \u00b5(loctype f).0' h ' . It remains to show R T dd ' and conf \n(loctype f) .0 h (resp. conf (loctype f) .0 ' h ' ), for which we go by cases on loctype f. Recall that \nf . locs(Rep.), so (loctype f) = Rep. (i) loctype f = A, i.e., either loctype f<A or loctype f = A. \nIn either case, since CT is con.ned, by condition (iii)(a) or (iii)(b) in the de.nition of con.ned CT \n, we know T> = Rep. By induction on e, we get R U dd ' (as we are con\u00adsidering the non-. case). Thus, \nby U = T and the corol\u00adlary to Fact 3.4, R T dd ' . Because T>we = Rep, have, d . locs(Rep.). Now conf \n(loctype f) .0 h . rng .0 n locs(Rep.)= \u00d8. And rng .0 n locs(Rep.)= {d, f}n locs(Rep.)= \u00d8, since d . \nlocs(Rep.) and f . locs(Rep.). (ii) loctype f = A: Hence f . locs(A.). Since CT is con.ned, by condition \n(iii)(a) in the de.nition of con.ned CT , we know T> = Rep. = A and T>As in case (i), induction on e \nyields R T dd' . = A and T> Because T> = Rep, we have, d . locs(A.) and d . locs(Rep.). Now conf (loctype \nf) .0 h . rng .0 n (locs(Rep.) . locs(A.)) . dom(hAj *hRepj ) for some j where dom(hAj )= {.0 this} = \n{f}. And rng .0 n (locs(Rep.) . locs(A.)) = {d, f}n (locs(Rep.) . locs(A.)) = {f}. dom(hAj * hRepj ), \nfor some j and dom(hAj )= {.0 this} = {f}. Identity extension. The abstraction theorem is usually used \nin conjunction with an identity extension lemma. A typical formulation says that R T is the identity \non any type T for which it is the identity on all base types b that occur in T . The reason is that no \nvalue of type b can occur in a value of type T if b does not occur in T . This fails with extensi\u00adble \nrecords and structural subtyping, and with procedures that may have global variables [28]. It can be \nmade to work using name-based (declaration) subclassing [6], but it turns out that for our purposes it \nis enough to deal with the heap. In our language, R T is the identity for every data type T (Fact 3.4), \nbut that is only because the interesting data is in the heap which is not typed at all.6 In general, \n[ A state] =[ A state] ' and R(A state) is not the identity. Related heaps can contain A. objects with \ndi.erent states that may point to completely di.erent Rep. objects. But consider executing a method on \nan object o from whose .elds no A objects are reachable, i.e., A objects are not part of the representation \nof o. The resulting heap may contain A objects that were assigned to local variables, but if the method \nis con.ned then those objects are unreachable in the .nal state. Enter garbage collection. For a set \nor list d of values, de.ne the heap collect(d, h) to be the restriction of h to cells reachable from \nelements of d. Say h is A-free just if dom h n locs(A.)= \u00d8. Lemma 4.3. Suppose R (G \u00d7 Heap)(., h)(. ' \n,h ' ). If both collect((rng .),h) and collect((rng . ' ),h ' ) are A-free then collect((rng .),h)= collect((rng \n. ' ),h ' ). Proof. Related heaps are con.ned, by de.nition R Heap. In con.ned heaps, Rep. objects are \nonly reachable from A. objects. Now the argument is a straightforward induction using the de.nition of \nR. An A-free heap in [ Heap] is also an element of [ Heap] ' , and [[G]] = [[G]] ' for any G. For any \nR, a con.ned A-free h has no Rep.-objects, and R Heap hh. To compare commands interpreted with respect \nto CT and CT ' , we say commands G; C f S : com and G; C f ' 6Nor would we want to impose a typing system \non the heap, as it would likely preclude unbounded data structures [13]. S ' : com are equivalent i. \nthe following holds, where d is the semantics of S in CT and d ' the semantics of S ' in CT ' : For every \ncon.ned A-free heap h and every . . [[G]] with conf C.h, either d.h = . = .h or neither d ' . ' collect((rng \n.0),h ' 0), where (.0,h0)= d.h and (.0' ,h ' 0)= d ' .h. is . and moreover .0 = 0 and collect((rng .0),h0)= \nExample. Consider a client class C with a method contain\u00ading the following command, typed in some A0-free \nenviron\u00adment G with G b = bool. varA0z :=nullin z := new A0(); z.setg(true); b := z.getg()  Let d (resp. \nd ' ) be the meaning of this command, using the .rst version (resp. primed version) of A0 in Section \n2.1. Let R be the relation described in Section 2.1 and formalized following De.nition 2. It is straightforward \nto show that the induced relation holds between methods of the two ver\u00adsions of A0. To show that d is \nequivalent to d ' , consider any con.ned, A0-free heap h and environment . con.ned in C, h. We have R \nHeap hh and R G .., and by the abstraction theorem d and d ' are related, so we get related outcomes \nd.h and d ' .h. If the outcome is not . then these related environments are equal (they do not contain \nany A0 loca\u00adtions) and the related heaps, once collected, are equal by the identity extension Lemma 4.3. \nSection 2.1 gives an example command that exploits the representation object leaked by the bad method. \nFor that command the abstraction theorem does not apply because that method is not con.ned. The two interpretations \nof the command are not equivalent; it acts as skip using the .rst version of A0 and diverges using the \nprimed version. 5. APPLICATION The following example is based on one of the Meyer-Sieber equivalences \n[21], which we .rst recall in Algol syntax. The following two commands are equivalent, because they both \ndiverge, for any P that takes a command as argument. var x := 0; P(x:=x+2); if x is even then diverge \nvar x := 0; P(x:=x+2); diverge Informally, the argument is that in the .rst example x is invariably even. \nThis is because P is declared somewhere not in the scope of x so the variable can only be a.ected by \n(possibly repeated) executions of the command x:=x+2 and this maintains the invariant. Now we consider \nan adaptation, due to Peter O Hearn, of the example to Java. The Java version uses a private .eld in \nplace of local variable x. Instead of passing the command x:=x+2 as argument, the object passes a reference \nto itself; this gives access to a public method inc. Using the implementation of A1 below, which corresponds \nto the .rst Algol example, the command var C y := new C() in (*) var A1 x := new A1() in x.callP(y) \ndiverges because after calling y.P, method callP diverges. class A1 extends Object { int g; /* initially \n0 */ unit callP(C y){ y.P(this); if (isEven(g)) then diverge else skip } unitinc(){g:= g+ 2}} Here is \nan implementation for which (*) corresponds to the second Algol example. class A1 extends Object { int \ng ; /* initially 0 */ unit callP(C y){ y.P(this); diverge } unitinc(){g :=g +2}} Both interpretations \nof (*) are equivalent, provided that any overriding declarations for inc preserve its invariant (behav\u00adioral \nsubclassing [19, 10]), and similarly for callP. Proposition 5.1. The command (*) has the same mean\u00ading \nwith either of the implementations for A1, provided that the corresponding class tables are con.ned, \ncallP is not overridden, and any declaration overriding inc maintains evenness. To prove equivalence \nwe choose Rep, Rep ' to be arbitrary classes (unusable by clients but not needed by A1), as they are \nnot relevant here. Let the basic simulation R relate h to h ' just if they have the same singleton domain \nf with loctype f = A1 and hfg = h ' fg ' =2 \u00d7 m for some m = 0. The proposition can be proved without \nusing the identity extension Lemma 4.3, but that is only because the example uses divergence to make \nit obvious that the two commands are equivalent. Identity extension is needed for other vari\u00adations. \nFor example, we can make (*) behave as skip by replacing the .rst implementation of callP with y.P(this); \nif(isEven(g))then skip else diverge and the second implementation with y.P(this); skip. Be\u00adcause x is \nlocal in (*), there are no reachable A1-objects in the .nal states, so the outcomes from the two versions \nof (*) are equal. The preceding examples do not involve representation ob\u00adjects or con.nement. What they \ncon.rm is that in our lan\u00adguage local variables and private .elds provide .rst-class stateful procedures \nin a form that does not have the prob\u00adlematic interactions found in Algol. The same is true of some other \nconventional languages (e.g., C has no nested procedure declarations, and Oberon does not allow local \npro\u00adcedures to be passed as arguments), making it possible to prove the Meyer-Sieber equivalences in \nsimple models [28] for those languages. It is straightforward to extend the examples to include representation \nobjects. For example, the integer .eld g can be replaced by an Integer object similar to the Boolean \nobject used in the example of Section 2.1. Then con.nement is needed just as in that example.  6. PRIVILEGE-BASED \nACCESS CONTROL In the Java access control mechanism [11], each class has an associated principal, the \nsigner of the class (e.g., the user, or an authenticated remote site from which the code was obtained). \nAn access control matrix associates with each principal n a set A(n) of privileges, or resources, for \nwhich it is authorized. For example, a user program might have the privilege p to change their password \nbut not the priv\u00adilege w for directly writing the password .le. The stack frame for a method activation \nis marked with the signer of the class .le declaring the method, and also contains a set of enabled privileges. \n(Enabled privileges need not be au\u00adthorized for the signer.) Let us write .n, P . for such frame, where \nn . Principals and P .P(Privs). Privileges must be explicitly enabled by an operation called doPrivileged, \nwhich adds the privilege to the current frame. Before ex\u00adecuting an operation, like hardware write, that \nis to be protected, a check (checkPermission) is performed. This stack inspection decides chk(p, S), \nwhich is de.ned as fol\u00adlows, where we write .n, P . :: S for .n, P . on top of stack S. For the empty \nstack, chk(p, nil) . false. For nonempty stacks, chk(p, (.n, P . :: S)) . p .A(n).(p . P .chk(p, S)). \nHere are two example classes in our syntax. class Sys signer sys extends Object {unit writepass(String \nx){check w; write(x,\"passfile\") }unit passwd(String x){check p; dopriv w in this.writepass(x) }} class \nUser signer user extends Object { Sys s ... /* initialization elided */ unit use(){ dopriv p in s.passwd(\"mypass\") \n} unit try(){ dopriv w in s.writepass(\"mypass\") }} Assume that A(user)= {p} and A(sys)= {p, w}. Invoking \nmethod use makes a frame .user, \u00d8., and then use enables p; from the resulting frame .user, {p}., a call \nis made to passwd which pushes .sys, \u00d8.. Then check p succeeds and privilege w gets enabled. Finally, \nwritepass checks w suc\u00adcessfully, and calls the hardware write. Invocation of user method try results \nin a security excep\u00adtion: Although w gets added to the frame for try, the check by writepass fails because \nw is not authorized for user. As described, the stack inspection semantics is lazy in that tests p .A(n) \nare only performed when p is actually needed to perform a guarded operation. But a stack S determines \na set privs S of enabled, authorized privileges: p . privs S . chk(p, S). This gives rise to an equivalent \neager [11, 42] semantics: Instead of evaluating an expression in the context of a stack S, it maintains \nthe context .n, privs S., where n is the principal in the top frame of S. Actual implementations depend \non facilities built in to the runtime environment, but they are largely written as library classes. In \nearlier work [3], we showed equivalence of the lazy and eager strategies, using simulations and built-in \nse\u00admantics for the security mechanism in an idealized language (like those of [38, 42], which also show \nthe equivalence). It is an interesting exercise to write down, in our core language, lazy and eager implementations, \nand show their equivalence using the abstraction theorem. This involves rewriting the source code to \nadd a security context parameter for meth\u00adods, and to invoke suitable methods on that context. What is \nmore important is to give an accurate model including the built-in features. This is what we do below, \nextending the language of Section 2 and using eager semantics. Then we show that the abstraction theorem \nholds. By itself, the access control mechanism merely controls which methods can be called. To ensure \nan intrinsic security property such as user programs do not write the password .le , visibility control \ncan ensure that, e.g., the write oper\u00adation is only called by writepass (by making write or even writepass \nprivate). Con.nement can be used to protect access to data such as real disk addresses. We show para\u00admetricity \nfor the language including access control, which lays a basis for proofs of intrinsic security properties, \nbut such proofs are left for future work. The extended language. The core language in Section 2 is extended \nas follows: CL ::= class C signer n extends C { Tf; M } S ::= ... | check p | dopriv p in S e ::= ... \n| testpriv p The new typing rules are simple: For any G,C, the type of testpriv p is bool, and the type \nof check p is com. The type of dopriv p in S is com just if the type of S is com. The only addition to \nsemantic categories . is Sec where [ Sec] =(Principals \u00d7P(Privs)) ordered by equality. The changes in \nthe semantic domains occur in the domains of methods, expressions and commands: [ C, (x : T ) . T ] = \n[ x : T, this : C] . [ Heap] . [ Sec] . ([[T ] \u00d7 [ Heap]]). [[G; C f e : T ] . [ MEnv] .[[G]] .[ Heap] \n.[ Sec] .[ T ] . [[G; C f S : com] . [ MEnv] .[[G]].[ Heap] .[ Sec] .([[G]]\u00d7[ Heap] \u00d7[ Sec]]). We give \nbelow the interesting changes in the semantics of expressions and commands; the rest of the semantics \nfollow mutatis mutandis taking [ Sec] into account. Let s range over [ Sec]]. [[G; C f e.m(e): T ] \u00b5.hs \n= let f = [[G; C f e : D] \u00b5.hs in if f . dom h then . else let d = \u00b5(loctype f)m in let n = signer(loctype \nf) in let . ,P . = s in let s0 = .n, P nA(n). in let d = [[G; C f e : U] \u00b5.hs in let (h0,d0)= d[x . d, \nthis . f]hs0 in d0 [[G; C f testpriv p : bool] \u00b5.hs = let . ,P . = s in (p . P ) [[G; C f check p : com] \n\u00b5.hs = let . ,P . = s in if p . P then (., h, s) else . [[G; C f dopriv p in S : com] \u00b5.hs = let .n, \nP . = s in if (p .A(n)) then [[G; C f S : com] \u00b5.h.n, P .{p}.else [[G; C f S : com] \u00b5.hs The statement \nof Theorem 4.1 can be interpreted in the new semantics, taking into account the revised semantic do\u00admains. \nAnd it can be proved the same way, using the fol\u00adlowing lemma to take [ Sec] into account. Lemma 6.1. \nSuppose a basic simulation is given, such that CT and CT ' are con.ned. Then, for all non-rep classes \nC = A, all constituent expressions G; C f e : T and com\u00admands G; C f S : com in methods declared in C, \nand all con.ned \u00b5, \u00b5 ' , the following holds. For all con.ned heaps h (resp. h ' ) and environments . \ncon.ned for C, h (resp. . ' for C, h ' ), and all s . [ Sec] , if R MEnv \u00b5\u00b5 ' , R Heap hh ' , and R G \n.. ' then ' . ' R (T.) ( [[G; C f e : T ] \u00b5.hs)([[G; C f ' e : T ] ' \u00b5h ' s) R (G\u00d7Heap\u00d7Sec). ([[G; C \nf S] \u00b5.hs)([[G; C f ' S] ' \u00b5 ' . ' h ' s)  7. DISCUSSION We have used instance-based con.nement to show \nrepre\u00adsentation independence for a Java-like language including references and access control based on \nprincipals and priv\u00adileges. Although we focused on Java, similar features are found in a number of other \nlanguages. As remarked in [13], there do not seem to be comparable results in the literature. Cavalcanti \nand Naumann [6] prove representation indepen\u00addence for language very similar to our core language except \nthat they use copy semantics for assignment and do not model shared references, a central feature of \nconventional languages. We exploit their insights on how simple seman\u00adtic domains are adequate. Their \nwork addresses re.nement calculus, and uses predicate transformer semantics in order to model speci.cations \nas constituents of method bodies. Con.nement .gures heavily in the veri.cation logics of M\u00a8uller and \nPoetzsch-He.ter [26] and in some work by the group of Nelson and Leino [18, 9]. Whereas other formal\u00adizations \nof semantics for Java-like languages are oriented to veri.cation of individual programs [14] or proofs \nof metathe\u00adorems such as type safety [41], these works are expressly concerned with modular checking \nand veri.cation. They address encapsulation with speci.cations based on Leino s notion of dependency \nwhich relates abstraction to represen\u00adtation. Aspects of parametricity have doubtless been con\u00adfronted \nin soundness proofs by these researchers (especially in [18, 25]). But they are ambitiously tackling \nmany issues at once, including speci.cations and more sophisticated forms of con.nement; we have found \nit di.cult to glean results and proof techniques that can be used in other settings. Certainly there \nare no explicit results like the abstraction theorem. Our semantics does not depend on con.nement or \nspeci\u00ad.cations, and is presented using widely known semantic no\u00adtions. We believe that our formulation \nof con.nement and abstraction is transparent enough to invite independent con\u00ad.rmation and to be adapted \nfor other uses. In ongoing work we are assessing various notions of con.nement and their use for checking \nof security and other properties. The capa\u00adbility semantics of [5] might complement our work, in that \nit o.ers a means for formalizing and thus comparing various .ne-grained notions of con.nement. Our result \nuses con.nement expressed in terms of types declared in the program; one direction for future work is \nto explore con.nement based on principals. Acknowledgements. Peter O Hearn, David Schmidt, and the anonymous \nreferees o.ered improvements and encour\u00adagement. Hongseok Yang pointed out a faulty proof step, which \nled us to correct the de.nition of con.nement. 8. REFERENCES [1] M. Abadi, A. Banerjee, N. Heintze, \nand J. G. Riecke. A core calculus of dependency. In POPL, 1999. [2] A. Banerjee and D. A. Naumann. A \nstatic analysis for instance-based con.nement in Java. In preparation. [3] A. Banerjee and D. A. Naumann. \nA simple semantics and static analysis for Java security. Technical Report CS Report 2001-1, Stevens \nInstitute of Technology. [4] J. Boyland. Alias burying: Unique variables without destructive reads. Software \nPractice and Experience, 31(6), 2001. [5] J. Boyland, J. Noble, and W. Retert. Capabilities for sharing: \nA generalisation of uniqueness and read-only. In ECOOP, 2001. [6] A. Cavalcanti and D. A. Naumann. Forward \nsimulation for data re.nement of classes. Submitted, 2001. [7] D. G. Clarke, J. Noble, and J. M. Potter. \nSimple ownership types for object containment. In ECOOP 2001. [8] W.-P. de Roever and K. Engelhardt. \nData Re.nement: Model-Oriented Proof Methods and their Comparison. Cambridge University Press, 1998. \n[9] D. Detlefs and K. R. M. Leino and G. Nelson. Wrestling with rep exposure. Research Report 156, COMPAQ \nSystems Research Center, July 1998. [10] K. K. Dhara and G. T. Leavens. Forcing behavioral subtyping \nthrough speci.cation inheritance. In ICSE, Berlin, 1996. [11] L. Gong. Inside Java 2 Platform Security. \nAddison-Wesley, 1999. [12] A. D. Gordon and A. M. Pitts, editors. Higher Order Operational Techniques \nin Semantics. Cambridge University Press, 1998. [13] D. Grossman, G. Morrisett, and S. Zdancewic. Syntactic \ntype abstraction. ACM Trans. Prog. Lang. Syst., 22(6), 2000. [14] M. Huisman and B. Jacobs. Java program \nveri.cation via a Hoare logic with abrupt termination. In FASE, 2000. [15] A. Igarashi, B. Pierce, and \nP. Wadler. Featherweight Java: a minimal core calculus for Java and GJ. In OOPSLA, 1999. [16] S. Ishtiaq \nand P. W. O Hearn. BI as an assertion language for mutable data structures. In POPL, 2001. [17] D. Lea. \nConcurrent Programming in Java. Addison-Wesley, second edition, 2000. [18] K. R. M. Leino and G. Nelson. \nData abstraction and information hiding. Research Report 160, COMPAQ Systems Research Center, Nov. 2000. \nTo appear in ACM Trans. Prog. Lang. Syst. [19] B. H. Liskov and J. M. Wing. A behavioral notion of subtyping. \nACM Trans. Prog. Lang. Syst., 16(6), 1994. [20] N. Lynch and F. Vaandrager. Forward and backward simulations \npart I. Inf. Comput., 121(2), 1995. [21] A. R. Meyer and K. Sieber. Towards fully abstract semantics \nfor local variables: Preliminary report. In POPL, 1988. [22] J. C. Mitchell. Representation independence \nand data abstraction. In POPL, 1986. [23] J. C. Mitchell. On the equivalence of data representations. \nIn V. Lifschitz, editor, Arti.cial Intelligence and Mathematical Theory of Computation: Papers in Honor \nof John McCarthy, 1991. [24] J. C. Mitchell. Foundations for Programming Languages. MIT Press, 1996. \n[25] P. M\u00a8uller. Modular Speci.cation and Veri.cation of Object-Oriented Programs. PhD thesis, FernUniversit\u00a8at \nHagen, 2001. Available from www.informatik.fernuni-hagen.de/pi5/publications. [26] P. M\u00a8uller and A. \nPoetzsch-He.ter. Modular speci.cation and veri.cation techniques for object-oriented software components. \nIn G. T. Leavens and M. Sitaraman, editors, Foundations of Component-Based Systems. Cambridge University \nPress, 2000. [27] P. M\u00a8uller and A. Poetzsch-He.ter. A type system for controlling representation exposure \nin Java. ECOOP Workshop on Formal Techniques for Java Programs, Technical Report 269, Fernuniversit\u00a8at \nHagen, 2000. [28] D. A. Naumann. Soundness of data re.nement for a higher order imperative language. \nTheoretical Comput. Sci., 2001. To appear. [29] P. W. O Hearn and R. D. Tennent. Parametricity and local \nvariables. J. ACM, 42(3), 1995. [30] P. W. O Hearn and R. D. Tennent. Algol-like Languages (Two volumes). \nBirkh\u00a8auser, Boston, 1997. [31] G. Plotkin. Lambda de.nability and logical relations. Technical Report \nSAI-RM-4, University of Edinburgh, School of Arti.cial Intelligence, 1973. [32] U. S. Reddy. Objects \nand classes in Algol-like languages. In FOOL, 1998. [33] J. C. Reynolds. Towards a theory of type structure. \nIn Colloques sur la Programmation, LNCS 19, pages 408 425, 1974. [34] J. C. Reynolds. The essence of \nAlgol. In J. W. de Bakker and J. C. van Vliet, editors, Algorithmic Languages. North-Holland, 1981. [35] \nJ. C. Reynolds. Types, abstraction, and parametric polymorphism. In R. Mason, editor, Information Processing \n,83, pages 513 523. North-Holland, 1984. [36] J. C. Reynolds. Intuitionistic reasoning about shared mutable \ndata structure. In Millenial Perspectives in Computer Science. Palgrave, 2001. [37] C. Ruby and G. T. \nLeavens. Safely creating correct subclasses without seeing superclass code. In OOPSLA, 2000. [38] C. \nSkalka and S. Smith. Static enforcement of security with types. In ICFP, 2000. [39] C. Strachey. Fundamental \nconcepts in programming languages. Higher Order and Symbolic Computation, 13(1), 2000. Originally appeared \nin 1967 Lecture notes, International Summer School in Computer Programming, Copenhagen. [40] J. Vitek \nand B. Bokowski. Con.ned types in java. Software Practice and Experience, 31(6), 2001. [41] D. von Oheimb, \nT. Nipkow, and C. Pusch. muJava: Embedding a programming language in a theorem prover. In Proceedings \nof the International Summer School Marktoberdorf, 1999. [42] D. Wallach, A. Appel, and E. Felten. SAFKASI: \na security mechanism for language-based systems. ACM Trans. Software Eng. Method., 9(4), 2000.  \n\t\t\t", "proc_id": "503272", "abstract": "Denotational semantics is given for a Java-like language with pointers, subclassing and dynamic dispatch, class oriented visibility control, recursive types and methods, and privilege-based access control. Representation independence (relational parametricity) is proved, using a semantic notion of confinement similar to ones for which static disciplines have been recently proposed.", "authors": [{"name": "Anindya Banerjee", "author_profile_id": "81100144615", "affiliation": "Kansas State University, Manhattan KS", "person_id": "PP14060901", "email_address": "", "orcid_id": ""}, {"name": "David A. Naumann", "author_profile_id": "81100447696", "affiliation": "Stevens Institute of Technology, Hoboken NJ", "person_id": "PP14157099", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/503272.503289", "year": "2002", "article_id": "503289", "conference": "POPL", "title": "Representation independence, confinement and access control [extended abstract]", "url": "http://dl.acm.org/citation.cfm?id=503289"}