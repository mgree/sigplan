{"article_publication_date": "01-01-2002", "fulltext": "\n Functional Logic Overloading Matthias Neubauer Peter Thiemann Martin Gasbichler Michael Sperber Universit\u00a8at \nFreiburg Universit\u00a8at T\u00a8ubingen {neubauer,thiemann}@informatik.uni-freiburg.de {gasbichl,sperber}@informatik.uni-tuebingen.de \n ABSTRACT Functional logic overloading is a novel approach to user\u00adde.ned overloading that extends Haskell \ns concept of type classes in signi.cant ways. Whereas type classes are concep\u00adtually predicates on types \nin standard Haskell, they are type functions in our approach. Thus, we can base type infer\u00adence on the \nevaluation of functional logic programs. Func\u00adtional logic programming provides a solid theoretical foun\u00addation \nfor type functions and, at the same time, allows for programmable overloading resolution strategies by \nchoosing di.erent evaluation strategies for functional logic programs. Type inference with type functions \nis an instance of type inference with constrained types, where the underlying con\u00adstraint system is de.ned \nby a functional logic program. We have designed a variant of Haskell which supports our ap\u00adproach to \noverloading, and implemented a prototype front\u00adend for the language. 1. INTRODUCTION Since the invention \nof type classes more than a decade ago [49], every year has seen astonishing new applications and interesting \nextensions of the original idea. Among these extensions are constructor classes [26], multi-parameter \ntype classes [43], implicit parameters [35], and functional de\u00adpendencies [31]. A number of applications \nof type classes critically depend on extensions to properly resolve ambigui\u00adties [28, 48]. Moreover, \nthe various Haskell implementations feature a number of additional ad-hoc extensions. Among the extensions, \nfunctional dependencies e.ectively allow writing logic programs at the type level [16, 37] and running \nthem at type-inference time. However, these type\u00adlevel programs are often awkward to write, and the introduc\u00adtion \nof functional dependencies poses additional pragmatic problems such as the resolution of overlapping \ninstances which interact poorly with functional dependencies [38]. The upshot is that no single approach \nto constrained poly\u00admorphism and overloading is su.ciently general and e.ec\u00adtive to be applicable in \nall situations. Therefore, we pro\u00adpose making the overloading machinery programmable. The Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 02, Jan. 16-18, \n2002 Portland, OR USA Copyright 2002 ACM ISBN 1-58113-450-9/02/01 ...$5.00. The print version of this \narticle contained some misaligned figure boxes. The problems have been corrected for the online version \nof the article. main device in our proposal is a conceptual shift from type\u00adclasses-as-predicates to \ntype-classes-as-functions. Therefore, constraints in the resulting type system are now constraints in \na functional logic language [18] at the type level. Thus, the study of type-level programs can immediately \nbene.t from the large body of published knowledge on functional logic programming. This is in sharp contrast \nto the imple\u00admented extensions of Haskell s type classes, which have been developed incrementally and \nsometimes without careful in\u00adtegration. For instance, some systems implement functional dependencies \nas well as overlapping instances even though there is no theoretical work that investigates their interac\u00adtion. \nFunctional logic programming, just like functional pro\u00adgramming, features a variety of evaluation strategies. \nThere are two main approaches, residuation and narrowing, which exist in many di.erent variants, each \nof which has speci.c tradeo.s [18]. Fortunately, Hanus s evaluation model based on de.nitional trees \nsuits all evaluation strategies [19]. Since there are similarly diverging requirements in type-level \npro\u00adgramming for resolution of overloading, it seems natural to employ a parameterized model to specify \nits semantics. Contributions. We extend Haskell s type class system with the following features: The \nresolution of overloading is speci.ed using func\u00adtions at the type level.  Type functions are de.ned \nby a terminating (condi\u00adtional) term rewriting system augmented with (mem\u00adber) value de.nitions. The \nresponsibility of making the term rewriting system terminating rests with the programmer, as with most \napproaches that make type checking programmable.  The type-level semantics is clearly speci.ed by attach\u00ading \na deterministic evaluation strategy for functional logic programs to each type function. This has two \nimportant consequences: 1. Overloading resolution is deterministic. Thus, no coherence problems arise. \n 2. Di.erent .avors of overloading resolution are pro\u00adgrammable by choosing an evaluation strategy. \n  Our system extends the scope of Haskell-style type class systems by treating overlapping instances \nin com\u00adbination with functions (which has a number of signif\u00adicant applications [28]) and by being able \nto resolve Ada-style overloading.  On the technical side, our system is based on HM(X) [41], a framework \nfor constrained type inference. We instanti\u00adate HM(X) with a suitable term constraint system and de\u00ad.ne \nconstraint simpli.cation rules, that extend the rule sys\u00adtems for E-uni.cation [11]. We show that simpli.cation \nis sound and complete. The resulting type inference algorithm is inherently incomplete because not all \nevaluation strate\u00adgies (residuation, in particular) yield complete E-uni.cation procedures [17]. A companion \ntechnical report [12] further extends our instance of HM(X) towards overloading resolu\u00adtion by formalizing \na dictionary translation for it. On the practical side, we have implemented a compiler frontend for a \ndialect of Haskell. Using our implementation, we have validated a number of applications (see Section \n2) ranging from simple dependent types through polymorphic extensible records with .rst-class labels \nto Ada-style over\u00adloading. Each application requires a particular type-level evaluation strategy (outermost \nresiduation, residuation with most-speci.c matching, and outermost narrowing), which demonstrates the \nusefulness of a parameterized strategy. Overview. The following section presents a number of ex\u00adamples \nfor our variant of Haskell which make intrinsic use of type-level functions. Section 3 introduces some \nnotational preliminaries. Section 4 gives an overview of the HM(X) framework. The following section describes \nthe constraint system which forms the basis of our type system. Section 6 discusses possible evaluation \nstrategies for type-level func\u00adtion applications which occur during constraint simpli.ca\u00adtion. It also \nshows how these strategies evaluate the exam\u00adples from Section 2. Section 7 contains some notes on our \nprototype implementation. Finally, we discuss related work in Section 8 and conclude.  2. EXAMPLES Four \nsimple examples demonstrate our type system and our variant of Haskell: a type-safe sprintf function, \nan im\u00adplementation of records with .rst-class labels, a function en\u00adcoding type equality, and the Ada-style \noverloading of the operator +. We assume basic familiarity with Haskell. The standard resolution strategy \nis based on outermost residua\u00adtion (see Section 6.1). 2.1 Format The sprintf function from the C standard \nlibrary is an example of an unsafe function that could be made type-safe by a dependent type [4]: The \n.rst parameter of sprintf is a format speci.er which determines the number and type of the remaining \nparameters. The type-level function SPRINTF computes the type of the remaining parameters from the for\u00admat \nspeci.er [38]. In our variant of Haskell, format speci.ers cannot simply be strings with control characters \nbut rather String constants or values from the following datatypes:1 data If=If data Cf=Cf data Sf=SString \nf The format speci.er (using ) for function application) fmt :: S (I (S (C String))) fmt = S\"Int: \"$I$S\",Char: \n\"$C$\".\" 1This particular application is also implementable using only ML-style polymorphism [9]. means \nThe literal string Int: followed by an inte\u00adger followed by the literal string , Char: followed by \na character and terminated by a period. The following dec\u00adlaration speci.es the type-level function SPRINTF \ntogether with an associated member value sprintf1. The overloaded sprintf1 function accepts a pre.x string, \na format speci.er, and corresponding further arguments: class SPRINTF (f :: *) :: * where sprintf1 :: \nString -> f -> SPRINTF f instance SPRINTF String = String where sprintf1 prefix str = prefix ++ str instance \nSPRINTF (I a) = Int -> SPRINTF a where sprintf1 prefix (I a) = \\i -> sprintf1 (prefix ++ show i) a instance \nSPRINTF (C a) = Char -> SPRINTF a where sprintf1 prefix (C a) = \\c -> sprintf1 (prefix ++ [c]) a instance \nSPRINTF (S a) = SPRINT a sprintf1 prefix (S str a) = sprintf1 (prefix ++ str) a The .rst line says that \nSPRINTF maps types of format speci.ers, f, of kind * to results of kind *. The lines following the where \nkeyword are type declarations of member values associated to SPRINTF. There is only one member function \nhere, sprintf1. The .rst instance states that a format speci.er of type String leads to a member value \nwith the same result type. The value-level member declaration of sprintf1 for this case follows. In case \nof a format speci.er starting with the I type constructor, the type-level function is de.ned recursively: \nthe result type of sprintf1 is a function, the parameter of this function is of type Int, and the return \nvalue type arises from another recursive call to SPRINTF. Again, the corre\u00adsponding member value follows. \nThe two remaining cases for type expressions starting with C and S are analogous. The main entry point, \nsprintf, supplies an empty pre.x to sprintf1: sprintf :: (SPRINTF m =:= o) => m -> o sprintf = sprintf1 \n\"\" It is only applicable to values of types m and o so that the constraint SPRINTF m =:= o is satis.ed. \nThe operator =:= speci.es strict equality of its left-hand side, the application of the type-level function \nSPRINTF to m, and its right-hand side, o. The type of sprintf fmt is now Int -> Char -> String. When \napplied to an integer2 and a character, the result is > sprintf fmt 42 x \"Int: 42, Char: x.\" 2.2 Polymorphic \nExtensible Records with First-Class Labels We implement records as heterogeneous lists on the type and \non the data level. (Since order is important, the pro\u00adgrammer must normalize records upon construction.) \nTwo type constructors EMPTY and CONS create record types. A record type is an association list at the \ntype level: it maps a record label (also a type) to the type of the corresponding record .eld. The representation \nat the value level is analo\u00adgous: two value constructors EMPTY and CONS create record values; the representation \nof a record is an association list 2Throughout, we assume that numeric literals have type Int. mapping \nrecord labels to .eld values. Thus, the structures of record types and record values as well as of record \ntype labels and record value labels are identical. As this kind of situation is typical in type-level \nprogramming, there is a special lifted declaration which creates a type constructor and a value constructor \nat the same time (the comments show the expansions): lifted EMPTY --data EMPTY = EMPTY lifted CONS x \nxs --data CONS x xs = CONS x xs lifted Lx --data Lx = Lx lifted Ly --data Ly = Ly Lx and Ly are two possible \nlabels, modeled by singleton types. A type class EQUAL models equality of record labels: lifted TRUE \nlifted FALSE class EQUAL (l1 :: *) (l2 :: *) :: * reifying equal instance EQUAL Lx Lx = TRUE instance \nEQUAL Lx Ly = FALSE instance EQUAL Ly Lx = FALSE instance EQUAL Ly Ly = TRUE The .rst line speci.es the \nkinds of the arguments to EQUAL as well as the return kind. The reifying clause says that EQUAL has a \nmember equal which mirrors the EQUAL function at the value level; this is possible as all types involved \nhave lifted declarations. The explicit de.nition of equal looks like this: class EQUAL (l1 :: *) (l2 \n:: *) :: * where equal :: l1 -> l2 -> EQUAL l1 l2 instance EQUAL Lx Lx = TRUE where equal Lx Lx = TRUE \ninstance EQUAL Lx Ly = FALSE where equal Lx Ly = FALSE instance EQUAL Ly Lx = FALSE where equal Ly Lx \n= FALSE instance EQUAL Ly Ly = TRUE equal Ly Ly = TRUE The SELECT class performs .eld selection. It relies \non a type-level version of the Maybe a type (NOTHING and JUST x) as well as on a type-level conditional \n(COND). lifted NOTHING lifted JUST x class SELECT (f :: *) (r :: *) :: * reifying select instance SELECT \nf EMPTY = NOTHING instance SELECT f (CONS (f , v) r) = COND (EQUAL f f ) (JUST v) (SELECT f r) class \nCOND(t::*)(c :: *) (a:: *) ::* reifying cond instance COND TRUE x y = x instance COND FALSE x y = y The \nunwrap function allows us to de.ne a modi.ed .eld selection function: unwrap (JUST t) = t sel ::(SELECT \nfr =:= JUST t) =>f ->r->t sel f r = unwrap (select f r) Again, the sel function carries a constrained \ntype: It is only applicable for types f, r, and t which satisfy the con\u00adstraint SELECT f r =:= JUST t. \nThe SELECT type-function checks whether a given .eld is present. The add operation adds a new .eld to \na record. It requires that the .eld is not yet present. add :: (SELECT f r =:= NOTHING) =>r -> f->v ->CONS \n(f, v) r add record field value = CONS (field, value) record The remove class removes a .eld from a record: \nclass REMOVE (f :: *) (r :: *) :: * reifying remove instance REMOVE f EMPTY = EMPTY instance REMOVE f \n(CONS (f , v) r) = COND (EQUAL f f ) r (CONS (f , v) (REMOVE f r)) With this de.nition, removing a .eld \nfrom a record always succeeds, regardless of the actual presence or absence of such a .eld. If the presence \nof the .eld is required to remove it, then the following typing should be used with the remaining de.nitions \nunchanged: rmv ::(SELECT fr =:= JUST t) => f-> r -> REMOVE fr rmv = remove An example script demonstrates \nthe encoding. Record .elds are polymorphic. > add EMPTY Lx 42 :: CONS (Lx, Int) EMPTY > add EMPTY Lx \nc :: CONS (Lx, Char) EMPTY Existing .elds cannot be added: > add (add EMPTY Lx 42) Lx 0 --***ERROR*** \nField labels are .rst class. The constraint (SELECT ...) checks that .eld labels are di.erent. Application \nto di.erent labels succeeds and application to equal labels fails. > \\l1 l2 -> add (add EMPTY l1 42) \nl2 \"x\" :: (SELECT f (CONS (f1, Int) EMPTY) =:= NOTHING) => f1 -> f -> CONS (f, [Char]) (CONS (f1, Int) \nEMPTY) > (\\l1 l2 -> add (add EMPTY l1 42) l2 \"x\") Lx Ly :: CONS (Ly, [Char]) (CONS (Lx, Int) EMPTY) > \n(\\l1 l2 -> add (add EMPTY l1 42) l2 \"x\") Lx Lx --***ERROR*** 2.3 Overlapping Instances The de.nition \nof the function EQUAL in the previous sub\u00adsection is tedious and restrictive: equality is only avail\u00adable \nfor a .xed, prede.ned set of types and the number of instance declarations grows quadratically with the \nsize of this set. Here is the code in our Haskell variant: class EQUAL (l1 :: *) (l2 :: *) :: * where \nequal :: l1 -> l2 -> EQUAL l1 l2 with specificity instance EQUAL a a = TRUE where equal a b = TRUE instance \nEQUAL a b = FALSE where equal a b = FALSE The Haskell type system would reject an equivalent de.\u00adnition \nbecause the two instance declarations overlap. (EQUAL aa is an instance of EQUAL a b.) Our Haskell dialect \ndeals with this declaration by rewriting of the type function EQUAL with residuation and most-speci.c \nmatching. That is, a match on a instance declaration will not be reduced until it is clear that no other \ninstance declaration can match. In particular, EQUAL t1 t2 suspends until either t1 and t2 are fully \ninstantiated to equal types or su.ciently instan\u00adtiated to determine that they cannot be equal. 2.4 \nAda-style Overloading Another typical scenario is Ada-style overloading which corresponds to type classes \nwith .xed, .nite sets of instances. Consider overloading the + operator with addition on Int and Float \nas well as with list concatenation: class PLUS (a :: *) (b :: *) :: * where (+)::a-> b-> PLUS a b with \nclosed narrowing instance PLUS Int Int = Int where ... instance PLUS Float Float = Float where ... instance \nPLUS [a] [a] = [a] where ... The phrase with closed narrowing stipulates the use of a narrowing semantics \nfor PLUS and indicates that the follow\u00ading list of instances is complete. The resulting overloading resolution \nworks similarly to the operator overloading found in the Ada programming languages. It is even more gen\u00aderal \nbecause it does not require that overloading is locally resolved. As an example, consider the following \ncode: fxy= (x+y) +42 The specificity strategy from the previous subsection simply defers the resolution \nof overloading to the point where the types of x and y become known. The resulting type is f:: (PLUS \nxy =:= z&#38;PLUS zInt=:= w)=>x->y-> w Using the narrowing semantics, the type system can re\u00adsolve the \noverloading locally to f :: Int -> Int -> Int. The narrowing semantics explores all overloaded alternatives \nat the same time and prunes those that do not match. 2.5 Embedding of Standard Type Classes It is easy \nto encode standard type classes in our system of type functions. Here is an encoding with an excerpt \nof the Haskell 98 type class Eq that characterizes types with an equality function. class Eq a where \n(==) :: a -> a->Bool instance Eq Int where (==) = primEqInt instance (Eq a) => Eq [a] where [] ==[] =True \n(x:xs) == (y:ys) = x == y &#38;&#38; xs == ys _ == _ = False instance (Eq a, Eq b) => Eq (a,b) where \n(x1, x2) == (y1, y2) =x1==y1&#38;&#38; x2 == y2 A translation of these declarations into type-level func\u00adtions \ntakes the same route as the embedding of predicates into functional logic languages via the special singleton \nkind, Success, with element Success [20]. class Eq :: (a :: *) :: Success where (==) :: a -> a->Bool \ninstance Eq Int = Success where {...} instance Eq [a] = Eq a where {...} instance Eq (a, b) = Eq a &#38; \nEq b where {...} Predicates can be combined by conjunction &#38;. In Haskell, type classes can form \na hierarchy where new classes can inherit operations from existing superclasses. We do not consider superclasses \nhere because they can be ex\u00adpanded to sets of classes [5, 39].  3. PRELIMINARIES A ranked alphabet \nA is a .nite set of symbols with asso\u00adciated arities. Let further X be a set of variables. The set TA(X \n) is the set of terms over alphabet A and variables X . That is, it is the smallest set with X. TA(X \n) and, when\u00adever f .A with arity n . N and t1,...,tn . TA(X ), then ft1 ...tn . TA(X ). A term that does \nnot contain variables is a ground term. Let C be a ranked alphabet of constructor symbols and let F be \na ranked alphabet of function symbols. A constructor term is a term in TC(X ). A substitution s is a \nmapping from variables to terms which is the identity on almost all variables. A substitution extends \nhomomorphically to terms. A term t' is a (substi\u00adtution) instance of t if there is a substitution s such \nthat ' '' t= s(t). In this case, we write s : t = tor just t = tif s does not matter. Two terms t and \nt' are disjoint if neither t = t' nor t' = t. These notions extend to tuples of terms and to substitutions \nin the natural way. We often write t for a tuple of terms and analogously for other entities. 4. THE \nHM(X) FRAMEWORK This section gives a short account of the HM(X) frame\u00adwork that extends the Hindley/Milner \ntype system with con\u00adstraints [41]. In particular, HM(X) provides a generic type inference algorithm \nthat computes principal types if the un\u00adderlying constraint system has certain properties. e ::= x data \nvariables | .x.e lambda abstraction | e e application | let x = e in e let expression T 3 t ::= a type \nvariables | t . t function types Figure 1: Syntactic domains for type inference Figure 1 de.nes the \nsyntactic domains. The term lan\u00adguage is a lambda calculus with let [8]. The core type lan\u00adguage is also \nstandard; an applied type language would in\u00adclude additional type constructors. To express princial types, \nHM(X) de.nes a notion of con\u00adstrained type scheme which combines universal quanti.ca\u00adtion with a constraint \nu on the type variables in a. s ::= .a.u . t type schemes G(x)= s (e-var) u | G f x : s u | G{x . t}f \ne : t' (e-lam) u | G f .x.e : t . t' u | G f e1 : t2 . t1 u | G f e2 : t2 (e-app) u | G f e1 e2 : t1 \nu | G f e : .a.u' . t' u f u'[a . t] (e-spec) u | G f e : t'[a . t] u &#38; u' | G f e : t a/. FV (u) \n. FV (G) (e-gen) u &#38; .a.u' | G f e : .a.u' . t u | G f e1 : su | G{x . s}f e2 : t (e-let) u | G f \nlet x = e1 in e2 : t . u | G f e : tu f t = t' (e-conv) u | G f e : t' Figure 2: Logical type system \nfor HM(X) Figure 2 shows the inference rules for HM(X) s typing judgement u | G f e : s (u is a constraint \nand G a type assumption). The rule (u-conv) replaces the subtyping rule of HM(X). It relies on constraint \nentailment f , which is de.ned in the next section. 5. CONSTRAINTS . U 3 u ::= t = t | u &#38; u |.a.u \n| u ; u | SUCCESS | FAIL T 3 t ::= a | ct | ft Figure 3: Grammar of constraints This section describes \na constraint system for use in the HM(X) framework. A constraint speci.es a uni.cation prob\u00adlem involving \napplications of type-level functions. The gram\u00admar in Figure 3 de.nes the constraint language. . ' The \nprimitive constraint is strict equality t = t between ' . ' two type-level terms t and t [13]. t = t \nis satis.ed if t and t ' are reducible to the same term.3 Type-level terms t are taken from T = TC.F \n(X ) where X is the set of type variables. The type language T is implicitly included in T . is just \nanother binary type constructor. For convenience, the concrete syntax allows extended type schemes of \nthe form s ' ::= .a.u . t where the types might contain applications of type functions. In this case, \ns ' denotes a corresponding proper type scheme s . T, which is obtained from s ' by replacing each function \napplication ft1 ...tn in t by a fresh type variable a and adding an . equation a = ft1 ...tn to the constraint. \nThe &#38; operator is for constraint conjunction: u1 &#38; u2 is satis.ed if both u1 and u2 is satis.ed. \nIt is commutative and associative. Existential quanti.cation .a.u restricts a local variable a. Its scope \nextends as far to the right as possible. The constraint u1 ; u2 expresses a disjunction. s |= t1 . = \nt2 i. st1 . t0 and st2 . t0 for some t0 s |= u1 &#38; u2 i. s |= u1 and s |= u2 s |= .a.u i. s[a . t] \n|= u for some t s |= u1 ; u2 i. s |= u1 or s |= u2 s |= SUCCESS Figure 4: Semantics of constraints The \nsemantics of a constraint u is the set of ground construc\u00adtor substitutions that solve the constraint. \nA substitution s solves u whenever s |= u is derivable using the axioms and rules in Figure 4. Since \nthe terms in equality constraints can contain func\u00ad tion symbols, the de.nition of |= is parameterized \nwith an evaluation relation t . t ' that evaluates term t to term t ' . We defer the de.nition of this \nrelation to Section 6. The notation s |= u means that no proof exists for s |= u. Simpli.cation of constraints \ncorresponds to standard for\u00admulations of E-uni.cation [20] with a few extensions, no\u00adtably the explicit \ntreatment of choice and existential quan\u00adti.cation as required by HM(X). In this section, we only consider \nthe core constraints. Rewriting steps arising from function applications are treated in Section 6. The \nrules in Figure 5 use a standard de.nition of the free variables FV (u) of a constraint u, which treats \n.a as a binding con\u00adstruct and uses FV (t) to yield the set of variables occurring in a type-level term. \nStrict equality is a standard term in functional logic pro\u00adgramming. It corresponds to the standard notion \nof equality in functional programming. . (u-constr-dec) ct1 ...tn = ct ' ...t ' 1 n .. t1 = t1 ' &#38; \n... &#38; tn = t ' n . (u-constr-fail) ct1 ...tn = dt ' ...t ' FAIL 1 m if c = d or n= m .. (u-exch) \nt = a a = t if t not a variable . (u-taut) a = a SUCCESS . (u-occur) a = t FAIL if a . CV (t) and t = \na .. (u-subst) a = t &#38; u a = t &#38; u[a . t] if t = ca1 ...an and a/.{a1,...,an}.. (u-subst-var) \na = b &#38; u a = b &#38; u[a . b] if a . FV (u) . (u-peel) a = ct1 ...tn .a1 ...an. . a = ca1 ...an \n&#38; .. a1 = t1 &#38; ... &#38; an = tn if a/. CV (ti) and .i.ti not a variable (u-and-success) SUCCESS \n&#38; u u (u-and-fail) FAIL &#38; u FAIL (u-choice-and) u &#38;(u1 ; u2) (u &#38; u1) ;(u &#38; u2) (u-choice-fail-1) \nFAIL ; u u (u-choice-fail-2) u ; FAIL u (u-choice-success-1) SUCCESS ; u SUCCESS (u-choice-success-2) \nu ; SUCCESS SUCCESS (u-exists-drop) .a.u u if a/. FV (u) (u-and-exists) u1 &#38; .a.u2 .a.u1 &#38; u2 \nif a/. FV (u1) ' u1 u 1 (u-and-context-1) ' u1 &#38; u2 u1 &#38; u2 ' u u (u-exists-context) ' .a.u .a.u \n' u1 u 1 (u-choice-context-1) ' u1 ; u2 u ; u2 1 Figure 5: Simpli.cation of constraints For a sound occur \ncheck in E-uni.cation, it is necessary to consider the set CV (t) of the critical variables of t.A variable \nis critical unless it is protected by a function sym\u00adbol [20]: CV (a)= {a} CV (ct1 ...tn)= CV (t1) .\u00b7 \n\u00b7\u00b7. CV (tn) CV (ft1 ...tn)= \u00d8 The .rst four rules of Figure 5 are standard: The (u-constr\u00addec) rule performs \nterm decomposition and pushes the equal\u00adity of two terms with matching top-level constructors to the \nimmediate subterms. The (u-constr-fail) rule signals failure if either the top-level constructors do \nnot match or if the number of subtrees does not agree. The (u-exch) rule ori\u00adents equations so that variables \nappear on the left side. The rule (u-taut) removes trivial equations. The (u-occur) rule performs the \noccurs-check restricted to critical variables as explained above. The rule (u-subst) applies a constructor \nsubstitution and (u-subst-var) substitutes a variable by an other variable. The rule (u-peel) peels a \nconstructor substitution from the top of a term, potentially exposing a function call or making it possible \nto apply (u-occur) on a subterm. The (u-and-success) and (u-and-fail) rules specify how conjunction interacts \nwith success and failure, respectively. The (u-and-exists) rule allows an existential quanti.er to .oat \nout of a conjunction unless variable capture forbids it. The (u-exists-drop) rule drops an existential \nquanti.cation if the bound variable does not appear in the constraint. The (u-choice-and) rule is a distributive \nlaw of conjunc\u00adtion over choice. The rules (u-choice-fail-* ) remove a failing constraint from a choice \noperator. The (u-choice-success-* ) rules select the .rst succeeding alternative of a choice. The last \ngroup of rules determines the context in which transformations may occur: The rules (u-and-context-* \n) al\u00adlow transformation in both arguments of a conjunction (it is commutative). Rule (u-exists-context) \nperforms transfor\u00admation under existential quanti.cation and rules (u-choice\u00adcontext-* ) enables transformation \nof each individual choice. Here are some properties of constraint simpli.cation: Proposition 1 (Equivalence). \nSuppose that u . u ' . Then s |= u if and only if s |= u ' . Proposition 2. Constraint simpli.cation \nis con.uent. Definition 1. A constraint u is normalized i. u = FAIL or u = SUCCESS or u = .a.u1 &#38; \n... &#38; un where {a} = FV (u1 &#38; ... &#38; un) and each ui is in one of the following forms: . \na = b where a and b are di.erent variables; .  a = Ca1 ...ak a constructor substitution where a ./ \n {a1 ...ak}; . a = Ft1 ...tk where t1,...,tk . TC(X ); '' '' u1; ... ; um where u1,...,um are normalized, \nbut nei\u00ad ther FAIL nor SUCCESS. Moreover, u is in solved form i. u is normalized and each . variable \na occurs at most once in a constraint a = ... ; Proposition 3. If the rule (u-peel) is restricted to \napply at most once to any particular constraint, then constraint simpli.cation terminates with a normalized \nconstraint. Finally, we de.ne the entailment relation. Definition 2. Entailment is a relation ff. U \u00d7U \nde.ned by u f u ' i., .s, s |= u implies s |= u ' . The constraint system speci.ed in this section is \nin a form suitable for HM(X) [41]. The formal statements and proofs are in the full version of the paper \n[12].  6. EVALUATION STRATEGIES The constraint system of the previous section deliberately does not \naddress the evaluation of function applications in constraints: Function applications are evaluated as \nterms in the sense of functional logic programming. In turn, func\u00adtional logic programming knows a variety \nof di.erent eval\u00aduation strategies with di.erent tradeo.s [18, 19]. Thus, the evaluation strategy is \na parameter to simpli.cation. The choice of evaluation strategy must take a number of pragmatic issues \ninto account: For type-level functions rei.ed at the value level the evaluation strategy should be the \nsame at both levels.  The with closed clause speci.es that a given type class is closed by giving a \n.xed, .nal set of instances.  There must be support for open type classes.4  There may be no obvious \norder among the instances of a class (ruling out a sequential strategy).  We consider three evaluation \nstrategies, each of which cor\u00adresponds to a di.erent strategy for resolving overloading: outermost residuation \nwith sequential matching This strategy corresponds most closely to Haskell s constraint reduction with \nunderlying open-world semantics. With a closed-world assumption, it is the strategy of choice for functions \nlifted from the data level. outermost residuation with most-speci.c matching This strategy is most useful \nfor resolving Haskell-style overlapping instances. outermost narrowing This strategy is useful for model\u00ad \ning Ada-style overloading. It also assumes a closed world. As a prerequisite we assume that each function \non the type level is de.ned by a terminating term rewriting system with rules of the form f. p1 ...pn \n= r. . is a strategy annota\u00adtion and is one of the letters r, s, and n for residuation, speci.city, \nand narrowing, respectively. By convention p (with decoration) always stands for a constructor term. \nMoreover, write f. pj1 ...pjn = rj for the jth rule of the de.nition for function f. , and that mf. is \nthe number of j rules for f. . Clearly, there is no t ' so that f. t1 ...tn . t ' if j>mf. . Each of \nthe following subsections discusses one of the strategies. Each starts o. with an exposition of the rewrit\u00ading \nstrategy. A de.nition of the corresponding rewriting rule is next, and .nally we explain the applicability \nof this particular strategy in terms of one of the examples. 6.1 Residuation with Sequential Matching \nOur .rst strategy is based on residuation [47]. It is less powerful than narrowing (it is incomplete) \nbut it gives rise to a deterministic evaluation strategy. We present a complete formulation of residuation \nwith se\u00adquential matching. It corresponds to the typical way that functional programming languages interpret \npattern match\u00ading. The strategy tries to match the equations in textual order and commits to the .rst \nmatching equation. On the type level, this is the strategy of choice for function lifted from the data \nlevel to ensure that their type-level semantics are the same as their data-level semantics. Even though \nresiduation with sequential matching is a standard strategy [19], we present it in full because the pre\u00adsentation \nof speci.city-based matching in Section 6.2 builds upon the de.nitions here. Our notion of reduction \nis speci.ed as a rewriting relation on type terms t . t and is shown in Figure 6. In addition to 4 Haskell \nin particular, restricts instance declarations so that for each top-level type constructor there is at \nmost one in\u00adstance declaration. This restriction guarantees that reduc\u00adtion of predicates (aka reduction \nof type functions) is deter\u00administic because addition of new instances neither changes the typing nor \nthe meaning of an existing de.nition. The overlapping instances extension of Haskell has severe prob\u00adlems \nin connection with Haskell s open-world assumption. fr t1 . . . tn 1. t ' fr t1 . . . tn . t ' M(t1 . \n. . tn, pj1 . . . pjn) = Succ s fr t1 . . . tn j. srj if j = mfr M(t1 . . . tn, pj1 . . . pjn) = Fail \nfr t1 . . . tn j+1 . t ' if j = mfr fr t1 . . . tn j. t ' M(t1 ...tn,pj1 ...pjn)= Red t ' 1 ...t ' n \nif j = mfr j fr t1 ...tn . ft ' ...t ' 1 n The table shown in Figure 7 de.nes the function d(q, x), for \nq . Q and a match result x that accumulates the demand state of a list of terms. Typically, this list \nis the list of subterms of a particular term. The state remains Succ as long as the input symbol is Succ. \nAt the same time, the index keeps track of the position in a list of terms. The input Suspend or Fail \nchanges the state to Suspend or Fail. On input Red t, the state changes to (i, Red t) to register the \nposition where the reduction should happen. We write d * (q, D(ti,pi)) for d(... (d(q, D(t1,p1)),... \n), D(tn,pn)). Figure 6: Sequential residuation strategy the rules of a standard outermost reduction strategy, \nthere are additional cases for dealing with logical variables. Eval\u00aduation regards logical variables \nas indeterminate values. The de.nition of an outermost residuation step, t . t ' , j rests on an auxiliary \nnotion of reduction, t . t ' . Both rela\u00adtions are at most de.ned for terms t of the form fr t1 ...tn. \nj The latter relation, t . t ' , holds if t rewrites to t ' using rule number j or higher. The de.nition \nof . relies on a match\u00ading function M(t, p) that takes a tuple of terms, t, and a tuple of patterns, \np, both of the same length, and produces a match result. A match result is either Succ s indicating \na match with substitution s;  Fail indicating a match failure;  Suspend indicating that t is not su.ciently \ninstanti\u00adated to decide matching with p;  Red t ' indicating that the attempt to match t against  p \nhas forced an evaluation step from t to t ' in one of the components. j Note that there is no t ' such \nthat fr t1 ...tn . t ' if the matching function yields M(t1 ...tn,pj1 ...pjn)= Suspend. Matching makes \nuse of the subsidiary demand function D(t, p) that tries to evaluate the term t su.ciently so that syntactical \nmatching with p is possible. Since D just drives the evaluation, it does not return a substitution but \nonly signals with Succ that the term is su.ciently evaluated for matching to proceed syntactically. For \nthe correct and exhaustive de.nition of D, we rely on D(t, a)= Succ D(a,c p1 ...pn)= Suspend .' Red \nt. . . ... .. . if p not a variable and fr t1 ...tn . t ' D(fr t1 ...tn,p)= Suspend if p not a variable \nbut (.t ' ) fr t1 ...tn . t ' ' '' D(ct1 ...tn,c p1 ...p' )= Fail if c = c or n = n n ' Succ if q =(n, \nSucc) ' Fail if q = Fail ' D(ct1 ...tn,c p1 ...pn)= Suspend if q = Suspend Red ct1 ...t ' ...tn i ' if \nq =(i, Red t ' ) i ' where q = d*((0, Succ), D(ti,pi)) Figure 8: Demand function Figure 8 shows the demand \nfunction D. If the pattern is a variable, it signals Succ. If the term is a variable but the pattern \nis not, then D suspends because matching cannot proceed without further instantiation of the term. If \nthe term is a function call and the pattern is not a variable, then D returns Red t ' if the function \ncall reduces, otherwise D returns Suspend. If term and pattern start with construc\u00adtors that are either \ndi.erent or applied to di.erent numbers of subterms, D returns Fail. If both term and pattern start with \nthe same constructor applied to the same number of subterms, D is applied recursively to all corresponding \nsub\u00adterms and subpatterns. If all recursive calls yield Succ, the result is Succ. If the .rst non-Succ \nresult is Fail, the result is Fail. If the .rst non-Succ result is Suspend, the result is Suspend. If \nthe .rst non-Succ result is Red t, the result is also Red but with t correctly replaced in the reduced \nterm. an automaton that implements left-to-right matching. The states of the automaton form the following \nset Q: Q = {(i, Succ) | i . N}.{Suspend, Fail}.{(i, Red t) | i . N,t . TC.F (X )} The meaning of Succ, \nSuspend, Fail, and Red t is as described above. The additional index i paired with Succ and Red determines \na position in a tuple. In particular, (i, Red t) means that the ith subterm has been reduced to t and \nmust M(t1 . . . tn, p1 . . . pn) = . ' Succ s if q = (n, Succ) and (.1 = i = n) spi = ti . . Fail if \nq ' = (n, Succ) and (.s.i) spi = ti . Fail if q ' = Fail . . Red t1 . . . t ' i . . . tn Suspend if q \n' if q ' = (i, Red t ' i) = Suspend '  where q = d*((0, Succ), D(ti,pi)) Figure 9: Matching function \nbe replaced accordingly. The matching function M shown in Figure 9 applies D (i, Succ) Suspend Fail \n(i, Red t) (i + 1, Succ) Suspend Fail (i, Red t) Suspend Suspend Fail (i, Red t) Fail Suspend Fail (i, \nRed t) (i + 1, Red t ' ) Suspend Fail (i, Red t) Figure 7: Demand state transition function recursively \nto all corresponding pairs, (ti,pi), of term and pattern. If all calls to D return Succ, then syntactic \nmatch\u00ading is possible and M returns Succ s if s : p = t and Fail if no such substitution exists. M returns \nFail, Suspend, and Red t analogously to D. In the de.nition of s |= u a notion of normalization t . t \n' is required which does not stop reduction at a constructor, but rather reduces the subterms of a data \nconstructor as well. The de.nition of normalization does not distinguish partiality from non-termination: \nit either computes a con\u00adstructor term t ' or is unde.ned: t1 . t1 ' ... tn . tn ' a . a ct1 ...tn . \nct 1 ' ...t ' n fr '' t1 ...tn . tt . t fr t1 ...tn . t On the basis of this rewriting relation, the \nconstraint sys\u00adtem can be extended by the following simpli.cation rule for constraints: . ' . ' (u-residuate) \nt1 = t2 . t1 = t2 if (t1 . t1 ' and t2 = t2' ) or (t2 . t2 ' and t1 = t1' ) Proposition 4. Rule (u-residuate) \nis sound and com\u00adplete. This results extends Proposition 1. Given a con.uent and termination term rewriting \nsystem, Propositions 2 and 3 ex\u00ad tend, too. The structural properties of constraint entailment remain \ntrue, but we cannot hope for a principal constraint property, in general. Figure 10 demonstrates the \nuse of (u-residuate) for infer\u00adring the types of some expressions involving records.  6.2 Residuation \nwith Most-Speci.c Matching The residuation strategy with sequential matching is ap\u00adplicable when there \nis an obvious textual ordering of the in\u00adstances belonging to a single class. In the context of Haskell, \nthis is usually not the case, as the instances may be spread over several modules. Making the semantics \nof overloading depend on the order of the imports would be unsatisfactory. Hence, we consider a residuation \nstrategy which is indepen\u00addent of the textual order of the instances and which deals directly with overlapping \nrules. In the context of term rewriting, Kennaway [34] consid\u00ad ers a speci.city rule for ambiguous term \nrewriting systems: The rule (really a rewriting strategy) stipulates that a term rewrite rule of the \nsystem can only be used to reduce a term which matches it, if that term can never match any other rule \nof the system which is more speci.c than the given rule. One rule is more speci.c than another if the \nleft-hand side of the .rst rule is a substitution instance of the second, and the reverse is not true. \nThis is exactly the right de.nition for our purposes. While Kennaway applies the rule by trans\u00adlating \na system of equations into strongly sequential form, we embed speci.city directly into our evaluation \nstrategy. We start o. in a simpli.ed setting. Let t be a constructor term and P be a set of patterns \nthat appear as left-hand sides of equations. Let U(t, P ) be the set of patterns uni.\u00adable with t and \nM(t, P ) the set of patterns matching t. U(t, P )= {p . P |.t ' .t = t ' . p = t ' } M(t, P )= {p . P \n| p = t} Clearly, each matching pattern is also a uni.able pattern and instantiating a term increases \nthe set of matches. Proposition 5. M(t, P ) . U(t, P ) (1) t = t ' . M(t, P ) . M(t ' ,P ) (2) We say \nthat a pattern set P is ambiguous for t if M(t, P ) does not have a greatest element wrt. =.  a pattern \np . P is a de.nite match for t if p . M(t, P ) and .p ' . U (t, P ).p ' = p.  A pattern p cannot be \na de.nite match for t as long as there are patterns in P which are more speci.c than p and which are \nuni.able with t. Clearly, if s0 is a uni.er of p '' and t, then s0t matches p as well as p '' . Hence, \nthe de.nition rules out all potential patterns like p '' . The original formulation of the speci.city \nrule only deals with term rewriting systems. We also need to handle terms which contain residual function \napplications which are not su.ciently instantiated for further evaluation. Hence, we are interested in \nanswering the following question: could the function calls in (an instance of) t eventually evaluate \nto something matching p? We make a very rough approx\u00adimation to this property by replacing each function \ncall in t by a fresh variable and trying to unify the resulting term with p. Hence, de.ne FA(t) as a \nconstructor term so that t = FA(t)[ai . fi t ' i] where ai ./t for all i. Proposition 6. M(t, P )= M(FA(t),P \n) (1) U(t, P ) . U(FA(t),P ) (2) ' '' '' '' .t.(t = t . t . t ) . U (t ,P ) . U(FA(t),P ) (3) We extend \nour former de.nition: pattern p . P is a .nal match for t if p . M(t, P ) and .p ' . U(FA(t),P ).p ' \n= p. For de.ning the speci.city-based strategy, we extend the de.nitions of M, U, and FA() to tuples \nof terms t as well as sets of tuples of patterns P whenever the number of compo\u00adnents of the tuples is \nthe same throughout a set. The speci.city-based strategy tests all rewriting rules be\u00adfore making the \ndecision. For a term t = t1 ...tn, it f s computes a set L as follows: Each matching left-hand side \ncontributes a pair of the form (pj , srj )M where pj is a tuple of patterns (the left-hand side patterns \nof rule j) and srj is the instan\u00adtiated right-hand side of the matching rule j.  A left-hand side for \nwhich matching suspends con\u00adtributes just its tuple of patterns (pj )S .  Now de.ne LP(L)= {p |(p, r)M \n. L .(p)S . L}, and let .nalMatch(L, t) := {(p, t ' )|(p, t ' )M . L, p .nal match for t in LP(L)}. Figure \n11 de.nes the rewriting strategy as a reduction s relation t . t ' using an inference system for judgements \nof s,i the form L; t . t ' where L tracks the applicable matches. We write e, L for {e}. L. Consider \nthe generation of a record with one integer element at label Lx: add EMPTY Lx 42. The trace shows how \nu-residuate implements Haskell s predicate reduction at the type level: 1. Assumption: EMPTY :: EMPTY \n 2. Assumption: Lx ::Lx 3. Assumption: 42 :: Int  4. Assumption: add :: (SELECT f r =:= NOTHING) => \nr -> f -> v -> CONS (f,v) r 5. (e-app) on 4 and 1: add EMPTY :: (SELECT f EMPTY =:= NOTHING) => f -> \nv -> CONS (f,v) EMPTY 6. (e-app) on 5 and 2: add EMPTY Lx :: (SELECT Lx EMPTY =:= NOTHING) => v -> CONS \n(Lx,v) EMPTY 7. (e-app) on 6 and 3: add EMPTY Lx 42 :: (SELECT Lx EMPTY =:= NOTHING) => CONS (Lx,Int) \nEMPTY 8. (u-residuate) on the call to SELECT in 7 succeeds in the .rst step with substitution s mapping \nf to Lx: add EMPTY Lx 42 :: (NOTHING =:= NOTHING &#38; f =:= Lx) => CONS (Lx,Int) EMPTY 9. (u-constr-dec) \nand the fact that f is not part of the type lets us get rid of the remaining constraints: add EMPTY Lx \n42 :: CONS (Lx,Int) EMPTY  Figure 10: Type Derivation for Records s,1 \u00d8,fs t1 ...tn . t ' s fs t1 ...tn \n. t ' M(t1 ...tn,pj1 ...pjn)= Succ s s,j+1 (pj , srj )M ,L; fs t1 ...tn . t ' if j = mfs s,j L; fs t1 \n...tn . t ' M(t1 ...tn,pj1 ...pjn)= Fail s,j+1 L; fs t1 ...tn . t ' if j = mfs s,j L; fs t1 ...tn . t \n' M(t1 ...tn,pj1 ...pjn)= Red t ' ...t ' s,j1 n if j = mfs L; fs t1 ...ti ...tn . fs t ' ...t ' 1 n M(t1 \n...tn,pj1 ...pjn)= Suspend s,j+1 (pj )S ,L; fs t1 ...tn . t ' s,j L; fs t1 ...tn . t ' (p, t '). .nalMatch(L, \nt1 ...tn) if j>mfs s,j L; fs t1 ...tn . t ' Figure 11: Speci.city-based strategy In the same way as for \nthe sequential evaluation strategy, the speci.city-based strategy induces an evaluation relation: ss \n'' Assuming a closed world, we need not defer the expan\u00adsion of a function to the point where its parameters \nare su.ciently known. In particular, we can derive negative information and hence determine failures \nearlier. Narrowing comes in several eager and lazy variants [18]. Unfortunately, a narrowing step may \nintroduce a choice of We apply the overloaded equal member value of the EQUAL class from Section 2.3 \nto two character literals: equal x y . 1. Assumption after (e-spec): equal :: (r =:= EQUAL Char Char) \n=> Char -> -> r 2. x , y :: Char 3. equal x y :: (r =:= EQUAL Char Char) => 4. (u-residuate-ms) on \nthe constraint of 3 leads to  TRUE where (a, a, TRUE). .nalMatch(\u00d8, Char, Char) s,1 \u00d8, EQUAL Char \nChar . TRUE s EQUAL Char Char . TRUE 5. applying the substitution yields equal x y :: Char r r =:= TRUE \nFigure 12: Example with Most-Speci.c Matching di.erent alternatives. This choice is often expressed by \nnon\u00addeterministically rewriting a term into a term paired with a substitution. Formally, fn t1 ...tn \n.s sr if fn p1 ...pn = r is a variant of a rule for fn and s is the most general (syntactic) uni.er of \nt and p. The non-determinism arises due to the choice among the rules which are uni.able with p. In our \nconstraints, the non-determinism appears in the form of disjunction. Provided that the underlying term \nrewriting system is con.uent and terminating, narrowing yields a sound and complete E-uni.cation strategy \n[24]. A su.cient condition for con.uence is orthogonality of the rewrite rules (the left\u00ad s t1 . t ... \n1 tn . tn hand sides of the rules are pairwise disjoint). . a a s '' Here is the appropriate addition \nto the constraint simpli.\u00ad . ct1 ...tn ct 1 ...t n cation system that implements the narrowing strategy \n(;mj=1 s . fs s,1 '' t1 ...tn tt . t means a disjunction of constraints for j =1,...,m): . s fs  t1 \n...tn t . .. ' (u-narrow) u ;m .aj .t1 = t ' j1 &#38; ... &#38; tn = t ' = r j=1 jn &#38; t j .. The \nintegration of the speci.city-based strategy into the if (u = fn t1 ...tn = t or u = t = fn t1 ...tn) \nand t not a variable type inference engine gives rise to a rule (u-residuate-ms) ' and fn t ' ...t ' \n= r for 1 = j = m j1 jn j are fresh variants of fn s de.ning rules and aj are the free variables in the \njth rule which is analogous to (u-residuate). Proposition 7. Rule (u-residuate-ms) is sound and s complete \nwith respect to . . Proposition 8. Rule (u-narrow) is sound and complete. Figure 12 shows an example \nderivation using residuation with most-speci.c matching. The use of narrowing in type reduction can lead \nto bet\u00adter types and earlier error detection. On the other hand,  6.3 Narrowing narrowing it can also \nlead to complex and potentially un\u00ad readable types. Figure 13 considers the example from Section 2.4. \nThe interaction of the two uses of narrowing allows the type checker to narrow down the type to the point \nwhere it becomes unique. The e.ect is similar to the two-pass algo\u00adrithm for overloading resolution for \nAda given in the Dragon book [1]. The important di.erence is that our strategy does not require that \nan expression has a unique type, but rather defers the .nal elaboration by moving the remaining predi\u00adcates \ninto the type s context. Narrowing is only applicable for mutually disjoint sets of patterns. In particular, \nnarrowing in combination with most-speci.c matching can lead to problems. To see this, consider the function \nf de.ned by fC = D and fa = a, where C and D are nullary constructors. Consider further . the equation \nfC = C. By de.nition, a narrowing step with . ... this de.nition of f leads to [C = C &#38; D = C; a \n= C &#38; a = . C; ]. This predicate simpli.es to [FAIL; a = C; ] and then to . a = C. This outcome is \nwrong since the failure to unify the actual result of f with the expected result is interpreted as failure \nto match the argument with the expected argument. . The correct simpli.cation of fC = C would be FAIL. \n 7. IMPLEMENTATION NOTES We have implemented a prototype frontend for the vari\u00adant of Haskell used in \nthe examples of this paper. In par\u00adticular, we have adapted a Haskell frontend [36] to the new syntax, \nadded a dependency analysis and a kind inference pass as well as a translation to essentially the form \nrequired by Jones s Typing-Haskell-in-Haskell type checker [30]. We have adapted the type checker to \nHM(X), and implemented the constraint simpli.cation rules in Figure 5. The con\u00adstraint simpli.er calls \nan evaluation engine for function ap\u00adplications based on de.nitional trees [19], a representation for \nfunctional logic programs allowing .ne-grain control over the evaluation strategy. Currently, we have \ninstance transla\u00adtion functions implementing sequential residuation and nar\u00adrowing as described in Sections \n6.1 and 6.3.  8. RELATED WORK There have been many approaches to adding overloading to languages with \na Hindley/Milner style polymorphic type system, beginning with Kaes [33] and Wadler and Blott [49] and \nlater picked up, re.ned, and implemented by many oth\u00aders [40, 5, 39, 3, 26, 42, 15, 27, 29, 43, 35, 31]. \nIn particular, recent work is pushing hard the borders of complete and de\u00adcidable type inference [45, \n46]. In the face of this plethora, we only consider the most closely related work here. The work of Jones \n[27] and its extension to constructor classes [26] provides a general framework for type infer\u00adence with \nquali.ed types which (still) subsumes the facilities present in Haskell 98. The framework of quali.ed \ntypes is not su.ciently expressive for our purposes because it neither supports disjunction nor a closed-world \nassumption. Still, much of our inspiration comes from Jones s work on im\u00adprovement of predicates [29] \nand from its implementation via functional dependencies [31]. The HM(X) framework [41] generalizes various \nconstraint\u00ad based type inference systems, e.g., for record types and for object types. It can be instantiated \nto Haskell s type classes and can handle open-world as well as closed-world theories. HM(X) provides \nus with a parameterized type inference en\u00adgine and completeness results. A recent proposal that employs \nconstraint handling rules (CHR) to model type classes [14] is also based on HM(X). In this proposal, \nthe semantics of predicate reduction is for\u00admally de.ned as the rewriting relation induced by the CHR. \nSemantic properties such as ambiguity can be decided by checking certain properties of CHRs. The authors \ndemon\u00adstrate the generality of CHRs and their suitability to encode closed-world theories, too. Much \nof the thrust of our work is also on formally specifying the semantics of constraint sim\u00adpli.cation. \nHowever, a key innovation of our proposal is the customizability of the evaluation strategy. Duggan and \nothers [10] have proposed kinded parametric overloading for a variant of ML. They de.ne a kind struc\u00adture \nsimilar to a type class from accumulated overloaded value de.nitions. They have open kinds (corresponding \nto an open-world theory) as well as closed kinds (sic), but they provide a .xed type inference engine \nfor their language. In contrast, we specify a parameterized modular type inference system based on HM(X). \nShields and Peyton Jones [46] discuss various ad-hoc ex\u00ad tensions of Haskell s type system with the goal \nof explor\u00ading the design space. The main thrust of their extensions is the interoperability between Haskell \nand the object-oriented language C. . In particular, they present an encoding of sub\u00adtyping, ad-hoc overloading \nin a style similar to Java, and a general notion of overlap. Technically, they develop a type inference \nengine and give an overview of its technical properties termination, completeness, etc. Our approach \nis incomparable in power with their proposal. We can deal with most of their extensions, except the resolution \nof Java\u00adstyle overloading. We expect that their proposed solution (de.ne a partial order on type classes) \ncould also be made to work with our most-speci.c matching strategy. On the other hand, the narrowing \napproach to resolve Ada-style overloading is unique to our system. In addition, our sys\u00adtem extends simply \nand modularly just by specifying a new rewrite strategy. Further work on type-level programming indicates \nwide\u00adspread interest in the subject. There are applications [38, 37, 16, 48] as well as theoretical investigations \nstarting from a variety of foundations. Dependent types are certainly the ultimata ratio in type-level \nprogramming. Cayenne [4] is a Haskell dialect that builds on dependent type theory. Cayenne is much more \nradical than the present work be\u00adcause it builds on a richer type theory, where the entire term language \nis encorporated in the type language. While this is an interesting proposition for future work, we only \nallow certain term rewriting systems at present. An approach towards integrating dependent types into \na full programming language is the language DML(C) [51]. DML(C) allows for types indexed with constraints \nfrom a constraint domain C. This approach is also incomparable with our proposal. While DML(C) can incorporate \nsemanti\u00adcally rich constraint theories and thus guarantee a decidable type checking algorithm, our constraint \ntheory is in principle .xed but still variable due to the underlying term rewriting system and the choice \nof strategy for each function. Intensional type analysis [21, 7, 6, 50] is an approach to de.ning functions \nby induction on the structure of types. These works are closer to generic programming [22, 25]. The commonality \nis that their scheme of function de.nition is much more rigid than with our approach. Usually, the in\u00adspection \nof the type structure is limited to a fold operation. In contrast, we can examine the type structure \nusing a term rewriting system, which can even be ambiguous. There is a plethora of di.erent strategies \nfor performing narrowing and residuation and each has its bene.ts. De.\u00adnitional trees [19] serve as a \nmechanism for .ne-grain spec\u00ad  Narrowing obtains the unambiguous typing f :: Int -> Int -> Int (cf. \nSection 2.4) via the following derivation: 1. Assumptions: x:: x, y:: y, (+) :: (c=:=PLUS ab)=>a->b->c \n 2. (e-app) on 1: (+x):: (c=:= PLUS xb) =>b-> c 3. (e-app) on 2 and 1: x+y:: (c=:= PLUS xy) =>c 4. \n(e-app) on 1 and 3: (+) (x+y) :: (f=:= PLUS ce&#38;c=:= PLUSxy) =>e-> f 5. (e-app) on 4 and 42 :: Int: \n(x+y) +42:: (f =:= PLUS cInt &#38;c=:= PLUS xy)=>f From now on, the term remains the same and is omitted. \n 6. (u-narrow) for .rst PLUS on 5: (((c =:= Int &#38; Int =:= Int &#38; f =:= Int) ;(c =:= Float &#38; \nInt =:= Float &#38; f =:= Float) ;(exists q. c =:= [q] &#38; Int =:= [q] &#38; f =:= [q])) &#38;c =:= \nPLUS x y) =>f  7. (u-choice-and) on 6: ((c =:= Int &#38;Int =:= Int&#38;f=:=Int&#38;c=:= PLUS x y) ;(c \n=:= Float &#38; Int =:= Float &#38; f =:= Float &#38; c =:= PLUS x y) ;(exists q. c=:=[q] &#38;Int=:=[q]&#38;f=:=[q]&#38;c=:= \nPLUS xy))=>f 8. (u-constr-dec), (u-constr-fail) on 7: ((c =:= Int &#38; Success &#38; f =:= Int &#38; \nc =:= PLUS x y) ;(c =:= Float &#38; Fail &#38; f =:= Float &#38; c =:= PLUS x y) ;(exists q. c=:=[q] \n&#38;Fail&#38;f=:=[q] &#38;c=:= PLUS xy)) =>f  9. (u-and-fail) and (u-exists-drop) on 8: ((c =:= Int \n&#38; Success &#38; f =:= Int &#38; c =:= PLUS x y) ;Fail ;Fail) => f 10. (u-choice-fail) and (u-and-success) \non 9: (c=:=Int &#38;f =:=Int &#38; c=:= PLUS xy)=>f 11. (u-subst) on 10: (Int =:= PLUS x y) => Int \n12. (u-narrow) on 11: ((x =:= Int &#38; y =:= Int &#38; Int =:= Int) ;(x =:= Float &#38; y =:= Float \n&#38; Int =:= Float) ;(exists q. x =:= [q] &#38; y =:= [q] &#38; Int =:= [q]) ) => Int  13. (u-constr-dec), \n(u-constr-fail), (u-and-success), (u-and-fail), (u-exists-drop), and (u-choice-fail) on 12: (x =:= Int \n&#38; y =:= Int) => Int Figure 13: An Example Derivation with Narrowing i.cation of evaluation strategies. \nIn particular, the Curry language [20] allows the programmer to annotate equations with evaluation annotations \nspecifying the evaluation strat\u00adegy, similar to our approach. 9. CONCLUSION We have presented a programmable \napproach to the im\u00adplementation of overloading. The introduced transition from type-classes-as-predicates \nto type-classes-as-functions allows for natural formulations of solutions of many practical over\u00adloading \nproblems, among them the classic sprintf problem, the handling of overlapping instances as well as Ada-style \noverloading. We have designed a concrete variant of the Haskell language which supports functional logic \noverload\u00ading, and implemented a prototype frontend for it. The type system needed for handling this style \nof overloading is based on parameterizing the HM(X) framework with uni.cation constraints. Constraint \nsimpli.cation calls an evaluation en\u00adgine for functional logic programs when it encounters appli\u00adcations \nof type-level functions. The choice of an evaluation strategy for type-level functions opens a spectrum \nof design choices for this style of overloading. Di.erent applications bene.t from di.erent evaluation \nstrategies. It remains to be seen what combination of evaluation strategies is most ap\u00adpropriate for \npractical use, and what degree of control over it the language should o.er the programmer. 10. REFERENCES \n[1] A. V. Aho, R. Sethi, and J. D. Ullman. Compilers Principles, Techniques, and Tools. Addison-Wesley, \n1986. [2] Arvind, editor. Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, \nJune 1993. ACM Press, New York. [3] L. Augustsson. Implementing Haskell overloading. In Arvind [2], pages \n65 73.  [4] L. Augustsson. Cayenne a language with dependent types. In Hudak [23]. [5] K. Chen, P. \nHudak, and M. Odersky. Parametric type classes. In Proc. 1992 ACM Conference on Lisp and Functional Programming, \npages 170 181, San Francisco, California, USA, June 1992. [6] K. Crary and S. Weirich. Flexible type \nanalysis. In P. Lee, editor, Proc. International Conference on Functional Programming 1999, pages 233 \n248, Paris, France, Sept. 1999. ACM Press, New York. [7] K. Crary, S. Weirich, and G. Morrisett. Intensional \npolymorphism in type-erasure semantics. In Hudak [23], pages 301 312. [8] L. Damas and R. Milner. Principal \ntype-schemes for functional programs. In Proc. 9th Annual ACM Symposium on Principles of Programming \nLanguages, pages 207 212. ACM, 1982. [9] O. Danvy. Functional unparsing. Journal of Functional Programming, \n8(6):621 625, Nov. 1998. [10] D. Duggan, G. V. Cormack, and J. Ophel. Kinded type inference for parametric \noverloading. Acta Inf., 33(1):21 68, 1996. [11] J. H. Gallier and W. Snyder. Complete sets of transformations \nfor general E-uni.cation. Theoretical Comput. Sci., 67((2+3)):203 260, 1989. [12] M. Gasbichler, M. Neubauer, \nM. Sperber, and P. Thiemann. Functional logic overloading. Technical Report 163, Institut f\u00a8ur Informatik, \nUniversity of Freiburg, Germany, Nov. 2001. Available from ftp://ftp.informatik.uni-freiburg.de/documents/ \nreports/report163/report00163.ps.gz. [13] E. Giovannetti, G. Levi, C. Moiso, and C. Palamidessi. Kernel-LEAF: \nA logic plus functional language. Journal of Computer and System Sciences, 42(2):139 185, 1991. [14] \nK. Glynn, P. Stuckey, and M. Sulzmann. Type classes and constraint handling rules. In First Workshop \non Rule-Based Constraint Reasoning and Programming, July 2000. [15] C. Hall, K. Hammond, S. Peyton Jones, \nand P. Wadler. Type classes in Haskell. In D. Sannella, editor, Proc. 5th European Symposium on Programming, \nnumber 788 in Lecture Notes in Computer Science, pages 241 256, Edinburgh, UK, Apr. 1994. Springer-Verlag. \n[16] T. Hallgren. Fun with functional dependencies. In Joint Winter Meeting of the Departments of Science \nand Computer Engineering, Chalmers University of Technology and G\u00a8oteborg University, Varberg, Sweden, \nJan. 2001. http: //www.cs.chalmers.se/~hallgren/Papers/wm01.html. [17] M. Hanus. On the completeness \nof residuation. In Proc. of the 1992 Joint International Conference and Symposium on Logic Programming, \npages 192 206. MIT Press, 1992. [18] M. Hanus. The integration of functions into logic programming: From \ntheory to practice. Journal of Logic Programming, 19,20:583 628, 1994. [19] M. Hanus. A uni.ed computation \nmodel for functional and logic programming. In Jones [32], pages 80 93. [20] M. Hanus. Curry an integrated \nfunctional logic language. http: //www.informatik.uni-kiel.de/~curry/report.html, June 2000. Version \n0.7.1. [21] R. Harper and G. Morrisett. Compiling polymorphism using intensional type analysis. In Proc. \n22nd Annual ACM Symposium on Principles of Programming Languages, pages 130 141, San Francisco, CA, Jan. \n1995. ACM Press. [22] R. Hinze. A new approach to generic functional programming. In Reps [44], pages \n119 132. [23] P. Hudak, editor. International Conference on Functional Programming, Baltimore, USA, \nSept. 1998. ACM Press, New York. [24] J.-M. Hullot. Canonical forms and uni.cation. In R. Kowalski, \neditor, Proceedings of the Fifth International Conference on Automated Deduction (Les Arcs, France), \nnumber 87 in Lecture Notes in Computer Science, pages 318 334, Berlin, July 1980. Springer-Verlag.  \n[25] P. Jansson and J. Jeuring. PolyP -a polytypic programming language extension. In Jones [32], pages \n470 482. [26] M. P. Jones. A system of constructor classes: Overloading and implicit higher-order polymorphism. \nIn Arvind [2], pages 52 61. [27] M. P. Jones. Quali.ed Types: Theory and Practice. Cambridge University \nPress, Cambridge, UK, 1994. [28] M. P. Jones. Functional programming with overloading and higher-order \npolymorphism. In Advanced Functional Programming, volume 925 of Lecture Notes in Computer Science, pages \n97 136. Springer-Verlag, May 1995. [29] M. P. Jones. Simplifying and improving quali.ed types. In S. \nPeyton Jones, editor, Proc. Functional Programming Languages and Computer Architecture 1995, pages 160 \n169, La Jolla, CA, June 1995. ACM Press, New York.  [30] M. P. Jones. Typing Haskell in Haskell. In \nE. Meijer, editor, Proceedings of the 1999 Haskell Workshop, number UU-CS-1999-28 in Technical Reports, \n1999. ftp://ftp.cs. uu.nl/pub/RUU/CS/techreps/CS-1999/1999-28.pdf. [31] M. P. Jones. Type classes with \nfunctional dependencies. In G. Smolka, editor, Proc. 9th European Symposium on Programming, number 1782 \nin Lecture Notes in Computer Science, pages 230 244, Berlin, Germany, Mar. 2000. Springer-Verlag.  [32] \nN. D. Jones, editor. Proc. 24th Annual ACM Symposium on Principles of Programming Languages, Paris, France, \nJan. 1997. ACM Press. [33] S. Kaes. Parametric overloading in polymorphic programming languages. In H. \nGanzinger, editor, Proc. 2nd European Symposium on Programming 1988, number 300 in Lecture Notes in Computer \nScience, pages 131 144. Springer-Verlag, 1988. [34] R. Kennaway. The speci.city rule for lazy pattern-matching \nin ambiguous term rewrite systems. In N. D. Jones, editor, Proc. 3rd European Symposium on Programming \n1990, number 432 in Lecture Notes in Computer Science, pages 256 270, Copenhagen, Denmark, 1990. Springer-Verlag. \n[35] J. R. Lewis, J. Launchbury, E. Meijer, and M. B. Shields. Implicit parameters: Dynamic scoping with \nstatic types. In Reps [44], pages 108 118. [36] S. Marlow, S. Panne, and N. Winstanley. hsparser: The \n100% pure Haskell parser, 1998. http://www.pms.informatik.uni-muenchen.de/ mitarbeiter/panne/haskell_libs/hsparser.html. \n [37] C. McBride. Faking it simulating dependent types in Haskell. http://www.dur.ac.uk/~dcs1ctm/faking.ps, \n2001. [38] M. Neubauer, P. Thiemann, M. Gasbichler, and M. Sperber. A functional notation for functional \ndependencies. In R. Hinze, editor, Proceedings of the 2001 Haskell Workshop, 2001. to appear. [39] T. \nNipkow and C. Prehofer. Type checking type classes. In Proc. 20th Annual ACM Symposium on Principles \nof Programming Languages, pages 409 418, Charleston, South Carolina, Jan. 1993. ACM Press. [40] T. Nipkow \nand G. Snelting. Type classes and overloading resolution via order-sorted uni.cation. In J. Hughes, editor, \nProc. Functional Programming Languages and Computer Architecture 1991, number 523 in Lecture Notes in \nComputer Science, pages 1 14, Cambridge, MA, 1991. Springer-Verlag. [41] M. Odersky, M. Sulzmann, and \nM. Wehr. Type inference with constrained types. Theory and Practice of Object Systems, 5(1):35 55, 1999. \n[42] J. Peterson and M. Jones. Implementing type classes. In Proc. of the ACM SIGPLAN 93 Conference on \nProgramming Language Design and Implementation, pages 227 236, Albuquerque, New Mexico, June 1993. [43] \nS. Peyton Jones, M. Jones, and E. Meijer. Type classes: An exploration of the design space. In J. Launchbury, \neditor, Proc. of the Haskell Workshop, Amsterdam, The Netherlands, June 1997. Yale University Research \nReport YALEU/DCS/RR-1075. [44] T. Reps, editor. Proc. 27th Annual ACM Symposium on Principles of Programming \nLanguages, Boston, MA, USA, Jan. 2000. ACM Press. [45] M. Shields and E. Meijer. Type-indexed rows. In \nH. R. Nielson, editor, Proc. 28th Annual ACM Symposium on Principles of Programming Languages, pages \n261 275, London, Jan. 2001. ACM Press. [46] M. Shields and S. Peyton Jones. Object-oriented style overloading \nfor Haskell. In BABEL 01. First Workshop on Multi-Language Infrastructure and Interoperability, Florence, \nItaly, Sept. 2001. [47] P. A. Subrahmanyam and J.-H. You. FUNLOG: A computational model integrating logic \nprogramming and functional programming. In D. DeGroot and G. Lindstrom, editors, Logic Programming: Functions, \nRelations and Equations. Prentice Hall, Englewood Cli.s, NJ, 1986. [48] P. Thiemann and M. Sperber. Program \ngeneration with class. In M. Jarke, K. Pasedach, and K. Pohl, editors, Proceedings Informatik 97, Reihe \nInformatik aktuell, pages 582 592, Aachen, Sept. 1997. Springer-Verlag. [49] P. Wadler and S. Blott. \nHow to make ad-hoc polymorphism less ad-hoc. In Proc. 16th Annual ACM Symposium on Principles of Programming \nLanguages, pages 60 76, Austin, Texas, Jan. 1989. ACM Press. [50] S. Weirich. Encoding intensional type \nanalysis. In D. Sands, editor, Proc. 10th European Symposium on Programming, Lecture Notes in Computer \nScience, Genova, Italy, Apr. 2001. Springer-Verlag. [51] H. Xi and F. Pfenning. Dependent types in practical \nprogramming. In A. Aiken, editor, Proc. 26th Annual ACM Symposium on Principles of Programming Languages, \npages 214 227, San Antonio, Texas, USA, Jan. 1999. ACM Press.   \n\t\t\t", "proc_id": "503272", "abstract": "Functional logic overloading is a novel approach to user-defined overloading that extends Haskell's concept of type classes in significant ways. Whereas type classes are conceptually predicates on types in standard Haskell, they are <i>type functions</i> in our approach. Thus, we can base type inference on the evaluation of functional logic programs. Functional logic programming provides a solid theoretical foundation for type functions and, at the same time, allows for programmable overloading resolution strategies by choosing different evaluation strategies for functional logic programs. Type inference with type functions is an instance of type inference with constrained types, where the underlying constraint system is defined by a functional logic program. We have designed a variant of Haskell which supports our approach to overloading, and implemented a prototype front-end for the language.", "authors": [{"name": "Matthias Neubauer", "author_profile_id": "81100042558", "affiliation": "Universit&#228;t Freiburg", "person_id": "P343130", "email_address": "", "orcid_id": ""}, {"name": "Peter Thiemann", "author_profile_id": "81100458917", "affiliation": "Universit&#228;t Freiburg", "person_id": "PP39043747", "email_address": "", "orcid_id": ""}, {"name": "Martin Gasbichler", "author_profile_id": "81100649955", "affiliation": "Universit&#228;t T&#252;bingen", "person_id": "PP14222682", "email_address": "", "orcid_id": ""}, {"name": "Michael Sperber", "author_profile_id": "81100100127", "affiliation": "Universit&#228;t T&#252;bingen", "person_id": "PP14044834", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/503272.503294", "year": "2002", "article_id": "503294", "conference": "POPL", "title": "Functional logic overloading", "url": "http://dl.acm.org/citation.cfm?id=503294"}