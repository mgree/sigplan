{"article_publication_date": "01-01-2002", "fulltext": "\n Information Flow Inference for ML Franc\u00b8ois Pottier Vincent Simonet INRIA, BP 105, 78153 Le Chesnay \nCedex, INRIA, BP 105, 78153 Le Chesnay Cedex, France France Francois.Pottier@inria.fr Vincent.Simonet@inria.fr \nABSTRACT This paper presents a type-based information .ow analysis for a call-by-value .-calculus equipped \nwith references, ex\u00adceptions and let-polymorphism, which we refer to as Core ML. The type system is constraint-based \nand has decidable type inference. Its non-interference proof is reasonably light\u00adweight, thanks to the \nuse of a number of orthogonal tech\u00adniques. First, a syntactic segregation between values and expressions \nallows a lighter formulation of the type system. Second, non-interference is reduced to subject reduction \nfor a non-standard language extension. Lastly, a semi-syntactic approach to type soundness allows dealing \nwith constraint\u00adbased polymorphism separately. 1. INTRODUCTION Information .ow analysis consists in statically \ndetermin\u00ading how a program s outputs are related to its inputs, i.e. how the former depend, directly \nor indirectly, on the latter. This allows establishing secrecy and integrity properties of a program, \ni.e. proving that some aspects of its behavior convey no information about those of its inputs deemed \nse\u00adcret , or remain independent of those deemed unreliable . These properties are instances of non-interference \n[6]: they state the absence of certain dependencies. Because information .ow analysis is complex and \nerror\u00adprone, it must be automated. During the past few years, several researchers have advocated its \nformulation as a type system. Then, existing type inference techniques provide automation, while type \nsignatures provide concise, formal security speci.cations. Our interest is in designing and proving \ncorrect a type\u00adbased information .ow analysis for (the kernel of) a realis\u00adtic sequential programming \nlanguage. (In the presence of concurrency, the termination of a process is observable by other processes, \ncreating new ways to leak information and requiring more restrictive type systems. Hence, it appears \nreasonable to .rst experiment with information .ow control in a sequential setting.) To date, most formal \nresults ob- Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n02, Jan. 16-18, 2002 Portland, OR USA Copyright 2002 ACM ISBN 1-58113-450-9/02/01 ...$5.00. tained in \nthis area concern extremely reduced programming languages. Several papers address pure .-calculi [7, \n1, 14]. Volpano et al. [20, 19] study a core imperative program\u00adming language, where all variables store \nintegers. Standing in sharp contrast, Myers [9, 10] considers the full Java lan\u00adguage, including objects, \nexceptions, parameterized classes, etc. However, he does not give a formal proof of correctness; indeed, \nour formal approach uncovered a couple of .aws in his type system (see section 7.3). In an attempt to \nbridge the gap between these approaches, we consider a call-by-value .-calculus equipped with refer\u00adences, \nexceptions and let-polymorphism, which we refer to as Core ML. (Presentation set aside, it is identical \nto Wright and Felleisen s Core ML [22], except our exception names have global scope and are not .rst-class \nvalues.) Such a cal\u00adculus can be viewed as the core of the functional program\u00adming language Caml-Light \n[8]. We endow it with a polymor\u00adphic, constraint-based type system, called mlif, which has decidable \ntype inference and guarantees non-interference. A (monomorphic) treatment of references in a higher\u00adorder \nlanguage can be found in [23]. Exceptions have been studied by Myers [9, 10] for Java. However, Myers \ntreat\u00adment relies on Java s explicit, monomorphic throws clauses, whereas our type system uses a more \n.exible, polymorphic e.ect analysis, giving rise to issues discussed in section 10. The combination of \nreferences, exceptions and constrained let-polymorphism, as well as our use of a standard subject reduction \ntechnique to establish non-interference, are novel. Our treatment of un-annotated tuple types and of \npolymor\u00adphic equality form ancillary contributions. 2. OVERVIEW Type systems are typically used to establish \nsafety prop\u00aderties, i.e. prove that a certain invariant holds throughout the execution of a program. \nType safety is such a property. However, non-interference [6] requires two independent pro\u00adgram runs, \ngiven di.erent inputs, to yield the same output. As a result, its proof is often more delicate. Abadi \net al. [2] devised a labelled operational semantics of the .-calculus, where the labels attached to a \nterm indicate how much information it carries. Executing a program un\u00adder such a semantics amounts to \nperforming a dynamic de\u00adpendency analysis along with the actual computation. Pot\u00adtier and Conchon [14] \nlater showed how static, type-based dependency analyses could be systematically derived, and proven safe, \nfrom such a labelled semantics. Unfortunately, in a programming language with side ef\u00adfects, it is possible \nto leak information through the absence of a certain e.ect. Indeed, consider the program fragment if \nx =1 then y := 1 . If, after executing this statement, y isn t 1, then x cannot be 1 either. Thus, in \nthat case, exe\u00adcution transfers information about x to y, even though no assignment takes place, since \nthe statement y:=1 is skipped. It appears di.cult for a labelled semantics to account for the e.ect of \ncode that is not executed; so, the approach must be reconsidered. Direct non-interference proofs, although \nstraightforward for simple programming languages [20], become increasingly complex in richer languages, \nrequiring cumbersome invari\u00adants to be manipulated [23]. To avoid this pitfall, we break our proof down \ninto several independent steps. First, we de.ne a special-purpose extension of the language, which allows \nexplicit reasoning about the commonalities and dif\u00adferences between two arbitrary program con.gurations, \nand prove it adequate in a certain sense. Then, we de.ne a type system for this extended language, and \nprove that it enjoys a subject reduction property. Lastly, we show that non-interference for the base \nlanguage is a consequence of these results. In other words, we reduce the initial problem to subject \nreduction a safety property for our special\u00adpurpose language. The invariant preserved by reduction \nis thus expressed in the type system itself, making it easier to reason about. In keeping with the ML \ntradition, our type system has let-polymorphism and type inference. In addition to struc\u00adture, our types \ndescribe e.ects and security levels; polymor\u00adphism allows writing code that is generic with respect to \nall three. Type inference is an indispensable help, because our types are verbose and information .ow \nis often un-intuitive. Because we employ subtyping (as well as other forms of constraints), our type \ninference system is constraint-based. Yet, if generalization, instantiation, and constraint manip\u00adulation \nwere part of the type system from the outset, our subject reduction proof would be signi.cantly obfuscated. \nTo work around this problem, we adopt a semi-syntactic approach [13], which again consists in breaking \ndown the construction into two steps. First, we present a system equipped with an extensional form of \npolymorphism, whose formal treatment is remarkably un-intrusive. Then, we build a constraint-based system \nin the style of HM(X) [11], which we prove correct with respect to the former. We will now proceed as \nfollows. We .rst present the syn\u00adtax of Core ML (section 3). Then, we introduce our technical extension \nof it, which we refer to as Core ML2 , give an operational semantics to both languages at once, and show \nhow they relate to each other (section 4). Section 5 intro\u00adduces mlif0, a type system for Core ML2, and \nestablishes subject reduction. Combining these results, we obtain a non-interference property for Core \nML (section 6). In sec\u00adtion 7, we digress and discuss a few language extensions. Culminating our development, \nsection 8 presents mlif,a constraint-based type system which we prove correct with respect to mlif0, \nallowing type inference. Sections 9 and 10 give some examples and conclude. By lack of space, many proofs \nare omitted; they can be found in the full version of this paper [15]. 3. Core ML Let k range over integers; \nlet x, m, e range over disjoint denumerable sets of program variables, memory locations, and exception \nnames, respectively. Then, values, outcomes, expressions and evaluation contexts are de.ned as follows: \nv ::= x | .x f..x.e | k | () | m | ev o ::= v | raise (ev) e ::= o | vv | ref v | v := v | ! v | raise \nv | let x = v in e | E[e] E ::= bind x =[] in e | [] handle ex > e | [] handle x > e Our values include \nvariables, .-abstractions, integers, a unit constant, memory locations, and exceptions. An ab\u00adstraction \n.x f..x.e may recursively refer to itself through the program variable f. (This is done merely to avoid \ndeal\u00ading with recursion separately.) Every exception name e can be used as a data constructor to build \nexception values of the form ev. Outcomes, known as answers in [22], represent inactive computations; \nthey are either values or unhandled exceptions of the form raise (ev). An expression is an out\u00adcome, \na so-called basic expression,a let construct, or another expression enclosed within an evaluation context. \nBasic expressions include function applications as well as instances of four primitive operations, which \nallow allocat\u00ading, updating, dereferencing memory cells, and raising ex\u00adceptions. They are built out \nof values, rather than out of ar\u00adbitrary sub-expressions. This syntactic restriction, which is reminiscent \nof Flanagan et al. s A-normal forms [5], o.ers a number of advantages. First, it enables a lighter formulation \nof our type-and-e.ect system. Indeed, because values have no computational e.ect, a basic expression \ns sub-expressions do not contribute to its e.ect. Furthermore, it allows our system to remain independent \nof the evaluation strategy, i.e. of the choice of left-to-right vs. right-to-left evaluation order. User \nprograms, expressed in a more liberal syntax, must be translated down into our restricted syntax before \nthey can be analyzed; di.erent evaluation strategies will simply cor\u00adrespond to di.erent translation \nschemes. The let construct let x = v in e has the same meaning as the basic expression (.x f..x.e) v \n(where f is not free in e). However, as usual in ML [22], the let keyword di\u00adrects the type checker to \ngive x polymorphic type. Follow\u00ading Wright [21], we require the binding to contain a value v, rather \nthan an arbitrary sub-expression, so as to avoid unsoundness in the presence of imperative features. \nAs a result, let constructs do not appear among evaluation con\u00adtexts. Evaluation contexts provide glue \nto combine expressions and specify their evaluation order. The expression bind x = e1 in e2 evaluates \ne1, binds its value (if any) to x, then evaluates e2. The bind keyword does not request type gen\u00aderalization; \nit merely expresses sequentiality. Our decision of making let and bind separate constructs emphasizes \nthis distinction. The handle constructs are dual to bind: they specify what happens after the expression \nunder scrutiny raises an exception, rather than after it returns a value. The meaning of the memory locations \nwhich occur in a Core ML expression is given by a store \u00b5, i.e. a partial map from memory locations to \nvalues. We write \u00b5[m . v] and \u00b5 . [m . v] for the store which maps m to v and otherwise agrees with \u00b5; \nthe latter is de.ned only if m . dom(\u00b5).  4. Core ML2 4.1 Presentation Non-interference requires reasoning \nabout two programs and proving that they share some sub-terms throughout ex\u00adecution. To make such reasoning \neasier, we choose to repre\u00adsent them as a single term of an extended language, called Core ML2, rather \nthan as a pair of Core ML terms. The extension is as follows: v ::= ... |(v | v)| void o ::= ... |(o \n| o) e ::= ... |(e | e) The Core ML2 term (e1 | e2) is intended to encode the pair of Core ML terms (e1,e2). \nIt is important to note that it can appear at an arbitrary depth within a term. For instance, assuming \nv is a Core ML value, the terms (v1 | v2)v and (v1 v | v2 v) both encode the pair (v1 v, v2 v). The former, \nhowever, is more informative, because it explicitly records the fact that the application node and its \nargument v are shared, while the latter doesn t. We do not allow nesting (\u00b7 | \u00b7) constructs. We need \nto keep track of sharing not only between ex\u00adpressions, but also between stores. However, distinct stores \nmay have distinct domains. To account for this fact, we in\u00adtroduce a special constant void. By creating \nbindings of the form m .(v | void) and m .(void | v) in the store, we represent situations where a memory \nlocation m is bound within only one of the two Core ML expressions encoded by a Core ML2 term. A con.guration \ne/i \u00b5 is a triple of an expression e, a store \u00b5, and an index i . { , 1, 2}, whose purpose is explained \nin section 4.2. We write e/\u00b5 for e/ \u00b5. We restrict our attention to well-formed, closed con.gu\u00adrations. \n(These technical notions are de.ned in the full ver\u00adsion of this paper [15]. They are preserved by reduction \nand guarantee that void is used exclusively in store bindings, as described above.) Furthermore, we identify \ncon.gurations up to consistent renamings of memory locations. The correspondence between Core ML and \nCore ML2 is made explicit by means of two projection functions L\u00b7Ji, where i ranges over {1, 2}. They \nsatisfy L(e1 | e2)Ji = ei and are homomorphisms on other expression forms. They are ex\u00adtended to stores \nas follows: L\u00b5Ji maps m to L\u00b5(m)Ji if and only if the latter is de.ned and isn t void. Lastly, the pro\u00adjection \nof a con.guration is de.ned by Le/\u00b5Ji = LeJi / L\u00b5Ji.  4.2 Semantics The small-step operational semantics \nof Core ML2 is given in .gure 1. The .rst two groups of reduction rules are those of Core ML, with a \nfew technical twists explained below. The rules in the third group are speci.c to Core ML2; they allow \ndiscarding sharing information if reduction cannot oth\u00aderwise take place. The rules in the fourth group \nallow re\u00adduction under a context. The rules are designed so that the image of any reduction step through \na projection function is again a valid reduction step. Reduction may take place outside brackets, causing \nboth projections to perform the same reduction step; in\u00adside brackets, letting one projection compute \nindependently, while the other remains stationary; or lift up the bracket boundary, discarding some sharing \ninformation, while leav\u00ading both projections unchanged. The capture-free substitution of v for x in e, \nwritten e[x . v], is de.ned in the usual way, except at (\u00b7 | \u00b7) nodes, where we must use an appropriate \nprojection of v in each branch: (e1 | e2)[x . v] is (e1[x .LvJ1] | e2[x .LvJ2]). We would like the rules \nin the .rst two groups to be ap\u00adplicable under any context. However, (ref), (assign) and (deref) need \na small amount of contextual information. In\u00addeed, the store must be accessed in a context-dependent \nmanner: operations which take place inside a (\u00b7 | \u00b7) con\u00adstruct must use or a.ect only one projection \nof the store. The index i carried by con.gurations is used for this pur\u00adpose. Its value is when dealing \nwith top-level reduction steps; it is made 1 (resp. 2) by rule (bracket) when reducing within the left \n(resp. right) branch of a (\u00b7 | \u00b7) construct. It is used in the auxiliary functions newi, updatei and \nreadi to access the store in an appropriate way. The rules in the second group describe how values and \nexceptions are bound (i.e. handled) or propagated. We say that E handles o if and only if E[o] is reducible \nthrough (bind), (handle) or (handle-all). The rules in the third group have no computational con\u00adtent: \nthey leave both projections unchanged. Their purpose is to prevent (\u00b7 | \u00b7) constructs from blocking reduction, \nwhich is done by lifting them up, thus causing some sub-terms to be duplicated, but allowing reduction \nto proceed independently within each branch. For instance, the left-hand expression in (lift-app) is \nnot a \u00df-redex. In its reduct, the application node and the sub-term v are duplicated, allowing two \u00df\u00adredexes \nto appear. A somewhat analogous rule can be found in Abadi et al. s labelled semantics of the .-calculus \n[2]. To understand the signi.cance of the lift rules, one must bear in mind that the contents of every \n(\u00b7 | \u00b7) construct will be viewed as secret . By causing new sub-terms to become secret during reduction, \nthese rules actually provide an ex\u00adplicit description of information .ow. Our design attempts to discard \nas little sharing information as possible; indeed, replacing all of these rules with e . (LeJ1 |LeJ2), \nwhile com\u00adputationally correct, would cause the type system to view every expression as secret . The \nsemantics of Core ML can be obtained as a fragment of that of Core ML2 . 4.3 Relating Core ML2 to Core \nML We now show that Core ML2 is an appropriate tool to reason simultaneously about the execution of two \nCore ML programs. This is expressed by two properties. First, as explained above, the image of a valid \nreduction through projection remains a valid reduction. Conversely, if both projections of a term can \nbe reduced to an outcome, then so can the term itself. Lemma 4.1 (Soundness) Let i .{1, 2}. If e/\u00b5 . \ne' /\u00b5', = then Le/\u00b5Ji .Le' /\u00b5'Ji. Lemma 4.2 (Completeness) Assume Le/\u00b5Ji .* oi /\u00b5'i for all i .{1, 2}. \nThen, there exists a con.guration o/\u00b5' such that e/\u00b5 .* o/\u00b5' and, for all i .{1, 2}, Lo/\u00b5'Ji = oi /\u00b5'i. \nOur completeness result requires both projections to con\u00adverge; it is not applicable if one of them diverges. \nIndeed, de\u00ad.ne e as bind x = (O | 0) in 0, where O is a non-terminating expression. Its right projection \nis bind x =0 in 0, which reduces to 0; yet, e cannot be reduced to any term whose Basic reductions Sequencing \nLifting (.x f..x.e) v/i \u00b5 ref v/i \u00b5 m := v/i \u00b5 ! m/i \u00b5 let x = v in e/i \u00b5 bind x = v in e/i \u00b5 raise \n(ev) handle ex > e/i \u00b5 raise (ev) handle x > e/i \u00b5 E[o] /i \u00b5 E[(o1 | o2)] /\u00b5 (v1 | v2) v/\u00b5 (v1 | v2) \n:= v/\u00b5 ! (v1 | v2) /\u00b5 raise (e1 v1 | e2 v2) /\u00b5 Reduction under a context . e[x . v][f . .x f..x.e] \n/i \u00b5 . m/i \u00b5 . [m . newi v] . () /i \u00b5[m . updatei \u00b5(m) v] . readi \u00b5(m) /i \u00b5 . e[x . v] /i \u00b5 . e[x \n. v] /i \u00b5 . e[x . v] /i \u00b5 . e[x . ev] /i \u00b5  . o/i \u00b5 if \u00ac(E handles LoJ1 . E handles LoJ2) . (LEJ1[o1] \n|LEJ2[o2]) /\u00b5 if none of the sequencing rules applies . (v1 LvJ1 | v2 LvJ2) /\u00b5 . (v1 := LvJ1 | v2 := \nLvJ2) /\u00b5  . ( ! v1 | ! v2) /\u00b5 . (raise (e1 v1) | raise (e2 v2)) /\u00b5 e/i \u00b5 . e ' /i \u00b5 ' E[e] /i \u00b5 . E[e \n' ] /i \u00b5 ' ' ' ' ei /i \u00b5 . ei /i \u00b5ej = ej {i, j} = {1, 2} ' ' ' (e1 | e2) /\u00b5 .(e1 | e2) /\u00b5 '' (\u00df) (ref) \n(assign) (deref) (let) (bind) (handle) (handle-all) (throw-context) (lift-context) (lift-app) (lift-assign) \n(lift-deref) (lift-raise) (context) (bracket)  new v = v update vv = v read v = v Auxiliary functions \nnew1 v = (v | void) update1 vv ' = (v ' |LvJ2) read1 v = LvJ1 new2 v = (void | v) update2 vv ' = (LvJ1 \n| v ' ) read2 v = LvJ2 Figure 1: Operational semantics of Core ML2 right projection is 0, because e only \nreduces to itself. Such a formulation of completeness will naturally lead us to estab\u00adlish a weak non-interference \nresult, whereby two programs can be guaranteed to yield the same result only if they both terminate. \nWe do not aim at a strong non-interference re\u00adsult, because it would make little sense to plug information \nleaks related to termination without attacking timing leaks in general. Furthermore, such a result would \nrequire a much more restrictive type system. In essence, the completeness lemma guarantees that we have \nprovided enough lift rules to allow reducing all mean\u00adingful Core ML2 expressions. In the next section, \neach of these rules will add one case to our subject reduction proof, forcing us to ensure that our type \nsystem accounts for all possible kinds of information .ow. 5. TYPING Core ML2 We now give a type system, \ncalled mlif0, for Core ML2 . It is a ground type system: it has no type variables and deals with polymorphism \nin a simple, abstract way. As a result, it does not describe an algorithm; we will address this issue \nin section 8. Throughout the paper, every occurrence of * stands for a distinct anonymous meta-variable \nof appropriate kind.  5.1 Types Let (L, =) be a lattice whose elements, denoted by . and pc, represent \nsecurity levels. (Following Denning [4], we typ\u00adically use the meta-variable pc, rather than f, when \nconsid\u00ad ering information obtained by observing the value of the program counter .) Types, rows and alternatives \nare de\u00ad .ned as follows: t ::= unit r a ||||::= ::= int. (t pc [r]---. t). t ref. r exn . {e . a}e.E \nAbs | Pre pc A row r is an in.nite, quasi-constant family of alternatives indexed by E. (A family is \nquasi-constant if all but a .nite number of its entries are equal.) We write (e : a; r) for the row whose \nelement at index e is a and whose other elements are given by the sub-row r, which is indexed by E\\{e}. \nWe write a . r to indicate that a is a member of r s codomain. Our types are those of ML s type system, \ndecorated with extra annotations of two kinds. First, we employ rows to keep track of exceptions, as \nin existing type-and-e.ect systems, such as Pessaux and Leroy s [12]. If an exception value has type \nr exn * , then the row r contains information about the exception s name. Speci.cally, for every e .E, \nif r(e) is Abs, then the excep\u00adtion s name cannot be e; if, on the other hand, it is Pre *, then the \nexception may be named e. Furthermore, func\u00adtion types carry an e.ect [ r ]. It is also a row, and gives \na conservative description of all exceptions possibly raised by executing the function. Second, we use \nsecurity levels to keep track of how much information can be obtained by looking up integer values, executing \nfunctions, dereferencing memory locations, and handling exceptions. The remainder of this section describes \ntheir meaning. Because there is only one value of type unit, the value of a unit expression yields no \ninformation whatsoever. As a result, it would be super.uous for the unit type constructor to carry a \nsecurity level. Immutable tuple and record types can be dealt with similarly; see section 7.1. Thus, \nwe break the convention set forth in a number of previous papers [7, 14] that all types be of the form \n*\u00a3. We expect this feature to help reduce verbosity in practice. The type int\u00a3 describes integer expressions \nwhose value may re.ect information of security level f. Function types carry two security annotations. \nThe exter\u00adnal annotation f represents information about the function s identity. When the function is \napplied, part of this informa\u00adtion may be re.ected in its result or in other aspects of the function \ns behavior (i.e. in its e.ect); as a result, their se\u00adcurity level will be made f or greater. The annotation \npc, found above the . symbol, tells how much information the function obtains merely by gaining control \n indeed, observ\u00ading that a particular function is called may allow telling which branches were previously \ntaken. pc can be thought of as an extra parameter to the function, and indeed it is contravariant (see \nsection 5.2). To avoid leaking this infor\u00admation, the function will be allowed to write into memory cells, \nor to raise exceptions, only at level pc or greater. This explains why the annotation pc is sometimes \ndescribed as a lower bound on the level of the function s e.ects [7]. Reference types carry one annotation \nf, which represents information about the reference s identity, i.e. about its ad\u00address. Information \nabout the reference s contents is found within the parameter t. Exceptions are described by rows, within \nwhich every non-Abs entry, of the form e . Pre pc, carries an annotation pc, telling how much information \nwill be obtained by observing (i.e. handling) the exception, if it is named e. We follow Myers [9, 10] \nand associate a distinct security level with every exception name, so as to obtain better precision. \nOur rows are closely related to Myers sets of path labels X, which map every exception name to either \na special constant \u00d8 or a security level; compare these with our alternatives Abs and Pre pc. (See section \n10 for further comparison with [9, 10].) In addition to a row, exception types also carry an ex\u00adternal \nannotation f. It is, in fact, redundant with the row r. That is, manipulating an exception as a .rst-class \nvalue causes its external level f to increase, leaving the row r un\u00adchanged; when the exception is later \nraised, every non-Abs entry in r is raised to level f or greater. It would be possi\u00adble to suppress the \nexternal annotation, at the cost of some extra implementation complexity. Another reasonable ap\u00adproach \nwould be to restrict the language so that exceptions are no longer .rst-class values; this would allow \nus to do away with exn entirely. The reader may notice that rows do not record the type of exception \narguments, i.e. the constructor Pre has no type parameter. Indeed, as in ML, we make exceptions monomor\u00adphic \nby assuming given a .xed mapping typexn from excep\u00adtion names to types. This decision is useful in two \nways. First, it should make function types (which include a row) [.] int. (e---. .). 8 ref. . exn . {e \n. .}e.E Pre . Abs = Pre * Figure 2: Subtyping much more compact. Second, it makes our subtyping re\u00adlation \natomic (see section 5.2), which we believe opens the way to simpler and (in practice) more e.cient constraint \nsolving techniques. 5.2 Subtyping We equip types, rows and alternatives with a subtyping relation =, \nwhich extends the partial order (L, =). Itis de.ned by the axioms in .gure 2. The axiom int. is a com\u00adpact \nversion of the assertion int\u00a31 = int\u00a32 .. f1 = f2. In other words, it states that int s parameter is \ncovariant. The other axioms are to be understood similarly; ., e and 8 represent covariant, contravariant \nand invariant param\u00adeters, respectively. The .fth axiom extends subtyping to rows, point-wise and covariantly. \nThe last axiom is the only one which relates two con\u00adstructors of di.erent arities, apparently making \nthe subtyp\u00ading relation non-atomic. However, it is only super.cially so. Indeed, it is possible to give \na presentation of the system where the set of alternatives is merely the disjoint union {Abs}.L, causing \nthe explicit injection Pre to disappear, because security levels become a subset of alternatives. In \nthis presentation, subtyping is atomic [16]: alternatives form a set of atoms. The use of subtyping in \ninformation .ow control is ubiq\u00aduitous [3, 4, 19, 7] and appears essential, because it al\u00adlows building \na directed view of the program s information .ow graph, yielding better precision than a uni.cation-based \nanalysis. 5.3 Additional notation A polytype s is a nonempty, upward-closed set of types. A polytype \nenvironment G is a partial mapping from program variables to polytypes. G[x . s] denotes the environment \nwhich maps x to s and agrees with G otherwise. A memory environment M is a partial mapping from memory \nlocations to types. We de.ne f <t (read: f guards t) as follows: f = f' \u00a31 * [*] \u00a31 f <unit f <intf <(* \n- -. *) \u00a31 \u00a31 f <* reff <* exn The assertion f < t requires t to have security level f or greater, and \nis used to record a potential information .ow. Note that, for any given f and t, there exists a supertype \n'' t of t such that f < t holds. Thus, the presence of f < t as a premise typically never prevents the \napplication of a typing rule: indeed, preceding that rule with a subtyping step will satisfy the premise. \nOne exception is e-Assign, where t cannot be promoted to a supertype because it ap\u00adpears as an invariant \nargument to the ref type constructor. The predicate < has transitive behavior: '' Lemma 5.1 If f ' = \nf and f <t and t = t then f ' <t . To every row r, we associate two security levels, de.ned by U r = \nU{pc | Pre pc . r} and . r = .{pc | Pre pc . r}. Note that Abs entries in r do not contribute to these \nlevels. 5.4 Typing judgements We distinguish two forms of typing judgements: one deals with values only, \nthe other with arbitrary expressions. Be\u00adcause values are normal forms, they have no side e.ects, so \nthe former look quite simple: G,M f v : t (We also write G,M f v : s when G,M f v : t holds for all t \n. s.) On the other hand, expressions do produce side e.ects, so the latter are more elaborate: pc, G,M \nf v : t [ r ] The pc parameter again tells how much information the ex\u00adpression may acquire by gaining \ncontrol; it is a lower bound on the level of the expression s e.ects. Previous works [19, 7] employ a \nsimilar parameter. The row r approximates the set of exceptions which the expression may raise. Two extra \njudgement forms are employed to type stores: M f \u00b5 and con.gurations: G f e/i \u00b5 : t [ r ]. In typing \njudgements, we omit G and M when they are empty; we sometimes omit pc and r when they are unspeci\u00ad.ed \n(i.e. when they could be written *). Even though the security lattice (L, =) is arbitrary, it is desirable \nto establish a simple dichotomy between low and high security levels. Such a distinction simpli.es our \nproofs; full generality will be recovered in section 6. In the present section, we assume H is a .xed, \nupward-closed sub\u00adset of L. We will view levels inside (resp. outside) H as high (resp. low ). Non-interference \ndemands that two expressions which dif\u00adfer only in high-level sub-terms have identical low-level be\u00adhavior. \nTo achieve this, our type system requires expressions of the form (e1 | e2) which we use to encode the \ndi.erences between two Core ML expressions to have high-security re\u00adsult and side e.ects. (See v-Bracket \nand e-Bracket in .gure 3.) This will be our only use of H in this section. 5.5 Typing rules We now comment \non the typing rules, given in .gure 3. v-Unit and v-Int assign base types to constants. v-Void allows \ntyping values of the form (v | void) or (void | v)by pretending void has the same type as v. v-Loc and \nv-Var assign types to memory locations and to variables by looking up the appropriate environment. Note \nthat G(x) is a polytype, of which v-Var selects an arbitrary instance. As usual in type-and-e.ect systems, \nv-Abs records, on top of the . type constructor, information about a function s side e.ects. v-Exn associates \nto the exception value ev a row which maps the name e to Pre * and leaves other entries unconstrained, \nallowing them to be Abs. v-Bracket requires the components of a (\u00b7 | \u00b7) construct to have a common type, \nwhich must have high security level, i.e. be guarded by some (arbitrary) element of H. v-Sub is standard. \ne-Value allows viewing a value as an expression, and re\u00ad.ects the fact that values have no side e.ect. \ne-App governs function application. Because the e.ect of a function application is exactly the function \ns latent e.ect, the security level pc, which should represent a lower bound on the level of the former, \nmust also be a lower bound on the latter s. Because a function s side e.ects may reveal infor\u00admation \nabout its identity, their level must equal or exceed the function s own security level, namely f. As \na result of these remarks, the function s body must run at level pc U f. Because the function s result, \ntoo, may reveal information about its identity, we require its type to be guarded by f. e-Ref and e-Assign \nrequire pc < t to ensure that pc is indeed a lower bound on the security level of the memory cell that \nis written. e-Assign and e-Deref require f <t to re.ect the fact that writing or reading a cell may indirectly \nreveal information about its identity. e-Raise requires pc =. r, ensuring that pc is a lower bound on \nthe level of every non-Abs entry in the row r. Thus, any code fragment able to observe this expression \ns side ef\u00adfect must run at level pc or greater (see e-Bind, e-Handle and e-HandleAll). The security level \nf, which re.ects ad\u00additional, exception-name-independent information, is dealt with similarly. Because \nlet only binds values, e-Let is nearly as simple as in ML. Note that v can be given a polytype s, allowing \nx to be used at di.erent types within e. In a binding construct bind x = e1 in e2, the expression e2 \nobserves, if it receives control, that no exception was raised by e1. To account for this information \nchannel, e-Bind type\u00adchecks e2 at a security level augmented with U r1, the com\u00adbined level of all exceptions \nwhich e1 can potentially raise. This is a conservative approximation, which works well in the common \ncase where e1 is statically known never to raise exceptions; see section 10 for details. r1 U r2 denotes \nthe least common supertype of r1 and r2. Like e-Bind, e-Handle typechecks e2 at an increased se\u00adcurity \nlevel, re.ecting the fact that, by gaining control, e2 observes that e1 raised an exception named e. \nThe incre\u00adment is exactly pc ' , the security level associated with e in e1 s e.ect, so the analysis \nis, in this case, quite accurate. Because the result of the handle construct may also allow determining \nwhether the handler was executed, we require pc ' < t. e-HandleAll is analogous; however, because the \nconstruct allows observing any exception, regardless of its name, we again use U r1 as a conservative \napproximation of how much information is gained. Myers [9, 10] performs the same approximation. As explained \nearlier, e-Bracket requires both compo\u00adnents of a (\u00b7 | \u00b7) expression to have a common type, and demands \nthat its side e.ects and its result be of high security level, i.e. guarded by an arbitrary pc ' . H. \nThe auxiliary predicate e. holds if and only if e is of the form E1[ ...En[raise (ev)] ... ] where n \n= 0 and none of the Ei handles raise (ev). The use of this predicate in e-Bracket s last premise is technical; \nit is required for subject reduction to hold.  5.6 Subject reduction Let us .rst state a few auxiliary \nlemmas, whose proofs are straightforward. Lemma 5.2 (Subsumption) pc ' = pc and pc, G,M f e : t [ r ] \nimply pc ' , G,M f e : t [ r ]. Lemma 5.3 (Projection) Let i .{1, 2}. If G,M f v : t then G,M fLvJi : \nt. Lemma 5.4 (Guard) If G,M f(v1 | v2) : t then there exists pc ' . H such that pc ' <t. Values v-Var \n v-Unit v-Int v-Void v-Loc t . G(x) G,M f () : unit G,M f k : int * G,M f void : * G,M f m : M(m) ref \n* G,M f x : t v-Bracket v-Abs v-Exn G,M f v1 : t G,M f v2 : t pc [r] '' \u00a3'' pc, G[x . t ][f . (t ---. \nt)],M f e : t [ r ]G,M f v : typexn(e) pc . H pc <t ' \u00a3 G,M f ev :(e : Pre *; *) exn * G,M f(v1 | v2) \n: t pc [r] G,M f .x f..x.e :(t ---. t) v-Sub G,M f v : t ' t ' = t G,M f v : t Expressions e-Value \ne-App e-Ref pcu\u00a3 [r] ' \u00a3 ' G,M f v : t G,M f v1 :(t -----. t)G,M f v2 : tf <t G,M f v : t pc <t *, G,M \nf v : t [ *] pc, G,M f v1 v2 : t [ r ] pc, G,M f ref v : t ref * [ *] e-Assign G,M f v1 : t ref\u00a3 G,M \nf v2 : t e-Deref e-Raise '' \u00a3 pc U f <t G,M f v : t ref\u00a3 t = tf <t G,M f v : r exn pc U f =. r pc, G,M \nf v1 := v2 : unit [ *] pc, G,M f ! v : t [ *] pc, G,M f raise v : * [ r ] e-Bind e-Let pc, G,M f e1 : \nt ' [ r1 ] G,M f v : s pc, G[x . s],M f e : t [ r ] pc U (U r1), G[x . t ' ],M f e2 : t [ r2 ] pc, G,M \nf let x = v in e : t [ r ] pc, G,M f bind x = e1 in e2 : t [ r1 U r2 ] e-Handle e-HandleAll pc, G,M f \ne1 : t [ e : Pre pc ' ; r ] pc, G,M f e1 : t [ r1 ] ' '* pc U pc , G[x . typexn(e)],M f e2 : t [ e : \na; r ] pc <t pc U (U r1), G[x . r1 exn ],M f e2 : t [ r2 ](U r1) <t pc, G,M f e1 handle ex > e2 : t [ \ne : a; r ] pc, G,M f e1 handle x > e2 : t [ r2 ] e-Bracket pc U pc ' , G,M f e1 : t [ r ] pc U pc ' , \nG,M f e2 : t [ r ] e-Sub ' ' '''' pc . H (pc <t) . (e1.) . (e2.) pc, G,M f e : t [ r ] t = tr = r pc, \nG,M f(e1 | e2) : t [ r ] pc, G,M f e : t [ r ] Con.gurations Store dom(M) = dom(\u00b5) Conf .m . dom(\u00b5) \nM f \u00b5(m): M(m) pc, G,M f e : t [ r ] M f \u00b5 M f \u00b5 G f e/\u00b5 : t [ r ] Figure 3: The type system mlif0 Lemma \n5.5 (Substitution) M f v : s and pc, G[x . s],M f e : t [ r ] imply pc, G,M f e[x . v]: t [ r ]. We can \nnow state our main lemma: Lemma 5.6 (Subject reduction) Let e/i \u00b5 . e ' /i \u00b5 ' . Assume pc, M f e : t \n[ r ] and M f \u00b5. If i .{1, 2}, assume pc . H. Then, there exists a memory environment M ' , '' '' which \nextends M, such that pc, M f e : t [ r ] and M f \u00b5 . Proof. By induction on the derivation of e/i \u00b5 . \ne ' /i \u00b5 ' . We assume, w.l.o.g., that the derivation of pc, M f e : t [ r ] does not end with an instance \nof e-Sub. As a result, it must end with an instance of the single syntax-directed rule that matches e \ns structure. By lack of space, we only give a few representative cases; all others can be found in [15]. \npcu\u00a3 [r] . Case (\u00df). e is (.x f..x.e0) v. Let . =(t ' -----. t)\u00a3 . By e-App, we have M f .x f..x.e0 : \n. and M f v : t ' . The former s derivation must end with an instance of v-Abs, fol\u00adlowed by a number \nof instances of v-Sub. Because . is con\u00adtravariant (resp. covariant) in its .rst and second (resp. third \nand fourth) parameters, applying lemma 5.2 and e-Sub to v-Abs s premise yields pc, (x . t '' ; f . . \n' ),M f e0 : t [ r ], '' ''' for some t and . ' such that t = t and . = . ' . By v-Sub, M f v : t '' \nand M f .x f..x.e0 : . ' hold. Then, lemma 5.5 yields pc, M f e0[x . v][f . .x f..x.e0]: t [ r ]. . Case \n(deref). e is ! m. By e-Deref, we have M f m : t ' ref * , where t ' = t. By v-Loc, v-Sub and by invariance \nof the ref type constructor, this entails M f \u00b5(m): t ' . By ' . Case (lift-app). e is (v1 | v2) v. Let \n. =(t -----. t)\u00a3 lemma 5.3, M f readi \u00b5(m) : t follows. Conclude with v-Sub and e-Value. ' pcu\u00a3 [r] \n. e-App s premises are M f(v1 | v2) : . and M f v : t ' and f < t. Lemma 5.3 yields M f vi : . and M \nfLvJi : t ' , for i .{1, 2}. Then, e-App yields pc U f, M f vi LvJi : t [ r ]. Furthermore, applying \nlemma 5.4 to the .rst premise above and recalling that H is upward-closed yields f . H. Because f <t, \ne-Bracket is applicable and yields pc, M f e ' : t [ r ]. . Case (lift-deref). e is ! (v1 | v2). e-Deref \ns premises are M f(v1 | v2) : t ' ref\u00a3 and t ' = t and f < t. As above, applying lemma 5.3 and building \nnew instances of e-Deref, we obtain pc U f, M f ! vi : t [ r ], for i .{1, 2}. Similarly, lemma 5.4 yields \nf . H. Lastly, by e-Bracket, we obtain pc, M f( ! v1 | ! v2) : t [ r ]. 0 The previous lemma entails \nthe following, more abstract statement: Theorem 5.1 (Subject reduction) If f e/\u00b5 : t [ r ] and e/\u00b5 . \ne ' /\u00b5 ' then f e ' /\u00b5 ' : t [ r ]. We do not establish progress (i.e. no well-typed con.g\u00aduration is \nstuck ), even though it does hold, because it is unrelated to our concerns.  6. NON-INTERFERENCE From \nhere on, the set H is no longer .xed. We introduce it explicitly when needed, writing fH instead of f \nin Core ML2 typing judgements. (This is not necessary for those judgements which involve plain Core ML \nexpressions, be\u00adcause H is used only in v-Bracket and e-Bracket.) We write e .* o if there exists a store \n\u00b5 such that e/0.* o/\u00b5, where 0is the empty store. Our type system keeps track of (\u00b7 | \u00b7) constructs by \nassign\u00ading them high security levels (i.e. levels in H). By subject reduction, any expression which may \nevaluate to such a con\u00adstruct must also carry a high annotation. Conversely, no expression with a low \nannotation can evaluate to such a construct, as stated, in the particular case of integers, by the following \nlemma: Lemma 6.1 Let H be an upward-closed subset of L. Let f . H. If fH e : int\u00a3 and e . * v then LvJ1 \n= LvJ2. Proof. By theorem 5.1 and Conf, there exists a memory environment M such that M fH v : int\u00a3 [ \n*] holds. A value of type int * must be of the form k or (k1 | k2). If the latter, then, by v-Bracket \nor e-Bracket, there exists pc ' . H such that pc ' = f, which implies f . H, a contradiction. Thus, we \nmust have v = k = LvJ1 = LvJ2. 0 We can now use the correspondence between Core ML and Core ML2 developed \nin section 4.3 to reformulate this result in a Core ML setting: Theorem 6.1 (Non-interference) Choose \nf, h .L such that h = f. Let h <t. Assume (x . t) f e : int\u00a3, where e is a Core ML expression. If f vi \n: t and e[x . vi] .* vi' , for i .{1, 2}, then v ' = v ' 12. Proof. Let H = .{h}. De.ne v = (v1 | v2). \nBy v-Bracket, fH v : t holds. Lemma 5.5 yields fH e[x . v]: int\u00a3 . Now, Le[x . v]Ji is e[x . vi], which, \nby hypothesis, reduces to vi' . According to lemma 4.2, there exists an outcome o such that e[x . v] \n. * o and, for i .{1, 2}, LoJi = vi' . Because of the latter, o must be a value. Lastly, h = f yields \nf . H. The result follows by lemma 6.1. 0 In words, h and f are security levels such that information \n.ow from h to f is disallowed by the security lattice. As\u00adsuming the hole x has a high -level type t, \nthe expression e can be given the low -level type int\u00a3 . Then, no matter which value (of type t) is placed \nin the hole, e will compute the same value (that is, if it does produce a value at all). 7. EXTENSIONS \nIn this section, we describe a number of language exten\u00adsions. Some are standard programming facilities \nwhich we have left out so far, namely products, sums, and primitive operations. Others are new language \nconstructs which cap\u00adture common idioms, so as to make them more amenable to analysis. We omit all proofs \nin this section; they can be found in [15]. 7.1 Products and sums Extending our system with products \nand sums is straight\u00adforward. The grammar of types is extended as follows: t ::= ... | t \u00d7 t | (t + t)\u00a3 \nProducts carry no security annotation because, in the ab\u00adsence of a physical equality operator, all of \nthe information carried by a tuple is in fact carried by its components. To re.ect this, we de.ne f < \nt1 \u00d7 t2 as f < t1 . f < t2. More details appear in [15]. Our treatment of products is slightly innovative, \nand has implications on constraint solving. Indeed, if every type carried a security annotation, as in \nprevious works [7, 1, 14], then f < would be syntactic sugar for f = m. Because *m it is not the case \nhere, constraints involving < must receive special treatment by the constraint solver (see section 8.4). \nf ' = ft1 .ft2 .f unit .f int\u00a31 .ft1 \u00d7 t2 .f f ' = ft1 .ft2 .ft .ff ' = f (t1 + t2)\u00a31 .ft ref\u00a31 .f Figure \n4: Collecting security annotations 7.2 Primitive operations Practical programming languages usually \nprovide many primitive operations, such as integer arithmetic operators. Some languages, such as Caml-Light \n[8], provide generic (i.e. polymorphic) comparison, hashing or marshalling functions. In the full version \nof this paper [15], we present a way of as\u00adsigning types to such primitive operations, without knowl\u00adedge \nof their semantics, i.e. by considering them as black boxes which potentially use all of the information \ncontent of their arguments. Here, we only describe it brie.y. We introduce a two-place predicate ., whose \narguments are a type and a security level (.gure 4). In short, t .f re\u00adquires all of the security annotations \nwhich appear in t and its sub-terms to be less than (or equal to) f. It also requires t to have no function \nor exception types in its sub-terms. (Functions are not valid arguments to the polymorphic com\u00adparison \noperators; exceptions must be ruled out because exn is, in practice, an extensible type, i.e. the mapping \ntypexn is never fully known.) Then, uses of the comparison operators can be typed as follows: G,M f v1 \n: t G,M f v2 : tt .f . .{=, =, =,...}*, G,M f v1 .v2 : bool\u00a3 [ *] (The type bool\u00a3 can be de.ned as (unit \n+ unit)\u00a3 or added as a primitive type.) Because these operators traverse data structures recursively, \nthe result of a comparison may re\u00adveal information about any sub-term. The premise t . f re.ects this \nby requiring f to dominate all security annota\u00adtions which appear in t. Generic hashing and marshalling \noperations can be dealt with similarly: G,M f v : tt .f G,M f v : tt .f *, G,M f hash v : int\u00a3 [ *] *, \nG,M f marshal v : int\u00a3 [ *] By contrast, in Myers Java-based framework [9, 10], hashing is done by having \nevery class override the standard hashCode method, which is declared in class Object with signature int{this} \nhashCode (). A re-implementation of hashCode by a sub-class of Object must also satisfy this signature. \nAs a result, it may only rely on .elds labelled this. The paramet\u00adric class Vector[L], for instance, \nmust compute hash codes in a way that does not depend upon the vector s length or contents, because their \nlabel is L. Of course, this severely limits hashCode s usefulness. 7.3 Common idioms Because our type \nsystem is quite conservative, some com\u00admon programming idioms deserve special treatment, even though \nthey are already expressible in the language. For instance, consider the expression form e1 .nally e2, \nakin to Lisp s unwind-protect and Java s try-.nally constructs. Such an expression could be viewed as \nsyntactic sugar for bind x =(e1 handle y > e2; raise y) in e2; x. However, by duplicating e2, this encoding \nprevents the type-checker from discovering that e2 is executed always, i.e. regardless of e1 s behavior. \nAs a result, e2 is typechecked under an in\u00adcreased security assumption pc. Zdancewic and Myers [23] show \nhow ordered linear continuations provide a general so\u00adlution to this problem. In our case, it is simpler \nto make e1 .nally e2 a primitive construct: e-Finally pc, G,M f e1 : t [ r1 ] pc, G,M f e2 : * [ r2 ] \nU r2 =. r1 pc, G,M f e1 .nally e2 : t [ r1 U r2 ] Following Myers [9, 10], we typecheck e1 and e2 at \na com\u00admon pc. However, we add the premise U r2 =. r1, which re.ects that, by observing an exception thrown \nby e1, one may deduce that e2 terminated normally. Its absence in Myers work is a .aw. Myers typing rule \nin fact exhibits a second .aw: its overall e.ect should be X1 .X2, rather than X1[n := \u00d8] . X2, because \nnormal termination of the whole statement implies normal termination of e1. This fact is taken into account \nin our typing rule, even though we do not explicitly associate a security level to normal termina\u00adtion; \nsee section 10. Both .aws in Myers framework were uncovered by our formal approach [Andrew C. Myers, \nper\u00adsonal communication, June 2001].  8. A CONSTRAINT-BASED TYPE SYSTEM We now give a more algorithmic \npresentation of our type system, called mlif. It di.ers from mlif0 mainly by intro\u00adducing type variables, \nconstraints, and using them to form universally quanti.ed, constrained type schemes, in the style of \nHM(X) [11]. Like HM(X), it has principal types and de\u00adcidable type inference. Because the construction \nis not the central topic of this paper, we will describe it only succinctly; the reader is referred to \n[11, 13] for more details. 8.1 Types and constraints In mlif, the grammar of types, rows, alternatives \nand levels is extended with type variables. (We let a range over type variables of all four kinds; no \nambiguity will arise.) Furthermore, R\u00b4emy s [17] row syntax is introduced, turning rows into .nite lists \nof bindings from exception names to alternatives, terminated with a row variable. p [.] t ::= a | unit \n| int. | (t ---. t). | t ref. | . exn . . ::= a | (e : .; .) . ::= a | Abs | Pre p ., p ::= a | f The \nvariable-free types (resp. rows, alternatives, levels) of mlif are isomorphic to the types (resp. rows, \nalternatives, levels) of mlif0; we identify them and refer to them as ground. Then, constraints are de.ned \nas follows: C ::= true | C . C |.a.C | t = t | . = . | . = . | . = . | . <t |U . = . | . =. . | t .. \nThe constraint forms on the .rst line are standard [11]. Those on the second line are subtyping constraints; \nthose on the third line are custom constraint forms, which corre\u00adspond to the notions developed in sections \n5 and 7.2. We Values v-Absv-Var p [.] v-Unit v-Int '' . G(x)= .a\u00af[D].t a.D C,p, G[x . t ][f . (t --] \nf e : t C ..\u00af-. t)[ .] C, G f () : unit C, G f k : int * p [.] C . D, G f x : t ' . C, G f .x f..x.e \n:(t ---. t) v-Exn v-Sub C, G f v : typexn(e) C, G f v : t ' C .t ' = t C, G f ev :(e : Pre *; *) exn \n* C, G f v : t Expressions e-Value C, G f v : t e-App C, G f v1 : (t ' pu. [.]- ---. t ). C, G f v2 \n: t ' C .. <t e-Ref C, G f v : t C .p <t C, *, G f v : t [ *] C, p, G f v1 v2 : t [ . ] C, p, G f ref \nv : t ref * [ *] e-Assign C, G f v1 : t ref. C, G f v2 : t e-Deref C .p U . <t C, G f v : t ' ref. C \n.t ' = tC .. <t C, p, G f v1 := v2 : unit [ *] C, p, G f ! v : t [ *] e-Raise e-Let . '' C, G f v : \n. exn C .p U . =. .C . D, G f v : t C, p, G[x ..a\u00af[D].t ] f e : t [ .] a\u00afn fv(C, G) = 0 C, p, G f raise \nv : * [ . ] a.D, p, G f let x = v in e : t C ..\u00af[ . ] e-Bind e-Handle C, p, G f e1 : t ' [ .1 ] C, p, \nG f e1 : t [ e : Pre p ' ; .] '' ' C, p U (U .1), G[x . t ] f e2 : t [ .2 ] C, p U p, G[x . typexn(e)] \nf e2 : t [ e : .; .] C .p <t C, p, G f bind x = e1 in e2 : t [ .1 U .2 ] C, p, G f e1 handle ex > e2 \n: t [ e : .; . ] e-HandleAll C, p, G f e1 : t [ .1 ] e-Sub * ''' ' C, p U (U .1), G[x . .1 exn ] f e2 \n: t [ .2 ] C .(U .1) <t C, p, G f e : t [ . ] C .t = tC .. = . C, p, G f e1 handle x > e2 : t [ .2 ] \nC, p, G f e : t [ . ] Figure 5: The type system mlif omit the sorting rules necessary to ensure that \nterms and judgement begins with a constraint C which represents an constraints involving rows are well-formed; \nsee [17]. assumption about its free type variables; for the judgement Let a ground assignment f map every \ntype variable a to a to be valid, C must be satis.able. (We omit C when it is ground type, row, alternative, \nor level, according to its kind. true.) Constrained type schemes are introduced by e-Let, The meaning \nof terms and constraints under an assignment which performs generalization, and eliminated by v-Var, \n' f is de.ned in the obvious way. We write C .C (read: C which performs instantiation. For the sake \nof conciseness, entails C ' ) if and only if every assignment f which satis.es some rules use the binary \noperator U on levels and on rows, C satis.es C ' as well. as well as the unary operator U on rows, as \nif they were Let a type scheme be a triple of a set of quanti.ers a\u00af, a part of our term syntax; we let \nthe reader check that these constraint C and a type t ; we write s = .a\u00af[C].t. The type notations can \nbe de-sugared into extra meta-variables and variables in a\u00afare bound in s; type schemes are considered \nconstraints. equal modulo a-conversion. By abuse of notation, a type t 8.3 Non-interference may be \nviewed as a type scheme .0[true].t . An environ\u00adment G is a partial mapping from program variables to \ntype We prove the following statement by induction on type schemes. derivations, along the lines of [13]. \nLemma 8.1 (Soundness) Assume C, p, G f e : t [ . ].  8.2 Typing rules Let f be an arbitrary ground assignment \nwhich satis.es C. The typing rules for mlif are given in .gure 5. They look Then, f(p),f(G), 0f e : f(t)[ \nf(.)] holds in mlif0. very similar to those of mlif0; let us brie.y discuss the dif\u00adferences. We restrict \nour attention to source expressions, (We do not de.ne f(G) here; see [13].) In particular, every i.e. \nCore ML expressions which do not contain memory lo-ground typing judgement in mlif is also a valid judgement \ncations; this is enough for our purposes. Thus, typing judge-in mlif0. This allows us to lift our non-interference \nresult to ments no longer contain a memory environment M. Every mlif. That is, the statement of theorem \n6.1 remains valid if (x . t) f e : int\u00a3 and f vi : t are read as mlif typing judgements. 8.4 Type inference \nIt is easy to check that there exists a type inference algo\u00adrithm which computes principal types for \nmlif. Sulzmann et al. [18] show how to derive a set of type inference rules from a set of typing rules \nsimilar to ours. The main point that remains to be settled is whether constraint solving is decidable. \nAs explained in section 5.2, our subtyping relation is atom\u00adic; constraint solving for atomic subtyping \nis decidable and well understood [16]. The introduction of rows is essentially orthogonal to other constraint \nsolving issues. Lastly, our custom constraint forms can be solved in a lazy manner. That is, a constraint \nof the form . < a, a . ., U a = . or . =. a remains suspended as long as nothing is known about a, and \nis decomposed into a number of sub-constraints only when a is uni.ed with a non-variable term t or row \n.. Further details, including proofs and algorithms, will be given in a later paper. 9. EXAMPLES We intend \nto integrate mlif into a realistic programming language, such as Caml-Light [8]. In this section, we \ngive a taste of that by describing the principal type schemes in\u00adferred for some library functions by \nour prototype imple\u00admentation. We use Caml-Light syntax, which can be easily de-sugared into Core ML. \nWe omit type annotations on top of . when they are unconstrained, anonymous type variables. Because none \nof the type schemes below has free type variables, we omit the universally quanti.ed variables after \n.. We have not explained how to include datatype declara\u00adtions in the language. Since we already have \nproduct and sum types, this should be straightforward. Let us assume the type constructor list is declared \nas follows: type ( a, b) list = < b> | [] | (::) of a * ( a, b) list In a list\u00df, the parameter a is \nthe type of the list s elements, as usual, while \u00df is a security level. The annotation < b> on the right-hand \nside is meant to indicate that \u00df is the secu\u00adrity annotation carried by the sum type. Our .rst example \nfunction computes the length of a list: let rec length = function |[] ->0 | _:: l-> 1+ lengthl A valid \ntype scheme for length is .[a = \u00df]. * lista -. int\u00df . As expected, the result s security annotation \u00df \ndoes not depend on the type of the list s elements. The constraint a = \u00df describes the information .ow \ninduced by the func\u00adtion: the length of a list contains some information about its structure. This type \nscheme is in fact equivalent to .[]. * lista -. inta , a simpli.cation which our implemen\u00adtation performs \nautomatically. let rec iter f = function | [] -> () | x:: l-> fx;iterfl iter applies f successively \nto every element of a list. Its inferred type scheme is \u00df [.] \u00df [.] .[U . = \u00df].(a ---. *)\u00df -. a list\u00df \n---. unit Here, . represents f s e.ect. Because iter does not throw any exceptions of its own, . is also \niter s e.ect. \u00df is f s pc parameter. It must dominate iter s own pc parameter (be\u00adcause f is invoked \nby iter), the list s security level (because gaining control tells f that the list is nonempty) and U \n. (because gaining control tells f that its previous invocation terminated normally). let incr r = r:=!r \n+1 a [*] incr has .[].inta refa ---. unit as principal type scheme. Indeed, by e-Assign, the security \nlevel of the reference s contents must dominate both incr s pc parameter and the reference s own security \nlevel. We now re-implement length in imperative style: let length l = let count = ref 0 in iter (fun \n() -> incr count) l; !count a [*] We obtain .[]. * lista ---. inta . This appears more restric\u00adtive \nthan length s type scheme: the result s security level must now be greater than or equal to the function \ns pc pa\u00adrameter. However, the di.erence is only super.cial; it can be checked that both types in fact \nhave the same expressive power. Formalizing this claim, and understanding its con\u00adsequences, are left \nfor future work. We continue with a few library functions which deal with association lists. let rec \nmem_assoc x = function | [] -> false | (y, _) :: l -> if x = y then true else mem_assoc x l Because mem \nassoc s result reveals information about both the structure of the list and the keys stored in it, we \nobtain: .[a .\u00df].a -. (a \u00d7*) list\u00df -. bool\u00df The constraint a . \u00df, which arises due to the use of poly\u00admorphic \nequality, speci.es that \u00df must be an upper bound for all security annotations which occur in the type \nof the keys. let rec assoc x = function | [] -> raise Not_found |(y,d)::l-> ifx =ythendelseassocx l assoc \nreturns the piece of data associated with a given key. If no such key exists, Not found is raised, as \nre.ected in assoc s e.ect: d [Not found: d; *] .[a .\u00df, \u00df <., \u00df = d].a -. (a \u00d7 .) list\u00df ----------. . \nHere, as in mem assoc, \u00df represents the information associ\u00adated with the list s structure and keys. Because \nthis infor\u00admation is re.ected both in assoc s normal and exceptional results, the type system requires \n\u00df <. and \u00df = d. Lastly, we re-implement mem assoc in terms of assoc, us\u00ading an exception handler: let \nmem_assoc x l = try let _=assoc xlin true with Not_found -> false As in the case of length vs. length \n, the new type scheme requires the result s security level to be greater than or equal to the function \ns pc parameter: \u00df [*] .[a .\u00df].a -. (a \u00d7*) list\u00df ---. bool\u00df This betrays the fact that the function s \nimplementation uses e.ects, but does not otherwise restrict its applicability. 10. DISCUSSION The reader \nmay notice that normal and exceptional results are not dealt with in a symmetric way by our type system. \nIndeed, in a typing judgement pc, G,M f e : t [ r ], the row r associates a security level with every \nexception name, so as to record how much information is gained by observing that particular exception. \nHowever, no information level is explicitly associated with normal termination. Instead, the typing rule \nfor sequential composition, namely e-Bind, uses U r as an approximation of it. Myers [9, 10] sets of \npath labels X, on the other hand, record the security level associated with normal termination under \na special label n, which is then used in the sequential composition rule. It is, however, typically an \nupper bound for the value reached by pc inside every sub-expression of the expression at hand, so this \ndesign alone would make the type system very restrictive. To prevent that, Myers adds a non-syntax-directed \nrule, the single-path rule, stating that X[n] can be reset to \u00d8 if the expression at hand can be shown \nto always terminate normally. Our system doesn t need the single-path rule: indeed, when all entries \nin r1 are Abs, then U r1 is the least ele\u00adment of L, and e-Bind typechecks e1 and e2 at a common pc, \nas desired. Myers system is more precise than ours in a few cases, which involve expressions that never \ntermi\u00adnate normally; experience will tell how common they are. The single-path rule requires counting \nthe number of non-Abs entries in a row; in the presence of row variables, this requires new (and quite \nheavy) constraint forms, which is why we avoid it. This di.culty does not arise in Myers framework because \nit relies on Java s explicit, monomorphic throws clauses. There exists a simple monadic encoding of exceptions \ninto sums. Thus, it is possible, in principle, to derive a type system for exceptions out of a type system \nthat can han\u00addle sums. This approach sounds interesting, because it is systematic and promises to yield \na symmetric treatment of normal vs. exceptional results. However, some experiments show that, in order \nto obtain acceptable precision in the end, the treatment of sums that is chosen as a starting point must \nbe very accurate (much more so than the one given in this paper). We leave it as a topic of future research. \nOur main direction for future work is to create a full im\u00adplementation of the system on top of Caml-Light \nand to assess its usability through a number of case studies. We also plan to study a variant of Core \nML where exceptions are second-class citizens, i.e. where raise x is disallowed. In exchange for this \nslight loss of expressive power, we hope to be able to use a simpler type and constraint language. 11. \nREFERENCES [1] Mart\u00b4in Abadi, Anindya Banerjee, Nevin Heintze, and Jon G. Riecke. A core calculus of \ndependency. In Conference Record of the 26th ACM Symposium on Principles of Programming Languages, pages \n147 160, San Antonio, Texas, January 1999. [2] Mart\u00b4in Abadi, Butler Lampson, and Jean-Jacques L\u00b4evy. \nAnalysis and caching of dependencies. In Proceedings of the ACM SIGPLAN International Conference on Functional \nProgramming, pages 83 91, Philadelphia, May 1996. [3] D. E. Bell and Leonard J. LaPadula. Secure computer \nsystems: Uni.ed exposition and Multics interpretation. Technical Report MTR-2997, The MITRE Corp., July \n1975. [4] Dorothy E. Denning. Cryptography and Data Security. Addison-Wesley, Reading, Massachusetts, \n1982. [5] Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. The essence of compiling \nwith continuations. In Conference on Programming Language Design and Implementation, pages 237 247, \nJune 1993. [6] Joseph Goguen and Jos\u00b4e Meseguer. Security policies and security models. In Proceedings \nof the 1982 IEEE Symposium on Security and Privacy, pages 11 20, April 1982. [7] Nevin Heintze and Jon \nG. Riecke. The SLam calculus: Programming with secrecy and integrity. In Conference Record of the 25th \nACM Symposium on Principles of Programming Languages, pages 365 377, January 1998. [8] Xavier Leroy, \nDamien Doligez, et al. The Caml Light system, release 0.74. http://caml.inria.fr/, 1997. [9] Andrew \nC. Myers. JFlow: practical mostly-static information .ow control. In Proceedings of the 26th ACM SIGPLAN-SIGACT \non Principles of Programming Languages, pages 228 241, San Antonio, Texas, January 1999. [10] Andrew \nC. Myers. Mostly-Static Decentralized Information Flow Control. PhD thesis, Massachusetts Institute of \nTechnology, January 1999. [11] Martin Odersky, Martin Sulzmann, and Martin Wehr. Type inference with \nconstrained types. Theory and Practice of Object Systems, 5(1):35 55, 1999. [12] Fran\u00b8cois Pessaux and \nXavier Leroy. Type-based analysis of uncaught exceptions. ACM Transactions on Programming Languages and \nSystems, 22(2):340 377, 2000. [13] Fran\u00b8cois Pottier. A semi-syntactic soundness proof for HM(X). Research \nReport 4150, INRIA, March 2001. [14] Fran\u00b8cois Pottier and Sylvain Conchon. Information .ow inference \nfor free. In Proceedings of the the Fifth ACM SIGPLAN International Conference on Functional Programming \n(ICFP 00), pages 46 57, September 2000. [15] Fran\u00b8cois Pottier and Vincent Simonet. Information .ow inference \nfor ML. Full version. http://pauillac.inria.fr/ ~fpottier/publis/fpottier-simonet-popl02-long.ps.gz. \n[16] Jakob Rehof. Minimal typings in atomic subtyping. In ACM Symposium on Principles of Programming \nLanguages, pages 278 291, January 1997. [17] Didier R\u00b4emy. Type inference for records in a natural extension \nof ML. In Carl A. Gunter and John C. Mitchell, editors, Theoretical Aspects Of Object-Oriented Programming. \nTypes, Semantics and Language Design. MIT Press, 1993. [18] Martin Sulzmann, Martin M\u00a8uller, and Christoph \nZenger. Hindley/Milner style type systems in constraint form. Research Report ACRC 99 009, University \nof South Australia, School of Computer and Information Science, July 1999. [19] Dennis Volpano and Geo.rey \nSmith. A type-based approach to program security. Lecture Notes in Computer Science, 1214:607 621, April \n1997. [20] Dennis Volpano, Geo.rey Smith, and Cynthia Irvine. A sound type system for secure .ow analysis. \nJournal of Computer Security, 4(3):167 187, 1996. [21] Andrew K. Wright. Simple imperative polymorphism. \nLisp and Symbolic Computation, 8(4):343 356, December 1995. [22] Andrew K. Wright and Matthias Felleisen. \nA syntactic approach to type soundness. Information and Computation, 115(1):38 94, November 1994. [23] \nSteve Zdancewic and Andrew C. Myers. Secure information .ow and CPS. In Proceedings of the 2001 European \nSymposium on Programming (ESOP 01), Lecture Notes in Computer Science. Springer Verlag, April 2001. \n  \n\t\t\t", "proc_id": "503272", "abstract": "This paper presents a type-based information flow analysis for a call-by-value &#955;-calculus equipped with references, exceptions and let-polymorphism, which we refer to as Core ML. The type system is constraint-based and has decidable type inference. Its non-interference proof is reasonably lightweight, thanks to the use of a number of orthogonal techniques. First, a syntactic segregation between <i>values</i> and <i>expressions</i> allows a lighter formulation of the type system. Second, non-interference is reduced to <i>subject reduction</i> for a non-standard language extension. Lastly, a <i>semi-syntactic</i> approach to type soundness allows dealing with constraint-based polymorphism separately.", "authors": [{"name": "Fran&#231;ois Pottier", "author_profile_id": "81100490085", "affiliation": "INRIA, BP 105, 78153 Le Chesnay Cedex, France", "person_id": "PP39045333", "email_address": "", "orcid_id": ""}, {"name": "Vincent Simonet", "author_profile_id": "81100608449", "affiliation": "INRIA, BP 105, 78153 Le Chesnay Cedex, France", "person_id": "P343137", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/503272.503302", "year": "2002", "article_id": "503302", "conference": "POPL", "title": "Information flow inference for ML", "url": "http://dl.acm.org/citation.cfm?id=503302"}