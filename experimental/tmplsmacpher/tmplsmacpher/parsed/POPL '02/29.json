{"article_publication_date": "01-01-2002", "fulltext": "\n Resource Usage Analysis Atsushi Igarashi Department of Graphics and Computer Science Graduate School \nof Arts and Sciences University of Tokyo igarashi@graco.c.u-tokyo.ac.jp ABSTRACT It is an important \ncriterion of program correctness that a program accesses resources in a valid manner. For example, a \nmemory region that has been allocated should be even\u00adtually deallocated, and after the deallocation, \nthe region should no longer be accessed. A .le that has been opened should be eventually closed. So far, \nmost of the methods to analyze this kind of property have been proposed in rather speci.c contexts (like \nstudies of memory management and veri.cation of usage of lock primitives), and it was not so clear what \nis the essence of those methods or how methods proposed for individual problems are related. To remedy \nthis situation, we formalize a general problem of analyz\u00ading resource usage as a resource usage analysis \nproblem, and propose a type-based method as a solution to the problem. 1. INTRODUCTION It is an important \ncriterion of program correctness that a program accesses resources in a valid manner. For example, a \nmemory cell that has been allocated should be eventually deallocated, and after the deallocation, the \ncell should not be read or updated. A .le that has been opened should be eventually closed. A lock should \nbe acquired before a shared resource is accessed. After the lock has been acquired, it should be eventually \nreleased. A number of program analyses have been proposed to en\u00adsure such a properly. Type systems for \nregion-based memory management [1, 3, 25, 28] ensure that deallocated regions are no longer read or written. \nLinear type systems [18, 26, 27, 30] ensure that a linear (use-once) value that has been already accessed \nis never accessed again. Abadi and Flana\u00adgan s type systems for race detection [7, 8] ensure that ap\u00adpropriate \nlocks will be acquired before a reference cell or a concurrent object is accessed. Freund and Mitchell \ns type system [9] for JVM ensures that every object is initialized before it is accessed. Bigliardi and \nLaneve s type system [2] for JVM ensures that an object that has been locked will be eventually unlocked. \nDeLine and F\u00a8ahndrich s type sys- Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 02 1/02, Portland, Oregon, USA Copyright 2002 ACM ISBN 1-58113-450-9/02/01 \n...$5.00. Naoki Kobayashi Department of Computer Science Graduate School of Information Science and Engineering \nTokyo Institute of Technology kobayasi@cs.titech.ac.jp tem [5] keeps track of the state of each resource \nin order to control access to the resource. The problems attacked in the above-mentioned pieces of work \nare similar: There are di.erent types of primitives to access resources (initialization, read, write, \ndeallocation, etc.) and we want to ensure that those primitives are ap\u00adplied in a valid order. In spite \nof such similarity, however, most of the solutions (except for DeLine and F\u00a8ahndrich s work [5]) have \nbeen proposed for speci.c problems. As a re\u00adsult, solutions are often rather ad hoc, and it is not clear \nhow they can be applied to other similar problems and how solu\u00adtions for di.erent problems are related. \nThis is in contrast with standard program analysis problems like .ow analysis: For the .ow analysis problem, \nthere is a standard de.nition and there are several standard methods, whose properties (computational \ncost, precision, etc.) are well studied. Based on the observation above, our aims are: 1. To formalize \na general problem of analyzing how each resource is accessed as a resource usage analysis prob\u00adlem (usage \nanalysis problem, in short1), to make it easy to relate existing methods and to stimulate fur\u00adther studies \nof the problem. 2. To propose a type-based method for usage analysis. Unlike DeLine and F\u00a8ahndrich s \ntype system [5], our type-based analysis does not need programmers type annotation to guide the analysis. \nOur analysis auto\u00admatically gathers information about how resources are accessed, and checks whether \nit matches the program\u00admer s intention.  We give an overview of each point below. 1.1 Resource Usage \nAnalysis Problem We formalize a resource usage analysis problem in a man\u00adner similar to a formalization \nof the .ow analysis prob\u00adlem [23]. Suppose that each expression of a program is an\u00adnotated with a label, \nand let Lbe the set of labels. The standard .ow analysis problem for .-calculus is to obtain a function \n.ow .L.2L (2L denotes the powerset of L) where .ow(l)= {l1,...,ln}means that an expression labeled with \nl evaluates to a value generated by an expres\u00adsion labeled with one of l1,...,ln. (Or, equivalently, \nthe problem is to obtain a function .ow-1 .L.2L where 1The term usage analysis is also used to refer \nto linearity analysis [11]. Our resource usage analysis problem can be considered generalization of the \nproblem of linearity analy\u00adsis. .ow-1(l)= {l1,...,ln}means that only expressions labeled with l1,...,ln \ncan evaluate to the value generated by an ex\u00adpression labeled with l.) From a .ow function, we know what \naccess may occur to each resource. For example, con\u00adsider the following fragment ML-like program: let \nx= fopen(s)l in ...fread(Mlr ) ...fclose(Nlc ) ... Here, we assume that fopen opens a .le of name s and \nre\u00adturns a .le pointer to access the .le, and that fread (fclose, resp.) takes a .le pointer as an input \nand reads (closes, resp.) the .le. If .ow-1(l)= {lr}, then we know that the .le opened at l may be read, \nbut is not closed (since ex\u00adpression Nlc cannot evaluate to the .le by the de.nition of .ow-1). A .ow \nfunction does not provide information about the order of resource accesses. Suppose that flow-1(l)is \n{lc,lr}in the above program. From the .ow information, we can t tell whether the .le created at l is \nclosed after it has been read, or the .le is read after it has been closed. Let us write L * for the \nset of .nite sequences of labels. We formalize usage analysis as a problem of (i) computing a function \nuse .L.2L * where l1 \u00b7\u00b7\u00b7ln .use(l) means that a value generated by an expression labeled with l may be \naccessed by primitives labeled with l1,...,ln in this order, and then (ii) checking whether use(l) contains \nonly valid access sequences. Let us reconsider the above example: let x= fopenl(s) in ...freadlr (M) \n...fcloselc (N) ... (Here, labels are moved to primitives for creating or access\u00ading resources.) If use(l)= \n{lrlc,lrlrlc}, we know that the .le opened at l may be closed after it is read once or twice, and the \n.le is never read after being closed. On the other hand, if use(l)= {lrlc,lclr}, the .le may be read \nafter it has been closed. Many problems can be considered instances of the usage analysis problem. In \nregion-based memory management [25, 3, 1, 28], we can regard regions as resources. Suppose that every \nprimitive for reading a value from a region (writing a value into a region, deallocating a region, resp.) \nis anno\u00adtated with lr (lw,lF , resp.). Then, a region-annotated pro\u00adgram is correct if use(l) . (lr + \nlw) * lF , where (lr + lw) * lF is a regular expression. In linear type systems [27, 26, 18, 30], we \ncan regard values as resources. A linear type sys\u00adtem is correct if for every label l of a primitive \nfor creating linear (use-once) values, use(l) contains only sequences of length 1. The object initialization \nis correct [9] if for every label l of an (occurrence of) object creation primitive, every sequence in \nuse(l) begins with the label of a primitive for object initialization. Usage of lock primitives is correct \nif each occurrence of a label of the lock primitive is followed by an occurrence of a label of the unlock \nprimitive. The con\u00adtrol .ow analysis problem can also be considered an instance of the usage analysis \nproblem. We can regard functions as resources, function abstraction as the primitive for creating a function, \nand function application as the primitive for ac\u00adcessing a function. Then, a function created at l may \nbe called at l' if use(l) contains l'. 1.2 Type-Based Usage Analysis We present a type-based resource \nusage analysis for a call\u00adby-value, simply-typed .-calculus extended with primitives for creating and \naccessing resources. The main idea is to augment types with information about a resource access order. \nFor example, the type of a .le is written as (File,U), where U, called a usage, expresses how the .le \nis accessed. Its syntax is given by: U ::= l |U1 ; U2 |U1 &#38; U2 |\u00b7\u00b7\u00b7 Usage l means that the resource \nis accessed by a primitive labeled with l. U1 ; U2 means that the resource is accessed according to U1 \nand then accessed according to U2. U1 &#38; U2 means that the resource is accessed according to either \nU1 or U2. For example, a .le that is accessed by a primitive labeled with l1 and then by a primitive \nlabeled with l2 has type (File,l1 ; l2). Based on the extension of types with usages, we extend ordinary \ntyping rules for the simply-typed .-calculus. For example, the ordinary rule for let-expressions is: \nG fM : t G,x: t fN : s G flet x= M in N : s It is replaced by the following rule: G fM : t .,x: t fN \n: s G; . flet x= M in N : s Type environment G; . indicates that the resources referred to by free variables \nare .rst accessed according to G and then according to ., re.ecting the evaluation rule that M is evaluated \nand then N is evaluated. For example, if we have y:(File,l1) f M : bool (which implies that y is a .le \naccessed at l1 in M) and y :(File,l2),x: bool f N : bool, then we get y :(File,l1; l2) f let x = M in \nN : bool. The resulting type environment indicates that y is a .le accessed at l1 and then at l2. Actually, \nthe type system is a little more complicated than it might seem. Consider an expression M = let x = y \nin (freadlr (y); fwritelw (x)). If we naively apply the above rule, we get: y:(File,lw) fy:(File,lw) \ny:(File,lr),x:(File,lw) ffreadlr (y); fwritelw (x): bool (y:(File,lw)); (y:(File,lr))(= y:(File,lw; lr)) \nfM : bool The conclusion implies that y is .rst written at lw and then read at lr, which is wrong. This \nwrong reasoning comes from the fact that the access represented by the type en\u00advironment y:(File,lw) \noccurs not when y is evaluated but when the body of the let-expression freadlr (y); fwritelw (x) is evaluated. \nTo solve this problem, we introduce a usage constructor DU, which means that the resource is accessed \naccording to U now (when the expression is evaluated) or later (when the value of the expression is used). \nUsing the operator D, we replace the above inference with: y:(File,Dlw) fy:(File,lw) y:(File,lr),x:(File,lw) \nffreadlr (y); fwritelw (x): bool y:(File,Dlw; lr) fM The premise y :(File,Dlw ) f y :(File,lw) re.ects \nthe fact that the resource y is accessed only when the value of y is used later (when fwritelw (x) is \nevaluated). The conclusion implies that that y may be accessed at lw either immediately before an access \nat lr occurs, or later after an access at lr occurs. (In order to obtain a more accurate usage lr; lw,we \nneed to keep dependencies between di.erent variables: See Section 6.) In order to get accurate information \nabout the access or\u00adder, we also need to have a rule to remove D. Suppose that x :(File, Dl) fM : t is \nderived and that we know that the value (evaluation result) of M cannot contain a reference to x. Then, \nwe know that x is accessed at l when M is eval\u00aduated, not later. To allow such reasoning, we introduce \nthe following rule: G,x : t fM : sx does not escape from M G,x : t fM : s Here, is an operator to cancel \nthe D-operator. Based on the above idea, we formalize a type system for usage analysis and prove its \ncorrectness. We also develop a type inference algorithm to infer resource usage informa\u00adtion automatically \nso that programmers only have to declare what access sequences are valid: the type inference algo\u00adrithm \nautomatically computes the function use, and checks whether use(l) contains only valid access sequences \nfor each resource creation point l. 1.3 The Rest of This Paper Section 2 introduces a target language. \nSection 3 de.nes the problem of resource usage analysis. Sections 4 and 5 present a type-based method \nfor resource usage analysis. Section 6 discusses extensions of the type-based method. Section 7 discusses \nrelated work and Section 8 concludes. A proof of the correctness of our type-based analysis and a de\u00adtailed \ntype inference algorithm are given in a longer version of this paper, available at http://www.kb.cs.titech.ac.jp \n/~kobayasi/publications.html.  2. TARGET LANGUAGE This section introduces a call-by-value .-calculus \nex\u00adtended with primitives to create and access resources. We assume that there is a countably in.nite \nset Lof la\u00adbels, ranged over by meta-variable l. We write L * for the set of .nite sequences of labels, \nand write L *,. for the set L * .{s .|s .L * }. The special symbol . is used to denote the termination \nof a program. We call an element of L *,. a trace. We write E for the empty sequence, and s1s2 for the \nconcatenation of two traces s1 and s2. A trace set, denoted by a meta-variable F, is a subset of *,. \n' L that is pre.x-closed, i.e, ss . F implies s . F. S. denotes the set of all pre.xes of elements of \nS, i.e., {s . L *,. |ss ' .S}. Definition 1 (terms). The syntax of terms is given by: M ::= true |false \n|x |.Fx.M |.xF(f, x, M) |if M1 then M2 else M3 |M1@lM2 |new F() |accil(M) |let x = M1 in M2 Here, we \nextended a standard .-calculus with two con\u00adstructs: new F() for creating a new resource and accil(M) \nfor accessing resource M. For simplicity, we consider a sin\u00adgle kind of resource except for functions \n(hence the single primitive for resource creation). Also, we assume that ac\u00adcess primitives (acc1,..., \naccn) always return true or false. This is not so restrictive from the viewpoint of usage anal\u00adysis: \nFor example, the behavior of a primitive that accesses a resource and then returns the updated resource \ncan be simulated by .r.(let x = accil (r) in r). .xF(f, x, M ) de\u00adnotes a recursive function f that satis.es \nf = .x.M. A let\u00adexpression let x = M1 in M2 is computationally equivalent to (.Fx.M2)@lM1, but we include \nit to make our type-based analysis in Section 4 more precise (see Section 6). A formal operational semantics \nof the language is de.ned in the next section. A label (denoted by l) is attached to each occurrence \nof a primitive to access resources and functions. The same label may be attached to multiple occurrences \nof a primitive. A trace set F is attached to each occurrence of .\u00adabstraction, a recursive function, \nand the resource creation primitive. It represents the programmer s intention on how the function or \nresource should be accessed during evalua\u00adtion. A trace of the form s . is a possible sequence of ac\u00adcesses \nperformed to a resource by the time when evaluation terminates, while a trace of the form s(.L * ) is \na possible sequence of accesses performed by some time during evalua\u00ad {l2 .,l1l2 .}. tion. For example, \nnew() creates a resource that should be accessed at l1 at most once and then accessed once at l2 before \nevaluation of the whole term terminates. It is important to distinguish between traces ending with . \nand those without .. For example, for a .le, the trace set may contain lR; lW but not lR; lW ., since \nthe .le should be closed before the program terminates. We do not .x a particular way to specify trace \nsets F. They could be speci.ed in various ways, for example, using regular expressions, shu.e expressions \n[10, 16] context-free grammars, modal logics [6], or usage expressions we intro\u00adduce in Section 4. Bound \nand free variables are de.ned in a standard man\u00adner. We write FV(M) for the set of free variables in \nM. When x. FV(M2), we often write M1; M2 for let x = M1 in M2. Example 1. Let init, read, write, and \nfree be primi\u00adtives to initialize, read, update, and deallocate a resource re\u00adspectively. (In examples, \nwe often use more readable names for primitives, rather than acci.) The following program creates a new \nresource r, initializes it, and then calls func\u00adtion f. Inside function f, resource r is read and updated \nseveral times and then deallocated. let f = .xFf (f, x, if readlR (x) then freelF (x) else (writelW (x); \nf@l1 x)) in let r = new Fr () in (initlI (r); f@l2 r) .*,. Here, Fr =(lI (lR + lW ) * lF .), andFf = \nL (where lI (lR + lW ) * lF .is a regular expression). Fr speci.es that r should be initialized .rst \nand deallocated at the end. This kind of access pattern (initialized, accessed, and then deallo\u00adcated) \noften occurs to various types of resources (e.g., mem\u00adory, .les, Java objects [9]). The trace set L *,. \nfor Ff means that the programmer does not care about how function f is called. 3. RESOURCE USAGE ANALYSIS \nPROB-LEM The purpose of resource usage analysis is to infer how each resource is used in a given program, \nand check whether the inferred resource usage matches the programmer s intention (speci.ed using trace \nsets). We give below a formal de.\u00adnition of the resource usage analysis problem, by using an operational \nsemantics that takes the usage of resources into account. 3.1 Operational Semantics We .rst introduce \nthe notion of heaps to keep track of how each resource is used during evaluation: Formally, a heap is \na mapping from variables to pairs of a heap value (either a resource or function) and a trace set. Definition \n2 (heap values, heap). The set of heap values, ranged over by h, is given by the syntax: h ::= R|.x.M, \nwhere R denotes a resource created by new F().A heap H is a function from a .nite set of variables to \npairs of a heap value and a trace set. .F1 .Fn We write {x1 h1,...,xn hn} (n may be 0) for the heap H \nsuch that dom(H)= {x1,...,xn} and H(xi)= (hi, Fi). When dom(H1) ndom(H2)= \u00d8, we write H1 lH2 for the \nheap H such that dom(H)= dom(H1) .dom(H2) and H(x)= Hi(x)if x .dom(Hi). Following [18, 22, 26], program \nexecution is represented by reduction of pairs of a heap and a term. When a resource is used at a program \npoint l, the attached traces are con\u00adsumed the label l at the head of a trace is removed (if the trace \nbegins with l; the traces not beginning with l are discarded). We de.ne F-l, which represents the trace \nset after the use at l,by {s | ls . F}. The formal reduction relation is de.ned below after a few auxiliary \nde.nitions. Definition 3 (small values, substitution). A small value (or just value) v is either a variable, \ntrue,or false. We write [v/x] for the standard capture-avoiding substitution of v for x. Definition 4 \n(evaluation contexts). The syntax of evaluation contexts is given by: E ::= [] |if E then M1 else M2 \n|E@lM | v@lE |accil(E) |let x = E in M We write E[M] for the expression obtained by replacing [] with \nM in E. Definition 5. A reduction relation (H,M) P, where P is either Error or a pair (H ' ,M ' ), is \nde.ned as the least relation closed under th rules below. z fresh F (R-AlcRes) (H,E[new ()]) (H l{z. \nF R}, E[z]) z fresh (R-AlcLam) .F (H,E[.Fx.M]) (H l{z .x.M}, E[z]) z fresh .F (H,E[.xF(f, x, M)]) (H \nl{z .x.[z/f]M}, E[z]) (R-AlcFix) F-l b = true or false = \u00d8 (H l{x i(x)]) (H l{x R}, E[b]) .F R}, E[acc \nl .F-l (R-Acc) F-l = \u00d8 l (R-AccErr) (H l{x i(x)]) Error .F R}, E[acc F-l = \u00d8 (R-App) .F (H l{x .y.M}, \nE[x@l v]) .F-l (H l{x .y.M}, E[[v/y]M]) F-l = \u00d8 (R-AppErr) (H l{x v) Error .F .y.M},x@l (H,E[if true \nthen M1 else M2]) (H,E[M1]) (R-IfT) (H,E[if false then M1 else M2]) (H,E[M2]) (R-IfF) We write * for \nthe re.exive transitive closure of . Most of the rules are straightforward. In rules R-Acc and R-App, \nthe attached trace set must include a trace be\u00adginning with l (represented by F-l = \u00d8). On the other \nhand, if no such traces are included, a usage error is sig\u00adnaled (R-AccErr and R-AppErr). Since we do \nnot care about the result of resource access here, it is left unspeci.ed which boolean value is returned \nin R-Acc. When an or\u00addinary type error like application of a non-functional value occurs, the reduction \nwill get stuck. Example 2. Let M be the following program, obtained by removing initlI (r) from the program \nin Example 1: let f = .xFf (f, x, if readlR (x) then freelF (x) else (writelW (x); f@l1 x)) in let r \n= new Fr () in f@l2 r The evaluation of M fails because r is read before it is ini\u00adtialized. ({},M) .L \n*,. * ({x1 2 (x) then \u00b7\u00b7\u00b7 else \u00b7\u00b7\u00b7, .x.if accR x2 R},x1@l2 x2) .Fr .L *,. .(lI (lR+lW ) * lF .) ({x1 \n.x.(\u00b7\u00b7\u00b7),x2 R}, if acc2 lR (x2) then \u00b7\u00b7\u00b7 else \u00b7\u00b7\u00b7) Error 3.2 Resource Usage Analysis Now, we de.ne the \nproblem of resource usage analysis. Intuitively, M is resource-safe if evaluation of M does not cause \nany usage errors and if all the resources are used up when the evaluation terminates. Definition 6. M \nis resource-safe i. (1) ({},M) * Error and (2) if ({},M) * (H,v), then for any x . dom(H), H(x)=(h, F) \nand .. F. The resource usage analysis problem is, given a program M, to check whether M is resource-safe. \nSince the problem is undecidable, a resource usage analysis should be sound but need not be complete: \nIf the answer is yes, the program should indeed be resource-safe, but even if the answer is no, the program \nmay be resource-safe. Example 3. The program M in Example 1 is resource\u00adsafe. Example 4. Let M be the \nfollowing program, obtained from the program in Example 1 by replacing freelF (x)in the de.nition of \nf with true: let f = .xFf (f, x, if readlR (x) then true else (writelW (x); f@l1 x)) in let r = new Fr \n() in (initlI (r); f@l2 r) It is evaluated as follows: ({},M) * ({x1 .L *,. .x.(\u00b7\u00b7\u00b7),x2 .{(lR+lW ) * \nlF .} R}, if true then true else (acc3 lW (x2); x1@l1 x2)) ({x1 .L *,. .x.(\u00b7\u00b7\u00b7),x2 .{(lR+lW ) * lF .} \nR}, true) In the .nal state of the execution, the trace set associated to x2 indicates that the resource \nstill needs to be accessed at lF before the execution terminates. Since the term cannot be reduced further, \nthe program M is not resource-safe (the second condition of De.nition 6 is violated). Remark 1. Alternatively, \nwe can formalize usage anal\u00adysis as a problem of giving not only an yes / no answer but also a trace \nset (consisting of possible access sequences) for each resource, as explained in Section 1. Our type-based \nanalysis presented in Sections 4 and 5 can solve this problem too.  4. A TYPE SYSTEM FOR RESOURCE US-AGE \nANALYSIS In this section, we present a type system that guarantees that every well-typed (closed) program \nis resource-safe. As mentioned in Section 1, a main idea is to augment the type of a resource with a \nusage, which expresses how the resource may be accessed. Note that programmers need not explic\u00aditly declare \nany usage in their programs: the type inference algorithm described in the next section can automatically \nrecover usage information from (untyped) terms. 4.1 Usages, Types Definition 7 (usages). The set U of \nusages, ranged over by U, is de.ned by: U ::= 0 |a | l |U1 &#38; U2 |U1 ; U2 |U1 .U2 |\u00b5a.U |DU | U |U1 \n8U2 |U1 cU2 We assume that the unary usage constructors D and bind tighter than the binary constructors \n(&#38;, ;, .,...), so that Dl1 ; l2 means (Dl1); l2. 0 is the usage of a resource that cannot be accessed \nat all. a denotes a usage variable (which is bound by \u00b5a.). Usages l, U1 ; U2, and U1 &#38; U2 have been \nexplained in Sec\u00adtion 1. U1 .U2 is the usage of a resource that can be ac\u00adcessed according to U1 and \nU2 in an interleaved manner. So, (l1 ; l2) .l3 is equivalent to (l3; l1; l2)&#38;(l1; l3; l2)&#38;(l1; \nl2; l3). \u00b5a.U denotes a recursive usage such that a = U. For exam\u00adple, \u00b5a.(0 &#38;(l; a)) means that \nthe resource is accessed at l an arbitrary number of times. As mentioned in Section 1, DU means that \nthe resource may be accessed now or later according to U. So, a resource of usage Dl1; l2 may be ac\u00adcessed \neither at l1 and then at l2,or at l2 and then at l1.  U means that the access represented by U must \noccur now. So, for example, (Dl1; l2; Dl3) is equivalent to l1 .(l2; l3). Usage U1 8 U2 means that the \naccess represented by U2 occurs for each single access represented by U1. For exam\u00adple, (l1; l2) 8U is \nequivalent to U; U. Usage U1 cU2 means that for each single access l represented by U1, the access represented \nby l; U2 happens. For example, (l1; l2) cU is equivalent to l1; U; l2; U. The precise meaning of each \nusage is de.ned in Subsection 4.2. Probably, we do not need some of the usage constructors (like 8 and \nc ) to express the .nal result of resource usage inference, but we need them to de.ne the type system \nand the type inference algorithm. Definition 8 (types). The set of types, ranged over by t , is de.ned \nby: t ::= bool |(t1 .t2,U) |(R,U) (t1 . t2,U) is the type of a function that is accessed (i.e., called) \naccording to U. For example, (bool . bool,l1; l2) is the type of a boolean function that is called at \nl1 .rst and then called at l2. (This kind of information is, for example, useful to determine when function \nclosures should be deal\u00adlocated.) (R,U) is the type of a resource that is accessed according to U. The \noutermost usage of t , written Use(t ), is de.ned by: Use(bool)= 0, Use(t1 .t2,U)= U, and Use(R,U)= U. \n 4.2 Semantics of Usages We de.ne the meaning of usages using a labeled transition semantics. A usage \ndenotes a set of traces, obtained from possible transition sequences. We also de.ne a subusage re\u00adlation, \nwhich induces a subtyping relation, using the labeled transition system and the usual notion of simulation. \nWe .rst de.ne auxiliary relations. We write U1 U2 when U2 is obtained from U1 by unfolding some recursive \nusages (\u00b5a.U) and removing some branches from choices (U &#38; U ' ). Definition 9. A relation is the \nleast re.exive and transitive relation on usages that satis.es the rules in Fig\u00adure 1. For example, l1;(l2 \n&#38; l3) l1; l2. Definition 10. Unary relations \u00b7 . and \u00b7 . are the least relations on usages that satis.es \nthe following conditions: 0. U. .((DU). .( U). .(U 8U ' ). . '. .(U ' 8U).(Uc U )) (U1 . .U2 .) .((U1 \n.U2). .(U1 ; U2). .(U1 &#38; U2).) ([\u00b5a.U/a]U). .(\u00b5a.U). 0. (DU). U. .( U) . '. .. U. .((U 8U ).(U ' \n8U).(Uc U ' )) .... (U1 . .U2 ) .((U1 .U2).(U1 ; U2).(U1 &#38; U2)) ([\u00b5a.U/a]U). .(\u00b5a.U). Intuitively, \nU. means that the resource is no longer accessed before evaluation of the whole term terminates. means \nU. that the resource is not accessed for now. (In other words '' all labels are boxed. ) We write U:. \nif U U and U . ' ''. for some U . Similarly, we write U:. if U U and U for some U ' . U1 &#38; U2 U1 \nU1 &#38; U2 U2 \u00b5a.U [\u00b5a.U/a]U U1 U ' 1 U2 U ' 2 U1 ; U2 U ' 1 ; U ' 2 U1 U ' 1 U2 U ' 2 U1 . U2 U ' 1 \n. U ' 2 U U ' DU DU ' U U ' U U ' U1 U ' 1 U2 U ' 2 U1 8 U2 U ' 1 8 U ' 2 U1 U ' 1 U2 U ' 2 U1 cU2 U \n' 1 cU ' 2 U ' Figure 1: Relation U We write DL for the set {Dl | l .L}. We call an element of L. DL \nan extended label, and use a meta-variable L for it. When L is an extended label, DL and L is de.ned \nby: DL if L .L DL = L if L . DL L if L .L L = l if L = Dl Let S be a set of extended labels. We write \nDS and S for the sets {DL | L. S} and { L | L. S} respectively. L Now we de.ne a transition relation \nU -. U ' . Intuitively, it implies that a resource of usage U can be .rst accessed at L and then accessed \naccording to U ' . L Definition 11. A transition relation U -. U ' on usages is the least relation closed \nunder the rules in Figure 2. Example 5. Dl1; l2 has two transition sequences: .l1l2l2.l1 Dl1; l2 -. 0; \nl2 -. 0; 0 and Dl1; l2 -. Dl1; 0 -. 0; 0 but l1l2 l1; l2 has only the transition sequence: l1; l2 -. \n0; l2 -. 0; 0. (Note the righthand premise of rule (UR-SeqR).) The set of traces denoted by a usage U, \nwritten [[ U]], is de.ned as follows. Definition 12. Let U be a usage. [[ U]] denotes the set: L1Ln {( \nL1) \u00b7\u00b7\u00b7 n) |.U1,...,Un.(U -. U1 \u00b7\u00b7\u00b7 Un-1 -. Un)}.{( L1) \u00b7\u00b7\u00b7 n) .| L1Ln:. .U1,...,Un.((U -. U1 \u00b7\u00b7\u00b7 Un-1 \n-. Un) . Un )} Here, n can be 0 (so E. [[ U]] for any U). It is trivial by de.nition that [[ U]] is a \ntrace set (i.e., pre.x\u00adclosed). Example 6. [[ 0 ]] = {E,.}, [[ \u00b5a.a]] = {E} [[ D(l1; l2); l3 ]] = {l1l2l3 \n.,l1l3l2 .,l3l1l2 .} [[ \u00b5a.(0 &#38;(l; a))]] = {.,l.,ll.,lll.,...}  4.3 Subtyping We de.ne subusage \nand subtype relations U1 = U2 and t1 = t2 below. Intuitively, U1 = U2 means that U1 rep\u00adresents a more \ngeneral usage than U2, so that a resource of usage U1 may be used as that of usage U2. Similarly, t1 \n= t2 means that a value of type t1 may be used as a value of type t2. We de.ne the subusage relation \nto be closed under usage contexts. Formally, a usage context, written C, is an expres\u00adsion obtained from \na usage by replacing one occurrence of a free usage variable with [ ]. Suppose that the set of free usage \nvariables in U are disjoint from the set of bound us\u00adage variables in C. We write C[U] for the usage \nobtained by replacing [ ] with U. For example, if C = \u00b5a.([] ; a), then C[U]= \u00b5a.(U ; a). Definition \n13. Subusage relation = is the largest binary relation such that for all U1,U2 .U,if U1 = U2, then the \nfollowing conditions are satis.ed: 1. C[U1] = C[U2] for any usage context C; L L ' ''' 2. If U2 -. U2, \nthen U1 -. U1 and U1 = U2 for some ''' ' U and L with L = L or L = DL; and 1 3. If U2 :., then U1 :. \n. ~ We write U1 = U2 if and only if U1 = U2 and U2 = U1. Definition 14. Subtype relation = is the least \nbinary re\u00adlation on types that satis.es the following rules: bool = bool (Sub-Bool) U = U ' (Sub-Fun) \n(t1 . t2,U) = (t1 . t2,U ' ) U = U ' (Sub-Res) (R,U) = (R,U ' ) Remark 2. Actually, we could relax the \nabove subusage and subtype relations. For the subtype relation, for exam\u00adple, we can replace rule (Sub-Fun) \nwith the following rule. t1 ' = t1 t2 = t2 ' U = U ' (t1 . t2,U) = (t1 ' . t2' ,U ' )  4.4 Type environments \nA type environment is a mapping from a .nite set of vari\u00adables to types. We use meta-variables G and \n. for type environments. We write \u00d8 for the type environment whose domain is empty. When x . dom(G), \nwe write G,x : t for the type environment . such that dom(.) = dom(G) .{x}, .(x)= t, and .(y)=G(y) for \ny . dom(G). We de.ne several operations and relations on types and type environments. l l-. 0 (UR-Zero) \nU L-. U ' U1 L-. U ' 1 (UR-ParL) U L-. U ' (UR-Unbox) U1 . U2 L-. U ' 1 . U2 U2 L-. U ' 2 (UR-ParR) U1 \nl-. U ' 1 U2 L-. U ' 2 U1 8 U2 L-. U ' 2 ;(U ' 1 8 U2) (UR-Mult1) U1 . U2 L-. U1 . U ' 2 U1 L-. U ' 1 \n(UR-SeqL) U1 .l-. U ' 1 DU2 L-. U ' 2 U1 8 U2 L-. U ' 2 ;(U ' 1 8 U2) (UR-Mult2) U1 ; U2 L-. U ' 1 ; \nU2 U2 L-. U ' 2 U2 . (UR-SeqR) U1 l-. U ' 1 U1 cU2 l-. U2 ;(U ' 1 cU2) (UR-SMult1) U1 ; U2 L-. U1 ; U \n' 2 U1 .l-. U ' 1 U L-. U ' (UR-Box) U1 cU2 .l-. DU2 ;(U ' 1 cU2) DU .L-. DU ' (UR-SMult2) U U '' U '' \nL-. U ' (UR-PCong) U L-. U ' Figure 2: Usage Reduction Rules Definition 15. Let C be a usage context. \nSuppose that the set of free usage variables appearing in t or G is disjoint from the set of bound usage \nvariables in C. We de.ne C[t] and C[G] by: C[bool]= bool C[(t1 . t2,U)] =(t1 . t2,C[U]) C[(R,U)] =(R,C[U]) \ndom(C[G]) = dom(G) C[G](x)= C[G(x)] Let op be a binary usage constructor ; or &#38; .It is extended to \noperations on types and type environments by: bool op bool = bool (t1 . t2,U1) op (t1 . t2,U2)=(t1 . \nt2,U1 op U2) (R,U1) op (R,U2)=(R,U1 op U2) dom(G1 op G2)= dom(G1) . dom(G2) . . G1(x) op G2(x) . . if \nx. dom(G1) n dom(G2) (G1 op G2)(x)= . G1(x) if x. dom(G1)\\ dom(G2) . . G2(x) if x. dom(G2)\\ dom(G1) The \ntype environment xG is de.ned by G if x. dom(G) xG= G '' ,x: tx if G=G '' ,x: tx and tx = bool Note \nthat if G(x)= bool, then xG is unde.ned. Example 7. LetGbe x:(R,U)and.be x:(R,U ' ),y: bool. Then, DG= \nx: D(R,U)= x:(R,DU) and G;. = x:(R,U); (R,U ' ),y: bool = x:(R,U; U ' ),y: bool. We write G1 = G2 when \ndom(G1) . dom(G2), G1(x) = G2(x) for all x . dom(G2), and Use(G1(x)) = 0 for all x . dom(G1)\\ dom(G2). \n 4.5 Typing A type judgment is of the form G f M : t. It carries not only ordinary type information \nbut information about how resources are used. For example, x :(R,l1; Dl2) f M : (R,l2) implies that if \nx is a resource that can be accessed at l1 and then at l2, then M is evaluated to a resource that can \nbe accessed at l2. It further implies that the access at l1 occurs during evaluation of M, while the \naccess at l2 occurs either during evaluation of M or when the value of M is used (because l1 is not boxed \nbut l2 is boxed). For example, if M = let y = acc l1 (x) in x, this type judgment holds. i (Actually, \nannotation on escape information is necessary: See Example 8 below.) As mentioned in Section 1, an escape \nanalysis [4, 12] is useful to re.ne the accuracy of our type-based usage analy\u00adsis. To make our type \nsystem simple and clarify its essence, we assume that a kind of escape analysis has been already performed \nand that a program is annotated with the result of the escape analysis. We extend the syntax of terms \nby introducing a term of the form M{x}, which means that x does not escape from M, in the sense that \na heap value re\u00adferred to by x is not contained in (unreachable from) the value of M. A simplest escape \nanalysis would be to com\u00adpare the type of M and that of x, as in variants of linear type system [27, \n29]: For example if the type of M is bool or if the type of M is a resource type but the type of x is \na function type, xcannot escape from M (in the above sense). Typing rules are shown in Figure 3. In rule \n(T-Var), the D-operator is applied to the type of x in the type environ\u00adment, because x is used only \nlater, not when x is evaluated. In rules (T-New), (T-Abs), and(T-Fix), the premise [[ U]] . F checks \nthat resources or functions created here are accessed according to F (which represents the programmer \ns intention). In rule (T-Abs), the lefthand premise G,x: t1 f M: t2 means that the resources referred \nto by free variables in .Fx.M are accessed according to G each time the function is called. Since the \nfunction itself is called according to U, we multiply G by U to obtain a type environment expressing \nthe total access.2 Finally, since the resources are accessed only later when the function is called, \nD is applied. Rule (T-Fix) is similar to (T-Abs), except that the us\u00adage describing how the function \nis called is more complex. 2 Similar calculation is performed in linear type systems [18, 14, 13]. c \n= true or false G1 fM1 :(t1 .t2,l)G2 fM2 : t1 (T-Const)(T-App) \u00d8fc : bool G1;G2 fM1@lM2 : t2 x : Dt fx \n: t (T-Var)G fM :(R,l) (T-Acc) [[ U ]] .FG faccil (M): bool \u00d8fnew F():(R,U) G,x : t1 fM : t2 [[ U ]] \n.F D(U 8G) f.Fx.M :(t1 .t2,U) G,f :(t1 .t2,U1),x : t1 fM : t2 [[ U2 c (\u00b5a.U1 ca)]] .F a fresh D(U2 8(\u00b5a.(G \n.(U1 8a)))) f.xF(f, x, M):(t1 .t2,U2) (T-New) G1 fM1 : bool G2 fM2 : t G3 fM3 : t (T-If) G1;(G2 &#38;G3) \nfif M1 then M2 else M3 : t (T-Abs) G1 fM1 : t1 G2,x : t1 fM2 : t2 (T-Let) G1;G2 flet x = M1 in M2 : t2 \nG fM : t (T-Fix) (T-Now) xG fM{x} : t G '' ' fM : t G =G ' t =t (T-Sub) G fM : t Figure 3: Typing Rules \nThe type of .xF(f, x, M) implies that the function is called according to U2 from the outside. Upon each \ncall, M is evaluated and the function is internally called according to U1, and for each internal call, \nthe function is again called according to U1. Therefore, the usage of the function in total is represented \nby U2 c (\u00b5a.U1 ca). As for usage of the resources referred to by the free variables of the func\u00adtion, \nupon each call, M is evaluated and the resources are accessed according to G. Moreover, during the evaluation, \ninternal calls occur and for each internal call, the resources are again accessed according to G. The \nusage in total is therefore represented by U2 8(\u00b5a.(G .(U1 8a))) and D is applied to this, since the \nresources are accessed only later, not when the term .xF(f, x, M) is evaluated. In rule (T-App), the \npremises imply that resources are accessed according to G1 and G2 in M1 and M2 respectively. Because \nM1 is evaluated .rst, the usage of resources in total is represented by G1;G2. Because the function M1 \nis called at l, the usage of M1 must be l. Similarly, in rule (T-Acc), 3 the usage of M must be l because \nit is accessed at l. In rule (T-If), after M1 is evaluated, either M2 or M3 is evaluated. Thus, the usage \nof resources in total is repre\u00adsented by G1;(G2 &#38;G3). Inrule(T-Now), M{x} asserts that x does not \nescape from M. So, the access represented by t should happen now, when M is evaluated. The operator \nis applied to re.ect this fact. We exclude the case where t1 = bool, since in that case escape information \nis useless. Example 8. A derivation for the type judgment l1 {x} x :(R,l1; Dl2) flet y = acci (x)in x \n:(R,l2) is shown in Figure 4.  4.6 Type Soundness The above type system is sound in the sense that every \nclosed well-typed expression of type t where Use(t) = 0 is resource-safe, provided that the escape analysis \nis sound. The condition Use(t) =0 means that resources contained in the result of the evaluation may \nno longer be accessed. 3Actually, because the value of acc li(M) cannot contain ref\u00aderences to resources, \nit is safe to apply to G in the conclu\u00adsion. In order to make explicit the assumption on the escape \nanalysis, we extend the operational semantics of the target language to deal with terms of the form M{x}. \nFirst, we extend the syntax of evaluation contexts by: E ::= \u00b7\u00b7\u00b7|E{x} We add the following reduction \nrule: x .Reach(v, H) (R-ECheck) (H, E[v{x}]) (H, E[v]) Here, Reach(v, H) is the least set that satis.es \nthe following conditions: x .Reach(x, H) (y .Reach(v, H) .y .dom(H)) . FV(H(y)) .Reach(v, H) Intuitively, \nReach(v, H) is the set of variables (i.e., heap locations) reachable from v. Rule (R-ECheck) makes sure \nthat if the escape analysis were wrong, evaluation would get stuck. Now soundness of our type system \nis stated as follows. Theorem 1 (type soundness). If \u00d8f M : t and Use(t) =0, then M is resource-safe. \nProof Sketch. We use a technique similar to the one used in Kobayashi s quasi-linear type system [18]. \nWe intro\u00adduce another operational semantics to the target language the semantics takes into account not \nonly how but also where in the expression each heap value is used during evaluation. This alternative \nsemantics is shown to be equivalent to the standard semantics in a certain sense and the type system \nis shown to be sound with respect to the alternative se\u00admantics. Interested readers are referred to a \nlonger version of the paper available at http://www.kb.cs.titech.ac.jp /~kobayasi/publications.html for \ndetails.  5. A TYPE INFERENCE ALGORITHM Let M be a closed term. By the type soundness theorem (Theorem \n1), in order to verify that all resources are used (T-Var) x:(R,Dl1) fx:(R,l1) (T-Acc) x:(R,Dl1) facc \nli 1 (x): bool (T-Now) (T-Var) (x){x} x:(R, Dl1) facc li 1 : bool x:(R,Dl2) fx:(R,l2) (T-Sub) (T-Sub) \n x:(R,l1) faccil1 (x){x} : bool x:(R,Dl2),y: bool fx:(R,l2) (T-Let) x:(R,l1; Dl2) flet y = accil1 (x){x} \nin x:(R,l2) Figure 4: An Example of Type Derivation correctly in M, it su.ces to verify that \u00d8fM : t \nholds for some type t with Use(t) =0. In this section, we describe an algorithm to check it. For simplicity, \nwe assume the following conditions. Escape analysis has been already performed, and an input term is \nannotated with the result of the escape analysis.  The standard type (the part of a type obtained by \nre\u00admoving usages) of each term has been already obtained by the usual type inference. We write .N for \nthe stan\u00addard type of each occurrence of a term N.  Given a usage U and a set F of traces, there is \nan al\u00adgorithm that veri.es [[ U]] .F. This algorithm should be sound but may not be complete; in fact, \ndepending on U and how F is speci.ed, the problem can become undecidable.  Because we do not expect \na complete algorithm in the third assumption, our algorithm described below is sound but in\u00adcomplete. \nOur algorithm proceeds as follows, in a manner similar to an ordinary type inference algorithm [17, 19] \nfor the simply\u00adtyped .-calculus. Step 1 Construct a template of a derivation tree for \u00d8f M:t, using usage \nvariables to denote unknown usages. Step 2 Extract constraints on the usage variables from the template. \nStep 3 Solve constraints on usage variables. 5.1 Step 1: Constructing a template of a type derivation \ntree First, we obtain syntax-directed typing rules equivalent to the typing rules given in Section 4, \nso that there is exactly one rule that matches each term. It is obtained by com\u00adbining each rule with \n(T-Sub) and removing (T-Sub). For example, (T-App) is replaced by the following rule: G1 fM1 :(t1 .t2,l)G2 \nfM2 : t1 G =G1;G2 t2 =t2 ' (T-App )G fM1@lM2 : t2 ' For each subterm N of an input term M, we prepare: \n(i) a type tN such that all the usages in tN are fresh usage variables, and except for the usages, tN \nis identical to .N . (ii) a type environment GN such that dom(GN )= FV(N) and for each x.dom(GN ), GN \n(x) is identical to tx ex\u00adcept for their outermost usages. The outermost usage of GN (x) (i.e., Use(GN \n(x))) is a fresh usage variable. We can construct a template of a type derivation tree, by labeling each \nnode with a judgment GN f N : tN .For example, consider a term f@l x where the standard type of f is \nR .bool. The template is: f :((R,a1) .bool,a3) ff :((R,a1) .bool,a2) x:(R,a5) fx:(R,a4) f :((R,a1) .bool,a6),x:(R,a7) \nff@l x: bool 5.2 Step 2: Extracting constraints In order to make the template a valid type derivation \ntree, it su.ces to instantiate usage variables so that the side con\u00additions of a syntax-directed typing \nrule are satis.ed at each derivation step. The side conditions are expressed as con\u00adstraints on types \nand usages. For example, for the node where the rule (T-App ) is applied, the side conditions can be \nexpressed by: {Use(GM1@lM2 (x)) =Use(GM1 (x); GM2 (x)) |x.dom(GM1@lM2 )}.{domty(tM1 )= tM2 ,tM1M2 =codty(tM1 \n)} Here, domty and codty is de.ned by: domty(t1 .t2,U)= t1 and codty(t1 .t2,U)= t2. Let CS be the set \nof constraints obtained by gathering the side conditions for every node of the template, plus the con\u00adstraint \nUse(tM ) =0. Then, a substitution . for usage vari\u00adables satis.es CS if and only if the derivation tree \nobtained by applying . to the template is a valid type derivation tree. Therefore, the problem of deciding \nwhether \u00d8fM : bool holds is reduced to the problem of deciding whether CS is satis.able. We can reduce \nthe constraints on types and obtain the following set of constraints on usages: '' {a1 =U1,...,an =Un}.{[[ \nU1 ]] .F1,...,[[ U ]] .Fm} m We can assume without loss of generality that a1,...,an are distinct usage \nvariables, because a=U1 .a =U2 holds if and only if a=U1 &#38; U2 holds. 5.3 Step 3: Solving constraints \nGiven the set of constraints {a1 = U1,...,an = Un}. '' {[[ U1 ]] .F1,...,[[ Um ]] .Fm}, we can eliminate \nthe .rst set of constraints by repeatedly applying the transformation: CS .{a=U}=.[\u00b5a.U/a]CS.Then, we \ncheck whether the remaining set of constraints is satis.ed (using the algorithm stated in the third assumption). \n 5.4 Properties of the Algorithm The above algorithm is relatively sound and complete with respect to \nan algorithm to judge [[ U ]] . F: The former is sound (complete, resp.) if the latter is sound (complete, \nresp.). Note that in the step 3 above, we are using the fact that \u00b5a.U is the least solution of a = U \nin the sense that U ' = [U ' /a]U implies [[ \u00b5a.U ]] . [[ U ' ]]. Suppose that the size of the standard \ntypes .N of sub\u00adterms is bound by a constant. Then, computational cost of the above algorithm, excluding \nthe cost for checking the validity of constraints of the form [[ U ]] . F, is quadratic in the size n \nof an input term. Note that the size of each constraint set C (N) in Step 2 is O(n). So, the size of \nthe set CS of all constraints is O(n 2). It is reduced to constraints on usages in O(n 2) steps and the \nsize of the resulting con\u00adstraints in Step 2 is also O(n 2). Therefore, the total cost of the algorithm \nis O(n 2). Actually, we expect that we can remove the assumption that the size of standard types is bound, \nby performing inference of standard types and that of usages simultaneously, in a manner similar to [19]. \nWe assumed above that a whole program is given as an input. It is not di.cult to adapt our algorithm \nto perform a modular analysis: The .rst and second steps of extract\u00ading and reducing constraints can \nbe applied to open terms. The third step can also be partially performed, because con\u00adstraints on a usage \nvariable a can be solved when we know that no constraint on a is imposed by the outside of the program \nbeing analyzed. 5.5 Examples We give examples of our analysis. We omit annotations on escape information \nbelow, but assume that terms of type bool are appropriately annotated with escape information (as in \n(acc l1 I (r)){r},(f@l2 r){r}). Example 9. Let us consider the program in Example 1. Let the types of \nf and r in writelI (x); f@l2 r be ((R,ax) . bool,af ) and (R,ar). Then, we get the following con\u00adstraints \non usage variables ax, ar, and af : { ax = lR;(lF &#38;(lW ; ax)),ar = lI ; ax,af = l2} By solving this, \nwe know that the usages of r and f in the whole program are lI ; \u00b5ax.(lR;(lF &#38;(lW ; ax))) and l2 \nc \u00b5a.((0 &#38; l1) ca). The usage of r implies that r is .rst ini\u00adtialized, read and written several \ntimes, and then deallocated. Example 10. Let us consider the following program: let f = .xFf (f, x, if \nreadlR (x) then true else (pushlP ush (x); f@l1 x; pop lPop (x))) in let r = new Fr () in f@l2 r The \nusage of r, inferred in a manner similar to the above example, is \u00b5a.(lR;(0 &#38;(lP ush; a; lPop))). \nIt implies that r is accessed in a stack-like manner: Each access push is fol\u00adlowed by an access pop. \nThis kind of access pattern appears in stacks, JVM lock primitives [2], memory management with reference \ncounting [29] (counter increment corresponds to push and decrement to pop). Example 11. Let us consider \nthe following program: let f = .xFf (f, g, g@l1 true; f@l2 g) let r = new Fr () in f@l3 .Fg x.readlr \n(r) It .rst creates a new resource r, and passes to f a func\u00adtion to access the resource. f calls the \nfunction repeatedly, forever. Let the types of f and r in f@l3 .Fg x.readlr (r) be ((bool . bool,ag ) \n. bool,af ) and (R,ar). Then, we get the following constraints on ag and ar: { ag = l1; ag,ar = D(ag \n8 lr)} . From this, we get: ag = \u00b5a.(l1; a),ar =(\u00b5a.(l1; a)) 8 lr(= \u00b5a.(lr ; a)) So, we know that r is \naccessed at lr in.nitely many times. (As a by-product, we also know that the program never ter\u00adminates, \nbecause no trace in [[ ar ]] contains . .)  6. EXTENSIONS Polymorphism and subtyping As in other type-based \nanalysis, polymorphism on types and usages improves the accuracy of our analysis. Consider the following \nprogram: F l1 l2 l4 l3 l5 let f = .x.(acc (x); x) in (acc (f@y); acc (f@z)) 1 23 There are two calls \nof f. The return value of the .rst call is used at l2 and that of the second call is used at l3. So, \nthe best type we can assign to f is ((R,l1;(l2 &#38; l3)) . (R,l2 &#38; l3),l4; l5), and the type of \ny is (R,l1;(l2 &#38; l3)). If we introduce polymorphism, we can give f a type . a.((R,l1; a) . (R,a),l4; \nl5), and we can assign a more ac\u00adcurate type (R,l1; l2)to y. Similarly, our analysis becomes more precise \nif we relax the subtype relation (see Remark 2). Dependencies between di.erent variables Our type\u00adbased \nanalysis is imprecise when there is an alias. For ex\u00adample, consider the following program: l1 l2 {x} \n(let y = x in (acc1 (x); acc2 (y))) The type inferred for x is (R, (Dl2; l1)) (which is equiv\u00adalent \nto (R,l2 . l1)). So, we lose information that x is actually used at l1 and then at l2. The problem is \nthat a type environment is just a binding of variables to types and it does not keep track of the order \nof accesses through di.erent variables. To solve the problem, we can extend type environments, following \nour generic type sys\u00adtem for the p-calculus [15]. For example, the type envi\u00ad l1 l2 ronment of the expression \nacc1 (x); acc2 (y) can be repre\u00adsented as x :(R,l1); y :(R,l2), which means that x is ac\u00adcessed at l1, \nand then y is accessed at l2. Then, we can obtain the type environment of the whole expression by: [x/y](x \n:(R,l1); y :(R,l2)) = x :(R,l1; l2). Combination with region inference Regions and ef\u00adfects [3, 25] are \nalso useful to improve the accuracy of l1 l2 the analysis. Consider a term (.{l3}y.acc1 (x))@l3 acc2 \n(x). The best type we can assign to x is (R, Dl1; l2), al\u00adthough the term is computationally equivalent \nto let y = acc2 l2 (x) in accl1 1 (x). The problem is that rule (T-Abs) loses information that free variables \nin .Fx.M are accessed only after the function is applied. We can better handle this problem using region \nand ef\u00adfect systems [3, 25]. Let us introduce a region to express a set of resources, and let r be the \nregion of the resource x above. Then, we can express the type of .{l3}y.acc1 l1 (x) r l1 l1 as bool -. \nbool, where the latent e.ect r means that a resource in region r is accessed at l1 when the function \nis invoked. Using this precise information, we can obtain r l2 ; r l1 as the e.ect of the whole expression. \nA problem of the above method is that since the e.ect r l2 ; r l1 tells only that some resource in region \nr is accessed at l2 and then some resource in region r is accessed at l1, we don t know whether x is \nindeed accessed at l1 and l2 if r represents multiple resources. Multiple resources are indeed aliased \nto the same region, for example, when they are passed to the same function: let x= new() in let y = new() \nin (f(x),f(y)) A common solution to this problem is to use region poly\u00admorphism, existential types, etc. \n[5, 25, 28], at the cost of complication of type systems. We are currently studying a method to combine \nour analy\u00adsis with region/e.ect systems to take the best of both worlds. The resulting analysis would \nno longer require a separate es\u00adcape analysis, because region/e.ect information subsumes escape information. \nRecursive data structures It is not di.cult to extend our type-based analysis to deal with recursive \ndata struc\u00adtures like lists. For example, we can write (R,U) list for the type of a list of resources \nused according to U. (Note that in DeLine and F\u00a8ahndrich s type system [5], existential types are required \nto express similar information.) The rules for constructing and destructing lists can be given as: G1 \nfM1 : t G2 fM2 : t list G1;G2 fM1 :: M2 : t list G1 fM1 : t list G2 fM2 : t ' G3,x: t,y: t list fM3 : \nt ' G1;(G2 &#38;G3) fcase M1 of nil .M2 |x :: y .M3 : t ' If we are also interested in how cons cells \nare accessed, we can further extend the list type to ((R,U1) list,U2), which means that each cons cell \nis accessed according to U2. 7. RELATED WORK The goal of the present work is close to that of DeLine \nand F\u00a8ahndrich s Vault programming language [5]. Vault s type system keeps track of the state (called \na key)ofa re\u00adsource. The state of a resource determines what operations can be performed on the resource, \nand the state changes af\u00adter operations are performed. Therefore, keys in their type system roughly correspond \nto usages in our type-based usage analysis. A main di.erence is that our analysis automati\u00adcally gather \ninformation on resource usage, while their type system requires programmers explicit type annotations \n(in\u00adcluding keys) to guide an analysis. In fact, Vault s type sys\u00adtem seems rather complicated (it requires \nexistential types, etc.), and unsuitable for type inference. On the other hand, annotation of trace sets \n(F) in our framework is only used to declare valid access sequences. This declaration is necessary because \nthe valid access sequences vary depending on the type of each resource. Typically, declaration of a trace \nset needs to be done only once for each kind of resource. For example, the following program de.nes new \nro and new rw as functions to create a read-only .le and a read-write .le respectively: (l * lC .) let \nnew ro = .x.newR() in ((lR+lW ) * lC .) let new rw = .x.new() in \u00b7\u00b7\u00b7 Here, we assume that the primitives \nfor reading, writing, and closing a .le are annotated with lR, lW , and lC , respec\u00adtively. Another di.erence \nis that resources can have only .nite states in Vault, while we can express possibly in.nite states (recall \nExample 10). Technical ideas of our type-based analysis are similar to the quasi-linear type system [18] \nfor memory management and type systems for concurrent processes (especially, those for deadlock-free \nprocesses) [15, 20, 21, 24]. The quasi-linear type system distinguishes between candidates for the last \nac\u00adcess (labeled with 1) to a heap value and other accesses (la\u00adbeled with d or .), and guarantees that \nheap values judged to be quasi-linear are never accessed after they are accessed by an operation labeled \nwith 1. Similar typing rules are used to keep track of the access order (although the details are di.erent). \nThe idea of usage expressions was borrowed from type systems for concurrent processes [15, 20, 21, 24]. \nIn those type systems, usage expressions express how each communication channel is used. As mentioned \nin Section 1, many pieces of previous work on memory management, safe locking, etc. are related with \nour resource usage analysis problem. We remark on some of them below; Detailed comparison of our type-based \nanalysis with previous work is left for future work. The problem of linearity analysis [11, 26, 27, 30] \ncan be viewed as an instance of the resource usage analysis problem: By removing information on label \nnames and access order from usage information, we get linearity information. Our type-based analysis \nsubsumes the linear type system of [13]. Among previous work on region-based memory manage\u00adment, most \nclosely related would be Walker et al s work [28, 29]. Given programs explicitly annotated with region \nop\u00aderations, their type system checks the safety of the region operations through a type system. (On \nthe other hand, most of other work on region-based memory management [1, 3, 25] inserts region operations \nautomatically.) However, un\u00adlike in our type-based usage analysis, programs have to be explicitly annotated \nwith type information that guides the program analysis in their type system. Freund and Mitchell [9] \nproposed a type system for Java bytecode, which guarantees that every object is initialized before being \nused. Although the problem of checking this property is an instance of the usage analysis problem, our \ntype-based analysis presented in Section 4 is not powerful enough to guarantee the same property. The \nmain di.culty is that in typical Java bytecode, a pointer to an uninitialized object is duplicated into \ntwo pointers, one of which is used to initialize the object, and then the other is used to access the \nobject. To deal with this, our analysis must be extended to keep track of dependencies between di.erent \nvariables, as mentioned in Section 6. 8. CONCLUSION We have formalized a resource usage analysis problem \nas generalization of various program analysis problems con\u00adcerning resource access order. Our intention \nis to provide a uniform view for various problems attacked individually so far, and to stimulate development \nof general methods to solve those problems. As a starting point towards devel\u00adopment of general methods \nfor resource usage analysis, we have also presented a type-based method. A lot of work is left for future \nwork. In order to deal with various kinds of resources and programming styles, it is probably necessary \nto extend our type-based method as dis\u00adcussed in Section 6. In fact, our current type-based method does \nnot subsume many solutions proposed for individual problems [9, 28]. It is also left for future work \nto choose a language appropriate to specify valid trace sets (F), and design a practically good algorithm \nto check that inferred usages conform to the speci.cation (i.e., [[ U ]] . F). Asa speci.cation language \nfor trace sets, we are currently plan\u00adning to use shu.e expressions [10, 16] or context-free gram\u00admars. \n(Note that regular expressions are a little too weak to express access patterns like that in Example \n10.) We used the call-by-value simply-typed .-calculus as a target language of our type-based analysis. \nIt would be in\u00adteresting to develop a method for usage analysis for other languages such as imperative \nlanguages, low-level languages (like assembly languages and bytecode languages), and lazy functional \nlanguages. A rather di.erent method may be necessary to analyze those languages. Acknowledgment We would \nlike to thank Haruo Hosoya, Tatsuro Sekiguchi, and Eijiro Sumii for discussions and comments. 9. REFERENCES \n[1] A. Aiken, M. F\u00a8ahndrich, and R. Levien. Improving region-based analysis of higher-order languages. \nIn Proc. of PLDI, pages 174 185, 1995. [2] G. Bigliardi and C. Laneve. A type system for JVM threads. \nIn Proc. of 3rd ACM SIGPLAN Workshop on Types in Compilation (TIC2000), 2000. [3] L. Birkedal, M. Tofte, \nand M. Vejlstrup. From region inference to von neumann machines via region representation inference. \nIn Proc. of POPL, pages 171 183, 1996. [4] B. Blanchet. Escape analysis: Correctness, proof, implementation \nand experimental results. In Proc. of POPL, pages 25 37, 1998. [5] R. DeLine and M. F\u00a8ahndrich. Enforcing \nhigh-level protocols in low-level software. In Proc. of PLDI, pages 59 69, 2001. [6] E. A. Emerson. \nTemporal and modal logic. In J. V. Leeuwen, editor, Handbook of Theoretical Computer Science Volume B, \nchapter 16, pages 995 1072. The MIT press/Elsevier, 1990. [7] C. Flanagan and M. Abadi. Object types \nagainst races. In CONCUR 99, LNCS 1664, pages 288 303. Springer-Verlag, 1999. [8] C. Flanagan and M. \nAbadi. Types for safe locking. In Proc. of ESOP 1999, LNCS 1576, pages 91 108, 1999. [9] S. N. Freund \nand J. C. Mitchell. The type system for object initialization in the Java bytecode language. ACM Trans. \nProg. Lang. Syst., 21(6):1196 1250, 1999. [10] J. Gischer. Shu.e languages, Petri nets, and context-sensitive \ngrammars. Comm. ACM, 24(9):597 605, 1981. [11] J. Gustavsson and J. Svenningsson. A usage analysis with \nbounded usage polymorphism and subtyping. In Proceedings of IFL 00, Implementation of Functional Languages, \nLNCS 2011, pages 140 157, 2000. [12] J. Hannan. A type-based analysis for stack allocation in functional \nlanguages. In Proceedings of SAS 95, LNCS 983, pages 172 188, 1995. [13] A. Igarashi and N. Kobayashi. \nGarbage collection based on a linear type system. In Proc. of 3rd ACM SIGPLAN Workshop on Types in Compilation \n(TIC2000), 2000. [14] A. Igarashi and N. Kobayashi. Type reconstruction for linear pi-calculus with I/O \nsubtyping. Info. Comput., 161:1 44, 2000. [15] A. Igarashi and N. Kobayashi. A generic type system for \nthe pi-calculus. In Proc. of POPL, pages 128 141, 2001. [16] J. J\u00b8edrzejowicz and A. Szepietowski. Shu.e \nlanguages are in P. Theor. Comput. Sci., 250(1-2):31 53, 2001. [17] P. C. Kanellakis, H. G. Mairson, \nand J. C. Mitchell. Uni.cation and ML Type Reconstruction. In J.-L. Lassez and G. D. Plotkin, editors, \nComputational Logic: Essays in Honor of Alan Robinson, pages 444 478. The MIT Press, 1991. [18] N. Kobayashi. \nQuasi-linear types. In Proc. of POPL, pages 29 42, 1999. [19] N. Kobayashi. Type-based useless variable \nelimination. In Proc. of PEPM, pages 84 93, 2000. [20] N. Kobayashi. Type systems for concurrent processes: \nFrom deadlock-freedom to livelock-freedom, time-boundedness. In Proc. of IFIP International Conference \non Theoretical Computer Science (TCS2000), LNCS 1872, pages 365 389, 2000. [21] N. Kobayashi, E. Sumii, \nand S. Saito. An implicitly-typed deadlock-free process calculus. In Proc. of CONCUR2000, LNCS 1877, \npages 489 503. Springer-Verlag, 2000. [22] G. Morrisett, M. Felleisen, and R. Harper. Abstract models \nof memory management. In Proc. of Functional Programming Languages and Computer Architecture, pages 66 \n76, 1995. [23] F. Nielson, H. R. Nielson, and C. Hankin. Principles of Program Analysis. Springer-Verlag, \n1999. [24] E. Sumii and N. Kobayashi. A generalized deadlock-free process calculus. In Proc. of Workshop \non High-Level Concurrent Language (HLCL 98), ENTCS 16(3), pages 55 77, 1998. [25] M. Tofte and J.-P. \nTalpin. Implementation of the call-by-value lambda-calculus using a stack of regions. In Proc. of POPL, \npages 188 201, 1994. [26] D. N. Turner, P. Wadler, and C. Mossin. Once upon a type. In Proceedings of \nFunctional Programming Languages and Computer Architecture, pages 1 11, 1995. [27] P. Wadler. Linear \ntypes can change the world! In Programming Concepts and Methods. North Holland, 1990. [28] D. Walker, \nK. Crary, and J. G. Morrisett. Typed memory management via static capabilities. ACM Trans. Prog. Lang. \nSyst., 22(4):701 771, 2000. [29] D. Walker and K. Watkins. On linear types and regions. In Proc. of ICFP, \n2001. [30] K. Wansbrough and S. L. P. Jones. Once upon a polymorphic type. In Proc. of POPL, pages 15 \n28, 1999.  \n\t\t\t", "proc_id": "503272", "abstract": "It is an important criterion of program correctness that a program accesses resources in a valid manner. For example, a memory region that has been allocated should be eventually deallocated, and after the deallocation, the region should no longer be accessed. A file that has been opened should be eventually closed. So far, most of the methods to analyze this kind of property have been proposed in rather specific contexts (like studies of memory management and verification of usage of lock primitives), and it was not so clear what is the essence of those methods or how methods proposed for individual problems are related. To remedy this situation, we formalize a general problem of analyzing resource usage as a <i>resource usage analysis problem</i>, and propose a type-based method as a solution to the problem.", "authors": [{"name": "Atsushi Igarashi", "author_profile_id": "81100444415", "affiliation": "University of Tokyo", "person_id": "PP39043055", "email_address": "", "orcid_id": ""}, {"name": "Naoki Kobayashi", "author_profile_id": "81100603931", "affiliation": "Tokyo Institute of Technology", "person_id": "PP39050408", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/503272.503303", "year": "2002", "article_id": "503303", "conference": "POPL", "title": "Resource usage analysis", "url": "http://dl.acm.org/citation.cfm?id=503303"}