{"article_publication_date": "01-01-2002", "fulltext": "\n\t\t\t", "proc_id": "503272", "abstract": "Conservative garbage collectors can automatically reclaim unused memory in the absence of precise pointer location information. If a location can possibly contain a pointer, it is treated by the collector as though it contained a pointer. Although it is commonly assumed that this can lead to unbounded space use due to misidentified pointers, such extreme space use is rarely observed in practice, and then generally only if the number of misidentified pointers is itself unbounded.We show that if the program manipulates only data structures satisfying a simple <i>GC-robustness</i> criterion, then a bounded number of misidentified pointers can at most result in increasing space usage by a constant factor. We argue that nearly all common data structures are already GC-robust, and it is typically easy to identify and replace those that are not. Thus it becomes feasible to prove space bounds on programs collected by mildly conservative garbage collectors, such as the one in [2]. The worst-case space overhead introduced by such mild conservatism is comparable to the worst-case fragmentation overhead for inherent in any non-moving storage allocator.The same GC-robustness criterion also ensures the absence of temporary space leaks of the kind discussed in [13] for generational garbage collectors.", "authors": [{"name": "Hans-J. Boehm", "author_profile_id": "81423595101", "affiliation": "Hewlett-Packard Laboratories, Palo Alto, CA", "person_id": "PP80031134", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/503272.503282", "year": "2002", "article_id": "503282", "conference": "POPL", "title": "Bounding space usage of conservative garbage collectors", "url": "http://dl.acm.org/citation.cfm?id=503282"}