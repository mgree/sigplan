{"article_publication_date": "01-01-2002", "fulltext": "\n Analyzing Security Protocols with Secrecy Types and Logic Programs * Mart\u00b4in Abadi Bruno Blanchet Computer \nScience Department D\u00b4epartement d Informatique University of California, Santa Cruz Ecole Normale Sup\u00b4 \nerieure, Paris abadi@cs.ucsc.edu Bruno.Blanchet@ens.fr ABSTRACT We study and further develop two language-based \ntech\u00adniques for analyzing security protocols. One is based on a typed process calculus; the other, on \nuntyped logic pro\u00adgrams. Both focus on secrecy properties. We contribute to these two techniques, in \nparticular by extending the former with a .exible, generic treatment of many cryptographic op\u00aderations. \nWe also establish an equivalence between the two techniques. 1. INTRODUCTION Concepts and methods from \nprogramming languages have long been useful in security (e.g., [30]). In recent years, they have played \na signi.cant role in understanding security pro\u00adtocols. They have given rise to programming calculi for \nthese protocols (e.g., [5, 6, 7, 12, 13, 16, 17, 19, 26, 28, 34]). They have also suggested several approaches \nfor reasoning about protocols, leading to theories as well as tools for formal pro\u00adtocol analysis. We \ndescribe some of these approaches below. Although several of them are incomplete, they are appli\u00adcable \nto many protocols, including in.nite-state protocols, often with little e.ort. Thus, they provide an \nattractive al\u00adternative to .nite-state model checking (e.g., [27]) and to human-guided theorem proving \n(e.g., [33]). In this work we pursue these language-based approaches to protocol analysis and aim to \nclarify their interconnections. We examine and further develop two techniques that repre\u00adsent two substantial \nbut largely disjoint lines of research. One technique relies on a typed process calculus, the other * \nThis work was partly done while the author was at Bell Labs Research, Lucent Technologies, and at InterTrust \ns Strategic Technologies and Architectural Research Labora\u00adtory. This work was partly done while the \nauthor was at INRIA Rocquencourt. Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 02, Jan. 16-18, 2002 Portland, OR USA . 2002 ACM ISBN 1-58113-450-9/02/01 \n...$5.00. on untyped logic programs. We contribute to these two tech\u00adniques, in particular by extending \nthe former with a .exible, generic treatment of many cryptographic operations. We also establish an equivalence \nbetween the two techniques. We believe that this equivalence is surprising and illuminat\u00ading. The typed \nprocess calculus belongs in a line of research that exploits standard static-analysis ideas and adapts \nthem with security twists. There are by now several type systems for processes in which types not only \ntrack the expected structure of values and processes but also give security in\u00adformation [1, 4, 11, 20, \n22, 23]. A related approach relies on control-.ow analysis [10]; it has an algorithmic emphasis, but \nit is roughly equivalent to typing at least in important special cases [9]. Such static analyses have \napplications in a broader security context (e.g., [3, 21, 31, 35]); security proto\u00adcols constitute a \nparticularly challenging class of examples. To date, however, such static analyses have dealt case by \ncase with operations on data, and in particular with cryp\u00adtographic operations. In this paper, we develop \na general treatment of these operations. In another line of research, security protocols are repre\u00adsented \nas logic programs, in classical or linear logic, and they are analyzed symbolically with general provers \n[15, 36] or with special-purpose algorithms and tools [8, 12, 14] (see also [24] for some of the roots \nof this approach). Super.\u00adcially, these algorithms and tools are quite di.erent from typing and control-.ow \nanalysis. However, in this paper we show that one of these tools can be viewed as an implemen\u00adtation \nof a type system. More speci.cally, we develop a generic type system for a process calculus that extends \nthe pi calculus [29] with constructor operations and corresponding destructor oper\u00adations. These operations \nmay be, for instance, tupling and projection, symmetric (shared-key) encryption and decryp\u00adtion, asymmetric \n(public-key) encryption and decryption, digital signatures and signature checking, and one-way hash\u00ading \n(with no corresponding destructor). As in the applied pi calculus [5], these operations are not hardwired. \nThe ap\u00adplied pi calculus is even more general in that it does not require the classi.cation of operations \ninto constructors and destructors; we suspect that it might be treated along sim\u00adilar lines but with \nmore di.culty (see section 2). Our type system for the process calculus gives secrecy information. The \nbasic soundness theorem for the type system, which we prove only once (rather than once per choice of \noperations), states that well-typed processes do not reveal their secrets. We compare this generic type \nsystem with an automatic protocol checker. The checker takes as input a process and translates it into \nan abstract representation by logic\u00adprogramming rules. This representation and its manipula\u00adtion, but \nnot the translation of processes, come from previ\u00adous work [8], which develops an e.cient tool for establishing \nsecrecy properties of protocols. We show that establishing a secrecy property of a protocol with this \nchecker corresponds to typing the protocol in a particular instance of the generic type system. This \nresult implies a soundness property for the checker. Conversely, as a completeness property, we es\u00adtablish \nthat the checker corresponds to the best instance of our generic type system: if a secrecy property can \nbe es\u00adtablished using any instance of the type system, then it can also be established by the checker. \nThe next section presents our process calculus, without types. Section 3 gives a (fairly standard) de.nition \nof se\u00adcrecy. Section 4 presents our type system, and section 5 gives the main soundness theorems for \nthe type system and related results. As an example, section 6 explains how the type system applies to \nshared-key and public-key encryp\u00adtion operations. Section 7 formalizes and studies the logic\u00adprogramming \nprotocol checker. Section 8 concludes.  2. THE PROCESS CALCULUS (UNTYPED) This section introduces our \nprocess calculus, by giving its syntax and its operational semantics. 2.1 Syntax and Informal Semantics \nThe syntax of our calculus is summarized in Figure 1. It distinguishes a category of terms (data) and \none of processes (programs). It assumes an in.nite set of names and an in.\u00adnite set of variables; a, \nb, c, k, s, and similar identi.ers range over names, and x, y, and z range over variables. It also as\u00adsumes \na set of symbols for constructors and destructors; we often use f for a constructor and g for a destructor. \nConstructors are used to build terms. Therefore, the terms are variables, names, and constructor applications \nof the form f(M1,...,Mn). On the other hand, destructors do not appear in terms, but only manipulate \nterms in pro\u00adcesses. They are partial functions on terms that processes can apply. The process let x \n= g(M1,...,Mn) in P else Q tries to evaluate g(M1,...,Mn); if this succeeds, then x is bound to the result \nand P is executed, else Q is exe\u00adcuted. More precisely, the semantics of a destructor g of arity n is \ngiven by a partial function from n-tuples of terms to terms, such that g(sM1,...,sMn)= sg(M1,...,Mn) \nif g(M1,...,Mn) is de.ned and s is a substitution that maps names and variables to terms. We may isolate \na min\u00adimal set def(g) of equations g(M1',...,M')= M' that de\u00ad n .ne g, where M1',...,M',M' are terms \nwithout free names. n Then g(M1,...,Mn) is de.ned if and only if there exists a substitution s and an \nequation g(M1',...,M')= M' in n def(g) such that Mi = sM'for all i .{1,...,n}, and i g(M1,...,Mn)= sM'. \nThis set of equations may be in.\u00adnite, but it is usually .nite and small in concrete examples. Using \nthese constructors and destructors, we can repre\u00adsent data structures, such as tuples, and cryptographic \nop\u00aderations, for instance as follows: ntuple(M1,...,Mn) is the tuple of the terms M1,..., Mn, where ntuple \nis a constructor. (We sometimes ab\u00adbreviate ntuple(M1,...,Mn)to(M1,...,Mn).) The n projections are destructors \nithn for i.{1,...,n}, de\u00ad.ned by ithn(ntuple(M1,...,Mn)) = Mi sencrypt(M,N) is the symmetric (shared-key) \nencryp\u00adtion of the message M under the key N, where sencrypt is a constructor. The corresponding destruc\u00adtor \nsdecrypt is de.ned by sdecrypt(sencrypt(M,N),N)= M Thus, sdecrypt(M',N) returns the decryption of M' \nif M' is a message encrypted under N. In order to represent asymmetric (public-key) encryp\u00adtion, we may \nuse two constructors pk and pencrypt: pk(M) builds a public key from a secret M and pencrypt(M,N) encrypts \nM under N. The corre\u00adsponding destructor pdecrypt is de.ned by pdecrypt(pencrypt(M,pk(N)),N)= M As for \ndigital signatures, we may use a constructor sign, and write sign(M,N) for M signed with the sig\u00adnature \nkey N, and the two destructors checksignature and getmessage with the equations: checksignature(sign(M,N),pk(N)) \n= M getmessage(sign(M,N)) = M We may represent a one-way hash function by the con\u00adstructor H. There is \nno corresponding destructor; so we model that the term M cannot be retrieved from its hash H(M). Thus, \nthe process calculus supports many of the operations common in security protocols. It has limitations, \nthough: for example, XOR is neither a constructor nor a destructor. The other constructs in the syntax \nof Figure 1 are stan\u00addard; most of them come from the pi calculus. The input process M(x).P inputs a \nmessage on channel M, and exe\u00adcutes P with x bound to the input message. The output process M(N).P outputs \nthe message N on the channel M and then executes P. Here, we use an arbitrary term M to represent a channel: \nM can be a name, a variable, or a constructed term, but the process blocks if M does not re\u00adduce to a \nname at runtime. Our calculus is monadic (in that the messages are terms rather than tuples of terms), \nbut a polyadic calculus can be simulated since tuples are terms. It is also synchronous (in that a process \nP is executed after the output of a message). The nil process 0 does nothing. The process P |Q is the \nparallel composition of P and Q. The replication !P represents an unbounded number of copies of P in \nparallel. The restriction (.a)P creates a new name a, and then executes P. The local de.nition let x \n= M in P executes P with x bound to the term M. The conditional if M = N then P else Q executes P if \nM and N reduce to the same term at runtime; otherwise, it executes Q.As usual, we may omit an else clause \nwhen it consists of 0. The name a is bound in the process (.a)P. The vari\u00adable x is bound in P in the \nprocesses M(x).P, let x = g(M1,...,Mn) in P else Q, and let x = M in P.We write fn(P) and fv(P) for the \nsets of names and variables free in P, respectively. A process is closed if it has no free M, N ::= x, \ny, z a, b, c, k, s f(M1,...,Mn) P, Q ::= M(N).P M(x).P 0 P | Q !P (.a)P let x = g(M1,...,Mn) in P else \nQ let x = M in P if M = N then P else Q terms variable name constructor application processes output \ninput nil parallel composition replication restriction destructor application local de.nition conditional \n Figure 1: Syntax of the process calculus variables; it may have free names. We identify processes up \nto renaming of bound names and variables. We write {M1/x1,...,Mn/xn} for the substitution that replaces \nx1, ..., xn with M1,..., Mn, respectively. As an example, we may express the following protocol: Message \n1. A . B : pencrypt((k, pKA),pKB) Message 2. B . A : pencrypt((k, KAB ),pKA) Message 3. A . B : sencrypt(s, \nKAB ) This protocol establishes a session key KAB between two parties A and B, then uses the key to transmit \na secret s from A to B. It relies on public keys pKA for A and pKB for B. First, A creates a challenge \nk (a nonce), sends it to B paired with A s public key, encrypted under B s public key. Then B replies \nwith the same nonce and the session key KAB, encrypted under A s public key. When A receives this message, \nit recognizes k; it is then con.dent that the key KAB has been created by B. Finally, A sends the secret \ns under KAB . The following processes represent the protocol: . P =(.sKA)(.sKB)let pKA = pk(sKA) in let \npKB = pk(sKB) in e(pKA).e(pKB).(A | B) . A =(.k)e(pencrypt((k, pKA),pKB)). e(z).let (x, y)= pdecrypt(z, \nsKA) in if x = k then e(sencrypt(s, y)) . B = e(z).let (x, y)= pdecrypt(z, sKB ) in (.KAB )e(pencrypt((x, \nKAB ),y)). '' ' e(z ).let s = sdecrypt(z ,KAB ) in 0 (This code corresponds to a simple, one-shot version \nof the protocol; it is easy to extend it to represent more elaborate versions.) Here we write let (x, \ny)= M in Q instead of let z = M in let x =1th2(z) in let y =2th2(z) in Q, using pattern-matching on tuples. \nThe keys sKA and sKB are the decryption keys that match pKA and pKB, respectively, and e is a public \nchannel. The messages e(pKA) and e(pKB ), which publish pKA and pKB on e, model the fact that these keys \nare public. We return to this example in section 6.  2.2 Formal Semantics The rules of Figure 2 axiomatize \nthe reduction relation . for processes, thus de.ning the operational semantics of our calculus. Auxiliary \nrules axiomatize the structural con\u00adgruence relation =; this relation is useful for transforming processes \nso that the reduction rules can be applied. Both = and . are de.ned only on closed processes. We write \n. * the re.exive and transitive closure of ..As in [4], we say that the process P outputs M immediately \non c if and only if P = c(M).Q | R for some processes Q and R. We say that the process P outputs M on \nc if and only . * if PQ and Q outputs M immediately on c for some process Q. 2.3 Discussion As mentioned \nin the introduction, our calculus resembles the applied pi calculus [5]. Both calculi are extensions \nof the pi calculus with (fairly arbitrary) functions on terms. However, there are also important di.erences \nbetween these calculi. The .rst one is that we use destructors instead of the equational theories of \nthe applied pi calculus. The second di.erence is that our calculus has a built-in error-handling construct \n(the else clause of the destructor application), whereas in the applied pi calculus the error-handling \nmust be done by hand . This error-handling construct makes typing easier.  3. A DEFINITION OF SECRECY \nThroughout this paper, we use the following informal def\u00adinition of secrecy: a protocol P preserves the \nsecrecy of data M if P never publishes M, or anything that would permit the computation of M, even in \ninteraction with an adver\u00adsary Q. Equivalently, a protocol P preserves the secrecy of data M if P in \nparallel with an adversary Q will never output M on a public channel. De.nitions along these lines are \nquite common in protocol analysis. (There are how\u00adever alternatives, in particular some based on the \nconcept of noninterference; see [2] for discussion.) Next we give a formal counterpart for this informal \nde.\u00adnition, in the context of our process calculus and relying on the operational semantics of section \n2. We represent the ad\u00adversary Q as a process of the calculus, with some hypotheses that characterize \nQ s initial capabilities. We formulate these hypotheses simply by using a set of names S. Intuitively, \nQ knows the names in S initially; and Q may acquire some additional capabilities not represented in S \nin the course of P |0 =P P |Q=Q|P (P |Q) |R =P |(Q|R) !P =P |!P (.a1)(.a2)P =(.a2)(.a1)P if a1= a2 (.a)(P \n|Q) =P |(.a)Q if a/.fn(P) a(M).Q|a(x).P .Q|P{M/x} let x= g(M1,...,Mn) in P else Q.if g(M1,...,Mn)= M \n' let x= g(M1,...,Mn) in P else Q.Q if g(M1,...,Mn) is not de.ned let x= M in P .P{M/x} if M = M then \nP else Q .P if M = N then P else Q .Q if M = N P .Q .P |R .Q|R P .Q .(.a)P .(.a)Q P ' '' =P, P .Q, Q=Q \n.P ' .Q P =Q .P |R=Q|R P =Q .!P =!Q P =Q .(.a)P =(.a)Q P =P Q=P .P =Q P =Q, Q=R .P =R (Red I/O) P{M ' \n/x} (Red Destr 1) (Red Destr 2) (Red Let) (Red Cond 1) (Red Cond 2) (Red Par) (Red Res) (Red =) Figure \n2: Structural congruence and reduction computation, by creating fresh names and receiving terms in messages. \nIn order to represent that Qmay initially know complex terms rather than just names, we may let P begin \nwith the output of these terms on a public channel c .S, so the restriction that S is a set of names \nentails no loss of generality. De.nition 1. Let S be a .nite set of names. The closed process Q is a \nS-adversary if and only if fn(Q) .S. The closed process P preserves the secrecy of M from S if and only \nif P |Q does not output M on c for any S-adversary Q and any c.S. If P preserves the secrecy of M from \nS, then it clearly can\u00adnot output M on some c .S, that is, on one of the channels known to the adversary. \nThis guarantee corresponds to the informal requirement that P never publishes M on its own. Moreover, \nP cannot publish data that would enable an ad\u00adversary to compute M, because the adversary could go on \nto output M on some c.S.  4. THE TYPE SYSTEM This section presents a general type system for our pro\u00adcess \ncalculus; the following sections include instances of this general type system. Figure 3 gives the rules \nof the type system. In the rules, the metavariable u ranges over names and variables, and T over types. \nThe rules concern three judgments: E f0means that E is a well-formed typing environ\u00adment.  E fM : T \nmeans that M is a term of type T in the environment E.  E fP says that the process P is well-typed in \nthe environment E.  The type system is parameterized by a set of types Types and a non-empty subset \nTPublic .Types. These parameters will be .xed in each instance of the type system. Always, TPublic is \nthe set of types of data that can be known by the attacker. The type system relies on a function conveys \n: Types . P(Types) such that: (P0) If T .TPublic, then conveys(T)= TPublic. Intuitively, conveys(T) is \nthe set of types of data that are conveyed by a channel of type T. (It is empty when ele\u00adments of T cannot \nbe used as channels.) Data conveyed by a public channel is public, since the adversary can obtain it \nby listening on the channel. Conversely, public data can appear on a public channel, since the adversary \ncan send it. The type system also relies on a partial function from types to types Of : Typesn .Types \nfor each constructor f of arity n, and a function from types to sets of types Og : Typesn .P(Types) for \neach destructor g of arity n. These operators Of and Og give the types of constructor and destructor \napplications. These applications need not have unique or most general types (but terms do have unique \ntypes in a given environment). Constructors and destructors can accept arguments of di.erent types, and \nreturn results whose types depend on the types of the arguments. In this sense, we may say that they \nare overloaded functions; this overloading subsumes some forms of subtyping and para\u00admetric polymorphism. \nWe require the following properties: (P1) If for all i .{1,...,n}, Ti .TPublic, then Of (T1, ...,Tn) \nis de.ned and Of (T1,...,Tn) .TPublic. (P2) If for all i .{1,...,n}, Ti . TPublic and T . Og(T1,...,Tn), \nthen T .TPublic. (P3) For each equation g(M1,...,Mn)= M in def(g), if for all i .{1,...,n},E fMi : Ti, \nthen there exists T .Og(T1,...,Tn) such that E fM : T. Well-formed environments: (Env \u00d8) \u00d8f0 E f0 u/.dom(E) \n (Env atom) E,u: T f0 Terms: E f0 (u: T) .E (Atom) E fu: T E f0 .i.{1,...,n},E fMi : Ti Of (T1,...,Tn) \nis de.ned (Constructor application) E ff(M1,...,Mn): Of (T1,...,Tn) Processes: E fM : TE fN : T ' T \n' .conveys(T) E fP (Output) E fM(N).P E fM : T .T ' .conveys(T),E,x: T ' fP (Input) E fM(x).P E f0 \n (Nil) E f0 E fPE fQ (Parallel) E fP |Q E fP (Replication) E f!P E,a: T fP (Restriction) E f(.a)P \n.i.{1,...,n},E fMi : Ti .T .Og(T1,...,Tn),E,x: T fPE fQ (Destructor application) E flet x= g(M1,...,Mn) \nin P else Q E fM : T E,x: T fP (Local de.nition) E flet x= M in P E fM : TE fN : T ' if T = T ' then \nE fPE fQ (Cond) E fif M = N then P else Q Figure 3: Type rules The .rst two properties re.ect that \nthe result of applying a function to public terms should also be public, since the adversary can compute \nit. The third property essentially says that the de.nition of Og on types is compatible with the de.nition \nof g on terms. The type rules for nil, parallel composition, replication, re\u00adstriction, and local de.nition \nare standard. We use a Curry\u00adstyle typing for restriction, so we do not mention a type of a explicitly \nin the construct (.a). (That is, we do not write (.a : T) for some T.) This style of typing gives rise \nto a form of polymorphism: the type of a can change according to the environment. By the rule (Output), \nthe process M(N).P is well-typed only if data of the type T ' of N can be conveyed on a channel of the \ntype T of M, that is, T ' . conveys(T). Conversely, for typechecking the process M(x).P via the rule \n(Input), the variable x is considered with all types T ' . conveys(T) where T is the type of M. The universal \nquanti.cation on the type of x is unusual; it arises because a channel may convey data of several types. \nIn security protocols, this .ex\u00adibility is important because a channel may convey data from the adversary \nand from honest participants, and types can help distinguish these two cases. The rule (Constructor application) \ntypes f(M1,...,Mn) according to the corresponding operator Of . The rule (Destructor application) is \nsimilar to (Input); in let x = g(M1,...,Mn) in P else Q, the variable xis considered with all the possible \ntypes of g(M1,...,Mn), that is, all elements of Og(T1,...,Tn). Rule (Cond) exploits the property that \nif two terms M and N have di.erent types then they are certainly di.erent. In this case, if M = N then \nP else Q may be well-typed without P being well-typed. The constructs if M = N then P else Q and let \nx = M in P can be de.ned as special cases from let x = g(M1,...,Mn) in P else Q, and their typing follows: \n Let equals be a binary destructor with equals(M,M)= M (and with equals(M,N) unde.ned otherwise), Oequals \n(T,T)= {T}, and Oequals (T,T ' )= \u00d8 if T =. T ' Then if M = N then P else Q can be de.ned and typed \nas let x = equals(M,N) in P else Q, where x/. fv(P).  Let id be a unary destructor with id(M)= M and \nOid (T)= {T}. Then let x = M in P can be de.ned and typed as let x= id(M) in P else 0.  Because of these \nencodings, we may omit the cases of if M = N then P else Q and let x= M in P in various arguments and \nproofs. The encodings also suggest that the typing rule (Cond) for if M = N then P else Q is more natural \nthan might seem at .rst sight.  5. PROPERTIES OF THE TYPE SYSTEM The subject-reduction lemma says that \ntyping is preserved by computation. Lemma 1 (Subject reduction) If E f P and P . Q then E f Q. The secrecy \ntheorem says that if a closed process P is well\u00adtyped in an environment E, and a name s is not of a type \nin TPublic according to E, then P preserves the secrecy of sfrom S, where S is the set of names that \nare of a type in TPublic according to E. In other words, P preserves the secrecy of names whose type \nis not in TPublic against adversaries that can output, input, and compute on names of types in TPublic. \nTheorem 1 (Secrecy) Let P be a closed process. Suppose that E f P, E f s: T ' , and T ' ./TPublic. Let \nS = {a | E f a: T and T . TPublic}. Then P preserves the secrecy of s from S. This secrecy theorem is \na consequence of the subject\u00adreduction lemma and the typability of the adversary (i.e., that any S-adversary \nQ can be typed with all names and variables of a type in TPublic).  6. A SIMPLE INSTANCE OF THE TYPE \nSYSTEM As an example, we show how the type system applies to symmetric and asymmetric encryption. The \nresulting in\u00adstance of the type system is similar in scope and power to a previous special-purpose type \nsystem [4], but treats ad\u00additional constructs and could easily treat even more. For this instance, the \ngrammar of types is given in Figure 4. Informally, types have the following meanings: Public is the \ntype of public data.  Secret is the type of secret data.  T1 \u00d7 ...\u00d7 Tn is the type of tuples, whose \ncomponents are of types T1,...,Tn.  C[T] is the type of a channel that can convey data of type T and \nthat cannot be known by the adversary. (Channels that can be known by the adversary are of type Public.) \n KSecret[T] is the type of symmetric keys that can be used to encrypt data of type T and that cannot \nbe known by the adversary. (Symmetric keys that can be known by the adversary are of type Public.)  \nEKSecret [T] is the type of secret asymmetric encryption keys that can be used to encrypt cleartexts \nof type T. DKSecret[T] is the type of asymmetric decryption keys for cleartexts of type T and such that \nthe correspond\u00ading encryption keys are secret. These decryption keys are also secret.  EKPublic[T] is \nthe type of public asymmetric encryp\u00adtion keys that can be used to encrypt cleartexts of type T. The \nadversary can use these keys to encrypt its messages, so public messages can also be encrypted under \nthese keys.  DKPublic [T] is the type of asymmetric decryption keys for cleartexts of type T and such \nthat the correspond\u00ading encryption keys are public. These decryption keys are however secret. When decrypting \na message with such a key, the result can be of type T (in normal use of the key) or of type Public (when \nthe adversary has used the corresponding encryption key to encrypt one of its messages). T ::= types \nPublic public data Secret secret data T1 \u00d7...\u00d7Tn tuple C[T] secret channel KSecret[T] secret shared \nkey DKSecret[T] decryption key whose corresponding encryption key is secret EKSecret[T] secret encryption \nkey DKPublic [T] decryption key whose corresponding encryption key is public EKPublic [T] public encryption \nkey Figure 4: Grammar of types in an instance of the type system TPublic = {T |T =Public}Public = {Public,EK[T]}.{T1 \n\u00d7...\u00d7Tn |.i.{1,...,n},Ti .TPublic} If T =Public, then conveys(T)= TPublic; conveys(C[T]) = {T ' |T ' \n=T}. Ontuple (T1,...,Tn)= T1 \u00d7...\u00d7Tn. If T1 =Public and T2 =Public, then Osencrypt (T1,T2) = Public; \n '' Secret if T =T, then Osencrypt (T,K[T]) = Public. If T1 =Public and T2 =Public, then Opencrypt (T1,T2) \n= Public; '' L if T =T, then Opencrypt (T,EK[T]) = Public. If T1 =Public, then Opk (T1) = Public; Opk \n(DKL[T]) = EKL[T]. Oithn (T1 \u00d7...\u00d7Tn)= {Ti}. If T =Public, then Osdecrypt (Public,T)= TPublic; Secret'' \n Osdecrypt (Public,K[T]) = {T |T =T}. If T =Public, then Opdecrypt (Public,T)= TPublic; Secret'' Opdecrypt \n(Public,DK[T]) = {T |T =T}; Public'' Opdecrypt (Public,DK[T]) = {T |T =T}.TPublic. Other cases: conveys(T)= \n\u00d8, Of (T1,...,Tn) is not de.ned, and Og(T1,...,Tn)= \u00d8. Figure 5: De.nition of TPublic and type operators \nin an instance of the type system We de.ne TPublic and the type operators of the system in Figure 5. \nFor this purpose, we let the subtyping relation = be re.exive and transitive, with SecretSecret C[T] \n=Secret,K[T] =Secret,DK[T] =Secret, SecretPublic EK[T] =Secret,DK[T] =Secret, Public EK[T] =Public,Public \n\u00d7...\u00d7Public =Public, if .i .{1,...,n},Ti = Secret then T1 \u00d7...\u00d7Tn =Secret, '' '' if T1 =T1,...,Tn =Tn \nthen T1 \u00d7...\u00d7Tn =T1 \u00d7...\u00d7Tn. (We do not adopt a subsumption rule.) Importantly, these de.nitions allow \nencryption under a public key of type EKPublic [T] to accept data both of type Public and of type T. \nFor the corresponding decryption, we handle both cases: Opdecrypt (Public,DKPublic[T]) includes both \nsubtypes of T and subtypes of Public. (A similar idea appears in the special-purpose type system mentioned \nabove [4].) Proposition 1 These de.nitions satisfy the constraints of the general type system (P0, P1, \nP2, P3). For example, the type system can be used to prove that s remains secret in the example protocol \nof section 2. For this . proof, we de.ne E = s: Secret,e: Public, and derive E fP. In the (Restriction) \nrule, we choose the types . PublicSecret TsKB =DK[Secret \u00d7EK[Secret \u00d7K[Secret]]] TsKA =DK [Secret \u00d7K \n[Secret]] for sKA and . Public Public Secret for sKB. Then pk(sKA) has the type . )=EKPublic TpKA = \nOpk (TsKA [Secret \u00d7KSecret[Secret]] and pk(sKB ) has the type . TpKB = Opk (TsKB ) PublicPublicSecret \n=EK[Secret \u00d7EK[Secret \u00d7K[Secret]]] The remainder of the process is typed in the environment: ' . PublicSecret \nE = E,sKA :DK[Secret \u00d7K[Secret]], PublicPublicSecret sKB :DK[Secret \u00d7EK[Secret \u00d7K[Secret]]], PublicSecret \npKA :EK[Secret \u00d7K[Secret]], PublicPublicSecret pKB :EK[Secret \u00d7EK[Secret \u00d7K[Secret]]] We check that TpKA \n. conveys(Public) and TpKB . conveys(Public) (since these types are subtypes of Public). Then we only \nhave to show that E ' fA and E ' fB. In the typing of A, we choose k of type Secret. Then E ' ,k: Secret \nfpencrypt((k,pKA),pKB ) : Public follows by (Constructor application), hence the output e(pencrypt((k,pKA),pKB)) \nis well-typed by (Output). In the input e(z), by (Input), z can be of any subtype of Public, then by \n(Destructor application), we have to prove E ' ,k: Secret,x: Tx,y: Ty fif x = k then e(sencrypt(s,y)), \n= KSecret where either Tx = Secret and Ty [Secret] or Tx =Public and Ty =Public. In the .rst case, the \nconditional is well-typed, since the output is well-typed. In the second case, the conditional is well-typed, \nsince x and k cannot have the same type. We leave to the reader the veri.cation that B is well-typed. \nFinally, by Theorem 1, P preserves the secrecy of s from {e}.  7. PROTOCOL CHECKER In this section we \ngive a precise de.nition of a proto\u00adcol checker based on untyped logic programs, then study its properties, \nin particular proving its equivalence to the type system. This equivalence is considerably less routine \nand predictable than properties such as subject reduction (Lemma 1). 7.1 De.nition of the Protocol Checker \nGiven a closed process P0 and a set of names S, the proto\u00adcol checker builds a set of rules, in the form \nof Horn clauses. We assume that each restriction (.a)P in P0 has a di.erent name a, and that this name \nis di.erent from any free name of P0. The rules use two predicates: attacker and message. The fact attacker(p) \nmeans that the attacker may have p, and the fact message(p,p ' ) means that the message p ' may appear \non channel p. F ::= facts attacker(p) attacker knowledge message(p,p ' ) channel messages Here pand p \n' range over patterns (or terms , but we prefer the word patterns in order to avoid confusion), which \nare generated by the following grammar: p::= patterns x,y,z variable a[p1,...,pn] name f(p1,...,pn) constructor \napplication For each name ain P0 we have a corresponding pattern con\u00adstruct a[p1,...,pn]. We treat a \nas a function symbol, and write a[p1,...,pn] rather than a(p1,...,pn) only for clarity. If a is a free \nname, then the arity of this function is 0. If a is bound by a restriction (.a)P in P0, then this arity \nis the number of input statements above the restriction (.a)P in the abstract syntax tree of P0. Thus, \nin the checker, a new name behaves as a function of the inputs that take place (lexically) before its \ncreation. Therefore, we distinguish names only when they are created after receiving di.erent inputs. \nIn contrast, a restriction in a process always gener\u00adates fresh names; hence the rules will not exactly \nre.ect the operational semantics of processes, but this approximation is useful for automation and harmless \nin most examples. As we show below, this approximation is also compatible with soundness and completeness \ntheorems that prove the equiv\u00adalence between the type system and the logic-programming system. The rules \ncomprise rules for the attacker and rules for the protocol. Next we de.ne these two kinds. 7.1.1 Rules \nfor the attacker Initially, the attacker has all the names in a set S, hence the rules attacker(a[]) \nfor each a.S. Moreover, the abilities of the attacker are represented by the following rules: For each \nconstructor f of arity n, attacker(x1) .....attacker(xn) (Rf) .attacker(f(x1,...,xn)) For each destructor \ng, for each equation g(M1,...,Mn)= M in def(g), (Rg) attacker(M1) .....attacker(Mn) .attacker(M) message(x,y) \n.attacker(x) .attacker(y) (Rl) attacker(x) .attacker(y) .message(x,y) (Rs) The rules (Rf) and (Rg) mean \nthat the attacker can apply all operations to all terms it has, (Rf) for constructors, (Rg) for destructors. \nThe set of these rules is .nite if the set of constructors and each of the sets def(g) is .nite; handling \nthis set is easiest in this .nite case. For (Rg), notice that equations in def(g) do not have free names \nand that terms without free names are also patterns, so the rules have the required format. Rule (Rl) \nmeans that the attacker can listen on all the channels it has, and (Rs) that it can send all the messages \nit has on all the channels it has. 7.1.2 Rules for the protocol When a function . associates a pattern \nwith each name and variable, and f is a constructor, we extend . as a sub\u00adstitution by .(f(M1,...,Mn)) \n= f(.(M1),...,.(Mn)). The translation [ P]].h of a process P is a set of rules, where . is a function \nwhich associates a pattern with each name and variable, and h is a sequence of facts of the form message(p,p \n' ). The empty sequence is denoted by \u00d8; the concatenation of a fact F to the sequence h is denoted by \nh.F. [[0]].h = \u00d8,  [[P |Q]].h=[[P]].h.[[Q]].h,  [[!P]].h=[[P]].h,  [[(.a)P]].h =[[P]](.[a .. a[p \n' 1,...,p ' ]])h if h =  n message(p1,p1' ) .....message(pn,p ' ), n [[M(x).P]].h =[[P]](.[x. .x])(h.message(.(M),x)), \n [[M(N).P]].h =[[P]].h.{h.message(.(M),.(N))},  [[let x= g(M1,...,Mn) in P else Q]].h =  ' ' ''' .{[[P]]((s.)[x \n.p 1,...,pnp . s ])(sh) | g(p )= is in def(g) and (s,s ' ) is a most general pair of sub\u00adstitutions such \nthat s.(M1)= s ' p ' 1,...,s.(Mn)= s ' p ' }.[[Q]].h. n Thus, the translation of a process is, very roughly, \na set of rules that enable us to prove that it sends certain mes\u00adsages. The sequence h keeps track of \nmessages received by the process, since these may trigger other messages. The translation of 0 is the \nempty set, because this process does nothing. The translation of a parallel composition P | Q is the \nunion of the translations of P and Q, because P |Q sends the messages of P and Q plus any messages that \nre\u00adsult from the interaction of P and Q. Replication is ignored, because the target logic is classical, \nso all logical rules are applicable arbitrarily many times. For restriction, we re\u00adplace the restricted \nname a in question with a pattern a[...] that depends on the messages received, as recorded in the sequence \nh. This sequence is extended in the translation of an input, with the input in question. On the other \nhand, the translation of an output adds a clause; this clause rep\u00adresents that reception of the messages \nin h can trigger the output in question. Finally, the translation of a destructor application takes the \nunion of the clauses for the case where the destructor succeeds (with an appropriate substitution) and \nthose for the case where the destructor fails; thus we avoid having to determine whether it will succeed \nor fail. 7.1.3 Summary and secrecy results Let . = {a ..a[] | a .fn(P0)}. We de.ne the rule base corresponding \nto process P0 as: BP0,S =[[P0]].\u00d8.{attacker(a[]) |a .S} .{(Rf),(Rg),(Rl),(Rs)} We have the following \nsecrecy result. Let s . fn(P0). If attacker(s[]) cannot be derived from BP0,S , then P0 pre\u00adserves the \nsecrecy of s from S. This result is the basis for a method for proving secrecy properties. Of course, \nwhether a fact can be derived from BP0,S may be undecidable, but in practice there exist algorithms that \nterminate on numerous examples of protocols. In particular, we can use variants of resolution algorithms, \nsuch as the algorithm described in [8]. This result can be proved directly. Instead, we establish it \nby showing that we can build a typing of P0 in a suitable instance of our general type system; the result \nthen follows from Theorem 1. We also establish a completeness theorem, as a converse: the checker yields \nthe best instance of our general type system.  7.2 Correctness We use the rule base BP0,S to de.ne an \ninstance of our general type system, as follows. The grammar of types is T ::= types a[T1,...,Tn] name \nf(T1,...,Tn) constructor application The types are exactly closed patterns. TPublic = {T | attacker(T) \nis derivable from BP0,S }(that is, the protocol checker says that the attacker may have T).  conveys(T)= \n{T ' | message(T,T ' ) is derivable from BP0,S } (that is, the protocol checker says that the channel \nT may convey T ' ).  Of (T1,...,Tn)= f(T1,...,Tn).  Og(T1,...,Tn)= {sM | there exists an equation g(M1,...,Mn)= \nM in def(g), s maps variables to types, and .i.{1,...,n},sMi = Ti}.  We can show that the type system \nas de.ned above satis.es the constraints (P0, P1, P2, P3) of the general type system, and that E fP0, \nwhere E = {a: a[] |a .fn(P0)}. The se\u00adcrecy theorem for the protocol checker then follows from the secrecy \ntheorem for the general type system (Theorem 1): Theorem 2 (Secrecy) Let P0 be a closed process and s \n. fn(P0).If attacker(s[]) cannot be derived from BP0,S , then P0 preserves the secrecy of s from S. \n7.3 Completeness The protocol checker is incomplete in the sense that it fails to prove some true properties. \nHowever, as the next theorem states, the protocol checker is relatively complete: it is as complete as \nthe type system of section 4. Theorem 3 (Completeness) Let P0 be a closed process, s a name, and S a \nset of names. Suppose that an instance of the general type system proves (by Theorem 1) that P0 preserves \nthe secrecy of s from S. Then attacker(s[]) cannot be derived from BP0,S , so the protocol checker also \nproves that P0 preserves the secrecy of s from S. This theorem is proved by establishing a correspondence \nbe\u00adtween types T of an instance of the general type system and types Tc of the checker (of section 7.2): \nwe de.ne a par\u00adtial function f that maps Tc to T. (The appendix gives the de.nition of f.) Then we prove \nthat all rules of BP0,S are satis.ed, in the following sense: The closed fact attacker(Tc) is satis.ed \nif f(Tc) . TPublic.  The closed fact message(Tc,T ' c) is satis.ed if f(T ' c) . conveys(f(Tc)).  The \nrule F1 . .... Fn . F is satis.ed if sF is sat\u00adis.ed for every closed substitution s such that .i . {1,...,n},sFi \nis satis.ed.  Therefore, all facts derived from BP0,S are satis.ed. More\u00adover, if s is proved secret \nby the instance of the general type system, then attacker(s[]) is not satis.ed. (If attacker(s[]) were \nsatis.ed, we would also have that f(s[]) . TPublic,so the instance of the general type system would not \nbe able to prove the secrecy of s.) Hence, attacker(s[]) cannot be derived from BP0,S . The result follows. \nThis completeness result shows the power of the proto\u00adcol checker. This power is not only theoretical: \nit has been demonstrated in practice on several examples [8], from sim\u00adple protocols like variants of \nthe Needham-Schroeder proto\u00adcols [32] to Skeme [25]. The completeness result does not however mean that \nthe protocol checker constitutes the only useful instance of the general type system. In particular, \nsimpler instances are eas\u00adier to use in manual reasoning. Presenting those instances by type rules (rather \nthan logic programs) is often quite con\u00advenient. Moreover, the checker does not always terminate, in \nparticular when it tries to establish properties of an in.\u00adnite family of types; in other instances of \nthe type system, we may merge those types (obtaining some .nite proofs at the cost of completeness). \nSimilarly, the (rare) case where a set def(g) is large or in.nite is more problematic for the checker \nthan for the general type system. Finally, the gen\u00aderal type system may be combined with other type-based \nanalyses for proving protocol properties other than secrecy (e.g., as in [20]).  8. CONCLUSION This \npaper makes two main contributions: (1) a type system for expressing and proving secrecy prop\u00aderties \nof security protocols with a generic treatment of many cryptographic operations; (2) a tight relation \nbetween two useful but super.cially quite di.erent approaches to protocol analysis, respec\u00adtively embodied \nin the type system and in a logic\u00adprogramming tool. The .rst contribution can be seen as the continuation \nof a line of work on static analyses for security, discussed in the introduction. So far, those static \nanalyses have been devel\u00adoped successfully but often in ad hoc ways. We believe that type systems such \nas ours not only are useful in examples but also shed light on the constraints and the design space for \nstatic analyses. In the last few years, there has been a vigorous prolif\u00aderation of frameworks and techniques \nfor reasoning about security protocols. Their relations are seldom explicit or obvious. Moreover, little \nis known about how to combine techniques. The second contribution is part of a broader e.ort to understand \nthose relations. Previous work (in par\u00adticular [18]) suggests connections between (untyped) process calculi \nand logic-programming notations for protocols; we go further by relating proof methods in those two worlds. \nSuch connections are perhaps the start of a healthy consolidation. 9. REFERENCES [1] M. Abadi. Secrecy \nby typing in security protocols. Journal of the ACM, 46(5):749 786, Sept. 1999. [2] M. Abadi. Security \nprotocols and their properties. In F. Bauer and R. Steinbrueggen, editors, Foundations of Secure Computation, \nNATO Science Series, pages 39 60. IOS Press, 2000. Volume for the 20th International Summer School on \nFoundations of Secure Computation, held in Marktoberdorf, Germany (1999).  [3] M. Abadi, A. Banerjee, \nN. Heintze, and J. G. Riecke. A core calculus of dependency. In Proceedings of the 26th ACM Symposium \non Principles of Programming Languages, pages 147 160, Jan. 1999. [4] M. Abadi and B. Blanchet. Secrecy \ntypes for asymmetric communication. In F. Honsell and M. Miculan, editors, Foundations of Software Science \nand Computation Structures (FoSSaCS 2001), volume 2030 of Lecture Notes in Computer Science, pages 25 \n41. Springer-Verlag, Apr. 2001. [5] M. Abadi and C. Fournet. Mobile values, new names, and secure communication. \nIn Proceedings of the 28th Annual ACM Symposium on Principles of Programming Languages (POPL 01), pages \n104 115, Jan. 2001. [6] M. Abadi and A. D. Gordon. A calculus for cryptographic protocols: The spi calculus. \nInformation and Computation, 148(1):1 70, Jan. 1999. An extended version appeared as Digital Equipment \nCorporation Systems Research Center report No. 149, January 1998. [7] R. M. Amadio and D. Lugiez. On \nthe reachability problem in cryptographic protocols. In C. Palamidessi, editor, CONCUR 2000: Concurrency \nTheory (11th International Conference), volume 1877 of Lecture Notes in Computer Science, pages 380 394. \nSpringer-Verlag, Aug. 2000. [8] B. Blanchet. An e.cient cryptographic protocol veri.er based on Prolog \nrules. In 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 82 96, June 2001. [9] C. \nBodei. Security Issues in Process Calculi. PhD thesis, Universit`a di Pisa, Jan. 2000. [10] C. Bodei, \nP. Degano, F. Nielson, and H. Nielson. Control .ow analysis for the p-calculus. In CONCUR 98: Concurrency \nTheory, volume 1466 of Lecture Notes in Computer Science, pages 84 98. Springer Verlag, Sept. 1998. [11] \nL. Cardelli, G. Ghelli, and A. D. Gordon. Secrecy and group creation. In C. Palamidessi, editor, CONCUR \n2000: Concurrency Theory, volume 1877 of Lecture Notes in Computer Science, pages 365 379. Springer-Verlag, \nAug. 2000. [12] I. Cervesato, N. A. Durgin, P. D. Lincoln, J. C. Mitchell, and A. Scedrov. A meta-notation \nfor protocol analysis. In Proceedings of the 12th IEEE Computer Security Foundations Workshop (CSFW 99), \npages 55 69, June 1999. [13] M. Dam. Proving trust in systems of second-order processes. In Proceedings \nof the 31th Hawaii International Conference on System Sciences, volume VII, pages 255 264, 1998. [14] \nM. Debbabi, M. Mejri, N. Tawbi, and I. Yahmadi. A new algorithm for the automatic veri.cation of authentication \nprotocols: From speci.cations to .aws and attack scenarios. In Proceedings of the DIMACS Workshop on \nDesign and Formal Veri.cation of Security Protocols, Rutgers University, New Jersey, Sept. 1997. [15] \nG. Denker, J. Meseguer, and C. Talcott. Protocol speci.cation and analysis in Maude. In N. Heintze and \nJ. Wing, editors, Proc. of Workshop on Formal Methods and Security Protocols, Indianapolis, Indiana, \n25 June 1998. [16] A. Durante, R. Focardi, and R. Gorrieri. CVS: A compiler for the analysis of cryptographic \nprotocols. In Proceedings of the 12th IEEE Computer Security Foundations Workshop (CSFW 99), pages 203 \n212, June 1999. [17] N. Durgin, J. Mitchell, and D. Pavlovic. A compositional logic for protocol correctness. \nIn 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 241 255, June 2001. [18] N. A. Durgin \nand J. C. Mitchell. Analysis of security protocols. In M. Broy and R. Steinbruggen, editors, Calculational \nSystem Design, pages 369 395. IOS Press, 1999. [19] R. Focardi and R. Gorrieri. The compositional security \nchecker: A tool for the veri.cation of information .ow security properties. IEEE Transactions on Software \nEngineering, 23(9), Sept. 1997. [20] A. Gordon and A. Je.rey. Authenticity by typing for security protocols. \nIn 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 145 159, June 2001. [21] N. Heintze \nand J. G. Riecke. The SLam calculus: programming with secrecy and integrity. In Proceedings of the 25th \nACM Symposium on Principles of Programming Languages, pages 365 377, 1998. [22] M. Hennessy and J. Riely. \nInformation .ow vs. resource access in the asynchronous pi-calculus. In Proceedings of the 27th International \nColloquium on Automata, Languages and Programming, Lecture Notes in Computer Science, pages 415 427. \nSpringer-Verlag, 2000. [23] K. Honda, V. Vasconcelos, and N. Yoshida. Secure information .ow as typed \nprocess behaviour. In G. Smolka, editor, Programming Languages and Systems: Proceedings of the 9th European \nSymposium on Programming (ESOP 2000), volume 1782 of Lecture Notes in Computer Science, pages 180 199. \nSpringer-Verlag, 2000. [24] R. Kemmerer, C. Meadows, and J. Millen. Three systems for cryptographic protocol \nanalysis. Journal of Cryptology, 7(2):79 130, Spring 1994. [25] H. Krawczyk. SKEME: A versatile secure \nkey exchange mechanism for internet. In Proceedings of the Internet Society Symposium on Network and \nDistributed Systems Security, Feb. 1996. Available at http://bilbo.isu.edu/sndss/sndss96.html. [26] P. \nLincoln, J. Mitchell, M. Mitchell, and A. Scedrov. A probabilistic poly-time framework for protocol analysis. \nIn Proceedings of the Fifth ACM Conference on Computer and Communications Security, pages 112 121, 1998. \n[27] G. Lowe. Breaking and .xing the Needham-Schroeder public-key protocol using FDR. In Tools and Algorithms \nfor the Construction and Analysis of Systems, volume 1055 of Lecture Notes in Computer Science, pages \n147 166. Springer Verlag, 1996. [28] C. Meadows. Panel on languages for formal speci.cation of security \nprotocols. In Proceedings of the 10th IEEE Computer Security Foundations Workshop, page 96, 1997. [29] \nR. Milner. Communicating and Mobile Systems: the Pi-Calculus. Cambridge University Press, June 1999. \n[30] J. H. Morris, Jr. Protection in programming languages. Communications of the ACM, 16(1):15 21, Jan. \n1973. [31] A. C. Myers. JFlow: Practical mostly-static information .ow control. In Proceedings of the \n26th ACM Symposium on Principles of Programming Languages, pages 228 241, Jan. 1999. [32] R. M. Needham \nand M. D. Schroeder. Using encryption for authentication in large networks of computers. Commun. ACM, \n21(12):993 999, Dec. 1978. [33] L. C. Paulson. The inductive approach to verifying cryptographic protocols. \nJournal of Computer Security, 6(1 2):85 128, 1998. [34] E. Sumii and B. C. Pierce. Logical relations \nand encryption (Extended abstract). In 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages \n256 269, June 2001. [35] D. Volpano, C. Irvine, and G. Smith. A sound type system for secure .ow analysis. \nJournal of Computer Security, 4:167 187, 1996. [36] C. Weidenbach. Towards an automatic analysis of security \nprotocols in .rst-order logic. In H. Ganzinger, editor, 16th International Conference on Automated Deduction \n(CADE-16), volume 1632 of Lecture Notes in Arti.cial Intelligence, pages 314 328. Springer-Verlag, July \n1999. APPENDIX  Function f for the completeness proof This appendix describes the construction of a \nfunction f on types that plays a role in the completeness proof, as ex\u00adplained in the main body of the \npaper. In order to prove completeness, we consider a closed pro\u00adcess P0, a name s, and a set of names \nS. We consider an instance of the general type system, and assume that this instance proves (by Theorem \n1) that P0 preserves the se\u00adcrecy of s from S. That is, we assume that, in this instance, there exists \nan environment E0 such that E0 f P0, E0 f s:T with T/. TPublic, and S = {a | E0 f a: T and T . TPublic}. \nWithout loss of generality, we may assume that E0 contains only names. We .x a proof of E0 f P0 for the \nrest of this argument. Intuitively, a well-chosen environment for a subprocess P of P0 is an environment \nthat can be used to type P in a standard proof that P0 is well-typed, using the type sys\u00adtem associated \nwith the protocol checker in section 7.2. A standard proof is one in which types introduced by the rule \n(Restriction) for (.a)Q are of the form a[Tc1,...,Tcn], where Tc1,...,Tcn are the types of the variables \nbound by inputs above (.a)Q in P0 s syntax tree. A(Tc1,...,Tcn)-well-chosen environment for P is simi\u00adlar, \nexcept that the parameters (Tc1,...,Tcn) indicate which types should be chosen for the variables bound \nby inputs. Note that a (Tc1,...,Tcn)-well-chosen environment for P does not always exist, for example \nwhen the number of pa\u00adrameters (Tc1,...,Tcn) does not correspond to the number of variables bound by \ninputs above P in P0. De.nition 2. Let Tc1,...,Tcn be closed patterns. A (Tc1,...,Tcn)-well-chosen environment \nfor an occurrence of a subprocess of P0 is de.ned as follows: A ()-well-chosen environment for P0 is \n.0 .= {a . a[] | (a: T) . E0}. If Ec is a (Tc1,...,Tcn)-well-chosen environment for M(N).P, then Ec \nisa(Tc1,...,Tcn)-well-chosen envi\u00adronment for P.  If Ec is a (Tc1,...,Tcn)-well-chosen environment for \nM(x).P, then Ec[x..Tcn+1]isa(Tc1,...,Tcn,Tcn+1)\u00adwell-chosen environment for P.  If Ec isa(Tc1,...,Tcn)-well-chosen \nenvironment for P |Q, then Ec isa(Tc1,...,Tcn)-well-chosen environment for P and Q.  If Ec is a (Tc1,...,Tcn)-well-chosen \nenvironment for !P, then Ec isa(Tc1,...,Tcn)-well-chosen environment for P.  If Ec is a (Tc1,...,Tcn)-well-chosen \nenvironment for (.a)P, then Ec[a.c1,...,Tcnc1,...,Tcn)\u00ad  . a[T]] is a (T well-chosen environment for \nP. If Ec is a (Tc1,...,Tcn)-well-chosen environment for let x = g(M1,...,Mn) in P else Q, then Ec is \na (Tc1,...,Tcn)-well-chosen environment for Q, and if in addition there exists an equation g(M1' ,...,Mn' \n)= M ' in def(g) and a substitution s such that for all i . {1,...,n}, sMi ' = Ec(Mi), then Ec[x .. sM \n' ]isa (Tc1,...,Tcn)-well-chosen environment for P. Finally, the function f is de.ned so that if a type \nTc ap\u00adpears in a standard proof that P0 is well-typed using the type system associated with the protocol \nchecker in section 7.2, then f(Tc) appears in the corresponding place in the proof of E0 f P0 in the \ninstance of the general type system under consideration. De.nition 3. The partial function f: Tc . T \nfrom types of the protocol checker to types of the instance of the general type system is de.ned by induction \non the term Tc: f(f(Tc1,...,Tcn)) = Of (f(Tc1),...,f(Tcn)). (There\u00adfore, f(f(Tc1,...,Tcn)) is unde.ned \nif Of (f(Tc1),..., f(Tcn)) is unde.ned.)  If E0 f a: T, then f(a[]) = T.  When a is bound by a restriction \nin P0, we de.ne f(a[Tc1,...,Tcn]) as follows. Without loss of gener\u00adality, we may assume that a is bound \nexactly once. Let P be the process such that (.a)P is a subprocess of P0. Let Ec bea(Tc1,...,Tcn)-well-chosen \nenvironment for (.a)P. Let E = f. Ec. Then f(a[Tc1,...,Tcn]) =  T ' where T ' is such that E,a: T ' \nf P is a judgment used to prove E0 f P0. There is at most one such judgment, so T ' is unique. Ifa (Tc1,...,Tcn)-well-chosen \nenvironment for (.a)P does not exist, or if no suitable judgment E,a: T ' f P appears in the proof of \nE0 f P0, then f(a[Tc1,...,Tcn]) is unde.ned. This de.nition is recursive, and we can check that it is \nwell-founded using the following ordering. Names are or\u00addered by a<b if a is bound above b in P0,or a \nis free and b is bound in P0. The ordering on terms is then the lex\u00adicographic ordering of pairs containing \nas .rst component the multiset of names that appear in the term and as sec\u00adond component the size of \nthe term. In the .rst case of the de.nition of f, the .rst component is constant and the sec\u00adond one \ndecreases. In the third case, the .rst component decreases: when de.ning f(a[Tc1,...,Tcn]), in the recur\u00adsive \ncalls used to compute f . Ec, the name a at the top of the term has disappeared, and the only names that \nhave appeared due to the computation of the well-chosen envi\u00adronment are free names or names bound above \na (therefore names smaller than a). \n\t\t\t", "proc_id": "503272", "abstract": "We study and further develop two language-based techniques for analyzing security protocols. One is based on a typed process calculus; the other, on untyped logic programs. Both focus on secrecy properties. We contribute to these two techniques, in particular by extending the former with a flexible, generic treatment of many cryptographic operations. We also establish an equivalence between the two techniques.", "authors": [{"name": "Mart&#237;n Abadi", "author_profile_id": "81100547147", "affiliation": "University of California, Santa Cruz", "person_id": "PP39047996", "email_address": "", "orcid_id": ""}, {"name": "Bruno Blanchet", "author_profile_id": "81100497004", "affiliation": "Ecole Normale Sup&#233;rieure, Paris", "person_id": "PP14173660", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/503272.503277", "year": "2002", "article_id": "503277", "conference": "POPL", "title": "Analyzing security protocols with secrecy types and logic programs", "url": "http://dl.acm.org/citation.cfm?id=503277"}