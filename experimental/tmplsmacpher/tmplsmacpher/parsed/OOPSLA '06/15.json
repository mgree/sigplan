{"article_publication_date": "10-16-2006", "fulltext": "\n A Flexible Framework for Implementing Software Transactional Memory Maurice Herlihy Victor Luchangco \nMark Moir Brown University Sun Microsystems Laboratories Sun Microsystems Laboratories mph@cs.brown.edu \nvictor.luchangco@sun.com mark.moir@sun.com Abstract We describe DSTM2, a JavaTM software library that \nprovides a .exible framework for implementing object-based software trans\u00adactional memory (STM). The \nlibrary uses transactional factories to transform sequential (unsynchronized) classes into atomic (transac\u00adtionally \nsynchronized) ones, providing a substantial improvement over the awkward programming interface of our \nprevious DSTM library. Furthermore, researchers can experiment with alternative STM mechanisms by providing \ntheir own factories. We demon\u00adstrate this .exibility by presenting two factories: one that uses es\u00adsentially \nthe same mechanisms as the original DSTM (with some enhancements), and another that uses a completely \ndifferent ap\u00adproach. Because DSTM2 is packaged as a Java library, a wide range of programmers can easily \ntry it out, and the community can begin to gain experience with transactional programming. Furthermore, \nresearchers will be able to use the body of transactional programs that arises from this community experience \nto test and evaluate different STM mechanisms simply by supplying new transactional factories. We believe \nthat this .exible approach will help to build consensus about the best ways to implement transactions, \nand will avoid the premature lock-in that may arise if STM mechanisms are baked into compilers before \nsuch experimentation is done. Categories and Subject Descriptors D.1.3 [Programming Tech\u00adniques]: Concurrent \nProgramming parallel programming; D.1.5 [Programming Techniques]: Object-oriented Programming; D.2.11 \n[Software Engineering]: Software Architectures; D.3.3 [Program\u00adming Languages]: Language Constructs and \nFeatures concurrent programming structures; F.1.2 [Computation by Abstract De\u00advices]: Modes of Computation \nparallelism and concurrency General Terms Algorithms, Experimentation, Languages. Keywords software transactional \nmemory (STM), transactions, concurrency, atomicity, obstruction-free factory, shadow factory, Java library. \n1. Introduction The major chip manufacturers have, for the time being, given up trying to make processors \nrun faster. Moore s law has not been re\u00adpealed: each year, more and more transistors .t into the same \nspace, Copyright is held by Sun Microsystems, Inc. OOPSLA 06 October 22 26, 2006, Portland, Oregon, USA. \nACM 1-59593-348-4/06/0010. but clock speed cannot be increased without overheating. Instead, attention \nis quickly turning toward chip multiprocessing (CMP), in which multiple computing cores are included \non each proces\u00adsor chip. These trends mean that, in the medium term, advances in technology will provide \nincreased parallelism, but not increased single-thread performance. As a result, system designers and \nsoft\u00adware engineers can no longer rely on increasing clock speed to hide software bloat. Instead, they \nmust learn to make effective use of in\u00adcreasing parallelism. This adaptation will not be easy. With today \ns programming practices, programmers typically rely on a combination of locks and conditions, such as \nmonitors, to prevent concurrent access by different threads to the same shared data. Although this approach \nsimpli.es reasoning about interactions by allowing programmers to treat sections of code as atomic , \nit nonetheless suffers from a number of severe shortcomings. First, programmers must decide between coarse-grained \nlock\u00ading, in which a large data structure is protected by a single lock, and .ne-grained locking, in \nwhich a lock is associated with each component of the data structure. Coarse-grained locking is simple, \nbut permits little or no concurrency, thereby preventing the pro\u00adgram from exploiting multiple processing \ncores. By contrast, .ne\u00adgrained locking is substantially more complicated because of the need to ensure \nthat threads acquire all necessary locks (and only those, for good performance), and because of the need \nto avoid deadlock when acquiring multiple locks. The decision is further complicated by the fact that \nthe best engineering solution may be platform-dependent, varying with different machine sizes, work\u00adloads, \nand so on, making it dif.cult to write code that is both scal\u00adable and portable. Second, conventional \nlocking provides poor support for code composition and reuse. For example, consider a lock-based hash \ntable that provides atomic insert and delete methods. Ideally, it should be easy to move an element atomically \nfrom one table to another, but this kind of composition simply does not work. If the table methods synchronize \ninternally, then there is no way to acquire and hold both locks simultaneously. If the tables export \ntheir locks, then modularity and safety are compromised. Finally, basic issues, such as the mapping from \nlocks to data that is, which locks protect which data and the order in which locks must be acquired and \nreleased, are based on convention, and violations are notoriously dif.cult to detect and debug. For these \nand other reasons, today s software practices make concurrent programs too dif.cult to develop, debug, \nunderstand, and maintain. In reaction to these problems, the transactional model of syn\u00adchronization \nhas received attention as an alternative programming model. In transactional programming, code that accesses \nshared memory is divided into transactions, which are intended to be ex\u00adecuted atomically: operations \nof two different transactions should not appear to be interleaved. A transaction may commit,inwhich case \nall its operations appear to take place atomically, or abort, in which case its operations appear not \nto have taken place at all. If two transactions con.ict that is, if they access the same ob\u00adject, and \nat least one of them writes it then one must wait until the other either commits or aborts. An aborted \ntransaction is typi\u00adcally retried until it commits, usually after taking some measures to reduce contention \nand avoid further con.icts. This approach has been investigated in hardware [1, 7, 13, 19, 20], in software \n[8, 9, 12, 15, 16, 18, 24], and in schemes that mix hardware and software [3, 23]. Here we focus on software \nschemes. As an application programming interface (API), software trans\u00adactional memory (STM) promises \nto alleviate the dif.culty of pro\u00adgramming using conventional mechanisms such as locks and con\u00addition \nvariables. One of the principal challenges in understanding how to make STM effective is how to design \nand evaluate effective run-time mechanisms for transactional synchronization, including how to establish \nand restore checkpoints, how to detect synchro\u00adnization con.icts, and how to guarantee progress. There \nis no short\u00adage of potential mechanisms, but much remains to be learned about how such mechanisms interact, \nand especially how they are af\u00adfected by characteristics of systems and applications. The commu\u00adnity \nneeds more experience with applications written in a trans\u00adactional style before we can reach consensus \non the best ways to support this API. This paper describes the DSTM2 software transactional mem\u00adory library, \na collection of JavaTM packages that supports a trans\u00adactional API. This library can be retrieved through \na link from our group s webpage [25]. We hope that this simple, self-contained open-source library will \nencourage researchers to implement trans\u00adactional applications, and to experiment with alternative implemen\u00adtations \nof key transactional mechanisms. As the name suggests, DSTM2 is our second software transactional memory \npackage. The earlier DSTM design [12] focused on the basic model of computa\u00adtion and on run-time techniques, \nwith little attention to providing a safe, convenient, and .exible API for application programmers. DSTM2 \nincorporates the lessons we learned from DSTM. Designing a software transactional memory library is more \ncomplex than designing conventional libraries. The effect of trans\u00adactional synchronization is pervasive: \nthe need to synchronize ac\u00adcess to shared objects affects how classes are de.ned, and the need to commit \nand abort transactions affects normal control .ow. An STM library for a standard language must do more \nthan simply pro\u00advide a collection of useful objects and algorithms. The challenge is also to provide \na nearly seamless view of transaction synchroniza\u00adtion and recovery, with a minimum of pitfalls. Guiding \nthe design of DSTM2 is our belief that it is premature to commit to speci.c implementation techniques. \nExisting STM systems provide similar functionality, but there is little or no con\u00adsensus on the best \nways to implement key run-time features such as con.ict detection and resolution, or transaction synchronization \nand recovery. A key aspect of DSTM2 is that it provides users the ability to plug in their own synchronization \nand recovery mecha\u00adnisms in the form of transactional factories that transform stylized sequential interfaces \ninto transactionally synchronized data struc\u00adtures. Like its predecessor, DSTM2 also allows users to \ncustomize their techniques for managing contention. This modular decomposition is intended to make it \nas easy as possible to modify or replace those modules most likely to be the targets of experiment. It \nallows users to customize the underlying run-time executive to match the characteristics of the application, \na valuable property if, as experience suggests, no single run-time mechanism is ideal for all kinds of \napplications. We focus on a Java library, instead of a compiler, because a library is easier to distribute \nand provides greater freedom to experiment. (For examples of language-based STM systems, see Harris et \nal. [9] or Saha et al. [23]). Eventually, if the transactional API wins wide acceptance, we can expect \nlanguage and compiler support for the model. A language is safer and easier to use than a library, and \na compiler can perform many nonlocal optimizations that would be dif.cult or impossible in a library. \nNevertheless, a library for a standard, widely used language has the advantages that it can be used right \nnow, without installing proprietary software or waiting for language-design committees, and that it is \nmore .exible and can be integrated more easily into other research projects. The remainder of the paper \nis organized as follows. In Section 2, we give an overview of the factory approach to implementing STM, \nand present the DSTM2 API through a simple example. In Sec\u00adtion 3, we describe the factory approach in \nmore detail, and present a transactional factory that uses essentially the same mechanisms as the original \nDSTM, as well as an alternative transactional fac\u00adtory that demonstrates the .exibility of our approach. \nWe present the results of preliminary performance experiments in Section 4. We discuss related work in \nSection 5 and conclude in Section 6. 2. The DSTM2 Library The DSTM2 library assumes that multiple concurrent \nthreads share data objects. The DSTM2 library provides a new kind of thread that can execute transactions, \nwhich access shared atomic objects. DSTM2 threads provide methods for creating new atomic classes and \nexecuting transactions. Perhaps the most novel aspect of DSTM2 is the way atomic classes are de.ned. \nFor each atomic class, the programmer de.nes a stylized sequential interface, a named collection of method \nsig\u00adnatures satisfying certain simple consistency conditions. The pro\u00adgrammer then passes this interface \nto the constructor of a trans\u00adactional factory, which uses a combination of re.ection and run\u00adtime class \nsynthesis to create an anonymous class implementing the original interface, whose methods are transactionally \nsynchro\u00adnized; the constructed factory creates instances of this anonymous class. Re.ection and run-time \nclass synthesis occur only once per atomic class (that is, when its factory is constructed); they do \nnot occur each time an atomic object is created using that factory. Transactional factories embody different \ntransactional synchro\u00adnization and recovery techniques. Later in this paper, we describe two factory \nclasses provided by the DSTM2 library, which employ very different techniques (e.g., one is nonblocking, \nthe other uses locks). Programmers may also de.ne their own factories; indeed, enabling them to do so \nis one of the main motivations for this work. Because the interface is passed to the transactional factory \nconstructor, the choice of how to implement atomic objects is a run-time decision, which is intended \nto facilitate experimentation with different synchronization and recovery techniques. DSTM2 provides \ndirect support for simple atomic classes that provide transactional get and set methods for virtual .elds \n(as well as optional escape methods described below). As illustrated below, it is straightforward to \nimplement more complex data struc\u00adtures, such as lists or skip lists, on top of such simple atomic types. \nDSTM2 also provides the ability to register methods (in the form of Callable<Boolean> objects) to be \ncalled when important transactional events occur. For example, one can register a method that can veto \na transaction s attempt to commit (the so-called val\u00adidation step). One can also register methods to \nrun immediately after a transaction commits or aborts (useful for cleaning up data structures). We have \nfound this service, which as far as we know is not supported by any other STM library, to be essential \nto giving factories the .exibility needed to implement a range of strategies. As explained later, it \nis also key to supporting certain built-in trans\u00adactional libraries, such as transactional arrays. Finally, \nDSTM2 provides support for user-de.ned contention managers. This was a focus of our previous version \nof DSTM [12], @atomic public interface INode {int getValue (); void setValue ( int value ); INode getNext \n(); void setNext(INode value); } Figure 1. Interface for an atomic class and also of work by other researchers \n(e.g., [6, 14]), so we do not focus on it in this paper. The initial release of DSTM2 does not support \ncertain advanced features such as nested transactions [21] or conditional waiting [9, 10]. We think these \nfeatures are important in the long run, and intend to support them in the future. The DSTM2 library requires \nthe ability to construct classes at run time. We currently use a combination of re.ection, class loaders, \nand the byte-code engineering library (BCEL) [4], a rich collection of packages for synthesizing code \nand classes at run time under program control. This approach may not be well-suited to languages such \nas C or C++ that lack support for re.ection or run\u00adtime code generation. In the rest of this section, \nwe introduce the basic features by example, and discuss some of the design decisions we made based on \nour experience with the original DSTM library. 2.1 The DSTM2 API Perhaps the easiest way to introduce \nthe DSTM2 API is by exam\u00adple. In this section, we walk through the construction of a simple linked-list \nbenchmark, in which transactions add, remove, and look up entries in a sorted list of integers. The .rst \nstep is to de.ne the class implementing list nodes. Be\u00adcause list nodes will be read and modi.ed by concurrent \ntransac\u00adtions, they must be explicitly declared to be atomic by providing an interface for the object \nto satisfy. Figure 1 shows the interface we would use for a list node. The interface declaration is prefaced \nby the @atomic attribute, which is an explicit declaration that objects satisfying this interface should \nbe safe to share among concurrent transactions. An atomic interface de.nes one or more properties,where \na property of type T is a pair of matching method signatures: T getField {}; void setField (T value ); \nThink of a property as de.ning a virtual .eld, in this case, named field of type T. The interface in \nFigure 1 de.nes two properties: value of type int,and next of type INode. As mentioned earlier, and for \nreasons explained later, each property must have a type that is either scalar a simple immutable type \nsuch as a primitive type or its wrapper class or an interface satisfying the @atomic attribute. (In addition \nto de.ning a set of properties, an atomic interface may de.ne certain other specialized methods, which \nwe discuss later.) The atomic interface is passed to a transactional factory con\u00adstructor, which returns \na factory capable of creating list nodes. The DSTM2 library provides several transactional factories, \nand researchers are encouraged to write their own to investigate alterna\u00adtive STM implementations. Each \nDSTM2 thread maintains a trans\u00adactional factory (which can be, but typically is not, changed at run\u00adtime), \nwhich can be applied to the INode interface as follows: Factory<INode> factory = dstm2.Thread.makeFactory(INode.class \n); The factory itself provides a single method: public class List extends IntSetBenchmark { static \nFactory<INode> factory = Thread.makeFactory(INode.class ); public boolean insert ( int v) {INode newNode \n= factory. create (); newNode.setValue(v); INode prevNode = this . root ; INode currNode = prevNode.getNext \n(); while (currNode.getValue () < v) { prevNode = currNode; currNode = prevNode.getNext (); } if (currNode.getValue \n() == v) { return false ;  } else { newNode.setNext(prevNode.getNext()); prevNode.setNext(newNode); \nreturn true; } } ... } Figure 2. A transaction INode node = factory . create (); This method creates \nan object of an anonymous class implementing the INode interface. The object is then initialized by calling \nthe properties set methods. Transactions are written as methods. Figure 2 shows an exam\u00adple transaction \nthat inserts a value in a list. This example illustrates an important property of DSTM2: a transaction \nis almost identi\u00adcal to a sequential program for inserting an object in a list. The principal differences \nare that nodes are created by calling a factory create() method, not by calling new, and that property \nget and set methods are used instead of .eld accesses. Transactions (or methods used within transactions) \nshould en\u00adsure that all shared objects are atomic, since the DSTM2 library does not provide synchronization \nand recovery for non-atomic ob\u00adjects. This restriction is analogous to the conventional lock-based discipline \nthat requires that all objects shared by concurrent threads be thread-safe (that is, locked while in \nuse). However, because DSTM2 manages synchronization for atomic objects, there is no need to associate \nlocks with objects or to avoid deadlocks. The transaction itself is invoked by creating a Callable<T> \nobject (that is, one that provides a T call() method), and passing it to the Thread.doIt(...) method. \nresult = Thread.doIt(new Callable<Boolean>() { public Boolean call () { return intSet . insert (value \n); } }); The doIt method, shown in Figure 3 (slightly simpli.ed for readability), ensures that transactions \nare properly nested. It re\u00adplaces an earlier API in which programmers explicitly called meth\u00adods to begin \nand end transactions. The doIt method repeatedly retries a transaction until it either commits or throws \nan unexpected exception. The private beginTransaction method called by doIt al\u00adlocates a new transaction \ndescriptor, which has a status .eld public static <T> T doIt(Callable<T> xaction) {Tresult = null ; while \n(!Thread.stop) { beginTransaction (); try { result = xaction . call (); } catch (AbortedException d) \n{ } catch (Exception e) { throw new PanicException( Unhandled exception + e); } if (commitTransaction()) \n{ return result ; }}} Figure 3. The transaction retry loop that indicates whether the transaction is \ncommitted, aborted, or still active. To commit a transaction, a thread attempts to change its descriptor \ns status .eld from active to committed using the atomic compareAndSet method (of AtomicReference from \njava.util.concurrent.atomic). The dstm2.Thread package exports the descriptor for the currently active \ntransaction (if any), and factories typically use references to transaction descriptors to keep track \nof which transactions are reading or writing a particular object. Property calls that occur outside a \ntransaction have the same effect as regular, unsynchronized method calls. Such calls are not thread-safe, \nbut are useful for initializing data objects before run\u00adning benchmarks and running correctness checks \nafterwards. 2.2 Lessons The design of this API was in.uenced by the lessons learned from the earlier \nversion of DSTM. DSTM used a wrapper API, in which a Node object is kept inside a transactional container, \ncalled a TMObject<Node> object. One could create an atomic Node object by calling TMObject<Node> tmNode \n= new TMObject<Node>(new Node()); To open the object for reading or writing: Node rNode = tmNode.openRead(); \n// for reading ... Node wNode = tmNode.openWrite(); // for writing Although this API was adequate for \nexperimental purposes, it has several pitfalls that make it less than ideal for widespread use. First, \nthe programmer must not modify the object referenced by rNode. Second, if wNode is opened before rNode, \nthen changes to wNode are visible through rNode, but not if they are opened in the opposite order, which \ncan cause confusion. Third, the rNode and wNode references shown above are meaningful only during the \nlifetime of the transaction in which the calls to open occurred, so the programmer must be careful that \nthese references do not linger. Furthermore, programmers must be aware of the container\u00adbased STM implementation \nwhen declaring classes. For example, if Node is a list node, then the reference to the next node must \nbe a container, not another node: class Node { int value ; TMObject<Node> next; // not Node } Finally, \nthe implementor of the Node class must provide a clone() method that does a shallow copy of the object \nfor creating check\u00adpoints. The list example shows that DSTM2 substantially improves on the programming \ninterface of DSTM. The key to improving trans\u00adparency lies in the factory approach to transactional synchroniza\u00adtion, \nwhich allows a straightforward transformation from .eld ac\u00adcesses to method calls. Another advantage \nis that there is no need to de.ne a class-speci.c clone() method; such methods, if needed, can be synthesized \nby the factory. Although encapsulating transactions in Callable<T> objects may seem awkward at .rst, \nit has substantial advantages over the approach of our original DSTM library. In that approach, trans\u00adactions \nare delimited by explicit calls to methods to begin and end transactions, and the call to end a transaction \nreturns a condition in\u00addicating whether the transaction had committed. The principal dis\u00adadvantage of \nthis approach is that the application programmer was in charge of retrying aborted transactions, so syntactically, \nevery transaction was a try/finally block within an unbounded loop. Moreover, this structure contains \na subtle pitfall: if transactions can be nested, then a transaction might repeatedly abort because its \npar\u00adent transaction has already aborted. It follows that ending a trans\u00adaction must return one of three \nconditions: (1) the transaction com\u00admitted, or (2) the transaction failed, but can be retried, or (3) \nthe transaction failed, and there is no point in retrying. Programming in this style was tiresome and \nerror-prone.   3. Transactional Factories In this section, we describe in more detail the factory approach \nat the heart of the DSTM2 library. We place transactional synchronization within method calls be\u00adcause \nthere is no easy way to intercept .eld accesses directly. De.n\u00ading atomic types by an interface has the \nadvantage that each fac\u00adtory is free to provide its own implementations for the methods de\u00adclared. Putting \nproperty de.nitions (that is, matching stylized set and get methods) in the interface has the advantage \nthat the in\u00adtended semantics of property set and get methods are clear, while the implementation of this \nsemantics is left up to the factory, and necessary syntactic consistency conditions are easily checked \n(via re.ection). Because all property types are required to be scalar or @atomic, a factory can checkpoint \nany atomic object s state sim\u00adply by performing a shallow copy , that is, copying .eld values but not \nthe objects to which they refer. The Factory<T> interface can be implemented by more than one class. \nIn fact, it is possible to mix and match different factory implementations, even within the same program, \nas long as they agree on the order in which transactions appear to take effect. The factories provided \nby DSTM2 are compatible in this sense. This .exibility is useful for experimentation. For example, one \ncan run the same program repeatedly with different factories to test their relative performance (see \nSection 4). One can also use different factories for different classes, or switch dynamically among fac\u00adtories \nin response to changes in load or environment. To pick an extreme example, one can construct a linked \nlist in which different nodes, all satisfying the same @atomic interface, were created by different compatible \nfactories. As noted in earlier work [2, 12], some applications may ben\u00ade.t from certain escape mechanisms \n. For example, applications that scan through a list can reduce the level of synchronization con\u00ad.ict \nby releasing list nodes whose contents have been read, but whose values do not affect the application \n[12]. Similarly, some ap\u00adplications can bene.t from a transactional snapshot that returns the value that \nwould have been returned had the object been read, allowing transactions to avoid reading unnecessary \ndata [2]. The details of these mechanisms do not concern us here; rather, they il\u00adlustrate an important \npoint: some applications are likely to require escape mechanisms, and the nature of these mechanisms \ncannot be foreseen. To address this issue, we partition the methods declared by @atomic interfaces into \ntwo classes: property declarations, with .xed syntax and semantics, and other methods, whose interpreta\u00adtions \nare speci.c to the factory. For example, if your application requires a release or snapshot method, then \nyou are free to declare one in your interface, but you must also provide a factory that can implement \nsuch a method. A transactional factory that encounters an unfamiliar method in an interface passed to \nit should throw an exception. Transactions are managed by the dstm2.Thread package, which provides the \nfollowing essential service: A transactional factory (or any other package) can register a method to \nbe called when a transaction (1) validates, checking whether it can com\u00admit, (2) aborts, discovering \nthat it cannot commit, or (3) commits, discovering that it can. This service allows any package to veto \ntransaction commitment, or to clean up in an application-speci.c wayoncommitorabort. As mentioned, the \ntype of every .eld of an atomic object must be scalar or atomic. This restriction means that the .elds \nof atomic objects cannot be arrays. Instead, DSTM2 provides an AtomicArray<T> class that can be used \nwhenever an array of T is needed. This class provides its own class-speci.c synchronization and recovery. \nEventually, we plan to provide a library of ef.cient basic types, analogous to the Java Collections Framework, \nto facil\u00aditate transactional applications. 3.1 The Base Factory The transactional factories provided \nby DSTM2 are subclasses of a BaseFactory class, which handles many tasks common to all transactional \nfactories. Programmers who implement their own factories are advised, but not required, to extend BaseFactory<T>. \nAs usual for Java subclasses, each factory constructor .rst calls the BaseFactory<T> constructor, which \ntakes a single argument, the class descriptor for the interface being implemented. The base class constructor \nuses re.ection to examine the interface, splitting the method declarations into property de.nitions and \nother meth\u00adods. It parses the property methods (checking, for example, that method names agree and that \nall types are @atomic or scalar). The property methods are stored in one symbol table, and the remaining \nuninterpreted methods are stored in another symbol table. When the base class constructor returns, these \ntables are available to the actual factory constructor. In each of the DSTM2 factories described in the \nnext sections, the .rst time a transaction accesses an object, it opens the object, checking whether \nthe object is in use by a con.icting transaction. If so, it consults a contention manager module [6, \n12, 14] to decide whether to abort the con.icting transaction, to wait for a while for the con.icting \ntransaction to commit, or to abort and restart itself. User-de.ned factories need not be organized in \nthis way. For example, one could provide a factory that checks for con.icts only when a transaction is \nabout to commit, in the style of the OSTM package of Harris and Fraser [8]. To illustrate how DSTM2 supports \nheterogeneous transactional factories, we now describe the implementations of two factories that represent \nvery different approaches to implementing atomic objects. We emphasize that these examples, different \nas they are, barely scratch the surface of possible factory implementations. Be\u00adcause these two factories \nrepresent thoroughly different approaches to transactional synchronization, it is instructive to observe \nhow they can both be accommodated in a single library. Figure 4. Structure of objects created by obstruction-free \nfactory  3.2 Obstruction-Free Factory A concurrent object is obstruction-free [11, 12] if any thread \nthat runs by itself for long enough makes progress (pragmatically, this condition means that any thread \nwill make progress if it runs for long enough without encountering a synchronization con.ict from a concurrent \nthread). Like stronger nonblocking progress condi\u00adtions such as lock-freedom and wait-freedom, obstruction-freedom \nensures that a halted thread cannot prevent other threads from mak\u00ading progress. The obstruction-free \nfactory is based on the obstruction-free algorithm introduced in the earlier version of DSTM [12]. Objects \ncreated by the obstruction-free factory are represented in three levels: a start cell holds a reference \nto a locator, which has three .elds: the old version of the object, the new version, and a reference \nto the transaction descriptor of the last transaction to open the object for writing (see Figure 4). \nThe logical value of the object is the old version if that transaction is still active or has aborted, \nand is the new version if it has committed. The factory synthesizes a clone() method that creates a shal\u00adlow \ncopy of an object. (In the earlier DSTM, the application pro\u00adgrammer was required to provide such a method.) \nThe .rst time a transaction invokes a set method for a .eld of a particular object, it opens the object \nfor writing. To do so, it .rst checks whether the previous writer committed or aborted. (As mentioned, \nif the previous writer is still active, then the transaction consults a contention manager to decide \nwhether to pause, allowing the other transaction a chance to complete, or whether to abort the other, \nallowing the transaction to proceed immediately.) If the pre\u00advious writer committed, the transaction \ncreates a new locator whose old version is the prior new version, and whose new version is a cloned copy \nof the old version, created using the factory s synthe\u00adsized clone method (see Figure 5). If the prior \ntransaction aborted, the transaction behaves similarly, except that the prior old version is used instead \nof the new one (see Figure 6). It then installs the new locator in the start cell, using the atomic compareAndSet \nmethod to ensure consistency in the face of con.icts with compet\u00ading transactions. This protocol ensures \nthat the logical value of the object does not change upon opening, and that the logical values of all \nobjects so opened by the transaction become the new versions when and if the transaction successfully \ncommits. Henceforth, this transaction s invocations of the object s set methods will update the new version \ndirectly. There are two variants of the obstruction-free factory that differ in the way they deal with \nread sharing. In the visible-read version of the factory, each object maintains a list of readers transaction \ndescriptors, and a transaction intending to modify the object must .rst abort them. In the invisible-read \nversion of the factory, each transaction keeps a private list of the values it has read. (As a rule, \nfactories keep transaction-local information as thread-local data, which is updated at important transitions \nsuch as transaction start, validation, commit, and abort.) When a transaction tries to commit, it must \nvalidate itself by checking that the values it read are still current. The invisible-read factory implements \nthis functionality by Figure 6. Opening an object created by the obstruction-free fac\u00adtory after recent \nabort   registering methods to be called at transaction validation (to check the currency of the values \nread), commit, and abort (to discard the list of values read).  3.3 Shadow Factory The shadow factory \nuses short critical sections to avoid the indi\u00adrection and allocation costs of the obstruction-free factory. \nThis ap\u00adproach substantially lowers the overhead associated with opening an object, but it may not be \nas well suited to multiprogrammed en\u00advironments (where multiple transactions share a single processor). \nAlthough this factory uses locks, these locks are managed by the system, and they are not held while \napplication code is executed, so the application programmer need not think about them. In future architectures, \nsome of these critical sections could be replaced by small hardware-supported transactions. For each \nproperty de.ned in the interface, the shadow factory generates both a .eld and a shadow .eld (Figure \n7). It synthesizes a backup() method that copies each regular .eld to its shadow, and a restore() method \nthat copies the values in the other direction. As usual, when a transaction opens an object, it checks \nwhether the last transaction to write the object committed or aborted. If it committed, then the object \ns .elds hold the current state, so the transaction calls backup() to copy the .elds to the shadow .elds \n(Figure 8). If, instead, the most recent writer aborted, then the shadow .elds hold the object s current \nstate, and the transaction calls restore() to copy the shadow .eld values back to the regular .elds (Figure \n9). Either way, the factory has established the ability to restore the object s state if the current \ntransaction aborts, and subsequent property calls directly read or write the object s .elds. Figure 7. \nStructure of objects created by shadow factory Figure 8. Opening an object created by shadow factory \nafter recent commit restore Figure 9. Opening an object created by shadow factory after recent abort \n 4. Performance We ran a number of simple benchmarks using the obstruction-free factory (with visible \nreads), the obstruction-free factory with invis\u00adible reads, and the shadow factory. We present results \nfor two of these benchmarks, to demonstrate how DSTM2 can be used exper\u00adimentally to evaluate the relative \nperformance of different factories. (A thorough analysis of factory performance would require many more \nexperiments, and would distract from the point of this paper.) All the results presented here are from \nruns on a Sun FireTM T2000 server. This server has a single UltraSPARC R . T1 processor containing eight \ncomputing cores, each with four hardware strands, clocked at 1200 MHz. Each four-strand core has a single \n8 KByte level-1 data cache and a single 16 KByte instruction cache. All eight cores share a single 3 \nMByte level-2 uni.ed cache, and a four\u00adway interleaved 32GB main memory. Data access latency ratios are \napproximately 1:8:50 for L1:L2:Memory accesses. 4.1 List Benchmark We .rst considered a simple linked \nlist using the same list node in\u00adterface shown in Figure 1. The list is sorted, and threads randomly \ninsert, remove, or search for numbers. Figure 10 shows the transac\u00adtions per second executed in a 20-second \nperiod, where the number of updates executed (insert and remove calls) varies is 100%, 50%, 2500 or none. \nThe shadow factory has substantially higher throughput than the obstruction-free factories, with the \nadvantage becoming slightly more pronounced as the percentage of updates decreases. 2000 The two obstruction-free \nfactories are roughly the same across the board.  4.2 Skip List Benchmark In the next benchmark, we \nreplace the list with a skip list [22]. The skip list node declaration, shown in Figure 11, illustrates \na use of Transactions/Second 1500 1000 ofree ofree.invisible shadow (a) With 100% updates the built-in \nAtomicArray class. As shown in Figure 12, the shadow 500 factory dominates the obstruction-free factory \nwhen the percentage of updates is high, but not when it is low. 0  5. Related Work The goal of our \nwork has been to provide a .exible framework for allowing a wide range of researchers to experiment with \ndifferent STM implementation mechanisms, while providing a reasonable API to encourage the development \nof a shared body of transac\u00adtional programs. We believe that our framework provides the .rst STM implementation \nwith a reasonable transactional programming points 3500 interface that does not depend on modi.cations \nto compilers and/or run-time systems. As explained in Section 2.2, our previous DSTM [12] is also 3000 \nimplemented as a library, but it does not provide an adequate 2500 programming interface to enable a \nsigni.cant body of transactional applications to be developed. Several other STM implementations that \nare based on DSTM inherit the same disadvantage, including the OSTM of Harris and Fraser [5] and the \nASTM of Marathe, Transactions/Second 2000 1500  Scherer, and Scott [17]. The WSTM implementation of \nHarris and 1000 Fraser [5, 8] similarly requires the programmer to access memory through explicit library \ncalls. 500 The SXM implementation of Herlihy [10] is a precursor to the 0 work reported here, and has \nmany of the same advantages. Most other STM implementations we are aware of are imple\u00admented via changes \nto compilers and/or run-time systems, and are therefore much less .exible and more dif.cult to distribute \nand modify than implementations based on our DSTM2 framework. These include: the conditional critical \nregion construct of Harris and Fraser [8], which is implemented through modi.cations to both the source\u00adto-bytecode \nand bytecode-to-native compilers for the Sun Java 18000 Virtual Machine for Research; 16000 the composable \nmemory transactions of Harris, Marlow, Peyton- Jones and Herlihy [9], which is implemented in the Glasgow \n 14000 Haskell compiler; 12000 the McRT STM of Saha et al. [23], which depends on special\u00ad 10000 ized \ncompiler and run-time support; and 8000  the transactional monitors of Welc, Jagannathan, and Hosking \n[26], which is implemented in a modi.ed version of the Jikes 6000 RVM compiler; and  the HybridTM of \nMoir et al. [3], which is designed to exploit  4000 2000 whatever hardware transactional support is \navailable, includes 0 an STM that runs on current systems but uses a modi.ed C/C++ compiler to achieve \nit.  6. Conclusions Our experience with DSTM2 and the original DSTM has con\u00advinced us that designing \na simple, relatively pitfall-free, (mostly) implementation-agnostic STM library is harder than it may \nlook. ofree ofree.invisible shadow (b) With 50% updates @atomic public interface Node { /** * Get array \nof nodes further along in the skip list . **/ public AtomicArray<Node> getForward(); /** * Set array \nof nodes further along in the skip list . **/ public void setForward(AtomicArray<Node> value); /** * \nGet node value . **/  public int getKey(); /** * Set node value . **/ public void setKey( int value \n); } Figure 11. Atomic skip list node The DSTM2 design described here is a result of our collective ex\u00adperience \ndesigning and working with earlier STM packages, both in Java programming language [12] and in C# [10]. \nWe hope that DSTM2 can be used as a common framework for experimenting with a variety of transactional \nalgorithms and implementations, sparing researchers from the time-consuming chore of construct\u00ading their \nown infrastructures, and providing a common ground for comparing alternatives. As noted, no prior work \ncombines the same degree of simplicity, portability, and .exibility. DSTM2 is object-based in the sense \nthat transactional synchro\u00adnization works by intercepting and synchronizing calls to object methods, \nleveraging the infrastructure provided by object-oriented languages. An alternative approach is word-based \nsynchronization, which works by intercepting and synchronizing direct memory ac\u00adcesses. Word-based synchronization \nis intended for environments in which one cannot rely on a high-level language to mediate mem\u00adory accesses, \nsuch as C and C++ programs that allow pointer arith\u00admetic. The engineering issues that arise in word-based \nSTM sys\u00adtems are quite different from those that arise in the object-based al\u00adternatives considered here. \nMost importantly, the lack of facilities for re.ection and run-time code generation in the environments \nfor which word-based STMs are typically designed mean that it is dif\u00ad.cult or impossible to implement \na word-based STM that provides a clean API without modifying the compiler. We think that DSTM2 provides \na unique combination of a sim\u00adple API and substantial .exibility to experiment with run-time mechanisms. \nThis .exibility follows from two innovations: trans\u00adactional factories allow user-de.ned synchronization \nalgorithms to intercept method calls, combined with the ability to register user\u00adde.ned methods to veto \ntransaction commitment and to clean up when transactions .nish.  References [1] C. Scott Ananian, Krste \nAsanovic, Bradley C. Kuszmaul, Charles E. Leiserson, and Sean Lie. Unbounded transactional memory. In \nProc. 11th International Symposium on High-Performance Computer Architecture, pages 316 327, February \n2005. 20000 18000 16000 14000 12000 10000 8000 6000 4000 2000 0 25000 20000 15000 10000 5000 0 35000 \n30000 25000 20000 15000 10000 5000 0 Transactions/Second Threads/Second Transactions/Second Figure 12. \nSkip list benchmark with different update rates ofree ofree.invisible shadow (a) With 100% updates \nofree ofree.invisible shadow (b) With 50% updates ofree ofree.invisible shadow (c) With no updates [2] \nC. Cole and M.P. Herlihy. Snapshots and software transactional memory. Science of Computer Programming, \n58(3):310 324, December 2005. [3] Peter Damron, Alexandra Fedorova, Yossi Lev, Victor Luchangco, Mark \nMoir, and Dan Nussbaum. Hybrid transactional memory. In Proceedings of the 12th International Conference \non Architectural Support for Programming Languages and Operating Systems (ASPLOS-XII), October 2006. \n[4] Apache Software Foundation. Byte-code engineering library. http://jakarta.apache.org/bcel/manual.html. \n [5] Keir Fraser and Tim Harris. Concurrent programming without locks. Submitted for publication. [6] \nRachid Guerraoui, Maurice Herlihy, and Bastian Pochon. Poly\u00admorphic contention management in SXM. In \nProceedings of the 19th International Conference on Distributed Computing, September 2005. [7] Lance \nHammond, Vicky Wong, Mike Chen, Brian D. Carlstrom, John D. Davis, Ben Hertzberg, Manohar K. Prabhu, \nHonggo Wijaya, Christos Kozyrakis, and Kunle Olukotun. Transactional memory coherence and consistency. \nIn Proc. 31st Annual International Symposium on Computer Architecture, June 2004. [8] Tim Harris and \nKeir Fraser. Language support for lightweight trans\u00adactions. In Proceedings of the 18th ACM SIGPLAN Conference \non Object-Oriented Programing, Systems, Languages, and Applications, pages 388 402, 2003. [9] Tim Harris, \nSimon Marlow, Simon Peyton Jones, and Maurice Herlihy. Composable memory transactions. In Proceedings \nof the 10th ACM SIGPLAN Symposisum on Principles and Practice of Parallel Programming, 2005. [10] Maurice \nHerlihy. http://www.cs.brown.edu/~mph/. [11] Maurice Herlihy, Victor Luchangco, and Mark Moir. Obstruction-free \nsynchronization: Double-ended queues as an example. In Proceedings of the 23rd International Conference \non Distributed Computing Systems (ICDCS), pages 522 529, May 2003. [12] Maurice Herlihy, Victor Luchangco, \nMark Moir, and William N. Scherer, III. Software transactional memory for dynamic-sized data structures. \nIn Proceedings of the 22nd Annual ACM Symposium on Principles of Distributed Computing, pages 92 101, \n2003. [13] Maurice Herlihy and J. Eliot B. Moss. Transactional memory: Architectural support for lock-free \ndata structures. In Proc. 20th Annual International Symposium on Computer Architecture, pages 289 300, \nMay 1993. [14] W. N. Scherer III and M. L. Scott. Contention management in dynamic software transactional \nmemory. In PODC Workshop on Concurrency and Synchronization in Java Programs, July 2004. [15] Amos Israeli \nand Lihu Rappoport. Disjoint-access-parallel imple\u00admentations of strong shared memory primitives. In \nProceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing, pages 151 160, 1994. \n[16] V. J. Marathe, W. N. Scherer III, and M. L. Scott. Design tradeoffs in modern software transactional \nmemory systems. In 7th Workshop on Languages, Compilers, and Run-time Support for Scalable Systems, October \n2004. [17] Virendra Marathe, William Scherer, and Michael Scott. Adaptive software transactional memory. \nIn Proceedings of the 19th Interna\u00adtional Conference on Distributed Computing, September 2005. [18] Mark \nMoir. Practical implementations of non-blocking synchroniza\u00adtion primitives. In Proceedings of the 16th \nAnnual ACM Symposium on Principles of Distributed Computing, pages 219 228, 1997. [19] Kevin E. Moore, \nJayaram Bobba, Michelle J. Moravan, Mark D. Hill, and David A. Wood. LogTM: Log-based transactional memory. \nIn Proc. 12th Annual International Symposium on High Performance Computer Architecture, 2006. [20] Kevin \nE. Moore, Mark D. Hill, and David A. Wood. Thread-level transactional memory. Technical Report CS-TR-2005-1524, \nDept. of Computer Sciences, University of Wisconsin, March 2005. [21] J. Eliot B. Moss and Antony L. \nHosking. Nested transactional memory: Model and preliminary architecture sketches. In OOPSLA Workshop \non Synchronization and Concurrency in Object-Oriented Languages, October 2005. [22] William Pugh. Skip \nlists: A probabilistic alternative to balanced trees. Communications of the ACM, 33(6):668 676, June \n1990. [23] Bratin Saha, Ali-Reza Adl-Tabatabai, Rick Hudson, Chi Cao Minh, and Benjamin Hertzberg. McRT-STM: \nA high performance software transactional memory system for a multi-core runtime. In Proceedings of the \n11th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programs (PPoPP), 2006. [24] N. Shavit \nand D. Touitou. Software transactional memory. Distributed Computing, Special Issue(10):99 116, 1997. \n[25] Sun Microsystems Laboratories. Scalable synchronization research group. http://research.sun.com/scalable. \n[26] Adam Welc, Suresh Jagannathan, and Antony L. Hosking. Trans\u00adactional monitors for concurrent objects. \nIn Proceedings of the 18th European Conference on Object-Oriented Programming, pages 519 542, June 2004. \n \n\t\t\t", "proc_id": "1167473", "abstract": "We describe DSTM2, a Java&#8482; software library that provides a flexible framework for implementing object-based software transactional memory (STM). The library uses <i>transactional factories</i> to transform sequential (unsynchronized) classes into atomic (transactionally synchronized) ones, providing a substantial improvement over the awkward programming interface of our previous DSTM library. Furthermore, researchers can experiment with alternative STM mechanisms by providing their own factories. We demonstrate this flexibility by presenting two factories: one that uses essentially the same mechanisms as the original DSTM (with some enhancements),and another that uses a completely different approach.Because DSTM2 is packaged as a Java library, a wide range of programmers can easily try it out, and the community can begin to gain experience with transactional programming. Furthermore, researchers will be able to use the body of transactional programs that arises from this community experience to test and evaluate different STM mechanisms simply by supplying new transactional factories. We believe that this flexible approach will help to build consensus about the best ways to implement transactions, and will avoid the premature \"lock-in\" that may arise if STM mechanisms are baked into compilers before such experimentation is done.", "authors": [{"name": "Maurice Herlihy", "author_profile_id": "81100151794", "affiliation": "Brown University", "person_id": "PP15024334", "email_address": "", "orcid_id": ""}, {"name": "Victor Luchangco", "author_profile_id": "81100464444", "affiliation": "Sun Microsystems Laboratories", "person_id": "P290813", "email_address": "", "orcid_id": ""}, {"name": "Mark Moir", "author_profile_id": "81100542583", "affiliation": "Sun Microsystems Laboratories", "person_id": "P190748", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167495", "year": "2006", "article_id": "1167495", "conference": "OOPSLA", "title": "A flexible framework for implementing software transactional memory", "url": "http://dl.acm.org/citation.cfm?id=1167495"}