{"article_publication_date": "10-16-2006", "fulltext": "\n The Paradoxical Success of Aspect-Oriented Programming Friedrich Steimann Lehrgebiet Programmiersysteme \nFernuniversit\u00e4t in Hagen D-58084 Hagen steimann@acm.org Abstract Aspect-oriented programming is considered \na promising new technology. As object-oriented programming did before, it is be\u00adginning to pervade all \nareas of software engineering. With its growing popularity, practitioners and academics alike are wonder\u00ading \nwhether they should start looking into it, or otherwise risk having missed an important development. \nThe author of this essay finds that much of aspect-oriented programming s success seems to be based on \nthe conception that it improves both modularity and the structure of code, while in fact, it works against \nthe pri\u00admary purposes of the two, namely independent development and understandability of programs. Not \nseeing any way of fixing this situation, he thinks the success of aspect-oriented programming to be paradoxical. \nCategories and Subject Descriptors D.2.2 [Software Engineer\u00ading]: Design Tools and Techniques Modules \nand interfaces; Structured programming. D.3.2 [Programming Languages]: Language Classifications Multiparadigm \nlanguages. D.3.3 [Programming Languages]: Language Constructs and Features Modules, packages; Control \nstructures; Procedures, functions, and subroutines. General Terms Languages. Keywords aspect-oriented \nprogramming; modularization; pro\u00adgram structure; globalization of variables; independent develop\u00adment; \nreadability; software engineering.  1. Introduction I first encountered aspect-oriented programming \n(AOP) while writing my habilitation thesis, via the detour of subject-oriented programming (SOP) [30]. \nAt that time, I was mostly interested in roles as first class modeling and programming concepts, and \nal\u00adthough I could see the practical problems SOP and AOP were ad\u00addressing, I decided that their relationship \nto roles at least the way I viewed them was weak. After finishing my habilitation, I was asked to take \nover the Soft\u00adware Engineering lectures. For Software Engineering II, I decided to include a short excursion \ninto AOP, partly because I wanted to find out for myself what it was good for (if not for representing \nroles), partly because I wanted to communicate to my students that object-orientation and Java were not \nthe last words in pro- Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distrib\u00aduted for profit \nor commercial advantage and that copies bear this notice and the full citation on the first page. To \ncopy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific \npermission and/or a fee. OOPSLA 06 October 22 26, 2006, Portland, Oregon, USA. Copyright &#38;#169; \n2006 ACM 1-59593-348-4/06/0010 $5.00. gramming. AspectJ was particularly attractive for my purposes because \nit came with a compiler and a plugin for the Java IDE I was using. After fiddling with the versions I \nmanaged to get it in\u00adstalled and my first sample program running. What proved more difficult, though, \nwas to find a conceptual motivation of AOP that convinced me (one comparable to how classes, associations, \nand roles can be motivated in OOP); unsuccessful as I was, I decided to stick with the material used \nfor the AspectJ demo at OOPSLA 2002, which was available on the web. My students immediately bought it. \nWhat impressed me most at that time was the fact that the devel\u00adopers of AspectJ had undergone the suffering \nof developing an IDE plugin that not only allowed compilation without pre\u00adprocessing, but also provided \ntool support allowing me to deal with the features of the language rather than the technical obsta\u00adcles \nto using it. In fact, all other language extensions proposed by academics I had looked into until that \ntime either remained at the theoretical level entirely (with very impressive, page long sound\u00adness proofs \nconvincing me that there are smarter guys out there than me, but not giving me any feeling of the practical \nimpact of the formalism), or came with command level precompilers requir\u00ading me to undertake installation \nprocedures so intimidating that I was sure I would never get it running. The AspectJ people on the other \nhand knew what it takes for a new language to be adopted by programmers: a set of simple concepts attacking \na real prob\u00adlem, and good tool support. In this light, AspectJ was surely one piece of commendable work. \nA little later, I attended a biannual national (German) meeting on teaching software engineering at universities. \nSomeone had raised the question, what minimum half life does a new approach need to deserve to be taught? \nOne highly respected participant said that we as lecturers should be able to judge the impact of, say, \nAOP right away so that there would be no need to wait for first signs of decay in order to be able to \nestimate the half life. I wondered why he used AOP as an example, and asked him for his judgment in this \nparticular case. He responded by saying he was confident that AOP would have sufficient impact to grant \nteaching it. This made me wonder what made him so sure. What disturbed me most about AOP at that time \nwas the monot\u00adony of examples. In particular, to me the ever-recurrent logging, tracing, debugging, etc. \naspects are all more or less programming problems in that they address concerns that a programmer has \nto deal with because he is programming, not because some particular problem domain or application demands \nit. This is in contrast to application classes such as Person, Document, etc., and also methods such \nas attend, format, and so on, which all represent problem domain level concepts. I conjectured that most, \nif not all of the programming problems addressed by AOP could either be tackled by adding a corresponding \nfeature to an IDE (for example, tracing as done in Eclipse), or by extending the language with suitable \nconstructs (for example, exception handling as in Java, or transaction management as in database languages). \nI expressed this in my provocative claim that the number of useful aspects is not only finite, but also \nfairly small. Although obviously impos\u00adsible to prove, I thought I could make it plausible by showing \nthat aspects are not domain level abstractions and thus lack a signifi\u00adcant source of diversity. Because \nmy claim was both provocative and unproven, I decided to test it against a pro-aspect audience and submitted \nit as a posi\u00adtion paper to a small European workshop on aspect systems. Not surprisingly, most of the \nAOP proponents at the workshop would not follow my thoughts, and the discussion led, if I remember cor\u00adrectly, \nnowhere. However, it was there that I learned that to some in the community, AOP is all about modularity. \nTo me, this came as a surprise, mainly because I missed interfaces in the AOP tool\u00adset, a construct which \nI had always thought (and taught) to be in\u00adseparable from that of modules. The good thing I took home \nfrom this workshop was that I decided to get myself a copy of a work\u00adshop paper by Filman and Friedman, \ntitled Aspect-oriented pro\u00adgramming is quantification and obliviousness [23]. When I first read this \npaper, I thought: Wow, this is it! It was the first paper I had come across that without putting forward \na particular language seemed to be more concerned about what AOP is rather than what it is good for. \nHence, it seemed one big step toward the conceptual justification of the approach and its constructs \nthat I had been looking for. At the same time, it pre\u00adsented AOP as a next step in the history of the \ndevelopment of programming languages, and gave criteria for classifying whether a language is aspect-oriented. \nThe third thing that struck me, how\u00adever, was that the paper s characterization of aspect orientation \nalmost completely covered one I had believe it or not independently devised for the purpose of making \nplausible Why most domain models are aspect free [59], my (vain) attempt to put an end to the (vain, \nin my eyes) attempts of aspectizing do\u00admain modeling and its graphical modeling languages. However, although \nI had based my argumentation mainly on the quantifica\u00adtion property and the resulting second-orderedness \nof aspect\u00adorientation, I quickly learned that not all in the community liked the article by Filman and \nFriedman as much as I did, apparently mostly because the notion of obliviousness was too much an invi\u00adtation \nto question the modularity property thought to be crucial to AOP. My most recent noteworthy encounter \nwith AOP has been at a conference where someone explained to the audience how he had used AspectJ to \nfactor out the various passes of a compiler from the node classes of the abstract syntax tree. As far \nas I could see, this inevitably meant that as aspects, the passes needing access to the data stored in \nthe nodes had to break the nodes modularity. When I remarked that he had just given us a perfect example \nof why AOP is fundamentally at odds with modularization, that in fact I believed that AOP should not \nbe spoken of in connection with modularity in any other than a negative sense, someone from the audience \nresponded that I was right, but only if I talked about Parnas style modularization. Given that modularization \nis a fairly broadly accepted notion, I thought that this was a pretty odd thing to say. To me programming \nis the process of creating a software artifact that, by repeated extension, adaptation, and correction, \napproxi\u00admates an ideal solution to a given problem. The more complex the problem and its solution are, \nthe more programming depends on recursive (de)composition, that is, on the possibility to repeatedly \ndivide a problem into smaller parts whose solutions can either be taken off the shelf or be programmed \nindependently. However, such an approach poses stern requirements on compositionality; in particular, \nit demands that the functionality of the whole is pre\u00addictable from the functionality of its parts and \nhow they are com\u00adposed; because otherwise one has to understand the complete sys\u00adtem in order to know \nwhat it does, making assembly from parts no easier than creating the software in one piece. To reach \nthis level of compositionality, each part must come with a sufficiently accu\u00adrate specification of what \nit does, and what it requires for doing it. While there may in fact be different styles of decomposition, \nthe resulting specifications always involve modules and interfaces. Surely, keeping to interfaces means \nrestricting the programmer s freedom, and programming without bounds (interfaces) is cer\u00adtainly more \nfun; yet I believe that for big systems, restriction is the key to success. With hindsight, I personally \nhave undergone a development that may not be so untypical for many like me. I started out trying to ignore \nAOP, but it came back to me with sufficient thrust to make me curious. By looking into it, I found its \napplicability to be fairly limited, but when I looked up again, I realized that it had begun to penetrate \nall areas of software engineering, at least in academic circles. Wondering what the key to its apparent \nsuccess was, I tried to learn more about it, but the more I knew, the less I could see how AOP was going \nto live up to its claims. While this may not be the end of my personal development, I decided that I \nhad collected enough material to share my thoughts with others. After all, AOP is not some shrinking \nviolet that I could wipe out with a few well-chosen words. Quite the contrary. 2. Pinning Down a Moving \nTarget When I originally set out to write this tract, I tried to present a characterization of AOP that \nwas 1. general enough to cover sufficiently many approaches hud\u00addling under the aspect-oriented umbrella, \nwhile at the same time was 2. specific enough to be able to base some conclusive argumenta\u00ad  tion on \nit. I thought this was wise because although each aspect-oriented programming language (AOPL) comes with \nits own, formal and unambiguous definition of what AOP is, there seems to be no one such definition, \nnot even on an abstract level, that a) is common to all AOPLs and b) sufficiently distinguishes it from \nother, long established pro\u00adgramming concepts. One problem with having no single, accepted definition \nis that it makes AOP a moving target for its opponents: whenever some problem is identified, answers \nof the kind Ah well, this is a prob\u00adlem of <insert some AOPL here>, but if you look at, for instance, \n<insert another AOPL here>, then you don t have this problem! can easily be generated. I tried to shield \nthe points I was going to make from frustrating discussions of this kind, by basing my ar\u00adgumentation \non as few defining characteristics of AOP as possi\u00adble. I was hoping that my readers would agree that \nthere must be some such characteristics, or else the subject of the discussion would dissolve away, at \nleast from an engineering standpoint. Un\u00ad fortunately, I did not get further than generating comments \nof the kind While this may be a valid characterization of <insert some AOPL here> and like languages, \nit is certainly not one of <insert some other AOPL here>. With hindsight, this is what I should have \nexpected; others much more involved in the subject than I am have come to the conclusion that capturing \nAOP is a very dif\u00adficult undertaking (cf., for example, Mehner &#38; Rashid [45] and also the discussions \nat http://aosd.net/). Despite the lack of a common agreement of what AOP is, there is a common understanding \nof what AOP is good for, namely for modularizing crosscutting concerns. However, this understanding reflects \nthe purpose, not the nature of AOP. What disturbs me most about this is that it forbids me from deriving \nmyself what AOP is good for, since this is antici\u00adpated in its definition. In particular, with modularizing \ncrosscut\u00adting concerns as the definition of AOP, finding that whatever is considered to be AOP modularizes \ncrosscutting concerns is just begging the question,1 and finding that it does not implies (via modus \ntollens) that whatever I have looked at and found to not modularize cannot have been AOP basta! Also, \nif modularizing crosscutting concerns is a widespread problem whose solution be\u00adstows success on the \napproach, AOP must be a success, simply because it is by definition solving the problem. If it is successful \nwithout solving the problem, it can still be so for other reasons, but these cannot be explained by its \ndefinition; in fact, it leaves what is successful undefined. I don t find this very satisfactory. Instead, \nas formulated by Fil\u00adman and Friedman: Understanding something involves both understanding how it works \n(mechanism) and what it s good for (methodology). In computer science, we re rarely shy about grandiose \nmethodological claims (see, for example, the literature of AI or the Internet). But mechanism is important \n appreciating mechanisms leads to improved mechanisms, recognition of commonalities and isomorphisms, \nand plain old clarity about what s actually happening. (from [22], Chapter 2, a revised version of [23]) \nBecause recognition of commonalities and isomorphisms, and plain old clarity about what s actually happening \nare precisely what I am interested in, I will need an understanding of the mechanisms of AOP. For this \npurpose I will resort to a rather simplistic capture of how AOP works, willing to accept that it does \nnot cover all of AOP in particular, that it ignores ap\u00adproaches such as SOP that, previous to joining \nthe AOP family, led an independent life. 3. The Aspect Formula Perhaps the best known definition of \nwhat AOP is (its nature) is the simple equation aspect orientation = quantification + obliviousness (1) \nput forward in a workshop paper by Filman and Friedman [23] and only recently repeated in a book on aspect-oriented \nsoftware development edited by Filman and others [22]. Obliviousness ba\u00adsically implies that a program \nhas no knowledge of which aspects 1 an instance of the logical fallacy of that name, also known as petitio \nprincipii modify it where or when, and quantification expresses the fact that an aspect can affect arbitrarily \nmany different points in a pro\u00adgram. One might be tempted to add precisely which being speci\u00adfied by \nthe aspect to the last sentence, but this would make obliviousness a consequence of quantification, which \nwould not allow one to be discussed independently from the other. In fact, while obliviousness has been \nthe subject of some criticism, and in response to this has been questioned as a defining characteristic \nof AOP by its community (see, for example, Murphy and Schwan\u00adninger [47]), quantification seems to have \nbeen challenged less. Thus, the sentence, In programs P, whenever condition C arises, (2) perform action \nA. which is also from Filman and Friedman [22, 23] and captures much of the essence of Definition (1) \nwithout mentioning oblivi\u00adousness explicitly2, seems much more generally agreed upon. In fact, Characterization \n(2) specifies in a concise way the effect an aspect defined as a pair (C, A) has on a program P.3 As \nmentioned in the introduction, I had proposed a slightly more explicit formulation of Definition (2) \nindependently in an earlier paper of mine [59]; in particular, that formulation captured a no\u00adtion of \ncontext in which condition C arises, and in which action A is performed. This context is of particular \nimportance when speaking about modularity (and thus the purpose of AOP), since whenever action A is not \ncompletely independent of the context in which C arises, A will require access to this context, possibly \nbreaking the modularity of the program P. I will therefore assume in the rest of this essay that both \nC and A are parameterized by a set of context variables that are bound to actual program elements whenever \nC is satisfied (the existence of the context elements may in fact be part of the condition). Note that \nit is somewhat typical for AOP although perhaps not a necessary condition that the context provided to \nan action A is expressed by the aspect (C, A), but not by the program elements that provide it. By contrast, \na subroutine call explicitly specifies the context (parameters) passed to the subroutine at the call \nsite (unless the subroutine has automatic access to this context, for in\u00adstance through global variables). \nGenerally, this means that the program elements satisfying a condition C are oblivious to which elements \nof their context an aspect relies on (they could assume all, though). 2 In fact, Definition (2) is presented \nin Filman and Friedman [23] as cap\u00adturing the quantification part of aspect orientation. From Definition \n(2) alone, it remains unclear whether P (or its elements) have knowledge of C. Filman later added that \nthe oblivious claim is that real aspect lan\u00adguages do not require P to mention A [24]. 3 One might argue \nthat this capture of AOP is incomplete in that it leaves out the structural (as opposed to behavioral) \nchanges made possible by certain AOPLs (for instance the inter-type declarations of AspectJ). But the \nsame is also true for other popular definitions of AOP that are of the kind when X happens, do Y (Coyler \net al. [12]). Besides, and decisive for this paper, the possibility to introduce structural changes does \nnot al\u00adleviate any of the problems I am concerned about: the same line of ar\u00adgumentation can be applied \nto a definition of AOP that includes struc\u00adtural introductions. 3.1 Interpretations of the Aspect Formula \nAdmittedly, the characterization of AOP as captured by Defini\u00adtions (1) and (2) seems to be influenced \nby the language definition of AspectJ. In fact, the definition of aspects as a pair (C, A) and their \neffect on programs covered by Definition (2) translates to the terms of AspectJ as follows: P is the \nexecution of a program, which includes the execution of advice (see below);  C is a set of so-called \npointcuts specifying the target elements of the aspect in the program and the context in which they oc\u00adcur \n(mostly variables, but also stack content);  A is a piece of advice that depends on the context captured \nby C; and  the quantification is implicit in AspectJ s compiler/weaver.  Despite the influence of AspectJ, \nthe generality of the above sim\u00adple capture of AOP should not be underestimated: 1. First and foremost, \nit allows full flexibility for different AOPLs concerning when C is to be evaluated and, conse\u00adquently, \nwhich elements of the program it has access to. So\u00adcalled static AOPLs evaluate C at compile (or class \nloading) time, whereas dynamic AOPLs evaluate it at runtime. In the static case, evaluation of C has \nonly access to the elements of the program text. In the dynamic case, C can range over execu\u00adtion elements \nas well as over temporal patterns of these. 2. Second, there are no theoretical bounds to what the condition \nC has access to, in particular, what the context may include: declared and actual types of all kinds \nof variables (not only pa\u00adrameters), their values (objects), the receiver of a method call, the caller, \nthe current state of the program, past states, the call stack, an event, a sequence of events C could \neven be a predicate over traces [3, 37, 65]. In brief: in Definition (2), condition C can have access \nto whatever is allowed by the AOPL and can be made available by the underlying runtime system. 3. Depending \non viewpoint, action A is expanded to a sequence of program elements (static view) or to a set of join \npoints (dy\u00adnamic view). In either case, the condition C of an(other) aspect can range over the elements \nof A. In other words: actions A can be elements of programs P, and aspects can be the targets of aspects. \nTherefore, Definition (2) is not as asymmetric as it may seem. Instead, one should be aware that target \nin the literature usually referred to as base program and advice are relative terms, or roles of advising: \nwhat is the target in one aspect application can be the advice in another. This is some\u00adwhat analogous \nto the (not unrelated) distinction between ob\u00adject language and metalanguage, which comes with corre\u00adsponding \nroles [7, 25]. 4. In practice, the point nature of join points limits the variability regarding how \nthe execution of an action (advice) A can be combined with that of the program elements (join points) \ntrig\u00adgering it: before, after, around (that is, one part before, one part after), and instead4 seem to \nbe the only options. This is of course different if the model also allows multi-point patterns  4 Note \nthat allowing an aspect to block execution of its advised join point is somewhat contradictory to the \ninterpretation of AOP as event-driven programming [18], in that an event that led to the execution of \nan aspect actually does not take place. [3, 37, 65] as join points. Since Definition (2) does not place \nany constraints on the nature of the elements of P other than that they can be selected by suitable conditions \nC, this model of AOP covers multi-point patterns as well. In fact, with a little flexibility Definition \n(2) of how AOP works can even be stretched to be in accord with more recent characteri\u00adzations of AOP, \nsuch as those proposed by Masuhara &#38; Kiczales [44] or Kojarski &#38; Lorenz [38]. In particular, \nconditions C can be interpreted as composition rules governing the composition of dif\u00adferent action sets \nA (representing different concerns) into a com\u00adposed program P. This would allow Definition (2) to cover \nother, so-called symmetric approaches to AOP such as Hyper/J [50], as well as the inter-type declarations \nof AspectJ (cf. Footnote 3). In the context of this essay, however, it is important to note that these \nnewer characterizations of AOP do not assign it properties voiding the discussions that follow. In particular, \nin all but the most trivial cases the composition rules C (labeled R in [38]) will likely need some intimacy \nwith the structure (including context) of the actions A (labeled C in [38]) to be composed. 3.2 But \nOOP ! Some proponents of AOP say that trying to nail down AOP to its mechanisms is premature, or even \nunfair, simply because an analogous capture of OOP has long been or is still missing, and that this fact \nhasn t compromised OOP or its community. However, I don t agree with this argumentation. Concerning the \nlack of definedness, I never thought that this was a problem for OOP. In fact, the first definition of \nOOP that I heard is still the one I use today: object-orientation = abstract data types + inheritance \n(3) Surely, this characterization depends on a common understanding of what abstract data types and inheritance \nare, but other than that, I think it s perfectly OK. In particular, it serves as a broadly usable criterion \nfor deciding whether some language is object\u00adoriented or not: all that needs to be done is to check whether \nit supports abstract data types and comes with some kind of inheri\u00adtance. At the same time, this definition \nis sufficient respective definitions of abstract data types and inheritance provided to in\u00adfer some properties \nof OOP. For instance, its modularity property can be inferred from that of abstract data types, and it \ncan be shown that OOP has a problem with modularity if inheritance breaks the encapsulation provided \nby abstract data types. This susceptibility to rigorous reasoning is in sharp contrast to the grandiose \nmethodological claims that OOP isn t at all devoid of: that object-orientation better captures the real \nworld, that it al\u00adlows seamless integration of analysis, design, and implementa\u00adtion, that it leads to \nproductivity gains, etc. None of these claims serves the plain old clarity about what s actually happening \n. But Definition (3) does.  4. Playing with the Options That Characterization (2) is indeed a very general \ncapture of AOP can be seen by running through a number of possible formulations of condition C. At one \nextreme, C could stand for the condition that a certain aspect with associated action (advice) A is refer\u00adenced \nin the program text. Definition (2) then expresses no more than the semantics of a standard procedure \ncall: In programs P, whenever an aspect is referenced, (4) perform its associated action A. This is an \ninteresting construction, since it shows that quantifica\u00adtion can indeed be completely independent from \nobliviousness: all places where condition C can possibly arise are explicitly marked in the program text \n(cf. Footnote 2). Of course the programmer of P needs to know which aspects there are, how they are named, \nand where or when they should apply; and almost certainly, no one would accept this style as AOP, since \nit can be replaced by ordinary procedural programming; nevertheless, it goes to show that Definition \n(2) of how AOP works is quite stretchable. At the other extreme, C can express some condition that does \nnot allow a programmer of P to associate elements of P with aspects: for instance, C could express a \nrandom selection, invoking A by chance (including always or never). This would be expressed by In programs \nP, whenever Random indicates it, (5) perform action A. Then, aspect awareness of a program is reduced \nto the level that all places in a program may be regarded as implicitly marked, but performance of A \nremains uncertain (the non-certainty of appli\u00adcation noted in a different context in AOP considered harmful \n[13]). This is largely the situation in which the programmer of P has no knowledge of the presence of \naspects or which they are, but knows that AOP exists and that P may be subject to it; and also to a certain \nextent the situation in which the programmers of aspects (C, A) have no detailed knowledge of the programs \nthe aspects are to apply to. Surely, these formulations of C are theoretical extremes that no practical \nAOPL will adopt. The question that I find interesting, though, is whether the conditions C can be cast \nin such a form that AOP serves its methodological claims, in particular the modularization of crosscutting \nconcerns, while at the same time makes its mechanisms sufficiently innovative to justify its recep\u00adtion \nas a new form of programming. I will therefore further ex\u00adplore the possibilities of tweaking Definition \n(2). 4.1 Taming Obliviousness Returning to the first extreme, it is obvious that directly calling aspects \nfrom a program is not AOP, simply because it is indistin\u00adguishable from procedural programming. However, \nthe program P need not make explicit reference to the aspects themselves instead, it could also reference \nsome third elements B exterior (that is, not directly contributing) to P that are not parts of the as\u00adpects, \nbut nevertheless indicate that some aspects may evaluate these elements in their conditions C, possibly \ninvoking the at\u00adtached actions A. This would be expressed by the formula In programs P, whenever condition \nC arises (6) where element B is referenced, perform action A. In order to hook an aspect (C, A) to B, \nB will usually be integrated into the aspect s condition C so that Definition (6) collapses to Definition \n(2) with the additional constraint that C must check for the presence of B. As regards the additional \nprogram elements B, annotations can be employed5 (which are in a way outside the program they annotate); \nhowever, if these annotations do not al\u00adlow the inclusion of runtime values, they cannot capture the \ncon\u00ad 5 called abstract annotations by Laddad [39], because they indicate the nature of the annotated \nrather than possible aspects that depend on it; also referred to as annotation-properties by Kiczales \nand Mezini [35] text of B which A may need access to6. Note that B need not nec\u00adessarily occur exactly \nwhere A is to be invoked it can also be at\u00adtached to a program scope in which C should be checked. For \nin\u00adstance, B could be an interface of a module to whose internals (execution of program elements inside \nthe module) aspect (C, A) is to be applied. Using additional program elements B to tag the places where \nas\u00adpects may apply gives the programmers of P the possibility to deny aspects access where it is not \nwanted, simply by not refer\u00adencing B (or any other annotation that could be evaluated by as\u00adpects) in \nthese places. To express where they could apply, how\u00adever, the programmer must have some sense of what \npossible as\u00adpects might want to do, so as to be able to tag the corresponding points in a program and \nalso to be able to expose their context through B, if that is linguistically possible. In fact, referencing \nB in a program is more or less equivalent to inserting (or announc\u00ading, in case B does not mark the exact \nposition) a dynamically bound procedure call, the main difference being that there is an additional condition \nC guarding this call that is not expressed at the call site. Also, if B does not capture the context \nthat A may have access to, A must take access to the context it depends on for granted. Referencing some \nother element B in the program, while keeping the information about which aspects are hooked to B the \nsecret of the aspects, adjusts obliviousness to a level at which the pro\u00adgrammer knows that aspects may \ninteract with the points in P tagged with B (and will not interact with all other points); yet he does \nnot know which aspects. As with the dynamic binding of methods in OOP, the surprise induced by this ignorance \ncan be reduced by specifying contracts that have to be fulfilled by each aspect advising points matched \nby B, as has been suggested by, for example, Clifton, Griswold, Sullivan, and their co-workers [10, 27, \n63] (note that [27] and [63] also impose contracts on the targets; see the appendix). But no matter how \nattractive annotating the targets of aspects as suggested by Definition (6) may appear, AOP has a problem \nwith it: for massively crosscutting concerns, annotating every program element that can be the target \nof corresponding aspects leads to widely scattered annotations that are just as annoying as the scat\u00adtering \nof code the aspect is to modularize. For instance, with trac\u00ading as a crosscutting concern, annotating \nevery program element whose execution is to be traced is just as annoying as adding the tracing code \n(usually no more than the calling of a subroutine) on site. To avoid this, it has been suggested to use \nso-called annota\u00adtor aspects that annotate program elements so that they can be ad\u00advised by other aspects \n[39], as expressed by In programs P, wherever condition C arises, (7) add annotation B. Obviously, the \nannotator aspects could be used to add the advice directly, but this would mean returning to Definition \n(2), that is, AOP without annotations. Considering that the proposed use of abstract annotations is to \n[translate] some of the best practices from the object-oriented world to AOP [39], and that this transla\u00adtion \nrequires other aspects to restore the characteristic of AOP, the 6 This is the case, for instance, in \nJava. suggested tango of aspects and annotations7 looks more like an egg dance to me, the eggs being \nobliviousness, quantification, and explicit procedure calls.8 4.2 Taming Quantification Returning to \nthe other extreme, thinking of the conditions C as random may seem absurd. However, for the programmer \nof P who is unaware of the active aspects, which of his statements get advised may indeed appear random;9 \nfor the programmers of the aspects, if the aspects use generic, intensional expressions for C, exactly \nwhich program elements of an (evolving) program an as\u00adpect advises is also subject to some coincidence. \nA first step to\u00adward reducing this apparent randomness is to resort to an exten\u00adsional specification \nof C, that is, to explicitly listing all program elements to be advised. This is expressed by In programs \nP, whenever execution reaches one of the (8) points in {p1 , , pn}, perform action A. While this maintains \nP s obliviousness to aspect application (the implicit invocation of A), it requires aspects to repeat \nexplicitly those parts of a program that they are to advise. As with annotat\u00ading targets of aspect application, \nfor massively crosscutting con\u00adcerns this also quickly becomes a nuisance, the biggest difference being \nthat the previously scattered references are now all col\u00adlected in one location. While such a programming \ntechnique (which reminds me of manually maintaining the tables a linker uses for putting together separately \ncompiled parts of a program) may be useful for updating (or patching) existing and already de\u00adployed \nprograms, it is most certainly not what the AOP commu\u00adnity envisions. Generally, the quantification property \nmakes AOP suffer from the problem that the conditions C in Definition (2) and its variations are extremely \nsensitive to changes in the program P, a condition that has become known under the label fragile pointcut \nproblem [61] (also called arranged pattern problem in [29]). Some re\u00adsearchers expect that this problem \ncan be addressed by devising better languages for expressing C ( semantic pointcut or crosscut languages \n[29, 42, 48, 51]; cf. also [4] for the semantics of point\u00adcuts). However, no matter how semantic a selector \npredicate C may be: in order to be able to formulate its action in terms of a programming language, an \naspect must make reference to the con\u00ad 7 phrased after a talk titled Metadata and aspect-oriented programming: \nIt takes two to tango presented at Java One in 2004 8 Egg dance: Lightly, nimbly, quickly, and with hairbreadth \naccuracy, she carried on the dance. She skipped so sharply and surely along be\u00adtween the eggs, and trod \nso closely down beside them, that you would have thought every instant she must trample one of them in \npieces, or kick the rest away in her rapid turns. By no means! She touched no one of them, though winding \nherself through their mazes with all kinds of steps, wide and narrow, nay even with leaps, and at last \nhalf-kneeling. J. W. von Goethe, Wilhelm Meister s Apprenticeship, Book II, Chapter VIII. 9 Proponents \nof AOP usually point to possible tool support here: a tool (such as an aspect-aware IDE) can highlight \nthe potential targets of as\u00adpects in the program text. However, this highlighting is not without ran\u00addomness, \neither: it depends on the availability of the conditions C at ed\u00aditing time (which is a problem for aspects \nthat are added later), and it is subject to change without notice, namely when an aspect programmer chooses \nto change C. text it needs access to. I find it difficult to imagine how seman\u00adtic conditions and their \ncontext specifications can be automati\u00adcally mapped to the surface structure of a program. Ultimately, \nI believe, semantic referencing as envisioned by Lopes et al. [42] will require automatic program understanding \nwhich, once avail\u00adable, will revolutionize the entirety of programming, conceivably making AOP, as well \nas many other techniques en vogue today, obsolete. 4.3 Quintessence It seems to me that its nature makes \nAOP a rather delicate crea\u00adture: when developed to the full, both obliviousness and quantifi\u00adcation conflict \nwith its goals, but cutting back on them seems to deprive AOP of its core contribution. Reducing the \nobliviousness in a program not only comes close to reducing implicit invocation of advice to some variation \nof dynamically bound procedure call\u00ading, it also reintroduces the very scattering AOP was to avoid. Reducing \nthe quantification in aspects ultimately amounts to maintaining lists of places in a program the aspects \nare to advise: the obliviousness of a program to its aspects is therefore bought at the price of far-reaching \nintimacy of the aspects with the program, which thwarts modularization and thus the purpose of AOP. It \nmay be my ignorance or lack of imagination, but I cannot see how to get out of this dilemma.  5. AOP \nfrom a Software Engineering Perspective In the previous sections I tried to characterize AOP in abstract \nterms, which allowed me to point to some of its problems and to give reason to my belief that it will \nbe very difficult to fix them without giving up the essence of AOP. For much of the rest of this essay \nI will try to carry over my findings to the real world of pro\u00adgramming, that is, to software engineering. \n5.1 AOP and Modularization One of the first things that I noted when digging into the body of available \nliterature is that the AOP community revels in quoting Parnas, a man whose name is inseparably tied to \nthe concept of information hiding and whose contributions to program modulari\u00adzation are respected to \nthis date. In particular, Parnas s seminal article titled On the criteria to be used in decomposing systems \ninto modules [55] is almost universally referenced when speak\u00ading of the separation of concerns, even \nthough the term is never mentioned in it. This however is not a real problem, since the modularization \ncriteria Parnas suggested do serve separation of concerns. My problem with citing Parnas s work is that \nin my eyes it does not accommodate the AOP form of modularity; if anything, it forbids it. 5.1.1 Modularity \nand Information Hiding This requires some explanation. At the time when Parnas s cited article was written, \nmodularity was already a well-established no\u00adtion, basically known as one that helps manage the development \nof large programs by dividing them into separate chunks that can be developed largely independently of \neach other: A well-defined segmentation of the project effort ensures system modularity. Each task forms \na separate, distinct program module. At implementation time each module and its inputs and outputs are \nwell-defined, there is no confu\u00adsion in the intended interface with other system modules. [ ] Finally, \nthe system is maintained in modular fashion; system errors and deficiencies can be traced to specific \nsys\u00adtem modules, thus limiting the scope of detailed error searching. [55], quoting Gauthier and Pont \nDesigning Sys\u00adtems Programs (Prentice-Hall, Englewood Cliffs 1970). At that time, so Parnas reported, \nmodules typically consisted of one or more procedures that mapped to a phase or step of process\u00ading (as \nderived, for example, from a flowchart); the data struc\u00adtures on the other hand, on which the procedures \noperated, were shared among the modules and thus were part of their mutual in\u00adterfaces. Parnas s contribution \nto modularization was to deliver a novel criterion that guided the process of creating modules: each \nmodule should fully encapsulate one design decision so that later changes of this decision would be less \nlikely to affect more than the hosting module. Parnas named this criterion information hid\u00ading ([55], \np. 1056), making reference to an earlier paper of his, titled Information distribution aspects of design \nmethodology [54]. It is instructive to read this paper, too. Much to my surprise, Par\u00adnas did not write \nabout (the benefits of) information hiding, but about the detrimental effects of the opposite, namely \ninformation distribution among programmers. In fact, he never even used the term information hiding, \nnor did he suggest what we know to\u00adday as data encapsulation (which for me had been more or less synonymous \nuntil then10). Instead, he made clear that information hiding (or, rather, information non-distribution) \nis not only a de\u00adsign issue affecting the structure of the product, but also a process issue: information \nof how something was implemented should not be shared among programmers working on different modules, \nbe\u00adcause this would create untoward dependencies and hamper inde\u00adpendent development. In fact, in a recent \ndefense of his earlier work he said that My early work clearly treated modularisation as a design issue, \nnot a language issue. A module was a work assign\u00adment, not a subroutine or other language element. Although \nsome tools could make the job easier, no special tools were needed to use the principal, just discipline \nand skill. When language designers caught on to the idea, they as\u00adsumed that modules had to be subroutines, \nor collections of subroutines, and introduced unreasonable restrictions on the design. They also spread \nthe false impression that the important thing was to learn the language; in truth, the im\u00adportant thing \nis to learn how to design and document. We are still trying to undo the damage caused by the early treatment \nof modularity as a language issue and, sadly, we still try to do it by inventing languages and tools. \n[15] That Parnas s work was actually perceived that way is expressed by a contemporary quote from Brooks \ns classic The Mythical Man-Month : D. L. Parnas of Carnegie-Mellon University has proposed a [ ] radical \nsolution11. His thesis is that the programmer is most effective if shielded from, rather than exposed \nto the details of construction of system parts other than his own. This presupposes that all interfaces \nare completely and 10 an instance of the eternal confusion of data and information 11 Brooks refers to \na technical report here that was a precursor to reference [54]. precisely defined. While that is definitely \nsound design, de\u00adpendence upon its perfect accomplishment is a recipe for disaster. A good information \nsystem both exposes interface errors and stimulates their correction. ([8], Chapter 7) At that time, \nBrooks seems to have favored that all programmers should see all the material, so as to increase the \noverall quality of code and to spot flaws and bugs early. However, 25 years later he recanted and stated, \nParnas was right, and I was wrong about in\u00adformation hiding ([8], Chapter 19), basing his change of mind \non the insight that information hiding [ ] is the only way of raising the level of software design. \n5.1.2 Modularity and Data Encapsulation Although Parnas with his suggestions to improve modularity of \ndesigns did not call for new programming language constructs, he did suggest that data encapsulation \n(once more without resort\u00ading to this term) is a viable criterion for decompositions respect\u00ading information \nhiding, although not the only one: 1. A data structure, its internal linkings, accessing proce\u00addures \nand modifying procedures are part of a single mod\u00adule. They are not shared by many modules as is conven\u00adtionally \ndone. ([55], the first item in a list of some specific examples of decompositions which seem advisable. \n; Par\u00adnas s emphasis) To today s object-oriented programmers, this seems a matter of course, but at that \ntime, it revolutionized thinking about modular\u00adity: it suggested that modules can consist of procedures \ntogether with the data structures on which they operate (ideally hiding the latter behind the former), \nand that such a module no longer neces\u00adsarily corresponds to a certain phase or step of the processing. \nThis was the first move in the direction of object-oriented pro\u00adgramming, as Brooks later acknowledged: \nParnas s information-hiding definition of modules is the first published step in [a] crucially important \nresearch pro\u00adgram, and it is an intellectual ancestor of object-oriented programming. He defined a module \nas a software entity with its own data model and its own set of operations. Its data can only be accessed \nvia one of its proper operations. The second step was a contribution of several thinkers: the upgrading \nof the Parnas module into an abstract data type, from which many objects could be derived. The abstract \ndata type provides a uniform way of thinking about and specifying module interfaces, and an access discipline \nthat is easy to enforce. ([8], Chapter 19) The third step was the adding of inheritance which, as we \nknow, breaks modularity of abstract data types (classes). But even with\u00adout inheritance, programming \nwith abstract data types (that is, in\u00adformation hiding enforced by linguistic data encapsulation mechanisms12) \nis not without problems: taken to the extreme, it leads to the situation in which a single system level \nfunction (use case, concern, or whatever you want to call it) is distributed among all modules whose \nencapsulated data are involved in that function. This leads to the scattering of functionality that is \nso characteristic of object-oriented programming. In this light, I found it interesting to see that a \nsimilar problem was already rec\u00adognized by Parnas, who warned us: 12 which is not what Parnas had in \nmind! (personal communication) If each of the functions is actually implemented as a proce\u00addure with \nan elaborate calling sequence there will be a great deal of such calling due to the repeated switching \nbe\u00adtween modules. The first [traditional] decomposition will not suffer from this problem because there \nis relatively in\u00adfrequent transfer of control between modules. [55] Today this reads like a valid criticism \nof object-oriented pro\u00adgramming: when trying to understand, or debug, a function of an object-oriented \nprogram, the frequent transfer of control between modules (classes) is indeed a problem. But can AOP \nsolve it? Before I proceed, let me make clear that I do understand that there is a difference between \nthe scattering of code resulting from the decomposition of a function into subfunctions that are associated \nwith the data they operate on, and the scattering of code imple\u00admenting crosscutting concerns such as \ntracing or logging, which is reflected in more or less identical pieces of code being found in several \nplaces. Also, the implementation of crosscutting concerns is usually tangled with that of other (crosscutting) \nconcerns, which is typically not the case for subfunctions. On the other hand, both the subfunctions \nand the crosscutting functions access and operate on data elements held by the objects of the classes \nthey are associated with; therefore, I believe that the following thought experiment of applying AOP \nto the modularization result\u00ading from data encapsulation via classes (which AOP applied to OOP is invariably \nabout) is legitimate. In order to arrive at a better modularization of concerns, AOP al\u00adlows that the \nscattered subfunctions are moved into an aspect. But if the original design that led to the scattering \nis guided by data encapsulation, the subfunctions are assigned to a module because they operate on the \ndata contained in that module, and because changing the representation of the data would likely affect \nthe implementation of the subfunctions. By moving the subfunctions to an aspect, this data dependency \nis not lifted, but is either moved to the interface between the module and the aspect (if such an interface \nat all exists; see below), or is  left implicit, by granting the aspect general access to the data \n hidden in the module. The former makes evident in the interface the resulting coupling between an aspect \nand the original module. A change in the data structure captured by the module (its formerly hidden design \ndeci\u00adsion) on which the subfunction and thus also the aspect depend likely entails a change of the interface \nand therefore also the as\u00adpect. Independent evolvability is therefore compromised. The lat\u00adter suffers \nfrom the same problem, but is worse in that the pro\u00adgrammers responsible for the design decision thought \nto be en\u00adcapsulated by the module are not aware of the dependency of the aspect on that decision (because \nthere is no explicit interface stat\u00ading this dependency). In fact, granting the aspect the access that \nit needs amounts to a globalization of the data contained in the module. But this is exactly the situation \nthat Parnas found to be prevailing at the outset of his work: modules hosting phases or steps of processing, \nand complex interfaces between modules that capture the shared design decisions, or dependence of all \nmodules on global data structures. Now one might blame me for suggesting an improper use of AOP, one \nin which it is misused to implement a questionable design. Surely, such abuse of concepts is possible \nin all programming paradigms. But my main concern is not reverting to some design ideal thought to be \nlong overcome (the division of a program into functions corresponding to steps or phases of processing, \nwhich may in fact be justified even in OOP); my main concern is the ex\u00adistence of a strong coupling between \nan aspect and its target, par\u00adticularly if this coupling is left implicit, that is, not reflected in \nan explicit interface; since this impairs independent development. And this is the same, at least as \nfar as I can see, for all but the most trivial crosscutting concerns factored out to aspects: when code \nis moved out of its context to some other place, it must take (a reference to) the context that it depends \non with it, thereby es\u00adtablishing a coupling between its old and its new location. Only if the context \nthat it depends on is already published in the interface of its old host, independent development will \nnot be compromised by this move. Given that classes hide design decisions, my feeling is that this will \nnot often be the case. Therefore, the effect of AOP is likely less (or worse) modularity and not more \n(or better). Now I will not ignore that data encapsulation as realized in ob\u00adject-oriented programming \nlanguages \u00e0 la Java is not without problems. In fact, it is often difficult, or even impossible, to as\u00adsign \nprocedures to a class so that they depend only on the data structure represented (or hidden) by that \nclass, and no other. The availability of C++ s friend functions and so-called multi-methods (methods \nwhose late binding depends on the dynamic types of the receiver and the parameters) in other languages \nprovide sufficient evidence for this. But as far as I can see, modularity problems of this kind can only \nbe solved by introducing units larger than sin\u00adgle objects (or their classes) as modules. Splitting a \nclass into a class and an aspect produces smaller, strongly coupled units; it leads to more and larger \ninterfaces, which is counterproductive to improving modularity. 5.1.3 Modularity and Interfaces For \nall I know, the concept of a module is meaningless without that of an interface.13 Interfaces form the \nborders between mod\u00adules across which control flow and data is passed; they specify the functions that \ncan be called and the variables that can be ac\u00adcessed.14 Interfaces represent the coupling between modules \nonly if the interface between two modules is empty are the mod\u00adules completely decoupled. If the interface \nis not empty, modules are decoupled to the extent that changes on either side are admis\u00adsible without \nnotice as long as the interface is kept constant. Note that this is independent of what is explicitly \nspecified in the pro\u00adgram text to be the interface: interfaces between modules exist regardless of what \ncan be (or is) declared by the available means of the programming language used. However, leaving interfaces \nimplicit is a bad start for independent development; quite the con\u00adtrary, to ensure independent development, \nas much must be made explicit as possible. 13 Both Gauthier &#38; Pont and Brooks above stress the significance \nof inter\u00adfaces in connection with modules, which has been a consistent theme in Parnas s writings. Also, \nthe ACM Computing Classification System lists modules and interfaces as one common entry (under D.2.2, \nDesign Tools and Techniques ). 14 Depending on definition, interfaces also specify protocol, that is, \nthe sequence in which procedures can be called and variables can be ac\u00adcessed. Certainly, this information \nwas part of the interface Parnas had in mind. However, most contemporary programming languages support \nonly weaker notions of interfaces, namely sets of signatures. The re\u00admaining information must be communicated \nusing means outside the programming language (that is, specification or documentation). 5.1.4 Provided \nand Required Interfaces Work on component-based programming, which relies heavily on components as modules \nand on the explicit specification of the in\u00adterfaces between them, has led to the notion that interfaces \ncome in two complementary forms: a module can have provided and required interfaces, and one module s \nrequired interface is an\u00adother module s provided interface. A provided interface is basi\u00adcally a collection \nof program elements a module offers to its cli\u00adents. A required interface on the other hand is a set \nof program elements a module needs from some other module for performing its function. In a system composed \nof modules, there needs to be a match between each required interface of one module and a pro\u00advided interface \nof another. It is instructive to try and apply these terms to aspects (as mod\u00adules) and their targets \n(advised or base modules). Clearly, the items passed between the target and an aspect (C, A) are captured \nby the context attached to (C, A), which qualifies for an interface specification. But is this interface \na required or a provided inter\u00adface? Because the aspect provides a particular service through which it \nextends a program, one might be led to think of it as a provided interface. However, the matching required \ninterface of the target remains implicit the target program does not specify that it needs something, \nlet alone specify what precisely it needs. Therefore, there is no visible (as made explicit by a required \ninter\u00adface) coupling between the target module and the aspect the tar\u00adget does not appear to depend on \nthe aspect. From a different viewpoint, one might argue that it is actually the target module that provides \na set of program elements, which are required by the aspect to perform its function. And indeed, the \naspect specifies a required interface in the guise of its condition C: it specifies the program elements \nthe aspect needs to query from its target in order to achieve its function (see Ostermann et al. [51] \nfor a similar view). This reflects the inversion of depend\u00adency [49] so characteristic of AOP: technically, \nalthough the as\u00adpect complements the target program, the aspect depends on the target and not vice versa. \nHowever, despite this dependency the target module comes without an explicit counterpart interface specification: \nits provided interface is implicit at best. Seen either way, the target specifies no interfaces that \ncould be matched with those of its aspects. For the programmer of the tar\u00adget module this means that \nthere is no visible (explicit) coupling and, more importantly, that there is nothing to keep constant \nacross all possible changes of the secrets of the module. This however ignores the part of the aspects \nwhich do specify inter\u00adfaces that must not change if the aspects are to remain unaffected by target module \nmodifications. Now one might argue that requiring aspects and their targets to explicitly specify provided \nand required interfaces is unfair; after all, the interface between a class and its subclasses is not \nonly not divided into a provided and a required interface, it is also mostly implicit in most object-oriented \nprogramming languages in use today (except for the rather weak notion of declaring members as protected \n). While this is certainly correct, it is also widely ac\u00adcepted as substantial and valid criticism of \nOOP as a form of modular programming: in fact, as exposed by the so-called fragile base class problem \n[46], subclassing breaks the modularity of classes. Needless to say that subclassing impedes independent \nde\u00advelopment unless (a) the implicit interface between a class and its subclasses is made explicit, or \n(b) a class and all its subclasses are assigned to the responsibility of one team, and can thus be re\u00adgarded \nas one module. Surely, adding interfaces on the targets side means giving up much of the attractiveness \nof the approach, and packaging a class and its aspects into one module is counter to the intent of AOP. \nBut denying attacks against the claimed modularity of AOP by pointing at similar weaknesses in object\u00adoriented \nprogramming is no way out of this dilemma. 5.1.5 Modularity and Dynamic Interfaces It should be clear \nthat resorting to a purely dynamic AOPL (whose conditions make no reference to static parts of a program) \nis no escape: even if dynamic interface specifications (behavioral interface specifications [67] for \nexample or event sequence speci\u00adfications [3, 37, 65]) are supported by an AOPL, in order to also support \nmodularity (viz. independent development), they will have to be provided at both sides, the target s \nand the aspect s. In particular, mutual conformance of the interfaces, as well as adher\u00adence of the implementations \nto their interfaces, are promises made at development time. After all, this is what modularization is \nabout. 5.1.6 The Modularity of Aspects Now one could argue that while modularity of the (crosscut) tar\u00adget \nprogram is sacrificed, modularity of the crosscutting concerns is won, and that this may be better in \ncertain cases. However, crosscutting concerns may crosscut each other, and whenever the actions introduced \nby an aspect are part of the program and thus candidates for aspect application (as is the case for instance \nin AspectJ), the modularity of aspects is broken in exactly the same way as that of target programs. \n 5.1.7 Summary Introducing explicit interfaces on the target modules side (includ\u00ading annotations that \nindicate where aspects can apply) can declare the coupling with possible aspects, but then, as argued \nin Section 4.1, aspect activation not only becomes almost indistinguishable from late bound, guarded \nsubroutine calling, it also re-introduces the very scattering AOP was to avoid. On the other hand, more \nabstract interfaces on the targets side would require equal relaxa\u00adtion of the required/provided interfaces \non the aspects side, but it is unclear how an aspect (or any system functionality for that mat\u00adter) can \nbe programmed without concretely specifying somewhere what it needs access to. Once again, it may be \nmy lack of imagi\u00adnation, but I can see no way of fixing this situation to me, it ap\u00adpears that the idea \nof AOP is at odds with interfaces and thus also with modularization. (For a detailed discussion of related \nwork, see the appendix). To conclude: There may be means other than data encapsulation to realize information \nhiding as a design discipline, but one in\u00advariant is that they must grant independent development. While \nI agree that independent development is an important problem of programming even today, I find it hard \nto accept that the notion of a module as one of the most fundamental to software engineer\u00ading is reinterpreted \nto the extent that its original meaning is no longer recognizable. A module is (and unless we manage \nto dele\u00adgate programming to machines entirely, will continue to be) a unit of independent development, \nfor such a concept is (and most probably always will be) needed. If aspects don t support it, please \ndon t call them modular. Call them something else.  5.2 AOP and the Organization of Source Code Regardless \nof whether aspects modularize, one could still argue that they are a good way of organizing source code. \nSince indeed every nontrivial application comes with several more or less inde\u00adpendent criteria according \nto which its source code could be struc\u00adtured, and since both scattering and tangling of code is in fact \na nuisance, such is a legitimate goal. In fact, the late Dijkstra, whose works are also commonly cited \nin the AOP community (and seem to be the bibliographical sources of the term separa\u00adtion of concerns \n[16, 17]), applied considerable thought to the organization of source code. But as it turns out, AOP \nis also at odds with the work of Dijkstra, in particular the idea of structured programming. In his famous \nletter to the Communications of the ACM titled Go to statement considered harmful Dijkstra argued that \na programming lan\u00adguage should set up a coordinate system according to which any trace of a program is \ndescribable as a simple set of coordinates telling one precisely where the program is, and how it got \nthere (by knowing the previously executed statement). For a sequence of statements and for a branch such \na coordinate would be the program pointer (telling one that the program got there from the statement \npreceding in program text, including how a possible prior condition evaluated), for a loop the program \ncounter plus a loop counter, and for a subroutine the program counter plus an\u00adother program counter pointing \nto the site where the subroutine was called (basically the call stack). Dijkstra stressed that the co\u00adordinate \nsystem was to be set up automatically by the program\u00adming language, not the concrete program (and hence \nnot the pro\u00adgrammer). In other words, program organization should be pro\u00admoted by the programming language, \nand not left to the wisdom of the programmer. Dijkstra s complaints led to the maxim that each control \nstructure of so-called structured programming should have precisely one entry and one exit point. Goto \nstatements break this condition, torpedoing all conceivable coordinate systems. Now it can be ar\u00adgued \nthat the net effect of AOP on any of the mentioned control structures is equally destructive: since an \naspect can plug into just about any point of execution of a program, one can never tell the previous \n(or following) statement of any statement. In fact, as has been pointed out in AOP considered harmful \n[13], AOP intro\u00adduces a modern variant of the comefrom statement, which was once suggested as a humorous \ncontribution to the goto discus\u00adsion, the joke being that such an inverse form of calling very much like \nthe implicit invocation mechanisms of AOP [20] renders even small programs completely unreadable [9]. \nToday, Dijkstra s demand for a firm coordinate system is no longer dogma. In fact, as regards the single \nentry and exit point criterion, we now know that having multiple exit points from con\u00adtrol structures \ncan improve readability of programs, even though the reader does not know (without additional pointers) \nthe state\u00adment executed immediately before the exit. The reason that we accept this breaking with formal \nstructuredness is that the alterna\u00adtive, introducing guards that result in skipping the rest of a control \nstructure, is often worse. Allowing multiple entry points, on the other hand, is widely rejected, but \nnot because they formally break with Dijkstra s suggested coordinate system, but because experience has \nshown that they are rarely needed, yet are almost always difficult to understand. So we should take Dijkstra \ns coor\u00addinate system as one attempt at an explanation for what it takes for a human to be able to map \nthe dynamic control flow of a pro\u00adgram to its static structure. Now Dijkstra s argument can be seen as \nbasically one about the property of locality in programs. As discussed by Filman and Friedman [22, 23], \nmany advances in the history of programming have broken with locality; in fact, even subroutine calling \n(as one of the four basic structured control structures) does. While Dijkstra s suggested coordinate \nsystem takes the non-locality of subroutines into account (by adding to the coordinates a pointer to \nthe call site), the next step in programming language history, dy\u00adnamically bound procedure calls, require \naddition of yet another pointer, namely one pointing to the bound procedure, for without this, one would \nnot know which the statement executed immedi\u00adately before the one statically succeeding the call was. \nExperience with object-oriented programming has shown that this advance\u00adment leads to problems in program \nunderstanding, in particular in (mentally) tracing program execution. This is worsened by the fact that \nin languages with dynamic class loading (such as Java), the number of possible branches depends on the \nconfiguration of a system, that is, on the set of alternative implementations (sub\u00adclasses) provided \nat execution time. The implicit invocation of aspects can be viewed as the next logi\u00adcal step in this \ndevelopment. In order to know the predecessor (in execution) of a statement, one must only add a pointer \nto the as\u00adpect just called (if any). The problem is that the points in the pro\u00adgram in which I need this \npointer (the selected join points) are not marked in place, as is the case for a (statically or dynamically \nbound) explicit procedure call. Even with tool support annotating the so-called join point shadows [31] \nin the program text (that is, the places where advice may be called), these places depend on the final \nconfiguration of the system, that is, the number and kind of aspects added (cf. Footnote 9). This is \nin contrast to the prob\u00adlem induced by dynamically bound procedure calls, in which I know, independent \nof configuration, where I need a pointer to the called procedure (only to which procedure I may not know). \nThus, AOP adds another dimension of not knowing what just happened, or where I have come from, to programming. \nThe question is whether the possible gains are worth the confusion it causes. Certainly, more time will \nhave to be allowed before this latter question can be answered. However, I will allow myself a little \nspeculation here. While trading understandability of a program for expressiveness of a language may be \nin the tradition of progress in computing, it seems to me that AOP is pushing expressiveness a little \ntoo far. Surely, it is still some way from unconstrained metaprogramming (which is thought to be too \ndifficult to be mas\u00adtered by the average programmer), but it may just be that a healthy trade-off between \nexpressiveness and understandability has already been found, and that this trade-off does not include \nthe implicit invocation mechanisms of AOP. 5.3 AOP and the Globalization of Local Variables In the wake \nof Dijkstra s letter, many other programming con\u00adcepts were questioned along similar lines of argumentation. \nAmong them, and with direct relevance to AOP, is an article by Wulf and Shaw titled Global variable considered \nharmful [66]. In it, the authors argue that visibility of variables outside a pro\u00adgram segment under \nconsideration strain the intellectual abilities of programmers, because of the phenomena of indiscriminant \naccess and vulnerability , where the former reflects the fact that the declaror [sic] has no control \nover who uses his variables; the latter reflects the fact that the program itself has no control over \nwhich vari\u00adables it operates on. Both problems force upon the pro\u00adgrammer the need for a detailed global \nknowledge of the program which is not consistent with his human limitations. [66] Transferred to AOP, \nthe declaror of a variable is the target pro\u00adgram, which indeed has no control over which aspects use \nits variables, and the program is the aspect which, if programmed without knowledge of the target, has \nno control over which vari\u00adables it operates on . Because of its very nature, AOP not only makes the \ncontrol flow unobvious from the program text, it also effectively globalizes all variables aspects can \nget access to. The conclusion drawn by Wulf and Shaw that in the presence of global variables programmers \nneed a detailed global knowledge of the program is therefore also true for the presence of aspects (cf. \nalso, for example, the work of Aldrich, Clifton, Kiczales, and their co-workers [2, 10, 34]). While the \nglobalization of local variables is a worrying problem, there is another one related to context that \nsomewhat alleviates it, but at the same time severely restricts the feasibility of AOP: the problem of \nhow to get hold of the context needed by an aspect. While it is difficult enough for a simple aspect \nto specify in itself (that is, locally) the context it needs access to in such a way that the specification \napplies to all points of a program which the as\u00adpect is to address (Sullivan et al. [63] provide a list \nof such prob\u00adlems found using AspectJ), more complex crosscutting behavior is much more intertwined with \na single location of the target (it may in fact involve multi-point patterns in both time and space), \nand also much more diverse in its appearance among different loca\u00adtions. Also, in all but trivial cases \ncombining separated concerns ( weaving ) will be much harder than inserting one concern be\u00adfore, after \nor around another (see Ernst [21] for a concrete exam\u00adple of this). To phrase it in mathematical terms: \nAOP is based on the assumption that crosscutting concerns are scalars that can be factored out of a vector \n(a program) without leaving a trace, and that this factoring out (separation of concerns) can be reversed \nwithout any loss in meaning; however, weaving an aspect into a program is not always as simple as multiplying \na scalar with a vector.  6. Some Observations on the Use and Usefulness of AOP As expressed in some \ndetail in the previous section, my opposi\u00adtion to aspects and AOP as a programming discipline is based \nmainly on my impression that it dismisses basic software engi\u00adneering principles, and that in order to \nrestore these principles, it must be stripped of its key characteristics. On the other hand, ad\u00adhering \nto these principles is not always compulsory, so that there are application domains in which AOP should \nbe unproblematic. However, is seems to me that domains of this kind are not core to the motivation of \nAOP; rather, what I find amply are application examples that, besides suffering from the modularity and \nstructur\u00ading problems discussed above, are questionable with regard to AOP s net effect on systems. To \nmake my point clearer, I will contrast examples for which I believe AOP may be useful with examples of \nhow it seems to be actually used. 6.1 Usefulness of Aspects in Generated Code First and foremost, AOP \ns unpunished use should be granted where modularity and structuredness are unimportant. This is for example \nthe case in code generation, where the generated code not the source to the generation! may be aspect \noriented without causing any problems of the above mentioned kind. Thus, it would seem that natural application \nareas of AOP are ad hoc lan\u00adguage extensions (including domain-specific languages) and model-driven development \n(MDD). The former could for instance enhance an existing OOPL with language constructs specific for security, \ntransaction management, or design by contract. The lat\u00adter seems particularly interesting since the primary \nassets of MDD, models, usually come with many different views of a sys\u00adtem which, like aspects, need \nto be woven together. And yet, model integration that is, the integration of the information con\u00adtained \nin diagrams of various kinds is still mostly an open prob\u00adlem in modeling, and it will be interesting \nto see whether AOP can actually contribute to its solution [60]. 6.2 Usefulness of AOP for Component-Based \nProgramming Also, I believe that AOP is useful where proper modules are a hindrance rather than an advantage. \nIronically, this is to a certain extent the case in component-based programming: namely in the special \n(but not infrequent!) situation in which a composite cannot be formed out of available components without \nbreaking into them that is, without disrespecting their designed interfaces. In\u00addeed, in the non-ideal \nworld of programming practice, available components sometimes happen to be one bit off what is actually \nneeded (see Kiczales et al. on open implementations [33] for an account of such cases), and the alternatives \nto breaking modular\u00adity seem just as unattractive. In these cases, AOP-related tech\u00adniques may digest \ncomponents (that is, dismantle and reassem\u00adble them) to form a new whole, giving this whole a new hull \npro\u00adviding the interface to the rest of the world. Seen this way, AOP grants the writers of so-called \nglue code entirely new possibilities. The price is, obviously, that because the inner components are \nno longer modules, they cannot be evolved independently; instead, the newly formed component must be \nseen as an atomic whole that can only be read, understood, and changed in toto. Because this procedure \nof digesting components can be applied recur\u00adsively, it can be abused to destroy all modularity in a \nsystem, turning it into one big monolith comprising what used to be mod\u00adules.15 Thus, it must be used \nwith measure; in particular, because of the above-mentioned lack of independent evolvability associ\u00adated \nwith it, I don t think that it is justified to found a new disci\u00adpline of modular software development \non it.16 6.3 Observed Uses of AOP While AOP seems to be useful for the above-mentioned coding problems, \nit appears that it is mostly used to solve quite different ones. When looked at more closely, some of \nthese examples show that AOP can be used to fix problems to which it itself (although not alone) contributes. \nI admit that my observations presented in 15 An alternative way of looking at it is that there exist \nno modules prior to system composition, and that modularization takes place only after this composition \nhas been done [34]; see the appendix for a discussion. 16 Aspectual collaborations [41, 52, 53] as promoted \nby Ovlinger et al. are an alternative approach to combining aspects and modularity in the form of components; \nagain, see the appendix. the following are somewhat nit-picking, nevertheless I think that the motivation \nof a new programming model should not resort to examples that can be attacked so easily. 6.3.1 Aspects \nfor Logging, Tracing, and Debugging Logging, tracing, and debugging are perhaps the canonical appli\u00adcations \nof AOP they are returned to almost universally in papers on the subject. Although we already have excellent \ntools for log\u00adging, tracing, and debugging at hand that work without AOP (take for instance the Eclipse \nIDE), I will accept that AOP can offer an alternative approach. However, since generally aspects can \nplug their advice into just about any point in a program s execution, tracing, logging, and debugging \nbecome important concerns even in programs that without aspects would not need them (because they have \nbeen written in such a way that program flow is obvi\u00adous from its static structure, or that the program \nis obviously cor\u00adrect). In the extreme case, one will find oneself introducing a trac\u00ading, logging, or \ndebugging aspect only to trace, log, or debug other aspects executed. So in a way, while helping to solve \na par\u00adticular category of programming problems, AOP also adds to them. 6.3.2 Aspects for Security Issues \nAn aspect can intrude into a program (its components, or mod\u00adules) in order to implement security, but \nwhat if it fails to do so? What if it never intended to? Can security aspects be installed that check \nthe validity of aspects, that authorize and/or authenticate them? Perhaps they can, but not only is this \na bootstrapping prob\u00adlem (or are there aspects that can ensure their own security?), but this also poses \nthe question of what the net effect of AOP on sys\u00adtem security is. As with tracing/logging/debugging \nabove, not all applications will explicitly need to address security issues, but if they are executed \nin an AOP environment, they had better do so. 6.3.3 Aspects for Program Verification Aliasing is a well-known \nproblem for the verification of object\u00adoriented programs, since an alteration of one object s value (as \naddressed through a reference) can change the value of what ap\u00adpears to be another object, but is really \nthe same object addressed by a different reference (its alias) [32]. In short, with aliasing the simple \nverification problem {x.a = true} y.a := false {x.a = true} can become quite hard to prove in a modular \nfashion, because x and y might refer to the same object. With AOP, the problem becomes even worse, because \naspects may access and change the values of variables in their context even between the executions of \ntwo consecutive statements. In fact, the above aliasing problem can be rephrased as an aspect problem \nof program verification: in an aspect-oriented program, it is unclear how {x = true} y := false {x = \ntrue} could be proven correct without performing a whole-program analysis. Once more, aspects can come \nto the rescue, by introduc\u00ading runtime verification of programs (for example, Bodden &#38; Stolz [6, \n62] and Lorenz &#38; Skotiniotis [43]); however, introduc\u00ading aspects that verify programs with aspects \n(including them\u00adselves) [36] sounds more like an academic exercise than a practi\u00adcal thing to do. To \nparaphrase Hoare, one should strive to write programs in such a way that they obviously contain no bugs; \nwith AOP, however, the best a programmer not aspect aware can achieve is write programs that contain \nno obvious bugs.  6.4 Conclusion The telephone was first used for broadcasting concerts, and radio for \npeer-to-peer communication. The gramophone was thought to be a replacement for newspapers, and Gutenberg \ns moveable type was designed to reproduce exactly handwritten letters. In each case, it took many years \nuntil a truly successful use of the inven\u00adtion was found. I wouldn t be surprised if AOP ended up being \nused for something quite different from what it is thought to be good for today.  7. New Programming? \nIf I am right and if the problems I discussed above are all real problems of AOP, why, then, is it such \na success? Is it a success? Measured in terms of the number of successful commercial pro\u00adjects, it is \nperhaps still too early to judge. Measured in terms of the attention it receives, in academic circles \nin particular, it must be called a tremendous success. After only a few years, accep\u00adtance rates of the \nAOSD conference the venue of the AOP community seem to settle at approx. 20% (a score comparable to that \nof this conference (OOPSLA), which is now in its 21st year), and other major conferences in the field \nof programming have installed their own AOP tracks. In fact, within an extremely short period of time \nafter its inception the number of papers and theses on the subject has risen beyond what can reasonably \nbe overseen by a single researcher, a growth that is comparable only to the greatest revolutions in the \nhistory of programming. There are several possible explanations to this phenomenon. One is given in Gabriel \n&#38; Steele s report The evolution of Lisp [58], in which the authors describe a general evolution pattern \nof pro\u00adgramming languages. According to this pattern, a successful lan\u00adguage requires an acceptance group \nthat is itself successful. Ac\u00adceptance in turn requires, among other factors, solving a pressing problem \nand having the right cachet. Surely, AOP addresses an important problem, namely the modularization of \ncrosscutting concerns, but the jury is still out on whether AOP can actually solve it (I have certainly \nwritten enough about my doubts in this essay). Regarding cachet, AOP seems to have plenty: it has the \naura of a leading edge technology, it is supported by a number of OOP luminaries, and it comes with its \nown fancy lingo. In fact (and referring to [58] for an example of right cachet ), seen from the outside \nwatching someone do AOP is a little like watching someone own a Mac: one is not really sure of its advantages, \nbut is willing to accept that it is superior technology. But there is also a simple economics-based explanation \nfor the success of AOP in academia. The last revolution in program\u00adming object-oriented programming is \nalready more than a generation old, and although many new things have been tried since, none has had \ncomparable impact. As a result, tremendous pressure (in the form of program committees expecting new \nideas to be presented and funding agencies waiting for new, promising strains of research to be financed) \nhas built up, and it is quite clear to everyone that the next big thing will attract enormous atten\u00adtion \nand resources. We have all been asking ourselves what this thing could be. AOP blesses us with a whole \nconcert of innovations: a new way of structuring code [64], resulting in new kinds of modules with new \ninterfaces [34], allowing new ways of composition [45], etc. In fact, there are so many new concepts \n(or, rather, new variants of old concepts) attached to AOP that one cannot help but view it a new programming \nparadigm. Therefore, from a purely phe\u00adnomenological standpoint it certainly qualifies as the next big \nthing in programming, as the post-object programming mecha\u00adnism [20].  Economically, the last century \nended with the insight that tradi\u00adtional laws are not easily put to rest: the much praised new econ\u00adomy \nturned out to have some really old problems. Old modu\u00adlarity, interfaces, and independent development \nare so fundamen\u00adtal to disciplined programming that it is difficult to imagine how they could be replaced \nwith new variants. Instead, it may be that the belief in AOP is just a belief in new programming.  8. \nConclusion Given that AOP has set out to modularize crosscutting concerns (its methodological claim), \nbut by its very nature (its mechanics) breaks modularity, I think the current success AOP enjoys is paradoxical. \nFor all I can see, this paradox cannot be resolved by adjusting the mechanics of AOP so as to respect \nmodularity, since then whatever remains of it appears to be only mildly different from other programming \ntechniques currently not thought of as being aspect-oriented. As a way of organizing source code, AOP \nhas its merits, namely the localization or compartmentalizing [40] of code belonging to one concern in \none place, but almost ironically, this requires sacrificing locality ( local in that [a state\u00adment] was \nalmost always proximate to the statements executing around it [22], p. 22) and thus structuredness in \nDijkstra s sense. The net effect on program understandability is not indisputable. I would feel much \nbetter about AOP if it gave up its modulariz\u00ading the un-modularizable [40] promise and instead focused \non blending its key concepts with those of other programming mod\u00adels17, reserving its unbridled use for \ncoding problems for which modularity and structuredness are no issues. Alternatively, it could provide \nus with a definition of what it is that is consistent with what it aims to be good for. 17 the coherence \nrequested in the call for this conference! &#38;#169; 1993 IEEE Epilogue If you think that my claims \nare polemic, or those of a cynic, or of an envier, I will agree, yet only to the extent of admitting \nthat they are somewhat overstated. But why am I doing this? During my works on my doctoral thesis in \nMedical Informatics back in the early nineties, I looked into Lotfi Zadeh s fuzzy set theory. At that \ntime, the theory was already a generation old, and Charles Elkan s The paradoxical success of fuzzy logic \n[19] had just appeared. In the same year, James Bezdek wrote the fol\u00adlowing in the editorial of the inaugural \nissue of the IEEE Transac\u00adtions on Fuzzy Systems: Every new technology begins with naive euphoria its \nin\u00adventor(s) are usually submersed in the ideas themselves; it is their immediate colleagues that experience \nmost of the wild enthusiasm. Most technologies are overpromised, more often than not simply to generate \nfunds to continue the work, for funding is an integral part of scientific devel\u00adopment; without it, only \nthe most imaginative and revolu\u00adtionary ideas make it beyond the embryonic stage. Hype is a natural handmaiden \nto overpromise, and most technolo\u00adgies build rapidly to a peak of hype. Following this, there is almost \nalways an overreaction to ideas that are not fully developed, and this inevitably leads to a crash of \nsorts, fol\u00adlowed by a period of wallowing in the depths of cynicism. Many new technologies evolve to \nthis point, and then fade away. The ones that survive do so because someone finds a good use (= true \nuser benefit) for the basic ideas. [5] The timescale he assigned to his observation (specialized to fuzzy \nmodels) is depicted in the figure above (reproduced from the edi\u00adtorial [5] with kind permission by the \nIEEE). Now reading Bezdek s observation in the context of this essay not only uncovers its author as \na cynic, but also as one who hasn t re\u00adalized that he is as much part of the game as the ones he criticizes \nfor playing it. Yet the enthusiasts should forgive him, for his role is not an unimportant one: the earlier \nthe depth of cynicism is reached, the sooner the true user benefits are discovered, and the sooner AOP \ncan converge to the asymptote of reality. Sometimes, to be truly good, good cops need bad cops, so here \nI am, ready to take the bashing. Acknowledgments I am indebted to Alexander Pretschner, Colin Atkinson, \nEric Bod\u00adden, and especially Stefan Hanenberg for their suggestions on im\u00adproving the original manuscript. \nAlso, fourteen anonymous re\u00adviewers spent their valuable time helping shape the content of this essay \nwith their detailed comments. Needless to say, views dif\u00adfered greatly, and the sometimes conflicting \nproposals were diffi\u00adcult to integrate; yet, all expressed opinions and remaining mis\u00adconceptions are \nexclusively my own. Finally, I would like to thank my shepherd Richard P. Gabriel for conveying his sense \nof essayness to me, and for helping me form my many points into a cohesive argument. Appendix: Known \nAttempts to Restore Modularity in Aspect-Oriented Programs Pointcut Interfaces A workshop paper by Gudmundson \nand Kiczales first proposed to reduce the adverse effect AspectJ style AOP has on modulariza\u00adtion (information \nhiding) by moving the pointcut definition closer to the target modules, that is, in proximity of the \nplaces where they match [28]. For this purpose, it introduced what its authors called pointcut interfaces: \nbasically collections of pointcut signa\u00adtures (pointcut name plus argument types). According to their \nsuggestion, the definition (implementation) of the pointcut inter\u00adface, that is, the provision of a concrete \npointcut expression, is the responsibility of the module that exports the interface, which can be a class, \na package, or a whole program. This means that the declaration and the definition of the pointcut are \ncontained in the same syntactical unit, but outside the aspects that depend on it. Particularly if this \nunit is a class, it should be comparatively easy to maintain the contract of a pointcut interface (keep \nthe interface constant) when the definition of the class is changed. In order to allow independent development \nof target modules and aspects, pointcut interfaces should be defined together with all other mod\u00adule \ninterfaces that is, at the project s outset (with modifications possible as the design evolves). It is \nnot obvious to me why the idea of pointcut interfaces, which was picked up by other authors (for example, \n[1, 2, 27, 63], all discussed in the following subsections), appears to have not been pursued further \nby Kiczales, who now seems to favor other kinds of aspect interfaces ([34]; also discussed below). One \npossible reason for this may be that in order to have the linguistically en\u00adforceable effect of pointcut \nawareness, it is not sufficient that pointcuts reside in the proximity of the target modules they apply \nto: rather, the aware have to state explicitly what they are aware of. This however would amount to a \nkind of (target) tagging (comparable to that of classes declaring to implement certain in\u00adterfaces) that \nwould reduce obliviousness and increase intimacy [20, 63] as well as scattering to levels thought to \nbe incompatible with the original idea of AOP. On the other hand, just keeping pointcut definitions separate \nfrom the aspects depending on them, in some third place but without any reference from the code they \nquantify over, is not a big improvement over keeping them within the aspect. Open Modules Aldrich notes \nthat in order to retain some contribution of AOP while at the same time respecting the intended information \nhid\u00ading boundaries (aka interfaces) a compromise needs to be found [1, 2]. His so-called Open Modules \nenables aspects to advise all external uses of program elements exported in the module s pro\u00advided interface, \nas well as internal joinpoints that are declared public ( open ) by that interface. All other intrusions \nfrom as\u00adpects, including advice on internal use of published elements, are prohibited. Because in Open \nModules all interfaces toward an as\u00adpect are explicit, a module can hide the information considered as \nits secret behind these interfaces, allowing it to evolve independ\u00adently from aspects. As Aldrich himself \nnotes, the pointcut interfaces of Open Mod\u00adules can be thought of as definitions of extension points \nand the execution of advice at these points as a kind of callback to client\u00adprovided functions [1] (which \nlets the pointcut interfaces appear as required interfaces; cf. discussion in Section 5.1.3). In fact, \nas pointed out by Aldrich [2], explicitly exposing internal events in an interface pointcut means a loss \nof some obliviousness in the distributed development case, since the author of the module must anticipate \nthat clients might be interested in the event. But modu\u00adlarity is all about distributed, independent \ndevelopment (see Par\u00adnas [54, 55] and also Section 5.1), and the price for modularity is, once more, \nthe introduction of some pluggable procedure call through the back door.18 Crosscutting Interfaces Griswold \net al. suggest the introduction of crosscutting interfaces (XPIs) [27] as interfaces that base code designers \nimplement and that aspects may depend upon [63]. For this, they assign de\u00adsign rules to XPIs as a kind \nof contract which the programmers of the base code must observe. At the aspects side, each XPI comes \nwith a syntactic part that exposes the signature of named point\u00adcuts, but not its hidden implementation \n([27], p. 54), that is, the part that specifies the concrete pointcut expressions. Note that storing \nthe implementation in the interface is somewhat unusual, but must be seen as technical tribute to AspectJ \nas the language in which XPIs are currently implemented. In fact, the authors of XPIs deliberately wanted \nAspectJ to remain as is, in order not to subject their work to the lack of adoption that is usual for \nlan\u00adguage modifications [63]. However, this technicality impairs in\u00addependent module evolution to a certain \nextent, since the imple\u00admentation of the crosscutting interface is not part of the imple\u00admentation of \nthe module (cf. the discussion of Gudmundson and Kiczales s pointcut interfaces above, which suffer from \nthe same problem if the pointcut crosscuts more than a single class). Griswold et al. note that the decoupling \nof aspects from their bases through XPIs is comparable to that of a caller from the called module through \nthe provided interface (the API) of that module. In fact, just as a module can remain (and usually is) \noblivious of its specific callers (a property called feature oblivi\u00adousness in Sullivan et al. [63]), \nand although the module needs to prepare for aspects (by providing an XPI), it may remain oblivi\u00adous \nof which aspects exactly utilize this interface. However, while the API of a module is usually designed \nto serve a specific goal 18 Another criticism of Open Modules expressed by Sullivan et al. is that since \nthe pointcut interface is tied to a single (hierarchical) module, the interface is not crosscutting [63]. \nOne could add that therefore, Open Modules are not aspect oriented. Note that the same argumentation \ncan be applied to the pointcut interfaces suggested by Gudmundson and Kiczales, if they are assigned \nto single classes. (the purpose of the module), specification of the XPI requires an a priori decision \nwhat the crosscutting behavior of a system is. To address this, Sullivan et al. [63] state they designed \ntheir XPIs by ask[ing] the question, what constraints on the code would shape it to make it relatively \neasy to write the aspects at hand, as well as support future aspects? This is exactly the loss of obliviousness \nnoted by Aldrich. Restoration of Modular Reasoning Clifton and Leavens note that AOP, although heavily \nciting Par\u00adnas s article [55], is at conflict with it, basically because the obliviousness property contradicts \nthe independent comprehensi\u00adbility required of a module (a notion called modular reasoning) [10, 11].19 \nFollowing the behavioral subtyping analogy they sug\u00adgest that the effect of aspect application should \nbe checkable so as to not alter the behavior of a module in unexpected ways. For this, they suggest to \ndivide aspects into so-called spectators (formerly called observers [10]) and assistants, the former \nnot changing ( in some well-defined sense ) the behavior of the modules they ad\u00advise, the latter only \ndoing so to an extent made explicit in a suit\u00adable module interconnection specification to be found in \na well-defined place relative to the client module [11]. This would retain some of the flexibility associated \nwith the obliviousness property of AOP, and at the same time allow modular reasoning. Support for automated \nclassification of aspects as spectators comes from a whole-program analysis described by Zhao &#38; Ri\u00adnard \n[57], which is also capable of pointing to specific problems of assistants. However, it seems that the \nmodule interconnection specification suffers from the same problems as the definition of pointcut interfaces \nspanning several modules (discussed above). Also although only a marginal note even spectators can be \nharmful, if only by spying on local (private) data and passing it on to some other, malevolent party. \nFor a more detailed discussion, see Dantas &#38; Walker s recent work on Harmless advice [14]. Aspect-Implied \nInterfaces In another attempt to restore modular reasoning, Kiczales and Mezini argue that aspects cut \nnew interfaces through the primary module structure [34]. De facto, this means that a module is no longer \nsovereign over its own interfaces; rather, they are forced upon it by system composition. One immediate \nconsequence of this is that modules cannot be changed independently of their as\u00adsembly, simply because \nit is unclear which interfaces to keep con\u00adstant. This of course leads independent development and with \nit also the module concept ad absurdum. A closer look at Kiczales and Mezini s proposal reveals that \nthey suggest that a tool computes the aspect aware interfaces given a complete system configuration (cf. \nFootnote 9). While this may allow modular reasoning in the presence of aspects, it does so only after \nthe system has been composed, a stage at which mod\u00adules and their interfaces have done their service \nand might as well disappear. In fact, Parnas stressed explicitly that after assembly, two differently \nmodularized programs might conceivably be iden\u00adtical ([55], p.1055) modularization is a design-time issue! \nAlso, using the same argumentation one could demand that program\u00ad 19 The authors also touch on the verification \nproblem mentioned in Sec\u00adtion 6.3.3, namely that aspects can break the postconditions of a method in \na way that is outside the control of its programmer [10]. mers declare all members of all classes public, \nand only after sys\u00adtem composition derive which ones may be declared private. Last but not least, making \ninterfaces aspect aware by adding the computed information which aspects apply to which members of the \nprovided interface of a class does not really add to the inter\u00adface, since no client of the class except \nthe aspect from which it has been computed will ever use this information (at least not in a way that \nis enforced by the compiler). Instead, these aspect-aware interfaces publish implementation details of \nthe aspects, namely which aspect is called where. This in turn means that with the suggested aspect awareness \nof interfaces, non-locality20 is much the same as in conventional, procedure-call based implementa\u00adtions, \nwhich also need to import the modules containing the called procedures. So in a way, Kiczales and Mezini \ns proposal seems to support my observation that the problems of AOP cannot be fixed without giving up \nits distinguishing characteristics. Aspectual Collaborations The Aspectual Collaborations of Ovlinger \net al. [41, 52, 53] con\u00adtinue previous work on aspectual components, enabling recursive composition of \ncollaboration patterns as modules. So-called as\u00adpectual methods extend the usual binding between expected \n(or required) and provided interfaces by allowing a form of method call interception across modules in \nwhich the intercepting and the intercepted method can remain oblivious of each other. Aspectual Collaborations \ncan be used to implement crosscutting concerns such as caching; yet this requires an explicit composition \n(bind\u00ading) of the (collaboration representing the) aspect and the (col\u00adlaboration representing the) base. \nTherefore, Aspectual Collabora\u00adtions are more an exploitation of an aspect-oriented mechanism (method \ncall interception, which is also a standard mechanism of metaprogramming) for the purpose of component-based \npro\u00adgramming, than a general reconciliation of AOP with modularity. Information Transparency But there \nare other ways of addressing crosscutting. One such way is explored by Griswold in his work on information \ntrans\u00adparency [26], a complement to information hiding that allows the ad hoc creation of localized descriptions \nof a design concern based on similarity of the scattered code implementing it. Gris\u00adwold describes his \napproach as relying on naming conventions and other characteristics of code (including the use of particular \nvariables, data structures, etc.) that can be evaluated by a tool, and sometimes even architectural information. \nOne could add that to\u00adday, source code annotations would lend themselves to explicitly associating code \nwith concerns [56]. Perhaps the greatest advantage of information transparency over aspect-oriented approaches \nfrom a technical point of view is that it does not depend on weaving, that is, on the automatic tangling \nof code designed as separate units, but on its opposite, namely on the automatic disentangling of code \ndesigned to go together. In other words: rather than creating a system from different views of it, it \ncreates different views of a system. Whether and how these views can be used to change and extend the \nsystem, however, re\u00admains an open challenge. 20 Here, locality refers to the property that all program \nelements relating to one concern are located in a single place, which is, according to Kicza\u00adles &#38; \nMezini [34], a necessary condition for modularity.  References [1] Aldrich, J.: Open Modules: Reconciling \nextensibility and in\u00adformation hiding. In: Software Engineering Properties of Languages for Aspect Technologies \n(SPLAT). Workshop at AOSD (2004). [2] Aldrich, J.: Open Modules: Modular reasoning about advice. In: \nECOOP (2005) 144 168. [3] Allan, C. et al.: Adding trace matching with free variables to AspectJ. In: \nOOPSLA (2005) 345 364. [4] Avgustinov, P. et al.: Semantics of Static Pointcuts in As\u00adpectJ. Technical \nReport abc-2006-3 (Oxford University Computing Laboratory, 2006). [5] Bezdek, J.C.: Fuzzy models what \nare they, and why. IEEE Transactions on Fuzzy Systems 1:1 (1993) 1 6. [6] Bodden, E.: Efficient and expressive \nruntime verification for Java. In: Proceedings of the Grand finals of the ACM Student Research Competition \n2005, San Francisco (2005). [7] Bodden, E., Forster, F., Steimann, F.: Avoiding infinite re\u00adcursion with \nstratified aspects. In: NODe 2006 Objects, Aspects, Services, the Web. GI Lecture Notes in Informatics \n(2006) in press. [8] Brooks, Jr., F.P.: The Mythical Man-Month: Essays on Soft\u00adware Engineering, 20th \nAnniversary Edition (Addison-Wesley 1995). [9] Clark, L.R.: A linguistic contribution to goto-less program\u00adming. \nCommun. ACM 27:4 (1984) 349 350. [10] Clifton, C., Leavens, G.T.: Obliviousness, modular reason\u00ading, \nand the behavioral subtyping analogy. In: SPLAT (2003). [11] Clifton, C., Leavens, G.T.: Observers and \nassistants: A pro\u00adposal for modular aspect-oriented reasoning. In: Workshop on Foundations of Aspect-Oriented \nLanguages (FOAL) (2002). [12] Colyer, A., Harrop, R., Johnson, R., Vasseur, A.: AOP will see widespread \nadoption. IEEE Software 23:1 (2006) 72 74. [13] Constantinides, C., Scotinides, T., St\u00f6rzer, M.: AOP \nconsid\u00adered harmful. In: 1st European Interactive Workshop on As\u00adpect Systems (EIWAS) (2004). [14] Dantas, \nD. S., Walker, D.: Harmless advice. In: POPL, SIG-PLAN Not. 41:1 (2006) 383 396. [15] Devanbu, P.T., \nBalzer, B., Batory, D.S., Kiczales, G., Launchbury, J., Parnas, D.L., Tarr, P.L.: Modularity in the new \nmillenium: A panel summary. In: ICSE (2003) 723 724. [16] Dijkstra, E.W.: A Discipline of Programming. \n(Prentice Hall, Englewood Cliffs, New Jersey 1976). [17] Dijkstra, E.W.: On the role of scientific thought. \nIn: Edsger W. Dijkstra: Selected Writings on Computing: A Personal Perspective. (Springer-Verlag 1982). \n[18] Douence, R., Motelet, O., S\u00fcdholt, M.: A formal definition of crosscuts. In: Proc. of the 3rd Int. \nConf. on Metalevel Ar\u00ad chitectures and Separation of Crosscutting Concerns. Springer LNCS 2192 (2001) \n170 186. [19] Elkan, C: The paradoxical success of fuzzy logic. IEEE Ex\u00adpert 9:4 (1994) 3 8. First appeared \nat the 1993 National Conference on Artificial Intelligence (AAAI'93). [20] Elrad, T., Filman, R.E., Bader, \nA.: Aspect-oriented pro\u00adgramming: Introduction. Commun. ACM 44:10 (2001) 29 32. [21] Ernst, E.: Separation \nof concerns and then what? In: Position papers from the workshop on Aspects and Dimensions of Concern \nat ECOOP'00 (2000). [22] Filman, R.E., Elrad, T., Clarke, S., Aksit, M.: Aspect-Oriented Software Development. \n(Addison-Wesley Profes\u00adsional, 2004). [23] Filman, R.E., Friedman, D.P.: Aspect-oriented programming \nis quantification and obliviousness. In: Workshop on Ad\u00advanced Separation of Concerns at OOPSLA (2000). \nRevised reprint appeared in [22]. [24] Filman, R.E.: What is AOP, revisited. In: Workshop on Multi-Dimensional \nSeparation of Concerns at ECOOP (2001). [25] Forster, F., Steimann, F.: AOP and the antinomy of the liar. \nIn: Workshop on the Foundations of Aspect-Oriented Lan\u00adguages (FOAL) at AOSD (2006) 47 56. [26] Griswold, \nW.G.: Coping with crosscutting software changes using information transparency. In: Proceedings of the \n3rd International Conference on Metalevel Architectures and Separation of Crosscutting Concerns. Springer \nLNCS 2192 (2001) 250 265. [27] Griswold, W.G., Shonle, M., Sullivan, K., Song, Tewari, N., Cai, Y., Rajan, \nH.: Modular software design with crosscut\u00adting interfaces. IEEE Software 23:1 (2006) 51 60. [28] Gudmundson, \nS., Kiczales, G.: Addressing practical software development issues in AspectJ with a pointcut interface. \nIn: Advanced Separation of Concerns, Workshop at ECOOP (2001). [29] Gybels, K., Brichau, J.: Arranging \nlanguage features for more robust pattern-based crosscuts. In: AOSD (2003) 60 69. [30] Harrison, W.H., \nOssher, H.: Subject-Oriented Programming (A critique of pure objects). In: OOPSLA (1993) 411 428. [31] \nHilsdale, E., Hugunin, J.: Advice weaving in AspectJ. In: AOSD (2004) 26 35. [32] Hogg, J., Lea, D., \nWills, A., de Champeaux, D., Holt, R. C.: The Geneva convention on the treatment of object aliasing. \nOOPS Messenger 3:2 (1992) 11 16. [33] Kiczales, G., Lamping, J., Lopes, C.V., Maeda, C., Mend\u00adhekar, \nA., Murphy, G.C.: Open implementation design guidelines. In: ICSE (1997) 481 490. [34] Kiczales, G., \nMezini, M.: Aspect-oriented programming and modular reasoning. In: ICSE (2005) 49 58. [35] Kiczales, \nG., Mezini, M.: Separation of concerns with proce\u00addures, annotations, advice and pointcuts. In: ECOOP \n(2005) 195 213. [36] Klaeren, H., Pulvermueller, E., Rashid, A., Speck, A.: As\u00adpect composition applying \nthe design by contract principle. In: Proceedings of the GCSE 2000, Second International Symposium on \nGenerative and Component-Based Software Engineering (2000) 57 69. [37] Klose, K., Ostermann, K.: Back \nto the future: pointcuts as predicates over traces. In: Workshop on Foundations of As\u00adpect-Oriented Languages \n(FOAL) at AOSD (2005). [38] Kojarski, S., Lorenz, D.H.: Modeling aspect mechanisms: a top-down approach. \nIn: ICSE (2006) 212 221. [39] Laddad, R.: AOP and metadata: A perfect match. In: AOP@work (http://www-128.ibm.com/developerworks/java, \n2005). [40] Lesiecki, N.: Improve modularity with aspect-oriented pro\u00adgramming (http://www\u00ad128.ibm.com/developerworks/java/library/j-aspectj/, \n2002). [41] Lieberherr, K.J., Lorenz, D.H., Ovlinger, J.: Aspectual col\u00adlaborations: combining modules \nand aspects. The Computer Journal 46:5 (2003) 542 565. [42] Lopes, C.V., Dourish, P., Lorenz, D.H., Lieberherr, \nK.: Be\u00adyond AOP: toward naturalistic programming. In: OOP\u00adSLA'03 Special Track on Onward! Seeking New \nParadigms &#38; New Thinking. ACM (2003) 198 207. [43] Lorenz, D.H., Skotiniotis, T.: Extending design \nby contract for aspect-oriented programming. http://arxiv.org/abs/cs.SE/0501070. [44] Masuhara, H., Kiczales, \nG.: Modeling crosscutting in aspect\u00adoriented mechanisms. In: ECOOP (2003) 2 28. [45] Mehner, K., Rashid, \nA.: Towards a generic model for AOP (GEMA). Technical Report CSEG/1/03, Computing Depart\u00adment, Lancaster \nUniversity, UK (2003). [46] Mikhajlov, L., Sekerinski, E.: A Study of the fragile base class problem. \nIn: ECOOP (1998) 355 382. [47] Murphy, G., Schwanninger, C.: Aspect-oriented program\u00adming. IEEE Software \n23:1 (2006) 20 23. [48] Nagy, I., Bergmans, L.: Towards semantic composition in aspect-oriented programming. \nIn: 1st European Interactive Workshop on Aspects in Software (EIWAS). (Berlin, Ger\u00admany 2004). [49] Nordberg, \nIII., M. E.: Aspect-oriented dependency inversion. In: Workshop on Advanced Separation of Concerns in \nOb\u00adject-Oriented Systems at OOPSLA (2001). [50] Ossher, H., Tarr, P.: Hyper/J: Multi-dimensional separation \nof concerns for Java. In: ICSE (2001) 729 730. [51] Ostermann, K., Mezini, M., Bockisch, C.: Expressive \npoint\u00adcuts for increased modularity. In: ECOOP (2005) 214 240. [52] Ovlinger, J.: Modular programming \nwith aspectual collabo\u00adrations. In:OOPSLA 2002 Doctoral Symposium (2002) 16 17. [53] Ovlinger, J.: Combining \nAspects and Modules. PhD Thesis (College of Computer and Information Science, Northeastern University, \nBoston, USA 2004). [54] Parnas, D.L.: Information distribution aspects of design methodology. In: Information \nProcessing 71, Proceedings of the IFIP Congress 1 (North-Holland, 1972) 339 344. [55] Parnas, D.L.: On \nthe criteria to be used in decomposing sys\u00adtems into modules. Commun. ACM 15:12 (1972) 1053 1058. [56] \nRevelle, M., Broadbent, T., Coppit, D.: Understanding con\u00adcerns in software: insights gained from two \ncase studies. In: IWPC (2005) 23 32. [57] Rinard, M., Salcianu, A., Bugrara, S.: A classification sys\u00adtem \nand analysis for aspect-oriented programs. In: Proceed\u00adings of the 12th ACM SIGSOFT International Symposium \non Foundations of Software Engineering (2004) 147 158. [58] Steele, Jr., G.L., Gabriel, R.P.: The Evolution \nof Lisp. http://dreamsongs.com/NewFiles/HOPL2-Uncut.pdf [59] Steimann, F.: Why most domain models are \naspect free. In: 5th Aspect-Oriented Modeling Workshop AOM at UML (2004); revised version appeared as \nRef. [60]. [60] Steimann, F.: Domain models are aspect free. In: MoDELS 2005, 8th International Conference \non Model Driven Engi\u00adneering Languages and Systems (2005) 171 185. [61] St\u00f6rzer, M., Graf, J.: Using \npointcut delta analysis to support evolution of aspect-oriented software. In: 21st IEEE Interna\u00adtional \nConference on Software Maintenance (2005) 653 656. [62] Stolz, V., Bodden, E.: Temporal assertions using \nAspectJ. In: RV'05 5th Workshop on Runtime Verification (Edinburgh, Scotland, UK, 2005). [63] Sullivan, \nK.J., et al.: Information hiding interfaces for as\u00adpect-oriented design. In: Proc. 10th European Software \nEng. Conf. Held Jointly with 13th ACM SIGSOFT Int l Symp. Foundations of Software Eng. (ESEC/FSE 2005) \n(ACM Press, 2005) 166 175. [64] Tourw\u00e9, T., Brichau, J., Gybels, K.: On the existence of the AOSD-evolution \nparadox. In: Workshop on Software-Engineering Properties of Languages for Aspect Technolo\u00adgies (SPLAT). \nWorkshop at AOSD (2003). [65] Walker, R.J., Viggers, K.: Implementing protocols via de\u00adclarative event \npatterns. In: SIGSOFT FSE (2004) 159 169. [66] Wulf, W., Shaw, M.: Global variable considered harmful. \nSIGPLAN Notices 8:2 (1973) 28 34. [67] Zhao, J., Rinard, M.C.: Pipa: A behavioral interface specifi\u00adcation \nlanguage for AspectJ. In: Fundamental Approaches to Software Engineering, 6th International Conference \n(2003) 150 165.  \n\t\t\t", "proc_id": "1167473", "abstract": "Aspect-oriented programming is considered a promising new technology. As object-oriented programming did before, it is beginning to pervade all areas of software engineering. With its growing popularity, practitioners and academics alike are wondering whether they should start looking into it, or otherwise risk having missed an important development. The author of this essay finds that much of aspect-oriented programming's success seems to be based on the conception that it improves both modularity and the structure of code, while in fact, it works against the primary purposes of the two, namely independent development and understandability of programs. Not seeing any way of fixing this situation, he thinks the success of aspect-oriented programming to be paradoxical.", "authors": [{"name": "Friedrich Steimann", "author_profile_id": "81100654667", "affiliation": "Fernuniversit&#228;t in Hagen, Hagen", "person_id": "PP18010558", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167514", "year": "2006", "article_id": "1167514", "conference": "OOPSLA", "title": "The paradoxical success of aspect-oriented programming", "url": "http://dl.acm.org/citation.cfm?id=1167514"}