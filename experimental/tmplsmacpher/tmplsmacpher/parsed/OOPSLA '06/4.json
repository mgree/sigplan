{"article_publication_date": "10-16-2006", "fulltext": "\n Design Fragments Make Using Frameworks Easier George Fairbanks, David Garlan, William Scherlis Carnegie \nMellon University School of Computer Science 5000 Forbes Avenue Pittsburgh, PA, 15213, USA {george.fairbanks,david.garlan,william.scherlis}@cs.cmu.edu \nAbstract Object oriented frameworks impose additional burdens on pro\u00adgrammers that libraries did not, \nsuch as requiring the programmer to understand the method callback sequence, respecting behavior constraints \nwithin these methods, and devising solutions within a constrained solution space. To overcome these burdens, \nwe express the repeated patterns of engagement with the framework as a de\u00adsign fragment. We analyzed \nthe 20 demo applets provided by Sun and created a representative catalog of design fragments of con\u00adventional \nbest practice. By evaluating 36 applets pulled from the internet we show that these design fragments \nare common, many applets copied the structure of the Sun demos, and that creation of a catalog of design \nfragments is practical. Design fragments give programmers immediate bene.t through tool-based conformance \nassurance and long-term bene.t through expression of design in\u00adtent. Categories and Subject Descriptors \nD.2.2 [Software Engineer\u00ading]: Design Tools and Techniques; D.2.3 [Software Engineer\u00ading]: Coding Tools \nand Techniques; D.2.13 [Software Engineer\u00ading]: Reusable Software General Terms Design, Documentation, \nLanguages, Standard\u00adization Keywords Object-oriented Programming, Frameworks, Patterns, Design Fragments \n1. Introduction Programmers use object oriented frameworks because they provide partially-complete and \npre-debugged solutions to common prob\u00adlems, such as windowing systems and application servers. Popular \nexamples of frameworks include Enterprise Java Beans[24], Mi\u00adcrosoft .NET [4], and Java applets [23]. \nFrameworks differ from code libraries in that the framework, not the programmer, provides important parts \nof the architectural skeleton of the application [20] and, in doing so, places additional burdens on \nthe programmer. The applet shown in Figure 1 is from the original Sun Java Development Kit (JDK) and \nit has a bug in it. No amount of code inspection can reveal the bug unless you Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 06 October 22 26, 2006, Portland, Oregon, \nUSA. Copyright c &#38;#169; 2006 ACM 1-59593-348-4/06/0010. . . $5.00 also know how the applet framework \nwill drive that code. The applet framework invokes the start() method then the stop() method on the programmer-provided \ncode perhaps this much could be guessed from the method names. Additionally, the run\u00adnable framework \nwill invoke the run() method on the applet sometime after the timer.start() method is called. The bug \nis a race condition that can be reasoned about only if you know that the framework may call start() and \nstop() multiple times. public class Clock2 extends java.applet.Applet implements Runnable { ... Thread \ntimer = null; ... public void start() { if (timer == null) { timer = new Thread(this); timer.start(); \n } } public void stop() { timer = null; } public void run() { while (timer != null) { try { Thread.sleep(100); \n} catch (InterruptedException e){} repaint(); } timer = null; } Figure 1. Threaded applet example The \nprogrammer s intent during the stop() callback is to signal to the running thread that it should terminate. \nThe signal is that the timer .eld is set to null. The race condition occurs when the framework invokes \nboth start() and stop() before the thread checks the value of the timer .eld. When that happens, the \nold thread continues executing, since it missed the signal to terminate, and a new thread executes too, \nsince it was started in the second call to start(). The bug was .xed in the next release of the JDK and \nthe check for timer != null was replaced with timer == Thread.currentThread(). The burden placed on the \nprogrammer is to know when the framework will call his code. Initially, it is not apparent why this applet \nis using a thread at all. Because this is a clock applet, it needs to regularly paint the correct time \nonto the screen. It would seem reasonable to do this painting in the start() method. However, the framework \nhas an implicit requirement that the programmer complete his processing within a few fractions of a second \nin the start() and stop() callbacks because the GUI of the applet is blocked until these methods complete. \nSo, if the programmer were to just continuously paint the clock after the start() callback, the GUI would \nbe unresponsive. The creation of a background thread is to satisfy both the framework s demands and the \nprogram s purpose. The burden placed on the programmer is to know what rules his code must follow. If \nthe programmer were freed from the framework s choice of what methods get called when, he might already \nknow how to co\u00adordinate two threads to avoid a race condition. The programmer cannot rewrite the framework, \nso he must live within the frame\u00adwork s rules and some of his prior expertise cannot be used. In ex\u00adtreme \ncases, a framework provides just a single way to accomplish a task. For example, in the applet framework \nthere is only one way to .nd out what the mouse is doing. The code must register as a mouse listener, \nimplement the MouseListener interface and its re\u00adquired callback methods, and de-register. Additionally, \nthis single path to success must be coordinated with the applet s callback se\u00adquence, so registering \nalmost always happens in the init() call\u00adback and de-registering in destroy(). The burden placed on the \nprogrammer is to be more ingenious in .nding a solution within a constrained solution space. For other \nforms of reuse, such as libraries, programmers use method-level documentation and possibly method speci.cations. \nNeither of these is an appropriate place to document something like the example shown because the documentation \nwould need to be spread across many methods. Furthermore, there are other things that can be accomplished \nwith the start() and stop() methods besides coordinating a thread, so the documentation for these methods \nwould be cluttered with many if you want to do this, then ... clauses. Instead, leading framework authors \n[8] suggest that program\u00admers follow the Monkey see / monkey do rule and copy code examples in which \nother programmers have used the framework. When copying an example, you are looking for structure, much \nof which you ll typically delete because it doesn t apply, or at least not yet. When a programmer applies \nthis rule, he must recognize that the code does what he wants (e.g., coordinate a background thread with \nan applet), cull the extra details, and reproduce that code elsewhere. However, .nding such concrete \npatterns is dif.\u00adcult and time-consuming, separating out the relevant parts is error\u00adprone, and preserving \ndesign intent is impossible. It is with good reason that this practice has been termed rape and paste \nprogram\u00adming [1]. Programmers want help that provides the advantages of Mon\u00adkey see / monkey do but removes \nthe drawbacks. Ideally, this help would encode the structure of the solution, reveal relevant details \nabout the framework, avoid swamping them with information, and check conformance between their code and \ntheir intent. This paper describes two contributions toward that ideal. First, we provide an improved \ntechnique to help programmers overcome the burdens of using frameworks. The technique, called design \nfragments, is based on the representation of structural patterns in the vein of JavaFrames [12] and OOram \n[28]. To the description of what the programmer must do, we add a minimally suf.cient description of \nhow the framework will act on the programmer s code so that the programmer can reason about the code \ns interaction with the framework. Tools inside the programmer s development environment can compare the \nprogrammer s stated intent with his source code and warn him when the two diverge. Such an approach has \nclear short-term bene.t for the programmer. It promises long-term bene.ts also because design intent \nhas been expressed. For example, Sun .xed the Clock2 applet shown above between JDK 1.0 and 1.1, yet \nan internet search reveals that applets based on that 1.0 code example are still prevalent. With design \nintent expressed, the promise is that tools to check conformance would help with this and similar evolution \nproblems. In short, design fragments provide programmers with solutions, assure conformance with those \nsolutions through code analysis, and, because design intent has been captured, provide an opportu\u00adnity \nto catch errors, speed code comprehension, and improve code quality over the long-term. The second contribution \nis a detailed case study on the applet framework that examines how .fty-six applets use design frag\u00adments. \nThe case study allows us to evaluate the following hypothe\u00adses. 1. Source code that uses a framework \nis likely to follow struc\u00adtural patterns. 2. Programmers refer toexamples tolearn how to use frameworks. \n3. The effort to create a catalog of design fragments tapers off. 4. The design fragments language can \nbe used to express the patterns we discovered in the example code. Hypotheses like these are necessary \nin order for a structural pattern technique, such as design fragments or JavaFrames, to be a viable solution. \nOur results indicate that, for the most part, the hypotheses are true. In this paper we describe the \nconcepts behind design fragments in detail, the language used to express design fragments, the tooling \nwe have built that allows conformance checking between the pro\u00adgrammers code and the design fragment, \nand how we envision de\u00adsign fragments contributing to the software life cycle. We describe a case study \ninvolving the Java applet framework and analyze our hypotheses with respect to the collected data. We \nconclude by relat\u00ading design fragments to related work and describe our future plans. 2. Design Fragments \nA design fragment is a pattern that encodes a conventional solution to how a program interacts with a \nframework to accomplish a goal. It has two primary parts. The .rst is a description of what the pro\u00adgrammer \nmust build to accomplish the goal of this design fragment, including the classes, methods, and .elds \nthat must be present. This description also includes the behavior of these methods. The sec\u00adond part \nof the design fragment is a description of the relevant parts of the framework that interact with the \nprogrammer s code, includ\u00ading the callback methods that will be invoked, the service methods that are \nprovided, and other framework classes that are used. A design fragment provides a programmer with a smart \n.ash\u00adlight to help him understand the framework. This smart .ashlight illuminates only those parts of \nthe framework he needs to under\u00adstand for the task at hand. Without the smart .ashlight, a program\u00admer \nbrowsing the framework classes is swamped with private im\u00adplementation details or unable to differentiate \nthe relevant from ir\u00adrelevant. Even simple parts of a framework have enormous com\u00adplexity [17]: In the \nSwing user interface framework, the JButton class has 160 methods and .elds, while JTree has 336. Each \nframework will have its own catalog of design fragments that act like a handbook, collecting conventional \nsolutions to prob\u00adlems. Programmers can see examples of the design fragment in use by navigating from \nthe catalog to the code that implements a given design fragment. Discipline must be used when revising \ndesign fragments in the catalog, similar to the discipline used in revising code libraries with existing \nclients. Design fragments have two immediate bene.ts for program\u00admers. First, analysis tools can check \nconformance between the pro\u00adgrammer s stated intent and his source code. Second, programmers who do not \nknow a part of the framework can quickly .nd a solu\u00adtion in the catalog. We believe it is essential to \nprovide program\u00admers immediate value for their investment of effort. Once programmers have started using \ndesign fragments, long\u00adterm bene.ts arise. Since programmers have expressed their intent (e.g., this \ncode follows the Threaded Applet design fragment), it becomes pos\u00adsible to analyze the code with respect \nto that intent. Even if analysis tools are not available at the time the code is written, the expression \nof intent endures and can be checked by stronger tools available tomorrow. For example, our current tools \ncan\u00adnot check for concurrency bugs today but in the future static analysis tools from the Fluid project \n[11] could ensure correct threading behavior.  The use of design fragments allows other programmers \nto com\u00adprehend the code more quickly. At a glance it s possible to see, for example, that this is an \napplet that listens for mouse events, has a background task, and takes in parameters from HTML. Design \nfragments convey architectural information that is dif\u00adferent from and complimentary to an Acme [10] \narchitecture model.  Evolution of code is easier. As was seen in the example from the introduction, \nthe bug in the source code was detected and .xed but not before other code had cloned its structure. \nA design frag\u00adment could be marked as deprecated, causing programmers to examine their code and .x the \nbug. Note that in the example there is no single method or class that can be deprecated, only the collection \nof methods and classes that are used in a particu\u00adlar way.  Unnecessary code diversity can be reduced. \nInstead of a task being implemented slightly differently by various programmers on the same team, they \ncould standardize on a particular design fragment. This yields bene.ts in code comprehension and may \nreduce bugs. Framework authors could deliver both example ap\u00adplications, as they do now, as well as a \ncatalog of design frag\u00adments. This catalog could act as a seed crystal so programmers would use the conventional \nsolution unless they had a good rea\u00adsontodeviate.  3. Design Fragment Language In describing the design \nfragment language, we will continue to use the code example from the introduction (despite its bugs), \nshown earlier in Figure 1. The intention of the language is to express: the structure of the programmer \ns code  the behavioral requirements of the programmer s code  the relevant structure of the framework \ncode  the relevant behavior of the framework.  One of our goals is to keep the language suf.ciently \nsimple that programmers can rapidly create and comprehend design fragments. 3.1 Structure The structure \nfor the threaded applet example is shown as a UML class diagram in Figure 2. The classes above the line \nare provided by the framework. Note that only methods that are relevant to this design fragment are shown \non the framework classes. The classes below the line are roles in the design fragment and will be bound \nto the programmer s classes. The design fragment language is expressed in XML. The lan\u00adguage can refer \nto classes, interfaces, .elds, methods, return val\u00adues, and method parameters. Figure 3 shows how the \nRoleThread class is represented. The provided= no clause indicates that Ro\u00adleThread is not a framework-provided \nclass. Figure 2. Structure of threaded applet <class name=\"RoleThread\" provided=\"no\"> <implementsinterface \n name=\"java.lang.Runnable\" /> <method name=\"run\" returnvalue=\"void\"> </method> </class> Figure 3. RoleThread \nstructure 3.2 Behavior In addition to the code structure, the programmer needs to know how his code \nshould behave. The required behavior in the threaded applet example is as follows. In the start() callback, \nthe code should create a new RoleThread instance and assign it to the ro\u00adleThread .eld. In the stop() \ncallback, the code should set the ro\u00adleThread .eld to null. We use the null .eld as a signal to the thread \nthat it should terminate because calling roleThread.stop() is deprecated and unsafe. Then, in the run() \ncallback, the code should loop repeatedly while checking that the roleThread .eld has not been set to \nnull. Most of this behavior can be expressed in the design fragments language. The required creation \nof a new instance is expressed like this: requirednewinstance target= java.lang.thread.Thread argu\u00adments= \n. A required method call is expressed like this: required\u00adcallspec target= roleThread method= start arguments= \n. Additionally, freeform text can also be entered as a speci.cation: freeformspec text= By the end of \nthis method, a new thread must be running and assigned to roleThread .eld . However, note that the looping \nbehavior required in run() cannot be expressed in the current design fragments language except as freeform \ntext. Inheritance and interfaces work the same way as Java, which includes single inheritance for classes \nbut multiple implementa\u00adtions of interfaces. Constraints on behavior that are placed on su\u00adperclasses \nor interfaces are inherited by subclasses. New constraints can be added and, optionally, corresponding \nanalyses for checking the constraints. The parser ignores any constraints it does not understand. So, \nfor example, a method could be written with the following speci.cation: timingspec to\u00adtaltime= 200ms \nto indicate that the method should complete within 200ms. If desired, an analysis could be written to \nadvise the programmer on the running time behavior of his method and the likelihood that it would violate \nthe speci.cation. The behavior of the framework classes can be expressed with the speci.cations described \nabove, but it can also use some new speci.cations that are speci.c to frameworks. In the threaded applet \nexample, the programmer needs to know which framework meth\u00adods are callback methods, the sequence of \nthe callbacks, and how many times the callback can occur. The speci.cation invocation\u00adtype value= callback \nindicates that this framework method is <class name=\"java.applet.Applet\" provided=\"yes\"> <method name=\"start\" \nreturnvalue=\"void\"> <freeformspec text=\"Callback method; invoked when framework decides to initialize \nyour applet.\" /> <invocation-cardinality value=\"*\"/> <invocation-lifecycle value=\"yes\" /> <invocation-type \nvalue=\"callback\" /> <invocation-pair value=\"stop\" /> <invoked-before value=\"stop\" /> </method> ... </class> \n Figure 4. start() method in java.applet.Applet a callback, not a service method. Callback methods are \ninvoked by the framework on the programmer s code while service meth\u00adods are provided by the framework \nfor the programmer to invoke. Most callback methods are lifecycle methods but not all. On ap\u00adplets, the \nspeci.cation invocation-lifecycle value= yes would be placed on init(), start(), stop(),and destroy(), \nbut not on paint() or getParameterInfo(). Some call\u00adbacks occur in matched pairs, so the speci.cation \ninvocation\u00adpair value= stop would be placed on the start() method. Finally, placing the speci.cation \ninvoked-before value= stop on the start() method indicates that it will be invoked before the stop() \nmethod. An example of these speci.cations is seen in the framework method start() on the java.applet.Applet \nclass in Figure 4. 3.3 Bindings to Java Source Code Each time a programmer wants to use a design fragment, \nhe de\u00adclares it using a Java 5 annotation. Figure 5 shows the declara\u00adtion of a new instance named bc1 \nof the design fragment Back\u00adgroundContinuousV1. The Java 5 annotation, which applies to the demos.applets.clock \npackage, is shown italicized. This annotation lives in the special Java .le package-info.java. @df.DFInstances({ \n @df.DFInstance( df= BackgroundContinuousV1 , inst= bc1 ) }) package demos.applets.clock; Figure \n5. Declaration of a design fragment instance Figure 6 shows some of the bindings between the roles in \nthe design fragment and the Clock2 class. Again, the Java5 annotations are shown italicized. Note that \nhere the Clock2 class plays both the RoleApplet and RoleThread roles from the design fragment, while \nin other applets, the RoleThread is sometimes a different class than the applet. The advantages of using \nJava 5 s annotations are that it is a standard mechanism and the annotations can be typechecked using \nthe standard Java compiler. One disadvantage that can be seen above is that conceptually simple bindings \nbecome quite verbose.  4. Tool In order to provide feedback on our ideas and in order to execute a large \ncase study, we built tools to support the creation, binding, and evaluation of design fragments. The \ntool is an extension to the Java Development Tooling for the Eclipse integrated development environment \n(IDE) [8]. The tool has three parts that are visible to programmers. The .rst part is a new view in the \nIDE that displays a @DFTypeBindings({ @DFTypeBinding(inst= bc1 , role= RoleApplet ), @DFTypeBinding(inst= \nbc1 , role= RoleThread ) }) public class Clock2 extends java.applet.Applet implements Runnable { ... \n@DFFieldBindings({ @DFFieldBinding(inst= bc1 , role= roleThread ) }) Thread timer = null; ... @DFMethodBindings({ \n@DFMethodBinding(inst= bc1 , role= start ) }) public void start() { ... Figure 6. Binding of design \nfragment instance to Java code catalog of design fragments, as shown in Figure 7. The second part is \na new view that displays a list of the design fragments that have been bound to the source code, as shown \nin Figure 8. The third part is a new set of problem markers that appear in the standard Eclipse problem \nview, as shown in Figure 9. There are many components that run behind the scenes to keep these views \nupdated, including a builder that re-parses the design fragment de.nitions when the source .les change, \na builder that re-evaluates the design fragment bindings when relevant Java source .les change, and analysis \ntools that check conformance between the design fragments and the Java code. 4.1 Design Fragment Catalog \nView Figure 7 shows the design fragments catalog view for the Java applets framework. The Background \nContinuous Task V1 design fragment has been opened, showing the text of its goal, the parts provided \nby the framework, and the parts the programmer must build. The de.nition of the run() callback method \nhas been opened, showing the speci.cations of when and how often this callback will be invoked by the \nframework. The section on programmer responsibility shows the two class roles, RoleApplet and RoleThread. \nThe class role RoleApplet must be a subclass of java.applet.Applet, must have a .eld named ro\u00adleThread \nof type java.lang.Thread, and must implement the two callback methods start() and stop().The start() \ncallback method has been opened, showing the speci.cations of what the programmer is expected to do in \norder to ful.ll framework obliga\u00adtions and this design fragment. The design fragment catalog is represented \nas an Eclipse project. The .les in the project are the XML design fragment de.n\u00aditions. One advantage \nof this representation is that Eclipse provides integration with source code control repositories, like \nCVS or Sub\u00adversion, for .les within projects, so programmers can stay updated with the latest design \nfragment catalog by synchronizing the project with the server. Following the Debian [3] example of maintaining \nstable, testing, and unstable builds of their Linux distribution, each design fragment catalog has folders \nfor stable, testing, and unstable design fragments. It is expected that most programmers would use the \nstable design fragments, which have been vetted by the catalog maintainer, but less risk-averse programmers \nor ones on the cutting edge could use the testing or unstable folders. Each catalog con\u00adtains design \nfragments for just one version of a framework. While the applet framework has changed relatively little \nover time, other frameworks can change signi.cantly as they evolve. Figure 7. Design fragment catalog \nview 4.2 Design Fragment Instances View Each use of a design fragment, which we call a design fragment \ninstance, is given a name and declared in the package-info.java .le. Usually a design fragment is used \njust once per class or package, but not always. For example, one of the applets we analyzed is a two-player \nTetris game that used two background threads, so it used two instances of the Background Continuous Task \nV1 design fragment. Figure 8. Design fragments instances view Figure 8 shows some of the nine instances \nof the Background Continuous Task V1 design fragment. This view shows, for each role in the design fragment, \nwhere it is bound in the Java source code. For example, the scope.at1 instance has the RoleApplet and \nRoleThread roles bound to the Scope Java class, the roleThread role bound to the clock .eld. This view \nwill indicate binding problems, such as when a class role is not bound to any Java class. If there are \nany conformance analysis failures then they are shown in this view. The speci.cations for the start() \nmethod have been opened, revealing checkmarks. As currently imple\u00admented, the tool can detect when a \nmethod fails to invoke a required method and it does this through trivial analysis of the method body. \nThe user interface distinguisheds three states: pass, fail, or no\u00adanalysis . 4.3 Eclipse Problems View \nIn the Eclipse IDE, a single view collects all problems found in the environment. The design fragments \ntool extends this view by adding new problem markers that appear within the view. As seen in Figure 9, \nwhen source code fails to meet the speci.cations de\u00ad.ned in the design fragment, these problems are reported \nas warn\u00adings in the problems view. Clicking on the problem will navigate the programmer to the line in \nthe source code where the problem was detected. Most problems are reported as warnings, including confor\u00admance \nanalysis failures and incomplete bindings. A few problems are reported as errors, including the declaration \nof design fragment instances where the design fragment is not found in the catalog. 4.4 Integration \nThe Eclipse IDE includes convenient features like incremental compilation upon the saving of source .les \nso that the list of prob\u00adlems is always accurate. Programmers have grown accustomed to this style of \ninteraction with their tools, so the design fragments tools operate in a consistent way. Changes to the \nsource .les that de.ne design fragments cause those .les to be re-parsed and pre\u00adsented in the catalog \nview. Any changes to the catalog will prop\u00adagate to the design fragment instances view. Similarly, changes \nto the Java source code will trigger re-analysis of the bindings to de\u00adsign fragments and these will \nbe displayed in the instances view. Any problems detected during these steps are re.ected in the prob\u00adlems \nview.  5. Hypotheses Our vision for design fragments relies upon some assumptions about how programmers \ninteract with frameworks and example code. These assumptions are reasonable but it is best to state them \nexplicitly as hypotheses so that data can be gathered to support or refute them. Our .rst hypothesis \nis that patterns exist in source code, specif\u00adically source code that interacts with frameworks. If this \nis not true, then each programmer interacts with the framework in a slightly different way and it is \nsenseless to try to encode patterns. A corol\u00adlary to this is that unnecessary diversity exists in source \ncode, mean\u00ading that sometimes programmers could choose to interact with the framework in a conventional \nway instead of being different. If un\u00adnecessary diversity exists then it might be possible to increase \nthe frequency of pattern use by reducing that unnecessary diversity. Our second hypothesis is that programmers \nreference examples, speci.cally source code examples that appear to do the same thing they want their \nprogram to do. Frameworks often come with exam\u00adple applications and it is possible that programmers look \nat these applications and clone their structure using the Monkey see / mon\u00adkey do rule. If programmers \ndo not already reference examples, then convincing them to reference a catalog of design fragments will \nbe more dif.cult. Our third hypothesis is that the effort to create a catalog tapers. As more applications \nare analyzed it should become less likely that more design fragments are found. Ideally, the discovery \nof new design fragments would follow an asymptotic curve. Analysis of a few applications would yield \na great many design fragments but the rate of their discovery would slow down as more applications are \nanalyzed. The earlier the catalog reaches 80% of its maximum size, or some other threshold of utility, \nthen the more practical it will be to build it. Our .nal hypothesis is that the design fragments language \ncan express patterns, speci.cally the patterns that the authors have rec\u00ad  Figure 9. Problems view ognized \nin the code. The evaluation for this hypothesis will be subjective and we will note the cases where we \nrecognized a pattern but were unable to express it.  6. Applet Case Study The applet framework allows \nJava code to run inside a web browser. Sun has bundled demonstration applets with the Java Development \nKit (JDK) since its original version. The JDK today contains twenty demo applets and thousands more can \nbe found on the internet with a simple search. The applet framework de.nes several lifecycle callback \nmeth\u00adods that are invoked on the programmer s applet when the user starts the applet in the web browser. \nThe applet .rst receives an init() callback, then at least one start() and stop() pair of callbacks, \nthen a single destroy() callback. The framework also de.nes service methods that can be invoked by the \nprogram\u00admer s code, such as addMouseListener(). Many other frameworks are more complex than the applet \nframework but their complexity arises primarily from scale, not from a difference in their natures. All \nframework programmers are presented with the same challenges, including understanding which methods are \ncallbacks or service methods, the sequence of callbacks, and the assumptions the framework makes about \nbehav\u00adior within the callback methods. The applet framework is a suitable choice for research because \nall of these essential challenges are present, it is well known, and it is small. One exception is that \nsome frameworks rely on declarative elements in addition to object oriented mechanics, either in external \n.les or Java annotations, and we plan to examine this in our future work. public class Simple extends \njava.applet.Applet { public Simple() { add(new java.awt.Label(\"Hello\")); } } Figure 10. Simple AWT applet \nNot all applets, however, meaningfully engage in the applet framework; for an example see the one shown \nin Figure 10. Since the applet framework is an extension to the Abstract Widget Toolkit (AWT), every \nlegal AWT program is also a legal applet so long as it derives from java.applet.Applet. Since it is our \ndesire to investigate framework use, we must exclude such applets from our study. We de.ne meaningfully \nengage in the applet framework to mean that the code implements applet callbacks or invokes applet-speci.c \nservice methods on the framework. Speci.cally, it cannot extend java.applet.Applet yet solely call AWT \nservice methods. 6.1 Design Fragments from Sun Demos We decided to start populating our catalog of design \nfragments by examining the demo applets provided in the Sun JDK. The intent of these demo applets was \nboth to impress programmers with the applet framework s capabilities as well as instruct the next generation \nof applet writers, so it seemed a good place to start looking for canonical patterns of interaction with \nthe framework. Recognizing a design fragment is equivalent to de.ning a cat\u00adegory. The design fragment \nauthor must examine source code and recognize that a subset of that code is repeated elsewhere. The au\u00adthor \nthen encodes this pattern as a design fragment and binds it to the source code. Some of our initial attempts \nto de.ne design frag\u00adments were overly broad (e.g., an applet that paints to the screen) and others overly \nnarrow (e.g., an applet that has a background thread for running a control panel). The selection of an \nappropriate scope became easier after de.ning a dozen or so design fragments. However, it is natural \nthat different authors would create different design fragments in same way that different authors would \ncreate different code libraries. From the twenty Sun demo applets we found ten design frag\u00adments. A tabulation \nof these design fragments including a short de\u00adscription and how often they occurred is shown in Table \n1. The .rst column lists the design fragments by category and name. A short description of the design \nfragment is in the second column, and the number of times the design fragment was found in the Sun demos \nand the internet are in the third and fourth columns. Note that the Background Continuous V1 and Focus \nListener applets have a count of zero for the Sun column because they were not dis\u00adcovered until looking \nat applets from the internet. Also, the One\u00adtime Init Task and Timed Task design fragments were not found \nin the applets from the internet. All other design fragments were found in both. In order to ensure that \ndesign fragments were consistently iden\u00adti.ed despite differences in the source code, we established \nthe set of rules shown below to de.ne the required matches and the al\u00adlowed deviations. The rules were: \n Background Continuous V2: Must have a .eld holding refer\u00adence to thread, Must create thread in start(), \nassigning .eld to thread, Must set .eld to null in stop(), Must implement run() and loop continuously \nuntil .eld is not the same as cur\u00adrently running thread.  One-time Init Task: Must create thread in \ninit(), Thread must execute run() to completion just once.  One-time On-demand Task: May create thread \nat any time, Thread must execute run() to completion just once.  Timer: Must create a new TimerTask \nin start() and call schedule() on it, Must call cancel() on the TimerTask in stop().  Event Handling \n(all kinds): Must register in init() using addZZZListener(), Must implement relevant interface, Must \nimplement interface methods, May fail to de-register in destroy() using removeZZZListener().  Parameterized \nApplet: Must call getParameter(),per\u00adhaps not from init(), May fail to de.ne getParameter-Info(), May \nfail to match getParameter() calls with getParameterInfo() data.  Manual Applet: Must have main() method \nthat calls init() and start() on applet  Design Fragment Name Description Instances from Sun demos \nInstances from internet Threading Background Continuous v1 A separate thread used to execute an ongoing \ntask 0 9 Background Continuous v2 Same as above, but with a race condition removed 6 3 One-time Init \nTask A separate thread used to run a task at startup, once 2 0 One-time On-Demand Task A separate thread \nused to run a task at a domain-speci.c time, once 1 3 Timed Task A task that should be repeated regularly \n1 0 Event Handling Component Listener Listening for component events 1 1 Focus Listener Listening for \nwhen the applet gets focus in the GUI 0 1 Key Listener Listening for keyboard events 1 2 Mouse Listener \nListening for simple mouse events 10 12 Mouse Motion Listener Listening for complex mouse events 4 11 \nOther Parameterized Applet An applet that reads parameters from a web page 13 17 Manual Applet An applet \nthat can be run from the command line because its main method manually invokes the applet lifecycle methods \n5 5 Table 1. Design fragment frequency 6.2 Design Fragments from Internet In order to evaluate our \ndesign fragments, we next collected a set of thirty-six applets from the internet. Our goal was to collect \napplets that had not been created by Sun so we used the search string import java.applet.Applet -site:sun.com. \nWe revised our search strings to ensure that the applets meaningfully engaged in the applet frame\u00adwork, \neither by using one of the lifecycle methods or event handling interfaces. To .nd threaded applets, we \nadded java.lang.Thread to the search string; to .nd mouse listener applets, we added java.\u00adawt.MouseListener; \nto .nd parameterized applets, we added getPa\u00adrameter. We collected the .rst ten applets that matched \neach search string. As a result of our targeted search process, we were sure to get applets that used \nthe features we searched for but our collection of applets no longer represented a neutral sampling of \napplets on the internet. A concern about our process is that our searches preferen\u00adtially targeted speci.c \nkinds of applets, speci.cally those using threads, engaging in event listening, and reading parameters. \nIn\u00adternet searches indicate that 27% of applets use threads, 3.5% use events, and 18% use parameters. \nFrom the internet applets we found an additional two design fragments: Focus Listener Applet and Background \nContinuous V1. The Focus Listener Applet design fragment is structurally identical to the other listener \ndesign fragments except that it listens for user interface focus changes. Background Continuous V1 and \nV2 are the same in intent and nearly identical in structure, differing only in a single check that occurs \nin the run() method. V1 checks that the thread .eld is not null while V2 checks that the thread .eld \nis equal to the currently running thread. Similarly to how the design fragments were de.ned in the previous \nsection, the rules for identifying the Background Continuous V1 design fragment are: Must have a .eld \nholding reference to thread, Must create thread in start(), assigning .eld to thread, Must set .eld to \nnull in stop(), Must implement run() and loop continuously until .eld is found to be null. Table 5 at \nthe end of this paper is a compilation of all of the applets analyzed and the design fragments that were \nfound within them. We tolerated some deviations from the ideal in matching the design fragments to the \ncode. The most common deviation was a failure to de-register for events, which occurred in about two\u00adthirds \nof the listening applets. Also common was the reading of parameters via getParameter() but a failure \nto publish those parameters in getParameterInfo(), which occurred in about a third of the Parameterized \nApplets. Non-conformance is detailed in Table 2. We note these deviations not as compelling evidence \nthat design fragments can reduce bugs in code, but rather as evidence that even in debugged, released \ncode it is possible to .nd incorrect usage of framework interfaces because of the dif.cult, non-local \nnature of engaging with a framework. Sun Internet Applets Applets Failure to de.ne getParameterInfo() \n0/ 13 12 / 17 Failure to de-register for events 3/ 16 26 / 27 Table 2. Non-conformance to design fragment \nThe design fragments we discovered fall into three categories: threading, event handling, and other. \nThe threading design frag\u00adments deal with how to coordinate threads with the pre-determined applet method \ncallbacks. The event handling design fragments deal with how to obtain additional events from the applet \n(and also AWT) framework. In the other category, Parameterized Applet deals with how to obtain the textual \nparameters that can be passed into an applet and how to report to users what parameters can be passed \nin. Manual Applet deals with how to provide a main() method that simulates the callback structure of \nan applet so that the applet can be invoked from the command line. The three categories of design fragments \nare discussed in detail in the following three subsections. 6.3 Threaded Applets Five of the design \nfragments had the purpose of coordinating a sep\u00adarate thread. Two of these are the Background Continuous \nvariants that have been discussed as a running example through this paper, as in Figure 2. These threads \nare intended to run for a long time, usually the duration of the applet. The One-Time Init Task design \nfragment uses a thread to per\u00adform some time-consuming startup task, such as establishing a con\u00adnection \nwith a server. This task is done in a background thread so as to keep the GUI responsive. This task is \nstarted in the init() callback method. For the One-Time On-Demand Task design frag\u00adment, the only difference \nis that the background task can be started at any time during the running of the applet, such as when \nthe user presses a key. It is possible to consider the former as a special case of the latter. The Timed \nTask design fragment was only found in the Sun demo applets but could have been applied in many places \nwhere Background Continuous was used. Timed Task uses a Java Timer instead of a thread and the Timer \ncan be set to run every so many milliseconds. The Clock2 applet from Figure 1 could have been written \nmore simply and with less risk of a race condition had it used the Timed Task instead. The applet framework \nnever explicitly requires programmers to create new threads yet 27% of applets on the internet do. The \napplet framework constrains the solution space for programmers and they in turn have solved their problem \nusing threads. It is interesting to note that no traditional technique for documenting interfaces, in \nthis case framework interfaces, would instruct programmers to use threads. 6.4 Event Handling Applets \nAll of the event handling design fragments followed the structure shown in Figure 11, which shows the \nMouse Listener design frag\u00adment. The programmer s code must implement the appropriate lis\u00adtener interface, \nin this case MouseEvent, and provide implemen\u00adtations for each of the required callback methods de.ned \nin that interface. In the init() callback method of the applet, the pro\u00adgrammer s code calls the framework \nservice method to register for callback events of this type, in this case addMouseListener(). A corresponding \nremoveMouseListener() service method is provided for the applet to de-register for events and it should \nbe calledinthe destroy() callback method on the applet. Many of the applets from the internet did not \nde-register for events. Since most applets respond to events their whole life, there is little harm in \nthis since destruction of the applet happens just be\u00adfore the entire program terminates. It is present \nin the design frag\u00adment because the Sun applets, with few exceptions, de-registered for events and because \nit is probably good practice. 6.5 Parameterized Applets Java applets are often run from web pages. It \nis possible to pass parameters into the applet via the HTML text, like: <applet code=ArcTest.class width=400 \nheight=400>.In this case, the parameters width and height are passed in as strings with values of 400 \n. The applet can read these parameters with the framework service method getParameter(String name). It \nis also possible for an applet to let its users know what parameters they can pass in, and this is done \nwith the non-lifecycle callback method getParameterInfo(), which returns an array con\u00adtaining the parameters \nand their expected types. Ideally, every applet that reads parameters would publish the fact that it \nreads them. Furthermore, the published list should match exactly the calls to getParameter() made by \nthe applet. In practice it appears easy to break this non-local constraint since more than half of the \napplets from the internet had a mismatch between the parameters they queried and the parameters they \npub\u00adlished. 6.6 Similarities Between Sun and Internet Applets Some of the applets from the internet \nshared structural features with the Sun applets. Speci.cally, some of the .eld names were identical. \nThe threaded Sun applets used the following .eld names to hold a reference to the thread: engine, kicker, \nkillme, runner (twice), and timer. The internet applets used: engine, kicker, killme, runner (four times), \naniThread, artist, clock, _helloThread, loader, marcher, my_thread, Tetris1, and Tetris2. Note that the \nhighlighted .eld names engine, runner, kicker, and killme are found in both the demo applets and the \ninternet applets.  7. Analysis The results of the case study support our hypotheses. Program\u00admers did \nengage the applet framework in roughly the same way. Based on looking at their applets, it appears that \nprogrammers copied the structure of the Sun demos. We were able to create a catalog quickly. And, with \na few exceptions, the design fragment language was able to express the patterns we found. 7.1 Hypothesis: \nPatterns Exist in Code Our .rst hypothesis was that patterns exist in source code, speci.\u00adcally source \ncode that interacts with frameworks. As seen in Table 5, across the 56 applets we found 108 design fragment \ninstances. In order to conform to a design fragment, the program must adhere to the rules previously \ndescribed. Conformance was universal for the bureaucratic parts of design fragments dealing with event \nhandling, such as implementing in\u00adterfaces and providing method implementations. Universal confor\u00admance \nis not surprising because this bureaucracy is checked by the compiler and the code will never function \ncorrectly without it. Con\u00adformance was also universal for registering for events, but about 2 in 3 applets \nfailed to de-register, including essentially all of the non-Sun applets. In most applets, no fault can \nbe detected by a user because the applet and the rest of the Java environment are termi\u00adnated at the \nsame time. Note too that registering and de-registering must be implemented in two different callback \nmethods. In the Parameterized Applet design fragment, programmers were asked to keep two parts of their \ncode consistent: asking for parameters and publishing which parameters they ask for. More than a third \nof the applets, and more than two thirds of the non-Sun ones, failed to publish their parameters. Parameters \ncan be passed in to the applet even when those parameters are not published, so a user may not detect \na fault. Note that checking for parameters is implemented in a different method than publishing the parameters. \nWe note that type-checked bureaucracy is correlated with high conformance. Low conformance is correlated \nwith dif.culty to observe faults through testing and a lack of tool-based conformance checking (such \nas type checking from the compiler). A corollary to our hypothesis was that unnecessary diversity ex\u00adists \nin source code. We found some evidence for this in the exis\u00adtence of two versions of the Background Continuous \ndesign frag\u00adment, but these versions were substantially similar. It is possible that our process of searching \nthe internet for speci.c kinds of ap\u00adplets led to less diverse code, or that the applet framework is \nso simple that consistency is high. 7.2 Hypothesis: Programmers Reference Examples Our second hypothesis \nwas that programmers reference examples, speci.cally source code examples that appear to do the same \nthing they want their program to do. Two features of the applets from the internet support this hypothesis, \nboth from the threaded applets category. First, the replication of the threading bug in nine of the twelve \napplets that implemented the Background Continuous design frag\u00adment variants supports the notion that \nthis bug was copied from the original demo applet bug. Second, identical names of the thread .elds strongly \nsuggests that code was copied. The original Sun applets used names like engine and runner that could \nplausibly be independently re-created by other programmers. However, names like kicker and killme are \nalso seen in both Sun and internet applets seem unlikely to have arisen independently by chance. If the \nnext generation of frameworks were to distribute its exam\u00adple applications with design fragments bound \nto the source code, then there is a good chance that this expression of design intent would also be copied \nby programmers and bug .xes like the race condition could be propagated to copied code. 7.3 Hypothesis: \nEffort to Create a Catalog Tapers Our third hypothesis was that the effort to create a catalog tapers. \nAfter examining .fty-six applets we had found twelve design frag\u00adments for our catalog. Ten of these \ntwelve were found in the initial twenty demo applets from Sun. One of the remaining design frag\u00adments \nwas the buggy version of Background continuous and the other was the Focus Listener, which is structurally \nequivalent to the other event listening design fragments. Our catalog was built by examining the applets \nalphabetically starting with the Sun demo applets. The growth of the catalog is plotted in Figure 13. \nWe would like to see the rate of discovery of new design fragments slow down as more applets are analyzed, \nand this is what is shown in the chart. This result is not a quirk of the alphabetical order of evaluation \nsince a glance at Table 5 reveals that there are paths that populate the catalog either more quickly \nor more slowly. 7.4 Hypothesis: Design Fragment Language Can Express Patterns Our fourth hypothesis \nwas that the design fragments language can express patterns, speci.cally the patterns that the authors \nhave recognized in the code. The design fragment language did a good job of encoding the structure of \nthe patterns with a few exceptions. 0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 Applets Analyzed In the \nParameterized Applet design fragment, the programmer should return an array of an array of string to \npublish the para\u00admeters that his applet checks. The strings are the parameters that are checked elsewhere \nin the program via calls to the framework service method getParameter(). Since the design fragment language \ncannot refer to the strings used as actual parameters to method invocations, nor can it refer to the \nstrings in the array, it cannot express the constraint that these strings be paired. The design fragment \nlanguage also cannot express when the programmer may change the name of a role (e.g., class, method, \nor .eld) and when he should not. We have adopted the convention that role names beginning with role (e.g., \nRoleApplet) can be changed but other cannot, (e.g., start()). The behavioral requirements of a pattern \ncan only be minimally expressed in the design fragment language. The differences be\u00adtween a design fragment \nwhere the thread runs continuously ver\u00adsus one where the thread runs just until its task are completed \nmust be expressed in natural language that cannot be checked by tools. Additionally, the expression of \nthe order of framework method call\u00adbacks is only partial. Despite these restrictions in expressiveness, \nwe found that the interaction between the programmer s code and the framework could largely be expressed \nthrough the design fragments language.  8. Eclipse Framework We created a catalog of design fragments \nfor the Eclipse framework opportunistically, since we were creating a tool that uses the Eclipse framework. \nUnlike the applet case study, the design fragments we created have not been tested on a large number \nof example applications. The Eclipse Java development environment allows program\u00admers to build arbitrary \nJava programs, but also provides special tools to help them build extensions to the Eclipse environment \nit\u00adself. One of these special tools is a wizard that creates an example application. The programmer can \nchoose features that he would like in the example application from a short list and the wizard gener\u00adates \na suitable application. We created our design fragments from the generated example application since \nit, like the Sun demo applets, is intended to show programmers how to use the framework. We created a \ncatalog containing the design fragments shown in Table 3. These design fragments were more complex than \nthe applet design fragments. For example, a UML diagram of the Dynamic Right Click Menu design fragment \nstructure is shown in Figure 14.  While using the Eclipse framework, we noticed that even after we had \nused one part of the framework extensively, for example the part for creating the user interface, this \nknowledge did not make us experts in other parts of the framework, for example the parts for incremental \ncompilation. While the applet framework is suf.ciently small that a programmer can comprehend it within \na few hours, the Eclipse framework is far larger and more complex. With a large framework like Eclipse, \nknowing the structure of common solutions could speed up development time. Design Fragment Name Description \nContent Provider Data presented in a view Label Provider The labels for data in a view Initializing Actions \nInitial setup of the action objects Resource Listener Responding to resource changes Dynamic Right Click \nMenu A popup context menu Toolbar Action Ad an action to view s toolbar Tree View Initialization Initial \nsetup of a tree view Tree View Selection User selecting item in tree view View Sorter Aviewthatstays \nsorted Table 3. Design Fragments from Eclipse  9. Related Work This work builds upon previous work \nin a number of areas. Re\u00adsearchers in the 1980s and 1990s documented the use of software frameworks that \nthey observed being used in industrial and acad\u00ademic settings. Frameworks were described as a new reuse \nmech\u00adanism that differed from class libraries. Ralph Johnson suggested natural language design patterns \nas a way for programmers to un\u00adderstand frameworks. Most design patterns are based on the ideas of role \nmodeling, where a given class can play various roles and its responsibilities are the superset of the \nresponsibilities of its roles. Research into design patterns led to tools that could model design patterns \nprecisely and compare them with source code. The precise modeling of design patterns was modi.ed to describe \nthe program\u00admers burden and instead of how the framework was implemented. Cookbooks and recipes followed \na similar path starting from un\u00adstructured text through a precise representation. 9.1 Categorization \nof the Research Table 4 provides a categorization of the work on framework docu\u00admentation. It divides \nthe work along two dimensions describing the style of documentation. The .rst dimension is whether the \ndocu\u00admentation provides examples or speci.cations. The second dimen\u00adsion is whether the documentation \nprescribes how clients should use the framework or describes the implementation of the frame\u00adwork. Prescribes \nhow clients Describes the should use the framework implementation of the framework Speci.cation- Helm \nContracts JavaDoc based FCL Constraints UML-F Pro.le Decl. Metaprogramming OOram Riehle frameworks JavaDoc \nOOram Riehle fwks Example- Decl. Metaprogramming Design Patterns based Design Patterns Hooks JavaFrames \nCookbooks JavaDoc Design Fragments JavaFrames Utrecht Tool JavaDoc Table 4. Categorization of the research \nRelatively few projects have set out to describe the internals of frameworks and most of these projects \nwere older, when frame\u00adworks were themselves just beginning to become popular. Most research has focused \non documenting how to use the framework rather than documenting how the framework is designed. Tech\u00adniques \nsuch as JavaDoc and Design Patterns can be applied to al\u00admost any documentation problem, and have been \nused to describe how frameworks work internally. Techniques in the Example-based dimension do not claim \nto document every possible and correct use of the framework but instead provide known-good examples. \nThis simpli.es the task both for the documentation author and for the reader. Conversely, techniques \nin the Speci.cation-based dimension claim to cover all correct use in much the same way that func\u00adtional \nspeci.cations for methods should cover all cases of inputs and outputs. A Microsoft Foundations Classes \nexample from FCL Constraints constrains all subclasses of CWnd such that each must call one of three \nwindow creation methods de.ned in the frame\u00adwork. 9.2 Role Modeling Object Oriented Role Analysis Modeling \n(OOram) is a software engineering method developed by Trygve Reenskaug that focuses on collaborating \nobjects (role models) instead of classes [28]. Each role model consists of a number of roles with assigned \nbehavior. Classes are created by composing these roles. A tool for the Small\u00adtalk language was created \nfor authoring and composing these role models. Reenskaug recalls Brad Cox s metaphor [2] of the surface \narea of components, that is, the things that must be understood about the component for a client to use \nit correctly, and applies it to frameworks. He notes that the surface area of a framework should be kept \nas small as possible, can be described with role models, and should not be changed for fear of breaking \nexisting applications. Reenskaug is credited with the creation of the Model\u00adView-Controller pattern, \nwhose implementation in Smalltalk may be considered the earliest framework [20]. In his thesis [30], \nDirk Riehle extends the role modeling con\u00adcepts from OOram to treat frameworks as .rst-class concepts, \ncall\u00ading it role modeling for framework design. Role models describe the interface between the framework \nand the programmer s code; free roles represent the roles the programmer can implement to use the framework. \nProgrammers should .nd frameworks with as\u00adsociated role models easier to comprehend since the complexity \nof the class models has been explained in terms of cross-cutting role models. 9.3 Precise Design Patterns, \nCode Ties The Utrecht University design pattern tool tool [5], implemented in Smalltalk, allowed the \ncreation of prototype-based design pat\u00adterns and binding of these design patterns to source code. Con\u00adformance \nchecking between the pattern and source code could be performed and prede.ned .xes could be used to repair \nnon-con\u00adformance. Modeling focused on design patterns and application of the tool to frameworks was not \nspeci.cally explored. Conformance checking was limited to static program structure while our analysis \nadditionally supports behavior checking. 9.4 Frameworks Confronting the challenge of communicating how \nto use the Model-View-Controller framework in Smalltalk-80, Krasner and Pope [22] constructed an 18 page \ncookbook that explained the purpose, structure, and implementation of the MVC framework. The cookbook \nbegins with text but increasingly weaves in detailed code examples to explain how the framework could \nbe used to solve problems. This cookbook was designed to be read from beginning to end by programmers \nand could also be used as a reference but every recipe did not follow a consistent structure nor was \nit suitable for parsing by automatic tools. Ralph Johnson appears to have been the .rst to suggest docu\u00admenting \nframeworks using patterns. He notes that the typical user of framework documentation wants to use the \nframework to solve typical problems [18] but also that cookbooks do not help the most advanced users \n[19]. Patterns can be used both to describe a frame\u00adwork s design as well as how it is commonly used. \nHe argues that the framework documentation should describe the purpose of the framework, how to use the \nframework, and the detailed design of the framework. After presenting some graduate students with his \ninitial set of patterns for HotDraw, he realized that a pattern iso\u00adlated from examples is hard to comprehend. \nFroehlich et al. s Hooks focus on documenting the way a frame\u00adwork is used, not the design of the framework \n[7]. They are similar in intent to cookbook recipes but are more structured in their nat\u00adural language. \nThe elements listed are: name, requirement, type, area, uses, participants, changes, constraints, and \ncomments. The instructions for framework users (the changes section) read a bit like pseudo code but \nare natural language and do not appear to be parsable by tools. Cookbook recipes, hooks, and design fragments \nare similar in that they all provide example-based descriptions of how to use a framework. Hooks added \nstructure to recipes but were still natural language; design fragments regularize hooks to make them \ntool-readable and enable tool-based assurance. Design patterns themselves can be decomposed into more \nprim\u00aditive elements [27]. Pree calls these primitive elements metapat\u00adterns and catalogs several of them \nwith example usage. He pro\u00adposes a simple process for developing frameworks where identi.ed points of \nvariability are implemented with an appropriate metapat\u00adtern, enabling the framework user to provide \nan appropriate imple\u00admentation. The declarative metaprogramming group from Vrije Univer\u00adsity [33, 32] \nuses Pree s metapatterns [27] to document frame\u00adwork hotspots and de.nes transformations for each framework \nand design pattern. Framework instances (plugins) can be evolved (or created) by application of the transformations. \nThe tool uses SOUL, a prolog-like logic language. The validation was done on the HotDraw framework by \nspecifying the metapatterns, patterns and transformations needed. The validation uncovered design .aws \nin HotDraw, despite its widespread use, along with some false positives. The declarative metaprogramming \napproach to modeling framework hotspots appears to have signi.cant up-front investment before payoff \nin order to provide its guarantees about correct use of the framework. It may additionally assume a higher \nlevel of accu\u00adracy or correctness in frameworks than will commonly be found in practice. In [33], the \nauthors comment that their approach speci.cally avoids design patterns in favor of metapatterns because \nthere could be many design patterns. While this makes their technique gener\u00adally applicable and composable, \nit will be dif.cult to add pattern\u00adspeci.c semantics and behavior checking to their approach. A UML pro.le \nis a restricted set of UML markup along with new notations and semantics [6]. The UML-F pro.le provides \nUML stereotypes and tags for annotating UML diagrams to encode framework constraints. Methods and attributes \nin both framework and user code can me marked up with boxes (grey, white, half-and\u00adhalf, and a diagonal \nslash) that indicate the method/attribute s par\u00adticipation in superclass-de.ned template patterns. A \ngrey box indi\u00adcates newly de.ned or completely overridden superclass method, a white box indicates inherited \nand not rede.ned, a half-and-half indicates rede.ned but call to super(), and a slashed box indicates \nan abstract superclass method. The Fixed, Adapt-static, and Adapt-dyn tags annotate the frame\u00adwork and \nconstrain how users can subclass. Template and Hook tags annotate framework and user code to document \ntemplate meth\u00adods. Stereotypes for Pree s metapatterns (like uni.cation and sep\u00adaration variants) are \npresent, as are prede.ned tags for the Gang of Four [9] patterns. Recipes for framework use are presented \nin a format very similar to that of design patterns but there is no explicit representation of the solution \nversus the framework. The recipe en\u00adcodes a list of steps for programmer to perform. The FRamework EDitor \n/ JavaFrames project [13, 12, 14] is a result of collaboration between The University of Tampere, the \nUniversity of Helsinki, and commercial partners starting in 1997. They have developed a language for \nmodeling design patterns and tools that act as smarter cookbooks, guiding programmers step\u00adby-step to \nuse a framework. With the 2.0 release of JavaFrames, many of these tools work within the Eclipse IDE. \nTheir language allows expression of structural constraints and the tool can check conformance with the \nstructural constraints. Code can be generated that conforms to the pattern de.nition, optionally including \ndefault implementations of method bodies. Speci.c patterns can be related to general patterns; for example \na speci.c use of the Observer pattern in a particular framework can be connected to a general de.nition \nof the Observer pattern. The Framework Constraint Language (FCL) [16] applies the ideas from Richard \nHelms object oriented contracts [15] to frame\u00adworks. Like Riehle s role models, FCLs specify the interface \nbe\u00adtween the framework and the user code such that the speci.cation describes all legal uses of the framework. \nThe researchers raise the metaphor of FCL as framework-speci.c typing rules and validate their approach \nby applying it to Microsoft Foundation Classes, his\u00adtorically one of the most widely used frameworks. \nThe language has a number of built-in predicates and logical operators. It is de\u00adsigned to operate on \nthe parse tree of the users code. Though tar\u00adgeted at plugin points, this language appears to be compatible \nwith design fragments and could provide the basis of a richer constraint language for design fragments. \n 9.5 Aspects Aspect oriented programming seeks to improve the modularity of source code by localizing \nprogrammer-chosen concerns into their own input .les [31, 21, 25]. For example, the parts of a program \nthat deal with logging could be extracted to a new source .le so they do not clutter up the main code. \nDesign fragments and aspects share a similar desire to decompose a program into smaller chunks. While \ndesign fragments are speci.cations, aspects are implementations. It may be possible to use aspects to \nprovide default implementations for design fragments. 9.6 General Programming Assistance The complexity \nof programming has long been recognized and at\u00adtempts to help programmers manage that complexity have \nbeen re\u00adsearched. The Inscape Environment [26] focused on the challenges of evolution and scale in procedural \nprograms. It addresses these challenges in part through speci.cation of interfaces, much like de\u00adsign \nfragments. The speci.cation language was deliberately impov\u00aderished in order to avoid the tar pit of \nveri.cation, again much like the desire of design fragments to maintain simplicity in its language to \nencourage adoption. The Programmers Apprentice [29] was an attempt to apply arti\u00ad.cial intelligence to \nthe problem of programming by providing an intelligent agent to support the programmer. Cohesive collections \nof program elements are bound together into a clich\u00e9, similar to a design fragment based on syntactic \ncode structure, encoding roles and constraints. These clich\u00e9s are used by the tool to aid the pro\u00adgrammer. \n 9.7 Comparison of Design Fragments with Related Work Design fragments are similar to JavaFrames in that \nboth encode structural patterns that programmers use to engage with a frame\u00adwork. JavaFrames has been \nin.uenced by the cookbook approaches and provides automated tool support to ensure the recipe has been \nfollowed. Design fragments add a description of the relevant parts of the framework. This description \nbegins to answer why the recipe or pattern works, which enables two things. First, analysis tools that \ncheck for errors, such as the race condi\u00adtion described in this paper, can take advantage of the descriptions \nof the framework. Direct analysis of the framework code may be impossible because its source is unavailable \nor because it is too large. Second, knowing why a recipe works enables the programmer to go beyond the \nrecipe. Functionality demands from his problem domain will cause him to push on the limits of the pattern \nand he must be given an understanding of how this can be done. With exposure to many design fragments, \nthe programmer will build up a mental model of how the framework acts on his code. At .rst glance design \nfragments appear very similar to Riehle s role models. Following the categorization from section 9.1, \nrole models are speci.cation-based, while design fragments are example\u00adbased. As such, a role model strives \nto describe the complete and abstract protocol that every set of classes conforming to it must follow, \nwhile design fragments describe just a single legal use of that protocol. In addition to this fundamental \ndifference, there are differences of focus and intent. First, design fragments often span multiple framework \nrole models, such as in the Mouse Listener de\u00adsign fragment where the Applet callback methods are coordinated \nto invoke service methods to register for mouse events. Second, de\u00adsign fragments often encode actions \noutside of the framework, such as in the thread coordination design fragments. Third, design frag\u00adments \nare asymmetric, so they de.ne only what the programmer must do and only provide a programmer-centric \nview of what the framework roles are doing. The intent of both techniques is to aid programmers in using \nframeworks and in practice their strengths are complimentary.  10. Conclusions and Future Work Frameworks \nimpose burdens on programmers and existing tech\u00adniques do not provide adequate help to programmers. Design \nfrag\u00adments are patterns that encode conventional solutions to how a program interacts with a framework \nto accomplish a goal. Since it is necessary to understand how the framework in.uences the programmer \ns code, design fragments encode the relevant parts of the framework. By declaring that his program uses \na design frag\u00adment, a programmer is expressing enduring design intent that can be checked by analysis \ntools now and in the future. Through a case study with .fty six applets, this paper has supported the \nhypotheses that code interacting with frameworks follows patterns, programmers copy example code, the \neffort to create a design fragment catalog is mostly up-front, and that the design fragment language \nis effective at expressing most of the patterns we observed. In the future, we plan to evaluate design \nfragments on larger frameworks and involve more users. One area of particular interest is the evolution \nof design fragments as frameworks evolve, for ex\u00adample the evolution of the Eclipse framework through \nits 3.0, 3.1, and 3.2 versions. We plan to strengthen our ability to check confor\u00admance of the behavior \nspeci.cations and broaden their scope. Frameworks are increasingly relying upon declarative elements \nin addition to the object oriented mechanisms discussed here. Web frameworks such as Apache Struts de.ne \nobjects in Java but de\u00adclare their relationship to the website .ow in an XML .le. Enter\u00adprise frameworks \nsuch as J2EE are increasingly relying upon Java annotations to encode characteristics of classes. We \nplan to identify what kinds of burdens these place on programmers and determine if design fragments are \nan appropriate technique to assist the pro\u00adgrammer. One issue we will work to overcome is the programmer \ns cost of expressing design intent versus the short-term bene.t. It is possible that an improved user \ninterface could reduce the expression cost. For example, it seems reasonable to instantiate design fragments \nwith help from a wizard. 11. Acknowledgements This work and paper were greatly improved through helpful \ncom\u00adments from Bradley Schmerl, the members of the SSSG seminar, and the anonymous reviewers. This research \nwas sponsored by the US Army Research Of.ce (ARO) under grant number DAAD19\u00ad01-1-0485, the National Science \nFoundation under grant CCR\u00ad0113810, and a research contract from Lockheed Martin ATL. The views and conclusions \ncontained in this document are those of the author and should not be interpreted as representing the \nof.cial policies, either expressed or implied, of the ARO, the U.S. gov\u00adernment, Lockheed Martin ATL \nor any other entity.  References [1] Kent Beck and Donald G. Firesmith. Kent Beck s Guide to Better \nSmalltalk : A Sorted Collection (SIGS Reference Library). Cambridge University Press, 1998. [2] Brad \nCox. Object-Oriented Programming, An Evolutionary Ap\u00adproach. Addison Wesley, New York, 1987. [3] The \nDebian Linux Distribution. http://www.debian.org. [4] D. Fay. An architecture for distributed applications \non the internet: Overview of microsoft s .NET platform. IEEE International Parallel and Distributed Processing \nSymposium, April 2003. [5] Gert Florijn, Marco Meijers, and Pieter van Winsen. Tool support for object-oriented \npatterns. In Mehmet Aksit and Satoshi Matsuoka, editors, Proceedings ECOOP 97, volume 1241 of Lecture \nNotes in Computer Science, pages 472 495, Jyvaskyla, Finland, June 1997. [6] Marcus Fontoura, Wolfgang \nPree, and Bernhard Rumpe. The UML Pro.le for Framework Architectures. Addison-Wesley Professional, 2001. \n[7] Gary Froehlich, H. James Hoover, Ling Liu, and Paul Sorenson. Hooking into object-oriented application \nframeworks. In ICSE 97: Proceedings of the 19th international conference on Software engineering, pages \n491 501, New York, NY, USA, 1997. [8] Erich Gamma and Kent Beck. Contributing to Eclipse: Principles, \nPatterns, and Plugins. Addison-Wesley Professional, 2003. [9] Erich Gamma, Richard Helm, Ralph Johnson, \nand John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional \nComputing Series). Addison-Wesley Professional, 1995. [10] David Garlan, Robert T. Monroe, and David \nWile. Acme: Architec\u00adtural description of component-based systems. In Gary T. Leavens and Murali Sitaraman, \neditors, Foundations of Component-Based Systems, chapter 3, pages 47 67. Cambridge University Press, \n2000. [11] Aaron Greenhouse, T.J. Halloran, and William L. Scherlis. Observa\u00adtions on the assured evolution \nof concurrent java programs. Science of Computer Programming, 58:384 411, March 2005. [12] Markku Hakala, \nJuha Hautam\u00e4ki, Kai Koskimies, Jukka Paakki, Antti Viljamaa, and Jukka Viljamaa. Annotating reusable \nsoftware architectures with specialization patterns. In WICSA 01: Proceedings of the Working IEEE/IFIP \nConference on Software Architecture (WICSA 01), page 171, Washington, DC, USA, 2001. [13] Imed Hammouda \nand Kai Koskimies. A pattern-based j2ee application development environment. Nordic Journal of Computing, \n9(3):248 260, 2002. [14] Jan Hannemann and Gregor Kiczales. Design pattern implementation in java and \naspectj. In OOPSLA 02: Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, \nsystems, languages, and applications, pages 161 173, New York, NY, USA, 2002. [15] Richard Helm, Ian \nM. Holland, and Dipayan Gangopadhyay. Contracts: specifying behavioral compositions in object-oriented \nsystems. In OOPSLA/ECOOP 90: Proceedings of the European conference on object-oriented programming on \nObject-oriented programming systems, languages, and applications, pages 169 180, New York, NY, USA, 1990. \nACM Press. [16] Daqing Hou and H. James Hoover. Towards specifying constraints for object-oriented frameworks. \nIn CASCON 01: Proceedings of the 2001 conference of the Centre for Advanced Studies on Collaborative \nresearch, page 5. IBM Press, 2001. [17] Daqing Hou, Kenny Wong, and H. James Hoover. What can programmer \nquestions tell us about frameworks? In IWPC 05: Proceedings of the 13th International Workshop on Program \nComprehension, pages 87 96, Washington, DC, USA, 2005. [18] Ralph E. Johnson. Documenting frameworks \nusing patterns. In OOP-SLA 92: conference proceedings on Object-oriented programming systems, languages, \nand applications, pages 63 76, New York, NY, USA, 1992. [19] Ralph E. Johnson. Components, frameworks, \npatterns. SIGSOFT Softw. Eng. Notes, 22(3):10 17, 1997. [20] Ralph E. Johnson. Frameworks = (components \n+ patterns). Commun. ACM, 40(10):39 42, 1997. [21] Gregor Kiczales, Erik Hilsdale, Jim Hugunin, Mik Kersten, \nJeffrey Palm, and William G. Griswold. An overview of aspectj. In ECOOP 01: Proceedings of the 15th European \nConference on Object-Oriented Programming, pages 327 353, London, UK, 2001. [22] Glenn E. Krasner and \nStephen T. Pope. A cookbook for using the model-view controller user interface paradigm in smalltalk-80. \nJ. Object Oriented Program., 1(3):26 49, 1988. [23] Sun Microsystems. Java applets. http://java.sun.com/applets/. \n[24] Richard Monson-Haefel. Enterprise JavaBeans (3rd Edition). O Reilly, 2001. [25] Harold Ossher, William \nHarrison, Frank Budinsky, and Ian Sim\u00admonds. Subject-oriented programming: Supporting decentralized development \nof objects. In Proc. 7th IBM Conf. Object-Oriented Technology, July 1994. [26] Dewayne E. Perry. The \ninscape environment. In ICSE 89: Proceedings of the 11th International Conference on Software Engineering, \npages 2 11, New York, NY, USA, 1989. [27] Wolfgang Pree. Design Patterns for Object-Oriented Software \nDevelopment. Addison Wesley Longman, 1994. [28] Trygve Reenskaug, P. Wold, O. A. Lehne, and Manning. \nWorking With Objects: The Ooram Software Engineering Method. Manning Pubns Co, 1995. [29] Charles Rich \nand Richard. C. Waters. The programmer s apprentice: A research overview. In D. Partridge, editor, Arti.cial \nIntelligence &#38; Software Engineering, pages 155 182. Norwood, NJ, 1991. [30] Dirk Riehle. Framework \nDesign: A Role Modeling Approach.PhD thesis, Swiss Federal Institute of Technology, Zurich, 2000. [31] \nPeri Tarr, Harold Ossher, William Harrison, and Jr. Stanley M. Sutton. N degrees of separation: multi-dimensional \nseparation of concerns. In ICSE 99: Proceedings of the 21st international conference on Software engineering, \npages 107 119, Los Alamitos, CA, USA, 1999. [32] Tom Tourw\u00e9. Automated Support for Framework-Based Software \nEvolution. PhD thesis, Vrije Universiteit Brussel, 2002. [33] Tom Tourw\u00e9 and Tom Mens. Automated support \nfor framework\u00adbased software evolution. In ICSM 03: Proceedings of the International Conference on Software \nMaintenance, page 148, Washington, DC, USA, 2003. AppletWithThreadV0AppletWithThreadV1AppletWithThreadV2AppletWithThreadV3 \nAppletWithTimerComponentListenerFocusListenerKeyListenerManualAppletMouseListenerMouseMotionParameterizedApple \nSource DF Name Sun demo animator 1 1 1 Sun demo arctest 1 Sun demo barchart 1 Sun demo blink 1 1 Sun \ndemo cardtest 1 Sun demo clock 1 1 Sun demo dithertest 1 1 1 Sun demo drawtest 1 Sun demo fractal 1 1 \n1 Sun demo graphicstest 1 Sun demo graphlayout 1 Sun demo imagemap 1 1 1 1 Sun demo jumpingbox 1 1 1 \nSun demo moleculeviewer 1 1 1 1 Sun demo nervoustext 1 1 1 Sun demo simplegraph Sun demo sortdemo 1 1 \n1 Sun demo spreadsheet 1 1 1 Sun demo tictactoe 1 Sun demo wireframe 1 1 1 1 Internet anbutton 1 1 Internet \nantacross 1 1 1 Internet antmarch 1 1 1 Internet blinkhello 1 Internet brokeredchat 1 1 1 Internet bsom \n1 Internet buttontest 1 1 Internet cte Internet demographics 1 1 Internet dotproduct 1 1 1 Internet envelope \nInternet fireworks 1 1 Internet gammabutton 1 Internet geometry 1 Internet hellotcl 1 1 1 Internet hyperbolic \n1 1 Internet iagtager 1 Internet inspect 1 Internet kbdfocus 1 1 1 Internet lagttager Internet linprog \n1 1 Internet mousedemo 1 1 Internet myapplet Internet myapplet2 1 1 1 1 Internet nickcam 1 Internet notprolog \n1 Internet scatter 1 Internet scope 1 1 Internet simplepong 1 Internet simplesun 1 1 Internet smtp 1 \nInternet superapplet 1 1 Internet tetris 2 Internet ungrateful 1 Internet urccalendar 1 Internet urlexample \n1 1 Internet webstart 1 1 1 1 Internet ympyra 1 Total 9924121310 22 15 30 Table 5. All applets with origin \nand counts of design fragments \n\t\t\t", "proc_id": "1167473", "abstract": "Object oriented frameworks impose additional burdens on programmers that libraries did not, such as requiring the programmer to understand the method callback sequence, respecting behavior constraints within these methods, and devising solutions within a constrained solution space. To overcome these burdens, we express the repeated patterns of engagement with the framework as a <i>design fragment</i>. We analyzed the 20 demo applets provided by Sun and created a representative catalog of design fragments of conventional best practice. By evaluating 36 applets pulled from the internet we show that these design fragments are common, many applets copied the structure of the Sun demos, and that creation of a catalog of design fragments is practical. Design fragments give programmers immediate benefit through tool-based conformance assurance and long-term benefit through expression of design intent.", "authors": [{"name": "George Fairbanks", "author_profile_id": "81100642138", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "P514691", "email_address": "", "orcid_id": ""}, {"name": "David Garlan", "author_profile_id": "81452615764", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP39036652", "email_address": "", "orcid_id": ""}, {"name": "William Scherlis", "author_profile_id": "81100605830", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "P299939", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167480", "year": "2006", "article_id": "1167480", "conference": "OOPSLA", "title": "Design fragments make using frameworks easier", "url": "http://dl.acm.org/citation.cfm?id=1167480"}