{"article_publication_date": "10-16-2006", "fulltext": "\n Uniform Proxies for Java Patrick Eugster Department of Computer Science Purdue University p@cs.purdue.edu \nAbstract The proxy abstraction has a longlasting tradition in object settings. From design pattern to \ninherent language support, from remote method invocations to simple forms of behavioral re.ection in\u00adcarnations \nas well as applications of proxies are innumerable. Since version 1.3, Java supports the concept of dynamic \nproxy. Such an object conforms to a set of types speci.ed by the program and can be used wherever an \nexpression of any of these types is expected, yet rei.es invocations performed on it. Dynamic proxies \nhave been applied to implement paradigms as diverse as behavioral re.ection, structural conformance, \nor multi-methods. Alas, these proxies are only available for interfaces . The case of creating dynamic \nproxies for a set of types including a class type has not been considered, meaning that it is currently \nnot possible to create a dynamic proxy mimicking an instance of a given class. This weakness strongly \nlimits any application of dynamic proxies. In this paper we unfold the current support for dynamic prox\u00adies \nin Java, assessing it in the light of a set of generic criteria for proxy implementations. We present \nan approach to supporting dy\u00adnamic proxies for classes in Java, consisting in transformations performed \non classes at load-time, including a generic scheme for enforcing encapsulation upon .eld accesses. These \ntransformations seemlessly extend the scope of the current support for dynamic proxies. We discuss the \nprecise bene.ts and costs of our extension in terms of the criteria introduced, and illustrate the usefulness \nof uniformly available proxies by implementing future method invo\u00adcations both safely and transparently. \nCategories and Subject Descriptors D2.3 [Software En\u00adgineering]: Coding Tools and Techniques Object-oriented \nprogramming; D3.3 [Programming Languages]: Language Constructs Classes and objects General Terms Experimentation, \nLanguages Keywords Java, future, proxy, transformation 1. Introduction The concept of proxy an object \nmimicking another object has a longlasting tradition in the realm objects, enjoying both innumer\u00adable \nincarnations and applications. The proxy design pattern and its relatives, such as the decorator pattern \n(responsibilities can be Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed dynamically \nattached to objects) or the adapter pattern (method invocations performed on an expression can be translated \n) [9], for instance, are probably among the most prominent of all de\u00adsign patterns. Examples of widespread \nand traditional applications of proxies are of course remote invocations [24], future objects in asynchronous, \nso-called future, invocations [34] (remote or not), and behavioral re.ection [16]. At version 1.3, JavaTM \ns core re.ection API [26] has seen the addition of dynamic proxies. A dynamic proxy is a typed proxy, \ncreated at run-time for a type (a set of types) de.ned by the appli\u00adcation. Such an object can be used \nin a consistent manner wherever an expression of that type (of any of those types) is expected. An in\u00advocation \nperformed on such a dynamic proxy object is however rei\u00ad.ed, somehow stepping from a statically typed \ncontext to dynamic interaction where any action can be performed in the con.nes of a method invocation. \nTogether with dynamic invocation facilities, this concept enables graceful realizations of the above-mentioned \npatterns and applications. Examples are plentiful. The WWW hosts various reports on implementations of \npopular paradigms in Java based on dynamic proxies, e.g., implicit (structural) conformance, future invocations, \ndynamic multi-dispatch (a.k.a. multi-methods), design by contract [21] or aspect-oriented programming \n[17] (see for instance [7] and [13] respectively for the latter two). Further\u00admore, dynamic proxies are \nnow of.cially endorsed as the preferred means for implementing Java RMI, making the rmic pre-compiler \nobsolete. The implementation of dynamic proxies in Java is simple and elegant. When creating a dynamic \nproxy for an interface (type) I, an instance of a class implementing I is created, that class be\u00ading \ngenerated automatically as byte code at run-time, loaded, and linked. This requires no speci.c support \nfrom the Java compiler or virtual machine [25]. Leaving aside the proxy-inherent two-body issue (a proxy \nand the object it mimicks remain distinct entities) this simple solution unfortunately manifests important \nlimitations: dynamic proxies are not uniformly available, but only for inter\u00adfaces . In other terms, \nsuch proxies can not be assigned to vari\u00adables whose static type is a class (type). This limitation strongly \nhampers the potential of dynamic proxies overall. To fully exploit the above-mentioned paradigms through \nimplementations based on dynamic proxies, programs are ultimately constrained to de.ne all variables \nas being of interface types, and to use classes only for instantiation. Consider the case of future invocations, \nwhich in\u00adtuitively make an ideal case for dynamic proxies. Unless respect\u00ading the above-mentioned severe \nconstraint, they can currently only be implemented explicitly [34] without such proxies. Transparency \ncan be achieved of course by other means. [22] for instance makes use of a powerful static analysis and \ncorresponding program trans\u00ad for pro.t or commercial advantage and that copies bear this notice and \nthe full citation formations, which however only deal with future invocations, and on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute are not complete. to lists, requires \nprior speci.c permission and/or a fee. The goal of this paper is to make the concept of dynamic proxies \nOOPSLA 06 October 22 26, 2006, Portland, Oregon, USA. Copyright . 2006 ACM 1-59593-348-4/06/0010. . . \n$5.00 in Java more uniformly available, i.e., also for classes . Unlike c seminal work extending Java \nfor the speci.c purpose of behavioral re.ection (e.g., [10, 6, 33], see Section 8), we augment Java s \nexisting support for dynamic proxies. More precisely, we make the following contributions: We unfold \nthe current support for dynamic proxies and their implementation in Java.  We discuss limitations of \nproxies overall, and in the case of Java, and establish a set of criteria to express what we expect from \na proxi.cation scheme. This set includes concerns such as completeness, safety, security, transparency, \nor performance overhead.  We propose uniform dynamic proxies for Java, building on the existing support \nfor dynamic proxies. This leads to creating a dynamic proxy class for a set of types including a class \nC as subclass of C . In order to make such an extension approach feasible, we introduce a set of byte \ncode transformations includ\u00ading a general scheme for transforming instance .eld accesses to invocations \nof automatically created getter/setter methods.  These transformations yield an internal uniformly virtual \nobject model, in which any type/member can be extended/overridden. We present how we have tamed the power \nof this model in the loading process to ensure extension and visibility constraints of programs.  We \nillustrate the bene.ts of uniform dynamic proxies by im\u00adplementing future method invocations in a way \nbalancing the transparency of [22] and the safety of [31], without requiring any future-speci.c static \nanalysis and program transformations.  We discuss our uniform proxies/uniformly virtual object model \nin the light of the proxi.cation criteria introduced. This includes measurements (conducted with the \nSpecJVM benchmark suite) of the overhead introduced by our uniformly virtual object model, which leads \nto quantifying the cost of encapsulation. We investigate the pros and cons of (different faces of) transparency \nin more depth through the case of future invocations, discussing also ways of dealing with the inherent \ntwo-body issue.  Roadmap. Section 2 dissects the original concept and implementa\u00adtion of dynamic proxies \nin Java. Section 3 discusses the limitations of dynamic proxies, and introduces our criteria for proxi.cation. \nSection 4 presents our approach to supporting dynamic proxies for classes, based on program transformations \nperformed at byte code level. Section 5 presents various issues tied to the implementation of these transformations \nin the class loading procedure. Section 6 re.ects on safety and transparency in future calls, and illustrates \nhow uniform proxies can help provide both. Section 7 discusses various issues, such as security impacts \nand limitations, further in the light of our proxi.cation criteria. Section 8 overviews related work. \nSection 9 concludes with .nal remarks.  2. Unfolding Java Proxies This section dissects the concept \nof dynamic proxies introduced with Java 1.3. 2.1 Presentation This appraisal includes a presentation \nof the types involved (see Figure 1) and perceived by programmers when manipulating dynamic proxies, \nand the creation of dynamic proxy classes. For presentation simplicity, we henceforth drop the quali.er \ndynamic when referring to proxies in the sense of Java re.ection, unless confusion might otherwise arise. \nFurthermore, we omit package names when they are unambiguous (e.g., java.lang.reflect common to most \ntypes for re.ection except Class meta-objects), public interface InvocationHandler { public Object invoke(Object \nproxy, Method method, Object[] args) throws Throwable; } public class Proxy implements Serializable \n{ protected InvocationHandler h; protected Proxy(InvocationHandler h) { this.h = h; } public static \n InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException {...} public static \nClass getProxyClass(ClassLoader loader, Class[] interfaces) throws IllegalArgumentException {...} public \nstatic Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) throws \nIllegalArgumentException {...} ... } Figure 1. Types InvocationHandler and Proxy and abbreviate syntax \nand names. For example im stands for the keyword implements,and RunExc might be used instead of RuntimeException. \nClasses and interfaces presented in separate .gures are reduced to those parts which are relevant for \nthe present work. 2.2 Proxy Objects A proxy is an object which conforms to a non-empty set of in\u00adterfaces \n{I1...In}, for which that proxy ( s class) was created. The corresponding proxy class extends class Proxy \n[27] depicted in Fig\u00adure 1, and implements all interfaces {I1...In} (see Section 2.4). Conforming to \nall those types, a proxy can be cast to any of them, and hence any method de.ned in either of those interface \ncan be invoked on the proxy. 2.3 Invocation Handlers Every proxy object has an associated object of \ntype InvocationHandler (see Figure 1), which handles the method invocations performed on the proxy. More \nprecisely, these invoca\u00adtions are rei.ed and passed to the invocation handler through its invoke method \nas illustrated by Figure 2. The arguments for an invocation of invoke include (1) the object on which \nthe method was originally invoked (i.e., the proxy), (2) a rei.cation of the method (an instance of class \nMethod) that was invoked on the proxy, and (3) the actual arguments (as an array of Objects). The invoke \nmethod is hence capable of handling any method invocation, which manifests in that the type of its return \nvalue and its arguments are of the root object type, and it is declared to throw instances of Throwable. \nAccording to the speci.cation [25], an exception of type ClassCastException is thrown if a wrong type \nis returned by invoke. Any exception from invoke of a type not de\u00adclared by the actually invoked method \nis wrapped in an UnknownThrowableException. This occurs also upon invoca\u00adtion of a method m on a proxy \ncreated for a set of interfaces {I1...In} in which at least two interfaces Ii and Ij declare m,but with \nnon-identical sets of exceptions. To ensure conformance, m will namely be declared to throw only exceptions \ndeclared by m in both Ii and Ij.A NullPointerException is thrown if null is returned by the invoke method \nbut the return type of the method invoked on the proxy is a primitive type (values of such types being \nwrapped by corresponding object types). Dynamic proxy Invocation handler Figure 2. Interacting with \ndynamic proxies ((I)) = I.class ((C)) = C.class ((m, T1...Tn))C = ((C)).getDeclMethod(m, {((T1) ,...,( \nTn))}) ((m, T1...Tn))I = ((I)).getDeclMethod(m, {((T1) ,...,( Tn))}) ((a))C = ((C)).getDeclField(a) Figure \n3. Rei.cation In essence, the invoke method de.ned by invocation handlers can be seen as the symmetric \ncounterpart to the invoke method im\u00adplemented by meta-objects representing methods. While the latter \nmethod allows to defer to run-time the choice of which method to invoke, the former one provides a means \nof deferring to run-time what to perform upon method invocation. 2.4 Proxy Creation The getProxyClass \nmethod in class Proxy expects as argument a set of interfaces de.ned by their respective Class meta-objects. \nWhen invoked, the method creates a proxy class, directly as byte code, as a class implementing that set \nof interfaces (unless a proxy class has already been created for that precise set) as a class which implements \nthose interfaces. A further argument to the above method is a class loader, with which the possibly created \nclass is to be loaded. In contrast the getProxyClass method described above, the method newProxyInstance \nin addition instantiates the possibly generated proxy class. It hence takes an additional argument, which \nis an invocation handler, and returns an instance of that class which the speci.ed invocation handler \nis associated with. Supposing a set of interfaces {I1...In} and an invocation handler ih we abbreviate \nsuch a call in the following (the class loader argument is omitted for simplicity): P [[I1...In, ih]] \n= Proxy.newProxyInstance(..., {((I1) ,...,( In))}, ih) The general notation ((...)) represents the rei.cation \nof con\u00adstructs (see Figure 31), and the notation P [[...]] represents the proxi.cation of constructs. \nThe Proxy class hence has a dual purpose. First, it serves as supertype for all proxy classes. Besides \nregrouping functionalities common to all proxy classes, this makes it possible to easily verify through \nthe instanceof operator whether a given object is a proxy. Second, the Proxy class contains class methods, \ndescribed above, which permit the generation of proxies/proxy classes, thus serving as factory . Note \nthat in certain cases it is impossible to create a proxy class for a set of interfaces [25]. Essentially, \nthe procedure fails whenever con.icts would also arise if a class was explicitly, i.e., statically, 1 \nThe static notation T .class is preferred to the dynamic lookup Class.forName(\"T \") for brevity, even \nwhen T is not know statically, and thus the former one would not apply. Similarly, the quotation marks \n\" will be omitted in certain cases. program P ::= {BD} classes B ::= c1...cn interfaces D ::= i1...in \nclass c ::= QV D cl CS {F B KMB } supertypes S ::= ext C im I1,...,In interface i ::= V D in I ext I1,...,In \n{MD} constructors K ::= k1...kn variables F x ::= fx 1 ...fx n methods Mx ::= dx 1 ...dx n constructor \nki ::= V B C(F D) ths X {e} variable fB i ::= V B Ta fD i ::= Ta method dB i ::= QV B Tm(F D) ths X {e} \ndD i ::= pub Tm(F D) ths X exceptions X ::= C1,...,Cn type T ::= C | I modi.er Q ::= fin | (virt) | abs \nvisibility V B ::= pub | (pack) | prot | priv V D ::= pub | (pack) expression e ::= null | this | a | \ne.a | e.a = e | e.m(e1,...,en) |P [[Ii...In, ih]] Figure 4. Simpli.ed Java syntax de.ned implementing \nthe speci.ed set of interfaces. Examples are the creation of a proxy class for two interfaces de.ning \nthe same method with different return types (return types not being consid\u00adered part of method signatures \nin Java), or for two non-public in\u00adterfaces de.ned in two distinct packages. A proxy class for a set \nof interfaces, including such with package visibility de.ned in the same package, is created in that \npackage, otherwise the package is unspeci.ed. For the following, we suppose the package in the latter \ncase to be always the same, and simply denote it as p.  2.5 Proxy Class Internals Once these cases have \nbeen ruled out, the generation of a proxy class for a given non-empty set of interfaces {I1...In} occurs \nas described in more detail in the following. We consider a simpli.ed Java syntax, outlined in Figure \n4. Fig\u00adure 5 summarizes relationships and orders (partial) among types (<T ), and (total) for visibility \n(<V ) and modi.cation (<Q) qual\u00adi.ers. We also introduce an order among (signatures of) methods . (= \nM), as well as a union operator (.M) and a union set (M )to capture overriding. (x)T denotes the declaration \nof x in T . Based on these de.nitions, [I-MSET] and [I-MSET-REC] in Figure 5 de\u00adscribe the construction \nof the sets of relevant methods MD(T ) for a given type T , also under consideration of supertypes (MB \n(T )). Only interfaces will be considered for now; the case of classes and hence .elds will be introduced \nin Section 4. The rules outlined in Figure 6 describe the original creation of proxies in source code \nnotation for readability. When a proxy class is created for interfaces {I1...In}, a class is created \n(here called I1...InProxy), which contains two constructors, and a method . body for each method in Mn \nMB (Ii). The body of such a proxy i=1 method is generated according to Figure 7. Note that methods equals, \nhashCode,and toString inherited by every class from Object are handled just like custom methods. They \nare also overridden by proxy classes, and invocations to them are hence forwarded to the invocation handler \nof the respective proxy. Other methods de.ned in Object are not overridden by proxy classes, as they \nare final. [U-DEF] [V-DEF] [Q-DEF] . n priv <V (pack) <V prot <V pub fin <V (virt) <V abs M (dilTi =(...(((d1lT1 \n.M (d2lT2) .M...)....M (dnlTn i=1 [T-TRANS] [T-CI] [T-CC] [T-II] T1 <T T2 T2 <T T3 cl C im I1, ..., \nIn cl C ext C' in I ext I1, ..., In T1 <T T3 . i . [1..n] C<T Ii C<T C' . i . [1..n] I<T Ii [I-MSET-REC] \nin I ext I1, ..., In { M} . [M-DEF] MB (I)= MD(I) . MMn MB(Ii) d1 = V1 T1.0 m(T1.1, ..., T1.k) ths C1.1, \n..., C1.l i=1 d2 = V2 T2.0 m(T2.1, ..., T2.k) ths C2.1, ..., C2.n [M-OVER] [I-MSET] . h . [1..k] T1.h \n= T2.h V1 = V V2 . n .l d2 = M d1 in I{ M} T2.0 = T T 1.0 C2.i . C1.j i=1j=1 . ( d1) T1 . M ( d2) T2 \n= ( d1) T1 MD(I)= ( d) I d1 = M d2 d . M Figure 5. Typing [P-CLASS] f ih: InvocationHandler P [[I1...In, \nih]] new I1...InProxy(ih) . f fin cl I1...InProxy ext Proxy im I1, ..., In { KM} [P-CONS] f cl I1...InProxy \n{ K} pub I1...InProxy(InvocationHandler ih) { sup(ih); }. K priv I1...InProxy() {} . K [P-METHS] f cl \nI1...InProxy { M} . . n P [[d]]mI = M (d = pub m(...) ...)I . M MB(Ii) i=1 Figure 6. Creating proxies \n[P-METH] P [[priv <V VT0 m(T1, ..., Tm) ths C1, ..., Cn]]r = T VT 0 m(T 1 a1, ..., T m am) ths C1, ..., \nCn {try { ret (T 0)ih.invoke(this, (( r, T1 ... Tm)) T , { a1, ..., am} ); } . n ctch(Ck x) { thr x; \n} k=1 ctch(Error e) { thr e; } ctch(RuntimeException r) { thr r; } ctch(Throwable t) { thr new UndThrException(t); \n} } Figure 7. Proxifying methods  2.6 Illustration Consider the interface I, de.ning a single method: \nimport java.io.*; public interface I{ public String foo(Integer i) throws IOException; } The following \nlines illustrate the creation of a proxy for this in\u00adterface I. The invocation handler associated with \nthe proxy simply prints the name of methods invoked on the proxy to the standard output, and forwards \nthe invocation to another object realI imple\u00admenting I: package p; import java.io.*;  public final \nclass IProxy extends Proxy implements I { private IProxy() {} public IProxy(InvocationHandler h) { super(h); \n}  public String foo(Integer i) throws IOException {try { Method md = I.class.getDeclaredMethod(\"foo\", \nnew Class[]{Integer.class}); return (String)h.invoke(this, md, new Object[]{i}); } catch(IOException \ne) { throw e; } catch(Error err) { throw err; } catch(RuntimeException rex) { throw rex; } catch(Throwable \nt) { throw new UndeclaredThrowableException(t); } } ... } Figure 8. A sample proxy class final I \nrealI = ...; InvocationHandler ih = new InvocationHandler() { public Object invoke(Object target, Method \nm, Object[] args) throws Throwable { System.out.println(\"Method \"+m.getName()+\" invoked\"); return m.invoke(realI, \nargs); } }; I i = (I)Proxy.newProxyInstance(I.class.getClassLoader(), new Class[]{I.class},ih); i.foo(10.0); \n > Method hello invoked Figure 8 outlines code of the proxy class generated for I in a schematic manner, \nchosen to accomodate our own implementation dealing also with the issues pointed out in the next section(s). \nNote that the class name is arbitrarily chosen: according to [25], the name space $Proxy* is reserved. \nCode fragments speci.c to custom interface I and its method(s) are emphasized. Methods from Object which \nare overridden are omitted in Figure 8 for brevity.   3. Assessment In this section, we elaborate on \nthe limitations of proxies in general, and on dynamic proxies in Java in particular. 3.1 Proxy-inherent \nLimitations The simplicity of the concept of proxy as an object able to mimick another object accounts \nfor its wide adoption as well as for its relative ease of implementation in object systems in the simplest \nform as design pattern. The same simplicity however accounts for its main limitation, the two-body problem: \nthe proxy and the object it respresents are distinct entities. While in certain scenarios this distinction \nturns out to be useful, and even desired, it is restrictive in the case of behavioral re.ection, and \nis one of the reasons why more recent derivatives of such re.ec\u00adtion (e.g., [17]) avoid proxies. For \nassociating a behavior through a dynamic proxy as a meta-level object with an existing base-level object, \nthe invocation handler associated with the corresponding proxy would most likely have to be given a reference \nto that object, and henceforth, the proxy would always have to be used instead of the original object, \nfor instance also for self-invocations.However, when a method of the actual target object invokes a further \nmethod of that very object, there is no way of intercepting that invocation ( self problem [19]). Similarly, \nself-references returned by a base\u00adlevel object invoked through a proxy would have to be recognized as \nsuch (e.g., by the associated invocation handler in the case of Java s proxies), such that again a proxy \ncould be returned instead ( encapsulation problem [19]). The detecting and handling of all such situations \nis very hard. Base-level objects can for instance also return references to their .elds which are dif.cult \nto identify, but would have to be shielded behind proxies as well. 3.2 Java Proxies In Java, proxies \ncan currently only be created for interfaces. Hence, creating a proxy for every value returned by a base-level \nobject requires return types of all methods of such an object to be inter\u00adfaces, and recursively also \nthe return types of the methods of those objects, etc. When striving for a uniform model of behavioral \nre\u00ad.ection with the current support for proxies in Java, the program\u00admer basically would be constrained \nto program exclusively with variables of interface types, and make use of classes only in instan\u00adtiations. \nThis limitation applies more generally to any application which would like to proxify objects of arbitrary \ntypes. 3.3 Extension Approach Achieving uniform proxies (i.e., any object can be proxi.ed) is of course \npossible with inherent language support, or in straight\u00adforward type systems. A proxy can be created \nfor any object in Smalltalk as an instance of a generic proxy class overriding just the default message \nhandler doesNotUnderstand [23]. The extension approach is also implementable in Java as a pure library, \ni.e., with\u00adout support from the runtime environment, yet with limited com\u00adpleteness. Since an instance \nof a proxy class must conform to the types it was created for, a proxy class created for a class C would \nalso have to subclass C and override all members. We enumer\u00adate in the following different obstacles \nencountered in the context of Java when straightforwardly applying this extension approach: (Section \n8 relates alternatives, such as the envelopment approach chosen by prominent implementations of behavioral \nre.ection in Java.) As pointed out in [28], an extension approach works well as long as everything is \nvirtual, i.e., no declarations are sealed. In Java, this manifests in that proxies could not be created \nfor classes kept from being subclassed by being marked as final. Similarly, methods decorated by that \nsame keyword could not be overridden. Members which are hidden might not be overridable. In Java, .elds \nare shadowed [20], and thus do not undergo dynamic dispatch. Though the semantics and rationale are different, \nprivate methods are also in some sense hidden, and thus can not be overridden by subclasses.  The coupling \nof initialization code between classes and super\u00adclasses, especially if not explicit, is another source \nof problems. In Java every constructor (except the no-argument construc\u00adtor in the root class Object) \nmust call a superclass construc\u00adtor, whether this is explicitly coded as .rst instruction inside a given \nconstructor, or a call to the default no-argument con\u00adstructor of the superclass is automatically added \n[20]. Relying on such default constructors of superclasses for initialization of proxy classes can yield \nside-effects, and as a matter of fact, might also fail if such a constructor is hidden (i.e., private, \nsee above).  3.4 Proxi.cation Criteria Based on the previous observations, we de.ne in the following \ncriteria of proxi.cation considered for the extensions proposed in the following and their subsequent \nevaluation. COMPLETENESS: This twofold criterion quanti.es the proportion of the types which can be proxi.ed \nat all, and also how much of those types can be proxi.ed. Typically, the impossibility of creating proxies \nfor .nal classes in Java, limits completeness in the .rst sense, while the impossibility of overriding \ncertain members can limit completeness in the second sense. SAFETY: Proxifying a construct, and giving \nthe possibility to per\u00adform any actions instead of the ones de.ned by the original con\u00adstruct obviously \ncan lead to safety issues ranging from unex\u00adpected exceptions to undesired side-effects. SECURITY: Closely \nrelated to the issue of safety is that of secu\u00adrity: using an entity instead of another one can obviously \nalso lead to security issues in a platform which incorporates security constraints. OVERHEAD: Any proxi.cation, \nor indirection used to achieve it, may introduce a performance overhead which must be consid\u00adered. TRANSPARENCY: \nThis measure describes how aware the program\u00admer is of the points at which proxi.cation occurs. The two-body \nissue nicely demonstrates the impact of transparency of a proxi\u00ad.cation mechanism. These different properties \nare likely to be correlated in any proxy implementation, and often tradeoffs have to be made. The .rst \ncriterion for instance describes the breadth of a proxi.cation. Extending it beyond a certain point \neven if possible might however lead to unsafe or unsound behavior and thus be undesired. Similarly, \ntransparency of a proxi.cation mechanism is not actually desired in certain contexts as it may compete \nwith safety. We will have a closer look at transparency later on in the context of future invocations. \n  4. Uniform Dynamic Proxies This section proposes an enhancement of Java s current implemen\u00adtation \nof dynamic proxies, aiming at increasing completeness by adding support for proxies for classes. 4.1 \nUniformly Virtual Object Model In essence, our approach builds on the principle applied for the generation \nof proxies for interfaces, that is, a proxy class for a set of types including a class is generated, \nwhen needed, at run-time as byte code, loaded, and linked. In order for a proxy to be able to reify any \naction performed on it, its class must hence override all superclass members (Figure 9 overviews the \nsets of members of classes). To deal with the limitations outlined in the previous section, we propose \nin the following a set of nearly independent transformations, denoted by T[[...]] , performed at byte \ncode level upon class loading for dealing with those cases. These yield a uniformly virtual object model, \nin which any instance member of a class can be overridden, and any class can be extended. The next section \npresents the integration of this model into Java s class loading procedure. Note that the choice of an \nextension approach has been moti\u00advated by the desire of retaining as much as possible of existing mechanisms \nand concepts of proxies for interfaces, but also by the fact that this approach adds no direct performance \npenalty in the most common case of invocations of non-private and non-.nal methods (see Section 5.4). \n[C-FSET] [C-MSET] cl C {F } cl C {M} .. DD F (C)=(f)C M(C)=(d)C f. Fd. M [C-FSET-REC] ' cl C ext Cim \nI1, ..., In{F } . BB' F (C)=(f)C . F (C) f. F [C-MSET-REC] ' cl C ext Cim I1, ..., In{M} BDB'.n B M(C)= \nM(C) . MM(C) . MM (I) i i=1 M Figure 9. Method and .eld sets for classes 4.2 Proxy Types As a direct \nconsequence, a proxy class created for a set of types including a class C must subclass C and hence cannot \nsubclass class Proxy. As elucidated in Section 2.4, it is however very useful to have a common supertype \nfor all proxy types, be it for the mere purpose of testing whether an object is indeed a proxy. To that \nend, we introduce the ProxyType interface (Figure 10). The Proxy class still serves as superclass for \nproxy classes created for a set of interfaces exclusively (see Figure 11), and hence implements ProxyType. \nThis is depicted in Figure 12, which focuses on additions in the new backwards-compatible version of \nthe Proxy class. Modi.cations from the original version are emphasized. 4.3 Access Handlers Furthermore, \nwe introduce a type AccessHandler to re.ect the possibility of performing (instance) .eld accesses in \naddition to (instance) method invocations in the case of proxies for classes. Field accesses made on \na proxy created for a set of types including a class are handled namely through methods get and set of \nan instance of that AccessHandler type associated with the proxy. The AccessHandler type hence complements \nthe InvocationHandler interface. Such an instance must be passed to any proxy created for a class. We \nthus augment our considered subset of Java of Figure 4 by a further kind of expression, leading to the \nfollowing extended expression set: ex = e |P[[C, I1...In, ah, ih]] This new expression is a shortcut \nfor creating proxies for classes . A proxy for a set of types including a class C and set of interfaces \n{Ii...In}, an invocation handler ih, and an access public interface ProxyType extends Serializable {} \n public interface AccessHandler { public Object get(Object proxy, Field field) throws RuntimeException; \npublic void set(Object proxy, Field field, Object val) throws RuntimeException; } public class UnexpectedRuntimeException \nextends RuntimeException {...} } Figure 10. New auxiliary types public class Proxy implements ProxyType \n{ protected InvocationHandler ih; protected Proxy(InvocationHandler h) { this.h = h; } ... public static \n AccessHandler getAccessHandler(Object proxy) throws IllegalArgumentException {...} public static Class \ngetProxyClass(ClassLoader loader, Class cl, Class[] interfaces) throws IllegalArgumentException {...} \npublic static Object newProxyInstance(ClassLoader loader, Class cl, Class[] interfaces, InvocationHandler \nih, AccessHandler fh) throws IllegalArgumentException {...} } Figure 12. Augmented Proxy class handler \nah, is created as follows: P[[C, I1...In, ah, ih]] = Proxy.newProxyInstance(..., ( C) , {((I1) ,...,( \nIn))}, ah, ih) Consequently, class Proxy has been added variants of the getProxyClass and newProxyInstance \nclass methods enabling the lookup/generation of a proxy class for a (possibly empty) set of interfaces \nand a class, including instantiation of that proxy class in the second case. Exceptions can be thrown, \nsimilarly to the original Proxy class, whenever the signatures of methods of supertypes for which the \nproxy class is to be created con.ict, or visibility problems occur (see Section 2.4). 4.4 Field Accesses \nField accesses have to trigger method invocations in order to be rei.ed. With an extension approach, \na solution to this consists in replacing .eld accesses to invocations of getter/setter methods which \nare automatically generated for classes. Since in Java, like in many other languages, .elds can not be \noverridden by subclasses, but only hidden (see Section 3.3), .eld access interception can not be achieved \nsimply by de.ning a getter/setter method pair ` a-la getf/setf in a class C for each .eld f de.ned by \nC. Care must be taken that the information about the class C in which a .eld is declared is not lost. \nA solution to this consists in conveying information about the declaring class C of a .eld in its respective \ngetter/setter method. To that end, we determine the name of such methods according to two respective \nfunctions G, S: A\u00d7B.M,where A, B,and M denote the sets of .eld, class, and method names respectively. \nThis is illustrated in the following through three recursive subclasses with G(a, C)= get$C$a and S(a, \nC)= set$C$a: [G-ACC] G[[VTa]]C = VT G(a, C)() { ret a; } V void S(a,C)(Ta) { this.a = a; } [G-METH-PRIV] \nG[[priv Tm(T1, ..., Tm) ths X]]C = T U(m,C)(T 1 a1,...,T m am) ths X { ret m(a1,...,am); } [G-CON] G[[C]] \n= prot C(R() i) { sup(i); } Original classes: .T Transformed classes: class C1 { class C1 { String s; \nString s; } String get$C1$s() { return s; } void set$C1$s(String s) { this.s =s;} } class C2 extends \nC1 {} class C2 extends C1 {} class C3 extends C2 { class C3 extends C2 { String s; String s; } String \nget$C3$s() { return s; } void set$C3$s(String s) { this.s =s;} Observe the corresponding transformations \nin code accessing the .elds of the above classes (source code for readability). The original code (left) \nand the code resulting from replacing those lines with corresponding transformations (right) in the original \ncode have the same effect: Original code: .T Transformed code: C1c1=...; C1c1=... c1.s = ...; c1.set$C1$s(...); \n ... = c1.s; ... = c1.get$C1$s(); C2 c2 = ...; C1 c1 =... c2.s = ...; c2.set$C1$s(...); ... = c2.s; \n... = c2.get$C1$s(); C3 c3 = ...; C1 c1 =... c3.s = ...; c3.set$C3$s(...); ... = c3.s; ... = c3.get$C3$s(); \n This scheme ensures that always the right variable is accessed. The speci.c corresponding transformations \nin Figure 13, i.e., (10), (15), and (16), are dubbed TFA. Figure 14 shows the generation of .eld access \nmethods for a given .eld (the generation of constructs is denoted by enclosing the source de.nition in \nG[[...]] ). Note that accesses to a .eld made in the access methods of that .eld are not transformed. \nSimilarly, .eld accesses made in .eld initializations coupled with .eld declarations are retained. Note \nfurthermore that for simplicity, the package name of a class is supposed to be part of the class name. \nThe names of get\u00adter/setter methods for a .eld declared in a given class namely con\u00adtain the name of \nthe class (in addition to that of the .eld), but also that of the package in which the class is contained \n(with occur\u00adrences of . replaced by $ ). Without this information, con.icts could occur in the case where \na class called C in package p2 sub\u00adclasses another class of same name C in package p1, and both classes \ndeclare a .eld of same name. Figure 14. Generating access and stub methods, and constructors 4.5 Private \nFields and Methods The above transformations do not enable the rei.cation of accesses to .elds which \nare private. This stems from the fact that the dispatch of a private (getter/setter) method does not \nstart at the class of the invoked object, but rather at the class declaring the method making use of \nthe invokespecial rather than invokevirtual byte code operator [20]. To circumvent this caveat, getter/setter \nmethods for private .elds are de.ned with package visibility, the weakest visibility enabling overriding/dynamic \ndispatch. The similarity between the lookup for private methods and the lookup for .elds suggests the \nadoption of a scheme for intercep\u00adtion of application-de.ned private methods inspired by the one ap\u00adplied \nfor .eld accesses, consisting in complementing private meth\u00adods with stub methods, through which former \nmethods are invoked. A stub method differs from the original method in its visibility quali.er (package \nvisibility) and name. Akin to getter/setter meth\u00adods, stub methods convey information about their class \nand the method name. More precisely, stub method names are determined by a function U: M\u00d7B.M(e.g., U(m, \nC)= C$m). This avoids accidental overriding in subclasses, since, as described above a class can very \nwell declare a same private method as its super\u00adclass. Private methods are complemented by stub methods \nrather than modi.ed directly because the renaming of methods declared to be native would invalidate lookup \ntables of corresponding na\u00adtive libraries. The transformations TPM corresponding to private methods in \nFigure 13 are (8) and (17). The transformation for private .elds, TPF, involves transformation (11). \nMB(T )[m(e1...en)] .(d)T ' denotes the method (declaration) d statically determined to handle a call \nto m with arguments e1...en on a given type T (this does not involve an actual lookup in the transformations \nin Figure 13). Note that TPF only makes sense if TFA is enabled. This is however the only dependency \nin the transformations presented in this section.  4.6 Final Classes and Methods There is no magic behind \nthe solution to circumventing the limita\u00adtions introduced by the final keyword. It consists in handling \n.nal classes and methods as non-.nal ones when linking corresponding classes, yet keeping track of these \noccurrences for the veri.cation of classes (see Section 5.1). The schemes for dealing with .nal classes \n(TFC)and .nal methods (TFM) are decribed by (2) and (6) respectively. As a consequence of TFM unlike \nin the original implementation of dynamic proxies also methods de.ned in the root object type Object \nas .nal can now be overridden by proxies, even by proxies created for interfaces only. T[[P ]] = T[[c1]] \n...T[[cm]] D (1) T[[fin V D cl C ... {KMB }]] = T[[V D cl C ... {KMB }]] (2) F B F B T[[fin <Q QV D cl \nC ... {KMB }]] = QV D cl C ... {T[[F B KMB ]] }, fG[[C]] .K (3) F B KMB ]] = T[[fB ]] T[[dB (4) T[[VC(T1 \na1, ..., Tm am) ths X {e}]] = VC(T 1 a1,...,T m am) ths X {T[[e]] } (5) T[[fin VT0 m(T1 a1, ..., Tm am) \nths X {e}]]C, M = T[[VT0 m(T1 a1, ..., Tm am) ths X {e}]]C, M (6) T[[fin <Q QV T0 m(T1 a1, ..., Tm am) \nths X {e}]]C, M = Q T[[VT0 m(T1 a1, ..., Tm am) ths X {e}]]C, M (7) T[[priv Tm(T1 a1, ..., Tm am) ths \nX {e}]]C, M = priv T[[Tm(T1 a1, ..., Tm am) ths X {e}]]C, M fG[[priv Tm(T1 a1, ..., Tmam) ths X]] C .M \n(8) T[[priv <V VTm(T1 a1, ..., Tm am) ths X {e}]]C, M = Tm(T 1 a1,...,T m am) ths X {T[[e]]C, M } (9) \nT[[priv <V VTa]]C,!M = VTa, fG[[VTa]]C .M (10) T[[priv Ta]]C, M = priv Ta, fG[[Ta]]C .M (11) T[[null]] \n= null (12) T[[this]] = this (13) T[[a]] = a (14) T[[F B 1 ]]C,M ...T[[foB]]C,M T[[k1]] ...T[[kp1 ]]C,M \n...T[[dBq ]]C,M e: C fT[[e.a]] = T[[e]] .G(a, C)() (15) '' e: C fT[[e.a = e ]] = T[[e]] .S(a, C)(T[[e \n]] ) (16) e: C, MD (C)[m(e1,...,en)] .(Q priv ...)C fT[[e.m(e1, ..., en)]] = T[[e]] .U(m, C)(T[[e1]] \n,...,T[[en]] ) (17)  e: C, MD (C)[ m(e1,...,en)] .(Q priv <V V ...)T fT[[e.m(e1, ..., en)]] = T[[e]] \n.m(T[[e1]] ,...,T[[en]] ) (18) T[[P[[I1...In, ih]]]] = P[[I1...In, ih]] (19) T[[P[[C, I1...In, ah, ih]]]] \n= P[[C, I1...In, ah, ih]] (20) Figure 13. Program transformation T 4.7 Superclass Constructors The troubles \nwith default constructors have been mentioned already in Section 3.3. As a countermeasure, we introduce \nan initializer class, dubbed R: .B, which is a public class containing nothing but a public no-argument \nconstructor. Every class is added a con\u00adstructor with a single argument of that type, which simply passes \nthat argument to the corresponding constructor of the superclass. TSC refers to transformation (3). \n4.8 Uniform Proxy Class Internals Figure 15 outlines the generation of a proxy class generated for a \nset of types including a class. The scheme integrates seemlessly with the original one outlined in Section \n2.4. If no class C is speci.ed for the extended scheme, the behaviors of the two schemes are the same. \nRules post.xed with X in Figure 15 supersede corresponding rules of the original proxy generation. A \nproxy class for a class C is de.ned as subclass of that class C (and subtype of ProxyType), and overrides \nall original instance methods of its superclass(es). Proxy methods for non\u00adprivate methods are still \ncreated in proxy classes according to Figure 7. To reify accesses to .elds and invocations to private \nmethods, a proxy class generated for a class also overrides all getter/setter and stub methods de.ned \nby its ancestor(s). The corresponding bodies are sketched in Figure 16. Upon invocation, an access method \nrei\u00ad.es the corresponding .eld access and passes the resulting objects to the AccessHandler associated \nwith the proxy by calling the get or set method respectively. Regarding the package in which a proxy \nclass is created, the rule given in Section 2.4 applies without modi.cations. That is, a proxy class \ncan only be created for a set of types including a class of which some types have package visibility \nif they are indeed de.ned in the same package. Furthermore, proxy creation can fail in similar situations \nas proxies for interfaces only (e.g., clashes in method declarations). In the case of a proxy class created \nfor a class C and an interface I, both de.ning the same method yet with different [P-CLASS-X] fah: AccessHandler, \nih: InvocationHandler P[[C, I1...In, ah, ih]] . new CI1...InProxy(ah, ih) ffin cl CI1...InProxy ext C \nim ProxyType,I1, ..., In {...} [P-CONS-X] fcl CI1...InProxy {K} priv CI1...InProxy() {}.K P[[CI1...InProxy]] \n.K [P-FLDS] fcl CI1...InProxy {F } priv AccessHandler ah; .F priv InvHandler ih; .F [P-METHS-X] fcl CI1...InProxy \n{M} . . n P[[d]]T .M (dlT . MB(C) .MM i=1 MB(Ii) [P-ACC] fcl CI1...InProxy {M} pub AccessHandler getAccessHandler() \n{ ret ah; }.M pub InvHandler getInvHandler() { ret ih; }.M . P[[VT0 a]]C .M (priv <VVT0 alC . FB (C) \n[P-ACC-PRIV] fcl CI1...InProxy {M} . P[[T0 a]]C .M (priv T0 alC . FB(C) Figure 15. Extended proxy creation \nvisibilities (i.e., anything except public in the case of C), the proxy class implements that method \nas public. 4.9 Illustration Suppose a class C implementing interface I introduced in Sec\u00adtion 2.6 and \nadding a .eld bar: public class C implements I{ public String bar; public String foo(Integer i) throws \nIOException {...} } [P-ACC] P[[VTa]]C = VT G(a,C)() {try { ret (T )ah.get(this, ( a) C ); }ctch(RuntimeExc \nr) { thr new UnexpRuntExc(r); }} V void S(a,C)(Ta) {try { ah.set(this, ( a) C , a); }ctch(RuntimeExc \nr) { thr new UnexpRuntExc(r); } } [P-METH-PRIV] P[[priv Tm(T1, ..., Tm) ths X]]C = P[[T U(m, C)(T1, ..., \nTm) ths X]]m C [P-CON] P[[C]] = pub C(AccessHandler ah, InvocationHandler ih) {sup(new R()()); this.ah \n= ah; this.ih = ih; } Figure 16. Proxifying access and stub methods, and constructors The following lines \nillustrate the creation of a proxy for C (the invocation handler ih from Section 2.6 is reused): final \nC realC = new C(); AccessHandler ah = new AccessHandler() { public Object get(Object target, Field f) \n{ System.out.println(\"Field \"+f.getName()+\" read\"); return f.get(realC); } public void set(Object target, \nField f, Object val) { System.out.println(\"Field \"+f.getName()+\" written\"); f.set(realC, val); } }; \nC c = (C)Proxy.newProxyInstance(C.class.getClassLoader(), new Class[]{C.class}, null, ah, ih); c.bar \n= \"hello\"; > Field bar written The proxy class created upon the invocation of the newProxyInstance method \nde.ned in the augmented Proxy class yields the pseudo code depicted in Figure 17 (with R() = ProxyInit). \n  5. Implementation Issues This section discusses implementation choices and consequences of the proposed \nextensions. 5.1 Applying Transformations As mentioned previously, the transformations described in the \npre\u00advious section are performed at load time. When a class C is to be loaded, it goes through the following \ncomponents (see Figure 18): Analyzer: Class C s byte code is analyzed, and the extension and visibility \nconstraints of C con.icting with subclassing/overrid\u00ading, e.g., occurrences of .nal or private, are identi.ed. \nVeri.er: The class C is veri.ed, in particular against the con\u00adstraints of previously loaded classes. \nVirtualizer: The transformations described in the previous section are applied. Beyond this point, C \nis uniformly virtual. Linker: The class is linked, and is ready to be used. Though possible, this loading \nprocedure has not been imple\u00admented as a user class loader, as the loading of only some classes in package \np; import java.io.*; public final class CIProxy extends C implements ProxyType, I { private AccessHandler \nah; private InvocationHandler ih; private CIProxy() {} public CIProxy(AccessHandler ah, InvocationHandler \nih) { super(new ProxyInit()); this.ah = ah; this.ih = ih; } public AccessHandler getAccessHandler() \n{ return ah; }public InvocationHandler getInvocationHandler() { return ih; } public String foo(Integer \ni) throws IOException {...}public String get$C$bar() { try {Field field = C.class.getDeclaredField(\"bar\"); \nreturn (String)ah.get(this, field); } catch(RuntimeException rex) {throw new UnexpectedRuntimeExeption(rex); \n} } public void set$C$bar(String bar) { try {Field field = C.class.getDeclaredField(\"bar\"); ah.set(this, \nfield, bar); } catch(RuntimeException rex) {throw new UnexpectedRuntimeExeption(rex); } } ... } Figure \n17. A sample proxy class for a class a way bypassing that loader (by using another user class loader, \ncf. Figure 18) would have strongly hampered safety and security [11]. Especially the possibility of enabling \nonly certain transformations (e.g., only TSC and TFA) would have introduced potential for mis\u00aduses. Along \nthe lines of several other extensions to Java (e.g., Agesen et al. s proposal for genericity [1]), we \nmake use of a pre\u00adprocessor integrated with the virtual machine s (default) class load\u00ading and linking \npath. More precisely, the analyser, veri.er, and vir\u00adtualizer are all parts of an instrumented system \nclass loader. As illustrated by Figure 18, classes can still be loaded with user class loaders before \nbeing passed on to that system loader. 5.2 Increasing Safety As mentioned previously, the parameterization \nof the functions G(a, C)and S(a, C) for naming .eld access methods, as well as of U(m,C) for naming stub \nmethods by the class C in which they are originally de.ned avoid accidental overriding in subclasses. \nThe parameterization of constructors by R() serves a similar purpose. The functions described so far \n(e.g., m$C for a stub for m in class C) have however only been chosen for illustration. In fact, these \nfunctions also involve a secret key to hash m and C respec\u00adtively. This measure not only further decreases \nthe chances of ac\u00adcidental overriding of .eld access methods, stub methods, or con\u00adstructors, but also \navoids intentional overriding. Otherwise, by ob\u00adserving one such name, e.g., through the printout of \na stack trace upon the occurrence of an exception, speci.cally designed sub\u00adclasses could be introduced \neasily into the system, compromising safety (see Section 3.4). Issues related to security (in the Java \nsense) will be discussed in Section 7.1. 5.3 Resolving Meta-Objects As already pointed out, the illustrations \nprovided for the creation of dynamic proxies in the case of a set of types consisting of only interfaces, \nbut also in the case of a set including a class, are schematic. According to Figures 8 and 17 namely, \nall relevant meta-objects (representing methods and .elds respectively) are re\u00adsolved (i.e., looked up) \nat every method invocation or .eld access targeting an instance of a proxy class. In practice, this repeated \nres\u00adolution is replaced by a static, lazy, one. More precisely, proxy class instances retain Method and \nField objects once looked up in an in\u00adternal table which is de.ned as static and thus shared by all in\u00adstances \nof such a class. Note at this point that the Method object looked up for a given method invoked on a \nproxy does not necessarily represent the exact method which would have been executed had the object not \nbeen a proxy. This is due to the fact that invocations of (non\u00adprivate) methods are dynamically dispatched, \nand that the type of the variable through which the invocation is performed is lost . In particular, \na proxy being called through a method m declared in two distinct interfaces I1 and I2 both implemented \nby the proxy class, can not distinguish whether it has been called through I1 or I2. Just like with the \noriginal implementation of dynamic proxies in Java, the method meta-object resolved upon that invocation \nis the one corresponding to the .rst of the interfaces I1 and I2 to have appeared in the array of types \npassed upon creation of the proxy (class). Classes take precedence over interfaces. More useful information \nis however obtained upon .eld ac\u00adcesses with our extension. Since the information of the declaring class \nof an accessed .eld is contained in the name of the used get\u00adter or setter method, the resolved meta-object \nin the case of a .eld access rei.cation can re.ect faithfully the class containing the ac\u00adcessed .eld \n(which is however not necessarily the static type of the variable through which the .eld was accessed). \n 5.4 Overhead The transformations performed on code to support proxies for classes nicely illustrates \nthe tradeoff between completeness and overhead. Removing the effect of the final keyword may affect performance \nby reducing the number of opportunities where the just in time (JIT) compiler can perform method inlining. \nHowever, JIT compilers such as Sun s HotSpotTM virtual machine can also inline methods which are not \n.nal, and as long as no subclass overriding such an inlined method is loaded (e.g., a proxy class), ms \n30 25 20 15 10 5 0  (none)  T FC, T FM, T FA T FC, T FM, T FA, T PM, T PF Figure 19. Performance overhead \nof transformations the JIT compiler does not have to recompile an affected class. This occurs in our \ncase only when a proxy class is loaded, and hence no sensible overhead was measured due to TFC and TFM \nin performance measurements. The main overhead associated with each of those transformations, and the \nonly one in the case of TSC, becomes then the cost of performing the transformation itself, which is \nneglectable since classes are only instrumented once upon loading. The transformations for .eld accesses \n(TFA) and private mem\u00adbers (TPM and TPF) are however more expensive in terms of over\u00adhead. Furthermore, \nit turns out that latter category has a stronger impact than former one. This is proof of a good programming \ndis\u00adcipline, as it re.ects the level of encapsulation that is achieved with respect to .elds. In any \ncase however, the overheads are not as dras\u00adtic as one might expect. These obvervations are conveyed \nby Fig\u00adure 19, which elucidates results of performance measurements ob\u00adtained with different sets of \ntransformations enabled. These results were computed with the SpecJVM benchmark suite on a HP Om\u00adnibook \nXE3, with a Pentium III processor, running Redhat Linux release 7.3. (Though enabled, TSC is not mentioned \nin the .gure, for the reason described above). Note that interface invocations are still slow (this is \nnot a neces\u00adsity, but still a valid statement when considering current implemen\u00adtations of dynamic dispatch \n[2]), and that according to the original scheme for dynamic proxies these are always invoked through \nin\u00adterfaces. If one would want to achieve a similar resilience with re\u00adspect to behavioral re.ection \nwithout our extension, i.e., one would like to be able to create a proxy for any object in an application, \none would not only have to introduce corresponding interfaces for all types in an application as mentioned \nin Section 3.1, but would also experience the additional overhead of interface invocations.  6. Transparent \nand Safe Futures This section illustrates the bene.ts of uniform proxies for Java by implementing future \ninvocations transparently and safely. Various other application scenarios which have originally motivated \nthis work, such as a lazy form of remote object passing, or the expres\u00adsion of predicates evaluated remotely \nin a deferred manner, are de\u00adscribedin[8]. 6.1 Explicit Futures in Java When implementing futures [34] \nin Java, programmers are cur\u00adrently required to identify upfront which methods/subprograms might be called \nasynchronously, and are forced to make use of the type parameterized Future and Callable interfaces de.ned \nin package java.util.concurrent (see Figure 20, [27]). In short, type Future<T > is used on the caller \nside when the respective logical return type of an (asynchronous) invocation would have been T , and \nthe called object will in fact implement Callable<T >. A programmer can achieve the asynchronous execution \nof a callable object by instantiating the prede.ned FutureTask with that object. Executing the future \ntask (run) then leads to invoking the call method on the callable object. Any exception raised by the \ncall is delivered to the caller at the point where it invokes the get method, wrapped up in an ExecutionException; \notherwise the actual result is returned. package java.util.concurrent; public interface Future<T> { \nT get() throws InterruptedException, ExecutionException; ... } public interface Callable<T> { T call() \nthrows Exception; } public class FutureTask<T> implements Future<T>, Runnable { public FutureTask(Callable<T> \ncallable) throws NullPointerException {...} public void run() {...} ... } Figure 20. Interface Future \nand related types 6.2 Transparency [22] proposes a powerful static analysis to make futures less ex\u00adplicit. \nMore precisely, the authors strive for transparency, which we can split into the following three aspects: \nTYPE: The (return) type of a future (call) appears to be the log\u00adical return type T of the method actually \nexecuted, and not Future<T > (or Callable<T > on the callee side). IDENTITY: A future object, as placeholder \nfor the value to be computed eventually, and the value then actually computed, appear as the same logical \nentity (cf. Section 3.1). ASYNCHRONY: The lazy nature of a future object is masked. It can be passed \naround like any other object, e.g., as argument to a method call, though the underlying asynchronous \ncall comput\u00ading that very object might not have completed yet. Any call on such a future object is then \nblocked until the computation fol\u00adlowed up. A speci.c library call Async.invoke(o.m(...)) is used to \nindi\u00adcate future calls in programs (here m on o) and guide the subse\u00adquent analysis which tracks potential \noccurrences of future objects, and wraps them in code to achieve the above transparency. Thus, a fourth \nform of transparency for future invocations is not a declared goal: CALL: An invocation which is supposed \nto be performed asyn\u00adchronously appears the same way as a synchronous invocation. 6.3 Safety The authors \nof [31] observe that transparency of asynchrony, with\u00adout supportive mechanisms, may hamper consistency. \nThe concur\u00adrent execution of a future invocation and its continuation the code between the future invocation \nand the actual access to the re\u00adturn value can namely lead to a different observable behavior than the \nsequential execution of instructions the way they appear in the code. A .agrant example is given by an \nexception raised during a future call only after several actions have already been performed as part \nof the continuation. The approach of [31] leverages on (optimistic) transactional mechanisms developed \nin [30]. A future call and its continuation are handled like two concurrent transactions, whose potentially \ncon.icting actions (i.e., actions on shared data) must respect seri\u00adalizability [12]. If violations are \nobserved, both the future call and its continuation are rolled back. [31] describes a class SafeFutures \noffering the same interface as FutureTask, but ensuring that the se\u00admantics of a forked future invocation \nexecuted in parallel with its continuation are the same as their sequential execution. 6.4 Safe Futures \nwith Proxies Basedonthisclass SafeFutures 2 and uniform proxies, we devise in the following an implementation \nof futures which combines the type transparency of [22] with the asynchrony transparency of [31], and \nadds call transparency, without requiring the speci.c program transformations of the former work. Figure \n21 sketches the implementation. Class BackToTheFuture makes it possible to create a proxy for an arbitrary \nobject, through which any method of that object can be (indirectly) invoked in an asynchronous manner \ntransparently and safely. Assume for instance an instance of class C introduced in Section 4.9: Cc= new \nC(); C cFut = BackToTheFuture.futurify<C>(c); String s = cFut.foo(); /* future call */ ... /* asynchronous \ncontinuation */ System.out.println(s); /* synchronization point */ Calling futurify leads to creating \na dynamic proxy with an in\u00adstance of AsyncHandler for handling both method invocations and .eld accesses. \nWhile an action of latter kind is directly relayed to the proxi.ed object, a method call triggers the \ninstantiation of class SafeFuture with a SafeCall (a subtype of Callable), which will actually perform \nthe call. A proxy representing the future ob\u00adject is returned, which is handled by an instance of FutureHandler. \nAny call on that proxy will then lead to blocking the caller on the SafeFuture until the underlying future \ncall has completed. The transparency achieved with this solution is discussed in more depth in Section \n7.4.  7. Discussion This section discusses various issues, such as security implications and limitations \nof the original and uniform proxies in the face of the criteria introduced in Section 3.4. 7.1 Security \nNo programming language has so far undergone as intensive inves\u00adtigations in terms of security as Java.3 \nCore notions in Java security are protection domains, permis\u00adsions,and policies [11]. Protection domains \ncorrespond to certi.\u00adcates for signing classes, and/or URLs for obtaining classes, and 2 Rollback capabilities \ncan be achieved in other less intrusive ways, cf. [18]. 3 An in-depth presentation of security issues \nraised by general-purpose re.ective extensions to Java can be found in [5]. public class BackToTheFuture \n{ public static T futurify<T>(T t) { AsyncHandler hand = new AsyncHandler(t); return (T)Proxy.newProxyInstance(..., \nt.getClass(), null, ..., hand); } } class AsyncHandler implements InvocationHandler { private Object \norig; public AsyncHandler(Object orig) { this.orig = orig; } public Object invoke(..., Method m, Object[] \nargs)... { SafeFuture future = new SafeFuture(new SafeCall(m, orig, args)); future.run(); /* start \ntransaction */ FutureHandler hand = new FutureHandler(future); return Proxy.newProxyInstance(..., orig.getClass(), \n null, hand, hand); } } class SafeCall extends Callable { private Method m; private Object on; private \nObject[] args; public SafeCall(Method m, Object on, ...) {...} public Object call() { return m.invoke(on, \nargs); } } class FutureHandler implements InvocationHandler, AccessHandler { private SafeFuture fut; \npublic FutureHandler(SafeFuture fut) { this.fut = fut; } public Object invoke(..., Method m, Object[] \nargs) ... { return m.invoke(fut.get(), args); /* end trn */ } } Figure 21. Safe and transparent futures \nhave an associated set of permissions. (If a class maliciously ex\u00adploits the permissions associated with \nits protection domain, the principals associated with that domain can be held responsible.) Java system \nclasses are part of a system protection domain which by default includes all permissions. A security \npolicy in Java gov\u00aderns the permissions granted to the different protection domains. Two key concepts \nunderlying security in Java are (1) the princi\u00adple of least privilege and (2) the concept of permission \nintersection. The former principle states that a piece of code should operate with the smallest possible \nset of privileges. The latter concept requires that, when performing a piece of code, the entire set \nof protection domains represented by classes on the execution stack at that point include the permissions \nnecessary for executing that code. In the context of dynamic proxies, handlers are the central players \nwith respect to security. The (augmented) Proxy class, as well as created proxy classes are namely, just \nlike any system classes, given all permissions. When an object accesses another object via a proxy, the \nonly relevant classes added to the execu\u00adtion stack are thus handler classes. Besides a class implementing \nInvocationHandler, this potentially includes a class implementing AccessHandler in the case of proxies \nfor classes. On the one hand, care must be thus taken when inserting a proxy between a caller and a callee, \nto not make the interaction impossible by associating an instance of a handler class with an insuf.cient \nset of permissions with that proxy. On the other hand, one can exploit this to dynami\u00adcally introduce \nsecurity barriers. Rather than providing an untrusted party with direct access to (instances of) a class, \nthat party can be urged to access (instances of) that class through dynamic proxies. The corresponding \nhandlers can then at run-time decide on granting permissions or not. 7.2 Introspection and Uniformity \nEnsuring that introspection objects (instances of, e.g., Class, Method) representing the structures of \nlinked classes do not re.ect changes made at load-time can improve safety. A deeper integra\u00adtion of our \nuniform virtual object model in the Java virtual machine could go hand-in-hand with instrumented introspection \nclasses. Such instrumentations would also apply to related approaches where corresponding issues are \nhowever rarely addressed. 7.3 Primitive Types Dynamic proxies can not be created for primitive types. \nOne might argue that this is not a limitation of dynamic proxies, but rather a consequence of Java s \nhybrid type system. In addition, since primitive types do not have any members, there might be no need \nto intercept/override any calls to values of primitive types at all. The case of future invocations however \nnicely illustrates that the lack of proxies for primitive types does sensibly reduce completeness: methods \nto be invoked in an asynchronous manner can not have primitive return types. A common workaround for \nthis problem consists in introducing own wrapper classes for primitive types, which de.ne methods corresponding \nto the operators that apply to them. Introducing own wrapper classes can also help preventing the modi.cation \nof Java system classes such as standard wrapper classes, which might, should they be passed on and exploited, \ninfringe license terms. Note that the automatic boxing/unboxing of values of primitive types now in Java \n1.5 only slightly alleviates the restricted com\u00adpleteness. Values of primitive types may for instance \nbe boxed au\u00adtomatically by objects, but since this occurs transparently to the programmer there is no \nway of proxifying these objects in many situations. 7.4 Transparency in Future Invocations We believe \nthat the explicit futurization of an object with our futures presented in the previous section, alike \nin [22], is not a drawback. It reminds the programmer of the restrictions that still apply, such as with \nasynchronous exceptions. In fact, the solu\u00adtion of [31] still has some limitations with that respect. \nTake the case of a try...catch block around a future call, intended at han\u00addling exceptions potentially \ncaused by that call. The end of such a clause should bound the call s continuation otherwise an ex\u00adception \nmight be thrown too late . In the worst case, the future object is a return value for the enclosing method. \nThis case is not considered at all by many future implementations which strive for asynchrony transparency. \nAn explicit proxi.cation, in contrast, can also offer the possibility of registering an asynchronous \nexception handler for such a scenario. The identity transparency which [22] strives for can be ap\u00adproached \nby adding a transformation, outlined below, which trans\u00adforms the equal method for object comparisons \nsuch as to forward any such call to the object compared to, in case that object is a proxy. T [[pub boolean \nequals(Ta) {e}]] = pub boolean equals(Ta) { if (ainstanceof ProxyType) ret a.equals(this); T [[e]] } \nThat way, a proxy handler such as AsyncHandler in Figure 21 which stores a reference to its associated \nproxi.ed object can simply compare the argument with that object. This transformation works even in the \npresence of calls to superclasses within an equals method. Alas, a remaining drawback is the fact that \nthe equals method is not necessarily symmetric anymore, as recom\u00admended [27]. Also, the == operator will \nstill reveal whether two variables point to the exact same object or not (while comparisons based on \nthe hashCode method in Object can be in.uenced by hav\u00ading proxies/invocotion handlers de.ne the result). \nMore intrusive transformations could be introduced to deal with those cases, e.g., by wrapping such operator \noccurrences (cf. Section 8.1).  8. Related Work The work closest to ours can be found in the area of \nbehavioral re.ection. We discuss in the following these efforts4,and also a closely related effort on \nthe topic of future invocations for Java. 8.1 Kava Kava [33] is a general extension to Java re.ection \nproviding behav\u00adioral re.ection, relying on a speci.c user class loader to modify classes at load-time. \nKava however follows an envelopment ap\u00adproach (unlike its proxy-based predecessor Dalang [32]), in the \nsense that hooks are added around method invocations and .eld accesses, to pass control to the meta-level. \nIn the context of dynamic proxies for classes, such an approach could be adapted to tranform the lines \n(source code for readability) C c = ...; String f = c.bar; into something looking like the following \n(by omitting exceptions etc.): C c = ...; String f; if (c instanceof ProxyType) try { Field F = C.class.getField(\"bar\")); \n f = (String) Proxy.getAccessHandler(c).get(c, F); } catch(Exception ex) {} else f = c.bar; Such an \napproach enables the uniform interception of any method invocations and .eld accesses, including class \nmethods and .elds. This however comes at the expense of a sensible overhead through the use of introspection \nfor every .eld access and method invocation through a proxy. In contrast, with our approach, such expensive \ncalls to the core re.ection API are made at most once for a same method or .eld for all uses of that \nmember (see Section 5.3). The use of an instrumented user class loader can be bypassed (see Section 5.1), \nthus putting the uniform application of re.ection at stake [32]. Just like in our case, transformations \naffect classes re.ected upon (e.g., for invocations to own instances) as well as classes using former \nclasses (e.g., invoking instances of classes re.ected upon). 8.2 Javassist Javassist [6] is another \nextension to Java re.ection, promoting load\u00adtime structural re.ection. Javassist offers a core API operating \nat byte code level, and a more high-level API providing useful macros built on former one (e.g., addition \nor modi.cation of methods), including a speci.c classloader for the instrumentation of classes. Javassist \nis extremely general and powerful, and has many po\u00adtential applications. Behavioral re.ection is in fact \nonly one of these instantiations, obtained by wrapping methods. I.e., shifts to the meta-level are achieved \nby inserting hooks into the bodies of methods to be re.ected upon rather than around the invocations \nto them (as in Kava). This scheme, in contrast to Kava, establishes a clear equivalence between the classes \nre.ected upon and the classes 4 See [33] and [5] for more broader and detailed surveys of existing re.ec\u00adtive \nextensions to Java. that have to be modi.ed, i.e., loaded with Javassist s speci.c class loader. Since \nthis scheme can not be extended to .eld accesses, Javassist proceeds similarly to our approach in that \ncase by replac\u00ading .eld accesses by invocations, however to class methods. The general applicability \nof Javassist has been illustrated by realizing binary code adaptation [15], aspect-oriented program\u00adming \n[14], or a form of synchronous RMI without static proxy generation. Based on the latter experience, Addistant, \nanother in\u00adstantiation of Javassist, is described in [28]. Addistant aims at the distribution of legacy \nJava programs, that is, Java programs de\u00adveloped without distribution in mind. Four different ways of \nmodifying a class to re.ect the possibly remote location of certain of its instances are discussed. In \nthe case of a class whose instances are all remote, the class can for instance be replaced by a proxy \nclass. An extension approach (termed subclass approach in [28]) is also discussed. The problems with \n.nal classes and methods, as well as constructors, are pointed out, unlike the cases of private methods \nand .eld accesses. Javassist has been used to implement a .rst prototype of the transformations presented \nin this paper. 8.3 ProActive ProActive, a descendant of Java// ( Java parallel ), is similar to Ad\u00addistant, \nin that it aims at providing features for transparent dis\u00adtributed or parallel execution of Java programs \n[4]. ProActive ad\u00advocates the use of implicit futures, to decouple remotely interacting components, through \nproxies obtained at run-time by manually in\u00adstantiating proxy classes part of the ProActive libraries. \nProActive could thus de.nitely directly bene.t from uniform proxies.  9. Conclusions This paper has \npresented an approach to broadening the scope of Java s own concept of dynamic proxies. The solution \npresented in this paper neither makes use of a spe\u00adci.c compiler nor relies on dispatch instrumentation \nin the virtual machine, but can do with a set of transformations performed at class loading.5 For instance, \nto be able to intercept .eld accesses we have presented a scheme for transforming such accesses to invocations \nof automatically generated getter/setter methods a general trans\u00adformation scheme whose applicability \nis not limited to the genera\u00adtion of dynamic proxies and the Java language. We have discussed tradeoffs \nof proxi.cation, such as between completeness, safety, and security, and have proposed a simple way of \ndealing with the inherent two-body limitation of proxies. Given the generic applicability of the proxy \nabstraction, the set of poten\u00adtial applications which can bene.t from our extension is unlimited. We \nhave illustrated our uniform proxies by implementing future invocations both transparently and safely, \nfurther dividing trans\u00adparency into different aspects and pointing out which of these as\u00adpects are actually \ndesirable in what contexts. The main remaining drawback seems to be a consequence of Java s hybrid type \nsystem. In fact, it s not surprising that the ab\u00adsence of a uniform object model makes it hard to achieve \na uniform proxy model. Hence, it would be interesting to see how one could combine our approach with \na uniform object model such as the one promoted by Kava [3].6 We believe that our work could also be \nextended to Microsoft s .NET platform [29], which proposes a closely related concept of dynamic proxies \nwith nearly the same limitations as in Java. For 5 This makes a case against the claim that the achievement \nof .eld access interception with a proxy approach is impossible without speci.cally mod\u00adi.ed virtual \nmachine [5]. 6 Not to be confused with the Kava approach to behavioral re.ection in Java [33], cf. Section \n8.1. instance, .eld accesses can not be intercepted either, which is however counterbalanced by the fact \nthat types in .NET languages such as C# can declare properties, a form of .elds with inherent support \nfor getter/setter methods.  Acknowledgments We thank Christian Damm, S\u00b4ebastien Baehni, and the anonymous \nreferees for helpful comments on draft versions of this paper, as well as all those who contributed to \nthe implementation of this work. References [1] O. Agesen, S.N. Freund, and J.C. Mitchell. Adding Type \nParame\u00adterization to the Java Language. In Proceedings of the 12th ACM Conference on Object-Oriented \nProgramming Systems, Languages and Applications (OOPSLA 97), pages 49 65, October 1997. [2] B. Alpern, \nA. Cocchi, S. Fink, and D. Grove. Ef.cient Implemen\u00adtation of Java Interfaces: Invokeinterface Considered \nHarmless. In Proceedings of the 16th ACM Conference on Object-Oriented Pro\u00adgramming Systems, Languages \nand Applications (OOPSLA 2001), pages 108 124, October 2001. [3] D. Bacon. Kava: A Java Dialect with \na Uniform Object Model for Lightweight Classes. In Proceedings of the Joint ACM Java Grande -ISCOPE 2002 \nConference, pages 68 77, June 2001. [4] D. Caromel, W. Klauser, and J. Vayssi`ere. Towards Seamless Computing \nand Metacomputing in Java. Concurrency: Practice and Experience, 10(11 13):1043 1061, September 1998. \n[5] D. Caromel and J. Vayssi`ere. Re.ections on MOPs, Components, and Java Security. In Proceedings of \nthe 15th European Conference on Object-Oriented Programming (ECOOP 2001), pages 256 274, June 2001. [6] \nS. Chiba. Loadtime Structural Re.ection in Java. In Proceedings of the 14th European Conference on Object-Oriented \nProgramming (ECOOP 2000), pages 313 336, June 2000. [7] A. Eliasson. Implement Design by Contract for \nJava using Dynamic Proxies. http://www.javaworld.com/javaworld/jw-02-2002/jw-0215\u00addbcproxy.html, February \n2002. [8] P.Th. Eugster and S. Baehni. Object-Oriented Programming in Peer-to-Peer Systems. Concurrency \nand Computation: Practice and Experience, 17(7-8):1053 1078, June 2005. [9] E. Gamma, R. Helm, R. Johnson, \nand J. Vlissides. Design Patterns, Elements of Reusable Object-Oriented Software. Addison-Wesley, 1995. \n[10] M. Golm and J. Klein\u00a8oder. Jumping to the Meta Level: Behavioral Re.ection Can Be Fast and Flexible. \nIn Proceedings of the 2nd ACM International Conference on Metalevel Architectures and Re.ection (Re.ection \n99), 1999. [11] L. Gong. Inside Java 2 Platform Security: Architecture, API, Design and Implementation. \nAddison-Wesley, 1999. [12] M. Herlihy and J. Wing. Linearizability: a correctness condition for concurrent \nobjects. ACM Transactions on Programming Languages and Systems, 12(3):463 492, July 1990. [13] JBoss. \nJBoss 3.0. http://www.jboss.org, 2003. [14] Kalixia. jAdvise. http://www.kalixia.com/weblogs/space/jAdvise, \n2003. [15] R. Keller and U. H\u00a8olzle. Binary Component Adaptation. In Proceedings of the 12th European \nConference on Object-Oriented Programming (ECOOP 98), pages 307 329, July 1998. [16] G. Kiczales, J. \ndes Rivi`eres, and D.G. Bobrow. The Art of the Metaobject Protocol. MIT Press, 1991. [17] G. Kiczales, \nJ. Lamping, A. Menhdhekar, Ch. Maeda, C. Lopes, J.-M. Loingtier, and J. Irwin. Aspect-Oriented Programming. \nIn Proceedings of the 11th European Conference on Object-Oriented Programming (ECOOP 97), pages 220 242, \nJune 1997. [18] J. Kienzle and R. Guerraoui. AOP: Does It Make Sense? The Case of Concurrency and Failures. \nIn Proceedings of the 16th European Conference on Object-Oriented Programming (ECOOP 2002), pages 37 \n61, June 2002. [19] H. Liebermann. Using Prototypical Objects to Implement Shared Behavior in Object-Oriented \nSystems. In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages and Applications \n(OOPSLA 86), pages 214 223, September 1986. [20] T. Lindholm and F. Yellin. The Java Virtual Machine \nSpeci.cation. Addison-Wesley, 2nd edition, 1999. [21] B. Meyer. Applying Design by Contract. IEEE Computer, \n25(10):40 51, October 1992. [22] P. Pratikakis, J. Spacco, and M. Hicks. Transparent Proxies for Java \nFutures. In Proceedings of the 19th ACM Conference on Object-Oriented Programming Systems, Languages \nand Applications (OOPSLA 2004), pages 206 223, October 2004. [23] F. Rivard. Smalltalk: A Re.ective Language. \nIn Proceedings of the 1st International Conference on Metalevel Architectures and Re.ection (Re.ection \n96), pages 21 38, April 1996. [24] M. Shapiro. Structure and Encapsulation in Distributed Systems: The \nProxy Principle. In Proceedings of the 6th IEEE International Conference on Distributed Computing Systems \n(ICDCS 86), pages 198 204, May 1986. [25] Sun. Dynamic Proxy Classes, 1999. [26] Sun. Java Core Re.ection \nAPI and Speci.cation, 1999. [27] Sun. The Java Platform 1.5 API Speci.cation, 2004. [28] M. Tatsubori, \nT. Sasaki, S. Chiba, and K. Itano. A Bytecode Translator for Distributed Execution of Legacy Java Software. \nIn Proceedings of the 15th European Conference on Object-Oriented Programming (ECOOP 2001), pages 236 \n244, June 2001. [29] T. Thai and H. Lam. .NET Framework Essentials. O Reilly and Associates, Inc., June \n2001. [30] A. Welc, S. Jagannathan, and A.L. Hosking. Transactional Monitors for Concurrent Objects. \nIn Proceedings of the 18th European Conference on Object-Oriented Programming (ECOOP 2004), pages 519 \n542, June 2004. [31] A. Welc, S. Jagannathan, and A.L. Hosking. Safe Futures for Java. In Proceedings \nof the 20th ACM Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA \n2005), pages 439 453, October 2005. [32] I. Welch and R. Stroud. From Dalang to Kava: the Evolution of \na Re.ective Java Extension. In Proceedings of the 2nd ACM International Conference on Metalevel Architectures \nand Re.ection (Re.ection 99), pages 2 21, 1999. [33] I. Welch and R.J. Stroud. Kava-Using Byte Code Rewriting \nto Add Behavioural Re.ection to Java. In Proceedings of the 6th Usenix Conference on Object-Oriented \nTechnologies and Systems (COOTS 01), pages 119 130, January 2001. [34] A. Yonezawa, E. Shibayama, T. \nTakada, and Y. Honda. Object-Oriented Concurrent Programming, chapter 4: Modeling and Programming in \nan Object-Oriented Concurrent Language ABCL/1, pages 55 89. MIT Press, 1987.  \n\t\t\t", "proc_id": "1167473", "abstract": "The proxy abstraction has a longlasting tradition in object settings. From design pattern to inherent language support, from remote method invocations to simple forms of behavioral reflection - incarnations as well as applications of proxies are innumerable.Since version 1.3, Java supports the concept of <i>dynamic</i> proxy. Such an object conforms to a set of types specified by the program and can be used wherever an expression of any of these types is expected, yet reifies invocations performed on it. Dynamic proxies have been applied to implement paradigms as diverse as behavioral reflection, structural conformance, or multi-methods. Alas, these proxies are only available \"for interfaces\". The case of creating dynamic proxies for a set of types including a class type has not been considered, meaning that it is currently not possible to create a dynamic proxy mimicking an instance of a given class. This weakness strongly limits any application of dynamic proxies.In this paper we unfold the current support for dynamic proxies in Java, assessing it in the light of a set of generic criteria for proxy implementations. We present an approach to supporting dynamic proxies \"for classes\" in Java, consisting in transformations performed on classes at load-time, including a generic scheme for enforcing encapsulation upon field accesses. These transformations seemlessly extend the scope of the current support for dynamic proxies. We discuss the precise benefits and costs of our extension in terms of the criteria introduced, and illustrate the usefulness of uniformly available proxies by implementing future method invocations both safely and transparently.", "authors": [{"name": "Patrick Eugster", "author_profile_id": "81100562902", "affiliation": "Purdue University", "person_id": "PP18004803", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167485", "year": "2006", "article_id": "1167485", "conference": "OOPSLA", "title": "Uniform proxies for Java", "url": "http://dl.acm.org/citation.cfm?id=1167485"}