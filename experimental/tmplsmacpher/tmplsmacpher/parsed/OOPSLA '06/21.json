{"article_publication_date": "10-16-2006", "fulltext": "\n An Operational Semantics and Type Safety Proof for Multiple Inheritance in C++ Daniel Wasserrab Tobias \nNipkow Universitat Passau \u00a8Technische Universitat\u00a8wasserra@fmi.uni-unchen M\u00a8 passau.de nipkow@in.tum.de \n Abstract We present an operational semantics and type safety proof for multiple inheritance in C++. \nThe semantics models the behaviour of method calls, .eld accesses, and two forms of casts in C++ class \nhierarchies exactly, and the type safety proof was formalized and machine-checked in Isabelle/HOL. Our \nsemantics enables one, for the .rst time, to understand the behaviour of operations on C++ class hierarchies \nwithout referring to implementation-level artifacts such as virtual function tables. Moreover, it can \nas the semantics is executable act as a reference for compilers, and it can form the basis for more advanced \ncorrectness proofs of, e.g., automated program transformations. The paper presents the semantics and \ntype safety proof, and a discussion of the many subtleties that we encountered in modeling the intricate \nmultiple inheritance model of C++. Categories and Subject Descriptors D.3.1 [Formal De.nitions and Theory]: \nSemantics; D.3.3 [Language Constructs and Fea\u00adtures]: Inheritance; F.3.2 [Semantics of Programming Languages]: \nOperational semantics; F.3.3 [Studies of Program Constructs]: Type structure General Terms Languages, \nTheory Keywords Multiple Inheritance, C++, Semantics, Type Safety 1. Introduction We present a operational \nsemantics and type safety proof for the multiple inheritance model of C++ in all its complexity, including \nboth repeated and shared (virtual) inheritance. This semantics en\u00adables one for the .rst time to fully \nunderstand and express the behaviour of operations such as method calls, .eld accesses, and casts in \nC++ programs without referring to compiler data structures such as virtual function tables (v-tables) \n[28]. Type safety is a language property which can be summarized by the famous slogan Well-typed programs \ncannot go wrong [14]. Cardelli s de.nition of type safety [7] demands that no untrapped errors may occur \n(although controlled exceptions are allowed). The type safety property that we prove is the fact that \nthe execution of a well-typed, terminating program will deliver a result of the ex- Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. Gregor Snelting Frank Tip \nUniversit\u00a8IBM T.J. Watson Research at Passau snelting@fmi.uni-Center passau.de ftip@us.ibm.com pected \ntype, or end with an exception. The semantics and proof are formalized and machine-checked using the \nIsabelle/HOL theorem prover [15] and are available online1. One of the main sources of complexity in \nC++ is a complex form of multiple inheritance, in which a combination of shared ( virtual ) and repeated \n( nonvirtual ) inheritance is permitted. Be\u00adcause of this complexity, the behaviour of operations on \nC++ class hierarchies has traditionally been de.ned informally [29], and in terms of implementation-level \nconstructs such as v-tables. We are only aware of a few formal treatments and of no operational semantics \nfor C++-like languages with shared and repeated mul\u00adtiple inheritance. The subobject model by Rossie \nand Friedman [21], upon which our work is based, formalizes the object model of C++. Rossie and Friedman \nde.ned the behaviour of method calls and member access using this model, but their de.nitions do not \nfollow C++ behaviour precisely, they do not consider the behaviour of casts, and they do not provide \nan operational semantics. In 1996, Rossie, Friedman, and Wand [22] stated that In fact, a provably\u00adsafe \nstatic type system [. . . ] is an open problem , and to our knowl\u00adedge this problem has remained open \nuntil today. The CoreC++ language studied in this paper features all the essential elements of the C++ \nmultiple inheritance model (while omitting many features not relevant to operations involving class hierarchies). \nThe semantics of CoreC++ were designed to mirror those of C++ to the maximum extent possible. In previous \nversions of the semantics [37], we explored a number of variations, and we will brie.y discuss these \nin \u00a78. Our interest in formalizing the semantics of multiple inheritance was motivated by previous work \nby two of the present authors on: (i) restructuring class hierarchies in order to reduce object size \nat run-time [34], (ii) composition of class hierarchies in the context of an approach for aspect-orientation \n[25], and (iii) refactoring class hierarchies in order to improve their design [26, 24]. In each of these \nprojects, class hierarchies are generated, multiple inheritance may arise naturally, and additional program \ntransformations are then used to replace multiple inheritance by a combination of single inheritance \nand delegation. In summary, this paper makes the following contributions: We present a formal semantics \nand machine-checked type safety proof for multiple inheritance in C++. This enables one, for the .rst \ntime, to understand and express the behaviour of operations involving C++ class hierarchies without referring \nto compiler data structures.  We discuss some subtle ambiguities concerning the behaviour of member \naccess and method calls in C++ that were uncovered in the course of designing the semantics.  OOPSLA \n06 October 22 26, 2006, Portland, Oregon, USA. Copyright . 2006 ACM 1-59593-348-4/06/0010. . . $5.00. \n1 http://afp.sourceforge.net c By formalizing the complex behaviour of C++ multiple inheri\u00adtance, we \nextend the applicability of formal semantics and the\u00adorem prover technology to a new level of complexity. \nThus the message to language semanticists is that the much maligned C++ system of multiple inheritance \ncontains a perfectly sound core.  2. Multiple inheritance 2.1 An intuitive introduction to subobjects \nC++ features both nonvirtual (or repeated) and virtual (or shared) multiple inheritance. The difference \nbetween the two .avors of inheritance is subtle, and only arises in situations where a class Y indirectly \ninherits from the same class X via more than one path in the hierarchy. In such cases, Y will contain \none or multiple X- subobjects , depending on the kind of inheritance that is used. More precisely, if \nonly shared inheritance is used, Y will contain a single, shared X-subobject, and if only repeated inheritance \nis used, the number of X-subobjects in Y is equal to N, where N is the number of distinct paths from \nX to Y in the hierarchy. If a combination of shared and repeated inheritance is used, the number of X-subobjects \nin a Y -object will be between 1and N (a more precise discussion follows). C++ hierarchies with only \nsingle inheritance (the distinction between repeated and shared inheritance is irrelevant in this case) \nare semantically equivalent to Java class hierarchies. Fig. 1(a) shows a small C++ class hierarchy. In \nthese and subse\u00adquent .gures, a solid arrow from class C to class D denotes the fact that C repeated-inherits \nfrom D, and a dashed arrow from class C to class D denotes the fact that C shared-inherits from D. Here, \nand in subsequent examples, all methods are assumed to be vir\u00adtual (i.e. dynamically dispatched), and \nall classes and inheritance relations are assumed to be public. In Fig. 1(a), all inheritance is repeated. \nSince class Bottom repeated-inherits from classes Left and Right,a Bottom\u00adobject has one subobject of \neach of the types Left and Right.As Left and Right each repeated-inherit from Top, (sub)objects of these \ntypes contain distinct subobjects of type Top. Hence, for the C++ hierarchy of Fig. 1(a), an object of \ntype Bottom contains two distinct subobjects of type Top. Fig. 1(b) shows the layout used for a Bottom \nobject by a typical compiler, given the hierarchy of Fig. 1(a). Each subobject has local copies of the \nsubobjects that it contains, hence it is possible to lay out the object in a contiguous block of memory \nwithout indirections. Fig. 2(a) shows a similar C++ class hierarchy in which the in\u00adheritance between \nLeft and Top and between Right and Top is shared. Again, a Bottom-object contains one subobject of each \nof the types Left and Right, due to the use of repeated inheritance. However, since Left and Right both \nshared-inherit from Top, the Top-subobject contained in the Left-subobject is shared with the one contained \nin the Right-subobject. Hence, for this hierar\u00adchy, a Bottom-object will contain a single subobject of \ntype Top. In general, a shared subobject may be shared by arbitrarily many subobjects, and requires an \nobject layout with indirections (typi\u00adcally in the form of virtual-base pointers)[28, p.266] 2. Fig. \n2(b) shows a typical object layout for an object of type Bottom given the hierarchy of Fig. 2(a). Observe, \nthat the Left-subobject and the Right-subobject each contain a pointer to the single shared Top-subobject. \n2 An alternative implementation mechanism is to store the offsets to shared subobjects in v-tables. \n 2.2 The Rossie-Friedman Subobject Model Rossie and Friedman [21] proposed a subobject model for C++\u00adstyle \ninheritance, and used that model to formalize the behaviour of method calls and .eld accesses. Informally, \none can think of the Rossie-Friedman model as an abstract representation of object lay\u00adout. Intuitively, \na subobject3 identi.es a component of type D that is embedded within a complete object of type C. However, \nsimply de.ning a subobject type as a pair (C, D)would be insuf.cient, because, as we have seen in Fig. \n1,a C-object may contain multi\u00adple D-components in the presence of repeated multiple inheritance. Therefore, \na subobject is identi.ed by a pair [C, Cs], where C de\u00adnotes the type of the complete object , and where \nthe path Cs consists of a sequence of class names C1 \u00b7 \u00b7\u00b7\u00b7 \u00b7Cn that encodes the transitive inheritance \nrelation between C1 and Cn. There are two cases here: For repeated subobjects we have that C1 =C, and \nfor shared subobjects, we have that C1 is the least derived (most general) shared base class of C that \ncontains Cn. This scheme is suf.cient because shared subobjects are unique within an object (i.e. there \ncan be at most one shared subobject of type S within any object). More formally, for a given class C, \nthe set of its sub\u00adobjects, along with a containment ordering on these subobjects, is inductively de.ned \nas follows: 1. [C, C]is the subobject that represents the full C-object. 2. if S1 =[C, Cs.X]is a subobject \nfor class C where Cs is any sequence of class names, and X shared-inherits from Y ,then S2 =[C, Y ]is \na subobject for class C that is accessible from S1 through a pointer. 3. if S1 =[C, Cs.X]is a subobject \nfor class C where Cs is any sequence of class names, and X repeated-inherits from Y , then S2 =[C, Cs.X.Y \n]is a subobject for class C that is directly contained within subobject S1.  Fig. 1(c) and Fig. 2(c) \nshow subobject graphs for the class hi\u00aderarchies of Fig. 1 and Fig. 2, respectively. Here, an arrow from \nsubobject S to subobject S. indicates that S. is directly contained in S or that S has a pointer leading \nto S. For a given subobject S =[C, Cs.D], we call C the dynamic class of subobject S and D the static \nclass of subobject S. Associated with each subobject are the members that occur in its static class. \nHence, if an object con\u00adtains multiple subobjects with the same static class, it will contain multiple \ncopies of members declared in that class. For example, the subobject graph of Fig. 1(c) shows two subobjects \nwith static class Top, each of which has distinct .elds x and y. Intuitively, a subobject s dynamic class \nrepresents the type of the full object and is used to resolve dynamically dispatched method calls. A \nsubobject s static class represents the declared type of a variable that points to an (subobject of the \nfull) object and is used to resolve .eld accesses. In this paper, we use the Rossie-Friedman subobject \nmodel to de.ne the behaviour of operations such as method calls and casts as functions from subobjects \nto subobjects. As we shall see shortly, it will be necessary in our semantics to maintain full subobject \ninformation even for static operations such as casts and .eld accesses. Multiple inheritance can easily \nlead to situations where mul\u00adtiple members with the same name are visible. In C++, many member accesses \nthat are seemingly ambiguous are resolved us\u00ading the notion of dominance [29]. A member m in subobject \nS. dominates a member m in subobject S if S is contained in 3 In this paper, we follow the terminology \nof [21] and use the term sub\u00adobject to refer both to the label that uniquely identi.es a component of \nan object type, as well as to components within concrete objects that are iden\u00adti.ed by such labels. \nIn retrospect, the term subobject label would have been better terminology for the former concept. class \nTop { int x, y; ... }; class Left : Top { ... }; class Right : Top { int y; ... }; class Bottom : Left, \nRight { int x; ... };  y  x AB : B is repeated baseclass of A (a) xy  Bottom [Bottom,Bottom.Right.Top] \n [Bottom,Bottom.Right]  xy [Bottom,Bottom.Right.Top] [Bottom,Bottom.Right]  y [Bottom,Bottom.Left.Top] \n[Bottom,Bottom.Left] [Bottom,Bottom]  (b) (c) Figure 1. The repeated diamond class Top { void f() { \n... }; ... }; class Left : virtual Top { ... }; class Right : virtual Top { void f() { ... }; ... }; \nclass Bottom : Left, Right { ... }; Top f() [Bottom,Top]  f() [Bottom,Bottom.Right] f() [Bottom,Bottom.Left] \n [Bottom,Bottom] A B : B is repeated baseclass of A A B : B is shared baseclass of A  (a) (b) (c) \nFigure 2. The shared diamond S. (i.e. S. occurs below S in the subobject graph). Member ac\u00adcesses are \nresolved by selecting the unique dominant member m if it exists; otherwise an access is ambiguous4. For \nexam\u00adple, in Fig. 2,a Bottom-object sees two declarations of f(), one in class Right and one in class \nTop. Thus a call (new Bottom())->f() seems ambiguous. But it is not, because in the subobject graph for \nBottom shown in Fig. 2(c), the de.nition of f() in [Bottom,Bottom.Right] dominates the one in [Bot-tom,Top]. \nOn the other hand, the subobject graph in Fig. 1(c) con\u00adtains three de.nitions of y in [Bottom,Bottom.Right], \n[Bot-tom,Bottom.Right.Top], and [Bottom,Bottom.Left.Top]. As there is no unique dominant de.nition of \ny here, a .eld access (new Bottom())->y is ambiguous.  2.3 Casts in C++ C++ has three cast operators \nfor traversing class hierarchies, each of which has signi.cant limitations5. Most commonly used are so\u00adcalled \nC-style casts. C-style casts may be used to cast between arbi\u00adtrary unrelated types, although some static \nchecking is performed on up-casts (e.g., a C-style up-cast is statically rejected if the re\u00adceiver s \nstatic type does not contain a unique subobject whose static class is the type being casted to), but \nno runtime checks. C-style casts cannot be used to down-cast along a shared inheritance rela\u00adtion, as \nit is not possible to go back along the indirection pointers In some cases, C++ uses the static class \nof the receiver for further disambiguation. This will be discussed shortly. 5 The remaining two cast \noperators in C++, const cast and reinter\u00adpret cast are irrelevant for the issues studied in this paper. \n in the object. When used incorrectly, C-style casts may cause run\u00adtime errors. The static cast operator \nonly performs compile-time checks (e.g., to ensure that a unique subobject of the tar\u00adget type exists) \nand disallows casting between unrelated types. static cast cannot be used to down-cast along a shared \ninher\u00aditance relation. When used incorrectly, static cast may cause run-time errors. The dynamic cast \noperator is the recommended cast oper\u00adator in C++. It has the desirable property that failing casts result \nin controlled exceptions (when the target of the cast is a reference) or the special value NULL (when \nthe target is a pointer). Unlike the previous two operators, down-casting along shared inheritance relations \nis allowed, and dynamic cast may be used to cast be\u00adtween unrelated types. However, a subtle limitation \nexists: A dy\u00adnamic cast is statically incorrect when applied to an expression whose declared type does \nnot declare virtual methods. In the semantics, we implemented two different casting operators: a static \ntype safe casting operator analogously to static cast and a generalization on dynamic cast that is not \nrestricted to casting types with declared virtual methods. It would be simple to add this restriction \nto our type system but this would weaken our type soundness result, which is completely in\u00addependent \nof this matter. 2.4 Examples We will now discuss several examples to illustrate the subtleties that \narise in the C++ inheritance model. Example 1. Dynamic dispatch behaviour can be counterintuitive in \nthe presence of multiple inheritance. One might expect a method class A { ... }; class B { void f(); \n}; class C { ... }; class D : A,B { void f(); }; class E : B,C { void f(); }; B* b; B f() C if (...) \nb = new D(); else b = new E(); f()  b->f(); (a) Then: this-pointer: after offset adjustment for f() \n delta-values:start Call f() A vptr B vptr A&#38;D vtable B vtable start Call f()  B&#38;E vtable \n C vtable after offset adjustment for f() Figure 3. C++ fragment demonstrating dynamically varying sub\u00adobject \ncontext call always to dispatch to a method de.nition in a superclass or subclass of the type of the \nreceiver expression. Consider, however, the shared diamond example of Fig. 2, where a method f() is de.ned \nin classes Right and Top. Now assume that the following C++ code is executed (note the implicit up-cast \nto Left in the assignment): Left* b = new Bottom(); b->f(); One might expect the method call to dispatch \nto Top::f(). But in fact it dispatches to f() in class Right, which is neither a superclass nor a subclass \nof Left. The reason is that up-casts do not switch off dynamic dispatch, which is based on the receiver \nobject s dynamic class. The dynamic class of b remains Bottom after the cast, and since Right::f() dominates \nTop::f(), the former is called. This makes sense from an application viewpoint: Imagine the top class \nto be a Window , the left class to be a Window with menu , the right class to be a Window with border \n, the bottom class to be a Window with border and menu , and f() to compute the available window space. \nThen, a Window with border and menu object which is casted to Window with menu pretends not to have a \nborder anymore (border methods cannot be called). But for the area computation, the hidden border must \nbe taken into account, thus f() from Window with border must be called. Example 2. The next example illustrates \nthe need to track some subobject information at run-time, and how this complicates the semantics. Consider \nthe program fragment in Fig. 3(a), where b points to a B-subobject. This subobject occurs in two different \ncontexts , namely either as a [D,D.B] subobject (if the then\u00adcase of the if statement is executed), or \nas an [E,E.B] subobject (if the else-case is executed). Note that executing the assignments b = new D() \nand b = new E() involves an implicit up-cast to type B. Depending on the context, the call b->f() will \ndispatch to D::f() or E::f(). Now, executing the body of this f() in\u00advolves an implicit assignment of \nb to its this pointer. Since the static type of b is B, and the static type of this is the class con\u00adtaining \nits method, an implicit down-cast (to D or to E, depending on the context) is needed. At compile time \nit is not known which cast will happen at run-time, which implies that the compiler must keep track of \nsome additional information to determine the cast that must be performed. In a typical C++ implementation, \na cast actually implies chang\u00ading the pointer value in the presence of multiple inheritance, as is illustrated \nin Fig. 3(b). The up-cast from D to B (then-case, upper part of Fig. 3(b)) is implemented by adding the \noffset delta(B) of the [D,D.B]-subobject within the D object to the pointer to the D object. Afterwards, \nthe pointer points to the [D,D.B]-subobject. As we discussed, the subsequent call b->f() requires that \nthe pointer be down-casted to D again. This cast is implemented by adding the negative offset -delta(B) \nof the [D,D.B]-subobject to the pointer. The else-case (lower part of Fig. 3(b)) is analogous, but involves \na different offset, which happens to be 0. In other words, the offsets in the then-and else-cases are \ndifferent, and we do not know until run-time which offset has to be used. To this end, C++ compilers \ntypically extend the virtual function table (v-table) [28] with delta values, that, for each v-table \nentry, record the offset that has to be added to the this-pointer in order to ensure that it points to \nthe correct subobject after the cast (Fig. 3(b), left part).6 Our semantics correctly captures the information \nneeded for performing casts, without referring to compiler data structures such as v-table entries and \noffsets. Example 3. The following example shows how C++ resolves ambiguities by exploiting static types. \nIn the repeated diamond of Fig. 1, let us assume that we have declared a method f() in class Top, and \nexecute the following code: Left* b = new Bottom(); b->f(); Note that the assignment performs an implicit \nup-cast to type Left, and that the method call is statically correct because a single de.nition of f() \nis visible. However, at run-time the dynamic class of the subobject [Bottom,Bottom.Left] associated with \nb is used to resolve the dynamic dispatch. The dynamic class of b is Bottom, and b has two Top subobjects \ncontaining f (and x). As neither de.nition of f() dominates the other, the call to b->f() appears to \nbe am\u00adbiguous. Note that the code for f exists only once, but this code will be called with an ambiguous \nthis-pointer at run-time: is it the one pointing to the [Bottom, Bottom.Left.Top] subobject, or the one \npointing to the [Bottom,Bottom.Right.Top] subobject? Each of these subobject has its own .eld x, and \nthese x s may have different values at run-time when referenced by f(), leading to ambiguous program \nbehaviour. C++ uses the static type of b to resolve the ambiguity and generate a unique v-table entry \nfor f().As b s static type is Left, the delta part of the v-table entry will cause the dynamic object \nof type Bottom (and thus the this\u00adpointer) to be cast to [Bottom,Bottom.Left.Top], and not to [Bottom,Bottom.Right.Top]. \n6 An alternative to delta entries in v-tables are so-called trampolines , which use additional machine \ncode for pointer adjustment. While this may seem to be a natural way to resolve the ambi\u00adguity, it makes \nthe result of dynamic dispatch which, intuitively, is based solely on an object s dynamic type additionally \ndepen\u00addent on the object s static type. During the evolution of our seman\u00adtics, for a long time we considered \nthis a .aw in the design of C++, and our .rst semantics [37] (for a language then called C+) did not \nresolve the ambiguity using the static type, but threw an exception instead. This viewpoint was inspired \nby Rossie and Friedman, who also considered this situation to be ambiguous. Now we stick ex\u00adactly to \nC++, even though this makes the semantics more complex (see discussion in \u00a78). Example 4. C++ allows \nmethod overriding with covariant (i.e. more speci.c) return types. Unrestricted covariance can however \nlead to ambiguities. In the context of the repeated diamond of Fig. 1, consider: class A { Top* f(); \n}; classB:A{ Bottom* f(); }; //not allowed A* a = new B(); Top* t = a->f(); Statically, everything \nseems .ne: because the type of a is A, the type of a->f() is Top. However, if we allowed the rede.nition \nof f(), at run-time a->f() evaluates to a Bottom object. C++ implicitly casts to the return type of the \nstatically selected method (which would be Top); but this cast is ambiguous, as a Bottom object has two \ndifferent Top subobjects in the repeated diamond. Hence this rede.nition is statically incorrect. C++ \nrequires unique covariance: if the return type of the statically selected method is C and the return \ntype of the dynamically selected one is D, then there must exist a unique path from Dback to C. Example \n5. C++ does not allow method overriding with con\u00adtravariant (i.e. less speci.c) parameter types, and \none reason for this is again the possibility of ambiguities. In the context of the repeated diamond of \nFig. 1, consider: class A { void f(Left* l); }; classB:A{ void f(Top* t); }; //no redefinition //in \nC++! A* a = new B(); a->f(new Bottom()); Here, the actual parameter must be cast from Bottom to Top, \nbut again this cast is ambiguous. Example 6. This example is taken from [20]. It shows that many compilers \ntreat dominance incorrectly and thus have problems with .eld access/assignment (as well as method call): \nclass A{ int x; }; class B{ int x; }; class C : virtual A, virtual B { int x; }; class D : virtual A, \nvirtual B, C {}; (new D())->x = 42; The g++ compiler rejects the left hand side of (new D())->x = 42 \nas ambiguous, whereas the Intel compiler accepts this program. We will come back to this example in \u00a75.1.3. \nClearly, the semantics of method calls, .eld accesses, and casts are quite complicated in the presence \nof shared and repeated mul\u00adtiple inheritance. Typical C++ compilers rely on implementation\u00adlevel artifacts \nsuch as v-tables and subobject offsets to de.ne the behaviour of these constructs. We will now present \na formaliza\u00adtion that relies solely on subobjects and paths, which enables us to demonstrate type-safety. \n  3. Formalization Our semantics builds on the multiple inheritance calculus devel\u00adoped by Rossie and \nFriedman [21], but goes well beyond that work by providing an executable semantics and a type-safety \nproof. Rossie and Friedman merely provide the subobject model but no programming language, they do not \nmodel casts and their notion of method dispatch does not model C++ precisely (see Example 3 above). The \nstarting point for our formal semantics was Jinja [11], a model of a Java-like language de.ned in higher-order \nlogic (HOL) in the theorem prover Isabelle/HOL. However, because of the many intricacies of C++, CoreC++ \nhas really outgrown its parent. As an indicator for this see the fact that the size of the formal speci.cation \nand associated proofs more than doubled. Our meta-language HOL conforms largely to everyday mathe\u00admatical \nnotation. This section introduces further non-standard no\u00adtation and in particular a few basic data types \nwith their primitive operations. 3.1 Basic notation The meta language Types include the basic types \nof truth values, natural numbers and integers, which are called bool , nat , and int respectively. The \nspace of total functions is denoted by .. Type variables are written a, b, etc. The notation t::t means \nthat HOL term thas HOL type t. Pairs come with the two projection functions fst :: a \u00d7 b . a and snd \n:: a \u00d7 b . b. We identify tuples with pairs nested to the right: (a, b, c) is identical to (a, (b, c)) \nand a \u00d7 b \u00d7 c is identical to a \u00d7(b \u00d7 c). Sets (type a set) follow the usual mathematical convention. \nLists (type alist) come with the empty list [], the in.x construc\u00adtor \u00b7, the in.x @ that appends two \nlists, and the conversion function set from lists to sets. Variable names ending in s usually stand for \nlists and length xs is the length of xs. The standard function map, which applies a function to every \nelement in a list, is also available. Function update is de.ned as follows: f(a := b) =.x.if x = a then \nbelse fx where f :: a . b and a :: a and b :: b. datatype a option = None |Some a adjoins a new element \nNone to a type a. All existing elements in type a are also in a option, but are pre.xed by Some.For succinctness \nwe write .a. instead of Some a. Hence bool option has the values .True., .False.and None. Partial functions \nare modeled as functions of type a . bop\u00adtion, where None represents unde.nedness and fx = .y.means x \nis mapped to y. Instead of a . b option we write a . b, call such functions maps, and abbreviate f(x:=.y.) \nto f(x .. y). The latter notation extends to lists: f([x1,.... ,xm][.] [y1,...,yn]) means f(x1..y1)...(xi. \n.yi), where i is the mini\u00admum of m and n. The notation works for arbitrary list expressions on both sides \nof [. .], not just enumerations. Multiple updates like f(x.... . y)(xs[.]ys) can be written as f(x . \ny, xs [.] ys). The map .x. None is written empty, and empty (...), where ... are updates, abbreviates \nto [...]. For example, empty (x.y,xs[. ..]ys) becomes [x .. . y, xs [.] ys]. The domain of a map is \nde.ned as domm ={a |ma .  = None}. Function map-of turns an list of pairs into a map: map-of [] = empty \nmap-of (p\u00b7ps)= map-of ps(fst p . snd p) 3.2 Names, paths, and base classes Type cname is the (HOL) type \nof class names. The (HOL) vari\u00adables C and D will denote class names, Cs and Ds are paths. We introduce \nthe type abbreviation path = cname list Programs are denoted by P. For the moment we do not need to know \nwhat programs look like. Instead we assume the following predicates describing the class structure of \na program: P .C .R D means D is a direct repeated base class of C.  P .C .S D means D is a direct shared \nbase class of C.  . * means (.R ..S ) * .  is-class P C means class C is de.ned in P.  3.3 Subobjects \nWe slightly change the appearance of subobjects in comparison with Rossie-Friedman style: we use a tuple \nwith a class and a path component where a path is represented as a list of classes. For ex\u00adample, a Rossie-Friedman \nsubobject [Bottom,Bottom.Left] is translated into (Bottom,[Bottom,Left]). The subobject de.nitions are \nparameterized by a program P. First we de.ne Subobjs R P, the subobjects whose path consists only of \nrepeated inheritance relations: is-classPC (C, [C]) .Subobjs R P P .C .R D (D, Cs) .Subobjs R P (C, C\u00b7Cs) \n.Subobjs R P Now we de.ne SubobjsP, the set of all subobjects: (C, Cs) .Subobjs R P (C, Cs) .SubobjsP \n* C P .C . P .C. .S D (D, Cs) .Subobjs R P (C, Cs) .SubobjsP We have shown that this de.nition and the \none by Rossie and Friedman (see \u00a72.2) are equivalent. Ours facilitates proofs because paths are built \nup following the inductive nature of lists. 3.4 Path functions Function last on lists returns the topmost \nclass in a path (w.r.t. the class hierarchy), butlast chops off the last element. Function @p appends \ntwo paths assuming the second one is starting where the .rst one ends with. If the second path only contains \nrepeated inheritance, then it starts with the same class the .rst one ends with, so we can append both \nof them via @ (taking care to just use the common class once). If the second path begins with a shared \nclass, the .rst path just disappears (because we lose all information below the shared class): Cs @p \nCs. = if last Cs = hd Cs . then Cs @ tl Cs . else Cs . The following property holds under the assumption \nthat program P is well-formed. If (C, Cs) . Subobjs P and (last Cs, Ds) . Subobjs P then (C, Cs @p Ds) \n. Subobjs P. A well-formed program requires certain natural constraints of the program such as the class \nhierarchy relation to be irre.exive. An ordering on paths is de.ned as follows: (C, Cs) .SubobjsP (C, \nDs) .SubobjsP Cs= butlast Ds P,C .Cs .1 Ds (C, Cs) .SubobjsP P .last Cs .S D P,C .Cs .1 [D] The re.exive \nand transitive closure of .1 is written .. The intu\u00adition of this ordering is subobject containment: \nP,C .Cs .Ds means that subobject (C,Ds) lies below (C,Cs) in the subobject graph. For example, it is \nnot hard to derive P,Bottom .[Bottom ] .[Bottom ,Left ,Top] (in the repeated diamond) from these de.ni\u00adtions. \n  4. Abstract syntax of CoreC++ We do not de.ne a concrete syntax for CoreC++, just an ab\u00adstract syntax. \nThe translation of the C++-subset corresponding to CoreC++ into abstract syntax is straightforward and \nwill not be discussed here. In the sequel, we use the following (HOL) variable conventions: Vis a (CoreC++) \nvariable name, Fa .eld name, Ma method name, e an expression, v a value, and T a type. In addition to \ncname (class names) there are also the (HOL) types vname (variable and .eld names), and mname (method \nnames). We do not assume that these types are disjoint. 4.1 References A reference refers to a subobject \nwithin an object. Hence it is a pair of an address that identi.es the object on the heap (see \u00a76.1 below) \nand a path identifying the subobject. Formally: reference = addr \u00d7path The path represents the dynamic \ncontext of a subobject as a result of previous casts (as explained in \u00a72.4), and corresponds to the result \nof adding delta values to an object pointer in the standard v\u00adtable implementation. Note that our semantics \ndoes not emulate the standard implementation, but is more abstract. Note: CoreC++ references are not \nequivalent to C++ references, but are more like C++ pointers. As an example, consider Fig. 3. If we assume \nthat the else statement is executed, then b will have the reference value (a, [E, B]) where a is the \nmemory address of the new E object, and path [E, B] represents the fact that this object has been up-cast \nto B and b in fact points to the B subobject.  4.2 Values and Expressions A CoreC++ value (abbreviated \nval ) can be a boolean Boolb, where b :: bool,or  an integer Intgi, where i :: int,or  a reference \nRef r, where r :: reference,or  the null reference Null,or  the dummy value Unit.  CoreC++ is an imperative \nbut an expression-based language where statements are expressions that evaluate to Unit. The following \nexpressions (of HOL type expr) are supported by CoreC++: creation of new object: new C  static casting: \nstat cast Ce  dynamic casting: dyn cast Ce  literal value: Val v  binary operation: e1 .bop. e2 (where \nbop is one of + or =)  variable access Var V and variable assignment V:= e  .eld access e.F{Ds}and \n.eld assignment e1.F{Ds}:= e2 (where Ds is the path to the subobject where F is declared)  method call: \ne.M(es)  block with locally declared variable: {V:T; e}  sequential composition: e1; e2  conditional: \nif (e) e1 else e2 (do not confuse with HOL s if bthen x else y)   prog = cdecl list cdecl = cname \u00d7 \nclass class = base list \u00d7 fdecl list \u00d7 mdecl list fdecl = vname \u00d7 ty method = ty list \u00d7 ty \u00d7 vname list \n\u00d7 expr mdecl = mname \u00d7 method datatype base = Repeats cname | Shares cname Figure 4. Abstract program \nsyntax while loop: while (e) e. The constructors Val and Var are needed in our meta-language to disambiguate \nthe syntax. There is no return statement because everything is an expression and returns a value. The \nannotation {Ds} in .eld access and assignment is not part of the input language but is something that \na preprocessor, e.g., the type checking phase of a compiler, must add. To ease notation we introduce \nan abbreviation: ref r = Val(Ref r)  4.3 Programs The abstract syntax of programs is given by the type \nde.nitions in Fig. 4, where ty is the HOL type of CoreC++ types. A CoreC++ program is a list of class \ndeclarations. A class declaration consists of the name of the class and the class itself. A class consists \nof the list of its direct superclass names (marked shared or repeated), a list of .eld declarations and \na list of method declarations. A .eld declaration is a pair of a .eld name and its type. A method declaration \nconsists of the method name and the method itself, which consists of the parameter types, the result \ntype, the parameter names, and the method body. Note that CoreC++ (like Java, but unlike C++) does not \nhave global variables. Method bodies can access only their this-pointer and parameters, and return a \nvalue. We refrain from showing the formal de.nitions (see [11]) of the predicates like P . C .R D introduced \nin \u00a73 as they are straightforward. Instead we introduce one more access function: class P C: the class \n(more precisely: class option ) associated with C in P.  5. Type system CoreC++ types are either primitive \n(Boolean and Integer), class types ClassC , NT (the type of Null ), or Void (the type of Unit ). The \nset of these types (i.e. the corresponding HOL type) is called ty. The .rst two rules of the subtype \nrelation = are straightforward: P . T = TP . NT = ClassC To relate two classes, we have to take care \nthat we can use an object of the smaller type wherever an object of the more general type can occur. \nThis property can be guaranteed by requiring that a static cast between these two types can be performed, \nresulting in the premise7: P .path C to D unique =.!Cs. (C, Cs) .Subobjs P .last Cs = D This property \nensures that the path from class C leading to class D exists and is unique (. ! is unique existence). \nThis leads to the third subtyping rule: P . path Cto Dunique P . ClassC = ClassD The pointwise extension \nof = to lists is written [=] . 7 For more information about static casts, see \u00a75.1.1 5.1 Typing rules \nThe core of the type system is the judgment P,E . e :: T , where E is an environment, i.e. a map from \nvariables to their types. We call T the static type of e. We will discuss the typing rules (see Fig. \n5) construct by con\u00adstruct, concentrating on object-orientation. The remaining rules can be found elsewhere \n[11]. For critical constructs we will also con\u00adsider the question of type safety: does the type system \nguarantee that evaluation cannot get stuck and that, if a value is produced, it is of the right type. \nValues are typed with their corresponding types, e.g., Bool as Boolean, Intg as Integer. However, there \nis no rule to type a reference,so explicit references cannot be typed. CoreC++, like Java or ML, does \nnot allow explicit references for well known reasons. 5.1.1 Cast Typing static casts is non-trivial in \nCoreC++ because the type system needs to prevent ambiguities at run-time (although it cannot do so completely). \nWhen evaluating stat cast Ce, the object that e evaluates to may have multiple subobjects of class C.Ifitis \nan up-cast, i.e. if P,E . e :: ClassD and D is a subclass of C,we have to check if there is a unique \npath from D to C. Two examples will make this clearer: if we want to cast Bottom to Top in the repeated \ndiamond in Fig. 1,wehavetwo paths leading to possible subobjects: [Bottom,Left,Top] and [Bottom,Right,Top]. \nSo there is no unique path, the cast is am\u00adbiguous and the type system rejects it. But the same cast \nin the shared diamond in Fig. 2 is possible, as there is only one possible path, namely [Top]. For down-casts \nwe need to remember (\u00a72.3) that we have chosen to model a type safe variant of static_cast (which means \nwe throw an exception where C++ produces a run-time error), for which C++ has .xed the rules as follows: \ndown-casts may only involve repeated inheritance. To enforce this restriction we introduce the predicate \nP .path C to D via Cs =(C, Cs) .Subobjs P .last Cs = D Combining the checks for up-and down-casts in \none rule and re\u00adquiring the class to be known we obtain WT1 (see Fig. 5). Re\u00admember that (C, Cs) . Subobjs \nR P means that Cs involves only repeated inheritance. As an example of an ambiguous down-cast, take the \nrepeated diamond in Fig. 1 and extend it with a shared superclass C of Top. Casting a Bottom object of \na static class C to Top is ambiguous because there are two Top subobjects. Dynamic casts are non-trivial \noperations at run-time but stati\u00adcally they are as simple as can be: rule WT2 only requires that the \nexpression is well-typed and the class is known. This liberality is not just admissible (because dynamic \ncasts detect type mismatches at run-time) but even necessary. We come back to this point when we discuss \nthe semantics in \u00a76.3.2.  5.1.2 Variable assignment and binary operators The assignment rule WT3 is \ncompletely straightforward as the expression on the right hand side has to be a subtype of the variable \n P,E . e :: ClassD is-classPC P . path Dto Cunique . P . C . * D . (. Cs. P . path Cto Dvia Cs -. (C, \nCs) . Subobjs R P) WT1 P,E . stat cast Ce :: ClassC P,E . e :: ClassD is-classPC WT2 P,E . dyn cast \nCe :: ClassC EV = . T. P,E . e :: T. P . T. = T WT3 P,E . V:= e :: T P,E . e1 :: T1 P,E . e2 :: T2 case \nbop of = . T1 = T2 . T = Boolean | + . T1 = Integer . T2 = Integer . T = Integer WT4 P,E . e1 .bop. \ne2 :: T P,E . e :: ClassC P . Chas least F : Tvia Cs WT5 P,E . e.F{ Cs} :: T P,E . e1 :: ClassC P . \nChas least F : Tvia Cs P,E . e2 :: T. P . T. = T WT6 P,E . e1.F{ Cs} := e2 :: T P,E . e :: ClassC P \n. Chas least M =(Ts, T, m) via Cs P,E . es [::] Ts. P . Ts. [= ] Ts WT7 P,E . e.M(es):: T Figure 5. \nThe typing rules type on the left hand side, which we get by consulting the typing environment. Rule \nWT4 for binary operators: Addition is unsurprising. In the equality test, we assume that both operands \nhave the same type, i.e. that all necessary casts are performed explicitly. This simpli.es the presentation \nwithout loss of generality.  5.1.3 Field access and assignment The typing rule for .eld access WT5 is \nstraightforward. It can either be seen as a rule that takes an expression where .eld access is already \nannotated (by { Cs} ), and the rule merely checks that the annotation is correct. Or it can be seen as \na rule for computing the annotation. The latter interpretation relies on the fact that predicate P. Chas \nleast F: Tvia Cs can compute Tand Cs from P, C and F. So it remains to explain P . Chas least F : Tvia \nCs: it checks if Cs is the least (w.r.t. . ) path leading from C to a class declaring an F. First we \nde.ne the set FieldDeclsPCF of all (Cs, T) such that Cs is a valid path leading to a class with an F \nof type T: FieldDeclsPCF = {(Cs, T)| (C, Cs).Subobjs P . (.Bs fs ms. class P (last Cs)=.(Bs, fs, ms)..map-of \nfs F =.T.)} Then we select a least element from that set: P .C has least F :T via Cs = (Cs, T).FieldDeclsPCF \n. (.(Cs . , T ).FieldDeclsPCF. P,C .Cs .Cs ) If there is no such least path, .eld access is ambiguous \nand hence not well-typed. We give an example. Once again we concen\u00adtrate on the repeated diamond in Fig. \n1 and assume that a .eld x is de.ned in class Bottom and class Top. When type check\u00ading e.x, where e \nis of class Bottom, the path components in FieldDeclsPBottomx are [Bottom], [Bottom,Left,Top] and [Bottom,Right,Top]. \nThe least element of the path components in this set is [Bottom], so the x in class Bottom will be accessed. \nNote that if no x in Bottom is declared, then there is no element with a least path in FieldDecls and \nthe .eld access is ambiguous and hence illegal. Field assignment works analogously as shown in WT6. Returning \nto Example 6 from \u00a7 2.4, one can see that our type system correctly determines that the least declaration \nof x is the one in C. Hence, our type system does not yield the incorrect result that is produced by \nseveral C++ compilers. 5.1.4 Method call In the call typing rule WT7 the class C of e is used to collect \nall declarations of M and select the least one. The set of all de.nitions of method M from class C upwards \nis de.ned as MethodDefsPCM = {(Cs, mthd)| (C, Cs).Subobjs P . (.Bs fs ms. class P (last Cs)=.(Bs, fs, \nms)..map-of ms M =.mthd.)} This set pairs the method (of type method, see Fig. 4) with the path Cs leading \nto the de.ning class. Among all de.nitions the least one (w.r.t. the ordering on paths) is selected: \nP .C has least M =mthd via Cs = (Cs, mthd).MethodDefsPCM . (.(Cs . , mthd ).MethodDefsPCM. P,C .Cs .Cs \n) Unfortunately, the absence of static ambiguity of method lookup is not suf.cient to avoid ambiguities \nat run-time. Even if the call is well-typed, e may evaluate to a class below C from which there is no \nleast declaration of M. We presented this problem in Example 3 and will discuss it in detail in \u00a7 6.3.6. \nIn the third premise of WT7, the relation [::] is the pointwise extension of :: to lists.  5.2 Well-formed \nprograms A well-formed CoreC++ program (wf-C-progP ) must obey all the usual requirements (every method \nbody is well-typed and of the declared result type, the class hierarchy is acyclic, etc for de\u00adtails \nsee [11]). Additionally, there are CoreC++-speci.c conditions concerning method overriding: (i) covariance \nin the result type combined with the uniqueness of paths from the new result class to all result classes \nin previous de.nitions of the same method (see Example 4). This require\u00adment is easily formalized by \nmeans of the path-unique predi\u00adcate introduced in \u00a7 5. state = heap \u00d7locals locals = vname . val heap \n= addr . obj obj = cname \u00d7subo set subo = path \u00d7(vname . val ) Figure 6. The type of CoreC++ program \nstates (ii) invariance in the argument types (see Example 5) (iii) for every method de.nition a class \nC sees via path Cs, the corresponding subobject (C,Cs) must have a least overrider as explained in \u00a76.3.6 \n(otherwise the corresponding C++ program would not be able to construct a unique v-table entry for this \nmethod call and the program would be rejected at compile time)  6. Big Step Semantics The big step semantics \nis a (deterministic) relation between an initial expression-state pair .e,s.and a .nal expression-state \npair .e. ,s.. The syntax of the relation is P,E ..e,s...e. ,s.and we say that e evaluates to e. The rules \nwill be such that .nal expressions are always values (Val)orex\u00ad ceptions (throw), i.e. .nal expressions \nare completely evaluated. We proved that the big step rules are deterministic, i.e. an expression-state \npair always evaluates to the same result. 6.1 State The set of states is de.ned in Fig. 6.A state is \na pair of a heap and a store (locals ). A store is a map from variable names to values. A heap is a map \nfrom addresses to objects. An object is a pair of a class name and its subobjects. A subobject (subo) \nis a pair of a path (leading to that subobject) and a .eld table mapping variable names to values. The \nnaming convention is that h is a heap, l is a store (the local variables), and s a state. Note that CoreC++, \nin contrast to C++, does not allow stack\u00ad allocated objects: variable values can only be pointers (CoreC++ \nreferences), but not objects. Objects are only on the heap (as in Java). We do not expect stack based \nobjects to interfere with multi\u00ad ple inheritance. Remember further that a reference contains not only \nan address but also a path. This path selects the current subobject of an object and is modi.ed by casts \n(see below). 6.2 Exceptions CoreC++ supports exceptions. They are essential to prove type soundness \nas certain problems can occur at run-time (e.g., a failing cast) which we cannot prevent statically. \nIn these cases we throw an exception so the semantics does not get stuck. Three exceptions are possible \nin CoreC++: OutOfMemory, if there is no more space on the heap, ClassCast for a failed cast and NullPointer \nfor null pointer access. We will explain in the text exactly when an excep\u00adtion is thrown but will omit \nshowing the corresponding rules; the interested reader can .nd them in the appendix.  6.3 Evaluation \nRemember that P,E ..e,s...e. ,s.is the evaluation judgment, where P denotes the program and E the type \nenvironment. The need for E will be explained in \u00a76.3.3. For a better understanding of the evaluation \nrules it is helpful to realize that they preserve the following heap invariant: for any object (C, S) \non the heap we have S contains exactly the paths starting from C: {Ds |.fs. (Ds, fs) .S}= {Ds |(C, Ds) \n.SubobjsP }, S is a (.nite) function: .(Cs,fs), (Cs. ,fs) .S. Cs = Cs. -.fs = fs. Furthermore, if an \nexpression e evaluates to ref (a, Cs) then the heap maps a to .(C, S).such that Cs is the path of a \nsubobject in S: (Cs, fs) .S for some fs.  last Cs is equal to the class of e inferred by the type system. \n We will now discuss the evaluation rules construct by construct, concentrating on object-orientation, \nas shown in Fig. 7. The re\u00admaining rules can be found elsewhere [11]. 6.3.1 Object creation Rule BS1 \nshows the big step rule for object creation. The result of evaluating new C is a reference Ref (a, [C]) \nwhere a is some unallocated address returned by the auxiliary function new-Addr (which returns None if \nthe heap is exhausted, in which case we throw an OutOfMemory exception). As a side effect, a is made \nto point to the object (C, S), where S = init-obj P C is the set of all subobjects (Cs, fs) such that \n(C, Cs) . Subobjs P and fs :: vname . val is the .eld table that contains every .eld declared in class \nlast Cs initialized with its default value (according to its type). We omit the details. Note that C++ \ndoes not initialize .elds. Our desire for type safety requires us to deviate from C++ in this minor aspect. \n 6.3.2 Cast Casting is a non-trivial operation in C++, in contrast to Java. Re\u00admember that any object \nreference contains a path component identi\u00adfying the current subobject which is referenced. A cast changes \nthis path, thus selects a different subobject. Hence casting must adjust the path component of the reference. \nThis mechanism corresponds to Stroustrup s adjustment of pointers by delta values. We con\u00adsider it a \nprime example of the fact that our semantics does not rely on run-time data structures but on abstract \nconcepts. Let us .rst look at the static up-cast rule BS2: After evaluating e to a reference with path \nCs, that path is extended (upward) by a (unique, if the the cast is well-typed, \u00a75.1.1) path Cs. from \nthe end of Cs up to C, which we get by predicate path-via.Soifwewant to cast Bottom to Left in the repeated \ndiamond in Fig. 1, the appropriate path is [Bottom,Left], casting Right to Top in the shared diamond \nin Fig. 2 uses path [Top]. Rule BS3 models the static down-cast which forbids down-casts involving shared \ninheritance. This means that class C must occur in the path component of the reference, or the cast is \nwrong . If neither of these two rules applies, the static cast throws a ClassCast exception (see appendix). \nNow consider dyn_cast which models dynamic_cast in C++. If possible, dyn_cast tries to behave like the \nstatic cast. Rules BS4 and BS5 are the analogues of BS2 and BS3, except that BS4 has the additional premise \nP . path last Cs to C unique. This is because typing of dyn_cast, in contrast to stat_cast, does not \nguarantee uniqueness (in order to be more general). In the presence of multiple inheritance, not only \nup and down-casts are possible but also cross-casts: A reference (a, [Bottom , Left ]) to the Left subobject \nof a Bottom object (in either the shared or repeated diamond) can be cast to the Right subobject resulting \nin the reference (a, [Bottom , Right ]). It is also possible that a legal down cast cannot be performed \nby rule BS5 because C does not occur in the path. Assume B is a shared subclass of A. Then a term which \nis statically of class A and evaluates to ref (b, [A]) but points to an object of class B can be cast \nto ref (b, [B]), but not by BS5. Both cross-casts and such dynamic down-casts are performed by rule BS6. \nAfter evaluating e to a reference to address a,we new-Addrh =.a. h. =h(a . .(C, init-objPC )) BS1 P,E \n..new C,(h, l)...ref (a, [C]),(h. , l). P,E ..e,s0...ref (a, Cs),s1. P .path last Cs to Cvia Cs. Ds =Cs \n@p Cs. BS2 P,E ..stat cast Ce,s0...ref (a, Ds),s1. P,E ..e,s0...ref (a, Cs @[C]@Cs),s1. BS3 P,E ..stat \ncast Ce,s0...ref (a, Cs @[C]),s1. P,E ..e,s0...ref (a, Cs),s1. P .path last Cs to Cunique P .path last \nCs to Cvia Cs. Ds =Cs @p Cs. BS4 P,E ..dyn cast Ce,s0...ref (a, Ds),s1. P,E ..e,s0...ref (a, Cs @[C]@Cs),s1. \nBS5 P,E ..dyn cast Ce,s0...ref (a, Cs @[C]),s1. P,E ..e,s0...ref (a, Cs),(h, l). ha =.(D, ). P .path \nDto Cvia Cs. P .path Dto CuniqueBS6 P,E ..dyn cast Ce,s0...ref (a, Cs),(h, l). P,E ..e,s0...ref (a, Cs),(h, \nl). ha =.(D, S).\u00acP .path Dto Cunique \u00acP .path last Cs to Cunique C ./set Cs BS7 P,E ..dyn cast Ce,s0...null \n,(h, l). P,E ..e,s0...Val v,(h, l). EV =.T. P .Tcasts v to v . l. =l(V ..v )BS8 P,E ..V:= e,s0...Val \nv . ,(h, l). P,E ..e1,s0...Val v1,s1. P,E ..e2,s1...Val v2,s2. binop (bop, v1, v2)=.v. BS9 P,E ..e1 \n.bop. e2,s0...Val v,s2. P,E ..e,s0...ref (a, Cs),(h, l). ha =.(D, S). Ds =Cs. @p Cs (Ds, fs).S fsF =.v. \nBS10 P,E ..e.F{Cs},s0...Val v,(h, l). P,E ..e1,s0...ref (a, Cs),s1. P,E ..e2,s1...Val v,(h2, l2). h2 \na =.(D, S). P .last Cs . has least F :Tvia Cs P .Tcasts v to v . Ds =Cs. @p Cs (Ds, fs).S fs. =fs(F .v \n)=S -{(Ds, fs)}.{(Ds, fsh2 . =h2(a .)) .S. )}.(D, S BS11 P,E ..e1.F{Cs}:= e2,s0...Val v ,(h2 , l2). \nP,E ..e,s0...ref (a, Cs),s1. P,E ..ps,s1.[.].map Val vs,(h2, l2). h2 a =.(C, ). P .last Cs has least \nM =(, T. ,, )via Ds P .(C, Cs @p Ds)selects M =(Ts, T, pns, body)via Cs. length vs =length pns P .Ts \nCasts vs to vs . l2 . =[this .Ref (a, Cs, pns [.] new-body =(case T. of ClassD .stat cast Dbody|\u00ad . ).]vs \n.body) P,E(this .), pns [.]Ts)..new-body,(h2, l2 .Class (last Cs . )...e ,(h3, l3). BS12 P,E ..e.M(ps),s0...e \n,(h3, l2). Figure 7. The Big Step rules look up the class D of the object at address a.If D has a unique \nC subobject, that is the one the reference must now point to. If BS6 is inapplicable, i.e. if there is \neither no path or no unique path from the dynamic class, and a static cast fails as well, we return the \nnull pointer, i.e. the value null (see BS7). This is exactly how C++ handles failing dynamic_casts. We \nnow return to the point raised in the discussion of the typing rule for dynamic casts in \u00a75.1.1. Rule \nWT2 needs to be as liberal as it is because even if there is no relationship between Cand the static \nclass of e (call it B), e may evaluate to an object of a subclass of both Cand Band the cast could succeed. \nDoes that mean we should at least require that C and B have a common subclass (or maybe superclass)? \nNot even that: since inheritance is all about permitting later extensions with new subclasses, the common \nsubclass of C and B need not yet exist when dyn cast Ce is type checked.  6.3.3 Variable assignment \nAssignment is straightforward (see rule BS8) except that it requires an up-cast of the expression to \nthe static type T of the variable. Hence we need the environment E to look up T (by EV =.T.). The up-cast \nis inserted implicitly by the semantics and de.ned via .C. T . =ClassC P .Tcasts v to v P .ClassC casts \nNull to Null P .path last Cs to Cvia Cs. Ds =Cs @p Cs. P .ClassC casts Ref (a, Cs)to Ref (a, Ds) 6.3.4 \nBinary operators The evaluation rule for binary operators BS9 is based on a function binop taking the \noperator and its two argument values and return\u00ading an optional (in order to deal with type mismatches) \nresult. The de.nition of binop for our two binary operators = and + is straight\u00adforward: binop (=, v1, \nv2)= .Bool (v1 =v2). binop (+, Intgi1, Intgi2)= .Intg (i1 +i2). binop (,, )= None In the .rst equation, \nequality on the left hand side is the CoreC++ equality operator, equality in the middle is de.nitional \nequality, and equality on the right hand side is the test for equality. Logically, the latter two are \nthe same. Addition only yields a value if both arguments are integers. We could also insist on similar \ncompatibility checks for the equality test, but that leads to excessive case distinctions that we want \nto avoid for reasons of presentation. In particular, = does not perform any implicit casts. 6.3.5 Field \naccess and assignment Let us .rst look at .eld access in rule BS10. There are two paths involved. Cs \nis (if the expression is well-typed, \u00a75.1.3) the path from the class of e to the class where F is declared. \nCs. is the path component of the reference that e evaluates to. As we have discussed in \u00a76.3, last Cs \n. is equal to the static class of e. To obtain the complete path leading to the subobject in which F \nlives, we just have to concatenate via @p the two paths. The resulting path Ds is the path to the subobject \nwe are looking for. If e doesn t evaluate to a reference, but to a null pointer, we throw a NullPointer \nexception. Field assignment (rule BS11) is similar, except that we now have to update the heap at a with \na new set of subobjects. The up-cast is inserted implicitly, analogously to BS8. Note that the functional \nnature of this set is preserved. 6.3.6 Method call Rule BS12 is lengthy: evaluate e to a reference \n(a, Cs) and the parameter list ps to a list of values vs;  look up the dynamic class C of the object \nin the heap at a;  look up the method de.nition used at type checking time (last Cs is the static class \nof e) and note its return type T and the path Ds from last Cs to this de.nition;  select the dynamically \nappropriate method (see below) and note its parameter names pns, parameter types Ts, body body, and path \nCs. from C to this de.nition;  check that there are as many actual as formal parameters;  cast the \nparameter values vs up to their static types Ts by using P. Ts Casts vs to vs . , the pointwise extension \nof casts to lists, yielding vs  ; evaluate the body (with an up-cast to T,if T is a class) in an updated \ntype environment where this has type Class (last Cs) (the class where the dynamically selected method \nlives) and the formal parameter names have their declared types, and where the local variables are this \nand the parameters, suitably initialized. The .nal store is the one obtained from the evaluation of the \nparam\u00adeters; the one obtained from the evaluation of body is discarded remember that CoreC++ does not \nhave global variables. If e evalu\u00adates to a null pointer, we throw a NullPointer exception. Method selection \nis performed by the judgment P . (C, Cs) selects M = mthd via Cs. , where (C,Cs) is the subobject where \nthe method lives that was used at type checking time. Hence there is at least one de.nition of M visible \nfrom C. There are two possible cases. If we are lucky, we can select a unique method de.nition based \nsolely on C: P . Chas least M = mthd via Cs. P . (C, Cs) selects M = mthd via Cs. Otherwise we need static \ninformation to disambiguate the selec\u00adtion as Example 3 already demonstrated. class Top { void f(); }; \nclass Right2 : Top { ... }; class Right : virtual Right2 { void f(); }; class Left : Top { void f(); \n}; class Bottom : Left, Right { ... }; ((Right2*)(new Bottom()))->f();  Figure 8. Example illustrating \nstatic resolution of dynamically ambiguous method calls Example. To appreciate the full intricacies of \nthis mecha\u00adnism, let us consider the example in Fig. 8, where a sub\u00adobject (Bottom,[Right2]) calls method \nf: the path com\u00adponents in MethodDefs P Bottom f are [Bottom,Left], [Bottom,Left,Top], [Bottom, Right] \nand [Right2,Top]. None of these paths is smaller than all of the others, so we cannot resolve the method \ncall purely dynamically. So another approach is taken: we select the minimal paths in MethodDefs P Bottom \nf, which leaves us with [Bottom,Left] and [Bottom,Right]. Now we have to .nd out which of these two paths \nwill select the method to call. This is done by considering the statically selected method call (i.e. \nthe least one seen from the static class Right2), yielding path [Right2,Top], which is guaranteed to \nbe unique by the type system. Now we append this static path to the path component of the subobject, \nwhich results in the path where the dy\u00adnamic class sees the statically selected method de.nition, namely \n[Right2]@p[Right2,Top]=[Right2,Top]. Finally we select a path from the above set of minimal paths that \nis smaller than the composed path, which results in [Bottom,Right]. The unique\u00adness of this path is guaranteed \nby the well-formedness of the pro\u00adgram (see \u00a75.2 (iii)). Abstractly, P . (C, Cs) selects M = mthd via \nCs. selects that Cs. from the set of minimal paths from C to de.nitions of M that lies on Cs, i.e. that \nlies below the statically selected method de.\u00adnition Cs. The minimal elements are collected by MinimalMethod-Defs, \nMinimalMethodDefsPCM = { (Cs, mthd)| (Cs, mthd). MethodDefsPCM . (. (Cs . , mthd ). MethodDefsPCM. P,C \n. Cs. . Cs -. Cs . =Cs)} the ones that override the de.nition at Cs, i.e. are below Cs, are selected \nby OverriderMethodDefs, OverriderMethodDefsPRM = { (Cs, mthd)| . Cs . mthd . . P . last (snd R)has least \nM =mthd . via Cs . . (Cs, mthd). MinimalMethodDefs P (fst R)M . P,fst R . Cs . snd R @p Cs } and selection \nof a least overrider is performed as follows: P . R has overrider M =mthd via Cs = (Cs, mthd). OverriderMethodDefsPRM \n. card (OverriderMethodDefsPRM)=1 Note that OverriderMethodDefs returns a singleton set (card is the \ncardinality of a set) if the program is well-formed (see \u00a75.2 (iii)). Hence the second de.ning rule for \nselects is .mthd Cs . . \u00acP .Chas least M = mthd via Cs. P .(C, Cs) has overrider M = mthd via Cs. P .(C, \nCs) selects M = mthd via Cs.  6.4 Small Step Semantics Big step rules are easy to understand but cannot \ndistinguish non\u00adtermination from being stuck. Hence we also have a small step se\u00admantics where expression-state \npairs are gradually reduced. The re\u00adduction relation is written P,E ..e,s...e. ,s.and its transitive \nre.exive closure is P,E ..e,s.. * .e. ,s.. We do not show the rules (for lack of space, the interested \nreader can .nd selected ones in the appendix) but emphasize that we have proven the equivalence of the \nbig and small step semantics (for well-formed programs): P,E ..e,s...e. ,s.=(P,E ..e,s.. * .e. ,s...nal \ne ).  7. Type Safety Proof Type safety, one of the hallmarks of a good language design, means that the \nsemantics is sound w.r.t. the type system: well-typed ex\u00adpressions cannot go wrong. Going wrong does \nnot mean throw\u00ading an exception but arriving at a genuinely unanticipated situation. The by now standard \nformalization of this property [39] requires proving two properties: progress (well-typed expressions \ncan be re\u00adduced w.r.t. the small step semantics if they are not .nal yet the small step semantics does \nnot get stuck) and preservation or sub\u00adject reduction: reducing a well-typed expression results in another \nwell-typed expression whose type is =the original type. In the remainder we concentrate on the speci.c \ntechnicalities of the CoreC++ type safety proof. We do not even sketch the actual proof, which is routine \nenough, but all the necessary invariants and notions without which the proof is very dif.cult to reconstruct. \nFor a detailed exposition of the Jinja type safety proof, our starting point, see [11]. For a tutorial \nintroduction to type safety see, for example, [19]. 7.1 Run-time type system The main complication in \nmany type safety proofs is the fact that well-typedness w.r.t. the static type system is not preserved \nby the small step semantics. The fault does not lie with the semantics but the type system: for pragmatic \nreasons it requires properties that are not preserved by reduction and are irrelevant for type safety. \nThus a second type system is needed which is more liberal but closed under reduction. This is known as \nthe run-time type system [8] and the judgment is P,E,h .e : T. Please note that there is no type checking \nat run-time: this type system is merely the formalization of an invariant which is not checked but whose \npreservation we prove. Many of the rules of the run-time type system are the same as in the static type \nsystem. The ones which differ are shown in Fig. 9. Rule RT3 takes care of the fact that small step reduction \nmay introduce references values into an expression (although the static type system forbids them, see \n\u00a75.1). The premise P .typeof h v = .T. expresses that the value is of the right type; if v = Ref (a, \nCs), its type is Class (last Cs) provided ha = .(C, ).and (C, Cs) .SubobjsP . The main reason why static \ntyping is not preserved by reduction is that the type of subexpressions may decrease from a class type \nto a null type with reduction. Because of this, both cast rules only require the expression to cast to \nhave a reference type (is-refTT ), which means either a class or the null type. None of the checks that \nRT1 P,E,h .e : T is-refT T is-class PC P,E,h .dyn cast Ce : Class C RT2 P,E,h .e : T is-refT T is-class \nPC P,E,h .dyn cast Ce : Class C RT3 P .typeof h v = .T. P,E,h .Val v : T RT4 P,E,h .e : NT P,E,h .e.F{Cs}: \nT P,E,h .e1 : NT P,E,h .e2 : T. P .T. =T RT5 P,E,h .e1.F{Cs}:= e2 : T P,E,h .e : NT P,E,h .es [:] Ts \n RT6 P,E,h .e.M(es): T Figure 9. Run-time type system are needed for the static cast are important for \nthe run-time type system. Rule RT4 takes care of e.F{Cs}where the type of e has reduced to NT. Since \nthis is going to throw an exception, and exceptions can have any type, this expression can have any type, \ntoo. Rules RT5 and RT6 work similarly for .eld assignment and method call. We have proved that P,E .e \n:: T implies P,E,h .e : T. Heap h is unconstrained as the premise implies that e does not contain any \nreferences. 7.2 Conformance and De.nite Assignment Progress and preservation require that all semantic \nobjects conform to the type constraints imposed by the syntax. We say that a value v conforms to a type \nT (written P,h .v :=T) if the type of v equals type T or, if T is a class type, v has type NT. A heap \nconforms to a program if for every object (C, S) on the heap if (Cs, fs) .S then (C, Cs) .SubobjsP and \nif F is a .eld of type T declared in class last Cs then fsF = .v.and the type of v (in the sense of rule \nRT1) conforms to type T.  if (C, Cs) .SubobjsP then (Cs, fs) .S for exactly one fs.  v In this case \nwe write P . h . A store l conforms to a type environment E iff lV = .v. implies EV = .T. such that v \nconforms to T. In symbols: P,h . l (:=)w E . We also need v conformance concerning the type environment: \nP.E states that for every variable that maps to a type in environment E, the type is a valid type in \nprogram P. v P .E =.VT. EV = .T.-.is-type P T vv If P .vh , P,h .l (:=)w E and P .E then we write P,E \n. (h, l) and say that state (h,l) conforms to the program and the environment. For the proof we need \nanother conformance property, which we call type-conf. It simply describes that given a certain type, \nan expression has that type in the run-time type system. However, if this given type is a class type, \nthe run-time type system may also return the null type for the expression. P,E,h .e :NT ClassC = P,E,h \n.e : ClassC .P,E,h .e : NT P,E,h .e :NT Void = P,E,h .e : Void The rules for Boolean, Integer and NT \nare analogous to the rule containing Void. From Jinja we have inherited the notion of de.nite assignment, \na static analysis that checks if in an expression every variable is initialized before it is read. This \nconstraint is essential for proving type safety. De.nite assignment is encoded as a predicate D such \nthat D eA (where A is a set of variables) asserts the following property: if initially all variables \nin Aare initialized, then execution of e does not access an uninitialized variable. For technical reasons \nA is in fact of type vname set option. That is, if we want to execute e in the context of a store lwe \nneed to ensure D e .doml .. Since D is completely orthogonal to multiple inheritance we have omitted \nall details and refer to [11] instead. 7.3 Progress Progress means that any (run-time) well-typed expression \nwhich is not yet not fully evaluated (i.e. .nal) can be reduced by a rule of the small step semantics. \nTo prove this we need to assume that the program is well-formed, the heap and the environment conform, \nand the expression passes the de.nite assignment test: vv If wf-C-prog P and P,E,h .e : T and P .h and \nP .E and . . De .dom l. and \u00ac.nal e then .es. P,E ..e,(h, l)...e ,s . This theorem is proved by a quite \nexhausting rule induction on the (run-time) typing rules, where most cases consist of several more case \ndistinctions, like e being .nal or not. So some cases can get quite long (e.g., the proof for method \ncall has about 150 lines of proof script). 7.4 Preservation To achieve type safety we have have to show \nthat all of the assump\u00adtions in the Progress theorem above are preserved by the small steps rules. First, \nwe consider the heap conformance: If wf-C-prog P and P,E ..e,(h, l)...e,(h . , l ). and P,E,h .e : T \nand P .h v then P .h . v . We proof this by induction on the small step rules. Most cases are straightforward, \nthe only work lies in the rules which alter the heap, namely the ones for creation of new objects and \n.eld assignment. Next, we need a similar rule for the conformance of the store. To prove this, we need \nto assume that the program is well-formed, the environment conforms to it and the expression is well \ntyped in the run-time type system: If wf-C-prog P and P,E ..e,(h, l)...e. ,(h . ,vl ). and P,E,h .e : \nT and P,h .l (:=)w E and P .E then P,h . .l. (:=)w E. Here, the interesting cases from the small step \nrule induction are those that change the locals, namely variable assignment and blocks with locally declared \nvariables. Furthermore, also de.nite assignment needs to be preserved by the semantics. The corresponding \nlemma is easily proved by induction on the small step rules: If wf-C-prog P and P,E ..e,(h, l)...e. ,(h \n. , l ). and De .dom l. then De . .dom l.. Finally we have to show that the semantics preserves well\u00adtypedness. \nPreservation of well-typedness here means that the type of the reduced expression is equal to that of \nthe original expression or, if the original expression had a class type, the type may reduce to the null \ntype. This is formalised via the type-conf property from \u00a77.2: If wf-C-prog P and P,E ..e,s...e. ,s . \nand P,E .s v and P,E,hp s .e : T then P,E,hp s . .e . :NT T. where hp s is the heap component of s. This \nproof is quite lengthy because the most complicated cases (mostly method call and .eld assignment) of \nthe 68 small step rules can have up to 80 lines of proof script each (the screenshot in Fig. 10 shows \nthe .rst case of the proof). 7.5 The Type Safety Proof All the preservation lemmas only work one step \n. We have to extend them from . to . *, which is done by induction (because of the equivalence of big \nand small step semantics mentioned in \u00a76.4, all these lemmas now also hold for the big step rules). Now \ncombining type preservation with progress yields the main theorem: v If wf-C-prog P and P,E .s and P,E \n.e :: T and De .dom (lcl s). and P,E ..e,s..* .e ,s. and \u00ac(.e . s. e . . P,E ..e . ,s ...,s.) then (.v. \ne . = Val v .P,hp s . .v :=T) . (.r. e = Throw r .the-addr (Ref r) .dom (hp s )). If the program is well-formed, \nstate s conforms to it, e has type T and passes the de.nite assignment test w.r.t. dom (lcl s) (where \nlcl s is the store component of s) and its .-normal form is e, then the following property holds: either \ne. is a value of type T (or NT, if T is of type class) or an exception Throw r such that the address \npart of r is a valid address in the heap.  8. Evolution of the Semantics The semantics presented in \nthis paper has gone through several stages. This section will discuss a few example steps in the evo\u00adlution \nof the speci.cation. 8.1 Addresses, references and object structure From the beginning, it was clear \nthat objects in the heap have to comprise an object s dynamic class, a subobject, and the values stored \nin the object s .elds. We initially thought that pointers to objects could be identi.ed by just an address. \nHowever, by studying the behaviours of static casts and .eld operations, we soon realized that we need \nto keep track of the subobject that is currently being pointed to. Our .rst attempt was to incorporate \nthis information in the object description itself, so objects became a triple with a path (the only way \nto uniquely identify a subobject) as a third component: obj = cname \u00d7 path \u00d7 (path . vname . val ) However, \nin the presence of multiple pointers to some object o, each of these pointers may point to a different \nsubobject of o, and hard-coding subobject information in o itself is clearly insuf.cient. Realizing this, \nwe removed the path component from the object and included it with the pointer (which we now call a reference), \nwhich is similar to how C++ works. Moreover, for technical reasons, we replaced the mapping from paths \nto the variable maps by a set of tuples with these two components. Thus, we arrived at the object representation \nthat we are using now: obj = cname \u00d7 (path \u00d7 (vname . val )) set Ref reference, where reference = addr \n\u00d7 path  8.2 Eliminating exceptions by using static type information A big issue was how to handle method \ncalls that become ambigu\u00adous at run-time. As already stated in the discussion of example 3 in \u00a72.4, we \ninitially considered the use of static information to re\u00adsolve dynamically dispatched calls contrary \nto the idea of dynamic dispatch. Following this line of reasoning, we argued that a method call that \nis ambiguous at runtime should not be resolved but should throw a MemberAmbiguousException instead. So \nthe rule looked as follows: P ..e,s0...ref (a,Cs),s1. P ..ps,s1.[.] .mapVal vs,(h2,l2). h2 a = Some(C,S) \n.TsTpns bodyCs. . \u00acP .Chas least M =(Ts,T,pns,body) via Cs. P ..e\u00b7M(ps),s0...THROWMemberAmbiguous,(h2,l2). \n A similar issue arose in the presence of overridden methods with covariant return types. Consider, \nfor example, a situation where the result of a method call (a reference) is assigned to a variable, and \nwhere there exists an overriding de.nition of the method under consideration with a smaller return type. \nThen, by assigning the returned reference to the variable, the reference may receive a supertype to its \nactual type (given by the last class in its path component). Because of this it was possible to have \nreferences with a gap between the last class in its path component and the static class given by the \n(run-time) type system. In the .eld access and .eld assignment rules one needed to .ll this gap by introducing \nin the rules a third path. We could not always guarantee this third path to be unique, and also threw \nthe MemberAmbiguousException when this was not the case. However, realizing that the introduction of \na new exception takes us away from the semantics of C++, we adopted the use of static information in \nboth cases to eliminate the MemberAmbigu\u00adousException exception. To this end, we introduced the term \nof an overrider which enabled us to use static information to make a dy\u00adnamically ambiguous method call \nunique. Of course, the resulting method call rule is quite intricate and requires auxiliary predicates. \nTo close the gap between the last class of a reference and the class computed by the type system we extended \nassignment and method call rules with explicit casts to the static type. Thus the need for the exception \ndisappeared.  9. Working with Isabelle This section is written for the bene.t of readers unfamiliar \nwith au\u00adtomated theorem provers. So far they may have gotten the impres\u00adsion that, given all the de.nitions \nand the statement of a lemma, Isabelle proves it automatically. Unfortunately, formal proofs still require \nmuch effort by an expert user, a limitation Isabelle shares with all such proof systems. A proof is an \ninteractive process, a dialogue where the user has to provide the overall proof structure and the system \nchecks its correctness but also offers a number of tools for .lling in missing details. Chief among these \ntools are the simpli.er (for simplifying formulae) and the logical reasoner (for proving predicate calculus \nformulae automatically). Most of the proofs in the present paper are written in Isar [38], a language \nof structured and stylized mathematical proofs understandable to both machines and humans. This proof \nlanguage is invaluable when constructing, communicating and maintaining large proofs. Fig. 10 shows a \nscreenshot of Proof General [1], Isabelle s GUI, which turns the XEmacs editor into a front end for Isabelle \nthat supports interactive proof construction. In the main window the reader can see a fragment of an \nIsar proof text. Other windows show the context, e.g. assumptions currently available, and diagnostic \ninformation, e.g. if a proof step succeeded or failed. Isabelle also supports the creation of LATEX documents \n(such as this paper) based on Isabelle input .les: LATEX text may contain references to de.nitions and \nlemmas in Isabelle .les and Isabelle will automatically substitute those references by pretty printed \nand typeset versions of the respective formulae. This is similar to and has all the advantages of literate \nprogramming . 10. Execution Isabelle furthermore enables one to automatically create ML .les from theories \n( rapid prototyping ) by using its built-in code gener\u00adator [3]. We have done so for the semantics and \nthe type system. To check real C++ programs restricted to the statements our seman\u00adtics can handle against \nour semantics, we implemented an eclipse plugin to parse C++ programs to ML. In the result the abstract \nsyn\u00adtax from Fig. 4 is coded as ML expressions. It is also possible to write these ML .les manually. \nBy executing these ML .les the generated semantics .les and the translated C++ program with an ML interpreter \n(e.g. PolyML) one can check if the program can be typed and if so, with which type, and what result executing \nthe semantics on the programs will return i.e. if the semantics does what it should, compared to the \nC++ standard. This enables us to execute arbitrary programs in our type system and semantics and compare \nthe results with compiler runs. val classA : (string list * (base list * ((string list * ty) list * (string \nlist * (ty list * (ty * (string list list * expr)))) list))) = ([\"A\"],([],([([\"x\"],Integer)],[]))); \nval classB : (string list * (base list * ((string list * ty) list * (string list * (ty list * (ty * (string \nlist list * expr)))) list))) = ([\"B\"],([],([([\"x\"],Integer)],[])));  val classC : (string list * (base \nlist * ((string list * ty) list * (string list * (ty list * (ty * (string list list * expr)))) list))) \n= ([\"C\"],([Shares [\"A\"],Shares [\"B\"]],([([\"x\"],Integer)],[]))); val classD : (string list * (base list \n* ((string list * ty) list * (string list * (ty list * (ty * (string list list * expr)))) list))) = ([\"D\"],([Shares \n[\"A\"],Shares [\"B\"],Repeats [\"C\"]],([],[]))); val prog : (string list * (base list * ((string list * \nty) list * (string list * (ty list * (ty * (string list list * expr)))) list))) list = [classA, classB, \nclassC, classD]; val main = eval__1_2_3 prog ((fn uu => None), FAss (new [\"D\"], [\"x\"], [[\"D\"], [\"C\"]], \nVal (Intg 42)), ((fn uu => None), (fn uu => None))); Figure 11. ML code generated from Example 6 in \n\u00a72.4 As an example see the ML code generated from Example 6 in \u00a72.4 in Fig. 11. The de.nitions ClassA \nto ClassB are of type cdecl and prog of type prog as described in Fig. 4. main is the translation of \nthe main method of the C++ program, eval 123 is the name of the function which simulates the semantics \nexecution applied to program prog and the empty type environment, which is formulated via (fn uu . None). \nWhereas many compilers cannot handle this program even if it adheres to the C++ standard, typechecking \nand executing this code in our framework poses no problems and returns the expected results. Executability \nof our type system and semantics is a strong indicator that the formalisation is correct and does not \ncontain any .aws. 11. Related work There is a wealth of material on formal semantics of object-oriented \nlanguages, but to our knowledge, a formal semantics for a language with C++-style multiple inheritance \nhas not yet been presented. We distinguish several categories of related work. 11.1 Semantics of Multiple \nInheritance Cardelli [6] presents a formal semantics for a form of multiple in\u00adheritance based on structural \nsubtyping of record types, which also extends to function types. Another early paper that claims to give \na semantics to multiple inheritance for a language (PCF++) with record types is [5]. It is dif.cult to \nrelate the language constructs used in each of these works to the inheritance model of C++. 11.2 C++ \nMultiple Inheritance Wallace [36] presents an informal discussion of the semantics of many C++ constructs, \nbut avoids all the crucial issues. The natural semantics for C++ presented by Seligman [23] does not \ninclude multiple inheritance or covariant return types. Most closely related to our work is [9], where \nsome basic C++ data types (including structs but excluding pointers) are speci.ed in PVS; an object model \nis in preparation . The complexities introduced by C++-style multiple inheritance are manifold, and have \nto our knowledge never been formalized adequately or completely. In the C++ standard [29], the semantics \nof operations such as method calls and casts that involve class hierarchies are de.ned informally, while \nseveral other works (see, e.g., [27]) discuss the implementation of these operations in terms of compiler \ndata structures such as virtual function pointer tables Rossie and Friedman [21] were the .rst to formalize \nthe seman\u00adtics of operations on C++ class hierarchies in the form of a cal\u00adculus of subobjects, which \nforms the basis of our previous work on semantics-preserving class hierarchy transformations that was \nalready mentioned in \u00a71 [34, 24, 25, 26]. Ramalingam and Srinivasan [20] observe that a direct imple\u00admentation \nof Rossie and Friedman s de.nition of member lookup can be inef.cient because the size of a subobject \ngraph may be ex\u00adponential in the size of the corresponding class hierarchy graph. They present an ef.cient \nmember lookup algorithm for C++ that operates directly on the class hierarchy graph. However, like Rossie \nand Friedman, their de.nition does not follow C++ precisely in cases where static information is used \nto resolve ambiguities (see Example 3 in \u00a72.4). It has long been known that inheritance can be modeled \nusing a combination of additional .elds and methods (a mechanism com\u00admonly called delegation ) [12]. \nSeveral authors have suggested independently that multiple inheritance can be simulated using a combination \nof interfaces and delegation [33, 32, 35]. Nonetheless, all of these works stop well short of dealing \nwith the more intri\u00adcate aspects of modeling multiple inheritance such as object initial\u00adization, implicit \nand explicit type casts, instanceof-operations, and handling shared and repeated multiple inheritance. \nMultiple inheritance also poses signi.cant challenges for C++ compiler writers because the layout of \nan object can no longer re.ect a simple linearization of the class hierarchy. As a result, a considerable \namount of research effort has been devoted to the design of ef.cient object layout schemes for C++ [31, \n30, 40]. 11.3 Other Languages with Multiple Inheritance Various models of multiple inheritance are supported \nin other object-oriented languages, and we are aware of a number of pa\u00adpers that explore the semantic \nfoundations of these models. The work by Attali et al. [2] is similar to ours in spirit but treats Eiffel \nrather than C++, whose multiple inheritance model differs considerably. Eiffel uses shared inheritance \nby default; re\u00adpeated inheritance is not possible, instead repeated members must be uniquely renamed \nwhen inherited. In several recent languages such as Jx [16] and Concord [10], multiple inheritance arises \nas a result of allowing classes to over\u00adride other classes, in the spirit of BETA s virtual classes [13]. \nIn Jx [16], an outer class A1 can declare a nested class A1.B, which can be overridden by a nested class \nA2.B in a subclass A2 of A1.In this case, A2.B is a subclass of A1.B. Shared multiple inheritance arises \nwhen A2.B also has an explicitly de.ned superclass. Mem\u00adber lookup is de.ned quite differently than in \nC++ (implicit over\u00adriding inheritance takes precedence over explicit inheritance when selecting a member), \nbut appears to behave similarly in practice. Nystrom et al. present a type system, operational semantics \nand soundness proof for Jx, although the latter is not machine-checked. Concord [10] introduces a notion \nof groups of classes, where a group g may be extended by a subgroup g . An implicit form of inheritance \nexists between a class g.X declared in group g that is further bound by a class g .X in subgroup g , \ngiving rise to a simi\u00adlar form of shared multiple inheritance as in Jx. Two important dif\u00adferences, however, \nare the fact that further binding does not imply subtyping: g .X is not a subtype of g.X, and explicit \ninheritance takes precedence over implicit overriding when resolving method calls. Jolly et al. present \na type system and soundness proof (though not machine-checked) for Concord. Because repeated multiple \nin\u00adheritance is not supported in either Jx or Concord, the semantics for these languages can represent \nthe run-time type of an object as a simple type, and there is no need for the subobject and path information \nrequired for modeling C++. Scala [17] provides a mechanism for symmetrical mixin inher\u00aditance [4] in \nwhich a class can inherit members from multiple su\u00adperclasses. If members are inherited from two mixin \nclasses, the inheriting class has to resolve the con.ict by providing an explicit overriding de.nition. \nScala side-steps the issue of shared vs. re\u00adpeated multiple inheritance by simply disallowing a class \nto (indi\u00adrectly) inherit from a class that encapsulates state more than once (multiply inheriting from \nabstract classes that do not encapsulate state called traits is allowed, however). The semantic founda\u00adtions \nof Scala, including a type system and soundness proof can be found in [18].  12. Conclusion We have \npresented an operational semantics and type-safety proof for multiple inheritance in C++. The semantics \nprecisely models the behaviour of method calls, .eld accesses and two forms of casts in C++ class hierarchies, \nand allows one for the .rst time to understand the behaviour of these operations without referring to \nimplementation-level data structures such as virtual function pointer tables (v-tables). The type-safety \nproof was formalized and machine-checked using Isabelle/HOL. The paper discusses C++ features in the \nlight of the formal analysis, discusses a number of subtleties in the design of C++ that we encountered \nduring the construction of the semantics, and provides some background about its evolution. Trying to \nput C++ on a formal basis has been interesting but quite challenging at times. It was great fun .guring \nout what C++ means at an abstract level, and this exercise has demonstrated that its mixture of shared \nand repeated multiple inheritance gives rise to a lot of additional complexity at the semantics level. \n  Acknowledgments We thank Martin Dirndorfer for his work on the parser plugin for eclipse and the \nanonymous referees for their comments.  References [1] David Aspinall. Proof General a generic tool \nfor proof development. In S. Graf and M.I. Schwartzbach, editors, Tools and Algorithms for Construction \nand Analysis of Systems, TACAS 2000, volume 1785 of Lect. Notes in Comp. Sci., pages 38 42. Springer-Verlag, \n2000. [2] Isabelle Attali, Denis Caromel, and Sidi Ould Ehmety. A natural semantics for Eiffel dynamic \nbinding. ACM TOPLAS, 18(6):711 729, 1996. [3] Stefan Berghofer and Tobias Nipkow. Executing Higher Order \nLogic. In P. Callaghan, Z. Luo, J. McKinna, and R. Pollack, editors, Types for Proofs and Programs (TYPES \n2000), volume 2277 of LNCS. Springer-Verlag, 2002. [4] Gilad Bracha and William Cook. Mixin-based inheritance. \nIn Proc. of OOPSLA/ECOOP 90, pages 303 311, 1990. [5] V. Breazu-Tannen, C. A. Gunter, and A. Scedrov. \nComputing with coercions. In Proc. ACM Conf. LISP and functional programming, pages 44 60. ACM Press, \n1990. [6] Luca Cardelli. A semantics of multiple inheritance. Information and Computation, 76:138 164, \n1988. [7] Luca Cardelli. Type systems. In The Computer Science and Engineering Handbook. 2 edition, 2004. \n [8] Sophia Drossopoulou and Susan Eisenbach. Java is type safe probably. In Proc. of ECOOP 97, volume \n1241 of Lect. Notes in Comp. Sci., pages 389 418, 1997. [9] Michale Hohmuth and Hendrik Tews. The semantics \nof C++ data types: Towards verifying low-level system components. In D. Basin and B. Wolff, editors, \nTheorem Proving in Higher Order Logics, Emerging Trends Proc., pages 127 144. Universit\u00a8at Freiburg, \n2003. Tech. Rep. 187. [10] Paul Jolly, Sophia Drossopoulou, Christopher Anderson, and Klaus Ostermann. \nSimple dependent types: Concord. In Proc. of FTfJP 05, 2005. [11] Gerwin Klein and Tobias Nipkow. A machine-checked \nmodel for a Java-like language, virtual machine and compiler. ACM TOPLAS, 28(4):619 695, 2006. [12] Henry \nLieberman. Using prototypical objects to implement shared behavior in object-oriented systems. In Proc. \nof OOPSLA 86, pages 214 223, 1986. [13] Ole Lehrmann Madsen and Birger Moeller-Pedersen. Virtual classes: \nA powerful mechanism in object-oriented programming. In Proc. of OOPSLA 89, pages 397 406, 1989. [14] \nRobin Milner. A theory of type polymorphism in programming. Journal of Computer and System Sciences, \n17(3):348 375, 1978. [15] Tobias Nipkow, Lawrence Paulson, and Markus Wenzel. Isa\u00adbelle/HOL A Proof \nAssistant for Higher-Order Logic, volume 2283 of Lect. Notes in Comp. Sci. 2002. http://www.in.tum. de/ \nnipkow/LNCS2283/. [16] Nathaniel Nystrom, Stephen Chong, and Andrew. C. Myers. Scalable extensibility \nvia nested inheritance. In Proc. of OOPSLA 04, pages 99 115, 2004. [17] Martin Odersky, Philippe Altherr, \nVincent Cremet, Burak Emir, Sebastian Maneth, St\u00b4ephane Micheloud, Nikolay Mihaylov, Michel Schinz, Erik \nStenman, and Matthias Zenger. An overview of the Scala programming language. Technical Report IC/2004/64, \nEcole \u00b4 Polytechnique F\u00b4ed\u00b4erale de Lausanne, Lausanne, Switzerland, 2004. Available from scala.epfl.ch. \n[18] Martin Odersky, Vincent Cremet, Christine R\u00a8ockl, and Matthias Zenger. A nominal theory of objects \nwith dependent types. In Proc. of ECOOP 03. [19] Benjamin C. Pierce. Types and Programming Languages. \nThe MIT Press, 2002. [20] G. Ramalingam and Harini Srinivasan. A member lookup algorithm for C++. In \nProc. of PLDI 97, pages 18 30, 1997. [21] Jonathan G. Rossie, Jr. and Daniel P. Friedman. An algebraic \nsemantics of subobjects. In Proc. of OOPSLA 95, pages 187 199. ACM Press, 1995. [22] Jonathan G. Rossie, \nJr., Daniel P. Friedman, and Mitchell Wand. Modeling subobject-based inheritance. In Proc. of ECOOP 96, \nvolume 1098 of Lect. Notes in Comp. Sci., pages 248 274, 1996. [23] Adam Seligman. FACTS: A formal analysis \nfor C++. Williams College, 1995. Undergraduate thesis. [24] Gregor Snelting and Frank Tip. Understanding \nclass hierarchies using concept analysis. ACM TOPLAS, pages 540 582, 2000. [25] Gregor Snelting and Frank \nTip. Semantics-based composition of class hierarchies. In Proc. of ECOOP 02, volume 2374 of Lect. Notes \nin Comp. Sci., pages 562 584, 2002. [26] Mirko Streckenbach and Gregor Snelting. Refactoring Class Hierarchies \nwith KABA. In Proc. of OOPSLA 04, pages 315 330, 2004. [27] Bjarne Stroustrup. Multiple inheritance for \nC++. Computing Systems, 2(4), 1989. [28] Bjarne Stroustrup. The Design and Evolution of C++. Addison \nWesley, 1994. [29] Bjarne Stroustrup. The C++ Standard: Incorporating Technical Corrigendum No. 1. John \nWiley, 2 edition, 2003. [30] Peter F. Sweeney and Michael G. Burke. Quantifying and evaluating the space \noverhead for alternative C++ memory layouts. Software: Practice and Experience, 33(7):595 636, 2003. \n[31] Peter F. Sweeney and Joseph Gil. Space and time-ef.cient memory layout for multiple inheritance. \nIn Proc. of OOPSLA 99, pages 256 275, 1999. [32] Ewan Tempero and Robert Biddle. Simulating multiple \ninheritance in Java. Journal of Systems and Software, 55:87 100, 2000. [33] Krishnaprasad Thirunarayan, \nG\u00a8unter Kniesel, and Haripriyan Hampapuram. Simulating multiple inheritance and generics in Java. Computer \nLanguages, 25:189 210, 1999. [34] Frank Tip and Peter Sweeney. Class hierarchy specialization. Acta Informatica, \n36:927 982, 2000. [35] John Viega, Bill Tutt, and Reimer Behrends. Automated delegation is a viable alternative \nto multiple inheritance in class based languages. Technical Report CS-98-3, University of Virginia, 1998. \n[36] Charles Wallace. The semantics of the C++ programming language. In E. B\u00a8 orger, editor, Speci.cation \nand Validation Methods, pages 131 164. Oxford University Press, 1995. [37] Daniel Wasserrab, Tobias Nipkow, \nGregor Snelting, and Frank Tip. An Operational Semantics and Type Safety Proof for C++-like Multiple \nInheritance. Technical Report RC23709, IBM, 2005. [38] Markus Wenzel. Isabelle/Isar A Versatile Environment \nfor Human-Readable Formal Proof Documents. PhD thesis, Institut f\u00a8ur Informatik, Technische Universit\u00a8at \nM\u00a8unchen, 2002. http: //tumb1.biblio.tu-muenchen.de/publ/diss/in/ 2002/wenzel.html. [39] Andrew K. Wright \nand Matthias Felleisen. A syntactic approach to type soundness. Information and Computation, (115):38 \n94, 1994. [40] Yoav Zibin and Joseph Gil. Two-dimensional bi-directional object layout. In Proc. of ECOOP \n03, volume 3013 of Lect. Notes in Comp. Sci., pages 329 350, 2003. A. Appendix new-Addrh = None P,E \n..e,s0...ref (a, Cs),s1.\u00acP .last Cs . * C P,E ..new C, (h,l)...THROWOutOfMemory,(h,l). P,E ..stat cast \nCe,s0...THROWClassCast,s1. P,E ..e,s0...null ,s1. P,E ..e1,s0...null ,s1. P,E ..e2,s1...Val v,s2. P,E \n..e\u00b7F{Cs},s0...THROWNullPointer,s1. P,E ..e1\u00b7F{Cs}:=e2,s0...THROWNullPointer,s1. P,E ..e,s0...null ,s1. \nP,E ..ps,s1.[.] .map Val vs,s2. P,E ..e\u00b7M(ps),s0...THROWNullPointer,s2. Figure 12. Big Step exception \nthrowing rules new-Addrh = .a. h. = h(a .(C, init-objPC )) P,E ..new C,(h, l)...ref (a, [C]),(h. , l). \nP,E ..e,s...e,sP .path last Cs to Cvia Cs. Ds = Cs @p Cs. P,E ..stat cast Ce,s...stat cast Ce. ,s. P,E \n..stat cast C (ref (a, Cs)),s...ref (a, Ds),s. P,E ..stat cast C (ref (a, Cs @[C]@ Cs)),s...ref (a, Cs \n@[C]),s. P,E ..e,s...e,s. P,E ..dyn cast C (ref (a, Cs @[C]@ Cs)),s...ref (a, Cs @[C]),s. P,E ..dyn \ncast Ce,s...dyn cast Ce. ,s. P .path last Cs to Cunique P .path last Cs to Cvia Cs. Ds = Cs @p Cs. P,E \n..dyn cast C (ref (a, Cs)),s...ref (a, Ds),s. hpsa = .(D, S). P .path Dto Cvia Cs. P .path Dto Cunique \n P,E ..dyn cast C (ref (a, Cs)),s...ref (a, Cs),s. hpsa = .(D, S).\u00acP .path Dto Cunique \u00acP .path last \nCs to Cunique C ./set Cs P,E ..dyn cast C (ref (a, Cs)),s...null ,s. . . P,E ..e,s...e,sP,E ..e,s...e,s. \n. P,E ..e .bop. e2,s...e.bop. e2,sP,E ..Val v1 .bop. e,s...Val v1 .bop. e,sbinop (bop, v1, v2)= .v. P,E \n..Val v1 .bop. Val v2,s...Val v,s. P,E ..e,s...e,s. EV = .T. P .Tcasts v to v P,E ..V:= e,s...V:= e,s. \nP,E ..V:= Val v,(h, l)...Val v,(h, l(V .v)). P,E ..e,s...e,shpsa = .(D, S). Ds = Cs. @p Cs (Ds, fs) \n.S fsF = .v. P,E ..e.F{Cs},s...e.F{Cs},sP,E ..ref (a, Cs).F{Cs},s...Val v,s. P,E ..e,s...e,s. P,E ..e,s...e,s. \nP,E ..e.F{Cs}:= e2,s...e. .F{Cs}:= e2,s. P,E ..Val v.F{Cs}:= e,s...Val v.F{Cs}:= e. ,s. ha = .(D, S). \nP .last Cs . has least F : Tvia Cs P .Tcasts v to vDs = Cs. @p Cs (Ds, fs) .S P,E ..ref (a, Cs).F{Cs}:= \nVal v,(h, l)...Val v,(h(a ))}.(S -{(Ds, fs)}))), l). .(D, {(Ds, fs(F .v P,E ..e,s...e,s. P,E ..es,s.[.] \n.es ,s. P,E ..e.M(es),s...e.M(es),s. P,E ..Val v.M(es),s...Val v.M(es ),s. hpsa = .(C, S). P .last Cs \nhas least M =(Ts. , T. , pns , body ) via Ds P .(C, Cs @p Ds) selects M =(Ts, T, pns, body) via Cs. length \nvs = length pns length Ts = length pns bs = blocks (this\u00b7pns, Class (last Cs )\u00b7Ts, Ref (a, Cs)\u00b7vs, body) \nnew-body =(case T. of ClassD .stat cast Dbs |-.bs) P,E ..ref (a, Cs).M(map Val vs),s...new-body,s. blocks \n(V\u00b7Vs, T\u00b7Ts, v\u00b7vs, e)= {V:T; V:= Val v; blocks (Vs, Ts, vs, e)}blocks ([], [], [], e)= e Figure 13. Small \nStep rules  \n\t\t\t", "proc_id": "1167473", "abstract": "We present an operational semantics and type safety proof for multiple inheritance in C++. The semantics models the behaviour of method calls, field accesses, and two forms of casts in C++ class hierarchies exactly, and the type safety proof was formalized and machine-checked in Isabelle/HOL. Our semantics enables one, for the first time, to understand the behaviour of operations on C++ class hierarchies without referring to implementation-level artifacts such as virtual function tables. Moreover, it can - as the semantics is executable - act as a reference for compilers, and it can form the basis for more advanced correctness proofs of, e.g., automated program transformations. The paper presents the semantics and type safety proof, and a discussion of the many subtleties that we encountered in modeling the intricate multiple inheritance model of C++.", "authors": [{"name": "Daniel Wasserrab", "author_profile_id": "81319504084", "affiliation": "Universit&#228;t Passau", "person_id": "P813668", "email_address": "", "orcid_id": ""}, {"name": "Tobias Nipkow", "author_profile_id": "81100147685", "affiliation": "Technische Universit&#228;t M&#252;nchen", "person_id": "PP39029747", "email_address": "", "orcid_id": ""}, {"name": "Gregor Snelting", "author_profile_id": "81100482381", "affiliation": "Universit&#228;t Passau", "person_id": "PP43121149", "email_address": "", "orcid_id": ""}, {"name": "Frank Tip", "author_profile_id": "81100333471", "affiliation": "IBM T.J. Watson Research Center", "person_id": "PP15029416", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167503", "year": "2006", "article_id": "1167503", "conference": "OOPSLA", "title": "An operational semantics and type safety prooffor multiple inheritance in C++", "url": "http://dl.acm.org/citation.cfm?id=1167503"}