{"article_publication_date": "10-16-2006", "fulltext": "\n A Framework for Implementing Pluggable Type Systems Chris Andreae and James Noble Victoria University \nof Wellington {chris,kjx}@mcs.vuw.ac.nz Abstract Pluggable types have been proposed to support multiple \ntype systems in the same programming language. We have designed and implemented JAVACOP, a program constraint \nsystem for im\u00adplementing practical pluggable type systems for Java. JAVACOP enforces user-de.ned typing \nconstraints written in a declarative and expressive rule language. We have validated our design by (re)implementing \na range of type systems and program checkers. By using a program constraint system to implement pluggable \ntypes, programmers are able to check that their programs will oper\u00adate correctly in restricted environments, \nadhere to strict program\u00adming rules, avoid null pointer errors or scoped memory excep\u00adtions, and meet \nstyle guidelines, while programming language re\u00adsearchers can easily experiment with novel type systems. \nCategories and Subject Descriptors D.1.5 [Programming Tech\u00adniques]: Object-oriented Programming; D.2.1 \n[Software Engi\u00adneering]: Requirements/Speci.cations Tools General Terms Design, Languages, Reliability \nKeywords JavaCOP, pluggable type systems 1. Introduction Many researchers have noticed that traditional \ntype systems do not enforce all of the kinds of constraints that may be useful for pro\u00adgrammers. A common \nway to address these limitations is to de.ne an extension to a base type system that introduces new constraints \non programs, often in conjunction with new program annotations. For example, a nonnull annotation can \nbe used to require a vari\u00adable to never point to null [26], a confined annotation can be used to ensure \nthat no references to instances of a class can escape the class s package [49], and various kinds of \nreadonly annotations can be used to ensure that an object reference is not modi.ed [7]. Unfortunately, \nlanguage designers cannot anticipate all of the constraints and conventions that programmers will want \nto spec\u00adify, nor can they anticipate all of the practical ways in which such properties can be checked. \nFurther, different rules may be impor\u00adtant to enforce in different programs, and it would be too unwieldy \nto require all programs to obey all rules all of the time. Therefore it is desirable to provide a framework \nfor user-de.ned type sys\u00adtems. Bracha has previously identi.ed the need for such a frame\u00adwork, coining \nthe term pluggable types for the resulting system [8]. Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 06 October 22 26, 2006, Portland, Oregon, USA. Copyright \nc . 2006 ACM 1-59593-348-4/06/0010. . . $5.00. Shane Markstrum and Todd Millstein University of California, \nLos Angeles {smarkstr,todd}@cs.ucla.edu Aside from its clear bene.ts to programmers, a framework for \nplug\u00adgable type systems is also bene.cial to programming language re\u00adsearchers, who can use such a framework \nto experiment easily with novel type systems. In this paper, we present the design, implementation, and \neval\u00aduation of a practical framework for implementing pluggable type systems in Java [3, 32], which we \ncall JAVACOP ( Constraints On Programs ). We have designed a declarative rule language in which programmers \nmay specify their pluggable type systems. User-de.ned rules work over a rich abstract syntax tree (AST) \nrep\u00adresentation for Java 1.5 programs and can refer to user-de.ned type information, which is expressed \nas annotations in Java 1.5 s meta\u00addata facility [6]. JAVACOP then automatically enforces these rules \non programs as they are compiled. As a simple example, consider the following code which uses a @NonNull \nannotation to specify the additional type constraint that the .eld firstname (of Java type String)may \nneverbenull. class Person { @NonNull String firstname = \"Chris\"; void setFirstName(String newname) \n { firstname = newname; } } Clearly, the assignment to firstname within setFirstName is potentially \nerroneous, since newname may be null. It is straight\u00adforward for a user to write a JAVACOP rule that \nwould discover this potential error. For example, the JAVACOP rule below requires the right-hand-side \nexpression of each assignment statement to be demonstrably nonnull whenever the type of the left-hand-side \nvari\u00adable or .eld is declared as such. rule checkNonNull(Assign a){ where(requiresNonNull(a.lhs)){ require(definitelyNotNull(a.rhs)): \nerror(a,\"Possible null assignment\" + \" to @NonNull\"); } }  This rule relies on two user-de.ned helper \npredicates. The requiresNonNull predicate checks that the given vari\u00adable or .eld was declared with the \n@NonNull attribute. The definitelyNotNull predicate inspects the given expres\u00adsion to determine if it \nis de.nitely nonnull. For example, definitelyNotNull would de.ne literals other than null to be nonnull. \nAssuming definitelyNotNull does not allow an arbitrary variable to be considered nonnull, the assignment \nto firstname in setFirstName will fail our rule, causing the com\u00adpiler to output the following error \nmessage: Person.java:4: Possible null assignment to @NonNull { firstname = newname; } 1 error As detailed \nin Section 5, there have been several prior systems that allow user-de.ned constraints to be enforced \non programs. JAVACOP is distinguished by a novel combination of features that is targeted to support \nthe development of practical pluggable type systems: JAVACOP leverages Java 1.5 s metadata facility \nto allow users to introduce additional type speci.cations. Java s annotations cannot be placed directly \non types, but only on declarations. As such, JAVACOP supports two main kinds of annotations for pluggable \ntypes. First, an annotation on a class declaration can be used to indicate that all values of the Java \ntype correspond\u00ading to that class satisfy some additional properties. For exam\u00adple, the declaration of \na class C can be annotated as @Confined to indicate that no instance of that class will escape the class \ns package. Second, an annotation on a variable (local or formal) or .eld declaration can be used to indicate \nthat a particular vari\u00adable or .eld satis.es some additional properties. For example, in our Person class \nabove, the firstname .eld is declared to be both a String and to be never null.  JAVACOP employs a declarative, \nrule-based language for ex\u00adpressing the semantics of these new annotations. While it would be possible \nto write the rules directly in Java with respect to an AST API, we believe rules in JAVACOP s language \nwill be signi.cantly easier for rule designers and programmers to un\u00adderstand and de.ne correctly. Further, \nour rule-based language has a natural correspondence with the traditional way in which syntax-directed \ntype rules are speci.ed.  JAVACOP makes it possible for user-de.ned types speci.ed using annotations \nto interact with Java s existing type system. This is a natural expectation for user-de.ned type systems; \nfor example, consider the @NonNull annotation. A user may want to ensure that this annotation is only \nemployed on declarations of variables or .elds of reference type, rather than of primitive type. To achieve \nthis, the AST abstraction over which JAVACOP rules work includes full Java type information about program \nentities, including information about type parameterization aris\u00ading from Java 1.5 s generics. The AST \nabstraction also includes other information that depends on types, for example the set of methods that \na given method overrides. User-de.ned rules can then easily access this information. Operationally, JAVA-COP \nenforces user-de.ned constraints only after regular Java typechecking has occurred.  Since Java includes \nsubtyping as a fundamental part of its type system, it is expected that user-de.ned types will also naturally \nhave interesting relationships to one another and to existing types. For example, a user may want to \ndisallow a @Confined type S from being considered a subtype of an uncon.ned super\u00adtype T, in order to \nprevent values of type S from escaping their package through that supertype. The JAVACOP rule language \nincludes special facilities that allow users to easily de.ne these kinds of relationships.  A key feature \nof Java s type system is modularity: each com\u00adpilation unit can be typechecked in isolation, given only \nin\u00adterface information about directly-mentioned types (e.g., de\u00adclared supertypes and the types of .elds). \nThis information can be gleaned from bytecode, without access to the associated Java source. All other \ntypes need not be present for the class to be properly typechecked and can therefore be easily changed \naf\u00adter the fact. JAVACOP maintains the exact same modularity as Java s type system: user-de.ned rules \nare enforced by JAVA-COP on each compilation unit individually, given only inter\u00adfaceinformationaboutdepended-upontypes.Inthisway, \nJAVA-  COP integrates naturally with existing Java compiler frame\u00ad works. Checking each compilation \nunit individually does have some liabilities. For example, an apparently simple rule such as My- Package \nmust contain exactly one class cannot be checked with JAVACOP, because JAVACOP will never see the entire \npackage, only the individual classes of which it is comprised. Given JAVACOP s place in the development \nlife-cycle and the kind of syntax-directed local rules JAVACOP is designed to check, we consider modularity \na valid design tradeoff. Further, in some cases rules can be reformulated so that JAVACOP can check them \nmodularly (e.g., JAVACOP can enforce the rule classes in MyPackage must be named MyClass ,and Java s \nnaming rules will ensure that MyClass is unique). We have implemented the JAVACOP framework as two log\u00adically \nindependent components. First, we have extended Sun s javac compiler, which is written in Java, with \na Java API that provides a clean interface to the compiler s internal AST and type structures. Just before \ncode generation, a new pass in the compiler executes Java code that employs this API in order to enforce \ncon\u00adstraints on the program being compiled. Second, we have imple\u00admented a component that translates \nconstraints in the JAVACOP rule language to Java code employing our new API. This separa\u00adtion of concerns \nallows the JAVACOP rule language to easily evolve without requiring modi.cations to the javac compiler, \nand it ad\u00admits the possibility of easily incorporating multiple languages for enforcing constraints on \nprograms. We have validated the JAVACOP framework in several ways. First, we illustrate the framework \ns expressiveness and practical\u00adity by replicating a number of interesting type systems from the literature, \nincluding con.ned types, scoped types, types for race detection, nonnull types, types for immutability, \nand generic own\u00adership types [49, 51, 27, 5, 47, 44]. We have also implemented several style and convention \ncheckers, including an EJB3.0 ver\u00adi.er [21], as well as various code pattern detectors [18, 31] and metrics \ntools [13]. Finally, we have tested the performance of the JAVACOP framework. In the worst case, the \naddition of JAVACOP rule checking increases total compile time by a factor of two. The rest of this paper \nis structured as follows. Section 2 intro\u00adduces the design of JAVACOP s rule language through a number \nof examples. Section 3, as well as the appendix, present additional ex\u00adamples illustrating the .exibility \nof the framework. Section 4 pro\u00advides details on the framework s implementation. Section 5 dis\u00adcusses \nrelated work to JAVACOP, and Section 6 concludes and dis\u00adcusses future directions. 2. The JavaCOP Rule \nLanguage This section describes JAVACOP s rule language in detail. The .rst part describes some of the \nfeatures of the AST representation of programs that the language employs. The rest of the section de\u00adscribes \nthe features of the JAVACOP rule language, and their utility in implementing pluggable type systems, \nvia several examples. 2.1 The Abstract Syntax Tree The AST of a Java program is made up of linked nodes \nrepresent\u00ading the program s structure: classes, methods, blocks, statements, expressions, identi.ers, \netc. JAVACOP s AST is an abstraction of javac s AST and contains more than 50 separate node types, all \nsubclasses of the abstract superclass Tree. Figure 1 lists a selection of the main AST nodes and the \nJava code they represent. As usual, each node provides methods to access its sub-nodes. JAVACOP s traversal \nof the AST occurs as a pass after type\u00adchecking has occurred. This allows JAVACOP rules to make use of \ntype information, which is critical for many kinds of type exten\u00adFigure 1. A selection of AST nodes classes \nand their meanings Tree subclass Name Java example Apply Method call meth(args) Assign Assignment x=y \nClassDef Class de.nition class X{ .. } Ident Identi.er foo If Conditional if(cond).. [else ..] MethodDef \nMethod de.nition void foo(){..} NewClass Instance creation new World(\"hello\") Return Return statement \nreturn false; Select Selection s.field Skip Empty statement {;} TopLevel Compilation unit TypeCast Cast \n(String)s VarDef Variable declaration String s = \"hello\"; sions. Every node in the AST contains a type \n.eld of type Type, which is set during the typechecking pass and represents the Java type of the expression \nrepresented by the node. These types include class types (which may be parameterized), array types, method \ntypes, and (bounded) type parameters; Java interfaces are repre\u00adsented by class types internally. Types \nhave methods that allow their component types to be accessed, and class types have meth\u00adods that allow \ntheir direct superclass (supertype()) and superin\u00adterfaces (interfaces()) to be retrieved. In order for \na class to be compiled, javac requires information about each nonlocal identi.er package, class, interface, \nmethod, and .eld name that is referenced in the class. If javac were a whole-program compiler, each \nidenti.er could simply be linked to the AST node for its associated de.nition. However, given javac s \nmodular style of compilation, the source of some depended-upon program entities, and hence AST nodes \nfor those entities, may be unavailable. Instead, javac reconstructs the necessary information about nonlocal \nentities from their bytecode representations, and stores it as Symbol objects. The JAVACOP AST includes \nan abstraction of this notion of symbols, thereby allowing users to modularly access infor\u00admation about \nnonlocal identi.ers in their rules. For example, a ClassSymbol contains the relevant information about \na nonlocal class, including its supertypes, modi.ers, metadata, and the types of its accessible methods \nand .elds. For uniformity, every identi\u00ad.er, whether to a local or nonlocal entity, has access to a Symbol \nobject representing the entity being identi.ed. Additionally, the AST nodes representing classes, methods, \netc., as well as the corre\u00adsponding kinds of Type objects, have a method sym() that provides access to \nthe associated Symbol. While JAVACOP s AST abstraction is currently built on top of the AST representation \nin javac, there is a separation between the two. For example, JAVACOP s AST nodes include several useful \nmethods that are not directly available in the underlying javac nodes, but instead get translated to \nthe appropriate chain of method invocations. Because of this separation, we hope to be able to move the \nJAVACOP system to another compiler without changing the rule language. We plan to explore the integration \nof JAVACOP with the Eclipse framework.  2.2 Rule Language Overview Figure 2 presents the syntax of the \nJAVACOP rule language. A pluggable type system is implemented in JAVACOP as a set of rules, which constrain \nclasses via the AST representation described in the previous subsection. Each rule is declared to apply \nto a par\u00adticular kind of AST node and provides constraints on the usage of that node, depending on type \ninformation, user-de.ned annota\u00adtions, and other context information available at that node. To en\u00ad \n(RuleFile)::= ((Rule)|(Declaration))+ (Rule) ::= rule (Identi.er) ( (Joinpoint) ) (StatementList) (FailureClause)? \n(Declaration)::= declare (Identi.er) ( (VarDefList) ) (StatementList) (StatementList)::= { (Statement)+ \n} (JoinPoint)::= (VarDef ) |(Identi.er) <: (Identi.er) @ (Identi.er) |(Identi.er) <<: (Identi.er) (VarDefList)::= \n(VarDef )( , (VarDef ))* (VarDef )::= (TypeIdenti.er)(Identi.er) (FailureClause)::= : ( error | warning \n) ( (ValueExpression) , (Expression) ) (Statement)::= (Condition) |(Quanti.cation) (Condition)::=( where \n| require ) ( ((VarDefList) ; )? (Expression) ) (ConditionRest) (ConditionRest)::= (FailureClause)? ; \n|(StatementList)(FailureClause)? (Quanti.cation)::= ( forall | exists ) ( (VarDef ) : (Expression) ) \n(StatementList)(FailureClause)? Figure 2. A subset of the JAVACOP Syntax. Expression syntax is not presented \nhere, but handles most Java expressions and addition\u00adally supports declarative type testing and pattern \nmatching. force user-de.ned rules, JAVACOP performs a depth-.rst traversal of the AST of a given compilation \nunit (i.e., a Java .le). As each node is traversed, any rules that apply to that type of node are eval\u00aduated \non that node. As shown in Figure 2, there are three kinds of join points for JAVACOP rules, which determine \nwhen a rule is applicable to an AST node, and these are detailed in the next two subsections. We then \ndiscuss the various kinds of constraints that may be em\u00adployed within a rule body, the declare syntax \nfor de.ning helper predicates for use within a rule, and JAVACOP s facilities for error reporting. 2.3 \nAST Rules The .rst kind of JAVACOP rule in Figure 2 is a function that starts with the keyword rule and \nincludes a name, a single parameter whose type is a (subtype of) Tree, and a body containing a se\u00adquence \nof constraints. When JAVACOP s AST traversal visits a node, the node is passed to each rule that takes \nan argument of the node s type. For example, the checkNonNull rule de.ned in Section 1 will be passed \neach node representing a Java assignment statement during JAVACOP s traversal of an AST. As a result, \neach assignment statement will be forced to satisfy the constraints in the body of checkNonNull. There \nare several forms of constraints, which are discussed in detail in later subsections. As mentioned earlier, \nJAVACOP s AST abstraction provides full type information about program entities, which is often useful \nfor implementing pluggable type systems. As a simple example, the following rule ensures that the @NonNull \nannotation is only used for variables of reference type. rule checkNonNull2(VarDef v){ where( requiresNonNull(v)){ \nrequire(!v.type. isPrimitive ()): error(v,\"@NonNull can only annotate\" +\" variables of reference type\"); \n}}  2.4 Subtype Rules A hallmark of most object-oriented type systems is the notion of subtyping. An \nimportant part of static typechecking ensures that this subtyping relation is respected, such that values \nof a given type can only ever be viewed as that type or a supertype. For example, the type of the right-hand \nside in an assignment statement must be a subtype of the type of the location being assigned, and the \nactual arguments to a method call must be subtypes of the corresponding formal argument types. Pluggable \ntype systems for a language like Java naturally re\u00adquire the ability to extend the existing subtyping \nrelation, in order to prescribe the ways in which the new user-de.ned type speci.\u00adcations interact with \nother types, both Java types and user-de.ned ones. JAVACOP s rule language supports the declarative speci.cation \nof user-de.ned subtyping relationships. For example, as mentioned earlier, the goal of a type system \nfor con.nement [49] is to ensure that instances of types that are marked as con.ned are only acces\u00adsible \nwithin the type s de.ning package. To achieve this goal, such a type system imposes a number of restrictions \non con.ned types. The rule below enforces one such restriction, which disallows a value of con.ned type \nfrom being viewed at an uncon.ned su\u00adpertype. The confined predicate used in the rule checks whether \na given type is annotated with @Confined. rule checkConfined(a <: b @ e){ where( confined (a )){ require( \nconfined (b )): error(e, \"Confined type \"+a +\" may not be treated as a subtype of\" +\"unconfined type \n\"+b); }} The only syntactic difference from the AST rule syn\u00adtax described earlier is the parameter \nlist of the form Type <: Type @ Tree. The rule applies to any AST node that (implicitly or explicitly) \nchanges the type of an expression, includ\u00ading assignment statements, parameter passing, result returning, \nand type casts. A rule in this style takes as arguments the original type of an expression (a in the \nabove rule), the type to which the ex\u00adpression is being changed (b), and the expression itself (e). During \nan AST traversal, the checkConfined rule will be applied to every node that changes the view of an expression \ns type. At each such node, JAVACOP retrieves the old and new types as well as the ex\u00adpression in question \nand passes them to the rule. A node may have multiple such expressions (for example, a method call with \nmulti\u00adple arguments), leading to multiple calls of checkConfined when that node is traversed. As mentioned \nin the introduction, JAVACOP allows users to de.ne two main kinds of type speci.cations, those that annotate \ntype declarations (e.g., @Confined) and those that annotate variable and .eld declarations (e.g., @NonNull). \nThe <: construct described above is suitable for the .rst kind of type speci.cation but not the second, \nsince the latter kind of speci.cation is not a property of a type but of a particular variable or .eld. \nTherefore, we introduce an alternate syntax of the form Tree <<: Symbol for expressing subtype constraints \non those kinds of type speci.cations. For exam\u00adple, the rule below subsumes the checkNonNull rule in \nSection 1 by ensuring a potentially null expression can never be viewed as @NonNull. rule checkNonNull(node \n<<: sym){ where( requiresNonNull (sym )){ require( definitelyNonNull ( node )): error(node, \"Possibly \nnull expression \"+ node+\" considered @NonNull\"); }}  The above rule is applicable to the same AST nodes \nas is the earlier checkConfined rule, except for type casts.1 Rather than comparing two Java types, however, \nrules of this new kind are passed the AST node for the expression being stored as well as the Symbol \nfor the variable or .eld that is being updated. At an assignment node, for example, the right-hand-side \nexpression is tested against the Symbol for the variable or .eld being assigned. 2.5 Constraints The \nbody of a JAVACOP rule consists of a sequence of constraints. The basic kind of constraint has the form \nrequire(<condition >); . Such a constraint is satis.ed if the associated condition evaluates to true; \notherwise the constraint fails. As a simple example, the rule below shows that JAVACOP can encode the \nsemantics of Java s final modi.er for classes, which requires a final class to have no subclasses. rule \nfinalClass(ClassDef c){ require(!c.supertype (). sym(). hasAnnotation (\" Final \" )); } The rule checks \neach class de.nition to ensure that the class does not inherit from a class that has the @Final attribute \n hasAnnotation is a built-in method on symbols for looking up a Java 1.5 attribute. A notable feature \nof this rule is its ability to be enforced modularly: the global property that a @Final class must have \nno subclasses is ensured by individual checks on each class in a program. These checks employ the rule \nlanguage s Symbol objects to access interface information about a class s declared superclass. The JAVACOP \nrule language ensures that rules can be enforced modularly via the API that it provides to users. For \nexample, while it is possible to access a given class s superclass, it is not possible to access all \nsubclasses of that class. To make the rule language intuitive for Java programmers, con\u00additions include \nordinary Java boolean expressions. These expres\u00adsions can invoke methods on any AST nodes, types, and \nsymbols in the scope of the constraint. JAVACOP also supports conditions that declaratively perform type \ntests and structural pattern match\u00ading, which are discussed in the next subsection. As a syntactic convenience, \nJAVACOP allows a method with zero arguments to be accessed like a .eld. For exam\u00adple, the requirement \nabove could be written more succinctly !c.supertype.sym.hasAnnotation(\"Final\").JAVACOP also includes \nsupport for Java s primitive types and String, and their associated operations and methods, as well as \nfor a List type pro\u00advided by javac. Finally, conditions may also employ values of two new types: a traversal \nenvironment Env holds information about the tree context surrounding a given node, and a global environ\u00adment \nGlobals is a repository for global constants, such as the type objects for java.lang.Object and primitive \ntypes, and the sym\u00adbols for the root and empty packages. An instance of each of these two types is implicitly \nin scope in each rule, with the name env and globals respectively. Some examples in the next section \nillustrate their usage. Often a constraint should only be applied under certain circum\u00adstances. This \ncan be accomplished through the where constraint, which is similar to Java s if statement. Like require,a \nwhere constraint has a guard expression and a body containing a sequence of other constraints; the where \nconstraint is satis.ed if either its guard evaluates to false or all constraints in the body evaluate \nto true. An example where constraint is shown in the checkNonNull rule from the previous subsection. \nIn that rule, the right-hand-side 1 Because of limitations in Java 1.5 metadata, a type cast cannot include \na user-de.ned type speci.cation, so type casts are irrelevant. @Confined class C{ protected C() { ... \n} public @Anon String toString() { ... } } Figure 3. A con.ned class C with an anonymous toString method. \nexpression of an assignment need only be shown to be nonnull if the left-hand-side variable or .eld is \nannotated with @NonNull.  2.6 Pattern Matching and Type Tests Type rules often depend on the ability \nto deconstruct the expres\u00adsions, types, and environments that they constrain, so it is imper\u00adative that \na language designed for encoding pluggable types also have this ability. To that end, JAVACOP supplies \ntwo new opera\u00adtors: <-for general type testing, and => for pattern matching on AST nodes. An expression \nof the form v<-e evaluates to true if the value of e at run time is an instance of the type of the variable \nv or a subtype. In that case, e is cast to the type of v, which is then assigned this value. Otherwise, \nthe type-test expression evaluates to false. An expression may be preceded by a list of variable declarations \nto be bound within that expression. For example, the following constraint fails if the value of tree.owner \nis not a subtype of ClassSymbol: require(ClassSymbol cs; cs <-tree.owner){...} As another example, type \nsystems for con.nement depend upon a notion of anonymous methods, which do not allow this to be stored. \nOnly anonymous methods may be invoked on a con.ned object outside of a con.ned scope. Figure 3 illustrates \na con.ned class that uses an annotation on a method declaration to specify that the method is anonymous. \nThe following rule uses <-to determine whether a method call within an anonymous method declaration properly \npreserves anonymity. The rule requires that method calls with an (explicit or implicit) receiver of this \nare either to static methods or to other anonymous methods. Type tests are used to distinguish between \nthe explicit and implicit receiver cases. rule anonCallsAnon(Apply a){ where(env.enclMethod != null \n&#38;&#38; anonymous(env.enclMethod )){ where(Select s; s <-a.meth){ where(Ident i; i <-s.selected){ \n where(i.name.equals(\"this\")){ require(s.isStatic || anonymous(s)): error(i, \" this may not be used \nto \"+ \"call non-anonymous methods.\"); }}} where(Ident i ; i <-a.meth){ require(i.isStatic || anonymous(i)): \n error(i, \"implicit this may not be\"+ \" used to call non-anonymous\"+ \" methods.\"); }}} JAVACOP also \nincludes an expression sublanguage for pattern matching on AST nodes. Pattern matching allows for declarative \ntesting of properties of an AST node, while also deconstructing the node and giving names to its component \nnodes for use in the rest of a constraint. A pattern match is a boolean expression: e=>[pat ]. In this \nexpression, e is an arbitrary expression of type Tree, and the pattern match succeeds if the value of \ne can successfully be matched against the pattern pat. Patterns are written as fragments of Java code \nwhich must be structurally equivalent to the provided expression in order for the match to succeed. Patterns \nmay include wildcard elements, which are written % to match any subtree, * to match any identi.er name, \nand ... for any number of elements in a sequence, such as state\u00adments in a block or parameters to a method. \nFor example, the pat\u00adtern [v => [@NonNull % *(...)] requires that the Tree node v must be a method declaration \nwhich is annotated @NonNull,has any return type, any name, and any number of arguments. Patterns may \nalso bind Tree, String (identi.er name), or List subcomponents encountered in the pattern structure to \nfresh vari\u00adables declared in the constraint. Variable binding involves an im\u00adplicit type test: for a \nvariable binding to succeed, the type of the component value must meet the declared type of the new variable. \nFor example, variables can be bound to the subexpressions in the pattern described above as follows: \nwhere(Tree typ, String nam, List<Tree> args ; v => [@NonNull typ nam(args)]){...} Patterns may also \ntest whether a given subtree is the same (by reference equality) as an expression in the current scope \nof the con\u00adstraint. For example, if n is an existing variable of type Tree,then the following constraint \nrequires n to be the .rst statement in its enclosing block: require(n.parent(env) => [{ n ;...}]) Pattern \nmatching can signi.cantly improve the readability and shorten the length of rules that would otherwise \nrequire multiple type tests. For example, the anonCallsAnon rule above can be rewritten in a single constraint \nusing pattern matching as follows: rule shortAnonCallsAnon(Apply a){ where(env.enclMethod != null &#38;&#38; \nanonymous(env.enclMethod )){ where(a.meth => [this.*] || a.meth => [*]){ require(a.meth.isStatic || anonymous(a.meth)): \nerror(i, \" this may not be used to \"+ \"call non-anonymous methods.\"); }}}  2.7 Quanti.cation JAVACOP \nsupports a form of quanti.cation over two kinds of data structures. First, constraints may universally \nor existentially quantify over javac Lists. The syntax is similar to the syntax of the enhanced for in \nJava 1.5. For example, the following rule enforces Java s requirement that a .nal method not be overridden: \nrule finalMethod(MethodDef m){ forall(Type supertype : m.enclClass.transitiveSupertypes){ forall(Symbol \nother : supertype.sym.memberLookup(m.name )){ where(other.isFinal){ require(!m.sym.overrides(other , \nsupertype.sym)) :error(m, \"Overriding final method\"); }}}} The outer forall iterates over a list of \nall transitive supertypes of the given method s enclosing class, binding each to the name supertype in \nturn. The inner forall then iterates over a list of all members of supertype that have the same name \nas the given method. We require the variable used to bind each element of a list to have the same type \nas the declared element type of the list. The syntax for existential quanti.cation is identical, except \nthat it uses the keyword exists instead of forall. The example above also illustrates another advantage \nof the fact that JAVACOP s AST representation contains full type information. The overrides method provided \nby the MethodSymbol class de\u00adtermines whether one method overrides another. This functional\u00adity is provided \nby javac and is well-de.ned after the typecheck\u00ading pass, so the JAVACOP API simply accesses it when \ndesired by users. If JAVACOP s AST abstraction did not have access to type information, users would be \nforced to manually check whether a method overrides another, which is nontrivial given features like \nmethod overloading, privacy modi.ers, and covariant return types. Second, JAVACOP allows quanti.cation \nto be used to iterate over all nodes in a depth-.rst traversal from a given AST node. During this traversal, \nonly nodes that match the declared type of the quanti.er variable are considered. For example, the following \nrule requires that every local variable in a method be assigned at least once. The rule uses universal \nquanti.cation to iterate over every variable declared in the given method and existential quanti.cation \nto .nd at least one assignment to this variable. rule allLocalVarsMustBeAssigned(MethodDef m){ forall(VarDef \nv : m){ where(v.init == null){ exists(Assign a : m){ require(a.lhs.getSymbol == v.getSymbol); }:error(v,\"Variable \n\" + v + \"is never assigned\") }}}  2.8 Auxiliary Predicates In addition to rules, JAVACOP allows users \nto declare auxiliary predicates, analogous to the auxiliary predicates sometimes used in formal type \nsystems (e.g., Featherweight Java [38]), using the declare keyword. These predicates are not tested directly \nduring JAVACOP s AST traversal but instead are used simply as helpers for rule de.nitions. Predicates \nare invoked by the bodies of rules and other predicates using a traditional function-call syntax. For \nexample, the rule checkNonNull from Section 2.4 makes use of a requiresNonNull predicate de.ned as follows: \ndeclare requiresNonNull(Tree t){ require(t.holdsSymbol &#38;&#38; t.getSymbol.hasAnnotation(\"NonNull\")); \n} This predicate gets the given node s associated symbol if it has one and uses the symbol to check \nwhether the node has the appropriate annotation. Auxiliary predicates provide the usual bene.ts of pro\u00adcedural \nabstraction. In this case, the requiresNonNull predicate serves to cleanly separate the logic that determines \nhow nonnull\u00adness is annotated from the logic that determines the behavior of programs employing such \nan annotation. This separation makes it easy to later augment or modify the annotation mechanism, for \nex\u00adample to use a marker interface instead of Java s metadata facility. Rule and predicate bodies naturally \nsupport a form of conjunc\u00adtion for constraints, by sequencing multiple constraints. Predicates themselves \nadditionally provide a declarative form of disjunction. Similar to predicates in Prolog, JAVACOP allows \nan auxiliary pred\u00adicate to have multiple de.nitions; an invocation of the predicate succeeds if at least \none of the de.nitions bodies is satis.ed. For example, the checkNonNull rule from Section 2.4 makes use \nof the definitelyNotNull predicate, which checks whether a given Tree object is de.nitely nonnull. It \nis natural to de.ne this predicate with a case analysis on different subtypes of Tree,by providing multiple \nde.nitions of the predicate. A few representa\u00adtive de.nitions are provided below. /* A node is nonnull \nif annotated as such */ declare definitelyNotNull(Tree t){ require(requiresNonNull(t)); } /* The value \nof an assignment is nonnull if the value being assigned is nonnull */ declare definitelyNotNull(Assign \na){ require(definitelyNotNull(a.rhs )); } /* Class instantiation is never null */ declare definitelyNotNull(NewClass \nn){ require(true); } A declare implicitly performs a type test on a given node against the declared \ntype of its argument. This type test desugars into a require constraint: the declare de.nition fails \nif the type test fails. For example, the last de.nition above fails if the given node does not represent \na Java new expression. 2.9 Error Reporting As in any type system, it is important to provide programmers \nuseful feedback about rule failures that occur during checking of their programs. Precise failure reporting \nis even more critical in the context of a pluggable type system, since programmers will be less familiar \nwith the checks being performed than they would be for a .xed type system. Informative messages can also \nmake it easier for type-system designers to debug their rules through testing as they are being developed. \nTo this end, JAVACOP supports user-de.ned failure clauses, which de.ne the message to be reported when \na rule fails. A failure clause has three components: an indication of whether an error or warning is \nto be emitted, via the keywords error and warning, respectively; the source position at which the error \nis to be reported, which may be a Tree object or the value globals.NOPOS;and an expression containing \nthe message to report. An error causes compilation to halt, while a warning allows compilation to continue \nnormally. In this way, JAVACOP users can easily decide how rule violations are to be treated on a case-by-case \nbasis. For example, a pure pluggable type system as de.ned by Bracha [8] might treat all violations as \nwarnings, while a use of pluggable types to enforce a form of security might treat particular violations \nas fatal errors. A failure clause can be applied to a constraint or rule simply by appending :<errortype>(<position>,<message>) \nto it. For example, the finalMethod rule from Section 2.7 provides a failure clause for the nested require \nconstraint, using the source position of the MethodDef object m as the position at which to report the \nerror. If this require fails during JAVACOP s AST traversal, an error will be reported at the source \nposition, using the given string as the error message. A failure clause can be placed on any constraint, \nno matter how nested it is within compound constraints. As a single exception, we disallow failure clauses \nwithin an exists constraint. The reason is simply that the failure of a constraint within an exists does \nnot necessarily result in failure of the entire constraint, so it would not make sense to signal a failure \nat that point. When a constraint fails to be satis.ed, JAVACOP searches for the nearest enclosing failure \nclause and executes it. For example, the following example signals a warning if a or b fails but signals \nan error if c fails. require(a){ require(b); require(c):error(pos1, \"error -c failed\"); }:warning(globals.NOPOS \n, \"warning -a or b have failed\")   3. Case Studies To illustrate the bene.ts of the JAVACOP framework \nfor pluggable type systems, we have implemented JAVACOP rules for a variety of interesting and nontrivial \ntype systems from the research literature. These systems include: a type system for con.nement [49] \n a type system for scoped types [51], which provide safe region\u00adbased memory management in Real Time \nJava  a checker for static detection of race conditions [27]  a checker for structured object aliasing \nvia islands [36]  a checker for nonnull references  a checker for Javari s notion of reference immutability \n[5, 47]  a type system for Generic Ownership (the core of the OGJ language) [44]  We have also implemented \nJAVACOP rules that enforce other kinds of program constraints and check for various program properties, \nincluding: an EJB3.0 veri.er [21]  two checkers supplied by the PMD Java checker [18]  rules that \nidentify classes matching the Degenerate Classes micro patterns [31]  rules that gather information \nfor Chidamber and Kemerer s object-oriented metrics [13].  In this section, we demonstrate JAVACOP s \nexpressivity and us\u00adability by describing the salient features of a number of these checkers, focusing \non the type systems. More examples can be found in the appendix of this paper. 3.1 Con.ned Types Con.ned \ntypes were introduced to create static restrictions on how references may be shared among objects [49]. \nThe goal of a type system for con.nement is to ensure that instances of con.ned types are only accessible \nwithin their de.ning package. To meet this goal, con.ned types must obey several restrictions: they cannot \nbe public; the cannot inherit from uncon.ned classes (other than java.lang.Object); and Java language \nconstructs (such as casts) must be restricted. As mentioned in Section 2, con.nement also depends on \na notion of anonymous methods. JAVACOP s implementation of a type system for con.nement requires 12 rules \nand 18 predicate declarations. We have already presented some of the basic rules in Sections 2.4 and \n2.6. We describe a few more of the key rules here. Con.ned Class Declaration Con.ned types cannot be \npublic, nor can they belong to the default Java package. This is encoded in the following rule: rule \nConfinedExample1(ClassDef c){ where(confined(c)){ require(!c.isPublic ()): error(c, \"Confined class may \nnot be public\"); require(c.pkg() != globals.emptyPackage): error(c, \"Confined class may not be \" + \"in \nthe default package\"); }} This rule is de.ned in terms of an auxiliary confined predicate, which checks \nwhether a type is declared to be con.ned. This pred\u00adicate could be de.ned to check for an annotation \nlike @Confined, to check for a particular marker superinterface, or even to check for a particular naming \nconvention on types.  Con.ned Class as Extension A con.ned class may not extend an uncon.ned type. This \nprevents inherited .elds and methods leaking a con.ned instance. The JAVA-COP rule that enforces this \nis: rule ConfinedExample2(ClassDef c){ where(confined(c)){ forall(Type s : c.supertypes()){ require(confined(s) \n|| s == globals.objectType): error(c, \"A confined class may not extend \" + \"an unconfined superclass\"); \n}}}  This rule shows again how to develop rules that utilize the inheri\u00adtance hierarchy. Via universal \nquanti.cation, it states that all super\u00adtypes, including both superclasses and superinterfaces, of a \ncon\u00ad.ned class must be con.ned. While the supertypes method does not return all transitive supertypes \nof c, it is suf.cient for this rule because if all direct supertypes are con.ned, by induction, all tran\u00adsitive \nsupertypes must be con.ned as well. As a single exception, a con.ned class may have java.lang.Object \nas a superclass, since this cannot be avoided in Java. Con.ned Type Coercion To maintain the integrity \nof the con.ned type system, coercion from a con.ned type to an uncon.ned type is disallowed. The following \nrule, seen previously, enforces the necessary behavior using JAVACOP s subtype join point. rule ConfinedExample3(a \n<: b @ pos){ where(confined(a)){ require(confined(b)): error(pos, \"confined type \"+a+ \" may not be \ncast to \"+ \"unconfined type \"+b); }}  As discussed in Section 2.4, this rule applies to all AST nodes \nwhere an (implicit or explicit) type coercion occurs. Because of the ConfinedExample2 rule, the only \nway that b can be uncon.ned is if it is the class java.lang.Object. The above rule enables the notion \nof con.nement to coexist safely with Java s choice to have a single root class in the language. Con.ned \nAccess via Anonymous Methods Earlier in the paper, we presented the notion of anonymous meth\u00adods for \ncon.ned classes and showed a rule that helps to enforce anonymity of such methods. The bene.t of anonymous \nmethods is that it is always safe for them to be invoked on instances of con\u00ad.ned types. This is not \ntrue of non-anonymous methods, as they could potentially leak this. The following JAVACOP rule requires \nevery invocation of a non-anonymous method on a con.ned object to occur within a con.ned scope: rule \nConfinedExample4(Apply a){ where(!anonymous(a.meth) &#38;&#38; !a.meth.isStatic){ where(Tree receiver; \na.meth => [receiver.*]){ where(confined(receiver)){ require(confined(a.meth.enclClass())): error(a,\"Non-anonymous \nmethod \"+ a.meth.sym+ \" called on confined class \"+ receiver.sym+\" \"); }}}}  The rule declaratively \ndispatches on all method invocations (the Apply AST node) and uses pattern matching to access the receiver \nin the method invocation. 3.2 Scoped Types Scoped types [51] use a variant of con.nement to provide a \nform of safe region-based memory management for Real Time Java. All types de.ned in a package declared \nto be scoped are implicitly considered to be scoped, except for a distinguished gate class that provides \ncontrolled access to the package s types from outside the package [2]. We have implemented a type system \nfor scoped types with .ve rules and 19 declarations. We present a selection of these rules and declarations \nthat illustrate JAVACOP s utility.  Scoped Packages and Scoped Types The following declare returns true \nif a package is declared to be scoped. By convention, a package is scoped if the package is nested within \neither the imm or scope packages. declare scopedPackage(PackageSymbol p){ require(List<Symbol> o; o <-p.transitiveOwners){ \nrequire(o.length >= 1 &#38;&#38; (o.head.name.equals(\"imm\") || o.head.name.equals(\"scope\"))); }} The \nnext declare determines whether a type is scoped. The .rst de.nition states that a type is scoped if \nit does not match the naming convention for a gate type and it is in a scoped package. The second de.nition \nsays that a type is considered scoped if it has a generic parameter that is a scoped type. declare scoped(Type \nt){ require(!gateNamed(t.sym)); require(scopedPackage(t.pkg)); } declare scoped(Type t){ exists(Type \np : t.allparams){ require(scoped(p)); }} The second de.nition above takes advantage of JAVACOP s ability \nto reason about Java generics. In this case, the list of type parame\u00adters of a type can be easily checked \nfor a speci.c property. The following rule uses the helper predicates de.ned above to ensure that the \nvisibility of a scoped type is respected. Except for a few special cases (captured by safeNode(t) below), \na variable of scoped type can only be accessed in the type s de.ning package and nested packages. rule \nscopedTypesVisibility(ClassDef c){ forall(Tree t : c){ where(t.type != null &#38;&#38; !safeNode(t)){ \nwhere(scoped(t.type)){ require(t.type.pkg .isTransitiveOwner(c.pkg)): error(t, \"Scoped type visible only \nin its \"+ \"package.\"); }}}}  Scoped Type Widening The visibility rule presented above can only be statically \nveri.ed if it is impossible to remove or change a variable s scope. If this were not the case, a value \nof some type T which should not be visible in a package P could be made visible in P simply by casting \nthe value to a type whose scope is visible in P. The following rule ensures that a variable s scope is \nnot changed by disallowing a type in a scoped package from being coerced implicitly or explicitly to \na type in another package. JAVACOP s subtyping rule form allows this semantics to be naturally encoded: \n rule scopedTypesCasting(a <: b @ pos){ where(scopedPackage(a.pkg) { require(a.pkg == b.pkg): warning(pos, \n\"Scoped type \"+a+\" may not be\"+ \"widened to a type in another\"+ \" package.\"); }}  3.3 Race Condition \nDetection Flanagan and Freund proposed a type system for detecting race conditions in Java [27]. In this \ntype system, each .eld of a class is declared to have another object as its lock. The type system then \nen\u00adsures that a .eld s associated lock is held (via Java s synchronized construct) whenever the .eld \nis accessed. We have implemented a pluggable version of such a type system in JAVACOP, utilizing Java \n1.5 metadata to annotate .elds with their associated locks. For simplicity, we assume that a .eld s lock \nis either this or an\u00adother .eld declared in the same class. A .eld s lock is speci.ed via a @LockedBy \nannotation, which includes the name of the lock as an associated value. Our implementation also properly \nhandles requires clauses, which represent method preconditions; we im\u00adplement them via @Requires annotations \non method declarations.  Immutable Locks For soundness, Flanagan and Freund require the expressions \nused as locks to be immutable. The following rule ensures this property by requiring that a .eld used \nas a lock is declared final.The hasLockSpec helper predicate determines whether a .eld has a properly \nformatted @LockedBy attribute. rule finalLock(VarDef v){ forall(VarDef v2 : env.enclClass){ where(hasLockSpec(v2.sym)){ \nwhere(Literal n; v2 => [@LockedBy(n) % *]){ where(n.value.equals(v.name)){ require(v.isFinal) :warning(v2,v.name+\" \nmust be immutable.\"); }}}}} The rule makes use of pattern matching to easily pull the lock name out \nof a .eld declaration. Field Access When Lock Held Ensuring that .eld accesses are properly synchronized \nrequires that information on the associated lock is properly retrieved from the type system. Since @LockedBy \nis an annotation on a .eld declaration, it can be found on the Symbol that represents the .eld. The following \nrule signals a warning if a .eld access does not occur within a synchronized block guarded by the .eld \ns associated lock. declare checkLockAccess(Select field, String name){ exists(Tree t: env.enclClass.pathTo(field)){ \nrequire(Synchronized s; s <-t){ require(s.lock.getFullName.equals(name)); }}} rule selectSynchCheck(Select \ns){ where(hasLockSpec(s.sym )){ where(Constant c; c <-s.sym.attributes .getCompound(\"LockedBy\") .getComponent(\"value\")){ \n require( checkLockAccess(s, s.selected.getFullName+\".\"+c.fullName)): warning(s, \"Unsafe access of \"+s.name); \n}}} Because JAVACOP is integrated with the Java type system, all necessary information can be retrieved \nfrom the type and symbol information that is available modularly at a .eld access. For ex\u00adample, the \nabove rule works properly for .eld accesses that occur outside of the .eld s declaring class, even if \nonly the bytecode (but not the source) of that class is available. The checkLockAccess predicate above \nmakes use of JAVACOP s Environment class to access the context surrounding a .eld access. Existential \nquan\u00adti.cation iterates over every block in this context to .nd an ap\u00adpropriate synchronized statement. \nAlthough not presented here, checkLockAccess also allows the needed lock to be found in the @Requires \nclause of the enclosing method. 3.4 Nonnull In Section 2, we showed several rules governing the use of \na @NonNull annotation. This section illustrates a more sophisticated rule that provides a simple form \nof .ow sensitivity. Assuming that threading does not exist or is handled correctly, it is always safe \nto treat a variable or .eld as @NonNull directly after a null check has been performed. For example, \nthe following code should not be marked as an error. if(x != null){ @NonNull Object nonnull_x = x; \n... } The rules discussed previously, however, are not suf.cient to rec\u00adognize the assignment to nonnull_x \nas safe. The following rule resolves this limitation. rule checkNonNull(Assign a){ where(declaredNonNull(a.lhs)){ \nrequire(definitelyNotNull(a.rhs) || safeNullableAssign(a)): error(a,\"Assigning null value to @NonNull \n\"+ \"variable.\"); }} declare safeNullableAssign(Assign a){ require(localVariable(a.rhs)); require(Tree \nl ; a.parent(env).parent(env) => [if(l != null){ a ;...}] || a.parent(env) => [if(l != null) a ]){ require(l.sym \n== a.rhs.sym); } } The above rule generalizes the rule for assignments in the in\u00adtroduction, in order \nto allow another possible way in which the right-hand side of an assignment can be considered nonnull. \nThe safeNullableAssign predicate uses the environment to access the enclosing lexical scope of the assignment \nnode along with pat\u00adtern matching to test whether this context performs the appropriate null check. The \n.rst pattern matches the case when the assignment is the .rst statement in a block, while the second \npattern matches the case when the assignment is the only statement guarded by the if. Whichever pattern \nmatches the context provides the value for l to be used by the innermost require.  3.5 Reference Immutability \nJavari [5, 47] is a Java extension that introduces a readonly modi.er. Javari s type system ensures that \nany reference marked readonly is transitively immutable. We have implemented a sig\u00adni.cant subset of \nJavari in JAVACOP using JAVACOP annotations and rules to emulate the behavior of the readonly modi.er. \nWe present a selection of the rules and end with a discussion of the compromises required to implement \nJavari with an annotation\u00adbased system.  Transitive Readonly The following predicates are a selection \nof those de.ning the read\u00adonly property. Read-only references include those .elds annotated as @Readonly,the \nthis reference within a method that is marked as @ReadonlyThis, and the inductive case of any reference \nob\u00adtained by dereferencing a .eld (that is not marked as @Mutable)of a read-only reference. These predicates \ndemonstrate JAVACOP s ability to use procedural abstraction and recursion to describe com\u00adplex structural \nproperties simply. declare readonlyS(Symbol s){ require(s.hasAnnotation(\"javari.Readonly\")); } declare \nreadonly(Tree t){ require(!t instanceof Indexed);  require(t.holdsSymbol &#38;&#38; readonlyS(t.sym)); \n} declare readonly(Select s){ require(!s.isStatic &#38;&#38; !mutable(s)  &#38;&#38; readonly(s.selected)); \n} declare readonly(Ident i){ require(i.name.equals(\"this\") &#38;&#38; readonlyThis(env.enclMethod)); \n} declare readonly(Ident i){ require(!i.isLocal &#38;&#38; !i.isStatic &#38;&#38; !mutable(i)  &#38;&#38; \nreadonlyThis(env.enclMethod)); }  Enforcing Immutability To prevent modi.cation of state reached via \na read-only reference, it is necessary to constrain the operations that can alter state, such as assignments \nand method calls. The following rule is an example of such a constraint. It prevents assignment to array \nelements and non-static .elds accessed via a read-only reference. rule readonlyAssignment(Assign a){ \n where(!a.lhs.isStatic){ where(Tree x; a.lhs => [x.*]){ require(!readonly(x) || assignable(a.lhs)): \n warning(a, \"Assigning to field of\"+ \" read-only reference \"+x); } where(a.lhs => [*] &#38;&#38; !a.lhs.isLocal){ \n require(!readonlyThis(env.enclMethod) || assignable(a.lhs)): warning(a, \"Assigning to field of\"+ \n\" read-only this\"); }} where(Tree x; a.lhs => [x[%]]){ require(!readonly(x)): warning(a, \"Mutating \nread only array\"+x); }}  Pattern matching allows us to validate cases without complex casts or sequences \nof method invocations. The .rst clause uses a simple pattern [x.*] to match .eld assignments, and it \nensures that either the receiver is read-only or the .eld is marked assignable. The second clause matches \nbare identi.ers without an explicit receiver. These may be either .elds of the this reference or local \nvariables, so the latter case must be excluded by requiring that the assignee is not local. In the former \ncase, the rule requires that either the enclosing method is marked as @ReadonlyThis or the .eld is marked \nassignable. The third clause matches assignment to an array index as an lvalue, which must be forbidden \nif the reference to the array is read-only. Readonly Value Flow Thevalue .owrulefor @Readonly is the \ninverse of that for the nonnull example seen previously. Whereas a nonnull system con\u00adstrains what values \nmay acquire the @NonNull annotation, the read\u00adonly system permits any value to acquire the @Readonly \nmodi\u00ad.er but constrains the ability to remove it. The following rule de\u00adscribes this constraint; the \nvalue of any expression which has been deemed read-only may only .ow into a position marked with the \n@Readonly modi.er. rule readonlyValueFlow(expr <<: sym){ where(readonly(expr )){ require(readonlyS(sym) \n|| (thismutable(expr) &#38;&#38; assignToThsMutLHS(expr.parent(env)))): warning(expr, \"cannot cast away \nreadonly\"); }} The predicate declaration assignToThsMutLHS describes the one case where a read-only \nvalue may be assigned to a .eld with\u00adout the @Readonly modi.er: when an assignable this-mutable .eld \n(a .eld which is marked neither read-only nor mutable, and there\u00adfore inherits its mutability from the \nreference used to access it) is assigned the value of a this-mutable .eld of the same object. declare \nassignToThsMutLHS(Tree t){ require(Tree lhs, Tree rhs; t => [lhs = rhs]){ require(assignable(lhs)); \n require(thismutable(lhs )); require(sameSelected(lhs ,rhs)); }}  Implementation Compromises Several \ncompromises were necessary to implement Javari using an\u00adnotations, and without modifying Java s semantics. \nTschantz and Ernst [47] describe in an appendix several problems with the ap\u00adproach of using annotations, \neach of which we had to address. We discuss a subset of these here. First, Javari uses the readonly modi.er \non method declarations to identify two different properties of the method: That the return type of the \nmethod is read-only.  That the this reference is to be treated as read-only within the method body. \n These uses are differentiated by the location of the modi.er: before the return type to modify the \nreturn type and immediately before the method body to modify the this reference. Java 1.5 annotations \nonly support the former syntax. Therefore it was necessary for us to choose another annotation to indicate \nthat the this reference is to be considered read-only. We use @ReadonlyThis for that purpose. Second, \nusing the @Readonly annotation alone, it is not pos\u00adsible to specify that the contents of an array are \nto be consid\u00adered read-only, while the array itself is mutable. A similar prob\u00adlem arises with the use \nof generic collections since annotations cannot be applied to uses of types (or type parameters), our \nsys\u00adtem cannot specify the mutability of generic parameters. We mit\u00adigate this problem through a new \nannotation @ReadonlyContent, which indicates that the contents of an array or a reference to a type extending \nCollection is read-only. The @ReadonlyContent property applies transitively across array indexing and \nretrieval us\u00ading .get(%) from collections. Additionally, the toArray(...) methods of Collection classes \nresult in @ReadonlyContent values, and the common non-mutating methods get, indexOf, contains*, isEmpty \nand size are marked as @ReadonlyThis. This behavior is enforced by the following predicates, along with \na de.nition and value-.ow rule for the readonlyContent predicate that are analogous to those for readonly. \ndeclare readonly(Indexed i){ require(readonlyContent(i.indexed)); } declare readonly(Apply a){ require(Tree \nx; a => [x.get(%)]){ require(extendsCollection(x.type)); require(readonlyContent(x)); }}  declare \nreadonlyContent(Apply a){ require(Tree k; a => [k.get(%)]){ require(extendsCollection(k.type)); require(readonlyContent(k)); \n}}  declare readonlyContent(Apply a){ require(Tree t; a => [t.toArray(...)]){ require(readonlyContent(t)); \n require(extendsCollection(t.type)); }}  Finally, because method overloading is based on Java s type \nsys\u00adtem alone, without consideration of annotations, JAVACOP rules cannot alter the behavior of method \noverloading and therefore are unable to implement this component of Javari.  4. Implementation Fig. \n4 gives an overview of the structure of the system: JAVACOP takes a Java program and checks it against \na set of constraint rule\u00adsets, producing errors and warning messages where the constraints are not met. \nBecause JAVACOP incorporates a full Java compiler (Sun s javac) it also produces compiled Java bytecode. \nThis is (at least psychologically) important, because it means that JAVACOP errors have some teeth: if \na class causes a ruleset to raise an error, then JAVACOP will not generate code for that class. Of course, \nthis design choice can be easily changed without affecting the rest of the system. The JAVACOP system \nhas two major components. First, JAVA-COP augments the javac compiler with JAVACOP.Framework, an object-oriented \nframework that provides a clean interface to the compiler s internal AST and type structures [1]. Second, \nthe sys\u00adtem includes the JAVACOP.Compiler component, which compiles constraints written in the JAVACOP \nrule language into Java code that uses the JAVACOP.Framework API to access a program s AST. The JAVACOP.Framework \nloads the rulesets compiled by JAVA\u00adCOP.Compiler and, just prior to code generation, invokes each ruleset \nin turn on the fully-attributed AST of each Java class it is compiling. In this section, we will highlight \nthree important consequences resulting from JAVACOP s implementation design. Figure 4. An overview of \nJAVACOP s implementation 4.1 Checking Source Code The .rst consequence of JAVACOP s design is that it \nchecks Java source code, rather than bytecode. This imposes some limitations: JAVACOP can only check \nprograms for which source code is avail\u00adable, and parsing source code is less ef.cient than reading in \nbyte\u00adcode. The key advantage, though, is that much more information is present in Java source code than \nthe bytecode in particular, generic type information and many annotations are only present in the source \ncode. As described earlier, JAVACOP can still glean in\u00adterface information from bytecode, which is necessary \nto check the source code for a class against the compiled code for depended\u00adupon types. 4.2 JAVACOP.Framework \nAPI The second consequence stems from the JAVACOP.Framework of\u00adfering a stand-alone API into the compiler \ns data structures: pro\u00adgrammers can write Java classes that use this API directly al\u00adthough our experience \nof using this API directly strongly moti\u00advated us to design the JAVACOP rule language. This separation, \nhowever, allowed us to develop and test the rule compiler indepen\u00addently from the program checker. The \nJAVACOP.Framework API also insulates the compiled rulesets from any ongoing changes to the Java compiler \ns implementation. For space reasons, a more de\u00adtailed description of this framework is presented elsewhere \n[1].  4.3 Performance Thirdly, to demonstrate that JAVACOP is a practical implementa\u00adtion, we measured \nits performance compiling a range of sample programs using a range of rulesets. The sample programs include \nseveral well-known open source examples, the Java code generated by the rules mimicking PMD behavior \nin JAVACOP (described in the appendix), and a real time program intended to be used with Scoped Types \nfrom the OVM project [43]. We compiled each pro\u00adgram .rst with no rulesets, then with the Scoped Types, \nPMD, Con\u00ad.ned Types, Nonnull and Micro Patterns rulesets individually, and then as a torture test with \nJAVACOP checking all these rulesets simultaneously. The measurements were taken on a Dell Optiplex GX250, \nwith an Intel Pentium IV 2.5GHz and 1GB RAM, running NetBSD 3.99.11. JAVACOP was run using the Sun Java \nHotSpot(TM) Client VM (build 1.5.0 05-b05, mixed mode, sharing). Each test was run .ve times, and timed \nusing the time built-in command from the bash shell. The wall clock ( real ) time was measured, the highest \nand lowest values were discarded, and the remaining three averaged to produce the .nal .gure. Because \nthe Con.ned Types and Scoped Types rules rely on annotations not present in most of the examples, we \nmodi.ed these rulesets so that every class would be checked as if it were con.ned or scoped, respectively. \n Fig. 5 presents the results. For each con.guration the upper row is time in seconds, while the lower \nrow is time relative to the No Rules condition in each case lower is better. The key point from this \ntable is that in the worst case, performing JAVACOP rule checking takes less than twice the time of compiling \nwithout any checking. Closer inspection shows that most of this time is spent in the Scoped Types ruleset: \nthis is not surprising as those rules (a de\u00advelopment of Con.ned Types discussed above) make very detailed \nchecks, since they are designed to support real-time programming. The other rulesets, including Con.ned \nTypes themselves, impose a compilation time overhead of between one and .fteen percent. We have not performed \nany optimisations on JAVACOP, nor have we investigated any kind of incremental compilation support. Nonethe\u00adless, \nthese performance numbers demonstrate the practicality of JAVACOP s design.  5. Related Work The term \npluggable types was coined recently by Gilad Bracha [8] to describe optional type systems that can be \nlayered on top of existing languages without affecting those languages dynamic semantics. Bracha suggests \nthat pluggable types should allow type systems to evolve independently of the underlying language, and \nthat programmers could choose which pluggable type system(s) to use with their programs, depending on \nthe programs require\u00adments. JAVACOP provides the .rst practical framework designed for introducing pluggable \ntypes in Java, allowing programmers to use and implement a range of type systems and other tools, with\u00adout \nthe costs of building a full compiler, parser, or type checker. In this section we discuss a range of \nwork related to JAVACOP, and to pluggable types more generally. Program Structure Constraints The earliest \nsystems related to pluggable types were not designed as type systems per se, but rather to express syntactic \nconstraints over programs, often to check programming style (like a customisable Lint). CCEL [22], the \nC++ Constraint Expression Language, was one of the .rst of these languages. CCEL constraints are written \nin a clean syntax, reminiscent of the relational calculus, and can be grouped into rulesets that are \nchecked and managed as groups. The Java Tools Language (JTL) [17] is a more recent system with many of \nthe same features as CCEL (except for using Java rather than C++, and with an execution model based on \nProlog), motivated by Gil and Maman s corpus analysis of Java code [31]. JTL s syntax is particularly \nnoteworthy, designed to be as close to Java s syntax as possible to make it easy for programmers to de.ne \nconstraint rules. JQuery [39] also uses Prolog to express structural constraints over Java programs, \nbut rather than checking constraints it uses them to de.ne complex browser views. JSR269 [20] de.nes \nan API for processing annotations. Annotation processors can check constraints and also generate new \nJava classes (e.g., RMI or EJB stubs) which are then themselves checked. Compared to our work, CCEL, \nJTL, and JQuery have a re\u00adstricted data model, containing primarily classes, methods (func\u00adtions and \nvirtual functions), and .elds; JQuery also provides access to Eclipse s dependency structures. These \nsystems do not look in\u00adside methods or traverse abstract syntax trees, so while they can express constraints \non the program structures, they cannot describe type constraints within method bodies. JSR269 annotation \nproces\u00adsors are more powerful as they are written in Java (rather than a System Classes No ruleset Scoped \nPMD Con.ned Nonnull Micro All Hello World 1 0.972 1.000 1.053 1.083 1.014 1.043 1.052 1.082 1.016 1.045 \n1.015 1.044 1.078 1.109 PMD ruleset 7 1.674 1.000 1.977 1.181 1.737 1.038 1.727 1.032 1.676 1.001 1.672 \n0.999 2.075 1.240 OVM example 197 3.534 1.000 5.242 1.483 3.874 1.096 3.918 1.109 3.621 1.025 3.661 1.036 \n5.642 1.596 JAVACOP 368 4.977 1.000 8.341 1.676 5.400 1.085 5.637 1.133 5.157 1.036 5.098 1.024 9.276 \n1.864 PMD 443 12.435 1.000 16.289 1.310 13.091 1.053 13.338 1.073 12.688 1.020 12.688 1.020 17.229 1.386 \nJython 630 6.362 1.000 10.240 1.610 7.202 1.132 7.302 1.148 6.595 1.037 6.642 1.044 11.360 1.786 JEdit \n805 7.687 1.000 12.683 1.650 8.708 1.133 8.831 1.149 7.907 1.029 8.107 1.055 14.255 1.854 Figure 5. \nJAVACOP Compilation Times domain-speci.c language like JAVACOP) and can both check and generate code. \nOn the other hand, JAVACOP s language is designed specially to support checking types and annotations, \nand JAVA-COP (and its JAVACOP.Framework API) provides access to the program s AST, unlike JSR269. Abstract \nSyntax Tree Constraints PMD [18] is a widely-used system for enforcing constraints on the abstract syntax \ntree of Java programs. Constraints can be speci.ed either as classes implement\u00ading a visitor pattern, \nor an XPATH expression. CheckStyle [11] is another much-used system, similar to PMD, also based on XPATH. \nCompared with JAVACOP, these systems do not contain type or symbolic information and therefore support \nonly syntactic con\u00adstraints. Most of the examples we have presented in this paper, which we feel are \nrepresentative of the kinds of rules that would be developed for pluggable type systems, are not expressible \nin these above systems because of the need for symbol and type informa\u00adtion. Furthermore, Java code and \nXPATH queries are less readable than JAVACOP s declarative rules, and much further from most speci.cations \nof type systems. A clear example of the improved readability that pattern matching affords can be found \nin the ap\u00adpendix. An older system, ASTLOG, [19] provides a domain-speci.c language for writing queries \nover the ASTs of C or C++ programs. ASTLOG is again based on a variant of Prolog; the target program \ns structure and AST are made accessible via the Prolog database. Compared with JAVACOP, ASTLOG s language \nis clearly more powerful in regards to .ow-sensitivity and temporal properties, but like other systems \nwhich load whole programs into databases, it is non-modular and less ef.cient than JAVACOP. ASTLOG also \ndoes not have support for type system access or for any of the more recent Java features such as annotations \nand generics. Thus, it is not an ideal framework in which to implement the kinds of pluggable type systems \nseen in this paper. More recently, CodeQuest [34, 33] has extended JQuery to pro\u00advide a comprehensive \nProlog-based program querying system. Like JAVACOP and ASTLOG, CodeQuest can in principle express con\u00adstraints \nacross types and methods, but JQuery requires the whole program to be stored in a relational database \nand then ef.ciently op\u00adtimises recursive queries to that database. The JunGL system [48] carries on from \nCodeQuest by incorporating a functional language to de.ne program refactorings. Compared with JAVACOP, \nCode-Quest certainly provides much better support for ad-hoc queries across entire projects, and has \na highly sophisticated implementa\u00adtion; JunGL adds full access to data and control .ow information. On \nthe other hand, JAVACOP is tightly focused on de.ning plug\u00adgable type systems and checkers, and implements \nthem modularly and straightforwardly within traditional compiler technology. Eichberg, Sch\u00a8 afer and \nMezini [24, 23] describe how a whole\u00adprogram XML database, XIRC, including a typed AST, can be used to \ncheck constraints on programs. A program is loaded into the database, and then constraints are expressed \nin the form of queries in the XQuery query language. XIRC is more powerful than JAVA-COP as its database \ncan include any development artifact so, for example, it can check EJB 2.0 components for conformity \nwith their XML deployment descriptor, or with documentation in Word imported into XML. On the other hand, \nJAVACOP constraints are arguably more readable than XML queries, and are certainly closer to the kind \nof rules used in existing descriptions of pluggable type systems. JAVACOP s checking is also completely \nmodular. Static Analysers FindBugs [37] identi.es bug patterns code which indicates bugs or potential \nbugs in Java programs by ex\u00adamining their bytecode. FindBugs is one example of an increasing set of \nbug-.nding static analysis tools. The rules enforced by Find-Bugs are written in Java and largely .xed \n it is not designed as a user-extensible tool. On the other hand, this allows FindBugs to implement relatively \nsophisticated custom analyses. Several exten\u00adsible static analysers for C (e.g., [35, 4]) allow users \nto express rules as state machines that are enforced by a path-sensitive data.ow analysis. These systems \ncan express requirements that are not ex\u00adpressible in JAVACOP, due to its minimal support for .ow sensi\u00adtivity. \nAt the same time, these systems do not naturally express the kinds of syntax-directed pluggable type \nrules that JAVACOP tar\u00adgets. Aspects and Meta-Objects Shomrat Yehudai [45] has described how AspectJ \ncan enforce architectural constraints, such as an expensive operation must not be called from within \na performance critical section of code , by de.ning pointcuts on the static call graph. AspectJ supports \na range of structural constraints, but the granularity of its pointcuts seems too coarse to easily express \nthe restrictions necessary for many pluggable type systems [30]. Inasmuch as JAVACOP layers a new type \nsystem on top of an extant base language, it is related to re.exive or meta-object systems, such as OpenJava \n[46]: Bracha and Ungar provide a good overview of design issues in such systems [9]. General re.exive \nsystems are often much more powerful than JAVACOP, providing dynamic access to the structures of running \nprograms, and allowing those programs to be modi.ed at runtime [12]. On the other hand, compared with \nJAVACOP, re.exive systems provide weak support for analysing or checking the .ne details of types and \nexpressions within method bodies. Type Systems CQual [28, 29] is a system for user-de.ned type quali.ers \nfor C programs. Quali.ers are analogous to the Java 1.5 type annotations that JAVACOP employs. JAVACOP \ns rule lan\u00adguage is much more expressive than that of CQual, which only allows users to specify subtyping \nrelationships among quali.ers. However, CQual supports .ow sensitivity and a form of quali.er inference, \nboth of which JAVACOP lack. The Clarity framework [14, 15] extends the idea behind CQual by providing \nan explicit language for user-de.ned quali.er rules. This language allows speci.cation of simple patterns \non individual expressions, but it does not allow the kinds of rich constraints on larger-scale program \nentities that JAVACOP supports. Clarity also allows programmers to provide an invariant de.ning the semantics \nof a quali.er, and an automatic theorem prover validates user\u00adde.ned rules with respect to this invariant. \nJAVACOP lacks any form of rule validation. JAVACOP is also loosely related to the research on soft typing \n[10]. Soft typing systems use type inference to add types to pro\u00adgrams in untyped languages such as Scheme \n[50] or Erlang [40], inserting explicit runtime type checks where the program does not conform to the \nstatic type scheme. In contrast, pluggable type sys\u00adtems check explicit type annotations, do not alter \nthe target pro\u00adgram, and can raise hard errors if the types fail to check. Further, pluggable type systems \nare designed to be user-extensible, while soft type systems typically employ a .xed type inference system. \nFinally, it is interesting to compare JAVACOP to extensible compiler frameworks such as JastAdd [25] \nand Polyglot [41]. Ex\u00adtensible compilers are certainly more powerful than JAVACOP, supporting arbitrary \n(and arbitrarily complex) analyses and exten\u00adsions to syntax and semantics as well as type systems. Such \nsys\u00adtems, however, come at the cost of a much more general (and thus much larger and more complex) overall \nsystem. Where JAVACOP produces rulesets that simply plug-in to a standard Java compiler, these systems \nproduce whole new compilers. JAVACOP s focus on separate, independent rulesets makes it straightforward \nto check multiple JAVACOP rulesets simultaneously, while combining mul\u00adtiple language extensions in Polyglot, \nsay, is a much more subtle endeavour [42].  6. Conclusions In this paper we have presented the .rst \npractical framework de\u00adsigned for implementing pluggable types for Java. Our contribu\u00adtions include: \n The design of the JAVACOP rule language for declaratively specifying natural and modular type constraints \non Java pro\u00adgrams.  An implementation of JAVACOP, which consists of a compiler for the rule language \nand a checker for the compiled constraints in an extended Java compiler.  A validation of JAVACOP through \nthe implementation of sev\u00aderal pluggable type systems (and other constraint sets), and through performance \nexperiments.  We plan a range of future extensions to JAVACOP. We hope to incorporate direct support \nfor a form of .ow sensitivity, which will increase the range of annotations that can be checked by JAVACOP \nand increase the precision of checking for existing annotations like @NonNull. We are also planning to \nextend the error clauses so that rules can count the number of times a constraint fails, or to accumulate \nlists of failing program elements, rather than simply producing error messages features of many other \nconstraint system veri.ers. To increase the ef.ciency of checking complex rulesets on large programs, \nwe are planning to cache quanti.cation and predicate results since JAVACOP is a declarative language, \nsuch caching will suffer from no problems with side effects, but can provide many of the bene.ts of imperatively \nassigning extra attributes to AST nodes. More pragmatically, the JAVACOP rule compiler is currently written \nin Haskell; we plan to port this to Java. Note that the extended javac compiler is already written in \nJava. Finally, we plan to continue to develop JAVACOP rulesets to support a wide range of type annotations, \nstyle checkers, and anal\u00adysis tools, to bring the bene.ts of pluggable types to Java program\u00admers everywhere. \n Acknowledgements This material is based upon work supported by the National Science Foundation under \nGrant Nos. CCF-0427202 and CCF-0545850; by a generous gift from Microsoft Research; by an IBM Eclipse \nInnovation Grant; by the EPSRC grant Practical Ownership Types for Objects and Aspect Programs, EP/D061644/1; \nand by the Royal Society of New Zealand Marsden Fund. Thanks to Alex Potanin, Gilad Bracha, Brian Foote, \nItay Maman, Jan Vitek, John Potter, and the anonymous reviewers from OOPSLA and ECOOP 2006 for comments \non prior drafts. Further Case Studies In this appendix, we present a number of additional examples of \nsystems implemented with JAVACOP, as mentioned in Section 3. Enterprise JavaBeans As part of the J2EE \nplatform, the Enterprise JavaBeans (EJB) archi\u00adtecture was created to aid in the development of component-based \ndistributed software. The EJB architecture requires applications to satisfy a number of well-formedness \nconstraints, which are detailed in the EJB speci.cations [21]. These speci.cations are very large and \ncomplicated, so J2EE implementations typically provide a ver\u00adi.er tool that checks some rules to avoid \naccidental deviations from the speci.cation. Since these rules are all predicated on the use of EJB annotations, \nthe EJB speci.cation itself can be viewed as a large, self-contained type system. As a test of JAVACOP \ns expressiveness, we have implemented many of the rules from the EJB 3.0 speci.cation [21]. In particular, \nwe were able to express in JAVACOP all the rules that have been ex\u00adpressed by other checker systems [24, \n11], except for two types of rules. First, a few rules inherently require global program knowl\u00adedge, \nfor example knowledge of all call sites of a given method. Since JAVACOP is a modular checker, all possible \ninformation about future references for .elds and methods may not be available for a class when it is \ninitially being checked. Any rules that would require such information are not possible to write in JAVACOP. \nSecond, some rules depend on the temporal order of method calls at run time, while JAVACOP s rule language \nis .ow-insensitive. All in all, we implemented 73 JAVACOP rules and 140 predicate declarations. A few \nof the more interesting rules are presented below. Proper Use of @TransactionAttribute The .rst example \nis a rule to enforce the part of the EJB 3.0 speci.cation that states The TransactionAttribute annotation \ncan only be speci.ed if container managed transaction demarcation is used [21]. What the speci.cation \nis stating is that any time the annotation TransactionAttribute is used, there may not be an annotation \nargument to any annotation that assigns the value BEAN to transactionManagement. Here is an example of \na Java class that violates this rule: @Stateless(transactionManagement=BEAN) @TransactionAttribute(MANDATORY) \nclass ExampleBean { ... } The following JAVACOP rule and predicate enforce this constraint: rule EJBExample1(ClassDef \nc){ where(c.sym. hasAnnotation(\"TransactionAttribute\")){ require(! isTransactionManagementBean(c.mods)): \n warning(c,\"Bean cannot be annotated with \" +\"@TransactionAttribute and \" +\"have bean-managed \" +\"transactions.\"); \n }} declare isTransactionManagementBean(Modifiers m){ exists(Annotation a: m){ exists(Tree arg: a.args){ \nwhere(Tree lhs, Tree rhs; arg => [lhs = rhs]){ require(lhs.getName. equals(\"transactionManagement\") &#38;&#38; \nrhs.getName.equals(\"BEAN\")); }}}} The isTransactionManagementBean predicate helps deter\u00admine whether \na class represents a transaction management bean, using pattern matching to deconstruct the name-value \npairs in the class modi.ers list, while the rule itself checks for the TransactionAttribute attribute \non such beans.  Public Getters for Entity Bean Fields For entity bean classes, the EJB 3.0 speci.cation \nstates [F]or every persistent property property of type T of the entity bean, there is a getter method \nnamed getProperty [21]. This is necessary to access the .elds since persistent .elds in entity bean classes \nmust either be declared private or protected. The following rule enforces such behavior: rule EJBExample2(ClassDef \nc){ where(isEntity(c)){ forall(VarDef v: c.varDefs){ require(hasGet(c,v)): error(v, \"Field \"+v.name+\" \ndoes not have \" +\"a getter method.\"); }}} declare hasGet(ClassDef c, VarDef v){ exists(MethodDef m: \nc.methodDefs){ where(m.name.equals( \"get\"+v.name.charAt (0). toUpper +v.name.substring(1,v.name.length \n))){ require(m.sym.isPublic); }}} Of particular note in this rule is JAVACOP s ability to utilize Java \ns libraries to perform transformations on the .eld s name. In this way, the proper getter method s name \ncan be enforced.  Business Method Exceptions The EJB 3.0 speci.cation says that the methods of [a] business \nin\u00adterface should not throw the java.rmi.RemoteException [21]. The rule to enforces this discipline is \nshown here, although predi\u00adcate de.nitions are omitted: rule EJBExample3(ClassDef c){ where((c.sym.hasAnnotation(\"Stateful\") \n|| c.sym.hasAnnotation(\"Stateless\")) &#38;&#38; !hasSessionInterface(c)){ forall(Type supr: c.supertypes){ \nwhere(supr.isInterface){ forall(Symbol m: supr.sym.methods){ forall(Type excp: m.thrown){ require(! \nhasGivenType(excp , \"java.rmi.RemoteException\")): warning(c,\"Business Interface \" +supr.fullName +\" \ndefines method \"+m.name +\" throwing RemoteException\"); }}}}}}  Since business interfaces are not determined \nby an annotation, the .rst where in this rule determines whether the interfaces imple\u00admented by a (stateful \nor stateless) session bean class are business interfaces. In the case that they are, the throws clause \nof each method of each business interface is then checked for the presence of the forbidden exception. \nPerhaps the most interesting feature of this rule is that it will check whether previously existing interfaces, \nwhich may predate EJB speci.cation, are safe to use as business interfaces. Generic Ownership Generic \nOwnership [44] is a type system that combines generic types and object ownership [16]. By building on \nan existing para\u00admetrically polymorphic language framework, Generic Ownership makes only minimal changes \nto an existing language to provide ownership, while simultaneously providing an ownership-based language \nthat is type-generic. We used JAVACOP to implement a version of the Generic Ownership language OGJ. Because \nGeneric Ownership depends heavily on parametric types, this implementa\u00adtion demonstrates that JAVACOP \ncan support sophisticated exten\u00adsions to parametric type systems. The full implementation is around 770 \nlines in 43 rules and predicates; in this section we present an overview of some of the key rules. Classes \nrequire owner parameters In OGJ, most programmer-de.ned classes are required to take an extra generic \nparameter to record their owner. This owner parameter must be declared to extend the class World (ogj.World \nin our implementation), and must be the last parameter provided, as in: class List<Element, Owner extends \nWorld > { ... In JAVACOP, we can enforce this behaviour as follows: rule RequireOwnerParameter(ClassDef \nc){ where(c.type.supertype == globals.objectType){ require(hasOwnerParameter(c.type) || isOwnerType(c.type)): \nerror(c, \"Toplevel class (\"+c.type+\") needs owner parameter\"); } where(hasOwnerParameter(c.type.supertype)){ \n require(c.type.typarams.last == c.type.supertype.typarams.last): error(c,\"Ownership not preserved when \n\"+ c.type+\" extends \"+c.type.supertype); } where(hasOwnerParameter(c.type )){  require(c.type.supertype \n== globals.objectType || hasOwnerParameter(c.type.supertype)): error(c,\"Owned type extends non-owned \ntype\"); } } This rule carries out a simple case analysis in its where clauses. Classes extending java.lang.Object \nmust declare a new owner parameter, while classes that extend another class must monoton\u00adically preserve \ntheir superclass s owner parameter. Finally, we re\u00adquire that classes may not be declared with an owner \nparameter unless they extend either Object or a superclass with an owner pa\u00adrameter. Preservation of \nownership The class formation rule above ensures that OGJ classes will al\u00adways have an owner parameter. \nWe then need to ensure that this information cannot be lost from an object s static type that is, we \nhave to prevent OGJ classes being cast to Java s raw types or to java.lang.Object. For example, consider \nthe following generic list of books: its elements are public Book objects owned by World, while the List \nitself is private, owned by This. Note that World and This are constants instantiating the owner parameters \nof List and Book [44]. List<Book<World>,This> l = new List<Book<World>, This>; Object obj = l; // loses \nownership information List rawList = l; // so do raw types In JAVACOP, this rule can be implemented \nas follows: rule preventRawCasting(sub <: supr @ e){ where(hasOwnerParameter(sub)){ require(!supr.isRaw): \nerror(e, \"Cast \"+sub+\" to raw type \"+supr); require(supr != globals.objectType): error(e,\"Cast \"+sub+\" \nto Object\"); }} This rule, like similar rules for Con.ned Types and other related systems, uses JAVACOP \ns subtyping rule form (see Section 2.4) to check all explicit and implicit casts. If the cast is from \na type with an owner parameter, we forbid that type from being cast to a raw type or Object.  Deep ownership \nThese two rules are suf.cient to ensure that every OGJ object has an owner that is known statically. \nOGJ however has a more structured ownership model, known as deep ownership , that establishes a transient \nowners-as-dominators property on the heap [44]. This means that private data (e.g., data owned by This) \nmust not be stored in publically-accessible structures. For example, code such as: List<Book<World>,This> \nl = new ...; that declares a private list of public Book objects is quite permissi\u00adble, but the alternative: \nList<Book<This>,World> l = new ...; must be prevented. In JAVACOP, this rule requires some quite complex \nconstraints on generic class instantiation especially because owners can be represented by type parameters \nsuch as (but not limited to) the Owner parameter of every OGJ class. Following the OGJ formal system \n[44], we consider each class de.nition, and (using JAVACOP s forall quanti.er over a tree) recursively \ncheck that all types present within the class are well formed for deep ownership. rule wellFormedTypes(ClassDef \nc){ forall(Tree t : c){ where(t.type instanceof ClassType &#38;&#38; !t instanceof ClassDef){ require(wellformed(t.type)): \nerror(t,\"Type \"+t.type+\" of \"+t+\" not well formed for deep ownership\"); }}}  The bulk of the work then \nis done by the wellformed predicate. First, types that don t take parameters (mostly primitive types, \nvoid, null, and packages) are considered well formed, as are type variables. declare wellformed(Type \nt){ require(unparameterizable(t)); } declare wellformed(TypeVar v){ require(true); } Second, for types \nthat do not have an owner parameter (presumably Java class types that are being used in OGJ programs), \nwe check that all their generic type parameters (typarams) are well formed. declare wellformed(ClassType \nc){ require(! hasOwnerParameter(c)); forall(Type prmtype: c.typarams){ require(wellformed(prmtype)); \n}}  Finally we check that each generic type instantiation is well formed: declare wellformed(ClassType \nc){ require(Type ownerofC; ownerofC <-c.typarams.last){ forall(Type prmtype: c.typarams){ where(isOwnerType(prmtype)){ \nrequire( isDeepOwnerSubtype(ownerofC, prmtype)); } where(Type ownerofPrmType ; ownerofPrmType <\u00adprmtype.classBound.typarams.last){ \nwhere(isOwnerType(ownerofPrmType )){ require(isDeepOwnerSubtype(ownerofC , ownerofPrmType )); }}}} forall(Type \nprmtype: c.typarams){ require(wellformed(prmtype)); }}  This rule fetches the class s owner (ownerofC) \nfrom the instan\u00adtiation of the last (ownership) generic type parameter, and then iterates over each of \nthe type parameters. If the parameter is a naked owner parameter (i.e., it extends World) then we check \nthat the parameter is outside the class s owner (via the auxiliary isDeepOwnerSubtype predicate); alternatively \nif the parameter is an OGJ class, we fetch its owner (ownerofPrmType)inturn from its last parameter, \nand check that that owner is valid. The isDeepOwnerSubtype predicate directly encodes the OGJ own\u00adership \nsubtyping relationship [44]. To .nish, we again recurse through all the type parameters. Instance encapsulation \nThese three rules work together to provide and statically enforce a dynamic model where objects are deeply \nnested inside each other. The .nal rule uses this structure to enforce strong object encapsulation: private \ndata may only be accessed from within their owners. For example, the following code declares an encapsulated \nlist within the Catalogue class: class Catalogue <Owner extends World >{ List<Book<World>,This> myList; \n int volumes() {return myList.size();} } This list can be accessed freely inside the current instance \nof the class but cannot be used outside it, because types owned by This may only be accessed (explicitly \nor implicitly) via this. Catalogue cat = ...; ...cat.myList.size(); // error as myList is private. \nIn JAVACOP, properly expressing this rule requires handling a number of cases. We begin with a rule that \ncatches Java s . dot selection operator via JAVACOP s Select AST node, and then simply delegates to the \nJAVACOP validThisSelect predicate: rule OGJThisSelect(Select s){ require(validThisSelect(s)): warning(s,\"Invalid \nselect on \"+s.type); } The validThisSelect predicate clauses catch various forms of dot operator. First, \nwe permit any calls via this and any uses of the dot operator to construct compound types: declare validThisSelect(Select \ns){ require(s => [this.*] || s.sym instanceof TypeSymbol); } Next, we check each case of the Select \nnode these clauses catch method sends and variable accesses and require that their generic type arguments \ndo not include This via the thislessType predicate. declare validThisSelect(Select s){ require(s.type \ninstanceof MethodType){ require(thislessType(s.sym.type )); } declare validThisSelect(Select s){ require(s.sym \ninstanceof VarSymbol){ require(thislessType(s.sym.type )); } Finally, we have a series of predicates \nthat recursively de.ne a thisless type as being a type which does not involve the owner This in any of \nits generic type parameters. declare thislessType(Type t){ require(unparameterizable(t)); } declare \nthislessType(ClassType c){ require(!(c.fullName.equals(\"ogj.This\"))); forall(Type t: c.allparams){ require(thislessType(t)); \n}} The full OGJ ruleset straightforwardly extends these cases to cover Java s other types and selection \nconstructs.  PMD style checking rules PMD is a popular utility for Java that scans application code \nfor code patterns that match stylistic rules [18]. Such rules encode behavior for .nding potential bugs \nand suboptimal code. However, these rules can be dif.cult to create and many are dif.cult to understand. \nJAVACOP is fully capable of recreating these rules in a more readable and declarative fashion. To show \nthis, we implemented the basic and .nalizers rulesets from PMD, which describe purely structural properties \nthat are considered bad style or bugs, as 23 JAVACOP rules and 12 declarations. The .ne-grained error \nmark\u00ading and reporting of JAVACOP makes reporting violations of these rules .exible and robust. We show \ntwo examples here:  Unconditional Ifs A common coding discipline that PMD implements is that if statements \nshould not be guarded by boolean literals. PMD rules may be written as Java code or in XPath, making \nthe rules relatively tedious for programmers to understand. For example, PMD s XPath implementation of \nthis rule is shown below. // IfStatement / Expression [ count ( PrimaryExpression ) =1] / PrimaryExpression \n/ PrimaryPrefix /Literal/ BooleanLiteral In JAVACOP, this same rule can be implemented as follows: rule \nPMDExample1(If i){ require(!(i => [if(true)%])): warning(i.cond,\"Body of this if \" +\"always executed\"); \nrequire(!(i => [if(false)%])): warning(i.cond,\"Body of this if \" +\"never executed\"); } Although longer \nthan the XPath rule, the JAVACOP rule is more readable and is a better approximation of a traditional \ntype rule through its use of pattern matching. JAVACOP s error clauses also allow it to produce meaningful \nerror messages if an unconditional if statement is detected. Empty Statements Another PMD rule focuses \non empty statements, or semicolons without an associated expression. PMD considers such code when not \nused in conjunction with a loop as either redundant or a bug. The JAVACOP version of this rule is: rule \nPMDExample2(Skip s){ require(env.tree instanceof Block &#38;&#38; skipOnlyLoop(env.next.tree, s)): warning(s, \n\"Empty statement in block\"); } declare skipOnlyLoop(ForLoop l, Skip s){ require(skipOnlyBlock(l.body, \ns)); } declare skipOnlyLoop(WhileLoop l, Skip s){ require(skipOnlyBlock(l.body, s)); } declare skipOnlyLoop(DoLoop \nl, Skip s){ require(skipOnlyBlock(l.body, s)); } declare skipOnlyBlock(Block b, Skip s){ require( b \n=> [{ s }]); } The .rst require in this rule ensures that the empty statement is directly enclosed within \na Block, and then passes the next en\u00adclosing Tree to the skipOnlyLoop predicate. The skipOnlyLoop predicate \ndispatches on the type of the Tree passed to it, fail\u00ading unless the Tree is a ForLoop, WhileLoop or \na DoLoop node, in which cases it uses the skipOnlyBlock predicate to test that the Skip statement is \nthe only element in the loop body. The skipOnlyBlock predicate uses a pattern match expression to en\u00adsure \nthat the argument Block b matches a Block containing only one statement, which is equal to the JAVACOP \nexpression s inthe current scope, that is, the Skip statement. PMD s XPath equivalent for this rule, \nshown below, is particu\u00adlarly dif.cult to read and debug. //Statement/EmptyStatement [not( ../../../ForStatement \nor ../../../WhileStatement or ../../../BlockStatement/ClassOrInterfaceDeclaration or ../../../../../../ForStatement/Statement[1] \n /Block[1]/BlockStatement[1]/Statement/EmptyStatement or ../../../../../../WhileStatement/Statement[1] \n/Block[1]/BlockStatement[1]/Statement/EmptyStatement) ]  Micro Patterns Micro patterns [31] are commonly \nused coding idioms that occur at a low level of abstraction. For example, the .rst micro pattern, Designator,isde.nedas \nan interface with absolutely no members. While a programmer may not develop an application with these \nmicro patterns in mind, identifying which micro patterns are being used, and how frequently, can give \ninsight into the broader behavior of a large application. To illustrate the utility of JAVACOP beyond \ndetecting errors, we implemented the Degenerate Classes micropatternsasasetof seven rules and seven declarations, \nwhich print a warning when a micro pattern is identi.ed. Checking an application s code with these rules \nwill then create a data set that can be analysed further. We present a representative rule that detects \nthree micro patterns for interfaces with no members: Designator (no members), Taxonomy (no members, but \nextends one interface), and Joiner (no members, but extends two or more interfaces). Any Taxonomy or \nJoiner interfaces are, by de.nition, also Designators. rule MicroPatternsExample(ClassDef c){ where(c.isInterface \n&#38;&#38; c.sym.members.length == 0){ require(false): warning(globals.NOPOS , \"Designator: \"+c.flatName); \nrequire(c.interfaces.length != 1): warning(globals.NOPOS , \"Taxonomy: \"+c.flatName); require(c.interfaces.length \n< 2): warning(globals.NOPOS , \"Joiner: \"+c.flatName); }}  Software Metrics Chidamber and Kemerer [13] \nde.ned one of the earliest sets of metrics for object-oriented systems. The six metrics they de.ned include: \nnumber of methods per class; depth of inheritance hierar\u00adchy; number of children; coupling between objects; \nresponse set of objects; and lack of cohesion of methods. We have written 9 rules (with no auxiliary \ndeclarations) to support gathering all of these metrics in JAVACOP. As with the micro patterns, our JAVACOP \nrules issue warnings when the basic data for the metrics is encoun\u00adtered: an external tool (a simple \nshell script) can analyse this data to derive the metrics. The following pair of JAVACOP rules deter\u00admines \ncoupling between objects. rule MetricsExample(Select s){ where(env.enclClass != null){ where(ClassSymbol \notherclass; otherclass <-s.getSymbol){ require(otherclass == env.enclClass.sym): warning(globals.NOPOS \n, env.enclClass.sym.flatName  +\" couples to \"+otherclass.flatName); }}} rule MetricsExample(Ident i){ \n where(env.enclClass != null){ where(ClassSymbol otherclass; otherclass <-i.getSymbol){ require(otherclass \n== env.enclClass.sym): warning(globals.NOPOS , env.enclClass.sym.flatName +\" couples to \"+otherclass.flatName); \n }}}  These two rules join on both dot selection and identi.er AST nodes. If we are in the context of \na class de.nition and the selection or identi.er node refers to a class other than that of the surrounding \nde.nition, we report that the enclosing class is coupled to the node s class.  References [1] C. Andreae. \nJavaCOP user-de.ned constraints on Java programs. Honours Report, Computer Science, Victoria University \nof Welling\u00adton, 2005. [2] C. Andreae, Y. Coady, C. Gibba, J. Noble, J. Vitek, and T. Zhao. STARS: Scoped \ntypes and aspects for real-time systems. In Proceedings of ECOOP 06, 2006. [3] K. Arnold, J. Gosling, \nand D. Holmes. The Java Programming Language Third Edition. Addison-Wesley, Reading, MA, third edition, \n2000. [4] T. Ball and S. K. Rajamani. The SLAM project: Debugging system software via static analysis. \nIn Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages \n1 3. ACM Press, 2002. [5] A. Birka and M. D. Ernst. A practical type system and language for reference \nimmutability. In OOPSLA Proceedings, pages 35 49, New York, NY, USA, 2004. ACM Press. [6] J. Bloch. A \nmetadata facility for the Java programming language. Technical Report JSR 175, www.jcp.org, 2002. [7] \nJ. Boyland, J. Noble, and W. Retert. Capabilities for sharing: A generalisation of uniqueness and read-only. \nIn ECOOP Proceedings, 2001. [8] G. Bracha. Pluggable type systems. In OOPSLA Workshop on Revival of Dynamic \nLanguages, 2004. [9] G. Bracha and D. Ungar. Mirrors: Design principles for meta-level facilities of \nobject-oriented programming languages. In OOPSLA Proceedings, 2004. [10] R. Cartwright and M. Fagan. \nSoft typing. In PLDI Proceedings, 1991. [11] Checkstyle Developers. Checkstyle. http://checkstyle.\u00adsourceforge.net, \n2005. [12] S. Chiba. Load-time structural re.ection in Java. In ECOOP Proceedings, 2000. [13] S. R. Chidamber \nand C. F. Kemerer. Towards a metrics suite for object oriented design. In OOPSLA Proceedings, 1991. [14] \nB. Chin, S. Markstrum, and T. Millstein. Semantic type quali.ers. In ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation (PLDI 2005), June 2005. [15] B. Chin, S. Markstrum, T. Millstein, \nand J. Palsberg. Inference of user\u00adde.ned type quali.ers and quali.er rules. In European Symposium on \nProgramming, 2006. [16] D. G. Clarke, J. M. Potter, and J. Noble. Ownership types for .exible alias protection. \nIn OOPSLA Proceedings, pages 48 64. ACM Press, 1998. [17] T. Cohen, J. Y. Gil, and I. Maman. JTL the \nJava tools language. In OOPSLA Proceedings, Oct. 2006. [18] T. Copeland. PMD Applied. Centennial Books, \nNov. 2005. [19] R. F. Crew. ASTLOG: a language for examining abstract syntax trees. In Proceedings of \nthe USENIX Conference on Domain-Speci.c Languages, Santa Barbara, Oct. 1997. [20] J. Darcy. Pluggable \nannotation processing API, 2005. [21] L. DeMichiel. Enterprise JavaBeans Speci.cation, Version 3.0. SUN \nMicrosystems, 2004. [22] C. K. Duby, S. Meyers, and S. P. Reiss. CCEL: A metalanguage for C++. In C++ \nConference, pages 99 116, 1992. [23] M. Eichberg, M. Mezini, K. Ostermann, and T. Sch\u00a8afer. Xirc: A kernel \nfor cross-artifact information engineering in software development environments. In Working Conference \non Reverse Engineering, 2004. [24] M. Eichberg, T. Sch\u00a8afer, and M. Mezini. Using annotations to check \nstructural properties of classes. In FASE, 2005. [25] T. Ekman and G. Hedin. Rewritable reference attributed \ngrammars. In ECOOP Proceedings, 2004. [26] M. Fahndrich and K. R. M. Leino. Declaring and checking non-null \ntypes in an object-oriented language. In OOPSLA Proceedings, 2003. [27] C. Flanagan and S. N. Freund. \nType-based race detection for Java. In Proceedings of the ACM SIGPLAN 2000 conference on Programming \nlanguage design and implementation, pages 219 232. ACM Press, 2000. [28] J. S. Foster,M.F\u00a8ahndrich, and \nA. Aiken. A Theory of Type Quali.ers. In Proceedings of the 1999 ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, pages 192 203, Atlanta, Georgia, May 1999. [29] J. S. Foster, T. \nTerauchi, and A. Aiken. Flow-sensitive type quali.ers. In Proceedings of the ACM SIGPLAN 2002 Conference \non Programming language design and implementation, pages 1 12. ACM Press, 2002. [30] C. Gibbs and Y. \nCoady. Making real-time abstractions concrete with aspects. In The 3rd Workshop on Java Technologies \nfor Real-time and Embedded Systems, 2005. Held in conjunction with OOPSLA 2005. [31] J. Y. Gil and I. \nMaman. Micro patterns in Java code. In OOPSLA Proceedings, 2005. [32] J. Gosling, B. Joy, G. Steele, \nand G. Bracha. The Java Language Speci.cation Second Edition. The Java Series. Addison-Wesley, Boston, \nMass., 2000. [33] E. Hajiyev, M. Verbaere, and O. de Moor. Codequest: Scalable source code queries with \ndatalog. In ECOOP Proceedings, 2006. [34] E. Hajiyev, M. Verbaere, O. de Moor, and K. de Volder. Codequest: \nQuerying source code with datalog. In OOPSLA Companion, 2005. [35] S. Hallem, B. Chelf, Y. Xie, and \nD. Engler. A system and language for building system-speci.c, static analyses. In PLDI Proceedings, 2002. \n[36] J. Hogg. Islands: aliasing protection in object-oriented languages. In OOPSLA Proceedings, pages \n271 285. ACM Press, 1991. [37] D. Hovemeyer and W. Pugh. Finding bugs is easy. In OOPSLA Companion, 2004. \n[38] A. Igarashi, B. C. Pierce, and P. Wadler. Featherweight Java: a minimal core calculus for Java and \nGJ. ACM Transactions on Programming Languages and Systems, 23(3):396 450, May 2001. [39] D. Janzen and \nK. D. Volder. Navigating and querying code without getting lost. In AOSD Proceedings, 2003. [40] S. Marlow \nand P. Wadler. A practical subtyping system for Erlang. In ICFP Proceedings, 1997. [41] N. Nystrom, M. \nR. Clarkson, and A. C. Myers. Polyglot: An extensible compiler framework for Java. In Proceedings of \nCC 2003: 12 th International Conference on Compiler Construction. Springer-Verlag, Apr. 2003. [42] N. \nNystrom, X. Qi, and A. C. Myers. J&#38;: software composition with nested intersection. In OOPSLA Proceedings, \n2006. [43] OVM/J Consortium. The open virtual machine project. http://www.ovmj.org/, 2004. [44] A. Potanin, \nJ. Noble, D. Clarke, and R. Biddle. Generic ownership for generic Java. In OOPSLA Proceedings, 2006. \n[45] M. Shomrat and A. Yehudai. Obvious or not?: regulating architectural decisions using aspect-oriented \nprogramming. In AOSD Proceedings, 2002. [46] M. Tatsubori, S. Chiba, M.-O. Killijiand, and K. Itano. \nOpenJava: A class-based macro system for Java. In Re.ection and Software Engineering, volume 1826 of \nLNCS, 2000. [47] M. S. Tschantz and M. D. Ernst. Javari: adding reference immutability to Java. In OOPSLA \nProceedings, pages 211 230, New York, NY, USA, 2005. ACM Press. [48] M. Verbaere, R. Ettinger, and O. \nde Moor. JunGL: a scripting language for refactoring. In Proceedings of the 28th International Conference \non Software Engineering (ICSE), 2006. [49] J. Vitek and B. Bokowski. Con.ned types. In OOPSLA Proceedings, \n1999. [50] A. K. Wright and R. Cartwright. A practical soft type system for scheme. TOPLAS, 19(1):87 \n152, 1997. [51] T. Zhao, J. Noble, and J. Vitek. Scoped types for real-time Java. In RTSS Proceedings, \n2004. \n\t\t\t", "proc_id": "1167473", "abstract": "Pluggable types have been proposed to support multiple type systems in the same programming language. We have designed and implemented J<sc>ava</sc>COP, a program constraint system for implementing practical pluggable type systems for Java. J<sc>ava</sc>COP enforces user-defined typing constraints written in a declarative and expressive rule language. We have validated our design by (re)implementing a range of type systems and program checkers. By using a program constraint system to implement pluggable types, programmers are able to check that their programs will operate correctly in restricted environments, adhere to strict programming rules, avoid null pointer errors or scoped memory exceptions, and meet style guidelines, while programming language researchers can easily experiment with novel type systems.", "authors": [{"name": "Chris Andreae", "author_profile_id": "81316487471", "affiliation": "Victoria University of Wellington", "person_id": "P797730", "email_address": "", "orcid_id": ""}, {"name": "James Noble", "author_profile_id": "81100588708", "affiliation": "Victoria University of Wellington", "person_id": "PP18009664", "email_address": "", "orcid_id": ""}, {"name": "Shane Markstrum", "author_profile_id": "81100292142", "affiliation": "University of California, Los Angeles, CA", "person_id": "P669741", "email_address": "", "orcid_id": ""}, {"name": "Todd Millstein", "author_profile_id": "81100018064", "affiliation": "University of California, Los Angeles, CA", "person_id": "PP14019523", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167479", "year": "2006", "article_id": "1167479", "conference": "OOPSLA", "title": "A framework for implementing pluggable type systems", "url": "http://dl.acm.org/citation.cfm?id=1167479"}