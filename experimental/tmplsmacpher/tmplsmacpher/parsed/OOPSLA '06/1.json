{"article_publication_date": "10-16-2006", "fulltext": "\n J&#38;: Nested Intersection for Scalable Software Composition Nathaniel Nystrom Xin Qi Andrew C. Myers \nComputer Science Department Cornell University {nystrom,qixin,andru}@cs.cornell.edu Abstract This paper \nintroduces a programming language that makes it conve\u00adnient to compose large software systems, combining \ntheir features in a modular way. J&#38; supports nested intersection, building on ear\u00adlier work on nested \ninheritance in the language Jx. Nested inher\u00aditance permits modular, type-safe extension of a package \n(includ\u00ading nested packages and classes), while preserving existing type relationships. Nested intersection \nenables composition and exten\u00adsion of two or more packages, combining their types and behavior while \nresolving con.icts with a relatively small amount of code. The utility of J&#38; is demonstrated by using \nit to construct two com\u00adposable, extensible frameworks: a compiler framework for Java, and a peer-to-peer \nnetworking system. Both frameworks support composition of extensions. For example, two compilers adding \ndif\u00adferent, domain-speci.c features to Java can be composed to obtain a compiler for a language that \nsupports both sets of features. Categories and Subject Descriptors D.3.2 [Language Classi.\u00adcations]: \nObject-oriented languages; D.3.3 [Language Constructs and Features]: Classes and objects, frameworks, \ninheritance, mod\u00adules, packages General Terms Languages Keywords nested intersection, nested inheritance, \ncompilers  1. Introduction Most software is constructed by extending and composing exist\u00ading code. \nExisting mechanisms like class inheritance address the problem of code reuse and extension for small \nor simple exten\u00adsions, but do not work well for larger bodies of code such as com\u00adpilers or operating \nsystems, which contain many mutually depen\u00addent classes, functions, and types. Moreover, these mechanisms \ndo not adequately support composition of multiple interacting classes. Better language support is needed. \nThis paper introduces the language J&#38; (pronounced Jet ), which supports the scalable, modular composition \nand extension of large software frameworks. J&#38; builds on the Java-based lan\u00adguage Jx, which supports \nscalable extension of software frame\u00adworks through nested inheritance [35]. J&#38; adds a new language \nfeature, nested intersection, which enables composition of multi- Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 06 October 22 26, 2006, Portland, Oregon, \nUSA. Copyright c . 2006 ACM 1-59593-348-4/06/0010. . . $5.00. ple software frameworks to obtain a software \nsystem that combines their functionality. Programmers are familiar with a simple form of software com\u00adposition: \nlinking, which works when the composed software com\u00adponents offer disjoint, complementary functionality. \nIn the general case, two software components are not disjoint. They may in fact offer similar functionality, \nbecause they extend a common ancestor component. Composing related frameworks should integrate their \nextensions rather than duplicating the extended components. It is this more general form of software \ncomposition that nested inter\u00adsection supports. A motivating example for software composition is the \nproblem of combining domain-speci.c compiler extensions. We demon\u00adstrate the utility of nested intersection \nthrough a J&#38; compiler framework for implementing domain-speci.c extensions to the Java language. \nUsing the framework, which is based on the Poly\u00adglot compiler framework [36], one can choose useful language \nfea\u00adtures for a given application domain from a menu of available op\u00adtions, then compose the corresponding \ncompilers to obtain a com\u00adpiler for the desired language. We identify the following requirements for \ngeneral extension and composition of software systems: 1. Orthogonal extension: Extensions may require \nboth new data types and new operations. 2. Type safety: Extensions cannot create run-time type errors. \n 3. Modularity: The base system can be extended without modify\u00ading or recompiling its code. 4. Scalability: \nExtensions should be scalable. The amount of code needed should be proportional to the functionality \nadded. 5. Non-destructive extension: The base system should still be available for use within the extended \nsystem. 6. Composability of extensions.  The .rst three of these requirements correspond to Wadler \ns ex\u00adpression problem [49]. Scalability (4) is often but not necessarily satis.ed by supporting separate \ncompilation; it is important for ex\u00adtending large software. Non-destructive extension (5) enables ex\u00adisting \nclients of the base system and also the extended system itself to interoperate with code and data of \nthe base system, an important requirement for backward compatibility. Nested inheritance [35] addresses \nthe .rst .ve requirements, but it does not support exten\u00adsion composition. Nested intersection adds this \ncapability. This paper describes nested intersection in the J&#38; language and our experience using \nit to compose software. Section 2 consid\u00aders a particularly dif.cult instantiation of the problem of \nscalable extensibility and composition the extension and composition of compilers and gives an informal \nintroduction to nested intersec\u00adtion and J&#38;. Nested intersection creates several interesting techni\u00adcal \nchallenges, such as the problem of resolving con.icts among composed packages; this topic and a detailed \ndiscussion of lan\u00adguage semantics are presented in Section 3. Section 4 then de\u00adscribes how nested intersection \nis used to extend and compose com\u00adpilers. The implementation of J&#38; is described in Section 5, and \nSec\u00adtion 6 describes experience using J&#38; to implement and compose extensions in the Polyglot compiler \nframework and in the Pastry framework for building peer-to-peer systems [44]. Related work is discussed \nin Section 7, and the paper concludes in Section 8. 2. Nested intersection Nested intersection supports \nscalable extension of a base system and scalable composition of those extensions. Consider building a \ncompiler with composable extensions. A compiler is of course not the only system for which extensibility \nis useful; other examples include user interface toolkits, operating systems, game engines, web browsers, \nand peer-to-peer networks. However, compilers are a particularly challenging domain because a compiler \nhas several different interacting dimensions along which it can be extended: syntax, types, analyses, \nand optimizations. 2.1 Nested inheritance Nested intersection builds on previous work on nested inheri\u00adtance \n[35]. Figure 1(a) shows a fragment of J&#38; code for a simple compiler for the lambda calculus extended \nwith pair expressions. This compiler translates the lambda calculus with pairs into the lambda calculus \nwithout pairs. Nested inheritance is inheritance of namespaces: packages and classes. In J&#38;, packages \nare treated like classes with no .elds, methods, or constructors. A namespace may contain other name\u00adspaces. \nA namespace may also extend another namespace, inher\u00aditing all its members, including nested namespaces. \nAs with or\u00addinary inheritance, the meaning of code inherited from the base namespace is as if it were \ncopied down from the base. A derived namespace may override any of the members it inherits, including \nnested classes and packages. As with virtual classes [29, 30, 19], overriding of a nested class does \nnot replace the original class, but instead re.nes, or further binds [29], it. If a namespace T ' extends \nanother namespace T that contains a nested namespace T.C,then T '.C inherits mem\u00adbers from T.C as well \nas from T '.C s explicitly named base name\u00adspaces (if any). Further binding thus provides a limited form \nof multiple inheritance: explicit inheritance from the named base of T ' .C and induced inheritance from \nthe original namespace T.C. Unlike with virtual classes, T '.C is also a subtype of T.C.InFig\u00adure 1(a), \nthe pair package extends the base package, further bind\u00ading the Visitor, TypeChecker,and Compiler classes, \nas illus\u00adtrated by the base and pair boxes in the inheritance hierarchy of Figure 2. The class pair.TypeChecker \nis a subclass of both base.TypeChecker and pair.Visitor and contains both the visitAbs and visitPair \nmethods. The key feature of nested inheritance that enables scalable ex\u00adtensibility is late binding of \ntype names. When the name of a class or package is inherited into a new namespace, the name is inter\u00adpreted \nin the context of the namespace into which it was inherited, rather than where it was originally de.ned. \nWhen the name occurs in a method body, the type it represents may depend on the run-time value of this. \nIn Figure 1(a), the name Visitor, in the context of the base package, refers to base.Visitor. In the \ncontext of pair,which inherits from base, Visitor refers to pair.Visitor. Thus, when the method accept \nis called on an instance of pair.Pair,it must be called with a pair.Visitor, not with a base.Visitor.This \nallows Pair s accept to invoke the visitPair method of the parameter v. Figure 2. Inheritance hierarchy \nfor compiler composition Late binding applies to supertype declarations as well. Thus, pair.Emitter \nextends pair.Visitor and inherits its visitPair method. Late binding of supertype declarations thus provides \na form of virtual superclasses [30, 15], permitting inher\u00aditance relationships among the nested namespaces \nto be preserved when inherited into a new enclosing namespace. The class hier\u00adarchy in the original namespace \nis replicated in the derived name\u00adspace, and in that derived namespace, when a class is further bound, \nnew members added into it are automatically inherited by sub\u00adclasses in the new hierarchy. Sets of mutually \ndependent classes may be extended at once. by grouping them into a namespace. For example, the classes \nExp and Visitor in the base package are mutually dependent. Ordinary class inheritance does not work \nbecause the extended classes need to know about each other: the pair compiler could de.ne Pair as a new \nsubclass of Exp, but references within Exp to class Visitor would refer to the old base version of Visitor, \nnot the appropriate one that understands how to visit pairs. With nested inheritance of the containing \nnamespace, late binding of type names ensures that relationships between classes in the original namespace \nare preserved when these classes are inherited into a new namespace. In general, the programmer may want \nsome references to other types to be late bound, while others should refer to a particular .xed class. \nLate binding is achieved by interpreting unquali.ed type names like Visitor as sugar for types nested \nwithin dependent classes and pre.x types. The semantics of these types are described in more detail in \nSection 3. Usually, the programmer need not write down these desugared types; most J&#38; code looks \nand behaves like Java code. 2.2 Extensibility requirements Nested inheritance in Jx meets the .rst .ve \nrequirements described in Section 1, making it a useful language for implementing exten\u00adsible systems \nsuch as compiler frameworks: Orthogonal extension. Compiler frameworks must support the addition of both \nnew data types (e.g., abstract syntax, types, data.ow analysis values) and operations on those types \n(e.g., type checking, optimization, translation). It is well known that there is package base; package \npair extends base; abstract class Exp { class Pair extends Exp { Type type; Exp fst, snd; abstract Exp \naccept(Visitor v); Exp accept(Visitor v) { } fst.accept(v); snd.accept(v); class Abs extends Exp { return \nv.visitPair(this); String x; Exp e; // .x.e } Exp accept(Visitor v) { } e = e.accept(v); class Visitor \n{ return v.visitAbs(this); Exp visitPair(Pair p) { return p; } }} } class TypeChecker extends Visitor \n{ class Visitor { Exp visitPair(Pair p) { ... } Exp visitAbs(Abs a) { } return a; class TranslatePairs \nextends Visitor { } Exp visitPair(Pair p) { } return ...; class TypeChecker extends Visitor { // (.x..y.. \nf . fxy) [p.fst][p.snd] Exp visitAbs(Abs a) { ... } } }} class Emitter extends Visitor { class Compiler \n{ Exp visitAbs(Abs a) { void main() { print(...); return a; Exp e = parse();  } e.accept(new TypeChecker()); \n} e = e.accept(new TranslatePairs()); class Compiler { e.accept(new Emitter()); void main() { ... } } \nExp parse() { ... } Exp parse() { ... } }} (a) Lambda calculus + pairs compilers package sum extends \nbase; class Case extends Exp { Exp test, ifLeft, ifRight; ... } class Visitor { Exp visitCase(Case c) \n{ return c; } } class TypeChecker extends Visitor { ... } class TranslateSums extends Visitor { ... } \nclass Compiler { void main() { ... } Exp parse() { ... } } (b) Lambda calculus + sums compiler package \npair_and_sum extends pair &#38; sum; // Resolve conflicting versions of main class Compiler { void main() \n{ Exp e = parse(); e.accept(new TypeChecker()); e = e.accept(new TranslatePairs()); e = e.accept(new \nTranslateSums()); e.accept(new Emitter()); } Exp parse() { ... } } (c) Con.ict resolution Figure 1. \nCompiler composition a tension between extending types and extending the procedures that manipulate them \n[42]. Nested inheritance solves this problem because late binding of type names causes inherited methods \nto op\u00aderate automatically on data types further bound in the inheriting context. Type safety. Nested \ninheritance is also type-safe [35]. Dependent classes ensure that extension code cannot use objects of \nthe base system or of other extensions as if they belonged to the extension, which could cause run-time \nerrors. Modularity and scalability. Extensions are subclasses (or sub\u00adpackages) and hence are modular. \nExtension is scalable for several reasons; one important reason is that the name of every method, .eld, \nand class provides a potential hook that can be used to extend behavior and data representations. Non-destructive \nextension. Nested inheritance does not affect the base code, so it is a non-destructive extension mechanism, \nunlike open classes [12] and aspects [27]. Therefore, base code and extended code can be used together \nin the same system, which is important in extensible compilers because the base language is often used \nas a target language in an extended compiler. The sixth requirement, composition of extensions, is discussed \nin the next section.  2.3 Composition To support composition of extensions, J&#38; extends Jx with nested \nintersection: New classes and packages may be constructed by inheriting from multiple packages or classes; \nthe class hierarchies nested within the base namespaces are composed to achieve a composition of their \nfunctionalities. For two namespaces S and T , S &#38; T is the intersection of these two namespaces. \nNested intersection is a form of multiple inheri\u00adtance implemented using intersection types [43, 13]: \nS &#38; T inherits from and is a subtype of both S and T . Nested intersection is most useful when composing \nrelated packages or classes. When two namespaces that both extend a com\u00admon base namespace are intersected, \ntheir common nested name\u00adspaces are themselves intersected: if S and T contain nested name\u00adspaces S.C \nand T.C, the intersection S &#38; T contains (S &#38; T ).C,which is equal to S.C &#38; T.C. Consider \nthe lambda calculus compiler from Figure 1(a). Sup\u00adpose that we had also extended the base package to \na sum package implementing a compiler for the lambda calculus extended with sum types. This compiler \nis shown in Figure 1(b). The intersection package pair &#38; sum, shown in Fig\u00adure 2, composes the two \ncompilers, producing a com\u00adpiler for the lambda calculus extended with both product and sum types. Since \nboth pair and sum contain a class Compiler, the new class (pair &#38; sum).Compiler extends both pair.Compiler \nand sum.Compiler. Because both pair.Compiler and sum.Compiler de.ne a method main,the class (pair &#38; \nsum).Compiler contains con.icting versions of main. The con.ict is resolved in Figure 1(c) by creating \na new derived package pair and sum that overrides main, de.ning the order of compiler passes for the \ncomposed compiler. A similar con.ict occurs with the parse method.   3. Semantics of J&#38; This section \ngives an overview of the static and dynamic semantics of J&#38;. A formal presentation of the J&#38; \ntype system is omitted for space but can be found in an associated technical report [37]. 3.1 Dependent \nclasses and pre.x types In most cases, J&#38; code looks and behaves like Java code. However, unquali.ed \ntype names are really syntactic sugar for nested classes of dependent classes and pre.x types, introduced \nin Jx [35]. The dependent class p.class represents the run-time class of the object referred to by the \n.nal access path p. A .nal access path is either a .nal local variable, including this and .nal formal \nparameters, or a .eld access p.f,where p is a .nal access path and f is a .nal .eld of p. In general, \nthe class represented by p.class is statically unknown, but .xed: for a particular p, all instances of \np.class have the same run-time class, and not a proper subclass, as the object referred to by p. The \npre.x type P[T ] represents the enclosing namespace of the class or interface T that is a subtype of \nthe namespace P. It is required that P be a non-dependent type: either a top-level namespace C or a namespace \nof the form P ' .C. In typical use T is a dependent class. P may be either a package or a class. Pre.x \ntypes provide an unambiguous way to name enclosing classes and packages of a class without the overhead \nof storing references to enclosing instances in each object, as is done in virtual classes. Indeed, if \nthe enclosing namespace is a package, there are no run\u00adtime instances of the package that could be used \nfor this purpose. Late binding of types is provided by interpreting unquali.ed names as members of the \ndependent class this.class or of a pre\u00ad.x type of this.class. The compiler resolves the name C to the \ntype this.class.C if the immediately enclosing class contains or inherits a nested namespace named C. \nSimilarly, if an enclosing namespace P other than the immediately enclosing class contains or inherits \nC, the name C resolves to P[this.class].C. Derived namespaces of the enclosing namespace may further \nbind and re\u00ad.ne C.The version of C selected is determined by the run-time class of this. For example, \nin Figure 1(a), the name Visitor is sugar for the type base[this.class].Visitor. The dependent class \nthis.class represents the run-time class of the object referred to by this. The pre.x package base[this.class] \nis the enclos\u00ading package of this.class that is a derived package of base. Thus, if this is an instance \nof a class in the package pair, base[this.class] represents the package pair. Both dependent classes \nand pre.xes of dependent classes are exact types [5]: all instances of these types have the same run-time \nclass, but that class is statically unknown in general. Simple types like base.Visitor are not exact \nsince variables of this type may contain instances of any subtype of Visitor. J&#38; provides a form \nof family polymorphism [17]. All types indexed by a given dependent class the dependent class itself, \nits pre.x types, and its nested classes are members of a fam\u00adily of interacting classes and packages. \nBy initializing a variable with instances of different classes, the same code can refer to classes in \ndifferent families with different behaviors. In the con\u00adtext of a given class, other classes and packages \nnamed using this.class are in the same family as the actual run-time class of this. In Figure 1(a), pair.Pair.accept \ns formal parameter v has type base[this.class].Visitor.If this is a pair.Pair, base[this.class].Visitor \nmust be a pair.Visitor, ensuring the call to visitPair is permitted. The type system ensures that types \nin different families (and hence indexed by different access paths) cannot be confused with each other \naccidentally: a base object cannot be used where a pair object is expected, for example. However, casts \nwith run-time type class A { class B {} void m() {} } class A1 extends A { class A2 extends A { classB{} \nclassB{} classC{} classC{} voidm(){} voidm(){} voidp(){} voidp(){} }} abstract class D extends A1 &#38; \nA2 { } Figure 3. Multiple inheritance with name con.icts checks allow an escape hatch that can enable \nwider code reuse. Casting an object to a dependent class p.class checks that the object has the same \nrun-time class as p. This feature allows objects indexed by different access paths to be explicit coerced \ninto another family of types. Nested inheritance can operate at every level of the containment hierarchy. \nUnlike with virtual classes [19], in J&#38; a class nested within one namespace can be subclassed by \na class in a different namespace. For example, suppose a collections library util is implemented in J&#38; \nas a set of mutually dependent interoperating classes. A user can extend the class util.LinkedList to \na class MyList not nested within util. A consequence of this feature is that a pre.x type P[T ] may be \nde.ned even if T is not directly nested within P or within a subtype of P. When the current object this \nis a MyList, the pre.x type util[this.class] is well\u00adformed and refers to the util package, even though \nMyList is not a member class of util. To ensure soundness, the type p.class is well-formed only if p \nis .nal. However, to improve expressiveness and to ease porting of Java programs to J&#38;, a non-.nal \nlocal variable x may be implicitly coerced to the type x.class under certain conditions. When x is used \nas an actual argument of a method call, a constructor call, or a new expression, or as the source of \na .eld assignment, and if x is not assigned in the expression, then it can be implicitly coerced to type \nx.class. Consider the following code fragment using the classes of Figure 1(a): base.Exp e = new pair.Pair(); \ne.accept(new base[e.class].TypeChecker()); In the call to accept, e is never assigned and hence its \nrun-time class does not change between the time e is .rst evaluated and method entry. If e had been assigned, \nsay to a base.Exp,the new expression would have allocated a base.TypeChecker and passed it to pair.Pair.accept, \nleading to a run-time type error. Implicit coercion is not performed for .eld paths, since it would require \nreasoning about aliasing and is in general unsafe for multithreaded programs. 3.2 Intersection types \nNested intersection of classes and packages in J&#38; is provided in the form of intersection types [43, \n13]. An intersection type S &#38; T inherits all members of its base namespaces S and T . With nested \nintersection, the nested namespaces of S and T are themselves intersected. To support composition of \nclasses and packages inherited more than once, J&#38; provides shared multiple inheritance: when a sub\u00adclass \n(or subpackage) inherits from multiple base classes, the new subclass may inherit the same superclass \nfrom more than one immediate superclass; however, instances of the subclass will not contain multiple \nsubobjects for the common superclass. For instance, pair and sum.Visitor in Figure 1(c) inherits from \nbase.Visitor only once, not twice through both pair and sum. Similarly, the package pair and sum contains \nonly one Visitor class, the composition of pair.Visitor and sum.Visitor. 3.3 Name con.icts Since an \nintersection class type does not have a class body in the program text, its inherited members cannot \nbe overridden by the intersection itself; however, subclasses of the intersection may override members. \nWhen two namespaces declare members with the same name, a name con.ict may occur in their intersection. \nHow the con.ict is resolved depends on where the name was introduced and whether the name refers to a \nnested class or to a method. If the name was introduced in a common ancestor of the intersected namespaces, \nmembers with that name are assumed to be semantically related. Otherwise, the name is assumed to refer \nto distinct members that coincidentally have the same name, but different semantics. When two namespaces \nare intersected, their corresponding nested namespaces are also intersected. In Figure 3, both A1 and \nA2 contain a nested class B inherited from A. Sinceacommon an\u00adcestor introduces B, the intersection type \nA1 &#38; A2 contains a nested class (A1 &#38; A2).B, which is equivalent to A1.B&#38; A2.B. The subclass \nD has an implicit nested class D.B, a subclass of (A1 &#38; A2).B. On the other hand, A1 and A2 both \ndeclare independent nested classes C. Even though these classes have the same name, they are assumed \nto be unrelated. The class (A1 &#38;A2).C is ambiguous. In fact, A1 &#38; A2 contains two nested classes \nnamed C, one that is a subclass of A1.C and one a subclass of A2.C.Class D and its subclasses can resolve \nthe ambiguity by exploiting pre.x type notation: A1[D].C refers to the C from A1 and A2[D].C refers to \nthe C from A2.In A1, references to the unquali.ed name C are interpreted as A1[this.class].C.If this \nis an instance of D, these references refer to the A1.C. Similarly, references to C in A2 are interpreted \nas A2[this.class].C,and when this is a D,these references refer to A2.C. A similar situation occurs with \nthe methods A1.p and A2.p. Again, D inherits both versions of p. Callers of D.p must resolve the ambiguity \nby up-casting the receiver to specify which one of the methods to invoke. This solution is also used \nfor nonvirtual super calls. If the superclass is an intersection type, the call may be ambiguous. The \nambiguity is resolved by up-casting the special receiver super to the desired superclass. Finally, two \nor more intersected classes may declare methods that override a method declared in a common base class. \nIn this case, illustrated by the method m in Figure 3, the method in the intersection type A1 &#38; A2 \nis considered abstract. Because it cannot override the abstract method, the intersection is also abstract \nand cannot be instantiated. Subclasses of the intersection type (D,in the example), must override m to \nresolve the con.ict, or else also be declared abstract.  3.4 Anonymous intersections An instance of \nan intersection class type A&#38;B may be created by explicitly invoking constructors of both A and B: \nnew A() &#38; B(); This intersection type is anonymous. As in Java, a class body mayalsobe speci.edinthe \nnew expression, introducing a new anonymous subclass of A&#38;B: new A() &#38;B() { ...}; class C {void \nn() { ...} } class A1 { class B1 extends C { } class B2 extends C { } void m() { new A1[this.class].B1() \n&#38; A1[this.class].B2(); } } class A2 extends A1 { class B1 extends C { void n() { ... } } class B2 \nextends C { void n() { ... } } // now B1 &#38; B2 conflict } Figure 4. Con.icts introduced by late binding \n If A and B have a name con.ict that causes their intersection to be an abstract class, a class body \nmust be provided to resolve the con.ict. Further binding may also introduce name con.icts. For exam\u00adple, \nin Figure 4, A1.B1 and A1.B2 do not con.ict, but A2.B1 and A2.B2 do con.ict. Since the anonymous intersection \nin A1.m may create an intersection of these two con.icting types, it should not be allowed. Because the \ntype being instantiated is statically unknown, it is a compile-time error to instantiate an anonymous \nintersection of two or more dependent types (either dependent classes or pre\u00ad.xes of dependent classes); \nonly anonymous intersections of non\u00addependent, non-con.icting classes are allowed. 3.5 Pre.x types and \nintersections Unlike with virtual classes [19], it is possible in J&#38; to extend classes nested within \nother namespaces. Multiple nested classes or a mix of top-level and nested classes may be extended, resulting \nin an intersection of several types with different containers. This .exibility is needed for effective \ncode reuse but complicates the de.nition of pre.x types. Consider this example: class A {class B {B m(); \n... }} class A1 extends A{class B{ Bx =m(); } } class A2 extends A { class B { } } class C extends A1.B \n&#38; A2.B { } As explained in Section 3.1, the unquali.ed name B in the body of class A.B is sugar \nfor the type A[this.class].B.The same name B in A1.B is sugar for A1[this.class].B. Since the method \nm and other code in A.B may be executed when this refers to an instance of A1.B, these two references \nto B should resolve to the same type; that is, it must be that A[this.class] is equivalent to A1[this.class]. \nThis equivalence permits the assignment of the result of m() to x in A1.B. Similarly, the three types \nA[C], A1[C], and A2[C] should all be equivalent. Pre.x types ensure the desired type equivalence. Two \ntypes P and P ' are related by further binding if they both contain nested types P.C and P ' .C that \nare inherited from or further bind a common type P '' .C. We write P ~ P ' for the symmetric, transitive \nclosure of this relation. In general, if P ~ P ',then P[T ] and P ' [T ] should be equivalent. The pre.x \ntype P[T ] is de.ned as the intersection of all types P ' ,where P ~ P ' where T has a supertype nested \nin P and a supertype nested in P ' . Using this de.nition A, A1 and A2 are all transitively related by \nfurther binding. Thus, A[C], A1[C],and A2[C] are all equivalent to A1 &#38; A2. Pre.x types impose some \nrestrictions on which types may be intersected. If two classes T1 and T2 contain con.icting methods, \nclass A { A(int x); } class B { class C extends A { C(int x) { A(x+1); } } } class B1 extends B { class \nC extends A { void m(); } } class B2 extends B { } class C extends A { void p(); } } class D extends \nB1 &#38; B2 { } Figure 5. Constructors of a shared superclass then their intersection is abstract, preventing \nthe intersection from being instantiated. If T1 or T2 contain member classes, a pre.x type of a dependent \nclass bounded by one of these member classes could resolve to the intersection T1 &#38; T2. To prevent \nthese pre.x types from being instantiated, all member classes of an abstract intersection are also abstract. \n 3.6 Constructors Like Java, J&#38; initializes objects using constructors. Since J&#38; per\u00admits allocation \nof instances of dependent types, the class being allo\u00adcated may not be statically known. Constructors \nin J&#38; are inherited and may be overridden like methods, allowing the programmer to invoke a constructor \nof a statically known superclass of the class being allocated. When a class declares a final .eld, it \nmust ensure the .eld is initialized. Since constructors are inherited from base classes that are unaware \nof the new .eld, J&#38; requires that if the .eld declaration does not have an explicit initializer, \nall inherited constructors must be overridden to initialize the .eld. To ensure .elds can be initialized \nto meaningful values, con\u00adstructors are inherited only via induced inheritance, not via explicit ' inheritance. \nThat is, the class T .C inherits constructors from T.C when T is a supertype of T ', but not from other \nsuperclasses of ' T .C. If a constructor were inherited from both explicit and induced superclasses, \nthen every class that adds a final .eld would have to override the default Object() constructor to initialize \nthe .eld. Since no values are passed into this constructor, the .eld may not be able to be initialized \nmeaningfully. Since a dependent class p.class may represent any subclass of p s statically known type, \na consequence of this restriction is that p.class can only be explicitly instantiated if p s statically \nknown class is final; in this case, since p.class is guaranteed to be equal to that final class, a constructor \nwith the appropriate signature exists. The restriction does not prevent nested classes of dependent classes \nfrom being instantiated. A constructor for a given class must explicitly invoke a con\u00adstructor of its \ndeclared superclass. If the superclass is an intersec\u00adtion type, it must invoke a constructor of each \nclass in the intersec\u00adtion. Because of multiple inheritance, superclass constructors are invoked by explicitly \nnaming them rather than by using the super keyword as in Java. In Figure 5, B.C invokes the constructor \nof its superclass A by name. Because J&#38; implements shared multiple inheritance, an inter\u00adsection \nclass may inherit more than one subclass of a shared super\u00adclass. Invoking a shared superclass constructor \nmore than once may lead to inconsistent initialization of final .elds, possibly causing a run-time type \nerror if the .elds are used in dependent classes. There are two cases, depending on whether the intersection \ninherits one invocation or more than one invocation of a shared constructor. In the .rst case, if all \ncalls to the shared superclass s construc\u00adtor originate from the same call site, which is multiply inherited \ninto the intersection, then every call to the shared constructor will pass it the same arguments. In \nthis case, the programmer need do nothing; the operational semantics of J&#38; will ensure that the shared \nconstructor is invoked exactly once. For example, in Figure 5, the implicit class D.C is a subclass of \nB1.C&#38;B2.C and shares the superclass A.Since B1.C and B2.C both inherit their C(int) constructor from \nB.C, both inherited construc\u00adtors invoke the A constructor with the same arguments. There is no con.ict \nand the compiler need only ensure that the constructor of A is invoked exactly once, before the body \nof D.C s constructor is executed. Similarly, if the programmer invokes: new (B1 &#38; B2).C(1); there \nis only one call to the A(int) constructor and no con.ict. If, on the other hand, the intersection contains \nmore than one call site that invokes a constructor of the shared superclass, or of the intersection itself \nis instantiated so that more than one construc\u00adtor is invoked, then the programmer must resolve the con.ict \nby specifying the arguments to pass to the constructor of the shared superclass. The call sites inherited \ninto the intersection will not be invoked. It is up to the programmer to ensure that the shared super\u00adclass \nis initialized in a way that is consistent with how its subclasses expect the object to be initialized. \nIn Figure 5, if one or both of B1 and B2 were to override the C(int) constructor, then B1.C and B2.C \nwould have different constructors with the same signature. One of them might change how the C constructor \ninvokes A(int). To resolve the con.ict, D must further bind C to specify how C(int) should invoke the \nconstructor of A. This behavior is similar to that of constructors of shared virtual base classes in \nC++. There would also be a con.ict if the programmer were to in\u00advoke: new B1.C(1) &#38; B2.C(2); The \nA(int) constructor would be invoked twice with different arguments. Thus, this invocation is illegal; \nhowever, since B1.C&#38; B2.C is equivalent to (B1&#38;B2).C, the intersection can be instantiated using \nthe latter type, as shown above. 3.7 Type substitution Because types may depend on .nal access paths, \ntype-checking method calls requires substitution of the actual arguments for the formal parameters. A \nmethod may have a formal parameter whose type depends upon another parameter, including this. The actual \narguments must re.ect this dependency. For example, the class base.Abs in Figure 1 contains the following \ncall: v.visitAbs(thisA ); to a method of base.Visitor with the signature: void visitAbs(base[thisV .class].Abs \na); For clarity, each occurrence of this has been labeled with an abbreviation of its declared type. \nSince the formal type base[thisV .class].Abs depends on the receiver thisV , the type of the actual argument \nthisA must depend on the receiver v. The type checker substitutes the actual argument types for de\u00adpendent \nclasses occurring in the formal parameter types. In this ex\u00adample, the receiver v has the type base[thisA \n.class].Visitor. Substituting this type for thisV .class in the for\u00admal parameter type base[thisV .class].Abs \nyields base[base[thisA .class].Visitor].Abs, which is equiv\u00adalent to base[thisA .class].Abs. The type \nsubstitution semantics of J&#38; generalize the original Jx substitution rules [35] to increase expressive \npower. However, to package pair; package pair_and_sum extends pair; class TgtExp = base.Exp; class TgtExp \n= pair.Exp; class Rewriter { class Rewriter { TgtExp rewrite(Exp e) TgtExp rewrite(Exp e) {...} {...} \n}} Figure 6. Static virtual types ensure soundness, some care must be taken. If the type of v were base.Visitor,then \nv might refer at run time to a pair.Visitor while at the same time thisA refers to a base.Abs. Substitu\u00adtion \nof base.Visitor for thisV .class in the formal parameter type would yield base[base.Visitor].Abs, which \nis equivalent to base.Abs. Since the corresponding actual argument has type base[thisA .class].Abs, which \nis a subtype of base.Abs,the call would incorrectly be permitted, leading to a potential run-time type \nerror. The problem is that there is no guarantee that the run\u00adtime classes of thisA and v both have the \nsame enclosing base package. To remedy this problem, type substitution must satisfy the re\u00adquirement \nof exactness preservation; that is, when substituting into an exact type a dependent class or a pre.x \nof a dependent class the resulting type must also be exact. This ensures that the run-time class or package \nrepresented by the type remains .xed. Substituting the type base[thisA .class].Visitor.for thisV .class \nis per\u00admitted since both base[thisV .class] and base[thisA .class] are exact. However, substituting base.Visitor \nfor thisV .class is illegal since base is not exact; therefore, a call to visitAbs where v is declared \nto be a base.Visitor is not permitted. Implicit coercion of a non-.nal local variable x to dependent \nclass x.class, described in Section 3.1, enhances the expressive\u00adness of J&#38; when checking calls by \nenabling x.class to be substi\u00adtuted for a formal parameter or this. Since this substitution pre\u00adserves \nexactness, the substitution is permitted. If x s declared type were substituted for the formal instead, \nexactness might not have been preserved.  3.8 Static virtual types Dependent classes and pre.x types \nenable classes nested within a given containment hierarchy of packages to refer to each other without \nstatically binding to a particular .xed package. This allows derived packages to further bind a class \nwhile preserving its rela\u00adtionship to other classes in the package. It is often useful to refer to other \nclasses outside the class s containment hierarchy without stat\u00adically binding to a particular .xed package. \nJ&#38; provides static vir\u00adtual types to support this feature. Unlike virtual types in BETA [29], a static \nvirtual type is an attribute of an enclosing package or class rather than of an enclosing object. In \nFigure 6, the package pair declares a static virtual type TgtExp representing an expression of the target \nlan\u00adguage of a rewriting pass, in this case an expression from the base compiler. The rewrite method \ntakes an expression with type pair[this.class].Exp and returns a base.Exp. The pair and sum package extends \nthe pair package and further binds TgtExp to pair.Exp. A static virtual type can be further bound to \nany subtype of the original bound. Be\u00adcause pair and sum.TgtExp is bound to pair.Exp, the method pair \nand sum.Rewriter.rewrite must return a pair.Exp,rather than a base.Exp as in pair.Rewriter.rewrite. With \nintersections, a static virtual type may be inherited from more than one superclass. Consider the declarations \nin Figure 7. Class B1 &#38; B2 inherits T from both B1 and B2. The type (B1 &#38; B2).T    class \nA {} class A1 extends A { } class A2 extends A { } class B {class T =A; } class B1 extends B { class \nT = A1; } class B2 extends B { class T = A2; } Figure 7. Static virtual types example must be a subtype \nof both A1 and A2; thus, (B1&#38;B2).T is bound to A1 &#38; A2. To enforce exactness preservation by \ntype substitution, static virtual types can be declared exact. For a given container name\u00adspace T , all \nmembers of the exact virtual type T.C are of the same .xed run-time class or package. Exact virtual types \ncan be further bound in a subtype of their container. For example, consider these declarations: class \nB { exact class T = A; } class B2 extends B { exact class T = A2; } The exact virtual type B.T is equivalent \nto the dependent class (new A).class;thatis, B.T contains only instances with run-time class A and not \nany subtype of A. Similarly, B2.T is equivalent to (new A2).class.Ifa variable b has declared type B,then \nan instance of b.class.T may be either a A or a A2, depending on the run-time class of b. 3.9 Packages \nJ&#38; supports inheritance of packages, including multiple inheri\u00adtance. In fact, the most convenient \nway to use nested inheritance is usually at the package level, because large software is usually con\u00adtained \ninside packages, not classes. The semantics of pre.x pack\u00adages and intersection packages are similar \nto those of pre.x and intersection class types, described above. Since packages do not have run-time \ninstances, the only exact packages are pre.xes of a dependent class nested within the package, e.g., \npkg[x.class], where x is an instance of class pkg.C.  4. Composing compilers Using the language features \njust described we can construct a composable, extensible compiler. In this section, we sketch the design \nof such a compiler. Most of the design described here was used in our port to J&#38; of the Polyglot \ncompiler framework [36] except where necessary to maintain backward compatibility with the Java version \nof Polyglot. The base package and packages nested within it contain all compiler code for the base language: \nJava, in the Polyglot framework. The nested packages base.ast, base.types,and base.visit contain classes \nfor AST nodes, types, and visitors that implement compiler passes, respectively. All AST nodes are subclasses \nof base.ast.Node; most compiler passes are imple\u00admented as subclasses of base.visit.Visitor. 4.1 Orthogonal \nextension Scalable, orthogonal extension of the base compiler with new data types and new operations \nis achieved through nested inheritance. To extend the compiler with new syntax, the base package is extended \nand new subclasses of Node can be added to the ast package. New passes can be added to the compiler by \ncreating new Visitor subclasses. Because the Visitor design pattern [21] is used to imple\u00adment compiler \npasses, when a new AST node class is added to an extension s ast package, a visit method for the class \n Figure 8. AST transformation must be added to the extension s visit.Visitor class. Be\u00adcause the classes \nimplementing the compiler passes extend base[this.class].visit.Visitor,this visit method is inher\u00adited \nby all Visitor subclasses in the extension. Visitor classes in the framework can transform the AST by \nreturning new AST nodes. The Visitor class implements default behavior for the visit method by simply \nreturning the node passed to it, thus implement\u00ading an identity transformation. Visitors for passes affected \nby the new syntax can be overridden to support it.  4.2 Composition Independent compiler extensions \ncan be composed using nested in\u00adtersection with minimal effort. If the two compiler extensions are orthogonal, \nas for example with the product and sum type com\u00adpilers of Section 2.3, then composing the extensions \nis trivial: the main method needs to be overridden in the composing extension to specify the order in \nwhich passes inherited from the composed extensions should run. If the language extensions have con.icting \nsemantics, this will often manifest as a name con.ict when intersecting the classes within the two compilers. \nThese name con.icts must be resolved to be able to instantiate the composed compiler, forcing the compiler \ndeveloper to reconcile the con.icting language semantics. It is undecidable to determine precisely whether \ntwo programs, including compilers, have con.icting semantics that prevent their composition. Several \nconservative algorithms based on program slicing have been proposed for integrating programs [23, 2, \n31]. These algorithms detect when two procedures are semantically compatible, or noninterfering. Interprocedural \nprogram integra\u00adtion [2] requires the whole program and it is unclear whether the algorithm can scale \nup to large programs. Formal speci.cation of\u00adfers a way to more precisely determine if two programs have \nse\u00admantic con.icts.  4.3 Extensible rewriters One challenge for building an extensible compiler is to \nimplement transformations between different program representations. In Fig\u00adure 1, for example, a compiler \npass transforms expressions with pairs into lambda calculus expressions. For a given transformation between \ntwo representations, compiler extensions need to be able to scalably and modularly extend both the source \nand target repre\u00adsentations and the transformation itself. However, if the extensions to the source and \ntarget representations do not interact with a trans\u00adformation, it should not be necessary to change the \ntransformation. Consider an abstract syntax tree (AST) node representing a bi\u00adnary operation. As illustrated \nin Figure 8, most compiler transfor\u00admations for this kind of node would recursively transform the two \nchild nodes representing the operands, then invoke pass-speci.c code to transform the binary operation \nnode itself, in general con\u00adstructing a new node using the new children. This generic code can be shared \nby many passes. However, code for a given base compiler transformation might not be aware of the particular \nextended AST form used by a given compiler extension. The extension may have added new children to the \nnode in the source representation of which the transformation is unaware. It is therefore hard to write \na reusable compiler pass; the pass may fail to transform all the node s children or attributes. In the \npair compiler of Figure 1, the TranslatePairs pass transforms pair AST nodes into base AST nodes. If \nthis compiler pass is reused in a compiler in which expressions have, say, addi\u00adtional type annotations, \nthe source and target languages node will have children for these additional annotations, but the pass \nwill not be aware of them and will fail to transform them. Static virtual types (Section 3.8) are used \nto make a pass aware of any new children added by extensions of the source language, while preserving \nmodularity. The solution is for the compiler to explicitly represent nodes in the intermediate form as \ntrees with a root in the source language but children in the target language, corresponding to the middle \ntree of Figure 8. This design is shown in Figure 9. In the example of Figure 1, this can be done by creating, \nfor both the source (i.e., pair) and target (i.e., base) language, packages ast struct de.ning just the \nstructure of each AST node. The ast struct packages are then extended to create ast packages for the \nactual AST nodes. Finally, a package is created inside each visitor class for the intermediate form nodes \nof that visitor s speci.c source and target language. In the ast struct package, children of each AST \nnode re\u00adside in a child virtual package. The ast package extends the ast struct package and further binds \nchild to the ast package itself; the node classes in ast have children in the same package as their parent. \nThe Visitor.tmp package also extends the ast struct pack\u00adage, but further binds child to the target package, \nwhich repre\u00adsents the target language of the visitor transformation. AST node classes in the tmp package \nhave children in the target package, but parent nodes are in the tmp package; since tmp is a subpack\u00adage \nof ast struct, nodes in this package have the same structure as nodes in the visitor s sibling ast struct \npackage. Thus, if the ast struct package is overridden to add new children to an AST node class, the \nintermediate nodes in the tmp package will also contain those children. Both the child and target virtual \npackages are declared to be exact. This ensures that the children of a tmp node are in the target package \nitself (in this case base.ast) and not a derived package of the target (e.g., pair.ast).  5. Implementation \nWe implemented the J&#38; compiler in Java using the Polyglot frame\u00adwork [36]. The compiler is a 2700-LOC \n(lines of code, excluding blank and comment lines) extension of the Jx compiler [35], itself a 22-kLOC \nextension of the Polyglot base Java compiler. J&#38; is implemented as a translation to Java. The amount \nof code produced by the translation is proportional to the size of the source code. The translation does \nnot duplicate code to imple\u00adment inheritance. Class declarations are generated only for explicit classes, \nthose classes (and interfaces) declared in the source pro\u00adgram. Classes inherited from another namespace \nbut not further bound are called implicit classes. Data structures for method dis\u00adpatching and run-time \ntype discrimination for implicit classes and intersection types are constructed on demand at run time. \n5.1 Translating classes Each explicit J&#38; class is translated into four Java classes: an in\u00adstance \nclass, a subobject class, a class class, and a method interface. Figure 10 shows a simpli.ed fragment \nof the translation of the code in Figure 1. Several optimizations discussed below are not shown. At run \ntime, each instance of a J&#38; class T is represented as an instance of T s instance class, IC(T ). \nEach explicit class has its own instance class. The instance class of an implicit class or inter\u00adsection \nclass is the instance class of one of its explicit superclasses.     package base.ast_struct; exact \npackage child = ast_struct; abstract class Exp { } class Abs extends Exp { String x; child.Exp e; } \n package base.ast extends ast_struct; exact package child = base.ast[this.class ]; abstract class Exp \n{ abstract v.class.target.Exp accept(Visitor v); void childrenExp(Visitor v, v.class.tmp.Exp t) { } } \npackage base; class Visitor { // source language // = base[this.class ].ast // target language // <= \nbase.ast; exact package target = base.ast; package tmp extends ast_struct { exact package child = target; \n} ... } Figure 9. Extensible rewriting example An instance of IC(T ) contains a reference to an instance \nof the class class of T , CC(T ). The class class contains method and construc\u00adtor implementations, static \n.elds, and type information needed to implement instanceof, pre.x types, and type selection from de\u00adpendent \nclasses. If J&#38; were implemented natively or had virtual machine support, rather than being translated \nto Java, then the ref\u00aderence to CC(T ) could be implemented more ef.ciently as part of IC(T ) s method \ndispatch table. All instance classes implement the interface JetInst. Subobject classes and .eld accesses. \nEach instance of IC(T ) contains a subobject for each explicit superclass of T , including ' T itself \nif it is explicit. The subobject class for a superclass T con\u00adtains all instance .elds declared in T \n' ; it does not contain .elds inherited into T ' . The instance class maintains a map from each ex\u00adplicit \nsuperclass of T to the subobject for that superclass. The static view method in the subobject class implements \nthe map lookup function for that particular subobject. If J&#38; were implemented na\u00adtively, the subobjects \ncould be inlined into the instance class and implemented more ef.ciently. To get or set a .eld of an \nobject, the view method is used to lookup the subobject for the superclass that declared the .eld. The \n.eld can then be accessed directly from the subobject. The view method could be inlined at each .eld \naccess, but this would make the generated code more dif.cult to read and debug. Class classes and method \ndispatch. For each J&#38; class, there is a singleton class class object that is instantiated when the \nclass is .rst used. A class class declaration is created for each explicit J&#38; class. For an implicit \nor intersection class T , CC(T ) is the runtime system class JetClass; the instance of JetClass contains \na reference to the class class object of each immediate superclass of T . The class class provides functions \nfor accessing run-time type information to implement instanceof and casts, for constructing instances \nof the class, and for accessing the class class object of pre.x types and member types, including static \nvirtual types. The code generated for expressions that dispatch on a dependent class (a new x.class() \nexpression, for example) evaluates the dependent class s access path (i.e., x) and uses the method jetGetClass() \nto locate the class class object for the type. All methods, including static methods, are translated \nto instance methods of the class class. This allows static methods to be invoked on dependent types, \nwhere the actual run-time class is statically unknown. Nonvirtual super calls are implemented by invoking \nthe method in the appropriate class class instance. Each method has an interface nested in the method \ninterface of the J&#38; class that .rst introduced the method. The class class implements the corresponding \ninterfaces for all methods it declares or overrides. The class class of the J&#38; class that introduces \na method m also contains a method m$disp, responsible for method dispatching. The receiver and method \narguments as well as a class package base; // method interfaces for Exp interface Exp$methods { interface \nAccept { JetInst accept(JetInst self, JetInst v); } } // class class of Exp class Exp$class implements \nExp$methods.Accept { JetInst accept(JetInst self, JetInst v) { /* cannot happen */ } static JetInst accept$disp(JetClass \nc, JetInst self, JetInst v) { JetClass r = ... // find the class class with the // most specific implementation \nreturn ((Exp$methods.Accept)r).accept(self, v); } ...  } // class class of Abs class Abs$class implements \nExp$methods.Accept { JetInst accept(JetInst self, JetInst v) { Abs$ext.view(self).e = Exp$class.accept$disp(null, \nAbs$ext.view(self).e, v); return Visitor$class.visitAbs$disp(null, v, self); } ...  } // instance class \nof Abs class Abs implements JetInst { JetSubobjectMap extMap; // subobject map JetClass jetGetClass() \n{ /* get the class class instance */ } ... } // subobject class of Abs class Abs$ext { String x; JetInst \ne; static Abs$ext view(JetInst self) { // find the subobject for Abs in self.extMap } } ... Figure 10. \nFragment of translation of code in Figure 1 class are passed into the dispatch method. The class class \nargument is used to implement nonvirtual super calls; for virtual calls, null is passed in and the receiver \ns class class is used. Single-method interfaces allow us to generate code only for those methods that \nappear in the corresponding J&#38; class. An alter\u00adnative, an interface containing all methods declared \nfor each class, would require class classes to implement trampoline methods to dispatch methods they \ninherit but do not override, greatly increas\u00ading the size of the generated code. Each virtual method \ncall is translated into a call to the dispatch method, which does a lookup to .nd the class class of \nthe most speci.c implementation. The class class object is cast to the ap\u00adpropriate method interface \nand then the method implementation is invoked. As shown in Figure 10, all references to J&#38; objects \nare of type JetInst. The translation mangles method names to handle over\u00adloading. Name mangling is not \nshown in Figure 10 for readability. Allocation. A factory method in the class class is generated for \neach constructor in the source class. The factory method for a J&#38; class T .rst creates an instance \nof the appropriate instance class, and then initializes the subobject map for T s explicit superclasses, \nincluding T itself. Because constructors in J&#38; can be inherited and overridden, constructors are \ndispatched similarly to methods. Initialization code in constructors and initializers are factored out \ninto initialization methods in the class class and are invoked by the factory method. A super constructor \ncall is translated into a call to the appropriate initialization method of the superclass s class class. \n 5.2 Translating packages To support package inheritance and composition, a package p is represented \nas a package class, analogous to a class class. The package class provides type information about the \npackage at run time and access to the class class or package class instances of its member types. The \npackage class of p is a member of package p. Since packages cannot be instantiated and contain no methods, \npackage classes have no analogue to instance classes, subobject classes, or method interfaces. 5.3 Java \ncompatibility To leverage existing software and libraries, J&#38; classes can inherit from Java classes. \nThe compiler ensures that every J&#38; class has exactly one most speci.c Java superclass. When the J&#38; \nclass is instantiated, there is only one super constructor call to some con\u00adstructor of this Java superclass. \nIn the translated code, the instance class IC(T ) is a subclass of the most speci.c Java superclass of \nT . When assigning into a vari\u00adable or parameter that expects a Java class or interface, the instance \nof IC(T ) can be used directly. A cast may need to be inserted be\u00adcause references to IC(T ) are of type \nJetInst, which may not be a subtype of the expected Java type; these inserted casts always succeed. The \ninstance class also overrides methods inherited from Java superclasses to dispatch through the appropriate \nclass class dispatch method.  5.4 Optimizations One problem with the translation described above is \nthat a single J&#38; object is represented by multiple objects at run time: an instance class object \nand several subobjects. This slows down allocation and garbage collection. A simple optimization is to \nnot create subobjects for J&#38; classes that do not introduce instance .elds. The instance class of \nexplicit J&#38; class T can inline the subobjects into IC(T ). Thus, at run time, an instance of an explicit \nJ&#38; class can be represented by a single object; an instance of an implicit class or intersection \nclass is represented by an instance class object and subobjects for superclasses not merged into the \ninstance class object. We expect this optimization to greatly improve ef.ciency.  6. Experience 6.1 \nPolyglot Following the approach described in Section 4, we ported the Poly\u00adglot compiler framework and \nseveral Polyglot-based extensions, all written in Java, to J&#38;. The Polyglot base compiler is a 31.9 \nkLOC program that performs semantic checking on Java source code and outputs equivalent Java source code. \nSpecial design pat\u00adterns make Polyglot highly extensible [35]; more than a dozen re\u00adsearch projects have \nused Polyglot to implement various extensions to Java (e.g., JPred [34], JMatch [28], as well as Jx and \nJ&#38;). For this work we ported six extensions ranging in size from 200 to 3000 LOC. The extensions \nare summarized in Table 1. The parsers for the base compiler, extensions, and compositions were generated \nfrom CUP [24] or Polyglot parser generator (PPG) [36] grammar .les. Because PPG supports only single \ngrammar inheritance, grammars were composed manually, and line counts do not include parser code. The \nport of the base compiler was our .rst attempt to port a large program to J&#38;, and was completed by \none of the authors within a few days, excluding time to .x bugs in the J&#38; compiler. Porting of each \nof the extensions took from one hour to a few days. Much of the porting effort could be automated, with \nmost .les requiring only modi.cation of import statements, as described below in Section 6.3. The ported \nbase compiler is 28.0 kLOC. The code becomes shorter because it eliminates factory methods and other \nextension patterns which were needed to make the Java version extensible, but which are not needed in \nJ&#38;. We eliminated only extension patterns that were obviously unnecessary, and could remove additional \ncode with more effort. The number of type downcasts in each compiler extension is reduced in J&#38;. \nFor example, coffer went from 192 to 102 down\u00adcasts. The reduction is due to (1) use of dependent types, \nobviating the need for casts to access methods and .elds introduced in ex\u00adtensions, and (2) removal of \nold extension pattern code. Receivers of calls to con.icting methods sometimes needed to be upcast to \nresolve the ambiguities; there are 19 such upcasts in the port of coffer. Table 2 shows lines of code \nneeded to compose each pair of extensions, producing working compilers that implemented a com\u00adposed language. \nThe param extension was not composed because it is an abstract extension containing infrastructure for \nparameterized types; however, coffer extends the param extension. The data show that all the compositions \ncan be implemented with very little code; further, most added code straightforwardly resolves trivial \nname con.icts, such as between the methods that re\u00adturn the name and version of the compiler. Only three \nof ten compo\u00adsitions (coffer &#38; pao, coffer &#38; covarRet,and pao &#38; covarRet) required resolution \nof nontrivial con.icts, for example, resolving con.icting code for checking method overrides. The code \nto re\u00adsolve these con.icts is no more 10 lines in each case. 6.2 Pastry We also ported the FreePastry \npeer-to-peer framework [44] version 1.2 to J&#38; and composed a few Pastry applications. The sizes of \nthe original and ported Pastry extensions are shown in Table 3. Excluding bundled applications, FreePastry \nis 7.1 kLOC. Name Extends Java 1.4 . . . LOC original LOC ported % original polyglot with nothing 31888 \n27984 87.8 param with infrastructure for parameterized types 513 540 105.3 coffer with resource management \nfacilities similar to Vault [14] 2965 2642 89.1 j0 with pedagogical features 679 436 64.2 pao to treat \nprimitives as objects 415 347 83.6 carray with constant arrays 217 122 56.2 covarRet to allow covariant \nmethod return types 228 214 93.9 Table 1. Ported Polyglot extensions Table 2. Polyglot composition \nresults: lines of code Host nodes in Pastry exchange messages that can be handled in an application-speci.c \nmanner. In FreePastry, network mes\u00adsage dispatching is implemented with instanceof statements and casts. \nWe changed this code to use more straightforward method dispatch instead, thus making dispatch extensible \nand eliminating several downcasts. Messages are dispatched to several protocol\u00adspeci.c handlers. For \nexample, there is a handler for the routing protocol, another for the join protocol, and others for any \nappli\u00adcations built on top of the framework. The Pastry framework al\u00adlows applications to choose to use \none of three different messaging layer implementations: an RMI layer, a wire layer that uses sock\u00adets \nor datagrams, and an in-memory layer in which nodes of the distributed system are simulated in a single \nJVM. Family polymor\u00adphism enforced by the J&#38; type system statically ensures that mes\u00adsages associated \nwith a given handler are not delivered to another handler and that objects associated with a given transport \nlayer are not used by code for a different layer implementation. Pastry implements a distributed hash \ntable. Beehive and PC-Pastry extend Pastry with caching functionality [41]. PC-Pastry uses a simple passive \ncaching algorithm, where lookups are cached on nodes along the route from the requesting node to a node \ncon\u00adtaining a value for the key. Beehive actively replicates objects throughout the network according \nto their popularity. We intro\u00adduced a package cache containing functionality in common be\u00adtween Beehive \nand PC-Pastry; the CorONA RSS feed aggregation service [40] was modi.ed to extend the cache package rather \nthan Beehive. Using nested intersection, the modi.ed CorONA was composed .rst with Beehive, and then \nwith PC-Pastry, creating two appli\u00adcations providing the CorONA RSS aggregation service but using different \ncaching algorithms. Each composition of CorONA and a caching extension contains a single main method \nand some con\u00ad.guration constants to initialize the cache manager data structures. The CorONA Beehive \ncomposition also overrides some CorONA message handlers to keep track of each cached object s popularity. \nWe also implemented and composed test drivers for the CorONA extension, but line counts for these are \nnot included since the orig\u00adinal Java code did not include them. The J&#38; code for FreePastry is 7.4 \nkLOC, 300 lines longer than the original Java code. The additional code consists primarily of interfaces \nintroduced to implement network message dispatching. Name LOC original LOC ported Pastry 7082 7363 Beehive \n3686 3634 PC-Pastry 695 630 CorONA 626 591 cache N/A 140 CorONA Beehive N/A 68 CorONA PC-Pastry N/A 28 \n Table 3. Ported Pastry extensions and compositions The Pastry extensions had similar message dispatching \noverhead; since code in common between Beehive and PC-Pastry was fac\u00adtored out into the cache extension, \nthe size of the ported extensions is smaller. The size reduction in CorONA is partially attributable \nto moving code from the CorONA extension to the CorONA Beehive composition. 6.3 Porting Java to J&#38; \nPorting Java code to J&#38; was usually straightforward, but certain common issues are worth discussing. \nType names. In J&#38;, unquali.ed type names are syntactic sugar for members of this.class or a pre.x \nof this.class, e.g., Visitor might be sugar for base[this.class].Visitor.In Java, unquali.ed type names \nare sugar for fully quali.ed names; thus, Visitor would resolve to base.Visitor. To take full ad\u00advantage \nof the extensibility provided by J&#38;, fully quali.ed type names sometimes must be changed to be only \npartially quali.ed. In particular, import statements in most compilation units are rewritten to allow \nnames of other classes to resolve to depen\u00addent types. For example, in Polyglot the import statement \nimport polyglot.ast.*; was changed to import ast.*; so that im\u00adported classes resolve to classes in polyglot[this.class].ast \nrather than in polyglot.ast. Final access paths. To make some expressions pass the type checker, it was \nnecessary to declare some variables .nal so they could used in dependent classes. In many cases, non-.nal \naccess paths used in method calls could be coerced automatically by the compiler, as described in Section \n3.1. However, non-.nal .eld accesses are not coerced automatically because the .eld might be updated \n(possibly by another thread) between evaluation and method entry. The common workaround is to save non-.nal \n.elds in a .nal local variable and then to use that variable in the call. This issue was not as problematic \nas originally expected. In fact, in 30 kLOC of ported Polyglot code, only three such calls needed to \nbe modi.ed. In most other cases, the actual method receiver type was of the form P[ p.class].Q and the \nformal parameter types were of the form P[this.class].R. Even if an actual argument were updated between \nits evaluation and method entry, the type system ensures its new value is a class enclosed by the same \nrun\u00adtime namespace P[ p.class] as the receiver, which guarantees that the call is safe. Path aliasing. \nThe port of Pastry and its extensions made more extensive use of .eld-dependent classes (e.g., this.thePastryNode.class \n) than the Polyglot port. Several casts needed to be inserted in the J&#38; code for Pastry to allow \na type dependent upon one access path to be coerced to a type dependent upon another path. Often, the \ntwo paths refer to the same object, ensuring the cast will always succeed. A simple local alias analysis \nwould eliminate the need for many of these casts.  7. Related work There has been great interest in \nthe past several years in mech\u00adanisms for providing greater extensibility in object-oriented lan\u00adguages. \nNested intersection uses ideas from many of these other mechanisms to create a powerful and relatively \ntransparent mecha\u00adnism for code reuse. Virtual classes. Nested classes in J&#38; are similar to virtual \nclasses [29, 30, 25, 19]. Virtual classes were originally developed for the language BETA [29, 30], primarily \nfor generic program\u00adming rather than for extensibility. Although virtual classes in BETA are not statically \ntype safe, Ernst s generalized BETA (gbeta) language [15, 16] uses path\u00addependent types, similar to dependent \nclasses in J&#38;, to ensure static type safety. Type-safe virtual classes using path-dependent types \nwere formalized by Ernst et al. in the vc calculus [19]. A key difference between J&#38; s nested classes \nand virtual classes is that virtual classes are attributes of an object, called the enclosing instance, \nrather than attributes of a class. Virtual classes may only have one enclosing instance. For this reason, \na virtual class can extend only other classes nested within the same object; it may not extend a more \ndeeply nested virtual class. This can limit the ability to extend components of a larger system. Because \nit is unique, the enclosing instance of a virtual class can be referred to unambiguously with an out \npath: this.out is the enclosing instance of this s class. In contrast, J&#38; uses pre.x types to refer \nto enclosing classes. Both J&#38; and gbeta provide virtual superclasses, the ability to late-bind a \nsupertype declaration. When the containing namespace of a set of classes is extended via inheritance, \nthe derived name\u00adspace replicates the class hierarchy of the original namespace, forming a higher-order \nhierarchy [18]. Because virtual classes are contained in an object rather than in a class, there is no \nsubtyping relationship between classes in the original hierarchy and further bound classes in the derived \nhierarchy, as there is in J&#38;. The gbeta language supports multiple inheritance. As in J&#38;, commonly \nnamed virtual classes inherited into a class are them\u00adselves composed [16]. However, multiple inheritance \nis limited to other classes nested within the same enclosing instance. Virtual classes in gbeta support \nfamily polymorphism [17]: two virtual classes enclosed by distinct objects cannot be statically con\u00adfused. \nWhen a containing namespace is extended, family polymor\u00adphism ensures the static type safety of the classes \nin the derived family by preventing it from treating classes belonging to the base family as if they \nbelonged to the extension. In gbeta, each object de\u00ad.nes a family of classes: the collection of mutually \ndependent vir\u00adtual classes immediately nested within it. Because nested classes in J&#38; are attributes \nof their enclosing class, rather than an enclosing object, J&#38; supports what Clarke et al. [11] call \nclass-based fam\u00adily polymorphism. With virtual classes, all members of the fam\u00adily are named from a single \nfamily object , which must be made accessible throughout the system. Moreover, only nested classes of \nthe family object are part of the family. In contrast, with class\u00adbased family polymorphism, each dependent \nclass de.nes a family of classes nested within and also enclosing. By using pre.x types, any instance \nof a class in the family can be used to name the family, not just a single family object. Tribe [11] \nis another language that provides a variant of virtual classes. By treating a .nal access path p as a \ntype, nested classes in Tribe can be considered attributes of an enclosing class as in Jx and J&#38; \nor as attributes of an enclosing instance as in BETA and its derivatives. This .exibility allows a further \nbound class to be a subtype of the class it overrides, like in J&#38; but unlike with virtual classes. \nTribe also supports multiple inheritance. However, super\u00adclasses of a Tribe class must be nested within \nthe same enclosing class, limiting extensibility. This restriction allows the enclosing type to be named \nusing an owner attribute: T.owner is the enclos\u00ading class of T . Concord [26] also provides a type-safe \nvariant of virtual classes. In Concord, mutually dependent classes are organized into groups, which can \nbe extended via inheritance. References to other classes within a group are made using types dependent \non the current group, MyGrp, similarly to how pre.x types are used in J&#38;. Rel\u00adative supertype declarations \nprovide functionality similar to virtual superclasses. Groups in Concord cannot be nested, nor can groups \nbe multiply inherited. Multiple inheritance. J&#38; provides multiple inheritance through nested intersection. \nIntersection types were introduced by Reynolds in the language Forsythe [43] and were used by Compagnoni \nand Pierce to model multiple inheritance [13]. Cardelli [9] presents a formal semantics of multiple inheritance. \nThe distinction between name con.icts among methods intro\u00adduced in a common base class and among methods \nintroduced in\u00addependently with possibly different semantics was made as early as 1982 by Borning and \nIngalls [3]. Many languages, such as C++ [47] and Self [10], treat all name con.icts as ambiguities to \nbe resolved by the caller. Some languages [32, 4, 45] allow methods to be re\u00adnamed or aliased. A mixin \n[4, 20], also known as an abstract subclass, is a class parameterized on its superclass. Mixins are able \nto provide uniform extensions, such as adding new .elds or methods, to a large number of classes. Mixins \ncan be simulated using explicit multiple inheri\u00adtance. J&#38; also provides additional mixin-like functionality \nthrough virtual superclasses. Since mixins are composed linearly, a class may not be able to access a \nmember of a given super-mixin because the member is overridden by another mixin. Explicit multiple inheritance \nimposes no ordering on composition of superclasses. Traits [45] are collections of abstract and non-abstract \nmethods that may be composed with state to form classes. Since traits do not have .elds, many of the \nissues introduced by multiple inheritance (for example, whether to duplicate code inherited through more \nthan one base trait) are avoided. The code reuse provided by traits is largely orthogonal to that provided \nby nested inheritance and could be integrated into J&#38;. Scala Scala [38] is another language that \nsupports scalable exten\u00adsibility and family polymorphism through a statically safe virtual type mechanism \nbased on path-dependent types. However, Scala s path-dependent type p.type is a singleton type containing \nonly the value named by access path p;in J&#38;, p.class is not a single\u00adton. For instance, new x.class(...) \ncreates a new object of type x.class distinct from the object referred to by x. This difference gives \nJ&#38; more .exibility, while preserving type soundness. Scala provides virtual types, but not virtual \nclasses. It has no analogue to pre.x types, nor does it provide virtual superclasses, limiting the scalability \nof its extension mechanisms. Scala supports composi\u00adtion using traits. Since traits do not have .elds, \nnew state cannot be easily added into an existing class hierarchy. Self types and matching. Bruce et \nal. [7, 5] introduce matching as an alternative to subtyping, with a self type,or MyType,rep\u00adresenting \nthe type of the method s receiver. The dependent class this.class is similar but represents only the \nclass referred to by this and not its subclasses. Type systems with MyType decouple subtyping and subclassing; \nin PolyTOIL and LOOM, a subclass matches its base class but is not a subtype. With nested inheritance, \nsubclasses are subtypes. Bruce and Vanderwaart [8, 6] propose type groups as a means to aggregate and \nextend mutually dependent classes, similarly to Concord s group construct, but using match\u00ading rather \nthan subtyping. Open classes and expanders. An open class [12] is a class to which new methods can be \nadded without needing to edit the class directly, or recompile code that depends on the class. Nested \ninheritance provides similar functionality through class overriding in an extended container. Nested \ninheritance provides additional extensibility that open classes do not, such as the virtual behavior \nof constructors, and the ability to extend an existing class with new .elds that are automatically inherited \nby its subclasses. Similar to open classes, expanders [50] are a mechanism for extending existing classes. \nThey address the limitations of open classes by enabling classes to be updated not only with new meth\u00adods, \nbut also with new .elds and superinterfaces. Expanders do not change the behavior of existing clients \nof extended classes. Exist\u00ading classes are extended with new state using wrapper objects. One limitation \nof this approach is that object identity is not preserved, which may cause run-time type checks to return \nincorrect results. Classboxes. A classbox [1] is a module-based reuse mechanism. Classes de.ned in one \nclassbox may be imported into another classbox and re.ned to create a subclass of the imported class. \nBy dispatching based on a dynamically chosen classbox, names of types and methods occurring in imported \ncode are late bound to re.ned versions of those types and methods. This feature provides similar functionality \nto the late binding of types provided by this\u00addependent classes and pre.x types in J&#38;. Since reuse \nis based on import of classboxes rather than inher\u00aditance, classboxes do not support multiple inheritance, \nbut they do allow multiple imports. When two classboxes that both re.ne the same class are imported, \nthe classes are not composed like in J&#38;. Instead, one of the classes is chosen over the other. Class \nhierarchy composition. Ossher and Harrison [39] propose an approach in which extensions of a class hierarchy \nare written in separate sparse extension hierarchies containing only new func\u00adtionality. Extension hierarchies \ncan be merged and naming con.icts detected. However, semantic incompatibilities between extension hierarchies \nare not detected. Unlike with nested intersection, hier\u00adarchies do not nest and there is no subtyping \nrelationship between classes in different hierarchies. Tarr et al. [48] de.ne a speci.cation language \nfor composing class hierarchies. Rules specify how to merge concepts in the hierarchies. Nested intersection \nsupports composition with a rule analogous to merging concepts by name. Snelting and Tip [46] present \nan algorithm for composing class hierarchies and a semantic interference criterion. If the hierarchies \nare interference-free, the composed system preserves the original behavior of classes in the hierarchies. \nJ&#38; reports a con.ict if com\u00adposed class hierarchies have a static interference,but makes no ef\u00adfort \nto detect dynamic interference. Aspect-oriented programming. Aspect-oriented programming (AOP) [27] is \nconcerned with the management of aspects, func\u00adtionality that cuts across modular boundaries. Nested \ninheritance provides aspect-like extensibility; an extension of a container may implement functionality \nthat cuts across the class boundaries of the nested classes. Aspects modify existing class hierarchies, \nwhereas nested inheritance creates a new class hierarchy, allowing the new hierarchy to be used alongside \nthe old. Caesar [33] is an aspect\u00adoriented language that also supports family polymorphism, permit\u00adting \napplication of aspects to mutually recursive nested types.  8. Conclusions This paper introduces nested \nintersection and shows that it is an effective language mechanism for extending and composing large bodies \nof software. Extension and composition are scalable because new code needs to be written only to implement \nnew functionality or to resolve con.icts between composed classes and packages. Novel features like static \nvirtual types offer important expressive power. Nested intersection has been implemented in an extension \nof Java called J&#38;. Using J&#38;, we implemented a compiler framework for Java, and showed that different \ndomain-speci.c compiler exten\u00adsions can easily be composed, resulting in a way to construct com\u00adpilers \nby choosing from available language implementation com\u00adponents. We demonstrated the utility of nested \nintersection outside the compiler domain by porting the FreePastry peer-to-peer system to J&#38;. The \neffort required to port Java programs to J&#38; is not large. Ported programs were smaller, required \nfewer type casts, and sup\u00adported more extensibility and composability. We have informally described here \nthe static and dynamic se\u00admantics of J&#38;. A formal treatment with a proof of soundness can be found \nin an associated technical report [37]. Nested intersection is a powerful and convenient mechanism for \nbuilding highly extensible software. We expect it to be useful for a wide variety of applications. Acknowledgments \nSteve Chong, Jed Liu, Ruijie Wang, and Lantian Zheng provided useful feedback on various drafts of this \npaper. Thank you to Michael Clarkson for his very detailed comments and for the pun. Thanks also to Venugopalan \nRamasubramanian for insightful dis\u00adcussions about Pastry and Beehive. This research was supported in \npart by ONR Grant N00014\u00ad01-1-0968, by NSF Grants 0133302, 0208642, and 0430161, and by an Alfred P. \nSloan Research Fellowship. The U.S. Government is authorized to reproduce and distribute reprints for \nGovernment purposes, notwithstanding any copyright annotation thereon. The views and conclusions here \nare those of the authors and do not necessarily re.ect those of ONR, the Navy, or the NSF. References \n[1] Alexandre Bergel, St\u00b4ephane Ducasse, and Oscar Nierstrasz. Class\u00adbox/J: Controlling the scope of \nchange in Java. In Proc. OOPSLA 05, pages 177 189, October 2005. [2] David Binkley, Susan Horwitz, and \nThomas Reps. Program integration for languages with procedure calls. ACM Transactions on Software Engineering \nand Methodology (TOSEM), 4(1):3 35, January 1995. [3] Alan Borning and Daniel Ingalls. Multiple inheritance \nin Smalltalk\u00ad 80. In Proceedings of the National Conference on Arti.cial Intelligence (AAAI), pages 234 \n237, August 1982. [4] Gilad Bracha and William Cook. Mixin-based inheritance. In Norman Meyrowitz, editor, \nProc. OOPSLA 90, pages 303 311, Ottawa, Canada, 1990. ACM Press. [5] Kim B. Bruce. Safe static type checking \nwith systems of mutually recursive classes and inheritance. Technical report, Williams College, 1997. \nhttp://cs.williams.edu/~kim/ftp/RecJava.ps.gz. [6] Kim B. Bruce. Some challenging typing issues in object-oriented \nlanguages. Electronic Notes in Theoretical Computer Science, 82(8):1 29, October 2003. [7] Kim B. Bruce, \nAngela Schuett, and Robert van Gent. PolyTOIL: A type-safe polymorphic object-oriented language. In European \nConference on Object-Oriented Programming (ECOOP), number 952 in Lecture Notes in Computer Science, pages \n27 51. Springer-Verlag, 1995. [8] Kim B. Bruce and Joseph C. Vanderwaart. Semantics-driven language design: \nStatically type-safe virtual types in object-oriented languages. In Mathematical Foundations of Programming \nSemantics (MFPS), Fifteenth Conference, volume 20 of Electronic Notes in Theoretical Computer Science, \npages 50 75, April 1999. [9] Luca Cardelli. A semantics of multiple inheritance. Information and Computation, \n76:138 164, 1988. Also in Readings in Object-Oriented Database Systems, S. Zdonik and D. Maier, eds., \nMorgan Kaufmann, 1990. [10] Craig Chambers, David Ungar, Bay-Wei Chang, and Urs H\u00a8olzle. Parents are \nshared parts of objects: Inheritance and encapsulation in Self. Lisp and Symbolic Computation, 4(3):207 \n222, June 1991. [11] Dave Clarke, Sophia Drossopoulou, James Noble, and Tobias Wrigstad. Tribe: More \ntypes for virtual classes. Submitted for pub\u00adlication. Available at http://slurp.doc.ic.ac.uk/pubs.html, \nDecember 2005. [12] Curtis Clifton, Gary T. Leavens, Craig Chambers, and Todd Millstein. MultiJava: Modular \nopen classes and symmetric multiple dispatch for Java. In OOPSLA 2000 Conference on Object-Oriented Programming, \nSystems, Languages, and Applications, Minneapolis, Minnesota, volume 35(10), pages 130 145, 2000. [13] \nAdriana B. Compagnoni and Benjamin C. Pierce. Higher order intersection types and multiple inheritance. \nMathematical Structures in Computer Science, 6(5):469 501, 1996. [14] Robert DeLine and Manuel F\u00a8ahndrich. \nEnforcing high-level protocols in low-level software. In Proceedings of the ACM Conference on Programming \nLanguage Design and Implementation, pages 59 69, June 2001. [15] Erik Ernst. gbeta a Language with Virtual \nAttributes, Block Structure, and Propagating, Dynamic Inheritance. PhD thesis, Department of Computer \nScience, University of Aarhus, \u00b0 Arhus, Denmark, 1999. [16] Erik Ernst. Propagating class and method \ncombination. In Proceedings of the Thirteenth European Conference on Object-Oriented Programming (ECOOP \n99), number 1628 in Lecture Notes in Computer Science, pages 67 91. Springer-Verlag, June 1999. [17] \nErik Ernst. Family polymorphism. In Proceedings of the 15th European Conference on Object-Oriented Programming \n(ECOOP), LNCS 2072, pages 303 326, Heidelberg, Germany, 2001. Springer-Verlag. [18] Erik Ernst. Higher-order \nhierarchies. In Proceedings of the 17th European Conference on Object-Oriented Programming (ECOOP), volume \n2743 of Lecture Notes in Computer Science, pages 303 329, Heidelberg, Germany, July 2003. Springer-Verlag. \n[19] Erik Ernst, Klaus Ostermann, and William R. Cook. A virtual class calculus. In Proc. 33th ACM Symp. \non Principles of Programming Languages (POPL), Charleston, South Carolina, January 2006. To appear. [20] \nMatthew Flatt, Shriram Krishnamurthi, and Matthias Felleisen. Classes and mixins. In Proc. 25th ACM Symp. \non Principles of Programming Languages (POPL), pages 171 183, San Diego, California, 1998. [21] Erich \nGamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns: Elements of Reusable Object-Oriented \nSoftware. Addison Wesley, Reading, MA, 1994. [22] Carl Gunter and John C. Mitchell, editors. Theoretical \naspects of object-oriented programming. MIT Press, 1994. [23] Susan Horwitz, Jan Prins, and Thomas Reps. \nIntegrating noninter\u00adfering versions of programs. ACM Transactions on Programming Languages and Systems, \n11(3):345 387, July 1989. [24] Scott E. Hudson, Frank Flannery, C. Scott Ananian, Dan Wang, and Andrew \nAppel. CUP LALR parser generator for Java, 1996. Software release. Located at http://www.cs.princeton.edu/~appel/\u00admodern/java/CUP/. \n[25] Atsushi Igarashi and Benjamin Pierce. Foundations for virtual types. In Proceedings of the Thirteenth \nEuropean Conference on Object-Oriented Programming (ECOOP 99), number 1628 in Lecture Notes in Computer \nScience, pages 161 185. Springer-Verlag, June 1999. [26] Paul Jolly, Sophia Drossopoulou, Christopher \nAnderson, and Klaus Ostermann. Simple dependent types: Concord. In ECOOP Workshop on Formal Techniques \nfor Java Programs (FTfJP), June 2004. [27] Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, \nCristina Videira Lopes, Jean-Marc Loingtier, and John Irwin. Aspect\u00adoriented programming. In Proceedings \nof 11th European Conference on Object-Oriented Programming (ECOOP 97), number 1241 in Lecture Notes in \nComputer Science, pages 220 242, Jyv\u00a8askyl\u00a8a, Finland, June 1997. Springer-Verlag. [28] Jed Liu and Andrew \nC. Myers. JMatch: Abstract iterable pattern matching for Java. In Proc. 5th Int l Symp. on Practical \nAspects of Declarative Languages (PADL), pages 110 127, New Orleans, LA, January 2003. [29] O. Lehrmann \nMadsen, B. M\u00f8ller-Pedersen, and K. Nygaard. Object Oriented Programming in the BETA Programming Language. \nAddison-Wesley, June 1993. [30] Ole Lehrmann Madsen and Birger M\u00f8ller-Pedersen. Virtual classes: A powerful \nmechanism for object-oriented programming. In Proc. OOPSLA 89, pages 397 406, October 1989. [31] Katsuhisa \nMaruyama and Ken-Ichi Shima. An automatic class gener\u00adation mechanism by using method integration. IEEE \nTransactions on Software Engineering, 26(5):425 440, May 2000. [32] Bertrand Meyer. Object-oriented Software \nConstruction. Prentice Hall, New York, 1988. [33] M. Mezini and K. Ostermann. Conquering aspects with \nCaesar. In Proceedings of the 2nd International Conference on Aspect-Oriented Software Development (AOSD), \npages 90 100, March 2003. [34] Todd Millstein. Practical predicate dispatch. In Proceedings of the 19th \nACM Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA), October 2004. \n[35] Nathaniel Nystrom, Stephen Chong, and Andrew C. Myers. Scalable extensibility via nested inheritance. \nIn Proceedings of the 19th ACM Conference on Object-Oriented Programming Systems, Languages and Applications \n(OOPSLA), pages 99 115, October 2004. [36] Nathaniel Nystrom, Michael R. Clarkson, and Andrew C. Myers. \nPolyglot: An extensible compiler framework for Java. In G\u00a8orel Hedin, editor, Compiler Construction, \n12th International Conference, CC 2003, number 2622 in Lecture Notes in Computer Science, pages 138 152, \nWarsaw, Poland, April 2003. Springer-Verlag. [37] Nathaniel Nystrom, Xin Qi, and Andrew C. Myers. Nested \nintersection for scalable software extension, September 2006. http://www.cs.cornell.edu/nystrom/papers/jet-tr.pdf. \n[38] Martin Odersky and Matthias Zenger. Scalable component abstrac\u00adtions. In Proc. OOPSLA 05, pages \n41 57, October 2005. [39] Harold Ossher and William Harrison. Combination of inheritance hierarchies. \nIn Proc. OOPSLA 92, pages 25 40, October 1992. [40] Venugopalan Ramasubramanian, Ryan Peterson, and Emin \nG\u00a8un Sirer. Corona: A high performance publish-subscribe system for the World Wide Web. In Proceedings \nof Networked System Design and Implementation (NSDI), May 2006. [41] Venugopalan Ramasubramanian and \nEmin G\u00a8un Sirer. Beehive: O(1) lookup performance for power-law query distributions in peer-to-peer overlays. \nIn USENIX Symposium on Networked Systems Design and Implementation (NSDI), March 2004. [42] John C. Reynolds. \nUser-de.ned types and procedural data structures as complementary approaches to data abstraction. In \nStephen A. Schuman, editor, New Directions in Algorithmic Languages, pages 157 168. Institut de Recherche \nd Informatique et d Automatique, Le Chesnay, France, 1975. Reprinted in [22], pages 13 23. [43] John \nC. Reynolds. Design of the programming language Forsythe. Technical Report CMU-CS-96-146, Carnegie Mellon \nUniversity, June 1996. [44] Antony Rowstron and Peter Druschel. Pastry: Scalable, distributed object \nlocation and routing for large-scale peer-to-peer systems. In IFIP/ACM International Conference on Distributed \nSystems Platforms (Middleware), pages 329 350, November 2001. [45] Nathanael Sch\u00a8arli, St\u00b4ephane Ducasse, \nOscar Nierstrasz, and An\u00addrew P. Black. Traits: Composable units of behavior. In Luca Cardelli, editor, \nProceedings of the 17th European Conference on Object-Oriented Programming (ECOOP 2003), number 2743 \nin Lecture Notes in Computer Science, pages 248 274, Darmstadt, Germany, July 2003. Springer-Verlag. \n[46] Gregor Snelting and Frank Tip. Semantics-based composition of class hierarchies. In Proceedings \nof the 16th European Conference on Object-Oriented Programming (ECOOP), volume 2374 of Lecture Notes \nin Computer Science, pages 562 584, M\u00b4alaga, Spain, 2002. Springer-Verlag. [47] Bjarne Stroustrup. The \nC++ Programming Language. Addison-Wesley, 1987. [48] Peri Tarr, Harold Ossher, William Harrison, and \nJr. Stanley M. Sutton. N degrees of separation: Multi-dimensional separation of concerns. In Proceedings \nof the 1999 International Conference on Software Engineering (ICSE), pages 107 119, May 1999. [49] Philip \nWadler et al. The expression problem, December 1998. Discussion on Java-Genericity mailing list. [50] \nAlessandro Warth, Milan Stanojevi\u00b4c, and Todd Millstein. Statically scoped object adaptation with expanders. \nIn Proceedings of the 2006 Conference on Object Oriented Programming Systems Languages and Applications \n(OOPSLA 06), October 2006.  \n\t\t\t", "proc_id": "1167473", "abstract": "This paper introduces a programming language that makes it convenient to compose large software systems, combining their features in a modular way. J& supports <i>nested intersection</i>, building on earlier work on nested inheritance in the language Jx. Nested inheritance permits modular, type-safe extension of a package (including nested packages and classes), while preserving existing type relationships. Nested intersection enables composition and extension of <i>two or more</i> packages, combining their types and behavior while resolving conflicts with a relatively small amount of code. The utility of J& is demonstrated by using it to construct two composable, extensible frameworks: a compiler framework for Java, and a peer-to-peer networking system. Both frameworks support composition of extensions. For example, two compilers adding different, domain-specific features to Java can be composed to obtain a compiler for a language that supports both sets of features.", "authors": [{"name": "Nathaniel Nystrom", "author_profile_id": "81100144238", "affiliation": "Cornell University", "person_id": "PP55042406", "email_address": "", "orcid_id": ""}, {"name": "Xin Qi", "author_profile_id": "81322503996", "affiliation": "Cornell University", "person_id": "PP18010095", "email_address": "", "orcid_id": ""}, {"name": "Andrew C. Myers", "author_profile_id": "81100011022", "affiliation": "Cornell University", "person_id": "PP14016809", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167476", "year": "2006", "article_id": "1167476", "conference": "OOPSLA", "title": "J&amp;: nested intersection for scalable software composition", "url": "http://dl.acm.org/citation.cfm?id=1167476"}