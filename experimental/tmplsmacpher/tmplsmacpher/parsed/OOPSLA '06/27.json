{"article_publication_date": "10-16-2006", "fulltext": "\n Intentional Software Charles Simonyi Magnus Christerson Shane Clifford Intentional Software Corporation \n500 108th Ave NE, #1050 Intentional Software Corporation 500 108th Ave NE, #1050 Intentional Software \nCorporation 500 108th Ave NE, #1050 Bellevue, WA, 98004 Bellevue, WA, 98004 Bellevue, WA, 98004 +1 425 \n467 6600 +1 425 467 6600 +1 425 467 6600 charless@intentsoft.com magnus@intentsoft.com shane@intentsoft.com \n Abstract Wysiwyg editors simplified document creation by separating the document contents from the looks \nand by automating the re\u00adapplication of the looks to changing contents. In the same way Intentional Software \nsimplifies software creation by separating the software contents in terms of their various domains from \nthe implementation of the software and by enabling automatic re\u00adgeneration of the software as the contents \nchange. This way, domain experts can work in parallel with programmers in their respective areas of expertise; \nand the repeated intermingling can be automated. Intentional Software is supported by a Domain Workbench \ntool where multiple domains can be defined, created, edited, transformed and integrated during software \ncreation. Key features include a uniform representation of multiple interrelated domains, the ability \nto project the domains in multiple editable notations, and simple access for a program generator. Categories \nand Subject Descriptors D.2.2 [Software Engineering]: Design Tools and Techniques; D.3.3 [Programming \nLanguages]: Language Constructs and Features. General Terms Management, Design, Human Factors, Languages, \nTheory. Keywords Intentional Software, Generative Programming. 1. Introduction For numerous practical \nreasons the creation of software has been historically approached from the point of view of the computer. \nAs a result most software is expressed in a general purpose programming language. Consequently, the programs \nrecord what is required for the computer, the detailed instructions for execution, rather than the problem \ndetails. This would not be an issue if only computers looked at programs, but that is evidently not the \ncase. Because programs are the only precise (i.e. machine processable) artifacts that record the programmers \nwork, any change (whether maintenance or extension) has to be done to the program, which is encoded in \na way that does not clearly express the problem that was to be solved. Fred Brooks expressed the frustration \nof programmers thusly [1]: Much of the complexity [the programmer] must master is arbitrary complexity, \nforced without rhyme or reason by the many human institutions and systems Of course this complexity is \nnot at all arbitrary from the point of view of the domain experts such as the hospital administrators, \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, or republish, \nto post on servers or to redistribute to lists, requires prior specific permission and/or a fee. OOPSLA \n06 October 22-26, 2006, Portland, Oregon, USA. Copyright &#38;#169; 2006 ACM 1-59593-348-4/06/0010 $5.00. \nthe content creators for a website, or the aeronautical engineers who have software needs. The goal of \nsoftware is to implement a solution to a problem that is defined by human intent alone. Some people have \nexpertise in the problem domain - they are domain experts. Some people have expertise in software creation \n they are programmers. Together they create software, perhaps with some people in both roles. This division \nof labor also leaves the domain experts frustrated. Why can they not contribute more directly to the \nsoftware? Granted, their potential contributions in terms of their domain expertise would not be executable \nby computer, but they evidently comprise an ever growing part of the total effort. The domain experts \nplea is: Programmers, if you are frustrated with complexity of the domain and with changes in the specifications, \ngive us a system where we, domain experts, can record and maintain our contributions in a way that is \nconvenient for you to process by software. The paper will present the following argument: 1. First we \nreview the well-known idea of generative programming that promises to involve the domain experts in the \ncreation of software by factoring the program into three parts: domain schema, domain code, and generator \ncode. 2. The main emphasis will be on the domain code. The novelty of this paper s approach is to introduce \na tool, the Domain Workbench that allows the combination of multiple domains that can be viewed and edited \nin multiple projections. 3. The domain schema defines the terms of the domain code and allows the generator \nto recognize and process these terms. 4. The generator processes the domain code and produces executable \ntarget code. The generator can be created using typical software engineering techniques. 5. The need \nfor multiple domains and multiple projections is introduced through a simple example familiar to many \nprogrammers: specification of a parser through production rules and tree building templates. 6. Finally, \nadditional applications are discussed and related approaches are reviewed.  1.1 Direct Programming and \nIntentionality For the creation of any software, two kinds of contributions need to be combined even \nthough they are not at all similar: those of the domain providing the problem statement and those of \nsoftware engineering providing the implementation. They need to be woven together to form the program. \nThe direct development workflow in use today (Figure 1) is the following: The domain expert communicates \nthe problem statement to the programmer. This is done in forms that can not be automatically transformed \ninto code, such as specs, use cases, stories, and sketches. The programmer then weaves these intentions \ntogether with software engineering knowledge and implementation decisions and creates the source code \nthat can run on a computer. Domain Programmer Source Code Run Expert Talks to Edits Compile Figure 1. \nDirect programming workflow. Persistent problems with this process stem from the fact that maintenance \nand correctness must be defined in the problem statement and in the implementation separately. However, \nmaintenance has to be performed and correctness has to be evaluated on the source code mixture of the \ntwo. Consider for example the following simple snippet from a banking application: void Trnsfr(Acct payer, \nAcct payee, Dlrs amount) { AuditTrl(payer.Xact(amount), payee.Xact(-amount)); } This program is correct \nwith respect to implementation types, yet it is incorrect in the domain: the payee should be credited \nthe amount and vice versa. When extending or otherwise maintaining a program, the programmer must mentally \nunweave the implementation (into Debits and Credits, for example), reason about the part in question, \nsolve the problem and reweave the result. This repeated unweaving and reweaving is an added burden on \nthe programmers that introduces many programming errors into the software and can increase costs disproportionate \nto the size of the problem. The example could be refactored like this: { AuditTrail(payer.Debit(amount), \npayee.Credit(amount)); } By using the domain terms Credit and Debit, the efficiency of maintenance can \nbe greatly improved. We may say that the second snippet is more intentional than the first it is a more \ndirect encoding of what was originally intended. Unfortunately, in complex systems a higher degree of \nintentionality is very difficult to achieve since a more complex domain vocabulary, domain relationships, \nand domain rules simply cannot be mapped into a programming language without a great deal of software \nengineering trickery which in turn makes maintenance exceedingly difficult. 1.2 Generative Programming \nIf we want to guarantee a high degree of intentionality, we have to express the problem in domain terms. \nSince by itself the expression won t necessarily constitute an executable program we have to rely on \nan additional transformational step: program generation. Generative programming (Figure 2) is a technique \nwhere instead of focusing on the final program, the programmers focus on a generator program that takes \ndomain code as its input and outputs the target code which is the final program. The domain code is expressed \nin a Domain Specific Language [4]. The target code can be a combination of any desired executable codes \nand other deliverables. The generator is the place where programming still needs to get done; but the \nfocus of the programmers' work has changed from writing the program directly, to writing the generator. \nMuch of the programming effort is very much like direct programming the program organization and the \ndata structures all need to be designed, defined, and written except that now the target code can be \nparameterized by the domain code. The savings are achieved when the domain code is maintained and the \ngenerator is re-run. Now the computer does what ordinarily would be the programmer s task: distributing \nthe domain code changes appropriately according to the complex correspondence between the domain and \nthe chosen implementation. Run Programmer Domain Source Edits Code Generate Code Compile Figure 2 Generative \nprogramming workflow The different applications of the generative techniques differ in how the domain \nspecific language is defined, how it is edited, and how the generator itself gains access to the language. \nA classic overview of the range of possibilities is given in [3]. 1.3 Intentional Software By using \na generator, the concerns of the domain experts and of the programmers can be separated. Nonetheless, \nmany issues remain for practical application. The relative dearth of generative solutions today may be \ndue to the lack of satisfactory resolutions for these issues: What is the language of the domain code? \nWho defines and who supports this language and its documentation? What if the problem spans more than \none domain for example banking and user interfaces? And what API does the generator use to access the \ndomain code? To create Intentional Software, we propose specific resolutions for the above issues and \nuse a Domain Workbench for support. The process starts by the domain experts with support from the programmers \ndefining the domain schema (see below) that will serve as the interface between the Domain Workbench \nand the generator as well as their users the domain experts and programmers. The domain schema contains \nat least a distinct identity (also called an intentional definition or def) for each concept of the domain. \n1 Were the domain chess, for example, we would need a def for the pieces, the colors, the board and its \nsquares, and the various states: initial, check, checkmate, draw. It is not required that we define the \ngame in the schema presumably that will be a part of the program that we create but we need to have \nthe vocabulary complete enough to define the game. If the domain is banking, we need defs for kinds of \ncustomers, for accounts, for credit and debit, for loan, debt, and interest; and also for the different \nbanking services, personnel titles, banking procedures and so on. Again, this is by no means a definition \nof 1 Conceptions of William James [11], or acquaintance objects as explained by Peter Naur [17] are remarkably \nsimilar to the intentional definitions, in that they have an identity but no fixed definition other than \nthrough their participation in a stream of consciousness. banking but something that is essential if \nwe want to say something about banking. The domain code is maintained by the domain experts. The need \nfor a fixed language is eliminated by the Domain Workbench s ability to project contents from multiple \ninterrelated domains in multiple views. Finally, a generator is written by the programmers to define \nhow the domain code input should be processed to get the intended implementation, see Figure 3. In other \nwords, the generator represents implementation knowledge such as engineering design, algorithm choices, \nplatforms and code patterns used (essentially all the work that programmers typically perform except \nfor the domain details in the domain code). So the generator excludes some information that is in sources \nproduced by direct programming, but also includes information that is not found in direct sources, namely \nin what precise ways the target code depends on the problem details. Programmer Builds Generator Generate \n&#38; Domain Edits Domain Code Compile RunExpert Figure 3. Intentional Software creation workflow How \ndo the domain schema and domain code differ from classes and objects? The main difference is the complete \nlack of a priori semantics. The domain expert need not make a decision whether the domain concept is \nan object, a quality, an action, a goal, or anything else. The need is just to establish an identity \nfor it, whatever it may be, and that can be accomplished always in the same way by a def in the schema. \nOn the other hand, how are the domain schema and domain code different from UML? The difference is the \nabsence of prior restrictions of what can be represented in the domains that are described by the schemas. \nThe generator is the ultimate guarantor of extensibility, but to do that the generator may need arbitrary \nforms in the domain code. This in turn is guaranteed by the extensibility of the schema language. Through \nbootstrapping, circular arguments are permitted in software engineering. So we can say that the schema \nlanguage is extendible with new properties (that might be considered meta\u00adproperties in this context.) \nIt can also be projected and edited in a number of notations because every language in a Domain Workbench, \npartly with the guidance of schemas, can be so extended and so edited. Given this ability to add properties \nto languages, we can enrich the schema language to contain the meta-information needed for the various \ndomains. In effect, the schema is simply a database of meta-information to be used by the generator and \nby the editor.   2. The Domain Workbench The Domain Workbench is used to define, create, edit, transform \nand integrate multiple domains. The Domain Workbench is an instance of the Language Workbench class of \ntools as described by Fowler [8]. Wysiwyg editors [14] are a useful historical metaphor for what can \nbe done when the demand for the expression and manipulation of more complex data arises. Before Wysiwyg \nbecame popular, editors were called text-editors since they represented only the text contents of documents. \nAs an intermediate stage of development, special character combinations (or control codes ) were used \nto encode what the formatting should be. For example, ^i might turn on italics. HTML and its successors \nstill use this style of encoding. Today, a word-processing user does not have to make a distinction between \nthe italic character i and its underlying representation. Wysiwyg editors separate the display of the \ndocument on the screen ( What you see ) and what is printed ( what you get ) from the underlying representation \nof the document. That separation makes it possible for the user to create and edit much more complex \nand effective documents. The editor of the Domain Workbench applies the same Wysiwyg technique to software \nsources. It separates the display of the software and what is generated from the underlying representation \nof the software whether schemas, domain code, or programming language source code. The representation \nis in a uniform format for all domains: the intentional tree. Display and editing is performed by projecting \nthe tree on a display by a number of reversible transformations some of which may be domain specific. \nAll are sensitive to user options that select from the many available views to project. 2.1 A simple \nexample Consider the following program statement as we used to write it: return a = b / (c + 1); Naturally \nthere is a projection of this statement that looks exactly like text: But how does the intentional tree \nlook? The editor has another projection that shows the underlying intentional tree like this: There \nare differences in the information shown in the program text and tree representations. What happened \nto the semicolon (;) and the parentheses that are in the program text and not in the tree? These are \nartifacts of the programming language syntax. The semicolon is implied by the structure below the Return \nstatement: it may or may not be needed depending on the syntax and depending whether the statement is \nthe last in the statement list. At any rate the semicolon does not convey any intention. Compare the \nabove tree with this tree: which describes the different formula b / c + 1 instead of b / (c+1). So \nthe parentheses are artifacts of the algebraic notation that takes the traditional precedences of the \n/ and + operators into account. There is an intention expressed (namely which operator we want to apply \nto the result of the other) but we express this in terms of the intentional tree structure, not some \nadditional participants like the left and right parentheses. By changing settings, we can project the \noriginal intentional tree into other different notations: Note that the intentions are so clear there \nis no need at all for parentheses. We realize that in the program text notation the unambiguousness of \nprogramming languages presupposes that we have perfect knowledge of possibly obscure language details, \nsuch as the relative precedence of &#38;&#38; to || . When we lack this knowledge, the theoretically \nunambiguous notation is in fact ambiguous for us. By projecting using a different notation (that may \nalso be ambiguous but along a different axis) we can easily resolve the ambiguity. As we will see, mixing \nand integrating notations and domains with software programs make software creation more effective for \nthe programmer. This also allows projections that non\u00adprogramming domain experts can understand and edit. \n 2.2 Structured Source Code and Structured Editors I mean, source code in files; how quaint, how seventies! \n Kent Beck The Domain Workbench builds on two key ideas that are decades old: Structured Source Code \nand Structured Editors. Consider two questions about a programming language. How do you write an if in \nAda? , and Does Ada have coroutines? . The first question is about notation or syntax, the second is \nabout semantics. These are the two main components of a text-based programming language. These two components \nare also reflected by the structure of a typical compiler: the front end embodies the knowledge of the \nsyntax, while the middle part defines the semantics. (The back end of a compiler expresses the knowledge \nof the target machine, which is not important here.) Structured source code means that we store, maintain \nand process the input to the compiler's middle part directly. In computer science this is called an Abstract \nSyntax Tree (AST). The intentional tree is similar to an AST, but there are some key differences that \nwe will discuss in Section 2.3. The format of the tree structure could be XML [20], but we use the proprietary \nIntentional Tree [19] representation. A structured editor is an editor that is cognizant of some higher \norganization in the edited data. Wysiwyg editors such as Bravo [14] or Microsoft Word can be called structured. \nEspecially when applied to program code, there are two major kinds of structured editors: A syntax directed \neditor is an editor that knows about a language syntax that is used ostensibly to help the user. Syntax \ndirected editors [12] operate well within the constraints of the syntax with many of the advantages and \ndisadvantages thereof that are outside of the purview of this paper. A projecting editor transforms, \nor projects, the underlying representation into one or more notations and may be able to invert the transformation \nto effect changes to the representation. CAD systems and modeling tools are typically projecting editors. \nEarly work on structured source code used in combination with structured editors had two goals. The now \nobsolete initial goal was to improve compiler performance. The other goal was to help implement syntax \ndirected editors where it was thought that strict control of the input and context-specific typing prompts \nwould help the user enter programs more rapidly and with fewer errors. By and large these efforts were \ndisappointing in that limitations of the input tended to get in the way of the creative process where \nthe program text often passes through intermediate stages of completeness and correctness. For example, \none might start with the interior of a loop and work outward. In contrast with the above goals, Intentional \nSoftware uses structured source code and a projecting editor not to help with enforcing a syntax but \nso that domains are not limited by syntax. Definition of new domains and arbitrary extension of existing \ndomains, can be difficult to accomplish if a parsable and unambiguous syntax also has to be designed. \nThere are several reasons for separating the syntax from the domain. We gain notational flexibility in \nthat many notations we observe both in programming domains and other domains can be equally accommodated. \nThis also results in greater user satisfaction because individual preferences differ, not only out of \ncaprice, but also due to individual backgrounds and experiences. Individuals prefer what is familiar \nfrom prior contexts. But the most important reason for separation is that computer notation then no longer \nneeds to be unambiguous. It can thus more closely resemble the domains own notations. In fact very few \nif any of the everyday domain notations are unambiguous. A good example is a drawing of a building facade \n it is just one view. We know that the complete definition of the building means a whole set of drawings, \nor more recently a CAD database from which any drawing can be printed as needed. The difference between \nnotations and syntax is subtle but important. Notations need not be parsable, so they can be quite freely \nchosen on the basis of qualities other than parsability. For example, we can pick notations that simply \nlook good, or are traditional in the domain, or otherwise please the users. Even ambiguity need not be \nan obstacle. For example, the common mathematical notation Aj is ambiguous yet it can be what the user \nwants and likes. Note that the structure that is projected is never ambiguous, but the projection might \nbe. In the proper context, an ambiguous projection need not create an ambiguous impression in the mind \nof the person using the editor. For example, mechanical drawings can be very ambiguous. A circle may \nwell denote the void of a hole in a plate or the cross section of a steel shaft, yet the engineer familiar \nwith the context would not be confused. However, key advantages of text representation that have assured \nits preponderance are worth reviewing. Text representations are easy to implement, especially when using \ntraditional input devices such as punched cards, keyboards, and glass teletypes. Text languages consequently \nhave a very simple editing model. For example, to create the program fragment a+b one simply has to press \nthe keys a, +, and b. So the editing model and the representation model coincide. But this advantage \nis not going to remain sufficient in the long run to compensate for the disadvantages enumerated in Section \n2.5, especially when most other application programs have abandoned text based representation and introduced \nmore effective editing models. For example, slide presentations and spreadsheets are not created just \nby using text syntax. 2.3 Intentional Tree The famous painting by Magritte ( Ceci n est pas une pipe \n) is not a pipe but a painting of a pipe. Similarly, the illustration of the tree representation above \nis not the tree; it is a projection of the tree. The actual tree, the domain code, is a data structure \nwith nodes that have an isa field pointing to the intentional definition (def) in the domain schema. \nThis is indicated in the above projection by names such as Plus or b . A node may have children, and \nmay also contain arbitrary binary data whose interpretation is based upon the node s definition. For \nexample, a NumLit together with the appropriate bits (...001) is projected above as the constant 1. The \ndefinitions themselves, represented in a domain schema, are also nodes in trees and as such form a domain \nof their own. For example, we can define a name as a TextLit parameter underneath the definition: def \n(name (TextLit Plus )) Figure 4 illustrates that there are no fundamental distinctions between nodes \nin the domain code and definitions in the domain schema.  The name property of a definition is not fundamentally \ndifferent from a string literal parameter in a print statement, or from a comment that looks like this \nin the tree: Comment (TextLit this is a comment ) Note that there are no comment delimiters or string \nquotes stored in the string, as opposed to XML. The proper delimiters for any given notation will be \nsupplied by the respective projection. Of course uses of names, string literals, or comments are completely \ndifferent, but the underlying representation can be the same. Treating names and other strings the same \nway eliminates the need for limiting rules on what can be a name or whether more than one name can decorate \na node. Domains often use names that programming languages do not support, for instance spaces or characters \nfrom non-English alphabets. In the intentional tree names are like comments. Names are there to communicate \nwith the users; they are not internal identifiers. The representation of the intentional tree is implemented \nin a special purpose system [19], rather than using a general purpose encoding of, say, XML. In a well \ndesigned system, solutions to all the issues that come up in practical use can be implemented uniformly \nto meet the highest standards. Examples include how to maintain identity reliably and independently of \nnames; renamings; what happens if a definition is deleted; how to handle undo; versioning and groupware; \nhow to search efficiently; and so on. In addition to maintaining identities, the most important requirement \nis the ability to refine any node at any time to an arbitrary extent by adding parameters without disturbing \nthe existing parameterization. In domains this corresponds to the need for continuous refinement. Refinement \nis used to add operands, attributes, properties, formatting, subscripting, tags, or decorations. For \nexample, we can make the word is in the comment italic, by adding a parameter like this: comment(TextLit \nthis TextLit is (Italics) TextLit a comment ) When strings are available it is always tempting to \nencode new information into the strings using special syntax. We could have written: comment(TextLit \nthis <i>is</i> a comment ) The disadvantage would be that none of the guarantees and benefits of the \nintentional tree representation would accrue to the text formatting.  2.4 Domain Schemas and Transformations \nDomain definitions, such as TextLit or Plus, are defined as nodes in Domain Schemas that are also defined \nin an intentional tree using a definition domain as its meta-domain. The description of this meta-domain \nis outside the scope of this paper. It is worth noting, however, that even a minimal definition is usually \nsufficient to start using it in intentional domain code. Any new definition will inherit sufficient services \nto be useful. For example, it will show up in name lists within the domain, and it can be displayed in \nany number of the universal tree display projections such as the one in Section 2.3. The semantic value \nof a definition is ultimately derived from intentional tree transformations that do something with it. \nFor this the transformations need only a minimal definition the identity of the intention. Meta-data \nassociated with the definition the Schema content serves merely to parameterize the transformation so \nthat more general transformations can be performed without requiring meta-data specific code. For example, \na name string in the definition allows the use of a general name lookup facility, possibly using multiple \nnames of any specific node. Field descriptions under the definition enable the use of menus that can \nprompt the user for common parameters or auto completion. In addition, help text in the definition is \nused to generate a help facility. For example, the definition of Plus can list the notations for Plus, \nincluding its possible names, possible symbols, methods for computing Plus, and information for generating \ncode for Plus. The definition can also include help text and the precedence of addition operator in multiple \nstandard languages. All of this information is there to support specific transformations, so that generic \nmethods can be used to evaluate expressions, to project the operation in multiple ways, or to generate \ncode or a help facility for Plus. These benefits are there to support the schemas as well. Schema notation \ncan evolve and improve as needs expand. Similarly, new kinds of information can be added to schemas. \nBecause each node is self-identifying through its schema, mixing trees from different domains becomes \npractical. See Sections 3.2, 4.1.1 and 4.1.7 for some examples. 2.5 Projections and Editing Domain code \nand domain schemas are just data. They have no behavior on their own. Transformations add behavior, and \na special type of transformation is the projection for editing in the Domain Workbench. But how can arbitrary \nediting work consistently across various notations? The well-established cut, copy, and paste model works \nwell for most structured editing. The main difference is that in text editing, the user perceives two \nkinds of selections: a place and an extent. There may be many different ways of selecting extents: by \ndrawing through them, by double clicking for words, or clicking on the left margin to select lines and \nparagraphs. When satisfied with a selection, the user can cut, copy, paste, or move the selected text. \nIn structured editing, a few more kinds of selections become available. This is not unusual. For instance, \na spreadsheet application is a form of structured editor, where the selection has to distinguish between \nwhole cells and the contents of a cell. Since the user is predisposed to making exactly that kind of \ndistinction, the distinction between cell selections and contents selection in spreadsheets does not \nraise usability issues. Similarly, in the Domain Workbench we use selection to distinguish the following \nediting situations: 1. Prepare for editing just one node in the tree ( crown selection ) 2. Prepare \nfor editing a subtree or forest ( tree/range selection ) 3. Insert into a list ( place selection ) \n4. Parameterize ie. add new children ( under selection ) 5. Operate on a subtree ie. splice above a \nnode ( wrap selection ) 6. Edit text contents ( text selection )  These selections provide an essentially \ncomplete set because any tree can be built, and editing operations to change a current tree into a desired \ntree are reasonably intuitive. For example, to negate an expression, the user wrap selects the expression \nin question and pastes the negation operator node. Each selection is identified and highlighted in an \nimage of the underlying node or subtree in a projection, so it is largely independent of the projections. \nFor example, to change a division into a multiplication, the user crown selects the division sign (in \nx whatever format is projected for example x/y or ) by clicking y on its image and pasting a multiplication \noperator node (perhaps from a menu). This can be accomplished in any notation that has any image of the \ndivision, including if it is denoted by a fractional line. Often making a selection and seeing the highlight \nhelps one to navigate complex formulas and visualize what operations apply to what operands. When a selection \nis in text, editing can continue in a conventional manner. The keyboard is used to input intentional \ninformation in two stages. First, sufficient text is entered and projected at the place of editing to \nconvey the user intention. This text is not yet a real edit on the intentional tree. Second, the editor \nmust interpret the text and convert it into an intentional node or nodes at which point the edit effectively \na paste takes place. Each interpretation at a minimum must recognize names by using name tables from \nwhich the intentional reference can be determined or by user interface techniques in case of name ambiguity \nor other complication. Numbers must be also recognized by the usual rules. At this point an arbitrary \ntree can already be built using the keyboard and the selections. The simplicity of editing text-based \nlanguages comes at a high cost. In effect, the user is continually expected to manually project the underlying \nintention into the text representation, just so the system can claim simplicity for its editing model! \nEditing in the Domain Workbench editor can also be perceived as simple because the user can think of \nediting the underlying intention, not somehow trying to manipulate the projection. This may take a little \ngetting used to just as Wysiwyg surprised its first users by making text flow from one line to another \nwithout typing carriage returns. If your expectation was that you are essentially using a typewriter \n(a glass teletype ) such behavior could have been surprising and disturbing. On the other hand, if your \nexpectation is that you are interacting with the contents and you let the system handle the text layout, \nthe flowing of the text is now perceived as perfectly natural. In fact, when text does not flow that \nis the surprising exception that may indicate a problem. Intentional interpretation of text can be extended \nto parsing of various simple syntaxes, such as the traditional syntax for expressions or code snippets \nfrom programming languages that are already defined to be parsable. Note that this is not the same as \nusing syntax to encode a result. Parsing is just another input device to augment the mouse, menus, and \ncontrol keys of the editor. Once the data has been intentionalized turned into intentional tree form \nall the guarantees will hold. To bring legacy definitions and code into the Intentional tree Parsing \nis a convenient way to bring legacy definitions and code into the intentional tree.  3. An Example: \nGrammars Despite the fact that the Domain Workbench does not rely extensively on syntax information, \ngrammars can still be used as an example of an intentional domain. A grammar is not executable by itself, \nbut can be used as input to a generator that generates an executable program in this example a parser. \nGrammar also has the advantage of being very familiar to computer scientists and comparable applications \nexist, most notably YACC [21]. An example is also valuable because a similar approach could be used to \nimplement business software. Of course, business domains are very different from grammars. But for comparison \npurposes they have much in common. Most importantly, neither is executable. Furthermore, both are repositories \nof complex information that define a specific set of decisions and rules from some more general domain. \nIn the production rules of a grammar, the decisions described are the structure of the language to be \ndefined, the nomenclature of the syntactic categories, and the like. The general domain is the theory \nof computer languages. For a business domain, the specific decisions described can include the nature \nof the process steps, their connection to each other, business rules and the nomenclature. A process \ndomain can be a set of common process steps such as process initiation, communication, approval and the \ncommon agents and concepts such as customer, invoice, or payment. In both cases the theory comes with \na large number of operations, combination rules for the operations, and whatever common notations the \ndomain experts prefer. The purpose of our comparison with YACC is not to belabor the obvious that after \nmore than 20 years of advancement in hardware and software technology we can produce better looking output. \nThe purpose is to suggest that the Domain Workbench can simplify the creation of tools like YACC. The \nnovelty is not the quality of the output, but the ease by which that quality can be achieved. 3.1 Intentional \nProduction Rules Figure 5 shows two production rules for a small part of the C# language shown as projections \nin the Domain Workbench editor. The underlying tree for the second of these is as follows: ProductionRule \n( Name( using ), Concatenate ( using , type-name, Optional ( = , type-name ), ; ) ) The production \nrule is expressed as the definition with a name so that it shows up in the name lists that the editor \nsupports. Within the expression we have three kinds of operators: terminals coded as literals, non-terminals \n coded as nodes referencing the corresponding production rule, meta-operators such as ProductionRule \nor Concatenate. Using the domain schema we can easily make changes such as the following without invalidating \nlegacy code that has already been developed in this domain: change or extend the nomenclature (the names \nof the meta-operators), add new meta-operators, extend the current meta-operators with new or different \nparameters, introduce new notations, and enjoy other benefits of the Domain Workbench such as groupware. \nLegacy domain code only needs to be modified if the domain schema changes radically, and if it is desirable \nto eliminate references to the old schema design (for usability or maintenance reasons). Multiple schemas \ncan easily coexist for an interim  Figure 5. Projecting a subset of the C# grammar.  Figure 6. Projecting \nthe subset using a different notation. period even using the same projections and the same nomenclature. \nDomain-specific names can also be accommodated. For example, non-terminals in production rules often \nuse hyphenated names as shown in Figures 5-8. The use of common terms, such as Concatenate, will not \nlimit use of these productions when mixed with other domains that also use the same term. Since names \nare used only to communicate with the user, name overloading affects only the user, not the system. In \neveryday life we are well equipped to handle occasional name ambiguity. For example, we would not otherwise \nuse first names. In the projection in Figure 5, the symbols * and [..] denote ZeroOrMore and Optional \nrepetitions respectively. If the user forgets which one is which, the user can simply change to the projection \nshown in Figure 6 where the repetitions are shown explicitly. This projection is also editable. But that \ndoes not mean the lower and upper limits are arbitrary (for example Repeat(...; 2..3)) unless such an \noperator is also defined for the domain. To change the first Repeat clause, it (or the * in Figure 5) \ncan be selected and Optional can be typed or chosen from a name list for pasting over. In response the \nsystem will echo Repeat(...; 0..1). This example shows the difference between what the intentional source \nis, how it is viewed, and how it can be edited. When these activities are separated, the domain designer \ncan choose to invest more or less support into any or all of them depending on user feedback. The interesting \nthing is how much is possible with little or no special support. Other projections can be created for \nthe same domain with dramatically different effect. In Figure 6 we used the < > brackets instead of italics \nto distinguish non-terminals. Figure 7 uses capitals, as in COBOL manuals with a twist on the nomenclature. \nFigure 8 uses railroad diagrams where non-terminals are distinguished by both font and borders. Note \nthat each of these projections uses exactly the same intentional tree representation. Only the projections \nare altered. In Figure 8, in contrast to the Repeat case, it would be quite natural for users to change \nthe first loop by picking Optional from a menu. This is because when the notation is graphical the user \nsimply does not expect to type what the user wants to see.  3.2 Extending and mixing domains Extending \nand mixing domains are useful capabilities. For example, we have already made a small extension the grammar \ndomain: we have added a repetition construct to the basic BNF notation to shorten the syntax productions. \n(Section 3.4 shows in part the extra productions that would have been necessary had we not used repetition.) \nThe goal of these productions is not only to parse syntax but also to build trees. There are several \nrequirements: we need to specify the template for the tree to build and we need to connect the parts \nof the productions to the variable parts of the template. The additional goal is easily met by wrapping \nthe individual parts, giving them names when the non-terminal name would not be sufficient, and building \nthe template by actually quoting the desired results. Compare the following native projection with those \nin Section 3.1: ProductionRule ( ProductionOutput ( Name( namespace ), Concatenate ( using , ProductionOutput \n( Name( Alias ), type-name, ) Optional ( = , ProductionOutput ( Name( Reference ), type-name, ) \n), ; ) Template ( Using ( Reference, Alias, ) ) ) ) These productions can be projected without the \ntemplate-related information as in Section 3.1, or with it included (see Figure 9.) The projection in \nFigure 9 neatly separates the production rules  Figure 7. Projecting the subset of the C# grammar using \nCAPITALS. Figure 8. Projecting using railroad notation.  Figure 9. Mixing the grammar domain and the \ntemplate domain. from the templates that reference it. The projection of the templates (in the right \ncolumn) uses the C# language domain. Note that this domain code combines three domains: the domain of \ngrammars, the domain of tree-building templates, and the domain of C# (where the actual definitions of \nthe source intention namespace and using reside). The productions named namespace and using define the \nsyntax only. Note also that the same name is used to denote two very different, yet related, things. \nIf that is not tolerable, renaming and multiple names can always be used.  3.3 The Generator The generator \nis a class written in C# that creates the parser (also in C#) as directed by the domain code. The Domain \nWorkbench provides an API whereby the generator program can access the domain schemas and the domain \ncode. The parser uses a simple name binder and textbook algorithms. When the parser is given the above \nsources and the string namespace Foo { using Bar ; } the output will be a tree that is projected:  \n3.4 Comparison with YACC These results can be directly compared with YACC files that perform essentially \nthe same tasks. Following are the YACC statements equivalent to the domain code in Section 3.2: namespace \n: 'namespace' type-name { nsCurrent = new Ns($2, nsCurrent); } '{' optional-usings optional-namespace-member-declarations \nnamespace_close { nsCurrent = nsCurrent.parent; } namespace_close : '}' ';' | '}' optional-usings \n: | usings usings : using | using usings using : 'using' alias '=' type-name { nsCurrent.AddChild(new \nUs($4, $2)); } |'using' type-name { nsCurrent.AddChild(new Us($2)); } alias : type-name optional-namespace-member-declarations \n: | namespace-member-declarations namespace-member-declarations : namespace-member-declaration | namespace-member-declaration \nnamespace-member-declarations First, note the extra productions above that were not necessary in the \nIntentional system. Those with names optional-* were implemented by the Optional construct. The production \nnamed namespace_close was necessary to allow the association of a template with both alternatives, with \nor without the semicolon. Second, the parse tree is built using templates written in a general purpose \nlanguage like C++. This assures flexibility, but it is complicated for normal cases. An API must be written \nfor building the tree, in this example the classes Ns for namespace and Us for using. Irrespective of \nhow the YACC template is expressed, how to connect it to parts of the production remains an issue. YACC \nuses the pragmatic approach of integer indices into the production. For example, $4 represents what was \nreturned by the 4th item in the production: 'using' alias '=' type-name namely type-name. To summarize \nthe differences: i) Enhancing expressiveness of a domain can improve intentionality of the domain. The \nDomain Workbench expressed with 2 productions what took 8 productions in YACC. The extra 6 productions \nin YACC were unrelated to the domain, having more to do with the lack of expressiveness. Especially for \nlarger, realistic problems, this expansion (a factor of 4 in this case) from the domain into a representation \nof the domain can obscure what is being described and is an obstacle to maintenance and enhancements. \nii) Domain enhancement can continue in the Domain Workbench. For example, the OneOrMoreOf construct could \nalso specify the delimiter before and after the list and in between the list items. This further reduces \nthe clutter and separates essential information (that there is a list) from the stylistic (that the list \nis separated by commas). iii) When domains can be combined clearly (with reliable references across the \nboundaries,) we can create a template domain that is related to the target language thus avoiding or \ndelaying use of a general purpose programming language (until truly exceptional situations arise). iv) \nReplacement of fragile integer references (such as $4 in YACC) with intentional references also eliminates \na large source of potential problems. These advantages are individually small but generally applicable \nand therefore have great cumulative effect. Just as it is simple to add capabilities to the domain schema, \nit is also possible to keep unnecessary constructs out of the domain; for example, eliminating the extra \nproductions and omitting the templates from the projections. The purity of the domain helps with maintenance \nand with processing the domain for new purposes. For example, the grammar domain may be used to create \na framework for documentation, or to generate a projection automatically from an intentional tree into \nthe particular notation described by the domain.  4. Applications The capabilities of the Domain Workbench \ncan be applied in many domains including various Software Engineering domains. The ability to define, \ncreate, edit, transform and integrate multiple domains creates an opportunity to rethink some Software \nEngineering practices. Depending on the focus of the Domain Schemas we can distinguish between language \noriented development (where the notations, the schemas, and the generator closely mirror and extend existing \ngeneral purpose languages) and domain oriented development (where a business domain is the starting point \nand the generator is built to create a domain specific solution.) 4.1 Language-oriented development \n4.1.1 Mixing sources from multiple languages Many software systems are implemented using multiple languages, \nfor example Java, Javascript, and HTML. The biggest problems here are references from one language into \nanother and sharing of definitions and other meta-data. In Section 2.3 we showed how the intentional \ntree representation expresses references. Similarly all meta-data can be shared and manual copying and \ntranslation of definitions can be avoided. The editor provides a common editing experience across all \nlanguages. Figure 10 shows a projection where a SQL statement (using a SQL domain) has been mixed into \na C# program (using a C# domain). Note the reference to the C# formal parameter ADDRESSID in the SQL \ncode. This is not a SQL feature, but a simple generator can create the files for the fragments to run \nin standard C# and SQL environments. 4.1.2 Extending a language Language features are currently associated \nwith specific languages and a great deal of energy is spent explaining the coherence or cleanliness of \nthe rather arbitrary feature bundles we call languages. Just as programmers are free to define APIs and \ndata structures today (for better or for worse), using the Domain Workbench they will also be able to \nimplement whatever language features will help them. 4.1.3 Names Names in programming languages serve \ntwo purposes. One has to do with identification of references, and the other has to do with human factors \n(as a name is also a communication, mnemonic and thinking aid). With these purposes separated, each purpose \ncan be better served. A quantity can have multiple names. The old name after renaming can be retained \nto ensure continuity with legacy. Localized names can be used in national alphabets. Nicknames can be \nused for quick entry. Iconic names can be used for learning. Names that follow a convention (for example \nusing the type as a name) can be generated automatically. 4.1.4 Eliminating code copying and aspect \nfragmentation Language extension should be considered when code is copied or when a particular concern \n(or aspect) is fragmented over many parts of the source. The former is frequently due to the difficulty \nof expressing performance concerns or for parameterization in a context where the language does not permit \nit. The latter gave rise to Aspect-Oriented Programming [13] with language features that centralize the \nexpression of aspects. Code copying and aspect fragmentation cause many of the most common maintenance \nproblems [7].  4.1.5 Personal preferences A frequent source of frustration in any environment arises \nfrom conflicts between personal preferences and external standards. Many of these conflicts go away in \nthe Domain Workbench as Figure 10. Mixing source from a C# domain and a SQL domain. each user can simply \nproject the common information in whatever ways that user prefers.  4.1.6 Testing Programmers ability \nto improve testing suffers greatly from lack of support to express and process test intentions beyond \nAsserts. The main needs are: a. The ability to associate test code (including asserts, pre and post conditions, \nwhite-box test and test data) with the code being tested without any permanent visual or other impact. \n b. The ability to refer to parts of the algorithm being tested and affect their behaviors for testing \nwithout disturbing the source code. c. Access to meta-data and other descriptions of the problem.  \nFigure 11 is an example of how test cases can be inserted directly in the source code. In this example, \ntest case 4 signals an error, but the error is actually in the test data not in the code. 4.1.7 Eliminating \nthe need for many tradeoffs Languages tend to differentiate themselves by the position taken on two inherently \nopposing requirements, expressiveness vs. brevity. Some languages take one extreme, some the other. For \nexample, the language APL [10] is famous for its extreme brevity. Others made pragmatic choices somewhere \nin the middle to minimize overall misery, while COBOL opted for garrulousness. The Domain Workbench can \nmove from one choice to another whenever needed so the tradeoff disappears. We can focus on many new \nchoices in the solution space, rather than continue to argue about yet another tradeoff. 4.1.8 Program \ntransformation and refactoring The intentional tree format is also convenient for program transformations. \nBoth display generation and code generation employs tree transformations. These capabilities are easily \nharnessed for other code refactoring and code analysis tasks, with the additional benefit that results \nof each transformation can be inspected in many formats. Note that program transformation is a domain \nof its own that invites support by DSLs. 4.1.9 Improving IDE interaction Many functions of Integrated \nDevelopment Environments are limited by the lack of intentional information in the source code. A trivial \nexample is the lack of connection between a comment and the statements. When the source contains the \nconnection at the outset, it is much easier to move the comment with the code, and to determine when \nthe display of a comment should be suppressed in outlines. When the editor can distinguish code that \nis used only for error cases, or only for testing, it becomes easier to include more testing code or \nmore assertions. Their presence will not overwhelm viewing of the main program logic. 4.1.10 Reuse Reusability \nis an important quality of code that is deeply connected to parameterization. The issues of reuse in \ngeneral are complicated and outside the purview of this discussion. But the likelihood of reuse, can \nbe greatly increased by parameterization. Fixed code will either match a situation or not. Parameterized \ncode will match a larger number of situations. Programmers are implored to make software more reusable. \nThis is effectively a call for parameterization with respect to some expected range of differences. The \nparameterization guarantee of intentional trees always makes this possible. If notation becomes an issue, \nthat can be resolved by extending the projections. Performance issues can be handled by specialization \nin code generation.  4.2 Domain-oriented development benefits The domain schema, the domain code, and \nthe generator together represent a factoring of the implementation. This factoring makes Intentional \nSoftware a plausible approach for dealing with the complexity of domains. The schema and generator can \nbe improved incrementally as new knowledge is gained in the domain. The domain experts can update the \ndomain code and re\u00adrun the generator for common changes in the problem that are still within the schema \nparameters. While not all desired changes can be made this way, the worst case outcome is just today's \nbest practice. Namely the domain experts will have to talk to the programmers. This contrasts with direct \nprogramming (as discussed in Section 1.1) where every change requires human interaction that introduces \ndelay, costs, and potential errors. Programmers can also make substantial implementation changes in many \ninstances by only changing the generator. The absence of domain detail helps reduce the scope of these \nprogramming tasks. The programmers' task of creating a generator, however, may be thought of as harder \nthan just creating one implementation instance. On the other hand, it can also be argued that creating \nthe generator is a purer, more explicit, and more transparent expression of what the programmers should \nbe doing: verifying assumptions, incorporating testing into the code, making dependencies on domain details \nclear, and so on. The concept of partial implementation is also worth noting. An intention recorded in \nthe schema or in the domain code is valuable when the implementation is not yet started, is done partially, \nor is done fully . Of course, there rarely is any full implementation. Just as there is no perfect implementation, \na minimal implementation can be valuable during the development process. Variants of generative programming \nhave been tried in the past with generally positive results. One important bottleneck has been the need \nto specify the input to the generator in the form of a DSL typically including a syntax and parser. Even \nwith automatic parser generators, just the design costs of a syntax can be daunting. In addition, most \nDSLs retain a programming language flavor that hinders more direct involvement of non-programmers such \nas domain experts. For domain experts to be efficient, the domain descriptions need to mirror the domain \nintentions [6]. Furthermore, most problems involve multiple domains and legacy components written in \nother languages. However, DSLs have historically been difficult to mix with general purpose programming \nlanguages and other DSLs. Sections 3.3 and 4.1.1 discusses how this can be resolved in the Domain Workbench. \n 5. Other Generative Approaches Several other approaches use generative techniques to tackle complexity \nin software development. Code generation is commonly used for generative programming. For example, template \nlibraries like STL [16] use code generation. The CASE products of the 80 s were able to generate standard \nCOBOL or C applications from specialized diagrams. These were fixed generators. If the users needed to \ndo anything that was not in the generator's repertoire, the user had to maintain the generated COBOL \nor C code. For specific, well contained problems, code generation was and still is effective. A list \nof current code generators can be found at [2]. Wizards are another example of code generators popular \nin IDEs. Wizard dialogs often capture intentional information about the program. But once the programmer \nclicks Finish, the code gets generated and the succinct intentions are scattered across the generated \ncode and lost. Code generators work fine as long as the output of the generator does not have to edited. \nWhen the output of the generator is edited, problems can arise the next time the generator runs the edits \nmay be overwritten. Editing the output challenges the code generator to invert the encoding function. \nMost generators cannot perform the inversion, and even if they were helped they could not represent the \ninverse without an enhancement of the input. Round trip engineering, two-way wizards, and synchronization \nwere all developed to solve the problem of allowing modification of generated code and still allow reconciliation \nwith the domain specific model. These remain standard features of many model driven tools. In a round \ntrip the same data persists in two places, in the model and in the code. That makes it difficult to maintain \nconsistency. Typical approaches designate one copy as master and either pull on demand or push on change \nfrom the master to the redundant copies. Another way around the problems is to separate the code that \nis generated into two parts: one that is editable by the programmer and one that is not. But this forces \nthe programmers into whatever artificial separation is prescribed by the tool. Domain Specific Languages \nshift customization into the language itself by trying to design the optimal language for each specific \ndomain [4, 5, 9, 15, and 18]. One problem with DSLs is that, since by nature they are specific to one \ndomain, they often become silos of their own. Furthermore, DSLs suffer from the same problems as General \nPurpose Languages: good languages are difficult to design, their syntax is limited both in the notation \nand expressiveness, they are difficult to evolve, and it has been difficult to combine multiple languages. \n 6. Summary This paper presented the general ideas of Intentional Software. The Domain Workbench allows \ncreation and editing of domain code. The intentional tree contains the domain code for Domain Specific \nLanguages, General Purpose Languages, and meta-data. The use of Generative Programming turns the domain \ncode into executable target code. Past problems with structured editing have also been discussed. While \npast experience with structured editors has been generally negative, the need in this new context should \ncause us to re\u00adexamine the problems and implement pragmatic solutions. Most application software other \nthan programming has already moved ahead toward recognizing more structure in documents. The domain of \ngrammar production rules was used as an example. Some snippets from the C# syntax were presented in a \nnumber of projections to show the interchangeability of popular notations and the corresponding tree-generating \ntemplates. These examples were selected to show not only that syntax and semantics can be separated, \nbut also that the users intention domain code is a proper focus of investigation. The factoring described \ncan yield benefits beyond direct benefits of notational flexibility and semantic extension. 7. Acknowledgements \nThe authors are grateful to all reviewers and colleagues at Intentional Software Corporation for their \nvaluable contributions to the content of this paper. 8. References [1] Brooks, Fredrick, No Silver Bullet \n Essence and Accidents of Software Engineering, Computer Magazine, 1987. [2] Code Generation Network \nwww.codegeneration.net [3] Czarnecki, K. and U. Eisenecker. Generative Programming: Methods, Tools, and \nApplications. Addison-Wesley, Reading, MA, USA, June 2000 [4] van Deursen, Arie, Paul Klint and Joost \nVisser Domain-Specific Languages: An Annotated Bibliography, 2000 http://homepages.cwi.nl/~arie/papers/dslbib/ \nAn updated list published here http://catamaran.labs.cs.uu.nl/twiki/pt/bin/view/Transform/D SLBibliographyAdditions \n[5] Dmitriev, Sergey. Language Oriented Programming: The Next Programming Paradigm, 2004. http://www.onboard.jetbrains.com/articles/04/10/lop/ \n[6] Evans, Eric. Domain-Driven Design. Addison Wesley, 2004 [7] Foote, B. and Yoder, J., Big Ball of \nMud, Fourth Conference on Pattern Language Programs, 1997. [8] Fowler, Martin, Language Workbenches: \nThe Killer-App for Domain Specific Languages? , 2005. www.martinfowler.com [9] Greenfield, Jack, Keith \nShort, Steve Cook, Stuart Kent, Software Factories: Assembling Applications with Patterns, Models, Frameworks, \nand Tools [10] Iverson, K. A Programming Language, 1962. See also Programming Notation in Systems Design. \nIBM Systems Journal 2(2): 117-128 (1963) [11] James, William, The Principles of Psychology, Henry Holt \n1890 [12] Khwaja, Amir, Joseph Urban, Syntax-directed editing environments: issues and features, Proceedings \nof the 1993 ACM/SIGAPP symposium on Applied Computing: states of the art and practice. [13] Kiczales \nG, et al, Aspect-Oriented Programming, Proceedings of European Conference on Object-Oriented Programming, \n1997. [14] Lampson, B.W. Personal Distributed Computing: The ALTO and Ethernet Software, ACM conference \non the History of Personal Workstations, Palo Alto, 1986. [15] Mernik, M, Heering, J, Sloane, A, When \nand How to Develop Domain Specific Languages, ACM Computing Surveys, vol 37, no 4, December 2005 [16] \nMusser, David R., Gillmer J. Derge, and Atul Saini STL Tutorial and Reference Guide, Second Edition: \nC++ Programming with the Standard Template Library, Addison-Wesley, 2001 [17] Naur, Peter, A Synapse-State \nTheory of Mental Life, 2004, www.naur.com/synapse-state.pdf [18] Simonyi, Charles. Intentional Programming \n An Ecology for Abstraction. 1997, Invited Talk USENIX Conference on Domain-Specific Languages [19] Simonyi, \nCharles. Intentional Program Tree Represented By High-Level Computational Constructs, US Patent Nos. \n5790863, 5911072, 6070007, 6078746, 6097888 and 6189143 [20] Wilson, Gregory V., Extensible Programming \nfor the 21st Century, ACM Queue, Vol 2, No 9, Dec/Jan 2004/2005. [21] YACC. http://dinosaur.compilertools.net \n \n\t\t\t", "proc_id": "1167473", "abstract": "Wysiwyg editors simplified document creation by separating the document contents from the looks and by automating the re-application of the looks to changing contents. In the same way Intentional Software simplifies software creation by separating the software contents in terms of their various domains from the implementation of the software and by enabling automatic re-generation of the software as the contents change. This way, domain experts can work in parallel with programmers in their respective areas of expertise; and the repeated intermingling can be automated. Intentional Software is supported by a Domain Workbench tool where multiple domains can be defined, created, edited, transformed and integrated during software creation. Key features include a uniform representation of multiple interrelated domains, the ability to project the domains in multiple editable notations, and simple access for a program generator.", "authors": [{"name": "Charles Simonyi", "author_profile_id": "81100055491", "affiliation": "Intentional Software Corporation, Bellevue, WA", "person_id": "PP18011284", "email_address": "", "orcid_id": ""}, {"name": "Magnus Christerson", "author_profile_id": "81319489838", "affiliation": "Intentional Software Corporation, Bellevue, WA", "person_id": "PP18004085", "email_address": "", "orcid_id": ""}, {"name": "Shane Clifford", "author_profile_id": "81319489830", "affiliation": "Intentional Software Corporation, Bellevue, WA", "person_id": "P813679", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167511", "year": "2006", "article_id": "1167511", "conference": "OOPSLA", "title": "Intentional software", "url": "http://dl.acm.org/citation.cfm?id=1167511"}