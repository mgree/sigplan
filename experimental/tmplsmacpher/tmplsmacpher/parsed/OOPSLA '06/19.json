{"article_publication_date": "10-16-2006", "fulltext": "\n Generic Ownership for Generic Java Alex Potanin James Noble Dave Clarke Robert Biddle Victoria University \nof Wellington Centrum voor Wiskunde en Informatica Carleton University New Zealand The Netherlands Canada \n{alex | kjx}@mcs.vuw.ac.nz dave@cwi.nl robert biddle@carleton.ca Abstract Ownership types enforce encapsulation \nin object-oriented pro\u00adgrams by ensuring that objects cannot be leaked beyond object(s) that own them. \nExisting ownership programming languages either do not support parametric polymorphism (type genericity) \nor at\u00adtempt to add it on top of ownership restrictions. Generic Ownership provides per-object ownership \non top of a sound generic impera\u00adtive language. The resulting system not only provides ownership guarantees \ncomparable to established systems, but also requires few additional language mechanisms due to full reuse \nof paramet\u00adric polymorphism. We formalise the core of Generic Ownership, highlighting that only restriction \nof this calls and owner subtype preservation are required to achieve deep ownership. Finally we describe \nhow Ownership Generic Java (OGJ) was implemented as a minimal extension to Generic Java in the hope of \nbringing ownership types into mainstream programming. Categories and Subject Descriptors D.3.3 [Programming \nLan\u00adguages]: Language Constructs and Features Classes and Ob\u00adjects, Polymorphism; D.1.5 [Programming \nTechniques]: Object-Oriented Programming General Terms Design, Languages, Theory Keywords Java, generics, \nownership, type systems 1. Introduction Object ownership (instance encapsulation) ensures that objects \ncan\u00adnot be leaked beyond an object or collection of objects which own them. There are two main approaches \nto object ownership in the lit\u00aderature: enforcing coding conventions within an existing program\u00adming \nlanguage, or signi.cantly modifying a language to allow own\u00adership support. The .rst approach is taken \nby Islands [25] and var\u00adious kinds of Con.ned Types [19, 54]. Programs must be written to follow a set \nof speci.c conventions, conformance to which can be checked to see if they provide ownership guarantees \n[24]. The soundness of this .rst approach has been proven only recently [55]. Support for generics is \nadded on top of such collections of restric\u00adtions that enforce encapsulation [55]. The second approach \nis taken by languages such as Joe, Universes, AliasJava, and SafeConcur\u00adrentJava [3, 10, 17, 39]. Ownership \nparameterisation is added to the syntax and expressed explicitly within the type systems of these Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 06 October \n22 26, 2006, Portland, Oregon, USA. Copyright c . 2006 ACM 1-59593-348-4/06/0010. . . $5.00 languages. \nAll of these different type systems employ ownership parameterisation, but none has support for type \ngenericity. Why would we want to combine ownership and generic types? Consider for example a box as a \nkind of object. In any object\u00adoriented language we are allowed to say: this is a box (mean\u00ading a box \nof any things). In a language with generics, we are al\u00adlowed to say: this is a box of books , denoting \na box containing books, but not birds. In a language with ownership parameterisa\u00adtion, we are allowed \nto say: this is my box or these are library books . Combining ownership and generics naturally allows \nus to say: this is my box of library books , not a box of birds, and not my personal books. This illustrates \nthe main idea of this paper: combin\u00ading ownership and genericity. Ownership works exceptionally well \nwith genericity, both in theory, practice, and implementation. In this paper, we present Generic Ownership, \na language design that uses a single parameter space to carry both generic type and ownership type information. \nWe show that ownership systems can be subsumed completely by parametric polymorphic type systems, and \nformalise our approach within the context of an imperative extension to Featherweight Generic Java (FGJ) \n[27]. Contributions. The contributions of this paper are as follows: Generic Ownership a practical \nway of integrating ownership and genericity by using a single parameter space to carry both type and \nownership information;  Featherweight Generic Ownership (FGO) a formal model with soundness proofs \ndemonstrating that the following is suf.\u00adcient to provide ownership and con.nement support: (1) disal\u00adlowing \nnon-this calls on owned objects, (2) preserving own\u00aders as part of the type, and (3) preserving owner \nnesting, as long as the underlying sound type system supports genericity;  Ownership Generic Java (OGJ) \n a publicly available exten\u00adsion to Java 5 that supports Generic Ownership which is the .rst language \nimplementation that supports ownership, con\u00ad.nement, and generics at the same time, while preserving \nfull syntactic compatibility with Java 5.  These contributions represent a signi.cant advance over \nour previous work on Featherweight Generic Con.nement [45, 47] which focused on con.nement within static \ncontexts (e.g. Java packages) and was formalised without heap objects, pointers, or assignment. In this \npaper we present an imperative, object-oriented formalism including pointers and assignment that supports \nfull, deep per-object ownership within dynamic contexts, and describe a language design and prototype \nimplementation. We build upon a preliminary workshop paper [46] that provided only shallow ownership \nand did not discuss a language design. The primary goal of this work is not to develop a higher level \nab\u00adstraction unifying ownership and genericity. Generic Ownership s contribution is a language design, \nthat, by building upon an existing generic type system, can smoothly extend Java-like languages to public \nclass Map { private Vector nodes; void put(Comparable key, Object value) { nodes.add(new Node(key, \nvalue)); } Object get(Comparable k) { Iterator i = nodes.iterator(); while (i.hasNext()) { Node mn \n= (Node) i.next(); if (((Comparable) mn.key).equals(k)) return mn.value; } return null; } } class Node \n{ public Object key; public Object value; Node(Object key, Object value) { this.key = key; this.value \n= value; } } Figure 1. A Java implementation of a Map class provide ownership types. Our goal is also \ndifferent to other recent ownership types work [2, 7, 31, 33, 36, 38, 42] which investigates new kinds \nof topologies or restrictions or applications for owner\u00adship types. Rather, we hope that Generic Ownership \nwill provide the means by which an ownership system can be incorporated into existing generically typed \nprogramming languages. Outline. In Section 2 we present a background overview of own\u00adership and genericity. \nSection 3 presents the fundamentals behind Generic Ownership and introduces our language design OGJ. \nSec\u00adtion 4 highlights the important aspects of the type system (available in full as a technical report \n[48]). Section 5 presents the dynamics of FGO, as well as the type soundness of the type system as a \nwhole. Section 6 discusses the ownership guarantees provided by FGO. Fi\u00adnally, Section 7 discusses related \nwork and Section 8 outlines future work and concludes the paper.  2. Background Genericity and Ownership \nare two language mechanisms that, in different ways, allow programmers to make the intentions behind \ntheir code more explicit. This can provide programmers with more support, typically by detecting errors \nstatically, at compile time, that could otherwise only be detected (or worse, remain undetected) once \nthe program is run. In this section, we will illustrate the advantages and impacts of genericity and \nownership with reference to a simple example, shown in Figure 1. This example is a small part of an implementa\u00adtion \nof a simple Map class that uses neither genericity nor owner\u00adship. The map is implemented using a Vector \ncontaining a num\u00adber of Nodes, each of which stores a key-value pair. The main Map class provides methods \nto insert a new key-value pair into the map and to return the .rst value associated with a particular \nkey. 2.1 Genericity Genericity allows us to use type parameters to give a better descrip\u00adtion of the \ntype of the variable we are dealing with. This allows more sensible collections (e.g. of Nodes rather \nthan anything), bet\u00adter compile-time error detection, and more readable and reusable code. The code in \nFigure 1 exhibits a number of well-known weak\u00adnesses [14, 30]. One prominent weakness is that it relies \nupon sub\u00adtyping to store objects of various types within the Map itself and within the Vector implementing \nthe Map. This is an old problem, and the solutions are equally old, dating back to the mid-1970s [37]: \nthe class de.nitions must be made public class Map<Key extends Comparable, Value> { private Vector<Node<Key, \nValue>> nodes; void put(Key key, Value value) { nodes.add(new Node<Key, Value>(key, value)); } Value \nget(Key k) { Iterator<Node<Key, Value>> i = nodes.iterator(); while (i.hasNext()) { Node<Key, Value> \nmn = i.next(); if (mn.key.equals(k)) return mn.value; } return null;  } } class Node<Key extends Comparable, \nValue> { public Key key; public Value value; Node(Key key, Value value) { this.key = key; this.value \n= value; } } Figure 2. A Generic implementation of a Map class generic (or parametrically polymorphic) \nso that particular instances of the classes can be created for particular argument types. Java now supports \ngeneric types [14, 50] and Figure 2 presents a version of the Map class written using genericity, in \nJava 5 syntax. Comparing Figures 1 and 2 illustrates both the advantages and disadvantages of generic \ntypes. Regarding the advantages, the types of objects stored in the Vector or Map can now be preserved \nwhen they are returned, so there is no need for a typecast when objects are removed from the Vector. \nMethod declarations can also carry more information, using generic type parameters like Key or Value \ninstead of Object or Comparable . As a result, only objects of the right types can be stored into Maps \nand Vectors; attempts to store the wrong types of objects will be detected at compile time. The main \ndisadvantage is that Figure 2 is more complex than Figure 1: in particular, the class de.nitions in the \ngeneric version declare formal generic type parameters, and then class instantia\u00adtions must provide actual \nvalues for those parameters, resulting in types like Vector<Node <Key, Value>> nodes rather than Vector \nnodes . 2.2 Ownership An object is aliased whenever there is more than one pointer re\u00adferring to that \nobject [26]. Aliasing can cause a range of dif.cult problems within object-oriented programs, because \none referring object can change the state of the aliased object, implicitly affect\u00ading all the other \nreferring objects [40, 54]. To return to our example, considering the basic Map implemen\u00adtation from \nFigure 1, the nodes .eld containing the Vector in the Map is declared as private, and so Java will ensure \nthat the .eld can only be accessed from within the Map class. This is done be\u00adcause the Vector is an \ninternal part of the implementation of the Map class and should not be accessed outside. Inserting or \nremov\u00ading elements from the Vector, or perhaps acquiring but not re\u00adleasing its internal lock would break \nthe invariants of the Map class and cause runtime errors. Unfortunately, the name based protection used \nin Java and most other programming languages is not strong enough to keep the Vector truly private to \nthe Map. An erroneous programmer could insert a public method that exposed the Vector,e.g. public Vector \nexposeVector() {return nodes;}  with no objection from the compiler. Any resulting errors will be subtle, \npossibly appearing at runtime long after the execution of public class Map<mOwner, kOwner, vOwner> { \nprivate Vector<this, this> nodes; void put(Comparable<kOwner> key, Object<vOwner> value) { nodes.add(new \nNode<this, kOwner, vOwner>(key, value)); } Object<vOwner> get(Comparable<kOwner> key) { Iterator<this, \nthis> i = nodes.iterator(); while (i.hasNext()) { Node<this, kOwner, vOwner> mn = (Node<this, kOwner, \nvOwner>) i.next(); if (mn.key.equals(key)) return mn.value; } return null; } } class Node<mapNodeOwner, \nkOwner, vOwner> public Comparable<kOwner> key; public Object<vOwner> value; Node(Comparable<kOwner> \nkey, Object<vOwner> value) { this.key = key; this.value = value; } } Figure 3. An Ownership Types implementation \nof a Map class the exposeVector method, and thus be dif.cult to identify and resolve. These kinds of \nerrors have been identi.ed as occurring in many Java libraries [49] and have caused signi.cant problems \nfor language security mechanisms [54]. Ownership types [3, 10, 17, 18, 39] protect against aliasing errors \nby allowing programmers to restrict access to objects at runtime, rather than just the names or variables \nused to store them. The key idea is that representation objects (like the Map s Vector) are nested and \nencapsulated inside the objects to which they belong (the Vector belongs to the Map;the Map owns the \nVector). Clarke [16] formulated an ownership invariant: that there can be no incoming references that \nbypass owners. This means that one object cannot refer to a second object directly, unless the .rst object \nis itself inside the second object s owner. Because this nesting (and thus the protection) is transitive, \nwe call this deep ownership [20]: if an Array is part of a Vector s representation, the array should \nbe owned by the vector and is thus nested inside both the vector and the map. Enforcing encapsulation \nvia deep ownership has many practical and theoretical applications [2, 6, 7, 33]. Figure 3 gives an example \nof the Map class using ownership types. The syntax used is proposed by Boyapati [7, Figure 2.7]. Comparing \nFigure 3 with Figures 1 and 2 illustrates both the strengths and weaknesses of ownership types. The most \nobvious difference is the presence of a range of ownership type parameter de.nitions such as <mOwner, \nkOwner, vOwner> on the class declarations. This declares a parameter, mOwner,torepre\u00adsent the ownership \nof the instances of the classes being declared, with further ownership parameters kOwner and vOwner de\u00adscribing \nthe ownership of the keys and values that will be stored in the map. These parameters are then instantiated \nas the types are used, as when a Node is created within the put method of Map. Note also that ownership \nparameters can be instantiated via the keyword this , which ensures that the current object (the ob\u00adject \nusually denoted this in Java) owns the object being de\u00adclared [18]. The Vector object is marked in this \nway as being owned by the Map, for example, so any attempt to access or pass the Vector object outside \nthe Map object will be detected and prevented at compile time. Code such as the exposeVector() method \nwill be unable to cause any damage by breaching encapsu\u00adlation. The ownership parameters carry ownership \ninformation around the program, so that the ownership status of the keys and values public class Map<mOwner, \nkOwner, vOwner> [Key extends Comparable<kOwner>, Value extends Object<vOwner>] { private Vector<this, \nkOwner, vOwner> [Node<this, kOwner, vOwner>[Key, Value]] nodes; void put(Key key, Value value) { nodes.add(new \nNode<this, kOwner, vOwner> [Key, Value](key, value)); } Value get(Key key) { Iterator<this>[Node<this, \nkOwner, vOwner> [Key, Value]] i = nodes.iterator(); while(i.hasNext()) { Node<this, kOwner, vOwner>[Key, \nValue] mn = i.next(); if (mn.key.equals(k)) { return mn.value; }} return null;  } } class Node<mapNodeOwner, \nkOwner, vOwner> [Key extends Comparable<kOwner>, Value extends Object<vOwner>] { public Key key; public \nValue value; Node(Key key, Value value) {  this.key = key; this.value = value; } } Figure 4. A combined \ngeneric and ownership types Map class can be maintained outside the Map. For example, the ownership \nof the keys and values may be speci.ed by each instantiation of the Map class, but by using the kOwner \nand vOwner ownership parameters, the .elds that will store keys and values inside the subsidiary Node \nobjects will have the correct ownership for these .elds. The main disadvantage of ownership types is \nquite similar to that of generic types: additional syntactic complexity as a result of ownership parameters. \nIn fact, this code also has all the type\u00adrelated problems of the straight Java code: the problems that \nare addressed by genericity. This code relies on subtyping to store different types of objects, and so \nrequires type casts when objects are removed from the Vector (or subsequently from the Map). Although \nthe code may look generic, all the declared types are simple Java types, such as Object or Comparable, \nwith the problems that entail. While the Vector stored in the nodes .eld can no longer be exposed outside \nof the Map instance that owns it, malicious or buggy programming within that class can break this code \nby directly inserting incorrect types into the Vector. 2.3 Combining Genericity and Ownership The state \nof the art, then, is that there are two separate but similar techniques that constrain which objects \nmay be accessed by which types, .elds, or expressions. Genericity constrains these accesses by compile-time \ntypes, while ownership constrains the accesses by compile-time object structures. These two mechanisms \nappear to be orthogonal, raising the question: could they both be included within a single programming \nlanguage? Figure 4 repeats the Map example using a hypothetical language separately supporting both genericity \nwith parameters marked with [ and ] and ownership with parameters marked with < and >. The syntax in \nthis Figure is based on Boyapati [7, page 29] and resembles the original Flexible Alias Protection proposal \n[40]. Again we can compare Figure 4 with the preceding Figures 1, 2, and 3. This code now has both type \nand ownership parameters, public class Map<Key extends Comparable<KOwner>, Value extends Object<VOwner>, \nOwner extends World> { private Vector<Node<Key, Value, This>, This> nodes; public void put(Key key, \nValue value) { nodes.add((new Node<Key, Value, This>()). init(key, value)); } public Value get(Key key) \n{ Iterator<Node<Key, Value, This>, This> i = nodes.iterator(); while (i.hasNext()) { Node<Key, Value, \nThis> mn = i.next(); if (mn.key.equals(key)) return mn.value; } return null; } } class Node<Key extends \nComparable<KOwner>, Value extends Object<VOwner>, Owner extends World> { public Key key; public Value \nvalue; public void init(Key key, Value value) { this.key = key; this.value = value; } } Figure 5. Generic \nOwnership implementation of a Map class each taken from their respective languages. As with the generic \nsystem, types can be instantiated for keys and values, removing the reliance on subtyping and the associated \nfragile type casts. As with the ownership system, objects can be tagged as owned by this, ownership can \nbe recorded via owner parameters, and thus any exposing method would be detected and prevented. Unfortunately, \nthe syntax required to implement both ownership and genericity separately means that this code is annotated \nin a signi.cantly more complex way than any of the other examples with both classes requiring .ve ownership \nand type parameters, some of which are not directly utilised by the code. The code is, arguably, so complex \nthat it would be unusable in practice.  3. Generic Ownership Generic Ownership takes a novel approach \nof providing ownership and genericity in a programming language. As opposed to the hy\u00adpothetical example \nof Figure 4 or the previous work on combining con.nement and genericity [55] Generic Ownership starts \nwith a sound type polymorphic language and adds ownership as an ex\u00adtension to the existing generic type \nsystem. Providing genericity before ownership, surprisingly, results in both simpler formalism and a \nsimpler language that provides the bene.ts of both type and ownership parameterisation: catching all \nthe errors and avoiding all the bugs that the generic and ownership languages do individ\u00adually. Generic \nOwnership treats ownership and genericity as one single aspect of language design, and so code using \nGeneric Own\u00adership is no more syntactically complex than code that is either type-parametric or ownership-parametric. \nThe key technical con\u00adtribution of Generic Ownership is that it treats ownership as an additional kind \nof generic type information. This means that the existing generic type systems can be extended to carry \nownership information with only minimal changes [47]. Figure 5 revisits our Map example for the last \ntime. This time, it is written in our new language design, Ownership Generic Java (OGJ). Note that the \ncode in Figure 5 is type-generic: de.nitions of .elds in Node and methods everywhere use generic types \nsuch as Key and Value rather than plain class types such as Object or Comparable. Note also that the \ncode is ownership-generic. Every class has an extra type parameter that represents the object s owner: \nwe place it last, typically name it Owner and call it the owner parameter. When creating an object, we \ncan mark it as owned by the current object this by instantiating the new object s owner parameter with \nthe owner constant This. All OGJ classes descend from a new parameterised root Object<O> that declares \nan owner parameter, and all subclasses must invariantly preserve their owner parameter. Owners descend \nfrom a separate root, World,which also acts as a second owner constant, meaning that access to an object \nis unrestricted. Consider an example exposing a nodes vector private to the Map object considered earlier \nin Section 2: public Vector exposeVector() {return nodes;}  This code is not valid in OGJ as is, since \nevery type has an owner parameter and casting to raw types [28] is prohibited. The type of the .eld nodes \nin Figure 5 has an owner parameter This.If we try to give a return type of the exposeVector method an \nowner parameter This, e.g.: public Vector<Node<Key, Value, This>, This> exposeVector() { return nodes; \n}  then this code will be valid OGJ, but the method can only be called if the result can be assigned \nto something that is a supertype of Vector<..., This>. Since OGJ preserves owners over sub\u00adtyping, any \nvalid supertype of the return type will have to have an owner This, which will only typecheck if it is \ncalled from the same instance of Map. This is enforced by the this function described in Section 4.3. \nIn other words, this exposeVector method cannot expose the vector. If we attempt to declare this method \nwith a return type having any other owner parameter, then the return type and the return value s (nodes) \ntype will not be assignment compatible in OGJ, as their owner parameters will be different. 3.1 Expressiveness \nof Generic Ownership Comparing Figure 5 with Figures 1 4 shows that it is slightly more complex than \nthe individual type genericity or ownership examples, but rather simpler than the straightforward combination \nin Figure 4. In particular, Figure 5 s declaration of the Map class has only three parameters (the same \nas in Figures 2 and 3). Furthermore, the type of .eld nodes in Figure 2 is more readable: Vector<Node<Key, \nValue, This>, This> nodes;  rather than: Vector<this, kOwner, vOwner> [Nodes<this, kOwner, vOwner>[Key, \nValue]] nodes;  presented in Figure 4. Because every OGJ class has a distinguished owner parame\u00adter, \nthe bounds of formal generic parameters (e.g. Key extends Comparable<KOwner>) must be declared with a \nplaceholder owner parameter (KOwner in this case). Apart from this declara\u00adtion, programmers are not \nrequired to supply placeholder parame\u00adters: rather they are bound implicitly, with very similar semantics \nto Java wildcards [35, 53]. Within the scope of the type parameter declaration (a generic type or method) \nthe bound type variable (e.g. Key) ranges simultaneously over type and owner. Owners can also be passed \nexplicitly (generally as arguments to formal parameters bound by World) indeed, the distinguished owner \nparameter is just a special case of this. This implicit binding of owner parameters and, more impor\u00adtantly, \nthe combination of ownership into types reduces the num\u00adber of formal arguments required by generic \nownership. Program\u00admers do not need to write code such as: public class Map<KO extends World, VO extends \nWorld, Key extends Comparable<KO>, Value extends Object<VO>, Owner extends World> { ... } because \nthe owners are bound implicitly. The implicit binding is generally suf.cient: we .nd that ownership and \ntype parameters are hardly ever used independently. For example, if a programmer wished to produce a \nspecialised version of a map class (MyMap) that was not type generic say it could store only names and \naddresses but which needed to be ownership generic, additional type parameters (NameO, AdrO) bound by \nWorld can be declared explicitly to carry the ownership for names and addresses. class MyMap<NameO extends \nWorld, AdrO extends World, Owner extends World> { void put(Name<NameO> n, Address<AdrO> a); Address \nget(Name<NameO> n); List<Name<NameO>, World> getAllPeopleOnThisStreet(String s); } On the other hand, \ngiven that the MyMap class requires three parameters anyway, standard OGJ style is to declare two bound \ngeneric parameters, and always instantiate those parameters with the same types as their bounds (although, \nfor ownership polymor\u00adphism, with different owners): class MyMap<MyName extends Name<NameO>, MyAddress \nextends Address<AdrO>, Owner extends World> { void put(MyName n, MyAddress a); Address get(MyName \nn); List<MyName, World> getAllPeopleOnThisStreet(String s); } Finally, to live up to the full potential \nof generics in Java 5, Generic Ownership allows owner parameters to be mixed with generic method parameters. \nOwners on methods allow more gran\u00adular control of what access each method has to the other objects, and \nthey can be utilised usefully for more granular alias control with little overhead for the programmer. \nFor example, the follow\u00ading method can create a new Name object even though the class to which addNewName \nmethod belongs might not have access to owner NameO: <NameO extends World> addNewName(String name) { \nthis.map.put(new Name<NameO>(name), null); } Owner method parameters come up in practice when implementing \nOGJ s static methods: since static methods do not belong to any instance of a class, they cannot have \ngeneric owner parameters coming from their class declaration. Without owner parameters for methods, creation \nof new classes with particular owners and implementation of static methods would not be easy. To summarise \nthis subsection: these examples show how OGJ can provide independent ownership and type genericity with \nsep\u00adarate parameters and ownership genericity without type gener\u00adicity with naked owner parameters, \nor by using parameters instantiated at their type bounds. Programmers can provide type parametricity \nwithout ownership parametricity either by supplying ownership constants (e.g. World) at point of use, \nor by using man\u00adifest ownership (described below) to .x an owner for all instances of a class.  3.2 \nOGJ and Con.nement Building on our previous work, OGJ supports both ownership and static con.nement \nallowing an object to be owned by a static package, rather than by another dynamically allocated object \n[47]. This is expressed by using an owner constant named after the current package so a package called \nm would have a matching owner constant M, that is only accessible within its package: as a convention, \nwe will pre.x class names by the name of their de.ning packages where necessary. This means that mMain \nbelow refers to class Main inside package m. Whereas objects owned by this can only be accessed from \nwithin their owner, objects owned by a package can be accessed by any object within that package. The \nfollowing declaration of a class called Main shows how an OGJ class is declared with its owner parameter \nOwner bound to its superclass s owner parameter (Object in this case), and then how a stack class can \nbe instantiated with different ownership. class mMain<Owner extends World> extends Object<Owner>{ OwnedStack<Object<World>,World> \npublic() {  return new OwnedStack<Object<World>,World>; } OwnedStack<mMain<World>,M> confined() { return \nnew OwnedStack<mMain<World>,M>; } OwnedStack<mMain<M>,This> private() { return new OwnedStack<mMain<M>,This>; \n} OwnedStack<mMain<M>,Owner> shared() { return new OwnedStack<mMain<M>,Owner>; } } Within the Main class, \nfour methods return different kinds of OwnedStack objects: one of these is public, another is con.ned \nto package m, the next one is owned by a particular instance of class Main, and the last one is owned \nby the owner of mMain class and can be shared with others owned by the same owner. The public stack stores \nObject<World> instances that are accessible from anywhere (because Object s owner parameter is instantiated \nby World). The second stack stores mMain instances that are also globally accessible, however the stack \nitself has owner M, meaning that it is only accessible within package m. The private stack stores instances \nof mMain accessible inside package m only, while the actual stack is only accessible by objects owned \nby a particular instance of mMain that created it. The shared stack stores the same sort of instances \nof mMain as the private stack, except that it is accessible by any other instances who have the same \nowner as current instance of mMain. In each case, the stack s second parameter describes its owner. Again, \nthese stacks illustrate how OGJ provides both type polymorphism (the stacks hold different item types) \nand ownership polymorphism (the stacks belong in different protection contexts). 3.3 Manifest Ownership \nOGJ supports a form of manifest ownership [16] to allow classes without explicit owner type parameters. \nA manifest class does not have an explicit owner parameter, rather the class s owner is .xed, so all \nthe objects of that class have the same owner. This is just the same way that in Generic Java, for example, \na non-generic Integer List class can be de.ned as extending List<Integer>, binding and .xing the list \ns type parameter. To demonstrate manifest ownership, consider the following alterna\u00adtive formulation \nof a public stack class: class PublicStack extends OwnedStack<World>{ }  In this example, the owner \nof class PublicStack is World,and thus all of its instances are owned by World. Because the owner is \nbound in the class declaration, uses of PublicStack require no owner type parameter. Manifest ownership \nallows us to .t existing Java classes into our class hierarchy by simply making Java s root class Object \ninto a manifest class1: class Object extends Object<World> { ... } With this de.nition Object and every \nclass inheriting from it has a default owner parameter World (thus making them publicly accessible). \nWe can write the following familiar declaration of a public Stack object, which is indistinguishable \nfrom that of Java: class Stack extends Object { ... } The important difference is that with manifest \nownership, every Stack instance has an owner originating from OGJ s root class.  3.4 OGJ Language Design \nWe conclude this section by bringing together the details of our language design. Ownership Generic Java \nis designed as a mini\u00admal extension to Java 5 [50]. The key difference is that OGJ allows classes to \nbe declared with a distinguished (last) ownership type pa\u00adrameter (conventionally Owner) extending World. \nClasses with\u00adout an ownership parameter ( plain Java classes descending from java.lang.Object) are treated \nas if they used manifest own\u00adership. OGJ supplies a number of ownership type constants: World, Package,and \nThis. When bound to a class s ownership type pa\u00adrameter, these constants mark the instances as public, \nas con.ned within their package, or as owned by the current this object, re\u00adspectively. To ensure deep \nownership, OGJ restricts the types which can be formed so that the distinguished ownership type parameter \nis always inside or equal to (greater or equally encapsulated than) any other parameters ownership type. \nIn practice, this means that when an actual owner parameter is World, all the other type pa\u00adrameters \nmust have an owner World; if the actual owner parameter is a package or an ownership type variable, then \nthat package (or variable) and World are permissible; if the actual owner parame\u00adter is an enclosing \nclass s Owner then World, Owner, and other (placeholder) formal ownership type parameters of that class \nare permissible; and if an ownership type parameter is bound to This, then the other parameters may be \nbound to anything. This is suf.cient to provide package con.nement. To en\u00adforce per-object ownership \nOGJ ensures that types with an ac\u00adtual owner parameter of This can only be accessed via Java s this keyword, \neither explicitly or implicitly. Assignments such as this.pvtField = other.pvtField between two Node \ninstances are illegal if this.pvtField is owned by this; sim\u00adilarly method or .eld accesses involving \na This owner are only permitted on the current this object. Finally, to ensure that ownership information \ncannot be lost, OGJ requires type casts to preserve ownership. This follows Java s existing rules for \nsubtyping parameterised types, except that it pre\u00advents casts to raw types [14, 28] when such casts would \ndelete an ownership parameter. OGJ must also restrict wildcards for owner\u00adship types to type variable \nbounds, and prevent re.ection when it could breach ownership. These are the only restrictions imposed \nby Generic Ownership on top of the vanilla type generic language. This achieves owner\u00adship and con.nement \nguarantees comparable to the alternative sys\u00adtems [3, 7, 55] with a large burden carried by the underlying \nsound type polymorphic system. Hence, these restrictions highlight the concepts important to the mechanism \nof ownership, excluding the rest of the rules required by the alternative type systems as technical details. \n1 To avoid class name con.ict with Object, OGJ can choose a different name for its root, such as OObject<World>, \nmeaning owned object. Our prototype implementation [44] includes a compiler that can bootstrap itself \n(albeit with substantial use of standard (manifest) Java classes) and compile a growing test suite. There \nare a number of implementation-speci.c issues omitted in this paper, such as dis\u00adtinguishing This between \nan inner class and the outer class, deal\u00ading with generic arrays and static .elds and methods. All of \nthese issues are addressed in the thesis referenced in our accompanying technical report [48]. Our future \nplans include the development of an ownership-aware version of the Java Collections library to sup\u00adport \nlarger OGJ programs without resorting to manifest ownership. To demonstrate the difference between OGJ \nand the other own\u00adership languages, consider the examples in the Figures 6 and 7. Both of these simple \nexamples were compiled with the latest ver\u00adsion of AliasJava2 and OGJ3. Both examples have two private \n.elds protected from erroneous exposure by making them owned by the instance of Rectangle that created \nthem. The construc\u00adtor is forced to make a private copy of the supplied Point ref\u00aderences. The method \ndoIt fails to expose the private .elds via exposeUpperLeft() unless the method receiver is explicitly \nthis. It is interesting to observe that a lot of work to do with alias\u00ading protection is performed by \nJava 5 on behalf of OGJ, as the com\u00adments in the .gure point out. These have to do with type parameters \n(which in OGJ can also include owner classes) checked by Java s type system. AliasJava adds support for \nownership by introducing extra an\u00adnotations such as owned added on top of Java syntax, while OGJ s syntax \nis completely Java compatible. OGJ also supports con.ne\u00adment, in addition to ownership, while still keeping \nJava syntax. This means that it inherits the problems of Generic Java, such as lack of proper generic \narray support. Most importantly, OGJ is the .rst working language implementation that supports ownership, \ncon\u00ad.nement, and generic types at the same time.  4. Featherweight Generic Ownership In this section, \nwe present Featherweight Generic Ownership (FGO) and its type system. We started the development of FGO \nby taking Featherweight Generic Java (FGJ) [27] and adding im\u00adperative features [43] to be able to take \ninto account assignments and .eld updates in the presence of per-object ownership. As de\u00adscribed above, \nwe then added a separate hierarchy of owner classes rooted in World that are used to carry ownership \ninformation for each FGO type. In fact, if we only aim to support static con.ne\u00adment, then we need add \nlittle other than owner classes to FGJ as we demonstrate elsewhere [47]. The key formal contribution \nof this work is that, by adding the imperative features (assignment, object store, etc) we demonstrate \nobject ownership in dynamic contexts. To support dynamic deep ownership, in addition to adding own\u00aders \nto types, we prevent non-this access to types owned by partic\u00adular instances, ensure owner invariance \nover subtyping, and provide for owner parameter nesting. This lets us prove the deep ownership property \nknown as owners as dominators (objects are nested within their owners). The remainder of this section \nhighlights the impor\u00adtant aspects of the FGO type system. 4.1 Syntax, Functions, and Judgements Figure \n8 shows FGO s syntax. The syntax is derived from FGJ by adding expressions for locations (references), \nlet (local variables), assignment (.eld update), and null. The .gure contains de.nitions for syntactical \nterms corresponding to types (T), type variables (X), nonvariable types (N), class declarations (L), \nmethod declarations (M), and expressions (e). The environment . stores mappings from 2 http://www.archjava.org/ \n3 http://www.mcs.vuw.ac.nz/ alex/ogj/ import ogj.ownership.*; class Point<Owner extends World> { Integer \nx; Integer y; Point(Integer x, Integer y) { this.x = x; this.y = y; } } class Rectangle<Owner extends \nWorld> { private Point<This> upperLeft; private Point<This> lowerRight; public Rectangle(Point<Owner> \nul, Point<Owner> lr) { // Copy rather than assignment is enforced by Java // (and hence OGJ) since type \nparameter Owner != This upperLeft = new Point<This>(ul.x, ul.y); lowerRight = new Point<This>(lr.x, lr.y); \n } public void doIt() { Point<This> p; p = this.upperLeft; p = this.exposeUpperLeft(); Rectangle<Owner> \nro = this; p = ro.upperLeft; // WRONG in OGJ, OK in Java p = ro.exposeUpperLeft(); // WRONG in OGJ, OK \nin Java } private Point<This> exposeUpperLeft() { return upperLeft; } public Point<Owner> getUpperLeft() \n{ // return upperLeft; // WRONG in both Java and OGJ return new Point<Owner>(upperLeft.x, upperLeft.y); \n } } Figure 6. Rectangle Class in OGJ variables to their types, mappings from type variables to nonvari\u00adable \ntypes, and the types of the locations. There is no explicit con\u00adstructor declaration: .elds are initialised \nto null. This is important because the ownership types mean that objects owned by This cannot be constructed \noutside the object to which they belong. FGO s additions to FGJ syntax include the locations (l), the \nstore (S) and adding location types to the environment (.). The expression l> e represents the expression \ne resulting from reducing a method call with the receiver object allocated at the location l in the store \nS this allows us to type the occurrences of this expression. We use CT (class table) to denote a mapping \nfrom class names C to class declarations L,and P (permission) to denote a class or a location. Permissions \nare used to implement object ownership using this function described in Section 4.3. FGO also adopts \nthe syntactical idiosyncrasies of FGJ, such as Tx denoting a list of pairs: T1 x1 ,...,Tn xn , rather \nthan two lists of types and variables. FGO ownership types are just types, but we assume that owners \nare syntactically distinguishable: O ::= XO |NO where O ranges over all owners, XO ranges over owner \nvariables, and NO ranges over nonvariable owners such as World and This, as well as the owner classes \ncorresponding to packages. We use capitals (P) for the owner class corresponding to a lower case package \nname (p). We use subscript (Thisl) for the owner class corresponding to the owner of an object at location \nl.Pure FGO types and classes are written to include an owner class as their last class Point { int x; \nint y; Point(int x, int y) { this.x = x; this.y = y; } } class Rectangle { private owned Point upperLeft; \nprivate owned Point lowerRight; public Rectangle(Point ul, Point lr) { // ArchJava forces to copy the \nvalues, since the // default annotation (lent) doesn t match // annotation owned upperLeft = new Point(ul.x, \nul.y); lowerRight = new Point(lr.x, lr.y); } public void doIt() { owned Point p; p = this.upperLeft; \np = this.exposeUpperLeft(); Rectangle r = this; p = r.upperLeft; // WRONG p = r.exposeUpperLeft(); // \nWRONG } private owned Point exposeUpperLeft() { return upperLeft; } // The copy is enforced using \nunique annotation. public unique Point getUpperLeft() { // return upperLeft; // WRONG return new Point(upperLeft.x, \nupperLeft.y); // RIGHT  } } Figure 7. Rectangle Class in AliasJava T ::= X |N N ::= C < T > L ::= class \nC < X <N > <N{Tf; M} M ::= < X <N > Tm(Tx) {return e; } e ::= x |e.f |e.m < T >(e) |new N() |(N) e |e.f \n= e |let x = eine |l |l > e |null v::= l|null Environment and Permission: .= {x : T}.{X < N}.{l : T} \nP ::= C | l Store (Heap): l .locations S ::= {l. N(v)} Figure 8. FGO Syntax type parameter or argument, \nwhich can be distinguished using the following syntax: Npure ::= C< T, O > Lpure ::= class C< X <N, XO \n<NO > <N {Tf; M}. While the last type parameter is distinguished to make it easy to identify the owner \nof a particular instance, other type parameters can be naked owners as well as type parameters with no \nsyntactic distinction made by the type system. FGO makes use of a number of functions to simplify the \npresen\u00adtation: pC the package owner class corresponding to C thisP (e) checks the use of this. calls \nin e (see 4.3) owner.(T) the owner of type T visible.(O, C) owner O is visible in class C visible.(T, \nC) type T is visible in class C pC is assumed to be an implicit lookup function; this, owner,and visible \nare described in detail in the rest of this section. Finally, we use the following judgements: . f T \nOK Type T is OK. . f T < U Type T is a subtype of type U. .; P f e : T Expression e is well typed. .; \nP f visible(e) Expression e is visible with respect to P. . f S Store (heap) is well-formed. . f < Y \n< P > Tm(Tx){return e0 ; } FGO INC, CO Method m de.nition is OK. class C < X < N > <N {Tf; M} FGO Class \nC de.nition is OK.  4.2 Owner Lookup owner.(O)= O owner.(X)= owner.(.(X)) owner.(C < T, O >)= O owner.(C \n< T >)= owner.([T/X]N), where CT (C)= class C < X < N > <N{T\" f; M} The owner function gives the owner \nof a type. A manifest class s owner is found by traversing the class hierarchy.  4.3 This Function (FGO-THIS) \nthisC (this)= This thisl(l)= Thisl thisP (...)= . The this function is used extensively during the typing \nof FGO expressions. It helps enforce ownership, as it ensures that types involving This can only be used \nwithin the current object, that is, as part of message sends or .eld accesses upon this. Basically, every \noccurrence of This in the type of a method call or .eld access is substituted with the result of calling \nthe this function; if the type involves This, the expression will typecheck only if the target of the \ncall or .eld access is this. As such, the this function is one of the key extensions we make to FGJ. \nIn detail, there are two distinct places where this is used. They are distinguished by the permission \nP that is present on the left hand side of the expression type rules. The .rst place is during the validation \nof FGO class declarations (in the class and method typing rules in Figure 13, which rely on expression \ntyping in Figure 11). Here, the permission P is set to the class C currently being validated. When typing \na .eld access or method call inside C,the this function is called upon the expression e0 that is the \ntarget of the .eld access (e0 .f) or method call (e0 .m()). Then, all occurrences of This in the types \nof the method or .eld are substituted by the result of the this function. If the target is this (e.g. \nthis.f), the this function returns This, the substitution will replace This with itself, and so the expression \ntypechecks, even if it involves This types. If the target is other than this,the this function returns \nan unde.ned (.) result, so This is substituted by . (leaving other types unaffected), and any expressions \nwith This types will fail to typecheck. In this way, FGO ensures that This types can only be used upon \nthis. The second place this appears is during the reduction of FGO expressions (e.g. R-METHOD in Figure \n15). In this case, expression types include locations (l). Every occurrence of a This owner is replaced \nby a location speci.c Thisl. The expression typing rules further ensure that every occurrence of This \nis made location spe\u00adci.c. To achieve this, the T-CONTEXT rule in Figure 11 sets the per\u00admission P to \nthe current location l. As the expression typing rules X . dom(.) (WF-VAR) . f X OK . f O < World (WF-OBJECT) \n. f Object < O >OK (WF-TYPE): class C < X < N > < N {...} . f N < Object < O > . f O < World . f T OK \n. f T < [T/X]N Figure 9. FGO Type Well-Formedness Rules. WF-TYPE rule en\u00adforces ownership with the grey \nclause checking the nesting among different owners present in the same type. recurse into the structure \nof the expression e, every occurrence of This is replaced appropriately by thisl to be Thisl. This replace\u00adment \nensures that FGO expression reduction distinguishes between different instances of the same class, allowing \nus to prove our own\u00adership system provides per-object ownership guarantees. In either case, invalid use \nof an owner class causes the expres\u00adsion type to become unde.ned (.). FGO type soundness guaran\u00adtees \nthat any validated FGO class will not incur an invalid access to a location-speci.c instance (marked \nby Thisl owner) during reduction. 4.4 Well-formed Types and Subtyping FGO s type well-formedness rules \nshown in Figure 9 are the same as those of FGJ, except that the root of the class hierarchy is parameterised. \nThe grey clause in the type formation rule ensures that FGO supports deep ownership: WF-TYPE enforces \nthe nesting of owner parameters essential to ensure owners as dominators object encapsulation. The owner \nnesting required of each type is that the last (distinguished) owner parameter of C < T > is inside of \nevery other owner of the rest of the type parameters T. Figure 10 shows FGO s subtyping rules. They are \ngenerally taken verbatim from FGJ, except for the addition of subtyping for owner classes. World forms \nthe top of the owner class hierarchy, which any package owner class extends directly. Location-speci.c \nversion Thisl extends the owner of the class at location l.The owner hierarchy for location-speci.c owners \nis built up in the FGO class rules (Figure 13) using owner variables. 4.5 Expressions and Visibility \nFigure 11 shows the expression typing rules. These are similar to the FGJ rules with added support for \nlocations, assignment, null, and let expressions [43]. We also simplify the detection of cast errors \nby only doing it at reduction time. Another important addition that FGO makes to FGJ is a set of visibility \nrules similar to those used by Featherweight Generic Con.nement [47]. While a subset of our visibility \nrules for terms is similar to those used by Con.nedFJ [55], the owner and type visibility rules are part \nof the foundation of FGO. Figure 12 shows the owner visibility rule that checks if an owner O is visible \ninside class C. This is the case if the owner is World, belongs to the same package as C, or is an owner \nof one of the generic parameters used when instantiating C. Supplying an actual owner parameter to a \nclass gives that class permission to access everything owned by that parameter. This, for example, can \nallow a type polymorphic class to have private access to more than one package. Bound of Type: bound.(X)=.(X) \nbound.(N)= N Subclassing: C DD E C C C E class C < X < N > < D < T >{...}C D Subtyping: (S-REFL): (S-TRANS): \n. fS < T . fT < U . fT < T . fS < U (S-VAR): (S-CLASS): class C < X < N > < N {...}. fX<.(X). fC < T \n> <[T/X]N (S-OWNER): class C < X < N > < N {...} l .dom(.) . fpC < World . fThisl < owner.(.(l))  Valid \nMethod Overriding: mtype(m, N)= < Z < Q > U .U0 . P, T =[Y/Z](Q, U) and Y < P fT0 < [Y/Z]U0 override(m, \nN, < Y < P > T .T0 ) Figure 10. FGO Subtyping Rules Finally, we allow complete visibility of the This \nowner, and rely on the this function described earlier to stop illegal uses of This. Type visibility \nsimply checks the owner of a given type for visibility. Term visibility (not shown) recursively checks \nall the types involved in the possible expressions of FGO to make sure that they are visible in a given \nclass C. Since these checks are performed on class declarations, locations are not present in these expressions. \n 4.6 Class and Method The class and method declarations are checked to make sure that they contain well-formed, \nvisible types and expressions as shown in Figure 13. There are rules for pure and manifest FGO classes \nthat are distinguished only by the fact that the owner is either explicit or must be looked up from a \nsuperclass. Both of the class rules check that (1) all the types involved (types of .elds and type parameters) \nare visible within the context of the owner of the class being declared or its superclass; (2) all the \ntypes are well formed FGO types; and (3) all the methods declarations are valid. The grey clauses ensure \nthat owner nesting (the distinguished owner is inside the owners of the other type parameters) is preserved \nfor the purposes of the deep ownership invariant proven below in Section 6. Additionally, FGO allows \nclass declarations to use implicit placeholder owner parameters in formal type parameter bounds, e.g.: \nclass List<E extends Foo<FO>, Owner extends World> { ... } Here, List s formal parameter E can only \nbe bound by actual type parameters that are subclasses of Foo; the owner of that type parameter (FO) \ncan be different from the owner of the list (Owner). Since FGO (like FGJ) requires every type variable \nto be bound, we need to make sure that our environment contains an appropriate mapping for implicit placeholder \nparameters like FO. A function PHowners in Figure 13 does exactly that, by making sure that (T-FIELD): \n.; P fe0 : T0 . fT OK fields(bound.(T0 )) = Tf T =[thisP (e0)/This]Ti .; P fe0 .fi : T (T-FIELD-SET): \n.; P fe0 : T0 .; P fe : T . fT OK fields(bound.(T0 )) = Tf T =[thisP (e0)/This]Ti .; P fe0 .fi = e : \nT (T-METHOD): .V \" .V :(. fV \" OK . . fV \" < World) . . ( owner.(T0 ) < owner.(V \" )) mtype(m,bound.(T0 \n)) = < Y < P > U .U .; P fe : S .; P fe0 : T0 . fT OK T =[V/Y, thisP (e0 )/This]U . fV < [V/Y, thisP \n(e0 )/This]P . fS < [V/Y, thisP (e0 )/This]U .; P fe0 .m < V >(e): T (T-CAST): . fN OK .; P fe0 : T0 \n.; P f(N)e0 : N (T-LET): .; P fe0 : T0 ., x : T0 ; P fe : T .; P flet x = e0 in e : T (T-CONTEXT) (T-NEW) \n.; l fe : T . fN OK .; P fl > e : T .; P fnew N() : N (T-ERROR) (T-NULL) . fT OK . fT OK .; P ferror \n: T .; P fnull : T (T-VAR) (T-LOC) .; P fx :.(x) .; P fl :.(l) Figure 11. FGO Expression Typing (V-TYPE): \nvisible.(T, C)= visible.(owner.(T), C) (V-OWNER): visible.(O, C)= O .owners(C) .{This,pC , World} where \nowners(C)= {owner.(N \" ) |N \" .N, N}, {if CT(C)= class C < X < N > <N{...} {XO }.{owner.(N \" ) |N \" \n.N}, if CT(C)= class C < X < N, XO < NO > <N{...} Figure 12. FGO Type and Owner Visibility any (placeholder) \nowner used in the type bounds is recorded in the FGO environment . as being a subtype of World. This \nensures that every owner present in the class declaration is bound, whether implicitly or explicitly. \nThe method typing rule checks that all the types involved are well formed FGO types that are visible \nwithin the class that contains the method. It also recursively checks the method s expression to ensure \nthat all the subexpressions are visible with respect to the  Method Typing (FGO-METHOD): \" P \" P \" .f.P \n.P :(OK).(< World) .=. .{Y < P} .=..PHowners.(N) .fT, T OK class C < X < N > < N {...} visible.(T, C) \nvisible.(T, C) visible.(P, C) ., x :T, this : C < X > ;C fvisible(e0 ) ., x :T, this : C < X > ;C fe0 \n:S .fS < T override(m, N, < Y < P > T .T) .f< Y < P > Tm(Tx){return e0 ; }FGO IN C, CO Class Typing \n(FGO-CLASS-MANIFEST): .={ X < N, This < owner.(N)} .=..PHowners.(N) .fM FGO IN C, owner.(N).fN, T, N \nOK visible.(N, C) visible.(T, C) visible.(N, C) class C < X < N > <N {Tf; M}FGO Class Typing (FGO-CLASS-PURE): \nN =D < T \" , XO > .N \" .N :.fN \" OK ..fN \" < World .={X < N, XO < NO , This < XO } .=..PHowners.(N) .fM \nFGO IN C, XO .fN, T OK visible.(, C) visible.(T, C) visible.(N, C) NO class C < X < N, XO < NO > <N \n{Tf; M}FGO Placeholder Owners Function: PHowners.(C < T >)= {owner .(C < T >)<World}..PHowners.(T) if \nowner.(C < T >)./dom(.) PHowners.(C < T >)= PHowners.(T) otherwise PHowners.(X)= {} Figure 13. FGO Method \nand Class Typing with Placeholder Own\u00aders Function  Store Well-Formedness (FGO-STORE-WF): .l .dom(.):.f \n.(l)OK .OK Store Typing (FGO-STORE): .OK dom(.)=dom(S) S[l]=N(v)...(l)=N (S[l, i]=l \" ).(.elds(.(l))=Tf)=. \n=..f.(l \" )< [Thisl /This]Ti (S[l, i]=l \" )=..f .(l \" )OK .fS Figure 14. FGO Store current class. Finally, \nin exactly the same manner as FGJ, the validity of method overriding (if applicable) is veri.ed.  5. \nFGO Dynamic Semantics This section addresses the dynamic aspects of FGO. The store typing rules shown \nin Figure 14 are standard [2, 17]. The mapping .contains the types for each location and the FGO-STORE-WF \nrule in Figure 14 ensures that every one of the types is well-formed. The mapping S contains the type \ninstantiations with locations for each .eld. The main FGO-STORE rule ensures that not only the types \nare (R-NEW): l/.dom(S) S \" =S[l .null] |null|=|fields(N)|new N(),S .l, S \" (R-FIELD): S[l]=N(v) fields(N)=Tf \nl.fi,S .vi,S (R-FIELD-SET): S[l]=N(v) fields(N)=Tf S \" =S[l .[v/vi]N(v)] l.fi =v, S .v, S \" (R-METHOD): \nS[l]=N(vl) mbody(m < V >, N)=x.e0 l.m < V >(v),S .l > [v/x,l/this, Thisl /This]e0 ,S S[l]=N(v) N < P \n(R-CAST) (P)l, S .l, S S[l]=N(v) N<:P (R-BAD-CAST) (P)l, S .error,S (R-CONTEXT) l > v, S .v, S (R-LET) \nlet x = v in e0 ,S .[v/x]e0 ,S (R-*-NULL): null.m < V >(v),S .error,S null.fi,S .error,S null.fi =v, \nS .error,S Figure 15. FGO Reduction Rules well-formed, but also that each .eld location is valid and \nis a correct subtype of the declared .eld type. It is interesting to note that our type system does not \nhave any explicit ownership constraints in the store rule the bene.t of ownership information being \npart of the type is that subtyping ensures that none of the ownership constraints are broken. Figure \n15 shows the reduction rules. Again, these are standard given the expressions that FGO supports. The \ncontext reduction rules are omitted from this paper for brevity, but are present in the accompanying \ntechnical report [48]. 5.1 Soundness In this subsection we present manual proofs of the FGO type soundness. \nPart of the future work on Generic Ownership is to convert these proofs to a machine-checkable format. \nTheorem (Preservation). If .;P f e : T and . f S and e,S . e \" ,S \" ,then .. \" . .and .T \" < T such that \n.;P f \" : T \"\" fS \" e and . . Proof. Use structural induction on reduction rules in Figure 15. This \nproof is presented in detail in the accompanying technical report [48]. Theorem (Progress). Suppose e \nis a closed well-typed expression. Then either e is a value or there is a reduction rule that contains \ne on the left hand side. Proof. Based on all the possible expression types, either e is a value (see \nthe last four rules in Figure 11) or one of the reduction rules applies. It can t be a variable because \nit is closed. We need to check that each of the reduction rules is satis.ed. The only rules that require \nadditional conditions are R-FIELD, R-FIELD-SET,and R-METHOD in the case of R-BAD-CAST the program reduces \nto errorif the downcast is impossible. In case of R-FIELD and R-FIELD-SET well-typedness of N ensures \nthat fields(N) is well de.ned and fi appears in it. In case of R-METHOD, the fact the mtype looks up \nthe type for m, ensures that mbody will succeed too and will have the same number of arguments (since \nMT-CLASS and MB-CLASS are de.ned in the same way). In case of l = null, one of R-FIELD-NULL, R-METHOD-NULL,and \nR-FIELD-SET-NULL will ensure that we reduce to error. Type soundness is then immediate from preservation \nand progress theorems. Note that this type soundness result proves only the absence of ordinary type \nerrors. The next section discusses the ownership guarantees provided by FGJ.  6. Ownership Guarantees \nLemma (Ownership Invariance). If . f S < T and . f T < Object < O >,then owner.(S)= owner.(T)= O. Proof. \nBy induction on the depth of the subtype hierarchy. By FGO class typing rules a FGO class has the same \nowner parameter as its superclass. 6.1 Ownership Invariant We de.ne inside (.) relationship on owner \nclasses for objects (e.g. Thisl) in the same manner as classic ownership type papers [10, 18]. During \nthe execution of any FGO program with deep ownership, if an object at l refers to object at l \" , then \nowner class Thisl corresponding to the object at l is inside (.) owner class corresponding to l \" (owner(.(l \n\" ))). At class declaration validation time, the . relationship for the owner classes is as follows: \nThis . Owner . World (note that our owner classes subtyping relationship is along the same lines: Thisl \n<: This <: World). During the reduction, both Owner and This will have appropriate location-speci.c owners \n(e.g. Thisl) substituted for them. This allows us to prove a deep ownership invariant similar to that \nof Clarke (and as used by Boyapati): De.nition (refers to). Object at location l refers to object at \nloca\u00adtion l \" if and only if (1) .(l)= N(l ) and l \" . l ;or(2) forsome .,P we have .; P f l > e : T \nand l \" occurs as one of the subex\u00adpressions of e. De.nition (inside). Owner class T is inside (.) owner \nclass T if and only if . f T < T \" < World. Theorem (Ownership Invariant). l refers to l only if Thisl \n. owner.(l \" ) or (owner.(l \" )= pC and visible.(pC , .(l))). Proof. .(l \" ) < [This/Thisl] Ti .Ifowner \nis World or This, then we are OK by de.nition of .. If owner is anything else then since well-formedness \npreserves owner class nesting and This < Owner < O (where O is the set of owners of type parameters) \nholds, we have Thisl < Thisl. . The second part of the proof holds due to the con.nement invariant (below). \nTheorem (Con.nement Invariant). Let e be a subexpression appearing in the body of a method of a well-formed \nFGO class C during program execution. Then: If e . * new D < TD >(e),then visible.(D < TD >, C). Proof. \nBecause the class is a well-formed FGO class, its methods are well-formed FGO methods. This, plus the \nstandard subformula property, implies that, for appropriate .; P : both .; P f e : T and .; C f visible(e) \nhold. From this we can derive visible.(T, C), and hence visible.(owner.(T), C). By FGO s subject reduction \nproperty, there is a T \" such that .; P f new D < TD >(e): T \" ,where . f T \" < T.Furthermore,we have \nthat .; P f new D < TD >(e): D < TD >, and hence clearly . f D < TD > < T \" ,and . f D < TD > < T. By \nthe Ownership Invariance lemma, owner.(D < TD >)= owner.(T), from which we deduce visible.(owner.(D < \nTD >), C), and hence visible.(D < TD >, C). The major difference between our generic ownership proofs, \nand more traditional non-type-generic ownership invariant proofs lies in a much simpler formulation. \nThe key bene.t comes from integrating ownership into a parametric polymorphic type system, rather than \nbuilding an ownership-parametric type system on top of a non-generic typed language.  7. Discussion \nand Related Work Object ownership can address aliasing, security, concurrency, and memory management \nproblems, while smoothly aligning with typ\u00adical object-oriented program designs. Systems using object \nowner\u00adship range from expressive but weighty explicit systems based on ownership types [18] to lightweight \nbut limited implicit systems based on con.ned types [54]. Ownership types make ownership information \nan integral part of the type. Ownership part cannot be separated or changed through subtyping or casts. \nGeneric Java treats generic part of types in a similar manner, making it an obvious choice for carrying \nowner\u00adship type information in Java. An alternative merger of con.nement with genericity [55] that treats \ncon.nement and genericity orthog\u00adonally results in more complex proofs and type rules duplicating the \njob that can be shared between genericity and ownership. This shows additional evidence that merging \nownership and genericity is more than a syntactical change to the language. Explicit systems such as \nAliasJava, Universes, and the systems of Boyapati et.al. [2, 3, 10, 39] differ primarily in one characteristic \nthat Clarke and Wrigstad de.ne as shallow vs. deep ownership [20]. Deep ownership protects transitively \nnested objects, while shallow ownership does not. Generic Ownership is an explicit deep ownership system: \nhowever its key contribution is that it combines type genericity and object ownership into a single system. \nClarke and Drossopoulou [17] and Boyapati et.al. [10] describe how to exploit the strong protection provided \nby deep ownership. The strong, transitive protection that deep ownership provides is also a liability, \nbecause the deep ownership protection prevents programmers from accessing objects internal structures, \nand can require inef.cient coding idioms to move data across the objects interfaces. Aldrich and Chambers \nAliasJava and Boyapati et.al. s SafeJava [2, 10] show how ownership types can support more .exible object \ngraph topologies we do not address this issue in this paper. Inspired by OGJ, AliasJava adopted Generic \nOwnership style parameters [2] to provide both type and ownership genericity, al\u00adthough without a type \ngeneric formal system: here we establish that this approach is sound. Krishnaswami and Aldrich have recently \nformalised an extension to Ownership Domains using System F and permission-based ownership [31], illustrating \na range of .ex\u00adible ownership topologies, and supporting strong encapsulation via ML-style abstract types \nand genericity. Other recent research has extended the applicability of ownership\u00adstyle schemes. Lu and \nPotter have shown how to ensure object references are acyclic [34], or to control .eld updates even when \nreferences are unconstrained [36] they also employ ownership wildcards. They later extended their work \nto owner variance [35]. Boyland and Retert have described how various forms of unique\u00adness and ownership \ncan be encoded using fractional permissions [12, 13]. None of these proposals are type-generic: however, \nwe expect that, like AliasJava, languages designed with these systems could take advantage of generic \nownership to provide both type and owner polymorphism. Unlike some other ownership type schemes [9] FGO \ndoes not currently support runtime downcasts. An implication of this is the FGO rule forbidding casts \nthat would lose ownership informa\u00adtion. This is primarily for compatibility with existing Java and GJ \nprograms: safe ownership downcasts require runtime information which existing compilers do not supply \nnor existing libraries expect. Also, we suspect that other ownership type systems require many of these \ndowncasts because they are not type-generic: as with GJ, FGO s genericity should remove the need for \nmany of these down\u00adcasts. All these explicit systems require additional annotations to use them, raising \nissues about their role in programming. For this rea\u00adson, Aldrich et.al. and Boyapati et.al. have described \na range of type inference schemes to provide these annotations automatically [3, 8, 9, 11]. Generic ownership \nenables a simpler approach, as many of the owner parameters that have to be inferred by other schemes \nare already present in type-generic code. Implicit con.ned type systems have achieved their more limited \ngoals while keeping the number of annotations low. Vitek and Bokowski s original system [54] required \nclasses to be annotated as con.ned, while Clarke, Richmond and Noble [19] apply these ideas in the context \nof Enterprise Java Beans. More recent work by Zhao, Palsberg and Vitek [55] has formalised con.ned types \nbased on Featherweight Java. Con.ned Featherweight Java also includes a notion of generic con.ned types, \nallowing a collection to be con.ned or not depending upon the speci.cations of the contained elements. \nOur approach is essentially the opposite. Rather than starting from a language without generic types \nand then adding a special form of genericity to support con.nement, we start from a language with generic \ntypes (Generic Java, and its formal core FGJ), and then ensure ownership and con.nement directly. Our \napproach leads to a simpler formal system requiring fewer new concepts and a distinctly simpler and shorter \nproofs. Clarke s thesis was the .rst account of a system with both parametric polymorphism and ownership \n[16]. This system was based on Abadi and Cardelli s object calculus [1], rather than a class-based language. \nClarke, however, gives an encoding of a class-based language into his formalism. He further discusses \nhow ownership can be combined with a class-based language (with inner classes), but does not provide \na generic type system or language design. Ownership types are similar to region types and region polymor\u00adphism \n[51, 52], but serve quite different purposes: ownership ac\u00adcounts for encapsulation while regions manage \nmemory allocation. Regions are restricted to stack-based memory allocation while own\u00adership supports \nlong-lived objects and much less restrictive topolo\u00adgies. Just as region polymorphism permits functions \nto be applied to arguments in different regions, so generic ownership polymor\u00adphism allows a class to \nbe instantiated to handle arguments with different ownership the actual ownership type arguments act \nas permissions allowing the generic class access the arguments with those types. Regions and other systems \nuse Hindley-Milner style type infer\u00adence to make .ne distinctions on potential aliasing [5, 32, 41]. \nType\u00adbased alias analysis uses the class hierarchy to discover non-alias conditions [21]. More generally, \nfunctional programmers use a re\u00adlated technique called phantom types [22] to include a wide range of \ninformation within types. Generic ownership is similar to these approaches in that it, too, uses additional \ntype parameters to carry ownership information, while paying a minimal syntactic cost. Finally, John \nPotter4 has suggested that owners could be mod\u00adeled orthogonally to class types. In such a scheme, types \nwould be a pair comprising an owner context and a class type (e.g. T ::= C@O, 4 Personal Communication, \nDec. 2005 where @ binds a type and an owner context). Cyclone, X10, and Fown [15, 23, 31] types have \nsimilar structures. This approach has the advantage of keeping owners and types conceptually separate, \nand, if type variables can range over such pairs, providing much of the polymorphism of generic ownership. \nCompared with our model these pairs need more language support a separate kind of own\u00aders, and then \nconstructors and accessors to retrieve owners from type pairs. This would be harder to incorporate into \na practical pro\u00adgramming language than generic ownership (X10 and Cyclone are new designs) and also harder \nto take advantage of new language fea\u00adtures. In particular, our deep ownership type formation constraints \nare very similar to GADT type constraints [29] although we require subtyping rather than type equality. \nBased on our model of generic ownership, we expect that a language with GADT s and subtype constraints \nmay be strong enough to express ownership directly in its type system. 8. Future Work and Conclusion \nIn this paper we described and formalised Generic Ownership a single system that encompasses both generic \ntypes and deep, per\u00adobject ownership. The primary goal of Generic Ownership is to pro\u00advide a practical \nway of integrating ownership into modern object\u00adoriented languages (like Java or C#) that already employ \ngenericity. Rather than purely to provide a uni.ed abstraction combining own\u00adership and genericity. Generic \nOwnership reuses generic language constructs as much as possible to provide ownership. Our language design \nand formalism show that ownership and generic type infor\u00admation can be expressed within a single system, \nand carried around the program as bindings to the same parameters. As a result, pro\u00adgrams using Generic \nOwnership are only slightly more complex than those using just generic types, yet enjoy the full protection \nprovided by ownership types. We have demonstrated the practicability of Generic Ownership with Ownership \nGeneric Java, a seamless, syntactically compatible extension to generic-capable Java 5 and we have implemented \nan OGJ language as an extension to Java 5 [44]. In the future, we plan to utilise the formal foundations \nprovided by FGO to work out proof principles of ownership guarantees, and develop a set of design patterns \nfor OGJ for programmers wishing to make use of ownership in their programs. To summarise, our contributions \nare as follows: Generic Own\u00adership, a seamless integration of genericity and ownership; Feath\u00aderweight \nGeneric Ownership, a formal model allowing the proof of soundness, con.nement, and deep ownership invariants; \nand Own\u00adership Generic Java combining generic types, ownership, and con\u00ad.nement in a single, straightforward \nlanguage design.  Acknowledgments Thanks to many anonymous reviewers for their comments, and especially \nfor providing a number of excellent examples. Thanks to Phil Wadler for encouraging us to publish this \nwork. Thanks to Chris Andreae for keeping us on our toes by providing an alternative implementation of \nGeneric Ownership in JavaCOP [4]. This work is partially supported by the EPSRC grant Practical Ownership \nTypes for Objects and Aspect Programs, EP/D061644/1. This work is also supported by the Royal Society \nof New Zealand Marsden Fund. References [1] ABADI,M., AND CARDELLI,L. A Theory of Objects. Springer-Verlag, \nBerlin, Heidelberg, Germany, 1996. [2] ALDRICH,J., AND CHAMBERS, C. Ownership Domains: Separating Aliasing \nPolicy from Mechanism. In Proceedings of European Conference on Object-Oriented Programming (ECOOP) (Oslo, \nNorway, June 2004), vol. 3086, Springer-Verlag, Berlin, Heidelberg, Germany, pp. 1 25. [3] ALDRICH,J., \nKOSTADINOV,V., AND CHAMBERS, C. Alias Annotations for Program Understanding. In Proceedings of ACM Conference \non Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA) (Seattle, WA, USA, Nov. \n2002), ACM Press, New York, NY, USA, pp. 311 330. [4] ANDREAE,C., NOBLE,J., MARKSTRUM,S., AND MILLSTEIN, \nT. A framework for implementing pluggable type systems. In Proceedings of ACM Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA) (Portland, Oregon, USA, Oct. 2006), ACM Press, \nNew York, NY, USA. [5] BAKER, H. G. Unify and Conquer (Garbage, Updating, Aliasing) in Functional Languages. \nIn Proc. 1990 ACM Conf. on Lisp and Functional Programming (Nice, France, June 1990), pp. 218 226. [6] \nBARNETT,M., DELINE,R., FAHNDRICH,M., LEINO,K. R. M., AND SCHULTE, W. Veri.cation of object-oriented programs \nwith invariants. In Proceedings of the Workshop on Formal Techniques for Java-like Programs in European \nConference on Object-Oriented Programming (FTfJP) (Darmstadt, Germany, July 2003), Springer-Verlag, Berlin, \nHeidelberg, Germany. [7] BOYAPATI,C. SafeJava: A Uni.ed Type System for Safe Program\u00adming. PhD thesis, \nEECS, MIT, February 2004. [8] BOYAPATI,C., LEE,R., AND RINARD, M. Ownership types for safe programming: \nPreventing data races and deadlocks. In Proceedings of ACM Conference on Object-Oriented Programming, \nSystems, Languages, and Applications (OOPSLA) (November 2002). [9] BOYAPATI,C., LEE,R., AND RINARD, M. \nSafe runtime downcasts with ownership types. In Proceedings of International Workshop on Aliasing, Con.nement, \nand Ownership (IWACO),D.Clarke, Ed. Utrecht University, July 2003, pp. 1 14. [10] BOYAPATI,C., LISKOV,B., \nAND SHRIRA, L. Ownership Types for Object Encapsulation. In Proceedings of ACM Symposium on Principles \nof Programming Languages (POPL) (New Orleans, LA, USA, Jan. 2003), ACM Press, New York, NY, USA, pp. \n213 223. Invited talk by Barbara Liskov. [11] BOYAPATI,C., AND RINARD, M. A Parameterized Type System \nfor Race-Free Java Programs. In Proceedings of ACM Conference on Object-Oriented Programming, Systems, \nLanguages, and Appli\u00adcations (OOPSLA) (Tampa Bay, FL, USA, 2001), ACM Press, New York, NY, USA, pp. 56 \n69. [12] BOYLAND, J. Checking interference with fractional permissions. In Static Analysis: 10th International \nSymposium (2003), no. 2694 in Lecture Notes in Computer Science (LNCS), Springer-Verlag, Berlin, Heidelberg, \nGermany, pp. 55 72. [13] BOYLAND,J. T., AND RETER, W. Connecting effects and uniqueness with adoption. \nIn Proceedings of ACM Symposium on Principles of Programming Languages (POPL) (2005). [14] BRACHA,G., \nODERSKY,M., STOUTAMIRE,D., AND WADLER, P. Making the future safe for the past: Adding Genericity to the \nJava programming language. In Proceedings of ACM Conference on Object-Oriented Programming, Systems, \nLanguages, and Applica\u00adtions (OOPSLA) (Oct. 1998). [15] CHARLES,P., DONAWA,C., EBCIOGLU,K., GROTHOFF,C., \nKIELSTRA,A., SARKAR,V., AND PRAUN, C. V. X10: An object\u00adoriented approach to non-uniform cluster computing. \nIn Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications \n(OOPSLA) (2005). [16] CLARKE,D. Object Ownership and Containment. PhD thesis, School of CSE, UNSW, Australia, \n2002. [17] CLARKE,D., AND DROSSOPOULOU, S. Ownership, Encapsulation, and the Disjointness of Type and \nEffect. In Proceedings of ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications \n(OOPSLA) (Seattle, WA, USA, Nov. 2002), ACM Press, New York, NY, USA, pp. 292 310. [18] CLARKE,D., POTTER,J., \nAND NOBLE, J. Ownership Types for Flexible Alias Protection. In Proceedings of ACM Conference on Object-Oriented \nProgramming, Systems, Languages, and Applica\u00adtions (OOPSLA) (Vancouver, Canada, Oct. 1998), ACM Press, \nNew York, NY, USA, pp. 48 64. [19] CLARKE,D., RICHMOND,M., AND NOBLE,J. Saving the World from Bad Beans: \nDeployment-Time Con.nement Checking. In Proceedings of ACM Conference on Object-Oriented Programming, \nSystems, Languages, and Applications (OOPSLA) (Anaheim, CA, 2003), ACM Press, New York, NY, USA, pp. \n374 387. [20] CLARKE,D., AND WRIGSTAD, T. External Uniqueness is Unique Enough. In Proceedings of European \nConference on Object-Oriented Programming (ECOOP) (Darmstadt, Germany, July 2003), vol. 2473 of Lecture \nNotes in Computer Science (LNCS), Springer-Verlag, Berlin, Heidelberg, Germany, pp. 176 200. [21] DIWAN,A., \nMCKINLEY,K. S., AND MOSS, J. E. B. Type-based alias analysis. In Proceedings of the ACM SIGPLAN Conference \non Programming Language Design and Implementation (PLDI) (June 1998). [22] FLUET,M., AND PUCELLA, R. \nPhantom Types and Subtyping. In International Conference on Theoretical Computer Science (TCS) (Aug. \n2002), pp. 448 460. [23] GROSSMAN,D., MORRISETT,J. G., JIM,T., HICKS,M. W., WANG,Y., AND CHENEY, J. Region-based \nmemory management in cyclone. In PLDI (2002), pp. 282 293. [24] GROTHOFF,C., PALSBERG,J., AND VITEK, \nJ. Encapsulating Ob\u00adjects with Con.ned Types. In Proceedings of ACM Conference on Object-Oriented Programming, \nSystems, Languages, and Applica\u00adtions (OOPSLA) (Tampa Bay, FL, USA, 2001), ACM Press, New York, NY, USA, \npp. 241 255. [25] HOGG, J. Islands: Aliasing Protection in Object-Oriented Languages. In Proceedings \nof ACM Conference on Object-Oriented Program\u00adming, Systems, Languages, and Applications (OOPSLA) (Phoenix, \nAZ, USA, Nov. 1991), vol. 26, ACM Press, New York, NY, USA, pp. 271 285. [26] HOGG,J., LEA,D., WILLS,A., \nDE CHAMPEAUX,D., AND HOLT, R. The Geneva convention of the treatment of object aliasing. OOPS Messenger \n3, 2 (April 1992), 11 16. [27] IGARASHI,A., PIERCE,B. C., AND WADLER, P. Featherweight Java: a minimal \ncore calculus for Java and GJ. ACM Transactions on Programming Languages and Systems (TOPLAS) 23, 3 (May \n2001), 396 450. [28] IGARASHI,A., PIERCE,B. C., AND WADLER, P. A recipe for raw types. In Proceedings \nof Workshop on Foundations of Object-Oriented Languages (FOOL) (2001). [29] KENNEDY,A., AND RUSSO, C. \nGeneralized algebraic data types and object-oriented programming. In Proceedings of ACM Conference on \nObject-Oriented Programming, Systems, Languages, and Applications (OOPSLA) (2005). [30] KENNEDY,A., AND \nSYME, D. The design and implementation of Generics for the .NET Common Language Runtime. In Proceedings \nof the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (2001). [31] KRISHNASWAMI,N., \nAND ALDRICH, J. Permission-based own\u00adership: Encapsulating state in higher-order typed languages. In \nProceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (Chicago, \nUL, USA, 2005), ACM Press, New York, NY, USA, pp. 96 106. [32] LAMPORT,L., AND SCHNEIDER, F. B. Constraints: \nA uniform approach to aliasing and typing. In Proceedings of ACM Symposium on Principles of Programming \nLanguages (POPL) (New Orleans, Louisiana, 1985), pp. 205 216. [33] LEINO,K. R. M., AND MULLER, P. Object \ninvariants in dynamic contexts. In Proceedings of European Conference on Object-Oriented Programming \n(ECOOP) (2004), Springer-Verlag, Berlin, Heidelberg, Germany. [34] LU,Y., AND POTTER, J. A type system \nfor reachability and acyclicity. In Proceedings of European Conference on Object-Oriented Programming \n(ECOOP) (2005), vol. 3586 of Lecture Notes in Computer Science, Springer, pp. 479 503. [35] LU,Y., AND \nPOTTER, J. Flexible ownership types with owner variance. In Proceedings of European Conference on Object-Oriented \nProgramming (ECOOP) (2006). [36] LU,Y., AND POTTER, J. Protecting representation with effect encapsulation. \nIn Proceedings of ACM Symposium on Principles of Programming Languages (POPL) (2006). [37] MILNER, R. \nTheory of type polymorphism in programming. Journal of Computer and System Sciences 17(3) (1978), 348 \n375. [38] MITCHELL, N. The runtime structure of object ownership. In Pro\u00adceedings of European Conference \non Object-Oriented Programming (ECOOP) (Nantes, France, July 2006), D. Thomas, Ed., vol. 4067 of Lecture \nNotes in Computer Science (LNCS), Springer-Verlag, Berlin, Heidelberg, Germany, pp. 74 98. [39] M \u00a8ULLER,P., \nAND POETZSCH-HEFFTER,A. Programming Lan\u00adguages and Fundamentals of Programming. Fernuniversit\u00a8at Hagen, \n1999, ch. Universes: a Type System for Controlling Representation Exposure. Poetzsch-Heffter, A. and \nMeyer, J. (editors). [40] NOBLE,J., VITEK,J., AND POTTER, J. Flexible Alias Protection. In Proceedings \nof European Conference on Object-Oriented Program\u00adming (ECOOP) (July 1998), E. Jul, Ed., vol. 1445 of \nLecture Notes in Computer Science (LNCS), Springer-Verlag, Berlin, Heidelberg, Germany, pp. 158 185. \n[41] O CALLAHAN,R., AND JACKSON, D. Lackwit: a program understanding tool based on type inference. In \nProceedings of the International Conference on Software Engineering (ICSE) (Boston, USA, May 1997). [42] \nPERMANDLA,P., AND BOYAPATI, C. A type system for preventing data races and deadlocks in the java virtual \nmachine language. Tech. rep., University of Michigan, 2005. [43] PIERCE,B. C. Types and Programming Languages. \nMIT Press, 2002. [44] POTANIN, A. Ownership Generic Java Download. http: //www.mcs.vuw.ac.nz/ alex/ogj/, \n2005. [45] POTANIN,A., NOBLE,J., CLARKE,D., AND BIDDLE, R. Default\u00ading Generic Java to Ownership. In \nProceedings of the Workshop on Formal Techniques for Java-like Programs in European Confer\u00adence on Object-Oriented \nProgramming (FTfJP) (Oslo, Norway, June 2004), Springer-Verlag, Berlin, Heidelberg, Germany. [46] POTANIN,A., \nNOBLE,J., CLARKE,D., AND BIDDLE,R. Feath\u00aderweight Generic Ownership. In Proceedings of the Workshop on \nFormal Techniques for Java-like Programs in European Conference on Object-Oriented Programming (FTfJP) \n(Glasgow, Scotland, July 2005), Springer-Verlag, Berlin, Heidelberg, Germany. [47] POTANIN,A., NOBLE,J., \nCLARKE,D., AND BIDDLE,R. Feath\u00aderweight Generic Con.nement. Journal of Functional Programming (2006). \nAccepted for publication. [48] POTANIN,A., NOBLE,J., CLARKE,D., AND BIDDLE, R. Feather\u00adweight generic \nownership. Tech. rep., Victoria University of Welling\u00adton, 2006. http://www.mcs.vuw.ac.nz/ alex/FGOTR. \npdf. [49] PUGH, B. Find Bugs A Bug Pattern Detector for Java. www.cs.umd.edu/ pugh/jva/bugs/, 2003. \n[50] SUN MICROSYSTEMS. Java Development Kit. Available at: http://java.sun.com/j2se/, 2005. [51] TALPIN,J.-P., \nAND JOUVELOT, P. Polymorphic type, region, and effect inference. Journal of Functional Programming 2, \n3 (July 1992), 245 271. [52] TOFTE,M., AND TALPIN, J.-P. Region-Based Memory Manage\u00adment. Information \nand Computation 132, 2 (1997), 109 176. [53] TORGERSON,M., ERNST,E., HANSEN,C. P., VON DER AHE\u00b4, P., \nBRACHA,G., AND GAFTER, N. Adding wildcards to the Java programming language. Journal of Object Technology \n3, 11 (Dec. 2004), 97 116. Special Issue: OOPS track at SAC 2004. [54] VITEK,J., AND BOKOWSKI, B. Con.ned \nTypes in Java. Software Practice &#38; Experience 31, 6 (May 2001), 507 532. [55] ZHAO,T., PALSBERG,J., \nAND VITEK, J. Type-Based Con.nement. Journal of Functional Programming 16, 1 (2006), 83 128.  \n\t\t\t", "proc_id": "1167473", "abstract": "Ownership types enforce encapsulation in object-oriented programs by ensuring that objects cannot be leaked beyond object(s) that <i>own</i> them. Existing ownership programming languages either do not support parametric polymorphism (type genericity) or attempt to add it on top of ownership restrictions. Generic Ownership provides per-object ownership on top of a sound generic imperative language. The resulting system not only provides ownership guarantees comparable to established systems, but also requires few additional language mechanisms due to full reuse of parametric polymorphism. We formalise the core of Generic Ownership, highlighting that only restriction of <i>this</i> calls and owner subtype preservation are required to achieve deep ownership. Finally we describe how Ownership Generic Java (OGJ) was implemented as a minimal extension to Generic Java in the hope of bringing ownership types into mainstream programming.", "authors": [{"name": "Alex Potanin", "author_profile_id": "81100005943", "affiliation": "Victoria University of Wellington, New Zealand", "person_id": "P668639", "email_address": "", "orcid_id": ""}, {"name": "James Noble", "author_profile_id": "81100588708", "affiliation": "Victoria University of Wellington, New Zealand", "person_id": "PP15036977", "email_address": "", "orcid_id": ""}, {"name": "Dave Clarke", "author_profile_id": "81100391212", "affiliation": "Centrum voor Wiskunde en Informatica, The Netherlands", "person_id": "PP18004849", "email_address": "", "orcid_id": ""}, {"name": "Robert Biddle", "author_profile_id": "81100135223", "affiliation": "Carleton University, Canada", "person_id": "PP14058058", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167500", "year": "2006", "article_id": "1167500", "conference": "OOPSLA", "title": "Generic ownership for generic Java", "url": "http://dl.acm.org/citation.cfm?id=1167500"}