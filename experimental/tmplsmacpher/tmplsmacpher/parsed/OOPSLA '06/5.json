{"article_publication_date": "10-16-2006", "fulltext": "\n JTL the Java Tools Language * Tal Cohen Joseph (Yossi) Gil Itay Maman Department of Computer Science \nTechnion Israel Institute of Technology Technion City, Haifa 32000, Israel ctal, yogi, imaman @ cs.technion.ac.il \nAbstract We present an overview of JTL (the Java Tools Language, pro\u00adnounced Gee-tel ), a novel language \nfor querying JAVA [8] pro\u00adgrams. JTL was designed to serve the development of source code software tools \nfor JAVA, and as a small language to aid program\u00adming language extensions to JAVA. Applications include \nde.ni\u00adtion of pointcuts for aspect-oriented programming, .xing type con\u00adstraints for generic programming, \nspeci.cation of encapsulation policies, de.nition of micro-patterns, etc. We argue that the JTL expression \nof each of these is systematic, concise, intuitive and gen\u00aderal. JTL relies on a simply-typed relational \ndatabase for program representation, rather than an abstract syntax tree. The underlying semantics of \nthe language is restricted to queries formulated in First Order Predicate Logic augmented with transitive \nclosure (FOPL*). Special effort was taken to ensure terse, yet readable expression of logical conditions. \nThe JTL pattern public abstract class, for example, matches all abstract classes which are publicly acces\u00adsible, \nwhile class { public clone(); } matches all classes in which method clone is public. To this end, JTL \nrelies on a DATALOG-like syntax and semantics, enriched with quanti.ers and pattern matching which all \nbut entirely eliminate the need for re\u00adcursive calls. JTL s query analyzer gives special attention to \nthe fragility of the closed world assumption in examining JAVA software, and determines whether a query \nrelies on such an assumption. The performance of the JTL interpreter is comparable to that of JQuery \nafter it generated its database cache, and at least an order of magnitude faster when the cache has to \nbe rebuilt. Categories and Subject Descriptors D.3.0 [Programming Lan\u00adguages]: General; D.2.3 [Software \nEngineering]: Coding Tools and Techniques General Terms Design, Languages Keywords Declarative Programming, \nReverse Engineering * Research supported in part by the IBM faculty award Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 06 October 22 26, 2006, Portland, Oregon, \nUSA. Copyright c . 2006 ACM 1-59593-348-4/06/0010. . . $5.00. 1. Introduction The designers of frontier \nprogramming paradigms and constructs often choose, especially when static typing is an issue, to test\u00adbed, \nexperiment, and even fully implement the new idea by an extension to the JAVA programming language. Examples \ninclude ASPECTJ [52], JAM [5], Chai [71], OpenJava [76], the host of type systems supported by pluggable \ntype systems [6], and many more. A prime component in the interaction of such an extension with the language \ncore is the mechanism for selecting program elements to which the extension applies: The pointcuts of \nASPECTJ, for example, select the point in the code on which an aspect is to be applied. Also, a key issue \nof implementing the conclusions of a genericity treatise [31,51] is checking whether a given set of classes \nare legible as parameters for a given generic construct what the community calls a concept. JTL (the \nJava Tools Language) is a declarative language, be\u00adlonging in the logic-programming paradigm, designed \nfor the task of selecting JAVA program elements. Two primary applications were in mind at the time when \nthe language was .rst conceived: (a) Join-point selection for aspect-oriented programming, where JTL \ncan serve as a powerful substitute of ASPECTJ s pointcut syntax, and,  (b) expressing the conditions \nmaking up concepts, and in particular multi-type concepts, for use in generic programming.  As JTL took \nshape and grew older it became clear it can be used not only for language extension, but also for other \nsoftware engi\u00adneering tasks, primarily as a tool to assist programmers understand the code they must \nmodify. This particular problem of program un\u00adderstanding even if it is far from being entirely solved \nby JTL, is dear to our hearts: First, software development activities in indus\u00adtry include (and probably \nmore and more so) the integration of new functionalities in existing code Second, maintenance remains \na ma\u00adjor development cost factor. JTL s focus is on the modules in which the code is organized, packages, \nclasses, methods, variables, including their names, types, parameters, accessibility level and other \nattributes. JTL can also in\u00adspect the interrelations of these modules, including questions such as which \nclasses exist in a given unit, which methods does a given method invoke, etc. Additionally, JTL can inspect \nthe imperative parts of the code by means of data.ow analysis. The extension of JTL to deal with with \ncontrol-.ow aspects of the code is left for further research. 1.1 Three Introductory Examples JTL syntax \nis terse and intuitive; just as in AWK [1], one-line programs are abundant, and are readily wrapped within \na single string. In many cases, the JTL pattern for matching a JAVA program element looks exactly like \nthe program element itself. For example, the JTL predicate1 public abstract void () matches all methods \n(of a given class) which are abstract, publicly accessible, return void and take no parameters. Thus, \nin a sense, JTL mimics the QueryByExample [80] idea. As in the logic paradigm, a JTL program is a set \nof predicate de.nitions, one of which is marked as the program goal. Even patterns which transcend the \nplain JAVA syntax should be understandable, e.g., abstract class { [long | int] field; no abstract method; \n } matches abstract classes in which there is a .eld whose type is either long or int and no abstract \nmethods. The .rst line in the curly brackets is an existential quanti.er ranging over all class members. \nThe second line in the brackets is a negation of an existential quanti.er, i.e., a universal quanti.er \nin disguise, applied to this range. JTL can also delve into method bodies, by means of intra\u00adprocedural \ndata.ow analysis, similar to that of the class .le veri.er. Consider for example cascading methods, i.e., \nmethods which can be used in a cascade of message sends to the same receiver, as in the following JAVA \nstatement (new MyClass()).f().g().h(); in which f, g and h are methods of MyClass. Then, the following \nJTL pattern matches all cascading methods: instance method { all [ !returned | this ]; } The curly brackets \nin the above pattern denote the set of values (including temporaries, parameters, constants, etc.) that \nthe method may generate or use. The statement inside the brackets is a requirement that all such values \nare either not returned by the method, or are provably equal to this,and therefore guarantees that the \nonly possible value that the method may return is this. 1.2 Applications The JTL interpreter (work on \nthe compiler is in progress) can be used in two ways: (i) as a stand-alone program; (ii) as a JAVA library, \nan API, to be called directly from within any JAVA program, in a manner similar to SQL . This API makes \nJTL useful in implementing not only language extensions (such as a pointcut evaluation engine for an \nAOP compiler), but also in various kinds of software engineering tools, including searches in programs \n[61], LINT-like tools [29, 48, 68], and pattern identi.cation [33]. JTL s ability to generate output \ntext based on matched program elements enables the use of JTL not only for search operations in programs, \nbut also for search-and-replace operations. A key appli\u00adcations for this ability is the context-aware \nrenaming of program elements [30]. The brevity of expression in JTL makes it suitable for inte\u00adgration \nas an interactive search language in an IDE. Also, a JTL con.guration .le can specify to a compiler program \nelements on which special optimization effort should be made, exclusion from warnings, etc. Thus, what \nmakes JTL unique as a tool for mak\u00ading tools , are its suitability for direct user interaction, and begin \na small language for con.guring other tools. To an extent, JTL resembles TCL [65], the general purpose \nTool Command Language, except that JTL concentrates on language processing. 1 The terms predicate and \npattern are used almost interchangeably; pattern usually refers to a unary predicate. In evaluating JTL \nsuitability for other applications we wrote several collections of JTL patterns, the two largest being \n(i) the implementation of the entire set of \u00b5-patterns developed by two of us [33] and (ii) the implementation \nof the entire set of Eclipse2 and PMD3 warning messages (with the exclusion of warnings per\u00adtaining to \nsource formatting and comments, since the current im\u00adplementation of JTL works on compiled classes). \nOther applica\u00adtions for which we used JTL included aspect pointcuts, and pre\u00adconditions for mixins and \ngenerics. An Eclipse plugin for running JTL queries over JAVA projects was implemented, and its performance \nwas compared with that of a similar plugin which uses JQuery [50] for querying JAVA code. 1.3 Underlying \nModel Underlying JTL is a conceptual representation of a program in a simply-typed relational database. \nThe JTL user can think of the interrogated JAVA program as a bunch of program elements stored in such \na database. JTL is declarative, sporting the simple and terse syntax and se\u00admantics of logic programming \nfor making database queries. JTL augments these with a number of enhancements that make it even more \nconcise and readable. Predicates are the basic programming unit. The language features a set of native \npredicates (whose im\u00adplementation is external to the language), with a library of pre\u00adde.ned predicates \nbuilt on top of the native ones. Many of the na\u00adtive and pre-de.ned predicates are conveniently named \nafter JAVA keywords. Thus, the scheme of this database is de.ned by the set of native JTL predicates. \nStandard library predicates and user-de.ned predicates, de.ned on top of the natives, can be thought \nof as database views or pre-de.ned queries. Interestingly, JAVA (and many other software systems) are \nbest modeled as in.nite databases. The reason is that in JAVA and in almost all programming languages, \none cannot hope to obtain all user code which uses a certain code-bit stored in a software library. Similarly, \nthe list of classes that inherit from a given class is un\u00adbounded. This is quite the opposite of traditional \ndatabase systems, which rely on a .nite, closed-world, model. The JTL processor analyzes the queries \npresented to it, deter\u00admining whether they are open-ended, i.e., the size of the result they return is \nunbounded. (In practice, only a .nite approximation of the in.nite database is stored. An open-ended \nquery can be thought as a query whose size increases inde.nitely with that of the approxi\u00admation.) Note \nthat this conceptual representation does not dictate any concrete representation for the JTL implementation. \nJTL is appli\u00adcable to several formats of program representation, ranging from program source code, going \nthrough AST representations, JAVA re\u00ad.ection objects, BCEL4 library entities, to strings representing \nthe names of program elements. In fact, JTL s JAVA API is character\u00adized by input-and output-data representation \n.exibility, in that JTL calls can accept and return data in a number of supported formats. We stress \nthat JTL can be implemented in principle on top of any source code parser, including the JAVA compiler \nitself. Two central concerns in the language design were scalability and the simpli.cation of the idiosyncracies \nof logic programming. We found, in accordance with the experience reported by Ha\u00adjiyev, Verbaere and \nMore with their CodeQuest system [44], that the underlying relational model, together with combinations \nof bottom-up and top-down evaluation strategies that DATALOG [17] makes possible, makes a major contribution \nto scalability. 2 http://www.eclipse.org 3 http://pmd.sourceforge.net 4 http://jakarta.apache.org/bcel \nFor the sake of elegance and brevity of expression, JTL features speci.c constructs for set manipulation, \nquanti.cation and other means that eliminate much of the need for loops (recursive calls in the logic \nprogramming world). As a result, unlike DATALOG and PROLOG [25] queries, JTL predicates are de.ned by \na single rule, written in a handful of lines, and often in a single line. Underlying JTL s syntax and \nsemantics is .rst order predicate logic with no function symbols and augmented with transitive clo\u00adsures, \ndenoted FOPL*. The .rst order logic represented by JTL is restricted to .nite structures (assuming a \ngiven database approxi\u00admation). An inherent dif.culty with FOPL** is that it allows one to make cyclic \nand senseless statements such as predicate p holds if and and only if the negation of p holds. . The \nlanguage pre\u00adprocessor therefore restricts queries to to DATALOG with strati.ed negation [77]. This allows \nus to be enjoy the theoretical advantages of the formalism, including modular speci.cation, polynomial \ntime complexity, and a wealth of query optimization techniques [39]. In\u00addeed, the JTL compiler under \ndevelopment will generate DATALOG output for an industrial-strength DATALOG engine. Nevertheless, our \nexperience indicates that strati.ed negation does not always suf.cient expressive power. Currently, the \nquery analyzer of JTL fails to deal with queries. As a result, some of the complex queries are not guaranteed \nto terminate. An interesting contribution of this work is in demonstrating that a simple query-by-example \nlike syntax is possible for many tasks of querying OO programs, and in showing that this syntax stands \non a solid theoretical ground. It may be possible to put together a JAVA\u00adlike syntax for JAVA queries \nin an ad hoc fashion. The challenge we took upon ourselves was the combination of the sound underlying \ncomputational model and the query-by-example front end. Also, in using a DATALOG-based model (and in \ncontrast with PROLOG as some other recent tools do) we achieve a termination guarantee, and the wealth \nof theory on database query optimization for concrete scalable implementation. SQL, and more generally, \nthe relational model was sometimes used for software query [72]. However, as Consents, Mendelian and \nRyan [22] observed, program analysis frequently requires transitive closure. This is the reason that \nJTL allows recursion, and is similar in its computational expressive power to Consents et al.\u00b4s Graphing \nsystem. As the name suggests, JTL is speci.c to JAVA. In particular, the bountiful class .le format of \nJAVA, its extensive documentation and the veri.cation process, made it possible to carry out the JTL \npro\u00adcessing on the binary-rather than on the source representation of a program. Such processing of binaries \nis not possible in languages such as C++ [73]. A port of JTL may therefore need to resort to less ef.cient \nand more intricate processing of the source code. Other issues involved in generalizing JTL ideas to \nother pro\u00adgramming languages and software model representations should become clearer with the more detailed \nexposition. It should be ev\u00adident for example, that the bulk of JTL can be easily adapted to C# [46]. \nThe most important non-portable part is the data.ow anal\u00adysis, which cannot be complete in C#. The reason \nis that unlike JAVA, the veri.cation process of C# is only partial. Outline Sec. 2 is a brief language \ntutorial, which shows how JTL can be used to inspect the non-imperative aspects of JAVA code, i.e., everything \nbut the method bodies. Queries of the imperative aspects of the code are the subject of Sec. 3. An explanation \nof the semantics is then presented in Sec. 4. Readers who are more interested in actual code may choose \nto leap directly to Sec. 5, which presents some more advanced applications and code samples. Sec. 6 compares \nthe performance of JTL with that of JQuery, a JAVA query tool which uses a similar underlying paradigm. \nSec. 7 elaborates further on the motivation, surveying existing systems and discusses potential applications. \nSec. 8 concludes.  2. The JTL Language This section gives a brief tutorial of JTL, assuming some basic \nfamiliarity with logic programming. The text refers only to the inspection of the non-imperative aspects \nof the software. The next section will build upon this description the mechanism for delving into method \nbodies. Readers interested more in the underlying semantics are encouraged to skip forward to Sec. 4, \nreturning here only for reference. The main issues to note here are the language syntax,in which aJAVA \nprogram element is matched by a JTL pattern which is very similar in structure to that element (see Sec. \n2.1), and the extensions to the logic paradigm, speci.cally, arguments list pat\u00adterns (Sec. 2.2), transitive \nclosure standard predicates (Sec. 2.3), and quanti.ers (Sec. 2.4) which make it possible to achieve many \nprogramming tasks without recursion. The two most important data types, what we call kinds,ofJTL are \n(i) MEMBER, which represents all sorts of class and interface members, including function members, data \nmembers, construc\u00adtors, initializers and static initializers; and (ii) TYPE, which stands for JAVA classes, \ninterfaces, and enums, as well as JAVA s primitive types such as int. Another important kind is SCRATCH, \nwhich, as the name sug\u00adgests, stands for a temporary value used or generated in the course of computation \nof a method. Scratches originate from a data.ow analysis of a method, and are discussed below at Sec. \n3. A JTL program is a set of de.nitions of named logical pred\u00adicates. Execution begins by selecting a \npredicate to execute as a query. As in PROLOG, predicate names start with a lower-case letter, while \nvariables and parameters names are capitalized. Identi.ers may contain letters, digits, or an underscore. \nAdditionally, the .nal characters of an identi.er name may be + (plus), * (asterisk), or  (single quote). \n2.1 Simple Patterns Many JAVA keywords are native patterns in JTL, carrying essen\u00adtially the same semantics. \nFor example, the keyword int is also a JTL pattern int, which matches either .elds of type int or methods \nwhose return type is int. The pattern public matches all public program elements, including public class \nmembers (e.g., .elds) and public classes. Henceforth, our examples shall use these keywords freely; no \nconfusion should arise. Not all JTL natives are JAVA keywords. A simple example is anonymous,de.ned on \nTYPE, which matches anonymous classes. Some patterns (like abstract) are overloaded, since they are applicable \nboth to types and members. Others are monomorphic, e.g., class is applicable only to TYPE. Another example \nis pattern type, de.ned only on TYPE,which matches all values of TYPE. This, and the similar pattern \nmember (de.ned on MEMBER) can be used to break overloading ambiguity. JTL has two kinds of predicates: \nnative and compound.Native predicates are predicates whose implementation is external to the language. \nIn other words, in order to evaluate native predicates, the JTL processor must use an external software \nlibrary accessing the code. Native patterns hence are declared (in a pre-loaded con.gu\u00adration .le) but \nnot de.ned by JTL. In contrast, compound patterns are de.ned by a JTL expression using logical operators. \nThe pattern public, int (2.1) matches all public .elds of type int and all public methods whose return \ntype is int.As in PROLOG, conjunction is denoted by a comma. In JTL however, the comma is optional; patterns \nseparated by whitespace are conjuncted. Thus, (2.1) can also be written as public int. As a matter of \nstyle, the JTL code presented henceforth denotes conjunction primarily by whitespace; commas are used \nmainly for readability breaking long conjugation sequences into subse\u00adquences of related predicates; \nDisjunction is denoted by a vertical bar, while an exclamation mark stands for logical negation. Thus, \nthe pattern public | protected | private matches JAVA program elements whose visibility is not default, \nwhereas !public matches non-public elements. Logical operators obey the usual precedence rules, i.e., \nnegation has the highest priority and disjunction has the lowest. Square parenthesis may be used to override \nprecedence, as in !private [byte|short|int|long] which matches non-private, integral-typed .elds and \nmethods. A pattern de.nition names a pattern. After making the following two de.nitions, integral := \nbyte | short | int | long; enumerable := boolean | char; the newly de.ned patterns, integral and enumerable, \ncan be used anywhere a native pattern can be, as in e.g., discrete := integral | enumerable Beyond the \nnatives, JTL has a rich set of pre-de.ned stan\u00addard patterns, including patterns such as integral, enumerable, \ndiscrete (as de.ned above), method, constructor (both with the obvious semantics), the predicate extendable \n:= !final type (matching classes and interfaces which may have heirs), predicate overridable := !final \n!static method (methods which may be overridden), and many more. 2.2 Signature Patterns Signature patterns \npertain to (a) the name of classes or members, (b) the type of members, (c) arguments list, (d) declared \nthrown exceptions, and (e) annotations (meta-data). Name Patterns A name pattern is a regular expression \npreceded by a single quote, or a previously-declared name. Standard JAVA regular expressions5 are used, \nexcept that the wildcard character is denoted by a question mark rather than a dot. Name literals and \nregular expressions are quoted with single quotes. The closing quote can be omitted if there is no ambiguity. \nFor example, void set[A-Z]?* method matches any void method whose name starts with set followed by an \nupper\u00adcase letter. If the name pattern does not contain any regular expression operators, as in toString_p \n:= toString method; (2.2) then the pattern can be made clearer by using a name statement to declare toString \nas a member name and get rid of the quote. Thus, an alternative de.nition of (2.2) is name toString; \n (2.3) toString_p := toString method; In truth, the above is redundant, since an implicit name statement \npre\u00addeclares all methods of the JAVA root class java.lang.Object. Type Patterns Type patterns make it \npossible to specify the JAVA type of a non-primitive class member. A type pattern is a regular expression \npreceded by a forward slash , e.g., pattern /java.util.?*/ method matches all methods with a return type \nfrom the java.util package or its sub-packages. The closing slash is optional. 5 as de.ned by java.util.regex.Pattern. \nThe distinction between type patterns and name patterns only makes sense for members. In matching types, \nthere is no such distinction, and both kinds of literals can be used. The forward slash is not necessary \nfor type names which were previously declared as such by a typename declaration. For exam\u00adple, typename \njava.io.PrintStream; (2.4) printstream_field := PrintStream field; matches any .eld whose type is java.io.PrintStream. \nThe typename statement in (2.4) declares java.io.Serializable as a name of a type, similarly to name \nstatement. All the types (including classes, interfaces and enumerations) declared in the java.lang package \nare pre-declared as type names, including Object, String, Comparable,and the wrapper classes (Integer, \nByte, Void,etc.). Here is a rede.nition of toString_p pattern (2.3), which ensures that the matched method \nreturns a String. toString_p := String toString method; (2.5) Arguments List Patterns JTL provides special \nconstructs which all but eliminate recursion. An important example is arguments list patterns, used for \nmatching against elements of the list of arguments to a method. (Internally, such lists are stored in \na linked list of elements of kind TYPE, using standard PROLOG-like head and tail relations.) The most \nsimple argument list is the empty list, which matches methods and constructors that accept no arguments. \nHere is a rewrite of (2.5) using such a list: toString_p := String toString(); (Note that the above \ndoes not match .elds, which have no argument list, nor constructors, which have no return type.) An asterisk \n( * ) in an arguments list pattern matches a se\u00adquence of zero or more types. Thus, the standard pattern \ninvocable := (*); matches members which may take any number of arguments, i.e., constructors and methods, \nbut not .elds, initializers, or static ini\u00adtializers. An underscore ( _ ) is a single-type wildcard, \nand can be used in either the argument list or in the return type. Hence, public _ (_, String, *); (2.6) \nmatches any public method that accepts a String as its sec\u00adond argument, and returns any type. (Again, \naonstructors fail to match (2.6), since they have no return type.) Other Signature Patterns There are \npatterns for matching the throws clause of the signature, e.g., io_method := method throws /java.io.IOException; \n There are also patterns which test for the existence or absence of speci.c annotations in a class, a \n.eld or a method, and for annotation values. For example, the following pattern will match all methods \nthat have the @Override annotation: @Override method These are not discussed here in detail further \nin respect of space limitations. 2.3 Variables It is often useful to examine the program element which \nis matched by a pattern. JTL employs variable binding, similar to that of PROLOG, for this purpose. For \nexample, by using variable X twice, the following pattern makes the requirement that the two arguments \nof a method are of the same type: firstEq2nd := method (X,X); Similarly, the pattern return_arg := RetType \n(*, RetType, *); matches any method whose return type is the same as the type of one of its arguments. \nPredicates Patterns are parameterless predicates. In general, it is possible to de.ne predicates taking \nany number of parameters. As usual in logic programming, parameters are nothing more than externally \naccessible variables. Consider for example the predicate is_static[C] := static field _:C; (2.7) which \ntakes parameter C. When invoked with a speci.c value for parameter C, pattern is_static matches only \nstatic .elds of that exact type. Conversely, if the predicate is invoked without setting a speci.c value \nfor C, then it will assign to C the types of all static .elds of the class against which it is matched. \nThe semantics by which a parameter to a predicate can be used as either input or output is standard in \nlogic programming; the different assignments to C are made by the evaluation engine. Note however that \nsince JTL uses a database-, DATALOG-like semantics, rather than the recursive evaluation engine of PROLOG, \neach type C satisfying (2.7) will show only once in the output, even if there two or more .elds of that \ntype. Native Predicates JTL has several native parameterized predi\u00adcates. The names of many of these \nare JAVA keywords. For exam\u00adple, predicate implements[I] holds for all classes which imple\u00adment directly \nthe parameter I (an interface). This is the time to note that the predicates implements[I] and is_static[C], \njust as all other patterns presented so far, have a hidden argument, the receiver, also called the subject \nof the pattern, which can be referenced as This or #. Other native predicates of JTL include members[M] \n(true when M is one of This s members, either inherited or de.ned), defines[M] (true when M is de.ned \nby This), overriding[M] (true when This is a method which overrides M), inner[C] (true when C is an inner \nclass of This), and many more. The following example shows how a reference to This is used to de.ne a \npattern matching what is known in C++ jargon as copy constructors : copy_ctor := constructor(T), T.members[This]; \n (2.8) This example also shows how a predicate can be applied to a subject which is not the default, \nby using a JAVA-like dot notation. The copy_ctor predicate works like this: .rst, the pattern constructor(T) \nrequires that the matched item, i.e., This,isa constructor, which accepts a single parameter of some \ntype T.Next, T.members[This] requires that This the matched constructor is a member of its argument type \nT, or in other words, that the constructor s accepted type is the very type that de.nes it. Literals, \njust as variables, can be used as actual parameters. For example, class implements[M] matches any class \nthat imple\u00adments interface M, whereas interface extends[/java.io.Serializable] matches any interface \nthat extends the Serializable interface. The square brackets in an invocation of a predicate with a single \nparameter are optional. The above could thus have also been written as: interface extends /java.io.Serializable \n Moreover, since there is a clear lexical distinction between parame\u00adters and predicates, even the dot \nnotation is not essential for chang\u00ading the default receiver. Thus, copy_ctor := constructor(T), T members \nThis; is equivalent to (2.8). Standard Predicates JTL also has a library of standard predi\u00adcates, many \nof which are de.ned as transitive closure of the native predicates. Fig. 2.1 shows a sample of these. \nFigure 2.1 Some of the standard predicates of JTL inherits[M] := members[M] !defines[M]; container[C] \n:= C.members[This]; precursor[M] := M.overriding[This]; implementing[M] := !abstract, overriding[M] \nM.abstract; abstracting[M] := abstract, overriding[M] !M.abstract; extends+[C] := extends[C] | extends[C \n] C .extends+[C]; extends*[C]:= C is This | extends+[C]; interfaceof[C] := C.class C.implements[This]; \ninterfaceof+[C] := C.implements+[This]; interfaceof*[C] := C.implements*[This]; The .gure makes apparent \nthe JTL naming convention by which the re.exive transitive closure of a predicate p is named p*, while \nthe anti-re.exive variant is named p+. The myriad of recursive def\u00adinitions such as these saves much \nof the user s work; in particular it is rare that the programmer is required to employ recursion. It \nis interesting to examine the recursive de.nition of one of these predicates, e.g., extends+: extends[C] \n| extends[C ] C .extends+[C] It may appear at .rst that with the absence of a halting condition, the \nrecursion will never terminate. A moment s thought reveals that this is not the case. Since JTL uses \na bottom-up construction of facts, starting at a .xed database, the semantics of this recursive de.nition \nis not of stack-based recursive calls, but rather as dy\u00adnamic programming, or work-list, approach for \ngenerating facts. Predicate Name Aliases The name extends+ suggests that it is used as a verb connecting \ntwo nouns. As mentioned above, we can even write C extends+ C But, the same predicate can be used in \nsituations in which, given aclass C, we want to generate the set of all classes that it extends. A more \nappropriate name for these situations is ancestors.It is possible to make another de.nition ancestors[C] \n:= extends+[C]; To promote meaningful predicate names, JTL offers what is known as predicate name aliases, \nby which the same predicate de.nition can introduce more than one name to the predicate. Aliases are \nwritten as an de.nition annotation which follows the main rule The de.nition of extends+ has such an \nalias extends+[C] := extends C| extends C , C .extends+[C]; Alias ancestors; The use for an alias named \nancestors will become clear with the presentation of predicate (2.10) below. Native predicates can also \nhave aliases, which are speci.ed along with their declaration.  2.4 Queries As mentioned previously, \nJTL s expressive power is that of FOPL*. Although it is possible to express universal and existential \nquanti.\u00adcation with the constructs of logic programming, we found that the alternative presented in this \nsection is more natural for the particu\u00adlar application domain. Consider for example the task of checking \nwhether a JAVA class has an int .eld. A straightforward, declarative way of doing that is to examine \nthe set of all of the class .elds, and then check whether this set has a .eld whose type is int. The \nfollowing pattern does precisely this, by employing a query phisticated mechanism that JTL uses for inspecting \nmethod bodies mechanism: is through a data.ow analysis, as described in Sec. 3.3. has_int_field := class \nmembers:{ exists int field; (2.9)  3.1 Abstract Syntax Trees and JTL }; Here, the query members:{ \nQ1; \u00b7\u00b7\u00b7 ; Qn } generates .rst the set of all possible members M, such that #.members[M] holds. (The members: \nportion of the query is called the generator.) This set is then passed to Q1 through Qn,the quanti.ers \nem\u00adbedded in the curly brackets. The entire query holds if all of these quanti.ers hold for this set. \nIn (2.9), there was only one quanti.er: the JTL statement exists int field is an existential quanti.er \nwhich holds when\u00adever the given set has an element which matches the pattern int field. The next example \nshows two other kinds of quanti.ers. class ancestors: { all public; (2.10) no abstract; }; The evaluation \nof this pattern starts by computing the generator. In this case, the generator generates the set of all \nclasses that the receiver extends directly or indirectly, i.e., all types C for which #.ancestors[C] \nholds. (Recall that ancestors is an alias for extends+, de.ned above.) The .rst quanti.er checks whether \nall members of this set are public. The second quanti.er succeeds only if this set contains no abstract \nclasses. Thus, (2.10) matches classes whose superclasses are all public and concrete. Quanti.ers in JTL \ninclude also, many p holds if the queried set has two or more elements for which pattern p holds; whereas \none p holds if this set has precisely one such element. The existential quanti.er is the most common; \nhence the exists is optional. Also, a missing generator (in predicates whose subject is a TYPE) defaults \nto the members: generator. Hence, a concise rewrite of (2.9) is has_int_field := class { int field; (2.11) \n}; In the two examples shown here, the generator was a predicate with a single named parameter and an \nimplicit receiver. In such cases, the generator generates a set of primitive values, which are the possible \nassignments to the argument. However, in general, the generator generates a relation of named tuples, \nand the quanti.ers are applied to the set of these tuples. We discuss the underlying semantics of queries \nin greater detail in Sec. 4.  3. Queries of Imperative Code The executional aspect of JAVA code remained \nbeyond the descrip\u00adtion of JTL in the previous section. This aspect is primarily method bodies, but also \nother imperative code, including constructors, .eld initializers and static initializers. Now that the \nbulk of the language syntax is described, we can turn to the question of queries of imperative entities.Toanextent, \nqueries of these entities are mostly a matter of library design rather than a language design. Recall \nthat JTL native predicates are imple\u00admented as part of the supporting library that the JTL processor \nuses for inspecting JAVA code. Extending this library, without changing the JTL syntax, can increase \nthe search capabilities of the language. Sec. 3.1 shows how by adding a set of native predicates, JTL \ncan be extended to explore an abstract syntax tree representation of the code. This section also explains \nwhy this extension was not implemented yet. We chose instead to implement a pedestrian set of natives \nthat make it possible to explore the .elds and methods that executional code uses, as described in Sec. \n3.2. The more so-Executional code can be represented by an abstract grammar, with non-terminal symbols \nfor compound statement such as if and while, for operations such as type conversion, etc. One could even \nthink of several different such grammars, each focusing on a different perspective of the code. Code \ncan be represented by an abstract syntax tree whose struc\u00adture is governed by the abstract grammar. To \nlet JTL support such a representation, we can add a new kind, NODE, and a host of native relations which \nrepresent the tree structure. For example, a native binary predicate if can be used to select if statement \nnodes and the condition associated with it; a binary predicate then can se\u00adlect the node of the statement \nto be executed if the if condition holds; another binary predicate, else, may select the node of the \nstatement of the other branch, etc. As an example of an application for such a representation, consider \na search for cumbersome code fragments such as if (C) return true; else return false; with the purpose \nof recommending to the programmer to write return C; instead. The following pattern matches such code: \nboolean_return_recommendation := if[_] then[S1] else[S2], S1.return[V1], S2.return[V2], V1.literal[\"true\"], \nV2.literal[\"false\"]; The above pattern should be very readable: we see that its receiver must be a NODE \nwhich is an if statement, with a don t-care condi\u00adtion (i.e., _), which branches control to statements \nS1 and S2;also both S1 and S2 must be return statements, returning nodes V1 and V2 respectively. Moreover, \nthe patterns requires that nodes V1 and V2 are literal nodes, the .rst being the JAVA true literal, the \nsecond a false. In principle, such a representation can even simultaneously sup\u00adport more than one abstract \ngrammar. Two main reasons stood be\u00adhind our decision not to implement, or even de.ne (at this stage), \nthe set of native patterns required for letting JTL explore such a representation of the code. 1. Size. \nAbstract grammars of JAVA (just as any other non-toy language) tend to be very large, with tens and hundreds \nof non\u00adterminal symbols and rules. Each rule, and each non-terminal symbol, requires a native de.nition, \ntypically more than one. The effort in de.ning each of these is by no means meager. 2. Utility. Clearly, \nan AST representation can be used for repre\u00adsenting the non-imperative aspects of the code. The experience \ngained in using the non-AST based representation of JTL for exploring these aspects, including type signatures, \ndeclaration modi.ers, and the interrelations between classes, members and packages, indicated that the \nabstraction level offered by an ab\u00adstract syntax tree is a bit too low at times.  A third, (and less \ncrucial) reason is that it is not easy (though not infeasible) to elicit the AST from the class .le, \nthe data format used in our current implementation. 3.2 Pedestrian Code Queries In studying a given \nclass, it is useful to know which methods use which .elds. The following JTL pattern, for example, implements \none of Eclipse s warning situations, in which a private member is never used. unused_private_member := \nprivate field, This is F, declared_in C, C inners*:{ all !access[F]; } The pattern fetches the class \nC that de.nes the .eld, and then uses the re.exive and transitive closure of the inner relation, to examine \nC, its inner classes, their inner classes, etc., to make sure that none of these reads or writes to this \n.eld. (The uni.cation (This is F) is for making the receiver .eld accessible inside the curly brackets.) \nThe pattern access showing in the penultimate line of the example is de.ned in the JTL library. The de.nition, \nalong with some of the other standard patterns that can be used in JTL for what we call pedestrian code \nqueries is shown in Fig. 3.1. Such queries model the method body as an unordered set of byte-code instructions, \nchecking whether this set has certain instructions in it. Figure 3.1 Standard predicates for pedestrian \ncode queries access[F] := read F | write F; Alias accesses; read[F] := offers M, M read F; Alias reads; \nwrite[F] := offers M, M read F; Alias writes; calls[M] := invokes_interface[M] | invokes_virtual[M] \n| invokes_static[M] | invokes_special[M]; Alias invokes, invoke; use[X] := access[M] | invoke[M]; Alias \nuses; In the .gure we see that the de.nition of access is based on the overloaded predicates read and \nwrite. The native predicate read[F] (respectively write[F]) holds if the receiver is a method whose code \nreads (respectively writes to) the .eld F. The second (respectively the third) line of the .gure, overloads \nthe native def\u00adinition of read (respectively write), so that it applies also to re\u00adceivers whose kind \nis TYPE. The .gure also makes uses of the four other pedestrian natives for inspecting code: invokes_interface, \ninvokes_virtual, invokes_static,and invokes_special. (These natives also have aliases identical to the \nbytecode mnemonics.) With this minimal set of six natives, several interesting patterns can be de.ned. \nFor example, predicate creates[T] := invokes_static[M], M.ctor, M.declared_in[T]; is true when the receiver \ncreates an object of type T. Also, the following predicates test whether a method re.nes its precursor \nrefines[M] := overrides[M] invokes_special[M]; refines := refines[_]; Alias refiner; The following predicate \nchecks whether a method is not empty does_something := !void | invokes[_] | writes[_]; (If a method \ndoes not return a value, does not invoke any other method, nor write to a .eld, then it must have no \nmeaningful effect.) With the above, we implemented an interesting PMD rule, signalling an unnecessary \nconstructor, i.e., the case that there is only one constructor, it is public, has an empty body, and \ntakes no arguments. unnecessary_constructor := class { constructor => public () !does_something; } \n The following predicate identi.es a case that a constructor calls another constructor C of class T. \nc_call[C,T] := constructor invokes_special[C] C.constructor C.declared_in[T] With this predicate, we \ncan present three rules which identify the different ways that a constructor may begin its mission in \nJAVA. c_delegation[C] := // First line is this(...) declared_in[MyClass] c_call[C,MyClass]; c_refinement[C] \n:= // First line is super(...) declared_in[MyClass] c_call[C,Parent], MyClass.extends[Parent]; c_handover[C] \n:= // Either ctor_delegation[C] | ctor_refinement[C];  3.3 Data.ow Code Queries As a substitute to AST \nqueries and at a higher level of abstrac\u00adtion than the pedestrian queries, stand data.ow code queries. \nIn the course of execution of imperative entities many temporary values are generated. Data.ow analysis \nstudies the ways that these values are generated and transferred. The idea is similar to data.ow anal\u00adysis \nas carried out by an optimizing compiler [2, Sects. 10.5 10.6], or by the JAVA bytecode veri.er [55, \nSec. 4.92]. 3.3.1 Scratches for Data.ow Analysis To implement data.ow analysis, we introduce a new JTL \nkind, SCRATCH, which represents what is called in the compiler lingo a variable de.nition , i.e., an \nassignment to a temporary variable. In JAVA we .nd two categories of temporary variables on what is called \na method frame : 1. A location in the local variables array , including the loca\u00adtions reserved in this \narray for method parameters, and in par\u00adticular the this parameter of instance methods, as well as local \nvariables that an imperative entity may de.ne.6 2. A location in the operands stack , used for storing \ntemporary variables in the course of the computation.  As usual with data.ow analysis, there is a fresh \nscratch for each assignment to a temporary variable. Also, scratches are generated on a merge of control \n.ow. A scratch is anonymous; it does not carry with it its location in the frame. An assignment to a \nscratch can be from one of the following sources: another scratch, an input parameter value, a constant, \na .eld, a value returned from a method or a code entity, an arithmeti\u00adcal operation, or a thrown exception. \nA scratch can be assigned to another scratch, passed as a parameter, assigned to a .eld, thrown or returned. \nThe data.ow analysis is implemented at the class .le level. Obviously, this can only be done with a non-optimizing \ncompiler, which makes a lossless translation of the source data.ow into an equivalent data.ow of the \nintermediate or target language. Luckily, the standard JAVA compiler obeys this requirement. It should \nbe clear that the data.ow information and analysis we carry is also feasible by starting from the source \nlevel, generating temporaries for all intermediate values. On the other hand, it should be noted that \nJAVA semantics and tradition also helped in making our data.ow analysis more effec\u00adtive; among the contributing \nfactors we can mention the tendency to use short methods, the requirement that all locals are initialized \nbefore they are uses, call-by-value semantics, no pointer arithmetic, our decision to ignore arrays, \netc. 6 Note that the veri.cation process guarantees that we can treat two adjacent locations which are \nused for storing a long or double variables. 3.3.2 Using Scratches The following pattern, capturing \nthe authors understanding of the notion of setter, gives a quick taste of the manner of using data .ow \ninformation in JTL. setter := void instance method(_) !calls[_] { putfield[_,_] => parameter; one putfield[_,_]; \n putfield[_,Ref] Ref.this. no [ putstatic[_] | get[_] | compared ]; }; The .rst line in the above \nrequires that the receiver is a void instance method, taking a single parameter, and (by using a pedestrian \npredicate) that it calls no other methods. The predicates in the curly brackets make the following requirements \nin order: (i) all assignments to a .eld are of a scratch that is provably equal to the single parameter \nof the method; (ii) there is precisely one assignment to an instance .eld in the method; (iii) this assignment \nis to a .eld using an object reference which is provably equal to the this implicit parameter of the \nmethod; and that (iv) there are no assignments to a static .eld, nor .eld retrievals, nor a comparison \nin the method. The example shows that the formulation of data .ow require\u00adments is not so simple. Moreover, \nthe precise notion of a setter is debateable. We argue that JTL s terse, English-like syntax, aug\u00admented \nwith the natural coding of work-list algorithms in the logic paradigm, help in quick testing and experimenting \nwith patterns such as the above. Data.ow analysis is a large topic, and its application in JTL involves \nabout three dozens of predicates. We can only give here a touch of the structure of JTL s predicates \nlibrary and the patterns that can be written with it. Tab. 1 lists the essential native unary predicates \nde.ned on scratches. The predicates are obtained by a standard (conservative) data.ow analysis similar \nto that of the veri.er does. Thus, predicate parameter holds for all scratches which are provably equal \nto a parameter, nonnull for temporaries which are provably non-null, etc. Table 1. Native unary predicates \nof scratches Predicate Meaning parameter a method parameter stored in the LVA constant a constant null \nthe null constant nonnull cannot be the null constant temp an operand-stack scratch this equal to parameter \n0 of an instance method local an (uninitialized) automatic variable in the LVA returned returned by the \ncode athrow thrown by the code caught obtained by catching an exception compared compared in the code \n The native binary predicate scratches[S] (also aliased as has_scratch) holds if S is a scratch of the \nmethod This,and serves as the default generator of methods. Hence, the curly brack\u00adets in the pattern \ninstance method { returned => this; } iterate over all scratches of a given method, checking that \nevery scratch returned by the method is equal to the this parameter. Also, the binary predicate typed[T] \nholds if T is the type of the scratch # (This). The following pattern returns the set of all types that \na method uses: use_types[T] := method has_scratch[S] S.typed[T]; The most important predicate connecting \nscratches is from[S], which holds if scratch S is assigned to scratch #. Similarly, func[S] holds if \n# is computed by an arithmetical computation. We also have the de.nition depend[S] := func[S] | from[S]; \nAs usual, from*, func* and depend* denote the re.exive transi\u00adtive closure of from, func and depend. \nThere is also a native predicate for each of the four bytecode in\u00adstructions used for accessing .elds. \nFor example, the binary predi\u00adcate putstatic[F] holds if the scratch # is assigned to static .eld F, \nwhile getfield[F,S] holds if # is retrieved from .eld F with scratch S serving as object reference. In \naddition, there are two predicates for each of the instruc\u00adtions for method calling, e.g., a predicate \ninvokespecial[M,S] holds if scratch # is used as an argument to a call of method M, where scratch S serves \nas the receiver, and a predicate get_invokestatic[M] which holds if # obtains its value from a static \ncall to method M. For a given scratch there is typically more than one S, such that from[S],or from*[S] \nholds 7. Dealing with this multiplicity of data.ow analysis is natural to DATALOG programming. For exam\u00adple, \npattern dead identi.es dead scratches, i.e., scratches whose values are never used: unassigned := !put[_] \n! [ _.from[#] | _.func[#] | ...etc. ]; dead := !compared unassigned ; The following predicate selects \nall sources of values that may be assigned to a scratch: origins[S] := from*[S], [ S.parameter | S.constant \n| S.get[_] ]; In words, origins[S] holds if S is a port of entry of an external value which may eventually \nbe assigned to #. We can now write a pattern which determines whether a method returns a constant. constant_method \n:= method { one returned; returned => origins: { all constant; } } Using an overloaded version of \nfrom[X] which holds if # obtains its value either from a .eld X or from a call to method X,it is mundane \nto extend the above pattern to match also method returning a final .eld. It should also be obvious that \ndata.ow analysis provides enough information so that the implementation of pattern capturing, say, a \ngetter notion, or even the selection of .elds, is not too dif.cult. The native predicate locus[S] holds \nif S and # are distinct scratches which are stored in the same location on the frame. This predicate \nis used in Fig. 3.2, together with dead and unassigned in a bunch of predicates which implement several \nPMD advices. . Figure 3.2 Implementation of some PMD warnings with scratches changed_parameter := parameter \nlocus[_]; multiple_returns := method returns: { many;}; null_assignment := from[C], C.null; unread_parameter \n:= dead parameter; flag_parameter := unassigned compared parameter; unassigned_local := local locus: \n{ empty }; unused_local := dead local; 7 other than in linear methods, i.e., methods whose control .ow \ncontains no branch statements  4. Underlying Semantics As stated above, JTL belongs to the logic programming \nparadigm. This section explains how the JTL constructs are mapped to famil\u00adiar notions of the paradigm. \nIn a nutshell, JTL is a simply typed formalism whose underlying semantics is .rst order predicate logic \naugmented with transitive closure (FOPL*). Evaluation in JTL is similar to that of PROLOG (more precisely, \nDATALOG), with its built-in support for the join and project operations of relational databases. This \nsection elab\u00adorates the language semantics a bit further. Kinds and Predicates The type system of JTL \nconsists of a .xed .nite set of primitive kinds (types) T. There are no compound kinds. A predicate is \na boolean function of T1 \u00d7\u00b7\u00b7\u00b7 \u00d7 Tn, n = 0, where Ti .T for i =1,...,n. A predicate can also be thought \nof as a relation, i.e., a subset of the cartesian product T1 \u00d7\u00b7\u00b7\u00b7\u00d7Tn, called the domain of the predicate. \nBy convention, the .rst ar\u00adgument of a predicate is unnamed, while all other arguments are named. The \nunnamed arguments is called the receiver or the sub\u00adject. Native Predicates JTL has a number of native \npredicates, such as class a unary predicate of TYPE, i.e., class . TYPE, synchronized . MEMBER (the predicate \nwhich holds only for synchronized methods), members . TYPE \u00d7 MEMBER, extends . TYPE \u00d7 TYPE (with the \nobvious seman\u00adtics), and the 0-ary predicates false (an empty 0-ary relation) and true (a 0-ary relation \nconsisting of a single empty tuple). Built-in predicates are called in certain communities Extensional \nDatabase (EDB) predicates. A run of the JTL processor starts by loading a declaration of ar\u00adity and argument \ntypes of all native predicates from a con.guration .le. Native declarations are nothing more than de.nitions \nwithout body. For example, the following commands in a con.guration .le MEMBER.int; states that int is \na unary predicate such that int . MEMBER. Compound Predicates Conjunction, disjunction and negation can \nbe used to de.ne compound predicates from the built-ins. Also permitted, are quanti.cation as explained \nin Sec. 2 and transitive closure, i.e., recursion as in extends+[X] := extends X| extends[Y] Y.extends+[X]; \n The language offers an extensive library of pre-de.ned of stan\u00addard compound predicates. Compound predicates \nare sometimes called Intensional Database (IDB) predicates. Finite Databases To run, a JTL program requires \na database which conforms to the natives, i.e., it must have in its schema the relations or the EDBs \nas dictated by the set of natives de.ned by the JTL implementation at hand. The simplest way to supply \na database is by specifying to the JTL processor a .nite set of classes and methods, e.g., a .jar .le. \nObviously, such a collection does not directly represent any EDBs. EDBs are realized on top of the collection \nby means of a bytecode analysis library. Alternatively, a .nite database can also be provided by supply\u00ading \na .nite set of legal JAVA source .les. The native relations are then realized on top of these by a JAVA \nparser. JTL queries can also be run without a .xed input set. Such a situation, can be thought of as \na DATALOG query over an in.nite database. Evaluation Order Unlike PROLOG, the order of evaluation in \nJTL is unimportant. The output set of a pattern is the same re\u00adgardless of the order by which its constituent \npredicates in it are invoked. Predicates have no side-effects, and all computations (on .nite databases) \nterminate. The simplest way to compute the output set is bottom-up, i.e., by using a work-list algorithm \nwhich uses the program rules to compute all tuples in all IDBs used by the program goal. This process, \nalthough guaranteed to terminate, can be very time-and space-inef.cient. JTL instead analyzes queries \nand applies, when\u00adever possible, a more ef.cient top-down evaluation strategy Overloading and Kind Inference \nThe JTL processor includes a kind inference engine which, based on the kind of arguments and arity of \nthe native predicates, infers arity and arguments kinds of predicates de.ned on top of these. For example, \nthe de.nition real := double | float; (4.1) implies that real . MEMBER. JAVA s overloading of keywords \ncarries through to JTL, e.g., since the JAVA keyword final can be applied to classes and mem\u00adbers, the \nbuilt-in predicate final in JTL is overloaded, denoting two distinct relations: final1 . TYPE and final2 \n. MEMBER. Many native predicates are similarly overloaded; JTL infers over\u00adloading of compound predicates. \nFor example, the conjunction of final and public is overloaded; the conjunction of final and interface \nis not. The Default Receiver As seen in the last examples, JTL sports an implicit mechanism of applying \na predicate to receiver. For example, the above de.nition of real could have been written as real := \n#.double |#.float; (4.2) Named Arguments The signature of a relation is an or\u00addered pair (R,A), whose \n.rst component, R .T,de.nes the type of the receiver, while the second component, A = {(e1,A1),...(em,Am)}, \nde.nes the names of the arguments (the labels ej, j =1,...,m, must be distinct) and their types (Aj .T \nfor j =1,...,m). A row of a relation is in general a named tuple, i.e., a tuple of values, where all \nbut the .rst carrying labels, such that the types of these values and the labels they carry match exactly \nthe signature of the predicate. Predicates are characterized by signature, e.g., the signature of () \npredicate members is TYPE,{( M ,MEMBER)}, while the de.ni\u00adtion container[C] := C.members[#] implies \n() MEMBER,{( C ,TYPE)} as the signature of container. Overloaded predicates have mul\u00adtiple signatures, \none for each meaning. For example, the built-in ()() predicate final has two signatures, MEMBER,\u00d8and \nTYPE,\u00d8. Baggage In addition to the receiver and to the named parameters, every JTL predicate has another \nhidden output parameter. The term baggage is used for this parameter since its computation is done behind \nthe scenes, without programmer intervention, and further, in many cases it is eliminated by the JTL processor. \nThe baggage parameter is always of kind STRING, and it de\u00adfaults, in most predicates, to the predicate \nname. So, the returned baggage of the predicate public is simply the string \"public\", the baggage of \na regular expression matching the name of a .eld or amethod is thenameofthat class member. Also, by default, \nthe baggage a conjunction is the concatena\u00adtion of the components baggage, in the order these component \nap\u00adpear. The returned baggage of predicate public int is therefore the string \"public int\". The default \nbaggage of most other con\u00adstructs for making compound predicates is simply the empty string. Although \nin principle, a programmer may override the baggage value, and even check it, current support for doing \nso in JTL is minimal. Set Expressions JTL extends logic programming with what we call a query, which \nis a predicate whose evaluation involves the generation of a temporary relation, and then applying various \nset expressions (e.g., quanti.ers) to this relation. A query predicate is true if all the set conditions \nhold for the generated temporary relation. The predicate de.ned in Fig. 4.1 tries to check that a class \nis classical , i.e., that it has at least one .eld, two or more methods, that all methods are public, \nall .elds are private, that there are no static .elds or methods, and that the sets of setters and getters \nof this class are disjoint. Figure 4.1 A JTL predicate for matching classical class notion. classical \n:= class members:{ has field; many method; no static; method => public; field => private; disjoint \nsetter, getter; } (The de.nition in the .gure assumes that predicates setter and getter were previously \nde.ned.) The essence of the example is the generator of the temporary relation, written as members:. \nThe colon character (:) appended to predicate members makes it into a generator. JTL generates the set \nof all members M, such that #.members[M] holds. This set, which can be also thought of as a relation \nwith only one unnamed column, is subjected to the set expressions inside the curly brackets. Six conditions \nare applied to this set: the .rst is an existential quanti.er (has is synonymous to exists) requiring \nthat at least one element in the generated set satis.es the field condition, i.e., that the class has \nat least one .eld. The second condition similarly requires that method holds to two more members. The \n3rd condition, as should be obvious, requires that this set does not contain any static members. The \n4th condition is a set expression requiring that the predicate method implies public holds in this set, \ni.e., that method members are public. The 5th condition similarly states that the set of field members \nis a subset of the set of private members. Finally, the set expression disjoint setter, getter requires \nthat the two subsets obtained by applying predicates setter and getter to the set of class members are \ndisjoint. 5. Applications Having presented the JTL syntax, the language s capabilities and its underlying \nsemantics, we are in a good position to describe some of the applications. 5.1 Integration in CASE Tools \nand IDEs In their work on JQuery, Janzen and De Volder [50] make a strong case, including empirical evidence, \nfor the need of a good software query tool as part of the development environment. As detailed below \nin Sec. 7.1 and demonstrated by Tab. 2, the querying (but not the navigational) side of JQuery can be \nreplaced and simpli.ed by JTL. We have developed an Eclipse plug-in that runs JTL queries and presents \nthe result in a dedicated view. Fig. 5.1 shows an example: the program (which appears above the results) \nfound all classes in JAVA s standard library for which instances are obtained using a static method rather \nthan a constructor. Using JTL, many searches can be described intuitively. For example, to .nd all classes \nthat share a certain annotation @X, the developer simply searches for @X class. The similarity between \nJTL syntax and JAVA declarations will allow even developers who are new to JTL to easily and effectively \nsift through the overwhelming number of classes and class members in the various JAVA libraries. JTL \ncan also be used to replace the hard-coded .ltering mecha\u00adnism found in many IDEs (e.g., a button for \nshowing only public members of a class) with a free-form .lter. Fig. 5.2 is a mock screenshot that shows \nhow JTL can be used for .ltering in Eclipse. Finally, JTL can be used for search-and-replace operations. \nSince the operation is context-sensitive, there is no risk of, e.g., changing text that appears in comments. \nWith the current version of JTL, this is limited to changing class and method signatures, and is therefore \nless powerful than Eclipse s built-in refactoring facilities. However, unlike these facilities, the changes \nthat JTL allows are open-ended and not limited to a pre-de.ned set of operations. For example, the following \nJTL program will make every method called getLock() synchronized, without changing any other part of \nthe method s signature: !synchronized getLock() [* synchronized #sig *] Currently, JTL has only rudimentary \nsupport for program transforma\u00adtion. In particular, as explained above, every JTL predicate returns a \nbag\u00adgage string which can be used for producing output. This returned value, may be used to generate \na replacement program fragment, although JTL does not offer still means for ensuring that it is indeed \nsyntactically valid string. By default, this returned string is the predicate name. As shown above, the \nconstruct [* S *],where S is a string expression can be used to change this default. In the example the \nreturned value is the string synchronized #sig,where sig is a library predicate that returns the member \ns signature as a valid JAVA source fragment. 5.2 Specifying Pointcuts in AOP The limited expressive \npower of the pointcut speci.cation language of ASPECTJ (and other related AOP languages, e.g., CAESAR \n[59] and ASPECTJ2EE [21]), has been noted several times in the litera\u00adture [42, 64]. We propose that \nJTL is integrated into AOP processors, tak\u00ading charge of pointcut speci.cation. To see the bene.ts of \nusing a JTL component for this purpose, consider the following ASPECTJ pointcut speci.cation: call(public \nvoid *.set*(*)); JTL s full regular expressions syntax can be used instead, by .rst de.ning setter := \npublic void set[A-Z]?* (_); (5.1) and then writing call(setter). Unlike the ASPECTJver\u00adsion, (5.1) uses \na proper regular expression, and therefore does not erroneously match a method whose name is, e.g., settle(). \nFig. 5.3 presents an array of ASPECTJ pointcuts trapping read and write operations of primitive public \n.elds. Not only tedious, it is also error prone, since a major part of the code is replicated across \nall de.nitions. Figure 5.3 An ASPECTJ pointcut de.nition for all read-and write-access operations of \nprimitive public .elds. get(public boolean *) || set(public boolean *)|| get(public byte *) || set(public \nbyte *)|| get(public char *) || set(public char *)|| get(public double *)||set(public double *)|| get(public \nfloat *)||set(public float *)|| get(public int *) || set(public int *)|| get(public long *) || set(public \nlong *)|| get(public short *)||set(public short *); By using disjunction in JTL expressions, the ASPECTJ \ncode from Fig. 5.3 can be greatly simpli.ed if we allow pointcuts to include JTL expressions: primitive \n:= boolean | byte | char | double | float | int | long | short; ppf := public primitive field; get(ppf) \n|| set(ppf); // JTL-based AspectJ pointcut The ability to name predicates, speci.cally ppf in the example, \nmakes it possible to turn the actual pointcut de.nition into a con\u00adcise, readable statement. The following \nis an example of a condition that is impossible to specify in ASPECTJ: setter := public void set[A-Z]?* \n(_); boolean_getter = boolean is[A-Z]?* (); other_getter = !boolean !void get[A-Z]?* (); getter := public \n [boolean_getter | other_getter]; field_in_plain_class := public field, declare_in[C], C.members:{ \nno getter; no setter; }; Condition field_in_plain_class holds for public .elds in a class which has \nno getters or setters. This requirement is realized by predicate container, which captures in C the container \nclass. A query is then used to examine the other members of the class. The above could have been implemented \nin other extensions of the ASPECTJ pointcut speci.cation language, but not without a loop or a recursive \ncall. Our contribution puts the expressive power of JTL at the dis\u00adposal of ASPECTJ and other aspect \nlanguages, replacing the some\u00adtimes ad-hoc pointcut de.nition language with JTL s systematic ap\u00adproach. \nThere are two limitations in doing that: First, JTL can only be used to make queries on the program static \nstructure, and not on the dynamic control .ow. The second limitation is more technical: although JTL \nqueries can be easily made from an JAVA program, there is no suf.cient API for the client code to intervene \nin the parsing process, pass error messages, etc. 5.3 Concepts for Generic Programming In the context \nof generic programming, a concept is a set of con\u00adstraints which a given set of types must ful.l in order \nto be used by a generic module. As a simple example, consider the following C++ template: template<typename \nT> class ElementPrinter { public: void print(T element) { element.print(); } } The template assumes \nthat the provided type parameter T has a method called print which accepts no parameters. Viewing T as \na single-type concept [31,74], we say that the template presents an implicit assumption regarding the \nconcept it accepts as a parame\u00adter. Implicit concepts, however, present many problems, including hurdles \nfor separate compilation, error messages that Stroustrup et al. term of spectacular length and obscurity \n[74], and more. With Java generics, one would have to de.ne a new interface interface Printable { void \nprint(); }; and use it to con.ne the type parameter. While the concept is now explicit, this approach \nsuffers from two limitations: .rst, due to the nominal subtyping of JAVA, generic parameters must explicitly \nimplement interface Printable; and second, the interface places a baggage constraint on the return type \nof print, a constraint which is not required by the generic type. Using JTL, we can express the concept \nexplicitly and without needless complications, thus: (class | interface) { print(); }; There are several \nadvantages for doing that: First, the underlying syntax, semantics and evaluation engine are simple and \nneed not be re-invented. Second, the JTL syntax makes it possible to make useful de.nitions currently \nnot possible with JAVA standard gener\u00adics and many of its extensions. The problem of expressing concepts \nis more thorny when mul\u00adtiple types are involved. A recent work [31] evaluated genericity support in \n6 different programming languages (including JAVA,C# and EIFFEL [49]) with respect to a large scale, \nindustrial strength, generic graph algorithm library, reaching the conclusion that the lack of proper \nsupport for multi-type concepts resulted in awkward designs, poor maintainability, and unnecessary run-time \nchecks. JTL predicates can be used to express multi-type concepts, and in particular each of the concepts \nthat the authors identi.ed in this graph library. As an example, consider the memory_pool concept, which \nis part of the challenging example the concepts treatise used by Garcia et al. A memory pool is used \nwhen a program needs to use several objects of a certain type, but it is required that the number of \ninstantiated objects will be minimal. In a typical implementation, the memory pool object will maintain \na cache of unused instances. When an object is requested from the pool, the pool will return a previously \ncached instance. Only if the cache is empty, a new object is created by issuing a create request on an \nappropriate factory object. More formally, the memory pool concept presented in Fig. 5.4 takes three \nparameters: E (the type of elements which comprise the pool), F (the factory type used for the creation \nof new elements), and This (the pool type). Figure 5.4 The memory_pool concept name create, instance, \nacquire, release; factory[E] := (class | interface){ public constructor (); public E create(); }; \nmemory_pool[F,E] := equals[T] { public static T instance(); public E acquire(); public release(E); }, \nF.factory[E]; The body of the concept requires that This will provide acquire() and release() methods \nfor the allocation and deallocation (respectively) of E objects, and a static instance() method to allow \nclient code to gain access to a shared instance of the pool. Finally, it requires (by invoking the Factory \npredicate) that F provides a constructor with no arguments, and a create() method that returns objects \nof type E. As shown by Garcia et al., the requirements presented in Fig. 5.4 have no straightforward \nrepresentation in JAVA,C# or EIFFEL.In particular, using an interface to express a concept presents ex\u00adtraneous \nlimitations, such as imposing a return type on release, and it cannot express other requirements, such \nas the need for a zero-arguments constructor in a factory. Using an interface also limits the applicable \ntypes to those that implement it, whereas the concept itself places no such requirement. In a language \nwhere JTL concept speci.cations are supported, a generic module parameterized by types X, Y and Z can \ndeclare, as part of its signature, that X.memory_pool[Y,Z] must hold. This will ensure, at compile-time, \nthat X is a memory pool of Z elements, using a factory of type Y8. Concepts are not limited to templates \nand generic types. Mix\u00adins, too, sometimes have to present requirements to their type pa\u00adrameter. The \nfamous Undo mixin example [5] requires a class that de.nes two methods, setText and getText, but does \nnot de\u00ad.ne an undo method. The last requirement is particularly impor\u00adtant, since it is used to prevent \naccidental overloading.However, it cannot be expressed using JAVA interfaces. The following JTL predicate \nclearly expresses the required concept: undo_applicable := class { setText(String); String getText(); \n no undo(); }; In summary, we propose that in introducing advanced support of genericity and concepts \nto JAVA, one shall use the JTL syntax as the underlying language for de.ning concepts. In addition to \nthe two bene.ts listed above (simple semantics and evaluation, useful de.nitions not possible in standard \nJAVA), using JTL also puts intriguing questions of type theory in the familiar domain of logic, since, \nas mentioned earlier, JTL is based on FOPL*. For example, the question of one concept being contained \nin another can be thought of as logical implication. Using text book results [15], one can better understand \nthe tradeoff between language expressiveness and computability or decidability. We are currently working \non de.ning a JTL sub-language, restricting the use of quanti.ers, which assures decidability of concept \ncontainment. 8 Thus, concepts may be regarded as the generic-programming equivalence of the Design by \nContract [58] philosophy 5.4 Micro Patterns A \u00b5-pattern is just like a design pattern, except that it \nis mechan\u00adically recognizable. Previous work on the topic [33] presented a catalog of 27 such patterns; \nthe empirical work (showing that these patterns matched about 3 out of 4 classes) was carried out with \na custom recognizer. To evaluate JTL, we used it to re-code each of the patterns. Fig. 5.5 shows the \nJTL encoding of the Trait pattern (somewhat similar to the now emerging traits OO construct [69]). In \na nutshell, a trait is a base class which provides pre-made behavior to its heirs, but has no state. \nThe code in Fig. 5.5 should make the details of the pattern obvious: A trait is an abstract class with \nno instance .elds, at least one abstract method, and at least one public concrete instance method which \nwas not inherited from Object. Figure 5.5 The Trait \u00b5-pattern trait := abstract { no instance field; \n abstract method; public concrete instance method !declared_in[Object]; } A programming language researcher \ncould type in the pattern of Fig. 5.5 to quickly .nd out how many classes in a certain program base are \ncandidates to be implemented as traits. This example also demonstrates how queries simplify the code. \nThe equivalent PROLOG predicate would have required three recursive calls, probably with the use of auxiliary \npredicates to implement the three quan\u00adti.ers in the query. All patterns were similarly implemented; \nthe speci.cation was never longer than 10 lines. In the course of doing so, we were able to quickly detect \nambiguities in the initial textual de.nition, and check the correctness of the ad-hoc recognizers. 5.5 \nLINT-like tests. JTL can be used to express, and hence detect, many undesired pro\u00adgramming constructs \nand habits. On the one hand, JTL s limitation with regard to the inspection of method bodies implies \nthat it cannot detect everything that existing tools [29, 48, 68] can. In its current state, as discussed \nin Sec. 3.1, JTL cannot detect constructs such as if (C) return true else return false; nor can it easily \nexpress numeric limitations (e.g., detecting classes with more than k methods for some constant k). Yet \non the other hand, JTL s expressiveness makes it easy for developers and project managers to improvise \nand quickly de.ne new rules that are both enforceable and highly self-documenting. To test this prospect, \nwe a collection of JTL patterns that im\u00adplement the entire set of warnings issued by Eclipse and PMD \n(a popular open source LINT tool for JAVA). The only exceptions were those warnings that directly rely \non the program source code (e.g., unused import statements), as these violations are not rep\u00adresented \nin the binary class .le, that we used. For example, consider the PMD rule LOOSECOUPLING.It de\u00adtects cases \nwhere the concrete collection types (e.g., ArrayList or Vector) are used instead of the abstract interfaces \n(such as List) for declaring .elds, method parameters, or method return values in violation of the library \ndesigners recommendations. This rule is expressed as a 45-lines JAVA class, and includes a hard\u00adcoded \n(yet partial) list of the implementation classes. PMD does make a heroic effort, but it will mistakenly \nreport (e.g.) .elds of type Vector for some alien class Vector which is not a collec\u00adtion, and was declared \noutside of the java.util package. The JTL equivalent is: loose_coupling := (class|interface){ T method \n| T field | method(*,T, *); }, T implements /java.util.Collection; It is shorter, more precise, and \nwill detect improper uses of any class that implements any standard collection interface, without providing \nan explicit list. 5.6 Additional Applications Several other potential uses for JTL include encapsulation \npolicies and con.ned types, among others. Encapsulation policies were suggested by Scharli et al. [70] \nas a software construct for de.ning which services are available to which program modules. Using JTL, \nboth the selection of services (methods) and the selection of modules (classes) can be more easily expressed. \nCon.ned types [14] are another example in which JTL could Figure 6.1 JTL queries q1 and q2. C.q1 holds \nif C declares a public static method whose return type is C; C.q2 holds if one of the super-classes of \nC is abstract and, in addition, C declares a toString() method and an equals() method. q1 := eq[T] declares: \n{ public static T(*); }; q2 := extends+ :{ abstract ;} declares : { public String toString() ; public \nboolean equals(Object) ; }; 20 be used, provided of course that con.nement is represented in a form \nof annotation. We have not yet investigated the question of 15 checking the imperative restrictions of \ncon.ned types with JTL.  6. Performance The JTL implementation is an ongoing project involving a team \nof several programmers. The main challenge is in providing robust and ef.cient execution environment \nthat can be easily integrated into JAVA tools. The current implementation, which is publicly available \nat http://www.cs.technion.ac.il/jtl, is an interpreter supporting the language core, including top-down \nevaluation. It does not yet include a complete implementation for some of the more advanced features \ndescribed earlier, and defers some of the type checking to runtime. Work is in progress for a JTL compiler \nwhich will translate a JTL program into an equivalent DATALOG program. The DATALOG code can then be processed \nby an industrial-strength DATALOG en\u00adgine. State of the art DATALOG research (see e.g., BDDBDDB [78] \nachieves signi.cant performance, which may bene.t JTL as well. The current implementation uses JAVA s \nstandard re.ection APIs for inspecting the structure of a class, and the Bytecode En\u00adgineering Library \n(BCEL) for checking the imperative instructions found within methods. The code spans some 150 JAVA classes \nthat make up a JTL parser, an interpreter, and the implementation of the native predicates that are the \nbasis for JTL s standard library. On top of this infrastructure there is a text based interactive environment \nthat allows the user to query a given jar .le, and an Eclipse plugin that signi.cantly enhances Eclipse \ns standard search capabilities. Naturally, other application can be easily developed by using JTL s programmatic \ninterface (API). We will now turn to the evaluation of the performance of this implementation. Our test \nmachine had a single 3GHz Pentium 4 processor with 3GB of RAM, running Windows XP. All JAVA programs \nwere compiled and run by Sun s compiler and JVM, version 1.5.0 06. In the .rst set of measurements, we \ncompared the time needed for completing the evaluation of two distinct JTL queries, q1 and q2, de.ned \nin Fig. 6.1. Each of the two queries was executed over six increasingly larger inputs, formed by selecting \nat random 1,000, 4,000, 6,000, 8,000, 10,000 and 12,000 classes from the JAVA standard library, version \n1.5.0 06, by Sun Microsystems. The running time of q1 and q2 on the various inputs are shown on Fig. \n6.2. Examining the .gure, we see that execution time, for the given programs, is linear in the size of \nthe input. The .gure may also suggest that runtime is linear in program size, but this conclusion cannot \nbe true in general, since there are programs of constant size whose output is polynomially large in the \ninput size.  Time (sec) 10 5 0 Figure 6.2 Execution time of a JTL program vs. input size. q2 q1 0 \n5,000 10,000 #Classes The absolute times are also quite reasonable. For example, it took just about 10 \nseconds to complete the evaluation of program q1 on an input of 12,000 classes. Overall, the average \nexecution rate for program q1 was 1,250 classes per second. In the second set of measurement we compared \nJTL s Eclipse plugin with that of JQuery. In a similar manner to JTL, JQuery also tries to harness the \npower of declarative, logical programming to the task of searching in programs, but (unlike JTL) JQuery \nexpressions are written in a PROLOG-like notation. Another difference between these two systems relates \nto the evaluation scheme: JQuery uses a bottom-up algorithm for the eval\u00aduation of predicates. As explained \nin Sec. 4, a bottom-up approach is far from being optimal since it needlessly computes tuples and relations \neven if they cannot be reached from the given input. Speci.cally, JQuery initialization stage, where \nit extracts facts the from all classes of the program took more than four minutes on a moderate size \nproject (775 classes), which is two orders of a magnitude slower than JTL s initialization phase. Also \nthe .rst invocation of an individual JQuery query is roughly ten times slower than the corresponding \ntime in JTL. Therefore, in order to make the comparison fair to JQuery, we broke a user s interaction \nwith the querying system into a sequence of six distinct stages (de.ned in Fig. 6.3) and compared the \nperformance of JQuery vs. JTL on a stage-by-stage basis. When running the JTL sessions we used the query \nq1 de.ned earlier. In the JQuery sessions we used query q1 (from Fig. 6.4) which is the JQuery equivalent \nof q1. We timed the JTL and the JQuery sessions on the Eclipse projects representing the source of two \nopen-source programs: JFreeChart9 (775 classes) and Piccolo10 (504 classes). The sizes of these projects, \nin number of classes, are 775 and 504 (respectively). 9 http://www.jfree.org/jfreechart 10 http://www.cs.umd.edu/hcil/jazz \nFigure 6.3 The sequence of stages used for benchmarking. Init. One-time initialization  Run1. First \nexecution of the query  Run2. Second execution of the query.  Update. Updating of the internal data-structure \nfollowing a slight modi.cation of the source .les.  Run3. Third execution of the query.  Run4. Fourth \nexecution of the query.  Figure 6.4 The JQuery equivalent of query q1. Holds for classes C that declare \na public static method whose return type is C. method(?C,?M), returns(?M,?C), q1 . modifier(?M,static), \nmodifier(?M,public) The speedup ratio of JTL over JQuery is presented in Fig. 6.5. The .gure shows that \nJTL is faster in the Init, Run1 and Update Init Run1 Run2 Update Run3 Run4 stages. JTL is about 100 \ntimes faster than JQuery at the Init stage, and about 25 times faster at the Run1 stage. JTL was just \nslightly faster in Run3, while JQuery was slightly faster in the Run2 and Run4 stages. As for space ef.ciency, \nwe predict that a bottom-up evaluator will be less ef.cient, compared to a top-down evaluator. In par\u00adticular, \nwe note that running JQuery searches on subject programs larger than 3,000 classes exhausted the memory \nof the benchmark machine. JTL, on the other hand, was able to process a 12,000\u00adclasses project.  7. \nDiscussion and Related Work Tools and research artifacts which rely on the analysis of pro\u00adgram source \ncode are abundant in the software world, including metrics [20] tools, reverse-engineering [10], smart \nCASE enhance\u00adments [47], con.guration management [11], architecture discov\u00adery [37], requirement tracing \n[38], AOP) [53], software porting and migration [54], program annotation [3], and many more. The very \ntask of code analysis per se is often peripheral to such products. It is therefore no wonder that many \nof these gravitate to\u00adward the classical and well-established techniques of formal lan\u00adguage theory, \nparsing and compilation [2]. In particular, software is recurringly represented in these tools in an \nAST. JTL is different in that it relies of a .at relational model, which, as demonstrated in Sec. 7.2, \ncan also represent an AST. (Curiously, there were recently two works [36, 56] in which relational queries \nwere used in OO software engineering; however, these pertained to program execution trace, rather than \nto its static structure.) JTL aspires to be a universal tool for tool writers, with applica\u00adtions such \nas speci.cation of pointcuts in AOP, the expression of type constraints for generic type parameters, \nmixin parameters, se\u00adlection of program elements for refactoring, patterns discovery, and more. The community \nhas already identi.ed the need for a general\u00adpurpose tool or language for processing software. The literature \ndescribes a number of such products, ranging from dedicated lan\u00adguages embedded into larger systems to \nattempts to harness exist\u00ading languages (such as SQL or XQUERY [13]) to this purpose. Yet, despite the \nvast amount of research invested in this area, no single industry standard has emerged. A well-known \nexample is REFINE [67], part of the Software Re.nery Toolset by Reasoning Systems. With versions for \nC, FORTRAN ,COBOL and ADA [75], Software Re.nery gener\u00adated an AST from source code and stored them in \na database for later searches. The AST was then queried and transformed us\u00ading the REFINE language, which \nincluded syntax-directed pattern matching and compiled into COMMON LISP, with pre-and post\u00adconditions \nfor code transformations. This meta-development tool was used to generate development tools such as compilers, \nIDEs, tools for detecting violations of coding standards, and more. Earlier efforts include Gandalf [43], \nwhich generated a devel\u00adopment environment based on language speci.cations provided by the developers. \nThe generated systems were extended using the ARL language, which was tree-oriented for easing AST manipula\u00adtions. \nOther systems that generated database information from pro\u00adgrams and allowed user-developed tools to \nquery this data included the C Information Abstractor [19], where queries were expressed in the INFOVIEW \nlanguage, and its younger sibling C++ Information Abstractor [40], which used the DATASHARE language. \nA common theme of all of these, and numerous others (includ\u00ading systems such as GENOA [26], TAWK [41], \nPonder [9], AST-Log [24], SCRUPLE [66] and more) is the AST-centered approach. In fact, AST-based tools \nbecame so abundant in this .eld that a recent such product was entitled YAAB, for Yet Another AST Browser \n[7]. Another category of products is contains those which rely on a relational model. For example, the \nRigi [60] reverse en\u00adgineering tool, which translates a program into a stream of triplets, where each \ntriplet associates two program entities with some rela\u00adtion. Sec. 7.1 compares JTL syntax with other \nsimilar products. Sec. 7.2 then says a few words on the comparison of relational\u00adrather than an AST-model, \nfor the task of queering OO languages. 7.1 Using Existing Query Languages Reading a poem in translation \nis like kissing your lover through a handkerchief. H. N. BIALIK (1917) Many tools use existing languages \nfor making queries. YAAB, for example, uses the Object Constraint Language, OCL, by Ra\u00adtional Software, \nto express queries on the AST; the Software Life Cycle Support Environment (SLCSE) [72] is an environment\u00adgenerating \ntool where queries are written in SQL; Rigi s triples representation is intended to be further translated \ninto a relational format, which can be queried with languages such as SQL and PROLOG;etc. BDDBDDB [78] \nis similar to JTL in that it uses DATALOG for analyzing software. It is different from JTL in that it \nconcentrates on the speci.c objective of code optimization, e.g., escape analysis, and does not further \nabstract the underlying language. However, the scope of the two for making optimization related analysis. \nA more modern system is XIRC [27], where program meta-data is stored in an XML format, and queries are \nexpressed in XQUERY. The JAVA standard re.ection package (as well as other bytecode analyzers, such as \nBCEL) generate JAVA data structures which can be manipulated directly by the language. JQuery [50] underlying \nis aPROLOG-based extension of Eclipse that allows the user to make queries. Finally, ALPHA [64] promotes \nthe use of PROLOG queries for expressing pointcuts in AOP. We next compare queries made with some of \nthese languages with the JTL equivalent. Fig. 7.1(a) depicts an example (due to the designers of XIRC) \nof using XQUERY to .nd Enterprise JavaBeans (EJB) which im\u00adplement finalize(), in violation of the EJB \nspeci.cation. Figure 7.1 Eichberg et. al [27] example: search for EJBs that implement finalize in XIRC \n(a) and JTL (b). subtypes(/class[ @name=\"javax.ejb.EnterpriseBean\"]) /method[ @name = \"finalize\" and \n.//returns/@type = \"void\" and not(.//parameter) ] (a) XIRC implementation of the query (from [27]). \nclass implements /javax.ejb.EnterpriseBean { public void finalize(); }; (b) The JTL equivalent of (a). \nIn inspecting the .gure, we .nd that in order to use this language the programmer must be intimately \nfamiliar not only with the XQUERY language, but also with the details of the XIRC encoding, e.g., the \nnames of attributes where entity names, return type, and parameters are stored. A tool developer may \nbe expected to do this, probably after climbing a steep learning curve, but its seems infeasible to demand \nthat an IDE user will interactively type a query of this sort to search for similar bugs. The JTL equivalent \n(Fig. 7.1(b)) is a bit shorter, and perhaps less foreign to the JAVA programmer. Fig. 7.1 demonstrates \nwhat we call the abstraction gap,which occurs when the syntax of the queries is foreign to the queried \nitems. We next compare JTL syntax with that of JQuery [50], which also relies on Logic programming for \nmaking source code queries. Tab. 2 compares the queries used in JQuery case study (extraction of the \nuser interface of a chess program) with their JTL counter\u00adparts. The table shows that JTL queries are \na bit shorter and resem\u00adble the code better. The JTL pattern in the last row in is explained by the following: \nTo .nd a method in which one of the type of parameters contains a certain word, we do a pattern match \non its argument list, allowing any number of arguments before and after the argument we seek. The desired \nargument type itself is a regular expression. The ASPECTJ sub-language for pointcut de.nition, just as \nthe sub-language used in JAM [5] for setting the requirements for the base class of a mixin, exhibit \nminimal abstraction gap. The challenge that JTL tries to meet is to do achieve this objective with a \nmore general language. Fig. 7.2 is an example of using JAVA s re.ectionAPIs toim\u00adplement a query here, \n.nding all public final methods (in a given class) that return an int. When compared with Fig. 7.1, we \ncan observe three things: Figure 7.2 Eliciting public .nal int methods with the re.ection library. public \nMethod[] pufim_reflection(Class c) { Vector<Method> v = new Vector<Method>(); for (Method m : c.getMethods()) \n{ int mod = m.getModifiers(); if (m.getReturnType() == Integer.Type &#38;&#38; Modifiers.isPublic(mod) \n&#38;&#38; Modifiers.isFinal(mod)) v.add(m); } return v.toArray(new Method[0]); }  Fig. 7.2 uses JAVA \ns familiar syntax, but this comes at the cost of replacing the declarative syntax in Fig. 7.1 with explicit \ncontrol .ow.  Despite the use of plain JAVA, Fig. 7.2 manifests an abstraction gap, by which the pattern \nof matching an entity is very different from the entity itself.  The code still assumes familiarity \nwith an API; it is unreason\u00adable to expect an interactive user to type in such code.  Again, the JTL \nequivalent, public final int(*), is concise, avoids complicated control .ow, and minimizes the abstraction \ngap. We should also note that the fragility of a query language is in direct proportion to the extent \nby which it exposes the structure of the underlying representation. Changes to the queried language (i.e., \nJAVA in our examples), or deepening the information extracted from it, might dictate a change to the \nrepresentation, and conse\u00adquently to existing client code. By relying on many JAVA keywords as part of \nits syntax, the fragility of JTL is minimal. There are, however, certain limits to the similarity, the \nmost striking one being the fact that in JTL, an absence of a keyword means that its value is unspeci.ed, \nwhereas in JAVA, the absence of e.g., static means that this attribute is off. This is expressed as !static \nin JTL. Another interesting comparison with JTL is given by consid\u00adering ALPHA and Gybels and Brichau \ns [42] crosscut language, since both these languages rely on the logic paradigm. Both lan\u00adguages were \ndesigned solely for making pointcut de.nitions (Gy\u00adbels and Brichau s work, just as ours, assumes a static \nmodel, while ALPHA allows de.nitions based on execution history). Itis no won\u00adder that both are more \nexpressive in this than the reference AS-PECTJ implementation. Unfortunately, in doing so, both languages \nbroaden rather than narrowtheabstractiongapof ASPECTJ.Thisisaresultofthestrict adherence to the PROLOG \nsyntax, which is very different than that of JAVA. Second, both languages make heavy use of recursive \ncalls, potentially with cuts , to implement set operations. Third, both languages are fragile in the \nsense described above We argue that even though JTL is not speci.c to the AO do\u00admain, it can do a better \njob at specifying pointcuts. (Admittedly, dynamic execution information is external to our scope.) Beyond \nthe issues just mentioned, by using the .xed point-model of com\u00adputation rather than backtracking, JTL \nsolves some of the open is\u00adsues related to the integration of the logic paradigm with OO that Gybels, \nBrichau, and Wuyts mention [16, Sec. 5.2]: The JTL API supports multiple results and there is no backtracking \nto deal with.  7.2 AST vs. Relational Model We believe that the terse expression and the small abstraction \ngap offered by JTL is due to three factors: (i) the logic programming paradigm, notorious for its brevity, \n(ii) the effort taken in making the logic programming syntax even more readable in JTL, and (iii) the \nselection of a relational rather than a tree data model. Task JQuery JTL Finding class BoardManager \n class(?C,name,BoardManager) class BoardManager Finding all main methods method(?M,name,main) method(?M,modifier,[public,static]) \npublic static main(*) Finding all methods taking a parameter whose type contains the string image method(?M,paramType,?PT) \nmethod(?PT,/image/) method(*,/?*image?*/,*) Table 2. Rewriting JQuery examples [50] in JTL We now try \nto explain better the third factor. Examining the list of tools enumerated early in this section we see \nthat many of these rely on the abstract syntax tree metaphor. The reason that ASTs are so popular is \nthat they follow the BNF form used to de.ne languages in which software is written. ASTs proved useful \nfor tasks such as compilation, translation and optimization; they are also attractive for discovering \nthe architecture of structured programs, which are in essence ordered trees. We next offer several points \nof comparison between an AST based representation and the set-based, relational approach repre\u00adsented \nby JTL and other such tools. Note that as demonstrated in Sec. 7.2, and as Crew s ASTLog language [24] \nclearly shows, logic programming does not stand in contradiction with a tree represen\u00adtation.) 1. Unordered \nSet Support. In traditional programming paradigms, the central kind of modules were procedures, which \nare sequential in nature. In contrast, in JAVA (and other OO languages) a recurring metaphor is the unordered \nset, rather than the sequence: A program has a set of packages, and there is no speci.c ordering in these. \nSimilarly, a package has a set of classes, a class is characterized by a set of attributes and has a \nset of members, each member in turn has a set of attributes, a method may throw a set of exceptions, \netc. Although sets can be supported by a tree structure, i.e., the set of nodes of a certain kind, some \nprogramming work is required for set manipulation which is a bit more natural and intrinsic to relational \nstructures. On the other hand, the list of method arguments is sequential. Although possible with a relational \nmodel, ordered lists are not as simple. This is why JTL augments its relational model with built-ins \nfor dealing with lists, as can be seen in e.g., the last row of Tab. 2). 2. Recursive Structure. One \nof the primary advantages of an AST is its support for the recursive structures so typical of struc\u00adtured \nprogramming, as manifested e.g., in Nassi-Shneiderman di\u00adagrams [62], or simple expression trees. Similar \nrecursion of program information is less common in mod\u00adern languages. JAVA does support class nesting \n(which are repre\u00adsented using the inners predicate of JTL) and methods may (but rarely do) include a \nde.nition of nested class. Also, a class cannot contain packages, etc. 3. Representation Granularity. \nEven though recursively de.ned ex\u00adpressions and control statements still make the bodies of OO meth\u00adods, \nthey are abstracted away by our model.  JTL has native predicates for extracting the parameters of a \nmethod, its local variables, and the external variables and methods which it may access, and as shown, \neven support for data.ow analysis. In contrast, ASTs make it easier to examine the control structure. \nAlso, with suitable AST representation, a LINT-like tool can pro\u00advide warnings that JTL cannot, e.g., \na non-traditional ordering of method modi.ers. It should be said that the importance of analyzing method \nbodies in OO software is not so great, particularly, since OO methods tend to be small [20], and in contrast \nwith the procedural approach, their structure does not reveal much about software architecture [37]. \nAlso, in the OO world, tools are not so concerned with the algo\u00adrithmic structure, and architecture is \nconsidered to be a graph rather than atree[47]. 4. Theory of Searches. Relational algebra, SQL, and DATALOG \nare only part of the host of familiar database searching theories. In contrast, searches in an AST require \nthe not-so-trivial VISITOR design pattern, or frameworks of factories and delegation objects (as in the \nPolyglot [63] project). This complexity is accentuated in languages without multi-methods or open classes \n[18] but occur even in more elaborate languages. Moreover, some questions of attribute grammars (which \nare essentially what generates AST) are very dif.cult, e.g., EXPTIME-complete [79]. 5. Data Model Complexity. \nAn AST is characterized by a variety of kinds of nodes, corresponding to the variety of syntactical ele\u00adments \nthat a modern programming language offers. A considerable mental effort must be dedicated for understanding \nthe recursive re\u00adlationships between the different nodes, e.g., which nodes might be found as children \nor descendants of a given node, what are the possible parent types, etc.  The underlying complexity \nof the AST prevents a placement of a straightforward interface at the disposal of the user, be it a pro\u00adgrammatic \ninterface (API), a text query interface or other. For ex\u00adample, in the Hammurapi11 system, the rule Avoid \nhiding inher\u00adited instance .elds is implemented by more than 30 lines of JAVA code, including two while \nloops and several if clauses. The cor\u00adresponding JTL pattern is so short it can be written in one line: \nclass { field overrides[_] } The terse expression is achieved by the uniformity of the relational structure, \nand the fact that looping constructs are implicit in JTL queries. The JTL code in this example is explained \nas follows: The outer curly paren\u00adthesis implicitly loop over all class members, .nding all .elds among \nthese. The inner ones implicitly loop over all members that this .eld overrides . A match (i.e., a rule \nviolation) is found if the inner loop is not empty, i.e., there exists one element in the set for which \nthe boolean condition true holds. 6. Representation Flexibility. A statically typed approach (as in Jamoos \n[34]) can support the reasoning required for tasks such as iteration, lookup and modi.cation of an AST. \nSuch an approach yields a large and complex collection of types of tree nodes. Con\u00adversely, in a weakly-typed \napproach (as in REFINE), the complexity of these issues is manifested directly in the code. Either way, \nchanges in the requirements of the analysis, when re.ected in changes to the kind of information that \nan AST stores, often require re-implementation of existing code, multiplying the complex reasoning toll. \nThis predicament is intrinsic to the AST structure, since the search algorithm must be prepared to deal \nwith all possible kinds of tree nodes, with a potentially different behavior in different such nodes. \nTherefore, the introduction of a new kind of node has the potential of affecting all existing code. 11 \nhttp://www.hammurapi.org In contrast, a relational model is typically widened by adding new relations, \nwithout adding to the basic set of simple types. Such changes are not likely to break, or even affect \nmost existing queries. 7. Caching and Query Optimization. There is a huge body of solid work on query \noptimization for relational structures; the research on optimizing tree queries, e.g., XPATH queries, \nhas only begun in recent years. Also, in a tree structure, it is tempting to store sum\u00admarizing, cached \ninformation at internal nodes a practice which complicates the implementation. In comparison, the well \nestab\u00adlished notion of views in database theory saves the manual and con\u00adfusing work of caching.  8. \nConclusions and Further Research JTL is a novel, DATALOG-based query language designed for querying JAVA \nprograms in binary format. The JTL system can be extended to query programs written in other programming\u00adlanguages \n(C#,SMALLTALK [35]), possibly in a different input formats. Such extensions require mostly a rewrite \nthe standard li\u00adbrary of native predicates to be replaced with new native predicates which are made to \ninspect the input at-hand. We note that the detection of scratch values relies on JAVA s veri.cation \nprocess which guarantees certain properties, of the data.ow graph, in every legal method. Therefore, \nthe use of scratch-related predicates over a languages that has a weaker veri\u00ad.cation process, such as \nC#, is limited. Even though termination is always guaranteed (on a .nite database) as long as negation \nis strati.ed, it is a basic property of FOPL*that other questions are undecidable. For example, it fol\u00adlows \nfrom G\u00a8odel s incompleteness theorem that it is impossible in general to determine e.g., if two queries \nare equivalent, a query is always empty, the results of one query is contained in another, etc. These \nlimitations are not a major hurdle for most JTL applications. Moreover, there are textbook results [15] \nstating that such ques\u00adtions are decidable, with concrete algorithms, if the use of quan\u00adti.ers is restricted, \nas could be done for certain applications. Still, we believe there is an interesting research challenge \nin stretching the limitations on the use of negation. One reason for trying to do so is that several \nclassical data.ow analysis problems exhibit non\u00adstrati.ed negation semantics, if expressed in JTL. JTL \nsports, whenever possible, a top-down evaluation strategy. Therefore, the amount of information seen \nby JTL s runtime\u00adsystem during a predicate evaluation is related to the output size and not by the size \nof the full database. Indeed, in many practical situations, the size of the input is signi.cantly smaller \nthan the size of the domain. For example, when a programmer looks for a class in his source directories, \nthe input is the set of classes found in these directories, where the database may consist of thousands \nor more classes, including e.g., JAVA s standard runtime library. Thanks to top-down evaluation, the \nprogrammer is not penalized for the size of the libraries his program uses. Moreover, the JTL processor \nincludes a query analyzer, (whose description is beyond the scope of this paper) which determines if \na given query is open or close . Intuitively, a query is closed if in computing it, JTL does not need \nto inspect classes beyond what a JAVA compiler would do. In other words, in the course of processing \nof a given query, JTL needs only inspect the classes ex\u00adplicitly mentioned in this query or passed to \nits as parameters, and the classes that they (transitively) depend on these. For example, the query bad_serialization,de.nedin \nFig.8.1, is close,since it can be evaluated while inspecting its input, speci.cally, on the hidden parameter \nand the literal /java.io.Serializable. Figure 8.1 A close JTL query bad_serialization := implements /java.io.Serializable \n{ no static final long field SerialVersionUID; } The query classical_interface,de.ned inFig.8.2,check\u00ading \nwhether all implementations of the implicit parameter are final, is open. Figure 8.2 An open JTL query \nimplemented_by[X] := X implements #; classical_interface := interface implemented_by: { all final; }; \n Processing open queries is time consuming. Worse, the output of these queries is non-deterministic, \nin the sense that it depends on the extent of the software repository available to the processor. This \nis the reason that the JTL processor warns the programmer against making open queries. As it turns out, \nJTL queries tend to be close. We showed that JTL performance exceeds that of a comparable tool. It would \nstill be interested to stretch further JTL scalability and evaluate its performance of close queries \nof very large programs, typical to the open-source community, or open queries of large libraries and \ncommercial frameworks. Another scalability concern is query complexity: The exam\u00adples we provided preserver \nthe spirit of QBE, and are similar to JAVA code. Would this property maintain for increasingly com\u00adplex \nqueries? We believe that the practice of using small auxiliary queries, such as implemented_by of Fig. \n8.2, should contribute the cause of preserving the brevity and JAVA-like look of even more complicated \nqueries. The work on JTL can be continued in the following directions: First, there is the recalcitrant \nissue of extending JTL to support modi.cations to the software base. The dif.culty here lies with the \nfact that such changes are expected to preserve the underlying lan\u00adguage semantics; in other words, there \nare complex invariants to which the database under change must adhere. The current bag\u00adgage mechanism \nis limited precisely for that reason: we are still seeking the balance between suf.cient expressive power \nfor string processing and automatic checking that the produced code is cor\u00adrect. The problem becomes \neven more dif.cult in dealing with ex\u00adecutional code. Despite these issues, we argue that that JTL can \nbe used, as is, for specifying pre-and post-conditions for existing program transformation systems. Second, \nwe would like to see a type-safe version of embedded JTL, similar to the work on issuing type safe-embedded \nSQL calls from JAVA [23, 57] and C# LINQ project12. The grand challenge is in a seamless integration, \na linguistic symbiosis [16] of JTL with JAVA, perhaps in a manner similar to by which XML was integrated \ninto the language by Harden et al. [45]. Third, it would be interesting to see if the JTL could be en\u00adhanced \nto examine not only the data.ow of methods, but also their control .ow. Even more challenging is the \ncombination of the two perspectives. Fourth, it might be useful to extend JTL to make queries on the \nprogram trace, similarly to PQL [56] or PTQL [36]. This extension 12 http://msdn.microsoft.com/vcsharp/future/ \ncould perhaps be used for pointcut de.nitions based on execution stack. Finally, there is an interesting \nchallenge of .nding a generic tool for making language type extensions, for implementing e.g., non\u00adnull \ntypes [28], read-only types [12], and alias annotations [4]. This could be carried out in the manner \ndescribed in [32], where the type constraints are speci.ed locally, with two closure conditions: .rst, \na recursively de.ned constraint on all invocable entities, and second, a condition on allowed modi.cation \nby inheritance. The dif.culty here lies in the fact that the data.ow analysis we presented is a bit remote \nfrom the code. Perhaps the grand challenge is the combination of the brevity of expression offered by \nJTL with the pluggable type systems of Andreae, Markstrum, Millstein and Noble [6]. Acknowledgements. \nInspiring long discussions with Evelina Zarivach greatly helped JTL take its shape. We are also indebted \nto her for her meticulous read of early drafts of this paper. Comments and encouragements of James Noble \nare happily acknowledged. Part of the implementation was carried out by Grigory Fridberg.  References \n[1] A. V. Aho, B. W. Kernighan, and P. J. Weinberger. The AWK programming language. Addison-Wesley series \nin Computer Science. Addison-Wesley Publishing Company, Reading, Massachusetts, 1988. [2] A. V. Aho, \nR. Sethi, and J. D. Ullman. Compilers: Principles, Techniques, and Tools. Addison-Wesley Publishing Company, \nReading, Massachusetts, 1986. [3] J. E. Aldrich and C. Chambers. Ownership domains: Separating aliasing \npolicy from mechanisms. In M. Odersky, editor, Proc. of the Eighteenth European Conference on Object-Oriented \nProgramming (ECOOP 04), volume 3086 of Lecture Notes in Computer Science, pages 1 25, Oslo, Norway, June \n2004. Springer Verlag. [4] J. E. Aldrich, V. Kostadinov, and C. Chambers. Alias annotations for program \nunderstanding. In Proc. of the Seventeenth Annual Conference on Object-Oriented Programming Systems, \nLanguages, and Applications (OOPSLA 02), pages 311 330, Seattle, Washington, Nov. 4 8 2002. OOPSLA 02, \nACM SIGPLAN Notices 37(11). [5] D. Ancona, G. Lagorio, and E. Zucca. Jam designing a Java extension with \nmixins. ACM Transactions on Programming Languages and Systems, 25(5):641 712, 2003. [6] C. Andreae, J. \nNoble, S. Markstrum, and T. Millstein. A framework for implementing pluggable type systems. In Proceedings \nof the 21th Annual conference on Object-oriented programming, systems, languages, and applications (OOPSLA \n06), Portland, Oregon, October 22 26 2006. ACM SIGPLAN Notices. [7] G. Antoniol, M. D. Penta, and E. \nMerlo. YAAB (Yet Another AST Browser): Using OCL to navigate ASTs. In Proc. of the Eleventh International \nWorkshop on Program Comprehension (IWPC 03), pages 13 22, Portland, Oregon, USA, May 10-11 2003. [8] \nK. Arnold and J. Gosling. The Java Programming Language. The Java Series. Addison-Wesley Publishing Company, \nReading, Massachusetts, 1996. [9] D. C. Atkinson and W. G. Griswold. The design of whole-program analysis \ntools. In Proc. of the Eighteenth International Conference on Software Engineering (ICSE 96), pages 16 \n27, Berlin, Germany, March 25-30 1996. [10] L. A. Barowski and J. H. Cross II. Extraction and use of \nclass dependency information for Java. In Proc. of the Ninth Working Conference on Reverse Engineering \n(WCRE 02), pages 309 318, Richmond, Virginia, USA, Oct. 2002. IEEE Computer Society Press. [11] L. Bendix, \nA. Dattolo, and F. Vitali. Software con.guration management in software and hypermedia engineering: A \nsurvey. In Handbook of Software Engineering and Knowledge Engineering, volume 1, pages 523 548. World \nScienti.c Publishing, 2001. [12] A. Birka and M. D. Ernst. A practical type system and language for reference \nimmutability. In J. M. Vlissides and D. C. Schmidt, editors, Proc. of the Nineteenth Annual Conference \non Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 04), pages 35 49, Vancouver, \nBC, Canada, Oct. 2004. ACM SIGPLAN Notices 39 (10). [13] S. Boag, D. Chamberlin, M. F. Ferna ndez, D. \nFlorescu, J. Robie, and J. Sim\u00b4eon. XQuery 1.0: An XML Query Language. W3C, 2005. [14] B. Bokowski and \nJ. Vitek. Con.ned types. In Proc. of the Fourteenth Annual Conference on Object-Oriented Programming \nSystems, Languages, and Applications (OOPSLA 99), pages 82 96, Denver, Colorado, Nov.1 5 1999. OOPSLA \n99, ACM SIGPLAN Notices 34 (10). [15] E. B\u00a8orger, E. Gr\u00a8adel, and Y. Gurevich. The Classical Decision \nProblem. Perspectives of Mathematical Logic. Springer Verlag, 1997. [16] J. Brichau, K. Gybels, and R. \nWuyts. Towards a linguistic symbiosis of an object-oriented and a logic programming language. In J. Striegnitz, \nK. Davis, and Y. Smaragdakis, editors, Proc. of the Workshop on Multiparadigm Programming with Object-Oriented \nLanguages (MPOOL 02) at the European Conference on Object-Oriented Programming, June 2002. [17] S. Ceri, \nG. Gottlob, and L. Tanca. Logic programming and databases. Springer Verlag, New York, 1990. [18] C. Chambers. \nObject-oriented multi-methods in Cecil. In O. L. Madsen, editor, Proc. of the Sixth European Conference \non Object-Oriented Programming (ECOOP92), volume 615 of Lecture Notes in Computer Science, pages 33 56, \nUtrecht,the Netherlands, June29 July3 1992. Springer Verlag. [19] Y.-F. Chen, M. Nishimoto, and C. Ramamoorthy. \nThe C information abstraction system. IEEE Trans. Softw. Eng., 16(3):325 334, Mar. 1990. [20] T. Cohen \nand J. Gil. Self-calibration of metrics of Java methods. In Proc. of the Thirty Seventh International \nConference on Technology of Object-Oriented Languages and Systems (TOOLS 00 Paci.c), pages 94 106, Sydney, \nAustralia, Nov. 20-23 2000. Prentice-Hall, Englewood Cliffs, New Jersy 07632. [21] T. Cohen and J. Gil. \nAspectJ2EE = AOP + J2EE: Towards an aspect based, programmable and extensible middleware framework. In \nM. Odersky, editor, Proc. of the Eighteenth European Conference on Object-Oriented Programming (ECOOP \n04), volume 3086 of Lecture Notes in Computer Science, pages 219 243, Oslo, Norway, June 2004. Springer \nVerlag. [22] M. Consens, A. Mendelzon, and A. Ryman. Visualizing and querying software structures. In \nCASCON 91, pages 17 35. IBM Press, 1991. [23] W. R. Cook and S. Rai. Safe query objects: statically typed \nobjects as remotely executable queries. In B. N. Gruia-Catalin Roman, William G. Griswold, editor, Proc. \nof the Twenty Seventh International Conference on Software Engineering (ICSE 05), pages 97 106, St. Louis, \nMO, USA, May 15-21 2005. ACM Press, New York, NY, USA. [24] R. F. Crew. ASTLOG: A language for examining \nabstract syntax trees. In S. Kamin, editor, Proc. of the First USENIX Conference Domain Speci.c Languages \n(DSL 97), pages 229 242, Santa Barbara, Oct. 1997. [25] P. Deransart, L. Cervoni, and A. Ed-Dbali. Prolog: \nThe Standard: reference manual. Springer-Verlag, London, UK, 1996. [26] P. T. Devanbu. GENOA a customizable, \nfront-end-retargetable source code analysis framework. ACM Trans. on Soft. Eng. and Methodology, 8(2):177 \n212, 1999. [27] M. Eichberg, M. Mezini, K. Ostermann, and T. Sch\u00a8afer. XIRC: A kernel for cross-artifact \ninformation engineering in software development environments. In Proc. of the Eleventh Working Conference \non Reverse Engineering (WCRE 04), pages 182 191, Delft, Netherlands, Nov. 8-12 2004. IEEE Computer Society \nPress. [28] M. F\u00a8ahndrich and K. R. M. Leino. Declaring and checking non\u00adnull types in an object-oriented \nlanguage. In R. Crocker and G. L. S. Jr., editors, Proc. of the Eighteenth Annual Conference on Object-Oriented \nProgramming Systems, Languages, and Applications (OOPSLA 03), pages 302 312, Anaheim, California, USA, \nOct. 2003. ACM SIGPLAN Notices 38 (11). [29] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, \nJ. B. Saxe, and R. Stata. Extended static checking for Java. In Proc. of the Conference on Programming \nLanguage Design and Implementation (PLDI) (PLDI 02), pages 234 245, Berlin, Germany, June 17-21 2002. \nCompaq Systems Research Center. [30] M. Fowler. Refactoring: Improving the Design of Existing Code. Object \nTechnology Series. Addison-Wesley Publishing Company, Reading, Massachusetts, 2000. [31] R. Garcia, J. \nJ\u00a8arvi, A. Lumsdaine, J. Siek, and J. Willcock. A com\u00adparative study of language support for generic \nprogramming. In R. Crocker and G. L. S. Jr., editors, Proc. of the Eighteenth Annual Conference on Object-Oriented \nProgramming Systems, Languages, and Applications (OOPSLA 03), pages 115 134, Anaheim, Califor\u00adnia, USA, \nOct. 2003. ACM SIGPLAN Notices 38 (11). [32] J. Gil and Y. Eckel. Statically checkable design level traits. \nIn Proc. of the Thirteenth IEEE Conference on Automated Software Engineering (ASE 98), page 217, Honolulu, \nHawaii, USA, Nov. 1998. IEEE Computer. [33] J. Gil and I. Maman. Micro patterns in Java code. In Proc. \nof the Twentieth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications \n(OOPSLA 05), San Diego, California, Oct.16-20 2005. ACM SIGPLAN Notices. [34] J. Gil and Y. Tsoglin. \nJAMOOS a domain-speci.c language for language processing. J. Comp. and Inf. Tech., 9(4):305 321, 2001. \n[35] A. Goldberg. Smalltalk-80: The Interactive Programming Envi\u00adronment. Addison-Wesley Publishing Company, \nReading, Mas\u00adsachusetts, 1984. [36] S. Goldsmith, R. O Callahan, and A. Aiken. Relational queries over \nprogram traces. In Proc. of the Twentieth Annual Conference on Object-Oriented Programming Systems, Languages, \nand Applications (OOPSLA 05), pages 385 402, San Diego, California, Oct.16-20 2005. ACM SIGPLAN Notices. \n[37] I. Gorton and L. Zhu. Tool support for Just-in-Time architecture reconstruction and evaluation: \nAn experience report. In B. N. Gruia-Catalin Roman, William G. Griswold, editor, Proc. of the Twenty \nSeventh International Conference on Software Engineering (ICSE 05), pages 514 523, St. Louis, MO, USA, \nMay 15-21 2005. ACM Press, New York, NY, USA. [38] O. C. Z. Gotel and A. C. W. Finkelstein. An analysis \nof the requirements traceability problem. In Proc. of the First International Conference on Requirements \nEngineering (ICRE 94), pages 94 101, Colorado Springs, Colorado, Apr. 1994. IEEE Computer Society Press. \n[39] G. Gottlob, E. Gr\u00a8adel, and H. Veith. Linear time Datalog for branching time logic. In Logic-Based \nArti.cial Intelligence.Kluwer, 2000. [40] J. E. Grass and Y. Chen. The C++ information abstractor. In \nProc. of the USENIX C++ Conference, pages 265 277, San Fransisco, CA, Apr. 1990. AT&#38;T Bell Laboratories, \nUSENIX Association. [41] W. G. Griswold, D. C. Atkinson, and C. McCurdy. Fast, .exible syntactic pattern \nmatching and processing. In Proc. of the Fourth Workshop on Program Comprehension (WPC 96), pages 144 \n153, Washington, DC, 1996. IEEE Computer Society Press. [42] K. Gybels and J. Brichau. Arranging language \nfeatures for more robust pattern-based crosscuts. In Proc. of the Second International Conference on \nAspect-Oriented Software Development (AOSD 03), pages 60 69, Boston, Massachusetts, USA, Mar. 17-21 2003. \nACM Press, New York, NY, USA. [43] A. N. Habermann and D. Notkin. Gandalf: Software development environments. \nIEEE Trans. Softw. Eng., 12(12):1117 1127, Dec. 1986. [44] E. Hajiyev, M. Verbaere, and O. de Moor. Codequest: \nScalable source code queries with datalog. In D. Thomas, editor, Proceedings of the 20th European Conference \non Object-Oriented Programming (ECOOP 06), volume 4067 of Lecture Notes in Computer Science, pages 2 \n27, Berlin, Germany, 2006. Springer. [45] M. Harren et al. XJ: integration of XML processing into Java. \nIn WWW Alt. 04: Proc. of the Thirteenth International World Wide Web Conference on Alternate track papers \n&#38; posters, pages 340 341, New York, NY, USA, 2004. ACM Press, New York, NY, USA. [46] A. Hejlsberg, \nS. Wiltamuth, and P. Golde. The C# Programming Language. Addison-Wesley Publishing Company, Reading, \nMas\u00adsachusetts, second edition, Oct. 2003. [47] R. Holmes and G. C. Murphy. Using structural context \nto recommend source code examples. In B. N. Gruia-Catalin Roman, William G. Griswold, editor, Proc. of \nthe Twenty Seventh International Conference on Software Engineering (ICSE 05), pages 117 125, St. Louis, \nMO, USA, May 15-21 2005. ACM Press, New York, NY, USA. [48] D. Hovemeyer and W. Pugh. Finding bugs is \neasy. ACM SIGPLAN Notices, 39(12):92 106, 2004. [49] ISE. ISE EIFFEL The Language Reference. ISE, Santa \nBarbara, CA, 1997. [50] D. Janzen and K. D. Volder. Navigating and querying code without getting lost. \nIn Proc. of the Second international conference on Aspect-Oriented Software Development (AOSD 03), pages \n178 187, New York, NY, USA, 2003. ACM Press. [51] J. J\u00a8arvi, J. Willcock, and A. Lumsdaine. Associated \ntypes and constraint propagation for mainstream object-oriented generics. In Proc. of the Twentieth Annual \nConference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 05), San Diego, \nCalifornia, Oct.16-20 2005. ACM SIGPLAN Notices. [52] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, \nJ. Palm, and W. G. Griswold. An overview of AspectJ. In J. L. Knudsen, editor, Proc. of the Fifteenth \nEuropean Conference on Object-Oriented Programming (ECOOP 01), volume 2072 of Lecture Notes in Computer \nScience, pages 327 355, Budapest, Hungary, June 2001. Springer Verlag. [53] G. Kiczales, J. Lamping, \nA. Menhdhekar, C. Maeda, C. V. Lopes, J.- M. Loingtier, and J. Irwin. Aspect-oriented programming. In \nM. Aks\u00b8it and S. Matsuoka, editors, Proc. of the Eleventh European Conference on Object-Oriented Programming \n(ECOOP 97), volume 1241 of Lecture Notes in Computer Science, pages 220 242, Jyv\u00a8askyl\u00a8a, Finland, June \n9-13 1997. Springer Verlag. [54] K. Kontogiannis, J. Martin, K. Wong, R. Gregory, H. A. M\u00a8uller, and \nJ. Mylopoulos. Code migration through transformations. In S. A. MacKay and J. H. Johnson, editors, Proc. \nof the Conference of the Centre for Advanced Studies on Collaborative research (CASCON 98), page 13, \nToronto, Ontario, Canada, Nov. 1998. IBM Press. [55] T. Lindholm and F. Yellin. The Java Virtual Machine \nSpeci.cation. Addison-Wesley Publishing Company, Reading, Massachusetts, second edition, 1999. [56] M. \nMartin, B. Livshits, and M. S. Lam. Finding application errors and security .aws using PQL: a program \nquery language. In Proc. of the Twentieth Annual Conference on Object-Oriented Programming Systems, Languages, \nand Applications (OOPSLA 05), pages 365 383, San Diego, California, Oct.16-20 2005. ACM SIGPLAN Notices. \n[57] R. A. McClure and I. H. Kr\u00a8uger. SQL DOM: compile time checking of dynamic SQL statements. In B. \nN. Gruia-Catalin Roman, William G. Griswold, editor, Proc. of the Twenty Seventh International Conference \non Software Engineering (ICSE 05), pages 88 96, St. Louis, MO, USA, May 15-21 2005. ACM Press, New York, \nNY, USA. [58] B. Meyer. Object-Oriented Software Construction. Prentice-Hall, Englewood Cliffs, New Jersy \n07632, Englewood Cliffs, New Jersy, second edition, 1997. [59] M. Mezini and K. Ostermann. Conquering \naspects with Caesar. In Proc. of the Second International Conference on Aspect-Oriented Software Development \n(AOSD 03), pages 90 100, Boston, Mas\u00adsachusetts, USA, Mar. 17-21 2003. ACM Press, New York, NY, USA. \n[60] H. A. M\u00a8uller and K. Klashinsky. Rigi A system for programming\u00adin-the-large. In Proc. of the Tenth \nInternational Conference on Software Engineering (ICSE 88), pages 80 86, Singapore, Apr. 1988. IEEE Computer \nSociety Press. [61] G. C. Murphy, M. Kersten, M. P. Robillard, and D. Cubranic. The emergent structure \nof development tasks. In A. P. Black, editor, Proc. of the Ninetieth European Conference on Object-Oriented \nProgramming (ECOOP 05), volume 3086 of Lecture Notes in Computer Science, pages 33 48, Glasgow, UK, July \n25 29 2005. Springer Verlag. [62] I. Nassi and B. Shneiderman. Flowchart techniques for structured programming. \nACM SIGPLAN Notices, 8(8):12 26, Aug. 1973. [63] N. Nystrom, M. R. Clarkson, and A. C. Myers. Polyglot: \nAn extensible compiler framework for Java. In Proc. of the Twelfth International Conference on Compiler \nConstruction (CC 03), pages 138 152, Warsaw, Poland, Apr. 2003. Springer Verlag. [64] K. Ostermann, M. \nMezini, and C. Bockisch. Expressive pointcuts for increased modularity. In A. P. Black, editor, Proc. \nof the Ninetieth European Conference on Object-Oriented Programming (ECOOP 05), volume 3086 of Lecture \nNotes in Computer Science, pages 214 240, Glasgow, UK, July 25 29 2005. Springer Verlag. [65] J. K. Ousterhout. \nTcl: An embeddable command language. In Proc. of the Winter 1990 USENIX Conference, pages 133 146, Wasington, \nD.C., Jan. 1990. [66] S. Paul and A. Prakash. Querying source code using an algebraic query language. \nIn H. A. M\u00a8uller and M. Georges, editors, Proc. of the Tenth IEEE International Conference on Software \nMaintenance (ICSM 94), pages 127 136, Victoria, BC, Canada, Sept. 1994. IEEE Computer. [67] Reasoning \nSystems. REFINE User s Manual, 1988. [68] N. Rutar, C. B. Almazan, and J. S. Foster. A comparison of \nbug .nding tools for Java. In Proc. of the Fifteenth International Symposium on Software Reliability \nEngineering (ISSRE 2004), pages 245 256, Saint-Malo, Bretagne, France, Nov. 2 5 2004. IEEE Computer Society \nPress. [69] N. Sch\u00a8arli, S. Ducasse, O. Nierstrasz, and A. P. Black. Traits: Composable units of behavior. \nIn L. Cardelli, editor, Proc. of the Seventeenth European Conference on Object-Oriented Programming (ECOOP \n03), volume 2743 of Lecture Notes in Computer Science, pages 248 274, Darmstadt, Germany, July 21 25 \n2003. Springer Verlag. [70] N. Sch\u00a8arli, S. Ducasse, O. Nierstrasz, and R. Wuyts. Compos\u00adable encapsulation \npolicies. In M. Odersky, editor, Proc. of the Eighteenth European Conference on Object-Oriented Programming \n(ECOOP 04), volume 3086 of Lecture Notes in Computer Science, pages 26 50, Oslo, Norway, June 2004. Springer \nVerlag. [71] C. Smith and S. Drossopoulou. Chai: Traits for Java-like languages. In A. P. Black, editor, \nProc. of the Ninetieth European Conference on Object-Oriented Programming (ECOOP 05), volume 3086 of \nLecture Notes in Computer Science, Glasgow, Scotland, July 25 29 2005. Springer Verlag. [72] T. Strelich. \nThe Software Life Cycle Support Environment (SLCSE): a computer based framework for developing soft. \nsys. In Proc. of the Third ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development \nEnvironments (SDE 88), pages 35 44, Boston, Massachusetts, 1988. ACM Press, New York, NY, USA. [73] B. \nStroustrup. The C++ Programming Language. Addison-Wesley Publishing Company, Reading, Massachusetts, \nthird edition, 1997. [74] B. Stroustrup and G. D. Reis. Concepts design choices for template argument \nchecking. ISO/IEC JTC1/SC22/WG21 no. 1536, 2003. [75] S. T. Taft and R. A. Duff, editors. Ada 95 Reference \nManual, Language and Standard Libraries, International Standard ISO/IEC 8652: 1995(E), volume 1246 of \nLNCS. Springer Verlag, 1997. [76] M. Tatsubori, S. Chiba, K. Itano, and M.-O. Killijian. Openjava: A \nclass-based macro system for java. In W. Cazzola, R. J. Stroud, and F. Tisato, editors, Proc. of the \nFirst OOPSLA Workshop on Re.ection and Software Engineering, volume 1826 of Lecture Notes in Computer \nScience, pages 117 133, Denver, CO, USA, Nov. 1999. OOPSLA 99, Springer Verlag. [77] A. van Gelder, K. \nRoss, and J. S. Schlipf. The well-founded semantics for general logic programs. Journal of the ACM, 38(3):620 \n650, 1991. [78] J. Whaley and M. S. Lam. Cloning-based context-sensitive pointer alias analyses using \nbinary decision diagrams. In Proc. of the Conference on Programming Language Design and Implementation \n(PLDI) (PLDI 04), pages 131 144, Washington, DC, June 9-11 2004. ACM Press, New York, NY, USA. [79] P.-C. \nWu. On exponential-time completeness of the circularity problem for attribute grammars. ACM Transactions \non Programming Languages and Systems, 26(1):186 190, 2004. [80] M. M. Zloof. Query By Example. In Proceedings \nof the National Computer Conference, pages 431 438, Anaheim, CA, May 1975. \n\t\t\t", "proc_id": "1167473", "abstract": "We present an overview of JTL (the Java Tools Language, pronounced \"Gee-tel\"), a novel language for querying JAVA [8] programs. JTL was designed to serve the development of source code software tools for JAVA, and as a small language which to aid programming language extensions to JAVA. Applications include definition of pointcuts for aspect-oriented programming, fixing type constraints for generic programming, specification of encapsulation policies, definition of micro-patterns, etc. We argue that the JTL expression of each of these is systematic, concise, intuitive and general.JTL relies on a simply-typed relational database for program representation, rather than an abstract syntax tree. The underlying semantics of the language is restricted to queries formulated in First Order Predicate Logic augmented with transitive closure (FOPL).Special effort was taken to ensure terse, yet readable expression of logical conditions. The JTL pattern &lt;B&gt;public abstract class&lt;/B&gt;, for example, matches all abstract classes which are publicly accessible, while &lt;B&gt;class&lt;/B&gt; (&lt;B&gt;public&lt;/B&gt; clone();) matches all classes in which method <i>clone</i> is public. To this end, JTL relies on a DATALOG-like syntax and semantics, enriched with quantifiers and pattern matching which all but entirely eliminate the need for recursive calls.JTL's query analyzer gives special attention to the fragility of the \"closed world assumption\" in examining JAVA software, and determines whether a query relies on such an assumption.The performance of the JTL interpreter is comparable to that of JQuery after it generated its database cache, and at least an order of magnitude faster when the cache has to be rebuilt.", "authors": [{"name": "Tal Cohen", "author_profile_id": "81100145582", "affiliation": "Technion-Israel Institute of Technology, Technion City, Haifa, Israel", "person_id": "PP18004105", "email_address": "", "orcid_id": ""}, {"name": "Joseph (Yossi) Gil", "author_profile_id": "81100349003", "affiliation": "Technion-Israel Institute of Technology, Technion City, Haifa, Israel", "person_id": "P149595", "email_address": "", "orcid_id": ""}, {"name": "Itay Maman", "author_profile_id": "81100460201", "affiliation": "Technion-Israel Institute of Technology, Technion City, Haifa, Israel", "person_id": "P753319", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167481", "year": "2006", "article_id": "1167481", "conference": "OOPSLA", "title": "JTL: the Java tools language", "url": "http://dl.acm.org/citation.cfm?id=1167481"}