{"article_publication_date": "10-16-2006", "fulltext": "\n Concepts: Linguistic Support for Generic Programming in C++ Douglas Gregor Indiana University dgregor@osl.iu.edu \nBjarne Stroustrup Texas A&#38;M University bs@cs.tamu.edu Jaakko J\u00a8arvi Texas A&#38;M University jarvi@cs.tamu.edu \nGabriel Dos Reis Texas A&#38;M University gdr@cs.tamu.edu Jeremy Siek Rice University Jeremy.G.Siek@rice.edu \nAndrew Lumsdaine Indiana University lums@osl.iu.edu Abstract Generic programming has emerged as an important \ntechnique for the development of highly reusable and ef.cient software libraries. In C++, generic programming \nis enabled by the .exibility of tem\u00adplates, the C++ type parametrization mechanism. However, the power \nof templates comes with a price: generic (template) libraries can be more dif.cult to use and develop \nthan non-template libraries and their misuse results in notoriously confusing error messages. As currently \nde.ned in C++98, templates are unconstrained, and type-checking of templates is performed late in the \ncompilation process, i.e., after the use of a template has been combined with its de.nition. To improve \nthe support for generic programming in C++, we introduce concepts to express the syntactic and semantic \nbehav\u00adior of types and to constrain the type parameters in a C++ template. Using concepts, type-checking \nof template de.nitions is separated from their uses, thereby making templates easier to use and eas\u00adier \nto compile. These improvements are achieved without limiting the .exibility of templates or decreasing \ntheir performance in fact their expressive power is increased. This paper describes the lan\u00adguage extensions \nsupporting concepts, their use in the expression of the C++ Standard Template Library, and their implementation \nin the ConceptGCC compiler. Concepts are candidates for inclusion in the upcoming revision of the ISO \nC++ standard, C++0x. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs \nand Features Abstract data types; D.3.3 [Programming Languages]: Language Constructs and Features Polymorphism; \nD.2.13 [Software Engineering]: Reusable Software Reusable libraries General Terms Design, Languages Keywords \nGeneric programming, constrained generics, paramet\u00adric polymorphism, C++ templates, C++0x, concepts 1. \nIntroduction The C++ language [25, 62] supports parametrized types and func\u00adtions in the form of templates. \nTemplates provide a unique com- Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 06 October 22 26, 2006, Portland, Oregon, USA. Copyright c &#38;#169; \n2006 ACM 1-59593-348-4/06/0010. . . $5.00. bination of features that have allowed them to be used for \nmany different programming paradigms, including Generic Program\u00adming [3,44], Generative Programming [11], \nand Template Metapro\u00adgramming [1, 66]. Much of the .exibility of C++ templates comes from their unconstrained \nnature: a template can perform any op\u00aderation on its template parameters, including compile-time type \ncomputations, allowing the emulation of the basic features required for diverse programming paradigms. \nAnother essential part of tem\u00adplates is their ability to provide abstraction without performance degradation: \ntemplates provide suf.cient information to a com\u00adpiler s optimizers (especially the inliner) to generate \ncode that is optimal in both time and space. Consequently, templates have become the preferred implemen\u00adtation \nstyle for a vast array of reusable, ef.cient C++ libraries [2,6, 14,20,32,54,55,65], many of which are \nbuilt upon the Generic Pro\u00adgramming methodology exempli.ed by the C++ Standard Template Library (STL) \n[42,60]. Aided by the discovery of numerous ad hoc template techniques [28,46,56,66,67], C++ libraries \nare becoming more powerful, more .exible, and more expressive. However, these improvements come at the \ncost of implemen\u00adtation complexity [61, 63]: authors of C++ libraries typically rely on a grab-bag of \ntemplate tricks, many of which are complex and poorly documented. Where library interfaces are rigorously \nsepa\u00adrated from library implementation, the complexity of implementa\u00adtion of a library is not a problem \nfor its users. However, templates rely on the absence of modular (separate) type-checking for .exi\u00adbility \nand performance. Therefore, the complexities of library im\u00adplementation leak through to library users. \nThis problem manifests itself most visibly in spectacularly poor error messages for simple mistakes. \nConsider: list<int> lst; sort(lst.begin(), lst.end()); Attempting to compile this code with a recent \nversion of the GNU C++ compiler [17] produces more than two kilobytes of output, containing six different \nerror messages. Worse, the errors reported provide line numbers and .le names that point to the implementa\u00adtion \nof the STL sort() function and its helper functions. The only clue provided to users that this error \nwas triggered by their own code (rather than by a bug in the STL implementation) is the fol\u00adlowing innocuous \nline of output: sort_list.cpp:8: instantiated from here The actual error, in this case, is that the STL \nsort() requires a pair of Random Access Iterators, i.e., iterators that can move any number of steps \nforward or backward in constant time. The STL sort_list.cpp: In function int main() : sort_list.cpp:8: \nerror: no matching function for call to sort(std::_List_iterator<int>, std::_List_iterator<int>) .../stl_algo.h:2835: \nnote: candidates are: void std::sort(_Iter, _Iter) [with _Iter = std::_List_iterator<int>] sort_list.cpp:8: \nnote: no concept map for requirement std::MutableRandomAccessIterator<std::_List_iterator<int> > Figure \n1. ConceptGCC error message produced when attempting to compile a call to the STL sort() with list iterators. \nlist container, however, provides only Bidirectional Iterators, which can move forward or backward only \none step at a time. Random Access Iterator and Bidirectional Iterator are concepts used in the design \nand documentation of the STL. A concept describes a set of requirements that a generic algorithm (implemented \nas a C++ function template) places on its template parameters. Concepts have no representation within \nthe C++ language, so a user s failure to meet the concept requirements of an STL algorithm will only \nbe detected when the compiler attempts to instantiate the algorithm. The absence of modular type-checking \nfor templates also means that the de.nitions of templates are not type checked indepen\u00addently of their \nuses. This causes serious problems for implementers of generic libraries because bugs can go uncaught \nprior to de\u00adployment. In particular, it is common for inconsistencies to exist between the documented \ntype requirements and the implementa\u00adtion of a function template. A form of separate type-checking can \nbe somewhat approximated using existing C++ language mecha\u00adnisms [56]. However, with this approach ( \nconcept checking or constraints checking ), concepts are not language entities. As a result, concept-checking \nlibraries are quite dif.cult to design, must be manually veri.ed, and suffer from portability problems. \nModern template libraries rely on a set of naming and documen\u00adtation conventions to express their fundamental \ndesign ideas, such as the Bidirectional Iterator and Random Access Iterator abstrac\u00adtions, and state \nthe requirements of generic algorithms in terms of those ideas. The root cause of most of the problems \nwith templates is that these fundamental design ideas cannot be directly expressed using C++98 templates, \nso compilers cannot detect errors early and cannot report them in the terms used by the library documentation. \nDirect language support for concepts addresses this problem. This paper describes a set of extensions \nto C++ that directly supports the notion of concepts; thus providing greater expressive power (e.g., \nin overloading) and improved modular type checking for C++ templates. For example, concepts directly \nsupport the ex\u00adpression and checking of concepts such as Bidirectional Iterator and Random Access Iterator. \nUsing concepts we can place con\u00adstraints on template parameters, enabling modular type-checking for templates. \nHaving concepts directly expressible in C++ makes templates easier to write and use. For example, instead \nof two kilo\u00adbytes of irrelevant information, our experimental compiler support\u00ading concepts, ConceptGCC \n[19], produces the error message shown in Figure 1 when given the erroneous STL code above. Besides its \nbrevity, there are several improvements in this error message. Most importantly, the error message (there \nis only one) refers directly to the user s code, at the erroneous call to sort(). The user is informed \nthat no sort() function matches, and that the cause of the failure is an unsatis.ed requirement for the \nMutable Random Access Iterator concept, i.e., a list iterator is not a Random Access Iterator, and therefore \nsort() cannot be used. By completely type\u00adchecking the call to sort() at the call site, the problem with \nSTL implementation details leaking into the user s error message has been eliminated. The improvement \nto error messages is a result of fundamental changes to the way templates are speci.ed: the requirements \nof a (templated) algorithm on its arguments are made explicit. This allows us to reason about template \ncode and (almost incidentally) gives the compiler the information it needs to produce radically better \nerror messages early. It also gives information needed to improve overloading. The primary challenge \nin designing a system of constrained generics for C++ templates is in providing language features that \nsupport current successful uses of the C++ template system without compromising the ideal of modular \ntype checking for templates or damaging performance. We focus on supporting the Generic Programming paradigm, \nwhich has been used to develop many generic C++ libraries. Early discussions on constrained generics \nfor C++ can be found in [61]. At the time, no solution was found to the stated problem of providing constraints \nwithout unacceptably limiting .exibility or performance. The objective that standard C++ should be extended \nwith constrained generics was made explicit in 2003 with a report laying out the main design goals [63]. \nThere are many existing programming languages that support generics in some form or other. Early attempts \nat building the Standard Template Library focused on Scheme, then Ada [43] before settling on C++. More \nrecently, we evaluated many more languages, including C#, Java, Cecil, ML, and Haskell, based on their \nability to express the ideas of Generic Programming [15, 16]. Building on these results and the experience \ngained from the Generic Programming language G [57 59], we designed concepts with the following goals \nin mind: To provide direct support for Generic Programming, so that pro\u00adgrams and libraries developed \nwith the Generic Programming methodology can be expressed clearly and without relying on template tricks \nor documentation conventions.  To make templates easier to write and easier to use by mak\u00ading a template \ns requirements on its arguments explicit using concepts, thereby enabling modular type-checking and making \ntemplate overloading more robust.  To provide a clear transition path from today s unconstrained templates \nto templates constrained by concepts. Libraries built with the Generic Programming methodology should \nbe up\u00adgradeable to use concepts without breaking source compatibil\u00adity for the vast majority of user \nprograms.  To do so without making programs more verbose, less .exible, or less ef.cient.  To retain \ncompatibility with C++98, both by not breaking ex\u00adisting code and by not introducing language rules that \ndiffer signi.cantly from existing rules.  The work reported here is part of a large on-going effort \nled by the authors to provide concepts for C++0x, the next ISO C++ standard [12, 22, 23, 53, 64]. This \npaper reports the .rst implemen\u00adtation of constrained generics for C++ using concepts, and the .rst extensive \nevaluation of their use in developing generic libraries. The primary aim of the resulting language and \nlibrary, collectively called ConceptC++, is to gain practical experience with the use of concepts. Our \ngoals are ambitious and, in some cases, contradictory. We report elsewhere [27] on the inherent trade-off \nbetween modular type checking and the Generic Programming notion of specializa\u00adtion. Specialization will \nbe discussed in Section 2 as part of a gen\u00aderal introduction to Generic Programming. Section 3 presents \nthe language extensions and Section 4 gives an overview of their im\u00adplementation in our compiler. Finally, \nwe evaluate the effective\u00adness of our language support for concepts by providing a concept\u00adenhanced STL \nimplementation, both from the perspective of library users and library developers. This analysis, along \nwith a discussion of the practical impact of our nearly-modular type checking for templates, will be \ndiscussed in Section 5. 2. Generic Programming Generic programming is a systematic approach to designing \nand organizing software that focuses on .nding the most general (or abstract) formulation of an algorithm \ntogether with an ef.cient implementation [30]. The primary goal of generic programming is to make algorithms \nmore widely applicable, and thus generic programming is sometimes referred to as algorithm-oriented [45]. \n2.1 Lifting and Abstraction The generic programming process derives generic algorithms from families \nof concrete (non-generic) implementations that exhibit some commonality. We lift away unnecessary requirements \non types from an implementation, thereby raising the level of ab\u00adstraction. Consider the following two \nconcrete implementations of sum(). The .rst computes the sum of doubles stored in an array; the second \ncomputes the sum of integers in a linked list. double sum(double* array, int n) { double s=0; for (int \ni=0; i < n; ++i ) s = s + array[i]; return s; } struct node { node* next; int data; }; int sum(node* \n.rst, node* last) { int s=0; for (; .rst != last; .rst = .rst. next) s=s+.rst. data; return s; } Abstractly, \nboth implementations do the same thing: traverse a col\u00adlection of elements and sum the values. However, \nthese implemen\u00adtations impose additional requirements (ones that are unnecessary for the purposes of \nsummation). In the .rst implementation, the el\u00adements must be of type double and be stored in an array. \nIn the second implementation, the elements must be of type int and be stored in the node* representation \nof a linked list. Fundamentally, summing the elements in a collection only re\u00adquires the ability to visit \nthe elements of the collection and add elements. A generic algorithm should therefore be able to work \ncorrectly with any collection of elements supporting traversal and the addition of elements. Using concepts, \nwe can specify these re\u00adquirements: template<InputIterator Iter> where Addable<Iter::value type> &#38;&#38; \nAssignable<Iter::value type> value type sum(Iter .rst, Iter last, Iter::value type s) { for (; .rst != \nlast; ++.rst) s=s+ *.rst; return s; } The sum() algorithm is implemented as a function template, with \nthe parameter Iter for the iterator type. The algorithm can be used with any type that is an Input Iterator, \ni.e., it supports the ++ opera\u00adtion for moving from one element to another, the * operation for ac\u00adcessing \na value, and != for testing iterator positions. This constraint for the template parameter Iter is stated \nin the template parameter list. Similarly, that iterator s element type, Iter::value type, must support \naddition and assignment, as stated in the separate where clause. Section 3 will explain the syntax and \nsemantics of concepts and their use as constraints in more detail. Suppose we broaden the family of \nconcrete implementations to include computing the product of a list of integers: int product(node* .rst, \nnode* last) { int s=1; for (; .rst != last; .rst = .rst. next) s=s * .rst. data; return s; } The sum() \nalgorithm can be further generalized to to compute products by replacing addition with parameters for \nan arbitrary binary operator and initial element. With this change, we arrive at an implementation of \nthe STL accumulate() algorithm: template< InputIterator Iter, BinaryOperation<Iter::value type, Iter::value \ntype> Op> where Assignable<Iter::value type, Op::result type> Iter::value type accumulate(Iter .rst, \nIter last, Iter::value type s, Op op) {for (; .rst != last; ++.rst) s = op(s, *.rst); return s; } We \ncan use the accumulate() algorithm with arrays, linked lists, or any other types that meet the requirements \nfor Input Iterator and Binary Operation: double x[10]; double a = accumulate(x, x+10, 0.0, plus <double>()); \n node* n = cons(1, cons(2, cons(2, null ))); int s = accumulate(n, null , 1, multiplies <int>()); int \np = sum(n, null, 0, plus <int>()); To review, we replaced requirements for particular types, such as \ndouble* or node*, with requirements for certain properties, such as InputIterator and BinaryOperation. \nWe have speci.ed policy but we have not speci.ed how these operations must be carried out. The lifting \nprocess can be summarized graphically as follows:    At the bottom of this .gure lie the concrete \nimplementations that form the basis of the lifting process. As we move further up the .gure, we .nd increasingly \ngeneric implementations that subsume the concrete implementations below, each step removing unnecessary \nrequirements. The lifting process is iterative, and at its limit lies the ideal of an algorithm: the \ngeneric implementation that subsumes all concrete implementations of the algorithm, specifying the minimum \nset of requirements to achieve maximum reusability without sacri.cing ef.ciency.  Input Random Access \n Bidirectional Forward  Output Figure 2. Re.nement relationships among the STL iterator concepts, \nwhere an edge A . B is read as A re.nes B. 2.2 Algorithm Specialization In addition to building highly \nreusable algorithms, Generic Pro\u00adgramming is concerned with building highly ef.cient algorithms. There \nis a natural tension between reusability and ef.ciency be\u00adcause sometimes greater ef.ciency (a better \nalgorithm) is enabled by additional requirements (and adding requirements decreases op\u00adportunities for \nreuse). We refer to such algorithms as specialized. When specialized algorithms provide better performance, \nwe im\u00adplement them in addition to the more generic algorithm and pro\u00advide automatic dispatching to the \nappropriate algorithm based on the properties of the input types. Note that we do not give up on genericity: \nwe still program in terms of properties of types and not in terms of particular types. A simple, but \nimportant, example of algorithm specialization is the STL advance() function which moves an iterator \nforward n steps. The following shows two versions of advance(), the second more specialized than the \n.rst. There is a slow advance() for iterators that only provide increment, and a fast advance() for iterators \nthat can jump forward arbitrary distances in constant time (using the += operator). template<InputIterator \nIter> void advance(Iter&#38; i, di.erence type n) { while (n--)++i; } template<RandomAccessIterator \nIter> void advance(Iter&#38; i, di.erence type n) { i+=n; } At a call to advance(), the most speci.c \noverload is selected. Consider: list<int> l; advance(l.begin(), n); // dispatches to slow advance vector<int> \nb; advance(v.begin(), n); // dispatches to fast advance The .rst call to advance() dispatches to the \nversion for Input Iter\u00adator because that is the only overload that matches: a list iterator is not a \nRandom Access Iterator. The second call to advance() could potentially dispatch to either version, because \na vector iterator is both an Input Iterator and a Random Access Iterator. Since Random Access Iterator \nincludes the requirements of Input Iterator, the sec\u00adond advance() is the more specialized algorithm, \nand is chosen in favor of the .rst.  2.3 Concepts Generic algorithms are speci.ed in terms of abstract \nproperties of types, rather than in terms of particular types. In the terminology of generic programming, \na concept is the formalization of an abstrac\u00adtion as a set of requirements on a type (or on a set of \ntypes, integers, operations, etc.) [3,31]. A type that implements the requirements of a concept is said \nto model the concept. These requirements may be syntactic, semantic, or performance-related. The requirements \nfor operators ++ and * on iterators are examples of syntactic require\u00adments. In the documentation of \nC++ libraries, such requirements are typically expressed in the form of valid expressions (also called \nuse patterns); ConceptC++ allows the expression of requirements on operations directly in the language. \nThe second kind of syn\u00adtactic requirement is associated types: types that collaborate in the concept \noperations and that are determined by the modeling type. For example, the associated value and distance \ntypes of an itera\u00adtor, which state the type of value that the iterator points to and the type that can \nbe used to measure distances between iterators, re\u00adspectively. An example of a semantic requirement is \nthat iterator equal\u00adity should imply that dereferencing yields the same value: i==j implies *i== *j. \nThe requirement that operator += execute in constant time is a performance requirement of the Random \nAccess Iterator concept. We do not include support for semantic or perfor\u00admance requirements, though \nsuch support is under investigation. A concept may incorporate the requirements of another concept, in \nwhich case the .rst concept is said to re.ne the second. Families of related concepts, called concept \ntaxonomies, form a strong orga\u00adnizational basis for many generic libraries. In particular, concepts can \ndescribe the essential abstractions for an entire domain, pro\u00advide common building blocks for implementing \na large number of generic algorithms, and lead to a uniform interface to the generic algorithms within \nthe domain. Figure 2 illustrates the concept tax\u00adonomy for the C++ Standard Template Library iterator \nconcepts. Often, a concept is parametrized over more than just one type: commonly a concept involves \nmultiple types and speci.es their relationships. For example, the algebraic concept of a Vector Space, \ninvolves two types, the vector type and the scalar type. Similarly, a concept can be parametrized by \ninteger values and operations. 3. Language Support for Concepts ConceptC++ translates the ideas of Generic \nProgramming into a small set of C++ language extensions. Generic algorithms and data structures are expressed \nas templates with constraints on their tem\u00adplate parameters. The constraints are expressed in terms of \nconcepts in where clauses or the template parameter list. A concept is an interface-like de.nition of \na set of requirements (associated types, signatures), while a concept map de.nition provides a mechanism \nfor declaring that a type satis.es a concept and for mapping a type to requirements (concepts) by providing \nrequired operations and associated types. We can illustrate the major concept features using the standard \nlibrary min function: concept LessThanComparable<typename T> { bool operator<(T x, T y); } template<typename \nT> where LessThanComparable<T> const T&#38; min(const T&#38; x, const T&#38; y) { return x < y? x : y; \n} The .rst de.nition speci.es the concept Less Than Comparable:any type T that models Less Than Comparable \nmust provide a less-than operator on two T objects that returns a boolean result. The second de.nition \nspeci.es a constrained function template min(), which can only be applied to types T that model Less \nThan Comparable. That is, we can .nd smaller of two objects using min provided we can compare them by \n<. However, there are notions of smaller that are not conven\u00adtionally expressed using <. For example, \nfor complex numbers the distance from (0,0), abs, is for some algorithms suitable for com\u00adparisons. We \ncan map abs for a complex number, dcomplex, to the < required by min: concept map LessThanComparable<complex> \n{ bool operator<(complex a, complex b) { return abs(a)<abs(b); } }; int f(dcomplex a, dcomplex b) { \ndcomplex&#38; x = min(a, b); // ... } The .rst de.nition is a concept map, which establishes that the \ntype dcomplex is a model of the Less Than Comparable concept when we use the supplied <. Finally, the \nf() function illustrates a call to min(): at the call site, the type T is bound to dcomplex and the concept \nmap LessThanComparable<dcomplex> satis.es min() s Less Than Comparable constraint. 3.1 Constraining \nTemplates with Concepts The syntax of C++ template declarations (and de.nitions) is ex\u00adtended to include \na where clause consisting of a set of requirements. Any template that contains a where clause is called \na constrained template. The following is a simple example of a where clause con\u00adtaining two requirements: \ntemplate<typename T> where Assignable<T> &#38;&#38; CopyConstructible<T> void swap(T&#38; a, T&#38; b) \n{ T tmp(a); // copy using constructor a = b; // copy using assignment b=tmp; } A concept name applied \nto a type, e.g., Assignable<T>, indicates that T must meet the requirements of the Assignable concept, \ne.g., int a=10; int b=20; swap(a,b); Here, int must be Assignable (as well as Copy Constructible). Thus, \nthe where clause, ensures that swap() can only be instantiated on a type that meets the requirements \nof the Assignable and Copy Con\u00adstructible concepts. A where clause may also be used to constrain class \ntemplates and members of class templates. For example, the list template requires the element type to \nmodel Copy Constructible. Furthermore, the sort() member function imposes the further re\u00adquirement that \nT model the Less Than Comparable concept: template<CopyConstructible T> class list { public: where LessThanComparable<T> \nvoid sort(); }; Note that the conventional abbreviation for single-type concepts template<CopyConstructible \nT> is equivalent to template<typename T> where CopyConstructible<T> A concept constraint applies the \nrequirements of a concept to a template parameter (or a set of template parameters). In doing so, it \nserves two roles: 1. It acts as a predicate: when a template identi.er is used, all of the requirements \nin the template s where clause must be satis.ed. For example, does int* meet the requirements of a Forward \nIterator? 2. It provides a scope for the resolution of names used in a tem\u00adplate. For example, what \nis the value type of int* when it is acting as a Forward Iterator?  The ConceptGCC error message shown \nin Section 1 is the result of a type error when concepts are used in the .rst role. At the call to sort(), \nthe compiler determines whether the actual type (a list iterator) meets the requirements of the concept \nstated in sort() s where clause (MutableRandomAccessIterator<Iter>); since this is not the case, the \nerror message shown in Figure 1 is emitted. When the requirements of a where clause are used in the second \nrole, they introduce assumptions into the context of compilation. For example, in the previous swap() \nexample, the .rst line in the body of swap() uses the copy constructor for type T, the existence of which \nis guaranteed by CopyConstructible<T> in the where clause. Likewise, the two assignments in the body \nof swap() type\u00adcheck because of Assignable<T>. Type checking fails when neither the requirements of a \ntem\u00adplate nor the enclosing scope provide suitable declarations for op\u00aderations used in the template. \nFor example, consider the following (erroneous) implementation of an STL-like .nd() algorithm: template<InputIterator \nIter, typename Val> where EqualityComparable<Iter::value type, Val> Iter .nd(Iter .rst, Iter last, Val \nv) { while (.rst < last &#38;&#38; !(*.rst == v)) ++.rst; return .rst; } The error in this example occurs \nin the comparison .rst < last: the Input Iterator concept (see Figure 6) provides comparison via == and \n!=, but not ordering via <. With unconstrained C++ templates, this error would go unnoticed until .nd() \nis instantiated with iterators that do not support <. Using concepts, the error is detected at template \nde.nition time and ConceptGCC produces the error message shown in Figure 3. Note the Iter::value type \nin the de.nition of .nd. That is an abbreviation of InputIterator<Iter>::value type, meaning .nd the \nname value type in the concept map InputIterator<Iter>. Concept maps are explained in 3.4. 3.1.1 Same-type \nConstraints All the concepts mentioned so far are user-de.ned ; that is, they are de.ned using the facilities \ndescribed in Section 3.2. The only built-in concept is SameType, which requires that two type expres\u00adsions \nproduce equivalent types. This concept is built-in because it plays a special role in the type checking \nof constrained templates. When the constraint SameType<S, T> appears in a where clause (where S and T \nare arbitrary type expressions), the type checker assumes that S and T denote the same type. For example, \nthe STL iter swap() template requires that the value types of the two itera\u00adtors be equivalent. template<MutableForwardIterator \nIter1, MutableForwardIterator Iter2> where SameType<Iter1::value type, Iter2::value type> void iter swap(Iter1 \na, Iter2 b) { swap(*a, *b); } find.cpp: In function Iter find(Iter, Iter, Val) : find.cpp:7: error: no \nmatch for operator< in first < last .../concepts.h:169: note: candidates are: bool std::SignedIntegral<Iter::difference_type>::operator<(const \nIter::difference_type&#38;, const Iter::difference_type&#38;) Figure 3. ConceptGCC error message produced \nwhen attempting to compile the erroneous de.nition of .nd(). When the type checker considers the call \nswap(*a,*b), it knows that the type of *a and the type of *b are the same type, which allows template \nargument deduction for swap() to succeed. The iter swap function also illustrates how one template may \nuse another template. In this case, swap() is implicitly instantiated on the iterator s value type and \nswap() requires Copy Constructible and Assignable. The Mutable Forward Iterator concept includes the \nrequirement that its value type satisfy these concepts. The where clause of iter swap therefore introduces \nthese as assumptions in the body of iter swap, allowing the instantiation of swap to type\u00adcheck.  3.1.2 \nNegative Constraints All of the constraints described thus far have been concept con\u00adstraints which can \nbe satis.ed only when the concept arguments model the concept. For example, a constraint InputIterator<Iter> \nis only satis.ed when the type Iter is a model of Input Iterator. Negative constraints, on the other \nhand, are only satis.ed when the concept arguments do not model the concept. A negative constraint !ForwardIterator<Iter> \ncan be satis.ed by a type Iter that is only an Input Iterator, or not even an iterator at all. Negative \nconstraints are most useful for directing algorithm spe\u00adcialization when selection among specializations \nis ambiguous. In the following example, we provide three different implementations of sort() with different \nconcept requirements: template<Sequence S> where LessThanComparable<S::value type> void sort(S&#38; s) \n{ vector<S::value type> v(s.begin(), s.end()); quick sort(v); copy(v.begin(), v.end(), s.begin()); } \ntemplate<SortedSequence S> void sort(S&#38;) {} template<RandomAccessSequence S> where LessThanComparable<S::value \ntype> void sort(S&#38; s) { quick sort(s); } If this sort() routine were called with a sorted array, \nwhich models both the Sorted Sequence and Random Access Sequence concepts, compilation would fail with \nan ambiguity [27], because neither the second nor the third sort() is better than the other. Negative \nconstraints can be used to break such ties, by excluding types that model certain concepts. We augment \nthe where clause of the third sort() to reject sorted sequences, resolving the ambiguity: template<RandomAccessSequence \nS> where LessThanComparable<S::value type> &#38;&#38; !SortedSequence<S> void sort(S&#38; s) { quick \nsort(s); } 3.1.3 Constraint Propagation Constraint propagation is a language mechanism that gathers \ncon\u00adstraints on type parameters that are induced by other constraints on the same type parameter. Constraint \npropagation often allows the omission of obvious constraints, simplifying the expression of concept-constrained \ntemplates. In our experience, the lack of con\u00adstraint propagation leads to verbose speci.cations of generic \nfunc\u00adtions and interfaces [16, 29]. Concepts support constraint propagation by propagating the re\u00adquirements \nfrom any concepts or templates used in the declaration of an entity (concept, generic function, or generic \ndata structure) into the where clause of that entity. For example, consider the fol\u00adlowing simple wrapper \nfunction that sorts a list: template<LessThanComparable T> void sort container(list<T>&#38;c) { c.sort(); \n} The list class template, shown in Section 3.1, requires that its type parameter T model the Copy Constructible \nconcept. The list<T>::sort() method introduces the additional requirement that T be Less Than Comparable. \nWithout constraint propagation, our sort container() function would fail to compile, because it does \nnot guarantee that T is a model of Copy Constructible, and there\u00adfore cannot use list<T>. That T should \nbe Copy Constructible is obvious from the dec\u00adlaration of sort container():if T were not Copy Constructible, \nthe user could not have created an object of type std::list<T> to pass to sort container(). Constraint \npropagation scans the declaration of constrained function templates identifying places where other templates \nare used, then adds the constraints of those templates to the where clause. These constraints can then \nbe assumed to hold, when type-checking the de.nition of the constrained func\u00adtion template, as discussed \nin Section 4.4. With sort container(), the presence of list<T> in the declaration causes the requirements \nof list<T> (i.e., CopyConstructible<T>) to be propagated, es\u00adsentially replacing the declaration with \nthe following: template<LessThanComparable T> where CopyConstructible<T> void sort container(list<T>&#38; \nc); Concepts provide a special form of constraint propagation for types that are passed to or returned \nfrom functions. For each type T that is passed by value, the constraint CopyConstructible<T> will be \npropagated into the where clause. The following min value() function propagates CopyConstructible<T>, \nbecause T is both passed as a parameter by value and returned by value. Without constraint propagation, \nthis generic function would fail to compile when the return statement attempts to copy the result. template<LessThanComparable \nT> Tmin value(T x, T y) { return x < y? x : y; }  3.2 Concept De.nitions A concept de.nition is a namespace-level \nentity that bundles to\u00adgether a set of requirements and names them. A concept consists of a parameter \nlist, an (optional) re.nement clause, an (optional) where clause, and a body (optionally) specifying \nfurther require\u00adments speci.c to this concept. The body can specify three kinds of requirements on the \nconcept parameters: signatures, associated types, and (nested) where clauses. We can de.ne a concept \nnamed Forward Iterator with a single type parameter, Iter, as follows: concept ForwardIterator<typename \nIter> { ... }; The parameter(s) of a concept are placed after the concept name, to emphasize that the \nparameters are mandatory. We could have used a template header, as is done for class and function templates. \nHowever, unlike class and function templates, a concept without any parameters does not make sense, because \nconcepts describe requirements on their parameters. The typename keyword speci.es a type parameter; concepts \ncan also have template and non-type (e.g., integer) parameters. 3.2.1 Re.nement Typically, we de.ne a \nconcept in terms of previously de.ned con\u00adcepts using a form of inheritance called re.nement. Re.nement \nis expressed using the same syntax as inheritance, to emphasize the is-a relationship between concepts. \nWe can de.ne a concept Bidi\u00adrectional Iterator in terms of Forward Iterator: concept BidirectionalIterator<typename \nIter> :ForwardIterator<Iter> { ... }; A concept may re.ne any number of other concepts. Because concepts \ndo not contain state, the repetition of re.nements is not a problem either theoretically or practically. \nConcepts contain sets of requirements, and set union simply ignores duplicates. 3.2.2 Associated Types \nOften, we design types that rely critically on related types. For example, a graph type may refer to \nthe types of edges and vertices, which are used in most graph operations. Thus, the concept Graph used \nto express generic graph algorithms may require that a graph type name its edge and vertex types, so \nthat the concept can refer to these types in its signatures: concept Graph<typename G> { typename edge; \ntypename vertex; ... edge .nd edge(vertex u, vertex v, const G&#38; g); }; Associated types are are place-holders \nfor actual types, that is, con\u00adcept they are implicit parameters to the concept. However, associ\u00adated \ntypes are nested inside the concept because they are entirely determined by the concept and its (explicit) \nparameters. For in\u00adstance, if we are given a type G that is a graph, we can determine its edge and vertex \ntypes because they are part of the graph de.ni\u00adtion. The converse is not true: there may be many graph \ntypes that all share the same vertex and edge types, particularly for common indexing types (int) or \nopaque pointers (void*). A concept may provide a default for an associated type. The default type need \nnot be well-formed if the concept map provides the type de.nition so that the default isn t used. For \nexample, we can de.ne the Input Iterator concept to require four associated types that default to nested \ntype de.nitions in the iterator: concept InputIterator<typename Iter> { typename value type = Iter::value \ntype; typename reference = Iter::reference; typename pointer = Iter::pointer; typename di.erence type \n= Iter::di.erence type; ... }; It is possible to eliminate associated types by replacing each as\u00adsociated \ntype with a new concept parameter. However, doing so makes the use of concepts much more verbose, because \neach refer\u00adence to the concept will need to specify all of the type parameters, even when most of those \nparameters are not directly used by most generic algorithms [15,16]. For instance, in the following .nd() \nal\u00adgorithm, we must mention the Reference, Pointer, and Di.erence type parameters even though they are \nunused: template<typename Iter, typename Value, typename Reference, typename Pointer, typename Di.erence, \nEqualityComparable<Value> T> where InputIterator<Iter, Value, Reference, Pointer, Di.erence> Iter .nd(Iter \n.rst, Iter last, T v); 3.2.3 Nested Requirements Nested requirements allow the use of other concepts \nto express re\u00adquirements on a concept s type parameters and associated types. Consider the STL Container \nconcept. Its associated iterator type satis.es the requirements of Input Iterator. Furthermore, the con\u00adtainer \ns value type must be the same type as the iterator s value type. concept Container<typename X> { typename \nvalue type; InputIterator iterator; where SameType<value type, InputIterator<iterator>::value type>; \n}; Note the use of Input Iterator as the type of the associated type iterator. This is the shorthand \nfor: typename iterator; where InputIterator<iterator>; 3.2.4 Function Signatures Signatures express \nrequirements for speci.c functions or operators. During type checking, they serve two purposes. When \nchecking a concept map de.nition, signatures specify the functions that must be implemented by a concept \nmap. When checking a template de.nition, signatures specify some of the operations that may be legally \nused in its body. Syntactically, an abstract signature is just a normal C++ func\u00adtion declaration or \nde.nition. A signature may be followed by a function body, providing a default implementation to be used \nif a concept map does not de.ne the function (see Section 3.4 for more details and an example). The following \nde.nition of the Equality Comparable concept includes two signatures, the second of which has a default \nimplementation: concept EqualityComparable<typename T> { bool operator==(const T&#38; x, const T&#38; \ny); bool operator!=(const T&#38; x, const T&#38; y) {return !(x==y);} }; An operator signature can \nbe satis.ed either with a free function de.nition (at global scope, in a namespace, or in a concept map) \nor a member function de.nition. Operators that normally are only allowed as member functions may be expressed \nas normal free functions in concept requirements. For instance, the Convertible concept describes the \nrequirement for an implicit conversion from one type to another: concept Convertible<typename T, typename \nU> { operator U(const T&#38;); }; The requirement that an operation must be implemented as a mem\u00adber \nfunction is expressed with an abstract signature quali.ed by the type. For example, in the following \nContainer concept there is a re\u00adquirement for an empty member function for type X. Constructor requirements \nare expressed similarly. concept Container<typename X> { bool X::empty() const; X::X(int n); }; A concept \nmay require a function template via a signature template, which may itself be a constrained template. \nThe following Sequence concept illustrates the use of a signature template to describe the STL sequence \nconstructors that allow one to construct, for instance, a vector from a pair of list iterators. concept \nSequence<typename X> { typename value type; template<InputIterator InIter> where Convertible<InIter::value \ntype, value type> X::X(InIter .rst, InIter last); }; We are investigating an alternative to abstract \nsignatures, called use patterns [12], which express operation requirements via expres\u00adsions that illustrate \nhow concept parameters can be used, rather than declarations that state what concept parameters provide. \nMuch of the design of concepts is independent of the syntax used to describe required operations.  3.3 \nOverloading and Specialization Using concepts, the Generic Programming notion of specializa\u00adtion takes \non two different forms. The most commonly used form of specialization is concept-based overloading, which \nallows the names of function templates to be overloaded on their where clauses. This form of specialization \nreferred to as concept-based overloading permits the expression and selection of the most spe\u00adci.c algorithm \nfor a particular task. Here we revisit the discussion of the advance() function from Section 2.2 in more \ndetail. There are three potential implementations of advance(), depending on the characteristics of the \niterator: Input Iterators can be moved for\u00adward with n increments Bidirectional Iterators can be moved \neither forward or backward in |n| steps, and Random Access Iterators can jump forward or backward any \ndistance in constant time. These three functions can be expressed as overloaded function templates follows: \ntemplate<InputIterator Iter> void advance(Iter&#38; iter, Iter::di.erence type n) { while (n--)++iter; \n} template<BidirectionalIterator Iter> void advance(Iter&#38; iter, Iter::di.erence type n) { if (n \n> 0) { while (n--)++iter; } else { while (n++) --iter; } } template<RandomAccessIterator Iter> void \nadvance(Iter&#38; iter, Iter::di.erence type n) { iter += n; } An invocation of the advance() function \nwill select the most spe\u00adci.c implementation of the advance() function based on the ca\u00adpabilities of \nthe type provided. In the following three examples, the Input Iterator, Bidirectional Iterator, and Random \nAccess Itera\u00adtor versions of advance() will be invoked, respectively: void advancement(istream iterator<int> \nii, list<string>::iterator lsti, vector<.oat>::iterator vi) { advance(ii, 17); advance(lsti, 17); advance(vi, \n17); } Concept-based overloading is particularly interesting when an overloaded function such as advance() \nis called from within an\u00adother generic function. The STL lower bound() algorithm, for instance, performs \na binary search for a given value within a se\u00adquence denoted by iterators. An implementation of lower \nbound() (extracted from ConceptGCC) follows. template<ForwardIterator Iter> where LessThanComparable<Iter::value \ntype> Iter lower bound(Iter .rst, Iter last, const Iter::value type&#38; value) { Iter::di.erence type \nlen = distance(.rst, last); Iter::di.erence type half; Iter middle; while (len > 0) { half = len >> 1; \nmiddle = .rst; advance(middle, half); if (*middle < value) { .rst = middle; ++.rst; len = len - half \n- 1; } else len = half; } return .rst; } The implementation of lower bound() relies on two auxiliary \nfunc\u00adtions: advance() and distance(); advance() moves the iterator forward some number of steps (to .nd \nthe new middle ), while distance() determines the length of the sequence. The algorithm itself can operate \non Forward Iterators, providing a logarithmic number of comparisons but a linear number of iterator increment \noperations due to the linear-time implementations of advance() and distance(). However, when the algorithm \nis provided with a Random Access Iterator, concept-based overloading selects the constant-time versions \nof advance() and distance() to effect a lower bound() algorithm with a logarithmic number of compar\u00adisons \nand iterator movements: list<int> lst; binary search(lst.begin, lst.end(), 17); // O(n) movements vector<int> \nv; binary search(v.begin, v.end(), 17); // O(lg n) movements The mechanism that ensures that the most \nef.cient forms of advance() and distance() are selected is similar to the two\u00adphase name lookup facility \nof C++ templates, because it performs some type-checking at template de.nition time but defers the .\u00adnal \ndecision until instantiation time. When a template such as lower bound() is initially parsed, overload \nresolution solution re\u00adsolves calls by selecting a seed function, which is the most speci.c function \nthat meets the minimal requirements of the template be\u00ading parsed. The call to advance() therefore resolves \nto the Input Iterator variant of advance(), because lower bound() is only guar\u00adanteed to pass a Forward \nIterator to advance(). Later, when the template is instantiated with a given set of concrete template \nar\u00adguments, overload resolution for the call is performed a second time with an expanded set of candidate \nfunctions. The set of candi\u00addate functions includes the seed function selected in the .rst phase (at \ntemplate de.nition time) and all other functions that meet the following three criteria: The function \noccurs within the same lexical scope as the seed function,  the function s template parameters, return \ntype, and argument types are identical to those of the seed function, and  the requirements in the function \ns where clause are stricter than those of the seed function s where clause.  These criteria represent \na compromise between the ideal of modular type checking for templates and the need to select the most \nef.cient function for any given operation. By limiting the set of candidate functions to those with identical \nsignatures, we en\u00adsure that type errors cannot occur when more speci.c functions are found. However, \nby allowing functions that are more speci.c than the seed to enter the candidate set even if they are \ndeclared after the calling function we free ourselves from ordering depen\u00addencies and allow the most \nef.cient operations to be selected in the vast majority of important cases. Note, however, that even \nwith the restrictions we are placing on the candidate set we have not eliminated all sources of instantiation-time \nerrors: ambiguities in the overload resolution process can still occur, a topic which we discuss in a \nseparate paper [27]. In practice, we have found that instantiation-time errors due to ambiguities are \nvery rare. By ensuring that the most ef.cient form of advance() is se\u00adlected, algorithms can be written \nin a very generic style without sac\u00adri.cing performance due to that genericity. The same two-phase strategy \napplies to the selection of class template partial specializa\u00adtions. In the following example we de.ne \na dictionary template that selects among three alternatives for lookup: a balanced binary tree, a hash \ntable, or a hash table using sorted separate chains. These three alternatives are expressible as constrained \npartial specializa\u00adtions of the primary dictionary template: template<EqualityComparable Key, Regular \nValue> class dictionary; template<EqualityComparable Key, Regular Value> where LessThanComparable<Key> \nclass dictionary<Key, Value> {/*use balanced binary tree */ }; template<Hashable Key, Regular Value> \nwhere EqualityComparable<Key> class dictionary<Key, Value> {/*use hash table */ }; template<EqualityComparable \nKey, Regular Value> where Hashable<Key>&#38;&#38; LessThanComparable<Key> class dictionary<Key, Value> \n{/*use hash table with sorted chains */ }; Concept-based overloading and specialization are crucial to \nsup\u00adport the Generic Programming ideal of always selecting the most ef.cient operation or data structure \nbased on complete type infor\u00admation. These features follow naturally from the expression of con\u00adstrains \nvia where clauses, and integrate seamlessly into the existing C++ rules governing partial ordering of \ntemplates.  3.4 Concept Maps One of the strengths of Generic Programming in C++ is that tem\u00adplates allows \nusers to instantiate templates with types providing a variety of interfaces. For example, the sort algorithm \naccepts point\u00aders and user-de.ned iterators and the vector container can hold both built-in types and \nuser-de.ned types. Unconstrained templates per\u00admit a variety of interfaces by allowing a built-in range \nof variations in argument passing style, operations declared as member vs. free functions, etc. With \nconcepts, we generalize this notion to an arbi\u00adtrary, user-de.ned mapping from a type to a concept, established \nby a concept map. A concept map de.nition establishes that a type is a model of a concept and de.nes \na mapping that states how the type models the concept. This mapping can include specifying associated \ntypes (e.g., the value type of an iterator) or providing de.nitions for the operations required by a \nconcept. Concept maps establish a modeling relationships, so a concept map is often called a model. Consider \nthe following example: class student record { public: string id; string name; string address; bool id \nequal(const student record&#38;); bool name equal(const student record&#38;); bool address equal(const \nstudent record&#38;); }; While the student record type is useful for storing information about students, \nfrom the point of view of many algorithms (e.g., .nd()) it lacks a way of comparing records. We could \nof course add such a comparison, but there are several ways of comparing records, so we prefer to de.ne \na comparison speci.cally for the Equality Comparable concept used by .nd() and its brethren: concept \nmap EqualityComparable<student record>{ bool operator==(const student record&#38; a, const student record&#38; \nb) {return a.id equal(b); } }; A map is de.ned from the student record type to the Equality Comparable \nconcept. This concept map is used whenever a tem\u00adplate requires student record to be Equality Comparable. \nIn partic\u00adular, when an algorithm uses == on a parameter declared Equality Comparable that is instantiated \nwith a student record, the == de\u00ad.ned in the concept map EqualityComparable<student record> is used. \nWe do not have to redesign student record to match the al\u00adgorithms requirements or separately de.ne a \nnew type to provide a mapping. Nor do we need to de.ne the meaning of == for all code in our program. \nConcept maps allow us to provide an interface to our data types that is speci.c to a given concept without \ninterfer\u00ading with the interfaces of other concepts or making that interface global. When a concept map \nis declared, its de.nition is checked for consistency against the concept. Each of the signatures in \nthe con\u00adcept must be satis.ed by a function de.nition in the concept map, each associated type must be \nsatis.ed by a type de.nition in the concept map, and, and all nested requirements must be satis.ed. For \nany signatures or associated types not provided by the concept map, default versions will be synthesized \neither from the lexical scope of the concept map (for signatures) or from the defaults pro\u00advided in the \nconcept. Thus, when the default de.nitions for signa\u00adtures and associated types are correct for a given \nset of types, the concept map de.nition may be empty. For example, in the follow\u00ading concept map de.nition \nthe built-in integer == and != operators will be used to satisfy the requirements of Equality Comparable: \nconcept map EqualityComparable<int>{}; Concept maps can be templated. For example, the following de.\u00adnition \nsays that any pointer type can be used as a Mutable Random Access Iterator: template<typename T> concept \nmap MutableRandomAccessIterator<T*>{ typedef Tvalue type; typedef T&#38; reference; typedef T*pointer; \ntypedef ptrdi. t di.erence type; }; Concept map templates can express nontrivial relationships. For instance, \nthe STL vector class is Equality Comparable whenever its type parameter T is Equality Comparable: template<EqualityComparable \nT> concept map EqualityComparable<vector<T>>{}; Possibly the most important use of concept map templates \nis to compose generic libraries. Often, two libraries will provide com\u00adponents that are related because \nthey express the same fundamen\u00adtal idea, but syntactic differences prevent reuse of the components. Concept \nmaps can be used to adapt the syntax of one concept to the syntax of the other. More importantly, this \nmapping can be performed even when the concepts represent entities from differ\u00adent application domains. \nConsider a graph G =(V, E), where E . V \u00d7V . Theoretically, one can view the graph G as a |V |\u00d7|V |one-zero \nmatrix A, where Ai,j =1when (i, j). E and Ai,j =0 when (i, j)./E. Concept maps allow us to express this \nrelation\u00adship directly, so that any data structure that is a model of Graph can also be used with a linear \nalgebra library that expects a Matrix: template<Graph G> concept map Matrix<G> { typedef int value type; \nint rows(const G&#38; g) { return num vertices(g); } int columns(const G&#38; g) { return num vertices(g); \n} double operator()(const G&#38; g, int i, int j) { if (edge e = .nd edge(ith vertex(i, g), ith vertex(j, \ng), g)) return 1; else return 0; } }; my graph g = read graph(); vector<int> x=compute ith eigenvector(g, \n0); By expressing the mapping from graph theory into linear algebra, we are able to immediately reuse \nthe algorithms from the domain of linear algebra to compute such properties as graph eigenvalues [7]. \nWe only require lightweight mappings expressed via concept maps, which will be optimized away by the \ncompiler s inliner. Concept maps therefore permit cross-domain fertilization through the com\u00adposition \nof separately developed libraries. 3.4.1 Implicit and Explicit Concepts Writing concept maps can be a \nburden to the user of constrained templates: before using a template a programmer must declare how the \nargument types map to the appropriate concepts. It would be convenient if instead the compiler would \nperform a check to see if a mapping is actually necessary. That is, the compiler could simply check if \na type has the required types and operations. Unfortunately, such an implicit ( structural ) check can \n(in our design) only take into account syntactic properties of a type, whereas signi.cant dif\u00adferences \ncan be semantic. This introduces the potential for run-time errors in what would otherwise be innocuous \nsituations. Consider: istream iterator<int> .rst(cin), last; vector<int> v(.rst, last); This should \ninitialize a vector from standard input, but if implicit matching is used, it instead results in an empty \nvector or a run-time error. The reason is that vector de.nes two overloads for its range constructor: \na slow version that grows the vector incrementally, and a faster version that relies on the multi-pass \ncapabilities of a Forward Iterator to determine the size of the range and resize the vector ahead of \ntime. template<CopyConstructible T> class vector { template<InputIterator Iter> where Convertible<Iter::value \ntype, T> vector(Iter .rst, Iter last); // slow template<ForwardIterator Iter> where Convertible<Iter::value \ntype, T> vector(Iter .rst, Iter last); // fast ... }; The istream iterator does not provide multi-pass \ncapabilities, how\u00adever it structurally (syntactically) satis.es the requirements of For\u00adward Iterator. \nTherefore, the constructor call would resolve to the more specialized (faster) version. This would read \nthe input and re\u00adserve space in the vector, but it would not be able .ll the vector in a second pass \nthrough the input range because the input will have been consumed in the .rst pass. The author of a concept \ncan choose between explicit and im\u00adplicit concepts. Concepts with important semantic aspects that are \nused for overloading should be explicit; other concepts can be im\u00adplicit. An implicit concept is identi.ed \nby placing the auto keyword in front of concept. For example, the following is the Equality Com\u00adparable \nconcept speci.ed to allow implicit matching: auto concept EqualityComparable<typename T> { bool operator==(const \nT&#38; x, const T&#38; y); bool operator!=(const T&#38; x, const T&#38; y) {return !(x==y);} };  3.4.2 \nRe.nements and Concept Maps When a concept map is de.ned for a concept that has a re.nement clause, concept \nmaps for each of the re.nements of that concept are implicitly de.ned. For example, the concept map in \nSection 3.4 that makes pointers a model of Mutable Random Access Iterator also makes pointers model Random \nAccess Iterator, Bidirectional Itera\u00adtor, Forward Iterator, etc., because Mutable Random Access Iterator \nre.nes all of the iterator concepts, either directly or indirectly. The implicit generation of concept \nmaps for re.nements min\u00adimizes the number of concept maps that users must specify for a given re.nement \nhierarchy. It suf.ces to provide a concept map for the most re.ned concept that the concept arguments \nmodel, as we have done for pointers in the iterator hierarchy. Beyond the bene.ts of reducing the amount \nof effort users must expend writing concept maps, the implicit generation of concept maps allows re.nement \nhierarchies to evolve without breaking ex\u00adisting code. As re.nement hierarchies evolve, they tend to \nmove from coarse-grained approximations to .ner-grained approxima\u00adtions, as new models, whose behavior \n.ts in between two existing concepts, are discovered. For example, the Forward Iterator intro\u00adduces two \nnew kinds of requirements on top of the Input Iterator concept it re.nes: the need for the reference \nassociated type to be a true reference and the multi-pass property that allows repeated iteration through \nthe sequence of values. Since the inception of the STL iterator concepts, iterator types that provide \nthe latter property but not the former (such as a counting iterator that enumerates values) have become \nmore prevalent, leading to the introduction of a Multi Pass Input Iterator concept [6] that sits between \nInput Iter\u00adator and Forward Iterator in the re.nement hierarchy. Without the implicit generation of concept \nmaps for re.nement, the introduc\u00adtion of this new iterator concept would break code based on the ex\u00adisting \nhierarchy, because every Forward Iterator concept map would have to be augmented with a new concept map \nfor Multi Pass Input Iterator. With implicit generation of concept maps for re.nements, a concept hierarchy \ncan evolve to a more .ne-grained structure over time, without breaking backward compatibility. 4. ConceptGCC \nTo evaluate our proposed extensions to C++, we implemented con\u00adcepts in the GNU C++ compiler [17] and \nreimplemented the STL using concepts (Section 5). Our concept-enhanced version of GCC is freely available \nfrom the ConceptGCC web site [19] . Here, we provide an overview of ConceptGCC and discuss several of \nthe implementation techniques we employed. We refer the interested reader to [21] for additional details \nof concept compilation. The aim of ConceptGCC is partially to provide us a tool with which to experiment \nwith the use of concepts, and partially to demonstrate that concepts can be integrated into real compilers. \nFor concepts to become accepted as part of C++0x we must make it plausible that such integration is possible \nand economical in all major C++ compilers, and ensure that there is a great deal of practical experience \nwith concepts prior to standardization [24]. 4.1 Compilation Model There are many potential compilation \nmodels that could be applied to C++ templates [69]. However, existing C++ compilers implement the so-called \ninclusion model of templates, where the de.nition of a template must be available wherever the template \nis used. When a particular instance of a template is needed, the compiler instantiates the template by \nsubstituting the concrete types needed by the instance for the corresponding template parameters. The \nresult is code that is speci.c to and optimized for a particular use of the template. Coupled with compiler \noptimizations such as inlining and copy propagation, template instantiation enables generic C++ libraries \nto produce code as ef.cient as hand-tuned FORTRAN [34, 55, 68]. ConceptGCC retains the template inclusion \nmodel of compila\u00adtion. This decision was motivated by the need for backwards com\u00adpatibility, the need \nto .t into existing C++ compilers, and the need to provide the performance currently delivered using \nunconstrained templates. The bene.ts of improved type-checking for templates would be weakened if they \nrepresented a trade-off in performance. The adoption of the template inclusion model of compilation precludes \nseparate compilation for C++ templates. In this C++ con\u00adstrained generics (concepts) differ from C# and \nJava generics. In C# and Java the default is that all instances of a generic method share the same native \ncode. However, C# has some .avor of the instantiation model: different code is generated for each different \ninstantiation of a generic method whose type arguments are value types. To attain apparent separate compilation, \nthis instantiation\u00adspeci.c code is generated at run time. The G language [57 59] shares syntactic constructs \nwith our design for C++ However, G differs in that it provides separate compilation and therefore implements \na weaker form of concept\u00adbased overloading than we propose for C++ concepts. Concept\u00adbased overloading \nin G is resolved exclusively based on the lexical information available prior to template instantiation, \nwhereas we postpone part of the overload resolution until after instantiation, when more information \nis available. This more powerful facility for dispatching prevents the separate compilation of template \ndef\u00adinitions, and also prevents completely separate type checking, as overload ambiguities may occur \nduring instantiation. We report on these and other issues in another paper [27]. Overall, the inclusion \nmodel of templates is the best match for C++ at this time, although we plan to further explore the interaction \nbetween specialization and separate compilation. 4.2 Concepts and Concept Maps The concept map lookup \nprocess shares so much with the nor\u00admal C++ template instantiation process that compiling concepts and \nconcept maps into class templates provides a reasonable implemen\u00adtation approach. Concepts are compiled \nto class templates and con\u00adcept maps are compiled to (full) specializations of those class tem\u00adplates. \nConcept map templates are compiled to partial specializa\u00adtions of the class templates. ConceptGCC exploits \nthis similarity completely, representing re.nement via (virtual) inheritance, func\u00adtion signatures as \nstatic member functions, and associated types as nested typedefs. Concept maps provide the same static \nmember functions and typedefs as in their concept s class. Using this representation, Con\u00adceptGCC is \nable to directly reuse much of the existing C++ front end functionality, including quali.ed name lookup \n(used to .nd as\u00adsociated types and signatures in concepts and concept maps), name lookup in base classes \n(used to .nd associated types and signa\u00adtures in re.nements), template instantiation (for synthesizing \ncon\u00adcept maps from concept map templates and implicitly matching concepts), and partial ordering of templates \n(for concept map se\u00adlection and concept-based overloading). Although concepts are se\u00admantically distinct \nfrom class templates, their structural similarities can greatly reduce the implementation cost of introducing \nconcepts into an existing C++ compiler. Figure 4 shows the compilation of a simple concept and concept \nmap de.nition. 4.3 Compilation of Constrained Templates The de.nition of a constrained template is compiled \nso that expres\u00adsions that refer to function signatures from the where clause are translated into expressions \nthat make explicit quali.ed calls into the class specializations for the appropriate concept map. For \nex\u00adample, the expression: s=s+ *.rst from the sum() example in Section 2.1 is translated into the fol\u00adlowing: \nAddable<value type>::operator+(s, InputIterator<Iter>::operator*(.rst)) The completely transformed version \nof the sum() algorithm looks like this: template <typename Iter> T sum(Iter .rst, Iter last, Iter::value \ntype s) { typedef InputIterator<Iter>::value type value type; for (; InputIterator<Iter>::operator!=(.rst, \nlast); InputIterator<Iter>::operator++(.rst)) Assignable<value type>::operator=( s, Addable<value type>::operator+( \ns, Convertible<reference>::operator value type( InputIterator<Iter>::operator*(.rst)))); return CopyConstructible<value \ntype>::value type(s); } Note that this translation is reminiscent of dictionary-based schemes for separate \ncompilation of generics: in effect, the instantia\u00adtion process is acting as dictionary lookup, because \nresolving Addable<value type> involves .nding the best matching concept map (selecting a dictionary) \nand extracting its operator+ acts as lookup into the dictionary. The main difference between this trans\u00adlation \nand dictionary passing is that here the lookup is performed at compile-time and there is no run-time \ndata-structure passed to the generic function.  4.4 Type-checking Templates The visible bene.ts of concepts \ncome from the introduction of modular type checking for templates. Not surprisingly, so do most of the \nimplementation challenges. It is a common misconception that C++ template de.nitions are completely unchecked \nwhen they are initially parsed. In fact, type-checking templates is a two-stage process. In the .rst \nstage, when parsing the template de.nition, a C++ compiler will type-check any non-dependent expressions, \ni.e., those that do not depend on any template parameters. Any depen\u00addent expressions (i.e., those that \nsomehow depend on a template parameter) will be stored in an abstract syntax tree without any type information. \nIn the second stage, during template instantiation, con\u00adcrete types are substituted for template parameters \nthroughout the concept Addable<typename T> {T operator+(const T&#38;, const T&#38;); template<typename \nT> class Addable; }; concept map Addable<big int> {big int operator+(const big int&#38; a, const big \nint&#38; b) { return a.plus(b); }}; =. template<> class Addable<big int> {static big int operator+(const \nbig int&#38; a, const big int&#38; b) { return a.plus(b); }}; Figure 4. Compilation of concepts and \nconcept maps. abstract syntax tree. This process makes all dependent expressions non-dependent, thereby \ntype-checking the entirety of the template with concrete types. ConceptGCC implements modular type checking \nby making dependent expressions into non-dependent expressions in the .rst stage, so that the entire \ntemplate de.nition will be type-checked when it is initially parsed. To do so, ConceptGCC generates an \narchetype [56] for each template parameter, using the archetype for type-checking in lieu of its corresponding \ntemplate parame\u00adter. Archetypes are placeholder types that de.ne only the oper\u00adations that have been \nstated by concept requirements involving the template parameters. For instance, the archetype for tem\u00adplate \nparameter T in the swap() function of Section 3.1 will only have two operations de.ned: a copy constructor, \nprovided by CopyConstructible<T>, and an assignment operation, provided by Assignable<T>. Due to the \nuse of archetypes and making more expressions non\u00addependent, the implementation of modular type-checking \nin Con\u00adceptGCC required far fewer changes to the compiler or language semantics than we had anticipated. \nMoreover, by placing both con\u00adstrained and unconstrained template compilation into the same framework \nof (non-)dependent expressions, we are able to com\u00adpile partially-constrained templates where some parameters \nhave been explicitly marked unconstrained. These templates have been found useful for the introduction \nof concepts into existing C++ li\u00adbraries, and may play a further role when template libraries need to \nbreak modular type checking in a localized way to perform some useful but type-unsafe operation. 4.4.1 \nSame-type Constraints Same-type constraints are requirements (contained either in a where clause or as \na nested requirement in a concept) that two types be equivalent. When type checking the de.nition of \na tem\u00adplate, same-type constraints in the where clause affect which types are considered equal. Consider \nthe includes() function template: template<InputIterator InIter1, InputIterator InIter2> where SameType<InIter1::value \ntype, InIter2::value type> &#38;&#38; LessThanComparable<InIter1::value type> bool includes(InIter1 .rst1, \nInIter1 last1, InIter2 .rst2, InIter2 last2) {... if (* .rst2 < * .rst1) ... } In the body of includes(), \nthe type InIter1::value type is con\u00adsidered the same type as InIter2::value type. This equivalence is \nimportant; consider * .rst2 < * .rst1. Because the < opera\u00adtor is de.ned as a type-symmetric operation \non the .rst iterator s value type. The compiler must use the equivalence between the two value types \nto type-check this function template. Type equality is an equivalence relation: it is re.exive, transi\u00adtive, \nand symmetric. Thus, a same type constraint may imply many other type equalities. The following template \nis an example where transitivity is required for type checking: the compiler must deduce that R is the \nsame type as T: template<typename R, typename S, LessThanComparable T> where SameType<R,S> &#38;&#38; \nSameType<S,T> bool foo(R r, S s, T t) { return r<s&#38;&#38;r<t; } Type equality is also congruence relation. \nFor example, if we have SameType<S,T> then SameType<vector<S>,vector<T>> holds. Conversely, SameType<vector<S>,vector<T>> \nimplies SameType<S,T>. The compiler must also ensure that the same\u00adtype constraints appearing in a where \nclause do not con.ict. For example, if the where clause contains (or implies) a constraint such as SameType<int,char>, \nthe compiler should produce an error. The problem of determining whether two types are equal given a \nset of same-type constraints is an instance of the congruence clo\u00adsure problem. The congruence closure \nproblem already shows up in modern compilers, for example, in common sub-expression elim\u00adination. There \nare ef.cient algorithms for the congruence closure problem: the algorithm by Nelson and Oppen [48] is \nO(n log n) time complexity on average, where n is the number of type nodes. It has O(n 2) time complexity \nin the worst case. This can be im\u00adproved by instead using the slightly more complicated Downey\u00adSethi-Tarjan \nalgorithm which is O(n log n) in the worst case [13]. The propagation of same-type constraints affects \nmore than types. For instance, it can cause concept maps introduced by a where clause to become duplicated. \nThis is particularly com\u00admon with nested requirements. For instance, in the following example the same-type \nconstraint that makes the two iterator s di.erence types equivalent also means that the two SignedIntegral \nconcept maps are now a single concept map. In ConceptGCC, we remove duplicates from the list of requirements \nonce all same-type constraints have been processed. concept InputIterator<typename Iter> { SignedIntegral \ndi.erence type; // ... }; template<InputIterator Iter1, InputIterator Iter2> where SameType<Iter1::di.erence \ntype, Iter2::di.erence type> void f(Iter1 .rst1, Iter1 last1, Iter2 .rst2); Same-type constraints change \nthe notion of type equivalence in C++. An ef.cient implementation of same-type constraints, based on \ncongruence closure, is provided by the compiler for G [58, 59]. Within ConceptGCC, however, we were forced \nto implement a simple disjoint sets data structure augmented by deep type com\u00adparisons, because GCC s \ninternal representation of types is not amenable to congruence closure algorithms.  4.4.2 Use of Class \nTemplates and Specializations Generic functions and data structures are often implemented using other, \ngeneric data structures. For instance, the STL mismatch() algorithm returns a pair of iterators: template<InputIterator \nIter1, InputIterator Iter2> where EqualityComparable<Iter1::reference, Iter2::reference> pair<Iter1, \nIter2> mismatch(Iter1 .rst1, Iter1 last1, Iter2 .rst2) { while (.rst1 != last1 &#38;&#38; *.rst1 == *.rst2) \n{ ++.rst1; ++.rst2; } return pair<Iter1, Iter2>(.rst1, .rst2); } When type-checking the body of this \nalgorithm, the compiler must verify that the type pair<Iter1, Iter2> has a constructor accepting two \nparameters of type Iter1 and Iter2, respectively. To do so, the compile will need to look inside the \nde.nition of the class template pair, whose de.nition follows: template<typename T, typename U> class \npair { public: pair(const T&#38;, const U&#38;); // ... }; ConceptGCC implements type-checking for uses \nof class tem\u00adplates within constrained templates via archetypes. When the def\u00adinition of mismatch() is \ntype-checked, the compiler generates archetypes A Iter1 and A Iter2 for the template type parame\u00adters \nIter1 and Iter2, respectively. The compiler also generates a type equivalence between the template type \nparameters and their archetypes. At the point when the compiler requires a complete type for pair<Iter1, \nIter2> (e.g., to search for a suitable con\u00adstructor in the return statement), ConceptGCC instantiates \nthe template class pair<A Iter1, A Iter2>. Doing so creates the con\u00adstructor pair(const A Iter1&#38;, \nconst A Iter&#38;), which is invoked by the return statement. Thus, by instantiating class templates \nwith archetypes, ConceptGCC is able to type-check function templates such as mismatch() that use class \ntemplates. There are some pitfalls with instantiating class templates in\u00adside a generic function. The \nde.nitions of those class templates are required for type-checking such instantiations, but this introduces \nthe potential for instantiation-time failures that break modular type checking. In particular, it is \npossible that an instantiation of the al\u00adgorithm will select a specialization of a class template that \ndoes not provide precisely the same members as the primary template. For pair this would be absurd. However, \nnot all templates are as simple as pair. For example, containers sometimes provide opti\u00admized implementations \nfor particular argument types. In particular, the C++ vector, optimizes storage of bool to a single bit \nper value via the vector<bool> specialization [25, \u00a723.2.5]. This optimiza\u00adtion, however, changes the \ninterface in subtle ways that can lead to instantiation-time failures. Consider the following generic \nfunc\u00adtion: template<Regular T> void g(vector<T>&#38;vec) { T&#38; startval = vec.front(); // ... } The \nde.nition of this function template is correct and will type\u00adcheck properly with ConceptGCC. It will \ninstantiate properly for vectors of integers, strings, lists, employees, and nearly every other data \ntype. However, when invoked with a vector<bool> the in\u00adstantiation will fail to compile, because the \nfront() method of vector<bool> returns a proxy class type vector<bool>::reference, not a true reference. \nThis is a design .aw of the C++98 STL caused by the inability of C++98 to express a perfect proxy for \na reference. How did the vector<bool> specialization manage to subvert modular type checking? When g() \nis de.ned and type-checked, its use of vector<T> is checked against the primary class template for vector; \nthere front() returns a reference to T. The vector<bool> specialization may not even have been available \nto the compiler at the time this type-checking occurred. Later, during the instantiation of g<bool>, \nthe compiler selects the most specialized form of vector, the vector<bool>. Since vector<bool> does not \nprovide a compatible front() method, instantiation fails. There are myriad workarounds that could be \napplied to .x this problem. We could provide a specialized g() for vector<bool>. We could design a Sequence \nconcept to encapsulates the behavior required by g(), so that a call with a vector<bool> argument would \nfail because it is not a Sequence. We could eliminate the potential for these problems by placing language \nrestrictions on specializations; Siek and Lumsdaine proved [57] with the system F G that a language with \nconcepts but without specialization can provide modular type checking. To obtain modular type checking, \nwe must either restrict the use of specializations (thereby breaking the principle of always selecting \nthe most-speci.c implementation) or restrict the implementations of specializations (thereby making it \nimpossible to use template meta-programming in conjunction with constrained generics). Neither solution \nseems feasible for C++. 5. Evaluation We evaluated the ability of our concept mechanisms to express the \nideas of Generic Programming by enhancing the GNU implemen\u00adtation of the C++ Standard Template Library, \nlibstdc++, with con\u00adcepts. We could have developed a new, idealized STL-like li\u00adbrary that kept all of \nthe core ideas of the STL but adapted them to use concepts. However, we instead decided to model the \nexist\u00ading STL (modulo errors) to produce an implementation that con\u00adforms closely to the ISO C++ standard \n[25]. Doing so emphasizes the evaluation of backward compatibility: existing C++ code us\u00ading the STL \nshould still compile and produce identical results with ConceptC++. Unfortunately, modeling the existing \nSTL rather than inventing a new generic library comes with a price: some design decisions in the STL \nwould have been very different if concepts were available at the time of its inception, but we are compelled \nto model the existing design rather than improve it. The process of upgrading the Standard Template Library \n.rst in\u00advolves migrating the semi-formal concept descriptions of the C++ standard (expressed via requirements \ntables ) into concept de.ni\u00adtions. These are then used to constrain the templates algorithms, data structures, \nand adaptors of the STL. 5.1 De.ning STL Concepts The de.nition of STL concepts involves the translation \nfrom re\u00adquirements tables, which are used to express the current standard, into concepts. Figure 5 compares \nthe requirements table for the Copy Constructible concept (left-hand side, extracted from the ISO C++ \nstandard [25]) with its ConceptC++ equivalent (right-hand side). The requirements table speci.es the \nsyntax of the concept using valid expressions, which illustrate the allowed uses of the types in a concept, \nwhile the type column provides information about the return type of the valid expression. Introducing \nconcepts (shown on the right-hand side of Figure 6), we have preserved the semantics as closely as possible. \nOften, some reorganization of the requirements is necessary, but in this concept the transla\u00adtion from \nvalid expressions to signatures is straightforward. The requirements tables for other simple concepts \nAssignable, Default Constructible, Less Than Comparable, Equality Comparable, etc. translate equally \nwell into (implicit) concepts. The most interesting set of requirements tables in the STL de\u00adscribe the \niterator concepts. The left-hand side of Figure 6 illus\u00adtrates one such requirements table, which describes \nForward Itera\u00adtors. In the translation to concepts (shown on the right-hand side of Table 30, Copy Constructible \nrequirements [25] auto concept CopyConstructible<typename T> { T::T(const T&#38;); T:: T(); T* operator&#38;(T&#38;); \nconst T* operator&#38;(const T&#38;);  }; Type T is a model of Copy Constructible, t is a value of type \nT and u is a value of type const T. expression return type T(t) T(u) T:: T() &#38;t T* &#38;u const T* \n Figure 5. The requirements table for Copy Constructible compared with its representation as a concept. \nFigure 6), we again have preserved the semantics as closely as pos\u00adsible but now some reorganization \nof requirements was necessary: We have factored common requirements into re.nements. Many of the valid \nexpressions in the requirements table are already described in other tables (e.g., Default Constructible, \nCopy Constructible, Assignable, Equality Comparable, and Input Iterator). While re.nement does exist \nwithin the requirements tables, it is implicit: when the requirements in table T1 are a superset of the \nrequirements in another table T2, the concept associated with T1 re.nes T2. We have instead made re.nement \nexplicit.  We have untangled the two distinct concepts described in the requirements table into separate \nForward Iterator and Mutable Forward Iterator concepts. There is a natural re.nement rela\u00adtionship between \nthe two, as any mutable iterator (which can be read or written) is also a non-mutable iterator (which \ncan only be read).  We have collapsed the iterator traits facility [25, \u00a724.3.1], which provides access \nto the associated types of a given iter\u00adator, into the iterator concepts themselves. In doing so, we \npro\u00advide speci.c meanings for the reference and pointer associated types, which are required of STL iterators \nbut have unspeci.ed behavior.  We have translated each valid expression into a corresponding signature. \nIn some cases, such as the pre-increment expression ++r, the translation is direct and obvious. In other \ncases, we introduce a special associated type that describes the return type of the signature. The valid \nexpressions in the requirements table do not specify the exact return type of the operators, and thus \nthe exact value of this associated type is not speci.ed. Instead, we place concept requirements on the \nassociated type to state that it must be convertible to the type described in the requirements table. \nFor instance, operator*() returns a value of type reference, which must meet the requirements of Convertible<reference, \nvalue type>, i.e., the return type of operator*() is a value that is convertible to the value type,as \ndescribed in the requirements table.  Not all of the requirements in the table can be modeled pre\u00adcisely, \nalthough most differences are due to errors in the semi\u00adformal speci.cation. For example, the requirements \ntable for for\u00adward iterators states that the return type of operator*() (called reference in the ConceptC++ \nformulation) must be exactly equal to const value type&#38; for non-mutable forward iterators or ex\u00adactly \nequal to value type&#38; for mutable forward iterators. These two requirements are mutually exclusive, \nbecause no value type can be identical to both a reference and constant reference. How\u00adever, it is assumed \nthroughout the STL that every mutable iterator is a non-mutable iterator, i.e., mutable iterators re.ne \ntheir non\u00admutable counterparts by adding the ability to modify values. To remedy this situation, our \nnon-mutable iterator concepts provide a weaker constraint on the reference associated type: it must be \nconvertible to const value type&#38;, while the mutable iterator con\u00adcepts state that the reference associated \ntype must be exactly equal to value type&#38;. By weakening the non-mutable constraint, we are able to \nexpress the necessary re.nement relationship between mu\u00adtable and non-mutable iterators. Translation \nof the iterator requirements into concepts proved to be the most challenging part of formalizing the \nSTL. The source of most problems was the loose speci.cation strategy in requirements tables (which permits \nproxy objects to be returned from many iterator operations), the tangling of non-mutable and mutable \nforms of the same concepts, and the presence of numerous small errors in the iterator speci.cations. \nDespite these challenges, the resulting concepts express the spirit of the existing STL closely enough \nthat iterators, data structures, and algorithms written to the existing speci.cation can be used with \nthe ConceptC++ STL without any changes. Section 5.3 discusses the mapping from existing iterators into \nconcept-enhanced STL iterators in more detail.  5.2 STL Algorithm Requirements To introduce concepts \ninto the algorithms and data structures of the STL, we must state the requirements of each STL algorithm \n(and data structure). This process involves introducing a where clause that covers the minimal requirements \nneeded to implement the algorithm. We focus here on algorithms, although the same process also applies \nto generic data structures. The left-hand side of Figure 7 illustrates the informal speci.\u00adcation style \nused to describe the requirements on STL algorithms. Using the convention that parameters are named after \nthe concepts they model, the function signatures in the speci.cation state that .nd() and .nd if() require \nmodels of the Input Iterator concept and that the latter function also requires a model of the Predicate \nconcept. Additionally, as stated in the requires clause, the type parameter T of .nd() must be a model \nof Equality Comparable. The na\u00a8ive translation of these requirements into concepts is shown on the right-hand \nside of Figure 7, but it is incorrect. Attempting to compile this constrained function template with \nConceptGCC produces the error message illustrated in Figure 8. The problem, in this case, is that two \nT values are comparable via == (since EqualityComparable<T> is required), but the code attempts to compare \nthe result of dereferencing .rst (a value type)to T. The type value type need not be the same as T. There \nare two immediate ways to resolve the error in .nd().We could either require that the value type of the \niterator be equivalent to T (using a Same Type constraint) or we could use a type\u00adasymmetric Equality \nComparable. While both options are viable, it is unclear which is dictated by the speci.cation on the \nleft\u00adhand side of Figure 7. Therefore, we decided to err on the side of leniency, because it allows more \nuses of the .nd() algorithm, Forward Iterator requirements [25] operation type Xu; X() X(a) Xu(a); \n Xu=a; a==b convertible to bool a!=b convertible to bool r=a X&#38; *a T&#38; if X&#38; is mutable, \nother\u00ad wise const T&#38; a. m U&#38; if X is mutable, otherwise const U&#38; r. m U&#38; ++r X&#38; \n r++ convertible to const X&#38; *r++ T&#38; if X is mutable, otherwise const T&#38;  concept InputIterator<typename \nIter> : CopyConstructible<Iter>, EqualityComparable<Iter>, Assignable<Iter> { typename value type = Iter::value \ntype; typename reference = Iter::reference; typename pointer = Iter::pointer; SignedIntegral di.erence \ntype = Iter::di.erence type where Arrowable<pointer, value type> &#38;&#38; Convertible<reference, value \ntype>; reference operator*(Iter); pointer operator. (Iter); Iter&#38; operator++(Iter&#38;); typename \npostincrement result; postincrement result operator++(Iter&#38;, int); where Dereferenceable<postincrement \nresult, value type>; }; concept ForwardIterator<typename Iter> : InputIterator<Iter>, DefaultConstructible<Iter> \n{where Convertible<reference, const value type&#38;>; where Convertible<pointer, const value type*>; \n}; concept MutableForwardIterator<Iter> Type X is a model of Forward Iterator, u, a, and b :ForwardIterator<Iter>, \nOutputIterator<Iter> {are values of type X, type T is a value type of where SameType<reference, value \ntype&#38;> &#38;&#38; iterator X, m (with type U) is the name of a SameType<pointer, value type*>; member \nof type T, and r is a reference to a }; non-constant X object. Figure 6. Forward Iterator and its mutable \nvariant, expressed using documentation conventions, and de.ned with concepts. For the concept description \nwe also show the de.nition of Input Iterator, which encapsulates many of the Forward Iterator requirements. \ntemplate<class InputIterator, class T> InputIterator .nd(InputIterator .rst, InputIterator last, const \nT&#38; value); template<class InputIterator, class Predicate> InputIterator .nd if(InputIterator .rst, \nInputIterator last, Predicate pred); 1. Requires: Type T is Equality Comparable. 2. Returns: The .rst \niterator i in the range [.rst,last) for which the following corresponding conditions hold: *i==value, \npred(*i) != false. Returns last if no such iterator is found. 3. Complexity: At most last-.rst applications \nof the cor\u00adresponding predicate.  // Literal translation: will not type-check template<InputIterator \nIter, EqualityComparable T> Iter .nd(Iter .rst, Iter last, const T&#38; value) { while (.rst!=last&#38;&#38;!(*.rst \n== value)) ++.rst; return .rst; } // Literal translation: complete and correct template<InputIterator \nIter, Predicate<Iter::reference> Pred> Iter .nd if(Iter .rst, Iter last, Pred pred) { while (.rst!=last&#38;&#38;!pred(*.rst)) \n++.rst; return .rst; } Figure 7. Speci.cation of the STL .nd() and .nd if() algorithms as described \nin the ISO C++ standard [25, \u00a725.1.2] (left) and its literal translation into ConceptC++. including many \nuses that will work with the existing STL. The de.nition of .nd() contained in ConceptC++ reads: template<InputIterator \nIter, typename T> where EqualityComparable<Iter::value type, T> Iter .nd(Iter .rst, Iter last, const \nT&#38; value) { while (.rst!=last&#38;&#38;!(*.rst == value)) ++.rst; return .rst; } Our exercise in \nstating STL algorithm requirements with concepts has uncovered several bugs and ambiguities due to the \ninformal speci.cation style used by the C++ standard. In many cases, the in\u00adtended requirements are clear \nin the C++ standard but the libstdc++ implementation was incorrect. Most often, these errors were due \nto assumptions made about the relationships between types that were not speci.ed in the requirements. \nFor instance, the GNU C++ li\u00adbrary contained the following implementation of replace copy() (with the \ndirect translation from requirements to where clause): template<InputIterator InIter, OutputIterator<InIter::value \ntype> OutIter, CopyConstructible T> where Assignable<OutIter::reference, T> &#38;&#38; EqualityComparable<InIter::value \ntype, T> OutIter replace copy(InIter .rst, InIter last, OutIter out, const T&#38; old val, const T&#38; \nnew val) {for ( ; .rst != last; ++.rst, ++result) *result = *.rst == old val ? new val : *.rst; return \nresult; } find.cpp: In function Iter std::find(Iter, Iter, const T&#38;) : find.cpp:8: error: no match \nfor operator== in *first == value .../concepts.h:170: note: candidates are: bool std::InputIterator<_Iter>::operator==(const \n_Iter&#38;, const _Iter&#38;) .../concepts.h:170: note: bool std::EqualityComparable<T, T>::operator==(const \nT&#38;, const T&#38;) .../concepts.h:170: note: bool std::SignedIntegral<difference_type>::operator==(const \ndifference_type&#38;, const difference_type&#38;) Figure 8. ConceptGCC error message produced when \nattempting to compile the na\u00a8ively translated version of .nd() shown on the right-hand side of Figure \n7. The where clause requires that one can assign both values from the input sequence and values of type \nT to the output sequence, even though the associated type value type of the Input Iterator may be different \nfrom the type T. However, when type-checking this routine, ConceptGCC produces the following error message: \nreplace_copy.cpp:15: error: operands to ?: have different types The problem, originally noted by Siek \nand Lumsdaine [58], is that the requirements to replace copy() do not say that T and the value type of \nthe input iterator are equivalent or coercible. Since the vast majority of uses of replace copy() have \nT and the iterator s value type equivalent, it is easy to see how this bug could have gone undetected. \nThe .x is easy: replace the conditional assignment via ?: with an if-else statement. We found several \nother errors within libstdc++ where the im\u00adplementation assumed type equivalence that is not guaranteed \nby the C++ standard. One particularly vexing example occurred in the sort heap() function, which had \nthe following de.nition once aug\u00admented with a where clause: template<MutableRandomAccessIterator RAIter> \nwhere { LessThanComparable<Iter::value type> } void pop heap(RAIter .rst, RAIter last); template<MutableRandomAccessIterator \nIter> where LessThanComparable<Iter::value type> void sort heap(Iter .rst, Iter last) { while (last - \n.rst > 1) pop heap(.rst, last--); } This algorithm is subtly incorrect. Attempting to compile with ConceptGCC \nproduces the following error message: sort_heap.cpp:8: error: no matching function for call to pop_heap(Iter&#38;, \npostdecrement_result&#38;) The problem in this case is that the postdecrement opera\u00adtor, used in last--, \nis speci.ed to return a value of associated type postdecrement result, which is convertible to but distinct \nfrom the type Iter of last. In the call to pop heap(), this differ\u00adence causes a failure in template \nargument deduction: RAIter is bound to Iter by the .rst parameter to pop heap(),but RAIter is bound to \npostdecrement result by the second parameter. Again, .xing the problem once it has been detected is trivial: \none can insert a cast from last-- to Iter. The last major source of errors we found when de.ning the \nrequirements of concepts in the STL is due to the infamous vector<bool> iterator (Section 4.4.2). The \nproblems with the vector<bool> iterator arise because the C++ standard incorrectly states that the vector<bool> \niterator is a Random Access Itera\u00adtor [25, \u00a723.2.5]. This error cannot occur when using concepts: an \nattempt to write the concept map de.nition will result in a compile\u00adtime failure, because the reference \ntype of a vector<bool> iterator does not meet the requirements of the Forward Iterator concept.  5.3 \nBackward Compatibility Backward compatibility of the ConceptC++ STL with programs written for the existing \nSTL is of paramount importance for two reasons. First, by providing all of the bene.ts of ConceptC++ \n(better error messages, improved library implementations, syntax remapping) without requiring users to \nport their code, backward compatibility improves the chances for adoption of concepts into real-world \nuse and C++0x. Second, if we are able to apply concepts to existing STL without signi.cant changes, then \nit is likely that they can be similarly applied to many other generic libraries. We can report that the \nConceptC++ STL provides excellent backward compatibility. The entirety of the libstdc++ test suite compiles \nand produces identical results with the ConceptC++ STL and existing STL, and required only three changes: \n1. The ConceptC++ STL de.ned a name in use by one of the tests (Integral), requiring the test to use \na different identi.er. 2. The ConceptC++ STL does not pretend that vector<bool> iterators model Random \nAccess Iterator.1 One test case that relied on this idiosyncrasy had to be modi.ed. 3. One type that \nwas used as an output iterator in the example required the addition of a single concept map to be used \nwith the ConceptC++ STL algorithms.  We also ran the test suites for several libraries in the C++ Boost \nlibrary collection [6], including the graph and iterator adaptor li\u00adbraries that make heavy use of STL \nconstructs, using ConceptC++. Again, there was a case where a type used as an output iterator required \na concept map to be used with the ConceptC++ STL. Assuming that we can express the requirements of an \nexisting generic library using concepts, the major impediment to backward compatibility is the possibility \nthat users will need to add many concept maps. We used a combination of implicit concepts (for trivial \nconcepts such as Copy Constructible or Less Than Compa\u00adrable) and concept map templates to minimize (to \nnearly zero) the number of concept maps that users will be required to write. In the ConceptC++ STL, \nthe only widely-used concepts that require explicit concept maps are the iterator concepts. For nearly \nall of the iterator concepts (Output Iterator is the only exception), however, we can write concept map \ntemplates that adapt iterators written for the existing STL into the new iterator concepts. This process \nis completely transparent to the user, otherwise porting the libstdc++ and C++ Boost [6] test suites \nto the ConceptC++ STL would have required many concept maps for various user-de.ned iterator types. The \nkey to adapting old-style iterators to take advantage of con\u00adcepts is in the observation that existing \nSTL iterators already pro\u00advide explicit declarations of the concepts they model in the form of traits \n[47]: we need only query these traits. Figure 9 illustrates how old-style forward iterators can be seamlessly \nmapped into the iterators of the ConceptC++ STL. The Iterator Traits concept is a structural concept \nthat extracts all of the types from the existing 1 In fact, the ConceptC++ can not pretend that vector<bool> \niterators are Random Access Iterators: the compiler will reject the de.nition of the concept map. auto \nconcept IteratorTraits<typename Iter> {typename iterator category = Iter::iterator category; typename \nvalue type = Iter::value type; typename di.erence type = Iter::di.erence type; typename pointer = Iter::pointer; \ntypename reference = Iter::reference; }; template<typename !Iter> where { IteratorTraits<Iter>, Convertible<iterator \ncategory, input iterator tag>, Convertible<iterator category, forward iterator tag>} concept map ForwardIterator<Iter> \n{typedef Iter::value type value type; typedef Iter::di.erence type di.erence type; typedef Iter::pointer \npointer; typedef Iter::reference reference; }; Figure 9. Concept map templates that seamlessly map old-style \nSTL iterators into ConceptC++ STL iterators, to enable backward compatibility. STL iterator traits trait \nclass. Most important of all of these is the iterator category type, which states which concept Input \nItera\u00adtor, Forward Iterator, etc. the type models. Implicit generation of the concept map IteratorTraits<Iter>, \nimplies that Iter is an iterator of some form. Therefore, we can declare concept map templates that take \nany type Iter with an implicit-generated concept map IteratorTraits<Iter> and query its iterator category \nto determine which concepts it models. In Figure 9, we generate a concept map of Forward Iterator so \nlong as there is a concept map of Iterator Traits and its iterator category is convertible to forward \niterator tag. The mapping is valid be\u00adcause the where clause of the Forward Iterator concept map tem\u00adplate \nmatches precisely the requirements needed to identify a type as a Forward Iterator in the existing STL. \nThus, with the exception of Output Iterator, types that meet the iterator requirements of the existing \nSTL will automatically meet the requirements of the Con\u00adceptC++ STL with no porting required. We believe \nthat upcoming extensions to C++ [26] will make it possible to provide the same automatic mapping for \nOutput Iterator concept maps as well, pro\u00adviding nearly perfect backward compatibility for existing iterators. \nComplete backward compatibility also requires that pre-concept generic algorithms written using the old \niterator interfaces (based on iterator traits) will continue to function, even with new itera\u00adtors that \nexpose only the concepts-based interface. For instance, the following algorithm counts all of the elements \nin the sequence that meet some speci.c criteria: template<typename InputIterator, typename Predicate> \ntypename std::iterator traits<InputIterator>::di.erence type count if(InputIterator .rst, InputIterator \nlast, Predicate pred) { typename std::iterator traits<InputIterator>::di.erence type n=0; for (; .rst \n!= last; ++.rst) if (pred(*.rst)) ++n; return n; } One could require that all new iterators expose both \na concepts\u00adbased interface (e.g., provide concept maps) and a pre-concept interface (e.g., specialize \niterator traits). However, this places the burden of backward compatibility on the authors of iterators. \nAside from the problems of maintaining two similar (but incompatible) interfaces, this approach would \nnever allow the concepts-based interface to completely replace the existing interface. template<InputIterator \nIter> struct iterator traits<Iter> { typedef input iterator tag iterator category; typedef Iter::value \ntype value type; typedef Iter::reference reference; typedef Iter::pointer pointer; typedef Iter::di.erence \ntype di.erence type; }; Figure 10. Class template partial specializations that seamlessly map new-style \nConceptC++ iterators into the old-style C++ iterator interface. Concepts allow us to de.ne a set of class \ntemplate partial spe\u00adcializations for iterator traits that provide new, concept-based it\u00aderators with \nthe old-style interface. Figure 10 illustrates one of the partial specializations, which provides a suitable \niterator traits de.nition for any model of the Input Iterator concept. Like the mapping from existing \niterators into the concept system, this map\u00adping is seamless and invisible: existing generic algorithms \nwill be able to access the associated types of new-style iterators through iterator traits. With a series \nof concept maps (illustrated in Figure 9) and class template partial specializations (illustrated in \nFigure 10), we are able to ensure that existing, pre-concept iterators seamlessly inter\u00adoperate with \nconcept-constrained algorithms and that pre-concept algorithms interoperate with new, concept-based iterators. \nMore\u00adover, the use of these techniques can simplify the development of dual-mode generic libraries, which \nprovide the same functional\u00adity with and without concepts. The ConceptGCC implementation of the Standard \nLibrary is one such library, allowing users to turn off concepts at the library level to provide a pre-concept, \nC++03\u00adcompliant library. The ability to develop dual-mode generic li\u00adbraries is crucial: even if vendors \ncould coordinate the release of compilers and libraries supporting concepts (which they can t), users \nare still likely to rely on a mix of compilers and libraries, some of which support concepts and others \nthat do not. The burden of maintaining the same library for C++ with and without concepts would be a \nsigni.cant barrier to adoption. 5.4 Summary We evaluated the design of concepts by translating the ideas \nand implementation of the Standard Template Library into Con\u00adceptC++. De.ning the requirements in the \nSTL using concepts uncovered errors and ambiguities in both the speci.cation and the implementation of \nthe STL. In the end, we were able to produce a concept-enhanced STL that is demonstrably better than \nthe orig\u00adinal, both from the user s point of view (better error messages, clearer abstractions) and from \nthe implementer s point of view (improved type checking, much less reliance on arcane template techniques). \nMoreover, the concept-enhanced STL provided near\u00adperfect backward compatibility with programs written \nusing the existing STL. 6. Related Work Concepts extend C++ with constraints on type parameters, as well \nas with modular type checking and overloading based on these con\u00adstraints. Various mechanisms for constraining \npolymorphic types and for overloading are part of many widely-used languages. Our design has been in.uenced \nby prior work in this area. Here, we present concepts with respect to these mechanisms and languages. \nSeveral object-oriented languages, including Eiffel [39], Java [18], and C# [40], support constrained \ngenerics with subtyping con\u00adstraints. In such languages, interfaces or abstract classes describe a set \nof requirements, as method signatures, that types declared to be subtypes of such classes must satisfy. \nThe constraints on generic methods and classes are then mutually recursive systems of subtyp\u00ading requirements \non type parameters, essentially a generalization of F-bounded polymorphism [8]. There are signi.cant \ndifferences be\u00adtween the above kind of constrained polymorphism and concepts, including the treatment \nof associated types, use of subtyping as the basis of constraints, use of constraints in overloading, \nand the compilation model of generic de.nitions. We discuss compilation model in Section 4.1, and address \nthe other differences below. Associated types, as well as requirements on them, are an es\u00adsential part \nof concepts. Representing associated types in Java or C# is less direct: interfaces do not provide type \nmembers that could serve for this purpose. It is possible, however, to express mappings between types \n(which is what associated types essentially are), as well as constraints on associated types, without \ntype members. This is accomplished with a distinct type parameter, and a set of con\u00adstraints, for each \nassociated type. This approach, however, does not encapsulate associated types and their constraints \ninto the in\u00adterfaces; we report how both associated types and constraints on them must be repeated in \nall sites where generic interfaces are used as type parameter constraints [15]. Concepts directly support \nas\u00adsociated type requirements in concepts. Note that we have devel\u00adoped language features to allow associated \ntypes in generic inter\u00adfaces [29] in C# or Java-like languages. Moreover, type members in objects and \nclasses have been extensively studied since the early work on virtual types [38]. We review this work \nin [29]. An interesting recent language regarding generic programming is Scala [50,51]. In particular, \nScala s type system provides abstract type members, which could serve as associated types of concepts. \nMoreover, the latest version of Scala includes a feature referred to as implicit parameters [49, \u00a77], \nwhich can be used to pass models (in the generic programming sense) to generic functions either explicitly \nor implicitly. We plan to do a more comprehensive analysis of Scala with respect to generic programming \nin the future. A type (a set of types, values, operations, etc.) can model a con\u00adcept that is de.ned \nafter the de.nition of the type. Such retroac\u00adtive modeling is important when composing separately developed \nlibraries as discussed in [15]. In constrained generics based on subtyping, the ability of retroactive \nmodeling is tied to the ability of retroactive subtyping, which is typically not provided in main\u00adstream \nobject-oriented languages where a subtype relation is nomi\u00adnal and established via subclassing. Of well-known \nobject-oriented languages, Cecil [37] supports retroactive subtyping, and the fea\u00adture has been suggested \nfor Java as well [4]. Also, mechanisms for specifying structural subtyping relations have been proposed \nfor C++ [5] and for Java [33]. Concepts do not build on C++ s subtype relation. In that re\u00adspect, concepts \nare similar to constraint mechanisms such as sig\u00adnatures in ML [41], and type classes in Haskell [70]. \nComparing concepts with ML signatures, we note that ML signatures encom\u00adpass equivalents of associated \ntypes, in particular we can observe the correspondence of same-type constraints to ML s sharing con\u00adstraints \n(see manifest types [35] and translucent sums [36]). A ma\u00adjor difference between concepts and ML signatures \nis the granu\u00adlarity of parametrization. In ML, signatures are used to constrain functors, i.e., parametrized \nmodules, not parametrized functions. Generic functions very seldom share the same parametrization and \nrequirements, so each function would have to be wrapped in a mod\u00adule of its own. Furthermore, functors \nmust be explicitly instanti\u00adated with type arguments, making their use quite heavy-weight, whereas C++ \nprovide implicit instantiation, with the type arguments deduced from the types of the actual arguments. \nIn ML, checking that the requirements of a signature are satis\u00ad.ed is based purely on structural conformance. \nOur concept exten\u00adsions support both structural and nominal modeling relations (cor\u00adresponding to implicit \nand explicit concepts, respectively). While implicit concepts are not (strictly speaking) necessary, \nthis feature has been found to reduce the number of trivial concept maps sig\u00adni.cantly. However, explicit \nconcepts are crucial for concepts that differ only semantically, as illustrated in Section 3.4.1. In \nparticu\u00adlar, often a concept re.nement (e.g. Forward Iterator re.ning Input Iterator) only adds more \nsemantic requirements, having no syntac\u00adtic difference between the concepts. Thus the structural properties \nof types do not suf.ce to uniquely determine which concepts the types model. Further details of the use \nof ML for generic program\u00adming can be found in [15]. Similar to concepts, Haskell type classes de.ne \na set of required functions that instances (models) of the type class must provide. Subtyping does not \nenter into the picture. Furthermore, type classes constrain individual functions, rather than modules. \nIn their stan\u00addard form, type classes do not support associated types, but recent research [9, 10] addresses \nthis issue. The most notable difference is Haskell s support for type inference, in particular inferring \nthe constraints of a generic function from its body. To ensure that the constraints of a generic function \ncan be uniquely determined, a sig\u00adni.cant restriction is placed on type classes: each function name can \noccur only once in all type classes visible in the program. This requires foresight, and is problematic \nin importing type class de.\u00adnitions from separately de.ned libraries. Concepts participate in overload \nresolution. This is contrary to Java and C# where constraints are ignored when selecting the best matching \noverload: two overloads of a function that only differ in their constraints are considered ambiguous. \nOverloading in Con\u00adceptC++ differs from ML s or Haskell s behavior too, since poly\u00admorphic functions \nin these languages cannot be overloaded. In Haskell, all overloading occurs by providing different instance \ndec\u00adlarations for a type class, and thus only functions de.ned within some type class are overloadable. \nIn ConceptC++ one overloaded function is considered to be a specialization of another if its concept \nconstraints imply the constraints of the other one, as described in Section 3.3. This is to provide direct \nsupport for algorithm special\u00adization, which is an essential part of the generic programming ap\u00adproach \nto software library development. We analyze concept-based overloading and specialization in detail in \n[27]. 7. Conclusion We propose new language features for C++, based on concepts, that provide (nearly) \nmodular type checking for templates and directly support Generic Programming. The addition of concepts \nto C++ libraries brings an immediate bene.t to library users by drastically shortening and simplifying \ntemplate error messages. In the longer term, concepts make it easier to design and implement template \nlibraries, replacing a grab-bag of template tricks with a single, coherent language feature. ConceptGCC \n[19], built on the GNU C++ compiler, imple\u00adments concepts and associated features as described here. \nUsing ConceptGCC, we have reimplemented the C++ Standard Template Library using concepts. This process \nof formalizing the require\u00adments of STL using concepts uncovered several de.ciencies in the semi-formal \nspeci.cation of C++ [25] and detected several new bugs in the GNU implementation. The resulting STL using \ncon\u00adcepts provides the same functionality as the existing STL, with nearly-perfect backward compatibility, \nbut greatly improves the user experience. ConceptGCC is available online at http://www. generic-programming.org/software/ConceptGCC. \n8. Future Work The current design and implementation of concepts draw from a larger on-going effort led \nby the authors [12,22,23,53,64]. The aim of this work is the inclusion of concepts in a form very similar \nto what is presented here into C++0x, the next ISO C++ standard. To make that happen, we will complete \nConceptGCC, im\u00adplementing the remaining few features of ConceptC++. Further\u00admore, we must document our \ndesign to the extent that it can be (re)implemented in commercial C++ compilers and used by prac\u00adticing \nprogrammers. The .nal word on the design of concepts in C++0x will be determined by the committee and \nthe ISO national representatives. Their criteria include completeness, simplicity, and stability of the \ndesign as well as performance and smooth integra\u00adtion with the rest of the language and the standard \nlibrary. To further evaluate expressiveness and usability, we will port additional generic C++ libraries \nto use concepts and tune their per\u00adformance and that of ConceptGCC. Concepts must not introduce any run-time \noverhead compared to unconstrained templates. We will evaluate the trade-offs between use patterns and \nsignatures. In general, we will continue to try to simplify our concept mechanisms to make it easier \nfor programmers to use concepts effectively. To increase the scope of analysis and optimization, we will \nexplore the notion of attaching semantic properties to concepts, to permit semantic descriptions of abstractions \nand aid compilers in concept-based optimization [52]. Acknowledgments The effort to introduce language \nsupport for Generic Programming into C++ in the form of concepts has been shaped by many, in\u00adcluding \nDavid Abrahams, Matthew Austern, Ronald Garcia, Mat Marcus, David Musser, Sean Parent, Sibylle Schupp, \nAlexander Stepanov, and Jeremiah Willcock. This work was supported by NSF grants EIA-0131354, CCF-0541014, \nCCF-0541335, and by a grant from the Lilly Endowment. References [1] David Abrahams and Aleksey Gurtovoy. \nC++ Template Metapro\u00adgramming: Concepts, Tools, and Techniques from Boost and Beyond. Addison-Wesley, \n2004. [2] P. An, A. Jula, S. Rus, S. Saunders, T. Smith, G. Tanase, N. Thomas, N. Amato, and L. Rauchwerger. \nSTAPL: A standard template adaptive parallel C++ library. In Int. Wkshp on Adv. Compiler Technology for \nHigh Perf. and Embedded Processors, page 10, July 2001. [3] Matthew H. Austern. Generic programming and \nthe STL: Using and extending the C++ Standard Template Library. Professional Computing Series. Addison-Wesley \nLongman Publishing Co., Inc., Boston, MA, USA, 1998. [4] G. Baumgartner, M. Jansche, and K. L\u00a8aufer. \nHalf &#38; Half: Multiple Dispatch and Retroactive Abstraction for Java. Technical Report OSU-CISRC-5/01-TR08, \nOhio State University, 2002. [5] Gerald Baumgartner and Vincent F. Russo. Signatures: A language extension \nfor improving type abstraction and subtype polymorphism in C++. Software Practice and Experience, 25(8):863 \n889, August 1995. [6] Boost. Boost C++ Libraries. http://www.boost.org/. [7] Alex Breuer, Peter Gottschling, \nDouglas Gregor, and Andrew Lumsdaine. Effecting parallel graph eigensolvers through library composition. \nIn Performance Optimization for High-Level Languages and Libraries (POHLL), April 2006. [8] Peter Canning, \nWilliam Cook, Walter Hill, Walter Olthoff, and John C. Mitchell. F-bounded polymorphism for object-oriented \nprogramming. In FPCA 89: Proceedings of the fourth international conference on Functional programming \nlanguages and computer architecture, pages 273 280. ACM Press, 1989. [9] Manuel M. T. Chakravarty, Gabrielle \nKeller, and Simon Peyton Jones. Associated type synonyms. In ICFP 05: Proceedings of the International \nConference on Functional Programming, pages 241 253. ACM Press, September 2005. [10] Manuel M. T. Chakravarty, \nGabrielle Keller, Simon Peyton Jones, and Simon Marlow. Associated types with class. In POPL 05: Proceedings \nof the 32nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 1 13. ACM Press, \n2005. [11] K. Czarnecki and U. Eisenecker. Generative Programming: Methods, Techniques and Applications. \nAddison-Wesley, 2000. [12] Gabriel Dos Reis and Bjarne Stroustrup. Specifying C++ concepts. In POPL 06: \nConference record of the 33rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages \n295 308. ACM Press, 2006. [13] Peter J. Downey, Ravi Sethi, and Robert Endre Tarjan. Variations on the \ncommon subexpression problem. Journal of the ACM (JACM), 27(4):758 771, 1980. [14] A. Fabri, G.-J. Giezeman, \nL. Kettner, S. Schirra, and S. Sch\u00a8onherr. On the design of CGAL, a computational geometry algorithms \nlibrary. Software Practice and Experience, 30(11):1167 1202, 2000. Special Issue on Discrete Algorithm \nEngineering. [15] Ronald Garcia, Jaakko J\u00a8arvi, Andrew Lumsdaine, Jeremy Siek, and Jeremiah Willcock. \nA comparative study of language support for generic programming. In OOPSLA 03: Proceedings of the 18th \nannual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications, pages \n115 134. ACM Press, 2003. [16] Ronald Garcia, Jaakko J\u00a8arvi, Andrew Lumsdaine, Jeremy Siek, and Jeremiah \nWillcock. An extended comparative study of language support for generic programming. Journal of Functional \nProgramming, 2005. Accepted. [17] GNU compiler collection. http://www.gnu.org/software/ gcc/, 2005. [18] \nJames Gosling, Bill Joy, Guy Steele, and Gilad Bracha. The Java Language Speci.cation, Third Edition. \nAddison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 2005. [19] Douglas Gregor. ConceptGCC: \nConcept extensions for C++. http: //www.generic-programming.org/software/ConceptGCC, 2005. [20] Douglas \nGregor and Andrew Lumsdaine. Lifting sequential graph algorithms for distributed-memory parallel computation. \nIn Pro\u00adceedings of the 2005 ACM SIGPLAN conference on Object-oriented programming, systems, languages, \nand applications (OOPSLA 05), pages 423 437, October 2005. [21] Douglas Gregor and Jeremy Siek. Implementing \nconcepts. Technical Report N1848=05-0108, ISO/IEC JTC 1, Information Technology, Subcommittee SC 22, \nProgramming Language C++, August 2005. [22] Douglas Gregor, Jeremy Siek, Jeremiah Willcock, Jaakko J\u00a8arvi, \nRonald Garcia, and Andrew Lumsdaine. Concepts for C++0x (revision 1). Technical Report N1849=05-0109, \nISO/IEC JTC 1, Information Technology, Subcommittee SC 22, Programming Language C++, August 2005. [23] \nDouglas Gregor and Bjarne Stroustrup. Concepts. Technical Report N2042=06-0112, ISO/IEC JTC 1, Information \nTechnology, Subcommittee SC 22, Programming Language C++, June 2006. [24] Michi Henning. The rise and \nfall of CORBA. ACM Queue, 4(5):28 34, June 2006. [25] International Organization for Standardization. \nISO/IEC 14882:1998: Programming languages C++. Geneva, Switzerland, September 1998. [26] J. J\u00a8arvi, \nB. Stroustrup, and G. Dos Reis. Decltype and auto (revision 4). Technical Report N1705=04-0145, ISO/IEC \nJTC 1, Information Technology, Subcommittee SC 22, Programming Language C++, September 2004. http://www.open-std.org/jtc1/sc22/ \nwg21/docs/papers/2004/n1705.pdf. [27] Jaakko J\u00a8arvi, Douglas Gregor, Jeremiah Willcock, Andrew Lums\u00addaine, \nand Jeremy Siek. Algorithm specialization in generic pro\u00adgramming: Challenges of constrained generics \nin C++. In PLDI 06: Proceedings of the 2006 ACM SIGPLAN conference on Programming language design and \nimplementation, pages 272 282. ACM Press, 2006. [28] Jaakko J\u00a8arvi, Jeremiah Willcock, Howard Hinnant, \nand Andrew Lumsdaine. Function overloading based on arbitrary properties of types. C/C++ Users Journal, \n21(6):25 32, June 2003. [29] Jaakko J\u00a8arvi, Jeremiah Willcock, and Andrew Lumsdaine. Associated types \nand constraint propagation for mainstream object-oriented generics. In OOPSLA 05: Proceedings of the \n20th annual ACM SIGPLAN conference on Object-oriented programming systems languages and applications, \npages 1 19. ACM Press, 2005. [30] Mehdi Jazayeri, R\u00a8udiger Loos, David Musser, and Alexander Stepanov. \nGeneric Programming. In Report of the Dagstuhl Seminar on Generic Programming, Schloss Dagstuhl, Germany, \nApril 1998. [31] D. Kapur and D. Musser. Tecton: a framework for specifying and verifying generic system \ncomponents. Technical Report RPI 92 20, Department of Computer Science, Rensselaer Polytechnic Institute, \nTroy, New York 12180, July 1992. [32] Steve Karmesin, James Crotinger, Julian Cummings, Scott Haney, \nWilliam Humphrey, John Reynders, Stephen Smith, and Timothy J. Williams. Array design and expression \nevaluation in POOMA II. In Denis Caromel, Rodney R. Oldehoeft, and Marydell Tholburn, editors, ISCOPE. \nAdvanced Computing Laboratory, LANL, 1998. [33] K. L\u00a8aufer, G. Baumgartner, and V. F. Russo. Safe structural \nconformance for Java. The Computer Journal, 43(6):469 481, 2000. [34] Lie-Quan Lee, Jeremy Siek, and \nAndrew Lumsdaine. Generic graph algorithms for sparse matrix ordering. In ISCOPE 99, Lecture Notes in \nComputer Science. Springer-Verlag, 1999. [35] Xavier Leroy. Manifest types, modules, and separate compilation. \nIn Proceedings of the 21st Annual ACM Symposium on Principles of Programming Languages, pages 109 122, \n1994. [36] Mark Lillibridge. Translucent Sums: A Foundation for Higher-Order Module Systems. PhD thesis, \nPittsburgh, PA, May 1997. [37] Vassily Litvinov. Contraint-based polymorphism in Cecil: towards a practical \nand static type system. In OOPSLA 98: Proceedings of the 13th ACM SIGPLAN conference on Object-oriented \nprogramming, systems, languages, and applications, pages 388 411. ACM Press, 1998. [38] O. L. Madsen \nand B. Moller-Pedersen. Virtual classes: a powerful mechanism in object-oriented programming. In OOPSLA \n89: Conference proceedings on Object-oriented programming systems, languages and applications, pages \n397 406. ACM Press, 1989. [39] Bertrand Meyer. Eiffel: the Language. Prentice Hall, .rst edition, 1992. \n[40] Microsoft Corporation. Generics in C#, September 2002. Part of the Gyro distribution of generics \nfor .NET available at http: //research.microsoft.com/projects/clrgen/. [41] Robin Milner, Mads Tofte, \nand Robert Harper. The De.nition of Standard ML. MIT Press, 1990. [42] David R. Musser, Gillmer J. Derge, \nand Atul Saini. STL Tutorial and Reference Guide. Addison-Wesley, 2nd edition, 2001. [43] David R. Musser \nand Alexander A. Stepanov. A library of generic algorithms in Ada. In Using Ada (1987 International Ada \nConference), pages 216 225. ACM SIGAda, December 1987. [44] David R. Musser and Alexander A. Stepanov. \nGeneric programming. In P. (Patrizia) Gianni, editor, Symbolic and algebraic computation: ISSAC 88, Rome, \nItaly, July 4 8, 1988: Proceedings, volume 358 of Lecture Notes in Computer Science, pages 13 25, Berlin, \n1989. Springer Verlag. [45] David R. Musser and Alexander A. Stepanov. Algorithm-oriented generic libraries. \nSoftware Practice and Experience, 24(7):623 642, July 1994. [46] Nathan Myers. A new and useful technique: \ntraits . C++ Report, 7(5):32 35, June 1995. [47] Nathan C. Myers. Traits: a new and useful template technique. \nC++ Report, June 1995. [48] Greg Nelson and Derek C. Oppen. Fast decision procedures based on congruence \nclosure. J. ACM, 27(2):356 364, 1980. [49] Martin Odersky. The Scala language speci.cation: Version 2.0, \ndraft march 17, 2006. http://scala.epfl.ch/docu/files/ ScalaReference.pdf, 2006. [50] Martin Odersky \nand al. An overview of the Scala programming lan\u00adguage. Technical Report IC/2004/64, EPFL Lausanne, Switzerland, \n2004. [51] Martin Odersky and Matthias Zenger. Scalable component abstrac\u00adtions. SIGPLAN Not., 40(10):41 \n57, 2005. [52] Sibylle Schupp, Douglas Gregor, David R. Musser, and Shin-Ming Liu. User-extensible simpli.cation: \nType-based optimizer generators. In CC 01: Proceedings of the 10th International Conference on Compiler \nConstruction, pages 86 101, London, UK, 2001. Springer-Verlag. [53] Jeremy Siek, Douglas Gregor, Ronald \nGarcia, Jeremiah Willcock, Jaakko J\u00a8arvi, and Andrew Lumsdaine. Concepts for C++0x. Technical Report \nN1758=05-0018, ISO/IEC JTC 1, Information Technology, Subcommittee SC 22, Programming Language C++, January \n2005. [54] Jeremy Siek, Lie-Quan Lee, and Andrew Lumsdaine. The Boost Graph Library: User Guide and Reference \nManual. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 2002. [55] Jeremy Siek and Andrew \nLumsdaine. The Matrix Template Library: Generic components for high-performance scienti.c computing. \nComputing in Science and Engineering, 1(6):70 78, Nov/Dec 1999. [56] Jeremy Siek and Andrew Lumsdaine. \nConcept checking: Binding parametric polymorphism in C++. In First Workshop on C++ Template Programming, \nOctober 2000. [57] Jeremy Siek and Andrew Lumsdaine. Essential language support for generic programming. \nIn PLDI 05: Proceedings of the ACM SIGPLAN 2005 conference on Programming language design and implementation, \npages 73 84. ACM Press, June 2005. [58] Jeremy Siek and Andrew Lumsdaine. Language requirements for large-scale \ngeneric libraries. In GPCE 05: Proceedings of the fourth international conference on Generative Programming \nand Component Engineering, September 2005. To appear. [59] Jeremy G. Siek. A Language for Generic Programming. \nPhD thesis, Indiana University, August 2005. [60] Alexander A. Stepanov and Meng Lee. The Standard Template \nLibrary. Technical Report X3J16/94-0095, WG21/N0482, ISO Programming Language C++ Project, May 1994. \n[61] Bjarne Stroustrup. Design and Evolution of C++. Addison-Wesley Longman Publishing Co., Inc., Boston, \nMA, USA, 1994. [62] Bjarne Stroustrup. The C++ Programming Language. Addison-Wesley, special edition, \n2000. [63] Bjarne Stroustrup and Gabriel Dos Reis. Concepts design choices for template argument checking. \nTechnical Report N1522=03\u00ad0105, ISO/IEC JTC 1, Information Technology, Subcommittee SC 22, Programming \nLanguage C++, October 2003. http: //www.open-std.org/jtc1/sc22/wg21. [64] Bjarne Stroustrup and Gabriel \nDos Reis. A concept design (rev. 1). Technical Report N1782=05-0042, ISO/IEC JTC 1, Information Technology, \nSubcommittee SC 22, Programming Language C++, May 2005. [65] Mathias Troyer and Prakash Dayal. The Iterative \nEigensolver Tem\u00adplate Library. http://www.comp-phys.org:16080/software/ietl/. [66] Todd Veldhuizen. Using \nC++ template metaprograms. C++ Report, May 1995. [67] Todd L. Veldhuizen. Expression templates. C++ Report, \n7(5):26 31, June 1995. Reprinted in C++ Gems, ed. Stanley Lippman. [68] Todd L. Veldhuizen. Arrays in \nBlitz++. In Proceedings of the 2nd International Scienti.c Computing in Object-Oriented Parallel Environments \n(ISCOPE 98), volume 1505 of Lecture Notes in Computer Science. Springer-Verlag, 1998. [69] Todd L. Veldhuizen. \nFive compilation models for C++ templates. In First Workshop on C++ Template Programming, October 10 \n2000. [70] P. Wadler and S. Blott. How to make ad-hoc polymorphism less ad\u00adhoc. In ACM Symposium on Principles \nof Programming Languages, pages 60 76. ACM, January 1989.    \n\t\t\t", "proc_id": "1167473", "abstract": "Generic programming has emerged as an important technique for the development of highly reusable and efficient software libraries. In C++, generic programming is enabled by the flexibility of templates, the C++ type parametrization mechanism. However, the power of templates comes with a price: generic (template) libraries can be more difficult to use and develop than non-template libraries and their misuse results in notoriously confusing error messages. As currently defined in C++98, templates are unconstrained, and type-checking of templates is performed late in the compilation process, i.e., after the use of a template has been combined with its definition. To improve the support for generic programming in C++, we introduce <i>concepts</i> to express the syntactic and semantic behavior of types and to constrain the type parameters in a C++ template. Using concepts, type-checking of template definitions is separated from their uses, thereby making templates easier to use and easier to compile. These improvements are achieved without limiting the flexibility of templates or decreasing their performance - in fact their expressive power is increased. This paper describes the language extensions supporting concepts, their use in the expression of the C++ Standard Template Library, and their implementation in the ConceptGCC compiler. Concepts are candidates for inclusion in the upcoming revision of the ISO C++ standard, C++0x.", "authors": [{"name": "Douglas Gregor", "author_profile_id": "81100327293", "affiliation": "Indiana University", "person_id": "P453535", "email_address": "", "orcid_id": ""}, {"name": "Jaakko J&#228;rvi", "author_profile_id": "81100614151", "affiliation": "Texas A&M University", "person_id": "P399140", "email_address": "", "orcid_id": ""}, {"name": "Jeremy Siek", "author_profile_id": "81100437231", "affiliation": "Rice University", "person_id": "PP18010234", "email_address": "", "orcid_id": ""}, {"name": "Bjarne Stroustrup", "author_profile_id": "81100106139", "affiliation": "Texas A&M University", "person_id": "PP18010813", "email_address": "", "orcid_id": ""}, {"name": "Gabriel Dos Reis", "author_profile_id": "81309496659", "affiliation": "Texas A&M University", "person_id": "P767497", "email_address": "", "orcid_id": ""}, {"name": "Andrew Lumsdaine", "author_profile_id": "81100082403", "affiliation": "Indiana University", "person_id": "P18130", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167499", "year": "2006", "article_id": "1167499", "conference": "OOPSLA", "title": "Concepts: linguistic support for generic programming in C++", "url": "http://dl.acm.org/citation.cfm?id=1167499"}