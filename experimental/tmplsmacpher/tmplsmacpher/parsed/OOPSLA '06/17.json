{"article_publication_date": "10-16-2006", "fulltext": "\n A Flow-Based Approach for Variant Parametric Types Wei-Ngan Chin Florin Craciun Siau-Cheng Khoo Corneliu \nPopeea Department of Computer Science, National University of Singapore {chinwn,craciunm,khoosc,corneliu}@comp.nus.edu.sg \nAbstract A promising approach for type-safe generic codes in the object\u00adoriented paradigm is variant \nparametric type, which allows covari\u00adant and contravariant subtyping on .elds where appropriate. Pre\u00advious \napproaches formalise variant type as a special case of the existential type system. In this paper, we \npresent a new framework based on .ow analysis and modular type checking to provide a sim\u00adple but accurate \nmodel for capturing generic types. Our scheme stands to bene.t from past (and future) advances in .ow \nanalysis and subtyping constraints. Furthermore, it fully supports casting for variant types with a special \nre.ection mechanism, called cast capture, to handle objects with unknown types. We have built a constraint-based \ntype checker and have proven its soundness. We have also successfully annotated a suite of Java libraries \nand client code with our .ow-based variant type system. Categories and Subject Descriptors D.3.3 [Programming \nLan\u00adguages]: Language Constructs and Features Classes and ob\u00adjects; Polymorphism; Constraints; D.3.1 \n[Programming Lan\u00adguages]: Formal De.nitions and Theory; D.3.2 [Programming Languages]: Language Classi.cations \nObject-oriented languages; F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs Object-oriented \nconstructs; Type structure General Terms Design, Languages, Theory, Veri.cation Keywords Genericity, \nFlow Analysis, Variant Parametric Types, Subtyping, Constraints 1. Introduction Software reuse is an \nimportant aspect of software engineering. Traditionally, most mainstream object-oriented (OO) languages, \nsuch as Java, C++ and C#, have relied on class subtyping to sup\u00adport reuse (or genericity) via inclusion \npolymorphism. While this mechanism allows the convenient storage of objects via safe upcast into generic \ndata structure, the converse process of retrieving ob\u00adjects from the same data structure requires downcast \ntesting, which incurs runtime overheads and is possibly unsafe. To address the shortcomings of inclusion \npolymorphism, there have been several recent proposals (amongst the Java [3] and C# [19] communities) \nfor parametric types to be supported . Here, each class c is allowed to carry a list of type parameters \nfor its .elds, e.g., c(t1,..,tn), whereby the type of each .eld can either be Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 06 October 22 26, 2006, Portland, Oregon, \nUSA. Copyright c &#38;#169; 2006 ACM 1-59593-348-4/06/0010. . . $5.00. instantiated or left as a type \nvariable. Below are two classes whose .elds have been parameterised: class Cell(A){ A fst; \u00b7\u00b7\u00b7 } class \nPair(A,B) extends Cell(A){ B snd; \u00b7\u00b7\u00b7 } With such parameterised class declarations, we may then de\u00ad.ne \nspecialised instances, such as Cell(Int), Cell(Float) or Pair(Int,Num), which contain more speci.c type \ninformation for the .elds of each class instance. Though parametric types can co\u00adexist with class subtyping, \npointwise matching of the respective .elds is required. For example, the subtyping relation (denoted \nby <:) Pair(t1,t2) <:Cell(t3) is allowed only when Pair<:Cell and t1=t3. The latter condition is for \npointwise matching of the common .eld. Similarly, Pair(t1,t2)<:Pair(t3,t4)holds, pro\u00advided t1=t3 and \nt2=t4. Pointwise matching (invariant subtyping) is required because .eld reading and .eld writing are \nbased on op\u00adposite .ows that change the directions of subtyping. This require\u00adment limits the reusability \nof programs based on parametric types. To address this shortcoming, Igarashi and Viroli [17] developed \na new variant parametric type system (or variant type, in short) to improve the subtyping of generic \nstructures, depending on how the .elds are being accessed. Let c denote a class with one type param\u00adeter. \nLet o denote an object of variant type c(a1t1) while v denotes a location of variant type c(a2t2), into \nwhich o is to pass. Each variant type c(at) has a variance a (see Section 3.1) attached to its .eld to \nindicate how the .eld is to be accessed. A .eld that is sub\u00adject to read-only access via reference of \nv (denoted by a2 = .)may be supported by covariant subtyping. That is, c(a1t1)<:c(.t2) if a1<:. and t1<:t2. \nConversely, a .eld that is subject to write-only access via reference of v (denoted by a2 = 8) may be \nsupported by contravariant subtyping. That is, c(a1t1)<:c(8t2) if a1<:8 and t2<:t1. Also, a .eld that \nis subject to both read and write ac\u00adcesses via reference of v (denoted by a2 = 8) must be supported \nby invariant subtyping. That is, c(a1t1)<:c(8t2) if a1<:8 and t1<:t2.t2<:t1. Lastly, if a .eld is not \naccessed via reference of v (denoted by a2 = \u00ae), we can use bivariant subtyping. That is, we support \nc(a1t1)<:c(\u00aet2) for any t1 and t2. Variant types give a much richer subtyping hierarchy than pa\u00adrameterised \ntypes do. Figure 1 illustrates some variant types for Cell objects and their places in the subtyping \nhierarchy. Note that . denotes a subtyping relation in the graph. Also, Cell(\u00aet), Cell(.Object) and Cell(8.) \nare equivalent to each other while Cell(8Num), Cell(8Float)and Cell(8Int)are unrelated. Note that . denotes \nthe type of null values which can be assigned into any class type. However, each Cell(8t) is a subtype \nof both Cell(.t) and Cell(8t). Also, types of the form Cell(.t) and Cell(8t)have a subtyping hierarchy \nbased on covariance and con\u00adtravariance, respectively. The bene.ts of variant typing have been known \nfor some time. However, early proposals have attached access rights to the .elds of each class declaration. \nThis mechanism is known as declaration\u00adsite variance and is shown in the following example:  class DSCell(A){ \n.A fst; A getFst() {return fst; } void setFst(A x) {fst=x; }} The .eld fst is declared read only using \nthe variance .. Conse\u00adquently, the method setFst cannot be invoked. Using the concept of structured virtual \ntype, Thorup and Torgersen [35] were the .rst to link access rights and covariant subtyping to the .elds \nof each use of a class rather than the class declaration itself. This use-site variance mechanism is \nmuch more .exible than previous mecha\u00adnisms based on declaration-site variance. In the following exam\u00adple, \nthe access to the .eld fst is governed by the variance vari\u00adable a. A reference of type USCell(.Int)allows \nread-only ac\u00adcess, while a reference of type USCell(8Int)allows read-write access to the .eld fst. class \nUSCell(aB){ aB fst; B getFst() {return fst; } void setFst(B x) {fst=x; }} Later, Igarashi and Viroli \nextended this concept to support contra-and bi-variance [17]. They formalised the variant type sys\u00adtem \nby mapping it into a corresponding existential type system [7, 21, 22]. A recent proposal by Sun Microsystems \nfor generics in Java 1.5 [37] supports wildcard type based onanimprovement of Igarashi and Viroli s variant \ntype system, but it is still viewed as a special case of the existential type system with subtyping. \nHowever, a more general version of existential type system, called System F=, has undecidable subtyping \n[28], while the decidabil\u00adity of Igarashi and Viroli s variant type system, remains an open problem [18]. \nIn this paper, we propose a new approach for the variant para\u00admetric type system that is based on the \nmechanism of .ow anal\u00adysis. Our .ow analysis captures value .ows via subtyping con\u00adstraints. A major \nbene.t of this approach is the considerable knowl\u00adedge in .ow analysis that has been accumulated in the \nrecent past [25, 32, 38, 15, 16, 34, 26]. In particular, to support modular type\u00adchecking, we require \nnon-structural subtype entailment of the form .v(C1 =..wC2),where C1,C2 are subtyping constraints while \nv, w are sets of type variables. These constraints are non-structural as we use .<: t<: Object, to support \nthe OO class inheritance mechanism. While the decidability of non-structural subtype entail\u00adment remains \nan open problem, there exist sound approximations that use constraint simpli.cation and induction techniques \n[32, 38]. Our work is built on top of sound but practical solutions to subtyp\u00ading (.ow) constraints, \nand we have developed a systematic frame\u00adwork for the variant parametric type system with the following \nnew features: Our framework is based on .ow analysis which can concisely and intuitively capture .ow \nof values on a per method ba\u00adsis (Section 3). We use variance annotations primarily to predict the .ows \nof values, and not for access control. We also provide special considerations for two type values. A \nvalue of Object type can always .ow out from any location while a null value of .type can always .ow \ninto any location.  We augment our generic type system with intersection type to help capture information \n.ow more accurately. An intersection type t1&#38;t2 denotes a type with both the properties of t1 and \nt2. Such types are important for languages with multiple in\u00adheritance (such as Java via its interface \nmechanism), and can accurately capture the .ow of objects with their expected .eld accesses.  Our approach \nis based on modular type checking (Section 5). Each method is speci.ed with a .ow constraint (and variant \ntypes) that is used to predict the value .ows that may occur in the method s body. We verify each method \nseparately to ensure that the predicted accesses, .ow constraint and variant typings are ef.ciently and \nsafely checked.  We advocate the support of downcast to arbitrary variant types (Section 6). With this \nmechanism is a novel cast capture that uses a re.ection technique to deal with values of unknown type. \nCast capture has helped improve the generic implementation of several JDK 1.5 libraries.  We present \na soundness theorem and a variant type checker. We have successfully applied our prototype to a suite \nof Java li\u00adbraries and client codes (Section 8). On average, we are able to eliminate 87.9% of the casts \nfrom non-generic Java 1.4 applica\u00adtion code, that means 12.9% more casts than wildcard-generic Java 1.5 \napplication code. Our goal is to strive for type-safe OO programs with better genericity via a modular \n.ow-based approach to variant parametric type system. Next, we explain our approach with the help of \nsome examples.  2. Better Genericity The main goal of genericity is to support highly reusable software \ncomponents. To allow this to happen in a type-safe way, we should strive to provide type descriptions \nthat are concise, understandable, general and accurate. Speci.cally, each well-typed generic program \nshould be accurately identi.ed where possible. As a side bene.t, we are able to track type information \nin a precise manner, allowing redundant cast operations to be eliminated where possible. In this section, \nwe examine the key aspects for which our approach based on .ow analysis makes improvements over existing \napproaches based on existential types. Some of these improvements may not be peculiar to the .ow-based \napproach, but they were gradually developed starting from a different view point. 2.1 Intersection Type \nParametric type systems use number of cast operations eliminated as a measure of accuracy [10, 14]. As \nit turns out, there may be competing decisions on what types to use for certain cast operations to be \neliminated. The following example from [10] illustrates: class B1 extends A implements I {\u00b7\u00b7\u00b7 } class \nB2 extends A implements I {\u00b7\u00b7\u00b7 } void foo(Boolean b) { Cell cb1 = new Cell(new B1()); Cell cb2 = new \nCell(new B2()); Cellc =b ? cb1: cb2; A a = (A) c.get(); I i = (I) c.get(); B1 b1 = (B1) cb1.get(); \n B2 b2 = (B2) cb2.get(); } This program contains four cast operations. With the help of para\u00admetric types, \nDonovan et al. [10] suggested three sets of possible types, each with a different subset of casts eliminated, \nas sum\u00admarised below: Types of Variables Casts Eliminated cb1 cb2 c (A) (I) (B1) (B2) vv Cell(B1) Cell(B2) \nCell v Cell(A) Cell(A) Cell(A) v Cell(I) Cell(I) Cell(I) Note that Cell denotes a raw type where nothing \nis known of its components. Hence, only Object values are statically retrievable from it. Raw type was \noriginally proposed in [3] for backwards compatibility, and it is the basis for generic typing through \ninclu\u00adsion polymorphism. However, none of the three proposed solutions are able to eliminate all four \ncasts. This indicates that parametric typing is not expressive enough to capture generic type for such \nprograms. There are two possible improvements. First, note that the .elds of cb1, cb2 and c are subject \nto read-only accesses, and not modi.ed in the program fragment. We can therefore provide co\u00advariant annotations \nto the .elds of these variables, and obtain two possible outcomes, each with three casts eliminated: \ncb1 cb2 c (A) (I) (B1) (B2) v vv Cell(.B1) Cell(.B2) Cell(.A) vv v Cell(.B1) Cell(.B2) Cell(.I) Second, \nboth classes B1 and B2 have supertypes A and I in com\u00admon. To exploit this, we can use an intersection \ntype parameter in Cell(.(A&#38;I)) to describe the variable c. In a lattice of type val\u00adues, an intersection \ntype A&#38;I essentially de.nes the greatest lower bound of A and I. With this, all four casts can now \nbe eliminated in our new solution to genericity, as shown below: cb1 cb2 c (A) (I) (B1) (B2) vvv v Cell(.B1) \nCell(.B2) Cell(.A&#38;I) Note that the above example cannot be coded in Java 1.5 syntax. Java 1.5 does \nnot allow the use of intersection types for local variable declaration, .eld declaration or method argument/return \ntypes. Intersection types can be used only as upper bounds for a method type parameter. 2.2 Modular \nFlow Speci.cation Another important principle for better genericity is that type de\u00adscription should \nbe designed in a modular fashion (on a per method basis). Type annotations appearing in the method header \nshould de\u00adpend only on the method body while each call site should be a speci.c instance of the method \ns type declaration. This principle is important for ef.cient type checking and ease of type annotation. \nSpeci.cally, for each instance method, we provide the following method declaration: t | t0 mn(t1 v1,...,tn \nvn) where . {...} A separate annotation t | is added at the beginning of each method s declaration to \ncapture the variance of the implicit this parameter. This separate annotation (omitted in previous works, \nsuch as [17, 37]) allows us to capture the behaviour of each method, independent of its class declaration. \nNote that . captures the ex\u00adpected value .ows of each method s body in terms of type of the pa\u00adrameters \n(t1, .., tn), result (t0), and receiver (t). We support modular type checking by localising type variables \nwhich are not present in the type of parameters, result and receiver. A previous approach [17] relies \non the existential open/close mechanism for the receiver parameter to determine if the receiver parameter \nis of suitable vari\u00adance while other parameters are checked via subtyping. In contrast, we achieve uniform \ntreatment for all parameters. To illustrate the modular type annotation mechanism, consider three method \ndeclarations for the Pair class: class Pair(A,B) extends Cell(A){ B snd; Pair(\u00ae,.Y) | Y getSnd() {return \nthis.snd;} Pair(\u00ae,8Y) | void setSnd(Y v) {this.snd=v;} Pair(\u00ae,\u00ae)&#38;W | Pair(8W,8W) dup() {return new \nPair(W,W)(this,this);}} First, note that getSnd will read the second .eld while setSnd will write to \nit. Because of these effects, we may apply covariant (.) and contravariant (e) subtypings to the second \ncomponent of the Pair object for getSnd and setSnd, respectively. Second, bivariant (\u00ae) subtyping is \nallowed for the unaccessed component of the Pair object for both methods. As a shorthand, we may write \n\u00ae to denote \u00aet since all bivariant types are equivalent. Note that Y from getSnd and Y from setSnd denote \ndifferent type variables treated independently by our modular type checker. The third method is an interesting \napplication of intersection type. The method itself does not access the .elds of the this pa\u00adrameter, \nwhich escapes into the two .elds of the method s Pair result. To capture this value .ow, we declare an \nintersection type Pair(\u00ae,\u00ae)&#38;W for the this parameter. The type Pair(\u00ae,\u00ae) is to acknowledge that we \nhave a Pair object whose .elds are not ac\u00adcessedbythe current dup method. A type variable W helps indicate \nthat this parameter will escape into the .elds of the result with type Pair(8W,8W). This .ow allows the \nvariant type of W to .ow into the two .elds of the output Pair. Hence, for a given receiver of type t,we \nhave t<:Pair(\u00ae,\u00ae) and t<:W. Possible candidates for the type t are Pair(.X,.Y) or Pair(.X,8Y), etc.In \ncontrast,if we use the following type suggested in [17]: Pair(8X,8Y) | Pair(8Pair(8X,8Y),8Pair(8X,8Y)) \ndup() we require t=Pair(8X,8Y) or t=., which restricts the possible uses of the method. One way to improve \nthis situation is to dupli\u00adcate the dup method for different scenarios, as shown below: Pair(.X,.Y) | \nPair(8Pair(.X,.Y),8Pair(.X,.Y)) dup() Pair(.X,8Y) | Pair(8Pair(.X,8Y),8Pair(.X,8Y)) dup() Pair(8X,8Y) \n| Pair(8Pair(8X,8Y),8Pair(8X,8Y)) dup() However, such duplications go against the goal of genericity. \nOn the other hand, our solution with intersection types can improve genericity by allowing value .ows \nto be accurately captured. 2.3 Avoiding F-Bounds where Possible One feature that adds to the expressivity \nof bounded existential type is the use of F-bounds [5] which effectively capture recursive constraints \nof the form T<:C(.., T, ..) where T is a type variable and C is a class name. While the designers of \nJava 1.5 consider this feature to be signi.cant and useful [37], it is also a source of complication \nas reported recently in [20]. In particular, F-bound together with existential type is a source of undecidability \nfor System F= which caused an earlier implementation of Java 1.5 to fail in accepting some programs with \nF-bounds that were actually type-safe (as .rst reported in [20]). Subsequent improvements in Java 1.6 \nhave removed the reported errors, but the decidability of its type system remains an open problem. While \nthe .ow-based approach that we advocate also supports recursive .ow constraints (if the inductive mechanism \nof [32, 38] is used), our pragmatic philosophy is to avoid F-bounds whenever it is possible to do so. \nAs an example of F-bound, consider the following de.nition of the Comparable interface for Java 1.5: \ninterface Comparable(T){ int compareTo(T o); } Here, class parameter T is being used to capture the \nparameter of the method compareTo. As this parameter is required to be a subtype of Comparable itself, \nF-bound of the form T<:Comparable(8T)is usually needed when Comparable is used, as shown in the next \nexample: class Collections {(T extends Comparable(? super T)) static T max (Collection(? extends T) col) \n{\u00b7\u00b7\u00b7 }} In our .ow-based approach, the current philosophy is to cap\u00adture the value .ows of each method \nindependently. Hence, we have chosen to capture the value .ow and subtyping relation di\u00adrectly for each \nmethod instead, as shown below for our de.nition of Comparable: interface Comparable(A){ Comparable(8T) \n| int compareTo(T o); } Based on this de.nition, we can write the max method, as follows: class Collections \n{ static T max(Collection(.T) col) where T<:Comparable(8T){\u00b7\u00b7\u00b7 } } This alternative is equivalent to \nthe earlier Java 1.5 de.nition. We also support a simpler way, to express Comparable inter\u00adface, as follows: \ninterface Comparable { S &#38; Comparable | int compareTo(T o) where T<:Comparable . T<:S ; } The use \nof this de.nition does not require any F-bound, but it is more restrictive than Java 1.5 de.nition of \nComparable interface. Another potential use of F-bound occurs for recursive .elds of class declarations. \nAn example is the following recursive List class: class List(A,B) extends Object where B<:List(A,B){ \nA val; B next; ... } This solution uses an F-bound B<:List(A,B) that makes constraint solving more \ncomplex [32]. However, in our system we may choose to avoid the recursive constraint from the invariant \nof the class List by leaving the recursive next .eld with an incomplete variance ., as follows: class \nList(A) extends Object { A val; .List(A) next; ... } The variance of the next .eld is incomplete at \nits declaration site and can be promoted to either 8 or ., depending on how its underlying type parameter \nList(A) is being instantiated at the use site. This type promotion process is elaborated later in Section \n4.2, and can be used to avoid F-bound, where possible. 2.4 Avoiding Existential Type Always It has been \ngenerally acknowledged that existential type is use\u00adful for describing data types whose implementation \ndetails can be made abstract. This aspect is closely related to the use of bivari\u00adant type \u00aet where the \nunderlying type t is unknown and may be assumed to be of any type. While no-access is one way to enforce \nbivariant type, it is also possible to use the open/close mechanism of existential type system to describe \nsituations where implemen\u00adtation details can be made abstract. A typical example is the copy operation \non two elements of a vector that was highlighted in [18], and reproduced below: void copy(Vector(\u00ae) x, \nint i, int j) { open x as [Y,y] in y.setElementAt(y.elementAt(i),j) } The above code opens the bivariant \ntype of x as an object bound to variable y with an abstract type Y. As all elements of each vec\u00adtor are \nof the same Y type, we may safely copy a value from one position of the vector into another position, \nwithout knowing the actual underlying type. The close correspondence between existen\u00adtial type and bivariant \ntype is a primary reason why Igarashi and Viroli considered existential type system as the underlying \nmodel for their variant parametric type system. However, the designers of Java 1.5 considered the open/close \nmechanism of existential type system to be somewhat restrictive [36]. They have therefore proposed a \nrelaxation to open each ex\u00adpression as an existential type by associating it with a global type variable \nwithout a corresponding close operation. This use is simi\u00adlar to the .ow-based approach where each parameter \n(or local vari\u00adable) is regarded as a location where values may .ow in and/or out. Nevertheless, in the \ncontext of existential type system, such relax\u00adation might possibly be unsound since each existential \ntype may in fact correspond to contradicting type values. This is possibly why correctness proof is yet \nto be completed (as of [36]), even though a full-scale implementation for wildcard type system has already \nbeen released for public use. Furthermore, Java 1.5 relied on polymorphic (generic) type system for selected \nmethods to capture situations where invariant type appears necessary, as shown by the following example: \n(T) void docopy(Vector(T) x, int i, int j) { T tmp = x.elementAt(i); x.setElementAt(tmp,j) } Through \na wildcard capture mechanism, it is possible to provide a method with bivariant parameter, as shown below: \nvoid copy(Vector(?) x, int i, int j) { docopy(x,i,j); } Note that wildcard type of x has been captured \nby the global T type variable. Again, the open/close mechanism is averted, even though the underlying \nsystem is still based on bounded existential type system. Our current philosophy is to avoid existential \ntype system alto\u00adgether. To capture the effect of an unknown abstract type, we have introduced a casting \nmechanism that is able to capture the underly\u00ading type of an object via a fresh type variable. We refer \nto this as a cast capture technique which is elaborated in more details in Sec\u00adtion 6. The same copy \nmethod can be re-written with a casting of the x parameter from bivariant type Vector(\u00ae) to an invariant \ntype (Vector(8T)). In the process, T is used to capture the unknown type, as shown below: void copy(Vector(\u00ae) \nx, int i, int j) { Vector(8S) w; {w = (Vector(8T))x; w.setElementAt(w.elementAt(i),j) } } While this \ncast capture construct may look like a syntactic sugar for the open/close mechanism, we stress that it \nis part of a more general mechanism that can take an arbitrary type as source (instead of a bivariant \ntype) for casting into another arbitrary type as target (instead of an invariant type). A cast for a \nc1-object into an invariant type of the form c2((8t)*) where c1<:c2 is always safe since every object \nis built using an invariant type. Furthermore, cast-capture is a runtime mechanism while open-close is \na type\u00adrelated operation to expose an obtained type at compile-time. Our cast capture mechanism using \nre.ection is more general as it can capture type values at runtime, and also support a mix of cast capture \nand cast testing. In our formulation of variant parametric type system, the .ow-based approach with casting \nhas therefore avoided the need for existential type system altogether. Some readers may contend that \nthe casting mechanism is the prerogative of programmers and may be too burdensome to write. While this \nis so, we believe that there is still scope for automatic in\u00adsertion of safe casts to invariant type \n(in a spirit similar to automatic type coercion) that is consistent with each user program.  3. Variance \nvia Flow Analysis A central feature of our proposed approach is the focus on .ow analysis. Variance annotations \nare used to support the analysis of value .ows to capture more accurate generic types, whereby suit\u00adable \n.eld subtypings (covariance and contravariance) are facilitated where possible. We highlight the expressiveness \nof variant types through some more examples in Figure 2. Apart from a generic Vector(A) class declaration, \nwe provide a number of static methods to highlight how .ow analysis may assist in the formulation of \ngeneric types. In the copyVec method, the elements from a .rst vector Vector(.X)are copied into a second \nvector Vector(8Y), while a constraint X<:Y captures the direction of the value .ow. class Vector(A) extends \nCollection(A){Vector(\u00ae) | int size() {...}Vector(.X) | X elementAt(int i) {...}Vector(8X) | void setElementAt(X \nv, int i) {...} } void copyVec(Vector(.X) v, Vector(8Y) w, int start) where X<:Y {for(int i=0;i<v.size()&#38;&#38;i+start<w.size();i++) \nw.setElementAt(v.elementAt(i),i+start); } void copyNestVec(Vector(.Vector(.X))v, Vector(8Y) w) where \nX<:Y {int pos=0; for(int i=0; i<v.size();i++) { Vector(.Z) s=v.elementAt(i); if (pos+s.size()<w.size()) \n {copyVec(s,w,pos); pos +=s.size(); }}}void clearVec(Vector(8.) v) { for(int i=0; i<v.size();i++) v.setElementAt(null,i); \n }Vector(8Z) merge(Vector(.X) v, Vector(.Y) w) where X<:Z.Y<:Z {...}Vector(8Pair(8X,8Z)) join(Vector(.Pair(.X,.Y)) \nv, Vector(.Pair(.Y,.Z)) w) {...}void swap(Pair(8X,8Y) p) where X<:Y.Y<:X {T t=p.fst; p.fst=p.snd; p.snd=t; \n} Figure 2. Examples with Variant Types Method copyNestVec copies from a nested vector of type Vector(.Vector(.X)) \ninto a second vector Vector(8Y) with .ow constraint X<:Y. This code remains highly generic as it uses \ncovariant and contravariant subtypings. The next example shows how we use a special type . to indicate \nthat null values will be written into the vector. Given that Vector(8.) is high up in the class hierarchy, \nthis method is rather generic as we can supply any vector as its argument. We also provide method headers \nfor merge and join.From the type annotation of merge, we can tell that values from the .rst two vectors \nare retrieved, and then they .ow into a new result vec\u00adtor. For the join method, we retrieve values from \nthe two vec\u00adtors Vector(.Pair(.X,.Y)) and Vector(.Pair(.Y,.Z)) be\u00adfore building a new vector Vector(8Pair(8X,8Z)) \nthat is joined on the Y type. The result s invariant type offers a strong post\u00adcondition with read/write \ncapability. For the swap method, the two .elds of a Pair object are swapped. Due to both reading and \nwriting, we require the invari\u00adant type Pair(8X,8Y)and the expected value .ow: X<:Y.Y<:X. Based on the \n.ows from the three assignments of the swap body, we may obtain the following constraints: 8X<:.T, 8Y<:.X \nand 8T<:.Y,where T is a local type variable (using type rules in Sec\u00adtion 5.1). These constraints are \nsimpli.ed to obtain the following collected .ow for the method body: X<:T.Y<:X.T<:Y.The swap method type \nchecks as the expected .ow implies the collected .ow: .X,Y.(X<:Y.Y<:X =..T.(X<:T.Y<:X.T<:Y)) Note that \nthe local type variable T is existentially quanti.ed, while type variables X,Y from method parameters \nare universally quanti\u00ad.ed. 3.1 Improved Variant Subtyping Variant parametric type t consists of a variance \na and a type t.Its grammar is introduced in Figure 4. We use variance annotations 8, ., 8 and \u00ae, which \ncorrespond to read-write access, read-only access, write-only access, and no-access, respectively. These \nanno\u00adtations are ordered by the following relation that is denoted by <:a but abbreviated to <: below: \n8<: .8<: 8.<: \u00ae 8<:\u00ae a1<:a2 a2<:a3 a<:a a1<:a3 A type t is either a type variable vt, a variant parametric \nclass c(t1,...,tn), the bottom type . or an intersection type t&#38;t.The bottom type is used to hold \nthe null value. We allow .nite intersections of types through the type operator &#38;. Semantically, \nt1&#38;t2 denotes the set of objects satisfying the interface speci.cation of both t1 and t2. In a lattice \nof type values with partial order de.ned by class inheritance (through extends) and interface mechanism \n(through implements), t1&#38;t2 de.nes the greatest lower bound of t1 and t2. Our intersection types \nare similar to the compound types proposed in [4]. Speci.cally, they can be of the form [t1&#38;]t2&#38;...&#38;tn[&#38;W \n],where t1 is a class, t2, ..., tn are interfaces, and W is a type variable. In our system, variant parametric \ntypes are used to support .ow analysis rather than access controls. As we focus on value .ows at each \nmethod boundary, we apply variance annotations primarily to .elds. The outermost variance of local variables \nis always 8. For .elds, variance annotations are used to support covariant or contravariant subtyping \nwhere possible. The subtyping relations are denoted by <:t and <:t, both ab\u00adbreviated to <: as follows: \nft1<:t2.. ft1<:t2.. The resulting constraints . (see Figure 4 for their grammar) are kept in a disjunctive \nnormal form. Instead of proving each sub\u00adtyping directly, we collect a set of subtyping constraints . \nvia t-subtyping and t-subtyping in Figure 3. The .rst four t-subtyping rules support contravariance, \ncovari\u00adance, invariance and bivariance, respectively. The invariant case generates a constraint from \nthe semantical equivalence of the two types (t1 =t2). Unlike the subtyping rule of Igarashi and Viroli \n[17], our improved mechanism handles two special values in the subtyping hierarchy, namely . (for type \nof null) and Object (for top of class hierarchy). These two types are special in that it is al\u00adways safe \nto write a null (of . type) into any location (even if it has been marked for read-only access), and \nit is safe to read an Object value from any location (even if it has been marked for write-only t-subtyping \na1<:8f t2<:t1..a1<:.f t1<:t2.. fa1t1<: 8t2.. fa1t1<: .t2.. ft1=t2.. ft<: \u00aet.true f8t1<: 8t2.. \u00ac(a1<:.) \n\u00ac(a1<:8) fa1t1<: .Object.true fa1t1<: 8..true t-subtyping f.<:t.true ft<:Object.true ft<:t.true fti<:tD..i,i \n=1..n ft2<:t3..2 i ft1<:t2..1 V n nn fc(ti)<:c(tD)..i ft1<:t3..1..2 i=1ii=1i=1 mn class c1(Vi)extends \n...c2(tDi=1... ).=[Vi.ti]m i=1 ii=1 n DDn c2(.tD).p c2(.t) ii=1ii=1 mn fc1(ti)<:c2(.tDD).true i=1ii=1ft<:t1..1 \nft<:t2..2 ft1<:t..1 ft2<:t..2 ft<:(t1&#38;t2)..1..2 f(t1&#38;t2)<:t..1..2 t1=vt.t2=vt ft1<:t2..1 ft2<:t1..2 \nft1<:t2.t1<:t2 ft1=t2..1..2 Figure 3. Variant Subtyping access). We may also cast any type t to either \n.Object or 8.as it is always safe to read an object or write a null value. This mechanism is implemented \nby the last two t-subtyping rules. In the second part of Figure 3, the .rst two t-subtyping rules handle \nthe bottom and top of the hierarchy. Subtyping between types of the same class is decomposed structurally \nby the fourth rule. The next two rules describe transitivity and the class in\u00adheritance relation. The \nclass inheritance rule uses type promotion mechanism that is described later in Section 4.1 Intersection \ntypes satisfy the subtyping relations as in [29]. Subtyping relations that contain type variables are \nnot simpli.ed further and preserved in the resulting constraint. Semantic equality (t1=t2)is given by \nthe last t-subtyping rule. In summary, from the subtyping relations be\u00adtween types, we generate a set \nof subtyping constraints (on type variables). Note that in the following sections, we will use t1<:t2 \nas an abbreviation for .,where ft1<:t2...  4. Core Language We introduce a core language to ease the \nformulation of static and dynamic semantics. This language can be viewed as a result of translation from \nfull Java language prior to type checking. For ease of presentation, we omit features that are related \nto static methods, exception handling, concurrency and inner classes. (Our implementation handles all \nfeatures of the Java language.) Our core language is named Variant CoreJava, and summarised in Figure \n4. We use the suf.x notation y * to denote a list of (zero or more) distinct syntactic terms that are \nsuitably separated. Both class and interface declarations are supported using the same syntactic grammar \nterm def. As with Java, the main difference is that inter\u00adface de.nitions do not have .elds, and are \nde.ned using abstract methods (without body). Furthermore, while we support multiple inheritance, it \nis of the same restricted kind as that supported by the Java language. Each class may extend from only \na single su\u00adperclass but may implement multiple interfaces. In our language, the declaration class c(V \n*)extends gc1..gcn assumes that gc1 is a Programs P ::= def* def ::= class c(V *)extends gc1..gcn where \n.inv {(p f)* meth*} gc ::= c(p1, .., pn) * meth ::= t |t mn((tv) *)(v )where . {e} w ::= v |v.f e ::= \nnull |w |w = e |{tv = e1; e2}|e1 ; e2 |new c(t *)(v *) |if v then e1 else e2 |while v do e |v0.mn(v *)(t \n*)|(t)v |{v1 =(t)v ; e} t Variant Parametric Types t ::= at t ::= vt |c(t1, .., tn)|t&#38;t |. a ::= \n8| . | 8 |\u00ae Incomplete Variant Parametric Types p ::= V |.s s ::= c(p1, .., pn)|s&#38;s |. Subtyping \nconstraints . ::= t1<:t2 |... |true Class Invariant .inv ::= V<:ic(t * )|c(t * )<:i V |.inv ..inv |true \nFigure 4. Syntax of VARIANT COREJAVA class while gc2..gcn are essentially interfaces (implements is also \nrepresented by extends for easy presentation). Each class decla\u00adration captures a class invariant .inv \nthat is expected to hold for all newly constructed objects of the class. This is being used to specify \nsuitable class lower and/or upper bounds for type variables. Since our system is based on use-site variance, \nthe class .elds types and the arguments of class inheritance have incomplete variance at declaration-site \n(denoted by p and V ). Section 4.1 describes the an\u00adnotations of class declarations with incomplete variant \nparametric types. Each method declaration meth contains a constraint . which captures the expected value \n.ows for its type variables. It also speci.es method type parameters (v *)in order to support modular \nt type checking. This set of type variables is automatically inserted by our compiler. We use an expression-oriented \nlanguage, where method body is denoted by e. Local variable declaration is supported by block structure \nof the form: {tv = e1; e2}, with e2 denoting its result. Each object is always built with an invariant \ntype c(8t *)via the construct new c(t *)(v *). Our core language also supports a full casting mechanism \nvia (t)v,where t can be an arbitrary variant type. In addition, we support a novel cast capture mechanism \nvia {v1 =(t)v ; e},where t is an invariant type with unknown type variables that may be captured at runtime \nand used in e.These special features will be described in more detail in Section 6. For simplicity of \npresentation, our core language represents primitive types (such as void, bool) by their corresponding \nclasses (such as Void, Bool). In our implementation, we handle primitive types directly, as elaborated \nin Section 9. For soundness reasons, we treat arrays in the same way as other classes (unlike Java 1.5, \nwhich assumes arrays to be covariant). In the subtyping constraints, disjunction is supported internally \nas it may be generated by subtyping relation for intersection types. 4.1 Class Parameterisation and Inheritance \nFor class declarations, an important decision is which .elds are to be parameterised and how the class \ninheritance mechanism is to be supported. In general, each class declaration should be written in the \nfollowing manner: class c1(V1..Vn)extends c2(p 1..p s)where .inv {p1 f1; ... pm fm; ... } n where each \n{Vi}originates either from the .elds of the current i=1 ms class {pi}or from the arguments of its superclass, \n{p i}. i=1 i=1 n {Vi}are variables corresponding to types with variance. For i=1 instance, the following \nnon-generic declarations of Cell and Pair classes: class Cell { Object fst; \u00b7\u00b7\u00b7 } class Pair extends \nCell { Object snd; \u00b7\u00b7\u00b7 } can be parameterized as: class Cell(A){ A fst; \u00b7\u00b7\u00b7 } class Pair(A,B)extends \nCell(A){ B snd; \u00b7\u00b7\u00b7 } Thevarianceofthe .elds fst and snd is governed by the vari\u00adables A and B. Given \nthe type Pair(.Int,8Int),the .eld fst is covariant and the .eld snd is contravariant. 4.2 Type Promotion \nThere are some situations where the variance of a class .eld cannot be speci.ed at use site. In the following \nexample, the variance of the .eld sndP does not have any correspondence in the class parameters A,B,C \nand remains unknown after instantiation of these parameters. class Triple(A,B,C)extends Cell(A){ Pair(B,C)sndP; \n\u00b7\u00b7\u00b7 } The compiler inserts a special variance marker .to represent the unknown variance of .eld sndP: \nclass Triple(A,B,C)extends Cell(A){ .Pair(B,C)sndP; \u00b7\u00b7\u00b7 } Note that the source program does not contain \nany variance markers. We use them to explain how incomplete (or unknown) variance of variant parametric \ntypes are computed to either .or 8. This process is known as type promotion and can be used for incomplete \nvariant parametric types from .eld declarations and arguments of class inheritance. The type promotion \nis de.ned using the relations . fp.pt. fs.pt where . is a substitution [V .t] from class declaration \nparameters V to variant parametric types t. The types p and s may contain unknown variance .. The rules \nare described in Figure 5. The second rule promotes the unknown variance .to either .or 8depending on \nthe predicate inv(t) where t is the type ob\u00adtained after substitution. Predicate inv(t) returns true,when \nall . f s.p ta = if inv(t) then 8 else . . f V .p .V . f.s.p at . f pi.p ti i =1,n . f si.p ti i =1, \n2 . f c(p1, ..pn).p c(t1, ..tn) . f s1&#38;s2.p t1&#38;t2 a= .|8|\u00ae inv(8t)=true inv(vt)= true inv(at)=false \n^^ inv(c(t1, ..tn))= inv(ti) inv(t1&#38;t2)= inv(ti) i=1,n i=1,2 inv(c())= true inv(.)= true Figure 5. \nType Promotion variances from t (if any) are 8 and false otherwise. Given Triple(.Int,.Int,.Int), the \ntype of .eld sndP is com\u00adputed as follows: . f.Pair(B,C).p.Pair(.Int,.Int) where . =[A ..Int,B ..Int,C \n..Int]. As another example, given Triple(.Int,8Int,8Int), the type of .eld sndP is com\u00adputed as follows: \n. f.Pair(B,C).p8Pair(8Int,8Int) where . =[A ..Int,B .8Int,C .8Int]. Another application of type promotion \nis for recursive .elds of a class. The recursive .eld next of the class List has an incomplete variance \n. as follows: class List(A) extends Object { A val; .List(A) next; ... } The variance of the .eld next \nis incomplete at its declaration site and can be promoted to either 8 or ., depending on how its underlying \ntype parameter List(A) is being instantiated at the use site. For example, when A is instantiated to \n8X, the variance of the next .eld will be promoted to . via . f.List(A).p .List(8X),where . =[A .8X]. \nOn the other hand, if A is instantiated to 8X,then . =[A .8X] and the variance of the next .elds is instantiated \nto 8X as follows: . f.List(A).p 8List(8X). Our type promotion is a re.nement of that proposed in [17]. \nFirst, we allow promotion to 8 whenever possible while Igarashi and Viroli considered mainly the promotion \nof nested types with .. Second, we consider type promotion for only .eld access and class inheritance \nwhere the outer variance is dependent on the variance of the underlying type. In contrast, Igarashi and \nViroli focused on the promotion of nested types of arguments/result for method declarations, which need \nnot be handled in our approach as these types are fully speci.ed in our method declarations. 4.3 Class \nInvariant The class invariant .inv is used to capture the lower and upper bounds for the parameterised \n.elds of each newly created object of the class. These bounds are of the form V c1(t*)<:iV<:ic2(t*). \nClass invariant may also support F-bounds when variable V occurs in the parameters of classes c1 and \nc2. If unspeci.ed, the default lower and upper bounds are . and Object, respectively. An upper bound \ninvariant on a write-only .eld restricts the class of the object that can be written to the .eld to be \nsubclasses of the bound, and a lower bound invariant on a read-only .eld restricts the class of the object \nthat can be read from the .eld to be superclass of the bound. We use the relation .cinv to reduce bounds \nfrom the class invariant to a constraint form: f [Vi . ti].inv.cinv.,where ti are the current variant \ntypes for the class .elds. The relation .cinv is de.ned in Figure 6. Note that this relation invokes \nthe subtyping relations de.ned in Figure 3. f\u00aet<:it1.cinvtrue ft1<:i\u00aet.cinvtrue ft<:t1..1 ft1<:t..2 ft<:t1..1 \nft1<:t..2 f.t<:it1.cinv.1..2 ft1<:i8t.cinv .1..2 a= 8|8 ft<:t1..a= .|8 ft1<:t.. fat<:it1.cinv. ft1<:iat.cinv \n. f .i .cinv.i inv VV f .i .i inv .cinv Figure 6. Class Invariant To illustrate the use of these bounded \ninvariants, consider a class declaration for Cell(X) with an upper bound X<:Num.For declarations of the \nform Cell(8Int) and Cell(8T), the relation .cinv generates the Int<:Num and T<:Num, respectively. The \n.rst constraint reduces to true, while the second constraint contains a type variable and will be checked \nlater for satis.ability. As another example, for Cell(8Object) the relation .cinv fails as the upper \nbound is violated. Correspondingly, for read access, we support Cell(.Int) and Cell(.Object), but not \nCell(.String) since no String objects can be read from the Num-bounded .eld. The class invariant is accumulated \nrecursively from all the su\u00adperclasses, as shown below: [CINV] class c(Vi)m extends(ck(pik)nk )s where \n.inv {..}.P i=1i=1k=1 .=[Vi.ti]m . f c1(pi1)n1 i=1 i=1.pt f ..inv .cinv. cinv(c1(ti)m )=..cinv(t) i=1 \n  5. Variant Type System Variance annotations of programs are used to support .ow analysis for more \naccurate generic types. We verify the .ow of values through the following typing relation: G; Q f e :: \nat, . The relation is for type checking, and assumes that G (type envi\u00adronment), Q (type variables in \nscope) and at (type with expected variance) are given while . is the collected .ow constraint. Syntax\u00addirected \nrules for various language constructs are given in Figure 7. Our type system is .ow-insensitive as every \nlocation (variable, parameter and .eld) is given a type that never changes. In our type system, each \nobject of type t1 can be placed in a location of type t2, provided t1<:t2. The type of a location is \ntherefore a particular type view of its object. This type view of an object may be changed by upcasting \n(via assignment or parameter passing) or by downcast operation that is checkable at runtime. The following \nrule shows how to type check an assignment expression: [ASSIGN] at=GetType(G,w) a<: 8 G; Q f e :: .t, \n. G; Q f w = e :: .Void,. Flow-in or write-only 8 is mandated on the left-hand side (w) while .ow-out \nor read-only . is mandated on the right-hand side (e). To highlight how these .ows are enforced, we present \nthe rule for variable and .eld access (w stands for either v or v.f): [NULL][LOCAL][SEQ] GD=G+{v::8t} \nG; Q fe1::.t, .1 GD; Q fe2::t, .2 G; Q fe1::\u00aet, .1 G; Q fe2::t, .2 G; Q fnull :: t, ..<:t G; Q f{tv=e1; \ne2}:: t, .1..2 G; Q fe1; e2::t, .1..2 [COND][WHILE][PROG] G(v)<: .Bool G(v)<: .Bool fdef InheritanceOK(defi),i \n=1..n G; Q fe1 :: t, .1 G; Q fe2 :: t, .2 G; Q fe :: t, . fdef defi,i =1..n G; Q fif v then e1 else e2 \n:: t, .1..2 G; Q fwhile v do e :: .Void,. fprg defi=1..n [CALL] [CLASS] D . =[Vj .tj ]k tD=G(v)q j=1 \ni ii=0 t 0 |t mn((t i vi)q )(V1..k)where ....tD c1fmethmethi,i=1..q Vi=10 S q tD n snk m .1 = <:.(.t \ni)..(.t)<:t vars{pi}.(vars {p ik}) .{Xi} i=0 ii=1k=1i=1i=1 G; Q fv0D .mn(v1D , .., vD )(t1..k):: t, .1... \nfdef class c1(Xi)m extends ( ck(p ik)nk )s where .inv {(pi fi)n methi=1..q} qi=1 i=1k=1 i=1 [INHC][OVERRIDE] \npq def = class c1(Vi)extends c2(p i)i=1..where..{fd* meth1..p} meth1 = t0 |t mn((ti vi)pi=1)(V *)where \n.1 {e1} i=1 q (.meth \u00b7meth .c2(p i)i=1.. .name(meth)= name(methi)) meth2 = t 0 |t mn((ti vi)p )(V *)where \n.2 {e2} i=1 .fOverridesOK(methi, meth) i.1..p VL=vars(t 0)-vars(t0) ft0<:t 0.. .VL \u00b7(...2 =..1) fInheritanceOK(def) \nfOverridesOK(meth1, meth2) [FIELDS][GetType1][GetType2] nr fi)m class c1(Vi)extends c2(p i)i=1..{(pD \ni=1..} at=GetType(G,v) i=1 i nn .=[Vi.ti]n . fpD.ptD,i.1..m . fp i.pt D,i.1..r t=G(v) t=c(ti)(tf)..elds(c(ti)) \ni=1 iii i=1 i=1nr .elds(c1(ti))= [(tD fi)]m +.elds(c2(t D)) t=GetType(G,v) t=GetType(G,v.f) i=1ii=1ii=1 \n Figure 7. Variant Type Rules [VAR-FIELD] t1=GetType(G,w) ft1<:t.. G; Q fw :: t, . To retrieve the types \nof the variables and class .elds, we use the auxiliary [GetType] rules from Figure 7. The current type \nt1 of w is retrieved from the type environment G. Further, the rule checks that t1 is a subtype of the \nexpected variant type t. This supports a .ow-out from the variable w. For object creation, we ensure \nthat each object is constructed with an invariant type using c (8ti)q . A type is said to be invari\u00ad \ni=1 ant if each variance on its immediate .elds is marked with 8.Note that the views of nested .elds, \nnamely t1, .., tq from c (8ti)q i=1, may still be of variant types. Note that the variance of all class \n.elds (including those which require type promotion) returned by .elds is 8. [NEW] qq vars{ti}.Qt0=c(8ti)(8tD \nfi)pi=1 =.elds(t0) i=1i=1 i f.t0<:t..0 G; Q fvi :: .tiD ,.i i =1..p V qp G; Q fnew c(ti)(v1, .., vp):: \nt, .i.cinv(t0) i=1i=0 For the purpose of constructing invariant types, the type variables in {ti}q must \nbe instantiated from Q. The class invariant cinv(t0) i=1 captures the speci.ed upper/lower bounds on \n.elds that must be satis.ed for every object of the class. When such .elds are updated, we statically \nensure that their bounds are never violated. Given an instantiated class type, the rule [FIELDS] returns \nthe variant types of the class .elds using type promotion if necessary. Local variable declaration v \nis marked for read-write access via v :: 8t as showninthe rule [LOCAL]. The rule for method call [Call] \ncollects the .ow-in for receiver and arguments, .ow-out for the result and the method precondition. 5.1 \nModular Flow Veri.cation We design a variant type system that can be veri.ed in a modular fashion. Each \nmethod declaration is given suitable variant type annotations for its parameters, result and receiver. \nA may .ow constraint . is speci.ed at the header of each method declaration. This may-.ow speci.cation \ncaptures all possible .ows that may occur in the method s body e. The type checking rule for a method \nis formalised as follows: [METHOD] p chkRecv(cn,tV0)G={vi:: .ti}i=1+{this:: .t0}.1=..p cinv(ti).cinv(t) \n.1= false i=0 Q={V *} vars(.).Q vars(G,t).Q G; Q fe :: .t, .2 VI =vars(.2)-Q.1 =..VI \u00b7.2 cn fmeth t0 \n|t mn((ti vi)p )(V *)where . {e} i=1 We .rst construct an initial assumed .ow constraint .1 that is de\u00adrived \nfrom the declared may-.ow speci.cation ., class invariants for each parameter, and result Vp cinv(ti).cinv(t), \nThe initial as\u00ad i=0sumed .ow constraint must be satis.able, that is, .1 =false.Fur\u00adthermore, we collect \nthe .ow constraint of the method body using G; Q fe : .t, .2,where .2 captures all .ows that may occur \nin the method body e. To prove the correctness of each declared .ow constraint, we perform a subtype \nentailment on the .ow constraint with VI as local type variables using: .1 =..VI \u00b7.2. If this entail\u00adment \nholds, we have successfully veri.ed the .ow speci.cation of a given method declaration. We also check \nif t0, the given type of this, is compatible (no stupid cast) with the current class via the predicate \nchkRecv(cn,t0)= cn(8t *)<:t0. Method overriding is checked by the [Override]rule. For safe function subtyping, \nwe require each overriding method to have weaker or equal .ow speci.cation compared to the overwritten \nmethod. 5.2 Soundness The soundness of our type system can be proven by relating to dynamic evaluation \nsemantics of the form: (.,r)[e] '.(.D,rD)[e D] where . and r denote runtime stack and heap, respectively. \nThis evaluation may yield three possible runtime errors, namely E = Error-Null | Error-Cast | Error-Type. \nThe second error is due to cast operations guarded by runtime checks inserted by the compiler. The third \nerror is due to an object of the wrong type being writ\u00adten into a location with some expected static \ntype. For well-typed programs, this last error can never happen. The progress theorem states that Error-Type \ncannot occur while the type preservation the\u00adorem shows that the type of an expression is preserved with \neach reduction step. We outline the two theorems below; details of proof may be found in Appendices A, \nB and C. THEOREM 1 (Progress). Let G be the environment mapping pro\u00adgram variables to ground types. If \nG; S; Q f e :: t,. and G; S; Q; . |=.,r, then either: e is a value, or (.,r)[e] '. Error-Null | Error-Cast,or \nthere exist .D,rD,eD such that (.,r)[e] '.(.D,rD)[eD]. Note that the type rules are extended to include \nstore typing S. G; S; . |=.,r denotes a consistency relation that relates static and dynamic semantics. \nThe following theorem states the preservation of type during dynamic evaluation. THEOREM 2 (Preservation). \nLet G be an environment mapping program variables to ground types. If G; S; Q f e :: t, . G; S; Q; . \n|=.,r (.,r)[e] '.(. ,r )[ e] then there exists G , S and Q such that G - diff(e,e )= G - diff( e,e) \nS . S S; e :: t, G; Q f . G; Q; =.,r. S; . . . | Function diff(e,eD) returns a list of local variables \nthat appear in e but not eD .  6. Casting and Cast Capture While a key goal of a generic type system \nis to provide precise information to eliminate unnecessary downcasts, there remains al\u00adways the need \nfor cast operations to support the class subtyping mechanism. Furthermore, the introduction of generics \nand vari\u00adance has complicated type casting as these operations must handle type variables and nested \nvariant types. For example, cast opera\u00adtions may target nested types, such as Vector(8Vector(.Num)), \nor those with type variables, such as Vector(.X). However, existing solutions that support casting in \nJava 1.5 are restricted in that they use cast checks on the outermost type constructor only [37], and \nrely on unchecked warnings that may cause runtime errors (e.g., when a cast to type variable occurs). \nThe only system that supports cast operations fully (but for parametric types) was proposed by Viroli \nand Natali [39]. Their technique can be adapted to handle arbitrary variant types. In the presence of \nsingle inheritance, we can classify each cast\u00ading relation from t0 to t into three categories: (1) safe \nupcast if ft0<:t, (2) downcast with runtime check if ft<:t0, and (3) stupid cast if \u00ac(ft0<:t .ft<:t0). \nHowever, in the presence of multiple in\u00adheritance with interfaces, a class and an interface may be unrelated \nbut a valid downcast is still possible if the actual type is a subtype of the two. Though it is possible \nto identify stupid cast with a more complex test, namely \u00ac(.X\u00b7X=..X<:t.X<:t0), we avoid it for simplicity. \nInstead, we only check to ensure that the type variables used in t have come from Q. Our type rule to \nsupport a variant cast operation is given below: [CAST] at0=G(v) a<:. vars(t).Q G; Q f (t)v :: t, .t<:t \nWhile casting is used to check a speci.c type for an object, we often have to deal with objects of unknown \ntypes. For example, we may have an object with a static type List(8A),and we may be interested to know \nits actual invariant type List(8T),where T is an unknown type. To help identify the invariant type of \na given object, we introduce a cast capture construct based on re.ection mechanism: {v1 =(t)v ; e} The \nfollowing rule shows how to type check the capture construct: [CAPTURE] ac(ti)n =G(v) a<:. t=c(8Vi)n \n{Vi}n n Q={} i=1 i=1 i=1 G; Q f v1 :: 8t, .1 Q1=Q.{Vi}n G; Q1 f e :: t, .2 i=1 G; Q f{v1 =(t)v; e} :: \nt,.1..2 Note that t is an invariant type of the form c(8Vi): c should have the same class type as v, \nwhile the captured type variables Vi stand for unknown types. Each Vi can be used in the expression e \nwith its .ow captured by the collected .ow (.1..2). The .ow of captured type variables should not cause \naddi\u00adtional restriction or generalization at the method boundary. We next present how the type system \nensures the correct use of captured type variables. The actual type t obtained via re.ection is guaranteed \nto be more precise than v s static type, G(v). We call this guarantee re\u00ad.ection assumption. For each \nmethod, a relation G f e .C VC ,.C collects captured type variables, VC , and their re.ection assump\u00adtions, \n.C as follows: at0=G(v) ft<:t0.. X=vars(t)G f e.CV,.1 G f{v1 =(t)v; e}.C V .X,...1 The method judgement \nis modi.ed to exclude captured type variables VC from the local type variables VI . Additionally, the \nexpected .ow .1 is strengthened with re.ection assumptions .C . [METHOD-WITH-CAPTURE] chkRecv(cn,t0)G={vi:: \nV. ti}pi=1+{this:: . t0}G f e.C VC ,.C .1=.. p cinv(ti).cinv(t)..C i=0 Q={V *} vars(.).Q vars(G,t).Q.1=false \nG; Q f e :: .t,.2 VI =vars(.2)-Q-VC .1 =..VI \u00b7.2 cn fmeth t0 | t mn((ti vi)p )(V *) where . {e} i=1 The \nproper .ow of captured type variables is then ensured by the entailment from the above rule. 6.1 Cast \nCapture Examples The cast capture mechanism can also be viewed as a downcast to the object s invariant \ntype. Unknown types that are captured (via re.ection) may be used in the program code, as shown in the \nex\u00adample below: void addNode(List(8A) y, B z) where B<:A { List(8S) v; List(8S) w; {v = (List(8T)) y; \nw = new List(T)(); w.val = z ; w.next = v.next ; v.next = w; }} Though we do not know the exact type \nof y, we can use a cast capture on (List<8T>) to obtain its invariant type. Correspond\u00adingly, the re.ection \nassumption is A<:T. We use the captured type T to build a List(8T) node, write z to w.val, and also recon\u00adstruct \npointers for the linked list in a type-safe and yet generic way. For this example, the initial assumed \n.ow is .1=(B<:A.A<:T), whereby B<:A is from the .ow speci.cation and A<:T is the re\u00ad.ection assumption. \nThis initial assumed .ow implies the collected .ow constraint .S\u00b7.2,where .2=(S<:T.T<:S.B<:S). Hence, \nmodular veri.cation holds for this example. The same cast capture mechanism may also be used to capture \nan unknown invariant type, enabling a swap of elements within the same collection without knowledge \nof its type. Consider: void swapVec(Vector(\u00ae) v,int i, int j) { Vector(8S) w; {w = (Vector(8T))v; S v1 \n= w.elementAt(i); S v2 = w.elementAt(j); w.setElementAt(v2,i); w.setElementAt(v1,j);}} Note that input \nparameter v uses a bivariant type Vector<\u00ae>, which can be used to support an argument of an arbitrary \nVector object. The initial assumed .ow is .1=true, while the collected .ow is .S\u00b7.2,where .2=(S<:T.T<:S). \nHence, the entailment .1 =..S\u00b7.2 holds. An example of a method that does not type check is presented \nbelow: Vector(.Y) foo1(Vector(\u00ae) v) { Vector(8S) w; {w = (Vector(8T))v; w}} The initial assumed .ow \nis .1=true while the collected .ow is .2=T<:Y. Note that neither T (captured type variable) nor Y (global \ntype variable) are existentially quanti.ed from .2. The entailment .1 =..S\u00b7.2 does not hold, since the \ncaptured type variable T in\u00adtroduces an additional .ow at method boundary. As another exam\u00adple, the following \nde.nition type checks as the collected .ow from the method s body (after elimination of the local type \nvariable S)is .2=true: Vector(\u00ae) foo2(Vector(\u00ae) v) { Vector(8S) w; {w = (Vector(8T))v; w}}  7. Implementation \nWe built a prototype for our variant parametric type system and carried out initial experiments to validate \nits feasibility. Our system was built using the Glasgow Haskell compiler [27], with a con\u00adstraint solver \n(for handling subtyping constraints) implemented us\u00ading Constraint Handling Rules (CHR) [13]. Our constraint \nsolver employs a two-step algorithm to prove the non-structural subtype entailment of the form .VG \u00b7(.1 \n=..VI \u00b7.2). Note that .1,.2 are conjunctions of subtyping constraints , while VG and VI are sets of type \nvariables. Even though the entailment from the [METHOD] rule may contain disjunctions, it can be re\u00adduced \nto entailments of the above form. 1. We eliminate the local type variables VI (based on their upper V \nand lower bounds) from .2 to obtain .D =n Xi<:Yi using 2 i=1 techniques similar to [32, 38]. To support \nthe language s semantics a local type inference sim\u00ad ilar to [30, 23] is employed to identify appropriate \ninstantiated types for local type variables or type parameters. V n 2. The resulting entailment .VG \u00b7(.1 \n=. i=1 Xi<:Yi) is equiv- V n alent to i=1(.VG \u00b7(.1 =. Xi<:Yi)). Each entailment can be proven by contradiction \nusing the falsity of the formula .VG \u00b7(.1.notsub(Xi,Yi)),where notsub(t1,t2) represents nega\u00adtion of \nsubtyping relation. Our constraint solver implements the variant subtyping rules (from Figure 3). Its \ndeduction mechanism detects falsity based on pair of constraints of the form t1<:t2 and notsub(t1,t2). \nOur algo\u00adrithm is a sound approximation of the subtype entailment problem. The deduction mechanism can \nbe further extended by the tech\u00adniques of case analysis and inductive proving. However, from our experience \nworking with large sets of Java library and application codes that have been annotated and checked with \nvariant paramet\u00adric types, we have yet to encounter real examples which require such extensions.  8. \nExperimental Results To test the utility of our .ow-based variant type system, we eval\u00aduated our prototype \non a set of Java applications1 as used in [10, 14]. These applications make use of library classes from \npack\u00adage java.util, which we annotated with our variant paramet\u00adric types. We counted each method declaration \nwith .ow speci.\u00adcation, each class declaration with type parameters and each cast capture as a line of \nannotation. On average, these annotations con\u00adstituted about 5.5% of the source code, which may be considered \na reasonable price to pay for better reuse of type safe generic code. Due to modular type checking, the \ntime needed to verify type-safe generic code was less than one second for each library code and less \nthan 30 seconds for each application code. We expect that the time can be reduced by using a specialised \nconstraint solver. Currently, our prototype is based on a meta constraint handling system writ\u00adten in \nCHR (which compiled to a Prolog program under IC-Parc s ECLiPSe system [2]). Library Prog. Java 1.4 Java \n1.5 VPT Lines Casts Casts Warnings Casts Warnings AbstractList 909 1 1 0 0 0 AbstractSet 162 1 1 0 0 \n0 ArrayList 623 2 8 9 1 0 HashMap 1103 7 9 20 3 0 HashSet 231 2 4 3 1 0 Hashtable 1154 10 14 31 7 0 LinkedList \n814 2 4 5 2 0 Properties 925 8 8 1 0 0 Vector 1062 2 9 9 0 0 Total 6983 35 58 78 14 0 Figure 8. Results \nfor Library Code Figures 8 and 9 show the experimental results for representative classes from the java.util \npackage and application code (in terms of remaining casts). We counted the number of casts in Java 1.4 \ncode (non-generic), Java 1.5 (annotated with wildcards) and our system (VPT -annotated with variant parametric \ntypes). The Java 1.5 compiler could not statically check some operations (especially those related to \nraw types and casts to type variables), and issued unchecked warnings since these operations cannot be \nveri.ed by JVM runtime. Therefore, it is the programmer s responsibility to ensure that all unchecked \noperations are in fact safe. 1 For more details: www.junit.org, www.cs.princeton.edu/ ~appel/modern/java/JLex/, \nwww.cs.princeton.edu/ ~appel/modern/java/CUP/, www.spec.org/osg/jvm98/, vpoker.sourceforge.net, telnetd.sourceforge.net. \nApplication Prog. Java 1.4 Java 1.5 VPT Lines Casts Casts Warnings Casts Warnings DB 842191000 JUnit \n5886 54 30 1 15 0 VPoker 679236 8 0 6 0 JLex 726069 12 3 0 0 Jess 10639 95 34 0 12 0 TelnetD 11314 46 \n8 0 6 0 JavaCup 11468 543 98 2 65 0 Total 54201 862 191 6 104 0 Figure 9. Results for Application Code \nTo summarize, our method can eliminate a signi.cant portion (on average 87.9%) of the casts from non-generic \nJava 1.4 applica\u00adtion code and 45.5% of the casts from wildcard-generic Java 1.5 ap\u00adplication code. We \nhave also made improvements for library code by eliminating about 60% casts from non-generic Java 1.4 \ncode and about 75.8% casts from the wildcard-generic Java 1.5 code. Since our system fully supports casting \nfor variant types, we can verify the unsafe operations for which the Java 1.5 compiler gener\u00adates unchecked \nwarnings. Note that Java 1.5 libraries contain more casts than Java 1.4 libraries do, since Java 1.4 \ncontainers are based on Object type instead of generic types. As expected, Java 1.4 application code \nrequires more downcasts compared to Java 1.5 code.  Note that the casts eliminated using our type system \nmeasure the improvement in program safety. Current Java implementation (which translates parametric programs \nvia type erasure) would re\u00adintroduce casts at the bytecode level. While such re-admitted casts may cause \nruntime overheads, they are known to be type safe and will never fail at runtime. Obviously, a better \nsolution is to support variant parametric type at the bytecode level and we look forward to this scenario. \n9. Extensions In this section, we present some features omitted in the main pre\u00adsentation for brevity. \nThe hierarchy of primitive types forms a separate lattice from reference types. Furthermore, it is not \nthe case that .<:p<:Object for each primitive type p. Due to such differences, primitives are excluded \nfrom use as type arguments for generic classes in Java 1.5. Furthermore, the type erasure algorithm for \nthe parametric program will transform each parametric .eld into an Object type for backwards compatibility. \nThis is invalid if primitive types are used as type arguments. We now show how primitive types can be \nused as type argu\u00adments for generic classes in our system. First, we need to add two constraints to distinguish \nreference and primitive types, as shown below: . ::= \u00b7\u00b7\u00b7 | ref(t) | prim(t) As these two families of \ntypes are disjoint, we add the following CHR irrevocable rule: ref(t) . prim(t) . false Second, we need \nto consider primitive types in the new variant subtyping mechanism. In the new subtyping hierarchy, \u00aet \ndenotes any type (reference or primitive) while .Object and 8. denote only reference types (that are \nstill equivalent, namely .Object=8.). The subtyping relation is changed accordingly: .Object<:\u00aet still \nholds while \u00aet<: . Object does not hold anymore. Furthermore, we allow .<:t and t<:Object if and only \nif t is not a primitive type. To support these changes, we modify the main variant subtyping rules from \nFigure 3 to the following: a=\u00ae a=\u00ae f at<: .Object.ref(t) f at<: 8..ref(t) a1= \u00ae \u00ac(a1<:.) a1= \u00ae \u00ac(a1<:8) \nf Object<:t2.. f t2<:... f a1t1<:.t2...ref(t1) f a1t1<:8t2...ref(t1) f.<:t.ref(t) ft<:Object.ref(t) ft<:..t<:..ref(t) \nfObject<:t.Object<:t.ref(t) Programmers often make use of the instanceof test on the runtime type of \nan object prior to some operations. Due to .ow and path insensitivity, the type system is currently unable \nto take advantage of such runtime testing of types. To help eliminate more cast operations, our compiler \ntranslates each program fragment of the form: if v.instanceof(t) then e1 else e2 to use a special program \nconstruct with fresh v0 variable: if v.instanceof(t) then let v0::t=v in [v.v0]e1 else e2 This construct \nis part of our core intermediate language, and it is generated prior to type checking. It is valid on \nthe proviso that any assignment into v is a subtype of the more speci.c t. A type rule corresponding \nto the new language construct is shown below: [LET-INSTANCEOF] e1 = (let v0 :: t = v in e) GD=G+{v0::8t} \nGD; Q f e::t, .1 G; Q f e2::t, .2 G; Q f if v.instanceof(t) then e1else e2 :: t, .1..2 Flow-sensitivity \nmay also cause some loss in type precision (such that some downcasts cannot be statically veri.ed) when \nthe same local variable is used for objects with different variant para\u00admetric types. To rectify this, \nwe could use Static Single Assignment (SSA) intermediate form [8] which is known to give better .ow\u00adsensitive \nanalysis results. Conversion of programs to SSA form can be handled in a preprocessing step, prior to \ntype checking. These techniques for incorporating path and .ow sensitivity are quite standard, and were \nalso explored in [41]. 10. Conclusion Software reuse has received much research interest for its boost \nto software development and maintenance productivities. Recently, generic type has become a main thrust \nin supporting software reuse. In reusing Java code, several works have proposed for refactoring legacy \nJava programs into those that use generic versions of popular container classes [10, 11, 14, 40]. Other \nworks try to achieve precise Java type inference results in the presence of parametric polymorphism and \ndata polymorphism in order to reduce the redundant cast operations [31, 1, 41]. The precision typically \ncomes at the price of a whole program analysis. Every time when an application code is analysed, the \nreachable library code must also be re-analysed. Variant parametric types attempt to increase language \nexpres\u00adsivity and code reuse by introducing another subtyping scheme, based on the notion of variance. \nThis idea originated from the struc\u00adtured virtual types proposed by Thorup and Torgersen [35]. Their \nwork is the .rst to link access rights and covariant subtyping to the .elds of each use of a class rather \nthan the class itself. Igarashi and Viroli extended this concept to support contra-and bi-variance [17]. \nThey also formalised the variant type system by mapping it into a corresponding existential type system \n[17, 18] for Feather\u00adweight Java. While Igarashi and Viroli s design faithfully models the existential \ntype system, it has been found to be too restrictive by the designers of Java 1.5. One improvement made \nin Java 1.5 is to allow each wildcard type to be opened without a corresponding close operation. This \nprovides more .exibility for writing generic code, but weakens the link to the traditional pack/unpack \nmech\u00adanism of the existential type system. Hence, even though a full\u00adscale language system has been implemented, \nthe soundness of the wildcard type system is still under development (as of [36]). Other than Java, a \nrecently developed language Scala [24] supports vari\u00adance for parametric polymorphism. In contrast with \nour approach, Scala uses variance at declaration-site. However, an earlier version of Scala has experimented \nwith the use-site variance mechanism that is consistent with the original system of Igarashi and Viroli \nbut without the .exibility of the wildcard capture. This was considered to be too restrictive before \nthe authors abandoned the approach. Recently, generic types of C# [12] were extended with declaration\u00adsite \nvariance following the design adopted for the language Scala. Theoretical foundations of the variance \nhave also been stud\u00adied in the context of typed .-calculi, where type operators are equipped with a polarity \nproperty [6, 33, 9]. These foundations have even been extended to handle higher-order functions, but \nare closer in nature to declaration-site variance, and have mostly been for\u00admalised in only a theoretical \nsetting, without practical implementa\u00adtions. In our paper, we have proposed a new approach based on .ow \nanalysis to support the variant parametric type system. We lever\u00adage prior knowledge that has been accumulated \nfor .ow analy\u00adsis and entailment for non-structural subtyping constraints. Pals\u00adberg and O Keefe [25] \nshow the equivalence of .ow analysis and non-structural subtyping. Subtype entailment is known to be \nhard even for simple subtyping constraints. Rehof and Henglein determined the complexity of structural \nsubtype entailment: for simple types, it is coNP-complete [15] and for recursive types it is PSPACE-complete \n[16]. Furthermore, they showed that non\u00adstructural subtype entailment is PSPACE-hard and is conjectured \nPSPACE-complete [16]. Su et al. [34] show the decidability of the .rst-order theory of non-structural \nsubtyping with unary function symbols. Algorithms for non-structural subtype entailment (sound, but incomplete) \nwere developed in Pottier [32], Trifonov and Smith [38]. While the decidability of non-structural subtype \nentailment remains an open problem, we use sound techniques based on these previous algorithms. Our new \napproach is practically driven and can give better generic types. We have also augmented it with intersection \ntypes to support Java-like multiple (interface) inheritance. We have built a prototype system based on \na set of syntax-directed type rules. This prototype is supported by a constraint-solver for variant subtyp\u00ading, \ncustomised using CHR. Furthermore, our system supports full casting for variant types. Through a new \ncast capture mechanism, we can use re.ection to handle objects with unknown types in a type-safe way. \nExperimental evaluation indicates that more down\u00adcasts can be eliminated by our approach, even when it \nis compared against the state-of-the-art type system from Java 1.5. Our .ow\u00adbased approach to variant \nparametric type system is another step towards better genericity for type-safe OO programs. Acknowledgments \nWe are grateful to Atsushi Igarashi for clarifying many questions regarding the variant type system. \nWe also thank Alex Aiken, Greg Morrisett and Martin Rinard for providing useful feedback on this work. \nShengchao provided useful technical comments on the paper while Hong Yaw implemented the Java-to-CoreJava \ntranslator and hand-annotated a suite of Java libraries and application code. We also thank Alexia Leong \nfor her proof-reading efforts. This work is supported by research grant R-252-000-151-112 and a gift \nfrom Microsoft Singapore.   References [1] Ole Agesen. The cartesian product algorithm: Simple and \nprecise type inference of parametric polymorphism. In ECOOP 95: Proceedings of the 9th European Conference \non Object-Oriented Programming, pages 2 26, London, UK, 1995. Springer-Verlag. [2] IC-Parc at Imperial \nCollege. ECLiPSe Constraint Logic Program\u00adming. http://www.icparc.ic.ac.uk/eclipse/. [3] Gilad Bracha, \nMartin Odersky, David Stoutamire, and Philip Wadler. Making the future safe for the past: adding genericity \nto the Java programming language. In OOPSLA 98: Proceedings of the 13th ACM SIGPLAN conference on Object-oriented \nprogramming, systems, languages, and applications, pages 183 200, New York, NY, USA, 1998. ACM Press. \n[4] Martin Buchi and Wolfgang Weck. Compound types for Java. In OOPSLA 98: Proceedings of the 13th ACM \nSIGPLAN conference on Object-oriented programming, systems, languages, and applications, pages 362 373, \nNew York, NY, USA, 1998. ACM Press. [5] Peter S. Canning, William R. Cook, Walter L. Hill, Walter G. \nOlthoff, and John C. Mitchell. F-Bounded polymorphism for object-oriented programming. In Conference \non Functional Programming Languages and Computer Architecture, pages 273 280, 1989. [6] Luca Cardelli. \nNotes about F . . 1994. Available at <: http://research.microsoft.com/Users/luca/Notes/FwSub.ps. [7] \nLuca Cardelli and Peter Wegner. On understanding types, data abstraction, and polymorphism. ACM Comput. \nSurv., 17(4):471 522, 1985. [8] Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth \nZadeck. Ef.ciently computing static single assignment form and the control dependence graph. ACM Trans. \nProgram. Lang. Syst., 13(4):451 490, 1991. [9] Adriana Compagnoni Dominic Duggan. Subtyping for object \ntype constructors. In Foundations of Object-Oriented Languages (FOOL 1999), 1999. [10] Alan Donovan, \nAdam Kiezun, Matthew S. Tschantz, and Michael D. Ernst. Converting Java programs to use generic libraries. \nIn OOPSLA 04: Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, \nlanguages, and applications, pages 15 34, New York, NY, USA, 2004. ACM Press. [11] Dominic Duggan. Modular \ntype-based reverse engineering of parameterized types in Java code. In Proceedings of the 1999 ACM SIGPLAN \nConference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA 99), pages 97 113, \n1999. [12] Burak Emir, Andrew J. Kennedy, Claudio Russo, and Dachuan Yu. Variance and generalized constraints \nfor C# generics. In Proceedings of the 20th European Conference on Object-Oriented Programming (ECOOP), \nJuly 2006. [13] Thom Fruhwirth and et al. Constraint Handling Rules. http://www.cs.kuleuven.ac.be/~ dtai/projects/CHR/. \n[14] Robert Fuhrer, Frank Tip, Adam Kiezun, Julian Dolby, and Markus Keller. Ef.ciently refactoring Java \napplications to use generic libraries. In ECOOP 05: Proceedings of the 19th European Conference on Object-Oriented \nProgramming, July 2005. [15] Fritz Henglein and Jakob Rehof. The complexity of subtype entailment for \nsimple types. In Proceedings of 12th Symposium on Logic in Computer Science (LICS 97), pages 352 361, \nJune 1997. [16] Fritz Henglein and Jakob Rehof. Constraint automata and the com\u00adplexity of recursive \nsubtype entailment for simple type. In Au\u00adtomata, Languages and Programming, 25th International Collo\u00adquium, \nICALP 98, pages 616 627, 1998. [17] Atsushi Igarashi and Mirko Viroli. On variance-based subtyping for \nparametric types. In ECOOP 02: Proceedings of the 16th European Conference on Object-Oriented Programming, \npages 441 469, 2002. [18] Atsushi Igarashi and Mirko Viroli. Variant parametric types: A .exible subtyping \nscheme for generics. ACM Trans. Program. Lang. Syst., 2006. [19] Andrew Kennedy and Don Syme. Design \nand implementation of generics for the .NET common language runtime. In Proceedings of the 2001 ACM SIGPLAN \nConference on Programming Language Design and Implementation (PLDI), pages 1 12, 2001. [20] Karl Mazurak \nand Steve Zdancewic. Type inference for Java 5: Wildcards, F-Bounds, and Undecidability. 2006. A note \navailable at http://www.cis.upenn.edu/~ stevez/note.html. [21] John C. Mitchell and Gordon D. Plotkin. \nAbstract types have existential type. ACM Trans. Program. Lang. Syst., 10(3):470 502, 1988. [22] Bengt \nNordstrom, Kent Petersson, and Jan M. Smith. Programming in Martin-Lof s Type Theory. Oxford University \nPress, 1990. [23] Martin Odersky, Christoph Zenger, and Matthias Zenger. Colored local type inference. \nIn The 28th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 41 53, 2001. [24] \nMartin Odersky and Matthias Zenger. Scalable component abstrac\u00adtions. In Proceedings of the 20th Annual \nACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applica\u00adtions, OOPSLA \n2005, pages 41 57, 2005. [25] Jens Palsberg and Patrick O Keefe. A type system equivalent to .ow analysis. \nIn 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 367 378, 1995. [26] \nJens Palsberg and Christina Pavlopoulou. From polyvariant .ow information to intersection and union types. \nIn The 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 197 208, 1998. \n[27] Simon Peyton-Jones and et al. Glasgow Haskell Compiler. http://www.haskell.org/ghc. [28] Benjamin \nC. Pierce. Bounded quanti.cation is undecidable. Information and Computation, 112(1):131 165, July 1994. \n[29] Benjamin C. Pierce. Types and Programming Languages.The MIT Press, 2002. [30] Benjamin C. Pierce \nand David N. Turner. Local type inference. In Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on \nPrinciples of Programming Languages, pages 252 265, 1998. [31] John Plevyak and Andrew A. Chien. Precise \nconcrete type inference for object-oriented languages. In OOPSLA, pages 324 340, 1994. [32] Franc\u00b8ois \nPottier. Simplifying subtyping constraints. In Proceedings of the 1996 ACM SIGPLAN International Conference \non Functional Programming (ICFP 96), pages 122 133, 1996. [33] Martin Steffen. Polarized Higher-Order \nSubtyping. PhD thesis, Universitat Erlangen-Nurnberg, 1997. [34] Zhendong Su, Alexander Aiken, Joachim \nNiehren, Tim Priesnitz, and Ralf Treinen. The .rst-order theory of subtyping constraints. In The 29th \nSIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 203 216, 2002. [35] Kresten Krab \nThorup and Mads Torgersen. Unifying genericity \u00adcombining the bene.ts of virtual types and parameterized \nclasses. In ECOOP 99 -Object-Oriented Programming, 13th European Conference, pages 186 204, 1999. [36] \nMads Torgersen, Erik Ernst, and Christian Plesner Hansen. Wild FJ. In Foundations of Object-Oriented \nLanguages (FOOL 2005), Long Beach, CA, January 2005. [37] Mads Torgersen, Erik Ernst, Christian Plesner \nHansen, Peter von der Ah\u00b4e, Gilad Bracha, and Neal M. Gafter. Adding Wildcards to the Java programming \nlanguage. Journal of Object Technology, 3(11):97 116, 2004. [38] Valery Trifonov and Scott F. Smith. \nSubtyping constrained types. In Static Analysis, Third International Symposium, SAS 96,pages 349 365, \n1996. [39] Mirko Viroli and Antonio Natali. Parametric polymorphism in java: an approach to translation \nbased on re.ective features. In Proceedings of the 2000 ACM SIGPLAN Conference on Object-Oriented Programming \nSystems, Languages and Applications (OOPSLA 2000), pages 146 165, 2000. [40] Daniel von Dincklage and \nAmer Diwan. Converting Java classes to use generics. In Proceedings of the 19th Annual ACM SIGPLAN Conference \non Object-Oriented Programming, Systems, Languages, and Applications, pages 1 14, 2004. [41] Tiejun Wang \nand Scott F. Smith. Precise constraint-based type inference for java. In ECOOP 01: Proceedings of the \n15th European Conference on Object-Oriented Programming, pages 99 117, 2001. A. Dynamic Semantics The \ndynamic operational semantics of Variant CoreJava is de\u00adscribed in small steps. Notations used are de.ned \nas follows. Locations : . . Location Primitives : k . prim = int bool float null void Values : d, . \n. Value =(TyPrim \u00d7 prim) Location Subs : \u00b5, . . Subs =TVar ..n Type Store : r . Store =Location ..n ObjVal \nVariable Env :. . VEnv =Var ..n Value Object values : . . ObjVal =Type \u00d7 (Fd..n Value) Type : t . Type \nTyPrim consists of primitive types. A type t maintained at run\u00adtime does not contain any variant information. \nIf need be, it will be treated as one with invariant annotation 8. A runtime environment .is a .nite \nmap from program variables to their associated values. A value can be a location referencing an object \nor a pair containing a primitive value and a primitive type. A runtime store r is a .nite map from locations \nto object values. An object value is comprised of its type and its .eld values. We write ..f to denote \nthe value of the .eld f of an object .. When the object is referred by its location ., we also write \n..f to refer to the value of its .eld f. We overload the function type to accept (1) primitive value \nand return the primitive type; (2) location and return the type of the dereferenced object; (3) object \nand return the object type; and (4) object .eld and return the .eld type. The variable environment . \nis such a stackable mapping. We write .[./v] to denote an update of the value of the latest variable \nv in . to .. We write .+ {v . .}to denote an extension of . to include a binding of . to v, while . -{v \n*}removes a subset of the mappings. Similar notations are used for the update and en\u00adhancement of object \nvalues and stores. In the case of store, we also provide an abbreviated notation r[./..f]=df let (t, \n.)= r(.) in r[(t,.[./f])/.]. Given an object value, . =(t, .),we have Flds(.) = df .. We require some \nintermediate expressions for the dynamic se\u00admantics to follow through. Our syntax is thus extended from \nthe original expression syntax as follows: * e ::= \u00b7\u00b7\u00b7|. |. |. |retd (v ,e) |retm (Q,v * ,t,e) The expression \nretd (v * ,e) is used to capture the result of eval\u00aduating a local block, and retm (Q,v *,t,e) captures \nthe result of method invocation. The set of variables v * occurring in both result structures contain \nthe local names and method parameters when en\u00adtering local body and method body respectively. They are \ndropped at the end of the local/method body s evaluation. t captures the type of the result of method \ninvocation, whereas Q captures the set of type variables declared in the method header. Q is an instrument \nused to facilitate our soundness proof. The dynamic evaluation rules are of the following form. .D (.,r)[e] \n'.(,r D)[e D] We shall formulate the rules using an exception-style semantics with three possible errors, \nnamely E = Error-Null |Error-Cast |Error-Type. Whenever one such error is raised, the evaluation aborts. \nThis error occurrence can be stated using (.,r)[e] '.E. The small-step dynamic call-by-name semantics \nis formalised in Fig 11, together with some auxiliary functions in Fig 12.  B. Soundness of Type System \nBefore formulating the soundness, we extend the static semantics of the language to include those intermediate \nexpressions given in Sec A. In the process, we require introduction of a store typing to describe the \ntype of each location. This ensures that objects created in the store during run-time are type-wise consistent \nwith that captured by the static semantics. Store typing is conventionally used to link static and dynamic \nsemantics. In our case, it is denoted by: S .StoreType = Location ..n Type Judgements in the static semantics \nwill be extended with store typing, as follows: G; S; Q fe :: t, . [ELFm] v * .dom(G) QD .Q G; S; Q fe \n:: t, . ft<:t1..1 G; S; Q fretm (QD,v *,t,e):: t1,. ..1 [ELFd][LOC] G; S; Q fe :: t,. t =S(.) ft<:t1.. \n* G; S; Q fretd (v ,e):: t, . G; S; Q f. :: t1,. [OBJ][VALUE] (t, .)= . f8t<:t.. f8t<:t.. G; S; Q f. \n:: t, . G; S; Q f(t, d):: t, . Figure 13. Type Rules for Intermediates The static semantics for these \nintermediate expressions is shown in Figure 13. The soundness of our static semantics relies on the following \nconsistency relationship between the static and dynamic semantics, de.ned as follows: dom(.) = dom(G) \ndom(r)= dom(S) VL = vars(.) -Q .v .dom(.) \u00b7..1 .Subs \u00b7..L .Subs\u00b7 (dom(.L )= VL .. = .1 ..L . (.(.) . \n(.(v) .prim .type(.(v))<:.(G(v))). (.(v) .Location . type(r(.(v)))<:.(G(v)))))) G; S; Q; . |=.,r In the \nabove relation, .L is a ground substitution of local type variables occurring in the constraint ., and \nthe composition of substitutions is recursively de.ned as: (.1 ..2)(v) = if (v .dom) then .2(v) else \n.1(v). The following theorem states the progress of well-typed expres\u00adsions. THEOREM 1(PROGRESS) Let \nG be an environment mapping pro\u00adgram variables to ground types. If G; S; Q fe :: t,. and G; S; Q; . |=.,r, \nthen either e is a value, or (.,r)[e] '.Error-Null |Error-Cast,or there exist .D,rD,eD such that (.,r)[e] \n'.(.D,rD)[eD]. A proof of Theorem 1 can be found in Appendix C.1. The next theorem states that each well-typed \nexpression pre\u00adserves its type under reduction with a runtime environment and a store which are consistent \nwith the compile-time counterparts. THEOREM 2(PRESERVATION) Let G be an environment mapping program variables \nto ground types. If G; S; Q fe :: t,. G; S; Q; . |=.,r (.,r)[e] '.(. ,r )[ e]  then there exists G , \nS and Q such that G -diff(e,e )= G -diff( e,e) S .S G; Q f . S; e :: t, S; Q ; = r. G; . .. |., [D-Const][D-Var-FD][D-If-true] \nkhas type tw = v|v.f . = read(.,w,w) .(v)=(Bool,true) (.,w)[k] .,w)[(t,k)] (.,w)[w] .,w)[.] (.,w)[if \nvthen e2] .,w)[e1] .(.(1 else e.( [D-Assign-1][D-Assign-2][D-If-false] ' (.,w)[e.(.',w')[e] (.',w')= \nupd(.,w,w,.) .(v)=(Bool,false) ] (.,w)[w ] .',w')[w = e'] (.,w)[w .(.',w')[(void,())] (.,w)1 else e.(.,w)2] \n= e.(= .] [if vthen e2] [e [D-Blk-1][D-Blk-2] ' (.,w)[e.(.'1] subType(type(.),t).' =.+ {v 1] ,w')[e. \n.} .'.' ' (.,w)[{tv = e1 ; e2}] .(,w')[{tv = e1; e2}] (.,w)[{tv = .; e2}] .(,w)[retd (v,e2)] [D-While-true][D-While-false] \n.(v)=(Bool,true) .(v)=(Bool,false) (.,w)[while vdo e.(.,w)[e; while vdo e(.,w)[while vdo e.(.,w)[(void,())] \n] ]] [D-Ret-d-1][D-Ret-d-2] '* (.,w)[e.(.'].' =. -(v ) ] ,w')[e * *' (.,w)[retd (v .(.',w')[retd (v \n,e)] (.,w)[retd (v *,.)] .',w)[.] ,e)] .( [D-Ret-m-1][D-Ret-m-2][D-Seq-1] '*' (.,w)[e.(.',w')[e] subType(type(.),t).' \n=. -(v ) (.,w)[e.(.',w')[e1] ] 1] **'' (.,w)[retm (Q,v ,t,e)] .',w')[retm (Q,v ,t,e)] (.,w)[retm (Q,v.(.',w)[.] \n(.,w)[e.(.',w')1; e2] .(*,t,.)] 1; e2] [e [D-Cast][D-Capture][D-Seq-2] (.,w)[v] .,w)[.] (.,w)[v] .,w)[.] \nt0 = type(.) .(.( chkCast(type(.),t) . = match(t,t0)(.',w')= upd(.,w,v1,.) .(}] 2] 2] (.,w)[(t) v] .,w)[.] \n(.,w)[{v1 =(t) v; e.(.',w')[.(e)] (.,w)[d; e.(.,w)[e [D-New][D-Call] class c(Xi)q \u00b7\u00b7\u00b7where .{\u00b7\u00b7\u00b7}.P. \n= fresh() .i =.(v') .i .{0..q} c(t' )m = type(.0) i=1 iii=1 \u00b5 =[ti/Xi]iq =1 .i = read(.,w,vi) .i .{1..p} \nt0 |tmn((ti vi)i=1..q)(V *)where .eb .mtds(c) '* .' chk(\u00b5(.)) t= type(.i) .i .{1..p} \u00b5 =[t /V * ] chk(\u00b5(.)) \n=.+[.0/this][.i/vi]q ii=1 ' qq subType(c(ti)i=1,c(ti)i=1) subType(type(.i),\u00b5(ti)) .i .{0..q} qp q . \n=(c(ti)i=1,{ i=1) w' = w+ {.. .} V' = {this}.{i=1 e = retm (V * ,V',\u00b5(t),\u00b5(eb)) fi..i}vi}q ''' i=1(v1..p)] \n0.*)] (.,w)[new c(ti).(.,w')[.] (.,w)[vmn(v1,..,v)(t .(.',w)[e] q Figure 11. Dynamic Semantics read(.,w,v)=.(v); \nupd(.,w,v,.s)= subType(t1,t2)= read(.,w,v.f)= . =.(v); if \u00ac(ft1<:t2) throw Error-Type; .=.(v); if \u00ac(ftype(.s) \n<: type(.)) true; if w(.)= nullthrow Error-Null; throw Error-Type; w(.).f; (.[.s/v],w); match(tv,t)=[t/tv]; \nchk(f)= upd(.,w,v.f,.s)= .=.(v); match(c(t * v),c(t *))= [t * /t * v]; match(t',t)= throw Error-Type; \nif \u00ac(ff) throw Error-Type; if w(.)= null throw Error-Null; true; .f = w(.).f; if \u00ac(ftype(.s) <: type(.f \n)) throw Error-Type; chkCast(t1,t2)= (.,w[.s/w(.).f]); if \u00ac(ft1<:t2) throw Error-Cast; true; Figure 12. \nDynamic Semantics:Auxiliary De.nitions  Function diff(e, eD) returns a list of local variables that \nappears in e but not eD : diff(e, eD)= df let lst = local(e) lst1 = local(eD) n = length(lst)- length(lst1) \nin (take(n, lst)< n = 0[ []) take(n, lst)= df ([]< n = 0[ [head(lst)]++take(n - 1, tail(lst))) x < b \n[ y = df if b then x else y Function local(e) returns a list of sets of local variables. It is de.ned \nas follows: local(e)=df case e of retm (Q, v*,t,e) . local(e)++ [{v *}] * retd (v ,e) . local(e)++ [{v \n*}] w = e . local(e) (tv = e1;e2) . local(e1) otherwise .\u00d8 Note that G- []= df G, G- ([s]++S)=df (G \n- s)- S. The proof is simple: by induction over the depth of type derivation of expres\u00adsion e. A proof \nof Theorem 2 can be found in Appendix C.2.  C. Proofs of Theorems C.1 Proof of Theorem 1 (Progress) \nBy induction over the depth of type derivation for expression e. Cases [NULL, VOID, VALUE, LOC, OBJ].Trivial. \nCase [VAR-FIELD]. We deal with expression w.As w = v |v.f is well-typed, the evaluation rule [D-Var-FD] \nis followed, the evaluation either reports an Error-Null or advances one step yielding a value. Case \n[ASSIGN]. We deal with expression w = e. From type rule, we have G; S; Q f e :: .t,.. By induction hypothesis, \neither (i) e is a value ., or (ii) (.,w)[e] '. Error, or (iii) (.,w)[e] '.(.D,wD)[e D]. Subcase (i): \nLet the runtime type of . be t , and that of w be t1. Then, we have 8 t<: . t and 8t1<: e t, which implies \n t<: t<: t1. Hence, the upd function at [D-Assign-2] will not throw Error-Type exception, and proceed \nto update the runtime environment . or the runtime store, as described in [D-Assign-2]. Subcase (ii): \nThis will result in the execution of (.,w)[w = e] aborted with Error. Subcase (iii): This will result \nin the execution of the assignment to reach (.,w)[w = e D],via [D-Assign-1].  Case [SEQ].We have G; \nS; Q fe1 :: \u00ae t,.. By induction hypoth\u00adesis, either (i) e1 is a value ., or (ii) (.,w)[e1] '.Error,or \n (iii) (.,w)[e1] '.(.D,wD)[e1D ]. Subcase (i): The execution proceeds to reach (.,w)[e2] un\u00adconditionally, \naccording to [D-Seq-2]. Subcase (ii): The execution will be aborted with Error excep\u00ad tion. Subcase (iii): \nThe execution proceeds to reach (.D,wD)[e1D ; e2], according to [D-Seq-1].  Case [LOCAL]. Given that \nG; S; Q f{tv = e1 ; e2}:: t, .1 ..2. We have G; S; Q fe1 :: .t,.1. By induction hypothesis, either (i) \ne1 is a value ., or (ii) (.,w)[e1] '.Error, or (iii) .DD (.,w)[e1] '.(,wD)[e1]. Subcase (i): Let the \nruntime type of . be t 0 and the runtime type of v be t . As the consistency relation holds between the \nstatic and the dynamic semantics, we have for all ground sub\u00adstitution ., f.(.1) .t = .(t).Since f.(.1) \n.8t 0<:.t, subType(type(.),t ) = subType(t 0,t ) = true. Hence, the execu\u00adtion will proceed to the state \n(.D,w)[retd (v, e2)] according to [D-Blk-2]. Subcase (ii). The execution will throw the corresponding \nError exception. Subcase (iii). The execution will proceed to (.D,wD)[{tv = e1D ; e2}] according to [D-Blk-1]. \n Case [NEW].Given G; S; Q fnew c(ti )iq =1(v1, .., vp ):: t, .,let t i (for all i =1..q)and t v i (for \nall i =1..p) be the runtime types of type arguments and value arguments to new.Thenwe have, for all ground \nsubstitution ., f.(.) ..qi =1(t i =.(ti )) and f.(.) ..p ( <:.(G(vi ))).Furthermore, f.(.) . i =1tv i \n.(G(vi ))<:ti D ,for all i. Hence, both calls to chk and subType at runtime do not fail, and the execution \nproceeds to the state (.,wD)[.],where . is the location referencing the new object. Case [COND].Given \nG; S; Q fif v then e1 else e2 :: t, . and G(v)<: . Bool, the runtime value of v will either be true, \nfalse, or null (). In the .rst two subcases, the execution pro\u00adceeds to next state according to the rules \n[D-If-true] and [D-If-false] respectively. In the last subcase, there is no corresponding dy\u00adnamic rule, \nand exception Error-Null will be thrown. Case [WHILE].Given G; S; Q f while v do e :: t, . and G(v)<: \n. Bool, the runtime value of v will either be true, false, or null (). In the .rst two subcases, the \nexecution pro\u00adceeds to next state according to the rules [D-While-true] and [D-While-false] respectively. \nIn the last subcase, there is no cor\u00adresponding dynamic rule, and exception Error-Null will be thrown. \nCase [ELFd, ELFm].We have G; S; Q fe :: t, . as the premise of the static semantics. By induction hypothesis, \neither (i) e is a value ., or (ii) (.,w)[e] produces Error, or (iii) (.,w)[e] '. (.D,wD)[e D]. Subcase \n(i): Let the runtime type of . be t . and that of return value be t then for all ground substitution \n. we have f.(.) . .(t)= 8t . Also, we have f .(.) . t . <:.(t). Hence, the call to subType in the rule \n[D-Ret-2] returns true,and the execution proceeds to (.D,w)[.] accordingly. Subcase (ii): The execution \nwill throw the corresponding Error exception, as no rule applies. Subcase (iii): The execution step to \nthe new state following rule [D-Ret-1].  Case [CAST]. Any type mismatch during cast will be captured \nby chkCast and Error-Cast exception will be thrown. Otherwise, casting will succeeds and the execution \nproceeds to the next state (.,w)[(t,.)]. Case [CAPTURE].We have G; S; Q f{v1 =(t)v; e}:: t, .1 ..2. n \nFrom its premise, we have t = c(8Vi )i =1. Executing the expression v either yields an Error exception \nor returns a value .. We consider the case where . is returned. Let t0 be the type of . as declared in \nthe runtime environment. The use of .ow symbol 8in t implies that match(t,t0) succeeds and produces . \nonly when .(t)= t0. Hence, by rule [D-Capture], the execution proceeds to the state (.D,wD)[.e]. Updating \nof v1 does not fail, similar with [ASSIGN]. D DD Case [CALL].Given G; S; Q f v0.mn(v1, .., v q )(t *) \n: t, ..Let the runtime type arguments be (t *)and the value arguments have type t v ' for i =0..q. Also, \nthe ground substitution \u00b5 i in [D-Call] is an instance of . in [CALL],which makes . true. Thus, we have, \nf \u00b5(.) . t v ' <:\u00b5(ti D), i =0..q,and f i t 0<:\u00b5(t0). Hence, the call to subType in [D-Call] yields true, \nand the execution proceeds to the state (.,w)[e] according to [D-Call]. D  C.2 Proof of Theorem 2 (Preservation) \nThe proof for Theorem 2 requires several lemmas. LEMMA 3 (Type Substitution). If G; S; Q fe :: t, ., \nthen for all substitution . such that f.(.), we have .(G); .(S); Q f.(e):: .(t),.(.). The proof is by \ninduction on a derivation of G; S; Q fe :: t, .. The next lemma, called assumption weakening lemma, states \nthat the static judgment remains valid despite a variation of its assumption. This assumes the store \ntype S to have unbounded mapping of locations to types. However, the type environment G takes the form \nof stackable mapping between variables and types, and is allowed to grow (by pushing in new mappings) \nand shrink (by popping out mappings from stack). The lemma states that such change to type environment \npreserves the type judgment, if the change are properly constrained. LEMMA 4 (Assumption Weakening). \nGiven that the following judgment holds: G; S; Q fe :: t, . Let G , S and Q be such that: vars(e) .dom(G) \nndom( G) Q .Q .Q .Q vars(.) -Q = vars(.) -Q * .v \u00b7(G -{v *}= G) .(G -{v *}=G) S .S Then, there exists \n. such that f. .. and  G; S; Q fe :: t, . The call vars(e) returns all program variables occurring in \ne, whereas vars(.) returns all (type) variables occurring in .. Proof of Lemma 4: By structural induction \non the static semantics of the form G; S; Q fe :: t, ..For any G , S and Q , we say that they satisfy \nthe premises of the Lemma if the following holds: vars(e) .dom(G) ndom( G) Q .Q .Q .Q vars(.) -Q = vars(.) \n-Q * } .v * \u00b7(G -{v = G) .(G -{v * }=G) S .S Cases [NULL, VOID, LOC, OBJ, VALUE].Trivial. Case [VAR-FIELD]. \nWe deal with expression w,where w = v |v.f. For any G , S and Q satisfying the premise of the lemma, \nwe see that G(v)= G; Q fw : t, .. G(v). Hence, S; Case [ASSIGN]. We deal with expression w = e.We have \nS; G; Q f e :: .t,. for at=GetType(G ,w)=GetType(G,w). The desired result is then derived by induction \nhypothesis. Cases [LOCAL, SEQ, COND, WHILE, CAST, CAPTURE, ELFd, ELFm]. By induction hypothesis. Case \n[NEW]. The result holds because G(vi)= = G(vi),for all i 1..p. Case [VAR-FD]. This can be proven by \nsetting G , S and Q to G, S and Q respectively. Case [ASSIGN]. There are two rules by which one-step \nderivation can be applied: Subcase [D-Assign-1]: By induction hypothesis, there exists GD , SD DD and \nQD such that GD;SD; QD f e :: . t,.D and which satis.es the premise of the theorem. Since .tD<: . t, \nwe thus DD<:.t ..DD have GD;SD; QD fe :: .t,.D..DD,where f.t. The desired result can then be proven by \nsetting G , S and Q to GD , SD and QD respectively. Subcase [D-Assign-2]: Consider the assignment to \na variable v. Given that upd(.,w,w,.) returns successfully (.D ,w D),it must be the case that type(.) \n<:type(.D(v)). The desired result can then be proven by setting G , S and Q to G, S and Q respectively. \nSimilar argument applies to the assignment to a .eld. Case [SEQ]. There are two rules by which one-step \nderivation can be applied: Subcase [D-Seq-1]: By induction hypothesis, there exists GD , SD and QD that \nestablishes the consistency relation at the hypoth\u00adesis. We elect G , S and Q to be GD , SD and QD respectively \nto obtain the desired result. Subcase [D-Seq-2]: By setting G , S and Q to be G, S and Q respectively. \n Case [COND]. There are two rules by which one-step derivation can be applied: [D-If-True], [D-If-False]. \nBoth can be proven by setting G , S and Q to G, S and Q respectively. Case [WHILE]. Similar as the argument \nfor case [COND]. Case [LOCAL]. There are two rules to consider: Subcase [D-Blk-1]: By induction hypothesis. \nSubcase [D-Blk-2]:Since subType(type(.),t), GD and S used in [LOCAL] remain consistent with .D and w \nin this subcase. We set G , S and Q to GD , S and Q respectively. Case [CAST]. This can be proven by \nsetting G , S and Q to G, S and Q respectively. Case [CAPTURE]. The argument for one-step derivation \n[D-Capture] is similar to that for case [D-Assign-2], except for the assignment of runtime type information \nof . to the type variables occurring in t. This assignment proceeds successfully because of the premise \nof [CAPTURE].We set G , S and Q to G, S and Q respectively. It suf.ces to show that S; f .(e):: G; Q \nt, . . This is true by applying Type Substitution Lemma to the following premise of [CAPTURE]: G; S; \nQ fe :: t,.2. Case [NEW].We set G= G , S= S+ {. .8c(8ti)q }and i=1 Q = Q. Case [CALL]. The fact that \nt , as obtained from [ELFm], is a subtype of t obtained from [CALL], is established from the result of \n[ELFm] and the constraint .(. t) <:t occurred in . in the premise of [CALL]. Finally, by assumption weakening \nrule, we . q . set G=G+ {vi :: ti}+ {this :: t0, S=S, i=1 Q = Q .{V * }. Case [ELFd, ELFm]. There are \ntwo subcases for consideration: Cases [CALL]. The result holds because G(viD)= iD) for all i Subcase \n[D-Ret-d-1, D-Ret-m-1]: By induction hypothesis. G(v = 1..q. D Subcase [D-Ret-d-2, D-Ret-m-2]: By induction \nhypothesis and the Proof of Theorem 2 This can be proven by induction over the Assumption Weakening Lemma. \nD depth of type derivation of expression e. Cases [NULL, VOID, LOC, OBJ, VALUE]. Vacuously true.  \n\t\t\t", "proc_id": "1167473", "abstract": "A promising approach for type-safe generic codes in the object-oriented paradigm is <i>variant parametric type</i>, which allows covariant and contravariant subtyping on fields where appropriate. Previous approaches formalise variant type as a special case of the existential type system. In this paper, we present a new framework based on <i>flow analysis</i> and <i>modular type checking</i> to provide a simple but accurate model for capturing generic types. Our scheme stands to benefit from past (and future) advances in flow analysis and subtyping constraints. Furthermore, it fully supports casting for variant types with a special reflection mechanism, called cast capture, to handle objects with unknown types. We have built a constraint-based type checker and have proven its soundness. We have also successfully annotated a suite of Java libraries and client code with our flow-based variant type system.", "authors": [{"name": "Wei-Ngan Chin", "author_profile_id": "81100655104", "affiliation": "National University of Singapore", "person_id": "PP39052727", "email_address": "", "orcid_id": ""}, {"name": "Florin Craciun", "author_profile_id": "81100147492", "affiliation": "National University of Singapore", "person_id": "P456686", "email_address": "", "orcid_id": ""}, {"name": "Siau-Cheng Khoo", "author_profile_id": "81100241361", "affiliation": "National University of Singapore", "person_id": "PP39034080", "email_address": "", "orcid_id": ""}, {"name": "Corneliu Popeea", "author_profile_id": "81100461244", "affiliation": "National University of Singapore", "person_id": "P327930", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167498", "year": "2006", "article_id": "1167498", "conference": "OOPSLA", "title": "A flow-based approach for variant parametric types", "url": "http://dl.acm.org/citation.cfm?id=1167498"}