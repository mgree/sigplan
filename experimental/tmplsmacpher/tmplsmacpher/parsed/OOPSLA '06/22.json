{"article_publication_date": "10-16-2006", "fulltext": "\n Ef.cient Software Model Checking of Data Structure Properties Paul T. Darga Chandrasekhar Boyapati \nElectrical Engineering and Computer Science Department University of Michigan, Ann Arbor, MI 48109 {pdarga,bchandra}@eecs.umich.edu \nAbstract This paper presents novel language and analysis techniques that signi.cantly speed up software \nmodel checking of data structure properties. Consider checking a red-black tree im\u00adplementation. Traditional \nsoftware model checkers system\u00adatically generate all red-black tree states (within some given bounds) \nand check every red-black tree operation (such as insert, delete, or lookup) on every red-black tree \nstate. Our key idea is as follows. As our checker checks a red-black tree operation o on a red-black \ntree state s, it uses program analysis techniques to identify other red-black tree states s1, s2, ..., \nsk on which the operation o behaves similarly. Our analyses guarantee that if o executes correctly on \ns,then o will execute correctly on every si. Our checker therefore does not need to check o on any si \nonce it checks o on s. It thus safely prunes those state transitions from its search space, while still \nachieving complete test coverage within the bounded domain. Our preliminary results show orders of magnitude \nimprovement over previous approaches. We be\u00adlieve our techniques can make model checking signi.cantly \nfaster, and thus enable checking of much larger programs and complex program properties than currently \npossible. Categories and Subject Descriptors D.2.4 [Software Engineering]: Program Veri.cation D.2.5 \n[Software Engineering]: Testing and Debugging F.3.1 [Logics]: Specifying and Verifying Programs General \nTerms Veri.cation, Reliability, Languages Keywords Software Model Checking, Program Analysis  1. Introduction \nThis paper presents novel language and analysis techniques that signi.cantly speed up software model \nchecking [1, 2, 4, 6, 7, 12, 15, 48, 21, 39] of data structure properties. Model checking is a formal \nveri.cation technique that exhaustively Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation tests a circuit/program \non all possible inputs (sometimes up to a given size) to handle input nondeterminism and on all possible \nnondeterministic schedules to handle scheduling nondeterminism. For hardware, model checkers have been \nsuccessfully used to verify fairly complex .nite state control circuits with up to a few hundred bits \nof state information; but not circuits in general that have large data paths or memories. Similarly, \nfor software, model checkers have been primarily used to verify event sequences with respect to tem\u00adporal \nproperties; but not much work has been done to verify programs that manipulate rich complex data with \nrespect to properties that depend on the data. This paper deals with such data oriented programs. In \nparticular, it focuses on verifying properties of data structures. Consider checking that a red-black \ntree [8] implementation maintains the red-black tree invariants. Previous model checking approaches such \nas JPF [48, 28], CMC [39, 38], Korat [2], or Alloy [26, 27] systematically generate all red\u00adblack trees \n(up to a given size n) and check every red-black tree operation (such as insert or delete) on every red-black \ntree. Since the number of red-black trees with at most n nodes is exponential in n, these systems take \ntime exponen\u00adtial in n for checking a red-black tree implementation. Our key idea is as follows. Our \nchecker detects that any red-black tree operation such as insert or delete touches only one path in the \ntree from the root to a leaf (and perhaps some nearby nodes). Our checker then determines that it is \nsu.cient to check every operation on every unique tree path (and some nearby nodes), rather than on every \nunique tree. Since the number of unique red-black tree paths is polynomial in n, our checker takes time \npolynomial in n. This leads to orders of magnitude speedups over previous approaches. In general, our \nsystem works as follows. Consider checking a .le system implementation, as another example. As our checker \nchecks a .le system operation o (such as reading, writing, creating, or deleting a .le or a directory) \non a .le system state s, it uses program analyses to identify other .le system states s1, s2, ..., son \nwhich the operation o k behaves similarly. Our analyses guarantee that if o executes correctly on s,then \no will also execute correctly on every si. Our checker therefore does not need to check o on any sonce \nit checks o on s. It thus safely prunes all those state transitions from its search space, while still \nachieving complete test coverage within the bounded domain. i on the .rst page. To copy otherwise, to \nrepublish, to post on servers or to redistribute We call this the glass box approach to model checking \nof data to lists, requires prior speci.c permission and/or a fee. oriented programs because our checker \nanalyzes the behavior OOPSLA 06 October 22 26, 2006, Portland, Oregon, USA. Copyright &#38;#169; 2006 \nACM 1-59593-348-4/06/0010 ...$5.00 c Figure 1. Three red-black trees before and after an insert operation. \nThe tree path touched by the operation is highlighted in each case. Once our glass box checker checks \nthe insert operation on tree t1, it determines that it is redundant to check the same operation on t2 \nand t3. of an operation to prune large portions of the search space. While there is much research on \nstate space reduction tech\u00adniques for model checkers such as partial order reduction [13, 15, 16] and \ntools based on predicate abstraction [19] such as Slam [1], Blast [21], or Magic [4], none of these techniques \nseem to be e.ective in reducing the state space of data ori\u00adented programs. For example, predicate abstraction \nrelies on alias analysis that is often too imprecise. Thus, our ap\u00adproach is in contrast to the traditional \nblack box approach to model checking of data oriented programs that checks every operation on every state, \ntreating the operation as a black box. Depending on the strength of the analyses, a glass box checker \ncan be signi.cantly more e.cient than a black box checker in exploring the same search space. In\u00addeed, \nour preliminary results show orders of magnitude im\u00adprovement over previous approaches. We therefore \nbelieve that our techniques can make model checking signi.cantly faster, and thus enable checking of \nmuch larger programs and broader class of program properties than currently possible. The rest of this \npaper is organized as follows. Section 2 illus\u00adtrates our approach with examples. Section 3 describes \nour glass box model checker. Section 4 presents experimental re\u00adsults. Section 5 discusses related work. \nSection 6 concludes. 2. Examples This section illustrates our key idea with examples. 2.1 Red-Black \nTree Example Consider the red-black tree example from Section 1. That is, consider checking that a red-black \ntree implementation maintains the red-black tree invariants. As we discussed in Section 1, a black box \nchecker (such as JPF [48, 28], CMC [39, 38], Korat [2], or Alloy [26, 27]) systematically generates all \nred-black trees (up to a given size n)and checks every red-black tree operation (such as insert or delete)on \nevery red-black tree. Since the number of red-black trees with at most n nodes is exponential in n,a \nblack box checker takes time exponential in n for the checking. Our glass box checker works as follows. \nConsider checking the insert operation on tree t1 in Figure 1. The tree t1 1 class Queue { 2 private \nStack front = new Stack(); 3 private Stack back = new Stack(); 4 5 public boolean repOk() { 6 return \n(back != null) &#38;&#38; back.repOk() &#38;&#38; (back != front) 7 &#38;&#38; (front != null) &#38;&#38; \nfront.repOk(); 8} 9 10 // -----------------------\u00ad11 // dequeue <---front | | back <---enqueue 12 // \n-----------------------\u00ad13 14 public void enqueue(Object o) { 15 back.push(o); 16 } 17 public Object \ndequeue() throws EmptyQueueException { 18 if (front.isEmpty()) moveBackToFront(); 19 if (front.isEmpty()) \nthrow new EmptyQueueException(); 20 return front.pop(); 21 } 22 private void moveBackToFront() { 23 while \n(!back.isEmpty()) front.push(back.pop()); 24 } 25 } Figure 2. Queue implemented using two Stacks. depicts \nthe state of the tree after the operation. (For sim\u00adplicity, the .gure only shows the tree structures \nand does not show the color of the nodes, or the keys or values stored in the nodes.) As our checker \nchecks the insert operation on t1, it detects that the operation touches only one path in the tree from \nthe root to a leaf. This path is highlighted in the .gure. That means, assuming deterministic execu\u00adtion, \nthe insert operation will behave similarly on all trees, such as t2 or t3, where the highlighted path \nremains the same. Our checker determines that it is redundant to check the same insert operation on trees \nsuch as t2 or t3 once it checks the insert operation on tree t1. Our checker safely prunes those state \ntransitions from its search space, while still achieving complete test coverage within the bounded domain. \nOur checker thus ends up checking every red-black tree operation on every unique tree path (and some \nnearby nodes), rather than on every unique tree. Since the num\u00adber of unique red-black tree paths (in \ntrees with at most n nodes) is polynomial in n, our checker takes time polynomial in n to check a red-black \ntree implementation. This leads to orders of magnitude speedups over the black box approach. 2.2 Queue \nExample This section illustrates our approach with a more detailed ex\u00adample. Figure 2 presents a Queue \nthat is implemented using two Stack objects front and back.The enqueue method in\u00adsertsanitematthe back \nof a Queue by pushing it onto back. The dequeue method removes and returns the item at the front of a \nQueue by popping and returning the top item of front.If front is empty, dequeue .rst moves all the items \nfrom back to front.If front is still empty, dequeue throws an EmptyQueueException. (One possible implementation \nof Stack is shown in Figure 7.) Queue s class invariant is described by its repOk method, as good programming \npractice suggests [32]. The class invari\u00adant of an object must hold before and after every public method \nof the object. That is, the class invariant is both a precondition and a postcondition of every public \nmethod. 1 class ReachabilityDemo { 2 private boolean x, y, z; 3 public boolean repOk() { return !z || \nx &#38;&#38; y; } 4 5 public void setX() { x = true; } 6 public void setY() { y = true; } 7 public void \nsetZ() { if (x &#38;&#38; y) z = true; } 8} Figure 5. A class with three boolean variables x, y, z. \n Figure 3. State space of Queue with at most n =4 items. State (f,b)has f items in front Stack and b \nin back.A black box checker checks O(n2) state transitions.   Figure 4. A glass box checker generates \nonly O(n) states and checks only O(n) transitions, yet achieves complete coverage within the bounded \ndomain. The repOk method returns true i. the current state (or rep\u00adresentation) of an object satis.es \nits class invariant. The class invariant of Queue holds i. its subobjects front and back are di.erent \nand not null, and their invariants hold. Consider checking that every public method of Queue pre\u00adserves \nits class invariant. That is, consider checking that if the class invariant holds before a method, then \nthe class invariant holds after the method, and the method either re\u00adturns normally or by throwing one \nof its declared excep\u00adtions. We assume all Queue methods execute determinis\u00adtically. (Otherwise, one \nmust expose the nondeterminism points to the model checker to check every possibility.) A black box checker \nsuch as JPF [48] or CMC [39, 38] starts from an empty Queue state and recursively invokes and checks \nevery Queue operation on every successive Queue state (within a bounded domain). A stateful checker stores \nall the checked states in a hashtable to avoid redundantly checking the same operation on the same state \nmore than once. Suppose there is exactly one concrete state represent- Figure 6. State space of code \nin Figure 5 (excluding self loops). (b1,b2,b3) implies x = b1, y = b2, z = b3. The .gures on the left \nand right show the state transitions executed by a black box and glass box checker respectively. ing \na Stack of size n. Then there are n +1 concrete states representing a Queue of size n. Figure 3 shows \nthe state space of Queue with at most n =4 items. State (f,b)has f items in front and b in back. Edges \nrepresent enqueue and dequeue operations. E.g., the edge from (1,1) to (1,2) rep\u00adresents an enqueue. \nThe edges from (1,2) to (0,2) and (0,2) to (1,0) represent dequeue operations. A black box checker executes \nO(n 2) state transitions to explore this space. Our glass box checker works as follows. Consider the \ntran\u00adsition from (0,0) to (0,1) using the enqueue method. This operation terminates normally and the \nclass invariant holds after the method. As our checker checks this operation, its dynamic analysis detects \nthat the enqueue method does not read the front Stack. That means, if the state of the front Stack were \ndi.erent, the enqueue method would still exe\u00adcute similarly. Our checker then determines that if enqueue \nexecutes successfully on (0,0), then it will execute success\u00adfully on (i,0) for any i. Our checker therefore \nsafely prunes all those state transitions from its search space. In partic\u00adular, if Queue has at most \nn = 4 items, our checker prunes the enqueue edges from (0,0), (1,0), (2,0), (3,0), and (4,0) once it \nsuccessfully checks enqueue on (0,0). Similarly, checking enqueue on (0,1), (0,2) and (0,3) results in \npruning enqueue operations on all (i,1), (i,2) and (i,3). Checking dequeue on (1,0), (2,0), and (3,0) \nresults in prun\u00ading dequeue operations on all (1,i), (2,i), and (3,i). Figure 4 presents the same state \nspace as Figure 3 except that it only shows the transitions that our checker executes. Our glass box \nchecker executes only O(n) state transitions to explore the state space, while still achieving complete \ntest coverage within the bounded domain. Moreover, our checker never generates states from which all \ntransitions have been pruned. For example, our checker never generates any state (i,j)where i .. =0 and \nj = 0. Thus, our checker generates only 1 public class Stack { 2 private static class Node { 3 Node next; \n4 Object value; 5 Node(Node n, Object v) { next = n; value = v; } 6} 7 8 private Node head; 9 10 public \nboolean repOk() { 11 Set visited = new java.util.HashSet(); 12 for (Node n = head; n != null; n = n.next) \n{ 13 if (!visited.add(n)) return false; 14 } 15 return true; 16 } 17 18 public void push(Object value) \n{ 19 head = new Node(head,value); 20 } 21 public Object pop() { 22 if (head == null) return null; 23 \nObject v = head.value; head = head.next; return v; 24 } 25 } Figure 7. Stack implemented using a linked \nlist. O(n) states and checks only O(n) transitions, compared to O(n 2) states and O(n 2) transitions \nin a black box approach. This results in signi.cant speedups. Note that for simplicity, we implicitly \nassumed that there is only one possible argument to enqueue, so there is only one enqueue transition \nfrom each state. But suppose there are n di.erent items that can be passed as arguments to enqueue, so \nthere are n enqueue transitions from each state. Then, for checking a Queue of size n, a black box checker \nactually executes an exponential number of transitions. Our glass box checker still executes O(n) transitions. \n  3. Glass Box Model Checking This section presents our glass box model checker. While the basic idea \nillustrated in the previous section is simple, one has to overcome several technical challenges to make \nit work well in practice. This section describes our approach. Section 3.1 describes the search space \nof a glass box model checker, Section 3.2 describes the search space representa\u00adtion, and Section 3.3 \ndescribes the search process. 3.1 Search Space This section describes the search space of a glass box \nchecker. 3.1.1 Search Space Organization Consider the Stack example from Figure 7. The Stack is implemented \nusing a linked list. Its class invariant (repOk) checks that the list is acyclic. Consider checking that \nthe Stack implementation preserves the Stack invariant. One way to systematically test the Stack implementation \nis to start from the initial empty Stack state, and recursively invoke and check every Stack operation \non every succes\u00adsive Stack state (within a bounded domain). Some black box checkers such as JPF [48] \nor CMC [39] use this ap\u00adproach. The stateful black box checkers store (a hash of) ev\u00ad 1 public class \nStack { 2 private static class Node { 3 tree Node next; 4 Object value; 5 Node(Node n, Object v) { next \n= n; value = v; } 6} 7 8 private tree Node head; 9 10 public boolean repOk() { return true; } 11 12 \npublic void push(Object value) { 13 head = new Node(head,value); 14 } 15 public Object pop() { 16 if \n(head == null) return null; 17 Object v = head.value; head = head.next; return v; 18 } 19 } Figure 8. \nStack in Figure 7 with its invariant rewritten using the tree annotation (Line 3). The repOk (Line 10) \nthen has no additional constraints to specify. ery checked state in a hashtable to avoid redundantly \ncheck\u00ading the same operation on the same state more than once. The above technique, however, is not a \nsuitable way for a glass box checker to organize its search space. The example in Figure 5 illustrates \nwhy. Figure 6 shows the correspond\u00ading state space (excluding self loops). A black box checker using \nthe above technique starts from the initial state and reaches all .ve states by recursively invoking \nmethods on successive states. However, as a glass box checker checks the setX method on state (F,F,F), \nits analyses detect that setX behaves similarly on state (F,T,F). Therefore, the glass box checker prunes \nthat edge from its state space. Similarly, as a glass box checker checks setY on (F,F,F), it prunes setY \nfrom (T,F,F). But this disconnects the state space graph. A glass box checker thus cannot depend on reachability \nof the state space to reach the state (T,T,F). Instead, our glass box checker uses a di.erent approach. \nOur system requires programmers to specify the class in\u00advariants of data structures. For example, in \nFigure 7, the repOk method describes the class invariant of the Stack.The search space of a glass box \nchecker checking a data structure is de.ned to consist of all type-correct states (within some .nite \nbounds) that satisfy its class invariant. Note that this is di.erent from the search space of a black \nbox checker, which is de.ned to consist of all states (within some .nite bounds) that are reachable from \nthe initial state by perform\u00ading a sequence of data structure operations. Sections 3.1.2 and 3.1.3 discuss \nthe implications of this di.erence. A glass box checker exhaustively checks every operation on every \nstate within the search space, but does so e.ciently by detecting redundancies in the search space and \npruning away large portions of the search space without explicitly checking them. Each time our checker \nchecks an operation, it veri.es that (i) the operation either terminates normally or throws one of its \ndeclared exception, (ii) the invariant holds after the operation, and (iii) any additional properties \nspeci.ed by programmers (e.g., as assert statements) hold. 1 public class RedBlackTree { 2 private static \nclass Node { 3 tree Node left; 4 tree Node right; 5 Node parent 6 boolean color; 7 8 public boolean repOkLocal() \n{ 9 assert((left == null) || (left.parent == this)); 10 assert((right == null) || (right.parent == this)); \n11 12 if (color == RED) { 13 assert((left == null) || (left.color == BLACK)); 14 assert((right == null) \n|| (right.color == BLACK)); 15 } 16 17 return true; 18 } 19 } 20 21 private tree Node root; 22 23 public \nboolean repOk() { 24 // Return true iff the number of black nodes in every 25 // path from the root to \na leaf is the same. 26 } 27 ... 28 } Figure 9. Partial implementation of RedBlackTree, ex\u00adcluding keys \nand values from Nodes. 3.1.2 Programming Overhead One of the main advantages of the black box model \nchecking approach is that it requires minimal programmer assistance. For checking application independent \nproperties (such as null pointer dereferences or memory leaks), it requires no programmer assistance. \nFor checking application dependent properties, it only requires a speci.cation of the properties to be \nchecked in an executable form (e.g., using asserts). Compared to black box checking, glass box checking \nsome\u00adtimes involves extra programming e.ort because program\u00admers have to additionally specify class invariants \nof data structures as described above. However, because glass box checking is orders of magnitude faster \nthan black box check\u00ading, writing the class invariants is often worth the e.ort. Note that the e.ort \nrequired to write class invariants is pro\u00adportional to the size and complexity of the data declarations, \nnot the size of the code. For example, java.util.TreeMap (a red black tree implementation) has 1670 lines \nof code, whereas its invariant takes less than 1% as many lines. Also, if the goal includes checking \nthat a data structure implemen\u00adtation preserves its invariants, then programmers have to specify the \ninvariants for both black box and glass box check\u00ading, in which case there is no additional overhead \ninvolved in glass box checking. In addition, if programmers make a mistake in writing the invariants, \nour system provides con\u00adcrete counterexamples to help them correct the invariants, as we describe in \nthe next section. Glass box model checking thus involves slightly more pro\u00adgramming overhead compared \nto black box model check\u00ading, but signi.cantly less overhead compared to other for\u00admal veri.cation techniques \nusing theorem provers (that re\u00adquire extensive programmer assistance either as invariants for loops and \nrecursive functions, or as guidance to interac\u00ad 1 public class RedBlackTree { 2 private static class \nNode { 3 tree Node left; 4 tree Node right; 5 Node parent 6 boolean color; 7 ghost int blackHeight; 8 \n9 public boolean repOkLocal() { 10 assert((left == null) || (left.parent == this)); 11 assert((right \n== null) || (right.parent == this)); 12 13 if (color == RED) { 14 assert((left == null) || (left.color \n== BLACK)); 15 assert((right == null) || (right.color == BLACK)); 16 } 17 18 int x = blackHeight -((color \n== BLACK) ? 1 : 0); 19 assert(blackHeight >= 0); 20 assert((left == null) || (left.blackHeight == x)); \n21 assert((right == null) || (right.blackHeight == x)); 22 if (x > 0) assert((left != null) &#38;&#38; \n(right != null)); 23 24 return true; 25 } 26 } 27 28 private tree Node root; 29 30 public boolean repOk() \n{ return true; } 31 ... 32 } Figure 10. RedBlackTree in Figure 9 with its invariant rewritten using \na ghost .eld (Line 7) and thus converting global constraints (Lines 24-25 in Figure 9) into local constraints \n(Lines 18-22 in this .gure). tive theorem provers). On the other hand, glass box checking is signi.cantly \nfaster than black box checking but could be slower than techniques using theorem provers, if the theorem \nprovers are provided su.cient manual assistance. Glass box model checking thus presents an interesting \ntrade-o. in the design space of software veri.cation techniques. 3.1.3 Handling Errors in Invariants \nProgrammers can make two kinds of errors in writing the class invariant of a data structure. Let SR be \nthe set of states (within some .nite bounds) that are reachable from the initial state by performing \na sequence of operations. Let SI be the set of states (within the same .nite bounds) that satisfy the \ninvariant. We say an invariant is unsound if there is a state in SR that is not in SI ,and incomplete \nif there is a state in SI that is not in SR. If an invariant is unsound, then (assuming the initial state \nis in SI ) there must exist a transition from states s1 to s2, where both s1 and s2 are in SR, but only \ns1 is in SI and s2 is not. Our glass box checker will eventually check such a transition (or a transition \nsimilar to it) and detect that the transition does not preserve the invariant. It will then present the \ntransition as a concrete counterexample to the user. The user can either .x the invariant, or alternately, \nif thebug is in thecode, theusercan .x thecode. If an invariant is incomplete, then either (i) the checker \nde\u00adtects a false positive, that is, a state s that is in SI but not SR on which some operation fails \nto check in which 1 public Finitization checkStack(int h, int nObjects) { 2 Finitization f = new Finitization(\"Stack\"); \n3 f.setOperations(\"push\", \"pop\"); 4 f.setMaxTreeHeight(h); 5 6 Set objects = f.createObjects(\"Object\", \nnObjects); 7 objects.add(null); 8 f.setFieldDomain(\"Node.value\", objects); 9 f.setArgumentDomain(\"push\", \n\"value\", objects); 10 11 return f; 12 } Figure 11. Finitization description for code in Figure 8. \n Field Domain operation {push, pop} head {N0, null} N0.next {N1, null} N1.next {N2, null} N2.next {null} \nN0.value {O0, O1, O2, null} N1.value {O0, O1, O2, null} N2.value {O0, O1, O2, null} push.value {O0, O1, \nO2, null} Figure 12. Search space for checkStack(3,3). case the user can strengthen the invariant by \nexamining the concrete counterexample s, or (ii) the checker successfully checks the program in which \ncase the checker would have veri.ed the program not only on all reachable states but on some unreachable \nstates as well. Thus, even though our glass box checker depends on invari\u00adants to cover all states, it \nis sound in that it does not miss any errors in the program that a black box checker would detect, even \nif programmers make a mistake in specifying the invariants. 3.1.4 Specifying Invariants One way programmers \ncan specify a class invariant is by writing a repOk method [32]. The repOk method returns true i. the \ncurrent state (or representation) of an object satis.es its class invariant. E.g., the repOk method of \nStack in Figure 7 checks that there are no cycles in the linked list. Our system also allows programmers \nto specify invariants (as well as other properties to be checked) using a declarative language, such \nas a subset of JML [30], as long as the declar\u00adative speci.cations can be automatically translated into \nex\u00adecutable code. For example, a large subset of JML can be automatically translated to Java using the \nJML tool set [30]. In addition to the above, our system provides a stylized way for specifying certain \nkinds of invariants that makes it both convenient for programmers to write the invariants, and faster \nfor a glass box checker to check programs using the invariants. Our approach is premised on the observation \nthat most data structures are tree-based. The next three subsections describe this approach. 3.1.4.1 \nSpecifying a Tree Backbone Given a tree-based data structure, our system allows pro\u00adgrammers to specify \nthe tree backbone of the data structure 1 public Finitization checkRedBlackTree(int h) { 2 Finitization \nf = new Finitization(\"RedBla ckTree\"); 3 f.setOperations(...); 4 f.setMaxTreeHeight(h); 5 return f; \n6} Figure 13. Finitization description for code in Figure 10. Field Domain operation {...} root {N0, \nnull}N0.left {N1, null}N0.right {N2, null}N1.left {N3, null}N1.right {N4, null}N2.left {N5, null}N2.right \n{N6, null} N3.left, N3.right, N4.left, N4.right, {null} N5.left, N5.right, N6.left, N6.right N0.color, \nN1.color, N2.color, N3.color, {RED, BLACK} N4.color, N5.color, N6.color N0.parent, N1.parent, N2.parent, \nN3.parent, {N0, N1, N2, N3, N4.parent, N5.parent, N6.parent N4, N5, N6, null}  Figure 14. Search space \nfor checkRedBlackTree(3). using the keyword tree as a .eld modi.er [36]. For example, in Figure 8, the \nkeyword tree on Line 3 speci.es that the linked list has no cycles along the next .elds. Note how this \nis far more convenient to write than the executable spec\u00adi.cation in Lines 11-15 of Figure 7. In general, \nif object x has a tree .eld fd that contains a pointer to object y, we say that there is a tree edge \nfd from x to y. x is the tree-parent of y and y is a tree-child of x. The meaning of the tree speci.cation \nis that (before and after every public method) the graph induced by the set of all tree edges in the \nheap is a forest of trees (that is, it has no directed or undi\u00adrected cycles). Programmers can use the \ntree keyword to specify the tree backbone of any tree-based data structure. This includes singly linked \nlists, doubly linked lists, trees with parent pointers, threaded trees, balanced search trees, etc. Note \nthat these data structures can have other non-tree pointers that can contain cycles, as long as their \ntree point\u00aders do not contain cycles. The partial implementation of a RedBlackTree in Figure 9 provides \nanother example. The tree keyword on Lines 3-4 specify that the left and right .elds form the tree backbone \nof the data structure. 3.1.4.2 Specifying Local Invariants Consider the RedBlackTree in Figure 9. One \nof its invari\u00adants is that for every node N,(N.left. =null)=. (N .left\u00ad.parent=N). We say that such invariants, \nthat involve only (the .elds of) an object and (the .elds of) its tree-children, are local invariants. \nAnother example of a local invariant in RedBlackTree (N.color=RED . is . N.left=null)=. (N.left.color. \n=RED)for allnodes N. Our system allows programmers to specify local invariants using the repOkLocal method. \nLines 8-19 in Figure 9 pro\u00advide an example. To check the local invariant on a particular instance of \na data structure, our system traverses the tree N0 N1 N2 head next value next value next value operation \npush.value Figure 15. A valid element of the search space in Fig\u00adure 12 representing the pop operation \non a Stack with two items O1 an O2. N0 N1 Figure 16. (A portion of) an invalid element of the search \nspace in Figure 14, with the root and its left child both being red. backbone of the data structure and \nchecks that repOkLocal returns true on every tree node. The advantage of specifying local invariants \nthis way (as opposed to specifying them as global invariants using the repOk method) is that program\u00admers \ndo not have to write code to perform the tree traversal. Another advantage is that it makes glass box \nmodel checking faster, as we explain later in the paper. 3.1.4.3 Specifying Non-Local Invariants In \naddition to specifying local invariants using repOkLocal, programmers can specify other non-local invariants \nusing the repOk method. The repOk method in Figure 9 provides an example. It checks that the number of \nblack nodes in every path from the root to a leaf is the same. It is often possible to convert non-local \ninvariants into local ones by adding extra .elds [35]. For example, the above non-local invariant can \nbe converted into a local invariant by adding a .eld blackHeight to every node (which stores the number \nof black nodes in any path from that node to a leaf). This is illustrated in Lines 18-22 of Figure 10. \nNote that in Line 7 of the .gure, blackHeight is declared to be a ghost .eld [14]. A ghost .eld exists \nonly during model checking, but otherwise does not exist when the data structure is used in a program. \nA ghost .eld is thus part of the speci.cation (and not implementation) of a data structure and it does \nnot slow down the performance of the data structure.  3.1.5 Specifying Bounds on Search Space In any \nmodel checker that checks data structure properties, programmers must specify .nite bounds on the search \nspace. In our glass box checker, programmers must specify the fol\u00adlowing: (i) for the tree back-bone \n(of a tree-based data struc\u00adture), the maximum height of the tree backbone; (ii) for objects not on the \ntree backbone, the maximum number of objects of each class; (iii) the domain of every method argument \nand non-tree .eld. Our checker then checks the program on every possible state in this .nite space. Figure \n11 presents an example .nitization description that is automatically generated by our system from the \ntype dec\u00adlarations in Figure 7. The setOperations method speci\u00ad.es that the checker must check the two \npublic methods push and pop.The setMaxTreeHeight sets the maximum height of the tree backbone. The createObjects \nmethod speci.es that a state can contain at most nObjects number of Objects.The setFieldDomain and setArgumentDomain \nmethods specify that the .eld value and the argument to push can either contain null or an Object. 1 \nvoid search(Finitization f) { 2 F = Set of all elements in f 3 I = Set of all elements in F that satisfy \nthe invariant 4 S=I 5 while (S is not empty) { 6 t = Any transition in S 7 Check t 8 T = Set of all transitions \nsimilar to t (including t) 9 S =S-T 10 } 11 } Figure 17. Pseudo-code for the search algorithm.  Once \nour system generates a .nitization, programmers can specialize it; e.g., they can make checkStack take \na single argument n and set both h and nObjects to n. We provide several helper functions for easy domain \nconstruction. Figure 13 presents another example .nitization description for the code in Figure 9. If \nthe domain of a non-tree .eld of type T is not explicitly set by the .nitization, then our system sets \nthe domain to be the set of all values of type T . For example, for Figure 13, our system sets the domain \nof color to true and false (representing BLACK and RED). 3.1.6 Search Space Suppose our checker is invoked \nusing checkStack(3,3) in Figure 11. Our system then constructs the search space in Figure 12. Our system \n.rst allocates the speci.ed number of objects: one Stack,three Nodes,and three Objects.It then sets the \ndomain of each object .eld and method argument as described in the .nitization. Finally, it includes \nthe two public methods of Stack in the operations to be checked. The search space consists of all possible \nassignments to the above .elds, where each .eld gets a value from its corre\u00adsponding domain. Every element \nof this search space is a state transition consisting of a concrete Stack state, a method to invoke on \nthe state, and the method arguments. For example, Figure 15 corresponds to invoking pop on a Stack with \ntwo items O0 and O1.In Figure 12, there are four .elds with four elements in their domains and four with \ntwo, so the size of this search space in 44 * 24 . In general, when our checker is invoked with checkStack(n,n),the \nsize of the search space is (2n +2)n+1 . Notethatsomeelements of a search space may be invalid because \nthe corresponding structure does not satisfy the class invariant. For example, the element in Figure \n16 (for the search space in Figure 14) is invalid because the root and its left child are both red. \n 3.1.7 Search Algorithm Figure 17 presents the glass box search algorithm. Given a class to check and \na .nitization, our system .rst initializes the search space S to the set I of all elements that satisfy \nthe invariant of the class. It then systematically explores the space S by repeatedly selecting a transition \nt from S,check\u00ading t, running its analyses to identify the set T of transitions similar to t (including \nt), and pruning T from S.Sections3.2 and 3.3 describe how to perform the above search e.ciently.   \n3.2 Search Space Representation Consider checking the RedBlackTree (Figure 10) with check\u00adRedBlackTree(h).Say, \nn =2h . Our checker generates O(n 2) states and checks O(n 2) transitions to cover this search space \n(as we show in Section 4). But the size of the search space is exponential in n. Also, the size of the \nset I in Fig\u00adure 17 is exponential in n. If we are not careful, then search space management itself could \ntake exponential time, thus defeating most of the advantage gained by glass box check\u00ading. To avoid this, \nwe compactly represent the search space using reduced ordered binary decision diagrams [3], or BDDs. \nFigure 18 presents an example, where the BDD represents the set I (in Figure 17) of all RedBlackTrees \nof maximum height 2 that satisfy the invariant in Figure 10. Each node in the BDD represents one bit. \nA solid line from the node repre\u00adsents the bit being 1 and a dotted line 0. For the .elds root, left,and \nright, 1 represents that the .eld is non-null and 0 null; for color, 1 represents BLACK and 0 RED.(We \nusemore than one bit for .elds whose domain contains more than two elements.) Any path in the BDD from \nthe initial node to the node 1 represents (one or more) elements of the set I,that is, data structures \nthat satisfy the invariant. For example, the following are elements of I: {root=null}, {root. =null, \nroot.color=BLACK, root.left=null, root.right=null}. Figure 19 presents another example, with a BDD represent\u00ading \nthe same set as in Figure 18, but with the order of the .elds in the BDD reversed. Figure 20 presents \na BDD repre\u00adsenting all RedBlackTrees of maximum height 3 that satisfy the invariant in Figure 10. Figure \n19. BDD representing the same set as in Fig\u00adure 18, with the order of the .elds in the BDD reversed. \nNote that in Figures 18, 19, and 20, we do not include the .eld parent in the BDD. This is because our \nanalyses detect that parent is a derived .eld. That is, given any reachable node in a tree, there is \nexactly one possible value of parent that satis.es the invariant. It is therefore unnecessary to store \nthe values of the parent .elds in the set S in Fig\u00adure 17, because given any element of S, one can reconstruct \nthe values of all the parent .elds. Similarly, we do not in\u00adclude the ghost .eld blackHeight (Line 7 \nin Figure 10) in the BDDs, because it is a derived .eld. A good .eld ordering is the key to keeping the \nBDD size small. In Figures 19 and 20, we order the .elds in the BDDs based on a post-order traversal \nof the tree backbone of the data structure. In general, this is ordering of .elds we use in our system. \nFor objects not on the tree backbone, we include them in the order in which we encounter them as we build \nthe set I (as we describe in Section 3.3.3). The above .eld ordering keeps the .elds connected by invariants \ntogether in the BDD, which seems to naturally induce a good .eld ordering and thus compact BDDs. The \nabove .eld ordering also makes the search e.cient. The reason is as follows. In the BDD package we use \n(and in the BDDpackagesweknowof), all theBDDs areimmutable. A BDD node once created cannot be modi.ed. \nBut di.erent BDDs can share nodes. To make a change to a BDD, the implementation constructs a new BDD \nby copying all the BDD nodes above the place where the change happens. That means, making a change to \nthe bottom of a BDD is more expensive because there is more copying involved, whereas making a change \nto the top of a BDD is cheaper. It is therefore better to keep .elds that change frequently at the N6.color \nN5.color N5.color N2.color N2.color N2.colorN2.color N2.right N2.right N2.right N2.right N2.left N2.leftN2.left \nN2.left N4.color N4.color N4.color N3.color N3.color N3.color N3.color N3.color N1.color N1.color N1.color \nN1.color N1.colorN1.color N1.color N1.color N1.color N1.color N1.color N1.right N1.right N1.right N1.rightN1.right \nN1.rightN1.right N1.right N1.left N1.left N1.leftN1.left N1.left N1.left N0.color N0.color N0.color N0.color \nN0.right N0.right N0.right N0.left N0.left root 10 Figure 20. BDD representing the set of all RedBlackTrees \nin the search space in Figure 14 (with maximum height 3) that satisfy the invariant in Figure 10. Max. \nHeight Set Size BDD Size 1 2 0 2 7 12 3 34 58 4 597 226 5 238526 744 6 42715248230 2367 7 1123387228727905854061 \n7359 Figure 21. For a given maximum height, Column 2 above presents the number of RedBlackTrees that \nsatisfy the class invariant in Figure 10, and Column 3 presents the size of the BDD representing the \nset of all such RedBlackTrees.  top of the BDD. In the context of checking a tree-based data structure, \nsuch as the RedBlackTree in Figure 10, the value of the root .eld is non-null for all valid RedBlackTrees \nexcept one. Hence the value of the root .eld does not change much as the search progresses. Therefore \nit is best to keep root at the bottom of the BDD. Similarly it is best to keep .elds that are near the \nroot of the tree towards the bottom of the BDD. We therefore use the post-order tree traversal ordering \nfor .elds as in Figures 19 and 20. Figure 21 presents the sizes of BDDs representing the set I (in Figure \n17) for RedBlackTrees with di.erent maxi\u00admum heights. The numbers indicate that as the height h increases, \nassuming n =2h, the size of the BDD grows as O(n log n). Thenumberofelementsin I however grows ex\u00adponentially \nin n, because there are exponentially (w.r.t. n) many RedBlackTrees of a given maximum height h.This \nillustrates how a BDD can provide a compact representation for a very large set of related data structures. \nIn general, if all the invariants of a tree-based data struc\u00adture are local (that is, the invariants \nare speci.ed using only repOkLocal and without using repOk), then it is easy to see that the size of \nthe BDD representing the set I in Figure 17 is always O(n log n)(where n is the maximum size of the data \nstructure), even though the number of elements in I could be exponential in n. This is part of the reason \nwhy it is advantageous to use local invariants as much as possible for glass box model checking.  3.3 \nSearch Figure 17 presented the search algorithm. This section de\u00adscribes how to perform each step of \nthe algorithm e.ciently. 3.3.1 Manipulating the Search Space This section describes how to execute Lines \n5, 6, and 9 in Figure 17 e.ciently. We described in Section 3.2 how we use BDDs to represent our search \nspace. Given that, Line 5, checking if a set is empty, is a constant time BDD operation. Line 9, computing \nthe di.erence of two sets, is usually an e.cient BDD operation. In particular, even if the two sets contain \nexponentially many elements, operations on the sets can be performed e.ciently using their compact BDD \nrep\u00adresentations. Line 6, choosing an element from a non-empty set, takes time linear in the number of \n.elds in the BDD. If the set has more than one element, our system chooses the lexicographically least \nelement of the set. That ensures that the search space remains contiguous and structured as much as possible, \nwhich in turn leads to smaller BDD representa\u00adtions of the search space as the search progresses.  3.3.2 \nPruning the Search Space This section describes how to execute Lines 7 and 8 in Fig\u00adure 17 e.ciently. \nThe key to making glass box model check\u00ading e.cient is to identify as large a set T as possible in Fig\u00adure \n17, that is, given a transition t, toidentifyasmany transitions similar to t as possible, so that they \ncan be pruned away without explicitly checking them. This section describes how we monitor the program \nas we check a transi\u00adtion t (Line 7) and how we use the results of the monitoring to construct the set \nT of transitions similar to t (Line 8). 3.3.2.1 Tracking Fields Read Consider the Stack example in Figure \n8. Consider checking that the transition in Figure 15 preserves the Stack invari\u00adant. As our checker \nruns the pop method, it monitors the set of .elds that pop reads. In this case, pop reads head, N0.value,and \nN0.next. That means, regardless of the val\u00adues of the remaining .elds, pop will still behave similarly. \nOur system then determines (as we explain below) that re\u00adgardless of the values of the remaining .elds, \nif the invariant holds before pop, then the invariant holds after pop. Our sys\u00adtem therefore prunes all \nelements of the search space where head=N0, N0.value=O0, N0.next=N1,and operation=pop. The above technique, \nin e.ect, detects don t care .elds in a transition t, and suggests that all transitions t that di.er \nfrom t only at the don t care .elds be pruned from the search space. However, we need additional mechanisms \nto ensure that the system is sound. To see why the above technique alone is unsound, consider the following \nexample: 1 class SoundnessDemo { 2 private boolean x, y; 3 public boolean repOk() { return !x || y; } \n4 public void flipX() { x = !x; } 5} The invariant repOk returns true i. x implies y. Suppose we invoke \nflipX on x=false and y=true. The invariant holds before and after the transition. flipX reads only x; \ny is a don t care. The above technique suggests that flipX will perhaps verify on all states where x=false \n(and there\u00adfore those elements be pruned from the search space). But the suggestion is incorrect because \nflipX does not verify on x=false and y=false. The invariant holds before the transition, but not after. \nThe above technique fails on this example because a .eld that is read (x) is related by the invariant \nto a .eld that is a don t care (y). 3.3.2.2 Identifying Don t Care Fields To correctly identify the \ndon t care .elds of a transition t and to soundly prune the search space, our system works as follows. \nLet Ft and Ft be the set of .elds read by t and modi.ed by t respectively. After executing t, our system \nchecks if the class invariant is preserved. If t has a postcon\u00addition in addition to the class invariant, \nour system checks the postcondition as well. Let FP be the set of .elds read by the additional postcondition, \nif any. If a data structure invariant only speci.es that the tree back\u00adbone of the data structure must \nremain a tree (that is, repOk and repOkLocal always return true), then our system com\u00adputes the set of \nrelevant .elds FR as Ft . FP .All the .elds not in FR are don t cares. In particular, if FP is an empty \nset, then FR reduces to Ft . Thus, for checking that the Stack in Figure 8 preserves its invariant, the \ntechnique described in Section 3.3.2.1 is actually sound. If a data structure invariant speci.es a local \ninvariant in ad\u00addition to the tree backbone (that is, repOk always return true but repOkLocal does not), \nthen our system works as follows. Recall from Section 3.1.4.2 that to check the local invariant, our \nsystem traverses the tree backbone of the data structure andchecksthat repOkLocal returns true on every \ntree node Ni.Also recall that repOkLocal is restricted to read only the .elds of a node and the .elds \nof its tree children our system enforces this restriction using dynamic checking. Let FNi be the set \nof .elds read when our system invokes repOkLocal on a tree node Ni, after the execution of t.Let FL be \nthe smallest set such that: (i) if f . Ft then f . FL , and (ii) if f1 . Ft and f1, f2 . Ni for any i \nthen f2 . FL . Our system computes the set of relevant .elds FR as FL . FP . Finally, all the .elds not \nin FR are don t cares. If a data structure invariant speci.es a global invariant as well (that is, repOk \ndoes not always return true), then our system conservatively treats all the .elds read by repOk as relevant \n.elds. (This is another reason, besides the one at the end of Section 3.2, why using local invariants \nas much as possible is advantageous.) Let FG be the set of .elds read by repOk, after the execution of \nt. Then our system com\u00adputes the set of relevant .elds FR as FL . FG . FP ,where FL is computed as above. \nAll the .elds not in FR are don t cares. 3.3.2.3 Tracking Information Flow to Improve Precision This \nsection describes an optimization to more precisely compute the above sets Ft , FNi , FG ,and FP .The \nabove al\u00adgorithm computes the sets by tracking the .elds read by the corresponding methods. But sometimes, \neven though a method reads a .eld, it does not depend on it. That is, the method s return value and its \nside e.ects do not depend on the .eld. The Point class below provides an example. Suppose the method \nreturns false on Line 5 because x==y. The above analysis assumes that because the method read all three \n.elds x, y, z, the return value depends on all the .elds even though it depends only on x and y. 1 class \nPoint { 2 private int _x, _y, _z; 3 public boolean isSkewed() { 4 int x=_x, y=_y, z=_z; 5 if (x == y) \nreturn false; 6 if (y == z) return false; 7 if (z == x) return false; 8 return true; 9}} To make our \nanalysis more precise, we use dynamic infor\u00admation .ow tracking. Consider Stack in Figure 12. There are \nnine .elds. For every value v the program computes, our system also computes a nine-bit shadow value \nv that tracks the input .elds from which there is information .ow to v. Given an execution trace of the \npostcondition of a method (such as repOkLocal, repOk, or any additional asserts) we say that the postcondition \nonly depends on the set of .elds from which there is information .ow to the value returned by postcondition. \nGiven an execution trace of a method m being checked, we say that m only depends on the set of .elds \nfrom which there is information .ow to the value returned by the postcondition that is run after m s \nexecution. One thing we must be careful about is that information .ow analysis [10, 40] is di.erent from \ndynamic slicing [29, 53], as the following example shows. 1 class InfoFlowDemo { 2 private boolean b; \n3 public boolean m() { 4 boolean x = false; if (b) x = true; return x; 5}} There is information .ow \nfrom b to x above. But if b is false,then x is not control or data dependent on b because the branch \nis not taken. If we use dynamic slicing, then on running the method with b=false we would incorrectly \nconclude that the method does not depend on b and always returns false. To avoid that, our analysis conservatively \nas\u00adsumes that after any join point in the control .ow graph, all variables depend on the corresponding \nbranch conditional. Thus the return value x depends on b. However, in the fol\u00adlowing example, q on Line \n2 does not depend on p because the branch on Line 1 always exits from the method, so there is no join \npoint. 1 if (p) return true; 2 if (q) return true;  3.3.2.4 Pruning Isomorphic Structures Compare the \nStack in Figure 15 with a Stack where head=N0, N0.next=N1, N0.value=O2, N1.next=null,and N1.value=O1.The \ntwo are isomorphic. Clearly, once we check pop on the .rst Stack, it is redundant to check pop on the \nsecond Stack. Our checker avoids checking isomorphic structures as follows. After checking the transition \nin Figure 15, the analyses in the previous sections conclude that the pop operation on all Stacks with \nhead=N0, N0.next=N1,and N0.value=O0 can be pruned. Our isomorphism analysis then determines that pop \ncan also be pruned from all structures that satisfy the following formula: (head=N0 . N0.next=N1 . N0.value \n=null). In general, to construct the formula, our system traverses all the relevant .elds of a transition \nt. Each time it encounters a fresh object o that a .eld points to, it includes (in the formula) all other \ntransitions t where the .elds read by the traversal so far have the same values except that instead of \no in t there is another fresh object o in t . Our system then prunes all transitions denoted by the formula \nusing e.cient BDD operations. The above technique is sound if our system traverses the .elds in a .xed \norder. Note that some black box checkers also prune isomorphs us\u00ading heap canonicalization [24, 37]. \nThe di.erence is, in heap canonicalization, once a checker visits a state, it canonical\u00adizes the state \nand checks if the state has been previously vis\u00adited. In our isomorphism pruning, once our checker checks \na Transitions BDD Nodes Created Time (seconds) Benchmark Max Size Total Initialization Checking Max \nBDD Size Total Initialization Checking 1 4 9 4 5 2 0.016 0.014 0.002 2 5 14 6 8 3 0.016 0.014 0.002 3 \n5 16 8 8 3 0.017 0.015 0.002 4 5 18 10 8 3 0.017 0.015 0.002 5 5 20 12 8 3 0.017 0.015 0.002 6 5 22 14 \n8 3 0.017 0.015 0.002 Stack 7 5 24 16 8 3 0.017 0.014 0.002 8 ... 5 26 18 8 3 0.017 0.015 0.002 16 5 \n42 34 8 3 0.018 0.016 0.002 32 5 74 66 8 3 0.018 0.015 0.002 64 5 140 130 10 3 0.020 0.017 0.003 128 \n5 268 258 10 3 0.023 0.020 0.003 1 5 17 6 11 4 0.019 0.017 0.002 2 7 36 10 26 8 0.020 0.017 0.002 3 8 \n46 14 32 10 0.020 0.018 0.002 4 9 61 18 43 10 0.020 0.017 0.003 5 10 68 22 46 10 0.021 0.017 0.004 6 \n11 75 26 49 10 0.021 0.017 0.003 Queue 7 12 101 30 71 10 0.021 0.017 0.004 8 ... 13 114 34 80 10 0.022 \n0.018 0.004 16 21 272 66 206 18 0.028 0.018 0.010 32 37 834 130 704 34 0.050 0.019 0.030 64 69 2873 258 \n2615 66 0.086 0.021 0.064 128 133 12292 514 11778 130 0.118 0.028 0.090 1 4 9 4 5 2 0.016 0.015 0.001 \n2 7 58 16 42 10 0.016 0.014 0.002 3 11 245 72 173 40 0.018 0.015 0.002 4 17 565 76 489 71 0.019 0.015 \n0.004 5 24 2053 350 1703 226 0.022 0.015 0.006 6 34 4398 597 3801 470 0.029 0.016 0.013 HeapArray 7 45 \n9032 959 8073 960 0.035 0.016 0.018 8 57 16621 672 15949 2467 0.045 0.016 0.029 9 70 55382 3092 52290 \n6274 0.080 0.018 0.062 10 86 81364 3963 77401 9105 0.114 0.018 0.096 11 103 145832 5387 140445 13656 \n0.198 0.019 0.179 12 122 254985 7299 247686 19472 0.318 0.020 0.298 13 142 556949 10407 546542 37432 \n0.647 0.022 0.625 14 165 1344220 17506 1326714 107759 2.098 0.026 2.072 Max Height RedBlackTree 1 2 \n3 4 5 6 7 6 28 108 366 1094 2968 7524 28 493 3860 24400 128314 781369 6263228 12 139 403 1645 3906 9352 \n23095 16 354 3457 22755 124408 772017 6240133 5 25 88 340 1311 4868 17434 0.022 0.028 0.066 0.134 0.340 \n1.543 10.340 0.019 0.020 0.021 0.022 0.027 0.035 0.055 0.003 0.007 0.045 0.112 0.313 1.508 10.285 Max \nHeight / Max Degree 2 2 62 784 58 726 21 0.035 0.019 0.015 3 2 135 1764 42 1722 14 0.057 0.019 0.038 \n4 2 240 3728 131 3597 41 0.075 0.019 0.056 5 2 380 6531 162 6369 40 0.096 0.020 0.076 6 2 558 9984 218 \n9766 56 0.109 0.020 0.089 7 2 777 13467 87 13380 18 0.125 0.020 0.105 8 2 1040 21755 350 21405 86 0.147 \n0.021 0.126 9 2 1350 31031 392 30639 79 0.167 0.020 0.146 10 2 1710 40954 509 40445 105 0.203 0.020 0.183 \n2 3 102 1132 152 980 31 0.051 0.020 0.031 3 3 270 2754 108 2646 20 0.076 0.020 0.055 FileSystem 4 3 560 \n6707 1035 5672 93 0.115 0.021 0.093 5 3 1005 12115 1587 10528 95 0.158 0.022 0.135 6 3 1638 20789 3650 \n17139 170 0.234 0.025 0.209 7 3 2492 21131 496 20635 27 0.266 0.029 0.237 8 3 3600 44059 12226 31833 \n348 0.583 0.037 0.546 2 4 182 1903 442 1461 49 0.065 0.020 0.045 3 4 675 5446 273 5173 21 0.114 0.021 \n0.093 4 4 1840 24672 12443 12229 289 0.324 0.034 0.289 5 4 4130 55614 27500 28114 349 0.935 0.053 0.882 \n2 5 342 3818 1420 2398 83 0.089 0.022 0.067 3 5 1890 13109 765 12344 26 0.243 0.032 0.211 Figure 23. \nExperimental results for glass box model checking.  1I=F 2 3 // Enforce local constraints 4 5 for (all \nnodes N in post-order traversal of tree backbone) { 6 I =I 7 I = Empty set 8 while (I is not empty) { \n9 t = Any transition in I 10 r = repOkLocal holds for t on node N 11 T = Set of all transitions with \nsame repOkLocal behavior 12 I =I -T 13 if(r)I=I+T 14 } 15 } 16 17 // Enforce global constraints 18 19 \nI =I 20 I = Empty set 21 while (I is not empty) { 22 t = Any transition in I 23 r = repOk holds for t \n24 T = Set of all transitions with same repOk behavior 25 I =I -T 26 if(r)I=I+T 27 } Figure 22. Pseudo-code \nfor initializing the search space. This is the expanded version of Line 3 in Figure 17. transition t, \nit computes a formula F denoting (often an ex\u00adponentially large number of) transitions isomorphic to \nt,and prunes F from the search space (often with a small number of BDD operations). Our checker never \nvisits F s transitions. In addition to heap symmetries, our checker also handles other symmetries. In \nparticular, if the actual values of in\u00adtegers in a program do not matter but only their relative ordering \nmatters, our checker prunes states which are sym\u00admetric in the above respect using e.cient BDD operations. \n  3.3.3 Initializing the Search Space This section describes how to execute Lines 2, 3, and 4 in Figure \n17 e.ciently. Line 2 builds a BDD F that represents the search space described by a given .nitization \n(e.g., the search spaces in Figures 12 and 14). It takes linear time. Lines 3 and 4 initialize the search \nspace with the set I of all structures that satisfy the invariant. The pseudo code for constructing the \nset I is shown in Figure 22. First, it initial\u00adizes I to F. It then performs a post-order traversal of \nthe tree backbone of the data structure. Each time it encounters a node N , it constrains I with the \nlocal constraints speci.ed by repOkLocal (Lines 6-14 in Figure 22). Finally, it further constrains I \nwith the global constraints speci.ed by repOk (Lines 19-27 in Figure 22). Note that the above algorithm \nfor initializing the search space is similar to the algorithm for performing the search (Figure 17). \nThe last part of the above algorithm (Lines 19-27 in Fig\u00adure 22) is also similar to our previous work \non Korat [2] for generating all structures satisfying a given global invari\u00adant (repOk), except that \nin this paper we use information .ow tracking to improve the precision of the analysis (Sec\u00adtion 3.3.2.3) \nand we use BDDs to represent the search space which leads to better pruning. (Recall that Korat imposes \na linear order on the search space and keeps all unexplored el\u00adements contiguous at the end of the linear \norder. While this makes the search space management e.cient, it also means that Korat can only prune \na subset of elements its analyses identify, so that all unexplored elements remain contiguous at the \nend. Our checker can prune all the elements its anal\u00adyses identify because it uses BDDs.) The main di.erence \nbetween Korat and our glass box model checker, however, is that Korat ultimately works like a black box \nmodel checker. That is, Korat generates every valid state (within a bounded domain) and checks every \noperation on every state. Our glass box checker, on the other hand, detects redundancies in the state \nspace and prunes away a large number of states and operations on states without explicitly checking them. \nWe present experimental results comparing Korat with glass box model checking in Section 4.  4. Experimental \nResults This section presents our preliminary experimental results. We implemented a rudimentary glass \nbox model checker as described in this paper. We extended the Polyglot [41] com\u00adpiler framework to automatically \ninstrument programs to perform our dynamic analysis (described in Section 3.3.2), and to automatically \ngenerate the .nitization descriptions (described in Section 3.1.5). We used JavaBDD [50] for BDDs, which \nis built on top of the BuDDy package [31]. We performed all our experiments on a Linux Fedora Core 4 \nmachine with a Pentium 4 3.2 GHz processor and 1 GB memory using Sun s Java 1.4.2 08. We present results \nfor the following benchmarks: (a) Stack shown in Figure 8, with methods push and pop;(b) Queue shown \nin Figure 2, implemented using the Stack in Figure 8, with methods enqueue and dequeue;(c) HeapArray \n[8], an array based implementation of a binary heap to represent a priority queue, with methods insert \nand extractMin;(d) Red-BlackTree [8], from java.util.TreeMap, with methods get, put,and remove;and (e) \nFileSystem, adopted from the Daisy .le system benchmark [11], with methods lookup, cre\u00adate, unlink, mkdir,and \nrmdir. For each benchmark, we ran the model checking tools to check that the implementation preserves \nthe data structure invariants. We checked each benchmark on states up to a maximum size, where: a Stack \nof maximum size n has at most n nodes and at most n di.erent non-null values and possibly some null values; \na Queue of maximum size n has at most n nodes in the front Stack, at most n nodes in the back Stack, \nand at most n di.erent non-null values and possibly some null values; a HeapArray of maximum size n has \nat most n nodes and at most n di.erent non-null values; a RedBlackTree of maximum size h has at most \nh height, atmost2h - 1dif\u00adferent keys, and at most 2h - 1 di.erent non-null values and possibly some \nnull values; and a FileSystem of maximum size (h, d) has at most h height and at most d degree, i.e., \neach directory has at most d entries. Figure 23 presents our experimental results. It reports the following \nnumbers for glass box model checking. It shows the number of transitions that are explicitly checked \nby our checker (that is, the number of times the loop in Lines 5-10 Glass Box JPF Benchmark Max Size \nTransitions BDD Nodes Time (s) Transitions States Time (s) 1 4 9 0.016 33 15 0.533 2 5 14 0.016 141 83 \n0.669 3 5 16 0.017 1033 687 1.349 4 5 18 0.017 10949 7819 7.233 5 5 20 0.017 149313 111983 96.529 6 5 \n22 0.017 2471943 1922551 1661.628 7 5 24 0.017 timeout Stack 8 5 26 0.017 timeout 9 5 28 0.017 timeout \n10 ... 5 30 0.017 timeout 16 5 42 0.018 timeout 32 5 74 0.018 timeout 64 5 140 0.020 timeout 128 5 268 \n0.023 timeout 1 5 17 0.019 601 299 1.121 2 7 36 0.020 89756 53852 47.598 3 8 46 0.020 timeout 4 9 61 \n0.020 timeout 5 10 68 0.021 timeout 6 11 75 0.021 timeout Queue 7 12 101 0.021 timeout 8 ... 13 114 0.022 \ntimeout 16 21 272 0.028 timeout 32 37 834 0.050 timeout 64 69 2873 0.086 timeout 128 133 12292 0.118 \ntimeout 1 4 9 0.016 19 7 0.434 2 7 58 0.016 133 67 0.521 3 11 245 0.018 1816 1090 1.464 4 17 565 0.019 \n39565 26377 15.184 5 24 2053 0.022 timeout 6 34 4398 0.029 timeout HeapArray 7 45 9032 0.035 timeout \n8 57 16621 0.045 timeout 9 70 55382 0.080 timeout 10 86 81364 0.114 timeout 11 103 145832 0.198 timeout \n12 122 254985 0.318 timeout 13 142 556949 0.647 timeout 14 165 1344220 2.098 timeout Max Height RedBlackTree \n1 2 3 4 5 6 7 6 28 108 366 1094 2968 7524 28 493 3860 24400 128314 781369 6263228 0.022 0.028 0.066 0.134 \n0.340 1.543 10.340 49 19 0.617 timeout timeout timeout timeout timeout timeout Max Height / Max Degree \nMax Height 2 2 62 784 0.035 12901 7482 6.883 3 2 135 1764 0.057 timeout 4 2 240 3728 0.075 timeout 5 \n2 380 6531 0.096 timeout 6 2 558 9984 0.109 timeout 7 2 777 13467 0.125 timeout FileSystem 8 2 1040 21755 \n0.147 timeout 9 2 1350 31031 0.167 timeout 10 2 1710 40954 0.203 timeout 2 3 102 1132 0.051 timeout 3 \n3 270 2754 0.076 timeout 4 3 560 6707 0.115 timeout 5 3 1005 12115 0.158 timeout Figure 24. Comparing \nglass box model checking to JPF.  Glass Box Black Box Black Box With Abstraction Benchmark Max Size \nTransitions BDD Nodes Time (s) Transitions States Time (s) Transitions States Time (s) 1 4 9 0.016 9 \n3 0.008 4 2 0.010 2 5 14 0.016 32 8 0.009 6 3 0.009 3 5 16 0.017 115 23 0.012 8 4 0.009 4 5 18 0.017 \n450 75 0.030 10 5 0.008 5 5 20 0.017 1946 278 0.067 12 6 0.009 6 5 22 0.017 9240 1155 0.137 14 7 0.009 \n7 5 24 0.017 47655 5295 0.437 16 8 0.009 Stack 8 5 26 0.017 264420 26442 2.242 18 9 0.009 9 5 28 0.017 \n1566587 142417 15.648 20 10 0.009 10 ... 5 30 0.017 9851844 820987 105.304 22 11 0.009 16 5 42 0.018 \ntimeout 34 17 0.012 32 5 74 0.018 timeout 66 33 0.026 64 5 140 0.020 timeout 130 65 0.041 128 5 268 0.023 \ntimeout 258 129 0.098 1 5 17 0.019 27 9 0.011 8 4 0.011 2 7 36 0.020 356 89 0.044 18 9 0.012 3 8 46 0.020 \n6610 1322 0.161 32 16 0.014 4 9 61 0.020 176430 29405 2.126 50 25 0.016 5 10 68 0.021 6330912 904416 \n92.334 72 36 0.019 6 11 75 0.021 timeout 98 49 0.025 Queue 7 12 101 0.021 timeout 128 64 0.029 8 ... \n13 114 0.022 timeout 162 81 0.036 16 21 272 0.028 timeout 578 289 0.069 32 37 834 0.050 timeout 2178 \n1089 0.211 64 69 2873 0.086 timeout 8450 4225 1.231 128 133 12292 0.118 timeout 33282 16641 11.148 1 \n4 9 0.016 4 2 0.007 4 2 0.007 2 7 58 0.016 18 6 0.008 18 6 0.008 3 11 245 0.018 96 24 0.013 96 24 0.013 \n4 17 565 0.019 550 110 0.035 550 110 0.035 5 24 2053 0.022 3984 664 0.088 3984 664 0.088 6 34 4398 0.029 \n31605 4515 0.284 31605 4515 0.284 HeapArray 7 45 9032 0.035 333568 41696 2.382 333568 41696 2.382 8 57 \n16621 0.045 3101139 344571 25.261 3101139 344571 25.261 9 70 55382 0.080 timeout timeout 10 86 81364 \n0.114 timeout timeout 11 103 145832 0.198 timeout timeout 12 122 254985 0.318 timeout timeout 13 142 \n556949 0.647 timeout timeout 14 165 1344220 2.098 timeout timeout RedBlackTree 1 2 3 4 5 6 7 6 28 108 \n366 1094 2968 7524 28 493 3860 24400 128314 781369 6263228 0.022 0.028 0.066 0.134 0.340 1.543 10.340 \n12 936 18143370 3 52 259191 0.013 0.084 431.682 timeout timeout timeout timeout 6 99 11781 2 11 561 0.012 \n0.020 0.298 timeout timeout timeout timeout Max Height / Max Degree Max Height 2 2 62 784 0.035 570 \n19 0.045 210 7 0.032 3 2 135 1764 0.057 14820 247 0.201 900 15 0.063 4 2 240 3728 0.075 552900 5529 6.267 \n3100 31 0.117 5 2 380 6531 0.096 timeout 9450 63 0.226 6 2 558 9984 0.109 timeout 26670 127 0.569 7 2 \n777 13467 0.125 timeout 71400 255 1.682 FileSystem 8 2 1040 21755 0.147 timeout 183960 511 5.088 9 2 \n1350 31031 0.167 timeout 460350 1023 15.066 10 2 1710 40954 0.203 timeout 1125850 2047 40.609 2 3 102 \n1132 0.051 222670 3181 2.573 5110 73 0.147 3 3 270 2754 0.076 timeout 851955 4369 18.740 4 3 560 6707 \n0.115 timeout timeout 5 3 1005 12115 0.158 timeout timeout Figure 25. Comparing glass box model checking \nto black box model checking.  Glass Box Korat Benchmark Max Size Transitions BDD Nodes Time (s) Transitions \nStates Considered Time (s) 1 4 9 0.016 6 7 0.001 2 5 14 0.016 9 12 0.001 3 5 16 0.017 12 18 0.000 4 5 \n18 0.017 15 25 0.001 5 5 20 0.017 18 33 0.001 6 5 22 0.017 21 42 0.001 7 5 24 0.017 24 52 0.001 Stack \n8 5 26 0.017 27 63 0.002 9 5 28 0.017 30 75 0.002 10 ... 5 30 0.017 33 88 0.003 16 5 42 0.018 51 187 \n0.007 32 5 74 0.018 99 627 0.018 64 5 140 0.020 195 2275 0.053 128 5 268 0.023 387 8643 0.259 1 5 17 \n0.019 12 15 0.001 2 7 36 0.020 27 39 0.001 3 8 46 0.020 48 78 0.002 4 9 61 0.020 75 135 0.005 5 10 68 \n0.021 108 213 0.007 6 11 75 0.021 147 315 0.010 Queue 7 12 101 0.021 192 444 0.015 8 ... 13 114 0.022 \n243 603 0.019 16 21 272 0.028 867 3315 0.059 32 37 834 0.050 3267 21219 0.363 64 69 2873 0.086 12675 \n149955 3.972 128 133 12292 0.118 49923 1123203 57.416 1 4 9 0.016 4 4 0.000 2 7 58 0.016 18 19 0.001 \n3 11 245 0.018 96 106 0.001 4 17 565 0.019 550 643 0.006 5 24 2053 0.022 3984 4606 0.023 6 34 4398 0.029 \n31605 36692 0.128 HeapArray 7 45 9032 0.035 333568 370714 0.879 8 57 16621 0.045 3101139 3579511 10.852 \n9 70 55382 0.080 36626580 41004532 95.155 10 86 81364 0.114 429394636 483881209 1356.158 11 103 145832 \n0.198 timeout 12 122 254985 0.318 timeout 13 142 556949 0.647 timeout 14 165 1344220 2.098 timeout Figure \n26. Comparing glass box model checking to Korat.  RedBlackTree 1 2 3 4 5 6 7 6 28 108 366 1094 2968 \n7524 28 493 3860 24400 128314 781369 6263228 0.022 0.028 0.066 0.134 0.340 1.543 10.340 8 144 16044 155496600 \n14 460 105779 1236548801 0.017 0.035 0.858 16023.741 timeout timeout timeout in Figure 17 is executed). \nIt shows the number of BDD nodes created, as a measure of the search space management over\u00adhead. It also \nshows the time taken by our checker. Note that we did not yet optimize the execution time of our checker, \nbut we report it here nonetheless to provide a rough idea. For the number of BDD nodes created and the \ntime taken, the .gure shows the totals as well as the numbers separately for the initialization phase \n(Lines 2-4 in Figure 17) and the checking phase (Lines 5-10 in Figure 17). Finally, the .gure also shows \nthe maximum size of the BDD representing the search space (set S in Figure 17). Note that in Figure 23, \nfor checking the Stack, our glass box checker checks only O(1) transitions regardless of the size of \nthe Stack. This is because push and pop touch only a con\u00adstant number of .elds at the beginning of the \nlinked list. For checking the Queue, our glass box checker checks O(n)tran\u00adsitions, as explained in Section \n2.2. For the HeapArray and the RedBlackTree, the growth in the number of transitions appears to be roughly \nO(n 2)(where n is the maximum size of the HeapArray and h =log n is the maximum height of the RedBlackTree). \nHowever, for the HeapArray, the search space management overhead dominates the cost. We are currently \nexploring other search space representation tech\u00adniques (e.g., an incremental SAT solver) to see if our \nsearch space management overhead can be further reduced. Figure 24 presents results of comparing the \nperformance of our glass box model checker with JPF [48] (version 4). For JPF, we wrote a test harness \nfor each benchmark and we marked all the methods in the benchmarks to be atomic (because the benchmarks \nare all single threaded programs). We report the number of transitions explicitly checked by JPF, as \nwell as the number of unique states visited within the .nite bounds (as a measure of the space overhead, \nas JPF is a stateful checker). We timeout if the tool runs out of memory or if it takes too long. The \nresults show how JPF takes exponentially more time as the size of the structures increases. Our glass \nbox checker scales much better. While running experiments with JPF, we noticed that JPF sometimes does \nnot detect that two states are isomorphic, perhaps because of their di.erent memory layouts. It there\u00adfore \nvisits a lot more states than necessary. To make for a fairer comparison, we implemented our own black \nbox checker that accurately detects heap isomorphisms. Fig\u00adure 25 presents results of comparing the performance \nof our glass box model checker with our black box model checker. The results clearly indicate that glass \nbox model checking scales signi.cantly better than black box model checking. We also extended our black \nbox model checker such that if programmers implement an abstraction function [51, 43], then our checker \ntreats all concrete states that map to the same abstract state as isomorphic (in addition to detecting \nheap isomorphisms). (Abstraction functions can thus speed up model checking but require manual assistance \nand are error-prone.) We handcoded an abstraction function for each of our benchmarks. For Stack, Queue,and \nRedBlackTree, the abstraction function ignores the value .elds because the invariants of the above data \nstructures do not depend on the values.For the FileSystem benchmark, the general pur\u00adpose heap isomorphism \ndetector does not work well because FileSystem uses array indices instead of pointers our ab\u00adstraction \nfunction for FileSystem maps all such isomorphic concrete states into the same abstract state. Figure \n25 also presents results of comparing the performance of our glass box model checker with our black box \nmodel checker with abstraction functions. Once again, the results clearly indi\u00adcate that glass box model \nchecking scales much better. Finally, Figure 26 presents the results of comparing our glass box model \nchecker with Korat [2]. We report the number of transitions explicitly checked by Korat. We also report \nthe number of candidate states considered by Korat, which includes both transitions checked by Korat \n(such as Fig\u00adure 15) and invalid states considered by the Korat (such as Figure 16). We could not run \nKorat on the FileSystem benchmark because the Korat infrastructure does not yet support multidimensional \narrays. The results show that our glass box checker scales much better that Korat. A version of JPF [28] \nuses lazy initialization of .elds to es\u00adsentially simulate the Korat algorithm. Its asymptotic per\u00adformance \nis similar to that of Korat. However, because JPF is a general purpose model checker, it has higher overhead \nandisslowerthanKorat. Wethereforeexpectour glassbox checker to similarly scale better than [28].  5. \nRelated Work There are many model checking tools that exhaustively test a program on all possible inputs \nup to a given size (to han\u00addle input nondeterminism) and on all possible nondeter\u00administic schedules \n(to handle scheduling nondeterminism). Verisoft [15] is a stateless model checker for C programs. Java \nPathFinder (JPF) [48, 28] is a stateful model checker for Java programs. XRT [20] checks Microsoft CIL \npro\u00adgrams. Bandera [7] and JCAT [9] translate Java programs into the input language of model checkers \nlike SPIN [22] and SMV [34]. Bogor [12] provides an extensible framework for building software model \ncheckers. CMC [39] is a stateful model checker for C programs that has been used to test large pieces \nof software including the Linux implementation of TCP/IP and the ext3 .le system [38]. However, most \nof the above work on applying model checking to software fo\u00adcuses on control oriented programs and properties, \nprimarily to verify event sequences with respect to temporal proper\u00adties. This paper, in contrast, focuses \non data oriented (and single threaded) programs and properties. There has been much research on techniques \nfor reducing the state space of a model checker. Tools such a Slam [1], Blast [21], and Magic [4] use \nheuristics to construct and check an abstraction of a program (usually predicate ab\u00adstraction [19]). \nAbstractions that are too coarse generate false positives, which are then used to re.ne the abstraction \nand redo the checking. This technique is known as Counter Example Guided Abstraction and Re.nement, or \nCEGAR. There are also many static [15, 16] and dynamic [13] par\u00adtial order reduction systems for concurrent \nprograms. There are many other symmetry-based reduction techniques as well (e.g., [25]). However, it \nis unclear how any of the above tech\u00adniques can be used to signi.cantly reduce the state space of data \noriented programs such as a .le system implementation or a balanced tree implementation. We believe CEGAR, \npar\u00adtial order reduction, and other techniques are complimentary to our glass box approach. Thereisalargebodyofresearchonspeci.cation-basedtest\u00ading. \nAn early paper [18] emphasizes its importance. Many projects automate test case generation from speci.cations, \nsuch as Z speci.cations [23], UML statecharts [42], or ADL speci.cations [5]. These speci.cations typically \ndo not con\u00adsider data structures that use pointers, and the tools do not generate Java test cases. Tools \nsuch as Alloy [26, 27] and Korat [2, 33] systematically generate all inputs that satisfy a given precondition. \nA ver\u00adsion of JPF [28] uses lazy initialization of .elds to essentially simulate the Korat algorithm. \nHowever, these tools work as black box checkers because they generate and test every valid state, unlike \nour glass box checker. (Section 4 compares the performance of such systems with our glass box checker.) \nJalloy [47] translates a Java program and its speci.cations into a SAT formula and uses a constraint \nsolver to check the program. [28] extends Korat by treating integers symboli\u00adcally. Symstra [52] also \ntreats some integers symbolically. Tools such as CUTE [45, 17] and a version of JPF [49] use constraint \nsolvers to obtain complete branch coverage (or complete path coverage on paths up to a given length) \nfor testing data structures. However, this approach does not guarantee that an implementation works correctly \non all data structures up to a given size. For example, a buggy tree insertion method that does not rebalance \nthe tree might work correctly on a set of test cases that exercise complete branch (or .nite path) coverage, \nbut fail on a di.erent test case that makes the tree unbalanced. Therefore, it seems to us that this \napproach is more suitable for checking control dependent properties rather than data dependent properties. \nESC/Java [14] uses a theorem prover to verify absence of such errors as null pointer dereferences and \narray bounds violations. Static analyses such as TVLA [44] and PALE [36] o.er a promising approach for \nverifying shape properties of data structures. However, none of the above techniques are currently practical \nenough to verify, say, the correctness of implementations of balanced trees, such as red-black trees. \nSoftware model checking, on the other hand, is a general approach that can verify any decidable property, \nbut for inputs bounded by a given size. 6. Conclusions This paper presents a novel approach to software \nmodel checking of data structure properties. Most previous work on software model checking focuses on \ncontrol oriented pro\u00adgrams and properties, primarily to verify event sequences with respect to temporal \nproperties. This paper, in contrast, focuses on data oriented programs and properties. In par\u00adticular, \nit deals with verifying properties of data structures. While there is much research on state space reduction \ntech\u00adniques for model checkers such as partial order reduction [13, 15, 16] and tools based on predicate \nabstraction [19] such as Slam [1], Blast [21], or Magic [4], none of these techniques seem to be e.ective \nin reducing the state space of data ori\u00adented programs. The paper presents novel techniques for de\u00adtecting \nsimilarities in the state space of data structures, and for soundly pruning large numbers of redundant \nstates and operations without explicitly checking them. It also presents novel techniques for e.ciently \nmanaging extremely large sets of data structures. This results in dramatic speedups. We do not know of \nany other model checker that scales nearly as well for checking linked data structures. We believe our \ntechniques can make software model checking signi.cantly faster, and thus enable checking of much larger \nprograms and complex program properties than currently possible. Acknowledgments We thank Sarfraz Khurshid, \nDarko Marinov, Madan Musu\u00advathi, and the anonymous referees for their useful comments. References [1] \nT. Ball, R. Majumdar, T. Millstein, and S. K. Rajamani. Automatic predicate abstraction of C programs. \nIn Programming Language Design and Implementation (PLDI), June 2001. [2] C. Boyapati, S. Khurshid, and \nD. Marinov. Korat: Automated testing based on Java predicates. In International Symposium on Software \nTesting and Analysis (ISSTA), July 2002. Winner of an ACM SIGSOFT distinguished paper award. [3] R. E. \nBryant. Symbolic boolean manipulation with ordered binary decision diagrams. ACM Computing Surveys 24(3), \n1992. [4] S. Chaki, E. Clarke, A. Groce, S. Jha, and H. Veith. Modular veri.cation of software components \nin C. In International Conference on Software Engineering (ICSE), June 2003. [5] J. Chang and D. J. Richardson. \nStructural speci.cation-based testing: Automated support and experimental evaluation. In Foundations \nof Software Engineering(FSE), September 1999. [6] E. M. Clarke, O. Grumberg, and D. A. Peled. Model \nChecking. MIT Press, 1999. [7] J. Corbett, M. Dwyer, J. Hatcli., C. Pasareanu, Robby, S. Laubach, and \nH. Zheng. Bandera: Extracting .nite-state models from Java source code. In International Conference on \nSoftware Engineering(ICSE), June 2000. [8] T. H. Cormen, C. E. Leiserson, and R. L. Rivest. Introduction \nto Algorithms. MIT Press, 1991. [9] C. DeMartini, R. Iosif, and R. Sisto. A deadlock detection tool \nfor concurrent Java programs. Software Practice and Experience(SPE) 29(7), June 1999. [10] D. E. Denning \nand P. J. Denning. Certi.cation of programs for secure information .ow. In Communications of the ACM(CACM) \n20(7), July 1977. [11] Daisy .le system. Joint CAV/ISSTA Special Event on Speci.cation, Veri.cation, \nand Testing of Concurrent Software. http://research.microsoft.com/~qadeer/cav-issta.htm. [12] M. Dwyer, \nJ. Hatcli., M. Hoosier, and Robby. Building your own software model checker using the Bogor extensible \nmodel checking framework. In Computer Aided Veri.cation (CAV), January 2005. [13] C. Flanagan and P. \nGodefroid. Dynamic partial-order reduction for model checking software. In Principles of Programming \nLanguages (POPL), January 2005. [14] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, \nand R. Stata. Extended static checking for Java. In Programming Language Design and Implementation (PLDI), \nJune 2002. [15] P. Godefroid. Model checking for programming languages using VeriSoft. In Principles \nof Programming Languages (POPL), January 1997. [16] P. Godefroid. Partial-order methods for the veri.cation \nof concurrent systems An approach to the state-explosion problem. LectureNotes in Computer Science(LNCS) \n1032, Springer-Verlag, January 1996. [17] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed automated \nrandom testing. In Programming Language Design and Implementation (PLDI), June 2005. [18] J. Goodenough \nand S. Gerhart. Toward a theory of test data selection. IEEE Transactions on Software Engineering (TSE) \nSE-1(2), June 1975. [19] S. Graf and H. Saidi. Construction of abstract state graphs with PVS. In Computer \nAided Veri.cation (CAV), June 1997. [20] W. Grieskamp, N. Tillmann, and W. Shulte. XRT Exploring runtime \nfor .NET: Architecture and applications. In Workshop on Software Model Checking (SoftMC), July 2005. \n[21] T. A. Henzinger, R. Jhala, and R. Majumdar. Lazy abstraction. In Principles of Programming Languages \n(POPL), January 2002. [22] G. Holzmann. The model checker SPIN. Transactions on Software Engineering(TSE) \n23(5), May 1997. [23] H.-M. Horcher. Improving software tests using Z speci.cations. In International \nConference of Z Users, September 1995. [24] R. Iosif. Symmetry reduction criteria for software model \nchecking. In SPIN workshop on Model Checking of Software (SPIN), April 2002. [25] C. N. Ip and D. Dill. \nBetter veri.cation through symmetry. In Computer Hardware Description Languages, April 1993. [26] D. \nJackson. Alloy: A lightweight object modeling notation. Transactions on Software Engineering and Methodology \n(TOSEM) 11(2), April 2002. [27] S. Khurshid and D. Marinov. TestEra: Speci.cation-based testing of Java \nprograms using SAT. In Automated Software Engineering(ASE), November 2001. [28] S. Khurshid, C. S. Pasareanu, \nand W. Visser. Generalized symbolic execution for model checking and testing. In Tools and Algorithms \nfor Construction and Analysis of Systems (TACAS), April 2003. [29] B. Korel and J. Laski. Dynamic program \nslicing. In Information Processing Letters (IPL) 29(3)s, October 1988. [30] G. T. Leavens, A. L. Baker, \nand C. Ruby. Preliminary design of JML: A behavioral interface speci.cation language for Java. Technical \nReport TR 98-06i, Department of Computer Science, Iowa State University, May 1998. [31] J. Lind-Nielsen. \nBuDDy. http://sourceforge.net/projects/buddy. [32] B. Liskov and J. Guttag. Abstraction and Speci.cation \nin Program Development. MIT Press, 1986. [33] D. Marinov. Automatic testing of software with structurally \ncomplex inputs. Ph.D. thesis, Massachusetts Institute of Technology, February 2005. [34] K. McMillan. \nSymbolic Model Checking.KluwerAcademic Publishers, 1993. [35] S. McPeak and G. C. Necula. Data structure \nspeci.cation via local equality axioms. In Computer Aided Veri.cation (CAV), January 2005. [36] A. Moeller \nand M. I. Schwartzbach. The pointer assertion logic engine. In Programming Language Design and Implementation \n(PLDI), June 2001. [37] M. Musuvathi and D. Dill. An incremental heap canonicalization algorithm. In \nSPIN workshop on Model Checking of Software (SPIN), August 2005. [38] M. Musuvathi and D. R. Engler. \nUsing model checking to .nd serious .le system errors. In Operating System Design and Implementation \n(OSDI), December 2004. Winner of the best paper award. [39] M. Musuvathi, D. Y. W. Park, A. Chou, D. \nR. Engler, and D. Dill. CMC: A pragmatic approach to model checking real code. In Operating System Design \nand Implementation (OSDI), December 2002. [40] A. C. Myers. JFlow: Practical mostly-static information \n.ow control. In Principles of Programming Languages (POPL), January 1999. [41] N. Nystrom, M. R. Clarkson, \nand A. C. Myers. Polyglot: An extensible compiler framework for Java. In Compiler Construction (CC), \nApril 2003. [42] J. O.utt and A. Abdurazik. Generating tests from UML speci.cation. In International \nConference on the Uni.ed Modeling Language, October 1999. [43] C. Pasareanu, R. Pelanek, and W. Visser. \nTest input generation for red black trees using abstraction. In Automated Software Engineering (ASE), \nNovember 2005. [44] M. Sagiv, T. Reps, and R. Wilhelm. Solving shape-analysis problems in languages with \ndestructive updating. Transactions on Programming Languages and Systems (TOPLAS) 20(1), January 1998. \n[45] K. Sen, D. Marinov, and G. Agha. CUTE: A concolic unit testing engine for C. In European Software \nEngineering Conference and Foundations of Software Engineering (ESEC/FSE), September 2005. [46] D. Suwimonteerabuth, \nS. Schwoon, and J. Esparza. jMoped: A Java bytecode checker based on Moped. In Tools and Algorithms for \nConstruction and Analysis of Systems (TACAS), April 2005. [47] M. Vaziri and D. Jackson. Checking properties \nof heap-manipulating procedures using a constraint solver. In Tools and Algorithms for Construction and \nAnalysis of Systems (TACAS), April 2003. [48] W. Visser, K. Havelund, G. Brat, and S. Park. Model checking \nprograms. In Automated Software Engineering (ASE), September 2000. [49] W. Visser, C. S. Pasareanu, and \nS. Khurshid. Test input generation with Java PathFinder. In International Symposium onSoftwareTesting \nandAnalysis(ISSTA), July 2004. [50] J. Whaley. JavaBDD. http://javabdd.sourceforge.net/. [51] T. Xie, \nD. Marinov, and D. Notkin. Rostra: A framework for detecting redundant object-oriented unit tests. In \nAutomated Software Engineering (ASE), September 2004. [52] T. Xie, D. Marinov, W. Schulte, and D. Notkin. \nSymstra: A framework for generating object-oriented unit tests using symbolic execution. In Tools and \nAlgorithms for Construction and Analysis of Systems (TACAS), April 2005. [53] X. Zhang and R. Gupta. \nCost e.ective dynamic program slicing. In Programming Language Design and Implementation (PLDI), June \n2004.  \n\t\t\t", "proc_id": "1167473", "abstract": "This paper presents novel language and analysis techniques that significantly speed up software model checking of data structure properties. Consider checking a red-black tree implementation. Traditional software model checkers systematically generate all red-black tree states (within some given bounds) and check every red-black tree operation (such as insert, delete, or lookup) on every red-black tree state. Our key idea is as follows. As our checker checks a red-black tree operation <i>o</i> on a red-black tree state <i>s</i>, it uses program analysis techniques to identify other red-black tree states <i>s'<sub>1</sub></i>, <i>s'<sub>2</sub></i>, ..., <i>s'<sub>k</sub></i> on which the operation <i>o</i> behaves similarly. Our analyses guarantee that if <i>o</i> executes correctly on <i>s</i>, then <i>o</i> will execute correctly on every <i>s'<sub>i</sub></i>. Our checker therefore does not need to check <i>o</i> on any <i>s'<sub>i</sub></i> once it checks <i>o</i> on <i>s</i>. It thus safely prunes those state transitions from its search space, while still achieving complete test coverage within the bounded domain. Our preliminary results show <i>orders of magnitude improvement</i> over previous approaches. We believe our techniques can make model checking significantly faster, and thus enable checking of much larger programs and complex program properties than currently possible.", "authors": [{"name": "Paul T. Darga", "author_profile_id": "81100650543", "affiliation": "University of Michigan, Ann Arbor, MI", "person_id": "P676843", "email_address": "", "orcid_id": ""}, {"name": "Chandrasekhar Boyapati", "author_profile_id": "81319488571", "affiliation": "University of Michigan, Ann Arbor, MI", "person_id": "PP18004119", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167504", "year": "2006", "article_id": "1167504", "conference": "OOPSLA", "title": "Efficient software model checking of data structure properties", "url": "http://dl.acm.org/citation.cfm?id=1167504"}