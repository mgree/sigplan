{"article_publication_date": "10-16-2006", "fulltext": "\n A Formal Framework for Component Deployment Yu David Liu Scott F. Smith Department of Computer Science \nThe Johns Hopkins University {yliu, scott}@cs.jhu.edu Abstract Software deployment is a complex process, \nand industrial-strength frameworks such as .NET, Java, and CORBA all provide explicit support for component \ndeployment. However, these frameworks are not built around fundamental principles as much as they are \nengineering efforts closely tied to particulars of the respective sys\u00adtems. Here we aim to elucidate \nthe fundamental principles of soft\u00adware deployment, in a platform-independent manner. Issues that need \nto be addressed include deployment unit design, when, where and how to wire components together, versioning, \nversion depen\u00addencies, and hot-deployment of components. We de.ne the appli\u00adcation buildbox as the place \nwhere software is developed and de\u00adployed, and de.ne a formal Labeled Transition System (LTS) on the \nbuildbox with transitions for deployment operations that in\u00adclude build, install, ship, and update. We \nestablish formal properties of the LTS, including the fact that if a component is shipped with a certain \nversion dependency, then at run time that dependency must be satis.ed with a compatible version. Our \ntreatment of deploy\u00adment is both platform-and vendor-independent, and we show how it models the core \nmechanisms of the industrial-strength deploy\u00adment frameworks. Categories and Subject Descriptors D.3.1 \n[Programming Lan\u00adguages]: Formal De.nitions and Theory; D.2.7 [Software Engi\u00adneering]: Version Control \nGeneral Terms Languages, Design, Theory Keywords Application Buildbox, Deployment, Component, Ver\u00adsion \n 1. Introduction In [44], Szyperski presents the three de.ning properties of soft\u00adware components; his \n.rst property is that they serve as units of independent deployment. This aspect has attracted far less \nattention from the research community than his other two properties (that components are units of composition \nand units of state encapsula\u00adtion). Make no mistake, component deployment is a complex pro\u00adcess which \nmust be carefully thought out if correct software behav\u00adior is to be achieved: an Enterprise JavaBean \n[17] might be tested in one container and then deployed in a different container that is incompatible \nwith the bean; the same Java application might dis- Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 06 October 22 26, 2006, Portland, Oregon, USA. Copyright \nc . 2006 ACM 1-59593-348-4/06/0010. . . $5.00 play different run-time behaviors on sites with different \nsettings of CLASSPATH to locate dependency components; updating a Win\u00addows DLL when installing an application \nmight cause other ap\u00adplications dependent on it to exhibit erratic behaviors; and, with dynamic plugins, \ncomponents can also be deployed into a running application. The manner in which industry has responded \nto these problems is a barometer of real-world need for elegant and rigorous mod\u00adels of deployment: numerous \ntools [18, 40, 12, 25, 10, 11, 43] have been designed to support component deployment, and the .NET, \nJava and CORBA platforms de.ne how software compo\u00adnents should be deployed [32, 17, 36]. These industrial \nsolutions provide workable systems that users can directly use, but along with this strength comes a \nweakness: to ensure correct functional\u00adity on a particular platform, these solutions are highly embedded \nin platform-speci.c details, such as .le system structures, envi\u00adronment variables, scripts, middleware \narchitectures, and program\u00adming language models. The speci.cations are also informal, and so no properties \ncan be rigorously guaranteed. For tool-based ap\u00adproaches, non-trivial issues such as dependency resolution \nare sub\u00admerged in the code. The best way to understand them in some cases is to run the tools and see \nwhat happens! So, we believe there is a real need for the formal study of the component deployment prob\u00adlem. \n1.1 This Work In this paper, we elucidate the fundamental principles of software deployment, in a platform-independent \nmanner. Despite its com\u00adplexity, software deployment is known to follow a lifecycle where common activities \nare shared [22, 37]: release from the develop\u00adment site (shipping), unpacking at the deployment site \n(installa\u00adtion), recon.guring at the deployment site in response to changes (update), and activating \nthe application into a usable state (execu\u00adtion). Is there a common core that a good deployment system \nshould have regardless of the choice of the platform? Is there a fun\u00addamental and precise notion about \nwhat a shipment package should contain, what it means to be a good software update, and what de\u00adployments \nwill not violate version compatibility? We answer these questions by coming up with an abstract formalization. \nOur goal is for these results to give researchers a basis to reason about de\u00adployment, and guide future \ndeployment tool developers to come up with systems with well-de.ned operations that have provable cor\u00adrectness \nproperties. This paper also indirectly sheds light on component design, from the perspective of what \nkind of component model is best\u00adsuited for deployment. By focusing primarily on this property here, this \npaper extends our past studies, from different perspectives, of component dependency and linking [42, \n27, 28]. Linking especially its theoretical foundations and type properties has been extensively studied \nand well-understood [6, 19, 20, 14, 13]. However, previous studies do not adequately take into account \nthe when and where of linking: Does it happen at build time, installation time, or run time? Does it \nhappen on the development site or the deployment site? If the software is .rst linked at the development \nsite, and then some of its dependencies are relinked at the deployment site, are these new dependencies \ncompatible with those at the development site? 1.2 Goals and Contributions The main contributions of \nour framework can be grouped into four categories, each of which addresses a principal design goal of \nthe framework: Expressiveness. The framework addresses the entire lifecycle of application evolution, \nspanning both the development site and deployment site, and covering both how applications evolve statically \nas well as dynamically. A more detailed discussion on the framework features is given in Sec. 2.  Generality. \nOur treatment of component deployment is both platform-and vendor-independent, and models the core mech\u00adanisms \nof existing deployment models found in Microsoft products (DLLs, COM[33], CLI Assemblies[32]), Unix/Linux \n(package installers[18, 12, 40]), Java (EJB[17], Classloaders) and middleware infrastructures (CORBA \nCCM[36]). Sec. 5 de\u00adtails how our framework can be related to different platforms. Although our framework \ndoes not capture every feature in ev\u00adery existing deployment model, it offers a more principled way to \nimplement their core features.  Correctness. We give the .rst known proof of version compat\u00adibility \nin a software deployment context, which states that if a component is shipped with a certain version \nrequirement for its dependencies, then at run time the dependency must be satis\u00ad.ed with a compatible \nversion. Our framework also provides a formal notion of application well-formedness, and we prove the \nframework is robust enough to preserve well-formedeness during application evolution. This topic is elaborated \nin Sec. 4.  Simplicity. Our framework provides a foundational model of the core issues of deployment \nsuch as evolution, naming and versioning. Because it is simple, it will be possible to use it as a basis \nfor studying more advanced deployment features such as security and transaction control.   2. Informal \nOverview In this section, we informally explain the core ideas of our frame\u00adwork. A few design decisions \nare also discussed. 2.1 Core Concepts 2.1.1 The Component Model: Assemblages Software components in \nour framework are called assemblages. Each assemblage is a named, versioned, independently shippable \nand independently deployable code unit. This abstraction can be mapped to any form of real-world deployment \nunit, for example an EJB component, a Java .class .le, an Eclipse plugin, or a C dy\u00adnamic linking library. \n(A non-example is the typical use of the C .o .le on Unix platforms: it is not an independent unit since \nit relies on linking at the development site before shipment and deployment.) Our goal is to construct \na model which elegantly captures the key features of the widely known deployment models; after presenting \nthe technical details we will make a detailed comparison with these models to show how we meet this goal. \nEach assemblage may be equipped with two kinds of inter\u00adfaces, mixers and pluggers. Both mixers and pluggers \nare named interfaces which can not only export features de.ned inside the assemblage implementation body \nto other assemblages, but also can import features from other assemblages. Our framework does not make \nassumptions on the format of the features themselves; they may be functions, classes, or other structures. \nFor convenience here, we often will use functions as examples. We will explain the difference between \nmixers and pluggers soon, in Sec.2.1.2. A sim\u00adple assemblages example is given in Fig. 1(a), showing \na browsing tool that is wrapped up as an independent deployment unit. It has the name Browser, and version \nidenti.er v2.  The component model introduced here is based on the module construct of our previous \nAssemblages project [27]. Despite the shared structural similarity, the goal of this work is very different \nfrom the original calculus, where type safety was the focus. Since we have previously addressed typing \nissues, we ignore them in this paper for simplicity.  2.1.2 The Component Wires: Mixing and Plugging \nComponent-based applications are commonly viewed as a number of individual components wired together \n[44], where wiring indi\u00adcates name binding. What matters in a deployment context is when the wires are \nestablished. The watershed event in a component life\u00adtime is load time, when the component turns from \na piece of state\u00adless code to a potentially stateful and executable runtime form. We call a wire established \nbefore the two wired components go through this watershed event a mixing wire (or sometimes simply a \nmixing), and for a wire established after that a plugging wire (or sometimes simply a plugging). In Fig. \n1(b), there is a mixing wire between the networking library NetLib assemblage and the Browser as\u00adsemblage, \nand its nature indicates the wire is established before the browser is up and running1. In Fig. 1(c), \nthere is a plugging wire between the Browser and the Flash dynamic plugin. Such a wire is established \nafter the browser has been launched. From an assemblage writer s perspective, declaring a mixer sig\u00adni.es \na willingness to establish a wire before it is loaded, while declaring a plugger signi.es a desire to \nestablish a wire after load\u00ading. A mixing wire binds together a pair of mixers, one from each wired party, \nso that the imports from one mixer can be satis.ed by the exports from the other. A plugging wire is \nthe same as a mixing wire, except it binds together a plugger of an assemblage already loaded and a mixer \nof an assemblage to be loaded as a result of plugging. The use of a mixer here may sound odd, but it \nindicates the desire of the assemblage being plugged in: Flash as a plugin in fact desires its names \ninside Brw interface be resolved the minute it is loaded, not after.  2.1.3 Evolution and Application \nBuildbox The study of deployment leads to the study of application evolution. The components forming \nthe application are .rst deployed one by one, then the wires between them are formed, and then perhaps \nsome components will be updated independently, and eventually the application is launched into the runtime \nform. In our framework, this application in .ux , i.e. a snapshot of the evolution process where some \ncomponents of the application are yet to be deployed and some wires are yet to be established, is evolving \nin an imaginary box called an application buildbox,or simply a buildbox. The buildbox is illustrated \nin Fig. 1(b). Three assemblages are currently in the buildbox, with two of them being two different versions \nof the same named assemblage NetLib. When the buildbox contains all the components the application needs \nand all the wires are established, we say an application 1 Our term mixing is sometimes called static \nlinking in the literature. We are cautious in using that term, however, because it is overloaded in the \nC context, where it refers to the linking of .o object .les. Mixing is analogous to the case in C where \nan a.out .le is linked to its dynamic linking library (.so .les), an action due to the technicalities \nof the platforms called dynamic linking in C terminology. is formed. The buildbox naturally captures \nthe evolving nature of component-based software development and deployment, and serves as a useful mechanism \nfor modeling the process. After the application is formed, it can be launched and be turned into a stateful \nand executable application runtime.Fig. 1(c)shows a snapshot of an application runtime, which contains \na collection of running assemblages, called assemblage runtimes. Because plug\u00adging wires may be established \nafter application runtimes are estab\u00adlished, application execution continues to support limited applica\u00adtion \nevolution.  2.2 The Deployment Lifecycle A primary goal of our framework is to model all of the fundamental \nactions involved in the deployment process. To demonstrate this, we now describe how the development \nand deployment of a simple browser is modeled in our framework. The focus of the framework is decidedly \non deployment, but to model deployment we must also model fundamental actions at the development stage, \nsince they have a major impact on deployment. The important development and deployment actions of our \nframework are illustrated in detail in Fig. 2. Component Build Component-based software development starts \nby preparing the components themselves. There are two ways a developer can obtain a component: either \nby building one from scratch, or by using off-the-shelf components shipped by third par\u00adties. The .rst \ncase is modeled by an action called component build, in Fig. 2(a). For a concrete analogy, this step \ncan be viewed as the creation of a Java .class .le. After this build step, the Browser component is now \nin the buildbox. A new browser version v2 as\u00adsigned to the component and uniquely identi.es it. The second \nway in which a component can be obtained (an off-the-shelf component like NetLib) will be explained below \nwhen component installation is discussed. Component Assembling In Fig. 2(a), the two components are in \nthe buildbox, but the namespaces have yet to be wired together. The component assembling process achieves \nthis, by wiring together the two mixer interfaces, one from each component. Note that the mixing wire \nis between two versions of components, not just two components. For instance in Fig. 2(b), the framework \nis not just aware that a NetLib component is wired to Browser component, butalso itisthat v1 of NetLib \nis wired to v2 of Browser. Component Shipping When development of the browser is .n\u00adished, the Browser \ncomponent needs to be packed up and shipped. This component shipping process is modeled in Fig. 2(c). \nThe result of shipping is the packed form of Browser, a data structure called packaged assemblage. When \na component is shipped, the shipper is given the option of specifying whether each version dependency \nshould be matched when the component is installed elsewhere. In the example here, let us assume the Broswer \nshipper does indeed care about the version of the network library, so that it will not be installed on \na machine whose NetLib component has an in\u00adcompatible version that e.g. might crash the browser. The \nresulting packaged assemblage ends up containing a dependency constraint saying my mixer Net at development \ntime is wired to the M mixer of version v1 of NetLib. I will never let myself be wired to a ver\u00adsion \nof NetLib that is not compatible with v1 . On the other hand, if the shipper decides all that matters \nis that NetLib has a mixer M containing the features it needs, but not the versions of them, he/she could \nalso choose to leave out this constraint. Component Installation The browser enters the deployment site \nby the action of component installation, illustrated in Fig. 2(d). The installation unit is a packaged \nassemblage. Note that in the example, the deployment site doesn t happen to have a copy of  Net Plugins \n  dependency: Net -> NetLib. v1. M  dependency: Net -> NetLib. v1. M  (f) Dynamic Component Deployment \n   Legends  Packaged Assemblage Figure 2. Software Development and Deployment Lifecycle version v1 \nof NetLib, only a compatible version. It results in a mixing wire connecting v3 of NetLib and v2 of Browser. \nEarlier when we explained component build, we raised the ques\u00adtion of how NetLib was put into the buildbox. \nThe Browser devel\u00adoper certainly does not want to build it from scratch, and most likely it is prepared \nby some other library developer. In our framework, the way a third-party component such as NetLib is \nput in the build\u00adbox is via component installation. Indeed, the development site of a browser is in fact \nthe deployment site of the network library. This explains from one angle the inseparable relationship \nbetween de\u00advelopment and deployment, and why a deployment framework also covers the actions in development. \nComponent Update At some point, there may be a new, improved release of the NetLib, and the system administrator \nwishes to update the browser to use the newer version. This updating action is modeled in Fig. 2(e), \nwhere the wiring to the Net mixer of Browser is now switched to the new NetLib library of version v4. \nA component update is only successful if the update does not violate version compatibility. Our framework \ndoes not explicitly support component removal, as non-referenced components (such as version v3 of NetLib \nhere after the transition) can be garbage collected easily. Dynamic Component Deployment With the browser \nnow in\u00adstalled, it will eventually be launched. And, once the browser is launched, a user might download \na dynamic plugin such as Flash. It will be desirable for the browser to use Flash without the need to \nterminate and restart. This action is modeled in Fig. 2(f). It is simi\u00adlar in spirit to component assembling, \nbut is an action that happens only at run time. Note that a Flash plugin here is also a packaged assemblage, \nwhich should come as no surprise since it is also a well-encapsulated, independently deployable unit. \nThis makes the action of enabling a dynamic plugin equivalent to deployment a component dynamically, \nan action sometimes also called hot de\u00adployment in the deployment community. Formalism and Its Design \nChoices In our formal framework, all actions represented in Fig. 2 except the last one are represented \nas transitions in a Labeled Transition System (LTS). Only well\u00adde.ned transitions are allowed during \ndeployment. Dangerous op\u00aderations such as manipulating low-level .les and system registries arbitrarily \nare not allowed. In the spectrum of formal models, the LTS approach lies between purely declarative approaches \nand full\u00ad.edged procedural languages. A purely declarative approach has the strength of being more mathematically \nconcise, but it is too weak to model the dynamic evolution of the deployment process as the latter is \ninherently dynamic. A full-.edged procedural ap\u00adproach is maximally expressive, but it comes with the \nprice of com\u00adplexity and greater dif.culty in veri.cation. We believe an LTS serves as a good balance \nbetween formal veri.cation and expres\u00adsiveness: the important operations of deployment are faithfully \nand intuitively modeled, and at the same time formal properties of the framework can be proved. In this \npaper we proved deployment site well-formedness preservation and version access compatibility properties. \nIn fact, out of the traditional strength of LTS, stronger framework-speci.c temporal properties can also \nbe expressed and checked, such as the fact that component update must happen be\u00adfore component installation. \nAll LTS transitions are independent of the component imple\u00admentation and are completely language-neutral. \nAs for dynamic component deployment, since it is fundamentally an operation after the application is \nexecuted, it is modeled as a reduction step within a minimally de.ned programming language. Indeed, since \ndynamic deployment fundamentally relies on dynamic link\u00ading/loading, some execution model must be assumed. \nModeling it as a language expression makes it programmable, so that the Figure 3. The Need for Interfaces \n(a) The Problematic Case (b) The Assemblage Solution  Browser developer has the freedom of trigger dynamic \ndeploy\u00adment at any point in the program. 2.3 Design Issues This section attempts to elucidate a few \ndesign decisions we made, and also introduces some advanced features of the framework. Among them, an \nimportant decision any deployment framework needs to make is the format of the deployment unit, i.e. \nthe compo\u00adnent model. In Sec. 2.1, we described our component model; you may ask, why does it look the \nway it is? The beginning subsections here will answer this question from the perspective of how such \na model can facilitate deployment. 2.3.1 Why are Interfaces Needed for Deployment? From the perspective \nof encapsulation, there is universal consensus that components should be designed with explicit interfaces. \nWe Figure 4. The Container-Bean Interaction argue that user-de.nable interfaces for the purpose of deployment \nare also important, for several reasons. First, an interface for a deployment unit is useful to de.ne \nthe atomic unit of versioning, i.e., all dependencies in one interface must be satis.ed with the same \nversion of the component where the dependencies are de.ned. Fig. 3 demonstrates this point. It is common \nthat a software component, say, PalmClient, contains two symbolic references, say, Palm and PalmDriver,de.ned \nin a different component, say, PalmComp.A version of PalmDriver should only operate upon a Palm of the \nsame version. A careless design of a deployment unit could result in the dangerous binding of Fig. 3(a), \nand the application may exhibit erratic behaviors. This problem can be avoided by equipping the component \nwith explicit interfaces, illustrated in Fig. 3(b). Here, dependencies are satis.ed on the level of interfaces, \nand not on the level of a single symbolic reference, so that all imports in the same interface can only \nbe satis.ed by one version of another component. Equipping a mixer with an assemblage expresses the desire \nto de.ne an atomic unit for versioning dependencies. Second, explicitly declaring interfaces on deployment \nunits also presents a cleaner solution for namespace management. This is especially true when a component \nwill be deployed in a different site, and the component needs to rebind its dependencies. In Fig. 3, \nthe namespace of the two mixers are merged together only when a mixing dependency is present, and there \nis no global binding of names. Since the development site and deployment site will often differ, global \nbinding of names can easily lead to accidental capture/clash of names, and also make deployment sensitive \nto platform-speci.c details such as the CLASSPATH. Our approach here is similar to Units [19] and Knit \n[41] (Units adaptation to C-like languages). Third, interfaces also specify a component s capability \nfor de\u00adployment. Such a declarative construct is in fact common in ex\u00adisting deployment frameworks, including \nthe package speci.cation used by Unix/Linux package managers[18, 40, 12], and the De\u00adployment Descriptors \nof EJB.  2.3.2 Why are Interfaces Bidirectional? Bidirectional dependencies between software components \nare a natural result of software decomposition. For instance, the CORBA CCM model allows users to de.ne \nfour types of interfaces where two types of them can be analogously thought of as all-export mix\u00aders \nin our framework and two as all-import mixers2.InCLI As\u00adsemblies, although no explicit bidirectional \ninterfaces are de.ned, it is de facto equivalent to an assemblage with each de.ned class 2 The interfaces \nof concern are called ports in CORBA, and the two types corresponding to all-export mixers are Facet \nand EventConsumer,and the other two corresponding to all-import mixers are Receptacles and EventPublisher. \n representing a one-export mixer, and each class dependency as a one-import mixer. A more important question \nto answer is how bidirectional in\u00adterfaces help model the process of deployment. Wewill usethe example \nof EJB deployment to show the prevalence of bidirec\u00adtional dependency. The primary task of an EJB deployer \nis to es\u00adtablish the interaction between the to-be-deployed bean and its con\u00adtainer located at the deployment \nsite. Such an interaction is funda\u00admentally bidirectional: the bean depends on the container to pro\u00advide \ncontainer-speci.c environment entries to customize its behav\u00adior, while the container depends on the \nbean to provide call-back lifecycle-related methods 3. Currently, EJB treats these as special cases, \nwhere environment entries are declared in an auxiliary data structure called the deployment descriptor \nwith special tags that can be recognized by the container, and call-back methods are sup\u00adported by adding \nsyntactic restrictions on what a bean class has to satisfy. Our framework can model such a case more \ndirectly, by allow\u00ading the bean to declare a bidirectional interface signifying how the bean will interact \nwith the container. Fig. 4 demonstrates such an interaction. In the .gure, the Bean can access its imports \nto obtain environment entry information set by the Container, such as the dataSource and searchBase here. \nThe Container can access its imports to invoke the lifecycle-related methods of the Bean such as ejbCreate \nand ejbRemove. The merit of our approach is our core model is smaller, environ\u00adment entry access and \ncall-back methods are not handled as special cases, and the interface for a bean s interaction with its \ncontainer is structurally similar to many other EJB business interfaces. When the above Bean is deployed, \nthe only thing that must be done is to set up a mixing wire between the Bean s IContainer mixer and Container \ns IBean mixer4. This more uni.ed treatment gives the deployment model a more rigorous basis, and can \nhelp deploy\u00aders to focus on the core aspects of the deployment task. In addi\u00adtion, version control can \nalso be naturally supported, as explained in Sec. 2.3.1. For instance, a bean can specify that it must \nbe de\u00adployed in some particular version of container. The current EJB model does not support version \ncontrol explicitly, and so such a task would need special handling by the programmer. Since IContainer \nbeing de.ned as a distinct mixer, the de\u00adployment logic and business logic, de.ned on other mixers, are \nnaturally separated. With this separation in place, an interface such as IContainer could be written \nby the EJB deployment descriptor writer role. 2.3.3 Why Put Pluggers in a Deployment Unit? For frameworks \nsupporting hot deployment, issues such as which party should initiate the deployment and when it should \nbe initiated are often a vendor-speci.c decisions. For instance, WebLogic s implementation of EJB [4] \nsupports hot deployment via a utility weblogic.deploy. Indeed, since WebLogic is a container vendor, \nthey know all the details of their container implementation, and so writing a tool of this .avor is possible. \nOur approach is to make minimal assumptions on the underlying software architecture, and provide a language \nconstruct which can facilitate the coding of such hot-deployment tools. 3 Different kinds of beans need \nto implement different sets of call\u00adback methods. For an entity bean for instance, they include .xed \nname/signature methods ejbCreate, ejbPostCreate, ejbActivate, ejbPassivate, ejbStore, ejbLoad, ejbRemove, \nsetEntityContext, unsetEntityContext. 4 Some vendors of EJB supports hot-deploying. In that case, the \nexample will demonstrate a plugging wire; the argument stays the same in terms of bi-directional dependency. \n Figure 5. Plugger Rebindability (a) Two Plugins (b) Dynamic Software Updating At a high level, placing \na plugger on an assemblage indicates its ability to initiate dynamic deployment. Since each component \nin component-based software development is independently de\u00adployable, such an interface declaration gives \nthe deployer a better idea what hot-deploying ability the to-be-deployed component can have. For instance, \nwhen a Browser component is deployed, the deployer knows the buildbox the component will enter will have \nsome capability for hot-deployment, and can thus prepare accord\u00adingly for other orthogonal and yet important \nissues, such as secu\u00adrity. The import and export declarations of the plugger can further aid the deployer \nby describing how the hot-deployed component needs to interact with the rest of the system, and thus \nwhat con\u00adsequences the potential hot-deploying might have. For instance, if the Plugins plugger of the \nBrowser is going to export a method called fileWrite, the deployer of Browser may have to be care\u00adful \nabout security issues. Applets are an analogous situation if we model applet download as a hot deployment. \n2.3.4 Plugger Rebindability and Dynamic Component Update Pluggers are rebindable in our framework: a \nplugger can be wired to multiple hot-deployed components at the same time. In Fig. 2(e), we presented \nan application runtime with only one plugin, Flash. But as the application runtime evolves, it can hot-deploy \nanother plugin, say, ShockWave, which would result in the situation cap\u00adtured by Fig. 5 (a). Since there \nis no way to predict in advance how many dynamic plugins a browser might hot-deploy, there is no way \none can enumerate all pluggers statically. Rebindability provides a solution to this problem. From the \nBrowser s perspective, it needs a way to interact with these two plugins individually. Since hot deployment \nis modeled by a language expression, we can distinguish different plugins by allowing the expression \nto return a handle that uniquely identi.es the speci.c hot-deployed component. For instance, the setup \nof Fig. 5 (a) can be achieved by the following code fragment: //hot-deploy Shockwave h1 = plugin Wshockwave \nwith Plugins >> Brw //hot-deploy Flash h2 = plugin Wflash with Plugins >> Brw //invoke a function on \nShockwave h1..start(); //invoke a function on Flash h2..start(); The handles h1 and h2 can start the \nShockwave and Flash plugins, respectively. The rebindability of pluggers gives our framework de facto \nsupport for dynamic software updating. Different handles to the same plugger could be viewed as different \nversions of the same component. For instance, suppose we have an air traf.c control component enclosed \nin assemblage AirControl. The software must stay running, but it is useful to allow some of the core \nalgo\u00adrithms to periodically be tuned up and replaced with better versions. For this purpose the AirControl \nassemblage can declare a plug\u00adger AlgmUpdate that imports the main algorithmic function say compute. \nInvocation recent..compute() will always refers to the most recent algorithm if we declare a mutable \n.eld recent in AirControl, and de.ne the update logic as follows: //hot-deploy a new algorithm p = plugin \nWnewAlgm with AlgmUpdate >> M // store the handle to the .eld recent = p; If a hot-deployed component \ncan not be reached from all live variables it can be automatically garbage collected, removing the component \nfrom the application. 2.3.5 Singleton Mixers and Rebindable Mixers A mixer is a singleton if there is \nat most one other mixer wired to it at any point in time. Singleton mixers are the most common form of \ndependency between components: for example if a Java .class .le contains a symbolic reference to a class \nname, this name clearly refers to a single class de.nition. Most of the exam\u00adples we have shown thus \nfar use singleton mixers. The one excep\u00adtion is the IBean mixer in Fig. 4. In the EJB infrastructure, \nall beans in an application in fact exchange information with their container. For example, if we have \na simple application involving two beans, one Customer and one Agent, both of them will need to read \nen\u00advironment entries. The container-bean interaction thus forms a pic\u00adture illustrated in Fig. 6. Note \nthat in this case, although the import ejbCreate of Container is currently associated with multiple ex\u00adports \nfrom different Beans, there is no confusion as to which one a container should call at any given time. \nThis is because they are call-backs which are never proactively invoked by the Container. Our framework \nsupports this style of mixer, and we call them re\u00adbindable mixers. We place the aforementioned restriction \non their use: the imports are never proactively invoked by the rebindable\u00admixer-owning party. A precise \nde.nition of its use will be detailed in Sec. 3.4. One way to help understand the difference between \nthe two styles of mixers is they represent different forms of dependency. Legends Rebindable Mixer \nSingleton Mixer Figure 6. Rebindable Mixers: the Container-Bean Interaction Re\u00advisited Singleton mixers \nrepresent the standard one-import-satis.ed-by\u00adone-export dependency, and rebindable mixers represent \nparamet\u00adric dependency. Indeed, parameterized modules such as ML func\u00adtors express parametric dependencies \nand they are well-known to be useful. However, existing deployment frameworks almost ex\u00adclusively disregard \nthis form of dependency. The consequence is that parameterized modules are not independent deployment \nunits and thus cannot be updated independently in those frameworks.  2.3.6 On Hierarchical Code Composition \nOne design decision a typical component/module system needs to answer is: should code composition be \nhierarchical? In other words, does the system support operations such as A=B+C where B and C are components, \nand A can also be viewed as a component used for further composition, such as E=A+D?Hi\u00aderarchical composition \nis in fact very common in modern compo\u00adnent/module systems, such as the compounds in Units [19] and MJ \n[9]. Do assemblages allow for hierarchical code composition? The answer is yes and no: assemblages can \nbe hierarchically composed, very much in the same way as other related work, but only the com\u00adposed assemblage \nis considered an independent deployment unit. The idea is that on the development site, if hierarchical \ncomposition is needed, developers can freely use static linking of assemblages (a topic we have left \nout of this paper for brevity interested read\u00aders can refer to [27]) to achieve this goal, and ship the \ncompound as one deployment unit. Assemblages on the deployment site are not hierarchically composable. \nThe main reason behind this design decision is that hierarchi\u00adcal composition will introduce complexity \nif every participant is individually versioned. Take the above example. If we allow hier\u00adarchical composition \non the deployment site, would we give both A and E new versions if B was updated? Indeed, some solution \nalong these lines would probably be possible, but we feel the expressive\u00adness gained is outweighed by \nthe complexity that must be added. It is worth pointing out that even without hierarchical code composition \non the deployment site, some typical bene.ts of hier\u00adarchical composition are nonetheless preserved in \nour framework. For instance, one situation hierarchical composition is useful for is for the case that \na parametric component is used more than once in forming a full application. For instance, MyApplication \n= E + F E=A+B F=A+C If one insists on deploying every component of MyApplication as an independent unit, \na naive non-hierarchical treatment will have will have to deploy two distinct versions of A, a solution \nwhich will not be ef.cient or elegant. Note that this problem can be addressed in our framework through \nthe use of rebindable mixers, in which case only one copy of A needs to be deployed. 2.3.7 On Sub-versioning \nOur framework does not have a .xed de.nition of when two ver\u00adsions of a component are considered semantically \ncompatible. The only constraints our framework assumes for sub-versioning are minimal structural compatibility, \nsuch as if a version has an inter\u00adface named m, then any subversion should have an interface of the same \nname. We will formalize this notion in Sec. 3.3.1. Refraining from giving sub-versioning a stronger de.nition \nis in fact a feature of the framework: it gives our framework more generality. In the real world, what \nis considered a compatible de\u00adpendency in the deployment context varies: in Java dynamic class loading, \nit means satisfying type constraints, while in other critical systems, it means more restrictive invariants \nsuch as pre-conditions and post-conditions. Previous approaches to answering what con\u00adstitutes compatible \nversions include behavioral subtyping [26, 30] and refactorability [2]. In our framework we assume compatibil\u00adity \nof versions is declared by some means, e.g., based on analysis results from the aforementioned systems. \n  3. The Formal System In this section we make rigorous the ideas of the previous section by presenting \na formal Labeled Transition System (LTS) that captures the key component interactions during the deployment \nprocess. In the following section we establish correctness properties of our formal framework. We .rst \nde.ne basic notations. x denotes a set { x1,...,xp} , ---. with empty set \u00d8 . | S| is the size of set \nSand A- B =An B. x. y is used to denote a mapping function Mp mapping x1 to y1, ..., xp to yp where { \nx1,...xp} is the domain of the function, denoted as dom(Mp). We also write Mp(x1)=y1,...Mp(xp)=(yp). \nWe use \u00d8 M to denote an empty map. dom(\u00d8 M )= \u00d8 . We write Mp[x . y]as a standard map update. Mp and \nMp[x . y]are identical except that Mp[x. y]maps xto y. 3.1 De.nitions Fig. 7 de.nes the grammatic structure \nof the buildbox, and Fig. 8 gives auxiliary functions that are used in the framework. We now work through \nthese de.nitions step by step. Buildbox A buildbox (Abb) is represented as a graph, where the nodes (N) \nare components and the edges (K) are the wires between them. This is in sync with the general notion \nof component-based software development: applications are components wired together. Each node might \ncontain multiple versions (V) of components of thesamename (a), and each version of the component is \nidenti.ed by a version identi.er (a). Instead of giving a concrete representa\u00adtion of a version identi.er, \nwe only require that version identi.ers are unique to a degree that accidental clash can be avoided. \nIn real\u00adworld systems, a version identi.er could be realized as a meaning\u00ad Abb ::= ( N; K) application \nbuildbox N ::= -------. a .(V ; R) buildbox nodes K ::= a.a.m . b.\u00df.n buildbox wires V ::= --------. \na .( A; C) component versions R ::= a = \u00df compatibility relation A ::= ( M; L) assemblage C ::= m.b.\u00df.n \ndependency constraints M ::= ----------. m .( kd; I; E) interfaces I ::= k imports E, L ::= ----. k . \nB exports, locals B code block, see Fig. 10 W ::= ( a; a; A; R; C) packaged assemblage a, b, c component \nname m, n interface name k feature name a, \u00df, . version identi.er kd .{ smixer, interface kind rmixer, \nplugger} Figure 7. De.nition: Buildbox ful number appended to a veri.able signature or hash. Other con\u00adcrete \nexamples along the same lines are the GUID s of COM and the strong names of CLI Assemblies. Assemblage \nRecall from earlier discussion that components in our framework are realized as assemblages. Each assemblage \nis formally represented as a list of interfaces M and local internal de.nitions L. Interfaces can either \nbe singleton mixers (smixer), rebindable mixers (rmixer) or pluggers (plugger). Each interface is bidirectional, \nwith its imports (I) and exports (E) declared. Note that for now, we abstractly represent items imported \nand exported through interfaces as named features ; the concrete de.nition of a code block B is not given \nuntil Sec. 3.4. Before then, all our discussion is independent of the actual component implementation, \nso it is language-neutral and platform-neutral. Wire A wire is represented as a.a.m . b.\u00df.n (see de.nition \nof K in Fig. 7). It means that component a version a s interface m is wired to component b version \u00df \ns interface n. Note the wiring information is precise as to what version of the node is wired. We equate \na.a.m . b.\u00df.n and b.\u00df.n . a.a.m. On the syntactical level, we do not distinguish mixing wires and plugging \nwires. This task can be easily achieved given the kinds of interfaces of m and n. Packaged Assemblage \nA packaged assemblage (W ) is the shipped form of component that can be deployed at a deployment site, \nand so it serves as the bridge between the development site and the deployment site. It contains the \nname (a), version identi.er (a)of the assemblage to be shipped (A), together with its dependency constraints \n(C) and compatibility information (R). We will next explain dependency constraints and postpone the elaboration \nof R until Sec. 3.3.1. Dependency Constraint A dependency constraint m.b.\u00df.n in C indicates that the \ncurrent assemblage s m interface should be sat\u00adis.ed by an interface named n of assemblage named b of \nversion \u00df. Note that C is both part of a packaged assemblage (W ) and part of an already installed node \n(V ). One might be tempted to think that dependency constraints should be checked against at installa\u00adtion \ntime and declared satis.ed or failed, so that installed nodes do not need to carry such information any \nmore. But, this is not real\u00adistic because assemblages may be mutually dependent: solving all constraints \nmight end up leading to neither assemblage being in\u00adstalled. In fact, since the buildbox at deployment \nsite is an evolving system, there is nothing wrong with recording some of the unsat\u00adis.ed constraints, \nthe C found in the de.nition of V . In addition, recording the constraints can also help with future \nupdates, ruling out those operations violating the dependency constraints. 3.2 Buildbox Well-formedness \nand Closure One important property of our framework is that no matter how the buildbox evolves, it stays \nwell-formed (see Sec. 4). We de.ne the notion of well-formedness in Fig. 8. A buildbox Abb is well\u00adformed \n(w.Abb) if all versions of all nodes, wires and version com\u00adpatibility settings are well-formed, represented \nby w.Ver, w.Wire and w.R respectively. A component of a speci.c version is well\u00adformed if there is no \ncon.ict between its dependency constraints and the rest of the buildbox (nocon.ictC), and no import in \na sin\u00adgleton mixer is satis.ed by more than one export (nocon.ictImp), as explained earlier in Sec. 2.3.5. \nWire well-formedness (w.Wire) depends on the correct matching of interfaces: on a per-wire ba\u00adsis, imports \nin the interface on one end of the wire must be satis\u00ad.ed by exports on the other end. A well-formed \nwire also should not connect two rebindable mixers, because otherwise neither party would initiate any \ninvocation and is de facto futile (recall the call\u00adback nature of rebindable mixers, explained in Sec. \n2.3.5). The last constraint precludes two pluggers from being connected together: pluggers only declare \nwhat plugins may be plugged into the current runtime. We will explain w.R in Sec. 3.3.1 below. Note that \nbuildbox well-formedness itself does not require all imports of installed assemblages to be satis.ed \nat deployment time, nor does it require all dependency constraints associated with a node version to \nbe satis.ed, as we explained in Sec. 3.1. These extra conditions are captured by de.nition closedAbb. \n 3.3 The Labeled Transition System The evolution of a buildbox is de.ned as a series of transitions in \nthe LTS of Fig. 9. This LTS is the formalization of the software development and deployment cycle, and \nrepresents the general and formal version of Fig. 2. All rules excepting (ship) are of the form Abb -lAbb', \ndenoting a buildbox transition from state Abb to . Abb', via operation l. Each LTS rule de.nes a legal \noperation that can be performed by a deployer (or by a role appropriate for the operation), with values \nin the label being the information provided by the role. The pre-conditions of each rule de.ne what a \ngood operation is. Multi-step evolution Abb -lAbb' is de.ned as the . * transitive closure over the \nsingle-step transition. The (ship)rule is slightly different because we only care about its output (packaged \nassemblages). The focus of this section is on how individual components are developed and deployed (Sec. \n3.3.1). At this point we assume for simplicity that there is only one buildbox deployed in the whole \nuniverse. In Sec. 3.3.4, we show how a universe with multiple buildboxs can be modeled in terms of this \nsimpler notion. Sec. 3.3.2 discusses the impact of our framework on distributed applications. def depends(a, \na, m, (N;K))= def interface(a, a, m, (N;K))= def interfaceKind(a, a, m, Abb)= def newer(R, a)= def newer(R, \nany)= def newest(T,R,a)= def newest(T,R, any)= def newest(T,R,a)= def bestChoice((N;K),b, \u00df)= def bestChoice((N;K),b, \n\u00df)= def bestChoice((N;K),b, \u00df)= def wrap(a, a, .,Abb)= if def wrapE(a, a, m, .,Abb)= if def wrapE(a, \na, m, .,Abb)= if def wrapE(a, a, m, .,Abb)= def (M1;L1)<:A (M2;L2) = def (kd1;I1;E1)<:M (kd2;I2;E2) = \n {b.\u00df.n | a.a.m .b.\u00df.n .K, interface(a, a, m, Abb)=(kd;I;E),I =\u00d8} M(m)where N(a)=(V ;R),V (a)=(A;C),A \n=(M;L) kd where interface(a, a, m, Abb)=(kd;I;E) {a}.{\u00df |(a =\u00df).R} {\u00df |(a =\u00df).R}.{a |(a =\u00df).R} \u00df, where \nnset =newer(R, a)nT,\u00df .nset, .\u00df ' .nset.(\u00df ' =.\u00df =. (\u00df ' =\u00df).R) \u00df, where nset =newer(R, any)nT,\u00df .nset, \n.\u00df ' .nset.(\u00df ' .=\u00df =. (\u00df ' =\u00df).R) unde.ned otherwise \u00df if N(b)=(V ;R),\u00df .dom(V ) \u00df ' if \u00df ' =newest(dom(V \n),R,\u00df),N(b)=(V ;R),\u00df /.dom(V ) unde.ned otherwise [ wrapE(a, a, mi, .,Abb) i.[1..p] Abb =(N;K), {m1,...,mp}={m \n|(a.a.m b.\u00df.n).K} {m b.\u00df.n} m .., {b.\u00df.n}=depends(a, a, m, Abb), interfaceKind(a, a, m, Abb)=smixer \n{m b.any.n} m/.., {b.\u00df.n}=depends(a, a, m, Abb), interfaceKind(a, a, m, Abb)=smixer \u00d8otherwise .m .dom(M1).(m \n.dom(M2).M1(m)<:M M2(m)) (kd1 =kd2).(.k .dom(E1).k .dom(E2)).(.k .I2.k .I1) def w.Abb((N;K))= def closedAbb((N;K))= \ndef w.Ver(a, a, Abb)= def closedVer(a, a, Abb)= def nocon.ictImp(a, a, Abb)= def satis.edImp(a, a, Abb)= \ndef nocon.ictC(a, a, Abb)= def satis.edC(a, a, Abb)= def w.Wire(a.a.m b.\u00df.n, Abb)= def w.R(V, R)= Well-formedness \nand Closure Related Predicates (.a .dom(N).(N(a)=(V ;R).(.a .dom(V ).w.Ver(a, a, Abb)))). (.a .dom(N).(N(a)=(V \n;R).w.R(V, R))). (.lk .K.w.Wire(lk, Abb)) (.a .dom(N).(N(a)=(V ;R).(.a .dom(V ).closedVer(a, a, Abb)))) \nnocon.ictC(a, a, Abb).nocon.ictImp(a, a, Abb) satis.edC(a, a, Abb).satis.edImp(a, a, Abb) .m..I..E.(interface(a, \na, m, Abb)=(smixer;I;E) =.|depends(a, a, m, Abb)|<=1) .m..I..E.((interface(a, a, m, Abb)=(smixer;I;E)).(I \n=.\u00d8) =.|depends(a, a, m, Abb)|=1) .(m.b.\u00df.n .C) b '' a.a.m .\u00df ' .n .K =. N(b ' )=(V ' ;R ' ).\u00df ' .newer(R \n' ,\u00df).n =n ' .b =b ' where Abb =(N;K),N(a)=(V ;R),V (a)=(A;C) nocon.ictC(a, a, Abb) ..(m.b.\u00df.n .C)..\u00df \n' .(a.a.m b.\u00df ' .n .K) where Abb =(N;K),N(a)=(V ;R),V (a)=(A;C) (I1 .dom(E2)) . (I2 .dom(E1)). (\u00ac(kd1 \n=rmixer .kd2 =rmixer)) . (\u00ac(kd1 =plugger .kd2 =plugger)) where interface(a, a, m, Abb)=(kd1;I1;E1), interface(b, \n\u00df, n, Abb)=(kd2;I2;E2) partialOrder(R). .(a =\u00df).R.((V (a)=(A1;C1)).V (\u00df)=(A2;C2))=. A1 <:A A2) Figure \n8. De.nition: Auxiliary Functions and Predicates (build) install (a;a;A;\u00d8;C) a is fresh Abb ------------. \nAbb ' build a,A,C' Abb - ------. Abb (assemble) Abb =( N;K)Abb ' =( N;K . K ' ) ' ''' . (a.a.m b.\u00df.n). \nK.(w.Wire(a.a.m b.\u00df.n, Abb ). w.Ver(a, a, Abb ). w.Ver(b, \u00df, Abb )) assemble K' Abb - -----. Abb ' (ship) \n closedVer(a, a, Abb) Abb =( N;K) N(a)=( V ;R) V (a)=( A;C ' ) C =wrap(a, a, .,Abb) ship a,a,. Abb -------. \nS ( a;a;A;R;C) (install) addN (a;a;A;R;C) Abb -----------. G Abb '' '' assemble K' ' Abb -------. Abb \n' ' ''' K ={ a.a.m b.\u00df.n | m.b.\u00df .n . C, \u00df =bestChoice(Abb ,b,\u00df )} install (a;a;A;R;C) Abb ------------. \nAbb ' (update) Abb =( N;K) N(b)=( V ;R) assemble K1 \u00df ' . dom(V ) ( N;K - K0) -------. Abb ' K0 ={ \na.a.m b.\u00df.n | a.a.m b.\u00df.n . K for some a, a, m, n} K1 ={ a.a.m b.\u00df ' .n | a.a.m b.\u00df.n . K for some a, \na, m, n} update b,\u00df,\u00df' Abb - ------. Abb ' (set-compatible) ' '' N(b)=( V ;R) N =N[b .( V ;R . rm { \n\u00df = \u00df }) ] w.R(V, { \u00df = \u00df } ) setComp b,\u00df,\u00df' ( N;K) ---------.( N ' ;K) (auxiliary -add node) a/. dom(N) \nV =a .( A;C) addN (a;a;A;R;C) ( N;K) - ---------. G ( N[a .( V ;R . rm \u00d8) ];K) (auxiliary -add version) \n ' '' N(a)=( V ;R) V =V [a .( A;C) ] w.R(V ,R . rm \u00d8 ) a/. dom(V ) addN (a;a;A;R';C) ( N;K) -----------. \nG ( N[a .( V ' ;R . rm R ' ) ];K) Figure 9. Application Evolution: the LTS Rules 3.3.1 Component-Level \nDeployment Building a Component Building a component from scratch is covered by transition rule (build). \nIt is an operation typically per\u00adformed by a role different from a deployer. For instance in the EJB \nspeci.cation, a role named Bean Provider is de.ned for this respon\u00adsibility. It .rst involves specifying \nthe component with a name (a), and its interfaces and the implementation (A). Note that a compo\u00adnent \nalmost always depends on other components, since libraries are themselves components. Here we allow a \ncomponent to spec\u00adify how such dependencies should be satis.ed, in dependency con\u00adstraints C. Such a \nmechanism is not absolutely necessary, since a separate rule (assemble) handles the wiring of components \nto\u00adgether, but we feel it is closer to real-world development practice when library component dependencies \nare immediately resolved at build time. A fresh version identi.er a is assigned to each build. Assembling \nComponents To form an application, components need to be assembled together. This process in the LTS \nis modeled by (assemble). The parameter of the operation is a set of wiring speci.cations (K ' ). The \nassembling process can only succeed if the well-formedness of the buildbox is not undermined. For instance, \nwiring two mixers with unmatched import-export pairs will fail to transition. As another example, if \none component contains a constraint saying its mixer m can only be satis.ed by mixer n of component b \nversion \u00df or a compatible one, the transition will fail if the attempt is to wire it with component b \nversion \u00df ' where \u00df ' is not compatible with \u00df. The (assemble) operation is typically performed by the \nappli\u00adcation developer: in the speci.cation of EJB, this is mostly the re\u00adsponsibility of the Assembler \nrole. Some component dependencies can only be solved at deployment time, for example EJB environ\u00adment \nentries; so, these operations can also be performed by the De\u00adployer. Shipping a Component Shipping a \ncomponent is de.ned in (ship), and involves specifying the name a and version a of the component to be \nshipped. Users can also specify a set of interface names of the component (.), expressing the desire \nthat the version information of the dependency to that interface be recorded as a dependency constraint \nin the packaged assemblage (the C part). Such a mechanism gives users the freedom to selectively record \nversion information. For those interfaces not included in . but still dependent on other components, \na special version identi.er any is recorded. Dependency constraints will affect the version checking \nwhen the component is later deployed. The key task of shipping is to create a packaged assemblage, in \nthe form as de.ned in Fig. 7. Preparing the dependency constraints is the core of this process; this \nis modeled by the wrap function de.ned Fig. 8. What makes wrap a non-trivial task is that not every wire \nto an assemblage interface is necessarily a dependency; for instance an all export mixer does not depend \non assemblages wired to it (it is the other way around). The essence of the wrap function is to precisely \nidentify the real dependencies. Speci.cally, it only garners constraints from the wires hooked up to \nits singleton mixers imports. No wire to a rebindable mixer will generate a dependency constraint: rebindable \nmixers by nature is passive, i.e. the assemblage with the mixer can never proactively access the code \nde.ned in the assemblage it is wired with. (Otherwise there would be ambiguity as to which dependency \nis to be used when an import is accessed.) In terms of dependency, it is the other party that depends \non it but not vice versa. Setting Component Version Compatibility As we have explained in Sec. 2.3.7, \nour framework provides a user interface for declaring two component versions are backward compatible. \nIn our transition system, this is modeled by rule (set-compatible), and operation setComp b\u00df\u00df ' sets \nversion \u00df ' of the component named b to be backward compatible with version \u00df. To explain this rule, \nwe .rst need to explain how backward compatibility information is recorded in an buildbox, the R of Fig. \n7. R is a set of version identi.er pairs of the form \u00df = \u00df ' , meaning version \u00df ' is backward compatible \nwith version \u00df. Sometimes we also say \u00df ' is newer than \u00df. We now give a few formal de.nitions related \nto R, including merging . R is well-formed, denoted as w.R(V,R) (see Fig. 8), iff R is a partial order \n(the de.nition of partialOrder(R)isstan\u00addard) and each pair of versions declared as compatible by R also \nsatis.es minimal structural compatibility (the de.nition of <:A ), as explained in Sec. 2.3.7. We de.ne \nmerging R1 .rm R2 as the tran\u00adsitive closure over relation set R1 . R2, and it is unde.ned if R1 or R2 \nis not a partial order, or the result of transitive closure is not a partial order. When R is a partial \norder, function newer(R, a) com\u00adputes the set of versions (identi.ers to be precise) that are backward \ncompatible with a, including a itself. When a is the special value any, the function degenerates into \nenumerating all version identi\u00ad.ers that appear in R. Similarly, partial function newest(T,R, a) .nds \nout a version included in T that is the newest subversion to a according to R. (set-compatible) simply \nrecords the newly declared compati\u00adbility information. It fails if the merging results in a non-partial \norder (the .rm part), or \u00df ' does not meet the minimal structural requirement to be compatible with \u00df \n(the w.R part). Installing a Component Component installation is modeled by the (install) rule. It has \ntwo key tasks: 1) adding the component itself to the buildbox (the addN auxiliary transition) 2) adding \nwires (the assemble transitiion). The core part of the (install)rule is to select a compatible version \nthat resolves dependencies. This is achieved by a partial function bestChoice, with its self-explanatory \nde.nition found in Fig. 8. The installation rule re.ects a best-effort strategy: it tries its best to \nwire the installed component up with the rest of the buildbox, based on the information it has on what \ndependencies are expected (C). However, due to reasons such as cyclic dependency (see Sec. 3.1), it is \nnot always possible to .nd a total order where all dependencies have already been present when a component \nis installed. What (install) can achieve, in an intuitive way, is whenever it sets up a wire, it is guaranteed \nto be a good one, i.e. without undermining the well-formedness of the buildbox. In the cyclic dependency \ncase where components a and b depend on each other, the unresolved constraints when installing a will \nbe satis.ed later when b is installed. This late satisfaction will not result in dangling dependencies \nat run time, since every execution will start with a check to make sure the buildbox is closed; see Sec. \n3.4 for details. Explicitly declaring compatibility relations in the fashion of (set-compatible) can \nbe a labor for deployers, so our transition sys\u00adtem also allows packaged assemblages to carry the compatibility \nrelation accumulated on the development site over to the deploy\u00adment site. At the deployment site, the \ncompatibility relation car\u00adried over from the development site is merged with the relation recorded by \nthe node on the deployment site, an operation real\u00adized by the (auxiliary -add version) rule of Fig. \n9. Note that we do not require all version identi.ers appearing in R to have their corresponding assemblage \ninstalled in the node, and this is in fact crucial to support compatible installation: an installation \nmay in\u00addicate it depends on a component of version a, but a deployment site may not have the component \nof the same version. Now, as long as the deployment site can recognize version identi.er a and .nd some \ncompatible version of it available there, installation can still proceed. Updating a Component The (update) \nrule models the case where a component b would like to update itself from version \u00df to \u00df ' .This process \nis modeled by .rst removing the existing wires and then add new wires in. Note that such a rule depends \non (assemble), which in turn contains well-formedness checks to ensure updating does not sacri.ce environment \nwell-formedness. The update opera\u00adtion does not require the updating version to be a subversion of the \nupdated version. Indeed, all that matters is switching from one ver\u00adsion to another would not violate \nany dependency contraint for any involved party, which is guaranteed by (assemble). This more re\u00adlaxed \ntreatment is in sync with real-world scenarios: not all updates are upgrades. Removing a Component Components \nare automatically garbage collected when a version is not wired to the rest of the buildbox. The criterion \nfor garbage collection is a very simple wire-counting based on the following predicate: def collectable(a, \na, (N; K))=(a.a.m b.\u00df.n) ./K for all m, b, \u00df, n  3.3.2 Distributed Deployment Software components of \na buildbox are not necessarily located on one physical network node. Distributed deployment has been \na focus of CORBA, and in the EJB case, all beans that can be accessed by its naming service JNDI may \nbe distributed across different network locations. This framework does not attempt to solve all issues \nrelated to distributed deployment, but we point out that the framework it\u00adself can serve as a basis for \ndistributed deployment. The build\u00adbox represented as a graph (N; K) may have nodes in N located in different \nplaces, and the K can represent the distributed wiring amongst nodes. The idea is that when an application \nis developed and shipped, all its components may end up being deployed in dif\u00adferent locations, and their \nversion compatibility is still preserved in a distributed manner. For instance, when one component is \nup\u00addated via (update), the wires being updated could very well link to some component in a different \nlocation, so that when components in other locations later have access to the updated component, the \nnew (and compatible) version will be used. 3.3.3 Deployment in Batch Mode Up to now our discussion has \nfocused on how deployment can be performed at the component level. This is because software com\u00adponents \nby de.nition are the deployment units, and atomic opera\u00adtions should be de.ned at this level. In addition, \nsome operations such as update are fundamentally component-level operations. In the real world, some \noperations might be more commonly used on the application level, such as shipping and installation. They \ndo not introduce extra dif.culty however: when shipping an application, it is equivalent to shipping \nits components one by one by repeat\u00adedly applying the (ship) rule, and when installing an application, \nit is equivalent to installing its components one by one by (install). Note that because our framework \ndoes not require all dependencies are satis.ed all at once at installation time, the ordering of which \nassemblage should be installed .rst is not important.  3.3.4 Multiple BuildBoxes The LTS rules address \nhow an assemblage operates in a single buildbox scenario. A software environment composed of multiple \nbuildboxes can easily be built up on top of this. Let us consider component installation, for example. \nIn a multiple buildbox sce\u00adnario, when an assemblage private to a buildbox is to be installed, the LTS \ninstall operation speci.c to that buildbox will be triggered and only this buildbox will evolve. When \nan assemblage function\u00ading like a library is to be installed, it can be conceptually viewed as installing \nthe same assemblage in all buildboxes. Since the majority of the transitions for the multiple buildbox \nscenario is to delegate them to a single buildbox scenario, we do not present these rules in this presentation. \nInterested readers can refer to the long version for details [29]. The principle behind this treatment \nis a conceptual level of buildbox isolation, which simpli.es our formal framework without loss of generality. \n  3.4 Execution Thus far we have made no assumptions about the code inside an assemblage, but the aim \nof deployment is to eventually run the application. In this section, we construct a very simple assemblage \nrealization, by taking code blocks to be functions, illustrated in Fig. 10. Since we are only interested \nin how names are linked and how hot deployment is accomplished, the expressions e in Fig. 10 are very \nsimple. Besides the plugin expression explained earlier, it supports m :: k(e) to invoke a function k \nde.ned in singleton mixer m, k(e) to invoke a callback function k de.ned in the current rebindable mixer, \n:: k(e) to invoke a local function, and e..m(e) to invoke a function de.ned in the plugger. Values v \nare either constants, or plugin handles: a.a.m . b.a.n is a .rst-class value denoting the plugging from \nplugger m of node a s version a,to the mixer n of node b s version \u00df. We leave out features unrelated \nto deployment from the expressions, for instance, mutable state. Readers interested in a more complete \nlanguage speci.cation can refer to [27]. Execution starts by applying rule (execute). It simply looks \nfor a mixer called Main, and invokes an export function called main. Predicate closedApp disallows dangling \nimports and makes sure all dependency constraints are satis.ed. Fig. 10 de.nes the small-step reduction \nrelation App, Stk, e . App ' ,Stk ' ,e ' , which executes the expressions inside an assemblage. Stk keeps \ntrack of the func\u00adtion invocations, based on where the current function is de.ned. A top element (a; \na; m) means the current expression is de.ned in a function inside mixer/plugger m of assemblage named \na,ver\u00adsion a. m can also be given a special value local, in which case the function is de.ned as a local \nfunction: here we are only inter\u00adested in the scope up to the level of mixer/plugger (or whether it is \na local function), but not which function is de.ned. The def\u00adinitions of expressions, values and stacks \nare given in Fig. 10. top(Stk) returns the top element of the stack. Multi-step reduction App, Stk, e \n.* App ' ,Stk ' ,e ' is de.ned as the transitive closure over the small-step reduction. 3.4.1 Dynamic \nPlugins and Hot Deploying The process of hot deploying is illustrated by (plugin). Note that a dynamic \nplugin in a deployment framework represents an inde\u00adpendent deployment unit, and hence it is represented \nas a packaged assemblage (W ), with its dependency information packed up. In our framework, built-in \nversion control for dynamic plugins is pro\u00advided, and it is uni.ed with version control for non-hot deployment: \nnotice the structural form of a dynamic plugin is no difference from regular packaged assemblages used \nfor non-hot deployment. A plugging wire is established between the initiating assem\u00adblage runtime s plugger \nand the mixer of the plugee (see the as\u00adsemble part of the rule). The assemble rule will also make sure \nall imports from one party are satis.ed by exports from the other party: no dangling import is possible. \nThe expression returns a plug handle which exactly records the information of the plugging wire. As the \nrule suggests, hot deploying needs to install the dy\u00adnamic plugin (see the install part of the rule). \nThis is obvious; hot-deploying is installation at runtime. The not-so-obvious issue is that depending \non the plugger to export to the dynamic plugin all functionalities is unrealistic in the real world. \nTake EJB for in\u00ad App ::= Abb application runtime B ::= .x.e code block e ::= i |m ::k(e)|k(e)|::k(e)|e..m(e)|e;e \nexpression | plugin W with m>>n |return e v ::= i |a.a.m I b.\u00df.n value E ::= []|m ::k(E)|::k(E)|k(E)|E..k(e)|v..k(E) \nevaluation context | E;e |v;E |return E Stk ::= s 0 Stk |s stack s ::= (a;a;m)|(a;a;local) stack frame \ni integer (execute) closedAbb(Abb) interface(a, a, Main,Abb)=(rmixer;\u00d8M ;main ..x.e) App =Abb exe Abb, \nexecute a, a - .App, (a;a;main),e (plugin) top(Stk)=(a;a;m ' ) W =(b;\u00df;(M;L);R;C) install W ' App -----.App \nassemble {a.a.m.b.\u00df.n} App ' ---------------.App '' interfaceKind(a, a, m, App)=plugger closedVer(b, \n\u00df, App '' ) App, Stk, plugin W with m>>n .App '' ,Stk,a.a.m I b.\u00df.n (handle invoke -1) interface(a, \na, m, App)=(plugger;I;E) k/.IE(k)=.x.e App, Stk, (a.a.m I b.\u00df.n)..k(v).App, (a;a;m)0Stk, e[v/x] (handle \ninvoke -2) interface(a, a, m, App)=(plugger;I;E) '' '' k .I interface(b, \u00df, n, App)=(smixer;I ;E )or \n(rmixer;I ;E )E ' (k)=.x.e App, Stk, (a.a.m I b.\u00df.n)..k(v).App, (b;\u00df;n)0Stk, e[v/x] (local invoke) top(Stk)=(a;a;m) \nApp =(N;K) N(a)=(V ;R) V (a)=(A;C) A =(M;L) L(k)=.x.e App, Stk, ::k(v).App, (a;a;local)0Stk, e[v/x] (import \ninvoke) top(Stk)=(a;a;m ' ) interface(a, a, m, App)=(smixer;I;E) k .I '' ''' depends(a, a, m, App)={b.\u00df.n} \ninterface(b, \u00df, n, App)=(smixer;I ;E )or (rmixer;I ;E ) E (k)=.x.e App, Stk, m ::k(v).App, (b;\u00df;n)0Stk, \ne[v/x] (export invoke) top(Stk)=(a;a;m ' ) interface(a, a, m, App)=(smixer;I;E) k/.IE(k)=.x.e App, Stk, \nm ::k(v).App, (a;a;m)0Stk, e[v/x] (rmixer import invoke) interface(a, a, m, App)=(rmixer;I;E) '' ''' \nk .I interface(b, \u00df, n, App)=(smixer;I ;E )or (plugger;I ;E ) E (k)=.x.e App, (a;a;m)0(b;\u00df;n)0Stk, k(v).App, \n(b;\u00df;n)0(a;a;m)0(b;\u00df;n)0Stk, e[v/x] (return) App, (a;a;m)0Stk, return v .App, Stk, v Figure 10. Application \nExecution: De.nitions and Reduction Rules stance,a hot-deployed bean might not only need to interact \nwith its container, but also interact with other beans, and also system li\u00adbraries, to make it work. \nThis is supported by the install part of the rule, since all dependency requirements C that W contains \nwill be solved by install. Some elements in C can certainly specify how some of the mixers of the dynamic \nplugin can be satis.ed by other assemblages in the application App.  3.4.2 Name Binding Rules All the \nother rules handle some form of name binding; studying linking in the context of component deployment \nis a goal of this paper. Readers should pay attention to the (import invoke)rule, where it needs to read \nfrom the application graph to .nd the cor\u00adrect function to invoke. Due to the structural choice of our \nformal\u00adism, this lookup process might look inef.cient, but in reality all the functions in the rule can \nbe precalculated: the assemblage of con\u00adcern can be associated with a symbol table and the function entry \ncan be obtained without indirect lookup.  4. Formal Properties One important evaluation of any formal \nframework is what proper\u00adties may be proven rigorously. In this section, we state three impor\u00adtant formal \nproperties. Informally, they are that any buildbox cre\u00adated, deployed and any application runtime executed \nin our frame\u00adwork will stay well-formed, and any well-formed application run\u00adtime will access features \nwithout violating version compatibility. The proofs of these theorems are detailed in the long version \n[29]. THEOREM 1 (Well-Formed Evolution over LTS). If w.Abb(Abb) and Abb -lAbb ' ,then w.Abb(Abb ' ). \n.* THEOREM 2 (Well-Formed Run-time Evolution). If w.Abb(App) and App, Stk, e .* App ' , Stk ' , e ' ,then \nw.Abb(App ' ). Thm. 1 states that all operations de.ned by the LTS including component building, assembling, \ninstallation, update do not turn a well-formed buildbox into an ill-formed one. Note that since each \nlabeled transition can be analogously thought of as a command issued by component deployers, providers \nand assemblers, such a theorem ensures that our framework is robust enought to fend off misuses of the \ncommands (such as providing special parameters) to undermine buildbox well-formedness. Thm. 2 states \nthat running an application also does not affect application well-formedness; for instance, hot-deploying \nwill not change a well-formed application into an ill-formed one. Together with the trivial fact that \nthe bootstrapping process (see the (execute) rule in Sec. 3.4) does not affect well-formedness and (\u00d8M \n; \u00d8) is trivially well-formed, we know that the buildbox created and deployed, and the application runtime \nlaunched from it in our framework are always well-formed at any given point of its evolution. We now \nstudy version compatibility. Before we state the main theorem, we .rst de.ne a relation .. to capture \nwhere a feature implementation will be looked for at run time. DEFINITION 1 (Run-time Feature Access). \nApp,a,a,m,k .. App ' ,b,\u00df, n holds iff w.Abb(App).  App = (N; K),N(a)= (V ; R),a . dom(V ) for some \nN, K, V , R.  exe App, execute a0,a0 - . App0,Stk0,e0 for some a0, a0, App0, Stk0, e0.  App0,Stk0,e0 \n.* App '' , (a; a; p)0 Stk '' , E[m :: k(v)] for some App '' , Stk '' , p, v, E.  App '' , (a; a; p)0 \nStk '' , E[m :: k(v)] . App ' , (b; \u00df; n)0Stk ' ,e for some e. THEOREM 3 (Compatible Code Access). Given \nship a,a,. A1: App0 ------.S W A2: m . . l1install Wlp A3: (\u00d8M ; \u00d8) -. ... - ---. ... -. App ' 0 A4: \nApp0,a,a,m,k .. App1,b,\u00df,n A5: App ' 0,a,a,m,k .. App1' ,b ' ,\u00df ' ,n ' A6: App ' = (N ' ; K ' ),N ' (\u00df \n' )= (V ' ; R ' ) then b = b ' , n = n ' and \u00df ' . newer(R ' ,\u00df) 1 This is the main theorem addressing \nthe correctness of our framework in terms of version compatibility. It is not trivial because it spans \nthe lifecycle of the component, from component develop\u00adment time (shipping) to its deployment (installation) \nto the run-time access to its features. It states that if a component is shipped from the development \nsite (A1), and its mixer m is speci.edbythe ship\u00adper to consider version compatibility (A2), then no \nmatter where the packaged component is installed (A3) and then executed, any access to the features inside \nm (either as an import or an export) at run time will always locate a version of the component (A5)com\u00adpatible \nwith the version located at the development site if the same application is test-run (A4). 5. Discussion \nAn important aspect of any formal framework is how well it mod\u00adels the problem domain. This section is \naimed at elucidating how our platform-independent framework can be mapped onto differ\u00adent platforms, \nhow it relates to existing real-world deployment ap\u00adproaches, and/or what insights it can provide for \ntheir improvement. It serves both as a validation of our framework and as a summary of related work. \n5.1 Deployment on Microsoft Platforms Over the years several different software component models have \nbeen de.ned on Microsoft platforms, and each of them addresses the issue of deployment. 5.1.1 Dynamic \nLink Libraries (DLLs) An application on earlier Windows platforms is deployed as a set of .les in .exe \nand .dll formats. The .dll .les are commonly shared by multiple applications, and many of them are provided \nby the operating system itself. The notorious problem [39] related to DLL deployment is updating without \nversion control: when the installation of one application involves installing a new version of an existing \n.dll .le, the new copy will overwrite the old copy and affect all other applications that depend on the \nlibrary. If the new copy happens to be backward incompatible, the affected ap\u00adplications might behave \nerratically. This can happen weeks after the damage was done and, and is thus very hard to track down \nthe cause. The DLL model is a very weak model of deployment that we do not feel a need to contrast with. \n 5.1.2 COM COM [33] as a component model strongly promotes the use of in\u00adterfaces, a feature also shared \nby assemblages. COM components are typically deployed in an environment, called context in which they \nrun. A COM component developer can specify how a particu\u00adlar component should behave by modifying speci.c \nattributes that de.ne the component s behavior within a context, a feature com\u00admonly known as attribute-based \nprogramming . Such a feature can be modeled in our framework by using bidirectional interfaces, in the \nsame way as modeling EJB environment entries, elaborated in Sec.2.3.2. COM addresses versioning by using \nimmutable interfaces: after one publishes an interface in a COM component with a universal ID, it should \nnever be changed. Newer versions of the same com\u00adponent should create additional interfaces to the component. \nSuch a solution can easily solve the problem of version backward com\u00adpatibility, but in reality is prone \nto interface proliferation [21]. COM also inherited some older problems of the Windows plat\u00adform, such \nas the requirement that all component metadata infor\u00admation be stored in a centralized repository, the \nWindows Registry. The principle of application isolation is not supported.  5.1.3 CLI Assemblies CLI \nAssemblies [16] de.ne a vendor-independent component stan\u00addard, which also had as a major goal the solution \nof the deployment problem with DLLs on the Windows platform. The best known im\u00adplementation of it is \n.NET CLR Assemblies [32] by Microsoft. Each assembly as a deployment unit contains version-aware de\u00adpendency \ninformation in a manifest .le, which is precisely matched against at deployment time. Since solving the \nDLL problem was a primary aim, only shared libraries are versioned, and they are al\u00adways referred to \nby strong names, which contain rich version in\u00adformation to avoid accidental name matches. Since different \nver\u00adsions of the same assembly do not have the same strong name, they can co-exist (so-called side-by-side \ndeployment). Updating a de\u00adpendency to a newer version is allowed by adding a version policy .le to an \nassembly, which claims to redirect the dependency to the new version. We share these features with Assemblies. \nSince application-speci.c assemblies are not accessed by glob\u00adally unique strong names, the correctness \nof locating the correct assembly is still subject to the lookup path setting, an issue very similar to \nthe CLASSPATH issue of Java. Assembly lookup paths happen to be the least stable part of CLI speci.cation, \nand different vendors have chosen different strategies (for instance .NET CLR and Mono [34] have different \npriorities on which path should be looked at .rst). In our framework, all assemblages are consistently \naccessed via its version identi.er, so no name confusion can arise. Assemblies are known to have dif.culty \nin handling cyclic ver\u00adsion dependencies. This does not look that bad in the speci.c do\u00admain Assemblies \naim to have an impact on: Assemblies historically have a strong focus on solving DLL-related problems, \nso compo\u00adnents within an application are not versioned and their dependen\u00adcies where cyclic dependencies \nare most likely to happen are not considered. In general component-based software development, however, \neach individual component might be subject to version control. In fact, even on the CLI platform, two \ncore library DLLs are still known to be cyclically dependent: there is a cyclic depen\u00addence between System.dll \nand System.Xml.dll that requires special handling. Interested readers can refer to the source code of \nan open source CLI implementation, Rotor [35]. The Assemblies framework does not consider the deployment \nsite as a running evolvable system, and does not precisely specify the deployment action as a process. \n 5.1.4 Installers On the Windows platform, many programs exist to address appli\u00adcation shipping and installation. \nThese tools are typically not more than a compression tool with a friendly user interface (the wiz\u00adard \n), and they heavily depend on platform-dependent environment variables and scripts to con.gure packages \ninside. A better installer in this category is InstallShield. Its recent releases have conformed to the \nCLI Assemblies standard.  5.2 Deployment on the Java Platform Java s component model is JavaBeans. \nThe deployment model on the Java platform is mostly speci.ed for a variant of the model, EJB. In this \nsection, we will also consider how .class .les are deployed. 5.2.1 EJB The J2EE solution for component \ndeployment is detailed in the speci.cation for Enterprise JavaBeans (EJB) [17]. It revolves around a \ndata structure called the Deployment Descriptor 5 as\u00adsociated with each to-be-deployed bean, which describes \nthe inter\u00adactions the bean may engage in at the deployment site. The primary task of a deployer is to \nestablish the interaction between the to-be\u00addeployed bean and its container. The way in which this interaction \ncan be modeled in our framework was explained in Sec. 2.3.2. In addition, a bean can rarely achieve a \ntask without collaborating with other beans, and it supports inter-bean dependency by introducing extra \nsyntax (<ejb-ref>). In our framework, this is analogous to declaring a bidirectional mixer. EJB does \nnot explicitly model ver\u00adsioning, and also does not de.ne the build evolution process that the application \nbuildbox models. 5.2.2 Deploying Java Programs In a Java context, each .class .le can serve as an independent \ndeployment unit. It is common that a Java program is tested on the development site with one version \nof the class as the dependency, and then is installed on the deployment site with another version of \nthe class. This is because CLASSPATH settings may be different between the development site and the deployment \nsite, and so program behavior is vulnerable to the settings of the CLASSPATH. This problem does not arise \nin our framework, since components are referred to by their unique ID, not just by their name. This issue \nalso affects the way type safety is ensured. Consider a simple Java program where class A refers to class \nB. Suppose class B at the deployment site is different from the version used when A was compiled. Type \nsafety would be jeopardized if the B with an incompatible type was loaded at run time. Java addresses \nthe issue by performing load-time re-typechecking as part of bytecode veri.cation. In our framework, \nif we make sure the B referred to by A is the same version (or a compatible version) of the one used \nby A, such a re-typechecking process will be unnecessary.  5.3 Deployment in CORBA OMG has released \na Deployment &#38; Con.guration (D &#38; C) spec\u00adi.cation [36] for the CORBA Component Model (CCM). In \nSec. 2.3.2, we have demonstrated how to model its bidirectional interfaces, and its deployment time attribute-rebinding \nis similar to EJB environment entries. D &#38; C allows components to be as\u00adsembled together to form \nan assembly. This can be modeled in our framework by the (assemble)rule. One focus of this paper, versioning, \nis left out of D &#38; C. Since a CCM component does depend on other CCM components (attested by its \n<dependsOn> tag), it is unclear what will happen when different versions of the same components are deployed. \nThis will especially affect component update, which is left out in the current speci.cation. The CORBA \nnaming mechanism is also challenged in [44]. Since it is aligned with the general rationale of CORBA, \nthe D &#38; C framework focuses on distributed deployment, where different CCM components in one assembly \ncan be deployed on different 5 In EJB 3.0 (the latest version), metadata annotations are used to record \ndeployment information, but its difference from deployment descriptors is only syntactic. network nodes. \nOur framework as an abstract study does not ex\u00adplicitly model distribution, but it can be soundly re-interpreted \nif different components of the application lie on different nodes. This topic was discussed in Sec. 3.3.2. \nCORBA relies on its underly\u00ading bus to look up distributed components. We do not have such a mechanism, \nbut note that the globally unique version ID ensures name confusion will not be an issue in the distributed \ncontext.  5.4 Deployment on Unix/Linux Platforms 5.4.1 Package Managers Modern operating systems come \nwith package managers and in\u00adstallers to assist in installing and upgrading software. On the Linux platform, \nwell-known examples include RedHat s RPM [18], De\u00adbian s Dpkg [12] and Gentoo s Portage [40]. Despite \ndifferences in usability, the underlying goal of the three systems is the same: to install packages with \nthe correct dependencies satis.ed. How de\u00adpendencies are created, checked and resolved is too speci.c \nin these systems. For instance, RPM is known to be complicated and weak in its support for dependency \nresolution. For cyclic dependencies, a tool like Dpkg will rely on a special speci.cation from the package \ndeveloper to break the cycle (declaring one of the dependencies to be a post-depends). In Portage, cyclic \ndependencies induce fail\u00adure, and the resulting packages will not be installed. Broadly, pack\u00adage managers \ndo not take into account the execution phase of the deployment lifecycle: the content in packages might \nnot be exe\u00adcutable code at all. The resulting model is weak to treat the deploy\u00adment of code components: \nthe declared package dependencies can be arbitrary, and not necessarily re.ect inherent code dependencies; \nsatisfying all package dependencies does not guarantee any correct behavior when code is executed. The \npopular archive distribution systems CPAN [10] (for Perl programs) and CTAN [11] (for TeX documents) \ncan also be included in this category; these systems have a strength on how to locate packages on the \nInternet. There are also package managers for speci.c language environments, in\u00adcluding RubyGems [43] \nand Scala Bazaar [3]. 5.4.2 Deploying C Programs C compilers on modern platforms almost always use dynamic \nlink\u00ading for library access. A direct consequence is when a binary appli\u00adcation is created (the one with \ndefault name a.out), it rarely forms a closure in terms of name binding. When shipping a C application \nusing function strlen, the implementation of strlen is only de.ned by the library at the deployment site. \nIf applied to our framework, a deployment unit for C programs can either be the non-closed application \ncode (with default name a.out) or the shared library code (the one de.ning strlen,com\u00admonly represented \nas .les with suf.x .so on Unix-compatible plat\u00adforms). What our framework can help avoid is to create \nan applica\u00adtion depending on one version of the library with strlen,and then being deployed at a deployment \nsite with a different (and incom\u00adpatible) version of the library. Our framework can also make sure multiple \nversions of the same library can be installed, with some applications use one, and other applications \nuse the other.  5.5 Hot Deployment A number of research projects address the ability to dynamically \nload/link/update software components, which in various degrees overlap with our discussion on dynamic \ncomponent deployment. Dynamic linking/loading of code fragments provides a foun\u00addational layer of this \nproblem. Existing approaches comparable to our plugin expression are those programmable dynamic link\u00ading/loading \nmechanisms. Well-known examples include Java s ClassLoader, Assemblies Assembly.Load, and Unit s invoke \n[19] expression. From a language construct perspective, our plugin expression differs from these approaches \nas it respects the bidirec\u00adtional contract of the interactions between the link/load initiating component \nand the linked/loaded component, where both of the parties provide an interface (a plugger or mixer) \nto specify what it needs and what it requires. Declaring the plugger on the link/load imitating component \ngives the component a more declarative speci\u00ad.cation on its ability to perform dynamic linking, and in \nthe context of component deployment, it provides an explicit declaration of the fact that a form of dynamic \ndeployment is supported. MagicBeans [7] provides a library to help develop dynamic plugins with the \nuse of the Observer pattern, and our plugin covers that model. Typing issues of dynamic linking have \nbeen well studied, such as linking of assembly code [20] and C# and Java s dynamic linking [13]. In our \nprevious work [27] a deployment unit must be type-safe, and so for simplicity we have left out typing \nissues here. EJB hot-deployment is not de.ned the EJB speci.cation, and it is supported only in a vendor \nspeci.c manner. For example, Weblogic [4] supports hot deployment via several custom tools. A well-known \nexample of plugin-based software is Eclipse [15]. The recent release (3.0) has also included the ability \nto add plugins at run time, i.e. dynamic plugins, based on the Open Services Gate\u00adway Initiative (OSGi) \n[37] speci.cation. OSGi only provides lim\u00adited support for handling dependencies. Their consistency checking \nis optional and not rigorously de.ned, especially for the versions of dependencies. Some projects have \naddressed issues related to dynamic updat\u00ading and recon.guration of software. The Dynamic Software Updat\u00ading \nsystem [23] focuses on correctness, usability and type safety. It does not focus on software deployment, \nand does not consider ver\u00adsion control. OpenRec [24] is a software architecture effort focus\u00ading on how \nto design dynamically recon.gurable systems. In [8], a few more practical issues related to dynamic recon.guration \nof distributed systems are considered, such as the handling of stubs. Our abstract framework does not \naddress this issue. 5.6 Deployment-Related Formalisms Formal frameworks that address component deployment \nin a vendor-independent manner are rare. CLI Assemblies name bind\u00ading mechanism was recently formalized \nby Buckley [5]. The focus of that work was to demonstrate the use of strong and simple names in the framework. \nNo formal property was proved, and the frame\u00adwork does not address application evolution in the deployment \nlifecycle. The linking of DLLs was formalized in [14], where the focus was on type safety. A conceptual \nframework for component-based software deploy\u00adment was proposed in [38]. As a result of a highly conceptual \ntreat\u00adment, inter-component dependency arguably the central issue in modeling complex process of deployment \n was not modeled. No formal rules were given to describe the deployment process or ap\u00adplication execution. \n 5.7 Complementing Module/Component Systems Assemblages, the abstract component construct used by our \nde\u00adployment framework, was .rst described in [27]. This previous work had a different goal: equipping \nmixin-like modules with inter\u00adfaces to directly support Internet-era concepts, such as distributed communication \nand dynamic linking. Deployment and versioning were not considered in that paper. In this work, we have \nreused the assemblage construct itself, but almost every structural choice was rejusti.ed in a deployment \ncontext, such as why we need bidi\u00adrectional interfaces and why we need pluggers for hot-deployment. Put \ntogether, they paint a complete picture to justify the need for an assemblage-like construct in component \ndesign: 1) it is .t for model modern programming concepts such as distributed commu\u00adnication and dynamic \nlinking (the thesis of [27]); and 2) it is .t for component deployment (this work). Most of the structural \nassumptions we have made about our de\u00adployment units are common to many modern module/component systems. \nThe generality makes our deployment framework use\u00adful for studying deployment in a variety of next-generation \nmod\u00adule/component systems. Module systems with bidirectional inter\u00adfaces include Units [19] and Jiazzi \n[31]. In MJ [9], the Java class\u00adloader is replaced with a compile-time notion of module, in which module \ndependencies are separated into two categories: static dependencies (import and export) and dynamic dependencies \n(dynamic export). These two notions can be modeled as mixing and plugging in our framework, respectively. \nIn Fortress [1], pro\u00adgram fragments are organized into components with interfaces of explicit import \nand export declarations, and are organized into a persistent store called a fortress, where a few pre-de.ned \nlibrary operations (called targets) are de.ned such as link, upgrade,and execute. A fortress can analogously \nbe thought of as a deploy\u00adment site in our framework, where the targets can mapped to our LTS operations. \nThe Fortress speci.cation only speci.es signa\u00adtures for the targets and allows different vendors to provide \ntheir own implementations. Our framework can be thought of as pro\u00adviding a guideline for what a well-formed \nfortress should be, and how different implementations should abide so that good properties of a fortress \nwill not be undermined. In Fortress, because there is no support for multiple interfaces, clashing of \nnames are common at link time, and Fortress has to resort to special rules to handle them.  6. Conclusion \nIn this paper we showed how the complex, ad hoc software de\u00adployment cycle could be reduced to a calculus \nwith a small set of platform-independent, vendor-independent operations that de.ne how the deployment \nsite should evolve. It elucidates the subtle rela\u00adtionships between pre-runtime application buildbox \nevolution and run-time application evolution, and proves formal properties about application well-formededness \nand version compatibility through\u00adout the evolution process. It also serves as a study of component de\u00adsign \nfrom the perspective of the deployment unit, where component dependency in terms of timing and location \nis studied. Expressive forms of dependency such as parametric and cyclic dependency be\u00adtween components \nare also addressed. With this foundational framework de.ned, we would like next to investigate how more \nadvanced features important in component deployment can be expressed on top of it, for instance security, \ndis\u00adtribution, and transaction control. A formal treatment of these is\u00adsues within the deployment lifecycle \nshould give us deeper insights into these hard problems.  References [1] ALLEN,E., CHASE,D., LUCHANGCO,V., \nRYU,J. W.M.S., STEELE,G., AND TOBIN-HOCHSTADT, S. The Fortress Language Speci.cation (Version 0.618), \nApril 2005. [2] BALABAN,I., TIP,F., AND FUHRER, R. Refactoring Support for Class Library Migration. In \nOOPSLA 05 (2005), pp. 265 279. [3] The Scala Bazaar System, http://scala.epfl.ch/downloads/sbaz.html. \n [4] BEA. BEA WebLogic Server Enterprise JavaBeans 1.1, http://www.weblogic.com/docs51/classdocs/API \nejb/. [5] BUCKLEY, A. A model of dynamic binding in .NET. In Proceedings of 3rd International Working \nConference on Component Deployment (2005), pp. 149 163. [6] CARDELLI, L. Program fragments, linking, \nand modularization. In POPL 97 (1997), pp. 266 277. [7] CHATLEY,R., EISENBACH,S., AND MAGEE, J. Magicbeans: \na platform for deploying plugin components. In Second International Working Conference on Component Deployment \n(2004), vol. 3083, pp. 97 112. [8] CHEN,X., AND SIMONS, M. A component framework for dynamic recon.guration \nof distributed systems. In Lecture Notes in Computer Science, Volume 2370 (Jan 2002), vol. 2370. [9] \nCORWIN,J., BACON,D. F., GROVE,D., AND MURTHY,C. MJ: a rational module system for java and its applications. \nIn OOPSLA 03 (2003), pp. 241 254. [10] Comprehensive perl archive network, http://www.cpan.org. [11] \nComprehensive tex archive network, http://www.ctan.org. [12] Debian package management, http://www.debian.org. \n[13] DROSSOPOULOU,S., LAGORIO,G., AND EISENBACH, S. Flexible models for dynamic linking. In Proceedings \nof the 12th European Symposium on Programming (2003). [14] DUGGAN, D. Type-safe linking with recursive \nDLLs and shared libraries. ACM Transactions on Programming Languages and Systems 24, 6 (2002), 711 804. \n[15] Eclipse, http://www.eclipse.org. [16] ECMA. Standard ECMA-335: Common Language Infrastructure, 2002. \n[17] EJB 3.0 EXPERT GROUP. JSR 220: Enterprise JavaBeans Version 3.0, June 2005. [18] EWING,M., AND TROAN, \nE. The RPM packaging system. In Proceedings of the 1st Conference on Freely Redistributable Software \n(1996). [19] FLATT,M., AND FELLEISEN, M. Units: Cool modules for HOT languages. In PLDI 98 (1998), pp. \n236 248. [20] GLEW,N., AND MORRISETT, G. Type-safe linking and modular assembly language. In POPL 99 \n(1999), pp. 250 261. [21] GORDON,A. The .NET and COM Interoperability Handbook. Pearson Education, Inc., \nUpper Saddle River, NJ, USA, 2003. [22] HALL,R.S., HEIMBIGNER,D. M., AND WOLF, A. L. Evaluating software \ndeployment languages and schema. In ICSM 98: Pro\u00adceedings of the International Conference on Software \nMaintenance (Washington, DC, USA, 1998), IEEE Computer Society, p. 177. [23] HICKS,M. W., MOORE,J. T., \nAND NETTLES, S. Dynamic software updating. In PLDI 01 (2001), pp. 13 23. [24] HILLMAN,J., AND WARREN, \nI. An Open Framework for Dynamic Recon.guration. In ICSE 04 (2004), pp. 594 603. [25] Installshield, \nhttp://www.installshield.com. [26] LISKOV,B., AND WING, J. A behavioral notion of subtyping. ACM Transactions \non Programming Languages and Systems 16,6 (Nov. 1994), 1811 1841. [27] LIU,Y. D., AND SMITH, S. F. Modules \nWith Interfaces for Dynamic Linking and Communication. In ECOOP 04 (2004), pp. 414 439. [28] LIU,Y. D., \nAND SMITH, S. F. Interaction-based Programming with Classages. In OOPSLA 05 (2005), pp. 191 209. [29] \nLIU,Y. D., AND SMITH, S. F. A Formal Framework for Component Deployment (Long Version), http://www.cs.jhu.edu/~yliu/deploy/. \nTech. rep., The Johns Hopkins University, Baltimore, Maryland, March 2006. [30] MCCAMANT,S., AND ERNST, \nM. D. Early identi.cation of incompatibilities in multi-component upgrades. In Proceedings of the 18th \nECOOP (2004), pp. 440 464. [31] MCDIRMID,S., FLATT,M., AND HSIEH, W. Jiazzi: New-Age Components for Old-Fashioned \nJava. In OOPSLA 01 (2001), pp. 211 222. [32] MEIJER,E., AND GOUGH, J. Technical Overview of the Common \nLanguage Runtime, 2000. [33] MICROSOFT. Component Object Model Technologies, http://www.microsoft.com/com/. \n[34] Mono, http://www.mono-project.com. [35] MSDN. Shared Source Common Language Infrastructure 1.0 Release, \nhttp://msdn.microsoft.com/net/sscli/. [36] OBJECT MANAGEMENT GROUP. Deployment and Con.guration of Component-based \nDistributed Applications Speci.cation, July 2003. [37] OSGI. Open services gateway initiative service \nplatform, release 4 core, available at http://www.osgi.org, 2005. [38] PARRISH,A., DIXON,B., AND CORDES, \nD. A conceptual foundation for component-based software deployment. Journal of Systems and Software 57, \n3 (2001), 193 200. [39] PIETREK, M. Avoiding DLL hell: Introducing application metadata in the microsoft \n.NET framework. MSDN Magazine, available at http://msdn.microsoft.com (2000). [40] Portage, http://www.gentoo.org. \n[41] REID,A., FLATT,M., STOLLER,L., LEPREAU,J., AND EIDE,E. Knit: Component composition for systems software. \nIn Proc. of the 4th Operating Systems Design and Implementation (OSDI) (October 2000), pp. 347 360. [42] \nRINAT,R., AND SMITH, S. F. Modular internet programming with cells. In Proceedings of the 16th ECOOP \n(2002), pp. 257 280. [43] Rubygems, http://rubyforge.org/projects/rubygems/. [44] SZYPERSKI,C. Component \nSoftware: Beyond Object-Oriented Programming. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, \nUSA, 2002. \n\t\t\t", "proc_id": "1167473", "abstract": "Software deployment is a complex process, and industrial-strength frameworks such as .NET, Java, and CORBA all provide explicit support for component deployment. However, these frameworks are not built around fundamental principles as much as they are engineering efforts closely tied to particulars of the respective systems. Here we aim to elucidate the fundamental principles of software deployment, in a platform-independent manner. Issues that need to be addressed include deployment unit design, <i>when, where</i> and <i>how</i> to wire components together, versioning, version dependencies, and hot-deployment of components. We define the <i>application buildbox</i> as the place where software is developed and deployed, and define a formal Labeled Transition System (LTS) on the buildbox with transitions for deployment operations that include build, install, ship, and update. We establish formal properties of the LTS, including the fact that if a component is shipped with a certain version dependency, then at run time that dependency must be satisfied with a compatible version. Our treatment of deployment is both platform- and vendor-independent, and we show how it models the core mechanisms of the industrial-strength deployment frameworks.", "authors": [{"name": "Yu David Liu", "author_profile_id": "81414612105", "affiliation": "The Johns Hopkins University", "person_id": "P753326", "email_address": "", "orcid_id": ""}, {"name": "Scott F. Smith", "author_profile_id": "81381593469", "affiliation": "The Johns Hopkins University", "person_id": "PP77028857", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167502", "year": "2006", "article_id": "1167502", "conference": "OOPSLA", "title": "A formal framework for component deployment", "url": "http://dl.acm.org/citation.cfm?id=1167502"}