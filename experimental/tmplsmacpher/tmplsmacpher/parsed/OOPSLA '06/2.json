{"article_publication_date": "10-16-2006", "fulltext": "\n Statically Scoped Object Adaptation with Expanders Alessandro Warth Milan Stanojevic\u00b4Todd Millstein \nComputer Science Department University of California, Los Angeles {awarth,milanst,todd}@cs.ucla.edu \nAbstract This paper introduces the expander, a new object-oriented (OO) programming language construct \ndesigned to support object adap\u00adtation. Expanders allow existing classes to be noninvasively up\u00addated \nwith new methods, .elds, and superinterfaces. Each client can customize its view of a class by explicitly \nimporting any num\u00adber of expanders. This view then applies to all instances of that class, including \nobjects passed to the client from other components. A form of expander overriding allows expanders to \ninteract natu\u00adrally with OO-style inheritance. We describe the design, implementation, and evaluation \nof eJava, an extension to Java supporting expanders. We illustrate eJava s syntax and semantics through \nseveral examples. The stat\u00adically scoped nature of expander usage allows for a modular static type system \nthat prevents several important classes of errors. We describe this modular static type system informally, \nformalize eJava and its type system in an extension to Featherweight Java, and prove a type soundness \ntheorem for the formalization. We also de\u00adscribe a modular compilation strategy for eJava, which we have \nimplemented using the Polyglot extensible compiler framework. Finally, we illustrate the practical bene.ts \nof eJava by using this compiler in two experiments. Categories and Subject Descriptors D.1.5 [Programming \nTech\u00adniques]: Object-oriented Programming; D.3.3 [Programming Languages]: Language Constructs and Features \nClasses and ob\u00adjects General Terms Design, Languages Keywords expanders, object adaptation, modular typechecking \n 1. Introduction Inheritance in object-oriented (OO) languages provides a form of extensibility for classes. \nA client of a class C can use inheritance to easily create a customized version of C without requiring \nsource\u00adcode access to or recompilation of C. Further, the modular static type systems in mainstream languages \nlike Java and C# ensure that instances of this subclass can be safely used wherever a C instance is expected. \nHowever, several programming scenarios require forms of ob\u00adject adaptation, and today s OO languages \ndo not easily support Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 06 October 22 26, 2006, Portland, Oregon, USA. Copyright c . 2006 ACM 1-59593-348-4/06/0010. \n. . $5.00. this idiom. For example, consider a database of business objects, which a particular client \nwishes to display in an application-speci.c manner. The client likely needs to add new methods to these \nob\u00adjects, and possibly to make these objects meet a client-speci.c in\u00adterface. Inheritance would allow \na new class to have these new behaviors but would do nothing to augment the existing objects. Design \npatterns like adapter and visitor [15] provide protocols that can be used to achieve the desired extensibility. \nHowever, these pat\u00adterns are often tedious and error prone to implement, can require advance planning \non the part of the original implementer of the class being extended, require invasive modi.cations whenever \nthe adapted class hierarchy is augmented, and often rely on statically unsafe constructs like type casts. \nIn this paper, we introduce the expander, a new language con\u00adstruct that provides explicit support for \nobject adaptation. An ex\u00adpander is a repository for adding new behaviors to existing classes and can \ninclude new methods, .elds, and superinterfaces. Clients of an expander may make use of these additional \nbehaviors on any ob\u00adject of the original class (or a subclass), including objects passed to the client \nfrom other components. Expanders also interact in a nat\u00adural way with inheritance: expanders can be overridden \nfor particu\u00adlar subclasses, and message sends dynamically dispatch to the best method for the given receiver, \nas with traditional message sends. There is a large body of research into mechanisms for increasing the \nextensibility of classes. Expanders are distinguished by a novel combination of design properties that \nare targeted to support object adaptation: In-place adaptation. An expander updates an existing class \nwith new behaviors, rather than creating a new class that contains the additional behaviors. This design \nchoice is critical for support of object adaptation. In particular, the new behaviors in an expander \nare available for use on instances of the original class, regardless of where or when those instances \nwere created. This design contrasts with the variety of proposals for .exible class extensibility, including \nmixins [5, 13], traits [28], proposals that include a form of dependently typed classes [10, 11, 21, \n23], and parameterized module systems for OO languages [12, 20]. These works have a very different goal \nfrom ours and are quite complementary. The customizations supported by these languages provide for .ne-grained \nforms of code reuse across classes and class hierarchies but do nothing to adapt existing objects. Indeed, \ntypically some advance planning, for example via the factory de\u00adsign pattern [15] or a form of module \nparameterization, is required to ensure that the full customization of a class can be produced be\u00adfore \nany instances are created. In contrast, expanders support object adaptation and allow multiple clients \nto view the same object in dif\u00adferent ways, but they do not provide code reuse across classes and class \nhierarchies. Statically scoped adaptation. Expanders target the problem of adapting existing classes \nto the needs of new clients, without affecting the behavior of existing clients. This focus led us to \na design whereby each client explicitly imports the expanders that are needed in order to perform its \ntask; all other expanders are out of scope and cannot affect the client s behavior. In addition to making \neach client s behavior easier to reason about, this static scoping of expanders naturally allows an object \nto be expanded in different ways by different clients in the same program without any con.ict. This design \ncontrasts with the inter-type declarations in aspect\u00adoriented languages like AspectJ [19], which also \nallow existing classes to be augmented with new methods, .elds, and superinter\u00adfaces. While aspects can \nbe used for object adaptation, such adapta\u00adtion affects all clients of a class implicitly, including \nexisting ones. This power can be quite useful, but it also makes it dif.cult to un\u00adderstand how a given \nclient will behave without global knowledge of all aspects in the program. Modular type safety. The existence \nof multiple versions of a class has the potential to cause erroneous or undesirable behavior at run time, \nwhereby a .eld or method of one version is expected but another is actually used. This problem is exacerbated \nin the presence of inheritance, since subclasses of the original class may add behaviors that clash with \nthose added by an expander. Aside from violating programmer expectations, these kinds of problems also \npotentially compromise type safety, for example if a .eld of one type is expected but a .eld of a different \ntype is actually used. Because of the static scoping of expanders, it is possible to perform modular \nstatic checking to guarantee type safety in the presence of expanders. A class that passes these modular \nchecks cannot suffer from the kinds of errors described above, regardless of what unknown classes and \nexpanders are ultimately linked into the .nal application. To our knowledge, this guarantee of modular \ntype safety is unique among languages that are expressive enough to support object adaptation, including \nthe AspectJ language de\u00adscribed above and the recent work on Classboxes [4, 3]. Multi-Java [7, 6] provides \nmodular typechecking for the addition of new methods to existing classes. However, MultiJava does not \nallow new .elds or superinterfaces to be added to existing classes, so it is unable to express many object \nadaptation scenarios. We have instantiated our notion of expanders in the language eJava, a backward-compatible \nextension to Java. We have designed a modular type system for eJava as well as a modular compilation \nstrategy from eJava to Java, and we have implemented both in the Polyglot extensible compiler framework \n[22]. We have also formalized eJava as an extension of Featherweight Java (FJ) [18] that we call Featherweight \neJava (FeJ), and we have proven its modular type system sound. Finally, we have used our eJava implementation \nto gain experi\u00adence with the language and gauge its practical utility. First, we used eJava to build \na small application that employs Java s Swing library to display some existing business objects in an \napplication-speci.c manner, and we compare the bene.ts and limitations against an implementation in pure \nJava. Second, we performed an exploratory study on the Eclipse integrated development environment [8]. \nWe identify several Java-based extensibility idioms used in the imple\u00admentation of Eclipse, and we explore \nthe ways in which expanders can allow these idioms to be more naturally and reliably expressed. The rest \nof the paper is structured as follows. Section 2 intro\u00adduces expanders by a number of examples. Section \n3 details eJava s method-lookup semantics and associated static typechecks. Sec\u00adtion 4 describes the \nFeJ formalism, which provides a more pre\u00adcise description of the language and its modular type system. \nSec\u00adtion 5 describes the modular compilation strategy for eJava, as im\u00adplemented in the eJava compiler. \nSection 6 discusses our two ex\u00adperiments with the language. Section 7 compares expanders with related \nwork, and Section 8 concludes.  Figure 1. An expression hierarchy.  2. Expanders This section informally \ndescribes the capabilities of expanders and their interaction with the other features of Java. As a running \nexample, consider a Parser class that parses a simple language of expressions supporting integers, .oating-point \nnumbers, and addition. The Parser has a parse method that accepts a String and produces an abstract syntax \ntree (AST), which is represented using the Expr class hierarchy shown in Figure 1. We illustrate eJava \ns expressiveness and .exibility by considering a number of ways in which clients may wish to employ this \nparser as part of a larger application. To reuse the parser, clients must .rst customize it to their \nneeds. eJava allows each client s customizations to be expressed without modifying or requiring access \nto the source code of the parser or the Expr hierarchy, without requiring any advance planning by the \nimplementer of the parser, and without interfering with the customizations of other clients. 2.1 Noninvasive \nVisitors with Expanders It is natural for clients to wish to augment the Expr hierarchy with new methods, \nin order to perform new passes over the AST. For example, suppose a client wishes to add an eval method \nthat eval\u00aduates an expression and returns the resulting value. One approach would be to create a subclass \nEvalExpr of Expr that includes such a method, as well as new classes like EvalPlus and EvalInt. However, \nthe lack of multiple implementation inheritance in Java would require this approach to duplicate a signi.cant \namount of code. For example, EvalPlus must inherit from EvalExpr in order to override its eval method, \nbut then it cannot also inherit from Plus, forcing the client to duplicate all of the existing capabilities \nof addition expressions. Further, this approach would not allow the existing Parser class to be reused, \nsince it creates instances of the original expression classes rather than the new ones. The standard \napproach to this problem is the visitor design pat\u00adtern [15], which allows clients to easily add new \nfunctionality to ex\u00adisting classes externally. However, this approach requires the origi\u00adnal implementer \nof the expression hierarchy to have anticipated the need for visitors, by providing a Visitor class and \nthe appropri\u00adate accept methods for each kind of expression. The visitor pat\u00adtern also has other, more \nminor, problems, for example the fact that every external operation must have the same argument and result \ntypes. Therefore, clients are often forced to add new functionality us\u00ading utility classes such as Evaluator, \nshown in Figure 2. While this approach allows the new method to be added without modifying existing code, \nit has several drawbacks. Since the method is placed in the Evaluator class, dynamic dispatch on the \nExpr instance must be performed manually via runtime type tests and type casts. These type tests must \nbe executed in the correct order (from most\u00adto least-speci.c), which is easy to get wrong for large and \ncom\u00adplex type hierarchies. Further, using utility classes like Evaluator // .le Evaluator.java package \neval; import ast.*; public class Evaluator { public static Value eval(Expr e) { if (e instanceof Value) \nreturn (Value)e; else if (e instanceof Plus) { Plus p = (Plus)e; Value v1 = eval(p.op1()); Value v2 = \neval(p.op2()); // ... } else throw new EvalError(); } } Figure 2. An external evaluator for Exprs in \nJava. // .le Calculator.java package calc; import parse.Parser; import ast.*; import eval.Evaluator; \npublic class Calculator { public void process(String s) { Expr e = new Parser().parse(s); Value ans = \nEvaluator.eval(e); ans.display(System.out); } } Figure 3. A client of the evaluator in Figure 2. forces \nclients to distinguish syntactically between calls to external methods of Expr like eval and calls to \nordinary methods of the hierarchy like display. This difference is illustrated by the sample client in \nFigure 3, which implements a calculator application using Parser and Evaluator. Expanders in eJava provide \na natural solution to these problems. An expander is a repository for augmenting an existing class in \nseveral different ways, including the introduction of new methods, without requiring source-code access \nto the original class. For example, an expander that adds an eval method to Expr would look as follows: \nexpander EX of Expr { public Value eval() {...} } This expander is given the name EX and is declared \nto expand the Expr class. The body of the expander then provides the new eval method, just as it would \nbe declared in the original class. For example, the method has an implicit receiver argument of type \nExpr which can be referenced as this in the method s body. An expander can declare any number of new \nmethods. We could choose to implement the semantics of expression eval\u00aduation entirely within the eval \nmethod of the above expander, anal\u00adogous to the code in Figure 2. However, expanders support a bet\u00adter \nsolution through expander overriding, as shown in Figure 4. In addition to the expander for Expr, the \ncompilation unit (i.e., .le) shown includes two expanders that provide overriding implemen\u00adtations of \neval for particular subclasses of Expr. We say that the three expanders are in the same expander family, \nwhich is a collec\u00ad // .le EX.ej package eval; import ast.*; public expander EX of Expr { public Value \neval() { throw new EvalError(); } } public expander EX of Value { public Value eval() { return this; \n} } public expander EX of Plus { public Value eval() { Value v1 = op1().eval(); Value v2 = op2().eval(); \n// ... } } Figure 4. An external evaluator for Exprs in eJava. tion of expanders of the same name. Each \nexpander family has a unique top expander: all other expanders in the family augment a class that is \na subclass of the top expander s class. Therefore, the .rst expander in the .gure is the top expander \nfor EX. The code in Figure 4 has the same behavior as the eval method in Figure 2. However, the use of \nexpander overriding obviates the need for instanceof tests and type casts. Instead, the method implementations \nmake use of Java s ordinary dynamic dispatch on the receiver argument, just as if they were declared \nin the original expression classes. We allow methods in expanders to override methods in other expanders, \nas the example shows. However, a method in an ex\u00adpander cannot override an ordinary method of the associated \nclass. This restriction is the result of a tradeoff between modular com\u00adpilation and external method \noverriding that has been previously recognized [6].1 Further, we disallow overriding expanders from declaring \nmembers that are not declared in the top expander. This simpli.cation ensures that an expander family \npresents a unique interface to clients, and it results in no loss of expressiveness since a separate \nexpander family can be created to contain any new members desired for a particular class and its subclasses. \nAn expander does not have privileged access to its associated receiver class, instead obeying the same \nvisibility rules as other clients of the class. This restriction ensures that an expander does not break \nany internal invariants of existing classes. An expander as well as its members can have the usual Java \nprivacy modi.ers. These modi.ers are interpreted relative to the expander s location, rather than that \nof the original class. For example, a method with package visibility in an expander is only accessible \nwithin the package in which that expander (not the class it expands) was declared. Figure 5 shows the \nnew version of our calculator application that uses EX (instead of Evaluator). In order to make use of \nthe expanded view of the expression hierarchy, the expander family EX must be explicitly used, with a \nsyntax analogous to Java s import statement. The methods declared for the EX expander family are thereby \nmade available for use, via the same syntax as if they were declared in the original classes. This is \nillustrated by the invocation e.eval() in the .gure. Without the use statement, that invocation would \nfail to typecheck, since Expr does not originally support an eval method. 1 An expander is still allowed \nto statically overload methods of the associ\u00adated class. // .le Calculator.ej package calc; import parse.Parser; \nimport ast.*; use eval.EX; public class Calculator { public void process(String s) { Expr e = new Parser().parse(s); \nValue ans = e.eval(); ans.display(System.out); } } Figure 5. A client of the evaluator in Figure 4. The \nexplicit import of expanders via use enables modular rea\u00adsoning about clients. For example, any client \nof the expression hi\u00aderarchy that does not use EX can be safely typechecked without knowledge of the \nEX expander family. Further, there can exist mul\u00adtiple expander families in a program that augment the \nexpression hierarchy with an eval method. Each client in the program can use the version of expression \nevaluation that suits its needs, without be\u00ading affected by the other versions. The rules for method \nlookup, as well as our static typechecks to ensure that method lookup will al\u00adways succeed at run time, \nare described in Section 3. An expander can be used to add functionality to any class, including final \nclasses. For example, one could implement an expander of Java s String class that adds a helper method \nlike removeWhitespace(). Clients can then use this expander and invoke removeWhitespace on any value \nof type String, including string literals. Because an expander does not have privileged access to the \nclass being expanded, this expander cannot violate any of the internal invariants of Java s String class. \n 2.2 Adapting with Expanders While the ability to add methods to existing classes from the out\u00adside \nis very useful, often it is not enough on its own. For example, suppose that our Calculator class is \nto be used within an appli\u00adcation in which all console output must be enqueued in a printing thread via \nthe enqueue() method of the Printer class: public static void enqueue(Printable p) {...} This method \ntakes an instance of the Printable interface, which is declared as follows: public interface Printable \n{ void print(); } In Java, a programmer could use the adapter design pattern [15] to adapt existing instances \nof Expr and subclasses to support the Printable interface. To do so, the programmer would create a wrapper \nclass PrintableExpr for Expr that meets the Printable interface and implements the associated methods \nby appropriately forwarding to the methods of the underlying expression. Whenever an instance of Expr \nor a subclass needs to be treated as Printable, it would .rst be adapted by explicitly constructing an \ninstance of PrintableExpr, passing the adaptee object as a parameter. Expanders provide a simpler and \nmore natural solution to this problem, as shown in Figure 6. An expander can use the implements clause \nto declare that the class being expanded (and its subclasses) implements any number of new interfaces. \nAn in\u00adterface can be implemented by a combination of methods already declared or inherited in the original \nclass and methods declared in the expander. Overriding expanders can also be used in conjunc\u00adtion with \nthe ability to meet new interfaces. For example, we could // .le PX.ej package exprAdapt; import ast.*; \nimport printer.Printable; public expander PX of Expr implements Printable { public void print() { display(System.out); \n} } Figure 6. Adapting Exprs to Printables with expanders. // .le Calculator.ej package calc; import \nparse.Parser; import ast.*; import printer.Printer; use eval.EX; use exprAdapt.PX; public class Calculator \n{ public void process(String s) { Expr e = new Parser().parse(s); Value ans = e.eval(); Printer.enqueue(ans); \n } } Figure 7. A fancier calculator, which uses both evaluation and printing functionality. provide \nan overriding expander to de.ne print specially for Plus expressions. Figure 7 shows an upgraded version \nof our Calculator class, which uses both evaluation and printing functionality. The compi\u00adlation unit \nnow uses both EX and PX, allowing Expr instances to be viewed as containing both eval and print methods, \nas well as meeting the Printable interface. Since Value is a subclass of Expr, the ans instance of Value \nis a typesafe argument to enqueue, without requiring any explicit adaptation as would be necessary with \nthe adapter design pattern. It is important to note that the im\u00adplementer of the Printer class need not \nknow about the existence of either the Expr hierarchy or its PX expander. All that the enqueue method \nof Printer requires is that the given argument meets the Printable interface; our modular compilation \nstrategy described in Section 5 ensures that this requirement is satis.ed. 2.3 Adding State with Expanders \nExpanders can also be used to add state to existing classes. An example is shown in Figure 8, which augments \nthe expression hierarchy with type information. A type .eld is added to Expr (and subclasses) to store \nan expression s type, along with a getter method and a method to compute the type. 2.4 Expanding Interfaces \nExpanders can also be used to add functionality to interfaces. For example, Figure 9 uses an expander \nto add a printAll method to instances of Java s Iterable interface, which prints all elements of the \niterable collection. The expander makes use of the iterator method de.ned for Iterable. An expander for \nan interface is not tied to a particular class hi\u00aderarchy. Instead, it can be used to expand any class \nthat implements the speci.ed interface. This interface acts as the abstract require\u00adments of that expander, \nso the expander can be considered to be parameterized by the classes that it expands. // .le TX.ej package \ntypes; import ast.*; public expander TX of Expr { private Type type = null; public void typecheck() \n{ type = new ErrType(); } public Type type() { if (type == null) typecheck(); return type; } } public \nexpander TX of Int { public void typecheck() { type = new IntType(); } } public expander TX of Flt { \npublic void typecheck() { type = new FltType(); } } public expander TX of Plus { public void typecheck() \n{ Type t1 = op1().type(); Type t2 = op2().type(); // ... } } Figure 8. Adding state in an expander. \n// .le IX.ej import java.util.*; public expander IX of Iterable { public void printAll() { Iterator it \n= iterator(); while (it.hasNext()) System.out.println(it.next()); } } Figure 9. An expander for an interface. \n// .le SPX.ej package printer; public expander SPX of Printable { public void safePrint() { synchronized \n(Printable.class) { print(); } } } Figure 10. SPX, the safe printing expander. Further, other expanders \ncan be used to increase the applicabil\u00adity of an interface-based expander. As shown earlier, an expander \ncan adapt an existing class to support a new interface. This capa\u00adbility can therefore be used to allow \nan existing class to meet the requirements of an interface-based expander. As an example, Figure 10 shows \nSPX, the safe printing ex\u00adpander, which augments instances of the Printable interface with safe-printing \nfunctionality (the safePrint method uses the Printable class as a lock to ensure that no two Printable \nobjects are ever printed to the console at the same time). Although Expr does not originally implement \nPrintable, its instances can be aug\u00ad // .le FancyCalculator.ej package client; import ast.*; import \nfancyParse.Parser; import fancyAST.Minus; use eval.EX; expander EX of Minus { public Value eval() {...} \n} public class FancyCalculator { public void process(String s) { Expr e = new Parser().parse(s); Value \nans = e.eval(); ans.display(System.out); } } Figure 11. Adding a new expander to an existing expander \nfamily. mented by SPX provided we .rst adapt them to the Printable in\u00adterface by using PX, the Printable \nexpander from Figure 6. 2.5 Locally Augmenting Expander Families In the examples so far, all expanders \nin a given family were de\u00adclared in the same compilation unit. However, it is possible for an expander \nfamily s associated class hierarchy to be augmented by clients with new subclasses. When this happens, \nit is often de\u00adsirable to augment the expander family with overriding expanders to provide special-purpose \nbehavior for these classes. To this end, eJava allows a client of an expander family to locally augment \nthat family with overriding expanders for new classes. The additional expanders are hygienic: they only \naffect the expander family s be\u00adhavior within the current compilation unit. For example, suppose a client \nof the original expression hierar\u00adchy adds a subclass Minus of Expr and creates a new parser to han\u00addle \nsubtraction. Figure 11 shows how a client of the EX expander can update it to handle Minus appropriately. \nThe call to eval in FancyCalculator will dynamically dispatch to the new eval im\u00adplementation whenever \nthe receiver is an instance of Minus.  3. Method Lookup and Modular Typechecking eJava s rules for method \nlookup are a natural generalization of those of Java. At compile time, each message send expression in \na program is determined to refer to a unique method family, or else a static error is signaled. At run \ntime, the most-speci.c method for the given receiver argument in the statically determined method family \nis selected and invoked. We discuss each of these phases in turn, along with the corresponding static \nchecks to ensure that method lookup always succeeds at run time. The section ends by illustrating a type \nhole that can arise in other languages for object adaptation, which our semantics for method lookup safely \navoids. 3.1 Static Method Family Selection Each method in eJava, and in Java, can be thought of as belonging \nto a unique method family. The method family of a method m1 is determined as follows. If m1 overrides \na method m2, then m1 is in the same method family as m2. Otherwise, m1 belongs to a different method \nfamily. The Java typechecker statically ensures that there is a single best method family for each message \nsend expression in a program, as discussed in the Java Language Speci.cation [16], \u00a715.12. In the presence \nof static overloading, a method family is essentially de.ned by the method s name, number of arguments, \nand static argument types. An error is signaled if either there are no applicable method families for \na given message send or there are multiple applicable families but no most-speci.c one. In eJava, we \n.rst use Java s rules to .nd a most-speci.c method family for a message send expression, completely ignoring \nex\u00adpanders. If a unique such method family exists, we are done. If there are multiple such families but \nno most-speci.c one, then an ambiguity error occurs, as in Java. However, if there are no ap\u00adplicable \nmethod families, we then search for a unique applicable method family in the expanders that are used \nby the current compi\u00adlation unit, signaling a compile-time error otherwise. As in Java, the method family \nassociated with a method in an expander is de.ned by the method s name, number of arguments, and static \nargument types, and additionally by the name of the enclosing expander. The rules for statically determining \nto which .eld declaration a .eld access refers are analogous. To illustrate these rules, consider statically \ndetermining the method family for the invocation e.eval() in Figure 5: Given the de.nitions of the Expr \nclass (Figure 1) and the EX expander family (Figure 4), the invocation is statically deter\u00admined to invoke \nthe method family consisting of the three eval methods in the EX expanders.  If the use EX; statement \nwere omitted from Figure 5, the eJava typechecker would signal a static error, since there is no appli\u00adcable \nmethod family for the invocation.  If the original Expr class contained a (possibly abstract) zero\u00adargument \neval method, then that method s associated family would be selected, even in the presence of the use \nEX; state\u00adment.  Suppose there existed another expander EX2 that also de.nes a zero-argument eval method \nfor Expr. If Figure 5 were aug\u00admented to include the statement use EX2;, the eJava type\u00adchecker would \nsignal a static error, since the eval method fami\u00adlies in EX and EX2 are ambiguous. However, the error \nis only sig\u00adnaled because of the call to eval. If that call were removed, EX and EX2 could both be used \nwithout problems, allowing other members of these expanders to be accessed.  Finally, we also provide \na mechanism for the programmer to explicitly specify the intended method family, which is useful for \nhandling ambiguous situations. If the receiver in a method invo\u00adcation has the form expr with X, where \nexpr is an eJava ex\u00adpression and X is an expander name, then only the expander X is searched for an appropriate \nmethod family; neither the origi\u00adnal class of the receiver nor any other expanders are considered. For \nexample, in the scenario described in the last bullet above, the programmer can cause static method-family \nselection to succeed by explicitly declaring which expander is intended, e.g., (e with EX2).eval(). The \nwith expression can also be used to multiply expand an expression. For example, the expander SPX can \nbe used to adapt an expression e of type Expr via the syntax (e with PX) with SPX, thereby allowing the \nsafePrint method to be invoked.  3.2 Dynamic Method Selection Run-time method lookup in eJava is de.ned \nas in Java: the dynamic class of the receiver argument is used to .nd the most-speci.c applicable method \nfrom the statically determined method family, and that method is then invoked. For example, if the run-time \nclass of e in Figure 5 is Plus, then the .rst and third eval methods in Figure 4 are applicable, and \nthe latter is the most-speci.c applicable method. Any local overriding expanders are taken into account \nwhen a client invokes a method family in an expander, allowing the new methods to be dispatched to appropriately. \nAs part of modular static typechecking of each class, Java en\u00adsures that each method family is exhaustive \nand unambiguous, thereby guaranteeing that run-time method lookup on that family will always succeed. \nFor example, Java checks that a concrete class C declares or inherits a concrete method for every method \nfamily declared in a superinterface or superclass. This check ensures ex\u00adhaustiveness: instances of C \nand its subclasses are guaranteed to have at least one applicable method in each inherited method fam\u00adily. \nJava lacks multiple inheritance of classes, so there is no possi\u00adbility of run-time ambiguities. eJava \nincludes additional modular static requirements on ex\u00adpanders to ensure that run-time method lookup always \nsucceeds. First, an expander cannot contain an abstract method, even if the class being expanded is abstract. \nThis requirement ensures exhaus\u00adtiveness in the presence of any unknown concrete subclasses of that class, \nwhich must always be assumed to exist given only a modu\u00adlar view of the program. Second, an overriding \nexpander can only expand a class, not an interface. This requirement prevents ambi\u00adguities that are not \nmodularly detectable, which can occur if an un\u00adknown class implements multiple interfaces. Both requirements \nare analogous to requirements on MultiJava s open classes [7], which also allow methods to be de.ned \nexternal to their classes. 3.3 Preventing Accidental Method Overriding Our method lookup rules rely \non the way in which a program s methods are partitioned into method families. A key property of eJava \nis the ability to modularly determine the method family to which a method belongs. A method s associated \nmethod family is de.ned to be the same as that of any method that it overrides, and the methods that \na particular method overrides can be determined based on information that is available in the static \nscope where the method is declared. This property of eJava is shared by Java, but it is not shared by \nother languages that support forms of object adaptation, including AspectJ [19] and Classboxes [4, 3]. \nTo illustrate this distinction, consider again the Expr class hier\u00adarchy (Figure 1) and the EX expander \nfamily (Figure 4). As men\u00adtioned earlier, if another expander EX2 for Expr also de.nes an eval method, \nthis method (and any eval methods in overriding expanders for EX2) is considered to belong to a different \nmethod family from the eval methods for EX. If these methods were all considered part of the same method \nfamily, there could be run-time ambiguities that are not modularly detectable, for example because there \nare two eval methods de.ned for the class Expr. Worse, there may be no ambiguity for a given receiver \nargument to eval, but clients will simply get unexpected behavior at run time. For example, suppose EX2 \nde.nes an eval method for some sub\u00adclass SpecialPlus of Plus. If the EX and EX2 eval methods were all \nconsidered part of the same method family, a client that uses EX and invokes eval on an instance of SpecialPlus \nwould unexpect\u00adedly execute the method from EX2. Aside from potentially having the wrong behavior, this \nsituation is not modularly typesafe, since for example the eval methods in EX2 could well have a different \nreturn type from those in EX. Since neither EX nor EX2 is aware of the other modularly, this clash eludes \nmodular typechecking. Analogous con.icts can occur between a class and an expander, instead of between \ntwo expanders. For example, consider a client of a class C that creates an expander containing a print \nmethod and uses this method to display an array of Cs in an application\u00adspeci.c way. By our semantics, \nthis print method is considered to be in its own method family. Therefore, even if the array contains \nsome instances of D, a subclass of C that happens to provide its own print method, the client will behave \nas expected, using only the expander s implementation of print. If the two print methods were considered \nto be part of the same method family, then D s print method would be invoked and our application would \nbehave incorrectly, since D s print method likely does not conform to the client s application-speci.c \ndisplay format. TD ::= class C extends D implements I {T f; K M}| interface I extends I {MH}| expander \nX of T implements I {T f=v; M} O O ::= of C {M} K ::= C(T f) {super(f); this.f=f;} M ::= T m(T x) {return \nt;} MH ::= T m(T x); T ::= C | I | TX t ::= x | t.f | t.m(f) | new C(t) | (T) t | t with X | peel t \nv ::= new C(v) | v with X Figure 12. The syntax of Featherweight eJava. To our knowledge, eJava is the \nonly language for object adapta\u00adtion that modularly ensures the absence of these accidental overrid\u00ading \nerrors, and hence modularly ensures type safety. Two aspects in AspectJ that de.ne the same method for \na given class can easily cause such con.icts, and similarly for two classboxes that re.ne a given class \nin the same way. These errors can only be detected with global knowledge of all aspects or classboxes \nin the program that can affect a given class. For example, in the Classbox/J imple\u00admentation, clashes \ninvolving incompatible return types are only de\u00adtected by the regular Java typechecker, which runs after \nthe Class\u00adbox/J compiler weaves all re.nements in the program for a given class into that class s declaration. \nAccidental overriding that does not violate type safety, such as the print example above, is silently \nallowed by Classbox/J, causing potentially unintended behavior at run time. The next section formalizes \nour modular type system for eJava and proves its soundness.  4. Featherweight eJava This section describes \nFeatherweight eJava (FeJ), an extension of Featherweight Java (FJ) [18] that formalizes our notion of \nex\u00adpanders and its associated modular type system. Aside from mak\u00ading the eJava language semantics precise, \nFeJ also allows us to prove a type soundness theorem, which validates the suf.ciency of our modular type \nsystem for ruling out run-time type errors, includ\u00ading problems with accidental overriding. The full \ndetails of FeJ and its type soundness proof are available in our companion technical report [33]. 4.1 \nSyntax The syntax of FeJ is shown in Figure 12. We use notational conven\u00adtions and sanity conditions \nanalogous to those of FJ. For example, the syntax D denotes a sequence of zero or more elements of the \ndomain D. Also, an FeJ program consists of a type table TT , which maps class, interface, and expander \nnames to their associated dec\u00adlarations, and an expression. We comment on other conventions as necessary \nthroughout this section. FeJ augments FJ with interfaces and expanders. For simplicity, the expander \ndeclaration both provides the top expander and all overriding expanders (via the O portion of the declaration); \nlocal overriding expanders are not modeled. The eJava language largely infers where expansion must occur \nas part of static method family selection, as described in the previous section. FeJ programs are explicit \nabout expander usage: there are no use declarations, an object is expanded via the with expression, and \nan expanded object is unexpanded via the peel expression. Similarly, we include an explicit type TX for \nobjects of type T that are expanded by expander X. S<:T T<:T S<:T T<:U S<:U TT (C)= class C extends \nD implements I {...} C<:D TT (C)= class C extends D implements I {...} C<:Ii TT (I)= interface I extends \nJ {...} I<:Ji TT (X)= expander X of T implements I {...} O TX<:Ii S<:T SX<:TX Figure 13. Subtyping \nin FeJ.  4.2 Subtyping FeJ s subtyping judgment formalizes the relationship between ex\u00adpanded and unexpanded \nobjects; it is shown in Figure 13. The .rst three rules are the adaptation of FJ s subtyping rules to \nour context. The following two rules handle subtyping in the presence of Java\u00adstyle interfaces appropriately. \nThe next rule is the essence of object adaptation: an expanded object can be typed with any interface \nthat is implemented by the associated expander, allowing the expanded object to be passed wherever values \nmeeting that interface are ex\u00adpected. The .nal rule extends this ability for object adaptation to instances \nof any subtype of the type being expanded in an expander declaration. A notable absence from the subtyping \nrelation is the axiom TX<:T. Omitting this rule forces an expanded object to be unex\u00adpanded via peel \nbefore it is passed where a value of the original type is expected. It also ensures that methods in an \nexpander will not be treated as overriding methods in the unexpanded type. Both of these behaviors mirror \nthe semantics and implementation strat\u00adegy of the eJava language. Despite the absence of this subtyping \nrelationship, values of type TX may still access methods and .elds of the original type T, as we show \nbelow. In this way, for example, an expanded type may inherit methods from the original type in order \nto meet a new interface. 4.3 Dynamic Semantics Figure 14 provides the small-step operational semantics \nof FeJ and makes use of the helper rules in Figure 15. We only present the rules that relate to expanders; \nthe rest of FeJ is identical to FJ. The .rst two rules de.ne .eld lookup for expanded objects. If the \nexpander de.nes the .eld being accessed, then its associated value is returned. Otherwise, .eld lookup \nproceeds in the unexpanded object. The rules for method lookup on expanded objects are described next, \nand they depend on the mbody helper function, which .nds the best implementation of the method m for \nclass C in expander t -. t. G . t : T f ields(X)= T f=v (v with X).fi -. vi fields(X)= T g=v f ./g (v \nwith X).f-. v.f v = new C(v) mbody(m,X,C)=(x,t0) (v with X).m(u)-. [x .. u,this .. v with X]t0 v = \nv with X mbody(m, X,Object)=(x,t0) (v with X).m(u)-. [x .. u,this .. v with X]t0 TT (X)= expander X \nof T implements I {T f=v; M} O m is not de.ned in M (v with X).m(u)-. v.m(u) peel (v with X) -. v t0 \n-. t. 0 t0 with X -. t. 0 with X t0 -. t. 0 peel t0 -. peel t. 0 Figure 14. FeJ evaluation rules. f \nields(X)= Tf=v TT (X)= expander X of T implements I {Tf= v;M} O f ields(X)= T f=v mbody(m,X, C)= (x, \nt) TT (X)= expander X of T implements I {T f=v; M} O of C {M } . O U m(U x) {return t;} . M mbody(m,X,C)= \n(x,t) TT (X)= expander X of T implements I {T f=v; M} O of C {M } . Om is not de.ned in M TT (C)= class \nC extends D \u00b7\u00b7\u00b7 mbody(m,X, C)= mbody(m,X,D) TT (X)= expander X of T implements I {T f=v; M} O C is not \nde.ned in O TT (C)= class C extends D \u00b7\u00b7\u00b7 mbody(m,X, C)= mbody(m,X,D) TT (X)= expander X of T implements \nI {T f=v; M} O U m(U x) {return t;} . M mbody(m,X,Object)= (x, t) Figure 15. Helper rules for FeJ evaluation. \nG . t : T ftype(f, T)= U G . t.f : U G . t0: T0 mtype(m,T0)= T.T G . t: S S<: T G . t0.m(t): T TT (X)= \nexpander X of T implements I {...} O G . t : U U<:T G . t with X : UX G . t : TX G . peel t : T Figure \n16. FeJ typechecking for terms. X. There are four cases. If X has an overriding expander for C containing \na method m, then that method s body is returned. If X either has an overriding expander for C but that \nexpander does not override m, or if X has no overriding expander for C, then we recursively search for \nan overriding expander for C s direct superclass D. Finally, if C = Object, then the body of the m method \nin the top expander is returned. Although Object may not be a subtype of the expanded type, static typechecking \nensures that mbody is always used in a type-correct manner. Given this mbody function, the third rule \nin Figure 14 looks up the appropriate method body in X for the unexpanded object s run\u00adtime class C. \nThe next rule handles the case when the expanded value itself has the form v with X . In that case, the \ntop ex\u00adpander s method is always invoked, without considering overriding expanders. This semantics makes \nsense since the run-time type of the expanded value has the form TX , and such a type cannot be a subtype \nof any class type according to our subtype relation, so we are guaranteed that no overriding expanders \nare applicable. The semantics is encoded by invoking mbody with Object as the third argument. Finally, \nif the expander X does not de.ne m, then lookup proceeds in the unexpanded object. The rest of the rules \nin Figure 14 de.ne the semantics of with and peel, which are straightforward. 4.4 Static Semantics The \nrules for typechecking terms are presented in Figure 16, and helper functions are de.ned in Figure 17. \nAgain, only the rules related to expanders are shown. A .eld access is type-correct if an appropriate \n.eld can be found for the type of the receiver. For a receiver of type UX, the declaration of X is searched \nfor a .eld of the appropriate name. If the .eld is not found, the type U is searched for a de.nition \nof the .eld. In this way, expanded objects are allowed to access .elds of the unexpanded object (if they \nare not shadowed by the expander). Typechecking of method invocation proceeds analogously. The type rule \nfor an expression t with X ensures that the type of t is a subtype of the type expanded by X. The type \nrule for peel is straightforward. Finally, Figure 18 contains the rules for typechecking expander declarations. \nWe assume that the types being expanded in a given expander declaration are all pairwise distinct. Each \noverriding ex\u00adpander is required to be for a class that is a subtype of the type expanded by the top \nexpander. The third rule describes how meth\u00adods are typechecked. The method body is typechecked under \nthe assumption that the receiver this has the expanded type. The Over\u00adrideOK judgment is used for typechecking \nmethods in overriding expanders. In addition to the ordinary rules for typechecking meth\u00adods, this judgment \nrequires that a method of the same type sig\u00adnature appear in the top expander. That check is accomplished \nvia the override helper function. Finally, the reallyImplements function ensures that each expander truly \nmeets its declared interfaces. f type(f, T) = U TD OK f ields(X) = T f=v f type(fi,UX) = Ti f ields(X) \n= T g=v fi /. g f type(fi,UX) = f type(fi, U) expander O OK in X X . v : S S<:T M OK in X,T O OK in \nX reallyImplements(TX ,I) of T implements I {T f=v; M} O OK mtype(m, T) = T. T T T (X) = expander X of \nT implements I {T U m(U x) {return t;} . M mtype(m,SX) = U.U f=v; M} O T T (X) = expander X of T implements \nI C<:T M OverrideOK in X,C of C {M} OK in X M OK in X,T {...} O T T (X) = expander X of T implements \nI m is not de.ned in M mtype(m,SX) = mtype(m,S) {T f=v; M} O x : T,this : TX . t0 : U0 U0<:T0 T0 m(T \nx){return t0;} OK in X,T Figure 17. Helper rules for term typechecking.  A key property of this type \nsystem is modularity. Each class, interface, and expander is typechecked using only knowledge of its \nown declaration and the declarations of other types that it di\u00adrectly references. This means, for example, \nthat an expander is typechecked without knowledge of what other expanders exist for the type being expanded, \nand without knowledge of all subtypes of the type being expanded.  4.5 Type Soundness We have proven \na type soundness theorem for FeJ using the stan\u00addard progress and preservation style [34]. THEOREM 4.1. \n(Progress) If . t : T, then either t is a value, t contains a subexpression of the form (U)(v) where \n. v : S and S. <:U, or there exists some term s such that t -. s. THEOREM 4.2. (Type Preservation) If \nG . t : T and t -. s, then there exists some type S such that G . s : S and S<:T. The full proofs of \nthese theorems are available in our companion technical report [33]. Together the theorems imply that \nwell-typed FeJ programs cannot incur a type error at run time. This means that FeJ s modular type system \nis suf.cient to guarantee the absence of the kinds of type errors that are caused by accidental overriding, \nas described in Section 3.3.  5. Compilation The eJava compiler is built on top of the Polyglot extensible \ncompiler framework for Java [22]. Like other Polyglot-based lan\u00adguage implementations, our compiler translates \neJava programs into equivalent Java programs, which can then be compiled with a standard Java compiler \nand run on a standard Java virtual machine M OverrideOK in X,C override(m,X, T. T0) T0 m(T x){return \nt0;} OK in X,C T0 m(T x){return t0;} OverrideOK in X,C reallyImplements(T,I) TT (I)=interface I extends \nJ {MH} S m(S x);. MH implies mtype(m,T)= U.U and override(m, I, U.U) reallyImplements(T,J) reallyImplements(T,I) \noverride(m,X, T.T0) TT (X)= expander X of T implements I {T f=v; M} O U m(U x) {return t;} . M override(m,X, \nU. U) Figure 18. Typechecking for expander declarations. (JVM).2 Polyglot compiles Java 1.4, so our \neJava compiler inherits this limitation, for example lacking support for generics. We ex\u00adpect the issues \nfor generic expanders to be analogous to those for classes, and we plan to pursue such an extension in \nthe future. The eJava compiler translates each expander family to a single Java class with the same name. \nFigure 19 shows the code gener\u00adated for the EX expander from Figure 4. We refer to that example throughout \nthis section. 5.1 Wrapper Classes The functionality provided by an expander family is implemented in \na set of wrapper classes, one for each expander in the fam\u00adily. In our example, the wrapper classes EX$Expr, \nEX$Value, and 2 We have not yet given serious consideration to the option of adding support for expanders \nto the JVM, although we suspect this would allow for a much more ef.cient implementation. class EX { \npublic static final java.util.WeakHashMap<Expr, EX$$tate> cache = new java.util.WeakHashMap<Expr, EX$$tate>(); \npublic static class EX$$tate { public java.lang.ref.WeakReference<Expr> instance$ = null; public java.lang.ref.WeakReference<EX$Expr> \nwrapper$ = null; } public static class EX$Expr { protected final Expr instance; protected final EX$$tate \nstate; protected EX$Expr(Expr instance, EX$$tate state) { this.instance = instance; this.state = state; \n} public Value eval() { throw new EvalError(); } } public static class EX$Plus extends EX$Expr { protected \nEX$Plus(Expr instance, EX$$tate state) { super(instance, state); } public Value eval() {  Value v1 = \n(EX.expand(((Plus) instance).op1())).eval(); Value v2 = (EX.expand(((Plus) instance).op2())).eval(); \n// ... } } public static class EX$Value extends EX$Expr { protected EX$Value(Expr instance, EX$$tate \nstate) { super(instance, state); } public Value eval() { return (Value) instance; } } public static \nsynchronized EX$Expr expand(Expr instance) { EX$Expr r; EX$$tate state = cache.get(instance); if (state \n== null) {  state = new EX$$tate(); state.instance$ = new java.lang.ref.WeakReference<Expr>(instance); \ncache.put(instance, state); } else if (state.wrapper$ != null) { r = state.wrapper$.get(); if (r != \nnull) return r; } if (instance instanceof Plus) r = new EX$Plus(instance, state); else if (instance \ninstanceof Value) r = new EX$Value(instance, state); else  r = new EX$Expr(instance, state); state.wrapper$ \n= new java.lang.ref.WeakReference<EX$Expr>(r); return r; } } Figure 19. Java translation of the EX \nexpander from Figure 4. EX$Plus are generated for the expanders of EX whose associated classes are Expr, \nValue, and Plus, respectively. Each wrapper class holds a reference to the original (unex\u00adpanded) object. \nThis reference is used in the implementation of the methods of the expander. For instance, EX$Plus s \neval method uses it to call the op1 and op2 methods of its associated object. Note that the hierarchy \nof the wrapper classes mirrors the hierar\u00adchy of the types for which they were created. Consequently, \nin any given family, expanders of more speci.c types inherit and may override, when desired methods from \nexpanders of less speci.c types.  5.2 The expand Method Wrapper objects are created by the expander \ns expand method, which takes an unexpanded object and performs instanceof tests to determine the best \n(i.e., most speci.c) wrapper class to use for that object. The .rst part of the expand method in Figure \n19 is used to properly handle .elds in expanders; it is discussed in Section 5.4. Clients of an expander \ncall its expand method in order to ac\u00adcess functionality it provides. For example, in Figure 5 the call \ne.eval() is translated to (EX.expand(e)).eval(). 5.3 Interface-Implementing Expanders Expander families \nthat implement one or more interfaces, such as Figure 6 s PX, are also translated as described above. \nAdditionally, the wrapper class generated for the top expander s associated type is declared to implement \nthose interfaces. This enables the client to use the expanded object (returned by expand) in contexts \nwhere any of the interfaces is expected. An expander can employ methods of the type being expanded in \norder to meet new interfaces. To implement this functionality, we generate forwarding methods in the \nwrapper class for the top expander, which simply invoke the corresponding methods on the unexpanded object. \nAll interfaces in Java implicitly include signa\u00adtures for the public methods of java.lang.Object, like \nequals, toString, and hashCode, so forwarding methods for them are also created (except in cases where \nthe method is explicitly shadowed by the expander). These forwarding methods are only ever used when \nan ex\u00adpanded object is viewed through one of the interfaces that the ex\u00adpander meets. They are not necessary \nin all other situations, be\u00adcause in those cases eJava s semantics will cause the appropriate methods \nto be called directly on the unexpanded method. For ex\u00adample, if e has static type Expr then e.toString() \nwill always invoke the toString() method de.ned for the run-time class of e, without considering any \nof the expanders in scope. When an expanded object is viewed through one of the inter\u00adfaces that the \nexpander meets, the forwarding methods enable the expanded object to pretend to be the original object \nas much as possible. However, one well-known limitation of wrappers is that they do not preserve object \nidentity. Therefore, code that employs == or instanceof on an expression of an interface type can get \nincorrect results if that expression evaluates to an expanded object. This limitation is an artifact \nof our modular compilation strategy and is also a limitation of the adapter design pattern [15]. An alternative \ncompilation strategy that nonmodularly modi.es a class in place would not suffer from this problem, but \nit would suffer from other problems. For example, it would be impossible to adapt a class to support \ntwo incompatible interfaces (e.g., interfaces that de.ne the same method but with a different return \ntype) in two different expanders. Both the AspectJ and Classboxes implementa\u00adtion strategies suffer from \nthese kinds of problems.  5.4 Handling State in Expanders One straightforward way to represent the \n.elds of an expander fam\u00adily in our implementation scheme would be to declare those .elds in the wrapper \nclass generated for that family s top expander. Wrap\u00adper objects would additionally be cached for use \nby the expand method, in order to give clients of the same object a consistent view of its new .elds \nvalues. Unfortunately, this simple approach inter\u00adacts poorly with Java s garbage collection: expand \ns cache would hold a reference to every object ever adapted by the expander, pre\u00adventing those objects \nfrom ever being garbage collected. Java has a notion of weak references, which, unlike the usual strong \nreferences, do not prevent their referents from being col\u00adlected. One possible solution to the above \nproblem is for the cache to hold weak references to unexpanded objects. Although this ap\u00adproach does \nnot result in memory leaks, it can cause dangling pointer errors: it is possible for the original object \nto be garbage collected while one or more clients still hold a reference to the as\u00adsociated wrapper object. \nOur implementation scheme, outlined in Figure 20, avoids both of these problems. The eJava compiler generates \na state class for each expander, and each wrapper object maintains a reference to an associated state \nobject. The EX$$tate class in Figure 19 is the state class generated for the EX expander. If EX declared \na .eld f, it would be declared in this state class. Client code referring to e.f, where e has type Expr, \nwould be translated to EX.expand(e).state.f. Like wrappers, state objects are instantiated when an object \nis expanded. As in the approach discussed above, the expand method uses a WeakHashMap, a hashtable implementation \nthat holds weak references to the objects it uses as keys, to cache the state objects for each object \nexpanded. An important property of WeakHashMap is that values associated with keys that are garbage collected \nare au\u00adtomatically removed. This feature ensures that state objects whose associated unexpanded objects \nare no longer accessible are prop\u00aderly disposed of, avoiding memory leaks. For performance reasons, the \nstate object contains a wrapper$ .eld, which is used to cache the associated wrapper object. This allows \nthe implementation to avoid instantiating a new wrapper object every time a client accesses functionality \nby an expander on the same object. To solve the dangling pointer problem, the wrappers generated by our \ntranslation hold strong references to their original objects. This ensures that the original object will \nnot be garbage collected as long as there is at least one client who still holds a reference to the wrapper. \nShould it ever be the case that no client holds a reference to the original object or to its wrapper, \nthe wrapper s strong reference to the object will not keep the object from being garbage collected. In \nsuch scenarios, the only object in the system which has a refer\u00adence to the wrapper is the state object. \nAnd because this reference is weak, it does not prevent the wrapper and consequently the orig\u00adinal object \nfrom being collected. Finally, suppose one or more clients have strong references to the original object, \nbut no client has a strong references to the class FancyCalculator$EX extends EX { public static class \nEX$Minus extends EX$Expr {...} public static EX$Expr expand(Expr instance) { EX$Expr r = null; EX$$tate \nstate = cache.get(instance); if (state == null) {  state = new EX$$tate(); state.instance$ = new java.lang.ref.WeakReference<Expr>(instance); \ncache.put(instance, state); } else if (state.wrapper$ != null) { r = state.wrapper$.get(); if (r != \nnull &#38;&#38; r.creator$ == FancyCalculator$EX.class) return r; } if (instance instanceof Minus) r \n= new EX$Minus(instance, state); else return EX.expand(instance); r.creator$ = FancyCalculator$EX.class; \nstate.wrapper$ = new java.lang.ref.WeakReference<EX$Expr>(r); return r; } } Figure 21. The translation \nof the local overriding expander in Figure 11. associated wrapper. Here, it is possible that the wrapper \nwill be garbage collected. Fortunately, because our wrappers are stateless, they can be instantiated \nas often as needed. This is done in the expander s expand method (see Figure 19).  5.5 The expand Method, \nRevisited Now that most of eJava s implementation details have been re\u00advealed, we are able to provide \na more detailed description of the actions carried out by the expand method. Step 1: expand searches \nthe expander s cache for the state object associated with the object to be expanded. If the search suc\u00adceeds \nand the state object s wrapper exists, expand returns the wrapper object. If the search fails, a new \nstate object whose instance$ .eld references the instance to be expanded is cre\u00adated and stored in the \ncache. Step 2: If we get to this point, we ve got a state object, but no wrapper. expand then creates \nthe most-speci.c wrapper based on the dynamic type of the object to be expanded. A weak reference to \nthis object is stored in the state object, and the wrapper is returned to the caller.  5.6 Local Overriding \nExpanders As discussed in section 2.5, clients may augment an expander fam\u00adily with any number of local \noverriding expanders. Our compilation scheme supports this ability by generating a subclass of the origi\u00adnal \nexpander s implementation class. For example, Figure 21 shows the code generated for the local overriding \nexpander shown in Fig\u00adure 11. The new class contains the appropriate wrapper classes, which are declared \nto be subclasses of the wrapper classes of the original expander. The state class created for the original \nexpander is inherited for use by the local overriding expander. When creat\u00ading new wrapper objects, the \nnew expander class s expand method uses instanceof tests to determine whether one of its re.nements should \nbe used for the instance being expanded. If this is not the case, it forwards the call to the expand \nmethod of its superclass. The uses of locally augmented expanders are compiled as calls to the new expander \nclass s expand method (and not that of the origi\u00adnal expander).  To adhere to eJava s semantics as described \nearlier, wrappers created by local expanders should never be returned by expand in contexts other than \ntheir own. Similarly, a wrapper created for a particular instance by the original expander should not \nbe used in a context where a local overriding expander exists for the dynamic type of that instance. \nIn order to prevent these scenarios, an ex\u00adpander s expand method never returns a cached wrapper object \nthat was created by a different expand method. Figure 21 shows how FancyCalculator$EX s expand method \nenforces this restriction with the help of a creator$ .eld in each wrapper class. Since any expander \nfamily may be augmented by clients through local over\u00adriding expanders, this check is performed by the \nexpand method of every expander, regardless of whether or not the the existence of local overriding expanders \nis known at compile time (for clarity, this mechanism was omitted from the implementation of EX shown \nin Figure 19).  6. Experience This section describes two experiments we performed to gauge the practical \nutility of eJava s expanders. First, we considered a scenario in which a client must adapt existing objects \nin order to display them in a tree structure using Swing s JTree class. We implemented solutions in both \nJava and eJava to compare the bene.ts and limitations of each approach. Second, we performed an exploratory \nstudy of the Eclipse IDE framework [8]. The goal of the study was to understand the various extensibility \nidioms used in Eclipse and the extent to which expanders allow these idioms to be expressed more naturally \nand/or reliably. 6.1 Making Objects Swing Consider a database of objects that represent various academic \npub\u00adlications, with each publication linking to the publications it ref\u00aderences. The publications in \nthis database are represented by the Publication hierarchy, shown in Figure 22. Since different clients \nof this database are likely to want to display publications in differ\u00adent ways, the classes in the Publication \nhierarchy do not provide any displaying capabilities on their own; this functionality must be implemented \nby each client that requires it. Further, because the publication objects come from a database (and are \nnot instantiated by clients themselves), this functionality must be added externally. This case study \naddresses how one client might display the ob\u00adjects in this database graphically as a tree with each \nnode repre\u00adsenting a publication and subnodes representing the publication s references using Swing s \nJTree class. Figure 23 shows a screen\u00adshot of the client application. Note that each kind of publication \nis displayed in its own style, consisting of a particular icon and text format. public interface ILabelProvider \n{ String getText(); Icon getIcon(); } Figure 24. The ILabelProvider interface. To display objects in \na JTree, clients must provide an imple\u00admentation of Java s TreeModel interface, which provides a data \nmodel for the tree. As a convenience, the Swing library provides a default implementation of this interface, \nDefaultTreeModel. However, DefaultTreeModel requires the objects in the tree to implement the TreeNode \ninterface. Therefore, in order to avoid du\u00adplicating the code of DefaultTreeModel, the publication objects \nmust be adapted to meet the TreeNode interface. To customize the way objects in a JTree are displayed, \nthe client must also implement the TreeCellRenderer interface. This interface has a single method, getTreeCellRendererComponent, \nwhich takes an Object and returns the graphical Component to be used for displaying that object. The \nsimplicity of this interface often complicates the implementation of the getTreeCellRendererComponent \nmethod, which must perform instanceof tests and type casts if different kinds of objects should be displayed \ndifferently. Therefore, many Swing applications de\u00ad.ne their own interface for rendering, which is implemented \nby the object passed to getTreeCellRendererComponent. The im\u00adplementation of that method can then delegate \nmost of the render\u00ading work to the given object by calling appropriate methods from this new interface. \nIn our application, we require the objects in the tree to support the ILabelProvider interface, shown \nin Fig\u00adure 24, which allows each kind of publication to provide its own text and icon for display. Therefore, \nPublication objects must also be adapted to meet the ILabelProvider interface. 6.1.1 The eJava Version \nOur eJava implementation uses expanders to adapt the various types of publications to meet the TreeNode \nand ILabelProvider interfaces. Figure 25 shows some of the code in the top expander (i.e., the one for \nPublication). The .rst several methods in the ex\u00adpander implement the TreeNode interface. Note the use \nof the with operator to explicitly expand p (an instance of Publication) in the children method. This \nis necessary because we intend to store the expanded versions of those objects in a Vector. Since Vector \ns add method takes an argument of type Object, no adaptation is necessary, and therefore p is not expanded \nautomatically. Java 1.5 s generics would allow us to type children as Vector<TreeNode>, which would then \nresult in the implicit adaptation of p, but as men\u00adtioned earlier, the eJava compiler does not currently \nsupport gener\u00adics. use StringExp; public expander PublicationExp of Publication implements TreeNode, \nILabelProvider { private Vector children = null; public Enumeration children() { if (children == null) \n{ children = new Vector(); Iterator it = citations().iterator(); while (iterator.hasNext()) { Publication \np = (Publication)it.next(); children.add(p with PublicationExp); } } return children.elements(); } // \n... public Icon getIcon() { return \"/icons/publication.gif\".getIcon(); } public String getText() { \nreturn getTitle(); } } Figure 25. The PublicationExp expander. expander PublicationExp of ConferencePublication \n{ public Icon getIcon() { return \"/icons/conference.gif\".getIcon(); } public String getText() {  return \ngetTitle() + \"@\" + getConferenceName(); } } Figure 26. An overriding expander. public expander StringExp \nof String { private Icon icon = null; public Icon getIcon() { if (icon == null) icon = new ImageIcon(Object.class.getResource(this)); \nreturn icon; } } Figure 27. Retrieving icons from a .le. The expander in Figure 25 provides a default \nimplementation of ILabelProvider for instances of Publication. Overriding ex\u00adpanders customize the presentation \nof each kind of publication by providing their own implementation of the getText and getIcon methods. \nFor example, Figure 26 shows the overriding expander for ConferencePublication. We use an expander for \nString to encapsulate the logic for loading icons from .les, as shown in Figure 27. The expander also \ncaches the icon in its icon .eld. Since in Java identical string literals are represented by the same \nunderlying String object, our application will not load an icon more than once from the same .le. public \nclass ConferenceAdapter extends PublicationAdapter { public ConferenceAdapter(ConferencePublication p) \n{ super(p); } public Icon getIcon() { return IconCache.getIcon(\"/icons/conference.gif\"); } public String \ngetText() { ConferencePublication a = (ConferencePublication) adaptee; return a.getTitle() + \"@\" + a.getConferenceName(); \n} } Figure 28. An adapter for ConferencePublication. public class GUIAdapterFactory { public static PublicationAdapter \ncreateAdapter(Publication p) { if (p instanceof OOPSLAPublication) { OOPSLAPublication pub = (OOPSLAPublication) \np; return new OOPSLAAdapter(pub); } if (p instanceof ConferencePublication) { ConferencePublication pub \n= (ConferencePublication) p; return new ConferenceAdapter(pub); } //.... return new PublicationAdapter(pub); \n } } Figure 29. The adapter factory.  6.1.2 The Java Version Our Java implementation employs the adapter \ndesign pattern [15]. To encode special rendering behavior for each subclass of Publication, we create \na hierarchy of adapter classes that mirrors the publication hierarchy. The root of the adapter hi\u00aderarchy \nis PublicationAdapter, which looks similar to the PublicationExp expander, except that it maintains an \nexplicit .eld adaptee of type Publication to access the underlying pub\u00adlication object. Similarly, the \nother classes in the hierarchy of adapters correspond to the overriding expanders of the eJava im\u00adplementation. \nFor example, the ConferenceAdapter, which is the analogue of the overriding expander for ConferencePublication \n(Figure 26) is shown in Figure 28. Since the adapter makes use of speci.c features of ConferencePublication, \nlike getConferenceName, the adaptee .eld must be downcast appro\u00adpriately. Our Java implementation is \nrequired to perform instanceof tests in order to determine the correct adapter class for a publication \nobject. The createAdapter method in Figure 29 implements this functionality. The instanceof tests must \nbe performed in most-to least-speci.c order to ensure that each object is adapted properly. It is possible \nto do away with the adapter hierarchy and instead use a single adapter class for all publications. However, \nin that case this sequence of instanceof tests would be required in the implementation of every method \nthat has specialized behavior for Publication subclasses, instead of occurring only once at the point \nof adaptation.  6.1.3 Comparison This case study exposes several advantages of expanders over standard \nadapters in Java. First, the eJava version is more eas\u00adily extensible. For example, consider the task \nof adding spe\u00adcial support for TOPLASPublication, which is a subclass of JournalPublication. In the eJava \nversion, one would simply add a new overriding expander for PublicationExp, either in the same source \n.le as the original expanders or via local expander overriding. In the Java version, one would analogously \nneed to add a new adapter class, TOPLASAdapter, which inherits from JournalAdapter. However, it would \nalso be necessary to update or create a subclass of the GUIAdapterFactory (from Figure 29), in order \nto add a new case to createAdapter s cascading if state\u00adment that appropriately adapts a TOPLASPublication. \nFurther, care must be taken to place this case in the appropriate order with respect to the existing \ncases. The eJava version is also less error prone than the Java ver\u00adsion. The latter version requires \ninstanceof tests and associated downcasts in GUIAdapterFactory, in order to create the adapters, and \nadditional downcasts within the adapters to narrow the type of the adaptee .eld, as shown earlier. In \ncontrast, the eJava version requires none of these instanceof tests or downcasts. Instead, eJava s modular \ntype system ensures type correctness statically. In total, the Java version of our simple application \nrequires four instanceof tests and eight downcasts. The eJava version contains no instanceof tests and \nthree downcasts. Two of these downcasts would have been avoided with the use of generics, and the third \noc\u00adcurs in the implementation of TreeCellRenderer, in order to nar\u00adrow the Object argument of getTreeCellRendererComponent \nto ILabelProvider; it is also present in the Java version. Finally, the eJava version has a performance \nadvantage over the Java version. As described in Section 5, the instances of wrapper classes used in \nthe implementation of an expander are cached for each expanded object. Therefore, the tree display in \nour applica\u00adtion will create exactly one wrapper object per publication object displayed, even if the \npublication appears multiple times in the tree. In the Java version, each node in the tree has a separate \nadapter in\u00adstance. Similarly, we remarked earlier that the StringExp expander naturally ensures that \neach icon is loaded from a .le at most once. In the Java version, this optimization had to be implemented \nwith an explicit icon cache.  6.2 An Exploratory Study of Eclipse Eclipse is built with extensibility \nas a primary goal: the framework is structured as a small kernel, known as the Eclipse platform, and \na collection of external plugins that provide the bulk of the system s functionality. As such, Eclipse \nrepresents a rich source for understanding the state of the art in Java-based extensibility idioms. In \nthe rest of this section, we describe several of these idioms and their relationship to eJava s expanders. \n6.2.1 External Methods Eclipse uses two main approaches to add methods to existing classes from the outside. \nFirst, it provides two kinds of visitors: ASTVisitor, for traversing the AST representation of a program, \nand IResourceVisitor, for traversing trees of resources such as .les, folders, and projects. These types, \nalong with the appropriate hooks inside the classes representing AST nodes and resources, allow for easy \nextension of these hierarchies with new methods. However, only these two particular class hierarchies \ncan be ex\u00adtended with new methods, and such extension is only possible be\u00adcause of advance planning by \nthe Eclipse developers. Expanders, public expander IMX of IMarker { public String getViewId() {...} public \nboolean showMarker(IWorkbenchPage p, boolean showView) {...} } Figure 30. The IMarker expander in eJava. \non the other hand, allow any existing class hierarchy to be eas\u00adily augmented with new methods, without \nthe need to plan ahead for such extension. Further, they do not suffer from the standard problems of \nvisitors, mentioned in Section 2.1. For example, each expander method can have its own argument and result \ntypes. However, visitors do have one important advantage over ex\u00adpanders. Since each external method \nis rei.ed as a visitor class, it is easy for external methods to inherit code from one another. A common \nusage of this ability is to de.ne a visitor that does noth\u00ading except recursively visit the children \nof each node in the given tree. A new visitor class can then subclass from that visitor and in\u00adherit \nthe code for traversing the tree for free, only overriding the particular methods that should perform \nsome useful work. In con\u00adtrast, method families in an expander are completely unrelated to one another, \nforcing each to re-implement the basic traversal be\u00adhavior. We believe this limitation could be solved \nwith a notion of expander inheritance. We are currently working on adding support for this feature to \nthe eJava compiler using a compilation strategy similar to the one used to support local overriding expanders. \nSecond, Eclipse has several utility classes that use static methods to provide new functionality to existing \ntypes. For exam\u00adple, the MarkerViewUtil class contains two methods that manip\u00adulate instances of the \nIMarker interface, with the following signa\u00adtures: public static String getViewId(IMarker m) public static \nboolean showMarker(IWorkbenchPage p, IMarker m, boolean showView) This approach to adding new methods \nto existing types has two main drawbacks. First, callers have to use a ver\u00adbose and unnatural syntax \nto invoke such methods, for example MarkerViewUtil.getViewId(m), which clashes with the concep\u00adtual intent \nthat the new methods are part of the existing IMarker type. Second, if a method needs to dispatch on \nthe run-time class of the IMarker instance in order to determine how to behave, then the programmer must \nresort to error-prone instanceof tests and type casts, as shown in earlier sections. Expanders naturally \nsolve both of these problems. Figure 30 shows an expander for IMarker that adds the two methods de\u00adscribed \nabove. These new methods can be invoked using the or\u00addinary calling syntax for methods of IMarker. Further, \nthe imple\u00admenter can provide overriding expanders in order to specify the behavior of each new method \nfor particular classes that implement the IMarker interface. The eJava language then does the work of \nautomatically dispatching to the appropriate implementation based on the run-time class of the receiver. \n 6.2.2 Multiple Implementation Inheritance Eclipse employs a style in which clients only manipulate \nan ab\u00adstraction through an interface, rather than a class. This style cleanly separates interface from \nimplementation, ensuring that clients can\u00adnot depend on implementation details and allowing implementers \nto change the underlying implementations without affecting clients. To aid implementers, Eclipse often \nprovides an abstract class that contains default implementations of a particular interface s meth\u00adods. \nImplementers can then easily create a class meeting the desired public expander VX of VXRequirements \nimplements IViewPart { // ... public IViewSite getViewSite() { return (IViewSite)getPartSite(); } public \nvoid init(IViewSite site) { partSite = site; } public void init(IViewSite site, IMemento memento) { \ninit(site); } public void saveState(IMemento memento) { } public Object getAdapter(Class adapter) { return \nPlatform.getAdapterManager() .getAdapter(this, adapter); } // ... } Figure 31. An expander replacing \nthe ViewPart abstract class. interface by inheriting from the associated abstract class and over\u00adriding \nmethods as appropriate [14]. For example, Eclipse s concept of a view provides a visual representation \nof some content. A view must implement the IViewPart interface, which declares or inher\u00adits a total of \n14 method signatures, and the abstract class ViewPart contains default implementations of 12 of these \nmethods, requiring concrete subclasses to implement the other two. Because Java does not support multiple \ninheritance, however, a class that subclasses ViewPart cannot inherit code from any other classes. This \nlimitation can lead to a signi.cant amount of code duplication. For example, suppose a class that subclasses \nViewPart must meet another interface in addition to IViewPart. It is not possible for the class to inherit \nthe default implementations of the other interface; instead, the implementer must explicitly copy these \nmethods in the new class. Expanders provide a natural solution to this problem. First we create an interface \nfor the two methods that each concrete subclass of ViewPart is required to implement: public interface \nVXRequirements { void createPartControl(Composite parent); void setFocus(); } Then we create an expander \nthat takes the place of the ViewPart class, providing the implementations of the other 12 methods re\u00adquired \nby IViewPart. This expander is shown in Figure 31. Any class that implements the VXRequirements interface \ncan now be expanded to meet the IViewPart interface and thereby inherit the default implementations of \nthe associated methods. Other ex\u00adpanders can be used in a similar fashion to allow the class to easily \nmeet other interfaces, without requiring code duplication. Further, the class can still inherit code \nfrom a superclass, as usual in Java. 6.2.3 Adapters Eclipse includes an adapter framework that allows \nan object to be dynamically extended to meet a new type. A type declares its in\u00adstances to be adaptable \nby implementing the IAdaptable interface. Clients of that type can implement an adapter factory which \nspeci\u00ad.es how to adapt that type s instances to new types, and register this factory with a global registry. \nAn adapter factory from Eclipse that package org.eclipse.jdt.internal.debug.ui; public class JavaBreakpointWorkbenchAdapterFactory \nimplements IAdapterFactory { public Object getAdapter(Object adaptableObject, Class adapterType) { if \n(adapterType != IWorkbenchAdapter.class || !(adaptableObject instanceof IJavaBreakpoint)) return null; \nreturn new IWorkbenchAdapter() { // ... public String getLabel(Object o) {...} // ... }; } // ... } \nFigure 32. An example adapter factory from Eclipse. public expander BPX of IJavaBreakpoint implements \nIWorkbenchAdapter { public String getLabel(Object o) {...} // ... } Figure 33. Adapting with an expander. \nadapts instances of IJavaBreakpoint to IWorkbenchAdapter is shown in Figure 32. The adapter factory can \nthen be invoked via the getAdapter method of the adaptee object, for example: IJavaBreakPoint bp = ... \nIWorkbenchAdapter wb = (IWorkbenchAdapter) bp.getAdapter(IWorkbenchAdapter.class); if (wb != null) {...} \n The adaptee object s getAdapter method typically forwards to the global registry, which uses the getAdapter \nmethod of each adapter factory to search for an appropriate adapter, returning null if one cannot be \nfound. With expanders, we can express both the adapter and its clients more naturally. Figure 33 provides \nan expander that adds the appropriate methods to an IJavaBreakpoint instance in order for it to meet \nthe IWorkbenchAdapter interface. A client of an IJavaBreakpoint instance simply uses the expander BPX \nin order to implicitly adapt the instance to IWorkbenchAdapter, thereby allowing methods like getLabel \nto be called on that instance. There are several interesting points of comparison between the two approaches. \nFirst, it is statically apparent in the declaration of an expander what type is being adapted and to \nwhat other type it is being adapted. This makes it easy for clients to under\u00adstand the intended behavior \nof an expander. Similarly, it is stat\u00adically visible through a compilation unit s use statements which \nexpanders are being employed by any particular client. In contrast, Eclipse s adapter framework is inherently \ndynamic. The code of the getAdapter method in Figure 32 must be inspected to under\u00adstand what types are \ninvolved in the adaptation. Further, it is im\u00adpossible for a client to tell which adapter will be used \nwhen it calls getAdapter on an object. Of course, such dynamism can also be an advantage, by providing \nmore expressiveness than is supported by expanders. For example, the getAdapter method in Figure 32 can \neasily perform the adaptation in one of several ways, depend\u00ading on run-time conditions. Eclipse is structured \naround a dynamic plugin model, so it often requires such expressiveness. Second, Eclipse s adapters \nare globally registered, which can cause problems. For example, if two plugins each register different \nadapter factories for the same source and target types, one of these factories will be shadowed, causing \none plugin to use an adapter that may not be appropriate for its needs. Since expander usage is statically \nscoped, there can naturally exist multiple expanders for the same source and target types, and different \nclients can use different expanders without con.ict. Third, a type is only adaptable in Eclipse s framework \nif it is declared to meet the IAdaptable interface (and provides a getAdapter method). Therefore, the \noriginal implementer of a type must plan ahead for adaptation. Unfortunately, this advance planning often \ndoes not happen, as indicated by several requests in the Eclipse Bug System [9], shown in Table 1. Fourth, \nEclipse s framework allows objects to be adapted to both new classes and new interfaces. In contrast, \neJava s expanders allow a class to meet new superinterfaces but not new superclasses. Finally, some Eclipse \nadapters are designed to be stateless: instead of storing the adaptee object as a .eld of the adapter \nobject and delegating to this .eld as necessary, the adapter object s methods all explicitly accept an \nadaptee object as a parameter. The example in Figure 32 is in fact a stateless adapter. For example, \nif bp is an instance of IJavaBreakPoint and wb is the IWorkbenchAdapter object returned from the call \nbp.getAdapter(IWorkbenchAdapter.class), then the la\u00adbel text of the adapted object is accessed by the \ninvocation wb.getLabel(bp). The stateless adapter design allows one adapter instance to be used across \nall objects that need to be adapted. In contrast, our compilation strategy for expanders, as discussed \nin Section 5, al\u00adways creates one adapter object per adaptee object, thereby con\u00adsuming more space. However, \nstateless adapters come at the cost of increased complexity, both for the adapter implementer and the \nadapter client. On the implementation side, the code for getLabel must downcast the given Object to an \nIJavaBreakPoint before retrieving its label. On the client side, callers must explicitly ma\u00adnipulate \nboth the adaptee object and its adapter. 6.2.4 External State Eclipse allows plugins to add new state \nto existing objects that represent system resources via a notion of properties. A property is a name-value \npair that can be added to an existing IResource instance. Properties are updated and accessed through \ntwo methods in the IResource interface: void setSessionProperty(QualifiedName key, Object value) Object \ngetSessionProperty(QualifiedName key)  For example, Figure 34 shows how Eclipse s BuildManager class \nmanipulates a property K BUILD LIST on instances of IProject. The property mechanism is useful but has \nseveral drawbacks. First, it cannot be used to add new state to objects that are not re\u00adsources. Second, \nproperties are not statically typed. For instance, nothing prevents two calls to setSessionProperty from \nstoring objects of different types to the same property. Since most callers of getSessionProperty downcast \nthe resulting object to the ex\u00adpected type of the property, such type disagreement could lead to run-time \nerrors like ClassCastExceptions. Third, each property of an object is globally accessible by all of the \nobject s clients, which can lead to con.icts. For example, two clients could acci\u00addentally use the same \nQualifiedName to represent two distinct properties, causing unexpected interactions between these clients \nat run time. Expanders allow state to be added to existing objects without suffering from any of these \nproblems. For example, the following Table 1. A sample of the Eclipse Bug System s should implement IAdaptable \nbugs. Bug ID Summary 12960 109138 23032 22452 80671 All Update Core model objects must implement IAdaptable \nIWorkingSet should extend IAdaptable Make IEditorReference adaptable Would like ITextViewer be a supported \nAdaptable for AbstractTextEditor [api] proxies should be adaptable package org.eclipse.core.internal.events; \npublic class BuildManager implements ICoreConstants, IManager, ILifecycleListener { public ArrayList \ngetBuildersPersistentInfo(IProject project) throws CoreException { return (ArrayList)project.getSessionProperty(K_BUILD_LIST); \n} public void setBuildersPersistentInfo(IProject project, ArrayList list) { // ... project.setSessionProperty(K_BUILD_LIST, \nlist); // .. } // ... } Figure 34. BuildManager in Java. package org.eclipse.core.internal.events; \nuse IPX; public class BuildManager implements ICoreConstants, IManager, ILifecycleListener { public \nArrayList getBuildersPersistentInfo(IProject project) throws CoreException { return project.buildList; \n} public void setBuildersPersistentInfo(IProject project, ArrayList list) { // ... project.buildList \n= list; // ... } // ... } Figure 35. BuildManager in eJava. expander augments IProject instances with \na new .eld of type ArrayList: package org.eclipse.core.internal.events; public expander IPX of IProject \n{ public ArrayList buildList = null; } Clients like BuildManager can then use this expander and manipu\u00adlate \nthe new .eld as it would any other .eld, as shown in Figure 35. Accesses to the .eld are now statically \ntypechecked, and different clients can use different expanders without any possibility of con\u00ad.icts. \n  7. Related Work Classboxes, a form of module for OO languages, are the closest language construct \nto expanders of which we are aware. Classboxes were originally developed in the context of Smalltalk \n[4] but were recently described in an extension to Java [3]. Classboxes allow existing classes to be \nre.ned to support new .elds, methods, and superinterfaces, as in eJava. Classboxes also support the addition \nof new constructors and inner classes, as well as the overriding of existing methods of the class, all \nof which eJava does not support. There are several important differences between expanders and classboxes. \nFirst, like expanders, the re.nements in a classbox are only available where that classbox has been explicitly \nimported. While the visibility of a classbox is scoped, any class members added in a classbox are treated \nsemantically as if they were de.ned in the original class declaration [2]. This semantics causes the \nkinds of accidental overriding problems described in Section 3.3, which elude modular detection. eJava \ns method-lookup semantics and modular type system prevent accidental overriding and the associated type \nsafety problems. Second, classboxes are implemented nonmodularly: all class\u00adboxes that re.ne a class \nmust be available when that class is com\u00adpiled, and these re.nements are weaved into the class s declara\u00adtion. \nAt that point, regular Java typechecking and compilation are performed on the resulting class. This means \nthat any errors in a classbox are not detected modularly. Further, while this implemen\u00adtation strategy \navoids the problem of object identity for wrappers, it allows unrelated classboxes to clash with one \nanother, preventing compilation. For example, if two classboxes de.ne a method m for class C, the methods \nare merged into a single m method that tests the current scope dynamically to determine what code should \nbe executed. If these methods have different return types, the resulting Java code will not typecheck. \nWhile this problem could potentially be addressed by a form of name mangling, that strategy would not \nwork if the methods are needed in order to implement particular interfaces. In contrast, because expanders \nare implemented modu\u00adlarly, two unrelated expanders cannot con.ict with one another. Finally, clients \ncan only import a single classbox for a given class, while clients in eJava can use multiple expanders \nfor the same class. The inter-type declarations in AspectJ [19] support similar aug\u00admentations to a class \nas do classboxes. However, aspect usage is not scoped: an aspect s inter-type declarations are implicitly \navailable to clients of the original classes. This semantics re.ects the fact that aspects are often \nintended to update the behavior of existing classes in a manner that automatically updates all existing \nclients, in order to noninvasively evolve existing applications. While this behavior is quite powerful, \nit can also easily cause accidental relationships and con.icts among logically independent aspects and \nclasses. Fi\u00adnally, AspectJ employs a similar compilation strategy as described above for classboxes and \nso suffers from similar problems. The concept of subject-oriented programming [17] has goals that are \nvery similar to our own. The basic idea is to allow dif\u00adferent clients of a class to have different subjective \nviews of that class s behaviors. Work on subject-oriented programming has ex\u00adplored mechanisms that allow \nprogrammers to specify rules for composing multiple subjects, each of which encapsulates some of a class \ns behaviors [24]. Similarly, the follow-on work on hy\u00adperslices [30, 25] allows programmers to explicitly \ncompose sepa\u00adrate hyperslices in .exible ways in order to produce the full class for use by an application. \neJava does not support explicit composi\u00adtion of expanders, instead using ordinary static scoping to disam\u00adbiguate \namong them. While less expressive, our approach allows expanders to be typechecked fully modularly. In \ncontrast, con.icts among subjects or hyperslices can only be detected when they are composed to produce \na particular full class, as with classboxes and aspects. The Scala [27] programming language contains \na construct called views, which are a form of language support for adaptation. Views are essentially \nprogrammer-de.ned functions from one type to another. However, the language infers where a view should \nbe in\u00adserted, in order to allow a value of one type to be treated as having a different type. As with \nexpanders, views must be explicitly im\u00adported in order to be considered for such inference. In this way, \non the client side views are quite similar to expanders. However, on the implementation side views provide \nno special support for adapta\u00adtion. For example, in order to augment a type with new methods, the programmer \nhas to implement a view that explicitly creates a wrap\u00adper class for values of that type, along with \nforwarding methods for all of the original methods of that type. In eJava, these details are taken care \nof by the compiler. Additionally, Scala does not support any form of overriding for views, so programmers \nmust manually implement run-time type dispatch in order to adapt different sub\u00adclasses in different ways. \nMultiJava s open classes [6] allow new methods to be added to existing classes externally. As in eJava, \nclients in MultiJava explicitly import any new methods they wish to employ, thereby allowing for modular \nreasoning. MultiJava does not support the introduction of new superinterfaces to existing classes and \nhence is not able to express object adapters and related idioms. MultiJava also does not support the \nintroduction of new .elds to existing classes. The inclusion of superinterfaces and .elds in expanders \nconstitutes a large increase in expressiveness over MultiJava and requires signi.cant new work to support \nmodular typechecking and compilation. Half &#38; Half [1] is an extension to Java that supports the ability \nto add new superinterfaces to existing classes, as well as a form of multiple dispatch. A wrapper strategy \nsimilar to the one we describe is used to compile the new language construct. Unlike eJava, Half &#38; \nHalf does not support the addition of new methods or .elds to existing classes. Therefore, a new interface \ncan only be given to an existing class if it already meets all the requirements of that interface. Several \nlanguage features, including mixins [5, 13, 29], traits [28], and parameterized modules [12, 20], support \nthe .exible creation of new classes from existing ones. In contrast, expanders .exibly update existing \nclasses in place. Therefore, expanders can be used to adapt existing objects with new capabilities, while \nthe approaches mentioned above cannot. On the other hand, those lan\u00adguage constructs provide .ne-grained \ncode reuse across indepen\u00addent classes, while expanders do not. Those languages also sup\u00adport some expressiveness \nthat could be useful to incorporate in ex\u00adpanders. For example, Sch\u00a8[28] describe an expressive arli \net al. sublanguage that allows clients to resolve con.icts that may occur when combining multiple traits. \nAs another example, Jiazzi [20] supports a very expressive form of class parameterization, includ\u00ading \nrecursive linking. There have also been several languages that include a form of virtual types [32, 31] \nand related forms of dependently typed classes [10, 11, 21, 23]. These languages allow hierarchies of \nclasses to easily be re.ned in various ways. Like the languages described above, these approaches allow \nnew hierarchies to be cre\u00adated from existing ones, rather than updating existing hierarchies in place. \nTherefore, these approaches are not suitable for adapting existing objects to new clients. On the other \nhand, these approaches allow multiple independent hierarchies to exist in a program, along with a guarantee \nthat instances of the constituent classes will only intermingle with other instances from the same hierarchy. \n 8. Conclusions and Future Work We have described the expander, a new construct that provides ex\u00adplicit \nlanguage support for modularly adapting objects in .exible ways to suit the needs of clients. Expanders \ncan be used to imple\u00adment a variety of recurring idioms in object-oriented software (such as the visitor \nand adapter design patterns), in a manner that is more declarative, more extensible, and more amenable \nto static type\u00adchecking. We have instantiated our notion of expanders in eJava, an extension to Java. \nWe have formalized a core subset of the eJava language and proven its modular type system sound. We have \nalso implemented eJava via a modular scheme for translating expanders to Java. Lastly, we demonstrated \nways in which expanders can pro\u00advide bene.ts in practice through two experiments. The exploratory study \nin Eclipse pointed out a few limitations of eJava that we plan to address in future work. First, while \na visitor can easily inherit code from another visitor, this is not true for expanders. It would be useful \nto consider a notion of expander inheritance, which would allow a new expander family to be easily derived \nfrom an existing expander family. Second, the exploratory study illustrated a potential use for the ability \nto augment existing classes with new superclasses, in addition to new superinterfaces. We plan to explore \nthis idea to determine if the resulting gain in expressiveness justi.es the added complexity. Finally, \nwe plan to extend the eJava language to handle the features in Java 1.5 by porting the eJava compiler \nto a recently announced extension to Polyglot for Java 1.5 [26]. 9. Acknowledgments This material is \nbased upon work supported by the National Science Foundation under Grant Nos. CCF-0427202 and CCF-0545850, \nas well as by a generous gift from Microsoft Research. Thanks to Craig Chambers, Doug Lea, Stephen Murrell, \nYoshiki Ohshima, and the anonymous reviewers (of both OOPSLA and ECOOP 2006) for useful feedback on this \nwork.  References [1] G. Baumgartner, M. Jansche, and K. Laufer. Half &#38; Half: Multiple dispatch \nand retroactive abstraction for Java. Technical Report OSU-CISRC-5/01-TR08, Department of Computer and \nInformation Science, The Ohio State University, revised March 2002. [2] A. Bergel. Personal communication, \nOct. 2005. [3] A. Bergel, S. Ducasse, and O. Nierstrasz. Classbox/J: Controlling the scope of change \nin Java. In Proceedings of Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA \n05), pages 177 189, New York, NY, USA, 2005. ACM Press. [4] A. Bergel, S. Ducasse, and R. Wuyts. Classboxes: \nA minimal module model supporting local rebinding. In Proceedings of JMLC 2003 (Joint Modular Languages \nConference), volume 2789 of LNCS, pages 122 131. Springer-Verlag, 2003. Best Award Paper. [5] G. Bracha \nand W. Cook. Mixin-based inheritance. In ECOOP/OOP-SLA 90, pages 303 311, 1990. [6] C. Clifton, G. T. \nLeavens, C. Chambers, and T. Millstein. MultiJava: Modular open classes and symmetric multiple dispatch \nfor Java. In OOPSLA 2000 Conference on Object-Oriented Programming, Systems, Languages, and Applications, \nMinneapolis, Minnesota, volume 35(10) of ACM SIGPLAN Notices, pages 130 145, Oct. 2000. [7] C. Clifton, \nT. Millstein, G. T. Leavens, and C. Chambers. MultiJava: Design rationale, compiler implementation, and \napplications. ACM Trans. Program. Lang. Syst., 28(3):517 575, 2006. [8] Eclipse home page. http://www.eclipse.org. \n[9] Eclipse Bug System home page. https://bugs.eclipse.org/ bugs. [10] E. Ernst. Family polymorphism. \nIn Proceedings of the European Conference on Object-Oriented Programming, pages 303 326, 2001. [11] E. \nErnst. Higher-order hierarchies. In Proceedings of the European Conference on Object-Oriented Programming, \nLNCS, Darmstadt, Germany, July 2003. Springer Verlag. [12] R. B. Findler and M. Flatt. Modular object-oriented \nprogramming with units and mixins. In Proceedings of the ACM SIGPLAN International Conference on Functional \nProgramming (ICFP 98), volume 34(1) of ACM SIGPLAN Notices, pages 94 104. ACM, June 1998. [13] M. Flatt, \nS. Krishnamurthi, and M. Felleisen. Classes and mixins. In Conference Record of POPL 98: The 25TH ACM \nSIGPLAN-SIGACT Symposium on Principles of Programming Languages, San Diego, California, pages 171 183, \nNew York, NY, 1998. [14] E. Gamma and K. Beck. Contributing to Eclipse: Principles, Patterns, and Plugins. \nAddison Wesley Longman Publishing Co., Inc., Redwood City, CA, USA, 2003. [15] E. Gamma, R. Helm, R. \nE. Johnson, and J. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, \nMassachusetts, 1995. [16] J. Gosling, B. Joy, G. Steele, and G. Bracha. The Java Language Speci.cation, \nThird Edition. Addison-Wesley, 2005. [17] W. Harrison and H. Ossher. Subject-oriented programming (A \ncritique of pure objects). In A. Paepcke, editor, Proceedings ACM Conference on Object-Oriented Programming \nSystems, Languages, and Applications, pages 411 428. ACM Press, Oct. 1993. [18] A. Igarashi, B. C. Pierce, \nand P. Wadler. Featherweight Java: a minimal core calculus for Java and GJ. ACM Transactions on Programming \nLanguages and Systems, 23(3):396 450, May 2001. [19] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, \nJ. Palm, and W. G. Griswold. An overview of AspectJ. In Proceedings of the 2001 European Conference on \nObject-Oriented Programming, LNCS 2072, Budapest, Hungary, June 2001. Springer-Verlag. [20] S. McDirmid, \nM. Flatt, and W. C. Hsieh. Jiazzi: New-age components for old-fashioned Java. In Proceedings of the OOPSLA \n01 conference on Object Oriented Programming Systems Languages and Applications, pages 211 222. ACM Press, \n2001. [21] N. Nystrom, S. Chong, and A. C. Myers. Scalable extensibility via nested inheritance. In OOPSLA \n04: Proceedings of the 19th annual ACM SIGPLAN Conference on Object-oriented programming, systems, languages, \nand applications, pages 99 115. ACM Press, 2004. [22] N. Nystrom, M. R. Clarkson, and A. C. Myers. Polyglot: \nAn extensible compiler framework for Java. In Proceedings of CC 2003: 12 th International Conference \non Compiler Construction. Springer-Verlag, Apr. 2003. [23] M. Odersky and M. Zenger. Scalable component \nabstractions. In OOPSLA 05: Proceedings of the 20th annual ACM SIGPLAN conference on Object oriented \nprogramming systems languages and applications, pages 41 57, New York, NY, USA, 2005. ACM Press. [24] \nH. Ossher, M. Kaplan, A. Katz, W. Harrison, and V. Kruskal. Specifying subject-oriented composition. \nTheor. Pract. Object Syst., 2(3):179 202, 1996. [25] H. Ossher and P. Tarr. Hyper/J: Multi-dimensional \nseparation of concerns for Java. In Proceedings of the 22nd International Conference on Software Engineering, \nJune 4-11, 2000, Limerick, Ireland, pages 734 737, 2000. [26] Polyglot for Java 1.5 home page. http://www.sable.mcgill.ca/ \njlhotak/polyglot-custom. [27] The Scala language home page. http://scala.epfl.ch. [28] N. Sch\u00a8arli, S. \nDucasse, O. Nierstrasz, and A. Black. Traits: Composable units of behavior. In Proceedings ECOOP 2003 \n(European Conference on Object-Oriented Programming), volume 2743 of LNCS, pages 248 274. Springer Verlag, \nJuly 2003. [29] Y. Smaragdakis and D. Batory. Implementing layered designs with mixin layers. In E. Jul, \neditor, ECOOP 98 Object-Oriented Programming, LNCS 1445, pages 550 570. Springer, 1998. [30] P. Tarr, \nH. Ossher, W. Harrison, and J. Stanley M. Sutton. N degrees of separation: multi-dimensional separation \nof concerns. In ICSE 99: Proceedings of the 21st international conference on Software engineering, pages \n107 119, Los Alamitos, CA, USA, 1999. IEEE Computer Society Press. [31] K. K. Thorup and M. Torgersen. \nUnifying genericity: Combining the bene.ts of virtual types and parameterized classes. In R. Guerraoui, \neditor, Proceedings ECOOP 99, volume 1628 of LNCS, pages 186 204, Lisbon, Portugal, June 1999. Springer-Verlag. \n[32] M. Torgersen. Virtual types are statically safe. In International Workshop on Foundations of Object-Oriented \nLanguages (FOOL) , informal proceedings, Jan. 1998. [33] A. Warth and T. Millstein. Featherweight eJava. \nTechnical Report CSD-TR-060013, UCLA Computer Science Department, 2006. ftp: //ftp.cs.ucla.edu/tech-report/2006-reports/060013.pdf. \n[34] A. K. Wright and M. Felleisen. A syntactic approach to type soundness. Information and Computation, \n115(1):38 94, Nov. 1994. \n\t\t\t", "proc_id": "1167473", "abstract": "This paper introduces the <i>expander</i>, a new object-oriented (OO) programming language construct designed to support object adaptation. Expanders allow existing classes to be noninvasively updated with new methods, fields, and superinterfaces. Each client can customize its view of a class by explicitly importing any number of expanders. This view then applies to all instances of that class, including objects passed to the client from other components. A form of <i>expander overriding</i> allows expanders to interact naturally with OO-style inheritance.We describe the design, implementation, and evaluation of eJava, an extension to Java supporting expanders. We illustrate eJava's syntax and semantics through several examples. The statically scoped nature of expander usage allows for a modular static type system that prevents several important classes of errors. We describe this modular static type system informally, formalize eJava and its type system in an extension to Featherweight Java, and prove a type soundness theorem for the formalization. We also describe a modular compilation strategy for eJava, which we have implemented using the Polyglot extensible compiler framework. Finally, we illustrate the practical benefits of eJava by using this compiler in two experiments.", "authors": [{"name": "Alessandro Warth", "author_profile_id": "81319503800", "affiliation": "University of California, Los Angeles, CA", "person_id": "P813664", "email_address": "", "orcid_id": ""}, {"name": "Milan Stanojevi&#263;", "author_profile_id": "81319502053", "affiliation": "University of California, Los Angeles, CA", "person_id": "P813676", "email_address": "", "orcid_id": ""}, {"name": "Todd Millstein", "author_profile_id": "81100018064", "affiliation": "University of California, Los Angeles, CA", "person_id": "PP14019523", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1167473.1167477", "year": "2006", "article_id": "1167477", "conference": "OOPSLA", "title": "Statically scoped object adaptation with expanders", "url": "http://dl.acm.org/citation.cfm?id=1167477"}