{"article_publication_date": "10-25-2009", "fulltext": "\n Self Type Constructors Chieri Saito Graduate School of Informatics Kyoto University, Japan saito@kuis.kyoto-u.ac.jp \nAbstract Bruce and Foster proposed the language LOOJ, an extension of Java with the notion of MyType, \nwhich represents the type of a self reference and changes its meaning along with inheritance. MyType \nis useful to write extensible yet type\u00adsafe classes for objects with recursive interfaces, that is, ones \nwith methods that take or return objects of the same type as the receiver. Although LOOJ has also generics, \nMyType has been in\u00adtroduced as a feature rather orthogonal to generics. As a result, LOOJ cannot express \nan interface that refers to the same generic class recursively but with different type argu\u00adments. This \nis a signi.cant limitation because such an in\u00adterface naturally arises in practice, for example, in a \ngeneric collection class with method map(), which converts a col\u00adlection to the same kind of collection \nof a different element type. Altherr and Cremet and Moors, Piessens, and Oder\u00adsky gave solutions to this \nproblem but they used a highly sophisticated combination of advanced mechanisms such as abstract type \nmembers, higher-order type constructors, and F-bounded polymorphism. In this paper, we give another solution \nby introducing self type constructors, which integrate MyType and generics so that MyType can take type \narguments in a generic class. Self type constructors are tailored to writing recursive interfaces more \nconcicely than previous solutions. We demonstrate the expressive power of self type constructors by means \nof ex\u00adamples, formalize a core language with self type construc\u00adtors, and prove its type safety. Categories \nand Subject Descriptors D.3.1 [Programming Languages]: Formal De.nitions and Theory; D.3.2 [Pro\u00adgramming \nLanguages]: Language Classi.cations Object\u00adoriented languages; D.3.3 [Programming Languages]: Lan- Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 2009, October \n25 29, 2009, Orlando, Florida, USA. Copyright c . 2009 ACM 978-1-60558-734-9/09/10. . . $10.00 Atsushi \nIgarashi Graduate School of Informatics Kyoto University, Japan igarashi@kuis.kyoto-u.ac.jp guage Constructs \nand Features Classes and objects; Poly\u00admorphism; F.3.3 [Logics and Meaning of Programs]: Stud\u00adies of \nProgram Constructs Object-oriented constructs; Type structure General Terms Design, Languages, Theory \nKeywords binary methods, generics, MyType, type con\u00adstructor polymorphism 1. Introduction Background. \nIt is well known that simple type systems (such as that of Java without generics) are not suf.ciently \nex\u00adpressive to make use of the inheritance mechanism in a type safe manner. One of the classical problems \nin this context is how to express binary methods [6] methods that are sup\u00adposed to take an object of \nthe same type as the receiver, such as equals() in statically typed languages. Ideally, in a class de.nition, \nthe parameter type of a binary method has to change covariantly as the class extends so that subclasses \nre\u00adfer to themselves. However, such covariant change of param\u00adeter types, if naively allowed, would break \ntype safety and so C++ and Java disallow it. As a result, the parameter type of a binary method is .xed \nto a particular class name and this problem is often solved by typecasting. The use of type\u00adcasting, \nhowever, is not a real solution since they may fail at run time, if used carelessly. A similar problem \noccurs when two or more classes are involved: paradigmatic examples are found in the implementation of \nnode and edge classes for graphs [15] and also in the expression problem [42]. Over the last years, there \nhave been many proposals to solve the problem above; a key idea common to them is to provide such inheritance \nand typing mechanisms that can properly preserve (mutual or self) dependencies among the interfaces of \nrelated classes. According to how depen\u00addencies are expressed in type systems, these proposals can be \nclassi.ed into two: one with dependent types [15, 16, 30, 31, 12, 34] and one without [23, 37, 22, 7, \n8, 9, 5] 1. This pa\u00adper focuses on the latter, which is admittedly less expressive but simpler and usually \nexpressive enough. 1 In spite of what the title of the paper [23] suggests, Concord is not really equipped \nwith dependent types in the traditional type-theoretic sense.  MyType and its Extensions. The approach, \nin which de\u00adpendent types are not used, is based on MyType [4], which represents the type of a self reference. \nMyType refers to the class where it appears and changes its meaning covariantly when a member is inherited \nso as to refer to the class that inherits it. So, MyType can be used to give appropriate sig\u00adnatures \nto binary methods. Although MyType in earlier pro\u00adposals can express only self-recursion within a single \nclass, it has been extended to more general settings: mutually re\u00adcursive classes [37, 8, 9, 5], class \nhierarchies [23], and arbi\u00adtrarily nested groups of classes [22]. LOOJ and its Limitation. Five years \nago, Bruce and Fos\u00adter proposed the language LOOJ, an extension of Java with MyType [7]. Although LOOJ \nalso includes generics [26, 3], MyType has been introduced as a feature rather orthogonal to generics. \nAs a result, LOOJ cannot express an interface that refers to the same generic class with different type \nar\u00adguments. For example, consider a collection class and its method map(), which takes a function from \nthe element type to another and returns a new collection whose elements are obtained by applying the \nfunction to each element in the receiver collection object. It is natural to expect that this method \nreturns the same kind of collection of a different el\u00adement type but LOOJ types cannot express such an \ninter\u00adface. This is a signi.cant limitation because such an inter\u00adface arises naturally in practice, \nnamely, in generic collection classes, which are typical applications of generic classes. In short, the \nlimitation of LOOJ is that, if a parameterized class refers to itself recursively but with different \ntype in\u00adstantiations, it is impossible to give such recursive references types that are covariantly re.ned \nalong with inheritance. Our Contributions. In this paper, we propose self type constructors, which integrate \nMyType and generics so that MyType is a type constructor, which can take type arguments just like ordinary \ngeneric class names2. We demonstrate the expressive power of self type constructors by means of examples. \nIn particular, we show collections with methods map() and flatMap(), which can be given the desired signatures \nby using self type constructors. To rigorously show that our proposal is safe, we formalize a core language \nFGJstc of self type constructors by extending FLJ [7], a core calculus of LOOJ, which in turn extends \nFeatherweight GJ [20], and prove its type soundness. Actually the problem pointed out here is not new; \nit has been tackled by other people [27, 1]. Their solutions required a highly sophisticated combination \nof advanced typing fea\u00adtures including abstract type members [39, 19, 33], higher\u00adorder type constructors \n[27, 1], and F-bounded polymor\u00adphism [11]. Compared with them, our proposal differs in that (1) there \nis less boilerplate code to write recursive interfaces because MyType automatically supports covariant \nchange of 2 Actually, Bruce once pointed out this idea as a solution to extensible parameterized visitors \n[5]. However, he did not investigate it any further due to its expected complexity. method signatures, \n(2) F-bounded polymorphism, which is often a source of complication in the semantics and meta\u00adtheory, \nis not needed, and (3) no second-or higher-order type constructors are needed. Actually, in order to \nbring these ad\u00advantages, we need the help (or, one might say, additional complexity) of our recent proposal \nto make self types more applicable [36]. Nevertheless, we believe our whole proposal offers a simpler \nsolution to writing extensible, recursive, and generic interfaces than the previous work. We summarize \nour contributions as follows: the proposal of self type constructors with a demonstra\u00adtion of their \nexpressive power by means of examples;  a formalization of the type system of self type construc\u00adtors; \nand  a proof of type soundness.  For brevity, the proofs of the theorems and main lemmas are only sketched. \nThe Rest of This Paper. Section 2 reviews the idea of My-Type and the type system of LOOJ and then, discusses \na limitation of LOOJ with respect to generic classes with re\u00adcursive interfaces. Section 3 informally \ndescribes the idea of self type constructors as a solution to the problem. Sec\u00adtion 4 formalizes self \ntype constructors as FGJstc, which is an extension of FLJ, a small model of LOOJ. Section 5 in\u00advestigates \nthe interaction between self type constructors and other advanced typing features. Section 6 discusses \nrelated work and Section 7 concludes. Hereafter, we use the key\u00adword This, as done in [22, 36], for MyType. \n2. The Type System of LOOJ and Its Limitation In this section, we .rst review the type system of LOOJ \n[7] and then describe its limitation caused by the fact that This stands for the current class with its \ntype parameters. 2.1 This and Exact Types In LOOJ, the keyword This (more precisely, ThisClass) represents \nthe class in which it appears; moreover, when the class is inherited, the meaning of This changes covariantly. \nA typical use of This is in methods with recursive interfaces, that is, methods that take or return \nthe same type as the receiver. Consider the following class de.nitions: class C { int field1; boolean \nisEqual(This that){ return this.field1 == that.field1; } } class D extends C { int field2; boolean isEqual(This \nthat){ return super.isEqual(that) &#38;&#38; this.field2 == that.field2;  } } Class C declares a binary \nmethod (i.e., a method that takes the same type as the receiver [6]) isEqual() to compare the receiver \nwith another object of the same type. This refers to class C in class C whereas it refers to class D \nin class D. So, in the overriding de.nition of isEqual(), the .eld access that.field2 in isEqual() in \nclass Dis legal. When members are accessed on an object, the signatures of the members are obtained by \nreplacing This with the (static) class name of the receiver object. For example, if isEqual() is invoked \non an expression of type C, the sig\u00adnature is C.boolean. On the other hand, if isEqual() is invoked on \ntype D, the signature is D.boolean. One advantage of using This is that programmers can avoid unnecessary \nuses of typecasts, which sidestep static typechecking and may fail at run time if used carelessly. For \nexample, if we wrote isEqual() with the argument type being C, the access to field2 would require a typecast \n(D) for that, since D has to override the method with the same signature (in Java) but Cdoes not have \nfield2. Exact Types for Safe Binary Method Invocations. How\u00adever, it is not safe to allow the invocation \nof binary methods naively. Consider the following code: C c1, c2; ... c1.isEqual(c2); // unsafe Although \nthis invocation is well typed under the above\u00admentioned interpretation of This and the usual typing rule \nfor method invocations, it can fail at run time if c1 refers to an object of class Dand c2 refers to \nan object of class C, then the overriding de.nition of isEqual() will be executed and the .eld access \nthat.field2 fails since c2 does not have field2. The problem here is that the run-time signature of isEqual() \ncan be different from the compile-time one. LOOJ introduces exact types [7, 22] in order to guarantee \nthe safe invocations of binary methods such as isEqual(). While an ordinary type C means an object of \nclass C or its subclasses, an exact type @C means the object of class C exactly, excluding its proper \nsubclasses. In other words, a variable or .eld of type @C always refers to an instance of class C. With \nthe help of exact types, the safe typing rule for method invocations becomes: the receivers of binary \nmeth\u00adods should have exact types. Thanks to this rule, the run\u00adtime and compile-time signatures of a \nbinary method invo\u00adcation will be the same3. The following method invocations illustrate type-checking \nunder this rule: @C c1; C c2, c3; 3 Obviously, this rule loses the bene.t of dynamic dispatch the method \nbody called is determined at run time. This problem will be overcome by local exactization, which we \nproposed in the previous work [36] See Section 3. interface Comparable { int compareTo(@This that); } \ninterface Iterator<T> { @T next(); @T peek(); boolean hasNext(); } Figure 1. Interfaces of Comparable \nand Iterator written in LOOJ. c1.isEqual(c3); // 1: legal c2.isEqual(c3); // 2: illegal The .rst invocation \nis legal (and in fact safe) since the receiver is of @C, an exact type, and the argument type C is a \nsubtype of the parameter type C. The second invocation, which is unsafe as we have seen, is rejected \nby the type system since the receiver s type is not exact. Hereafter, we call types without @inexact. \n 2.2 Limitation of LOOJ Although LOOJ has also generics, This is rather orthogonal to generics. When \nThis appears in generic class C<X>, This means C<X> including the type parameter X of the generic class \nC. As a result, LOOJ cannot express an interface that refers to the same generic class recursively but \nwith different type arguments. This is a signi.cant limitation because such an interface naturally arises \nin practice, for example, in a generic collection class with method map(), which converts a collection \nto the same kind of collection of a different element type. We elaborate on this problem, which was also \npointed out by Altherr and Cremet [1] and Moors, Piessens, and Odersky [27], below. Figures 1 and 2 show \nour running example4 adapted from [27]. Suppose that we are developing a class hierar\u00adchy of collections \nby the iterable-and-iterator idiom. The top of the hierarchy is Iterable<T>, an abstract collec\u00adtion \nof the elements of type @T. (The element type needs to be exact to allow binary method compareTo() to \nbe in\u00advoked on the elements in a subclass SortedList<T>. Ob\u00adviously, this prohibits heterogeneous collections, \neven for List. Its relaxation, which we do not incorporate in this pa\u00adper to simplify the discussion, \nwill be sketched in Section 7.) List<T> is a concrete class implementing Iterable<T>. SortedList<T> is \nan extension of List<T> and the ele\u00adments of its instance are expected to be sorted in an ascend\u00ading \norder. Since sorting involves comparison between ele\u00adments, the element type T in SortedList<T> is re.ned \nto be a subtype of Comparable, which declares binary method compareTo(). 4 More precisely, LOOJ distinguishes \nMyType in classes and interfaces and uses ThisClass for class types and ThisType for public interfaces. \nIn this paper, we use This for both. This is safe as long as the receiver of a binary method invocation \nhas an exact class type, as pointed out in [7].  abstract class Iterable<T> { abstract Iterator<T> iterator(); \nabstract void add(@T t); abstract @This append(@This that); } class List<T> extends Iterable<T> { Iterator<T> \niterator(){ ... } void add(@T t){ ... } @This create(){ ... } // discussed later @This append(@This that){ \n@This newList=create(); for(@T t: this) newList.add(t); for(@T t: that) newList.add(t); return newList; \n } <U> ??? map(T->U f){ ... } <U> ??? flatMap(T->??? f){ ... } } class SortedList<T extends Comparable> \n extends List<T> { ... @This append(@This that){ @This newList=create(); Iterator<T> iter=iterator(); \nIterator<T> iter2=that.iterator(); while(iter.hasNext() &#38;&#38; iter2.hasNext()){ if(iter.peek().compareTo(iter2.peek()) \n< 0) newList.add(iter.next()); else newList.add(iter2.next()); } while(iter.hasNext()) newList.add(iter.next()); \nwhile(iter2.hasNext()) newList.add(iter2.next()); return newList; } } Figure 2. Collection classes written \nin LOOJ. In this example, we omit the implementation of the data structure in each concrete class. So, \nthe bodies of add() and iterator() are omitted. Method add() adds a new ele\u00adment to the data structure. \nMoreover, in SortedList<T>, add() keeps the elements sorted. An invocation of method iterator() on List<T> \nreturns a new iterator object that iterates over the elements of the receiver; that on SortedList<T> \nreturns a new object that iterates over the elements in the ascending order. Iterable<T> declares binary \nmethod append() that takes the same kind of collection as the receiver, appends all the elements of the \nreceiver and argument, and then re\u00adturns a new collection of the same kind. Both List<T> and SortedList<T> \nimplement append(). In List<T>, the el\u00adements of that are simply connected to the tail of those of this \nby iteration. In SortedList<T>, on the other hand, append() is overridden so that the elements of this \nand that are merge-sorted. The algorithm assumes that the el\u00adements of that has been sorted. This assumption \nis correct since that has type @This referring to SortedList<T>, a sorted list. The implementation of \nthe factory method create() will be discussed later. Now, consider that we try to write types for methods \nmap() and flatMap() in class List<T>. The requirement is as follows: the method map() is a polymorphic \nmethod that takes a type U and a function5 from type T to U, and then returns a list whose element type \nis U. Moreover, we naturally expect that the invocation of map() on a list returns a list and that on \na sorted list returns a sorted list. The method flatMap(), which is also polymorphic and takes Uas a \ntype argument, takes a function from Tto lists of U and returns a new list obtained by concatenating \nthe results of applying the function to each element of the receiver list. Similarly, we expect that \nflatMap() returns the same kind of lists. It is impossible, however, to express such a requirement with \nLOOJ types. The problem is that This cannot be used to express the requirement that the returned list \nis the same kind of list as the receiver because This always refers to the generic class instantiated \nwith the declared type parameters: for example, in List<T>, This always refers to List<T> but cannot \nbe used to refer to, say, List<U>. Covariant re.nement of return types introduced to Java since 5.0 does \nnot solve the problem, either. All we can do at best is as follows: class List<T> { <U> List<U> map(T->U \nf){ ... } } class SortedList<T extends Comparable> extends List<T> { <U extends Comparable> SortedList<U> \nmap(T->U f) { ... } } The return types are correctly re.ned since SortedList<U> is a subtype of List<U>. \nHowever, this code is not very satisfactory. First, it is a programmer s responsibility to re\u00ad.ne the \nreturn type every time he or she de.nes a subclass of List<T>. Second, these signatures do not really \nsatisfy the requirement above since, for example, when map() is invoked on a plain list, we are not sure \nwhether a list or its subclasses will be returned in other words, the return type is inexact. Note that \nit is impossible to give @List<U> and @SortedList<U> as the return types of map() to classes List<T> \nand SortedList<T>, respectively, since @SortedList<U> is not a subtype of @List<U>. 5 In this paper, \nwe assume the existence of .rst-class functions, which can be seen in Scala [32], and use the notation \nS->T for the type for functions from S to T. They can be simulated in Java by representing functions \nby objects implementing a generic interface with method T apply(S x), where Sand T are type parameters, \nand function applications by invocation of apply().  class List<T> extends Iterable<T> { <U> @This<U> \ncreate(){ ... } @This<T> append(@This<T> that) { ... } <U> @This<U> map(T->U f){ @This<U> newList=this.<U>create(); \nfor(@T t: this) newList.add(f(t)); return newList; }  <U> @This<U> flatMap(T->@This<U> f){ @This<U> \nnewList=this.<U>create(); for(@T t: this)  newList = newList.append(f(t)); return newList; } } Figure \n3. The implementation of map() and flatMap() in class List<T> written by using self type constructors \nin the preliminary syntax. In general, in LOOJ, if a generic class refers to itself re\u00adcursively but \nwith different type instantiations, it is impossi\u00adble to give such recursive references types that are \nautomat\u00adically re.ned along with extension. 3. Self Type Constructors In this section, we introduce self \ntype constructors to solve the problem described in the previous section. Self type con\u00adstructors are \nthe integration of This and generics where This can take type arguments in a generic class de.nition. \nFirst, in Section 3.1, we begin with a simple use of self type constructors and rewrite the classes shown \nin the previous section. Second, we identify a subtlety that arises when the upper bound of a type parameter \nis re.ned in a subclass (Sec\u00adtion 3.2). This leads us to distinguishing two kinds of type parameters: \nones that are tied to self type constructors and whose upper bounds can be re.ned; and ones with oppo\u00adsite \nproperties. We also show the use of other related mech\u00adanisms, including constructor-polymorphic methods \n[1, 27] (Section 3.3), exact statements [36] (Section 3.4), and non\u00adheritable methods [36] (Section 3.5), \nwhich are useful in this context. 3.1 This as a Type Constructor The idea of self type constructors is \nsimple it is just to consider that This refers to a generic class name where it appears, without type \nparameters, and that it can take type arguments just like ordinary generic class names. Since self types \nare now type constructors, namely, a type-level func\u00adtion that takes types to yield another type, we \ncall This a self type constructor. Figure 3 shows class List<T> rewrit\u00adten with self type constructors. \nIn this class de.nition, This is used as a type constructor that takes one type. The return type of map() \ncan now be expressed as @This<U> and, sim\u00adilarly, method flatMap() also has the signature that re.ects \nour intention. Note that the argument type of append() is now @This<T> instead of @This because This \nalways needs to take one argument so as to be a proper type. The factory method create() becomes a polymorphic \nmethod, parameterized by an element type of the list to be created, so that it can be called from map() \nand flatMap(). The following code illustrates invocations of map(): @List<Integer> intList=...; @SortedList<Integer> \nintSList=...; Integer->Float intToFloat=...; @List<Float> floatList =intList.<Float>map(intToFloat); \n// 1 @SortedList<Float> floatSList =intSList.<Float>map(intToFloat); // 2 Each invocation returns a list \nof the same kind as the re\u00adceiver, as expected, but the element type is converted from Integer to Float. \nThe return type is obtained by replacing This with the constructor part (the simple class name, with\u00adout \ntypes surrounded by < and >) of the receiver type. For example, the return type of the .rst invocation \nis obtained by replacing This in @This<Float> by List.  3.2 Type Parameters with Re.nable/Fixed-Bounds \nAlthough the .rst idea is quite simple, the interaction of self type constructors with the inheritance \nmechanism is subtler than it may have appeared. We will see that type parameters have to be distinguished \ninto two kinds: one that allows upper bounds to be re.ned and the other with .xed upper bounds. The following \ncode reveals the problem: class List<T> { @This<String> strlist; } class NumList<T extends Number> extends \nList<T> { } The class List<T> above is well de.ned @This<String> is a well-formed type since the argument \nString is a sub\u00adtype of Object, the (implicitly speci.ed) upper bound of T. However, if strlist were \ninherited to NumList<T>, its type @This<String> would not be well formed any longer because String is \nnot a subtype of Number, which is a new upper bound for T. In fact, the class SortedList suffers from \nthe same problem since the upper bound of Tis re.ned to Comparable. Similarly, it will be a problem to \nde.ne a subclass that .xes a type parameter of its superclass class IntList extends List<Integer> {...} \nsince @This in IntList takes no type arguments and @This<String> does not make sense, either. In short, \nthe problem is that, without any restriction, the range of acceptable type arguments for (or, even the \narity of) self type constructors changes in a subclass and types in inherited members may become meaningless. \nAlthough such ill-formed types do no harm to type safety in the sense that execution does not get stuck \nby no-such-.eld or no\u00adsuch-method errors (as long as the type system disallows the instantiation of ill-formed \ntypes), we believe it is reasonable to prohibit them from appearing. A similar problem has also been \npointed out in the context of Scala, by Moors, Piessens, and Odersky [29], who developed a mechanism \nto prevent ill-formed types from appearing.  In order to solve the problem, we distinguish two kinds \nof type parameters of a generic class: parameters where their upper bounds can be re.ned (simply called \nre.nable parameters) and ones with .xed bounds (simply called .xed parameters). On the one hand, a re.nable \nparameter (1) allows its upper bound to be re.ned covariantly (or can be .xed in a subclass as in IntList \nabove), and (2) is included in the meaning for This: for example, when parameter T in class C<T> is re.nable, \nThis refers to C<T> instead of C. In LOOJ, all type parameters are considered re.nable and inheritance \nobviously preserves well-formedness of type expressions. On the other hand, a .xed parameter (1) cannot \nbe instantiated in an extends clause (as in IntList above), (2) requires its upper bound to be the same \nas that of the superclass, and (3) is not a part of the meaning of This. So, in order to be a proper \ntype, This has to take as many type arguments as the number of .xed parameters. Since the upper bound \ndoes not change along with inheritance, well\u00adformedness of types, especially the fact that the actual \ntype arguments for This are subtypes of the upper bounds of the corresponding formal, are preserved. \nTo make the distinction clear in the syntax, we enclose re.nable parameters by < and > before .xed parameters, \nwhich are enclosed by [and ]. For example, we write class C<T>[U]{ This[U] f; <S> This[S] m(){ ... } \n} Here, Chas one .xed parameter U, so This takes one param\u00adeter, even though C has two type parameters \nin total. In this class, the self type constructor This means that application to type S yields This[S], \nwhich is a subtype of C<T>[S]. We generalize the notion of the constructor part of the class to be a \nclass name together with its re.nable parameters. For example, the constructor part of Cis C<T>. This \ndistinction does not affect subtyping, which is point\u00adwise: if class C<T>[U] extends D<T>[U], for any \ntypes T1 and T2, C<T1>[T2]is a subtype of D<T1>[T2]. By using both kinds of type parameters, it is now \npossi\u00adble to de.ne SortedList, where the element type is a sub\u00adtype of Comparable, as a subclass of List, \nwithout being bothered by ill-formed types. Figure 4 shows the new def\u00adinitions, where the method bodies \nremain unchanged from the ones in Figure 3. In the new de.nition, class Iterable has one re.nable parameter \nBound and one .xed parameter abstract class Iterable<Bound>[T extends Bound]{ abstract Iterator<T> iterator(); \nabstract void add(@T t); abstract @This[T] append(@This[T] that); } class List<Bound>[T extends Bound] \n extends Iterable<Bound>[T]{ <U extends Bound> @This[U] create(){ ... } @This[T] append(@This[T] that){ \n... } <U extends Bound> @This[U] map(T->U f){ ... } <U extends Bound> @This[U] flatMap(T->@This[U] f){ \n... } } class SortedList<Bound extends Comparable> [T extends Bound] extends List<Bound>[T]{ @This[T] \nappend(@This[T] that){ ... } } Figure 4. Collections with self type constructors, .nally. T, bounded \nby Bound. The point is that, although T s upper bound cannot be re.ned, actually it can be indirectly \nre.ned by changing Bound s upper bound. The extension of List by SortedList is legal since the re.nement \nof re.nable pa\u00adrameter Bound is allowed and T has the same bound Bound as its superclass does. Note that \nin class List<Bound>[T], type @This[String] will not be well formed since String is not a subtype of \nBound. Although it is not possible that the number of .xed pa\u00adrameters decreases in a subclass (because \na subclass cannot instantiate them), it is possible for a subclass to have more .xed (and also re.nable) \nparameters. (In fact, such augmen\u00adtation is even necessary because Object at the top of the class hierarchy \nhas no type parameters.) When a subclass is given an additional .xed parameter, the signature of an in\u00adherited \nmember changes. An easy example is as follows: class List<Bound>[T extends Bound] extends Object { @This[T] \nclone(){ .. } // if overrides } Here, Object is assumed to have method clone() that re\u00adturns @This to \nexpress the intention that it must returns an object of the same type as the receiver. Now, clone() is \nin\u00adherited to List<Bound>[T], then the return type changes to @This[T], not @This, which is not a proper \ntype. So, if List overrides clone(), the return type must be written @This[T]. Although the return types \nlook syntactically dif\u00adferent, their meaning is the same, in that each represents the type of this in \nits declaring class. We summarize other restrictions on how two kinds of type parameters can be used \nin class de.nitions by giving the general form of the header of a class de.nition. Suppose there is a \nclass C class C<X1 extends B1>[X2 extends B2] ...  and we are going to declare a subclass D with a new \n.xed parameter. Then, ill-formed types can be avoided if a class de.nition is of the form class D<Y1 \nextends B. 1> [Y2 extends B. ,Y3 extends B. ] 2 3 extends C<T>[Y3] ... obeying the following rules: upper \nbounds B. contain only type variables Y1,... Yi-1 i (for i =1,2,3); B. is equal to a substitution instance \nof B2, in which X1 3 and X2 are replaced by Tand Y3, respectively; and type T, which instantiates the \nre.nable parameter X1 of C, does not include Y3. The .rst rule amounts to the absence of F-bounded poly\u00admorphism. \nFixed parameter Y3 corresponds to X2 in the su\u00adperclass, so it must instantiate X2 and have the same \nbound modulo instantiation of X1 (as enforced by the second rule). Y2 is the newly introduced .xed parameter; \nsince it cannot depend on the existing .xed parameter(s), its decla\u00adration is put before them. In the \nformal calculus given in the next section, the rules above are extended so that they can deal with sequences \nof type parameter declarations.  3.3 Constructor-Polymorphic Methods As studied in [8, 37, 22], it is \nconvenient to allow method declarations that work uniformly over different constructors. The following \nexample shows a method that takes two lists of the same kind and returns a truth value if the two have \nthe same length and the elements at the same positions are equal: static <T extends Comparable, L extends \nList<Comparable>> boolean isEqualLists(@L[T] n1, @L[T] n2){ Iterator<T> iter=n2.iterator(); for(@T t: \nn1){ if(!iter.hasNext()) return false; if(t.compareTo(iter.next()) != 0) return false; } return !iter.hasNext(); \n} The method above has two parameters. The .rst one T is an ordinary type variable, which ranges over \nsubtypes of Comparable but the second one Lis a type constructor vari\u00adable this is clear from its upper \nbound List<Comparable>, which requires one more argument to be a proper type. The method can be invoked, \nas follows: @SortedList<Comparable>[String] strList1, strList2; ... <String,SortedList<Comparable>> \nisEqualLists(strList1, strList2); Here, the actual arguments for the method invocation is ex\u00adplicitly \nspeci.ed. Since String implements Comparable, this method invocation is well typed. The development of \nan algorithm to infer these type arguments is left for future work. Constructor-polymorphic methods introduce \ntype param\u00adeters which range over type constructors. In the formal type system presented in the next \nsection, This will be also re\u00adgarded as an (implicit) type constructor parameter, which is bounded by \nthe constructor part of the class where it appears. In this paper, we allow such higher-order type parameter \nonly for methods, not for classes, to avoid a type construc\u00adtor parameterized by another type constructor. \nHowever, this is not an essential restriction see Section 5. Our main mo\u00adtivation for the restriction \nis rather to show interesting pro\u00adgramming is possible without higher-order type constructors as used \nin other work [1, 27].  3.4 exact Statements for Invoking Binary Methods on Inexact Types The examples \nso far show invocations on only exact types. Actually, with the help of exact statements (which were \ncalled local exactization [36]), invocations of binary meth\u00adods6 on inexact types are possible. Consider \nthe following example: class ReversibleList<Bound>[T extends Bound] extends List<Bound>[T] { void reverse(){ \n... } } static <L extends ReversibleList<Comparable>> boolean isPalindrome(@L[String] strList){ String->@L[Char] \nstringToChars= (String str) => { // first-class function @L[Char] newList=strList.<Char>create(); for(Char \nc: str) newList.add(c); return newList; } // flatMap is a binary method! @L[Char] charList= strList.<Char>flatMap(stringToChars); \n@L[Char] charList2=charList.clone().reverse(); return <Char,L>isEqualLists(cs, cs2); } The static method \nisPalindrome() judges if the given list of strings represents a palindrome. For example, when it takes \nthe list of borrow , or and rob as an input, it returns true. This method is constructor-polymorphic \n(just as isEqualLists) to work for a reversible list or any sub\u00adclasses (whose de.nitions are not given \nhere). However, the argument type has to be exact, since binary methods are in\u00ad 6 Here, the meaning of \nbinary methods is slightly expanded so that they now refer to methods taking another instantiation of \nThis; so the argument type is not necessarily the same as the type of this.  voked on the argument in \nthe method body, and it is im\u00adpossible to apply it directly to strList of inexact type ReversibleList<Comparable>[String]. \nWe use exact statements to make an inexact type tem\u00adporarily exact in a local scope. This typing feature \nis con\u00adsidered unpacking of existential types, when an inexact type C is considered an existential type \n.X<:C.@X, where X can be thought of a run-time class [36, 10]. It is also simi\u00adlar to wildcard capture \n[41]. Using an exact statement, isPalindrome() can be applied to strList as boolean b; exact <X>(@X[String] \nx = strList) { // X extends ReversibleList<Comparable> b = <X>isPalindrome(x); } <X> after the keyword \nexact declares a constructor vari\u00adable to be used in the type declaration for x and the body (inside \nthe braces). At run time, x is bound to the value of strList and X to the constructor part of the run-time \ntype of strList and the body is executed. At compile time, the type constructor variable X is assumed \nto extend ReversibleList<Comparable>, which comes from the constructor part of the type of strList and \nthe type of x is an exact type @X[String], so isPalindrome() can be called with x. 3.5 Nonheritable Methods \nfor Implementing create() There are several ways to implement create() in Figure 4. The problem in de.ning \ncreate() is that one cannot return an instance created from a concrete class such as List or SortedList, \nsince This is only a subtype of List<Bound> or SortedList<Bound> but not vice versa. Here, we intro\u00adduce \ntwo alternatives. One is to use the abstract factory pattern [17, 5]. First, we prepare abstract class \nFactory as the common interface for factories and a concrete factory ListFactory<Bound> and then augment \nclass List<Bound>[T] with a reference to Factory<Bound,This>: abstract class Factory<Bound, C extends \nList<Bound>> { <U extends Bound> @C[U] create(); } class ListFactory<Bound> extends Factory<Bound,List<Bound>> \n{ <U extends Bound> @List<Bound>[U] create() { return new List<Bound>[U](this); } } class List<Bound>[T \nextends Bound] extends Iterable<Bound>[T] { Factory<Bound,This> factory; List(Factory<Bound,This> f) \n{ this.factory = f; } <U extends Bound> @This[U] create() { return factory.<U>create(); } } A factory \nmust be implemented for each collection class and has to be supplied when a concrete collection is instantiated. \nNote that class Factory is parameterized by C, which is a type constructor variable. So, Factory is a \nhigher-order type constructor. An alternative is to use nonheritable methods [36]. A nonheritable method \nis one that is not inherited to sub\u00adclasses, which must rewrite the same methods. In exchange for this \nrestriction, a nonheritable method allows This and the constructor part of the declaring class to be \ncompatible, i.e., both types are subtypes of each other. This typing fea\u00adture is, in a nutshell, the \ntrick that allows object creations written in factory classes to be put into factory methods, as the \nfollowing code shows: class List<Bound>[T extends Bound] extends Iterable<Bound>[T] { nonheritable <U \nextends Bound> @This[U] create() { return new List<Bound>[U](); } } class SortedList<Bound>[T extends \nBound] extends List<Bound>[T] { nonheritable <U extends Bound> @This[U] create() { return new SortedList<Bound>[U](); \n} } The modi.er nonheritable is essential for each method above. Without it, they would be ill-typed \nfor example, List<Bound>[U] is not a subtype of @This[U] in class List<Bound>[U]. Note that higher-order \ntype constructors do not appear in this code. 4. FGJstc: A Formal Core Calculus In this section, we formalize \nthe idea described in the previ\u00adous section as a small core calculus called FGJstc based on FLJ [7]. \nWhat we model here includes self type constructors, constructor-polymorphic methods, and exact statements, \nas well as the usual features of calculi of the FJ family, that is, .elds, methods, object creations \nand recursion by this. The important restriction posed on FGJstc is that classes can be parameterized \nonly by proper types, but cannot by type con\u00adstructors. So, type constructors in FGJstc are .rst-order \ntype constructors takes only types, but does not take type constructors. As the last section has shown, \nthis .rst-order restriction still allows self type constructors to express the collection hierarchy if \nfactory methods are implemented by using nonheritable methods. The relaxation of this restric\u00adtion will \nbe discussed in Section 5. Since F-bounded poly\u00admorphism is kicked out, FGJstc is not a pure extension \nof FLJ. The calculus does not include nonheritable methods, but they are easy to add, as formalized in \n[36]. We omit inter\u00adfaces for simplicity. Typecasts are dropped since we aim at safe and extensible programming \nwithout typecasting, a pos\u00adsibly unsafe operation. Section 4.1 de.nes the syntax; Sec\u00adtions 4.2 and 4.3 \nde.ne the type system; Section 4.4 de.nes the operational semantics. Finally, we show type soundness \nin Section 4.5.  4.1 Syntax The abstract syntax of types, class declarations, method dec\u00adlarations, \nexpressions, and values is given in Figure 5. The metavariables C and D range over class names; V, W, \nX, Y, and Z range over type constructor variables; f and g range over .eld names; m range over method \nnames; x and yrange over variables. The symbols < and . are read extends and return, respectively. Following \nthe custom of FJ, we put an over-line for a possibly empty sequence. Furthermore, we abbreviate pairs \nof sequences in a similar way, writing T f; for T1 f1;... Tn fn; , where n is the length of T and f. \nSequences of .eld declarations, parameter names, and method de.nitions are assumed to contain no duplicate \nnames. We write the empty sequence as and concatenation of sequences using a comma. We write |\u00b7| for \nthe length of a sequence. As in FJ, every class has a single constructor that takes initial values of \nall the .elds and assigns them; we omit constructor declarations for simplicity. A type constructor K \nis either a type constructor variable X or a nonvariable type constructor C<H>. The application of type \nconstructor K to a sequence of H yields K[H], which can be also a type constructor since partial application \nof type constructors is allowed in FGJstc. In what follows, we call H an inexact type when H does not \ntake any more argu\u00adments, in other words His a fully applied type constructor. A type is either an inexact \ntype or an exact type, which is ob\u00adtained by adding @to an inexact type. Since this language is expression-based, \nthe body of a method is a single return statement, rather than a compound statement as in the previ\u00adous \nsection. An expression is either a variable, a .eld access, a method invocation, an object creation, \nor an exact expres\u00adsion, whose body is an expression. We assume that the set of (type) variables includes \nthe special variable this (This, resp.), which cannot be used as the name of a (type, resp.) parameter \nto a method. We use a different syntax for exact expressions to sim\u00adplify the notation. An exact statement \nexact <X>(@X[String] x = strList){ ... } corresponds to exact1 strList as x, X in ... here. In general, \nwe write exacti e0 asx,X in e1, where the variables x and X are bound in the body expression e1, and \nthe superscript irepresents the arity of X. A class table CT is a .nite mapping from class names Cto \nclass declarations L and is assumed to satisfy the following sanity conditions: (1) CT(C)= class C ... \nfor every C . dom(CT); (2) Object . dom(CT); (3) for every class name C (except Object) appearing anywhere \nin CT, we have C . dom(CT); and (4) there are no cycles in the inheritance relation induced by CT. A \nprogram is a pair (CT, e) of a class table and an expression. In what follows, we assume a .xed class \ntable CT to simplify the notation. 4.2 Lookup functions We give functions to look up .eld or method \ndeclarations. The function .elds(C<G>[H]) returns a sequence Tf of .eld names of class type C<G>[H] with \ntheir types. The function mtype(m,C<G>[H]) takes a method name and a class type as input and returns \nthe corresponding method signature of the form <X<I>T.T0, in which X are bound in T and T0. The functions \nare de.ned by the rules below, which are essentially the same as those of FGJ. .elds(Object<>[])= (F-OBJECT) \nclass C<X<H>[Y<I]<N[Z]{T f; M} .elds([F/X,G/Y](N[Z])) = Ug (F-CLASS) .elds(C<F>[G])= Ug,[F/X,G/Y]Tf \nclass C<X<H>[Y<I]<N[V]{T f; M} <Z<J>U0 m(U x){ . e0;} . M mtype(m,C<F>[G])=[F/X,G/Y](<Z<J>U.U0) (MT-CLASS) \nclass C<X<H>[Y<I]<N[Z]{T f; M} m . M mtype([F/X,G/Y](N[Z])) = <W<J>U.U0 mtype(m,C<F>[G])= <W<J>U.U0 (MT-SUPER) \nWe write [F/X,G/Y]for the capture-avoiding simultaneous substitution of F1 for X1, ..., of Fn for Xn, \nof G1 for Y1, ..., of Gm for Ym. Replacing X in X[I] by an application K[H] yields K[H,I]. In general, \nwe identify K[H][I] and K[H,I]. The type substitutions in these rules look a little more complicated \nsince the two kinds of class parameters are separated syntactically. Here, m . M means that the method \nof name m does not exist in M.  4.3 Type System The main judgments of the type system consist of .f \nS <: T for subtyping, . f I :: k for type constructor well\u00adformedness (k is a kind, de.ned later), . \nf Tok for type well-formedness, .1 f .2 :: kfor bound environment well\u00adformedness, and .;G f e :Tfor \nexpression typing. Here, . is a bound environment, which is a .nite mapping from type (constructor) variables \nto type constructors, written X <: I; G is a type environment, which is a .nite mapping from variables \nto types, written x : T. Following the custom of FJ [20], we abbreviate the sequence of judgments in \nthe obvious way: . f S1 <: T1,..., . f Sn <: Tn to . f S <:T; . f I1 :: k1,..., . f In :: kn to . f I \n:: k; . f T1 ok,..., . f Tn ok to . f Tok, and .;G f e1 :T1,..., .;G f en :Tn to .;G f e :T.  N,P ::= \nC<H> nonvariable type constructors K E,F,G,H,I,J ::= ::= X | N K[H] type constructors applications of \ntype constructors S,T,U L ::= ::= H | @H class C<X<I>[X<I]<N[X]{T f; M} types class declarations M ::= \n<X<I>T m(T x){ . e;} method declarations d,e v ::= ::= x | e.f | e.<I>m(e) | new new N[I](v) N[I](e) \n| exacti e as x, X in e expressions values Figure 5. FGJstc : Syntax. 4.3.1 Bounds of Types The function \nbound.(H), de.ned below, takes an inexact type as input and returns a class type, which is the least \nnonvariable upper bound of the input type. bound.1,X<:I,.2(X[H])= bound.1(I[H]) bound.(N[H])= N[H] If \nthe input begins with a type constructor variable (the .rst rule), the function will be recursively applied \nto the output, in which, again, a variable can appear at the head. 4.3.2 Subtyping The subtyping judgment \n.f S <:T, read as Sis a subtype of Tunder ., is de.ned below. This relation is the re.exive and transitive \nclosure of the extends relation with the rule that an exact type is a subtype of its inexact version. \nThe notable rules are S-CLASS and S-APPLY. The former is de.ned to give subtyping between type constructors \nthe arguments for Zare not given in either side of the conclusion. This partial application does not \ncause a free occurrence of type variables in the right side of the conclusion since N does not contain \nany of Z (as discussed in Section 3.2 and will be formalized later in T-CLASS). S-APPLY says that if \ntype constructors are in a subtyping relation, so are their applications to the same argument. .f T <:T \n(S-REFL) .f S <:T .f T <:U (S-TRANS) .f S <:U .f X <: .(X) (S-VAR) class C<X<H>[Y<I,Z<J]<N[Z]{T f; M} \n(S-CLASS) .f C<F>[G] <: [F/X,G/Y]N .f G <:H (S-APPLY) .f G[I] <: H[I] .f @I <:I (S-EXACT)  4.3.3 Well-formedness \nThe well-formedness judgments consist of two judgments: one . f I :: k for type constructors and one \n. f Tok for proper types. In the former, k is a kind of I. The kind of a type constructor represents \nthe arity of the type constructor and the upper bound for each parameter. Thanks to kinds, it is possible \nto check if applications of type constructors are well-formed. The de.nition is: k ::= * | X <: I.k kinds \nKind * is one for inexact types, which take no arguments. Kind X <: I.* is one for type constructors \nthat take a single argument, which must be a subtype of I. We write kind X <: I.*, as an abbreviation \nof X1 <: I1. ... .Xn <: In.*, for n-argument type constructors. Since type constructors are .rst-order, \nthe upper bounds that appear in a kind always have kind *. The well-formedness judgment . f I :: k for \ntype con\u00adstructors is read as type constructor I has kind k under .. The rules are de.ned below. Object<> \nhas kind *.A type constructor variable X has the same kind as its upper bound. Similarly to S-CLASS, \nWK-CLASS is de.ned so that the conclusion is a class type that is partially applied, drop\u00adping the arguments \nfor Z. The rule says that type constructor C<F>[G], which takes as many arguments as the length of Z, \nhas a kind if arguments Fand Ghave kind * and they conform to the corresponding upper bounds. WK-APPLY \nis the rule for application of a type constructor to a type constructor, which must have kind * and be \na subtype of the upper bound I, written in the kind X<:I.k of the applied type constructor G. .f Object<> \n:: * (WK-OBJECT) .f .(X)::k (WK-VAR) .f X :: k class C<X<H>[Y<I,Z<J]<N[Z]{T f; M} .f (F,G)::* .f (F,G)<: \n[F/X,G/Y](H,I) .f C<F>[G] :: Z <: [F/X,G/Y]J.* (WK-CLASS)  .f G :: X<:I.k .f H :: * .f H <:I .f G[H] \n::[H/X]k (WK-APPLY) The well-formedness judgment .f Tok for types is read as type T is well formed under \n.. The rules are de.ned below. If type constructor Ihas kind *, that is, Iis an inexact type, both exact \ntype @I[] and inexact type I[] are well\u00adformed types. .f I :: * .f I :: * .f @I[] ok .f I[] ok The bound \nenvironment well-formedness judgment .1 f .2 :: k, read as type environment .2 has kinds k with respect \nto .1, is de.ned as follows: .1 f .2 :: k .1,.2 f I :: k. .f :: .1 f (.2,X <:I)::(k,k.) Note that the \nrules are de.ned in such a way that F-bounded polymorphism [11] is kicked out from FGJstc. The scope \nof a type variable in a bound environment is the following type variable declarations. So, a type variable \ncannot appear in its upper bound.  4.3.4 Typing Expression Typing. The typing judgment for expressions \nof the form .;G f e :T, read as under bound environment .and type environment G, expression e has type \nT, de.ned as follows: .;G f x :G(x) (T-VAR) .;G f e0 :@H0 .elds(bound.(H0)) = Tf H0 = I0[H] .f [I0/This]Ti \nok (T-FIELD) .;G f e0.fi :[I0/This]Ti .;G f e0 :@H0 mtype(m,bound.(H0)) = <X<J>T.T0 H0 = I0[H] .f [I0/This]T0 \nok .f G :: k .f G <: [G/X][I0/This]J .;G f e :U .f U <: [G/X][I0/This]T .;G f e0.<G>m(e) :[G/X][I0/This]T0 \n(T-INVK) .f N[I] ok .elds(N[I])= Tf .;G f e :U for all i =|T|.(. f [N[G]/This]Ti ok and .f Ui <: [N[G]/This]Ti \nwhere I = G,Hfor some G,H) .;G f new N[I](e) :@N[I] (T-NEW) .;G f e1 :I[H] |H| = i .,X <:I;G,x :@X[H] \nf e0 :U0 .,X<:I f U0<:T0 .f T0 ok (T-EXACT1) .;G f exacti e1 as x,X ine0 :T0 .;G f e1 :@I[H] |H| = i \n.;G,x :@I[H] f [I/X]e0 :U0 .f U0 ok .;G f exacti e1 as x,X ine0 :U0 (T-EXACT2) The key rules are T-FIELD \nfor .eld access and T-INVK for method invocation. Both rules restrict the receivers to be exact. (So, \nto access members on inexact types, we .rst make the types of the receivers exact.) The rule T-FIELD \nmeans that the type of .eld access is obtained by looking up .eld declarations from the bound of H0 and \nthen substituting I0 for This in the type Ti corresponding to fi. Note that I0 is obtained by dropping \nsome H from H0 so that the type constructors This in the class where Ti is declared and I0 have the same \narity. The selection of I0 is correct if substitution of I0 for This in Ti yields a well-formed type. \nAssume that .;G f x : @C[T] and .;G f y : @D[U,S] for some .and Gwith the following class declarations: \nclass C[X]{ @This[X] f; } class D[Y,X] extends C[X]{ @This[Y,X] g; } Then, examples of typing .eld accesses \nare shown: .;G f x :@C[T] .elds(bound.(C[T])) = @This[T] f .;G f [C/This]@This[T] ok .;G f x.f :[C/This]@This[T](= \n@C[T]) .;G f y:@D[U,S] .elds(bound.(D[U,S])) = @This[S] f,@This[U,S] g .;G f [D[U]/This]@This[S] ok \n.;G f y.f :[D[U]/This]@This[S](= @D[U,S]) In the .rst derivation C is substituted for This in the result \ntype while in the second D[U] is for This. The rule T-INVK is similar to T-FIELD. First, the method signature \nis retrieved from the receiver s type by using mtype. Then, I0 is selected so that I0 and This in the \nnearest superclass where method m is declared have the same arity. Finally, it is checked if the type \narguments Ghave some kinds and are subtypes of the corresponding formal J, and if the types U of the \narguments e are subtypes of those of the cor\u00adresponding formal T. Since Tand Jmay contain This and X, \ntype substitution is applied when the subtyping checks are done. The rule T-NEW says that the type of \na new expression is the exact type of the class being instantiated. Since differ\u00adent .elds can come from \ndifferent classes, which have the different numbers of .xed parameters, we have to choose a different \nN[G] for each .eld. Under the assumption of the environments and class declarations above, an example \nof typing a new expression is shown:  .f D[U,S] ok .elds(bound.(D[U,S])) = @This[S] f,@This[U,S] g .;G \nf [D[U]/This]@This[S](= @D[U,S])ok .f @D[U,S]<:@D[U,S] .;G f [D/This]@This[U,S](= @D[U,S])ok .f @D[U,S]<:@D[U,S] \n .;G f new D[U,S](y,y) :@D[U,S] D[U] is substituted for This in the type of f while D is for This in \nthe type of g. There are two rules for exact expressions, depending on whether the type of e1 is inexact \nI[H] or exact @I[H]. If inexact (T-EXACT1), the body expression is typed under . extended by X<:I and \nGextended by x:@X[H]. The length of H is determined by superscript i. Since the result type U0 may contain \nthe type constructor variable X, the type of the whole expression is obtained by taking a supertype T0 \nof U0 so that T0 does not contain X. The rule T-EXACT2 is for the other case. This rule, which will not \nbe used in ordinary programs, is required to show the subject reduction property since an expression \nof inexact type eventually reduces to one (typically a value) of an exact type at run time. To avoid \ncumbersome exact in accessing members on inexact types, we could give the following derived rules, which \ncan be obtained by the combination of T-FIELD/T-INVK and T-EXACT1. .;G f e0 :I0[H] .elds(bound.(I0[H])) \n= Tf .,This<:I0 f Ti<:T .f Tok .;G f e0.fi :T (T-FIELD ) .;G f e0 :H0 mtype(m,bound.(H0)) = <X<J>T.T0 \nTand Jdo not contain This .f G :: k .f G <: [G/X]J .;G f e :U .f U <: [G/X]T H0 = I0[H] .,This<:I0 f \nT0<:T .f Tok .;G f e0.<G>m(e) :[G/X]T (T-INVK ) The condition that T and J do not contain This means \nthat the method invoked is not binary binary methods should be invoked on receivers of exact types. Closing \nof Types. In the rule T-EXACT1, T0 is not unique for given X, I, U0 and .. We could give a set of rules \nto determine a minimal X-free supertype of U0 as a basis for implementing typecheckers. We introduce \nthe judgment closing of types [21], written S .. T, meaning that Tis a X<:I minimal supertype of Swithout \nXunder . . We also say that Scloses to Tunder X<:Iand . . In T-EXACT1, U0 .. T0 X<:I can be used for \n.,X<:I f U0<:T0. Similarly, Ti .. T This<:I0 for .,This<:I0 f Ti<:T in T-FIELD and T0 .. T This<:I0 for \n.,This<:I0 f T0<:T in T-INVK . The rules of closing of types are as follows: X . fv(H) X . fv(T) H .. \nT I[H] .. T X<:I X<:I T .. T @H .. T X[H] .. T X<:I X<:I X<:I X = YX0 . fv(F,G) Y . fv(H) class C<X<H>[Y<I]<N[Z]{...} \n.(X)[H] .. T [F/X,G/Y]N[Z] .. T Y<:I X0<:I0 X[H] .. T C<F>[G] .. T Y<:I X0<:I0 Here, fv(T)returns the \nset of type variables that appear in T. There are three rules in the upper row. The left rule says that \nif type Tdoes not contain the variable X, the result is the same T. The center rule says that if an exact \ntype contains X, the result is what its inexact version closes to. The right rule says that if X appears \nat the head of the type to close, then the result is what I[H], the bound of X[H], closes to. There are \ntwo rules in the lower row. The left rule says that if the arguments for X contain Y, then the result \nis what .(X)[H], the bound of X[H], closes to. The right rule says that if the arguments of a class type \ncontain X0, the result is what the supertype of the class type closes to. Note that every well-formed \ntype always closes to a certain type, at worst to Object<>[], which is no informative type. Method Typing. \nThe typing judgment for method dec\u00adlarations is written C<X<H>[Y<I] f Mok. The rule T-METHOD, de.ned \nbelow, is straightforward. The method body e0 is typed under the bound environment derived from the parameterization \nclauses in the class and method declaration as well as This <: C<X>, and the type en\u00advironment, in which \nthis has type @This[Y]. The last premise, using the predicate override, checks valid over\u00adriding of method \nsignatures override(m, C<X<H>[Y<I], <Z<J>T.T0) means that class C<X<H>[Y<I] correctly over\u00adrides the \nmethod of name m in its superclass (if exists) and the overriding signature is <Z<J>T.T0. The rule is \nalso below. Note that method signatures are a-convertible and return types can be covariantly re.ned \nalong with extension. class C<X<H>[Y<I,Z<J]<N[Z]{T f; M} [This[Y]/This](mtype(m,N[Z])) = <V<F>U.U0 implies \nG,T =[W/V](F,U)and W <:G f T0 <: [W/V]U0 override(m,C<X<H>[Y<I,Z<J],<W<G>T.T0) (OVERRIDE) .1 = X <:H,Y \n<:I,This <: C<X> .2 = Z <:J .1 f .2 :: k .=.1,.2 .f T,T0 ok G= x :T,this :@This[Y] .;G f e0 :U0 .f U0 \n<:T0 override(m,C<X<H>[Y<I],<Z<J>T.T0) C<X<H>[Y<I] f <Z<J>T0 m(T x){ . e0;} ok (T-METHOD) Class Typing. \nThe typing judgment for classes is written f Lok. The rule is de.ned below. The type environment derived \nfrom the parameterization clause is checked if each upper bound has kind *. If it succeeds, it will be \nguaranteed that the scope of a type variable is the following bindings. So, the upper bounds Hcontain \nnone of Yand Z, and Inone of Z, as expected. As mentioned before, N does not contain any of Z. These \nconditions correspond to the general pattern of class parameterization discussed at the end of Section \n3.2. The well-formedness of .eld types T is checked under the bound environment with This <: C<X>. The \nlast conditional premise says that the upper bounds of type variables Zmust be the same as those of the \nsuperclass.  .= X <:H,Y <:I,Z <:J f .::* X<:H,Y<:I f N : Z<:J.* .,This <: C<X> f Tok C<X<H>[Y<I,Z<J] \nf Mok if D = Object where N = D<E> and class D<W<F>[V<G]<... {... }, then [E/W][Z/V]G = J f class C<X<H>[Y<I,Z<J]<N[Z]{T \nf; M} ok (T-CLASS) A class table (CT) is ok, if all the class de.nitions in it are ok.  4.4 Operational \nSemantics The operational semantics is given by the reduction re\u00ad lation of the form e-.e, read expression \ne reduces to ein one step. We require another lookup function mbody(m,C<G>[H]), de.ned below, for a pair \nof natural number and method body with formal (type) parameters, written i, X.x.e, of given method and \nclass names. X and x are considered bound in e. The natural number i counts the difference between the \nnumber of the .xed parameters in the class that the method receiver belongs to and that in the class \nwhere the method body comes from. class C<X<H>[Y<I]<N[W]{T f; M} <Z<J>U0 m(U x){ . e0;} . M mbody(m,C<F>[G])=0,[F/X,G/Y](Z.x.e0) \n(MB-CLASS) class C<X<H>[Y<I,Z<J]<N[Z]{T f; M} m . M mbody([E/X,F/Y,G/Z](N[Z])) = i, W.x.e0 mbody(m,C<E>[F,G])=(i+|F|),W.x.e0 \n(MB-SUPER) The reduction rules are given below. We write [d/x,e/y]e0 for the expression obtained from \ne0 by replacing x1 with d1, ..., xn with dn, and ywith e. This simultaneous substitution is capture-avoiding. \nThe .rst three rules are one for .eld ac\u00adcess, one for method invocation, which are straightforward, \nthanks to lookup functions, and one for exact expressions. The only non-trivial point is that, in R-INVK, \nThis is re\u00adplaced by N[H], which is obtained by dropping I from the receiver type. Since the length of \nHis the same as the number of .xed parameters introduced between the receiver class and the class where \nthe method is de.ned, N[H] is a sub\u00adtype of the constructor part of the class where the method is de.ned. \n.elds(N[H])= Tf (R-FIELD) new N[H](e).fi-.ei mbody(m,N[H,I])= i, X.x.e0 |H| = i new N[H,I](e).<G>m(d)-. \n[d/x,new N[H,I](e)/this][G/X,N[H]/This]e0 (R-INVK) exacti new |I| = i N[H,I](e) as x, X in e0 (R-EXACT) \n-.[new N[H,I](e)/x][N[H]/X]e0 The reduction rules may be applied at any point in an expression, so we \nalso need the congruence rules. e0-.e0 . (RC-FIELD) e0.f-.e0 ..f e0-.e0 . (RC-INVK-RECV) e0.<H>m(e)-.e0 \n..<H>m(e) ei-.ei . e0.<H>m(...,ei,...)-.e0.<H>m(...,ei .,...) (RC-INVK-ARG) ei-.ei . new N[H](...,ei,...)-.new \nN[H](...,ei .,...) (RC-NEW) e1-.e1 . (RC-EXACT) exacti e1 as x,Xin e0 -.exacti e1 as x,X ine0 e0-.e0 \n. exacti e1 as x,Xin e0 -.exacti e1 as x,X ine0 (RC-EXACT-BODY) We write -.* for the re.exive and transitive \nclosure of -..  4.5 Type Soundness The type system is sound with respect to the operational semantics, \nas expected. Type soundness is proved in the standard manner via subject reduction and progress [43, \n20]. Here, we show only the results. See Appendix A for the required lemmas and proof sketches of the \ntheorems. THEOREM 1 (Subject Reduction). If .;G f e : T and e-.e., then .;G f e: T., for some T. such \nthat . f T.<:T.  Proof. By induction on the derivation of e-.e. with case analysis on the reduction \nrule used. . THEOREM 2 (Progress). If \u00d8;\u00d8f e :Tand e is not a value, then e-.e., for some e. Proof. By \ninduction on the derivation of \u00d8;\u00d8f e : T with case analysis on the last rule used. . THEOREM 3 (Type \nSoundness). If \u00d8;\u00d8f e :Tand e-.* ewith e. a normal form, then e. is a value v with \u00d8;\u00d8f v : T. and .f \nT.<:T. Proof. Immediate from Theorems 1 and 2. . 5. Interactions with Advanced Typing Features In this \nsection, we discuss interactions between self type constructors and other advanced typing features. Higher-Order \nType Constructors. Type constructor poly\u00admorphism, which has been implemented in Scala [27] and formalized \nas FGJ.[1], is a generalization of generics [3] so that class and method declarations can be parameterized \nby type constructors. So, it allows higher-order type construc\u00adtors since classes can be parameterized \nby type constructors, as the following example shows: class List<T> { ... } class List2<T> extends List<T> \n{ ... } class C<L<X> extends List<X>> { .. L<String> f; .. } Class C is parameterized by a type constructor \nvariable L, where Lmust be instantiated by a subtype of List, meaning that for any X, L<X> is a subtype \nof List<X>. So, C is a higher-order type constructor. Not only can higher-order type constructors be \nused to simulate self type constructors (which will be detailed in Section 6), but also they have their \nown applications such as generalized algebraic data types [1], polymorphic embed\u00adding of DSLs [18], and \nmodular visitor components [13]. So, it is worthwhile to extend self type constructors to be higher-order \nin order to acquire the advantages of both. Although we believe that such an extension is straightfor\u00adward, \nwe will need notations to specify kinds of type param\u00adeters, as in Scala and FGJ.. For example, if a \ntype parameter Xof Cranges over a type constructor that takes another .rst\u00adorder type constructor, the \nclass de.nition should be written like: class C<X<Y<Z>> extends ...> { .. } FGJstc in Section 4 does \nnot need such machinery since the order of type constructors is restricted. De.nition-Site Variance. \nDe.nition-site variance [14], whose theory is based on polarity [38] in F<:, is a typing . feature that \ncan relax invariance on parameters in a generic class with respect to subtyping. For example, if we write \nclass List<+T> { }, List is covariant with respect to T List<S> <: List<U> holds if S <:U. In exchange \nfor .exible subtyping, certain restrictions are posed on where the type parameter Tcan appear. For example, \nin List<+T>, neither T nor List<T> can be used as parameter types of a method. De.nition-site variance \ncan also be easily adapted to self type constructors so that variance can be speci.ed for both re.nable \nand .xed parameters. Note that the vari\u00adance annotations for .xed parameters and their restric\u00adtions \nare also effective on This. For example, assume that class List[+T]{ ... }, then This[S] <: This[U] holds \nif S <:U in the class, but at the same time This[T] cannot appear in the parameter position of method \nsigna\u00adtures. The class de.nition for Lists below is a straightfor\u00adward adaptation of one from Emir et \nal. [14] so that it uses self type constructors: abstract class List[+T]{ T head; @This[T] tail; <U> \n@This[U] create(U h, @This[U] t); <U super T> @This[U] append(@This[U] that){ return this.<U>create(head, \n(tail==null ? that : tail.<U>append(that))); } } (Here, <U super T> means that type variable U has a \nlower bound T.) This de.nition satis.es the restriction on type parameters. So, in addition to the fact \nthat append() of its subclasses will return the same kind of lists as the receiver, thanks to the use \nof @This, List is a covariant type operator. The example of parser combinators [28] can be similarly \nadapted. Wildcard Types. Wildcard types [41], derived from variant parametric types [21], are introduced \nto Java to relax invari\u00adance on parameters in a generic class as well as de.nition\u00adsite variance above. \nThe difference is that variances annota\u00adtions appear at each use of generic classes. Wildcards can be \neasily adapted to self type constructors and they are useful to write common interfaces for different \ninstantiations of a generic class, for example7: List<Comparable>[? extends Number] list1; Above, wildcard \n? extends Number means a certain type that is a subtype of Number. So, list1 represents a list of the \nelements of a certain subtype of Number. So, this is a common interface of, for example, List<Comparable> \n[Float], List<Comparable>[Integer], and so on. The introduction of wildcards to FGJstc could give more \ninformative types for expressions. The following .eld access typed by T-FIELD in FGJstc illustrates this: \nclass List[T] {} class C{ List[This] f; } C c; 7 We assume that Number implements Comparable, unlike \nin Java.  interface Comparable<T> { int compareTo(T that); } interface Iterator<T> { T next(); T peek(); \nboolean hasNext(); } Figure 6. Interfaces Comparable<T> and Iterator<T> c.f; // : Object<>[] in FGJstc \nThe type of c.f is Object<>[], which is the only supertype of List[This]. In the presence of wildcards, \nList[This] could have a less trivial supertype List[? extends C], which at least means that the result \nvalue is a List. 6. Related Work Much recently, Altherr and Cremet [1] and Moors, Piessens, and Odersky \n[27] have introduced type constructor polymor\u00adphism into class-based object-oriented programming lan\u00adguages. \nThey are partly motivated by the same problem dis\u00adcussed in this paper. As is shown below, programming \nsimi\u00adlar to the one presented in this paper is indeed possible with\u00adout self type constructors. However, \nin these solutions, writ\u00ading recursive interfaces requires more boilerplate code due to complicated use \nof advanced language mechanisms, includ\u00ading abstract type members and F-bounded polymorphism (aside from \ntype constructor polymorphism) to encode self type constructors manually. In this section, we compare \nour solution with those in [27] and [1]. Comparison with Scala. We start with revisiting the def\u00adinitions \nof Comparable and Iterator. In the absence of This and exact types, interfaces Comparable<T> and Iterator<T> \nhave different signatures as Figure 6 shows: interface Comparable takes one argument, which is usually \nthe class name that implements Comparable so that the re\u00adceiver of compareTo() is compared with an object \nof the same kind; the element type of Iterator<T> is not exact. Figure 7 shows the solution in Scala8 \nthat Moors, Piessens, and Odersky gave at the last OOPSLA. They used a highly sophisticated combination \nof abstract type members [34], higher-order type constructors [27, 1], and F-bounded poly\u00admorphism [11]. \nAs classes in Figure 4, Iterable has two parameters: Bound and T. The difference is that Bound is a type \nconstructor parameter (<_> represents an unused type parameter) so as to be instantiated with Comparable. \nSo, Iterable is higher-order. Another difference is that Tis F\u00adbounded T appears in the upper bound of \nitself. The key\u00adword type introduces abstract type member Self, which is a type constructor of one argument. \nSelf is used for 8 We adapt Java s notation for familiarity. For example, we use abstract classes for \ntraits. abstract class Iterable<Bound<_>, T extends Bound<T>>{ type Self<X extends Bound<X>> extends \nIterable<Bound,X>; abstract Self<T> append(Self<T> that); } class List<Bound<_>, T extends Bound<T>> \nextends Iterable<Bound, T>{ type Self<X extends Bound<X>> extends List<Bound,X>; Self<T> append(Self<T> \nthat){ ... } <U extends Bound<U>> Self<U> map(T->U f){ ... } } class SortedList<T extends Comparable<T>> \nextends List<Comparable, T>{ type Self<X extends Comparable<X>> = SortedList<X>; <U extends Comparable<U>> \nSelf<U> map(T->U f); } class NumericList<T extends Number> extends List<<_>->Number,T>{ type Self<T extends \nNumber> = NumericList<T>; <U extends Number> Self<U> map(T->U f); } Figure 7. Collections in Scala our \nThis, as the signatures of the methods show. The co\u00advariant change is achieved by manually re.ning or \n.x the upper bound of Self in every subclass of Iterable: in List, the upper bound of Self<X> is re.ned \nto List<X>; in SortedList, Self<X> is .xed to SortedList<X>. In NumericList, the upper bound of T is \nre.ned to type Number. Since Bound in superclass List is a type constructor, we have to adjust the arity \nof Number when it is given to List by using an anonymous type constructor <_>->Number9. Scalina [29] \nis an object-oriented calculus that provides the formal underpinning for the implementation of higher\u00adorder \ntype constructors in Scala. Like re.nable/.xed param\u00adeters, this calculus distinguishes abstract type \nmembers into two: members and un-members to prevent ill-formed type from appearing. While members are \nsimilar to re.nable pa\u00adrameters in that both are covariant, un-members are a lit\u00adtle different from .xed \nparameters un-members are con\u00adtravariant but .xed parameters are invariant. If .xed param\u00adeters were \ncontravariant, type soundness of FGJstc would be lost since superclass types can be ill formed. Comparison \nwith FGJ.. Figure 8 shows the solution in FGJ.[1] by Altherr and Cremet. In this solution, Self is the \nparameter of each generic class. This approach is based on the simulation of covariant change, described \nin [40, 8, 35], by using F-bounded polymorphism [11] and generics. So, as 9 In fact, Scala does not support \nanonymous type constructors, which can be simulated by abstract type members. On the other hand, FGJ. \nhas them.  abstract class Iterable<Bound<_>, T extends Bound<T>, Self<X extends Bound<X>> extends Iterable<Bound, \nX, Self>> { abstract Self<T> append(Self<T> that); } class List<Bound<_>, T extends Bound<T>, Self<X \nextends Bound<X>> extends List<Bound, X, Self>> extends Iterable<Bound, T, Self> { <U extends Bound<U>> \nSelf<U> map(T->U f) { ... } } class SortedList<Bound<X> extends Comparable<X>, T extends Bound<T>, Self<X \nextends Bound<X>> extends SortedList<Bound, X, Self>> extends List<Bound, T, Self> { } Figure 8. Collections \nin FGJ. a natural result, this solution has the same disadvantages as the simulation in the following \npoints: 1. type parameterization is much more complex, 2. .xed point classes are necessary for object \ncreations, and 3. selftyping is not suitable for recursion.  We elaborate the second and third points \nbelow. It is impossible to create objects from these generic classes since there are no type constructors \nthat conform to the upper bounds. So, .xed point classes have to be declared as the generators of objects, \nas follows: class ListFix<Bound<_>, T extends Bound<T>> extends List<Bound, T, ListFix> {} class SortedListFix<Bound<_>, \nT extends Bound<T>> extends SortedList<Bound, T, SortedListFix> {} Note that these .xed point classes \nare not in subtyping rela\u00adtion because they are not in the inheritance relation. Wild\u00adcards [41], which \nFGJ. does not have, can be used to ex\u00adpress common interfaces of their instances. For example, List<Comparable,Integer,?> \nis a common interface of ListFix<Comparable,Integer> and SortedListFix< Comparable,Integer>. In our proposal, \ninexact types play the role of such common interfaces. In class List, this has type List<Bound,T,Self>, \nbut not Self<T>. As a result, the following method cannot be well typed: class List<Bound<_>, T extends \nBound<T>, Self<X extends Bound<X>> extends List<Bound,X,Self>> extends Iterable<Bound,T,Self> { void \ndouble(){ append(this); // ill-typed } } The type List<Bound,T,Self> of argument this is not a subtype \nof Self<T>, the parameter type. In general, this cannot be passed to binary methods as the arguments \nin this programming style. There are several solutions to this prob\u00adlem. In Scala, self types can be \nexplicitly annotated [34] by using requires clause. Another solution, invented in\u00addependently by Saito \nand Igarashi [35] and Kamina and Tamai [24], is to extend generics a little so that this can have abstract \ntypes in a special case in exchange for a small restriction on subclassing. 7. Conclusion In this paper, \nwe propose self type constructors, which inte\u00adgrate This and generics so that This is a type constructor \nin a generic class. Self type constructors can express open re\u00adcursion at the level of type constructors. \nSo, a generic class can be safely reused even if it has references to itself recur\u00adsively but with different \ntype instantiations. We expect that self type constructors can be applied not only to collections but \nalso to programming with comprehensions [2, 25] and parser combinators [28]. We formalize self type constructors \nas a small calculus FGJstc and prove that the type system is sound with respect to operational semantics. \nMain future work is to consider the integration of self type constructors with grouping mechanisms and \npath types [8, 37, 22], which support extensible yet type-safe mutually re\u00adcursive classes since mutual \nrecursion cannot be expressed by self type constructors. Such an integration will validate our decision \nto have thrown away F-bounded polymorphism, which has been used to express mutual recursion. We con\u00adjecture \nthat the present type system is decidable but showing it is left for future work. Other future work includes \nthe de\u00advelopment of a type inference algorithm for polymorphic method invocations. We believe that the \nlimitation that List s element type had to be exact can be easily addressed by allowing exact types (as \nwell as inexact types) to be passed as type argu\u00adments. Fig 9 sketches a solution. There, the element \ntype in the declarations of Iterator and List is inexact. Class SortedList inherits List and the element \ntype is instanti\u00adated by exact type @T. So, the inherited method iterator() returns an Iterator of the \nexact type. All in all, List is a heterogeneous collection while SortedList is homoge\u00adneous, as desired. \nThe formalization of this solution is left for future work, too.  interface Iterator<T>{ T next(); ... \n} class List<Bound>[T extends Bound] extends Iterable<Bound>[T]{ Iterator<T> iterator(){...} } class \nSortedList<Bound extends Comparable> [T extends Bound] extends List<Bound>[@T]{ // ^^ exact-type instantiation \nIterator<@T> iterator(){ ... } // if overridden (not necessary) } Figure 9. De.nitions of heterogeneous \nList and homoge\u00adneous SortedList. Acknowledgments Comments from anonymous reviewers of OOPSLA2009 helped \nus improve the presentation of the present paper. We would like to thank members of the Kumiki project \nfor fruit\u00adful discussions on this subject. This work was supported in part by Grant-in-Aid for Scienti.c \nResearch No. 18200001 and Graint-in-Aid for Young Scientists (B) No. 18700026 from MEXT of Japan (Igarashi). \nSaito is a research fellow of the Japan Society for the Promotion of Science for Young Scientists. A. \nProof Sketches of Theorems 1 and 2 We sketch the proofs of Theorems 1 and 2. (Theorem 3 is their easy \nconsequence.) The structure of the proof of sub\u00adject reduction is similar to those for Featherweight \nJava and Featherweight GJ [20]. So, we .rst prove various substi\u00adtution lemmas, which are all proved \nby induction on the derivations, with other auxiliary lemmas. LEMMA 1 (Weakening). Suppose f X <: I :: \nk and .f Uok. 1. If .f S <:T, then X <:I,.f S <:T. 2. If .f Sok, then X <:I,.f Sok. 3. If .;G f e : \nT, then .;G,x : U f e : T and X <: I,.;G f e :T.  Proof. Each is proved by straightforward induction \non the derivation of . f S <: T, . f Sok, and .;G f e : T, respectively. . LEMMA 2. If .f I[H] :: k, \nthen .f I :: k. for some k. . Proof. By induction on the derivation of .f I[H] :: k. . LEMMA 3. If . \nf H0 <: I0, then H0 = K.[H,I] and I0 = K[I] for some K. , K, H, and I. Proof. By induction of the derivation \nof .f H0 <:I0. . LEMMA 4 (Type Substitution Preserves Subtyping). If .1, X <:I,.2 f S <:Tand .1 f H <:Iwith \n.1 f H :: k, then .1,[H/X].2 f [H/X]S <: [H/X]T. Proof. By induction on the derivation of .1,X <:I,.2 \nf S <:T. . LEMMA 5. If .f S <:Tand .f S :: k, then .f T :: k. Proof. By induction on the derivation of \n. f S <: T. Note that the last premise about the equality on upper bounds in the rule T-CLASS is used \nin the case of S-CLASS. . LEMMA 6. If . f I[H] :: *, then there exist some X and J such that . f I :: \nX <: J.* and . f H <: [H/X]J and .f H :: *. Proof. By induction on the derivation of .f I[H] :: *. . \nLEMMA 7 (Type Substitution Preserves Well-Formedness). If .1,X <:I,.2 f Tok and .1 f H <:Iwith .1 f H \n:: k, then .1,[H/X].2 f [H/X]Tok. Proof. By induction on the derivation of .1,X <:I,.2 f Tok using Lemmas \n5 and 6. . LEMMA 8. If . f Tok and .;x:T f e : T for some well\u00adformed bound environment ., then .f Tok. \nProof. By induction on the derivation of .;x:T f e :Twith case analysis on the last rule used. . LEMMA \n9. If . f H <:I and .elds(bound. (I)) = Tf, then .elds(bound.(H)) = Sgand Si = Ti and gi = fi for all \ni =|f|. Proof. By straightforward induction on the derivation of .f H <:I. . LEMMA 10. If .f K.[G,H] \n<: K[H] and mtype(m,bound. (K[H])) = <X<I>T.T0, then mtype(m,bound.(K.[G,H])) = <Y<J>U.U0 and [This[G]/This][Y/X](I,T) \n=(J,U) and .f U0 <: [This[G]/This][Y/X]T0. Proof. By induction on the derivation of . f K.[G,H] <: K[H]. \n. LEMMA 11 (Type Substitution Preserves Typing). If .1,X <: I,.2;G f e : T and .1 f H :: k and .1 f H \n<:I, then .1,[H/X].2;[H/X]G f [H/X]e : Sfor some Ssuch that .1,[H/X].2 f S <: [H/X]T. Proof. By induction \non the derivation of .1,X <:I,.2;Gf e :T. . LEMMA 12 (Term Substitution Preserves Typing). If .;G, x \n: T f e0 : T0 and .;G f d : S where . f S <: T, then .;G f [d/x]e :S0 for some S0 such that .f S0 <:T0. \n Proof. By induction on the derivation of .;G,x : T f e0 : T0. Note that if .f S <: @H, then S = @H. \n. LEMMA 13. If . f N[H,I] ok and mtype(m,N[H,I])= <X<J>U . U0 and mbody(m,N[H,I])= |H|,X.x.e0, then there \nexist P, I and S0 such that . f N[H] <: P and . f P[I] ok and .,This <: P,X <:J f S0 <: U0 and .,This \n<: P,X <: J f S0 ok and .,This <: P,X <: J;x : U,this :@This[I] f e0 :S0 and .f [N[H]/This]U0 ok.  Proof. \nBy induction on the derivation of mbody(m,N[H,I]) = |H|,X.x.e0 using Lemma 11. . LEMMA 14 (Narrowing). \nIf .1,X<:I,.2 f e:T and .1 f I.<:I, then .1,X<:I. ,.2 f e:T. for some T. such that .1,X<:I. ,.2 f T.<:T. \nProof. By induction on the derivation of .1,X<:I,.2 f e:T. .   A.1 Proof of Theorem 1 We show only \nmain cases. Other cases, that is, RC-INVK-ARG, RC-NEW and RC-EXACT-BODY, are easy. Case R-FIELD: e = \nnew N[I](e).fi .elds(N[I])= Tf e= ei By T-FIELD, and T-NEW, we have .;G f ei :Si G,H = I .f Si <: [N[G]/This]Ti \n.f [N[G]/This]Ti ok T =[N[G]/This]Ti Thus, .;G f ei :Si .nishes the case. Case R-INVK: e = new N[H,I](e).<G>m(d) \nmbody(m,N[H,I])= i, X.x.e0 |H| = i e=[d/x, new N[H,I](e)/this] [G/X, N[G]/This]e0 By T-INVK and T-NEW, \nwe have .f N[H,I] ok .;G f new N[H,I](e) :@N[H,I] mtype(m,N[H,I])= <X<J>T.T0 .f G :: k .f G <: [G/X][N[H]/This]J \n.;G f d :S .f S <: [G/X][N[H]/This]T T =[G/X,N[H]/This]T0 .f [N[H]/This]T0 ok Then, by Lemma 13, there \nexist P, Iand S0 such that .f N[H] <:P .,This <:P,X<:J;G,x:T,this :@This[I] f e0 :S0 .,This <:P,X<:J \nf S0 <:T0. Then, by Lemma 11 and the fact that none of Xappears in I, there exists S0 . such that .;x \n:[G/X][N[H]/This]T,this :@N[H,I] f [G/X][N[H]/This]e0 :S0 .f S0 . <: [G/X][N[H]/This]S0. We also have \n.f [G/X][N[H]/This]S0 <: [G/X][N[H]/This]T0 by Lemma 4. Finally, by Lemma 12, there exists S0 .. such \nthat .. .. <:S0 . .;G f e. :S0 .f S0 . Finally, by S-TRANS, .f S0 .. <:T, .nishing the case. Case R-EXACT: \ne = exacti new N[H,I](e) as x,Xin e0 |I| = i e=[new N[H,I](e)/x][N[H]/X]e0 By T-EXACT and T-NEW, we have \n.f N[H,I] ok .;G f new N[H,I](e) :@N[H,I] .,X <: N[H];G,x :@X[I] f e0 :U .,X<:N[H] f U<:S .f Sok By Lemmas \n11 and 12, .;G f e. : U. such that . f U. <: [N[H]/X]U. By Lemma 4 and the fact that [N[H]/X]S = S, . \nf [N[H]/X]U <: S. By S-TRANS, . f U. <: S, .nishing the case. Case RC-FIELD: e = e0.f e= e0 ..f e0-.e0 \nBy the rule T-FIELD, we have .;G f e0 :@H0 .elds(bound.(H0)) = Tf H0 = I0[H] .f [I0/This]Ti ok T =[I0/This]Ti \nBy the induction hypothesis, .;G f e0 . : T0 . for some T0 such that . f T0 .<:@H0. Since T0 = @H0, .;G \nf e0 ..f : [I0/This]Ti by T-FIELD. Letting T. =[I0/This]Ti .nishes the case. Case RC-INVK-RECV: Similar \nto the case RC-FIELD. Case RC-EXACT: e = exacti e0 as x,X ine1 e= exacti e0 as x,Xin e1 e0-.e0 . Case \nanalysis on the typing rule used. Subcase T-EXACT1: .;G f e0 :I[H] |H| = i .,X<:I;G,x :@X[H] f e1 :U1 \n.,X<:I f U1<:T1 .f T1 ok T = T1 By the induction hypothesis, we have .;G f e0 : S0 for some S0 such that \n.f S0<:I[H]. Case analysis on S0. Subsubcase: S0 = I.[H] .f I.<:I By Lemma 14, .,X<:I.;G,x : @X[H] f \ne1 : U1 . for some U1 . such that .,X<:I. f U1 .<:U1. By Lemma 4, .,X<:I. f U1<:T1. By S-TRANS, .,X<:I. \nf U1 .<:T1. By T-EXACT1, .;G f exacti e0 as x,Xin e1 : T1. Letting T. = T1 .nishes the case.  Subsubcase: \nS0 = @I.[H] .f I.<:I By Lemma 11 and the fact that X does not appear in H and G, .;G,x : @I.[H] f e1 \n: U1 for some U1 such that . f U1 .<:[I./X]U1. By T-EXACT2, .;G f exacti e0 as x,X ine1 : U1 .. By Lemma \n4 and the fact that [I./X]T1 = T1, . f [I./X]U1<:T1. By S-TRANS, .f U1 .<:T1. Letting T. = U1 . .nishes \nthe case. Subcase T-EXACT2: Easy.  A.2 Proof of Theorem 2 We show only main cases. Other cases are easy. \nCase: e = e0.fi If e0 is not a value, by the induction hypothesis, e0 -. e0 for some e0 .; then, RC-FIELD \nshows e0.fi -. e0 ..fi. On the other hand, if e0 is a value new N0[I](v), then, by T-FIELD, it must be \nthe case that Tfi . .elds(N0[I]). Then, e0.fi -. vi by R-FIELD. Case: e = e0.<G>m(e) If ei is not a value, \nby the induction hypothesis, ei -. ei for some ei .; then, use RC-INVK-RECV or RC-INVK-ARG to show e0.<G>m(e) \n-. e0 ..<G>m(e)or e0.<G>m(..,ei, ..) -. e0.<G>m(..,ei ...), respectively. On the other hand, if e0 is \na value new N0[H](v), then by T-INVK, it must be the case that mtype(m,N0[H])= <X<F>S.S0. By Lemma 13, \nmbody(m,N0[H])= i,X.x.ewhere |x| = |e|. We let (I,J) = H where |I| = i. By R-INVK, we have e -. [e/x, \nnew N0[H](v)/this][G/X, N0[I]/This]e .nishing the case. Case: e = exacti e0 as x,X ine1 If e0 is not \na value, by the induction hypothesis, e0 -. e0 for some e0 .; then, RC-EXACT shows exacti e0 as x,X in \ne1 -. exacti e0 as x,Xin e1. On the other hand, if e0 is a value new N0[G,H](v) where |H| = i, then by \nR-EXACT we have e -. [new N0[G,H](v)/x][N0[G]/X]e1 .nishing the case. References [1] Philippe Altherr \nand Vincent Cremet. Adding type construc\u00adtor parameterization to Java. Journal of Object Technology, \n7(5):25 65, June 2008. Special Issue: Workshop on FTfJP 2007. [2] Gavin M. Bierman, Erik Meijer, and \nWolfram Schulte. The essence of data access in Comega. In Proc. of ECOOP, volume 3586 of LNCS, pages \n287 311, 2005. [3] Gilad Bracha, Martin Odersky, David Stoutamire, and Philip Wadler. Making the future \nsafe for the past: Adding genericity to the Java programming language. In Proc. of OOPSLA 98, pages 183 \n200, 1998. [4] Kim B. Bruce. A paradigmatic object-oriented programming language: Design, static typing \nand semantics. Journal of Functional Programming, 4(2):127 206, April 1994. [5] Kim B. Bruce. Some challenging \ntyping issues in object\u00adoriented languages. In Proc. of WOOD 03, volume 82 of ENTCS, 2003. [6] Kim B. \nBruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Objects Group, Gary T. Leavens, and Benjamin Pierce. \nOn binary methods. Theory and Practice of Object Systems, 1(3):221 242, 1996. [7] Kim B. Bruce and J. \nNathan Foster. LOOJ: Weaving LOOM into Java. In Proc. of ECOOP 2004, volume 3086 of LNCS, pages 390 414, \nJune 2004. [8] Kim B. Bruce, Martin Odersky, and Philip Wadler. A statically safe alternative to virtual \ntypes. In Proc. of ECOOP 98, volume 1445 of LNCS, pages 523 549, 1998. [9] Kim B. Bruce and Joseph C. \nVanderwaart. Semantics-driven language design: Statically type-safe virtual types in object\u00adoriented \nlanguages. In Proc. of MFPS XV, volume 20 of ENTCS, 1999. [10] Nicholas Cameron and Sophia Drossopoulou. \nOn subtyping, wildcards, and existential types. In Proc. of FTfJP, Genoa, Italy, July 2009. [11] Peter \nCanning, William Cook, Walter Hill, Walter Olthoff, and John C. Mitchell. F-bounded polymorphism for \nobject\u00adoriented programming. In Proc. of ACM Conference on Functional Programming and Computer Architecture \n(FPCA 89), pages 273 280, London, England, September 1989. ACM Press. [12] Dave Clarke, Sophia Drossopoulou, \nJames Noble, and Tobias Wrigstad. Tribe: A simple virtual class calculus. In Proc. of AOSD 07, pages \n121 134, 2007. [13] Bruno C. d. S. Oliveira. Modular visitor components: A practical solution to the \nexpression families problem. In Proc. of ECOOP 2009, pages 269 293, July 2009. [14] Burak Emir, Andrew \nKennedy, Claudio Russo, and Dachuan Yu. Variance and generalized constraints for C# generics. In Proc. \nof ECOOP2006, volume 4067, pages 279 303, 2006. [15] Erik Ernst. Family polymorphism. In Proc. of ECOOP \n2001, volume 2072 of LNCS, pages 303 326, 2001. [16] Erik Ernst. Higher-order hierarchies. In Proc. of \nECOOP 2003, volume 2743 of LNCS, pages 303 328, 2003. [17] Erich Gamma, Richard Helm, Ralph Johnson, \nand John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Sotfware. Addison-Wesley, 1995. \n[18] Christian Hofer, Klaus Ostermann, Tillmann Rendel, and Adriaan Moors. Polymorphic embedding of DSLs. \nIn Proc. of International Conference on Generative Programming and Component Engineering 2008, pages \n137 148, New York, NY, USA, 2008. ACM. [19] Atsushi Igarashi and Benjamin C. Pierce. Foundations for \nvirtual types. In Rachid Guerraoui, editor, Proceedings of the 13th European Conference on Object-Oriented \nProgramming (ECOOP 99), volume 1628 of Lecture Notes in Computer Science, pages 161 185, Lisbon, Portugal, \nJune 1999. Springer-Verlag.  [20] Atsushi Igarashi, Benjamin C. Pierce, and Philip Wadler. Featherweight \nJava: A minimal core calculus for Java and GJ. ACM Transactions on Programming Languages and Systems, \n23(3):396 450, May 2001. A preliminary summary appeared in Proc. of OOPSLA 99. [21] Atsushi Igarashi \nand Mirko Viroli. Variant parametric types: A .exible subtyping scheme for generics. ACM Transactions \non Programming Languages and Systems, 28(5):795 847, September 2006. A preliminary version appeared under \nthe title On Variance-Based Subtyping for Parametric Types in Proc. of ECOOP2002. [22] Atsushi Igarashi \nand Mirko Viroli. Variant path types for scalable extensibility. In Proceedings of the ACM Conference \non Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2007), pages 113 132, Montreal, \nQC, October 2007. [23] Paul Jolly, Sophia Drossopoulou, Christopher Anderson, and Klaus Ostermann. Simple \ndependent types: Concord. In Proc. of FTfJP 2004, June 2004. [24] Tetsuo Kamina and Tetsuo Tamai. Lightweight \nscalable com\u00adponents. In Proc. of 6th International Conference on Gener\u00adative Programming and Component \nEngineering(GPCE 07), pages 145 154, October 2007. [25] Erik Meijer. Confessions of a used programming \nlanguage salesman. In Proc. of OOPSLA, pages 677 694, 2007. [26] Bertrand Meyer. Genericity versus inheritance. \nIn Proc. of OOPSLA, pages 391 405, 1986. [27] Adriaan Moors, Frank Piessens, and Martin Odersky. Gener\u00adics \nof a higher kind. In Proc. of OOPSLA (OOPSLA 08), pages 423 438, 2008. [28] Adriaan Moors, Frank Piessens, \nand Martin Odersky. Parser combinators in Scala. Technical Report CW491, Katholieke Universiteit Leuven, \nBelgium, 2008. [29] Adriaan Moors, Frank Piessens, and Martin Odersky. Safe type-level abstraction in \nscala. In Proc. of International Workshop on Foundations of Object-Oriented Languages (FOOL 08), January \n2008. [30] Nathaniel Nystrom, Stephen Chong, and Andrew C. Myers. Scalable extensibility via nested inheritance. \nIn Proc. of OOPSLA 04, pages 99 115, October 2004. [31] Nathaniel Nystrom, Xin Qi, and Andrew C. Myers. \nJ&#38;: Nested intersection for scalable software composition. In Proc. of OOPSLA 06, pages 21 36, 2006. \n[32] Martin Odersky. The Scala language speci.cation, version 2.6. EPFL. http://www.scala-lang.org/docu/files/ \nScalaReference.pdf, November 2007. [33] Martin Odersky, Vincent Cremet, Christine R\u00a8ockl, and Matthias \nZenger. A nominal theory of objects with dependent types. In Luca Cardelli, editor, Proc. of ECOOP 03, \nvolume 2743 of LNCS, pages 201 224, Darmstadt, Germany, July 2003. [34] Martin Odersky and Matthias Zenger. \nScalable component abstractions. In Proc. of OOPSLA 05, pages 41 57, 2005. [35] Chieri Saito and Atsushi \nIgarashi. The essence of lightweight family polymorphism. Journal of Object Technology, 7(5):67 99, June \n2008. Special Issue: Workshop on FTfJP 2007. [36] Chieri Saito and Atsushi Igarashi. Matching ThisType \nto subtyping. In Proceedings of the 24th Annual ACM Symposium on Applied Computing (SAC2009), pages 1851 \n1858, Honolulu, HI, March 2009. [37] Chieri Saito, Atsushi Igarashi, and Mirko Viroli. Lightweight family \npolymorphism. Journal of Functional Programming, 18(3):285 331, 2008. [38] Martin Steffen. Polarized \nHigher-Order Subtyping. PhD thesis, Technische Fakult\u00a8at, Friedrich-Alexander-Universit\u00a8at Erlangen-N\u00a8urnberg, \nNovember 1998. [39] Kresten Krab Thorup and Mads Torgersen. Unifying generic\u00adity: Combining the bene.ts \nof virtual types and parameterized classes. In Proc. of 13th ECOOP (ECOOP 99), volume 1628 of LNCS, pages \n186 204, Lisbon, Portugal, June 1999. [40] Mads Torgersen. The expression problem revisited: Four new \nsolutions using generics. In Proc. of ECOOP2004, volume 3086 of LNCS, pages 123 146, Oslo, Norway, June \n2004. [41] Mads Torgersen, Christian Plesner Hansen, Erik Ernst, Peter von der Ah\u00b4Adding e, Gilad Bracha, \nand Neal Gafter. wildcards to the Java programming language. In Proc. of SAC 04, pages 1289 1296, 2004. \n[42] Philip Wadler. The expression problem., 1998. Discus\u00adsion on the Java-Genericity mailing list. Also \navailable at http://homepages.inf.ed.ac.uk/wadler/papers/ expression/expression.txt . [43] Andrew K. \nWright and Matthias Felleisen. A syntactic approach to type soundness. Information and Computation, 115(1):38 \n94, November 1994.  \n\t\t\t", "proc_id": "1640089", "abstract": "<p>Bruce and Foster proposed the language LOOJ, an extension of Java with the notion of <i>MyType</i>, which represents the type of a self reference and changes its meaning along with inheritance. <i>MyType</i> is useful to write extensible yet type-safe classes for objects with recursive interfaces, that is, ones with methods that take or return objects of the same type as the receiver.</p> <p>Although LOOJ has also generics, <i>MyType</i> has been introduced as a feature rather orthogonal to generics. As a result, LOOJ cannot express an interface that refers to the same generic class recursively but with different type arguments. This is a significant limitation because such an interface naturally arises in practice, for example, in a generic collection class with method map(), which converts a collection to the same kind of collection of a different element type. Altherr and Cremet and Moors, Piessens, and Odersky gave solutions to this problem but they used a highly sophisticated combination of advanced mechanisms such as abstract type members, higher-order type constructors, and F-bounded polymorphism.</p> <p>In this paper, we give another solution by introducing <i>self type constructors</i>, which integrate <i>MyType</i> and generics so that <i>MyType</i> can take type arguments in a generic class. Self type constructors are tailored to writing recursive interfaces more concicely than previous solutions. We demonstrate the expressive power of self type constructors by means of examples, formalize a core language with self type constructors, and prove its type safety.</p>", "authors": [{"name": "Chieri Saito", "author_profile_id": "81418598723", "affiliation": "Kyoto University, Kyoto, Japan", "person_id": "P1728771", "email_address": "", "orcid_id": ""}, {"name": "Atsushi Igarashi", "author_profile_id": "81309510908", "affiliation": "Kyoto University, Kyoto, Japan", "person_id": "P1728772", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640109", "year": "2009", "article_id": "1640109", "conference": "OOPSLA", "title": "Self type constructors", "url": "http://dl.acm.org/citation.cfm?id=1640109"}