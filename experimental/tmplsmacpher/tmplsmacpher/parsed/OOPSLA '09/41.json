{"article_publication_date": "10-25-2009", "fulltext": "\n Integrating Static Analysis and Testing for Firewall Policies William Formyduval Department of Computer \nScience, North Carolina State University Raleigh, NC 27695, USA wlformyd@ncsu.edu Abstract Static analysis \nis a technique of checking .rewall policies for com\u00admon miscon.gurations. Because static analysis does \nnot consider the desired behavior of a policy, it cannot detect faults located in partially masked rules. \nOur new approach, which integrates static analysis and testing, can detect miscon.gurations located in \npar\u00adtially masked rules. Categories and Subject Descriptors D.2.5 [Software Engineer\u00ading]: Testing and \nDebugging Debugging aids, Testing tools General Terms Security, Veri.cation. Keywords Firewall policies, \nFirewalls, Test generation. 1. Introduction A .rewall is a device that .lters network traf.c based on \na series of rules. These rules, which are collectively known as a policy, specify what is (and is not) \nallowed to pass through the .rewall. A miscon.guration in the .rewall policy can leave the network vulnerable \nto attack or deny legitimate users access to resources. Therefore, it is important that .rewalls be con.gured \nproperly. Firewalls perform the action associated with the .rst rule that matches the packet under process \nin a forward traversal of the policy. If a received packet does not match any of the rules in the policy, \nthen the .rewall performs the default action. In a policy with multiple rules, it is possible for a single \npacket to satisfy all of the conditions of more than one rule. If such a case occurs, then the rule with \nthe highest priority determines the action performed by the .rewall. This case is known as masking. It \nis possible for rules to occur in an order that makes them either partially or completely masked by earlier \nrules; both cases are easily detected by static analysis. Completely masked rules do not affect the behavior \nof the .rewall policy and, therefore, are considered faults [1]. Partially masked rules, however, cannot \nbe classi.ed as faults without additional information (i.e., the behavior intended by the administrator). \nBelow are two .ltering rules that illustrate this situation: permit tcp 192.168.0.0/16 10.110.0.0/16 \ndeny tcp host 192.168.1.2 any Copyright is held by the author/owner(s). OOPSLA 2009, October 25 29, 2009, \nOrlando, Florida, USA. ACM 978-1-60558-768-4/09/10. The .rst rule allows TCP traf.c from host 192.168.1.2 \nto the 10.110.0.0/16 network, whereas the second rule explicitly denies all TCP traf.c from host 192.168.1.2. \nHere the second rule is par\u00adtially masked by the .rst rule. Partially masked rules must be man\u00adually \ninspected by the administrator before they are considered faulty. But it is possible for a single policy \nto contain many par\u00adtially masked rules. Furthermore, it may be dif.cult to determine whether partially \nmasked rules exhibit undesirable behavior. There\u00adfore, there is a strong need for a technique of con.rming \nthe exis\u00adtence of faults located in partially masked rules. We propose a technique that creates a set \nof test packets that, together with their associated decisions (i.e., accept or deny), can aid administrators \nin detecting faults located in partially masked rules.  2. Fault Detection Our fault-detection process \nconsists of two steps. In the .rst step, we use static analysis to .nd partially masked rules. In the \nsecond step, we generate a set of test packets, evaluate them against the .rewall policy, and compare \nthe actual decisions to those expected by the administrator. Table 1 includes notation used in this paper. \nR an ordered set of rules ri the ith rule of the set R k a packet P (ri) the set of packets that are \naccepted or denied by rule ri Mi the set of packets that are accepted or denied by rules r1,r2,... ,ri-1 \nQi an ordered set of rules that mask rule ri qin the nth rule of the set Qi Ti the set of packets generated \nto test rule ri Table 1. Summary of notations 2.1 Finding Partially Masked Rules For a rule ri to be \npartially masked, there must exist one or more rules of higher priority than ri whose domain (i.e., the \nset of packets for which all conditions of the rule are satis.ed) intersects with that of ri,and if ri \nwere to be removed from the policy, then the behavior of the policy must change (i.e., ri is not completely \nmasked or redundant). A procedure for .nding Qi, which is the set of all rules that mask ri, is described \nin Algorithm 1. Note that Qi consists only of rules that are neither completely masked nor redundant1.Com\u00adpletely \nmasked rules and redundancies do not affect the behavior of the .rewall and, therefore, have no effect \non testing. Rules in Qi occur in the same order that they appear in R. 1 Cuppens et al. [1] present a \nredundancy-detection algorithm.  Algorithm 1 .ndMask(ri) Qi .\u00d8 for x =1 to i - 1 do if (P (rx) \\ (P \n(rx) n Mx)) n P (ri) = \u00d8 then if !isRedundant(rx) then Qi = Qi . rx end if end if end for return Qi 2.2 \nTesting Partially Masked Rules For a partially masked rule ri, we generate a set of test packets by solving \nconstraints collected from Qi. For a rule qin in Qi,we attempt to .nd a packet k, such that k satis.es \nall of the conditions of qin and ri, but does not satisfy all of the conditions of any other rule in \nQi. We conduct this procedure for every rule in Qi, resulting in |Qi| sets of constraints for rule ri. \nFor example, the set of constraints associated with the nth rule of Qi,where Qi consists of m rules, \nis: k/. P (qi1 ) . ... . k . P (qin ) . ... . k/. P (qim ) . k . P (ri) Because Qi consists only of rules \nthat mask ri, we can always .nd a packet that satis.es all of the conditions of both qin and ri. There \nmay not, however, exist a packet that does so without also satisfying all of the conditions of another \nrule in Qi (i.e., there does not exist a solution to the preceding constraints). If this case occurs, \nthen the test does not fail; it indicates that we have generated (or will generate) a packet that takes \nthe same path (i.e., generating constraints in this manner prevents redundant testing), provided that \nwe test every partially masked rule in Qi. Therefore, we can expect =|Qi| test packets to be generated \nfor a partially masked rule ri. The set of test packets generated for a partially masked rule ri is Ti. \nThe action performed by the .rewall when a test packet k from Ti is received2 is compared with the action \nexpected by the administrator. If the two actions are the same, then the test passes, and no fault is \ndetected. If the two actions are different, then the test fails, and the .rst rule (encountered in a \nforward traversal of Qi) that matches the test packet associated with the failed test is faulty (i.e., \ncauses the .rewall to perform an unexpected action). Testing of ri is complete when all |Ti| tests have \nbeen executed.  3. Implementation and Experience We modi.ed FIREMAN [3], a static analysis toolkit, \nto detect partially masked rules as presented in Section 2.1. To test partially masked rules for faults, \nwe modi.ed a .rewall policy testing tool [2] to generate packets according to the algorithm described \nin Section 2.2. We used our tool to test three Cisco PIX .rewall policies for faults. Each policy that \nwe tested consisted of one or more partially masked rules, some of which were randomly chosen to be clas\u00adsi.ed \nas miscon.gurations (i.e., unintentionally masked) prior to testing. For our test policies, the desired \nbehavior of two partially masked rules was chosen randomly from the decisions of the two rules. With \nthe aid of our tool, we were able to determine whether partially masked rules were the cause of undesirable \nbehavior in our policies under test. 2 Note that because Qi consists of all of the rules that mask ri, \nthe action performed by the .rewall when k is received is the action associated with the .rst rule encountered \nin a forward traversal of Qi whose conditions are satis.ed by k. One limitation of our approach is that \nthe desired behavior of the .rewall must be known prior to testing. In addition, our tool was not helpful \nin detecting all occurrences of unintentional masking; for example, if our tool encountered two overlapping \nrules with the same decision, then the generated test packets did not suggest that they were faulty, \neven if the two rules were unintentionally masked. 4. Discussion Static analysis can detect partially \nmasked rules, but it cannot determine whether they are faulty. Without a systematic approach to detecting \nfaults located in partially masked rules, they must be manually inspected by the administrator. The dif.culty \nlevel of manual policy inspection depends on many factors including the size of the policy, the number \nof partially masked rules, and the number of rules involved in each masking. In a large policy, manual \npolicy inspection may be impractical. Our technique of fault detection improves the results of static \nanalysis by performing behavioral testing on partially masked rules. In policy testing, the behavior \nof the .rewall policy is compared to that intended by the administrator. A disadvantage of policy testing \nis that manual inspection of packet-decision pairs may be tedious. Many policy testing techniques attempt \nto detect as many faults as possible in the entire policy. Because our technique is concerned with detecting \nonly faults located in partially masked rules (i.e., typically only a small portion of the overall policy), \nthe number of packet-decision pairs requiring manual inspection is small compared to that of many other \npolicy testing techniques. 5. Conclusion We have presented an approach that generates a set of test \npack\u00adets that, together with their associated decisions (i.e., accept or deny), can aid administrators \nin detecting faults located in partially masked rules. Our approach improved the results of static analy\u00adsis \nby performing behavioral testing on partially masked rules, and generated relatively few packet-decision \npairs requiring manual in\u00adspection, in contrast to policy testing alone.  Acknowledgments This work \nis supported in part by NSF grant CNS-0716579. The author would like to thank Tao Xie and JeeHyun Hwang \nfor their guidance in carrying out this work.  References [1] F. Cuppens, N. Cuppens-Boulahia, and J. \nGarc\u00b4ia-Alfaro. Detection and removal of .rewall miscon.guration. In Proc. IASTED Interna\u00adtional Conference \non Communication, Network and Information Se\u00adcurity (CNIS), pages 154 162, 2005. [2] J. Hwang, T. Xie, \nF. Chen, and A. Lui. Systematic structural testing of .rewall policies. In Proc. 27th IEEE International \nSymposium on Reliable Distributed Systems (SRDS), pages 105 114, 2008. [3] L. Yuan, J. Mai, Z. Su, H. \nChen, C. Chuah, and P. Mohapatra. FIRE-MAN: A Toolkit for FIREwall Modeling and ANalysis. In Proc. IEEE \nSymposium on Security and Privacy, pages 199 213, 2006.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Static analysis is a technique of checking firewall policies for common misconfigurations. Because static analysis does not consider the desired behavior of a policy, it cannot detect faults located in partially masked rules. Our new approach, which integrates static analysis and testing, can detect misconfigurations located in partially masked rules.</p>", "authors": [{"name": "William Formyduval", "author_profile_id": "81444605856", "affiliation": "North Carolina State University, Raleigh, NC, USA", "person_id": "P1728550", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1639996", "year": "2009", "article_id": "1639996", "conference": "OOPSLA", "title": "Integrating static analysis and testing for firewall policies", "url": "http://dl.acm.org/citation.cfm?id=1639996"}