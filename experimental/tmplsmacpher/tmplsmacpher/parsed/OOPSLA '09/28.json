{"article_publication_date": "10-25-2009", "fulltext": "\n Regrowing a Language Refactoring Tools Allow Programming Languages to Evolve Jeffrey L. Overbey Ralph \nE. Johnson Department of Computer Science University of Illinois at Urbana-Champaign 201 N. Goodwin Ave. \nMC 258 Urbana, IL 61801 {overbey2,johnson}@cs.uiuc.edu regrow (v. tr.): to grow (as a missing part) \nanew; (v. int.): to continue growth after interruption or injury Merriam-Webster s Online Dictionary, \n11/e Abstract Successful programming languages change as they age. They tend to become more complex, \nand eventually some features become outdated or are rarely used. Programming tools for these languages \nbecome more complex as well, since they have to support archaic features. Old programs are hard to maintain, \nsince these archaic features are un\u00adfamiliar to modern programmers. These problems can be solved by refactoring \ntools that can transform programs to use the modern form. We show that refactoring tools can ease the \ncost of program evolution by examining the evolu\u00adtion of two languages, Fortran and Java, and showing \nthat each change corresponds to an automatable refactoring. Categories and Subject Descriptors D.3.m \n[Programming Languages]: Miscellaneous General Terms Languages Keywords Fortran, Java, language design, \nlanguage evolu\u00adtion, refactoring, restructuring 1. Introduction Software designs evolve, and so do programming \nlanguages. The abstractions and models in a software system evolve as its requirements are better understood. \nSimilarly, the abstrac\u00adtions and constructs in a programming language evolve as the expressivity demands \nof its applications are better un\u00adderstood. Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. Copyright \nc &#38;#169; 2009 ACM 978-1-60558-734-9/09/10. . . $10.00 Over time, features are added to programming \nlanguages but rarely removed, for fear of breaking backward compat\u00adibility. This makes languages become \nincreasingly complex over time. Complexity makes languages more dif.cult for programmers to learn, and \nit makes programming tools more expensive to build. Eventually, some language features become outdated, \nand they should be removed from the language. But language designers have no strategy for doing this \nbesides warning developers many years ahead of time. We propose that automated refactoring tools be used \nto eliminate old constructs and idioms from source code. This would bene.t language designers by allowing \nthem to re\u00admove archaic constructs from languages more quickly than they do now. It would also bene.t \nmaintenance program\u00admers, who could avoid learning old versions of a language. Imagine a future in which \nrefactorings are an essential part of language design and refactoring tools are an essential part of \nlanguage implementation, on par with compilers. In such a world, languages could be designed with the \nexpec\u00adtation that end users would use refactoring tools to migrate their codebases from one version of \nthe language to the next. While this power would need to be used judiciously, it would help languages \nmaintain an elegant, coherent design over time. And it would not have to place an unreasonable burden \non end users. Several basic, almost fully-automatic refactor\u00adings could make minimal changes to appease \nthe compiler, removing outdated constructs and making other mandatory changes. These would be appropriate \nfor generated code and other black box components. A second set of refactorings would provide the capabilities \nnecessary to fully upgrade code to the newer version of a language. In some cases, these refactorings \nmight involve design-level changes, in which case more interactivity would be both necessary and desir\u00adable. \n This paper will describe the problems caused by language evolution, using Fortran and Java as examples \n(\u00a72). It will then describe automated refactoring (\u00a73) and discuss how, by forming a symbiotic relationship \nwith language design, it can help solve these problems (\u00a7\u00a74 5). The feasibility of this approach will \nbe supported by tracing the changes that have been made to Fortran and Java and enumerating the refactor\u00adings \nthat could have accompanied these changes (\u00a76). This will show that refactoring tools could have made \nthe evolu\u00adtion of both of these languages much less problematic. 2. On Language Evolution 2.1 How Languages \nEvolve FORTRAN I [Backus et al. 1956] emerged as the .rst suc\u00adcessful high-level language during the \nlate 1950s. Predating nearly every major development in computer science (and, in fact, predating the \nterm computer science [Janss 1999]), FORTRAN I now appears quaint, differing substantially from its modern \nincarnation, Fortran 2008, which re.ects the ben\u00ade.ts of half a century of accumulated experience. Since \nits inception, the Fortran language has been adapted to incorpo\u00adrate subprograms (FORTRAN 66), structured \nprogramming constructs (FORTRAN 77), modules and dynamic memory allocation (Fortran 90), object orientation \nand C language in\u00adteroperability (Fortran 2003), and co-arrays (Fortran 2008). Even the much-younger \nJava language has evolved from its initial release in 1996. Although most of the changes have been in \nthe library, the core language has been ex\u00adpanded as well, adding inner classes (JDK 1.1), strictfp (J2SE \n1.2), assert statements (J2SE 1.4), annotations, au\u00adtoboxing, enumerations, a new for loop, generics, \nimport static, and varargs methods (J2SE 5.0). Language evolution always comes at a cost. Introducing \nnew features adds complexity to the language. Deleting fea\u00adtures can make existing programs obsolete. \nIn the case of Fortran, the costs of evolution are largely due to its emphasis on backward compatibility. \nContinu\u00adously adding new features while retaining anachronistic al\u00adternatives has resulted in a complex \nlanguage that is effec\u00adtively splintered into several dialects. Any single piece of code will only use \na subset of the Fortran language, depend\u00ading on when the code was written and what experience the author \nhas. Fortran applications written when FORTRAN 66 was current will use .xed source form and goto statements, \nwhile more recent applications will use free source form and if statements. FORTRAN 77 programmers use \ncommon blocks, while Fortran 90 programmers will use module vari\u00adables. Among the latter, programmers \nwith more training in software engineering will be more inclined to encapsulate these variables, making \nthem private. It remains to be seen how the object-oriented facilities of Fortran 2003 will or will not \nbe used. The costs of evolution are different in Java. Being signif\u00adicantly younger, it has not had to \nendure philosophical shifts (like the disbarring of goto statements) that would render part of the language \nobsolete. But it has still increased sig\u00adni.cantly in complexity. Java s original design attempted to \nkeep the number of language features small, using idioms or libraries to express concepts when possible. \nUnfortunately, several things were awkward, inconvenient, or dif.cult to express in this way. For example, \nassertions could not easily be disabled in a production release, prompting the introduc\u00adtion of the assert \nstatement. Collections required clients to repeatedly downcast to the contained type, and iterating through \nthem used a fairly verbose idiom; these lead to the introduction of generics and the new-style for loop, \nrespec\u00adtively. As with Fortran, the addition of new features gave rise to different dialects of Java \nbeing used, depending on what version of the language was available at the time. For ex\u00adample, code written \nprior to the widespread availability of Java 5 will be littered with downcasts and Iterator instan\u00adtiations, \nwhereas code written later would use generics and new-style for loops instead. The rise of such temporal \ndialects is a necessary conse\u00adquence of language evolution. No one should be surprised that a Fortran \nprogram written in 1970 will use a different subset of the language than the same program written in \n2010. But these differences will only be exacerbated as the language continues to evolve. One can only \nimagine com\u00adparing Fortran programs from 1970 and 2070. But this is just a symptom of a larger problem, \nnamely, that code does not evolve with the language. This has been noted, for example, by J.M. Favre \n[Favre 2005], who ob\u00adserves that language evolution and language/program co\u00adevolution . . . are still \nneglected by the software engineering research community and presents an extensive argument for their \nstudy.  2.2 Languages Evolve, Code Stays Behind Programming language revisions turn up-to-date programs \ninto legacy code. This is a problem. Arguably, the most important consideration is what impact it has \non the day\u00adto-day programmer. Many programmers can safely ignore outdated parts of the language, concentrating \non the current dialect, or even a subset of that dialect. But the story is quite different for programmers \nforced to maintain others code: They must be .uent in whatever dialect the code s original author used. \nIn many cases, the programmer needs to be aware of old and new ways to accomplish the same task. Ideally, \nhe should understand why the new way is preferred. And, although it is not the job of the language or \ncompiler to force good programming style, failing to make outdated constructs (and idioms) obsolete can \nleave a programmer blissfully unaware that he is using a construct for which a better alternative exists. \nWhen code does not evolve with its language, maintain\u00ading backward compatibility means a language can \nbe ex\u00adpanded, but nothing can be removed. For both Fortran and Java, backward compatibility is paramount, \nand this is evi\u00addent in the way the languages evolved. Any Java 1.0 program will run on a Java 6 virtual \nmachine and (excepting minor changes like the addition of the assert keyword) will com\u00adpile using a Java \n6 compiler. The constraints caused by back\u00adward compatibility are more evident in Fortran 2008, which \nis, for the most part, a superset of its predecessors dating back to at least FORTRAN 77. The choice \nof language fea\u00adtures to delete in any given revision of the ISO Fortran stan\u00addard [Fortran 2003] is \nextremely conservative. Indeed, it is legal in Fortran 2003 to write an object-oriented program in a \nsource format designed for 80-column punch cards. Not recommended, but legal.  2.3 The Resulting Impasse \nThe inability to delete old language constructs (as in the case of Fortran) results in a language that \nis increasingly large and complex not by design but by default, since old features must be retained and \nevery new feature must co-exist with every old feature. This makes the learning curve steeper and maintenance \nmore dif.cult, but it also impacts programmers in a more subtle way: Retaining old language features \n(and increasing the complexity of the language) makes program\u00adming tools compilers, IDEs, static analysis \ntools, refac\u00adtoring tools, performance analysis tools, debuggers, etc. increasingly expensive to build. \nIn turn, this limits the num\u00adber of tools that will be made available to programmers. No company will \nbuild a tool unless it reasonably expects that it can recover its costs and eventually make a pro.t from \nit. Increasing the complexity of the language increases the time and cost of building tools, which lengthens \nthe pay\u00adback period the time it takes to recoup the initial cost of creating the tool and thus gives \nthe tool a lower return on investment compared to other projects. The lower ROI, com\u00adbined with the fact \nthat older languages (like Fortran) tend to become niche markets, renders the tool a less desirable investment. \nSo while a company that already produces a tool for Fortran 90 may be able to justify upgrading it to \nFor\u00adtran 2003 (since much of the complexity has been mitigated), it is far more dif.cult for a company \nto justify building a For\u00adtran 2003 tool from scratch. The most obvious non-solution to these problems \nis to freeze programming languages at some particular version and not allow them to evolve beyond that \npoint. Fortran has had more than enough opportunities to do this (its death has been imminent for several \ndecades now), and some people would argue that the same should be done for Java before it can be polluted \nwith, say, parallel programming constructs. Unfortunately, no programming language is eternally, uni\u00adversally \nperfect. Not even Lisp, although it may be close. Some defects in a language s design will not be found \nun\u00adtil it is widely used, and opinions about good programming language design will continually be in.uenced \nby advances in computer architecture, compilers, programming language theory, and software engineering. \nSuccessful software sys\u00adtems live lives much longer than their creators anticipated, and they are made \nto perform tasks that their creators never intended; suggesting that a programming language should be \nfrozen at a particular point in time tacitly denies that systems written in those languages will continue \nto evolve, adapting to new hardware, new programmers, and new requirements, and this evolution could \nbe ameliorated through changes to the language. Programmers will .nd (often kludgy) ways to make the \nfrozen language accommodate their needs. The counterargument is that these systems should be rewritten \nin a newer language; while this is perhaps justi.able on techni\u00adcal grounds, it ignores the tremendous \nintellectual and eco\u00adnomic investments that companies have in existing software and languages (and the \nrole of inertia in their selection). It appears that language evolution is a problem with no good solution. \nFailing to add new features will make the language stagnate. Adding new features without deleting old \nones results in an increasingly complex and dialect\u00adridden language. Deleting old features can break \nbackward compatibility. But there is one strategy that has the potential to allow languages to evolve \nwith fewer consequences. . . . 3. Enter Refactoring Refactoring [Opdyke 1992, Fowler 1999] is the process \nof making substantive changes to source code that do not have a net effect on the program s observed \nbehavior. For exam\u00adple, one might rename a variable or function, split a long subprogram into several \nsmaller subprograms, or convert an array of structures to a structure of arrays. Often, the intent is \nto allow the system s design to be changed retroactively so that unforeseen changes can be incorporated \nwithout com\u00adpromising the integrity of the design. Many common refactorings can be automated. Auto\u00admated \nrefactorings are included in many major IDEs, in\u00adcluding Eclipse JDT, IntelliJ IDEA, Microsoft Visual \nStudio, and Apple Xcode, among others. Photran [Photran, Overbey et al. 2005], ROSE [ROSE], and SPAG \n[SPAG] provide the same for Fortran. In an automated refactoring tool, the user provides some input, \nthe tool veri.es that the refactoring can be applied, and .nally the tool changes the user s source code. \nFor example, to rename a function, the user would se\u00adlect the function to rename and provide a new name \nfor the function; the tool would verify that the new name is legal and that it will not con.ict with \nan existing name, and .nally it would change the user s source code to re.ect the new name in the function \ndeclaration, interface declarations, and all call sites. Like most refactorings, this is a simple but \ntedious change to make manually. Refactoring Libraries Although refactoring has traditionally been applied \nto appli\u00adcations, recent research has suggested ways that it can also be applied to libraries, frameworks, \nand components.  Dig and Johnson [Dig and Johnson 2006] analyzed the evolution of several Java APIs, \nobserving that 80% of the API changes could be expressed as common, automated refactorings. They further \nsuggest that the refactorings used to change the library s API could be recorded as a script; the next \nversion of the library could ship with that script, which could then be executed on client code to upgrade \nit to the newer version of the library. For the 20% of changes that do not correspond to exist\u00ading refactorings, \nit is sometimes possible to develop library\u00adspeci.c refactorings. For example, Dig et al. [Dig et al. \n2009] implemented refactorings that migrate Java applica\u00adtions to use thread-safe collection classes \nthat will be pro\u00advided in Java 7, while Tansey and Tilevich [Tansey and Tile\u00advich 2008] provide refactorings \nthat migrate codebases from the JUnit 3 unit testing framework to JUnit 4. 4. Refactoring Languages Refactorings \nare used frequently to allow applications to change. They can be used to allow libraries to change. But \nthis idea should be taken a step further: Refactorings should allow languages themselves to change. Automated \nrefactor\u00ading tools can replace many outdated language constructs and idioms with their modern equivalents. \nIn other words, we want to make language evolution pain\u00adless. When a language standard changes, there \nshould be tools to convert from the old to the new version of the lan\u00adguage. Old programs will change \nto meet the new standard. Tool venders will not need to maintain versions of their tools for every version \nof the language. In a sense, refactoring languages is similar to the problem of refactoring libraries. \nLibraries provide a vocabulary, and they have both a syntax (inherited from the host language) and a \nsemantics, so they provide a language according to most de.nitions. And languages like Lisp and Smalltalk \nblur the distinction between library and language, so what would be considered a language change in Fortran \nwould be considered a library change in Smalltalk. Thus, much of what we propose applies equally to libraries. \nBut as we will see, refactoring the core of a language the constructs handled directly by the compiler \nis a different, and often more challenging, problem. 4.1 History The idea that tools could help source \ncode adapt to language changes .rst gained interest during the 1970s, motivated by the desire to convert \nprograms using goto statements into structured programs (an application which led to the coining of the \nterm restructuring) [Chikofsky and Cross II 1990]. Several systems provide this capability for Fortran \n(e.g., [SPAG, VAST]). This idea also appeared in PLATO [Jones 1973, Woolley], a time-sharing system developed \nat the University of Illi\u00adnois in the early 1960s. PLATO was designed for computer\u00adassisted instruction; \nPLATO IV (1972 1992) could support over a thousand simultaneous users and had over ten thou\u00adsand hours \nof courseware available. Most of the course\u00adware was developed in a language called TUTOR. TUTOR evolved \nas new features were added to PLATO. Part of the PLATO folklore is that changes to the TUTOR language \nwere often transparent to the programmers. PLATO did not have removable storage; all TUTOR programs were \nstored in a single .le system. Thus, when a new version of TUTOR was installed, it was possible to scan \nthe .le system and change every TUTOR problem to .t the new standard. All the TUTOR manuals were online, \nso they could be changed, too. Many programmers would not even notice the change, because they did most \nof their programming by copying old programs, and when they would look at an old program to see how to \nuse a particular feature, they would read the new version of that feature.  4.2 Interactivity: An Asset, \nNot a Liability Part I PLATO s upgrades, and the goto restructurers of the 1970s, were batch systems; \nthey attempted to automate the entire process. What makes refactoring tools particularly promis\u00ading is \nthat they are interactive. Clearly, it is bene.cial to auto\u00admate transformations as much as possible, \nand good defaults must be chosen when the user is asked to intervene. We will return to these ideas in \n\u00a75.1. But ultimately the ability to in\u00advolve the user can make the process much more satisfactory. There \nare three reasons why this is the case. First, as we will see in \u00a7\u00a76.1 6.2, some transformations are \nnecessarily heuristic, or ambiguous, or a completely con\u00adservative program analysis is not feasible. \nBy making such a tool interactive, the analyses do not have to be completely conservative, and often \nit is acceptable for the tool to make a guess at the appropriate transformation and ask the user to visually \ninspect the result or provide some input to further assist the tool. Similarly, there are some cases \nwhere a language change may result in design changes in the user s program. (Design, by de.nition, requires \ncreativity and domain knowledge, and thus cannot be automated.) One example would be the intro\u00adduction \nof modules in Fortran 90. While a tool could auto\u00admatically eliminate older-style (common) global variables \nby turning them into module variables, the user would likely want to move some subprograms into modules \nas well. A tool could guess which procedures these would be, but its decision could not rival that of \na domain expert. Finally, refactoring tools modify the user s source code, and the user maintains the \nrefactored code, so there are times when a user may want to intervene in order to in.uence the formatting, \nspacing, or comments in the refactored code issues that are uninteresting to tools but extremely impor\u00adtant \nto programmers.  5. Language/Refactoring Co-design Based on our experience implementing several refactoring \ntools [Opdyke and Johnson 1990, Roberts et al. 1997, Gar\u00adrido and Johnson 2003, Overbey et al. 2005] \nand previous successes in the area (e.g., [Kie.zun et al. 2007]), we believe that refactoring tools can \neliminate many outdated language constructs and idioms from programs. But our proposal is more ambitious \nthan that. We believe that such refactorings should play a key role in the language design process. Our \nvision is that refactoring tools will become an inte\u00adgral part of a language implementation, just as \ncompilers are now. Every developer will have access to a refactoring tool, and it will not be a luxury \nbut a necessity. When the language evolves and a new construct or idiom is introduced, it should be accompanied \nby a refactoring that replaces instances of the outdated construct or idiom. In other words, such refac\u00adtorings \nwould be developed proactively, alongside changes to the language, rather than as a reactive, best-effort \nattempt to upgrade codebases. The implementations of such refactorings would need to be robust, reliable, \nand reasonably fast in practice exactly what one expects of a compiler. Their availability would re\u00adduce \nthe impetus to retain outdated language features, be\u00adcause such a tool would allow older programs to \nbe updated almost for free. This, in turn, would allow programming languages to eliminate outdated features \nand idioms much more aggressively. Of course, this ability would need to be used with care. Becoming \n.uent in a new programming language is a sub\u00adstantial intellectual endeavor, and a succession of rapid, \nill\u00adconceived changes to a language could easily leave its end users frustrated. Similarly, language \nchanges affect program\u00adming tools as well compilers, IDEs, static analysis tools, etc. and so language \nchanges must still be carefully con\u00adsidered. (Practically, languages are not as malleable as soft\u00adware; \nthis is one reason why programming language design usually follows something resembling the Waterfall \nmodel.) Nevertheless, when changes are warranted, the ability to propagate them through all of the code \nimplemented using that language can be extremely powerful. Accepting automated refactoring as a natural \nand essen\u00adtial part of upgrading from one version of the language to the next can bene.t the language, \nits implementation, and its end users. When the refactorings are suf.ciently general, old constructs \nmay be eliminated from the language altogether, and they can be eliminated immediately upon the next \nre\u00adlease of the language. (Contrast this with current languages, where features are deprecated and then \nobsoleted over the course of many years, and most compilers retain them any\u00adway, making them a de facto \npart of the standard language, even if they are not part of any of.cial, published standard.) This means \nthose features can also be eliminated from the compiler, static analysis tools, IDEs, etc. This can simplify \nthe implementations of these tools, but it can also help the language design remain concise and cohesive. \nThis also ben\u00ade.ts the end users of the language, whose codebases will be upgraded to the current version \nof the language, eliminat\u00ading the need for new programmers to learn outdated dialects (and possibly helping \nexperienced programmers to un-learn them). 5.1 Interactivity: An Asset, Not a Liability Part II Of \ncourse, for upgrading a codebase to bene.t the end users, the perceived cost cannot be unreasonably high. \nAs dis\u00adcussed in \u00a74.2, interactivity is essential. But at the same time, an obsequious refactoring tool \nis more annoying than help\u00adful on a large system. There must be a way to control the amount of user input. \nRefactoring, by de.nition, is a technique for restructur\u00ading software which uses small-scale, behavior-preserving \nchanges to achieve larger, behavior-preserving changes in a system [Fowler 2004]. Refactoring does not \nimply that the system changes all at once. Rather, it implies that the system moves gradually, step-wise, \nfrom an initial design to a .nal design. This observation can be used to control the amount of interactivity \nin an evolutionary refactoring tool. Some parts of a system never change and are treated as black boxes. \nThese include mature components and generated code. Developers do not want to devote effort to redesigning \nthese; they simply want them to work. Other parts of a system are actively maintained, and developers \nwant very .ne-grained control over the code s appearance and the component s design. A successful evolutionary \nrefactoring tool must have two types of refactorings available. The .rst make very minimal changes, just \nenough to make the code compliant with the new language speci.ca\u00adtion. These address backwards-incompatible \nchanges, like the removal of language constructs and changes to type sys\u00adtems. Ideally, these should \nrequire little or no interactivity, allowing them to be applied painlessly to black box code, although \nmore interactivity may be optional for actively\u00admaintained code. After these have been applied, the remaining \nrefactorings can be used to fully upgrade actively-maintained code. Of\u00adten, these can be used to adjust \na system s design to com\u00adpensate for changes in the language. One example would be the elimination of \nold-style (common) global variables in Fortran. These can be converted into module variables by creating \na new module from each common block. How\u00adever, the resulting design is less than optimal. In actively\u00admaintained \ncode, the programmer would probably want to move some subprograms into the module as well, or he might \nwant to merge that module with another one with sim\u00adilar functionality. Another example is the conversion \nof pro\u00adcedural programs to object-oriented programs. This requires creativity and domain knowledge, so \none should not expect a make program object-oriented refactoring. In both of these cases, the old and \nnew constructs represent different styles of programming unstructured vs. structured, proce\u00addural vs. \nobject-oriented and the inadequacy of tools is due to the lack of a 1 1 correspondence between old and \nnew constructs.  That said, refactoring tools can still ease the process of eliminating these features \nfrom programs. For example, many of the steps in making a program object-oriented are algorithmic and \nare excellent candidates for implementation as refactorings, even though the entire process cannot be \nautomated.  5.2 Open World, Open Problems The language in PLATO could be upgraded at will because programs \nwere moderately sized, the changes were minor, and the system was closed in the sense that every PLATO \nprogram existed on the (one) PLATO system. In fact, the documentation and tutorials existed on that system \nand could be changed as well. Refactoring modern programming languages is more dif\u00ad.cult because they \nexist in an ecosystem which includes compilers, build tools, preprocessors, and code generators, among \nother things. This is where many research challenges in refactoring can be found. In the speci.c case \nof Fortran, widespread use of lan\u00adguage extensions and preprocessors make automated source code transformation \nmore dif.cult. Vendor-speci.c lan\u00adguage extensions are problematic because a tool cannot re\u00adliably transform \na programs containing constructs it does not understand. Refactoring a program containing C pre\u00adprocessor \ndirectives is complicated but tractable [Garrido 2005]; unfortunately, Fortran programmers do not just \nuse the C preprocessor. Some use M4. Some use M5. Some go even further: IBEAM [IBEAM] uses a custom prepro\u00adcessor \nwritten in Python to concatenate modules together, a makeshift attempt at inheritance. Plenty of make.les \nuse sed. Again, a refactoring tool cannot understand the parts of the program that are preprocessed into \nsomething else be\u00adfore the compiler sees them; there is no guarantee that it will analyze and transform \nthem correctly unless it is speci.cally programmed to do so. Is there a uniform way to handle a variety \nof preproces\u00adsors? Can a minimal set of refactorings be applied if the pre\u00adprocessor is treated as a \nblack box? Can refactoring tools learn to refactor language extensions? Can generated code be refactored \nwith user assistance once, and then the same refactoring be repeated, fully automatically, when the code \nis regenerated? Can a refactoring tool infer useful con.gu\u00adration information from build scripts? All \nof these are open problems whose solutions range from useful to essential in making refactoring-based \nlanguage evolution a possibility. 6. Feasibility If you look only at the language itself, and not the \nprogram\u00adming environment in which it is embedded, it is feasible to upgrade programs from an old version \nof a language to a newer version. We are going to show this by looking at two languages, Fortran and \nJava, examining how they have evolved and showing that the changes to these languages could have been \naccompanied by automated refactorings. 6.1 From FORTRAN to Fortran We will begin by considering refactorings \nthat could have expedited the removal of outdated features from the For\u00adtran language. This features \nconsidered include those that the ISO standardization committee has of.cially deprecated (e.g., .xed \nsource form) as well as some that are of.cially supported but whose use is discouraged in practice, either \nby culture (e.g., the use of keywords as identi.ers) or because a newer alternative exists (e.g., common \nblocks). Eliminate .xed source form. Fixed source form was orig\u00adinally designed for 80-column punch \ncards. The .rst six characters on a line have special meanings, columns 73 and beyond are effectively \na comment, actual code lies between columns 7 and 72, and whitespace can appear anywhere, even in the \nmiddle of a token. This is in con\u00adtrast to the newer free source form, which is more lex\u00adically similar \nto C or Java. Fixed-to-free form convert\u00aders already exist (e.g., [SPAG] and [VAST]), although it should \nbe noted that this conversion meets the de.ni\u00adtion of a refactoring, and Fortran refactoring tools contain \nall of the machinery needed to build a .xed-to-free form converter that maintains comments and formatting. \nFixed form is already an obsolescent feature in Fortran 95 and 2003 [Fortran 2003, \u00a7 B.2.6], indicating \nthe standardiza\u00adtion committee s intent to delete it in a future revision of the standard.  Reserve \nkeywords. Using keywords like if and while as variable names is generally considered poor practice, and \nfailing to reserve these words makes implementing For\u00adtran parsers dif.cult. Renaming identi.ers is a \ncanonical example of refactoring; building a tool to identify such names and change their names to non-keywords \ncould allow keywords to be reserved in a future revision of the standard. However, while a tool could \nauto-generate names (e.g., by adding a pre.x or suf.x), it could also bene.t from the interactivity of \nrefactoring by allowing the user to choose an entirely different name based on the application domain. \n Replace common blocks and block data subprograms with module variables. In the simplest version of \nthis transformation, each (named or unnamed) common block is replaced with a module containing a list \nof the same variables. The common statement (or include line) is re\u00admoved and replaced with a use statement \nfor the new module. Block data subprograms can be replaced with speci.cation statements and initializers \nin the new mod\u00adule. Subsequent refactorings could be used to encapsulate   these variables, if desired. \nAgain, user input is needed to generate meaningful names when a valid name cannot be inferred from the \ncommon block or include line. Require explicit interface blocks; eliminate external statements. Fortran \nallows external subprograms to be de\u00adclared using interface blocks, which specify the pa\u00adrameters and \nreturn type of the subprogram, or they may simply be listed by name in external declarations, in which \ncase the parameters and return type, if any, are unknown. In the latter case, the compiler cannot verify \nanything about the subprogram call not even that the number of parameters is correct so this is also \nconsid\u00adered poor practice, as it can lead to cryptic runtime errors. If the external subprograms are \nwritten in Fortran, it is straightforward for a tool to generate interface blocks for them and replace \nexternal statements with these; if they are written in another language (e.g., C), the refac\u00adtoring tool \nwould either need to (1) parse the C code and attempt to generate equivalent interface blocks, (2) in\u00adfer \ninterface blocks from the call sites in the Fortran program, or (3) punt and require the user to manually \ncode interface blocks.  Require explicit variable declarations; eliminate implicit typing and implicit \nstatements. This is also straight\u00adforward and is a refactoring already available in Photran. An implicit \nnone statement is added (potentially re\u00adplacing an existing implicit statement), followed by explicit \ntype declaration statements for all variables that were previously declared implicitly.  Remove other \nspeci.cation statements. Fortran allows most variable attributes including public, private, pointer, \ntarget, allocatable, intent, optional, save, dimension, parameter, and many C language\u00adbinding attributes \nto be included in a variable s type declaration statement, or they may be given in separate statements. \nArguably, spreading a variable s declaration across several statements is poor practice, since a pro\u00adgrammer \nmust read the entire list of speci.cation state\u00adments to determine all of the attributes assigned to \na vari\u00adable. Metcalf and Reid [Metcalf and Reid 1999, p. 243] note this in the particular case of the \ndimension at\u00adtribute: Omitting array dimension information from the type declaration statement makes \nit look like a decla\u00adration of a scalar. Replacing these speci.cation state\u00adments with equivalent clauses \nin a variable s type decla\u00adration statement (assuming implicit none) is straight\u00adforward. While user \ninput is not strictly necessary, many users would want to maintain some control over the order and formatting \nof the revised declarations.  Remove entry statements. The entry statement allows several entrypoints \nto be declared within a single sub\u00adprogram. The intent is to allow several procedures to share variables \nand/or code. A better practice is to cre\u00ad  ate a module and make each entrypoint into a module procedure \n[Metcalf and Reid 1999, p. 240]. This refac\u00adtoring is a somewhat more complicated variant of Ex\u00adtract \nMethod [Fowler 1999, p. 110], requiring an anal\u00adysis of what variables and what code is shared among \nen\u00adtrypoints, and potentially replacing goto statements with subprogram invocations. Remove computed \ngoto. The computed goto is equiva\u00adlent to a case construct [Metcalf and Reid 1999, p. 288]. A refactoring \ntool can always substitute a case construct containing goto statements for a computed goto.How\u00adever, \nit can also use a control .ow analysis to determine if the statements branched to can be moved into the \ncase construct, eliminating the goto statements entirely. More empirical work would be necessary to determine \nother id\u00adiomatic uses.  Remove arithmetic if, largely similar to removing com\u00adputed goto.  Remove character*n. \nThis form of a declaration for  character (string) variables is equivalent to character(len=n) and \ncan be removed through a simple syntactic substitu\u00adtion. Replace statement functions with internal functions. \nThis is a much simpler variant of the Extract Method refactor\u00ading.  Remove old-style do loops. These \nare entirely equiva\u00adlent to do constructs. If the loop is terminated with a continue statement, this \nstatement can be replaced with end do; if it is terminated with another executable state\u00adment, the end \ndo must be inserted after that statement. The statement label may be removed if it is not refer\u00adenced \nelsewhere.   6.2 From Java 1 to Java 6 Next, we will consider the language changes between Java 1 and \nJava 6. Java is different from Fortran because no lan\u00adguage constructs have been outdated. Rather, some \nidioms were outdated through the addition of new language con\u00adstructs. This eases demands on the refactoring \ntool, since no language construct is obsoleted and therefore the original code is still valid. The objective \nof refactoring is more stylis\u00adtic. At the same time, this can also make designing an effec\u00adtive refactoring \ndif.cult, since the exact patterns to match are necessarily heuristic and may vary from system to sys\u00adtem. \nIt can also increase the demands on the user. In some cases (e.g., introducing assertions), the user \nmay need to in\u00addicate what patterns to match. In others (e.g., introducing generics), the refactoring \ncannot be blindly applied across the entire codebase, and so the user must speci.cally decide where it \nis and is not warranted.  Introduce generics (parametric polymorphism). Of the new features introduced \nin J2SE 5.0, generics are by far the most complex, and it is not at all obvious that they can be introduced \nby a refactoring. Fortunately, the req\u00aduisite refactorings (Introduce Type Parameter and Infer Generic \nType Arguments) have already been studied in detail [Kie.zun et al. 2007, Tip 2007]. Some user input \nis still required; most importantly, the user must decide which variables were intended to have a generic \ntype.  Introduce new-style for loop. The new-style for loop  for (Something value : iterable) { ... \n } is syntactic sugar for the idiom Iterator<Something> it = iterable.iterator(); while (it.hasNext()) \n{ Something value = it.next(); ... } Replacing this idiom with the corresponding new-style for loop \ninvolves both matching the idiom syntactically and verifying that the iterator (it) is not accessed ex\u00adcept \nas shown. Unfortunately, not everyone uses this ex\u00adact idiom; the most dif.cult part of de.ning this \nrefac\u00adtoring is ensuring that it handles a suf.cient number of common variations. For example, the it \ndeclaration and while loop are often combined into an (old-style) for loop. It is also possible that \nit and/or value may be declared earlier; it may even be reused several times. The user may also insert \nother statements between those shown (e.g., between the iterator() invocation and the while loop), in \nwhich case a dependence analysis is nec\u00adessary to verify that the intervening statements do not in\u00ad.uence \nthe iterator s operation. The new-style for loop can also be used to iterate through arrays; a refactoring \nhas already been implemented in Eclipse which converts C-style array iterations into new-style for loops. \nThe pre\u00adconditions here are similar but somewhat more compli\u00adcated (e.g., the elements must be accessed \nfrom index 0 through length - 1, each iteration i must read only the element at index i, and the numeric \nindex i must not be used for any other purpose, such as updating the elements in the array). Convert \nto enumeration. Like the new-style for loop, enum declarations are syntactic sugar for a particular id\u00adiom \n( type-safe enumerations ) which can be mechani\u00adcally replaced. However, programmers also tend to use \ninteger constants to mimic a C enum, and so a useful refactoring would also need to allow the user to \ncon\u00advert these to Java 5 enumerations. In practice, this is of\u00adten used in tandem with refactorings like \nReplace Condi\u00adtional with Polymorphism [Fowler 1999, p. 255], which a tool might also provide. Again, \nthe choice between classes, constants, and enumerations is a design decision. Introduce autoboxing. \n\u00a7\u00a75.1.7 5.1.8 of the Java Lan\u00adguage Speci.cation, 3/e [Gosling et al. 2005] de.ne the contexts in which \nprimitive values are boxed and un\u00adboxed automatically. Since there are only two ways to box each primitive \n(for int values, these are the Integer class constructor and Integer#valueOf(int)) and one to unbox (Integer#intValue()), \nthe refactoring in\u00advolves matching these patterns and determining whether or not they occur in a context \nwhere the primitive would be auto-boxed/unboxed. It may be necessary to parenthe\u00adsize the replacement \nexpression to maintain the correct precedence and associativity. While this refactoring is straightforward, \nthe user must be aware that it may not preserve semantics if the code makes any assumptions about the \npointer-equality of boxed objects (cf. [Gosling et al. 2005, p. 87]). Although a tool could attempt to \ndetermine this (e.g., using a pointer analysis and check\u00ading for == and != comparisons), the analysis \nwould be expensive and very conservative, so the decision should ultimately be left to a user familiar \nwith the code.  Introduce static import. Java 5 s import static allows static members of another class \nto be accessed with\u00adout quali.ers. A canonical use is to reference constants like Math.PI or methods \nlike Math.cos() as simply PI and cos(). Sun recommends that this feature be used very sparingly, when \nthe programmer would otherwise be tempted to declare local copies of constants, or to abuse inheritance \n[Static Import]. As such, an automated refactoring to remove static quali.ers would similarly need to \nbe applied judiciously. A tool could detect some candidates (e.g., if a class uses several features from \nJava s Math class, or one feature repeatedly), but ulti\u00admately the user would need to decide when a static \nim\u00adport is warranted. The actual transformation is simple: ensure that the unquali.ed name will neither \nshadow nor be shadowed in the target namespace, add an import static statement, and then remove the static \nquali.ers from uses of the name.  Convert to varargs methods. Varargs methods are also syntactic sugar \nfor another idiom: passing an array as the last argument to a method in order to simulate a variable \nnumber of arguments. Like static imports, they should be used sparingly. Blindly replacing every possibile \noccur\u00adrence would be overzealous, since there are times when an array represents (for example) a vector \nor matrix, and a tool cannot tell the difference between these cases and those where a varargs transformation \nwould be appro\u00adpriate. Again, user input and domain knowledge are re\u00adquired.   Force strict .oating \npoint computations (strictfp). J2SE 1.2 changed the semantics of .oating point com\u00adputations in the Java \nvirtual machine, and the strictfp keyword was introduced to force the JVM to use the older .oating point \nbehavior. Determining when strictfp is necessary is a decision best left to the end user. Com\u00adpletely \npreserving the semantics of a Java 1.1 program on a J2SE 1.2 JVM would require an abundance of strictfp \nmodi.ers in the code; however, given how in\u00adfrequently strictfp actually appears in Java code, this is \nclearly one case where preserving semantics is often not desirable, since the new .oating point behavior \nis acceptable for most applications. Thus, a refactoring to introduce the strictfp keyword would be useful \nonly to the extent that it could provide a means for the user to quickly add the keyword to a large number \nof classes (or methods) at his discretion. Assertions. Assertions are different because there is no single \nidiom they were intended to replace. Prior to their introduction, each system had a proprietary idiom \nfor making assertions, often something like Assert.isTrue(expression); This is one case where a general, \nsyntactic .nd-and\u00adreplace is probably the best option, since both the syntax to replace and its replacement \nare system-dependent. Annotations. Annotations were a fundamentally new ad\u00addition to the Java language, \nproviding a facility that was not previously available, and so there is no widespread idiom that annotations \nwere intended to replace. How\u00adever, J2SE 5.0 also introduced three speci.c annotations (@Override, @Deprecated,and \n@SuppressWarnings) that could easily be inferred and introduced by a refac\u00adtoring tool. @Deprecated could \nbe inferred from the @deprecated JavaDoc tag. Suppressing compiler warn\u00adings would, of course, need to \nbe done at the discretion of the user. 7. Conclusions Our experiences implementing refactoring tools, \nand our observations about the evolution of Fortran and Java, support our belief that refactoring is \na viable technical strategy for language evolution. Why hasn t this happened already? There are many \ntech\u00adnical challenges, but perhaps the biggest obstacle is cultural. Only recently have refactoring tools \nbeen adopted widely in the Java and C# communities, and many programmers still have a dif.cult time trusting \na tool to rewrite parts of their source code. And perhaps they should; these tools are of\u00adten quite buggy \n[Daniel et al. 2007, Sch\u00a8afer et al. 2008]. Many Java programs are running business-critical applica\u00adtions. \nMany Fortran programs are in government labs, run\u00adning highly classi.ed simulations in strict security \nenviron\u00adments under heavy bureaucracies. For refactoring to become a vehicle for language evolution, \nrefactoring tools will need to enjoy the same robustness and trustworthiness that com\u00adpilers currently \ndo. These obstacles are also surmountable, but they will re\u00adquire the momentum of a community. Language \ndesigners should consider what can be removed using refactoring and what is possible when the constraints \nof backward compat\u00adibility are removed. Programmers should learn to use refac\u00adtorings, making them an \nessential part of their toolbox. Re\u00adsearchers and refactoring tool builders should focus on im\u00adproving \nthe reliability, scalability, and practical applicability of their tools. This change will require a \nsigni.cant effort, but it has great promise. We hope that others in the research community will agree, \nand the future will see a great number of languages evolving through refactoring. Onward! Envision the \nyear 2020. Java 11 has just been released. Mix\u00adins and parallel programming constructs have been added. \nThe instanceof operator is gone. The broken parts of the type system have been .xed. And the community \ndecided that import static wasn t such a great idea after all. The decision was made to upgrade your \nlatest project to Java 11, and you just downloaded the Java 11 Developer s Kit. But that consists of \nmore than a compiler and runtime: There is a tutorial on all the new features in Java 11, and there is \na Java 11 Upgrade Kit. When you open your IDE, the Upgrade Kit has plugged in a variety of Java 11 refactorings. \nYou run a basic, fully-automatic refactoring to make your system Java 11-compliant, which makes some \nchanges but also marks some portions of the changed code as potentially needing human assistance. Many \nof the changes are to a library that you purchased from another company. You .gure that you ll get a \nJava 11 version of the library before too long, so there is no reason for you to clean it up now. So \nyou focus on the parts of your own code that need to be improved. In some cases, the changed code is \ngood enough. In others, there are design improvements needed. Through a series of several more refactorings, \nyou are able to upgrade your code to a proper Java 11 design. In other places, you are able to improve \nyour code by taking advantage of Java 11 s new features. At the end of the day, you run the regression \ntest suite and check the upgraded code into version control. There are still parts of the code that ought \nto be cleaned up someday, but the parts of the program that you maintain from day to day are all in good \nshape. When you come into work the next day, you will be working exclusively on a Java 11 system. The \nlanguage evolved, and so did your system. Acknowledgments This work was supported by the United States \nDepartment of Energy under Contract No. DE-FG02-06ER25752 and is part of the Blue Waters sustained-petascale \ncomputing project, which is supported by the National Science Foun\u00addation (award number OCI 07-25070) \nand the state of Illi\u00adnois. Blue Waters is a joint effort of the University of Illinois at Urbana-Champaign, \nits National Center for Supercom\u00adputing Applications, IBM, and the Great Lakes Consortium for Petascale \nComputation. The authors would like to thank Paul Adamczyk, Baris\u00b8 Aktemur, John Brant, Nicholas Chen, \nDanny Dig, Isaac Dooley, Brian Foote, Munawar Ha.z, Binh Le, Darko Marinov, Daniel Overbey, and Maurice \nRabb for discussions that contributed to this paper, and Stas Negara who moderated our writers workshop \nand contributed to an earlier version of this paper submitted to the 2nd Inter\u00adnational Workshop on Software \nEngineering for Computa\u00adtional Science and Engineering [Overbey et al. 2009].  References J. Backus, \nR. Beeber, S. Best, R. Goldberg, H. Herrick, R. Hughes, L. Mitchell, R. Nelson, R. Nutt, D. Sayre, P. \nSheridan, H. Stern, and I. Ziller. Fortran Automatic Coding System for the IBM 704: Programmer s Reference \nManual. International Business Machines Corporation, New York, NY, 1956. E. Chikofsky and J. Cross II. \nReverse engineering and design recovery: A taxonomy. IEEE Software, 7(1):13 17, 1990. B. Daniel, D. \nDig, K. Garcia, and D. Marinov. Automated testing of refactoring engines. In Proc. ESEC-FSE 07, pages \n185 194, New York, NY, 2007. ACM. D. Dig and R. Johnson. How do APIs evolve? A story of refac\u00adtoring. \nJ. Software Maintenance and Evolution: Research and Practice, 18(2):83 107, 2006. D. Dig, J. Marrero, \nand M. Ernst. Refactoring sequential code for concurrency via concurrent libraries. In Proc. ICSE 09, \nWashington, DC, USA, 2009. IEEE Computer Society. J. Favre. Languages evolve too! Changing the software \ntime scale. In Proc. IWPSE 05, pages 33 44, Washington, DC, USA, 2005. IEEE Computer Society. M. Fowler. \nRefactoring: Improving the design of existing code. Addison-Wesley, Boston, MA, 1999. M. Fowler. MF \nBliki: RefactoringMalapropism. http:// martinfowler.com/bliki/RefactoringMalapropism.html, January 2004. \n A. Garrido. Program Refactoring in the Presence of Preproces\u00adsor Directives. PhD thesis, University \nof Illinois at Urbana-Champaign, Champaign, IL, 2005. A. Garrido and R. Johnson. Refactoring C with \nconditional compi\u00adlation. Proc. ASE 03. J. Gosling, B. Joy, G. Steele, and G. Bracha. The Java Language \n Speci.cation. Addison-Wesley, Boston, MA, 3/e, 2005. IBEAM. IBEAM. http://www.ibeam.org. Fortran 2003. \nISO/IEC 1539-1:2004: International standard: in\u00adformation technology, programming languages, Fortran.In\u00adternational \nOrganization for Standardization and International Electrotechnical Commission, Geneva, Switzerland, \n4/e, 2004. N. Janss. Professor Forsythe. http://infolab.stanford.edu/pub/voy/museum/pictures/display/ \n.oor1.htm, 1999. D. Jones. Run time support for the TUTOR language on a small computer system. Master \ns thesis, University of Illinois at Urbana-Champaign, Champaign, IL, 1973. A. Kie.zun, M. Ernst, F. Tip, \nand R. Fuhrer. Refactoring for pa\u00adrameterizing Java classes. In Proc. ICSE 07, pages 437 446, Washington, \nDC, USA, 2007. IEEE Computer Society. M. Metcalf and J. Reid. Fortran 90/95 Explained. Oxford Univer\u00adsity \nPress, 1999. W. Opdyke. Refactoring Object-Oriented Frameworks.PhD thesis, University of Illinois at \nUrbana-Champaign, Urbana-Champaign, IL, USA, 1992. W. Opdyke and R. Johnson. Refactoring: An aid in designing \napplication frameworks and evolving object-oriented systems. In Proc. SOOPPA. ACM, September 1990. J. \nOverbey, S. Xanthos, R. Johnson, and B. Foote. Refactorings for Fortran and high-performance computing. \nIn Proc. SE-HPCS 05, pages 37 39, New York, NY, USA, 2005. ACM. J. Overbey, S. Negara, and R. Johnson. \nRefactoring and the evolu\u00adtion of Fortran. In Proc. SECSE 09, pages 28 34, Washington, DC, USA, 2009. \nIEEE Computer Society. Photran. Photran -An Integrated Development Environment for Fortran. http://www.eclipse.org/photran/. \nD. Roberts, J. Brant, and R. Johnson. A refactoring tool for Smalltalk. Theor. Pract. Object Syst., 3(4):253 \n263, 1997. ROSE. ROSE. http://www.rosecompiler.org/. M. Sch\u00a8afer, T. Ekman, and O. de Moor. Sound and \nextensible renaming for Java. In Proc. OOPSLA 08, pages 277 294, New York, NY, USA, 2008. ACM. SPAG. \nSPAG. http://www.polyhedron.co.uk/spag0html. Static Import. Static Import. http://http://java.sun.com/j2se/1.5.0/ \ndocs/guide/language/static-import.html. W. Tansey and E. Tilevich. Annotation refactoring: Inferring \nup\u00adgrade transformations for legacy applications. SIGPLAN No\u00adtices, 43(10):295 312, 2008. F. Tip. Refactoring \nusing type constraints. In Proc. SAS 2007, volume 4634 of Lecture Notes in Computer Science, pages 1 \n17. Springer-Verlag Berlin Heidelberg, 2007. VAST. VAST/77to90. http://www.crescentbaysoftware.com/ vast \n77to90.html. D. Woolley. Plato: The emergence of online community. http:// thinko.t.com/plato/dwplato.htm. \n    \n\t\t\t", "proc_id": "1640089", "abstract": "<p>Successful programming languages change as they age. They tend to become more complex, and eventually some features become outdated or are rarely used. Programming tools for these languages become more complex as well, since they have to support archaic features. Old programs are hard to maintain, since these archaic features are unfamiliar to modern programmers. These problems can be solved by refactoring tools that can transform programs to use the modern form. We show that refactoring tools can ease the cost of program evolution by examining the evolution of two languages, Fortran and Java, and showing that each change corresponds to an automatable refactoring.</p>", "authors": [{"name": "Jeffrey L. Overbey", "author_profile_id": "81315491236", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P1728811", "email_address": "", "orcid_id": ""}, {"name": "Ralph E. Johnson", "author_profile_id": "81330492373", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P1728812", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640127", "year": "2009", "article_id": "1640127", "conference": "OOPSLA", "title": "Regrowing a language: refactoring tools allow programming languages to evolve", "url": "http://dl.acm.org/citation.cfm?id=1640127"}