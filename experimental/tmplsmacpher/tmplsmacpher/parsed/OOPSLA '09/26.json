{"article_publication_date": "10-25-2009", "fulltext": "\n Design Pattern Density Defined Dirk Riehle SAP Research, SAP Labs LLC 3412 Hillview Ave, 94304 Palo \nAlto, CA, U.S.A. +1 650 215 3459 dirk@riehle.org, www.riehle.org Abstract Design pattern density is \na metric that measures how much of an object-oriented design can be understood and represented as in\u00adstances \nof design patterns. Expert developers have long believed that a high design pattern density implies a \nhigh maturity of the design under inspection. This paper presents a quantifiable and observable definition \nof this metric. The metric is illustrated and qualitatively validated using four real-world case studies. \nWe present several hypotheses of the metric s meaning and their im\u00adplications, including the one about \ndesign maturity. We propose that the design pattern density of a maturing framework has a fixed point \nand we show that if software design patterns make learning frameworks easier, a framework s design pattern \ndensity is a measure of how much easier it will become. Categories and Subject Descriptors D.1.5: Object-oriented \nProgramming, D.2.8: Metrics Complex\u00adity Measures, D.2.11: Software Architectures Patterns. General \nTerms: Measurement, Design. Keywords: Design patterns, design pattern density, role model\u00ading, collaboration-based \ndesign, inheritance interface, object\u00adoriented framework, object-oriented design, framework maturity, \nJUnit, JHotDraw, object-oriented case study.  1 Introduction JUnit is a widely-adopted unit testing \nframework for Java, devel\u00adoped by Kent Beck and Erich Gamma. In the discussion of JUnit 3.8 s design, \nthe authors state: Notice how TestCase, the central abstraction in the framework, is involved in four \npatterns. Pictures of ma\u00adture object designs show this same pattern density . The star of the design \nhas a rich set of relationships with the supporting players. [1] This statement articulates the long-held \nbelief of expert software developers that mature frameworks consist of a higher than aver\u00adage number \nof design pattern instances, or, in short, exhibit a high design pattern density . However, this claim \nhas never been Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for profit or commercial \nadvantage and that copies bear this notice and the full citation on the first page. To copy otherwise, \nor republish, to post on servers or to redistribute to lists, requires prior specific permission and/or \na fee. OOPSLA 2009, October 25-29, 2009, Orlando, Florida, USA. Copyright &#38;#169; 2009 ACM 978-1-60558-734-9/09/10 \n$10.00. validated empirically nor has it been formalized to allow for such validation. The reason is \nsimple: It is difficult to define and meas\u00adure a metric like design pattern density as relevant case \nstudies are hard to come by and laborious to carry out one oneself. This paper presents a quantitative \ndefinition of design pattern density so that we can track its value in the evolution of a given framework. \nThe metric is applied to four case studies which are then interpreted based on the results. The paper \npresents multiple hypotheses using this metric, including the one about design ma\u00adturity, and discusses \nthese hypotheses using the instrument devel\u00adoped in this paper. This paper, however, does not validate \nthese hypotheses but rather leaves this to future work [34]. The paper presents an enhanced definition \nof collaboration-based design [2] a.k.a. role modeling [4] to define a quantitative meas\u00adure of functionality \nin a class model. Object collaborations are used as the atomic unit of functionality. This makes it easy \nto assess the number of design pattern instances in a given design. The calculation of a framework s \ndesign pattern density becomes the percentage of collaborations that are pattern instances. The contributions \nof this paper are: An enhanced definition of collaboration-based design that can cope with inheritance \ninterfaces;  A quantitative (and measurable) definition of a new metric called design pattern density \n;  A qualitative evaluation of the metric using four real-world case studies;  The discussion of multiple \nrelevant hypotheses about object\u00adoriented frameworks.  Again, the hypotheses themselves are not being \nvalidated in this paper. The main contribution of the paper is to be the first to pre\u00adcisely define the \nmetric, provide an instrument for assessing it, and illustrate its potential usefulness. Section 2 introduces \nthe enhanced version of collaboration-based design that is used in this work. Section 3 introduces the \ndesign pattern density metric and applies it to a running example. Section 4 presents three more case \nstudies. Section 5 presents multiple hypotheses that can now be defined more precisely than before and \ndiscusses conclusions that can be drawn from the metric, the case studies, and their data. Section 6 \ndiscusses the limitations of this work and addresses future work. Section 7 discusses related work and \nhow it addresses the issues presented in this paper. Sec\u00adtion 8 concludes the paper.  2 Patterns and \nCollaborations Section 3 defines design pattern density to be the percentage of a framework s functionality \nthat can be explained as design pat\u00adtern instances. For this, we need a measure of functionality on the \nlevel of granularity of design patterns so that we can represent and measure that functionality. We can \nthen determine which parts of a design are design pattern instances and which are not. This section defines \nthe notion of object collaboration as the atomic unit of functionality with which to measure the number \nof design pattern instances in a given framework.   2.1 Patterns and Granularity Software patterns \nvary greatly in their granularity (from architec\u00adtural styles through design patterns to programming \nidioms) as well as in what aspect of a design they address (object flexibility, concurrency, persistence, \netc.) Here, we focus on the level of granularity of the classic design patterns (hence design pattern \ndensity) [5] and we ignore aspects like concurrency and persis\u00adtence. Section 6 discusses the consequences \nof this limitation. The level of granularity addressed by the classic design patterns is the class and \nmethod level. This level is of a finer granularity than architectural styles like pipes and filters [6] \nand it is of a coarser granularity than programming idioms like how to write a for-loop in a given programming \nlanguage [7]. Thanks to the Design Pat\u00adterns book, this is the best investigated level of patterns. Most \npatterns (but not all) in the Design Patterns book are about object collaborations: How responsibilities \nare distributed across classes such that by configuring their instances a specific purpose can be achieved. \nBy admission of their authors [8] and as increas\u00adingly found in follow-up work, the notion of participant \nin many pattern descriptions is more accurately called a role, and the focus is on object collaboration \nrather than class structure. We have previously shown how to reinterpret the classic design patterns \nusing a collaboration-based approach [9] [10] [11]. However, not all design patterns are about object \ncollaborations; some are about the structural aspects of a design and how flexibil\u00adity is reached using \ninheritance (for example, Factory Method) or how behavior can be made pluggable (for example, Null Object). \nIn the next subsections, we present an enhanced version of col\u00adlaboration-based design that can be used \nto represent design pat\u00adterns even in such situations.  2.2 Collaboration-Based Design Collaboration-based \ndesign was born as role modeling [4]. It is related to (but independent of) the CRC (Class Responsibility \nCollaboration) card approach to design [3]. Collaboration-based design has made its way into UML where \nit is called collabora\u00adtions [12]. These modeling techniques vary significantly in their details and \nno single technique dominates collaboration-based design. The presentation here is based on [13] which \nin turn is based on [4] with its formalization in [32]. Table 1. Data from the collaboration-based design \nview of the JUnit 3.8 framework. Figure 3: Six collaborations in which the TestResult class is involved \nin. Collaboration name Number of Collaborations Number of Roles in Collaboration Number of Methods in \nCollaboration Is it a pattern? If so which? TestCase TestSuite TestSuiteTestCreation TestRun TestCaseTestRun \nTestSuiteTestRun TestHierarchy TestResult TestResultController TestResultObserver CollectingTestRun ProtectedTestRun \nTestRunMethod Assertions TestFailure AssertionFailedError ComparisonFailure ComparisonCompactor CompactMethod \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 3 3 2 3 2 3 2 2 2 2 2 2 2 4 4 4 1 2 1 13 9 2 7 4 2 \n4 38 6 2 3 2 6 ---Command --Composite Collecting Parameter -Observer Command Adapter Template Method \n----Strategy Composed Method Total 19 42 114 9  (1) TestResult collaboration \u00abinterface\u00bb TestResult::Client \n\u00abinterface\u00bb TestResult::Creator +TestResult() +addError(in test : Test, in t : Throwable) +addFailure(in \ntest : Test, in t : AssertionFailedError) +errorCount() : int +errors() : Enumeration +failureCount() \n: int +failures() : Enumeration +runCount() : int +wasSuccessful() : boolean \u00abinterface\u00bb TestResult::TestResult \n(2) TestResultController collaboration  (3) TestResultObserver collaboration  (4) CollectingTestRun \ncollaboration  (5) ProtectedTestRun collaboration +protect() \u00abinterface\u00bb ProtectedTestRun::Protectable \n+runBare() \u00abinterface\u00bb ProtectedTestRun::Target \u00abinterface\u00bb ProtectedTestRun::Client (6) TestFailure \ncollaboration   This paper uses the JUnit framework as a running example [33]. JUnit is a framework \nfor writing unit tests in Java. It is available in source code form. The framework has had significant \nindustry impact yet is small enough to make for a good case study. We use version 3.8, the last version \nfor which an official design discus\u00adsion by the authors is available [1]. We focus on the junit.frame\u00adwork \nclasses only. The discussion in this paper is based on our own method-by-method documentation of JUnit \n3.8 using col\u00adlaborations [14]. This paper uses the UML concept of interface to represent a role and \nthe UML concept of package to scope a collaboration (keep\u00ading its constituents, the roles, together). \nCompared with UML 2.x as well as our own definition [13] this is a simplification; how\u00adever, it helps \nfocus the paper and the metric definition. In collaboration-based design, objects play roles that define \nhow these objects collaborate to achieve exactly one well-defined pur\u00adpose. A role is scoped by its collaboration \nand it cannot see out\u00adside its boundaries. A role is a type that defines the behavior of an object within \na collaboration and a collaboration is a grouping of roles that defines how objects behind these roles \nare allowed to interact. For example, Figure 1 shows the TestResultObserver collabora\u00adtion from JUnit \n3.8. This collaboration defines how a TestResult object allows for registration and unregistration of \nTestListener objects interested in what s happening with the TestResult object. For that purpose, TestListener \nobjects provide callback methods that the TestResult object can invoke. It does so when a test run starts, \nwhen it ends, and when a failure occurs. This collaboration is an application of the Observer pattern, \nwhere the TestResult role represents the Subject participant and the TestListener role represents the \nObserver participant. An additional Configurator role handles the registration process. Earlier attempts \nviewed role modeling as a competitor to class\u00adbased approaches [4]. In contrast to this, we cast it as \nan extension of class-based modeling. In our definition, a class model like the JUnit framework can be \ndescribed by composing collaborations. The composition is carried out by assigning roles to classes and \nby defining how a class composes and implements the roles as\u00adsigned to it. The roles define the visible \nbehavior of instances of the class within a particular collaboration, and the class defines how its instances \nbring together the expected behavior in these different contexts as one integrated whole. Thus, the class \nview is complementary to the role view. The role view defines how an instance behaves in one particular \ncontext (collaboration) and the class view defines how state models and control flow is integrated between \nthe different collaborations. Basically, the class composes the roles to form the class [13]. The class \nTestResult in JUnit 3.8, for example, provides the Test\u00adResult::Testresult role. This denotes a role \ncalled TestResult that is part of a collaboration called TestResult. (Following UML, the collaboration \nis named first, followed by double colons, followed by the role name.) The collaboration name disambiguates \nthe role name by scoping it, so there can be several roles called TestRe\u00adsult. The role name, in this \ncase TestResult, is the same as the class name. This typically happens if the service provided by the \nrole is exactly the primary service associated with the class. In such a case, the collaboration represents \na domain-specific cli\u00adent/service collaboration. This double and triple use of the same name may at first \nappear confusing but works well within context. Other roles assigned to the TestResult class are the \nTestResult-Controller::TestResult role, the TestResultObserver::TestResult role, the TestFailure::Client \nrole, the CollectingTestRun::Com\u00admand role, and the ProtectedTestRun::Client role. One may won\u00adder again \nabout the frequent use of TestResult. For example, in the TestResultObserver collaboration, the TestResult \nrole repre\u00adsents the applied Subject participant of the Observer pattern, so why not call it Subject \nrather than TestResult? This is a decision left to the developer, and we follow the advice to be specific \n(TestResult) rather than generic (Subject). The TestResult class is shown in Figure 2, and its roles \nand their collaborations are shown in Figure 3. The class interface shown in Figure 2 is the sum of the \ndifferent methods defined by the roles in the participating collaborations. Please note that using UML \ninterfaces to represent a role doesn t imply that on the code-level any such interface exists. More often \nthan not, in JUnit the methods defined by roles are directly em\u00adbedded in a Java interface or Java class, \nas Figure 2 illustrates. Of the six collaborations that TestResult participates in, three are instances \nof design patterns: The TestResultObserver collabora\u00adtion is an instance of the Observer pattern, the \nCollectingTestRun is an instance of the Command pattern, and the ProtectedTestRun is an instance of the \n(Object) Adapter pattern. Table 1 shows the statistics of the junit.framework classes. It lists 19 collaborations \nthat were found when analyzing JUnit 3.8 s junit.framework classes (TestCase, TestSuite, TestSuiteCreation, \netc.) Of those, 9 collaborations were identified as instances of design patterns using the original authors \n[1] and our own judg\u00adment [14]. The table also lists the number of roles a collaboration offers: Typically \nit is two, sometimes three; atomic collaborations with more than three roles are rare. The number of \nmethods per collaboration is fairly evenly distributed from 1 to 9, with one anomaly, the Assertions \ncollaboration. The Assertions collabora\u00adtion provides the methods from the Assert class, which is using \na shopping list approach to interface design [15] to let developers express assertions about the program \nbeing tested.  2.3 Collaborations and Granularity Collaborations are design elements of the same granularity \nas the classic design patterns. They have two important properties: Well-defined collaborations are \northogonal to each other and can be composed easily;  Class models can be derived completely by composing \ncol\u00adlaborations; nothing falls between the cracks.  The JUnit 3.8 documentation using collaborations \naccounts for every single method in the framework and identifies it as part of a specific collaboration \n[14]. Any given collaboration has to serve one defined purpose. From this, an upper level of granularity \nfollows. (Composite collabora\u00adtions and patterns [11] are outside the scope of this paper.)  2.4 Collaborations \nand Inheritance Traditional and collaboration-based design typically focuses on the collaboration between \nobjects. Self-delegation, intra-object communication, and class inheritance structures have played little \nor no role. However, the inheritance interface that superclasses define as a contract of interaction \nwith their subclasses is also important. We need to extend the notion of collaboration-based design with \na way of specifying and using inheritance interfaces. Without such enhancement, we would not be able \nto completely capture white-box or gray-box frameworks like JUnit. The key insight is that one object \nmay play several roles within the same collaboration. For example, an object may be observing itself \nor it may be using some basic service using self-delegation. Hence, we can capture intra-object communication \nwith the same approach as inter-object communication: We simply define roles and collaborations as done \nbefore, but allow for role assignments to the same class, even if the same instance of that class may \nend up playing multiple roles. Then, a role in that collaboration can represent all or parts of the inheritance \ninterface. Template Method is an example. In this pattern, a superclass de\u00adfines a public method that \nspreads its work over multiple non\u00adpublic methods within the class. These other methods are part of the \nclass inheritance interface and are visible only to subclasses. Figure 4 shows an application of the \nTemplate Method pattern using a textual notation for collaborations. It defines three roles, two of which \nare assigned to the TestCase class. The public run-Bare method is a template method that makes use of \nprimitive methods that constitute parts of the class inheritance interface. The use of collaborations \nto define collaborations that are internal to class hierarchies is new to collaboration-based design. \nYet, it is critical to fully account for the functionality of a design. Without it, we would be ignoring \nhow class hierarchies work internally and would only be able to grasp the collaboration between sepa\u00adrate \nobjects. In short, the only frameworks we would be able to fully explain using collaborations would be \nblack-box frame\u00adworks. However, most frameworks are a mixture between black\u00adbox and white-box frameworks. \n 3 Design Pattern Density Using the instrument laid out in Section 2, we can now provide a quantitative \nand measurable definition of design pattern density: The design pattern density of an object-oriented \nframework is Table 2: Summary data from the JUnit 3.8 analysis. JUnit 3.8 Case Study Number of classes/interfaces \nNumber of collaborations Number of pattern instances Number of roles in total Ratio roles per class/interface \n11 19 9 42 3.8 Design pattern density 47% the percentage of its collaborations that are design pattern \nin\u00adstances. For example, as Table 1 shows, the core junit.framework classes are composed from 19 collaborations. \nOf these, 9 are instances of design patterns. Hence, as shown in Table 2, the design pattern density \nof JUnit 3.8 is 9/19 or 47%. The metric design pattern density is simple, precise, complete, and measurable. \nIt is simple and precise because only a basic calculation is needed. It is complete and measurable due \nto the completeness properties of the enhanced collaboration-based de\u00adsign method described in Section \n2. One advantage of this metric is that it has a simple comparison relation already built-in. With values \non a linear scale from 0 to 100%, comparing two density values becomes trivial. Interpreting the metric \nand a comparing two of its values is not trivial. What does it mean to say that the pattern density of \nJUnit 3.8 is 47% while the pattern density of JHotDraw 5.1 (a case study in Section 4) is 71%? Section \n5 discusses this further. In general, it is safe to assume that the pattern density of a frame\u00adwork will \nremain well below 100%, because in any given frame\u00adwork there will be at least one client/service collaboration \nwhose chief purpose is to provide a domain-specific service. In addition, we need to distinguish the \ndesign pattern density of a framework s interface architecture from the design pattern density of its \ncomplete design. The design pattern density of a framework s interface architec\u00adture is the percentage \nof those collaborations that are design pattern instances and that are defined in the framework s inter\u00adface \narchitecture. The design pattern density of a framework s complete design is the percentage of all collaborations \nin the framework s complete design, including both interface architecture and implementa\u00adtion structures. \nThe interface architecture of a framework defines its interfaces and interface classes and structures \ntheir core collaborations. If // collaboration definitionpublic collaboration TestRunMethod { free role \nClient { // no methods } role TemplateMethod {public void runBare() throws Throwable;} role PrimitiveMethods \n{ // role to class assignments public class TestCase provides TemplateMethod,PrimitiveMethods ...  \n Figure 4: A collaboration-based definition of the Template Method application in JUnit.  someone wants \nto understand how to use a framework, he or she typically turns to the interface architecture first. \nThe implementation architecture consists of the implementation classes and their class hierarchy and \nhow these classes implement the interface architecture. The implementation architecture be\u00adcomes relevant \nmostly if someone wants to extend the framework. It makes sense to measure both the design pattern density \nof the interface architecture and the complete design. The implementa\u00adtion cannot be understood without \nthe interface architecture, so we don t measure the density of the implementation structures only. Thus, \nwe distinguish between the design pattern density of the interface architecture and the complete design. \n  4 Case Studies In addition to JUnit, we used the metric and its underlying in\u00adstrument to gather data \nfrom three other frameworks. 1. The Geo system, a metalevel-architecture-based implementa\u00adtion of a distributed \nobject system [13]. 2. The KMU Desktop framework used to build tools in a finan\u00adcial risk assessment \napplication [13]. 3. The JHotDraw framework for building graphical editors [13]  [16] [17]. The Geo \nframework and the KMU Desktop framework are the result of a major revision and hence in their second \nrelease JHot-Draw had already undergone several major releases and was ana\u00adlyzed in version 5.1. 4.1 \nCase Study Data All case studies were documented using collaboration-based de- Table 3: Summary data \nfrom three case studies. Case study [1] [2] [3] Number of interfaces and interface classes 17 Number \nof collaborations 34 Number of pattern instances 20 Number of roles assigned to classes 75 Ratio roles \nper class/inter\u00adface 4.4 13 20 12 44 3.4 20 28 20 66 3.3 Design pattern density (interface architecture) \n59% 60% 71% [1] - The Geo framework [2] - The KMU Desktop framework [3] - The JHotDraw core framework \n sign. The referenced documentation provides the details on the collaborations, the class models, and \nhow the class models are composed from the collaborations. Table 3 shows summary data and the design \npattern densities from the three new case studies, excluding the JUnit case study. The three new case \nstudies were assessed on an interface architec\u00adture level, so the numbers given in Table 3 are interface \narchitec\u00adture design pattern densities. Table 4 summarizes the pattern densities and assigns a maturity \nlevel to each framework. The maturity level is a simple integer value 1-3, where 1 represents new , 2 \nmeans revised and 3 means mature . These values are based on this paper s author s assessment of the \nframeworks and are kept simple, because they can only give a qualitative maturity indication. These frameworks \nexhibit a high design pattern density.  4.2 Collaborations and Functionality The design pattern density \nmetric is based on collaborations. In terms of granularity, collaborations are between methods and use \ncases. Thus, collaborations can serve as a measure of functionality in a framework on a medium-granularity \nlevel: Collaborations are not as small as methods and not as coarse-grained as use cases. Moreover, how \nmany methods there are in a framework can de\u00adpend strongly on a developer s programming style. Use cases \non the other hand can vary drastically in terms of the actual function\u00adality they provide. Tables 2, \n3, and 4 and the documentation data show that collabo\u00adrations are of fairly even size. The number of \nroles per collabora\u00adtion is between 2 and 3 in the given frameworks, and the number of methods per role \nis between 2 and 4. The number of case stud\u00adies available is too small to measure the variance in these \nnum\u00adbers; however, it seems unlikely that they vary drastically. Thus, we have a strong indicator that \ncollaborations can serve as a more reliable measure of functionality in framework design than other approaches \nlike method count or use cases. Table 4: The maturity level, pattern density, roles per collaboration \ndata of the case studies. Case study Maturity Level (1-3) Design Pattern Density Number of roles per \ncollaboration Assessed on the interface architecture level Geo System 2 59% KMU Desktop 2 60% JHotDraw \n3 71% 2.21 2.20 2.36 Assessed on the complete design level JUnit 3 47% 2.21  We pick up this observation \nin Section 5 below where we frame it as the hypothesis that the design pattern density metric is a meas\u00adure \nof ease of learning a framework. While not explored further in this paper, this also shows that col\u00adlaborations \nmight be a good proxy for complexity and estimated effort in implementing a framework.  5 Hypotheses \nThe definition of the new metric design pattern density is sim\u00adple, precise, complete, and measurable. \nBut is it useful? To show that a metric is a reliable proxy of something, we need to develop a sufficiently \nlarge body of quantitative data and corre\u00adlate the metric with the property of interest, assuming that \nthis property is known for the case studies. This correlation can then be used to predict the property \nfor future case studies, assuming that it is easier to assess the metric than the property. The body \nof case studies presented in this paper is too small to derive statistically significant conclusions \nfrom it. As a conse\u00adquence, we can only use the metric, its underlying instrument, and the qualitative \nindicators from the case studies to discuss hypothe\u00adses of interest. This in itself is valuable if the \nhypotheses are new or can now be framed in more precise terms than before. This section looks at both \nold and new hypotheses that have be\u00adcome tractable for the first time. Previously, these hypotheses (so \nthey had been postulated) were unclear and not open to valida\u00adtion. We can frame them now in such a way \nthat we can validate (or invalidate) them in future work. 5.1 Framework Maturity The original motivation \nof this work came out of the expert opin\u00adion that a high design pattern density indicates a high maturity \nof a design. (This is our framing of the introducing quotation of Kent Beck and Erich Gamma). Hypothesis \n1: As a framework matures, the design pattern den\u00adsity of a framework increases. We equate age with maturity, \nso this can only be a statistical rela\u00adtionship, as it is (easily) imaginable that an aging framework \ns design pattern density drops temporarily through intermediate revisions. Given that the design pattern \ndensity will always stay below 100%, and given that a framework can t grow beyond any boundaries, we \ncan sharpen hypothesis 1: Hypothesis 2: As a framework matures, its design pattern den\u00adsity approaches \na fixed point value. This fixed point would be the design pattern density of the per\u00adfect design for \nthe framework at hand. We would expect (follow\u00ading Hypothesis 1) that the sequence of design pattern \ndensity values created by successive revisions of a framework approaches the fixed point from below. \nThis hypothesis isn t saying anything about a specific frame\u00adwork s fixed point for its design pattern \ndensity though. More\u00adover, the assumption is that this fixed point value varies from framework to framework. \nA corollary is that the fixed points of the design pattern densities of all conceivable frameworks follow \na probability distribution: Hypothesis 3: The fixed points of the design pattern densities of all possible \nframeworks form a random variable that follows a probability distribution. Here, the distinction between \nthe design pattern density of a framework s interface architecture and the design pattern density of \na complete design becomes important: Hypothesis 4: The distribution of the random variable design pattern \ndensity of a framework s interface architecture has a higher mean than the distribution of the random \nvariable de\u00adsign pattern density of a framework s complete design . This should be easy to see, since \nthe design pattern density of any interface architecture is generally higher than the design pattern \ndensity of a complete design. This is because most of a frame\u00adwork s flexibility is expressed in the \ninterface architecture. Add\u00ading implementation classes proportionally increases the number of non-design-pattern \ninstance collaborations in a framework over the number of pattern instances. For example, adding a new \nsub\u00adclass like Rectangle to the Figure abstraction in the JHotDraw framework for graphical editors does \nnot change the interface architecture. It does add, however, a client/service collaboration that lets \nclients make use of the specifics of Rectangle objects. It is the author s best guess that for the design \npattern densities of interface architectures the mean is likely to be at around 70% with a standard deviation \nof around 5%. It seems safe to assume that both densities are highly correlated: Hypothesis 5: The random \nvariable design pattern density of a framework s interface architecture is highly correlated with the \nrandom variable design pattern density of a framework s com\u00adplete design . For this reason most hypotheses \napply equally to both densities and there is usually no need to explicitly say which density we are talking \nabout. These hypotheses finally lead us to a precise formulation of the expert opinion quoted in the \nbeginning of this paper: Hypothesis 6: The difference between the design pattern density of a specific \nframework version and its fixed point is a measure of the framework s maturity. We suggest that if the \nvalue is far below the fixed point, the framework is still in its early stages. On the other hand, if \nthe value is higher than the fixed point, the framework may have been over-engineered. Over-engineering \ncan happen when developers learn about design patterns for the first time and apply them eve\u00adrywhere, \nappropriate or not. Hypothesis 6 is a precise framing of the original motivation of this paper and one \nthat can be validated. Once we determine the fixed point distribution through further case studies, we \nwill be able to measure how mature a given framework version is and can make decisions with more confidence \nthan before.  5.2 Ease of Learning Frameworks In Section 4, we discussed how collaborations can be used \nas a measure of functionality in a framework. As a consequence, the design pattern density of a framework \nmeasures how much of that framework s functionality can be captured as instances of design patterns. \n For example, in JUnit 3.8 s case, with a design pattern density of 47%, that very percentage of its \nfunctionality can be understood as design pattern instances. Assuming that design patterns make learning, \nusing, and docu\u00admenting frameworks easier, faster, and less error-prone, the de\u00adsign pattern density \nmetric also becomes a measure of how much easier, faster, etc. patterns make it for developers to work \nwith frameworks. Hypothesis 7: The closer a framework version s design pattern density is to its fixed \npoint, the easier on average the framework is to learn and use. For example, if consistent documentation \nof a framework using patterns is known to make learning a framework 50% faster with respect to those \nparts that are described using patterns, learning JUnit would be sped up by 23.5% (47% of its functionality \nis being learned at twice the speed over not using patterns). A key assumption is that patterns have \nbeen applied only where sensible, meaning the framework has not been over-engineered to artificially \ninflate its design pattern density. Thus, a framework s design pattern density may not only be a measure \nof the framework s maturity, but equally importantly, a measure of how much easier it will be for developers \nto learn the framework and put it to use.  6 Limitations and Future Work The work presented in this \npaper makes a number of assumptions that restrict the applicability of the metric and its underlying \nin\u00adstrument. This section discusses these assumptions as well as future work to follow this paper. In \nthis discussion, we need to distinguish the metric from the instrument from the case studies. 6.1 Definition \nof Metric It is a strength of the design pattern density metric that it is pre\u00adcise and explicit about \nwhat it is based on, namely collaborations. This is also its largest restriction, as there are patterns \nthat cannot be neatly captured using collaborations. Concurrency is one example. Synchronization patterns, \nwork distribution patterns, and different concurrency models can not be captured well using the instrument \npresented in this paper. The first question is whether they should be. Some of these pat\u00adterns are clearly \nnot on a design level, but rather on an architec\u00adture or programming level. More importantly though, \nit does not seem sensible to mix (largely) orthogonal design aspects into one metric. A better ap\u00adproach \nmight be to have a pattern density metric for each major type of aspect in a given system, and to define \nan overall design pattern density metric as a composite metric based on these dif\u00adferent aspect metrics. \nUnder this assumption, the design pattern density metric pre\u00adsented in this paper covers the aspect flexibility \n(by object composition and distribution of responsibilities between classes), while concurrency, persistence, \nand other aspects will be assessed using different metric definitions. This forms a base for future work, \nas it will be interesting to de\u00adfine aspect-specific patterns, a pattern density metric for these patterns, \nand instruments for assessing these densities in a given framework. Another issue is pattern granularity. \nWhat about those program\u00adming idioms that developers routinely apply? We argue that they are on a different \nlevel of abstraction and should be assessed in\u00addependently from a design level metric like design pattern \nden\u00adsity. A final restriction of this paper is that the metric definition fo\u00adcuses on frameworks rather \nthan the more general notion of class model. This choice was deliberate as the design pattern density \nmetric provides most of its value when applied to reusable code components like frameworks.  6.2 Application \nof Instrument The main instrument used in assessing the metric in a given framework is an enhanced method \nfor using collaboration-based design as presented in this paper. This instrument has the following two \nshortcomings with respect to assessing the design pattern metric: 1. Few developers actually use collaboration-based \ndesign, so any such documentation is after the fact; 2. The recognition of design patterns in a collaboration-based \ndocumentation may be subjective.  Shortcoming 1 about the limited use of collaboration-based design \nis a problem as it may be difficult to document a framework using collaborations after the fact. However, \nwe contend that as a framework matures, the different purposes why objects collabo\u00adrate become clearer, \nand the deconstruction of the framework into its constituting object collaborations will become easier. \nAn indicator of such a progress is the recognition of design pat\u00adterns itself: Since a pattern has one \nwell-defined purpose, recog\u00adnizing patterns goes lock-step with a collaboration-based decom\u00adposition \n(and reconstruction) of a framework. A more severe problem is the recognition of a pattern itself. One \nmight argue that if this is left to subjective opinion, anything goes, and an assessed metric s value \nis not worth much. (In par\u00adticular if commercial interests develop around this metric.) Most design pattern \ndescriptions are done in prose and remain ambiguous. While experts can generally determine which pattern \nhas been applied by looking at the context of the pattern and matching pattern intent with code, a machine \nmay remain con\u00adfused about whether it is looking at a Bridge, Strategy, or (Object) Adapter, if all it \nhas is the Structure Diagram from the Design Patterns book. This problem can only be alleviated through \nmore formal and precise definitions of what constitutes a (design) pattern. Gil and Maman s work on automated \nrecognition of micro-patterns is a step into the right direction [18]. However, their patterns are not \non a design level and extending it to that level seems difficult. Zdun and Avgeriou s work on primitives \nfor modeling design patterns has the advantage of being able to capture the many vari\u00adants in which patterns \ncan come, but their work has not yet been applied to automated recognition of design patterns [19]. \n To the extent that we make progress towards formalizing design patterns (without taking away their inherent \nvariability) we will be able to make progress towards automated calculation of the metric design pattern \ndensity.  6.3 Case Studies and Hypotheses The case studies discussed in this paper represent a non-trivial \namount of work. However, since they only provide four data points (design pattern densities), more are \nneeded to validate the hypotheses presented in Section 5. One type of studies that needs to be done are \nlongitudinal studies that track the design pattern density of a framework over its many versions. Using \nsuch studies, it should be possible to determine whether framework-specific fixed points of the design \npattern density metric exist, and how the metric approaches these fixed points. Another study that should \nbe done is one that determines the probability distribution of the fixed points of framework design pattern \ndensities. The underlying assumption is obviously that such fixed points exist. Further work should then \ninvestigate how the distribution relates to the fixed points of evolving frameworks. Also, the design \npattern density needs to be correlated with other properties of frameworks under investigation, most \nnotably ma\u00adturity, quality, and ease of learning. All of these studies represent non-trivial efforts. \nStill, they are necessary to validate the hypotheses presented in this work. Un\u00addertaking these studies \nseems worthwhile given the conjectured power of design pattern density in predicting such important qualities \nas framework maturity and ease of learning. Thanks to the open source movement, today we have sufficiently \nlarge quantities of materials at hand (frameworks in their many versions) which we can analyze so that \nthese studies have become feasible.  7 Related Work Related work falls mainly into three categories: \ndesign metrics, design patterns, and modeling techniques. Henderson-Seller s early work on object-oriented \nmetrics pro\u00advides a set of fundamental metrics useful in a wide variety of circumstances [20]. None of \nthose, however, are about design patterns and object-oriented frameworks. A 2003 survey by Purao and \nVaishnavi provides a collection of 375 different object\u00adoriented metrics [21]. Among those metrics is \nnot a single one that is about design patterns or object-oriented frameworks. One explanation for the \nlack of design pattern metrics is given by Stein et al. who argue that design-level metrics cannot be \nderived from the code and are therefore more difficult to handle [22]. Based on Etzkorn and Delugach \ns work on so-called semantic metrics (design-level metrics) [23] they show how to derive such metrics \nfrom design documentation. This work is related to the work presented in this paper as we also work off \ndesign documen\u00adtation. However, we derived this design documentation by analyz\u00ading the source code, so \nwe do not agree with the assumption that design and implementation are completely separate. Much of the \nwork on object-oriented metrics is geared towards aiding refactoring of object-oriented designs [24]. \nMetrics are used as quality measures to indicate how to improve a legacy system [25]. Design pattern \nmetrics, however, still have to enter this space. More work has been spent on formalizing and automatically \nrec\u00adognizing design patterns in existing code. Kramer and Prechelt provide one of the first implementations \nto automatically recog\u00adnize design patterns in code [26]. However, with just the Structure Diagram information \nfrom the Design Patterns book, pattern defi\u00adnitions remain ambiguous and experimental results suffer. \nGil and Maman therefore focus on micro-patterns, which are structural patterns that can be defined precisely \nand that can be found in code [18]. However, micro-patterns are still a level of abstraction below design \npatterns. Zdun and Avgeriou took a different approach by not focusing on comprehensive pattern specifications \nbut rather on the primitives that can be employed to specify patterns [19]. This approach has the advantage \nthat it can better cope with the breadth of variants that expert developers typically see in design pattern. \nIdeally, a combination of Gil/Maman s and Zdun/Avgeriou s work could lead to automated recognition of \ndesign patterns in code. Such work would benefit the metric assessment presented in this paper as it \nwould reduce some of the subjectivity in the process. Yet more work on detecting design patterns is available \n[36] [37] [38] [39]. The quality of the detection results depends as much on the quality of the chosen \npattern formalization as it depends on the actual detection algorithm. We see two potentially useful \nuse\u00adcases of such tools for assessing design pattern densities: The first approach creates high-quality \ndocumentation by keeping the hu\u00adman in the loop. Human experts decide on which pattern instance is at \nhand, supported by the tool s provision of an automatically generated candidate pool. The design pattern \nmetric of a frame\u00adwork assessed this way is likely to have high statistical signifi\u00adcance. The second \napproach creates low-quality documentation automatically, but plenty of it. This second use case may \nbe use\u00adful for establishing the overall design pattern density distribution of object-oriented frameworks. \nA core aspect of the work presented in this paper is collaboration\u00adbased design, the employed modeling \ntechnique to capture framework functionality and design pattern instances. Our en\u00adhanced version is based \non Reenskaug et al. s original work and related to CRC cards [4] [3]. Role modeling and collaboration-based \ndesign are not the only approaches to breaking up frameworks into smaller composable pieces. Other more \nrecent approaches are traits and fragments. A trait is a set of methods and their implementation that \ncan be composed with other traits to form a class [27]. Most of the work on traits, much like with the \nwork on subject-oriented program\u00adming [28] focuses on the difficulties encountered when compos\u00ading code. \nTraits are like roles but do not come with a notion of collaboration, which is essential in dealing with \ndesign patterns. Closer to collaborations is the work on fragments, which are de\u00adscriptions of code fragments \ntogether with the code and how they can be composed to form or add to a framework [29]. Like col\u00adlaborations, \nfragments can therefore be used to represent design pattern instances in framework design. As with traits \nand subject\u00adoriented programming, fragments are more concerned with data and code in a bottom-up fashion, \nwhile collaborations focus on meeting domain modeling problems and worry less about imple\u00admentation, \ncoming top-down.  In Section 6.1 we argue that the design pattern density metric presented in this paper \nis really only the most prominent member in a family of pattern density metrics. The family members are \ndefined by what aspect of the framework they address, be it flexi\u00adbility, concurrency, etc. The most \npromising attempt at modeling and implementing such aspects is aspect-oriented programming (AOP) [30]. \nAs Hannemann and Kiczales have shown, AOP can be used to implement design pattern instances in code [31]. \nDen\u00adier and Cointe's case study on JHotDraw shows that AOP can help capture design patterns; unfortunately, \nthey do not provide an explicit definition of design pattern density [35]. Given the comprehensiveness \nof aspect-oriented programming in comparison with other approaches, we view it as the most promis\u00ading \nimplementation technology for traditional object-oriented frameworks. As the CaesarJ programming language \nshows, ex\u00adtending AOP with new constructs lets us make collaborations explicit in a natural way [40]. \nMaking design patterns explicit is the next obvious step after this.  8 Conclusions This paper presents \na new metric called design pattern density. We investigate this metric because of common expert belief \nthat this metric can serve as a reliable proxy for the maturity of object\u00adoriented frameworks and can \naid decision making about whether to use a framework or not. The paper presents a novel extension of \ncollaboration-based de\u00adsign as the instrument to calculate the metric s value in a given framework. The \npaper makes the metric not only precise but also measurable for the first time. To do so, we show how \ncollabora\u00adtion-based design cannot only be used to capture inter-object col\u00adlaborations, but also how \nit can be extended to capture class in\u00adheritance interfaces. The metric and its instrument are applied \nto four case studies, followed by a discussion of their quantitative assessment. Based on the case studies \nand their discussion, seven hypotheses are presented about design pattern density, framework maturity, \nand ease of learning of frameworks. It is left to future work, however, to actually validate these hypotheses. \nKey hypotheses are that a framework s design pattern density has a fixed point and that the fixed pointfs \nof all conceivable frame\u00adworks form a random variable that follows a probability distribu\u00adtion. Thanks \nto the metric and its underlying instrument, these hypotheses have lost their vagueness and have become \ntractable in future studies. Acknowledgements I would like to thank Erich Gamma, Mario Lopes, James \nNoble, and Wolf Siberski for providing helpful comments and feedback for this paper.  References [1] \nKent Beck and Erich Gamma. JUnit: A Cook s Tour. Avail\u00adable from http://junit.sourceforge.net/doc/cookstour/cooks\u00adtour.htm \n[2] Rebecca Wirfs-Brock and Brian Wilkerson. Object-Oriented Design: A Responsibility-Driven Approach. \nIn Proceedings of the 1989 Conference on Object-Oriented Programming, Systems, Languages and Applications \n(OOPSLA 89). ACM Press, 1989: Pages 71-75. [3] Rebecca Wirks-Brock, Brian Wilkerson, and Lauren Wiener. \nDesigning Object-Oriented Software. Prentice Hall, 1990. [4] Trygve Reenskaug, Per Wold, and O.A. Lehne. \nWorking with Objects: The OOram Software Engineering Method. Prentice Hall, 1996. [5] Erich Gamma, Richard \nHelm, Ralph Johnson, and John Vlis\u00adsides. Design Patterns: Elements of Reusable Object-Oriented Software. \nAddison-Wesley, 1995. [6] David Garlan and Mary Shaw. An Introduction to Software Architecture. Prentice \nHall, 1994. [7] James O. Coplien. Advanced C++ Programming Styles and Idioms. Addison Wesley, 1991. [8] \nRalph Johnson, John Vlissides. Personal Email Communica\u00adtion, 2002. [9] Dirk Riehle. A Role-Based Design \nPattern Catalog of Atomic and Composite Patterns Structured by Pattern Purpose. Ubilab Technical Report \n97.1.1. Zurich: UBS AG, 1997. [10] Dirk Riehle, Roger Brudermann, Thomas Gross, and Kai-Uwe M\u00e4tzel. Pattern \nDensity and Role Modeling of an Ob\u00adject Transport Service. ACM Computing Surveys 32, 1es (March 2000): \nArticle No. 10. [11] Dirk Riehle. Composite Design Patterns. In Proceedings of the 1997 Conference on \nObject-Oriented Programming Sys\u00adtems, Languages and Applications (OOPSLA '97). ACM Press, 1997: Pages \n218-228. [12] The Object Management Group (OMG). UML 2.x Specifica\u00adtion. OMG, 2007. See http://www.uml.org. \n[13] Dirk Riehle. Framework Design: A Role Modeling Ap\u00adproach. Ph.D. Thesis, No. 13509. ETH Z\u00fcrich, 2000. \n[14] Dirk Riehle. JUnit 3.8 Documented Using Collaborations. In Software Engineering Notes Volume 33, \nIssue 2 (March 2008), Article No. 5. ACM Press, 2008. [15] Bertrand Meyer. Object-Oriented Software Construction. \nPrentice Hall, 1988. [16] Erich Gamma. Advanced Design with Java and Patterns. Tutorial held at the 1998 \nJAOO Conference. Available from http://www.riehle.org/blogs/research/2007/2007-01-03.html [17] Kent Beck \nand Erich Gamma. JHotDraw---Patterns Applied. Tutorial held at the 1997 Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications (OOP-SLA 97). ACM Press, 1997. [18] Joseph (Yossi) \nGil and Itay Maman. Micro Patterns in Java Code. In Proceedings of the 2005 Conference on Object-Oriented \nProgramming, Systems, Languages and Applica\u00adtions (OOPSLA 05). ACM Press, 2005: Pages 97-116.  [19] \nUwe Zdun and Paris Avgeriou. Modeling Architectural Patterns Using Architectural Primitives. In Proceedings \nof the 2005 Conference on Object-Oriented Programming, Sys\u00adtems, Languages, and Applications (OOPSLA \n05). ACM Press, 2005: Pages 133-146. [20] Brian Henderson-Sellers. Object-Oriented Metrics: Measures \nof Complexity. Prentice-Hall, 1995. [21] Sandeep Puraoand Vijay Vaishnavi. Product Metrics for Object-Oriented \nSystems. ACM Computing Surveys Vol. 35, No 2 (June 2003). ACM Press: Pages 191-221. [22] Cara Stein, \nLetha Etzkorn, and Dawn Utley. Computing Software Metrics from Design Documents. In Proceedings of the \n2004 ACM South East Conference (ACMSE 04). ACM Press, 2004: Pages 146-151. [23] Letha Etzkorn and H Delugach. \nTowards a Semantic Met\u00adrics Suite for Object-Oriented Design. In Proceedings of the 34th International \nConference on Technology of Object-Oriented Languages and Systems (TOOLS 2000). Pages: 71\u00ad 80. [24] Joshua \nKerievsky. Refactoring to Patterns. Addison-Wesley, 2005. [25] Serge Demeyer. St\u00e9phane Ducasse, and Oscar \nNierstrasz. Finding Refactorings via Change Metrics. In Proceedings of the 15th Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA 2000). ACM Press, 2000: Pages: 166-177. [26] \nChristian Kr\u00e4mer and Lutz Prechelt. Design Recovery by Automated Search for Structural Design Patterns \nin Object-Oriented Software. In Proceedings of the Working Confer\u00adence on Reverse Engineering. IEEE Press, \n1996: Pages 208\u00ad 215. [27] Nathanael Sch\u00e4rli, St\u00e9phane Ducasse, Oscar Nierstrasz and Andrew Black. Traits: \nComposable Units of Behavior. In Proceedings of the European Conference on Object-Oriented Programming \n(ECOOP 03). Springer Verlag, 2003: Pages 248-274. [28] Harold Ossher, Matthew Kaplan, William Harrison, \nAlexan\u00adder Katz and Vincent Kruskal. Subject-Oriented Composi\u00adtion Rules. In Proceedings of the 1995 \nConference on Ob\u00adject-Oriented Programming, Systems Languages and Appli\u00adcations. ACM Press, 1995: Pages: \n235-250. [29] George Fairbanks, David Garlan, and William Scherlis. De\u00adsign Fragments Make Using Frameworks \nEasier. In Pro\u00adceedings of the 2006 Conference on Object-Oriented Pro\u00adgramming, Systems Languages and \nApplications. ACM Press, 2006: Pages 75-88. [30] Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris \nMaeda, Cristina Lopes, Jean-Marc Loingtier, and John Irwin. Aspect-Oriented Programming. In Proceedings \nof the 1997 European Conference on Object-Oriented Programming (ECOOP 1997). Springer Verlag: Pages 220-242. \n[31] Jan Hannemann and Gregor Kiczales. Design Pattern Im\u00adplementation in Java and AspectJ. In Proceedings \nof the 2002 Conference on Object-Oriented Programming, Sys\u00adtems, Languages, and Applications (OOPSLA \n2002). ACM Press, 2002: Pages 161-173. [32] Egil Andersen. Conceptual Modeling of Objects: A Role Modeling \nApproach. Ph.D. Thesis, University of Oslo, 1997. [33] Kent Beck and Erich Gamma. Source code available \nfrom http://www.junit.org. [34] Dirk Riehle et al. Design Pattern Density Validated. In preparation. \n[35] Simon Denier and Pierre Cointe. Understanding Design Pattern Density with Aspects: A Case Study \nin JHotDraw us\u00ading AspectJ. In Proceedings of the 5th International Sympo\u00adsium on Software Composition \n(SC 2006). Springer Verlag, 2006. [36] Dirk Heuzeroth, Thomas Holl, Gustav H\u00f6gstr\u00f6m, and Welf L\u00f6we. \"Automatic \ndesign pattern detection.\" In Proceedings of the 11th IEEE International Workshop on In Program Comprehension, \n2003. IEEE Press, 2003. Page 94-103. [37] Rudolf Keller, Reinhard Schauer, Sebastian Robitaille, and \nPeter Page. \"Pattern-Based Reverse-Engineering of Design Components. In Proceedings of the 21st International \nCon\u00adference on Software Engineering (ICSE 1999). IEEE Press. Page 226-235. [38] Nikolaos Tsantalis, Alexander \nChatzigeorgiou, George Stephanides, and Spyros T. Halkidis, \"Design Pattern Detec\u00adtion Using Similarity \nScoring,\" IEEE Transactions on Soft\u00adware Engineering, vol. 32, no. 11 (November 2006). Page 896-909. \n[39] Zsolt Balanyi and Rudolf Ferenc, Mining Design Patterns from C++ Source Code. In Proceedings of \nthe 2003 Interna\u00adtional Conference on Software Maintenance (ICSM '03). IEEE Press, 2003. Page 305-314. \n[40] Ivica Aracic, Vaidas Gasiunas, Mira Mezini, and Klaus Os\u00adtermann. Overview of CaesarJ. Transactions \non Aspect-Oriented Software Development I (LNCS vol. 3880). Springer Verlag, 2006. Page 135-173.  \n\t\t\t", "proc_id": "1640089", "abstract": "<p><i>Design pattern density</i> is a metric that measures how much of an object-oriented design can be understood and represented as instances of design patterns. Expert developers have long believed that a high design pattern density implies a high maturity of the design under inspection. This paper presents a quantifiable and observable definition of this metric. The metric is illustrated and qualitatively validated using four real-world case studies. We present several hypotheses of the metric's meaning and their implications, including the one about design maturity. We propose that the design pattern density of a maturing framework has a fixed point and we show that if software design patterns make learning frameworks easier, a framework's design pattern density is a measure of how much easier it will become.</p>", "authors": [{"name": "Dirk Riehle", "author_profile_id": "81339524672", "affiliation": "SAP Labs LLC, Palo Alto, CA, USA", "person_id": "P1728809", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640125", "year": "2009", "article_id": "1640125", "conference": "OOPSLA", "title": "Design pattern density defined", "url": "http://dl.acm.org/citation.cfm?id=1640125"}