{"article_publication_date": "10-25-2009", "fulltext": "\n Flapjax: A Programming Language for Ajax Applications Leo A. Meyerovich University of California, Berkeley \nlmeyerov@eecs.berkeley.edu Arjun Guha Brown University arjun@cs.brown.edu Jacob Baskin Google jacob.baskin@gmail.com \nGregory H. Cooper Google ghcooper@gmail.com Michael Greenberg University of Pennsylvania mgree@seas.upenn.edu \nAleks Brom.eld Microsoft albrom.@microsoft.com Shriram Krishnamurthi Brown University sk@cs.brown.edu \n Abstract This paper presents Flapjax, a language designed for con\u00adtemporary Web applications. These \napplications communi\u00adcate with servers and have rich, interactive interfaces. Flap\u00adjax provides two key \nfeatures that simplify writing these ap\u00adplications. First, it provides event streams, a uniform abstrac\u00adtion \nfor communication within a program as well as with ex\u00adternal Web services. Second, the language itself \nis reactive: it automatically tracks data dependencies and propagates up\u00addates along those data.ows. \nThis allows developers to write reactive interfaces in a declarative and compositional style. Flapjax \nis built on top of JavaScript. It runs on unmodi.ed browsers and readily interoperates with existing \nJavaScript code. It is usable as either a programming language (that is compiled to JavaScript) or as \na JavaScript library, and is designed for both uses. This paper presents the language, its design decisions, \nand illustrative examples drawn from several working Flapjax applications. Categories and Subject Descriptors \nD.3.2 [Programming Languages]: Language Classi.cations Data-.ow languages General Terms Languages, Design \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n2009, October 25 29, 2009, Orlando, Florida, USA. Copyright c . 2009 ACM 978-1-60558-734-9/09/10. . . \n$10.00 Keywords JavaScript, Web Programming, Functional Re\u00adactive Programming 1. Introduction The advent \nof broadband has changed the structure of appli\u00adcation software. Increasingly, desktop applications are \nmi\u00adgrating to the Web. Programs that once made brief forays to the network now live there. The network \nservers they communicate with not only provide data but also store data, enabling networked persistence. \nSome applications, known as mashups, combine data from multiple sources. Often, ap\u00adplications process \nnot only static data but also continuous streams of information, such as RSS news feeds. This paper presents \nFlapjax, a programming language built with such applications in mind. We make three key arguments, which \nthis paper will substantiate: Event-driven reactivity is a natural programming model for Web applications. \n Consistency should be a linguistic primitive.  Uniformity is possible when treating both external \nevents (those from remote machines) and internal ones (those from local devices such as the mouse). Uniformity \nen\u00adables better abstractions and also reduces the number of concepts needed for reasoning and validation. \n  Rather than invent a language from fresh cloth, we chose to engineer Flapjax atop HTML and JavaScript \n(despite their warts). JavaScript offers three important bene.ts. First, it is found in all modern browsers, \nand has hence become a lin\u00adgua franca. Second, it rei.es the entire content of the cur\u00adrent Web page \ninto a single data structure called the Doc\u00adument Object Model (DOM), so that developers can nat\u00adurally \naddress and modify all aspects of the current page (including its visual style). Third, it provides a \nprimitive, XMLHttpRequest, that permits asynchronous communica\u00adtion (in the style called Ajax [17]) without \nreloading the current page. This enables background communication with servers so Web applications can \nprovide much of the reac\u00adtivity of desktop applications. As a result of building atop JavaScript and \nHTML, Flapjax applications do not require plugins or other browser modi.cations; they can reuse ex\u00adisting \nJavaScript libraries; and the language can build on the existing knowledge of Web developers. A formal \npresentation would hide the many pragmatic bene.ts and decisions in the design of Flapjax. We there\u00adfore \npresent it through a series of increasingly sophisticated examples, including uses and mashups of popular \nWeb ser\u00advices. These demonstrate how event streams, and automatic reaction to their changes, encourage \nseveral important soft\u00adware design principles including model-view clari.cation and policy-mechanism \nseparation. We outline the implemen\u00adtation technique and its pragmatic choices. Finally, we dis\u00adcuss \nthe use of the language in actual applications. Language or Library? We have repeatedly referred to Flapjax \nas a language, but with a little extra effort, Flapjax can be used as a JavaScript library. That means \nthe developer who does not want to add the Flapjax-to-JavaScript com\u00adpiler (section 3.3) to their toolchain \ncan include the Flapjax library and program purely in JavaScript itself; in fact, most Flapjax applications \nare actually written this way (section 4). This involves some overhead, as we discuss in section 3.3, \nbut we leave this decision in the hands of developers rather than making it for them.  2. Flapjax by \nExample We present Flapjax as a programming language through examples. They are necessarily short, but \nFlapjax is a living, breathing language! We invite the reader to view and run the demos on the language \nsite,1 read the documentation of the many primitives, and try out their own examples. 2.1 The Structure \nof JavaScript Programs Before we study Flapjax, let us consider a very simple JavaScript program. It \ndisplays the time elapsed since start\u00ading or clicking on a button (.gure 1, which elides some of the \nHTML scaffolding). The point of this program is to .ll in a value for the curTime element on the HTML \npage. Con\u00adsider the reasoning a developer must employ: 1. The value is ostensibly displayed by the second \nline of the function doEverySecond. 2. The value displayed is that of elapsedTime.  1 www.flapjax-lang.org \n var timerID = null; var elapsedTime = 0; function doEverySecond() { elapsedTime += 1; document.getElementById(\"curTime\") \n.innerHTML = elapsedTime; } function startTimer() { timerId = setInterval(\"doEverySecond()\", 1000); } \nfunction resetElapsed() { elapsedTime = 0; } <body onload=\"startTimer()\"> <input id=\"reset\" type=\"button\" \nvalue=\"Reset\" onclick=\"resetElapsed()\"/> <div id=\"curTime\"> </div> </body> Figure 1. Elapsed Time in \nJavaScript 3. elapsedTime is set in the previous line. 4. But this depends on the invocation of doEverySecond. \n 5. doEverySecond is passed inside a string parameter to setInterval inside startTimer. 6. startTimer \nis called by the onload handler...so it appears that s where the value comes from. 7. Is that it? No, \nthere s also the initialization of the variable elapsedTime at the top. 8. Oh wait: elapsedTime is also \nset within resetElapsed. 9. Does resetElapsed ever execute? Yes, it is invoked in the onclick.  Just \nto understand this tiny program, the developer needs to reason about timers, initialization, overlap, \ninterference, and the structure of callbacks. (We trust the reader spotted the semantic bug? See section \n2.2 for the answer.) The culprit here is not JavaScript, but the use of call\u00adbacks and their effect on \nprogram structure. Callbacks are invoked by a generic event loop (e.g., in the JavaScript run\u00adtime) which \nhas no knowledge of the application s logic, so it would be meaningless for a callback to compute and \nreturn a non-trivial value. The return type of a callback is therefore the equivalent of void. That immediately \nmeans developers can no longer use types to guide their reasoning. Furthermore, a void-typed function \nor method must have side-effects to be useful, so even local reasoning about a program s data depends \non global reasoning about the pro\u00adgram s control .ow, destroying encapsulation and abstrac\u00adtion. Indeed, \nMyers has forcefully made similar critiques of callbacks [25]. The problem of comprehension affects not \nonly humans but also tools. For example, static analysis and veri.cation engines must decipher a program \ns intent from a highly fragmented description, and must reconstruct its data.ow from a rat s nest of \nfragments of control. As previous work on model checking Web applications has shown [23], a more direct \nprogram structure is a great help in this regard. The asynchronous nature of Ajax applications further \ncompounds these problems. Because the primary composi\u00adtion operator is a side-effect, interleavings and \ninteractions become the developer s responsibility. The network does not guarantee message ordering; \ndeployment can further affect ordering (e.g., higher server loads, or users at a greater geo\u00adgraphic \ndistance from servers than developers). All the usual problems of concurrency manifest, without even \nthe small comfort of locking. Despite this, callbacks appear necessary to receive noti\u00ad.cation of events, \nand are charged with propagating them through the system to keep the data model up-to-date. In an Ajax \napplication, there are numerous sources of updates a program must process, such as: 1. initial data from \neach host 2. user actions (e.g., button clicks, mouse movements) 3. updates from a data stream 4. \nchanges to data made in another concurrent session 5. acknowledgments from servers (e.g., in response \nto a store request) 6. changes to the access-control policy  As a result, Ajax applications are agglomerations \nof call\u00adbacks with largely implicit control .ows. Some operations exacerbate this: for instance, XMLHttpRequest \nrequires a callback (onreadystatechange) that it invokes up to four times, providing the status in a \n.eld (not as a parameter to the callback).  2.2 The Flapjax Alternative Flapjax endows JavaScript with \na reactive semantics. In effect, if a developer de.nes y = f(x) and the value of x changes, the value \nof y is recomputed automatically. Concretely, Flapjax is JavaScript augmented with two new kinds of data. \nA behavior is like a variable it always has a value except that changes to its value propagate auto\u00admatically; \nan event stream is a potentially in.nite stream of discrete events whose new events trigger additional \ncompu\u00adtation [14, 28]. The propagation of updated behavior values and new events is the responsibility \nof the language. Figure 2 uses the same timer example to illustrate these concepts. The elapsed time \n(always has a value, but the value keeps changing) is best represented as a behavior, while clicks on \nthe reset button (may be clicked an arbitrary num\u00adber of times, but the developer cannot anticipate when \nit will be clicked next) is best represented as an event stream. timerB(1000) creates a behavior that \nupdates every second (i.e., 1000 milliseconds). The valueNow method extracts a snapshot of the behavior \ns value at the time it is invoked (i.e., it does not update automatically). $E de.nes an event stream, \n var nowB = timerB(1000); var startTm = nowB.valueNow(); var clickTmsB = $E(\"reset\", \"click\").snapshotE(nowB) \n .startsWith(startTm); var elapsedB = nowB -clickTmsB; insertValueB(elapsedB, \"curTime\", \"innerHTML\"); \n<body onload=\"loader()\"> <input id=\"reset\" type=\"button\" value=\"Reset\"/> <div id=\"curTime\"> </div> </body> \n Figure 2. Elapsed Time in Flapjax in this case one per click of the button named reset.The result is \na stream of DOM event objects. The snapshotE method transforms this into a stream of the value at the \ntime of clicking of the timer. startsWith converts the event stream into a behavior, initialized with \nstartTm.Fi\u00adnally, insertValueB inserts the value of its behavior into the DOM.(Appendix A recapitulates \nall Flapjax operations used in this paper.) Obviously, the Flapjax code may not appear any easier to \na .rst-time reader. What is salient is both what is and isn t present. What is present is the composition \nof expressions, even when they involve I/O. A button is no longer just an imperative object; rather, \n$E(\"reset\", \"click\") lets us treat it as a value that can be composed with and transformed by surrounding \nexpressions. What is absent is the callbacks: the developer simply expresses the dependencies between \nexpressions, and leaves it to the language to schedule up\u00addates.2 Thus, nowB updates every second, and \ntherefore so does elapsedB (which depends on nowB) and so does the value on the page (because elapsedB \nis inserted into it). It is instructive to return to the pure JavaScript version. The bug is that the \ntime displayed on-screen which we might think of as having to always represent the value of elapsedTime \n(i.e., a model-view relationship) is unde\u00ad.ned between when the user clicks on the Reset button and when \nthe timer next .res. This is because the program re\u00adsets elapsedTime but not does propagate it to the \nscreen. The error is subtle to detect during testing because it is a function of when in this interval \nthe user clicks on the but\u00adton. Put differently, the developer has incurred the burden of synchronizing \nthe on-screen value with the model of time, and even in such a simple program, it is possible to slip \nup. In contrast, the Flapjax developer has left maintenance of consistency to the language. In a sense, \nbehaviors should not surprise JavaScript de\u00advelopers. When a program makes a change to the JavaScript \nDOM, the update is automatically propagated to the screen without the need to notify the browser s renderer. \nIn other 2 The callbacks for the timer and the button are set up and managed by timerB and $E. Callback \nmanagement is discussed in section 3.5. words, the DOM already acts rather like a behavior! Flapjax \nthus asks why only the bottommost layer should provide this feature, and instead exposes to developers \nthe same function\u00adality previously reserved for a special case.  2.3 From Buttons to the Network (and \nBack) The example above shows that button clicks are event streams and clocks are behaviors. Flapjax \nmakes it possi\u00adble for developers to treat all the other components of Ajax programs in these terms. \nThe mouse s location is a behavior. A text box can be treated either as a behavior (its current content) \nor as an event stream (a stream of changes), de\u00adpending on which is more convenient. A server is simply \na function that consumes an event stream of requests and pro\u00adduces an event stream of responses. This \nview is slowly also being adopted by industry.3 As an illustration, consider a component that appears \nin many Web applications: a text buffer with auto-saving. (Many readers will recognize this from the \nmail composition buffer of Google Mail.) This is a component we reuse in several of our own applications \n(section 4). It is therefore instructive to consider its design and implementation. We will build the \nauto-save buffer incrementally to show how a developer might approach such a problem. At its simplest, \nthe developer wants to create a text box that saves every t seconds: function mkSaveBox(t) { var draftBox \n= // make a <textarea> setInterval(\"...XMLHttpRequest...\", t*1000); return draftBox; } In fact, however, \nthe buffer should also save whenever the user clicks the Save button. That means the function needs two \nparameters: function mkSaveBox(t, btn) { var draftBox = // make a <textarea> // save every t seconds \nor when btn clicks return draftBox; } Now it isn t quite as clear what to do: using setInterval, the \nsave callback will run every t seconds, but is that what we want? Should it auto-save every t seconds \nregardless of Save clicks, or only t seconds after the last Save? Irrespec\u00adtive, should it auto-save \neven if there are no changes? And then, if some user needs it to auto-save after every keystroke, this \nabstraction is useless. The problem is that the abstraction confuses mecha\u00adnism setting up timers, dispatching \nmessages, and so on with policy. Obtaining this separation is not straightforward in JavaScript and most \nlibraries fail to demonstrate it. 3 In September 2006, Opera 9 added support for their new standard on \nServer-Sent Events. Though we are critical of some details of their speci.\u00adcation, this push from a commercial \nvendor indicates that these ideas have the potential for broad support. In Flapjax, the event stream \nis an excellent representation of policy. Thus, we would write, function mkSaveBox(whenE) { var draftBox \n= // make a <textarea> // save every time there is an event on whenE return draftBox; } where whenE \nrepresents the policy. Armed with this abstrac\u00adtion, the concrete policy is entirely up to the developer \ns imagination; here are three simple examples: mkSaveBox(timerE(60000)) mkSaveBox($E(btn, \"click\")) mkSaveBox(mergeE(timerE(60000), \n$E(btn, \"click\"))) Respectively, these save every minute, every time the user clicks a button, or when \neither of these occurs. Now we complete the de.nition of mkSaveBox.First, we create the <textarea>: var \ndraftBox = TEXTAREA(); TEXTAREA creates a new <textarea> and exposes it as a behavior. Flapjax de.nes \nsimilar constructors for all the HTML elements. We now de.ne a simple function that identi.es the Web \nservice and marshals the text buffer s contents: function makeRequest(v) { return {url: \"/saveValue\", \nfields: {value: v}, request: \"post\"};} We use Flapjax s $B function to obtain a behavior car\u00adrying the \ncurrent value of draftBox.($B may be applied to any input element.) When a save event .res on whenE, \nwe snapshot the current value of draftBox and use makeRequest to wrap the draft into a request: var requestsE \n= whenE.snapshotE($B(draftBox)) .mapE(makeRequest); Given this event stream of requests we invoke the \nfunc\u00adtion getWebServiceObjectE, which consumes a stream of server requests and returns a stream of server \nresponses: var savedE = getWebServiceObjectE(requestsE); getWebServiceObjectE encapsulates both the call \nto XMLHttpRequest and its callback. When the callback is invoked to indicate that the response is ready, \nFlapjax .res an event carrying the response. Presentation The above provides a complete implementa\u00adtion \nof the auto-save functionality, using event streams to represent the policy. We can go further: in our \napplications, we have found it valuable for the abstraction to indicate when the buffer is out-of-sync \nwith the server (i.e., between edits and responses). We use a Cascading Style Sheet (CSS) annotation \nto alter the presentation by changing the editor s border: var changedE = $B(draftBox).changes(); styleE \n= mergeE(changedE.constantE(\"unsaved\"), savedE.constantE(\"saved\")); styleB = styleE.startsWith(\"saved\"); \ninsertValueB(styleB, draftBox, \"className\");} changes creates an event stream that .res each time the \nvalue of $B(draftBox) changes (i.e., on each keystroke). constantE transforms the keyboard events (which \nindi\u00adcate the buffer has changed) and the network responses (which indicate that the server has saved) \nto the strings \"unsaved\" and \"saved\" respectively. The merged event stream, styleE, propagates events \nfrom both its arguments. We use startsWith (seen earlier in .gure 2) to trans\u00adform the discrete event \nstream into a continuous behavior, styleB. The value carried by styleB, is the value of the last event, \nwhich is the current state of the auto-save buffer. We need to specify an initial value for styleB to \nhold before the .rst event .res. Initially, the (empty) buffer is effectively saved . This behavior is \ninserted into the DOM as the CSS className; CSS class entries for saved and unsaved will correspondingly \nalter the box s appearance.  2.4 Higher-Order Event Streams: Drag-and-Drop So far, we have seen event \nstreams of keystrokes and net\u00adwork requests. Flapjax events may, however, represent arbi\u00adtrary actions. \nIn particular, they can represent events much more complex than those exposed by the DOM. To illustrate \nthis, we build a drag-and-drop event abstraction. For simplicity, consider dragging and dropping a box: \n<div id=\"target\" style=\"position: absolute; border: 1px solid black\"> Drag this box </div> The DOM provides \nmouseup, mousedown and mousemove events for each element. A drag-and-drop operation begins with a mousedown, \nfollowed by a sequence of mousemoves, and ends with mouseup. We wish to de.ne a function that, given \nan element, produces an event stream of drags and a drop:4 dragE :: element -> EventStream (drag or drop) \nBoth drag and drop events are a record of three .elds. The .elds left and top are the mouse coordinates. \nThe third .eld, drag or drop, carries the element being manipulated. We begin with mousemove, which naturally \nleads to the creation of drag events: function dragE(elt) { 4 Throughout this paper, we specify each \nfunction s interface using a Haskell-like type annotation. Because JavaScript is a latently typed lan\u00adguage, \nthese should be regarded as comments, though they could be en\u00adforced by a static type checker; in Flapjax, \nthey are enforced using contracts (section 5). return $E(elt,\"mousemove\").mapE( function(mm) { return \n{ drag: elt, left: mm.clientX, top: mm.clientY };});} The function above is permanently stuck dragging. \nWe should start responding to mousemove events only after we register a mousedown event: return $E(elt,\"mousedown\").mapE( \nfunction(md) { return $E(elt,\"mousemove\").mapE( function(mm) { return { drag: elt, left: mm.clientX, \ntop: mm.clientY }})}); Above, the mousemove event stream is created only after an enclosing mousedown \nevent .res. In fact, each mousedown produces a new stream of mousemove events. This code appears to have \na runtime type error: it pro\u00adduces an event stream of event streams. Such higher-order event streams \nare in fact perfectly legal and semantically sound. The problem is that dragE ultimately needs the co\u00adordinates \nof the latest inner event stream (the latest drag se\u00adquence). To .atten higher-order streams, Flapjax \noffers the primitive: switchE :: EventStream (EventStream a) -> EventStream a switchE .res events from \nthe latest inner event stream. With switchE, we can easily .x our type error: var moveEE = $E(elt,\"mousedown\") \n.mapE(function(md) { ... as before ... return moveEE.switchE(); We have not accounted for drop events, \nwhich should turn off the stream of drag events. We thus map over the stream of mouseup events and return \na singleton drop event: var moveEE = ... as before ... var dropEE = $E(elt,\"mouseup\") .mapE(function(mu) \n{ return oneE({ drop: elt, left: mu.clientX, top: mu.clientY })}); We can combine these two event streams \nwith mergeE, which .res events from either of its arguments: return mergeE(moveEE,dropEE).switchE(); \nBecause switchE .res events from the latest inner event stream, when the mouse button is pressed, moveEE \nproduces an event stream of drags. This becomes the latest inner event stream, and switchE thus produces \na stream of drags. When the mouse button is released, dropEE produces a new event stream (oneE({ drop \n... }). When this new event stream arrives, switchE stops forwarding drag events from the previous event \nstream. It .res the single drop event and waits for more (in this case, we know there is just one drop \nevent). When the mouse button is pressed again, moveEE pro\u00adduces a new stream of drags that supersede \nthe earlier stream from dropEE. This abstraction therefore lets us drag the box repeatedly. Using Drag-and-Drop \nThe dragE function merely reports the position where the target is dragged and dropped. It does not, \nas one might expect, actually move the target. This omission is intentional. We can easily move the target \nwhen it is dragged: var posE = dragE(\"target\"); insertValueE(posE.mapE(function(p) {return p.left}), \n\"target\",\"style\",\"left\"); insertValueE(posE.mapE(function(p) {return p.top}), \"target\",\"style\",\"top\"); \nHowever, by separating the drag-and-drop event stream from the action of moving the element, we ve enabled \na variety of alternate actions. For example, the following action ignores the drag events and immediately \nmoves the target when it is dropped: insertValueE( posE.filterE(function(p) {return p.drop;}) .mapE(function(p) \n{ return p.left;}), \"target\",\"style\",\"left\"); In the next example, the target moves continuously but \nlags behind the mouse by 1 second: insertValueE( posE.delayE(1000) .mapE(function(p) {return p.left;}), \n\"target\",\"style\",\"left\"); Further possibilities include con.ning the drag area, abort\u00ading drag operations, \netc. Our example has omitted a start\u00addrag event, which opens up a range of new uses. The reader might \nwish to also compare our approach to that of Ar\u00adrowlets [22], which we discuss in section 6.  2.5 Compositional \nInterfaces: Building Filters We built drag-and-drop by combining event streams that were extracted from \na single DOM element. Flapjax also allows behaviors to be built from multiple, independently\u00adupdating \nsources. We will illustrate this with an example taken from Resume, an application we discuss in section \n4. Resume presents reviewers with a list of a job candidates. A large list is unusable without support \nfor .ltering and sorting. Figure 3 de.nes two possible .lters for selecting candidates: by sex and by \nscore. function pickSex() { var ui = SELECT( OPTION({ value: \"Female\" }, \"Female\"), OPTION({ value: \n\"Male\" }, \"Male\")); return { dom: ui, pred: function(person) { return person.sex == $B(ui); }};} function \npickScore() { var ui = INPUT({ type: \"text\", size: 5 }); return { dom: ui, pred: function(person) { \nreturn person.score == $B(ui); }};} Figure 3. Filters for Single Criteria function pickFilter(filters) \n{ var options = mapKeys(function(k, _) { return OPTION({ value: k }, k);}, filters); var sel = SELECT(options); \nvar subFilter = filters[$B(sel)](); return { dom: SPAN(sel, \" is \", subFilter.dom), pred: subFilter.pred \n};}; Figure 4. Selecting Filters Each function returns both the interface for the .lter and the predicate \nthat de.nes the .lter. The interface ele\u00adments are built using Flapjax s constructors, such as SELECT \nand INPUT, which construct behaviors (just like TEXTAREA in section 2.3). We can display these DOM behaviors \nwith insertDomB: var filterObj = pickScore(); insertDomB(filterObj.dom,\"filterDiv\"); We can use the predicate \nto .lter an array of candidates: var filteredCandidates = filter(filterObj.pred,candidates); Observe \nin pickScore that $B(ui) is a behavior dependent on the current score. The value of filteredCandidates \nthus updates automatically as the user changes their desired score. We can then map over the list of \ncandidates, transform\u00ading each candidate object to a string. The resulting strings can be inserted into \nthe DOM. Flapjax tracks these data de\u00adpendencies and automatically keeps them consistent. function modalFilter(subFilter) \n{ var button = A({ href: \"\" }, \"Update\"); var subPred = subFilter.pred; return { dom: DIV(subFilter.dom, \nbutton), pred: $E(button, \"click\") .snapshotE(subPred) .startsWith(subPred.valueNow()) };}; Figure 5. \nFilters with an Update Button Real systems may have many available .lters. If the user wants only one \nat any given time, displaying them all would clutter the screen. We might instead indicate the available \n.lters in a drop-down box, and show only the controls for the selected .lter. Figure 4 implements a .lter \nselector. It chooses between .lters of the form in .gure 3, where each .lter is an object with dom and \npred .elds (of the appropriate type). The result of pickFilter is also an object of the same type. The \nfunction is parameterized over a dictionary of avail\u00adable .lters; for example: basicFilters = { \"Sex\": \npickSex, \"Score\": pickScore }; var filterObj = pickFilter(basicFilters); We build the drop-down box (sel) \nby mapping over the names of the .lters (options); we elide mapKeys it maps a function over the key-value \npairs of an object. The pickFilter interface displays sel and the interface for the selected .lter (subFilter.dom). \nThe predicate for pickFilter is that of the selected .lter. When the user chooses a different .lter, \n$B(sel) up\u00addates, and so does subFilter.dom. Since the DOM de\u00adpends on subFilter.dom, Flapjax automatically \nremoves the interface of the old .lter and replaces it with that of the new one. The developer does not \nneed to engineer the DOM update. The .ltering predicate (subFilter.pred) updates similarly, changing \nany displayed results that depend on it. These .lters update the list immediately when the user makes \na selection in the .ltering GUI. An alternate, modal interface would not affect the list until an Update \nbutton is clicked. We can reuse our existing .ltering abstractions for modal .lters. To do so, we build \nthe interface by composing .lters, exactly as we did in .gure 4. When we re done, we apply modalFilter \n(.gure 5) to add an Update button: var filterObj = modalFilter(pickFilter(basicFilters)); As the user \nmakes selections in the .ltering interface, subPred continuously updates in modalFilter.How\u00adever, modalFilter \ns predicate is not the current value of // flickrSearchRequest :: String -> Request // Packages the \nsearch text into a Flickr API call. function flickrSearchRequest(req) { ... } // flickrSearchResponse \n:: Response -> Listof(Url) // Extracts URLs from a Flickr API response. function flickrSearchResponse(resp) \n{ ... } // makeImg :: Url -> Element function makeImg(url) { return IMG({ src: url }); } var queryE = \n$B(\"search\").changes().calmE(1000); var requestE = queryE.mapE(flickrSearchRequest); var responseE = \ngetForeignWebServiceObjectE(requestE) .mapE(flickrSearchResponse); var imgs = DIV(map(makeImg, responseE.startsWith([]))); \ninsertDomB(imgs, \"thumbs\"); Figure 6. Flickr Thumbnail Viewer subPred, but a snapshot of its value when \nUpdate was last clicked. As a result, we get a modal .ltering interface. By preserving the interface \nto a .lter at each level, we obtain a variety of substitutable components. For example, filterObj may \nbe any one of: filterObj = pickScore(); filterObj = pickSex(); filterObj = pickFilter( { \"Sex\": pickSex, \n\"Score\": pickScore }); filterObj = modalFilter(pickFilter( { \"Sex\": pickSex, \"Score\": pickScore })); \nRegardless of the de.nition of filterObj, the code to apply and display .lters does not need to change: \ninsertDomB(filterObj.dom, \"filterDiv\"); var filteredCandidates = filter(filterObj.pred, candidates); \n In Resume, we have even more general combinators such as the conjunction and disjunction of multiple \n.ltering options. Though it is unrelated to the notion of .ltering itself, this idea of bundling interface \nwith behavior is strongly reminis\u00adcent of Formlets [9], which we discuss in section 6. 2.6 Pipes (and \nTubes) for Web Services As Unix showed many decades ago, pipelines are good com\u00adponent connectors. The \ngetForeignWebServiceObjectE primitive extends this to the Web. Suppose, for instance, the developer wants \nto erect a pipeline from a text box to a Web service to the screen. Assuming the HTML document con\u00adtains \nan input box with id search and a presentation ele\u00adment with id thumbs, the program in .gure 6 extracts \neach // EventStream {data: a, loc: String } // -> EventStream {data: a, point: Point or false} function \nmakeGoogleGeocoderE(requestE) { var geocoder = new google.maps.ClientGeocoder(); var resultE = receiverE(); \n// primitive stream var callback = function(d) { return function(p) { resultE.sendEvent( { data: d, point: \np })}}; requestE.mapE(function(req) { geocoder.getLatLng(req.loc, callback(req.data));}); return resultE;}; \nFigure 7. Geocoder Service as Event Stream Transformer query typed into the search box, sends the query \nto the photo sharing site flickr.com, obtains a list of thumbnails, and displays them in the DOM. In \nthe de.nition of queryE, calmE builds a muted event stream for a given time period. By calming an event \nstream associated with a buffer s keystrokes for a second, the developer can keep the system from responding \nto every keystroke, waiting for a pause when the user is not typing. We use this method frequently to \nprovide smoother user interfaces.  2.7 Mashups: Composing Web Services If Web services expose themselves \nas consumers and pro\u00adducers of event streams, they naturally .t the Flapjax mold. However, many external \nWeb services are not designed this way. Some such as Twitter (www.twitter.com, which lets users broadcast \nshort messages called tweets) return re\u00adsponses containing JavaScript code that must be eval d to obtain \na local callback. Others, such as Google Maps (maps.google.com), supply extensive (callback-based) li\u00adbraries. \nHowever, with just a little effort, these callback\u00adbased APIs can be turned into event stream transformers \nthat .t naturally into Flapjax applications. We .rst show this adaptation, then use it to build a mashup \nof Twitter and Google Maps. Google Geocoder The Google Geocoder is a part of the Google Maps API. It \naccepts the name of a location (e.g., Providence, RI ) and, if it successfully interprets the name, returns \nits latitude and longitude. The lookup occurs asyn\u00adchronously on Google s servers, so it is unsurprising \nthat the Geocoder function uses a callback: getLatLng :: String * (Point -> void) -> void whose use tends \nto follow this template: var data = ... var callback = function(p) { ... }; getLatLng(data.location,callback); \n An application that uses getLatLng continuously needs to associate points returned in the callback \nwith data about the corresponding request; we can encapsulate in a closure: var callback = function(d) \n{ return function(p) { ... }}; getLatLng(data.location,callback(data)); We will package this pattern \ninto an event stream trans\u00adformer from strings to points, along with an arbitrary datum that is passed \nfrom each request to its associated result: EventStream { data: a, loc: String } -> EventStream { data: \na, point: Point } We can easily map over a stream of requests: function makeGoogleGeocoderE(requestE) \n{ var callback = ...; requestE.mapE(function(req) { getLatLng(req.loc,callback(req.data)); });} However, \nthe result is not available within the body of function(req) { ... }, so the event stream above does \nnot produce meaningful events. Since results arrive asyn\u00adchronously, they are conceptually a new event \nstream. The operation receiverE creates a primitive event stream with no sources, so it does not .re \nany events: var resultE = receiverE(); var callback = ...; requestsE.mapE(...); return resultE; However, \nwe can imperatively push an event to it using sendEvent. Since points are sent to the callback, the body \nof our callback becomes: resultE.sendEvent({ data: d, point: p }); The complete function is shown in \n.gure 7. It exposes it\u00adself as a pure Flapjax event transformer, completely hid\u00ading the internal callback. \nUsing this pattern, we can erect a similar reactive interface which can then be treated compositionally \nto any Web service with a callback-based API [20]. Twitter/Google Maps Mashup Now that we ve seen how \ncallback-based Web services can be turned into event stream transformers, we can combine Web services \ninto a mashup. Consider a simple mashup that takes Twitter s most recent public tweets and plots them \non a Google Map. This mashup operates in three steps: (1) Fetch the live feed of public tweets from Twitter. \nTweets are accompanied by the location (e.g., Providence, RI ) of their sender. (2) Using the Google \nMaps Geocoder API, transform these locations into latitudes and longitudes. (3) If the Geocoder recognizes \nthe location, plot the corresponding tweet on an embedded Google Map. Since we have a live feed, repeat \nforever. Figure 7 shows the code for the Geocoder event stream. We can similarly build a public tweet \nevent stream: var googleMap = new google.maps .Map2(document.getElementById(\"map\")); googleMap.setCenter( \nnew google.maps.LatLng(0, 0), 2); // Fetch the live feed of public tweets var tweetE = getTwitterPublicTweetsE(); \n// Transform locations into coordinates var pointsE = makeGoogleGeocoderE( tweetE.mapE(function(tweet) \n{ return { data: tweet.text, location: tweet.user.location };})); // Elide points the Geocoder did not \nrecognize makeMapOverlayE(googleMap, pointsE.filterE(function(x) { return x.point != false; })); Figure \n8. Mashup of Twitter and Google Maps Figure 9. Clicking on a Pin Displays Tweet getTwitterPublicTweetsE \n:: -> EventStream Tweet We are using Google Maps to plot points returned by the Geocoder. It thus suf.ces \nto build an event steam consumer: makeMapOverlayE :: GoogleMap * EventStream { data: String, point: Point \n} -> void In the interest of space, we elide the de.nitions of these functions. However, they are similar \nin length and in spirit to the Geocoder function. Figure 8 shows the code for our mashup (.gure 9 and \n.gure 10 show two instances of its execution). Aside from the initialization of the embedded map, the \nmashup is al\u00admost directly a transcription of strategy outlined in prose above. Furthermore, it employs \nreusable abstractions that other mashups can also share. 2.8 From Web Services to Persistent Objects \nWeb services are good abstractions for procedural and message-passing interfaces, such as for .nding \na list of movies playing on a particular evening. They do not, how\u00adever, directly model shared, mutable, \npersistent objects, such as a meeting in a group calendar. The Flapjax system pro\u00advides a custom persistent \nobject store to save such objects, and a client-side library to interface with it.5 The server maintains \nnotions of identity for users and ap\u00adplications (with standard authentication details). It presents each \napplication with a .lesystem-like tree, which develop\u00aders can also browse through a trusted Web interface. \nThe operation writePersistentObject associates an event stream with a location which is a path through \nthe tree while readPersistentObject re.ects the values stored at that location into a stream. Thus, referring \nto the draft-saver from section 2.3: writePersistentObject(draftBox.changes(), [\"draft\"]); saves drafts \nat the top-level .le \"draft\". In practice, an application will wrap writePersistentObject in an ab\u00adstraction. \nThis can be used to erect another policy-mechanism separation: writePersistentObject is a mechanism, \nbut various .lters can be applied to the event stream it consumes to perform, e.g., rate limiting. readPersistentObject \nre\u00adverses the direction of binding to re.ect persistent objects in the application, with extra parameters \nfor the initial value and polling rate. Access Control In keeping with the .lesystem analogy, every persistent \nobject is subject to an access-control policy. Naturally, this set of permissions can also change at \nany time. User interface elements that depend on the permissions should also update their appearance \nor behavior. The Flapjax primitive readPermissionsB produces a behavior representing the current permissions \nof a location in the persistent store. The application can use its value to drive the user interface. \nFor instance, if permsB is bound to the permission of a store location, INPUT({type: \"text\", disabled: \n!(permsB.has(\"WRITE\", true))}); 5 Flapjax applications do not have to use the object store. This is a \nproof-of\u00adconcept server. function EventStream(sources,update) { this.sources = sources; this.sinks = \n[ ]; // filled in by sources for (var i = 0; i < sources.length; i++) { this.sources[i].sinks.push(this); \n} this.update = update; } Figure 11. The Event Stream Constructor declaratively ties the disabling of \nthe input box with lack of write permission. Thus, the user interface will automatically update in step \nwith changing permissions.  3. Implementation The theory of Flapjax is rooted in signal processing: \nevents and behaviors are essentially signal-processing abstractions. The theoretical underpinnings of \nFlapjax can be found in Cooper s dissertation [10]. Here, we focus on the implemen\u00adtation strategy that \nenables the above programs to run. 3.1 The Evaluation Model The central idea behind Flapjax is push-driven \ndata.ow eval\u00aduation. Flapjax converts JavaScript programs into data.ow graphs. Data.ow graphs are mostly-acyclic \ndirected graphs from sources (clocks, user inputs, the network, etc.) to sinks (screen, network, etc.). \nWhen an event occurs at a source, Flapjax pushes its value through the graph. A graph node represents \na computation; when it receives an event, a,it ap\u00adplies a function f (representing the computation) to \na and may further propagate f(a) to its children. This push-based, demand-driven evaluation strategy \nis a good match for sys\u00adtems with many kinds of external stimuli that do not obey a single central clocking \nstrategy. We discuss other strategies in section 6.  3.2 Data.ow Graph Construction Though we have presented \nevent streams and behaviors as distinct entities, the astute reader will have guessed that they are almost \nduals of each other. Given a behavior, issuing an event whenever its value changes yields a corresponding \nevent stream. Given an event stream and an initial value, continuously yielding the most recent value \non the stream (and the initial value before the .rst event appears) gives a corresponding behavior. In \nFlapjax, nodes in the data.ow graphs are event streams while behaviors are derived objects. We describe \nthe construction of a data.ow graph of event streams below. To developers, an event stream is an abstract \ndata type that may only be manipulated with event stream combinators (e.g., mapE, calmE, etc). Internally, \nan event stream node is implemented as an object with three .elds: sources :: listof(EventStream) sinks \n:: listof(EventStream) update :: a -> (b or StopValue) // EventStream a * EventStream a -> EventStream \na function mergeE(src1,src2) { var update = function(a) { return a; } return new EventStream([src1,src2],update); \n} // (a -> b) * EventStream a -> EventStream b function mapE(f,src) { var update = f; return new EventStream([src],update); \n} // (a -> Bool) * EventStream a -> EventStream a function filterE(pred,src) { var update = function(a) \n{ if (pred(a)) { return a; } else { return StopValue; }}; return new EventStream([src],update); } // \nEventStream (EventStream a) -> EventStream a function switchE(srcE) { var outE = new EventStream([], \nfunction(a) { return a; }); var prevE = null; var inE = new EventStream([srcE], function(aE) { if (prevE) \n{ outE.sources.remove(prevE); prevE.sinks.remove(outE); } prevE = aE; outE.sources.push(aE); aE.sinks.push(outE); \nreturn StopValue; }); return outE; } Figure 12. Implementation of Event Stream Combinators sources \nand sinks specify a node s position in the graph. When a value (of type a) is pushed to a node, Flapjax \napplies the node s update function to the value. If update returns the StopValue sentinel, the value \ndoes not propagate further from the node. Otherwise the result, b, is propagated further by Flapjax s \nevaluator, as described in section 3.4. Consider mergeE, which builds a node that propagates all values \nfrom both its sources without transforming them: merged = mergeE(src1,src2) mergeE must build a new node \nby specifying the sources, sinks, and updater. The sources are the event streams src1 and src2. The update \nfunction propagates all values: function update(a) { return a; } Since Flapjax is push-driven, the node \nbound to merged must know the sinks to which it pushes values. However, we can defer specifying the sinks \nuntil merged is used as a source. To consistently follow this pattern, mergeE must set the node bound \nto merged as a sink for src1 and src2. We abstract this pattern into the EventStream constructor (.gure \n11), which only requires sources and update as ar\u00adguments. mergeE and other event stream combinators \n(.g\u00adure 12) are therefore pure JavaScript functions, and so are the update functions. This ensures that \nindividual expressions do not change their meaning relative to JavaScript, a prob\u00adlem that might ensue \nif we wrote a specialized interpreter to implement the data.ow evaluation strategy. Derived Behaviors \nA behavior in Flapjax is an extension of event streams. A behavior node maintains its current value, \nin addition to sources, sinks, and an update function. The initial current value is an additional parameter \nof the behavior constructor. The update function computes a new value n;if n is different from the current \nvalue it sets n as the current value and propagates to all sinks, otherwise it returns StopValue to prevent \nfurther propagation.  3.3 The Compiler We mentioned in section 1 that Flapjax can be viewed as a language \nor, with a little extra work, a library. Now we can explain precisely what this extra work is. The compiler \nconsumes .les containing HTML, JavaScript and Flapjax. Flapjax code is identi.ed by the <script type=\"text/flapjax\"> \ndirective. The compiler transforms Flapjax code into JavaScript and produces standard Web pages containing \njust HTML and JavaScript. It includes the Flapjax library and elaborates Flapjax source code to call \nlibrary functions as necessary. Flapjax source code has JavaScript s syntax, but the com\u00adpiler s elaboration \ngives it a reactive semantics. Further\u00admore, the compiler allows Flapjax and JavaScript code to seamlessly \ninteroperate. This strategy of transparent reac\u00adtivity [11] has great advantage for beginning users and \nin teaching contexts. We outline its main components below. Implicit Lifting The principal task of the \ncompiler is to automatically lift functions and operators to work over be\u00adhaviors. The compiler does \nso by transforming function ap\u00adplications to invocations of liftB. This allows us to write expressions \nsuch as timerB(1000) + 1 where JavaScript s + operator is applied to the timerB(1000) behavior. The compiler \ntransforms the expression above to code equivalent to: liftB(function(t) { return t + 1; }, timerB(1000)) \nThe function liftB creates a node in the data.ow graph with timerB(1000) as the source and function(t) \n{ return t+1 } as the update function. Without the compiler, such transformations must be per\u00adformed \nmanually. In practice, this appears to be less onerous than it sounds, as our experience suggests (section \n4). With\u00adout the compiler, the development cycle involves just editing code and refreshing the page in \nthe browser. The compiler introduces another step in the development cycle which may sometimes be inconvenient. \nJavaScript Interoperability The compiler enables Flapjax code to interoperate with raw JavaScript. Flapjax \nalready shares JavaScript s namespace, so either language can read\u00adily use identi.ers de.ned in the other. \nConsider Flapjax call\u00ading JavaScript functions. In the simplest case, if a JavaScript function is applied \nto behaviors, the compiler can lift the application. The JavaScript function is thus applied to the values \ncarried by the behaviors, rather than the behaviors themselves (which it presumably would not comprehend). \nWhenever a behavior changes, the function is reapplied. For example, suppose filter is de.nedinJavaScript: \n filter :: (a -> Bool) * listof(a) -> listof(a) and consider the following Flapjax code: var tock = filter(function(x) \n{ return (x % 2) == timerB(1000) % 2; }, [0,1]); filter expects a predicate and a list. The result of \ntock, however, is not a boolean, but a behavior carrying a boolean. The compiler thus wraps the predicate \nso that the current value of its result is extracted on application. Furthermore, when the result is \ninvalidated (as it is every second), filter is reapplied. As a result, tock is a behavior that alternates \nbetween [0] and [1]. In the other direction JavaScript calling Flapjax code the compiler performs no \ntransformations. There is no need to do so, since the natural way to invoke Flapjax from JavaScript is \nto treat it as a library with explicit calls to the event stream and behavior combinators. Inline Flapjax \nThe compiler provides one more conve\u00adnience that we have not yet discussed in this paper, called inline \nFlapjax. It recognizes the special matching tokens {! and !} 6 in any HTML context and treats the text \ncontained within as Flapjax code. This code is expected to evaluate to a behavior. The compiler inserts \nthe behavior into the docu\u00adment at that point without the need for additional code. For instance, given \nsome function validCC that validates a credit card number and these JavaScript declarations function \nvalidColor(valid) { return valid ? \"aqua\" : \"cyan\"; } var ccNumField = $B(\"ccNum\"); var ccNumValid = \nvalidCC(ccNumField); this inline Flapjax term 6 Pronounced curly-bang . <input id=\"name\" style={! { \nborderColor: validColor(ccNumValid)} !} disabled={! !ccNumValid !}/> creates an input element that is \nenabled or disabled depend\u00ading on the validity of the credit card number, and whose bor\u00adder color is \ncorrespondingly aqua or cyan. In particular, the JavaScript object { borderColor: ... } is automatically \nconverted into a CSS style speci.cation string. While inline expressions can become unwieldy in gen\u00aderal, \nwe .nd them especially useful for writing program ex\u00adpressions such as the validator above. In particular, \nwhen the validity of an element depends on several data, it is easier and clearer to express this as \na localized functional depen\u00addency rather than diffuse it into callbacks, which inverts the dependency \nstructure.  3.4 Propagation The recursive propagation model (which is implemented with trampolining \n[31], to prevent stack over.ow) requires additional explanation, particularly to prevent some undesir\u00adable \nbehavior. Consider the following expressions, where y is some numeric behavior: var a =y+0; var b =y+a; \nvar c =b+1; var d =c%2; We would expect b to always be twice y, c to be odd, d to be 1, and so on. Unfortunately, \nnothing in our description above guarantees this. The update from y may recompute b before it recomputes \na, which might trigger the subsequent recomputations, resulting in all the invariants above being invalidated. \nOf course, once the value of a updates, the invariants are restored. This temporary disruption is called \na glitch in signal-processing lingo. (There is another, subtle problem above: some nodes may be computed \nmore than once. Not only is this wasteful, this computation may be noticed in case the updater functions \nhave side-effects.) Fortunately, there is a simple solution: to use topological order. This prevents \nnodes from being evaluated before they should, and avoids repeated computation. To perform this, the \nnode data structure tracks its partial-order rank in the data.ow graph. The Flapjax evaluator calls nodes \nupdate functions (.gure 12) in topological order. Instead of propa\u00adgating values immediately, the evaluator \ninserts them into a priority queue in topological order. The only obstacle to topological ordering is \nthe presence of cycles in the graph. Cyclic dependencies without delays would, however, be ill-de.ned. \nFlapjax therefore expects that every cycle is broken by at least one delay (either the primitive delayE \nor a higher-level procedure, such as inte\u00adgration, that employs delays). This restores the delay-free \nsub-graph to a partial order.  3.5 Primitive Event Streams and Callbacks Flapjax programs do not directly \nuse callbacks, so the Flap\u00adjax library encapsulates callback management code. The simplest function that \nencapsulates a callback is $E,which encapsulates a DOM callback and exposes it as an event stream of \nDOM events. For example: var moveE = $E(document.body, \"mousemove\"); As we showed for the Geocoder (.gure \n7), we can use sendEvent to encapsulate the callback-based DOM API: function $E(elt, evt) { var stream \n= receiverE(); var callback = function(e) { stream.sendEvent(e); }; elt.addEventListener(evt, callback); \nreturn stream; } However, $E above never removes the callback. (It does not call the DOM function removeEventListener.) \nIf the event stream moveE becomes unreachable from the rest of the program, we may expect it to be garbage \ncollected. How\u00adever, addEventListener creates an internal reference from elt to callback. Therefore, \nas long as elt is reachable, the event stream .res in perpetuity. This scenario occurs when we have higher-order \nevent streams, such as the drag-and-drop example (section 2.4), where a new stream of mousemove events \nis created for each mousedown event. switchE makes the previous mousemove unreachable by the program, \nthough the element being dragged keeps a reference to the mousemove callback. Since the element is never \nremoved from the DOM, the previous mousemove callback is continually invoked. After a number of drag \noperations, the browser becomes noticeably slower. We solve this issue by adding an isDetached .eld to \nall event streams. If isDetached is set, the callback in $E removes itself, instead of propagating the \nevent: function $E(elt, evt) { var stream = receiverE(); var callback = function(e) { if (stream.isDetached) \n{ elt.removeEventListener(evt, callback); } else { stream.sendEvent(e); }}; elt.addEventListener(evt, \ncallback); return stream; } isDetached is initialized to false. In the de.nition of switchE (.gure 12), \nwe set prevE.isDetached = true when removing prevE from the data.ow graph. However, prevE may not itself \nbe a $E expression, so the isDetached .ag of its sources must be updated as well. For any event stream \nisDetached is set if all its sinks are detached. We compute this expression while propagating values \n(section 3.4).  3.6 Library Design The Flapjax library is unusual in that it serves both the compiler \n(as its runtime system) and developers using it directly. In both capacities it needs to be ef.cient; \nthe latter is unusual as most languages runtime systems are not directly used by developers. Here we \ndiscuss some design decisions that have proven important over several years of use. Functions versus \nObjects Flapjax encourages making Web applications more functional in style. This can, how\u00adever, lead \nto deeply nested function applications, which are syntactically alien to many JavaScript developers. \nWe have therefore found it convenient to make all the stan\u00addard functions available as methods in the \nBehavior and EventStream prototypes. This means that instead of var name = calmE(changes($B(\"name\")), \n300); developers can write var name = $B(\"name\").changes().calmE(300); which is arguably more readable \nthan standard functional notation, since the left-to-right order of operations corre\u00adsponds to the direction \nof data.ow. We do offer all these operations as standard functions also, so developers can use whichever \nstyle they favor. Lifting Constants The compiler inserts behavior combi\u00adnators automatically. To aid \ndevelopers who do not use the compiler, Flapjax s behavior combinators lift constant argu\u00adments to constant \nbehaviors; this does not require compiler support. For example, the type of timerB is timerB :: Behavior \nInt -> Behavior Int so that the interval may itself vary over time. Library users may, however, simply \nwrite timerB(1000). The function will treat 1000 as a constant behavior. Element Addressing The library \nincludes many DOM ma\u00adnipulation functions that consume HTML elements. There are many ways for JavaScript \nfunctions to acquire DOM ele\u00adments; one of the more common techniques is to give them a name (an id). \nAll functions that consume elements also accept strings that name elements. Reactive DOM Elements Developers \nmay be concerned about the cost of Flapjax s reactive element constructors. Perhaps hand-coding imperative \nDOM updates would be sig\u00adni.cantly faster? Indeed, a naive implementation of a constructor would rebuild \nthe entire element on any update. For example, DIV(timerB(1000)) might construct a new <div> every second. \nOur implemen\u00adtation updates changes in-place, so only one <div> is con\u00adstructed, but its text updates \nevery second. This strategy sig\u00adni.cantly ameliorates such ef.ciency concerns.  4. Evaluation All the \nFlapjax code above is real. Developers can run the Flapjax compiler on Flapjax code to generate pure \nJavaScript applications which can then be deployed. As a result, all these programs execute on stock \nbrowsers. Flapjax has been public since October 2006, and has been used by several third-parties (i.e., \nnon-authors) to build working applications: Data Grid The Data Grid application7 was developed by a commercial \nconsulting .rm based in London. They were able to successfully construct their application in the lan\u00adguage, \nand reported that it resulted in shorter code and a faster development cycle . They did identify places \nwhere the implementation could be faster, an issue we discuss in greater detail below. They found that \none fringe bene.t of using Flapjax was that it insulated developers from most of the cross-browser issues \n, which are con\u00adsiderable in JavaScript, due to notoriously poor standard\u00adization of Web technologies. \nInteractive Wiki Another group used Flapjax to build a Wiki system that updates on-the-.y. Their evaluation \nlargely concurred with that of the Data Grid develop\u00aders. They added that behaviors, while a convenient \nand intuitive abstraction, could cause a performance hit while initializing an application: the initial \nvalues are better de.ned statically with HTML when possible. (We con\u00adjecture that this is at least partially \ndue to the Flapjax im\u00adplementation s event-orientation, with behaviors treated as a derived type.) Thus, \nmuch of the computation in their Wiki system is done in terms of events. Network Monitor Another developer \nhas used Flapjax to construct a network monitoring client. A network of workstations each expose status \ninformation as a Web service; the monitor obtains this information as event streams and collates and \ncombines them to present indi\u00advidual and collective status information. In addition there are several \napplications that we have built ourselves. One example is TestFest, which enables stu\u00addents to separately \nupload their homework programs and test cases; each student s test is run against every other student \ns homework. This application has been used for two years at Brown and at another university. More signi.cantly, \nwe have written and deployed Resume (resume.cs.brown.edu) and Continue 2.0 (continue2. cs.brown.edu). \nResume is a program for managing the ap\u00adplication and review process for academic jobs; Continue is a \nconference paper manager. Though these sound similar, the two work.ows and hence applications are quite \ndif\u00adferent. Both applications are in daily use. Resume has been used for job searches for three years \nin multiple academic 7 http://www.untyped.com/untyping/2007/01/19/ flapjax-in-action/ departments, and \nhas been solicited by others who noticed it while submitting letters. Continue has been used by over \ntwenty-.ve workshops and conferences. Both applications use Flapjax as a library; they feature fewer \nthan 10 lifts per KLOC, suggesting that eschew\u00ading the compiler to use the library directly is not a \nmajor impediment. With event-streams and reactivity, it was easy to reproduce and cleanly encapsulate \nthe kinds of features users are accustomed to seeing in commercial applications. For instance, the auto-save \nbuffer example of section 2.3 is inspired by that of Google Mail; in our applications, it is used to \nsave reviews and comments. Searching also reacts to keystrokes without the need for a Search button, \njust as in ap\u00adplications like iTunes. We also use reactivity to (judiciously) affect styling to notify \nusers of unsaved data. Performance It is impossible to measure the perfor\u00admance of a language; we can \nonly measure the perfor\u00admance of individual programs. The problem is exacerbated when programs are highly \ninteractive, because performance is equally a function of the nature of inputs used to drive applications. \nIt is, nevertheless, worth asking what impact the Flapjax abstractions have on program performance. We \nanswer this question at several levels. At the highest level, we argue that Flapjax simply auto\u00admates \nmuch of the work that a JavaScript developer would have done by hand: to propagate values through computa\u00adtions \nand keep them consistent. A developer can certainly use the full force of human knowledge to short-circuit \nsome evaluation; however, these same attempts often produce in\u00adconsistent or erroneous Web applications \nin practice. The most signi.cant cost in Flapjax is from scheduling in the data.ow graph. This breaks \nwhat might have been one large call-by-value evaluation into several small call-by\u00advalue fragments interspersed \nby data.ow graph manipula\u00adtion and traversal. We have used several (sound) heuristics to eliminate constants \nand to compact chains of nodes into single nodes, inspired by the lowering work of Burchett, et al. [4]. \nBecause these have yielded reasonable performance we have not investigated this topic further, but there \nis con\u00adsiderable opportunity for performance improvement. Qual\u00aditatively, we have used Flapjax to develop \nseveral anima\u00adtions and games. Flapjax smoothly renders these programs. In addition, Resume and Continue \nhave full-featured GUIs built entirely in Flapjax. These systems have been tested and used successfully \nwith hundreds of records displayed on screen. Recent advances in the performance of commercial JavaScript \nevaluators have made the runtime cost of data.ow evaluation negligible. While data.ow evaluation might \nslow down programs, it also has the potential to speed them up through parallel exe\u00adcution. One of the \nmajor obstacles to parallelism is the use of unfettered, dependency-creating side-effects; these are \npre\u00adcisely what good Flapjax programming style eliminates. In\u00addeed, David Patterson s plenary speech \n[29] at the Interna\u00adtional Symposium on Low Power Electronics and Design (2007) outlined a research project \nat Berkeley that exploits Flapjax for parallelism [21]. Finally, as mentioned above, Flapjax is a working \nlan\u00adguage. In particular, each of Resume and Continue 2.0 is accompanied by a demo mode, which automatically \ncreates an instance of a job search or conference, respectively, and lets the user experiment with the \nprogram, without need for an account. Readers are invited to try these applications for themselves to \nget a feel for how much perceived overhead data.ow evaluation might cause.8 5. Perspective Our design \nchoices in Flapjax raise a variety of interesting issues. We discuss these below. Consistency as a Linguistic \nPrimitive One of the central goals of Flapjax is to explore the idea of consistency as a linguistic primitive. \nThe motivation for the data.ow eval\u00aduation model is to enable propagation of updates, and the complexities \nof propagation (section 3.4) are to make this notion semantically sensible. Our propagation algorithm \nen\u00adsures that the developer never sees a value that is inconsis\u00adtent with the text of the program. This \nmeans developers can reason algebraically about their programs (a task simpli.ed because programs tend \nto become much less imperative) for instance, they can refactor their program using algebraic reasoning, \nwhile knowing that so long as they preserved the algebraic meaning, the program s behavior will not change \nupon execution. We view consistency as analogous to garbage collection: a sensible requirement that is \nso pervasive that languages should try to support and optimize it. As with garbage col\u00adlection, developers \ndo sometimes need to manually inject be\u00adhavior. For instance, valueNow samples a behavior at a par\u00adticular \ninstant; similarly, snapshotE samples a behavior at the instant an event .res (section 2.2). We .nd that \nthe num\u00adber of uses of these primitives is small: 14 and 19, respec\u00adtively, in Continue, and 19 and 10, \nrespectively, in Resume. This is from about 4.3 KLOC of Continue and 2.3 KLOC of Resume, including about \n1 KLOC of shared code. This sug\u00adgests that consistency is indeed the right default. It would be interesting \nto study traditional JavaScript codebases to deter\u00admine how much programming effort is expended in the \nother direction: to obtain what Flapjax provides intrinsically. Security We have not discussed security, \nwhich is a per\u00advasive concern in Web applications, beyond access con\u00adtrol (section 2.8). This is partly \nintentional: security means so many different things in this context (avoiding cross\u00ad 8 In demo mode, \nthe application runs in one frame while the demo program running in the other frame points to elements \nof the .rst and suggests what the user might click on. The demo advances by the interac\u00adtions of the \nuser with the application under demonstration. In other words, the demo framework is itself a reactive \napplication. Naturally, it too is writ\u00adten in Flapjax. site attacks, preventing server attacks, detecting \nmalicious data.ows, and so on) that it is impossible for a language to cover it all. Rather, we believe \nthat by reducing the num\u00adber of callbacks, Flapjax enables better program analysis, which is a prerequisite \nto many security analysis techniques. Separately, we have already applied control .ow analysis to JavaScript \nand Flapjax for intrusion detection [18]. Debugging and Contracts The state of debugging support for \nJavaScript is still quite primitive, and is even more so for Flapjax. Unfortunately, debugging Flapjax \ncan be some\u00adwhat challenging because debuggers expose the underlying evaluation mechanism. This exposes \nthe convoluted control .ow of event-driven Web applications that Flapjax abstracts away. Halting on program \nerrors in the innards of Flapjax s implementation is not useful. To avoid this, we have created a higher-order \ncontract system for Flapjax that accurately tracks blame [19]. For example, the contract of switchE is: \nEventStream (EventStream a) -> EventStream a Consider, for example, this illegal use of switchE: switchE(timerE(60000)) \nThe run-time error, expected event stream of event streams, received event stream of integers , occurs \nin the innards of switchE, a whole minute after the line executes. Stepping through this code achieves \nnothing. The contract system, however, identi.es this call-site as the source of the error. The contracts \nhave an ancillary bene.t: they precisely document the Flapjax API, which has a straightforward type structure. \nThis is especially valuable in a language without a formal static type system. How Many DOMs? (or, Beyond \nFunctions to Relations) Because the DOM is a prede.ned, readily available data structure that often re.ects \nthe shape of program data, JavaScript developers routinely con.ate the display model the DOM with the \ndata model. Not only is this an inappro\u00adpriate con.ation that hinders later maintenance, it can also \nresult in bugs: for instance, browsers can behave in unde\u00adsirable ways if the same DOM node is inserted \nas a child of two different parents (which can happen when the actual da\u00adtum is a DAG or graph, not a \ntree). Separating the true data model from the display model is known in Web parlance as a Dual-DOM approach \n[2]. Unfortunately, maintaining two models (or three, count\u00ading the persistent store) greatly complicates \nthe developer s job. Because changes on one side may trigger updates to the other, the OpenAjax alliance \nobserves [2], It is usu\u00adally necessary to establish bidirectional event listeners be\u00adtween the Ajax DOM \nand the Browser DOM in order to main\u00adtain synchronization (and this ignores the third model). Not only \ndoes this mean many more callbacks (with interference caused by updates), developers must take care to \nnot cause cascading cyclic updates. Recognizing that these situations create relational,rather than \nfunctional (or directed) dependencies, we have exper\u00adimented with a limited form of principled relational \nsup\u00adport in Flapjax. Speci.cally, we have implemented vari\u00adants of both lenses [15] and constraint maintainers \n[24] adapted to the JavaScript object system. Our experiments show that lenses transparently and consistently \nmaintain the model/view relationship in a way that requires less focus on when the models change; using \nFlapjax along with lenses allows developers to use modular reasoning about the oc\u00adcurrence of these changes. \nConceptually, developers view the various models interface, client, and server as dis\u00adtinct, but conventional \npractice confounds this distinction with consistency maintenance and race prevention. Flapjax with lenses \nrei.es this conceptual distinction in code. 6. Related Work A key feature that distinguishes Flapjax \nfrom other Web pro\u00adgramming libraries is its adoption of functional reactive pro\u00adgramming (FRP)[14,28].In \nFRP, instead of using callbacks to respond imperatively to events, a program de.nes signals that vary \nimplicitly as other values in their de.ning equations change. While this essential idea originates from \ndata.ow programming [6, 33], FRP applies the idea in a dynamic and higher-order setting. The speci.c \napproach taken in Flapjax is mainly informed by FrTime [10, 11], a call-by-value in\u00adstantiation of the \nFRP model. Unlike FrTime, Flapjax is ex\u00adplicitly designed for use as a library (a design choice that \nhas proven very valuable in hindsight); it models interac\u00adtions with a Web page s DOM, which requires \nthe ability to de.ne signals that can model richly structured mutable data in a meaningful way; it uses \nevents to interface with Web services; and it handles the inconsistencies and complexities of JavaScript. \nFrTime and Flapjax differ from the other FRP systems by employing a purely push-based, event-driven up\u00addate \nstrategy; the Haskell-based systems are pull-based (and driven by polling). Frapp\u00b4e[12], a Java FRP library, \nuses a hybrid push/pull evaluation strategy. Like Flapjax in library mode, Frapp\u00b4e is closer to a library \nthan a language, not sup\u00adporting the transparent reuse of host-language programs in a reactive context. \nA number of other languages with data.ow-like fea\u00adtures have been developed in recent years. For example, \nYa\u00adhoo! Pipes (pipes.yahoo.com) is an interactive, graphical domain-speci.c language for assembling pipelines \nthat .l\u00adter and aggregate dynamic Web content. Nodes subscribe to and produce feeds, which are updated \nautomatically when\u00adever their source changes. Beyond the Web, StreamIt [32] is a language for constructing \nnetworks of stream processors, targeted in particular for high-performance systems with relatively stable \ngraph structures. The individual StreamIt processors operate imperatively on their input and output streams, \nbut are assembled into a declarative graph. Au\u00adrora [5] and Borealis [7] offer similar capabilities to \nStreamIt but, instead of having developers write imperative process\u00ading nodes, they support query evaluation \nfor a declarative, high-level SQL-like language over streaming data. They also provide built-in operators \nfor computing various aggregates (e.g., average, maximum) over sliding time windows. All of these languages \ndeal exclusively in discrete data, in contrast with FRP systems like Flapjax, which also provide distinct \nnotions of continuous behaviors and support general purpose programming such as building GUIs, I/O operations, \netc. Systems such as Open Laszlo (www.openlaszlo.org), Flex (www.adobe.com/products/flex),andJavaFX \n(www. sun.com/software/javafx) have also applied data.ow programming ideas to the Web. They permit user \ninterface elements to be bound to expressions: whenever the value of the element changes, the whole expression \nis reevaluated and the result assigned to the bound variable. This means, how\u00adever, that behaviors are \nno longer .rst-class values. These systems have very limited or no support for higher-order reactivity \nthe ability to dynamically rebind a variable in response to an event. Furthermore, these systems do not \nde\u00adscribe any guarantees comparable to our glitch-freedom. Various languages and systems have been designed \naround the idea of constraint programming, which is a general\u00adization of data.ow evaluation. For example, \nThingLab [3] is an object-oriented constraint-programming language de\u00adsigned for expressing and running \nsimulations. Like Flapjax, it maintains dependencies between objects and automati\u00adcally propagates updates \nwhen values change. The language supports bidirectional constraints and employs a sophisti\u00adcated constraint-solving \nengine, which allows it to express programs that Flapjax cannot support directly. However, the Flapjax \nlanguage is richer in other ways, including support for higher-order functions and reactivity, as well \nas exposing separate notions of discrete events and continuous behaviors. Kaleidoscope [16] allows for \nmixed imperative and con\u00adstraint programming with multidirectional constraints. It maintains consistency \nusing a constraint solver with sup\u00adport for a hierarchy of constraint strengths, as well as tem\u00adporal \ncontrol over constraints, like our events and behav\u00adiors. Kaleidoscope con.ates intra-model constraints \nand model/view constraints, while ours are orthogonal libraries built on top of Flapjax. Our model/view \nconstraint sys\u00adtem, lenses [15], guarantees well-behavedness of composed constraints it is unclear what \nKaleidoscope s constraint solver guarantees of composed and user-de.ned constraints. Other related systems \nthat support constraint program\u00adming include the Garnet [26] and Amulet [27] user-interface toolkits. \nAlthough these employ a unidirectional constraint\u00adpropagation algorithm, they do support cyclic constraint \nnet\u00adworks, without the need for explicit time delays as Flap\u00adjax requires. Instead, they resolve cycles \nwith a simple depth-.rst once-around algorithm, which stops propagat\u00ading when it returns to a node that \nhas already been updated. Arrowlets [22] allow developers to specify the control .ow of JavaScript programs, \nacross multiple event handlers, using the functional programming concept of arrows. Like Flapjax, Arrowlets \nabstracts away underlying callbacks. This makes it possible to reason algebraically about control .ow \nacross multiple callbacks. However, for an Arrowlet to have a visible effect on the DOM, an arrow must \ncause a side-effect. This is apparent in their central drag-and-drop example. Arrows specify a state \nmachine, but the actual effects of dragging are scattered throughout individual arrows, despite the fact \nthat they are abstracted into a proxy . The proxy methods are essentially callbacks their return values \nare discarded. Arrows do allow the DOM mouse events to be composed into a new drag-and-drop event stream. \nHowever, the arrow-bassed drag-and-drop abstraction has the same callback-based interface as the DOM. \nInteresting behavior that uses the results from the various drag-and-drop call\u00adbacks will require shared \nstate. jQuery (jquery.com) allows DOM transformations and event handlers to be sequenced and applied \nto destructively update collections of elements. Flapjax focuses the .ow of values through the program, \nsourced from arbitrary, hetero\u00adgeneous data sources, including the DOM. Data-.ow evalua\u00adtion is orthogonal \nto the speci.cation of sequences of effects. Web application frameworks such as Ruby on Rails (rubyonrails.org) \nand Django (djangoproject.com) enable easily creating CRUD (create-read-update-delete) interfaces. They \nfocus on simplifying the object-relational mapping at the database level, and impose good practices such \nas model-view-controller separation. They are, how\u00adever, primarily designed for the server, whereas Flapjax \ncon\u00adnects to any Web service; they also do not offer linguistic support comparable to Flapjax s abstractions. \nFormlets [9] address the problem of building Web forms and extracting their input compositionally. Our \ncomposi\u00adtional .lters example (section 2.5) is in the same spirit. While Flapjax does not provide the \nsyntactic sugar of form\u00adlets, we arguably also do not miss it: in our .lter example, we simply use the \nlanguage s existing binding mechanism to name the sub-.lter (subFilter) and use it in subsequent expressions. \nWe are not constrained by the type-structure of applicative functors and synchronous form submission; \nas a result we believe that our composed .lter example is an in\u00adstance of their impossible formlet, one \nthat renders before producing a result. Links [8] addresses the problem that Web programs in\u00adherently \nspan several tiers the browser, the application server, and the persistent store each of which must typi\u00adcally \nbe programmed in a different language. The key con\u00adtribution of Links is to allow the entire application \nto be written monolithically in one (typed functional) language, and to translate fragments into lower-level \ncode appropriate for their respective execution platforms: JavaScript for the browser, SQL for the database, \netc. The compiler can help to ensure, among other things, that the tiers agree on the types and representations \nof the data they pass to each other, saving the developer the burden of writing such logic by hand. Although \nLinks is nominally tierless , it provides a relatively server-centric programming model, with the user \ninterface and database acting as second-class citizens. Its user interface support focuses on forms, \nwhich lack the rich interactivity of modern applications. Hop [30] is similar in spirit to Links, but \nit places more emphasis on the server and user interface tiers, making an explicit distinction between \nthem, and supporting interest\u00ading control .ow both within and between the layers. Hop al\u00adlows both layers \nto be written in a (lexically) single program expressed in essentially the same dialect of Scheme. Its \nso\u00adphisticated compiler can compile any fragment of Scheme code into JavaScript for execution in the \nbrowser. The gen\u00aderated code is ef.cient enough to perform smooth anima\u00adtions or play multimedia in a \nmodern browser. In Hop, both tiers can call into each other, or send events to each other, using asynchronous \nHTTP request and response messages. However, event-handling uses a conventional callback-based mechanism, \nwhich forces the reactive aspects of the program to be written in an imperative style. This is one signi.cant \ndifference between Hop and Flapjax. Flapjax differs from Links and Hop by taking an ex\u00adclusively client-centric \nview. All of the application-speci.c logic is driven from the user interface, which is written in (an \nextension of) JavaScript and run in the browser. The Flapjax server is a general-purpose, non-programmable \nobject store with innate notions of users, applications, and access control. At its core, Flapjax is \njust a library, so no compilation is nec\u00adessary, although some syntactic sugar for reactive program\u00adming \nis provided through a lightweight compiler. The client library provides an implementation of the server \ns commu\u00adnication protocol, which simply exchanges objects in JSON notation over HTTP. Its support for \nmodern social Web appli\u00adcations is arguably superior to that of any non-commercial system of which we \nare aware, given the server s explicit support for users and controlled data-sharing. It also sup\u00adports \nmash-ups that coordinate data and services from sev\u00aderal Web sites, a feature that Links does not seem \nto provide. A key source of complexity in modern Web applications is the need to handle asynchronous \ncommunication between the user interface and application server. The standard Ajax model provides a callback-based \nevent model; this imposes an imperative style on the developer, as well as demanding explicit continuation \nmanagement and resulting in the phe\u00adnomenon of stack-ripping [1]. MapJAX [13] addresses this problem \nas it pertains to the manipulation of shared, per\u00adsistent data. It abstracts away the asynchronous HTTP \ncom\u00admunication and callbacks typically needed for Ajax and in\u00adstead presents a familiar, high-level interface \nin terms of shared memory and locking. MapJAX frees the developer from the details of the communication \nprotocol between the client and server, and it implements general techniques for making such communication \nmore ef.cient and effective. Asidebene.t of using MapJAX is that applications may perform signi.cantly \nbetter, in addition to enjoying consid\u00aderably simpler implementations. Unlike Flapjax, MapJAX only addresses \ninteractions between the client and server, not those between the user and client, which still require \ncallbacks. However, it does provide a notion of concurrency control, which we have not yet explored for \nFlapjax.  7. Conclusion We have presented the Flapjax programming language. Flap\u00adjax is designed with \nthe needs of Ajax developers in mind. It provides a uni.ed framework for programming with events, both \nwithin the program and when communicating with Web services. Flapjax is a data.ow-based reactive language \nwherein values are automatically updated to be consistent, relieving developers of this burden. Through \nexamples and discussion, we have shown that the mechanisms of Flap\u00adjax collaborate to make programs more \ndeclarative, and to achieve valuable separations of concerns. Flapjax is currently only a client-side \nprogramming language. This is because of the relative uniformity of Web clients: estimates are that over \n90% of browsers have JavaScript enabled, making it the Web s other lingua franca besides HTML. In contrast, \nthere is a much greater range of technologies in use on servers, making it harder to target one platform. \nNevertheless, it would be valuable to build support for reactivity and events for server applications \nas well, and to make these consistent with Flapjax clients to enable the establishment of properties \nsuch as glitch-freedom across an entire distributed system.  Acknowledgments We thank our users, most \nof all Sean Barker, Morgan McGuire, Noel Welsh, Artyom Shalkhakov, and therac25 [sic]. We are grateful \nto Pete Hopkins, David Reiss, and Kimberley Burchett for feedback, Cormac Flanagan for con\u00adstructive \nprovocation, Trevor Jim and Jack Templin for en\u00adcouragement, and Andrey Skylar, Eli Barzilay, and Jay \nMc-Carthy for technical support. Thanks to the authors of Links, Hop, and Arrowlets for useful conversations. \nThis work was partially supported by the NSF. All authors were af.liated with Brown during their primary \nwork on Flapjax. References [1] Atul Adya, Jon Howell, Marvin Theimer, William J. Bolosky, and John \nR. Douceur. Cooperative task management without manual stack management. In Proceedings of the 2002 Usenix \nAnnual Technical Conference, 2002. [2] OpenAjax Alliance. Successful deployment of Ajax and OpenAjax. \nhttp://www.openajax.org/whitepapers/ SuccessfulDeploymentofAjaxandOpenAjax.php.  [3] Alan Hamilton Borning. \nThe programming language as\u00adpects of ThingLab, a constraint-oriented simulation labora\u00adtory. ACM Transactions \non Programming Languages and Sys\u00adtems, 3(4):353 387, 1981. [4] Kimberley Burchett, Gregory H. Cooper, \nand Shriram Krish\u00adnamurthi. Lowering: A static optimization technique for trans\u00adparent functional reactivity. \nIn ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipula\u00adtion, pages 71 80, \n2007. [5] Don Carney, Ugur C.\u00b8 etintemel, Mitch Cherniack, Christian Convey, Sangdon Lee, Greg Seidman, \nMichael Stonebraker, Nesime Tatbul, and Stan Zdonik. Monitoring streams a new class of data management \napplications. In International Conference on Very Large Databases, pages 215 226, 2002. [6] Paul Caspi, \nD. Pilaud, N. Halbwachs, and J. A. Plaice. LUS-TRE: A declarative language for programming synchronous \nsystems. In ACM SIGPLAN-SIGACT Symposium on Princi\u00adples of Programming Languages, pages 178 188, 1987. \n[7] Mitch Cherniack, Hari Balakrishnan, Magdalena Balazinska, Don Carney, Ugur C.\u00b8 etintemel, Ying Xing, \nand Stan Zdonik. Scalable distributed stream processing. In First Biennial Con\u00adference on Innovative \nData Systems Research, 2003. [8] Ezra Cooper, Sam Lindley, Philip Wadler, and Jeremy Yallop. Links: Web \nprogramming without tiers. In Formal Methods for Components and Objects, 2006. [9] Ezra Cooper, Sam Lindley, \nPhilip Wadler, and Jeremy Yallop. The essence of form abstraction. In Asian Symposium on Programming \nLanguages and Systems, 2008. [10] Gregory H. Cooper. Integrating Data.ow Evaluation into a Practical \nHigher-Order Call-by-Value Language. PhD thesis, Brown University, 2008. [11] Gregory H. Cooper and Shriram \nKrishnamurthi. Embedding dynamic data.ow in a call-by-value language. In European Symposium on Programming, \npages 294 308, March 2006. [12] Antony Courtney. Frapp\u00b4e: Functional reactive programming in Java. In \nPractical Aspects of Declarative Languages. Springer-Verlag, March 2001. [13] Daniel Myers and Jennifer \nCarlisle and James Cowling and Barbara Liskov. MapJAX: Data Structure Abstractions for Asynchronous Web \nApplications. In Proceedings of the 2007 USENIX Annual Technical Conference, June 2007. [14] Conal Elliott \nand Paul Hudak. Functional reactive animation. In ACM SIGPLAN International Conference on Functional \nProgramming, pages 263 277, 1997. [15] J. Nathan Foster, Michael B. Greenwald, Jonathan T. Moore, Benjamin \nC. Pierce, and Alan Schmitt. Combinators for bidirectional tree transformations: A linguistic approach \nto the view update problem. ACM Transactions on Programming Languages and Systems, 29(3), May 2007. [16] \nBjorn N. Freeman-Benson and Alan Borning. Integrating constraints with an object-oriented language. In \nEuropean Conference on Object-Oriented Programming, pages 268 286. Springer-Verlag, 1992. [17] Jesse \nJames Garrett. Ajax: A new approach to web applica\u00adtions. www.adaptivepath.com/ideas/essays/archives/ \n000385.php. [18] Arjun Guha, Shriram Krishnamurthi, and Trevor Jim. Using static analysis for Ajax intrusion \ndetection. In International World Wide Web Conference, April 2009. [19] Arjun Guha, Jacob Matthews, Robert \nBruce Findler, and Shriram Krishnamurthi. Relationally-parametric polymorphic contracts. In Dynamic Languages \nSymposium, October 2007. [20] Daniel Ignatoff, Gregory H. Cooper, and Shriram Krishna\u00admurthi. Crossing \nstate lines: Adapting object-oriented frame\u00adworks to functional reactive languages. In International \nSym\u00adposium on Functional and Logic Programming, pages 259 276, 2006. [21] Christopher Grant Jones, Rose \nLiu, Leo Meyerovich, Krste Asanovic , and Rastislav Bodik. Parallelizing the web browser. In Proceedings \nof the First USENIX Workshop on Hot Topics in Parallelism, April 2009. [22] Yit Phang Khoo, Michael Hicks, \nJeffrey S. Foster, and Vibha Sazawal. Directing JavaScript with Arrows. In ACM SIG-PLAN Dynamic Languages \nSymposium, 2009. [23] Daniel R. Licata and Shriram Krishnamurthi. Verifying inter\u00adactive Web programs. \nIn IEEE International Symposium on Automated Software Engineering, pages 164 173, September 2004. [24] \nLambert Meertens. Designing constraint maintainers for user interaction, 1998. ftp://ftp.kestrel.edu/pub/papers/ \nmeertens/dcm.ps. [25] Brad A. Myers. Separating application code from toolkits: Eliminating the spaghetti \nof call-backs. In ACM Symposium on User Interface Software and Technology, pages 211 220, November 1991. \n[26] Brad A. Myers, Dario A. Giuse, Roger B. Dannenberg, David S. Kosbie, Edward Pervin, Andrew Mickish, \nBrad Van\u00adder Zanden, and Philippe Marchal. Garnet: Comprehensive support for graphical, highly interactive \nuser interfaces. IEEE Computer, 23(11):71 85, 1990. [27] Brad A. Myers, Richard G. McDaniel, Robert C. \nMiller, Alan S. Ferrency, Andrew Faulring, Bruce D. Kyle, Andrew Mickish, Alex Klimovitski, and Patrick \nDoane. The Amulet environment: New models for effective user interface software development. IEEE Transactions \non Software Engineering, 23(6):347 365, 1997. [28] Henrik Nilsson, Antony Courtney, and John Peterson. \nFunc\u00adtional reactive programming, continued. In ACM SIGPLAN Workshop on Haskell, pages 51 64, 2002. [29] \nDavid A. Patterson. The parallel computing landscape: a Berkeley view. In International Symposium on \nLow Power Electronics and Design, 2007. [30] Manuel Serrano, Erick Gallesio, and Florian Loitsch. Hop: \nA language for programming the Web 2.0. In ACM SIGPLAN Dynamic Languages Symposium, October 2006. [31] \nDavid Tarditi, Peter Lee, and Anurag Acharya. No assembly required: compiling Standard ML to C. ACM Letters \non Programming Languages and Systems, 1(2):161 177, 1992. [32] William Thies, Michal Karczmarek, and \nSaman Amarasinghe. StreamIt: A language for streaming applications. In Interna\u00adtional Conference on Compiler \nConstruction, pages 179 196, 2002. [33] W. W. Wadge and E. A. Ashcroft. Lucid, the data.ow pro\u00adgramming \nlanguage. Academic Press U.K., 1985. A. Flapjax API In this appendix, we document the portion of the \nFlapjax API covered by the paper. The Flapjax API de.nes many more functions, and some of the functions \nlisted here have richer interfaces. We encourage the curious reader to explore the full Flapjax reference \nat www.flapjax-lang.org. $B :: InputElement -> Behavior InputValue $B(element) Creates a behavior carrying \nthe value of element. The ele\u00adment must be a form control (e.g., a text box, a checkbox, etc.) $E :: \nElement * String -> EventStream DOMEvent $E(element,eventName) Creates an event stream of DOM events \non element. eventName may be any DOM event (e.g., click , load , etc.) calmE :: Int * EventStream a -> \nEventStream a calmE(t,evt) Repeatedly mutes evt for t milliseconds. The result will therefore never .re \nmore than one event in a t millisecond interval. changes :: Behavior a -> EventStream a changes(src) \nCreates an event stream that .res an event carrying the value of src whenever that value changes. constantE \n:: EventStream a * b -> EventStream b constantE(src,val) Creates an event stream that .res a constant \nvalue, val, whenever src .res an event. delayE :: Int * EventStream a -> EventStream a delayE(t,src) \nFires all events from src, but delays each of them by t milliseconds. DIV :: Behavior Element * ... -> \nBehavior <div> div(child,...) Creates a behavior carrying a <div> element. Similar con\u00adstructors exist \nfor other HTML tags (e.g., P, TABLE,etc.). filterE :: (a -> Bool) * EventStream a -> EventStream a filterE(pred,src) \nFires only those events of src that satisfy pred. getForeignWebServiceObjectE :: ... Same interface \nas getWebServiceObjectE.However, this function can communicate with allowed remote servers via a Flash \nproxy.9 getWebServiceObjectE :: EventStream request -> EventStream response request = { url :: String, \nfields :: Object, request :: \"get\" or \"post\", response :: \"json\" or \"xml\" }; response = JSON or XML getWebServiceObjectE(request) \nSends and receives messages from the server. Due to Web browsers security policies, url must be on the \ndomain serving the Flapjax application. insertDomB :: Behavior Element * Element -> void insertDomB(src,dest) \nInserts the element carried by src into the DOM, replacing the static element placeholder dest. insertValueB \n:: Behavior a * Element * String -> void insertValueB(val,elt,attr) Assigns the value val to the attr \nattribute of elt. Updates as val changes. insertValueE :: EventStream a * Element * String -> void insertValueE(val,elt,attr) \nWhen an event .res on val,sets the attr attribute of elt to the value of the event. liftB :: (a * ... \n-> r) * Behavior a * ... -> Behavior r liftB(f,src ...) Creates a behavior whose value is the result \nof f applied to the values of src .... f is applied in topological order (sec\u00adtion 3.4) to preserve the \nalgebraic semantics of the program. mapE :: (a -> b) * EventStream a -> EventStream b mapE(f,src) Applies \nf to all events of src. mergeE :: EventStream a * EventStream a -> EventStream a mergeE(src1,src2) Fires \nevents from both src1 and src2. 9 For more information on cross-domain security policies, see livedocs. \nadobe.com/flash/8/main/00001621.html. oneE :: a -> EventStream a oneE(val) Creates an event stream that \n.res val just once. The event is .red immediately after the current event has .nished propa\u00adgating. receiverE \n:: -> EventStream a receiverE() Creates an event stream that does not .re any events itself. See sendEvent. \nstartsWith :: EventStream a * a -> Behavior a startsWith(src,init) Returns a behavior that initially \nholds the value init.When a new event .res on src, the behavior holds the value of the event. snapshotE \n:: EventStream a * Behavior b -> EventStream b snapshotE(src,sample) Fires an event carrying the current \nvalue of sample when\u00adever an event .res on src. sendEvent :: a * EventStream a -> void sendEvent(val,dest) \nImperatively pushes val todest,where dest is created with receiverE. switchE :: EventStream (EventStream \na) -> EventStream a switchE(src) Given an event stream of event streams, .res events from the latest \ninner event stream. When a new event stream arrives, switchE stops .ring events from the previous stream \nand starts .ring events from the new stream. timerB :: Int -> Behavior Int timerB(interval) Creates a \nbehavior carrying the current time. The behavior updates every interval milliseconds. timerE :: Int -> \nEventStream Int timerE(interval) Creates an event stream that .res an event carrying the cur\u00adrent time \nevery interval milliseconds. valueNow :: Behavior a -> a valueNow(src) Returns the value of src at the \npoint in time when valueNow is applied.  \n\t\t\t", "proc_id": "1640089", "abstract": "<p>This paper presents Flapjax, a language designed for contemporary Web applications. These applications communicate with servers and have rich, interactive interfaces. Flapjax provides two key features that simplify writing these applications. First, it provides <i>event streams</i>, a uniform abstraction for communication within a program as well as with external Web services. Second, the language itself is reactive: it automatically tracks data dependencies and propagates updates along those dataflows. This allows developers to write reactive interfaces in a declarative and compositional style.</p> <p>Flapjax is built on top of JavaScript. It runs on unmodified browsers and readily interoperates with existing JavaScript code. It is usable as either a programming language (that is compiled to JavaScript) or as a JavaScript library, and is designed for both uses. This paper presents the language, its design decisions, and illustrative examples drawn from several working Flapjax applications.</p>", "authors": [{"name": "Leo A. Meyerovich", "author_profile_id": "81100521215", "affiliation": "University of California, Berkeley, Berkeley, CA, USA", "person_id": "P1728707", "email_address": "", "orcid_id": ""}, {"name": "Arjun Guha", "author_profile_id": "81331493565", "affiliation": "Brown University, Providence, RI, USA", "person_id": "P1728708", "email_address": "", "orcid_id": ""}, {"name": "Jacob Baskin", "author_profile_id": "81444600518", "affiliation": "Google, Mountain View, CA, USA", "person_id": "P1728709", "email_address": "", "orcid_id": ""}, {"name": "Gregory H. Cooper", "author_profile_id": "81406597902", "affiliation": "Google, Mountain View, CA, USA", "person_id": "P1728710", "email_address": "", "orcid_id": ""}, {"name": "Michael Greenberg", "author_profile_id": "81406593888", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1728711", "email_address": "", "orcid_id": ""}, {"name": "Aleks Bromfield", "author_profile_id": "81444595878", "affiliation": "Microsoft, Redmond, WA, USA", "person_id": "P1728712", "email_address": "", "orcid_id": ""}, {"name": "Shriram Krishnamurthi", "author_profile_id": "81100512233", "affiliation": "Brown University, Providence, RI, USA", "person_id": "P1728713", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640091", "year": "2009", "article_id": "1640091", "conference": "OOPSLA", "title": "Flapjax: a programming language for Ajax applications", "url": "http://dl.acm.org/citation.cfm?id=1640091"}