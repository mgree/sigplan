{"article_publication_date": "10-25-2009", "fulltext": "\n Agile Speci.cations Derek Rayside, Aleksandar Milicevic,KuatYessenov, GregDennis, and Daniel Jackson \nMIT Computer Science and Arti.cial Intelligence Laboratory {drayside, aleks, kuat, gdennis, dnj}@csail.mit.edu \nAbstract Traditional formal methods and modern agile methods are separated more by limitations of current \ntechnology than by fundamental intellectual di.erences.A mixed interpreter that executes mixed programs, \ncomprising both declarative speci.cation statements and regular imperative statements, might bridge the \ngap. This paper explores how such an interpreter mightbe used, showingbyexamplehowit might support a \nvariety of development activities. Categories and Subject Descriptors D.2.1[Software En\u00adgineering]: Requirements/Speci.cations; \nD.2.5 [Software Engineering]:Testing and Debugging General Terms Design, Languages Keywords formal methods, \nagile methods, speci.cation statement, re.nement calculus, test-driven development 1. Introduction Our \ndeparture from tradition is a small one: we sim\u00adply banish the distinction between speci.cations, sub\u00adspeci.cations \n(super-programs?), and programs. To us, they are all programs; what we give up is that all programs are \ndirectly executable. What we gain in\u00adstead is a more uniform approachin whichprograms play a role at \nevery level. Morgan [39] Modern agile methods and traditional formal methods are often perceived as \nbeing diametrically opposed. We argue that with a touch of new technology, however, they can be quite \ncompatible, and used in combination to good e.ect. Following Carroll Morgan [39], we say that amixed \npro\u00adgram is one written using a mixture of regular imperative statements and declarative speci.cation \nstatements [38].We understand the imperative statements to be written in a con\u00adventional object-oriented \nlanguage(e.g.,Java), and the spec- Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. OOPSLA 2009 October 25 29, 2009, Orlando, Florida, USA. Copyright &#38;#169;c2009ACM \n978-1-60558-768-4/09/10...$10.00 i.cation statements to be written in a .rst-order logic speci\u00ad.cation \nlanguage(e.g., JML [32] or JFSL [12, 49]). Amixed interpreter is an interpreter that canexecute such \nprograms. Hoare [26] and Hayes and Jones [23] argued years ago that executing declarative speci.cations \nwas infeasible. But advances in the past twenty years suggest that mixed interpreters may infact be possible. \nPreliminary steps have already been takenbyWahls et alia [31, 47], and we have also developed a prototype \nmixed interpreter ourselves (to be reported in a future paper). In this paper we assume the existence \nof a mixed inter\u00adpreter and explore how this technology might change our viewsof softwaredevelopment \nmethodology.We argue that the divide between formal methods and agile methods is due more to limitations \nof current technology than to fundamen\u00adtally irreconcilable intellectual positions. Throughaseriesof \nexamples we try to illustrate how a mixed interpreter might createasmooth continuum between the formal \nand the agile. 1.1 Background This paper attempts to connect two large and often culturally disjoint \nschools of the software development methodology literature: formal methods and agile approaches. Formal \nmethodstendto emphasize speci.cationsandver\u00adi.cation, whereas agile methods emphasize tests and rapid \nprototyping.A characteristic exampleof traditional formal methods is Dijkstra s idea that programs and \ntheir proofs should be constructed in tandem [13] by a process of step\u00adwise re.nement [14, 48]. This \napproach was developed into the re.nement calculus by Back [2], Hehner [24], Morris [40], Morgan [38, \n39], and others. Ontheagileside,KentBeck stest-drivendevelopment[3] begins with concrete inputs and graduallyevolvesa \nprogram that computesovera rangeof similar inputs. Figure2 lists some of the contrasting terms that are \ncommonly associated with each side. There have been a few hints of potential common ground between formal \nmethods and agile approaches in the liter\u00adature. The idea of lightweight formal methods [27] germi\u00adnated \naround the same time as agile methods and similarly advocated a pragmatic focus on partiality and tool \nsupport, but with an emphasis on applying tools to designs and speci\u00ad.cations as well as code. More recently,Ameyand \nChapman Figure1 Integer square root case study from Morgan [39]  (a) Purely declarative program: (b) \nMixed program: (c) Purely imperative program: 1: r . 0 1: r . 0 2: q. s + 1 2: q. s + 1 3: I . r2 = \ns < q// loop invariant defn 3: 4: while r + 1* qdo 4: while r + 1* qdo 5: p:[r + 1< q, I, r < p< q] 5: \np. (r + q)/2 r :[r2 = s < (r + 1)2] 6: if s < p2 then 6: if s < p2 then  2 7: q:[s < p2 . p< q, I, \nq< q0] 7: q. p 8: else 8: else 9: r :[s = p2 . r < p, I, r0 < r] 9: r . p 10: end if 10: end if 11: end \nwhile 11: end while The purely declarative program in (a) is re.ned to the purely imperative program \nin (c). The re.nement process has many steps. One mixed program produced during this process is shown \nin (b). The parts of the purely imperative program in (c) that have not changed from the mixed program \nin (b) arefadedto emphasizethelines(5,7,and9)thathave changed. [1] argued that programming with a su.ciently \npowerful staticveri.eris similartopair programming.A panel dis\u00adcussion ata National Academiesworkshop \nincludingKent Beck, Matthias Felleisen, and AnthonyHall came to the sur\u00adprising conclusion that formal \nmethods and agile approaches actually had much in common, primarily in being driven by perceived risk \n[43]. Figure2 Characterizations of formal and agile methods Formal Agile veri.cation validation correctness \npleasantness re.nement refactoring abstract concrete general particular proofs tests upfront design design \nevolves with code analysis-paralysis cowboy-coding programmer team Dijkstra [13, 14] Beck [3, 4] 2. \nProcedures In this section we follow the .rst case study in Morgan s book [39]: a procedure that computes \nthe non-negative inte\u00adger square root of its input. This example has also been used by Dijkstra, Ameyand \nChapman [1], and others. 2.1 Programming from Speci.cations If you don tdrive development with tests, \nwhat do you drive it with? Speculation? Speci.cations? Beck [3] Following Morgan s development, we start \nwith a speci.\u00adcation and systematically re.ne it to a mixed program, and eventually toa purely imperative \nprogram.A mixed inter\u00adpreter supports this formal methodologybyenabling the pro\u00adgrammer to execute the \nprogram at anystep in the process. The initial speci.cation is: var r, s : N (1) v r := L sJ (2) v where \ntakes the non-negative square root of its argu\u00adment. The .rst step of the re.nement is to remove the \nex\u00adotic mathematical operators and replace them with non\u00addeterministic assignment. In Morgan s syntax \nwe write [39]: r :[r2 = s < (r + 1)2] (3) which assigns to r an arbitrary value satisfying the formula \non the right-hand side of the colon. This speci.cation is now suitable for re.nement. After a few re.nement \nsteps, Mor\u00adgan [39] produces the mixed program shown in Figure 1b. Figure 1c shows the purely imperative \nprogram that is the .nal result of the re.nement process [39]. Line3 of Morgan s mixed program de.nes \nthe loop in\u00advariant I. Lines 5, 7, and 9 of Morgan s mixed program are speci.cation statements of the \nform v :[pre, inv, post], where v is the variable being constrained, pre is the precon\u00addition, inv is \nthe invariant, and post is the postcondition [39]. These lines are further re.ned to simple assignments \nin the purely imperative program listed in Figure 1c.  2.2 Validation Bewareofbugsin the above code;Ihave \nonlyproved it correct, not tried it. Knuth [30] Using tests for validation has been independently advocated \nin the requirements engineering community(e.g., [21]), the testing community(e.g., [22]), and the agile \nmethods com\u00admunity(e.g., [36, 41, 45]). Validation has also historically been the main argument for the \nexecution (and animation) of speci.cations(e.g., [20]).  With our prototype mixed interpreter we can \nexecute the speci.cation for integer square root given in Formula 3. Suppose we want to compute the integer \nsquare root of 10, which we expect to be 3. With our mixed interpreter we executeFormula3with the input \n10 and get the surprising result 27. Trying the same execution again we get other surprising results: \n-12, 42, -55, etc.. We eventually get an execution that returns the expected result of 3. What s going \non? Acloser look atFormula1reveals that Morgan de.nes r and s over the natural numbers(N), which range \nfrom0 to O. Our program is written with ints. In Java, ints are signed 32-bit values ranging from -231 \nto231 - 1.For our mixed interpreter ints are signed 8-bit values, ranging from -128 to 127. These two \ndi.erent sets of ints di.er from the natural numbers in the same ways: theyhave a .nite upper bound, \nand their lower bound is below zero. It turns out that these properties are important for this program. \nIn the world of signed 8-bit ints, 272 = -39 and (27 + 1)2 = 16. -39 is indeed less than 10 and 16 is \ngreater than 10, so our speci.cation is satis.ed: 27 is an integer square root of 10 according to our \nde.nition. Infact, it turns out that there are sixty numbers between -128 and 127 that satisfyFormula \n3. Similarly, with 32-bit ints there are 1,073,741,820 solutions that meet our speci.\u00adcation as an integer \nsquare root of ten, which again is about 25% of the possible values. We need to re-writeFormula3to get \nthe result wewant given the machine we have. First, we need to explicitly state that we re looking for \na non-negative root (which is explic\u00aditly stated in Morgan stext, and implicitly in his de.nition of \nr . N). Then we re-write the previous two clauses in terms of division instead of multiplication to avoid \nover.ow. So Formula3becomesFormula4(for simplicityofexposition we exclude the case where s and r are \n0): ss r :[s > 0, r > 0. r =. < r + 1] (4) rr + 1 When we execute this revised speci.cation with our \nproto\u00adtype mixed interpreter we get the expected result of 3 (as the non-negative integer root of 10) \non the .rst try. Further investigation con.rms that3is now the onlyvalid answer. Astudent [8] of Michael \nJackson [28] might diagnose the surprises we experienced in attempting to copythe pseudo\u00adcode out of \nProgramming from Speci.cations [39] and into a real computer asafailure to distinguish between require\u00adments \nand speci.cations. Requirements are all about and only about the problem domain. Programs are all about \nand only about the machine. Speci.cations stand in be\u00adtween requirements and programs, speaking of shared \nphe\u00adnomena. Formulas1,2, and3are really requirements: theyspeak aboutthe domainof mathematics.Formula4isa \nspeci.ca\u00adtion: it describes the problem domain solution in terms of the machine.We were seduced into \nthinkingofFormulas1,2, and3 as speci.cations becauseweliketo thinkof program\u00adming asa mathematical activity. \nThis illusion disappeared as soon as we tried to execute these speci.cations . Underestimating the signi.cance \nof arithmetic over.ow isnotamistakecon.nedtonovices. Joshua Bloch[7] reports making exactly this mistake \nwhen he copied (a mathemati\u00adcally proven) binary search algorithm out of Jon Bentley s ProgrammingPearls \n[5]. When computing the mid-point of high and low, Bloch s implementation (which was shipped with the \nstandard Java libraries for almost a decade) would potentially over.ow if the size of the array was greater \nthan about a billion elements. Similarly, Rod Chapman [personal communication] re\u00adlays that Praxis High \nIntegrity Systems uses this integer square root example in their SPARK/Ada training courses. The trainees, \nwho are usuallyexperienced programmers, are given the speci.cation and asked to implement it and to \nverify their implementation with the SPARK Examiner tool. The SPARK Examiner statically veri.es that \nthe code meets its speci.cation and will not throw anyruntime exceptions (integer over.ow causes a runtime \nexception in Ada). Only one student hasever writtenaveri.ably correct implemen\u00adtation on the .rst try: \nProfessor Robert Dewar. More quantitatively, Christeyand Martin [10] report that integer over.ows are \nan increasing source of discovered se\u00adcurity vulnerabilities, especially in operating systems code. These \nkinds of errors are made by competent professional programmers every day. Testing serves as an important \ntool for validating spec\u00adi.cations (declarative programs) and for verifying impera\u00adtive programs. Just \nas fully imperative programs often com\u00adpute correct results for common inputs and incorrect results for \nuncommon inputs, fully declarative programs often al\u00adlow undesirable results for common inputs(i.e., \nare under constrained).Testing our speci.cationbyexecutingit witha mixed interpreter was essential to \nvalidating that the speci.\u00adcation accurately captured our requirements.  2.3 Test-Driven Development \nWhat of testing and debugging? They are still neces\u00adsary. ... Those were the only errors, and it ran \nthird time. But the point had been made: mathematical rigour cannot eliminate mistakes entirely. Morgan \n[39] Test-Driven Development is a well-known agile method\u00adology advocatedbyKent Beck [3]. The mottoof \ntest-driven development is red/green/refactor. First the programmer writes a test for functionality that \ndoes not yet exist, and con.rms that the testfails. Thisfailing testis indicatedby a red light in the \ntest harness. Next the programmer writes Figure3 Test-Driven Development applied to the integer square \nroot speci.cation. Each row is a new step in the development. Test cases arein columns.At each step eithera \nnew testis added or the programis modi.ed.Test results canbe red (R), green (G), or yellow (Y). Redisfail. \nGreenis pass.Yellow means the resultisa super-setof the desired result.  vv v v v Step 1 r = 0 Program \nL 9J = 3 L 16J = 4 L 10J = 3 L 100J = 10 L 120J = 10 2 3 \" r = 3 R{0}G 4 5 \" r2 = s G Y{-125, -3,3, 125} \nR{3}Y{..., -4,4, 28, ...} 6 r2 = s . r = 0 Y{3, 125} Y{4, 28, ...} 7 8 \" r = s r . r > 0 G G G G G 9 \n\" G G G G 10 11 r = s r r = s \" . r > 0 G Y{1, 2,3} G Y{1, 2, 3,4} G Y{1, 2,3} G Y{1, 2, ...,10} R\u00d8 Y{1, \n2, ...,10} 13 12 r r = s r . r = s r+1 - 1 . r > 0 . r = s r -1 . r > 0 Y{2,3} G Y{3,4} G Y{2,3} G Y{9,10} \nG G R\u00d8 14 r = s r . r > s r+1 - 1 . r > 0 G G G G G the simplest possible code to make the test pass \n perhaps as simple as return 3. This passing test is indicated by a green light in the test harness. \nThe programmer then adds new test cases and refactors the implementation to be a more general program \nthat works over a broader range of inputs. With a mixed interpreter the test-driven methodology can also \nbe applied to speci.cations. Making speci.cations in\u00adteractivein thisway potentiallyo.ers usability bene.ts. \nOne way to develop a speci.cation is to have a brilliant .ash of insight and, with a single stroke of \nthe pen, capture that in\u00adsight in a mathematical formula. Another possibility is to start with concrete \ninput/output pairs,expressed as test cases, andbuildupthe general formula through interaction witha mixed \ninterpreter. Figure3walks through applying test-drivendevelopment totheinteger squarerootexample.Eachstepinthedevelop\u00adment \nis a new row in the table, and each step either adds a new test case or modi.es the program. The results \nfor each test are either red (R), green (G), or yellow (Y). Red and green indicatefailing and passing \ntests, respectively, as per normal.Yellow indicates that theexpected answeris among the answers,but is \nnot the only answer(i.e., the program is under-constrained). In red and yellow cases a sample of the \nresults returned by the program is also displayed. Step-by\u00adstep: 1.We start with the program r = 0and \nno test cases. v 2.We add the test case L 9J = 3, which fails. Keep it simple to start with: only perfect \nsquares. 3. Revise the program to r = 3. The single test case passes. v 4. Add a new test case, L 16J \n= 4, which is also a perfect square. This test casefails. 5. Revise the program to r= s. Both test cases \nreturn yellow, due to negative roots and over.ow.  2 6. Add r = 0to the program to eliminate the negative \nroots. 7. Divide both sides of r2 = s by r to avoid over.ow. Since we re dividingby r let s also now \nensure that r > 0. Both perfect-square tests pass.  v 8. Add a new test case, L 10J = 3, our .rst test \ncase that s 10 not a perfect square. Surprisingly, it passes: = 3 in 3 integer division. v 9. Addanewtest \ncase with some larger numbers: L 100J = 10. This also passes; it s a perfect square. 10. Add a new test \ncase with a larger number that isn t a v perfect square: L 120J = 10. This is a boundary case v just \nunder L 121J = 11. It fails: there is no integer r s such that r = .For example, 120 = 12, and 120 = \n10. r10 11 11. Relax the program from an equality to an inequality. Now all tests are yellow. Notice \nthat the desired result is always the upper bound of the result set. We need a stronger lower bound for \nr to eliminate these undesired values. 12. Add r = s -1to the program. It sone less than our upper\u00ad \n r bound, so maybe it will work. All tests are green except the last one, which again has no result. \nWhydoesn t our 120 desired answer 10 work? 10 - 1 = 11, which is greater than 10. Howcan we change the \nleft hand side so that it is a lower bound on 10? Let s examine the concrete values. 120 120 Possibilities \ninclude: - 2 = 10 or - 1 = 9. The 10 10+1 latter seemslikeabetterguess:sticking1 sintoaformula is more \nlikely to work out than 2 s. s 13. Change the lower bound to r =- 1. Most tests are r+1 yellow: this \nlower bound is a bit too low. 14. Change = to > on the lower bound clause to tighten it up a bit. All \ntests now pass. The astute reader will see that the speci.cation developed here is the same as that \ninFormula4 (notwithstanding the s > 0conjunct). Although both methods arrived at the same result, they \ndid so in di.erent manners. With Beck s agile method we dealt with negative values and over.ow early \nin the development, whereas with Morgan s formal method these adaptations to the actual machine were \nthe last step. In the agile approach we adapted to the environment .rst, and generalized later. In the \nformal approach, we generalized .rst and adapted to the environment later. 3. DataTypes Speci.cations \nof data types include not only the behavior of the type s operations,but also representation invariants \n[25] and abstraction functions [25]. (Jones [29] provides an inter\u00adesting discussionoftheearlyworkon \nabstraction functions.) Representation (or class) invariants de.ne the set of valid concrete (runtime) \nvalues for the structure. An abstraction function maps concrete values to their abstract counterparts. \nA mixed interpreter might make agile practical use of both representation invariants and abstraction \nfunctions. 3.1 Test-Input Generation Anumberof recenttools,suchasTestEra[35]andKorat[9], haveused representationinvariantsasabasisto \ngeneratetest inputs. The goal is to generate all non-isomorphic test inputs that satisfy the representation \ninvariant speci.cation. Amixed interpreter naturally subsumes the functionality of these task-speci.c \ntools. The advantages to this more gen\u00aderal approach are (1) the programmer uses the same speci\u00ad.cation \nlanguage for class invariants as for procedures; (2) the ease with which various speci.cations can be \ncomposed in order to generate test-inputs with a particular focus (com\u00adposition of logical speci.cations \nis simply conjunction); (3) the other tasks for which these same speci.cations can also be used, as described \nin the rest of this paper. Automatic generation of test inputs from speci.cations has already been established \nas an area that blurs the bound\u00adaries betweenthe concrete, test-centredworldofagile meth\u00adods and the \nabstract world of formal methods. Mixed inter\u00adpreters make this part of a more general and uniform ap\u00adproach \nto programming. 3.2 Data Structure Repair Sometimes data structures get into a bad state. At this point \noptions include: abrupt termination, try tokeep computing with invariants violated, or try to repair \nthe data structures before continuing. This last option, data structure repair, has received some attention \nin recent years(e.g., [11, 18]), and is usually based on the representation invariants. Given a logical \nspeci.cation of the class invariant, a mixed interpreter can easily be used to (a) check that the current \nstate complies with the invariant, and (b) to search for a state that does comply with the invariant. \nPerforming data structure repair with a mixed interpreter might have some advantages and disadvantages \nas compared with previous specialized approaches to repair. The main disadvantage is that, without some \nextra customization for this task, the mixed interpreter isn t going to be constrained to .nd a valid \nstate that is similar to the broken state. In the extreme, consider that an empty list is a valid list: \none valid (although not preferable) repair strategy for a list data structure is just to delete all elements \nof a broken list. An advantage that a mixed interpreter might have over a customized solution is the \nease with which various speci.\u00adcations canbe combined.Forexample, classinvariants are usually checked \nat the end of public methods. If, at the end of theexecutionofa public method,themixed interpreter .nds \nthat the class invariant of the receiver no longer holds, it can searchforastatethat respectsboththeinvariantandthepost\u00adcondition \nwhile mutating only the receiver. Such .exibility might be harder to achieve with a customized solution. \n 3.3 Object Contract Compliance In many object-oriented languages, including Java andC#, every object \nis supposed to provide implementations of the so-called object contract methods equals and hashCode. \nCorrect implementation of these methods is notoriously tricky, tedious, and error-prone [6, 33, 42, 44, \n46]. However,correct implementations of these object-contract methods can be mechanically derived from \nprogrammer\u00adprovided abstraction functions [44].Amixed interpreter en\u00adables these abstraction functions \nto be written in the same logic as the other speci.cations, and therefore also used as part of the other \nsoftware engineering activities described in this paper. (Previous work by Rayside et al. [44] required \nnon-trivial abstraction functions for this purpose to be writ\u00adten in imperative code.) While there are \nsome procedures for which it may be eas\u00adier to write code than a speci.cation, for abstraction func\u00adtions \nit is almost always easier to write the speci.cation. 4. Putting it all together: Mock Objects Mock objects \nare a speci.c form of rapid prototyping advo\u00adcatedbytheagile methods community[3,19,34,37].Mock objects, \nas objects, comprise both procedures and data. The motivation for mock objects is to facilitate testing \nof other code that uses complex infrastructure: mock imple\u00admentations of the infrastructure are developed \nto enable test\u00ading the other code.Forexample, one might use an alternative in-memory database for testing \nan order processing system rather than using the real on-disk database. Suppose we are developing an \nemail client, and are about to write EmailMessage.bind(AddressBook), which attempts to look up a person \ns email address in the address book.Following an agile test-driven approach [3], we .rst write two unit \ntests for bind, shown in Listing 1.  Now we need an AddressBook object so that we can run our tests. \nBut the developer working on the real Address-Book implementation hasn t .nished it yet. However, fol\u00adlowing \ntraditional formal methods, she has written a spec\u00adi.cation for it .rst (Listing 3). All we need to do \nthen to get a working AddressBook object for our tests is to cre\u00adate a class MockAddressBook that implements \nAddress-Book and speci.es the initial conditions(i.e.,that the book is empty) on the constructor (Listing \n4). Finally we implement EmailMessage.bind() (Listing 2) and run our tests. With the help of a mixed \ninterpreter we have a mock im\u00adplementation at no additional cost to writing its speci.cation. Moreover, \nthe speci.cation-based mock provides additional bene.ts: support for veri.cation of the real implementation, \ntest-input generation, data structure repair, object contract compliance, and so on. Listing 1. Unit \ntests for EmailMessage.bind() @Before public void setUp() { addressBook = new MockAddressBook ( ) ; addressBook.setEmailAddress(\"Daniel\", \n\"dnj@mit.edu\"); } @Test public void testBindIfPresent () { EmailMessage m = new EmailMessage(\"Daniel\" \n); Assert . assertTrue (m. bind ( addressBook ) ) ; Assert.assertEquals(\"dnj@mit.edu\", m.email); } @Test \npublic void testBindIfAbsent () { EmailMessage m = new EmailMessage(\"Robert\" ); Assert . assertFalse \n(m. bind(addressBook )); } Listing 2. EmailMessage.bind() method public boolean bind(AddressBook abook) \n{ if (!abook. contains ( this .name)) { return false ; } else { this . email = abook . getEmailAddress \n( this . name ) ; return true ; } } Listing 3. AddressBook interface and speci.cation @SpecField(\"data \n: String -> String \" ) @Invariant(\"all x:String | lone this.data[x]\") public interface AddressBook { \n@Requires( \"name != null &#38;&#38; email != null \" ) @Ensures(\"this.data = @old(this.data) ++ name -> \nemail \" ) @Modifies(\"this .data\") void setEmailAddress(String name, String email); @Ensures( \" return \n- null = this . data [name] \" ) String getEmailAddress(String name); @Returns(\"some this.data[name]\") \nboolean contains(String name); } Listing 4. MockAddressBook implementation public class MockAddressBook \nimplements AddressBook { @Ensures(\"no this.data\") @Modifies(\"this .data\") public MockAddressBook ( ) \n{ } } Terminology. The term mock object was introduced by Mackinnon et al. [34]. Since then the terminology \nin the agile-methods community has evolved [19, 37]. In the new terminology our MockAddressBook would \nbe referred to as a fake object rather than a mock object. Fake objects are fully (or mostly) functional \nreplacements, whereas mock objects are simply pre-programmed to respond to a speci.c sequence of method \ncalls for a single unit test. In other words, fake objects are richer than mock objects and take more \ne.ort to implement [37].Amixed interpreter provides fake objects for no additional e.ort over specifying \nthem. 5. Performance of a Prototype On reasonable assumptions, the whole universe will reach a uniform \ntemperature around four degrees Kelvin long before any interesting calculation is com\u00adplete. Hoare [26] \nOur prototype mixed interpreter can perform the basic com\u00adputations described in this paper with small \ninputs: 8-bit in\u00adtegers and a dozen or so objects. Mixed programs that we have executed with our prototype \ninclude the integer square root programs above, the address book mock object program above,sortingalistofintegers,andvarious \nmanipulationsof binary search trees. Figure4showsa plotofexecution timeversus input size for sorting \nan array of integers by executing a declarative speci.cation for a sort procedure. Lists of up to size \n15 can be sorted in a couple of seconds on stock hardware. These results show that interesting calculation \ncan be completed before the heat-death of the universe. While mixed interpreters may not yet be ready \nfor everyday use, they are clearly no longer beyond the bounds of our imagi\u00adnation. Figure4 Performance \nsorting an array of integers  6. Conclusion Muchwork has been done since the crucial .rst step of considering \nboth speci.cations and code to be pro\u00adgrams. Thee.ect has been to simplify, and make more regular, muchof \nthe detail of constructing programs: and there are signi.cant implications for the practice of software \nengineeringgenerally. Morgan [39] Until now, formal speci.cations have occupied a rather spe\u00adcialized \nniche in software engineering. While advocates of formal methods have argued, for several decades, that \nspeci\u00ad.cations should lie at the center of the programming process, practitioners have been reluctant \nto adopt them often out of ignorance,but also froma realistic assessmentof their costs and bene.ts. \nWith programming languages o.ering better support for runtime assertions, and a more positive attitude \nto unit testing encouraged by the agile programming move\u00adment, the value of speci.cations is being reassessed. \nSyn\u00adergies between tools allow multiple bene.ts to be obtained from a single speci.cation; the same annotation \nused as an oracle for unit testing can be fed to a theorem prover. This paper has argued for taking one \nstep further along theroadtowardsafullintegrationof speci.cationsandcode. In addition to using speci.cations \nfor traditional purposes, we have proposed that theybe executed just like code. From one perspective, \nthis is nothing more than providing some mechanical support for the re.nement calculus. From an\u00adother \nperspective, however, this makes speci.cations more agile by shifting the emphasis from abstraction and \nproof to simulation and checking. Something has beengained and nothing has been lost: systematic, proof-oriented \napproaches are still perfectly compatible with this technology. Speci.cation statements [2, 38, 40] were \ndeveloped as part of the re.nement calculus to support a very systematic style of programming that proceeds \nin an orderly fashion from speci.cation to code. One might imagine that, in a less systematic and moreexperimental \nsetting, these notions would be less useful. But, on the contrary, it seems likely that the ability to \nwrite a mixed program will be particularly helpful when the programmer is less disciplined, since it \nmakes it easier to maintain a complete version of the code (albeit with sections implemented as speci.cations) \nand explore it as it evolves. It has become clear that the writing of code in its narrow\u00adest sense is \nonly a small part of software engineering, and even of programming. The best programmers are willing \nto invest in the surrounding infrastructure test cases, stubs and oracles, runtime assertions, documentation \n and are ea\u00adger to integrate this infrastructure more closely with the code proper, and to .nd ways to \ndevelop the two in tandem. The ability to execute speci.cations might take us much closer towards this \ngoal; at the very least, the range of bene.ts of speci.cation would be greatly expanded. Through all \nof this what we have endeavoured to show is that formal methods and agile methods are separated more \nbyshortcomingsofexisting technology thanbyfundamental intellectual di.erences. One focuses on the abstract \nand on correctness and veri.cation. The other focuses on the con\u00adcrete and the convenient and on validation. \nBoth emphasize co-developmentofthe programanditsevaluation.Newtech\u00adnology to connect the concrete and \nthe abstract can give the practicing programmer a more .exible and uni.ed spectrum of approaches. Acknowledgments \nJonathan Edwards [15 17] has been an important in.uence in thinking about connecting the concrete and \nthe abstract. This research was funded in part by the National Science Foundation under grant 0541183 \n(Deep and Scalable Anal\u00adysis of Software). References [1] Peter Amey and Roderick Chapman. Static veri.ca\u00adtion \nand extreme programming. In SIGAda 03, Decem\u00adber 2003. URL http://www.praxis-his.com/sparkada/ publications_confs.asp. \n[2] Ralph-Johan Back. On the Correctness of Re.nement Steps in Program Development. PhD thesis, University \nof Helsinki, 1978. Report A 1978 4. [3] Kent Beck. Test-Driven Development. Addison-Wesley,2003. [4] \nKent Beck. Extreme Programming Explained. Addison-Wesley, 1999. [5] Jon Louis Bentley. ProgrammingPearls. \nACM Press, 1986. [6] Joshua Bloch. E.ectiveJava. Addison-Wesley, 2001. [7] Joshua Bloch. Nearly all binary \nsearches and mergesorts are broken. O.cial Google Research Blog, June 2006. URL http://googleresearch.blogspot.com/2006/ \n06/extra-extra-read-all-about-it-nearly.html. [8] Joshua Bloch. Response to discussion of [7], June 2006. \nURL http://lambda-the-ultimate.org/node/1549. [9] Chandrasekhar Boyapati, Sarfraz Khurshid, and Darko \nMari\u00adnov.Korat: AutomatedTesting BasedonJava Predicates. In Phyllis Frankl, editor, Proc.ISSTA, Rome, \nItaly, July 2002. [10] Steve Christey and Robert A. Martin. Vulnerability type distributions in cve, \nMay 2007. URL http://cwe.mitre. org/documents/vuln-trends/index.html. Version 1.1. [11] Brian Demskyand \nMartin C. Rinard. Goal-directed reasoning for speci.cation-based data structure repair. TSE,32(12):931 \n951, December 2006. [12] GregDennis. ARelationalFramework for BoundedProgram Veri.cation. PhD thesis, \nMIT, 2009. Advised by Daniel Jackson. [13] EdsgarW. Dijkstra. Aconstructive approach to the problem of \nprogram correctness. BIT Numerical Mathematics, 8(3): 174 186, September 1968. [14] EdsgarW. Dijkstra. \nNotes on structured programming. In O.- J. Dahl, C.A.R. Hoare, and E.W. Dijkstra, editors, Structured \nProgramming. Academic Press,NewYork, 1972.  [15] Jonathan Edwards. Example centric programming. In Doug \nSchmidt, editor, Proc.19th OOPSLA, October 2004. [16] Jonathan Edwards. Subtext: Uncovering the simplicity \nof pro\u00adgramming. In RichardP. Gabriel, editor, Proc.20th OOPSLA, October 2005. ISBN 1-59593-031-0. [17] \nJonathan Edwards. No ifs, ands, or buts: Uncovering the simplicity of conditionals. In Proc.22nd OOPSLA,pages \n639 658, Montr\u00e9al, Canada, October 2007. [18]B. Elkarablieh,I. Garcia,Y.Suen,andS. Khurshid. Assertion\u00adbased \nrepair of complex data structures. In Alexander Egyed and Bernd Fischer, editors, Proc.22nd ASE, Atlanta, \nGA, November 2007. [19] Martin Fowler. Mocks aren t stubs, January 2007. URL http://martinfowler.com/articles/ \nmocksArentStubs.html. [20] Norbert E. Fuchs. Speci.cations are (preferably) executable. Software Engineering \nJournal, 7(5):323 334, September 1992. [21] Donald C. Gause and Gerald M. Weinberg. Exploring Re\u00adquirements. \nDorset House, 1989. [22] DorothyGraham. Requirements and testing: Seven missing\u00adlink myths. IEEE Software, \n19(5):15 17, 2002. [23] Ian Hayes and Cli. B. Jones. Speci.cations are not (necessar\u00adily) executable. \nSoftware EngineeringJournal, 4(6):330 338, 1989. ISSN 0268-6961. [24] E. Hehner. Do considered od: a \ncontribution to the program\u00adming calculus. Acta Informatica, 11:287 304, 1979. [25] C. A. R. Hoare. Proof \nof correctness of data representations. Acta Informatica, 1(4):271 281, December 1972. [26] C. A. R. \nHoare. An overview of some formal methods for program design. IEEE Computer, 20(9):85 91, 1987. [27] \nDaniel Jackson and JeanetteWing. Lightweight formal meth\u00adods. IEEE Computer, pages 21 22, April 1996. \n[28] Michael Jackson. Software Speci.cations and Requirements: a lexicon of practice, principles and \nprejudices. Addison-Wesley, 1995. ISBN 0-201-87712-0. [29] Cli.ord B. Jones. The early search for tractable \nways of reasoning about programs. IEEE Annals of the History of Computing, 25(2):26 49, 2003. [30] Donald \nE. Knuth. Notes on the van Emde Boas construc\u00adtion of priority deques: An instructive use of recursion. \nLet\u00adter to Peter van Emde Boas, March 1977. URL http:// www-cs-faculty.stanford.edu/~knuth/faq.html. \n[31] Ben Krause andTimWahls. jmle:A tool forexecuting jml speci.cations via constraint programming. In \nL. Brim, editor, Formal Methods for Industrial Critical Systems (FMICS 06), volume 4346 of LNCS, pages \n293 296. Springer-Verlag, Au\u00adgust 2006. [32] GaryT. Leavens, Albert L. Baker, and Clyde Ruby. Prelimi\u00adnary \ndesign of JML:Abehavioral interface speci.cation lan\u00adguage for Java. Technical Report 98-06u, Iowa State \nUniver\u00adsity, April 2003. URL http://www.jmlspecs.org. [33] Barbara Liskov and John Guttag. Abstraction \nand Speci.ca\u00adtion in Program Development. MIT Press, 1986. [34] Tim Mackinnon, Steve Freeman, and Philip \nCraig. Endo\u00adtesting: Unit testing with mock objects. In eXtreme Pro\u00adgramming and Flexible Processes in \nSoftware Engineering (XP2000), 2000. [35] Darko Marinov and Sarfraz Khurshid. TestEra: A Novel Framework \nfor Automated Testing of Java Programs. In Proc.16th ASE, pages 22 31, November 2001. [36] Robert C. \nMartin and Grigori Melnik. Tests and Require\u00adments, Requirements andTests:AM\u00f6bius Strip. IEEE Soft\u00adware, \n25(1):54 59, 2008. [37] Gerard Meszaros. xUnitTestPatterns: RefactoringTest Code. Addison-Wesley, 2007. \n[38] Carroll Morgan. The speci.cation statement. TOPLAS, 10(3), 1988. [39] Carroll Morgan. Programming \nfrom Speci.cations. Prentice-Hall, Inc., 2nd edition, 1998. First edition 1990. [40] J. Morris. Atheoretical \nbasis for stepwise re.nement and the programming calculus. Science of Computer Programming,9 (3), December \n1987. [41] Rick Mugridge and Ward Cunningham. Fit for Developing Software:Framework for IntegratedTests. \nPrentice-Hall, Inc., 2005. [42] Martin Odersky,Lex Spoon, and BillVenners. Programming in Scala. Artima, \nNovember 2008. [43] Committee on Certi.ably Dependable Software Systems, ed\u00aditor. Summary of aWorkshop \non Software Certi.cation and Dependability. The National Academies Press, 2004. ISBN 978-0-309-09429-0. \nURL http://books.nap.edu/ catalog.php?record_id=11133. [44] Derek Rayside,ZevBenjamin, Rishabh Singh, \nJosephP. Near, Aleksandar Milicevic, and Daniel Jackson. Equality and hash\u00ading for (almost) free: Generating \nimplementations from ab\u00adstraction functions. In Joanne Atlee andPaolaInverardi, edi\u00adtors, Proc.31st ICSE, \n2009. [45] Filippo Ricca, MarcoTorchiano, MassimilianoDi Penta,Mar\u00adiano Ceccato, andPaoloTonella. Using \nacceptance tests asa supportfor clarifying requirements:Aseriesofexperiments. Information and SoftwareTechnology, \n51(2):270 283, 2009. [46] MandanaVaziri, FrankTip, Stephen Fink, and Julian Dolby. Declarative object \nidentity using relation types. In Erik Ernst, editor, Proc.21st ECOOP, volume 4609 of LNCS, pages 54 \n78, Berlin, Germany, July 2007. Springer-Verlag. [47]TimWahls, GaryT. Leavens, and AlbertL. Baker. Execut\u00ading \nformal speci.cations with concurrent constraint program\u00adming. Automated Software EngineeringJournal, \n7:315 343, 2000. [48] NiklausWirth. Programdevelopmentby stepwise re.nement. CACM, 14(4):221 227, April \n1971. [49] Kuat Yessenov. A light-weight speci.cation language for bounded program veri.cation. Master \ns thesis, MIT, May 2009. Advised by Daniel Jackson.   \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Traditional formal methods and modern agile methods are separated more by limitations of current technology than by fundamental intellectual differences. A mixed interpreter that executes mixed programs, comprising both declarative specification statements and regular imperative statements, might bridge the gap. This paper explores how such an interpreter might be used, showing by example how it might support a variety of development activities.</p>", "authors": [{"name": "Derek Rayside", "author_profile_id": "81100031447", "affiliation": "MIT, Cambridge, MA, USA", "person_id": "P1728368", "email_address": "", "orcid_id": ""}, {"name": "Aleksandar Milicevic", "author_profile_id": "81330495596", "affiliation": "MIT, Cambridge, MA, USA", "person_id": "P1728369", "email_address": "", "orcid_id": ""}, {"name": "Kuat Yessenov", "author_profile_id": "81384615851", "affiliation": "MIT, Cambridge, MA, USA", "person_id": "P1728370", "email_address": "", "orcid_id": ""}, {"name": "Greg Dennis", "author_profile_id": "81100008640", "affiliation": "MIT, Cambridge, MA, USA", "person_id": "P1728371", "email_address": "", "orcid_id": ""}, {"name": "Daniel Jackson", "author_profile_id": "81406595262", "affiliation": "MIT, Cambridge, MA, USA", "person_id": "P1728372", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640070", "year": "2009", "article_id": "1640070", "conference": "OOPSLA", "title": "Agile specifications", "url": "http://dl.acm.org/citation.cfm?id=1640070"}