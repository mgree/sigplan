{"article_publication_date": "10-25-2009", "fulltext": "\n When Users Become Collaborators: Towards Continuous and Context-Aware User Input Walid Maalej Technische \nUniversit\u00a8unchen, Germany at M\u00a8 maalejw@in.tum.de Abstract Current requirements engineering practices \nfor gathering user input are characterized by a number of communication gaps between users and engineers \nwhich might lead to wrong requirements. The problem situations and context which un\u00adderlie user input \nare either gathered back in time, or submit\u00adted with wrong a level of details. We think that making user \ninput a .rst order concern of both software processes and software systems harbours many innovation opportunities. \nWe propose and discuss a continuous and context-aware ap\u00adproach for communicating user input to engineering \nteams and other users, by a) instrumenting the problem domain, b) proactively recommending to share feedback \nand c) annotat\u00ading graphical interfaces. Categories and Subject Descriptors D.2.1 [Software En\u00adgineering]: \nRequirements/Speci.cations General Terms Human Factors, Measurement Keywords user need, context, user \nfeedback, observation, recommendation 1. Introduction In modern product development, the input of the \nusers and their acceptance of the product are of high importance for market success [3, 24]. This holds \nespecially true for the software industry, which is characterized by rapid develop\u00adment cycles and a \nhigh competition. In software projects, user input receives enormous attention, e.g. through various \nactivities in requirements engineering, short feedback cycles in agile methodologies, or user focused \nevents such as user conferences or online forums. Surprisingly, there is no com\u00admon and comprehensive \ntheory of user input in software Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. Copyright c \n&#38;#169; 2009 ACM 978-1-60558-768-4/09/10. . . $10.00 Hans-J\u00a8org Happel, Asarnusch Rashid FZI Forschungszentrum \nInformatik, Germany {happel, rashid}@fzi.de engineering. While decently incorporated in software pro\u00adcesses, \nuser input and feedback mechanisms in software sys\u00adtems themselves are not standardized and thus rather \nad hoc if they exist at all. We argue that user input is a concern, which is currently highly fragmented \nbut harbours huge po\u00adtential for innovation. The .rst contribution of this paper is the alignment of \nseveral disjoint approaches, such as user need studies, pro\u00adtotype demonstration, bug reporting, enhancement \nrequests and the perpetual beta development style, towards the goal of a uni.ed model for user input. \nThe second contribution is the identi.cation of the technology as well as the process en\u00adablers, which \nserve as building blocks of such a model. We start by presenting the ingredients of our innovation which \nare a benchmarking of user input in software processes and software systems as well as various related \nwork (Section 2). We then present our model for continuous and context-aware user input (Section 3), \nits bene.ts and its technical building blocks (Section 4). Finally we discuss the main challenges for \nmaking user input a .rst order concern in software engi\u00adneering (Section 5) and conclude its complementary \nnature and potentials for innovation (Section 6). 2. The Ingredients Our innovation stems from analyzing \nand benchmarking ex\u00adisting approaches of gathering user input, as well as reusing results from previous \nresearch. These appear to be unrelated at a .rst glance, but are useful if extrapolated to the problem \nof ef.ciently getting useful user input. 2.1 Benchmarking of User Input Evaluating user needs is a subtle \nprocess, and even those companies with elaborate processes for gathering user input are not always successful \n[32, 23, 15]. The problem may lie in what information was accumulated, how it was gathered, how it was \nprocessed, or how it was translated into product requirements [2, 30]. No matter which part of the process \nis buggy , it is crucial that the engineering team understands the users needs [11, 32]. In other words, \nunderstanding the needs means identifying the pains of the users and answer\u00ading the question: why is \nthis pain a real pain?  In order to understand user pains, to identify and analyze user needs and to \nderive product requirements, engineers ex\u00adtensively communicate with the users and other stakehold\u00aders. \nIn practice, these communication activities differ, de\u00adpending on the concrete project setting, the project \nphase as well as the motivation of users to provide input. We distin\u00adguish between pull communication, \nif the feedback is pulled from the user and push communication, if it is pushed by the user. Furthermore, \nuser input might be explicit, if the user has the intent to provide the input, or implicit, if the user \nun\u00adintentionally provides input information. Figure 1 shows the different kinds of input. Figure 1. \nClassi.cation of User Input Pull Communication &#38; Explicit Feedback Requirements engineers typically \ngather explicit user input in a pull pro\u00adcess, when the stakeholders are collocated, enough budget and \nresources are available, development starts from scratch (green.eld engineering) or when the project \nand organi\u00adzation is customer-focused . In such communication pro\u00adcesses, requirements engineers may \nconduct face-to-face in\u00adterviews or workshops with users and other stakeholders. They may run surveys \nor write clari.cation requests. In all these activities users have the explicit intention to give in\u00adput \nabout their pains, needs, problem domains and the prod\u00aduct they wish to have. Collected data is retrospective \n i.e. the user input usually re.ects past working situations for which problem statements are speci.ed \nand modeled as a post facto construct. That is the time when problem situa\u00adtions and their context are \nencountered is different from the time when problem statements are communicated. Thus, the remembrance \nof users is the main medium for transferring knowledge about their needs. The retrospective nature of \nthese approaches and impact of human factors cause an inef.cient communication and misleading interpretation \nof user input. First, users often do not know exactly what they want. Also, they cannot always communicate \ntheir pains and needs in a clear and accurate way [32]. It is often dif.cult for them to remember, articulate \nand focus on exact problem situations, which should be solved by the target product. Users also forget \nor neglect context information that seems irrelevant to them, which however can be of a particular importance \nfor understanding their needs and engineering product requirements. For this reason, requirements engineers \ncannot always understand the problems in an ef.cient and effective way, leading either to a huge communication \noverhead or to the speci.cation of wrong requirements. Some approaches such as paper\u00adbased prototypes \n[27], contextual design [16] or software cinema [9] try to bring users in the real context by simulating \nthe problem situation and their work environment. These approaches seem to be accepted as a compromise \nby both users and engineering teams. However, required effort and resources are high, crucial details \nmight be forgotten or hidden in the simulated context and .nally, the simulation is initiated by the \nengineers based on particular assumptions which can be wrong. The impact of other human factors such \nas subjectivity, interpretation or social distinctions makes the understanding of user input more dif.cult \nand inef.cient. Push Communication &#38; Explicit Feedback An increas\u00ading number of development projects \ninvolve a distributed set of users and/or development teams. In many cases, a face-to-face communication \nbetween users and engineering teams is not possible due to physical distribution, cost or pol\u00adicy constraints. \nA large number of new requirements, issues and wishes are communicated explicitly and in a push fash\u00adion \nfrom users to engineers. Users actively request enhance\u00adments and changes or report issues, pains, needs \nand require\u00adments in emails, forums, ticket or groupware systems. In large open-source projects such \nas the development environ\u00adment Eclipse1 as well as in online applications with large user basis such \nas Twitter and YouTube, users request new features, propose ideas and enhancements, or vote for new proposed \nrequirements in a democratic process. This approach has three drawbacks. First, requests and re\u00adports \noften lack context information and cannot easily be un\u00adderstood by the engineering team. Bettenburg et. \nal showed that there is an obvious gap between what is considered to be useful information by reporter \nand by engineers [4]. Im\u00adprovements have been achieved by embedding interfaces for the submission of \nrequests into applications which allows for the automatic transmission of static context information \nsuch as operating system version or error stack traces as shown in Figure 2. However, major context such \nas the inter\u00adaction sequence required for problem reproduction still have to be assessed and described \nby users. What is considered to be relevant can also differ from one request to another. Second, the \ncommunication between users and requirements engineers is inef.cient. Requirements engineers typically \nre\u00adquest clari.cations and ask questions to better understand the exact situation and why the request \nwas issued. Inquiries and clari.cations are time-consuming and parties have to wait for each others responses. \nOften several iterations are 1 http://www.eclipse.org  necessary to clarify the actual issue. Third, \nan explicit feed\u00adback in a push communication requires considerable effort and motivation from users. \nIn order to be useful, user in\u00adput must be complemented by meaningful comments. Given users main concern \nis to accomplish their tasks and not to give feedback, they might either provide a low quality input \nor just avoid the submission. Figure 2. User feedback form of Subversive Pull Communication &#38; Implicit \nFeedback Software engi\u00adneers can get information about users and their needs by an\u00adalyzing the content \nof legacy documents. Although this in\u00adformation can be very useful, it is rarely suf.cient without further \ninput and clari.cations. A second interesting means for getting implicit feedback is based on the Web \n2.0 per\u00adpetual beta paradigm [25]. Here, engineers continuously modify the product and roll out new versions, \nincluding incremental feature updates. Typically, software providers such as Google roll out new features \nfor a limited set of users and decide upon actual usage data if to include it in the public main version. \nWhile this model originally emerged with web-based applications, it is also increasingly adopted by desktop \napplications. Software systems such as the web browser Mozilla Firefox or the development envi\u00adronment \nEclipse come with a modular plug-in architecture, which triggers automatic updates several times a week. \nOn the other side, these applications gather user feedback in terms of system usage data. Examples for \nsuch initiatives in\u00adclude the Eclipse Usage Data Collector Project2 (as shown in Figure 3), the Microsoft \nCustomer Experience Improvement Program3 and the Adobe Product Improvement Program4. 2 http://wwww.eclipse.org/epp/usagedata/index.php \n3 http://www.microsoft.com/products/ceip/EN-US/default.mspx 4 http://www.adobe.com/misc/apipfaq.html \n Figure 3. Eclipse Usage Data Collector However, these systems represent context-islands since they are \nvery speci.c in terms of collected context. Data de\u00adscribes exclusively the usage of a particular tool. \nIn addi\u00adtion, the input is machine-oriented and cannot be reviewed, commented and understood by users \nthemselves. Usage data is sent to a server where it is analyzed based on a .xed model. The approach does \nnot provide any back channels for resolving ambiguities and there is no semantic differen\u00adtiation between \nwhat is problematic and what is not. There\u00adfore, submitted data include a lot of noise and irrelevant \ninput. Finally, this input approaches are realized in a non\u00adstandardized manner and are not yet embedded \ninto software engineering processes. Push Communication &#38; Implicit Feedback In the .\u00adnal approach \nusers implicitly push feedback to engineer\u00ading teams. This happens if users are the active party in the \ncommunication (i.e. start the communication). But, unlike creating a ticket or participating in a survey, \nusers implic\u00aditly deliver useful input about the software product to the engineering team. The so-called \nlead users usually act this way. Lead users [31] are particular users that think in the feature and have \na high innovation potential as well as tech\u00adnical competence. Typically lead users adjust the product \nby themselves to their needs. Thus they implicitly give input to software engineers how to improve the \nsoftware system. This approach is common in product development in other sectors [20]. In the software \nsector the barriers that hinder a lead user to become a competitor are very low. This might explain why \nsuch approach is not common in this domain. When observed during their work, users can reveal use\u00adful \ninput. This can lead to a better understanding of their needs and identi.cation of new requirements. \nThe scienti.c observation method is commonly used in behavioral science as well as in software engineering \nresearch. However, it is not realistic in common software project settings due to the high-required resources. \n  2.2 Related Work This section lines out several streams of related work, which we consider useful \nto address the problems related to gath\u00adering user input. Context Frameworks Several attempts have been \ntaken to\u00adwards monitoring user interactions to achieve context aware\u00adness. We describe two systems, Mylyn \nand TeamWeaver, which both focus on the software engineering domain, where the users are software developers. \nMylyn [18] addresses the problem of information overload faced by developers in a single development \nenvironment, by using a degree of in\u00adterest model calculated from the previous modi.cation of a particular \ncode elements. Mylyn allows a developer to share task context which include a sequence of their in\u00adteractions \nwithin a particular task. This helps to reproduce the working context in collaborative activities as \nbug .xing. In TeamWeaver [22] we implemented a context elicitation and interpretation framework by instrumenting \nthe work en\u00advironment of developers, such as code editors, email pro\u00adgrams, web browsers and test tools. \nCollected context data is semantically rich, since it instantiates an interaction, or\u00adganization, artifact \nand domain model de.ned in a common ontology. Context data are used to trigger recommendations for sharing \nand accessing useful information, such as which documents include details on bug or how colleagues instan\u00adtiated \nthis objects in similar situations. Open Design Spaces The vision of Open Design Spaces [7] describes \nnew and innovative spaces for user participa\u00adtion, where people with different interests and cultural \nback\u00adgrounds can interact. The paradigms of Metadesign [13], Participatory Design [5] and Open Innovation \n[8] in mind, this kind of user participation aims to enable users to act as co-designers and .nd ways \nto support innovation and cre\u00adativity. Instances of Open Design Spaces are Living Labs, Boundary Objects \nand User Communities for Innovation. Living Labs are usually characterized by user-centric envi\u00adronments \nfor open innovation that support the early and con\u00adtinuous involvement of users [29]. Boundary objects \nare a concept originally introduced by Fischer [13] to refer to ob\u00adjects that serve an interface between \ndifferent communities of practice. Boundary objects are an entity shared by several different communities \nbut viewed or used differently by each of them. Community for Innovations [6] aims at support\u00ading software \ncompanies at every stage of its innovation pro\u00adcess. Acting via an Internet-platform, the community mem\u00adbers \ncan generate ideas and collaborate with other commu\u00adnity members. Each member of this community can submit \nideas, connect with idea contributors that submitted similar or complementary ideas, and elaborate ideas \nin collaboration with matched members. Continuous Coordination As between users and require\u00adments engineers, \nthe right degree of synchronization and feedback is crucial for distributed software development teams. \nAl-Ani, Trainer, Ripley et al. found out that current development models and tools either impose very \ntight (but therefore costly and probably infeasible) or a very loose (and therefore not ef.cient) coordination \npractices [1]. They sug\u00adgest continuous coordination as a concept describing the sweet spot of ef.cient \ncoordination. User Feedback Systems Different systems are designed to gather feedback directly from users \nworking environment. Many of them also include context capturing functionality discussed before. Primary \nexamples are the feedback mod\u00adules in applications such as Eclipse, Adobe Acrobat or Mi\u00adcrosoft products \n(see section 2.1). They provide a structured form and allow sending user input plus information about \nthe system environment to application developers. Other ap\u00adproaches are not application speci.c, but \nrather full-.edged applications for the desktop or within an application frame\u00adwork. Krahasanovic et \nal. [17] present a methodology and a tool to gather continuous user feedback for research pur\u00adposes. \nWith the tool, users can be regularly asked for explicit feedback, which is then sent to the researchers. \nEUREKA [21], a plug-in for the Eclipse environment serves a different purpose by providing users with \ninput .elds which can be triggered within certain time intervals (see Figure 4). The in\u00adput data, together \nwith automatically generated context data is then sent to a server back-end. These two approaches are \nintended as a replacement for or complement to classical di\u00adary or observational studies but easily \n.t the idea of a con\u00adtinuous requirements engineering and user input. Figure 4. Feedback form of the \nEclipse Subversive plug-in Infrastructure Probes [12] can be seen as an additional ethnographic method \nto get a deeper understanding of the user s working context and thus help to improve the collab\u00adoration \nbetween users and engineering teams. They consist of a screen-shot tool, a digital camera, Post-it s, \nforms, an IT diary and a writing pad, allowing users to observe and docu\u00adment their use of the IT infrastructure \nin question with spe\u00adcial emphasis on problematic situations. OpenProposal [28] is based on the fact \nthat in most software products the user requirements refer directly to the graphical user interface. \nBasically, the idea behind OpenProposal is to enable users to annotate suggestions for software improvements \ndirectly on the screen-shot of the running software application and to send this screen-shot to the project \ns issue tracker. Soft\u00adfox [19], a plug-in for the Mozilla Firefox Browser, enables users to give directly \nfeedback to the graphical elements of website and supports direct linking of user input to the appli\u00adcation \nstructure or underlying system models, in particular if a model-driven development approach is being \nused.  2.3 Summary We described four archetypical settings for communicat\u00ading and understanding user \ninput, by differentiating implicit vs. explicit feedback and push vs. pull communication. Ac\u00adtual real-world \nsettings might combine these aspects. How\u00adever, all settings share the following limitations: Wrong \nlevel of feedback (long feedback cycles and/or missing feedback channels).  Lack of semantically rich \ncontext information to under\u00adstand users input.  Low ef.ciency and effectiveness of communication be\u00adtween \nusers and engineering teams.  We argue that these limitations can be addressed in next gen\u00aderation software \nengineering processes and tools, by intro\u00adducing a continuous and context-aware model for gather\u00ading \nand understanding user input. Continuity converges push and pull communication, and results in a prospective \nuser in\u00adput, i.e. data is collected forth in time. Context-awareness en\u00adables a convergence of implicitness \nand explicitness of feed\u00adback. Users pains and the context would be continuously captured in the real \nusers work settings (time and space). A continuous and context-ware user input overlaps with the four \ndifferent approaches. This is highlighted by the central question mark in Figure 1. 3. A Continuous Feedback \nModel In this section we .rst describe a visionary scenario of con\u00adtinuous and context-aware user input. \nThen we introduce a process model, which makes user input a .rst order concern to both software processes \nand software systems. Finally we present new functions of feedback driven processes and .n\u00adish by discussing \nthe advantages of such an approach. 3.1 Scenario Bob works in the .nancial services sector. In order \nto get news from the stock exchange, Bob s team uses the tool Sys-Finance, an application which is developed \nby SysSME. One of Bob s major daily activities is to write and publish short news predicting the option \ntrends for the automotive sector. Once, Bob notices that a main part of this activity can be au\u00adtomated. \nBob always requests the parameter X in the same way from the service provider SysServe and then calculates \nthe predicted value based on an equation, creates a docu\u00adment with the same structure and includes the \ncalculated value and a short description. Bob switches in SysFinance to a feedback mode that has been \nobserving Bob s interaction and collecting context information. The system summarises the problem situation \nand the context in a human readable language. Bob adds comments and sends his feature request directly \nfrom SysFinance to the requirements engineers of SysSME. These engineers can now analyze the rich con\u00adtext \ninformation and systematically compare it to the context of other users.  3.2 Process Classical software \ndevelopment and maintenance processes are characterized by several gaps. In the horizontal di\u00admension, \nthere exist gaps between users and the engineering team. Examples are the actual distribution of the \nbinary soft\u00adware product, which is broken due to download and installa\u00adtion. This gap is resolved for \nweb-based applications which do not require to install client-side software, and partially addressed \nfor modular desktop applications which receive incremental updates via the Internet. Similarly, a gap \nexists at the dimension of pushing explicit user feedback. Usually, users have to switch between different \nmedia such as emails or web pages to submit their requests. Only few approaches try to reduce this gap \nby e.g. embedding feedback channels in their application (c.f. Section 2.1). In the vertical dimensions, \ngaps exist between the var\u00adious interaction streams among users and the engineering team. For example, \nthe actual runtime version of the soft\u00adware and the explicit needs of users are only very loosely integrated \nby version numbers or release notes of the actual software. Thus it is e.g. hard for users to track the \nprogress and results of their inquiries. A related gap exists among the community of users of an application. \nWhile user-to-user assistance has become com\u00admon in many ways (e.g. real world user group meetings or \nuser assistance on the mailing-list of open source projects) the typical interaction channels are designed \nbetween indi\u00advidual users and the engineering team. This explains why user-to-user communication typically \nhappens in external in\u00adformation spaces, which are only loosely coupled with the other interaction streams. \nWe argue that these gaps make the overall software devel\u00adopment process less ef.cient and in particular \nmake it dif.\u00adcult for users to articulate their needs and contribute to var\u00adious aspects of development \nand maintenance. On the other hand, developers have a dif.cult time to monitor heteroge\u00adneous interaction \nstreams and to carry out actual work with their limited resources. Figure 5 depicts a visionary process \nof feedback driven development , where these gaps are reduced by continu\u00adous, integrated interaction \nstreams. User input is formulated within a concrete software environment, which allows to seamlessly \nand more precisely communicate feedback into the development process. The engineering team can then analyze, \nconsolidate and consider the input, make clari.ca\u00ad  Figure 5. Feedback Driven Development tion requests \nand implement actual modi.cations. These are again propagated into the users runtime system, providing \nfeedback on the improved version, starting the cycle again. Complementary to this, users can collaboratively \nengage in discussing requests but also in sharing know how. In the fol\u00adlowing section we identify and \ndiscuss a set of speci.c func\u00adtions in this process.  3.3 Process Functions Prospective Observation \nThe context in which user re\u00adquirements have emerged is captured and included com\u00admunication threads. \nUsers can continuously, ef.ciently and intuitively communicate issues, requirements and change re\u00adquests \nfrom the working environment. The communication and understanding of the requirements become a prospec\u00adtive, \nasynchronous process. Thereby the main assumption is that users always have changing needs and new require\u00adments, \nand that applications iteratively grow in functionality. Assisted Feedback The application automatically \nrecog\u00adnizes the problem situations by observing repetitive patterns in the users interactions (e.g., \nIteration in the navigation or long times to execute a certain activity). Users are proac\u00adtively asked \nto communicate their input and feedback to the application engineers. Similar to the detection of typi\u00adcal \nproblem situations, feedback data might be leveraged to analyze for common patterns in application work.ows. \nCommunity Sharing Users themselves can form commu\u00adnities on application usage or even about usage of \ncertain features. In these communities users exchange experiences and evaluate or comment features. Users \nget proactive sug\u00adgestions in problem situations, what they should do and what other users have done \nin similar context. The application can also suggest other users with similar usage behavior, prob\u00adlems \nor particular pains. Back-Feedback (Integrated Intelligent Help-desk) By observing and comparing user \ninteractions, the application learns how certain problems are solved by which features. New users are \nsupported by pro-active How-To sugges\u00adtions in problem situations. The work.ows which can lead to solution \nof the problem are suggested. Also, users interac\u00adtion data can be analyzed to identify most valuable \nfeatures which would require the most extensive documentation.  3.4 Advantages A prospective and context-aware \nrequirements engineering approach would offer advantages to users as well as to ap\u00adplication vendors. \nUsers can send feedback to the applica\u00adtion manufacturers at any time without much additional ef\u00adfort. \nThis feedback can be new requirements, semantic mis\u00adtakes or enhancements requests. A context switch \nto write an email or to participate on a requirements elicitation meet\u00ading is no longer necessary with \nthe same frequency as in current processes. Application vendors and engineering teams have con\u00adcrete \nand formal instantiations of the problems that should be addressed by the new features. Distributed, \nasynchronous requirement speci.cation becomes more ef.cient and less error-prone. Risks resulting from \nhuman factors are mini\u00admized. Applications grow faster and more purposeful. 4. Technical Building Blocks \nWe discuss the major enablers for our prospective, continu\u00adous user input model. 4.1 Context Awareness \nContext-awareness is the aggregation of the domain instru\u00admentation and the interpretation of automatically \ncollected context information. Context Elicitation In order to collect context informa\u00adtion from users \non runtime , their domain and work envi\u00adronment need to be instrumented. If users perform most of their \nactivities on computer systems (most knowledge work\u00aders such as engineers, online traders or people working \nin a back-of.ce belong to this group) this is feasible. Context elicitation can be realized by using \napplication frameworks such as the Eclipse Rich Client Platform or the Apple Co\u00adcoa Framework. These \nframeworks offer common interfaces for user interface events, independently from the application. It \nis possible to collect user interaction and sense particular context properties such as how long the \nuser has been read\u00ading or editing a particular document or which information she was searching for. Another \nalternative is to use program tracing tools (such as dtrace5 or systemTap6) to sense con\u00adtext such as \nparticular actions or relations from the system. Apart from the ef.ciency of the instrumentation, one \nma\u00adjor challenge is to aggregate, .lter and interpret the context 5 http://www.sun.com/bigadmin/content/dtrace/ \n6 http://sourceware.org/systemtap/  and render it in both human but also machine readable form (for \nthe requirements engineers and for systematic analysis and comparison with other contexts). We propose \nstatistical means and semantic technology to solve this issue. Context Interpretation Prospective and \ncontinuous gath\u00adering of user input is tightly related to behavioral research. By conducting empirical \nstudies, behavioral researchers dis\u00adcover behavioral patterns, correlations and causality. They construct \nhypothesis and test them using methodological and statistical instruments. In prospective user input \ncer\u00adtain contextual factors for concrete working situations need to be identi.ed and prioritized, analogously \nto behavioral research. These studies result in a standard catalog for heuristics that can be used to \npredict problem situations or the intents of the users. In addition, it is essential to detect the switching \nof user intents (i.e. from of a working situa\u00adtion to an other). This behavior can be examined empirically \nand form the basis of the recognition of context change. Our main assumption is that knowledge workers \nperform their activities following a problem-solving cycle. The mental sta\u00adtus of getting in a problem \nsituations can be recognized by using heuristics. Then the status getting a solution is also recognized \nor given by the user explicitly.  4.2 Visual Annotation The literature about Digital Annotation states \nthat annota\u00adtions are not only useful because they support such crucial mental functions as remembering, \nclarifying and sharing. Annotations do also provide a communication artifact and are important for a \ntwo-way information exchange, as dis\u00adcussed by Fogli et al. [10]. Considering annotations in proto\u00adtyping \nNaghsh ([26] p. 93) summarizes: Current annotation research falls into two categories, either presenting \nproto\u00adtype applications for annotating text documents or research on how and why readers annotate paper \ntexts. Despite the fact that the importance of annotation has been realized in the design process as \na support for discussion and communi\u00adcation around prototypes little has been done in understand\u00ading \nhow and why stakeholders annotate prototypes. There is a bunch of snapshot tools, most of them available \nfree to download or already integrated into graphics software. The snapshot tool Annotate Pro7, for example, \nprovides several functions to draw annotations directly on the users screen by using snapshots in combination \nwith ordinary picture editing functionality. This enables users to draw comments on their active applications, \nwithout time-consuming train\u00adings and preparations. The commented snapshots serve as requirement speci.cation \nand can easily be sent to the en\u00adgineering team by email. It is important that such annota\u00adtion tools \nprovide a simple annotation method, and a for\u00admal notation language since there does not exist any com\u00admon \nlanguage either which means that users are free to paint sketches and to send them to anyone without \nassistance. It 7 http://www.annotatepro.com/ is assumed that developers may have dif.culties in under\u00adstanding \nthese paintings. Furthermore, there is no possibil\u00adity for users to track the submitted requirements. \nThe Open-Proposal research [28] has shown that users prefer an easy way to submit feedback. To obtain \nclear and traceable state\u00adments and more understandable and concrete suggestions, users need formal structures \nto express their ideas. Further, submitted issues should be stored in a collaborative environ\u00adment providing \nall participants access to the issues, as users wish tracking their issues and observing the further \nprocess\u00ading of their feedback. OpenProposal provides such a solu\u00adtion.  4.3 Proactive Assistance Proactive \nassistance [14] has a twofold role in our approach. First, assistance in the sense of an information \naccess helps to raise awareness in the development ecosystem by notifying the actors involved about new \ninformation which might be relevant for them. As an example, users initiat\u00ading a modi.cation request \nmight be noti.ed if a new ver\u00adsion implemented this desired feature, or others are using a workaround. \nFurthermore, assistance can act as an infor\u00admation sharing service, which asks actors to provide cer\u00adtain \ninput. Fellow users with similar usage patterns can be, e.g., asked to rate a modi.cation request. Also, \nsuch service could guide people to extend help information based on data about user problems. Stepping \nback from the raw implemen\u00adtation level, proactive assistance could also help on the level of business \nprocesses which are supported by the software. Based on the analysis of usage patterns, best practices \nin terms of work.ows or the usage of software features could be recommended to fellow users. In order \nto realize such scenarios, a .exible and power\u00adful data model is required. Most collected context data \nis represented in a traditional, machine-oriented format, using hard-coded heuristics. A more .exible \nknowledge represen\u00adtation, e.g. based on Semantic Web technologies, will not only improve the possibilities \nto integrate and share addi\u00adtional information, but also help to make collected context more transparent \n e.g. by providing a human readable sum\u00admary for users, requirements engineers and other stakehold\u00aders. \nBased on semantic representation of the information and the interactions, context can be de.ned, re.ned \nand com\u00adpared more precisely. Semantic technologies also enable the de.nition of interaction, context \nand product meta models independently from concrete domains. 5. Challenges and Limitations Privacy In \norder to support an effective communication of user needs and to share and access knowledge around us\u00adage, \npains, requirements enhancements, sensitive data such as interaction history and private documents has \nto be trig\u00adgered and processed. Collecting context information raises questions about privacy and control. \nThe challenge is there\u00adfore to use the sensitive information and still ensure that it will not be abused. \nBy doing so, usability trade-offs might emerge (e.g. the user is asked to con.rm particular opera\u00adtions). \nWe believe that researchers have to give more atten\u00adtion to privacy issues. Privacy can be protected \nby keeping context information private by default, but pro-actively rec\u00adommending to share information \nif it would be helpful for the engineering team or fellow users. We argue that privacy is tightly related \nto research in software engineering ethics. So far there is little knowledge in this .eld.  Filtering \nBy continuous user involvement it is expected that the communication frequency between users, engineer\u00ading \nteam and fellow users rises. This means that require\u00adments engineers and developers need to be prepared \nand ap\u00adpreciate continuous user feedback. Requirements engineers and developers should try to better \ncoordinate their activi\u00adties, as developers could be over-strained. One way is that requirements engineer \n.lter and prioritize users feedback. Intrusiveness It is important to stress that the primarily role \nof users is to use the system to solve their tasks and not to develop and maintain it. Thus, a major \nchallenge for a continuous and context-aware user input model is of not be\u00ading intrusive to users. It \nis crucial that the applications which integrate a continuous user input functionality assess if the \nsituation is appropriate to recommend users to share their input. The diversity of the users, their preferences \nand their priorities makes this task even harder. Continuous user input must be therefore personalized \nto be acceptable. One person\u00adalization criteria is the experience level and general feedback attitude \nof users. In addition, the integration of user input in the work.ow in an intuitive way also requires \nresearch, in\u00adnovation as well as standardization in interfaces of human machine communication. 6. Conclusion \nUser input is crucial for realizing successful software appli\u00adcations. In this paper, we have surveyed \nthe state of the art concerning the elicitation of user input. We argued that there is currently no uni.ed \nmodel of user input which leads to a number of gaps and inef.ciencies throughout the devel\u00adopment process. \nWe therefore proposed an alternative devel\u00adopment process with a number of process functions which enable \nusers to become prosumers instead of mere con\u00adsumers of software applications and engineering teams to \nreceive more continuous, direct and rich input for applica\u00adtion development. We think that considering \nuser input a .rst order con\u00adcern should also be re.ected in software architectures. Ex\u00adisting features \nsuch as modular plug-in architectures with incremental auto-updates as well as feedback-and error\u00adreporting \ndialogs should be consolidated into a standardized module. To this end, we proposed various complementary \nfeatures such as context-elicitation frameworks, visual an\u00adnotation and proactive assistance technology. \nWhile our presentation is in parts visionary and not yet realized in a real world scenario, we believe \nthat these ideas are feasible since they are based on the integration of exist\u00ading approaches. However, \none of our main intentions is to spark discussion towards the consideration of user input as a .rst order \nconcern in development processes and application architectures. With respect to this, we do not propose \nto rev\u00adolutionary dismiss existing practices, but to use our proposed approach to complements existing \nones. Acknowledgments This work has been supported in part by the TEAM project (funded by the EU-IST \nprogramme under grant FP6-35111), the THESEUS project (funded by the German Federal Min\u00adistry of Economics \n(BMWi) under grant 01MQ07019) and the GlobaliSE project (funded by the Landesstiftung Baden-W\u00a8 urttemberg \nfoundation). References [1] Ban Al-Ani and Trainer et. al. Continuous coordination within the context \nof cooperative and human aspects of software engineering. In Int. workshop on Cooperative and human aspects \nof software engineering, New York, NY, USA, 2008. ACM. [2] C. M. Axtell, P. E. Waterson, and C. W. Clegg. \nProblems integrating user participation into software development. Int. J. Hum.-Comput. Stud., 47(2):323 \n345, 1997. [3] H. Barki and J. Hartwick. User participation and user in\u00advolvement in information system \ndevelopment. In 24. Annual Hawaii International Conference on System Sciences, Hawaii, USA, 1991. [4] \nNicolas Bettenburg, Sascha Just, Adrian Schr\u00a8oter, Cathrin Weiss, Rahul Premraj, and Thomas Zimmermann. \nWhat makes a good bug report? In Proceedings of the 16th Inter\u00adnational Symposium on Foundations of Software \nEngineering, November 2008. [5] S. B\u00f8dker. Creating conditions for participation: Con.icts and resources \nin systems design. Human Computer Interaction, 1996. [6] Ulrich Bretschneider, Michael Huber, Jan Marco \nLeimeister, and Helmut Krcmar. : Community for innovations: Develop\u00ading an integrated concept for open \ninnovation. Open IT-Based Innovation, pages 503 510, 2008. [7] Steffen Budweg, Sebastian Draxler, Steffen \nLohmann, Asar\u00adnusch Rashid, and Gunnar Stevens, editors. Open Design Spaces Supporting User Innovation \n-Proceedings of the In\u00adternational Workshop on Open Design Spaces (ODS 09), vol\u00adume 6. IISI -International \nInstitute for Socio-Informatics, 2009. [8] H. Chesbrough. Open Innovation. Havard Business School Press, \n2003. [9] Oliver Creighton, Martin Ott, and Bernd Br\u00a8Software ugge. cinema-video-based requirements engineering. \nIn Interna\u00adtional Conference on Requirements Engineering, pages 106 115. IEEE, 2006.  [10] G. Fresta \nD. Fogli and P. Mussio. On electronic annotation and its implementation. In AVI 2004. [11] RJ Dolan. \nManaging the new product development process. Addison-Wesley, 1993. [12] C. D\u00a8orne, J. He\u00df, and V. Pipek. \nFostering user-developer col\u00adlaboration with infrastructure probes. In International work\u00adshop on cooperative \nand human aspects of software engineer\u00ading. ACM, 2008. [13] Gerhard Fischer. Meta-design: Beyond user-centered \nand par\u00adticipatory design. In Julie A. Jacko and Constantine Stephani\u00addis, editors, Human-computer Interaction: \nTheory and Prac\u00adtice. 2003. [14] Hans-J\u00a8org Happel and Walid Maalej. Potentials and chal\u00adlenges of recommendation \nsystems for software development. In RSSE 08: Proceedings of the 2008 international workshop on Recommendation \nsystems for software engineering. ACM, 2008. [15] T. Heinbokel, S. Sonnentag, M. Frese, W. Stolte, and \nF.C. Brodbeck. Don t underestimate the problems of user cen\u00adtredness in software development projects \n-there are many! Behaviour &#38; Information Technology, 15(4):226 236, 1996. [16] K. Holtzblatt and \nH.R. Beyer. Contextual design: using cus\u00adtomer work models to drive systems design. In CHI 99, Pitts\u00adburgh, \nPennsylvania, 1999. ACM. [17] Amela Karahasanovic, Bente Cecilie Dahlum Anda, Erik Ar\u00adisholm, Siw Elisabeth \nHove, Magne J\u00f8rgensen, Dag I. K Sj\u00f8berg, and Ray Welland. Collecting feedback during soft\u00adware engineering \nexperiments. Empirical Software Engineer\u00ading, 10(2):113 147, 2005. [18] Mik Kersten and Gail C. Murphy. \nUsing task context to improve programmer productivity. In Proceedings of the 14th ACM SIGSOFT international \nsymposium on Foundations of software engineering, pages 1 11, New York, NY, USA, 2006. ACM. [19] S. Lohmann, \nJ. Ziegler, and P. Heim. In engineering interac\u00adtive systems 2008. In LNCS 5247, 2008. [20] Christian \nL\u00a8uthje and Cornelius Herstatt. The lead user method: An outline of empirical .ndings and issues for \nfuture research. R&#38;D Management, 2004. [21] Walid Maalej and Hans-Joerg Happel. From work to word: \nHow do software developers describe their work? In 6th IEEE International Working Conference on Mining \nSoftware Repositories, 2009. [22] Walid Maalej and Hans-J\u00a8org Happel. A lightweight approach for knowledge \nsharing in distributed software teams. In 7th International Conference on Practical Aspects of Knowledge \nManagement, Lecture Notes in Computer Science. Springer, 2008. [23] Ellen Stein Marco Iansiti. Understanding \nuser needs. Harvard Business Publishing, 1995. [24] J.D. McKeen and T. Guimaraes. Succesful strategies \nfor user participation in system development. Behaviour &#38; Informa\u00adtion Technology, 14(2), 1997. [25] \nJohn Musser and Tim O Reilly. Web 2.0 principles and best practices. an o reilly radar report., 12 2006. \n[26] A.M. Naghsh, A. Dearden, and M.B. Ozcan. Investigating an\u00adnotation in electronic paper-prototypes. \nIn Int. Workshop on Design, Speci.cation and Veri.cation of Interactive Systems, 2005. [27] Jakob Nielsen. \nPaper versus computer implementations as mockup scenarios for heuristic evaluation. In INTERACT 90: Proceedings \nof the IFIP TC13 Third Interational Conference on Human-Computer Interaction, pages 315 320, Amster\u00addam, \nThe Netherlands, The Netherlands, 1990. North-Holland Publishing Co. [28] Asarnusch Rashid, Jan Wiesenberger, \nDavid Meder, and Jan Baumann. Bringing developers and users closer together: The openproposal story. \nIn Multikonferenz Wirtschaftsinformatik, 2008. [29] H. Schaffers, M. Guerrero Cordoba, P. Hongisto, T. \nKallai, C. Merz, and J. van Rensburg. Exploring business models for open innovation in rural living labs \n. In 13th International Conference on Concurrent Enterprising, 2007. [30] Gillian Symon. The work of \nit system developers in con\u00adtext: an organizational case study. Hum.-Comput. Interact., 13(1):37 71, \n1998. [31] Stefan Thomke and Ashok Nimgade. Note on lead user research. Harvard Business Online, 1998. \n[32] Karl T. Ulrich and Steven D. Eppinger. Product Design and Development. McGraw-Hill, 2007.   \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Current requirements engineering practices for gathering user input are characterized by a number of communication gaps between users and engineers, which might lead to wrong requirements. The problem situations and context which underlie user input are either gathered back in time, or submitted with wrong a level of details. We think that making user input a first order concern of both software processes and software systems harbours many innovation opportunities. We propose and discuss a continuous and context-aware approach for communicating user input to engineering teams and other users, by a) instrumenting the problem domain, b) proactively recommending to share feedback and c) annotating graphical interfaces.</p>", "authors": [{"name": "Walid Maalej", "author_profile_id": "81384617491", "affiliation": "Technische Universit&#228;t M&#252;nchen, Munich, Germany", "person_id": "P1728363", "email_address": "", "orcid_id": ""}, {"name": "Hans-J&#246;rg Happel", "author_profile_id": "81350595962", "affiliation": "FZI Forschungszentrum Informatik, Karlsruhe, Germany", "person_id": "P1728364", "email_address": "", "orcid_id": ""}, {"name": "Asarnusch Rashid", "author_profile_id": "81461647897", "affiliation": "FZI Forschungszentrum Informatik, Karlsruhe, Germany", "person_id": "P1728365", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640068", "year": "2009", "article_id": "1640068", "conference": "OOPSLA", "title": "When users become collaborators: towards continuous and context-aware user input", "url": "http://dl.acm.org/citation.cfm?id=1640068"}