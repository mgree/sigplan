{"article_publication_date": "10-25-2009", "fulltext": "\n Enhancing Source-Level Programming Tools with An Awareness of Transparent Program Transformations Myoungkyu \nSong and Eli Tilevich Dept. of Computer Science Virginia Tech, Blacksburg, VA 24061, USA {mksong,tilevich}@cs.vt.edu \nAbstract Programs written in managed languages are compiled to a platform-independent intermediate representation, \nsuch as Java bytecode. The relative high level of Java bytecode has engendered a widespread practice \nof changing the bytecode directly, without modifying the maintained version of the source code. This \npractice, called bytecode engineering or enhancement, has become indispensable in transparently in\u00adtroducing \nvarious concerns, including persistence, distribu\u00adtion, and security. For example, transparent persistence \nar\u00adchitectures help avoid the entanglement of business and per\u00adsistence logic in the source code by changing \nthe bytecode directly to synchronize objects with stable storage. With functionality added directly at \nthe bytecode level, the source code re.ects only partial semantics of the program. Specif\u00adically, the \nprogrammer can neither ascertain the program s runtime behavior by browsing its source code, nor map \nthe runtime behavior back to the original source code. This paper presents an approach that improves \nthe utility of source-level programming tools by providing enhance\u00adment speci.cations written in a domain-speci.c \nlanguage. By interpreting the speci.cations, a source-level program\u00adming tool can gain an awareness of \nthe bytecode enhance\u00adments and improve its precision and usability. We demon\u00adstrate the applicability \nof our approach by making a source code editor and a symbolic debugger enhancements-aware. Categories \nand Subject Descriptors D.2.3 [Software En\u00adgineering]: Coding Tools and Techniques Program editors; D.2.5 \n[Software Engineering]: Testing and Debugging debugging aids, tracing; D.3.4 [Programming Languages]: \nProcessors debuggers, interpreters Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. Copyright c \n&#38;#169; 2009 ACM 978-1-60558-734-9/09/10. . . $5.00 General Terms Languages, Design, Experimentation \nKeywords Domain-speci.c languages, enhancement, pro\u00adgram transformation, bytecode engineering, debugging \n1. Introduction Managed languages, including Java and C#, reduce the com\u00adplexity of software construction \nby providing portability, type safety, and automated memory management. A Gartner report predicts that \nby 2010, as much as 80% of new soft\u00adware will be written in C# or Java [18]. Another reason for the widespread \npopularity of managed languages is that they feature multiple standard libraries and portable frameworks, \nwhose use improves programmer productivity. In fact, it has been observed that the third-party libraries \nand frameworks of a typical commercial enterprise application commonly constitute the majority of the \ncodebase [13]. Object-oriented frameworks have become an integral part of enterprise software development, \nas their reusable de\u00adsigns and prede.ned architectures streamline the software construction process. \nA major draw of modern enterprise frameworks is that the developer can write business logic components \nusing a Plain Old Object Model (e.g., Plain Old Java Objects (POJOs) and Plain Old Common Lan\u00adguage Runtime \nObjects (POCOs)), business-level applica\u00adtion objects that do not implement special interfaces or call \nframework API methods. Among Plain Old Object Models, POJO-based frameworks have become mainstream in \nthe en\u00adterprise computing community, as they improve separation of concerns, speed up development, and \nimprove portabil\u00adity [37]. To provide services to application objects, a framework employs bytecode engineering \nto enhance their intermediate representation (i.e, bytecode or CLR), commonly at runtime. Figure 1 demonstrates \nthe main steps of such framework\u00ad based development. First, the source code is compiled to an intermediate \nrepresentation. Then an enhancer uses byte\u00adcode engineering [11] to add new functionality to the com\u00ad \npiled bytecode as guided by the corresponding custom meta\u00addata. Each framework uses different metadata \nformats, com\u00admonly expressed using XML .les or Java 5 annotations, to  Figure 1. Enhancing intermediate \ncode via bytecode engineering. mark framework-related program constructs. Further, the en\u00adhancer can \nrun as a separate tool or be integrated with a class loader. Finally, the enhanced bytecode, which differs \nin functionality from the original source code, is executed by the framework. Although intermediate code \nenhancement has entered the mainstream of enterprise software development due to the widespread use of \nframeworks, no standard technique has been introduced to capture and document the enhance\u00adments. Metadata \nguiding the enhancement process not only is custom for each framework, but also speci.es what pro\u00adgram \nconstructs are relevant for a particular framework (e.g., which .elds are persistent) rather than how \nthe intermediate code should be enhanced. As a result, the enhancements are, at best, documented through \nan informal narrative (i.e., documentation) or treated as a black box. Lacking any formal description \nof bytecode enhance\u00adments, source code does not faithfully re.ect the full se\u00admantics of an enhanced \nprogram. For source-level program\u00adming tools, this inability to express all the functionality of a program \nin source code leads to reducing the utility of those programming tools that rely on the one-to-one corre\u00adspondence \nbetween the running version of a program and its source-level representation. The presence of bytecode \nen\u00adhancements not only hinders the ability to understand the real behavior of a program by browsing its \nsource code, but also makes it non-trivial to map the execution of a program to its source code. The \nprogrammer may need to understand the observed behavior of a program, while relating the ob\u00adserved behavior \nof the enhanced intermediate code back to the original source and vice versa. Although optimizing compilers \nhave long changed inter\u00admediate representations to improve performance, the tech\u00adniques developed for \ndealing with such optimized code (i.e., debugging optimized code) are unsuitable for dealing with enhanced \nbytecode. While optimizations are always semantics-preserving transformations (sometimes under cer\u00adtain \ninput), enhancements change the semantics of a program in custom and dif.cult-to-generalize ways. The \noptional Java class .le s attribute LineNumberTable provides little value as a mechanism for mapping \nenhanced bytecode to the original source code. An enhancer cannot adjust the LineNumberTable of an enhanced \nclass, as the enhancements are expressed only in bytecode and have no representation in source code. \nEven though Aspect Oriented Programming (AOP) [25] is often used for introducing crosscutting concerns, \nthe AOP languages such as AspectJ [24] do not capture all the en\u00ad hancements commonly introduced directly \nat the bytecode level, which include changing program construct names, re\u00admoving program constructs, \nand generating new classes. This paper presents an approach that improves the util\u00adity and precision \nof source-level programming tools by cap\u00adturing and documenting bytecode enhancements. First, we have \nclassi.ed commonly-used bytecode enhancements by examining the API of two widely-used bytecode engineer\u00ading \ntoolkits and by reverse-engineering the enhancements performed by two commercial enterprise frameworks. \nBased on our classi.cation, we have created a declarative, domain\u00adspeci.c language for describing bytecode \nenhancements. To demonstrate the expressiveness of our language, we used it to describe the enhancements \nperformed by several indus\u00adtrial and research systems that use bytecode engineering. Fi\u00adnally, we have \nused our approach to make a source code ed\u00aditor and a symbolic debugger enhancement-aware, thereby improving \ntheir precision and utility. This paper makes the following contributions: A novel approach to improving \nthe precision and utility of source-level programming tools in the presence of intermediate code enhancements. \n The Structural Enhancement Rule (SER) language, a Domain-Speci.c Language (DSL) for concisely ex\u00adpressing \nstructural enhancements that modern enterprise frameworks commonly apply to intermediate code.  A debugging \narchitecture that enables symbolic debug\u00adging of programs whose intermediate code has been transparently \nenhanced.   The rest of this paper is structured as follows. Section 2 provides a background for this \nwork, demonstrating how intermediate code enhancement is used in implementing a commercial persistence \narchitecture. Section 3 presents our approach to expressing and leveraging intermediate code en\u00adhancement \ninformation. Section 4 re.ects on our experi\u00ad ences of implementing and evaluating two enhancements\u00adaware \nprogramming tools: a code editor and a symbolic de\u00adbugger. Section 5 compares our approach with the existing \nstate of the art. Section 6 discusses future work directions, and Section 7 presents concluding remarks. \n2. Background In modern enterprise software development, the program\u00admer expresses business logic components \nusing application classes that do not inherit from special framework types or have any other functionality \nbesides business logic. Then ex\u00adtra functionality is added to the intermediate code1 of the application \nclasses via bytecode enhancement to enable en\u00adterprise frameworks to provide services, thereby implement\u00ading \nvarious (usually non-functional) concerns, including per\u00adsistence, transactions, and security. This development \nmodel relieves the programmer from the burden of having to im\u00adplement these important concerns by hand. \nThe programmer simply uses metadata (such as XML .les or Java 5 annota\u00adtions) to designate speci.c application \nobjects as interacting with a framework, and all the tedious details of enabling the interaction happen \nentirely behind the scenes. Despite the convenience afforded by the use of such intermediate code enhancement, \nas we demonstrate next, its use compromises the utility and precision of source-level programming tools. \n2.1 Transparent Persistence Frameworks The following example comes from the domain of transpar\u00adent persistence, \nwhich is used by several persistence frame\u00adworks in industrial software development, including Hiber\u00adnate \n[6] and JDO [38]. A transparent persistence architecture combines features of both orthogonally persistent \nlanguages [5, 29, 30, 4] and data access libraries, such as Java Database Connectivity (JDBC)[45] and \nOpen Database Connectivity (ODBC)[31]. When program data outlives the program s execution, the data is \nsaid to be persistent. Transparent persistence architectures provide a software framework for managing \nthe program data marked as persistent by the programmer. The management entails synchronizing the persistent \ndata and its stable storage representation. A representative of a transparent persistence infrastruc\u00adture \nfor Java is Java Data Objects (JDO) [38]. JDO uses static post-compile enhancement to enable Java objects \nwith persistence capabilities. The programmer writes Java ob\u00adjects to be persisted as regular Java Beans \n[44]. A sepa\u00ad 1 In the rest of the manuscript, we use the terms intermediate code and bytecode interchangeably. \nrate JDO meta.le (in XML) speci.es which .elds of a class should be persisted and how they map to stable \nstorage. Fi\u00adnally, as speci.ed by the metadata, the JDO enhancer adds persistence-speci.c methods and \n.elds to each persistent class, enabling its instances to interact with the JDO run\u00adtime. In particular, \nthe enhancer changes a persistent class to implement interface PersistenceCapable and wraps all read \nand write accesses to a persistent .eld with special methods that interact with the JDO runtime. Thus, \nbefore the value of a persistent .eld is retrieved or modi.ed, an appropri\u00adate JDO-speci.c action is \ntriggered, thereby ensuring that a fresh copy of the data is retrieved from stable storage and all the \nchanges in the application space are properly persisted. The design of JDO satis.es the stated goal of \nintroduc\u00ading persistent capabilities transparently. JDO enables rank and .le programmers to focus on \nwhat data is being per\u00adsisted and treating how the data is persisted as a black box. Enterprise programmers \nmay be aware that some bytecode enhancement is taking place, but the speci.c enhancements are not relevant \nto their primary concern expressing the re\u00adquired business logic.  2.2 Example: Mortgage Authorization \nApplication Consider a mortgage authorization application used by a bank to calculate the maximum amount \nof mortgage eligi\u00adbility, according to a set of business rules that use a cus\u00adtomer s salary and credit \nscore. The application uses sev\u00aderal transparently persistent classes, including SalaryLevel and CreditLevel \n, whose objects are persisted in a relational database such as MySQL or Oracle using the JDO frame\u00adwork. \nConsider the code listing in Figure 2, showing a method displayMaxMortgageEligibility. The method displays \nthe amount of maximum mortgage eligibility given a dis\u00adplay object and a projected salary increase amount. \nAs is usually the case, the method manipulates different concerns of the application: business logic \nand graphical user inter\u00adface. Assume that the GUI part of the method contains a bug: method getMortgageField \nreturns null, thereby causing a NullPointerException to be thrown in the next statement. Although the \nbug is in the GUI logic of the method and has nothing to do with persistence or enhance\u00adments, the JDO \nbytecode enhancements complicate source level debugging of the code. As an illustration, consider the \nenhanced bytecode of the method displayed in Figure 3. The programmer stepping through displayMaxMortgage-Eligibility \nwith a standard debugger will encounter the enhancements, including various new methods, including jdoGetSalaryLevel \nand jdoGetCreditLevel, which can be misleading, obfuscating the location of the bug. Al\u00adthough tracing \nthe enhanced bytecode with a standard de\u00adbugger may accidentally lead the programmer to discover a suspect \nbytecode instruction, matching the instruction to the corresponding statement in the original source \ncode may  1 public void displayMaxMortgageEligibility 2 3 (Display display , double projectedIncrease \n) {double newSalary = 4 salaryLevel . getSalary () + projectedIncrease ; 5 salaryLevel . setSalary (newSalary); \n6 double maxMortgage = 7 calcMaxMortgage(salaryLevel, creditLevel ); 8 FrameField mortgageField = 9 display \n.getMortgageField(); 10 mortgageField. setVal(maxMortgage); 11 ... 12 } Figure 2. Original source code. \nquickly turn nontrivial. Bytecode-only enhancements do not have any source code level representation. \nFrom a different perspective, a programmer who .rst en\u00adcounters this application with the goal of adding \nnew fea\u00adtures or .xing a bug would not get a realistic picture of the application s behavior by browsing \nthe source code. In par\u00adticular, the source code contains no information pertaining to the intermediate \ncode enhancements introduced to enable transparent persistence. Thus, any change to the code could potentially \nlead to an unrelated change in the persistence functionality, leading to dif.cult-to-.nd errors. The \nmeta\u00addata used to designate persistent classes only marks classes as such, but does not describe how \nexactly they will be en\u00adhanced. This simple but realistic example demonstrates how transparent enhancement \nhinders the effectiveness of source\u00adlevel programming tools. Because intermediate code en\u00adhancement has \nbecome an indispensable part of enterprise software development, new approaches are required to make \nsource level programming tools enhancements-aware. 3. Understanding and Expressing Bytecode Enhancement \nBecause intermediate code is enhanced using special-purpose libraries, typically at class load time, \nthe enhancements are poorly understood and not well-documented, if at all. The problem stems from a lack \nof the right expression medium for such enhancements. If intermediate code enhancements could be expressed \nin regular source code, there would be no need to manipulate intermediate code directly, such as with \nbytecode engineering. Conversely, bytecode is too low level a representation to be useful for most programming \ntools. As a means of understanding and expressing intermediate code enhancements, we have introduced \nStructural Enhance\u00adments Rules (SER), a special purpose language for doc\u00ad 1 public void displayMaxMortgageEligibility \n(Display, double); 2 Code: 3 aload 0 4 invokestatic 5 invokevirtual 6 i2d 7 dload 2 8 dadd 9 dstore 4 \n10 aload 0 11 invokestatic 12 dload 4 13 invokevirtual 14 aload 0 15 aload 0 16 invokestatic 17 aload \n0 18 invokestatic 19 ... // jdoGetsalaryLevel; // jdoGetsalaryLevel; // jdoGetsalaryLevel; // jdoGetcreditLevel; \nFigure 3. Bytecode enhanced by the JDO enhancer. umenting bytecode enhancements. Figure 4 demonstrates \nhow using SER can improve the precision and utility of source level programming tools. Speci.cally, the \nupper part of the .gure shows a SER interpreter helping inform the pro\u00adgrammer about how various program \nconstructs will be en\u00adhanced at the bytecode level, and can be integrated with a source code editor. \nThe lower part of the .gure shows a SER interpreter being used to map the enhancements to the orig\u00adinal \nsource code at runtime, and can be integrated with a symbolic debugger.  3.1 Structural Enhancements \nIntermediate code enhancement is concerned with structural changes, which are large scale program transformations. \nThe purpose of SER is to document structural enhancements in suf.cient enough detail to improve the precision \nand utility of source-level programming tools that manipulate the origi\u00adnal source code of an enhanced \nprogram. To ensure that SER provides the requisite facilities for expressing common in\u00adtermediate code \nenhancements, we .rst catalog and classify common structural enhancements. To determine what constitutes \na structural enhancement, we have reverse-engineered several industrial and research systems that use \nbytecode enhancement.2 In addition, we have also examined the capabilities of two major Java byte\u00adcode \nengineering libraries Apache BCEL[2] and Javassist [39]. Structural enhancements are the subset of general \npro\u00adgram transformations that affect the structure of an object\u00adoriented program, including classes, \nmethods, and .elds, as well as limited changes to method bodies. Structural en\u00adhancements to method bodies \nare primarily con.ned to re\u00ad.elds can be added to and removed from a class. Finally, ex\u00adisting methods \ncan serve as templates for other methods. We refer to this operation as replication. For example, a new \nwrapper method could be created based on some existing method the new method will have the same signature, \nbut a different name. There are no explicit constructs for chang\u00ading a .eld or a method this transformation \ncan be expressed by removing the old version and subsequently adding a new one. Figure 6 demonstrates \nthe semantics of structural en\u00ad hancement operations using set operations. Adding new pro\u00adgram elements \nto existing ones is described using ., the set union operator. Removing program elements is described \nus\u00ading \\, the set difference operator. Replicating program ele\u00adments is described using . and ., which \ndesignate a new element being created based on some existing element and added to the set, but the existing \nelement still remaining in the set. A set of original classes, C = {c1,c2,...,cn} ++ + A set of added \nclasses, C+ = {c1 ,c 2 ,...,c} n n placing direct .eld accesses with setter and getter methods as well \nas with other wrapper methods. A set of original interfaces, I = {i1,i2,...,in}= {i+,i+,...,i+} A set \nof added interfaces, I+A more strict de.nition of structural enhancement is as 12 follows. Modify a \nprogram, con.ning the set of changes to the following operations: A set of original methods, M } '' = \n{m1,m2,...,mnA set of replicated methods, M' = {m1,m2,...,m + 1 ,m 'n } Adding a new class or interface. \n+ A set of added methods, M+ + = {m Changing the type of a class or an interface (i.e., changing A set \nof removed methods, M- = {m the parent interfaces and/or classes) 2 ,...,m n --- n } 1 ,m 2 ,...,m } \nn Adding a new method or .eld A set of original .elds, F = {f1,f2,...,fn},f+,...,f+ A set of added .elds, \nF + 12 Removing a method or .eld = {f+ A set of removed .elds, F - = {f - 1 ,f - 2 - n } ,...,f } Changing \nthe signature of a method (e.g., adding or re\u00admoving parameters or changing the return type).  Changing \nthe type of a .eld  (c)p denotes a class c of program p (C)p denotes a set of classes C of program p \nReplacing direct .eld accesses with setter/getter methods  3.2 Semantics of Structural Enhancements \nNext we provide a more formal treatment of the program transformations that constitute the structural \nenhancement operations commonly applied to intermediate code. Figure 5 lists the symbols that we use \nin describing the enhancement operations, with the sets of transformed pro\u00adgram constructs appearing \n.rst. The original program con\u00adsists of a set of classes. During the enhancement, new classes can be \ngenerated and added to the program. In the origi\u00adnal program, a class can implement some interfaces. \nAn en\u00adhancer can add new interfaces to the set of implemented in\u00adterfaces and can also change the super \nclass. Methods and 2 Reverse-engineering these systems is perfectly legal, as they follow an open-source \ndevelopment model. Reverse-engineering enhanced bytecode turned out to be more effective than understanding \nthe source code of the enhancers. (i)c denotes a interface i implemented by class c (I)c denotes a set \nof interfaces I implemented by class c (m)c denotes a method m of class c (M)c denotes a set of methods \nM of class c (f)c denotes a .eld f of class c (F )c denotes a set of .elds F of class c ext denotes class \ninheritance relationship impl denotes interface inheritance relationship Figure 5. Syntax de.nition \n 3.3 SER Language Design The Structural Enhancement Rules (SER) language is a declarative, domain-speci.c \nlanguage that was designed to be easy to learn, use, and understand. To show how SER can serve as an \neffective medium for expressing intermediate code enhancements, we introduce it by example.  AddClass((C)p, \n(C+)p)= .i.C (i)p ..j.C+ (j)p AddSuperClass((C)p, (C+)p)= .i.C (i)p ext .j.C+ (j)p RemoveSuperClass((C)p, \n(C-)p)= .i.C (i)p \\.j.C- (j)p AddSuperInterface((I)c, (I+)c)= .i.I (i)c impl .j.I+ (j)c RemoveSuperInterface((R)c, \n(R-)c)= .i.R(i)c \\.j.R- (j)c AddMethod((M)c, (M+)c)= .i.M (i)c ..j.M+ (j)c RemoveMethod((M)c, (M-)c)= \n.i.M (i)c \\.j.M- (j)c ReplicateMethod((M)c)= (M )c .(M ' )c = .i.M (i)c ..j.M, (j)c AddField((F )c, (F \n+)c)= .i.F (i)c ..j.F + (j)c RemoveField((F )c, (F -)c)= .i.F (i)c \\.j.F - (j)c Field[Get | Set]Replacer((F \n)c)= (F )c .(M ' )c = .i.F (i)c ..j.M (j)c ..k.M, (k)c Figure 6. Structural Enhancement Operations. Describing \nthe JDO Enhancement Figure 7 shows the SER script, which documents the en\u00ad hancements performed by the \nJDO enhancer, discussed in Section 2. The script starts with the keyword Program fol\u00adlowed by the name \nof the script. SER scripts can use each other by means of the keyword Using. The body of the script is \ndelineated by the Begin and End keywords rather than curly braces. We have deliberately made SER look \ndif\u00adferent from the C family of languages. Another distinctive feature of SER is not using semicolons \nto terminate program statements each statement is expected to start from a new line. Each script makes \navailable to the programmer two re\u00ad.ective objects, OrgClass and EnhClass, representing the original \nclass and the enhanced class, respectively. This de\u00adsign decision is guided by the observation that bytecode \nen\u00adhancement either modi.es an existing class or generates a brand new class, using some original class \nas a template. In both cases, the program in the enhanced class can be expressed as a function of the \ncorresponding constructs in Figure 7. SER Script for the JDO Enhancement. the original class. Each re.ective \nclass object has built-in attributes Name and Type, which represent their name and class type (i.e., \nclass or interface), respectively. The state\u00ad9 uses the fieldP Pattern to obtain an Iterator of all ment \non line 3 expresses that the enhancer will modify the the private .elds in the original class. SER Patterns \npro\u00adoriginal class rather than generate a brand new one. vide records describing every existing property \nof a program In addition, to the attributes, the re.ective class objects construct, including its name, \ntype, modi.ers, and signature. make available to the programmer both accessor and modi-A Pattern can \ninclude any combination of records, as nec\u00ad.er methods. The accessor methods of SER mirror the ones essary. \nin the Java Re.ection API [20], with two notable excep-The SER modi.er methods can only be applied to \nthe tions. First, SER accessor methods return declarative iter-EnhClass re.ective object. SER provides \nmodi.er meth\u00adators, which can only be passed as parameters to SER mod\u00adods for adding and deleting all \nthe language constructs, i.er methods as we discuss later. Second, accessor methods including constructors, \n.elds, and methods. Changing a can accept as parameters Pattern objects, which describe construct can \nbe expressed by removing it .rst and then properties of program constructs. For example, the Pattern \nadding a new construct back. The statement on line 4 doc\u00adstarting on line 5 is named fieldP, and it describes \nall the uments the enhanced class modi.ed to implement interface .elds or methods that are private. The \nstatement on line PersistenceCapable. Every modi.er method can accept  Figure 8. SER script for the \nRemoting enhancement. an iterator as a parameter, and then every element repre\u00adsented by the iterator \nwill be added. Methods and .elds must be explicitly added to the EnhClass object, even if the en\u00adhancer \nmodi.es an existing class represented by OrgClass. A shorthand notation EnhClass = OrgClass represents \ncopying all the language constructs of the original class to the enhanced class. This shorthand is useful \nwhen the en\u00adhanced class differs from the original class only by a small margin. SER also provides special \nconstructs for replacing direct .eld accesses with setter and getter methods. To that end, SER provides \nmethods FieldSetReplacer and Field-GetReplacer, respectively, which can be taken as parame\u00adters to the \nmodi.er method AddMethod. These methods take a pre.x for the getter or setter method names and an iterator \nrepresenting the .elds, accesses to which are replaced. The statements on lines 12 and 13 express the \nrule that JDO re\u00adplaces direct .eld accesses with setter and getter methods, whose names start with jdoSet \nand jdoGet , respectively. Describing the Remoting enhancement A SER program can be comprised of multiple \nmodules, which can refer to each other s re.ective objects. A standard SER program is likely to contain \nmultiple modules, each representing the enhancements applied to a different class. Figure 8 shows a fragment \nof an enhancement that trans\u00ad forms direct references into proxy references in order to en\u00adable their \nexecution on a remote machine. In this enhance\u00adment, used in several research systems [33, 32, 47], for \neach original class, proxy, implementation, and interface classes are generated. The Pattern starting \non line 5 refers to the type of the EnhClass of REMOTING IFACE, which is an\u00adother module in the same \nscript. In this case, the Name of Figure 9. SER Script for the Hibernate Enhancement. the EnhClass in \nthe other module represents the type of the .eld added on line 11. Describing the Hibernate Enhancement \nAs an example of a more advanced feature of SER, consider the script that appears in Figure 9. This description \ncaptures how Hibernate [6], another widely-used commercial persis\u00ad tence architecture uses bytecode enhancement. \nUnlike JDO, Hibernate does not modify persistent classes; instead, it cre\u00adates proxy classes that extend \nthe original persistent classes, as is expressed by the statement on line 8. Furthermore, the exact name \nof the created proxy classes as well as the names of their methods start with hard-coded pre.xes ( Enhancer-ByCGLIB \n, CGLIB ), appended with randomly-generated integers. To express that the names of proxy methods are \nbased on the names of the corresponding methods in the original per\u00adsistent classes, SER introduces the \nability to create a deriva\u00adtive iterator, given an iterator and a pattern. On line 14, an Iterator describing \nthe public methods in the OrgClass is obtained. Then on line 15, a new Pattern describes adding the pre.x \nCGLIB* to the name of a program construct. Fi\u00adnally, on line 21, the AddMethod method takes as its pa\u00adrameter \nthe return value of method CreateNewIterator, which creates a new iterator by applying a pattern, nameP, \nto an iterator, methodIter. In effect, the one-liner on line 21 declaratively expresses that the public \nmethods in the newly-generated EnhClass will have names that start with CGLIB , followed by some random \nnumber, and ending with the corresponding method s name in the OrgClass. For example, if a persistent \nclass has a method named foo, the generated proxy s corresponding method could be named CGLIB123foo. \n  In essence, SER provides programming support for ma\u00adnipulating sets of methods, constructors, and \n.elds. An it\u00aderator representing a set of class constructs can be obtained based on a pattern. SER has \na functional feel in that SER does not allow changing iterators, but rather makes it possi\u00adble to derive \nnew iterators by applying a pattern to an exist\u00ading iterator. Also, program constructs can only be added \nto or removed from EnhClass, thus simplifying the API. Describing the Split Class enhancement Consider \nthe script depicted in Figure 10, which describes one of the enhancements required to split a class into \nparti\u00adtions, so that only the .elds used by a remote computation be transferred across the network. This \nenhancement entails selecting a subset of .elds of the original class and placing them into a newly created \nclass, representing the primary partition, which will be sent across the network. In SER, the selection \nof the required .elds is accomplished by .rst adding to EnhClass all the .elds contained in the original \nclass (Line 15). And then the .elds intended for the sec\u00adondary partition are removed (Line 18). SER \nlanguage summary Figure 11 summarizes the SER programming constructs. The language follows a minimalistic \ndesign, introducing new constructs only if necessary, with the goal of making it easier to learn and \nunderstand. SER conveys the enhance\u00adments declaratively and does not have explicit conditional or looping \nconstructs. As a result, a SER script does not contain a suf.cient level of detail to be used as input \nfor a bytecode enhancer, but it is descriptive enough to document the enhancements for source-level programming \ntools as we discuss in Section 4. In validating the usability of SER, we have documented four enhancements \nused in production and research systems: JDO [38], Hibernate [6], Remoting [47], and Split Class [8, \n48]. The scripts describing these enhancements in their entirety can be downloaded from the project s \nwebsite [41]. In the discussion above, we have presented only fragments of these scripts to demonstrate \nvarious language features of SER. SER is an interpreted language, and its interpreter can be integrated \ninto existing programming tools. We discuss the SER interpreter s design In Section 3.4, and how we used \nthe interpreter to enhance two existing source-level programming tools in Sections 4.2 and 4.3.  3.4 \nSER language interpretation The purpose of documenting enhancements with a SER script is to provide a \nbi-directional mapping between the source code of a class and its enhanced bytecode represen\u00adtation. \nThe SER interpreter can take either a Java source .le or a bytecode class .le as parameters, corresponding \nto the original or enhanced versions of a class, respectively. An\u00adother required parameter is the SER \nscript associated with the input .le. Although it would be possible for the inter\u00adpreter to search for \nSER scripts based on the input .les names, in the current implementation it uses a con.guration .le that \nspeci.es which SER .les work with which Java or  Program script-name1 [Using script-name2] Begin [Module \nmodule-name Begin...End] ... End A SER script can include other scripts and can be divided into modules. \nOrgClass / EnhClass Reflective class objects: original and enhanced class. Var Pattern pattern-name \nBegin property= value ... End Patterns for matching program constructs, based on their properties. \nVar Iterator iterator-name An iterator for a collection of program constructs. Constructors/Methods/Fields([pattern-name]) \nReturn a collection of program constructs, [possibly matching pattern-name] Field[Get/Set]Replacer(prefix, \niterator-name) Replace direct accesses to the fields specified by iterator-name with getter/setter methods \nstarting with prefix, and return them as an iterator iter-name.CreateNewIterator(pattern-name) Create \na new iterator by applying pattern-name to iter-name [Add|Remove]Interface/Superclass/Method/Field([iterator-name|pattern-name]) \nAdd or remove program elements specified by iterator-name or pattern-name to or from EnhClass Figure \n11. SER language constructs. class .les. If the SER .le cannot be located, the interpreter signals an \nerror. When processing a SER script, the interpreter parses the main script and all the included scripts \nspeci.ed with the Using keyword. Figure 12 demonstrates the interpreter s process .ow, which differs \ndepending on the type of the input .le used to parameterize the interpreter. If a Java source .le, containing \nthe original source code, is passed to the interpreter, the .le is processed using the Eclipse JDT API \n[15]. Then the enhancement information processed by the SER parser is combined with the one of the original \nJava source. The result is stored into a symbol table module that implements a quick lookup mechanism \ncapable of retrieving, in constant time, all the enhancements applied to a given program construct. Finally, \nan external API to the symbol table makes it possible to retrieve the enhancement information. In summary, \nthe API uses JDT AST constructs as lookup keys to retrieve the enhancements associated with them. For \nexample, sending a class object as a parameter will return a list of lists, containing the methods, constructors, \nand .elds that the bytecode enhancer adds to this class. Of course, some of these lists could be empty. \nIf a binary class .le, containing the enhanced bytecode, is passed to the interpreter, the .le is processed \nusing the Javassist library [39]. Then the enhancement information processed by the SER parser is combined \nwith the one of the enhanced bytecode. The result is stored in a format that we call Symbolic Undo, which \nis a collection of instructions that can be used to map every enhancement back to the original source \ncode. We will detail the exact format of Symbolic Undo when we discuss a symbolic debugger for enhanced \nprograms that we implemented as a case study. 4. Case Studies: Enhancements-Aware Programming Tools To \nevaluate the applicability of our approach, we have aug\u00admented two existing source-level programming \ntools with an awareness of bytecode enhancements. Speci.cally, we have added a new browsing view to a \nwidely-used source code editor to present the bytecode enhancements applied to the program constructs \nof the displayed compilation unit. We have also created a new debugging architecture that enables a symbolic \ndebugger running an enhanced program to dis\u00adplay the original source code, undoing the enhancements at \nruntime.  4.1 Example Applications To check the effectiveness of the enhancements-aware tools, we have \napplied both of them to four different applications, each using a different bytecode enhancement scheme. \nThe .rst two applications use transparent persistence architec\u00adtures, albeit with drastically different \nenhancement strate\u00adgies. While JDO modi.es persistent classes, Hibernate gen\u00aderates proxy classes that \ninherit from them. Another dif\u00adference between JDO and Hibernate is the time when the enhancement takes \nplace: while JDO enhances persistent classes as a static post-compilation step, Hibernate generates proxy \nclasses at class load time. Two other applications come from the domain of dis\u00adtributed computing. The \n.rst application performs an RMI Remoting enhancement, in which the original, local class is rewritten \ninto a remote implementation class, and new proxy and RMI remote interface classes are generated. This \nrewrite is performed by several systems designed to make distributed computing in Java more intuitive, \nboth at the source level such as JavaParty [34], and transparently at the bytecode level such as J-Orchestra \n[47]. Another enhancement from the distributed computing do\u00admain modi.es the structure of a data class \nto optimize the network transfer of its instances. Class .elds are divided into a set that is used by \na remote server and the one that is not, and the class is rewritten into two partitions containing those \nsets, using the Split Class binary refactoring [48]. Finally, the partition to be transferred across \nthe network is made to implement Serializable to enable the marshaling of its instances. Because the \nrewrite adds a new capability, it is classi.ed as an enhancement. We expressed each enhancement scheme \nin SER. For the transparent persistence architectures, we reverse-engineered the enhancements by comparing \nthe original and enhanced versions of multiple application classes. In the distributed application cases, \nwe simply documented in SER the trans\u00adformations informally described in the respective research publications \n[47, 48].  4.2 Source Editor with Zoom-in-on-enhancements View Intermediate code enhancement introduces \nnew functional\u00adity behind the scenes, transparently to the programmer. Fur\u00adthermore, leaving the programmer \nunaware of the speci.c changes applied directly to the bytecode has been recog\u00adnized as a key bene.t \nof the technique it improves sep\u00adaration of concerns, with the programmer being responsi\u00adble for business \nlogic only. Nevertheless, as we argue next, making the bytecode enhancement information accessible to \nthe programmer can yield software engineering bene.ts. For example, bytecode enhancers follow a certain \nconvention in choosing the names of program constructs that they add. In particular, JDO starts the names \nof all the added setter/getter methods with pre.x jdoSet/Get. There is nothing, how\u00adever, that would \nprevent the programmer from writing a method starting with these pre.xes, thus creating a dif.cult to \ndiagnose name clash. By examining the enhancements that will be applied to a class, the programmer can \nquickly identify such inappropriately-named program constructs. As another example, consider the restriction \nof Hibernate of not being able to persist instances of final classes and any classes that have final \nmethods. This restriction seems completely arbitrary, unless the programmer can examine how Hibernate \nenhances the persistent classes. This restric\u00adtion becomes immediately apparent, as soon as the pro\u00adgrammer \nobserves that persistence-enabling proxies gener\u00adated by Hibernate extend the persistent classes. As \nyet an\u00adother example, certain performance bottlenecks in the en\u00adhanced code can be identi.ed by examining \nthe enhance\u00adments. For example, the use of RMI in remoting enhance\u00adments can be detrimental to performance \nin some network\u00ading environments. As a .nal example, some bugs in meta\u00addata, which describes which program \nconstructs are to be enhanced, can be more easily identi.ed if the enhancement code is visible.   \n selects a class whose bytecode is subject to enhancement, a new view pops up displaying an abbreviated \ndescription of the enhancements. We call this view window a zoom-in-on\u00adenhancements view. Following the \nEclipse tooling strategy, the view is visible only if activated, so if they so choose, the programmers \nare free to remain oblivious about the nature and speci.cs of enhancements. In the case if the original \nclass is modi.ed at the bytecode level, the enhancements are shown as special comments in the main editor. \nSince not all the information about the enhancements in known at source edit time, the enhancements cannot \nbe expressed in source code form. If a single class is associated with several classes created during \nan enhancement, each of the created classes is displayed in a separate view. Figures 13, 14, 15, and \n16 show the screen-shots of the zoom-in-on-enhancements views, which document the en\u00adhancements used \nin the example applications described in Section 4.1. The views have been integrated with Eclipse. Figure \n17 presents a collaboration diagram that shows the backend processing triggered by the source editor \nto launch a zoom-in-on-enhancements view. When the SER in\u00adterpreter s main module receives a Java source \n.le as input, the corresponding SER script is identi.ed (using a con.gu\u00adration .le), loaded, and parsed. \nThe interpreter employs sev\u00aderal abstract syntax tree walkers (using Visitors) to traverse the Java program, \ncollecting the information about how the general enhancement instructions in the SER script will af\u00adfect \nthe speci.c program constructs (e.g., .elds, methods, constructors, etc.). The collected enhancement \ninformation is stored in a symbol table for fast searching and retrieval. Fi\u00adnally, the interpreter compiles \na complete documentation of the enhancements, which it uses to parameterize the zoom\u00adin-on-enhancement \nviewer.  4.3 A Symbolic Debugger for Enhanced Intermediate Code Because intermediate code enhancements \nare not repre\u00adsented at the source code level, source-level debugging of such enhanced bytecode is nontrivial. \nApplication code is enhanced to be able to interact with a framework, and the enhancements cannot be \nsimply turned off to facilitate de\u00adbugging. Thus, tracing, analyzing, and .xing .awed pro\u00adgrams whose \nbytecode has been enhanced with a standard debugger is misleading the debugger will show all the en\u00adhanced \nprogram s code faithfully, both the original logic and the transparently introduced enhancements. From \nthe de\u00adbugging perspective, enhancements obfuscate the original source code s logic. The debugging of \ntransparently enhanced programs can be facilitated by making a symbolic debugger aware of the enhancements. \nThe debugger could execute an enhanced program, but report the source code information pertaining to \nthe original source code. As our proof of concept, we have created a new debugging architecture that \nleverages the fa\u00adcilities offered by the Java Platform Debugger Architecture (JPDA) [43]. We then applied \nthe new architecture to aug\u00ad ment the capabilities of the standard debugger distributed with Sun s JDK \nwith an awareness of the enhancements in debugged programs.  Figure 18 demonstrates our new debugging \narchitecture, which integrates a SER interpreter. When debugging en\u00adhanced bytecode, the debugger also \ntakes the SER descrip\u00adtion of the enhancements as input. The integrated SER in\u00adterpreter then computes \nsymbolic undo instructions that map the enhanced bytecode to the original source code. To reverse the \nenhancements that add and change pro\u00adgram constructs, our debugging architecture introduces the skip \nand reverse symbolic undo instructions, which can be applied to classes, methods, .elds, and entire packages. \nThe debugger organizes the symbolic undo instructions as a hier\u00adarchical collection through the contains \nrelationship (i.e., packages contain classes, classes contain methods, etc.). All the instructions are \nsorted in the order of their quali.ed full names, so that they could be ef.ciently located through binary \nsearch in logarithmic time. The debugger executes the symbolic undo instructions on the encountered enhance\u00adments, \nso that the information reported to the user pertains to the original programmer written code. The symbolic \nundo instructions work as follows. The skip instruction suppresses the output of those program el\u00adements \nthat, in the original version, have not been repre\u00adsented in source code. Skip operations raise a special \npur\u00adpose debugging event whose semantics is similar to the reg\u00adular debugger s step event; however, the \noutput associated with handling the event is suppressed. The reverse instruc\u00adtion changes the name of \na program construct displayed through the standard debugging output. For example, if an enhancer has \nchanged the name of a class, a reverse instruc\u00adtion will direct the debugger to report the class s original \nname. From the user s perspective, our symbolic debugger is a plug-in replacement for the standard JDK \ncommand-line de\u00adbugger, providing the capabilities to step through the code, set breakpoints, print variable \nvalues, etc. The implemen\u00adtation leverages the Java Platform Debugger Architecture (JPDA)[43], which \nconsists of several layers of protocols and interfaces provided by the Java Virtual Machine. The functionality \nrequired for symbolically undoing transparent Figure 19. The symbolic debugger s collaboration diagram. \n  Events are also triggered when the step command moves the debugger to the next source code line. The \nvalues of member and local variables can be printed at any point af\u00adter a breakpoint has been triggered \nor the step command has been executed. Our symbolic debugger intercepts each de\u00adbugging event and executes \na corresponding symbolic undo instruction, thus mapping the enhanced bytecode back to the original version \nof the code. Figure 19 shows a collaboration diagram that details the runtime architecture of our symbolic \ndebugger. The diagram depicts the main events driving the execution of our symbolic debugger. The main \nmodule of the debugger, SymbolicDebugger, manages the symbolic undo informa\u00adtion, using the services \nof the EventHandler. The Even\u00adtHandler receives debugging events from the JPDA Even\u00adtQueue and delegates \nthem to SymbolicDebugger by call\u00ading vmInterrupted. SymbolicDebugger then evaluates the re\u00adceived event \nagainst the symbolic undo information, which can be generated on demand, and symbolically undoes any \nencountered enhancement. By using JPDA, which is thread\u00adaware, our debugger can effectively handle multi-threaded \nprograms. As a demonstration of the utility of the new debugger, we inserted a bug to the example mortgage \neligibility applica\u00adtion presented in Section 2. We then traced the bug using both our augmented debugger \nand JDB. In our experiences, the enhancements introduced by the JDO framework com\u00adplicate the debugging \nprocess. Figure 20 shows two screen shots, corresponding to debugging with our symbolic debug\u00adger and \nJDB, respectively. Points marked as (1) and (3) mark the start of the traced method, in their respective \ndebug\u00adger s displays. Individual debugging steps are circled. Point (2) shows the original code as displayed \nby our debugger. Points (4) and (5) show the bytecode instructions that would be skipped and reversed \nby our debugger, respectively. Our experience suggests that our debugger has the potential to become \nan effective aid in locating bugs in enhanced pro\u00adgrams. Nevertheless, only a controlled user study can \ncon\u00ad.rm the veracity of this conjecture. We plan to conduct such a study as future work. 5. Related Work \nOur approach to augmenting source-level programming tools with an awareness of intermediate code enhancements \nis related to several research areas including the debugging of transformed code, program transformation \nlanguages, and structural program differencing. 5.1 Debugging Transformed Code Debugging Optimized Code. \nModern compilers have pow\u00aderful code optimization capabilities. Compilers optimize code via performance-improving \ntransformations. However, because compilers transform an intermediate representation of a program, the \nrelationship between such a transformed representation and the original source code of a program be\u00adcomes \nobscured. Speci.cally, performance-improving trans\u00ad formations reorder and delete existing code as well \nas insert new code. Thus, debugging optimized code is hindered by the changes in data values and code \nlocation. A signi.cant amount of research aims at the problem of debugging opti\u00admized code [21, 22, 7, \n28, 17, 9, 19]. The proposed solutions enable source-level debuggers to display the information about \nan optimized program, as if the original (unoptimized) version of the code was being debugged.  The \ntechniques for debugging optimized code deal with the challenges arising as a result of optimizing compilers \ntransforming intermediate code to improve performance. While these transformations can be quite extensive, \nthey are usually con.ned to method bodies and do not alter the debugged program s semantics. By contrast, \nstructural enhancement aims at larger-scale program transformations that can add new classes and interfaces \nto a program. Thus, source level debugging of structurally enhanced programs requires different debugging \ntechniques such as the pre\u00adsented symbolic undo. Debugging for AOP. Aspect-Oriented Programming (AOP) \n[25] can be viewed as an enhancement technol\u00adogy, and several approaches aim at debugging support for \nAOP [14, 35, 23]. However, debugging aspect-oriented pro\u00ad grams is different from debugging transparently \nenhanced programs. AOP provides a domain-speci.c language for programming enhancements such as AspectJ \n[24], and an AOP debugger traces the bytecode generated by AspectJ to its aspect source .le. By contrast, \ntransparent bytecode en\u00adhancements have no source code representation. Thus, the approaches to debugging \nAOP software cannot be applied to debugging transparently enhanced programs. In addition, AspectJ as \na language cannot express all the structural enhancement transformations. For example, it is impossible \nto express in AspectJ that the name of a program construct (e.g., class, .eld, or method) be changed. \nAspectJ does not provide facilities for removing a program construct, something that program enhancers \nneed to do on a regu\u00adlar basis. For example, the split class enhancement moves .elds from a class to \nanother class, thus removing them from the original class. Finally, program enhancers often gener\u00adate \nnew classes and interfaces and reference them in the en\u00adhanced program. AspectJ is not designed for expressing \nhow to generate a new class, whose structure is based on some ex\u00adisting program construct. Thus, we could \nnot have used As\u00adpectJ instead of SER to represent structural enhancements. 5.2 Program Transformation \nLanguages SER is a domain-speci.c language for expressing how byte\u00adcode is enhanced structurally. Other \ndomains also feature domain-speci.c languages for expressing program transfor\u00admations. JunGL [49], a \ndomain-speci.c language for refactor\u00ading, combines functional and logic query language idioms. JunGL \nrepresents programs as graphs and manipulates refac\u00adtorings via graph transformations. The language provides \npredicates to facilitate the querying of graph structures. JunGL uses demand-driven evaluation to prevent \nscripts from becoming prohibitively complex. Sittampalam et al. [40] specify program transformations \ndeclaratively and generate executable program transformers from speci.cations. The Prolog language is \naugmented with facilities for incremental evaluation of regular path queries. The augmented language \nis used to specify program trans\u00adformations by expressing a program and its transformed counterpart. \nThe transformations can be combined with a strategy script, based on Stratego [50], to specify the traver\u00ad \nsals of a program and the order of the transformations. Whit.eld and Soffa s code-improving transformation \nframework consists of a case tool and a speci.cation lan\u00adguage [51]. The speci.cation language, called \nGospel, de\u00ad clares program transformations; the case tool, called Gene\u00adsis, generates a program transformer \ngiven a Gospel speci\u00ad.cation. A Gospel script consists of a declaration section, containing variables \ndeclarations, a precondition section, containing code pattern descriptions and control dependence conditions, \nand an action section, containing a set of trans\u00adformation operations. The Coccinelle [42] tool introduces \nthe SmPL language for locating and automatically .xing bugs. SmPL programs specify how in response to \nsome runtime condition, a pro\u00adgram should be transformed to .x a bug and log the changes. FSMLs [10] \nis a domain speci.c modeling language for describing the framework-provided knowledge, including framework \ninstantiation, procedures for implementing in\u00adterfaces, and proper usage of framework services. FSMLs \nbears similarity to our approach in its ability to provide a bi\u00addirectional mapping between framework \nfeatures and their abstract representation. JAVACOP [1] introduces a declarative rule language for expressing \nprogrammer-de.ned types, called pluggable types. The types are described as user-de.ned rules, which \nJAVACOP uses for transforming the abstract syntax tree of a program. Compile-Time Re.ection (CTR) [16] \nenables generative programming without the intricacies of the re.ection API in the mainstream managed \nlanguages such as Java or C#. To that end, CTR extends C# with the ability to inspect and generate code \nusing templates and pattern matching. CTR generates code at compile time, thus ensuring that the generated \ncode is statically checked. The purpose of CTR is to express how source code should be generated, rather \nthan how bytecode should be enhanced. Because these program transformation languages were designed speci.cally \nfor their respective domains, we could not have used any of them for our purposes. The main de\u00adsign goal \nof our SER language was to be able to express structural enhancements used by bytecode enhancers declar\u00adatively \nand to provide special constructs for domain-speci.c transformations such as adding getter/setter methods. \n  5.3 Program Differencing SER scripts describe generalized structural program differ\u00adences. Program \ndifferencing is an active research area and several new differencing algorithms have been proposed re\u00adcently. \nPrevitali et al. s technique [36] generates version differ\u00ad ences of a class at bytecode level. Their \nalgorithm produces the information on added, removed, or modi.ed classes. Dmitriev incorporates program \nchange history into a Java make utility that selectively recompiles dependent source .les [12]. The JDIFF \n[3] algorithm identi.es changes be\u00ad tween two versions of an object-oriented program using an augmented \nrepresentation of a control-.ow graph. M. Kim et al. [26] infer generalized structural changes at or \nabove the level of a method header, represented as .rst-order re\u00adlational logic rules. These techniques \ncould be leveraged to generate SER scripts automatically by generalizing the dif\u00adferences between the \noriginal and enhanced versions of mul\u00adtiple classes. Our own Rosemari system [46] generalizes structural \ndif\u00ad ferences between two versions of a representative example. Such examples are usually supplied by \nframework vendors to guide the developers in upgrading their legacy applica\u00adtions from one framework \nversion to another. Rosemari fea\u00adtures a DSL for describing program transformations, but can be retargeted \nto present structural changes in SER instead.  5.4 Symbolic Execution The idea of symbolic undo, used \nin implementing our de\u00adbugger, is in.uenced by symbolic execution [27], which an\u00ad alyzes a program by \nexecuting it with symbolic inputs, but without actually running it. By analogy, our symbolic undo technique \nenables source level debugging of enhanced byte\u00adcode by mapping it back, via symbolic operations, to \nits orig\u00adinal source code, also without affecting the program s exe\u00adcution. 6. Future Work The initial \nevaluation results of our approach have been pos\u00aditive. To demonstrate the effectiveness of our approach, \nwe have conducted two case studies. Speci.cally, we have aug\u00admented two source-level programming tools \nwith enhance\u00adment-awareness, so that the tools could handle programs that use four different bytecode \nenhancement strategies. As future work, we plan to conduct user studies to evalu\u00adate the value of our \napproach for programmers with different levels of expertise. One such study could evaluate whether a \nsymbolic undo debugger is more effective than a regular de\u00adbugger in helping the programmer to locate \nand .x bugs. Another study could evaluate the value of integrating the en\u00adhancement information with \na programming editor. We plan to create a debugger for SER scripts. Although the declarative nature of \nSER scripts makes it easier to en\u00adsure their correctness, bugs still can be introduced, particu\u00adlarly \nif a SER script is developed by someone other than a framework developer. Having a SER debugger is likely \nto improve the usability of our approach. We plan to extend our approach to programs that have been transparently \nenhanced more than once, possibly by different enhancers. For example, the same application can use multiple \nframeworks, each enhancing intermediate code in its own way. Bytecode enhancement could add functionality \nin lan\u00adguages other than the host language, including query lan\u00adguages such as SQL or Datalog. Our approach \nwould have to be extended to add the enhancements-awareness to pro\u00adgramming tools handling multi-language \napplications. There could be potential bene.t in synthesizing the source code representation of bytecode-only \nenhancements. To that end, the SER interpreter would have to be integrated with a decompiler that is \nenhancements-aware. The success of this approach would mainly depend on the decompiler s ef.ciency and \nprecision. Generating SER scripts automatically will reduce the framework programmer s effort and make \nour methodology more appealing to the average programmer. A promising ap\u00adproach would require generalizing \nprogram differencing, a target of several recent research efforts [26]. Finally, we would like to make \nour symbolic debugger available as an Eclipse IDE plug-in. 7. Conclusions This paper has argued about \nthe value of enhancing source\u00adlevel programming tool with an awareness of transparent program transformations. \nTo enable such awareness, we have introduced SER, a declarative language that concisely describes structural \nenhancements. To validate our approach, we have augmented two existing source-level programming tools \nwith an awareness of bytecode enhancement. We have also expressed in SER four enhancement strategies \nfollowed by different enhancers and used our augmented program\u00adming tool to handle the enhanced programs. \nAs part of en\u00adhancing a source level debugger, we have introduced a new debugging architecture that makes \nit possible to calculate reverse-mapping instructions based on a SER speci.cation. Bytecode enhancement \nhas already entered the main\u00adstream of enterprise software development, and future en\u00adhancers are likely \nto transform programs in even more com\u00adplex ways. As a result, source code alone will become even less \nsuf.cient in presenting a realistic picture about the func\u00adtionality of a program. Our approach of making \nprogram\u00adming tools aware of bytecode enhancements has the poten\u00adtial to address this problem, and help \nprogrammers enjoy the bene.ts of transparent bytecode enhancement without suffering any of its disadvantages. \n Availability All the software described in the paper is available from: http://research.cs.vt.edu/vtspaces/ser/. \nAcknowledgments The authors would like to express their gratitude to Taweesup Apiwattanapong, Barbara \nG. Ryder, Scott Schneider, Wes\u00adley Tansey, Patrick Yaner, Dave Zook, and the OOPSLA anonymous reviewers \nfor their helpful comments. References [1] C. Andreae, J. Noble, S. Markstrum, and T. Millstein. A framework \nfor implementing pluggable type systems. SIGPLAN Not., 41(10):57 74, 2006. [2] Apache Jakarta Project. \nThe Byte Code Engineering Library. http://jakarta.apache.org/bcel/manual.html. [3] T. Apiwattanapong, \nA. Orso, and M. Harrold. A differencing algorithm for object-oriented programs. Automated Software Engineering, \n2004. Proceedings. 19th International Confer\u00adence on, pages 2 13, Sept. 2004. [4] M. P. Atkinson. The \nNapier88 persistent programming language and environment, 1988. [5] M. P. Atkinson, L. Dayn`es, M. J. \nJordan, T. Printezis, and S. Spence. An orthogonally persistent java. SIGMOD Rec., 25(4):68 75, 1996. \n[6] C. Bauer, G. King, and I. NetLibrary. Hibernate in Action. Manning, 2005. [7] G. Brooks, G. J. Hansen, \nand S. Simmons. A new approach to debugging optimized code. In PLDI 92: Proceedings of the ACM SIGPLAN \n1992 conference on Programming language design and Implementation, pages 1 11, 1992. [8] T. M. Chilimbi, \nB. Davidson, and J. R. Larus. Cache\u00adconscious structure de.nition. SIGPLAN Not., 34(5):13 24, 1999. [9] \nM. Copperman. Debugging optimized code without being misled. ACM Trans. Program. Lang. Syst., 16(3):387 \n427, 1994. [10] K. Czarnecki. Framework-speci.c modeling languages with round-trip engineering. In In \nMoDELS, pages 692 706, 2006. [11] M. Dahm. Byte code engineering. Java Informations Tage, pages 267 277, \n1999. [12] M. Dmitriev. Language-speci.c make technology for the Java programming language. SIGPLAN Not., \n37(11):373 385, 2002. [13] B. Dufour, B. G. Ryder, and G. Sevitsky. Blended analysis for performance \nunderstanding of framework-based applica\u00adtions. In ISSTA 07: Proceedings of the 2007 international symposium \non Software testing and analysis, pages 118 128, New York, NY, USA, 2007. ACM. [14] M. Eaddy, A. Aho, \nW. Hu, P. McDonald, and J. Burger. De\u00adbugging aspect-enabled programs. In Software Composition, pages \n200 215. 2007. [15] Eclipse Foundation. Eclipse Java development tools, March 2008. http://www.eclipse.org/jdt. \n[16] M. F\u00a8ahndrich, M. Carbin, and J. R. Larus. Re.ective program generation with patterns. In GPCE 06: \nProceedings of the 5th international conference on Generative programming and component engineering, \npages 275 284, New York, NY, USA, 2006. ACM. [17] R. E. Faith. Debugging programs after structure-changing \ntransformation. PhD thesis, 1998. Adviser-Jan F. Prins. [18] J. Flen and A. Linden. Gartners hype cycle \nspecial report. Technical report, Gartner Research, 2005. www.gartner. com. [19] P. Fritzson. A systematic \napproach to advanced debugging through incremental compilation (preliminary draft). In Proceedings of \nthe ACM SIGSOFT/SIGPLAN software engineering symposium on High-level debugging, pages 130 139, 1983. \n[20] Glen McCluskey. Using Java Re.ection. http:// java.sun.com/developer/technicalArticles/ALT/ Reflection/index.html. \n[21] J. Hennessy. Symbolic debugging of optimized code. ACM Trans. Program. Lang. Syst., 4(3):323 344, \n1982. [22] U. H\u00a8olzle, C. Chambers, and D. Ungar. Debugging optimized code with dynamic deoptimization. \nSIGPLAN Not., 27(7):32 43, 1992. [23] T. Ishio, S. Kusumoto, and K. Inoue. Debugging support for aspect-oriented \nprogram based on program slicing and call graph. In ICSM 04: Proceedings of the 20th IEEE International \nConference on Software Maintenance, pages 178 187, 2004. [24] G. Kiczales, E. Hilsdale, J. Hugunin, M. \nKersten, J. Palm, and W. G. Griswold. An overview of AspectJ. In Proceedings of the 15th European Conference \non Object-Oriented Programming (ECOOP), pages 327 353, London, UK, 2001. Springer-Verlag. [25] G. Kiczales, \nJ. Lamping, A. Mendhekar, C. Maeda, C. Lopes, J. M. Loingtier, and J. Irwing. Aspect-oriented programming. \nIn ECOOP. Springer-Verlag, 1997. [26] M. Kim, D. Notkin, and D. Grossman. Automatic inference of structural \nchanges for matching across program versions. In ICSE 07: Proceedings of the 29th International Conference \non Software Engineering, pages 333 343, 2007. [27] J. C. King. Symbolic execution and program testing. \nCommun. ACM, 19(7):385 394, 1976. [28] N. Kumar, B. R. Childers, and M. L. Soffa. Tdb: a source-level \ndebugger for dynamically translated programs. In AADEBUG 05: Proceedings of the sixth international symposium \non Automated analysis-driven debugging, pages 123 132, 2005. [29] B. Liskov, A. Adya, M. Castro, S. Ghemawat, \nR. Gruber, U. Maheshwari, A. C. Myers, M. Day, and L. Shrira. Safe and ef.cient sharing of persistent \nobjects in thor. In SIGMOD 96: Proceedings of the ACM SIGMOD international conference on management of \ndata, pages 318 329. ACM, 1996.  [30] A. Marquez, S. Blackburn, G. Mercer, and J. N. Zigman. Implementing \northogonally persistent java. In POS-9: Revised Papers from the 9th International Workshop on Persistent \nObject Systems, pages 247 261, London, UK, 2001. Springer-Verlag. [31] Microsoft. Microsoft Open Database \nConnectivity. http:// msdn.microsoft.com/en-us/library/ms710252(VS. 85).aspx. [32] A. Orso and B. Kennedy. \nSelective Capture and Replay of Program Executions. In Proceedings of the Third International ICSE Workshop \non Dynamic Analysis (WODA 2005), pages 29 35, St. Louis, MO, USA, May 2005. [33] A. Orso, A. Rao, and \nM. J. Harrold. A technique for dynamic updating of Java software. Proceedings of the International Conference \non Software Maintenance (ICSM 02), October 2002. [34] M. Philippsen and M. Zenger. JavaParty transparent \nremote objects in Java. Concurrency Practice and Experience, 9(11):1225 1242, 1997. \u00b4to support aspect-oriented \nprogramming. In SAC 08: Proceedings of the 2008 ACM symposium on Applied computing, pages 266 270, 2008. \n[35] G. Pothier and Eric Tanter. Extending omniscient debugging [36] S. C. Previtali and T. R. Gross. \nDynamic updating of software systems based on aspects. Proceedings of the 22nd IEEE International Conference \non Software Maintenance, pages 83 92, September 2006. [37] C. Richardson. Untangling enterprise Java. \nACM Queue, 4(5):36 44, 2006. [38] C. Russell. Java Data Objects 2.1, June 2007. http: //db.apache.org/jdo/specifications.html. \n[39] Shigeru Chiba. Java Programming Assistant. http: //www.csg.is.titech.ac.jp/ chiba/javassist. [40] \nG. Sittampalam, O. de Moor, and K. F. Larsen. Incremental execution of transformation speci.cations. \nIn POPL 04: Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages, \npages 26 38, 2004. [41] M. Song. The structural enhancement rules language website. http://research.cs.vt.edu/vtspaces/ser. \n[42] H. Stuart, R. R. Hansen, J. L. Lawall, J. Andersen, Y. Padi\u00adoleau, and G. Muller. Towards easing \nthe diagnosis of bugs in os code. In PLOS 07: Proceedings of the 4th workshop on Programming languages \nand operating systems, pages 1 5, New York, NY, USA, 2007. ACM. [43] Sun Microsystems. Java Platform \nDebugger Architecture. http://java.sun.com/javase/technologies/core/ toolsapis/jpda/. [44] Sun Microsystems. \nJavaBeans Speci.cation. http://java. sun.com/javase/technologies/desktop/javabeans/ docs/spec.html. [45] \nSun Microsystems. The Java Database Connectivity. http: //java.sun.com/products/jdbc/overview.html. [46] \nW. Tansey and E. Tilevich. Annotation refactoring: inferring upgrade transformations for legacy applications. \nIn OOPSLA 08: Proceedings of the 23rd ACM SIGPLAN conference on Object oriented programming systems languages \nand applications, pages 295 312, 2008. [47] E. Tilevich and Y. Smaragdakis. J-Orchestra: Automatic Java \napplication partitioning. In Proceedings of the European Conference on Object-Oriented Programming (ECOOP), \npages 178 204. Springer-Verlag, LNCS 2374, 2002. [48] E. Tilevich and Y. Smaragdakis. Binary refactoring: \nImproving code behind the scenes. In Proceedings of International Conference on Software Engineering \n(ICSE), pages 264 273, May 2005. [49] M. Verbaere, R. Ettinger, and O. de Moor. JunGL: a scripting language \nfor refactoring. In ICSE 06: Proceedings of the 28th International Conference on Software Engineering, \npages 172 181, 2006. [50] E. Visser, Z. el Abidine Benaissa, and A. Tolmach. Building program optimizers \nwith rewriting strategies. SIGPLAN Not., 34(1):13 26, 1999. [51] D. L. Whit.eld and M. L. Soffa. An approach \nfor exploring code improving transformations. ACM Trans. Program. Lang. Syst., 19(6):1053 1084, 1997. \n   Appendices The Structural Enhancement Rules (SER) Lan\u00adguage s EBNF Grammar A. Base syntax A.1 Variant \nAttributes String Char = Printable -[\"] StringLiteral = \" String Char* \" IdLetter = Letter IdAlphaNumeric \n= Alphanumeric Identifier = IdLetterIdAlphaNumeric* IndirectCharLiteral = QuoteCharSign1Quote Case Sensitive \n = True Start Symbol = <CompilationUnit> Comment Line = -- <Literal> ::= StringLiteral <Modifiers> \n::= <Modifier> | <Modifiers> <Modifier> <Modifier> ::= public | protected | private | static | abstract \n| final | native | synchronized <ClassAccess> ::= <SERClass Type> . <ClassAttribute> <ClassAttribute> \n::= Name | Type <ModuleAccess> ::= Identifier . <ClassAccess> <AssignOptr> ::= = | += <NamingConvention> \n::= <Literal> <Prefix> ::= <Literal> <Name> ::= <SimpleName> | <QualifiedName> <SimpleName> ::= Identifier \n<QualifiedName> ::= <Name> . Identifier  A.2 Type and Signature syntax <PatternVarType> ::= Pattern \n<IteratorVarType> ::= Iterator <Type> ::= Class | Interface <SERClass Type> ::= OrgClass | EnhClass <Type> \n::= <PrimitiveType> | <ReferenceType> <PrimitiveType> ::= <NumericType> | boolean <NumericType> ::= <IntegralType> \n| <FloatingPointType> <IntegralType> ::= byte | short | int | long | char <FloatingPointType> ::= float \n| double <ReferenceType> ::= <ClassInterfaceType> | <ArrayType> <ClassInterfaceType> ::= <ClassType> \n| <InterfaceType> <ClassType> ::= Identifier <InterfaceType> ::= Identifier <ArrayType> ::= <Type> [ \n] <SignatureDclr> ::= <MethodHeader> <MethodHeader> ::= <Modifiers>? <ResultType> <MethodDeclarator> \n<Throws>? <ResultType> ::= <Type> | void <MethodDeclarator> ::= <Identifier> ( <FormalParameterList>? \n) <FormalParameterList> ::= <FormalParameter> | <FormalParameterList> , <FormalParameter> <FormalParameter> \n ::= <Type> <VariableDeclaratorId> <VariableDeclaratorId> ::= <Identifier> | <VariableDeclaratorId> [ \n] <Throws> ::= throws <ClassTypeList> <ClassTypeList> ::= <ClassType> | <ClassTypeList> , <ClassType> \n A.3 Body syntax <CompilationUnit> ::= <ProgramDclr> | <ProgramDclr> | <ModuleDclr> <ProgramDclr> ::= \nProgram <Name> <ModuleDclr> ::= Module <Name> <ProgramBody> ::= Begin End | Begin <ModuleBody> End <ModuleBody> \n::= Begin End B. Iterator syntax <IterVar> ::= Identifier <IteratorVarId> ::= Var <IteratorVarType> \n<IterVar> <IteratorVarDclr> ::= <IteratorVarId> <AssignOptr> <MethodInvocation> <MethodInvocation> ::= \n<SERClass Type> . <Accessors> | <SERClass Type> . <IteratationHandler> | <SERClass Type> . <ModificationHandler> \n C. Pattern syntax <PatternVar> ::= Identifier <PatternVarId> ::= Var <PatternVarType> <PatternVar> <PatternVarDclr> \n::= <PatternVarId> <PatternDclrBody> <PatternDclrBody> ::= Begin <PatternDclr> End <PatternDclr> ::= \n<PatternModifierDclr> | <PatternTypeDclr> | <PatternNameDclr> | <PatternSignatureDclr> <PatternModifierDclr> \n::= <ModiferAccess> <AssignOptr> <Modifier> <PatternTypeDclr> ::= <TypeAccess> <AssignOptr> <ModuleAccess> \n<PatternNameDclr> ::= <NameAccess> <AssignOptr> <NamingConvention> <PatternSignatureDclr> ::= <SignatureAccess> \n<AssignOptr> <SignatureDclr> <PatternAccess> ::= <ModiferAccess> | <TypeAccess> | <NameAccess> E. Addition \nand removal syntax | <SignatureAccess> <ModificationHandler> <ModiferAccess> ::= modifiers ::= <AddInterface> \n| <RemoveInterface> <TypeAccess> ::= type | <AddSuperclass> | <RemoveSuperclass> <NameAccess> ::= name \n| <AddConstructor> | <RemoveConstructor> <SignatureAccess> ::= signature | <AddMethod> | <RemoveMethod> \n| <AddField> | <RemoveField> D. Access and Replication syntax <AddInterface> <Accessors> ::= AddInterface \n ( <IterVar> ) ::= <Constructors> <AddSuperclass> | <Methods> ::= AddSuperclass ( <IterVar> ) | <Fields> \n <AddConstructor> <Constructors> ::= AddConstructor ( <PatternVar> ) ::= Constructors ( ) <AddMethod> \n| Constructors ( <PatternVar> ) ::= AddMethod ( <IterVar> ) <Methods> | AddMethod ( <PatternVar> ) \n::= Methods ( ) <AddField> | Methods ( <PatternVar> ) ::= AddField ( <IterVar> ) <Fields> ::= AddField \n ( <PatternVar> ) ::= Fields ( ) <RemoveInterface> | Fields ( <PatternVar> ) ::= RemoveInterface \n( <IterVar> ) <IteratationHandler> <RemoveSuperclass> ::= <FieldGetReplacer> | <FieldSetReplacer> ::= \nRemoveSuperclass ( <IterVar> ) | <CreateNewIterator> <RemoveConstructor> <FieldGetReplacer> ::= RemoveConstructor \n ( <PatternVar> ) ::= FieldGetReplacer ( <Prefix> , <IterVar> ) <RemoveMethod> <FieldSetReplacer> ::= \nRemoveMethod ( <IterVar> ) ::= FieldSetReplacer ( <Prefix> , <IterVar> ) | RemoveMethod ( <PatternVar> \n) <CreateNewIterator> <RemoveField> ::= CreateNewIterator ( <IterVar> ) ::= RemoveField ( <IterVar> \n) ::= RemoveField ( <PatternVar> )  \n\t\t\t", "proc_id": "1640089", "abstract": "<p>Programs written in managed languages are compiled to a platform-independent intermediate representation, such as Java bytecode. The relative high level of Java bytecode has engendered a widespread practice of changing the bytecode directly, without modifying the maintained version of the source code. This practice, called <i>bytecode engineering</i> or <i>enhancement</i>, has become indispensable in introducing various concerns, including persistence, distribution, and security, transparently. For example, transparent persistence architectures help avoid the entanglement of business and persistence logic in the source code by changing the bytecode directly to synchronize objects with stable storage. With functionality added directly at the bytecode level, the source code reflects only partial semantics of the program. Specifically, the programmer can neither ascertain the program's runtime behavior by browsing its source code, nor map the runtime behavior back to the original source code.</p> <p>This paper presents an approach that improves the utility of source-level programming tools by providing enhancement specifications written in a domain-specific language. By interpreting the specifications, a source-level programming tool can gain an awareness of the bytecode enhancements and improve its precision and usability. We demonstrate the applicability of our approach by making a source code editor and a symbolic debugger enhancements-aware.</p>", "authors": [{"name": "Myoungkyu Song", "author_profile_id": "81436594687", "affiliation": "Virginia Tech, Blacksburg, VA, USA", "person_id": "P1728777", "email_address": "", "orcid_id": ""}, {"name": "Eli Tilevich", "author_profile_id": "81100650102", "affiliation": "Virginia Tech, Blacksburg, VA, USA", "person_id": "P1728778", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640112", "year": "2009", "article_id": "1640112", "conference": "OOPSLA", "title": "Enhancing source-level programming tools with an awareness of transparent program transformations", "url": "http://dl.acm.org/citation.cfm?id=1640112"}