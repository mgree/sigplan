{"article_publication_date": "10-25-2009", "fulltext": "\n On Understanding Data Abstraction, Revisited William R. Cook University of Texas at Austin wcook@cs.utexas.edu \nAbstract In 1985 Luca Cardelli and Peter Wegner, my advisor, pub\u00adlished an ACM Computing Surveys paper \ncalled On un\u00adderstanding types, data abstraction, and polymorphism . Their work kicked off a .ood of \nresearch on semantics and type theory for object-oriented programming, which contin\u00adues to this day. \nDespite 25 years of research, there is still widespread confusion about the two forms of data abstrac\u00adtion, \nabstract data types and objects. This essay attempts to explain the differences and also why the differences \nmatter. Categories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features \nAbstract data types; D.3.3 [Programming Languages]: Language Constructs and Features Classes and objects \nGeneral Terms Languages Keywords object, class, abstract data type, ADT 1. Introduction What is the relationship \nbetween objects and abstract data types (ADTs)? I have asked this question to many groups of computer \nscientists over the last 20 years. I usually ask it at dinner, or over drinks. The typical response is \na variant of objects are a kind of abstract data type . This response is consistent with most programming \nlan\u00adguage textbooks. Tucker and Noonan [57] write A class is itself an abstract data type . Pratt and \nZelkowitz [51] in\u00adtermix discussion of Ada, C++, Java, and Smalltalk as if they were all slight variations \non the same idea. Sebesta [54] writes the abstract data types in object-oriented languages... are called \nclasses. He uses abstract data types and data abstraction as synonyms. Scott [53] describes objects in \nde\u00adtail, but does not mention abstract data types other than giv\u00ading a reasonable discussion of opaque \ntypes. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n2009, October 25 29, 2009, Orlando, Florida, USA. Copyright c &#38;#169; 2009 ACM 978-1-60558-734-9/09/10. \n. . $10.00 So what is the point of asking this question? Everyone knows the answer. It s in the textbooks. \nThe answer may be a little fuzzy, but nobody feels that it s a big issue. If I didn t press the issue, \neveryone would nod and the conversation would move on to more important topics. But I do press the issue. \nI don t say it, but they can tell I have an agenda. My point is that the textbooks mentioned above are \nwrong! Objects and abstract data types are not the same thing, and neither one is a variation of the \nother. They are fundamentally different and in many ways complementary, in that the strengths of one \nare the weaknesses of the other. The issues are obscured by the fact that most modern pro\u00adgramming languages \nsupport both objects and abstract data types, often blending them together into one syntactic form. But \nsyntactic blending does not erase fundamental semantic differences which affect .exibility, extensibility, \nsafety and performance of programs. Therefore, to use modern pro\u00adgramming languages effectively, one \nshould understand the fundamental difference between objects and abstract data types. While objects and \nADTs are fundamentally different, they are both forms of data abstraction. The general con\u00adcept of data \nabstraction refers to any mechanism for hiding the implementation details of data. The concept of data \nab\u00adstraction has existed long before the term data abstraction came into existence. In mathematics, there \nis a long history of abstract representations for data. As a simple example, consider the representation \nof integer sets. Two standard ap\u00adproaches to describe sets abstractly are as an algebra or as a characteristic \nfunction. An algebra has a sort, or collection of abstract values, and operations to manipulate the values1. \nThe characteristic function for a set maps a domain of values to a boolean value, which indicates whether \nor not the value is included in the set. These two traditions in mathematics correspond closely to the \ntwo forms of data abstraction in programming: algebras relate to abstract data types, while characteristic \nfunctions are a form of object. In the rest of this essay, I elaborate on this example to explain the \ndifferences between objects and ADTs. The 1 The sort, or carrier set, of an algebra is often described \nas a set, making this de.nition circular. Our goal is to de.ne speci.c set abstractions with restricted \noperations, which may be based on and assume a more general concept of sets  examples focus on non-mutable \nobjects, because they are suf.cient to explain the main points. Other topics, including inheritance and \nre.ection, are also ignored in order to focus on the basic idea of data abstraction. When I m inciting \ndiscussion of this topic over drinks, I don t tell the the full story up front. It is more fun to keep \nasking questions as the group explores the topic. It is a lively discussion, because most of these ideas \nare documented in the literature and all the basic facts are known. What is interesting is that the conclusions \nto be drawn from the facts are not as widely known. Most groups eventually work through the differences \nbetween objects and ADTs, but I can tell they walk away feeling uneasy, as if some familiar signposts \nnow point in different directions. One source of unease is that the fundamental distinctions are obscured, \nbut not eliminated, in real programming languages. Also, the story is quite complex and multi-faceted. \nThis essay is only an introduction to a large body of literature on the relationship between objects \nand ADTs. In my conversations about objects and ADTs, my next step is to push the discussion towards \na more precise under\u00adstanding of data abstraction. What is an abstract data type? What is an object? \nFor abstract data types, there is general agreement. 2. Abstract Data Types An abstract data type (ADT) \nhas a public name, a hidden representation, and operations to create, combine, and ob\u00adserve values of \nthe abstraction. The familiar built-in types in most languages, for example the int and bool data types \nin Algol, Pascal, ML, Java and Haskell, are abstract data types. In addition to built-in abstract data \ntypes, some languages support user-de.ned abstract data types. User-de.ned ab\u00adstract data types that \nresemble built-in data types were .rst realized in CLU [37, 36] and Alphard [61] in the 1970s. There \nwere also strong connections to algebraic speci.cation of data types [24, 7] The core ideas introduced \nin CLU were adapted for ML [42], Ada [49], Modula-2 [60]. As an exam\u00adple, Figure 1 de.nes an abstraction \nfor integer sets, adapted from the CLU reference manual [36]. The representation type is a list of integers. \nIn discussions of CLU, these values are called objects or data objects , although they are not necessarily \nthe same as objects in object-oriented programming. CLU used explicit syntax and operators to manage \nthe hiding of the representation. The cvt type represents the public view of the representation type, \nwhile the functions up and down convert between public and private views of the type. Rather than explain \nCLU in detail, it is easier to give the same abstraction in ML, as in Figure 2, where the hiding mechanism \nis simpli.ed and type inference simpli.es the types. Figure 3 gives the signature of the resulting abstract \ndata type. A signature de.nes the type name (but not its repre\u00ad set = cluster is empty, contains, insert \nrep = oneof[empty: null, pair: struct[.rst:int, rest:rep]] empty = proc() returns (cvt) return(rep$make \nempty(nil)); end empty; insert = proc(s: cvt, i: int) returns (cvt) if contains(up(s), i) then return(rep$make \npair(pair$(.rst:i,rest:s)) else return(s); end end insert isEmpty = proc(s: cvt) returns (bool) typecase \ns tag empty: return(true) tag pair(p:pair): return(false); end end empty; contains = proc(s: cvt, i: \nint) typecase s tag empty: return(false) tag pair(p:pair): if p..rst = i then return(true) else return(contains(up(p.rest), \ni)) end end contains union = proc(s1: cvt, s2: cvt) typecase s1 tag empty: return(s2) tag pair(p:pair): \n return insert(union(up(p.rest), s2), p..rst) end end union end set Figure 1. CLU cluster for integer \nsets sentation) and the types of the operations. The signature can be extended with a full speci.cation \nof the behavior of inte\u00adger sets. Abstract data types support very powerful speci.ca\u00adtion and veri.cation \ntechniques, including equational theo\u00adries [20, 3, 7] and axiomatic speci.cations [26, 40, 17]. The speci.cations \nwork well in this context; they are intuitive, elegant and sound. Clients can declare values of type \nset and use operations to manipulate the values. let a = empty() b = insert(a, 3) in if contains(b, 2) \nthen yes else no abstype set = EMPTY | INS of int * set where  val empty = EMPTY fun insert(s, i) = \nif not contains(s, i) then INS(i, s) else s fun isEmpty(s) = (s == EMPTY) fun contains(s, i) = case s \nof EMPTY . false | INS(n, r) . if i=n then true else contains(r, i) end fun union(s1,s2)= case s1 of \nEMPTY . s2 | INS(n1,r1) . insert(union(r1,s2), n1) end end Figure 2. ML abstract data type (ADT) for \ninteger sets type set val empty : set val isEmpty : set . bool val insert : set \u00d7 int . set val contains \n: set \u00d7 int . bool val union : set \u00d7 set . set Figure 3. Signature for integer set abstract data type \nBut clients cannot inspect the representation. This is why the isEmpty function is needed, because the \nfollowing pro\u00adgram is illegal when written outside of the abstraction: fun test(a : set) = (a == EMPTY); \nThe function test is attempting to break the encapsulation of the data abstraction to peek at its internal \nrepresentation. There is also no prede.ned notion of equality on integer sets. If equality is desired, \nit must be programmed and made explicit in the ADT interface. 2.1 Representation Independence The name \nset is abstract because it has a public name but its details are hidden. This is a fundamental characteristic \nof ab\u00adstraction: something is visible on the surface, but the details are hidden. In the case of type \nabstraction, the type name is public, but the representation is hidden. With procedural abstraction, \nthe procedure interface (name and arguments) is public, but the operational details are hidden. Type \nabstrac\u00adtion is a technical mechanism that can be used to support data abstraction. One of the practical \nbene.ts of data abstraction is that it allows internal implementation details to be changed with\u00adout \naffecting the users of the abstraction. For example, we could modify the code for set to represent integer \nsets as hash tables or balanced binary trees. For example, Figure 4 is an alternative implementation \nbased on a sorted list repre\u00adsentation. 2.2 Optimization A different implementation opens up the possibility \nfor op\u00adtimizing some of the operations. For example, the union op\u00aderation in Figure 2 is quite expensive \nto compute. With a sorted list representation union is computed in linear time. Insertion is faster in \nsome cases, but it may require copying more nodes. Deciding what representations to use, based on the \nassociated algorithmic trade-offs, is a standard software engineering activity. These optimizations depend \ncritically upon an important feature of abstract data types: the ability to inspect the rep\u00adresentation \nof more than one abstract value at the same time. Multiple representations are inspected in the union \nopera\u00adtion. There is nothing surprising about inspecting multiple representations. It is a natural side-effect \nof the type sys\u00adtem and the fact that all values of type set belong to the abstract data type implementation \nthat created them. As we shall see, the ability to inspect multiple representations does have some important \nconsequences.  2.3 Unique Implementations With ML abstypes, CLU clusters, Ada packages and Modula\u00ad2 \nmodules there can only be one implementation of an ab\u00adstract data type in any given program. The implementation \nis a construct that manages a collection of values that inhabit the type. All the values from a given \nimplementation share the same representation type, although there can be multiple different representational \nvariants within the type. This is usually accomplished by de.ning the representation type as a labeled \nsum. The type name set is a globally bound name that refers to a single hidden representation. The type \nsystem ensures that it is sound for the implementation to inspect any set value. Having only one implementation \nof a data abstraction is limiting. There is already a name clash between the de.ni\u00adtions in Figures 2 \nand 4. One of them had to be given a differ\u00adent name, set2, even though they are really just two different \nversions of the same abstraction. Client programs have to be edited to choose one or the other implementation. \nADTs are also frequently used in C programming [32], using header .les as a simple module system. The \nsignature of the type is given in a header .le as a forward reference to a structure that is only de.ned \nin the implementation .le. An example header .le for integer sets is given in Figure 5. This trick works \nbecause the C compiler does not need to know  abstype set2 = EMPTY | INS of int * set2 where val empty \n= EMPTY fun insert(s, i) = case s of EMPTY . INS(i, s) | INS(n, r) . if i=n then s else if i < n then \nINS(i, s) else let t = insert(r, i) in if r=t then s else INS(n, t) fun isEmpty(s) = (s == EMPTY) fun \ncontains(s, i) = case s of EMPTY . false | INS(n, r) . if i=n then true else if i > n then false else \ncontains(r, i) end fun union(s1,s2)= case s1 of EMPTY . s2 | INS(n1,r1) . case s2 of EMPTY . s1 | INS(n2,r2) \n. if n1 =n2 then insert(n1, union(r1,r2)) else if n1 < n2 then insert(n1, union(r1,s2)) else insert(n2, \nunion(s1,r2)) end end end Figure 4. Integer set ADT with sorted list representation struct set rep; // \nrepresentation is not de.ned in header typedef struct set rep* set; set empty(); bool isEmpty(set s); \nset insert(set s, int i); bool contains(set s, int i); set union(set s1, set s2); Figure 5. Abstract \ndata type in C header .le type SetImp = . rep . {empty : rep, isEmpty : rep . bool, insert : rep \u00d7 Int \n. rep, contains : rep \u00d7 Int . Bool, union : rep \u00d7 rep . rep } Figure 6. Type of .rst-class ADT set implementations \nthe format of the representation type, it only needs to know the size of a pointer to the representation. \n 2.4 Module Systems The problem of unique implementation is solved by putting abstract data types into \nmodules. ML [39] has a module sys\u00adtem that allows multiple implementations for a given signa\u00adture. The \nsignature of an abstraction can be de.ned once, and multiple implementations written in separate modules. \nA client program can then be parameterized over the sig\u00adnature, so that a particular implementation can \nbe selected during module binding. There can be multiple implementa\u00adtions in software repository, but \none implementation is used in a given program. Allowing multiple implementations is good, but it is still \nnot as .exible as might be desired. Consider a case where one part of a program needs to use the sorted \nlist representa\u00adtion for integer sets, and another part of the program needs to use a binary tree representation. \nHaving two different im\u00adplementations for an abstraction is possible in ML, Ada, or Module-2. However, \nthe two different parts of the program cannot interoperate. The different parts of the program can\u00adnot \nexchange integer sets. As a result the following program is illegal: fun f(a : set, b : set2) = union(a, \nb) There is no union operation to combine a set with a set2. Given the signature we have de.ned, it is \nnot even possible to write such an operation. The ML module system also allows multiple inter-related \nabstract types to be de.ned in a single module. For example, a personnel application might have data \nabstractions Em\u00adployee and Department with operations to associate employ\u00adees with departments.  2.5 \nFormal Models Formal models of abstract data types are based on existential types [44]. In this model, \nADT implementations are .rst class values with existential type, as de.ned in Figure 6. A value of type \nSetImp is not a set, it is an implementa\u00adtion of a set abstraction. This two-level structure is essential \nto abstract data types: the .rst level is an implementation (SetImp) which publishes an abstract type \nname and a set of operations. Within that implementation, at the second level, are the values that represent \nelements of the named abstract type (set).  This existential type is nearly identical to the signature \nin Figure 3. Intuitively, it asserts that a type locally identi\u00ad.ed as rep exists such that the following \noperations are de\u00ad.ned... . Most practical languages do not support the full general\u00adity of .rst-class \nADT implementations. Thus existential val\u00adues and their usage are not familiar to most programmers. Explaining \nthe mechanics of existential types is beyond the scope of this essay. They are described in Cardelli \nand Weg\u00adner s paper [10], and also covered thoroughly in Pierce s book, Types and Programming Languages \n[50]. To use an existential value, it must be opened to declare a name for the representation type and \naccess the operations. Each time an existential value is opened, it creates a com\u00adpletely new type name. \nThus if an ADT implementation is opened twice, the values from one instance cannot be mixed with values \nfrom the other instance. In practice, it is stan\u00addard to open all ADTs once in the global scope of the \npro\u00adgram. The ML module system has more sophisticated shar\u00ading mechanisms that allow multiple implementations \nto co\u00adexist, while allowing interoperability between multiple uses of the same abstractions. Even in \nthis case values from the two different implementations cannot be mixed.  2.6 Summary An abstract data \ntype is a structure that implements a new type by hiding the representation of the type and supplying \noperations to manipulate its values. There are several ways in which abstract data types seem fundamentally \nright. They work just like built-in types.  They have sound proof techniques.  ADTs can be implemented \nef.ciently, even for complex operations that require inspection of multiple abstract values.  From a \ntype theory viewpoint, abstract data types have a fundamental model based on existential types. Existential \ntypes are the dual of universal types, which are the basis for parametric polymorphism (called generics \nin Java and C#). The duality of universal and existential types is fundamental, and it leaves little \nroom for any other alternative. What else could there be?  There is a solid connection to mathematics. \nAn ADT has the same form as an abstract algebra: a type name rep\u00adresenting an abstract set of values \ntogether with opera\u00adtions on the values. The operations can be unary, binary, multi-ary, or nullary (that \nis, constructors) and they are all treated uniformly.  All of these observations lead to the general \nconclusion that abstract data types are the way to de.ne data abstrac\u00adtions. This belief is so deep-seated, \nso obviously correct, that it is almost impossible to think of any alternative. Many peo\u00adple take abstract \ndata type and data abstraction as syn\u00adonyms. But abstract data types are not the only way to de.ne data \nabstractions. The alternative is fundamentally different. 3. Objects Object-oriented programming has \nits origin in the language Simula 67 [16]. Zilles published a paper describing a form of objects [62] \nbefore he started working with Liskov and switched his focus to ADTs. At the same time, Smalltalk [55, \n28], Actors [25] and Scheme [56, 1] all explored objects in an untyped setting. Smalltalk especially \nformulated these ideas into a philosophically and practically compelling lan\u00adguage and environment for \nobject-oriented programming. As these languages were all dynamically typed, they did not immediately \ncontribute to the ongoing dialog about statically typed data abstraction in the form of ADTs. There is \nnot a single universally accepted model of object-oriented programming. The model that I present here \nis recognized as valid by experts in the .eld, although there certainly are other valid models. In particular, \nI present ob\u00adjects in a denotational style which I believe exposes their core concepts in an intuitive \nway. I believe that operational approaches obscure the essential insights. In this section I discuss \na pure form of object-oriented programming with interfaces [9, 8]. The practical realities of popular \nlanguages are discussed in Section 5. To begin with, let us reconsider the idea of integer sets. One \nalternative way to formulate integer sets is as the char\u00adacteristic function: type ISet = Int . Boolean \nThe type Int . Boolean is the type of functions from integer to boolean. It is clear that this is a different \nway to think about sets than the abstract data types presented in the previous section. Consider a few \nvalues of this type: Empty = .i. false Insert(s, n) = .i. (i = n or s(i)) Union(s1,s2)= .i. (s1(i) or \ns2(i)) The expression .i.e represents a function with a parame\u00adter named i and a result expression e. \nThe empty set is just a function that always returns false. Inserting n into a set s creates a function \nthat tests for equality with n or member\u00adship in the functional set s. Given these de.nitions, it is \neasy to create and manipulate sets: a = Insert(Empty, 1) b = Insert(a, 3) print a(3) results in true \nIn what sense could ISet be understood as de.ning a data abstraction for integer sets? We have been conditioned \nto think in terms of representations and operations. But these  interface ISet = {isEmpty : bool, contains \n: int . bool, insert : int . ISet, union : ISet . ISet } Figure 7. Object-oriented integer set interface \nconcepts do not apply in this case. One might say that this approach represents sets as functions from \nintegers to booleans. But this representation looks like an interface, not a concrete representation. \nNote that there is no contains operation, because the set itself is the contains operation. Although \nit may not seem like it, the characteristic function is the pure object-oriented approach to de.ning \ninteger sets. You may not accept this statement immediately, because I have not talked about any classes, \nmethods, or inheritance, which are supposed to be characteristic of objects. 3.1 Object Interfaces ISet \nis an object-oriented interface to an integer set data ab\u00adstraction. The function is an observation of \nthe set, and a set is represented by the observations that can be performed upon it. One problem with \nthis interface is that there is no way to tell if the set is empty. A more complete interface is given \nin Figure 7. It is a record type with four components corresponding to methods. The .eld names of the \nrecord are capitalized, to distinguish them from other uses of the same names. The result is a standard \nobject-oriented interface for immutable integer set objects. An essential observation is that object \ninterfaces do not use type abstraction: there is no type whose name is known but representation is hidden. \nThe type ISet is de.ned as a record type containing functions from known types to known types. Instead, \nobjects use procedural abstraction to hide behavior. This difference has signi.cant consequences for \nuse of the two forms of data abstraction. Object interfaces are essentially higher-order types, in the \nsame sense that passing functions as values is higher-order. Any time an object is passed as a value, \nor returned as a value, the object-oriented program is passing functions as values and returning functions \nas values. The fact that the functions are collected into records and called methods is irrelevant. As \na result, the typical object-oriented program makes far more use of higher-order values than many func\u00adtional \nprograms. The empty operation in the ADT is not part of the object\u00adoriented ISet interface. This is because \nit is not an observa\u00adtion on sets, it is a constructor of sets. Empty = \u00b5 this. {isEmpty = true, contains \n= .i. false insert = .i. Insert(this, i) union = .s. s } Insert(s, n) = if s(n) then s else \u00b5 this. {isEmpty \n= false, contains = .i. (i = n or s(i)) insert = .i. Insert(this, i) union = .s. Union(this, s) } Union(s1,s2)= \n\u00b5 this. {isEmpty = false, contains = .i. (s1(i) or s2(i)) insert = .i. Insert(this, i) union = .s. Union(this, \ns) } Figure 8. Object-oriented integer set implementations  3.2 Classes Several implementations for \nthe ISet interface are de.ned in Figure 8. The contains method is the same as the simple functions given \nabove. The de.nitions have the same types, after rede.ning ISet. The special symbol \u00b5 is used to de.ne \nrecursive val\u00adues [50]. The syntax \u00b5x.f de.nes a recursive value where the name x can appear in the expression \nf. The meaning of \u00b5x.f is the value of f where occurences of x represent recur\u00adsive references within \nf to itself. Objects are almost always self-referential values, so every object de.nition uses \u00b5. As \na convention, we use this as the name x, but any name could be used. The bound name x corresponds to \nself in Smalltalk or this in C++. Each of these de.nitions correspond to a class in object\u00adoriented programming. \nIn this encoding, classes are only used to construct objects. The use of classes as types is discussed \nlater. The de.nition of class state, or member variables, is dif\u00adferent from Java [21]. In this encoding, \nthe member variables are listed as parameters on the class, as in Scala [47]. Several of the method bodies \nare repeated in these de.\u00adnitions. The insert method simply invokes the Insert class to create a new \nISet object with one more member. Inheritance could be used to reuse a single method de.nition. Inheri\u00adtance \nis often mentioned as one of the essential character\u00adistics of object-oriented programming. However, \ninheritance will not be used in this section because it is neither necessary for, nor speci.c to, object-oriented \nprogramming [13].  A client of these classes looks just like a Java program, with the familiar method \ninvocation style: Empty.insert(3).union(Empty.insert(1)) .insert(5).contains(4) Selecting a function \nto invoke from a record containing function values is usually called dynamic binding. This term is not \na very intuitive description of what is essentially an invocation of a higher-order function. Just as \nthe ADT version of integer sets had two levels (set implementations and set values), the object-oriented \nversion has two levels as well: interfaces and classes. A class is a procedure that returns a value satisfying \nan interface. Al\u00adthough Java allows class constructors to be overloaded with more than one de.nition, \nit is clear that one of the primary purposes of a class is to construct objects.  3.3 Autognosis A careful \nexamination of the union operator in the object interface, in Figure 7, reveals that the parameter is \ntyped by an interface. This means that the union method in a set object cannot know the representation \nof the other set being unioned. Fortunately, the union operator does not need to know the representation \nof other sets, it just needs to be able to test membership. The Union class in Figure 8 constructs an \nobject that represents the union of two sets s1 and s2. To me, the prohibition of inspecting the representation \nof other objects is one of the de.ning characteristics of object\u00adoriented programming. I term this the \nautognostic principle: An object can only access other objects through their public interfaces. Autognosis \nmeans self knowledge . An autognostic ob\u00adject can only have detailed knowledge of itself. All other objects \nare abstract. The converse is quite useful: any programming model that allows inspection of the representation \nof more than one abstraction at a time is not object-oriented. One of the most pure object-oriented programming \nmod\u00adels yet de.ned is the Component Object Model (COM) [5, 22]. It enforces all of these principles rigorously. \nProgram\u00adming in COM is very .exible and powerful as a result. There is no built-in notion of equality. \nThere is no way to determine if an object is an instance of a given class. Autognosis has a profound \nimpact on the software engi\u00adneering properties of a system. In particular, an autognostic system is much \nmore .exible. But at the same time, it can be more dif.cult to optimize operations. More signi.cantly, \nthere can be subtle relationships between the public interface of a class and the ability to implement \nbehavior, as discussed in Section 3.5. 3.4 Flexibility Object interfaces do not prescribe a speci.c \nrepresentation for values, but instead accept any value that implements the required methods. As a result, \nobjects are .exible and extensible with new representations. The .exibility of object interfaces can \nbe illustrated easily by de.ning several new kinds of set. For example, the set of all even integers, \nand the set of all integers, are easily de.ned: Even = \u00b5 this. { isEmpty = false, contains = .i. (i mod \n2 = 0) insert = .i. Insert(this, i) union = .s. Union(this, s) } Full = \u00b5 this. { isEmpty = false, contains \n= .i. true insert = .i. this union = .s. this } The Full set returns itself as the result of any insert \nor union operation. This example also illustrates that objects can easily represent in.nite sets easily. \nThese new sets can be intermixed with the sets de.ned above. Other specialized sets can also be de.ned, \nincluding the set of prime numbers or sets representing intervals. Interval(n, m) = \u00b5 this. { isEmpty \n= (n > m), contains = .i. (n = i and i = m) insert = .i. Insert(this, i) union = .s. Union(this, s) \n} There is no direct equivalent to this kind of .exibility when using abstract data types. This difference \nis fundamen\u00adtal: abstract data types have a private, protected representa\u00adtion type that prohibits tampering \nor extension. Objects have behavioral interfaces which allow de.nition of new imple\u00admentations at any \ntime. The extensibility of objects does not depend upon inheri\u00adtance, but rather is an inherent property \nof object interfaces.  3.5 Interface Trade-Offs The choice of interfaces to an object can affect which \nopera\u00adtions are ef.cient, which are slow, and also which operations are impossible to de.ne. For example, \nit is not possible to augment the integer set interface with an intersect operation, because it is not \npossi\u00adble to determine if the intersection of two sets is empty with\u00adout iterating over the sets. It \nis commonplace to include iter\u00adator methods in collection classes like the ones given here. But iterators \ndo not interact well with in.nite sets. Signi.\u00adcant software engineering decisions must be made when \nde\u00adsigning interfaces, but these issues are rarely discussed in programming language textbooks.  One \nproblem with object interfaces is that ef.ciency con\u00adsiderations often allow implementation issues to \nin.uence the design of interfaces. Adding public methods that in\u00adspect the hidden representation can \nsigni.cantly improve ef\u00ad.ciency. But it also restricts the .exibility and extensibility of the resulting \ninterface.  3.6 Optimization The optimization of the union method based on sorted lists is not possible \nin the object-oriented implementation, without modifying the interfaces. The optimization would be possi\u00adble \nif the interfaces included a method to iterate the set con\u00adtents in sorted order. Extending an object \ninterface with more public methods can signi.cantly improve performance, but it also tends to reduce \n.exibility. If the sets used a more so\u00adphisticated representation, optimizations might require more representational \ndetails to be exposed in the public interface. There are several optimizations in the object implementa\u00adtion \nin Figure 8. The .rst is that the union method on empty sets is the identity function. The second is \nthat the insert class does not always construct a new value. It only creates a new value if the number \nbeing inserted is not in the set already. It is not necessary to include insert and union as methods \ninside the object interface, because they can be de.ned as classes that operate on any sets. The optimization \nof union in the empty set class is one reason why it is useful to internalize the creation operations \nin the object interface. 3.7 Simulation Object-oriented programming was .rst invented in the con\u00adtext \nof the simulation language Simula [16, 4]. The original intent was to simulate real-world systems, but \nI believe that simulation also allows one object to simulate, or pretend to be, another object. For example, \nthe set Interval(2, 5) simulates a set that has integers 2 through 5 inserted into it. According to the \nprinciple of autognosis, there should be no way for any part of the program to distinguish between the \ninterval and the inserted set. There are many operations that violate this principle, including pointer \nequality and instanceof tests. Simulation also provides a basis for veri.cation of object\u00adoriented programs. \nIf two objects simulate each other, form\u00ading a bisimulation, then they are equivalent [41]. The con\u00adcept \nof simulation and bisimulation are powerful mathemat\u00adical concepts for analyzing the behaviors. 3.8 \nSpeci.cations and Veri.cation Object-oriented programming has caused signi.cant prob\u00adlems for veri.cation \nefforts [34, 45, 2]. This is not surpris\u00ading if you understand that object-oriented programming is high-order \nprocedural programming; objects are a form of .rst-class procedure value, which are passed as arguments \nand returned as values everywhere. It is dif.cult to verify programs that combine .rst-class higher-order \nfunctions and imperative state. A common complaint is that it is impossible to determine what code will \nexecute when invoking a method. This is no different from common uses of .rst-class functions. If this \nobjection is taken seriously, then similar complaints must be leveled against ML and Haskell, because \nit is impossible (in general) to determine what code will run when invoking a function value. More signi.cantly, \nit is possible to create bad objects easily. For example, the following object does not meet the speci.cation \nfor integer sets: bad = \u00b5 this. { IsEmpty = (random() > 0.5), Contains = .i. (time() mod i = 1) Insert \n= .i. this Union = .s. Insert(3, s) } It reports that it is empty 50% of the time, and includes integers \nrandomly based on time of day. Object interfaces can be given behavioral speci.cations, which can be \nveri.ed to prohibit bad objects. A more subtle problem is that objects do not necessarily encapsulate \nstate effectively [27]. The problem arises when the state of an object is itself a collection of objects. \nThere is a tendency for the internal objects to leak out and become external, at which point the abstract \nboundary is lost. This problem motivates the ongoing research effort on ownership types [6]. One particularly \ndif.cult problem is that methods can be re-entered while they are running [46]. This causes problems \nfor the standard Hoare-style approach to veri.cation. In this approach, the class enforces an invariant, \nand every proce\u00addure (method) is given a precondition and a post-condition. The problem is that any method \ncalls within the body of the method may loop back around and invoke some other method of the object being \nveri.ed. In this case the other method may be called while the object is in an inconsistent state. It \nmay also modify the object state, to invalidate the assumptions used to verify the original method. Abstract \ndata types do not usually have this problem be\u00adcause they are built in layers; each layer invokes lower \nlay\u00aders, but lower layers do not invoke higher layers. Not all systems can be organized in this fashion, \nhowever. Complex systems often require noti.cations, or call-backs, which al\u00adlow lower layers to call \ninto higher layers. This can cause problems for veri.cation if call-backs are included in ADTs. Object-oriented \nprogramming is designed to be as .exi\u00adble as possible. It is almost as if it were designed to be as dif.cult \nto verify as possible.  3.9 Some More Theory The object interface has some interesting relationships \nto the abstract data type signature in Figures 3 and 6. First, the methods have one fewer argument than \nthe corresponding operations in the ADT signature. In each case, the rep ar\u00adgument is missing. Second, \nthe rep in the ADT operations corresponds to a recursive reference to ISet in each method of the object \ninterface. The similarity can be expressed by the following type function:  type F(t)= { IsEmpty : bool, \nContains : int . bool, Insert : int . t, Union : t . t } The types given above can be rewritten in terms \nof F: ISet = F(ISet) SetImp = . rep. rep \u00d7 (rep . F(rep)) The original de.nition of SetImp is isomorphic \nto this new de.nition. To see the relationship, note that in rep . F(rep) the function type with domain \nrep supplies the miss\u00ading argument that appears in all the ADT operations. The cartesian product with \nrep supplies the empty constructor. The de.nition of SetImp above is the encoding of a .nal coalgebra \nX . F (X) into the polymorphic .-calculus [19]. The only problem is that F is not a covariant functor, \nbe\u00adcause of the union method. This encoding also corresponds to the greatest .xedpoint of F , which corresponds \nto the re\u00adcursive type ISet. The relationship between coalgebra and objects is an active research topic \n[29].  3.10 Summary An object is a value exporting a procedural interface to data or behavior. Objects \nuse procedural abstraction for informa\u00adtion hiding, not type abstraction. Object and and their types \nare often recursive. Objects provide a simple and powerful form of data abstraction. They can be understood \nas clo\u00adsures, .rst-class modules, records of functions, or processes. Objects can also be used for procedural \nabstraction. Unlike abstract data types, many people .nd objects to be deeply disturbing. They are fundamentally \nhigher-order, unlike abstract data types. With an object, you are never quite certain what it is going \nto do: What method is being called? What kind of object is it really? On the other hand, many people \n.nd objects to be deeply appealing in their simplicity and .exibility. They do not require complex type \nsystems. Inheritance allows recursive values to be extended in powerful ways. The fact that objects are \nautognostic, so that they can only know themselves, is also confusing. On the one hand, it in\u00adterferes \nwith desirable optimizations that require inspection of multiple representations. One solution is to \nexpose repre\u00adsentational details in the object s interface, which limits .ex\u00adibility. The bene.ts of \nautognosis are often subtle and only realized as a system grows and evolves. Finally, as parts of a long \nand rich tradition of abstraction, objects too not just ADTs are fundamentally grounded in mathematics \n4. Relationships between ADTs and OOP Although object-oriented programming and abstract data types are \ntwo distinct forms of data abstraction, there are many relationships between them. Many simple abstractions \ncan be implemented in either style, although the usages of the resulting programs is quite different. \n4.1 Static Versus Dynamic Typing One of the most signi.cant differences between abstract data types and \nobjects is that objects can be used to de.ne data abstractions in a dynamically typed language. Objects \ndo not depend upon a static type system; all they need is some form of .rst-class functions or processes. \nAbstract data types depend upon a static type system to enforce type abstraction. It is not an accident \nthat dynamic languages use objects instead of user-de.ned abstract data types. Dynamic languages typically \nsupport built-in abstract data types for primitive types; the type abstraction here is enforced by the \nruntime system. Type systems only enforce structural properties of pro\u00adgrams; they do not ensure conformance \nto a speci.cation. But with ADTs, the type system can ensure that if the ADT implementation is correct, \nthen all programs based on it will operate correctly. The type system prevents outside clients from tampering \nwith the implementation. Pure object in\u00adterfaces allow any structurally compatible implementation, thus \nthe type system does not prohibit bad implementations from being used.  4.2 Simple and Complex Operations \nOne point of overlap between objects and abstract data types is that simple data abstractions can be \nimplemented equally well in either style. The difference between simple and com\u00adplex data abstractions \nis whether or not they have operations, like the union operation in the set ADT, that inspect the rep\u00adresentation \nof multiple abstract values. In this essay I call an operation complex if it inspects multiple representations. \nIn some of the literature complex operations are called binary . Literally speaking, a binary operation \nis one that accepts two inputs of the abstract type. For an object, a binary method is one that takes \na second value of the abstract type, in addition to the abstract value whose method is being invoked. \nAccording to these de.ni\u00adtions, union is always binary. However, not all binary methods are complex. \nThis de\u00adpends on how the operation is implemented. A binary opera\u00adtion can be implemented by invoking \npublic methods on the abstract arguments. Doing so does not require the represen\u00adtation of the two values \nto be inspected. The union operation in Figures 1 and 2 are simple. But the union operation in Figure \n4 is complex.  Pure object-oriented programming does not support com\u00adplex operations. Doing so requires \ninspection of another ob\u00adject s representation, using instance-of or similar means. Any abstract data \ntype with only simple operations can be implemented without loss of functionality, but more simply and \nextensibly, with objects. Consider an ADT implementation with the following type, where t does not appear \nin si, tj , .j, or dk. F(t) = { ci : si . t, oj :t \u00d7tj . .j, mk :t \u00d7dk . t } ADT : . t.F(t) The methods \nhave been partitioned into constructors, ob\u00adservations and mutators. The constructors ci create values \nof type t. The observations take an input of type t with addi\u00adtional arguments and produce values of \nsome other type. The mutators take an input of type t and produce a result of type t. These patterns \nare exhaustive, because there are no com\u00adplex methods. tj or dk is unit if there are no other arguments \nbesides t for a given operation. Create a new type I to represent the object interface: interface I = \n{ oj : tj . .j, mk : dk . I } For the constructors, de.ne a family of functions that invoke a wrap function \nthat creates the object. The notation for this example is that of Pierce s book Types and Programming \nLanguages [50]. Ci : si . T Ci(x : si)= let {*t, p} = ADT in wrap[t](p, p.ck(x)) wrap : .t. F(t) . I \nwrap[t](p, x) = { oj = .a:tj. p.mj(x, a); mk = .a:dk. wrap[t](p, p.mk(x, a)); } The constructors .rst \nopen the ADT, construct an appro\u00adpriate value of type t and then wrap it as an object. This transformation \nis a direct corollary of the basic de.nitions of ADTs [44] and objects [13]. The converse, however, is \nnot necessarily true. It is possi\u00adble to take any .xed set of object-oriented classes that imple\u00adment \nan interface and convert them to an ADT. One simple way to do it is to use objects as the representation \ntype for the ADT, but rewriting the abstractions is always possible. However, the result is no longer \nextensible, so the conver\u00adsion incurs a loss of .exibility.  4.3 Extensibility Problem When implementing \ndata abstractions, there are two impor\u00adtant dimensions of extensibility. New representational vari\u00adants \ncan be added, or new operations can be added. This observation suggests it is natural to organize the \nbehaviors into a matrix with representations on one axis and observa\u00adtions/actions on the other. Then \nextensibility can be viewed as adding a column or row to the matrix. In the 1970s, as work began on understanding \ndata ab\u00adstraction, Reynolds published a prophetic paper that iden\u00adti.ed the key differences between objects \nand abstract data types [52, 23], although I think he did not realize he was describing objects. Reynolds \nnoticed that abstract data types facilitate adding new operations, while procedural data val\u00adues (objects) \nfacilitate adding new representations. Since then, this duality has been independently discovered at \nleast three times [18, 14, 33], This duality has practical implications for program\u00adming [14]. Abstract \ndata types de.ne operations that collect together the behaviors for a given action. Objects organize \nthe matrix the other way, collecting together all the actions associated with a given representation. \nIt is easier to add new operations in an ADT, and new representations using ob\u00adjects. Although not discussed \nin detail here, object-oriented programs can use inheritance to add new operations [14]. Wadler later \ngave the problem a catchy name, the Ex\u00adpression Problem , based on the well-known canonical ex\u00adample \nof a data abstraction for expressions with operations to print, evaluate, or perform other actions [58]. \nThe extensibility problem has been solved in numerous ways, and it still inspires new work on extensibility \nof data abstractions [48, 15]. Multi-methods are another approach to this problem [11]. More complex \nvariations, involving integration of independent extensions, have still not been completely resolved. \n 4.4 Imperative State and Polymorphism Issues of imperative state and polymorphism have been avoided \nin this essay because they are, for the most part, orthogonal to the issues of data abstraction. The \ninteger sets discussed in this paper can be generalized to polymorphic sets, set<t>. These generalization \ncan be carried out for either abstract data types or objects. While there is signi.\u00adcant work involved \nin doing so, the issues of polymorphism do not interact very much with the issues relating to data abstraction. \nBoth abstract data types and objects can be de.ned in ei\u00adther a pure functional or imperative style. \nPure functional objects are quite common, although not as common as they could be. Issues of state are \nlargely orthogonal from a lan\u00adguage design viewpoint. However, imperative programming has a signi.cant \nimpact on veri.cation.  5. Reality The reality in practical programming languages is not so pure and \nsimple. It turns out that statically typed object\u00adoriented languages all support both pure objects and \nalso a form of abstract data types. They also support various hybrids. 5.1 Object-Oriented Programming \nin Java While Java is not a pure object-oriented language, it is pos\u00adsible to program in a pure object-oriented \nstyle by obeying the following rules Classes only as constructors A class name may only be used after \nthe keyword new. No primitive equality The program must not use primitive equality (==). Primitive equality \nexposes representation and prevents simulation of one object by another. In particular, classes may not \nbe used as types to declare members, method arguments or return values. Only inter\u00adfaces may be used \nas types. Also, classes may not be used in casts or to test with instanceof. This is generally considered \ngood object-oriented style. But what if you were forced to follow this style, because the language you \nwere using required it? Smalltalk comes close. Since Smalltalk is dynamically typed, classes are only \nused as constructors. It does support instanceof, although it is rarely used. One other way to break \nencapsulation in Java is through the use of re.ection, although this is not common when writ\u00ading most \nprograms. Re.ection is useful when writing meta\u00adtools (e.g. debuggers) and program generators. However, \nuse of re.ection appears to be growing more widespread. More research is needed to quantify the effect \nof re.ection on data abstraction and encapsulation. 5.2 ADTs in Java It takes a little more work to \nencode abstract data types in statically typed object-oriented programming languages. class ASet { // \ndeclare representation .elds // no public constructor static ASet empty(); static ASet insert(ASet s, \nint n); static bool contains(ASet s, int n); static ASet union(ASet a, ASet b); } Using a class name \nas a type introduces type abstraction. A class hides its representation. Object-oriented languages do \nnot always support the sums-of-products data structures found in other languages, but such types can \nbe simulated using an abstract class with a subclass for each variant in the sum type. Pattern matching \non these types can then be implemented by using instanceof and appropriate casts. One direct encoding \nuses static methods for all the ADT operations, and the class just holds the representation. class CSet \n{ // declare representation .elds // no public constructor static CSet empty(); CSet insert(Integer n); \nbool contains(Integer n); CSet union(CSet b); } To summarize, when a class name is used as a type, it \nrepresents an abstract data type.  5.3 Haskell Type Classes Type classes in Haskell [30] are a powerful \nmechanism for parameterization and extensibility [59]. A type class is an algebraic signature that associates \na group of operations with one or more type names. A type class for integer sets, de.ned below, is very \nsimilar to the existential type in Figure 6, but in this case uses curried functions: class Set s where \nempty :: s isEmpty :: s . Bool insert :: s . Int . s contains :: s . Int . Bool union :: s . s . s Functions \ncan be written using the generic operations: test :: Set s . s . Bool test s = contains(union(insert(s, \n3), insert(empty, 4)), 5) The quali.cation on the type of test indicates that the type s is any instance \nof Set. Any type can made an instance of Set by de.ning the appropriate operations: instance Set [Int] \nwhere empty = [] isEmpty = (== []) insert = .ip (:) contains = .ip elem union = (++) Instance de.nitions \ncan connect type classes with actual types that come from different libraries, and all three parts can \nbe written without prearranged knowledge of the others. As a result, type classes are .exible and extensible. \nA type can only be an instance of a class in one way. For example, there is no way to de.ne sorted lists \nand lists as both being different instances of Set. This restriction can always be bypassed by creating \na new type that is a tagged or labeled version of an existing type, although this can introduce undesirable \nbookkeeping when tagging values. Type classes are similar to object interfaces in allowing a method to \noperate on any value that has the necessary operations.  On the other hand, type classes are based on \nalgebraic sig\u00adnatures as in abstract data types. The main difference is that type classes do not enforce \nany hiding of representations. As a result, they provide parametric abstraction over type signa\u00adtures, \nwithout the information hiding aspect of ADTs. Given the success of Haskell, one might argue that encapsulation \nis somewhat overrated. Type classes are not autognostic. When a function is quali.ed by a type class, \nthe same type instance must be used for all values within that function. Type classes do not allow different \ninstances to interoperate. There are other ways in which Haskell provides abstraction and information \nhiding, for example, by parametericity. On the other hand, the object-oriented data abstractions given \nhere can also be coded in Haskell. In addition, an exis\u00adtential type can be used to combine the type \nclass operations with a value to create a form of object [31]. In this encoding, the type class acts \nas a method table for the value.  5.4 Smalltalk There are many interesting aspects of the Smalltalk \nlanguage and system. One curious fact is that Smalltalk has no built\u00adin control .ow and very few built \nin types. To see how this works, consider the Smalltalk implementation of Booleans. There are two Boolean \nclasses in Smalltalk, named True and False. They both implement a two-argument method called ifTrue:ifFalse:. \nclass True ifTrue: a ifFalse: b ^ a value class False ifTrue: a ifFalse: b ^ b value Method names in \nSmalltalk are sequences of keyword labels, where each keyword identi.es a parameter. The body of the \nTrue method returns the result of sending the value message to the .rst argument, a. The body of the \nFalse method returns the second argument, b. The value method is needed because a and b represent thunks \nor functions with a single dummy argument. A thunk is created by enclosing statements in square brackets. \nA con\u00additional is implemented by sending two thunks to a Boolean value. (x > y) ifTrue: [ x print ] ifFalse: \n[ y print ] The implementation of Booleans and conditionals in Smalltalk is exactly the same as for Church \nbooleans in the .-calculus [12]. Given that objects are the only way to implement data abstraction in \nan untyped language, it makes sense that the same kind of data would be used in Smalltalk and the untyped \n.-calculus. It would be possible to imple\u00adment a RandomBoolean class that acts as true or false based \non the .ip of a coin, or a LoggingBoolean that traced how many computations were performed. These booleans \ncould be use anywhere that the standard booleans are used, includ\u00ading in low-level system code. Smalltalk \nnumbers are not Church numerals, although they share some characteristics. In particular, numbers in \nSmalltalk implement iteration, just as they do in the Church encoding. Similarly, Smalltalk collections \nimplement a re\u00adduce operator analogous to the Church encoding of lists. The Smalltalk system does include \na primitive integer type, implemented as an ADT for ef.ciency. The primitive types are wrapped in high-level \nobjects, which communicate with each to other through an ingenious interface to perform coercions and \nimplement both .xed and in.nite precision arithmetic. Even with these wrappers, I claim that Smalltalk \nis not truly objects all the way down because the imple\u00admentation depends upon primitive ADTs. It may \nbe that ob\u00adjects are simply not the best way to implement numbers. More analysis is needed to determine \nthe ef.ciency costs and whether the resulting .exibility is useful in practice. One conclusion you could \ndraw from this analysis is that the untyped .-calculus was the .rst object-oriented lan\u00adguage. 6. Discussion \nAcademic computer science has generally not accepted the fact that there is another form of data abstraction \nbesides ab\u00adstract data types. Hence the textbooks give the classic stack ADT and then say objects are \nanother way to implement abstract data types . Sebesta focuses on imperative data ab\u00adstractions without \ncomplex methods, using stacks as an ex\u00adample, so it is not surprising that he does not see any differ\u00adence \nbetween objects and ADTs [54]. Tucker and Noonan also illustrate data abstraction with stacks [57]. But \nthey also provide a Java implementation of a type-checker and evalu\u00adator that appears to have been translated \ndirectly from ML case statements, implemented using intanceof in Java. The resulting program is a poor \nillustration of the capabilities of object-oriented programming. Some textbooks do better than others. \nLouden [38] and Mitchell [43] have the only books I found that describe the difference between objects \nand ADTs, although Mitchell does not go so far as to say that objects are a distinct kind of data abstraction. \nThe rise of objects interrupted a long-term project in academia to create a formal model of data based \non ADTs. Several widely used languages were designed with ADTs as their fundamental form of data abstraction: \nML, Ada, and Modula-2. As object-oriented programming became more prominent, these languages have adopted \nor experimented with objects. Object-oriented programming has also been subject to ex\u00adtensive academic \nresearch. However, I believe the academic community as a whole has not adopted objects as warmly as they \nwere received in industry. I think there are three reasons for this situation. One is that the conceptual \nfoundations for objects, discussed here, are not widely known. The second is that academics tend to be \nmore interested in correctness than .exibility. Finally, programming language researchers tend to work \nwith data abstractions that are more natural as ADTs.  There are signi.cant design decisions involved \nin choos\u00ading whether to implement a given abstraction with ADTs or with objects. In her history of CLU \n[35], Barbara Liskov discussed many of these issues, and gave good arguments for her choice of the ADT \nstyle. For example, she writes that although a program development support system must store many implementations \nof a type..., allowing multiple implementations within a single program seems less impor\u00adtant. This may \nbe true if the types in question are stacks and integer sets, but when the abstractions are windows, \n.le systems, or device drivers, it is essential to allow multiple implementations running within the \nsame system. To me it is unfortunate that Liskov also wrote that CLU is an object-oriented language in \nthe sense that it focuses attention on the properties of data objects and encourages programs to be developed \nby considering abstract properties of data. I believe that there is no technically or historically meaningful \nsense in which CLU is an object-oriented lan\u00adguage. I do believe that modern object-oriented languages \nhave been in.uenced by CLU (especially in the encapsula\u00adtion of representation) but this does not make \nCLU into an object-oriented language. Acknowledgements There are too many people to thank individually \nfor all their discussions on the topic of this essay. I thank Olivier Danvy, Shriram Krishnamurthi, Doug \nLea, Yannis Smarag\u00addakis, Kasper Osterbye, and Gilad Bracha for their com\u00adments on the essay itself. \n7. Conclusion Objects and abstract data types (ADTs) are two different forms of data abstraction. They \ncan both implement simple abstractions without complex methods, but objects are ex\u00adtensible while ADTs \nare easier to verify. Signi.cant differ\u00adences arise when implementing abstractions with complex operations, \nfor example comparisons or composition oper\u00adators. Object interfaces support the same level of .exibil\u00adity, \nbut often force a trade-off between interface simplicity and ef.ciency. Abstract data types support clean \ninterfaces, optimization, and veri.cation, but do not allow mixing or extending the abstractions. Mathematically \noriented types, including numbers and sets, typically involve complex oper\u00adations that manipulate multiple \nabstract values, and are best de.ned using ADTs. Most other types including .les, de\u00advice drivers, graphic \nobjects, often do not require optimized complex operations, and so are best implemented as objects. Modern \nobject-oriented languages support a mixture of object-oriented and ADT functionality, allowing program\u00admers \nto choose ADT style for speci.c situations. In modern object-oriented languages, the issue boils down \nto whether or not classes are used as types. In a pure object-oriented style, classes are only used to \nconstruct objects, and inter\u00adfaces are used for types. When classes are used as types, the programmer \nis implicitly choosing to use a form of abstract data type. The decision affects how easy it is for the \nprogram to be extended and maintained over time, and also how easy it is to optimize complex operations. \nUnderstanding the fun\u00addamental differences between objects and ADTs can help in choosing to use them \nwisely. References [1] N. Adams and J. Rees. Object-oriented programming in Scheme. In Proceedings of \nthe ACM Conf. on Lisp and Functional Programming, pages 277 288, 1988. [2] P. America. A behavioral approach \nto subtyping object\u00adoriented programming languages. In Proceedings of the REX Workshop/School on the \nFoundations of Object-Oriented Lan\u00adguages, volume 173 of Lecture Notes in Computer Science, 1990. [3] \nJ. Bergstra and J. Tucker. Initial and .nal algebra semantics for data type speci.cations: Two characterisation \ntheorems. Research Report IW 142, Stichting Mathematisch Centrum, 1980. [4] G. M. Birtwistle. DEMOS: \na system for discrete event mod\u00adelling on Simula. Springer-Verlag, 1987. [5] D. Box. Essential COM (DevelopMentor \nSeries). Addison-Wesley Professional, 1998. [6] C. Boyapati, B. Liskov, and L. Shrira. Ownership types \nfor object encapsulation. SIGPLAN Notices, 38(1):213 223, 2003. [7] R. Burstall and J. Goguen. Putting \ntheories together to make speci.cations. In International Joint Conferences on Arti.\u00adcial Intelligence, \npages 1045 1058. Department of Computer Science, Carnegie-Mellon University, 1977. [8] P. Canning, W. \nCook, W. Hill, and W. Olthoff. Interfaces for strongly-typed object-oriented programming. In Proceedings \nof ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications, pages 457 467, 1989. \n[9] L. Cardelli. A semantics of multiple inheritance. In Semantics of Data Types, volume 173 of Lecture \nNotes in Computer Science, pages 51 68. Springer-Verlag, 1984. [10] L. Cardelli and P. Wegner. On understanding \ntypes, data ab\u00adstraction, and polymorphism. Computing Surveys, 17(4):471 522, 1986. [11] C. Chambers. \nObject-oriented multi-methods in Cecil. In ECOOP 92: Proceedings of the European Conference on Object-Oriented \nProgramming, pages 33 56. Springer-Verlag, 1992. [12] A. Church. The Calculi of Lambda Conversion. Princeton \nUniversity Press, 1941.  [13] W. Cook. A Denotational Semantics of Inheritance. PhD thesis, Brown University, \n1989. [14] W. Cook. Object-oriented programming versus abstract data types. In Proceedings of the REX \nWorkshop/School on the Foundations of Object-Oriented Languages, volume 173 of Lecture Notes in Computer \nScience, 1990. [15] B. C. d. S. Oliveira. Modular visitor components: A practical solution to the expression \nfamilies problem. In S. Drossopoulou, editor, 23rd European Conference on Ob\u00adject Oriented Programming \n(ECOOP), 2009. [16] O.-J. Dahl, B. Myhrhaug, and K. Nygaard. The SIMULA 67 common base language. Technical \nreport, Norwegian Computing Center, 1970. Publication S-22. [17] H.-D. Ehrich. On the theory of speci.cation, \nimplementa\u00adtion and parameterization of abstract data types. J. ACM, 29(1):206 227, 1982. [18] A. Filinski. \nDeclarative continuations and categorical dual\u00adity. Master s thesis DIKU Report 89/11, University of \nCopen\u00adhagen, 1989. [19] J. Gibbons. Unfolding abstract datatypes. In MPC 08: Pro\u00adceedings of the 9th \ninternational conference on Mathematics of Program Construction, pages 110 133, 2008. [20] J. Goguen, \nJ. Thatcher, and E. Wagner. An initial algebra approach to the speci.cation, correctness, and implementa\u00adtion \nof abstract data types. Current Trends in Programming Methodology, IV:80 149, 1978. [21] J. Gosling, \nB. Joy, G. Steele, and G. Bracha. Java(TM) Language Speci.cation. Addison-Wesley Professional, 2005. \n[22] D. N. Gray, J. Hotchkiss, S. LaForge, A. Shalit, and T. Wein\u00adberg. Modern languages and Microsoft \ns Component Object Model. Commun. ACM, 41(5):55 65, 1998. [23] C. A. Gunter and J. C. Mitchell, editors. \nTheoretical aspects of object-oriented programming: types, semantics, and language design. MIT Press, \n1994. [24] J. Guttag. The Speci.cation and Application to Programming of Abstract Data Types. Report, \nUniversity of Toronto, Com\u00adputer Science Department, 1975. [25] C. Hewitt, P. Bishop, I. Greif, B. Smith, \nT. Matson, and R. Steiger. Actor induction and meta-evaluation. In POPL 73: Proceedings of the 1st annual \nACM SIGACT-SIGPLAN symposium on Principles of programming languages, pages 153 168. ACM, 1973. [26] C. \nA. R. Hoare. Proof of correctness of data representation. Acta Informatica, 1:271 281, 1972. [27] J. \nHogg, D. Lea, A. Wills, D. deChampeaux, and R. Holt. The Geneva convention on the treatment of object \naliasing. SIGPLAN OOPS Messenger, 3(2):11 16, 1992. [28] D. Ingalls. The Smalltalk-76 programming system. \nIn POPL, pages 9 16, 1978. [29] B. Jacobs. Objects and classes, co-algebraically. In Object orientation \nwith parallelism and persistence, pages 83 103. 1996. [30] S. P. Jones. Haskell 98 Language and Libraries: \nThe Revised Report. Cambridge University Press, 2003. [31] S. P. Jones. Classes, Jim, but not as we know \nthem. type classes in Haskell: what, why, and whither. ECOOP Keynote, 2009. [32] B. W. Kernighan and \nD. Ritchie. C Programming Language (2nd Edition). Prentice Hall PTR, 1988. [33] S. Krishnamurthi, M. \nFelleisen, and D. P. Friedman. Syn\u00adthesizing object-oriented and functional design to promote re\u00aduse. \nIn In European Conference on Object-Oriented Program\u00adming, pages 91 113. Springer, 1998. [34] B. Liskov. \nKeynote address -data abstraction and hierarchy. In OOPSLA 87: Addendum to the Proceedings on Object\u00adoriented \nprogramming systems, languages and applications (Addendum), pages 17 34, 1987. [35] B. Liskov. A history \nof CLU. In History of programming languages II, pages 471 510. ACM, 1996. [36] B. Liskov, R. Atkinson, \nT. Bloom, E. Moss, J. C. Schaf\u00adfert, R. Schei.er, and A. Snyder. CLU Reference Manual. Springer-Verlag, \n1981. [37] B. Liskov and S. Zilles. Programming with abstract data types. SIGPLAN Notices, 9(4):50 59, \n1974. [38] K. C. Louden. Programming Languages: Principles and Practice. Wadsworth Publ. Co., 1993. [39] \nD. B. MacQueen. Modules for Standard ML. In Conference on LISP and Functional Programming, 1984. [40] \nB. Mahr and J. Makowsky. An axiomatic approach to se\u00admantics of speci.cation languages. In Proceedings \nof the 6th Conference on Theoretical Computer Science, volume 145 of Lecture Notes in Computer Science, \npages 211 219. Springer-Verlag, 1983. [41] R. Milner. Communication and Concurrency. Prentice-Hall, 1989. \n[42] R. Milner, M. Tofte, and R. Harper. The de.nition of Standard ML. MIT Press, 1990. [43] J. C. Mitchell. \nConcepts in Programming Languages. Cam\u00adbridge University Press, 2001. [44] J. C. Mitchell and G. D. Plotkin. \nAbstract types have existen\u00adtial type. In Proceedings of the ACM Symp. on Principles of Programming Languages. \nACM, 1985. [45] P. M\u00a8uller, A. Poetzsch-Heffter, and G. T. Leavens. Modu\u00adlar invariants for layered object \nstructures. Sci. Comput. Pro\u00adgram., 62(3):253 286, 2006. [46] D. A. Naumann. Observational purity and \nencapsulation. Theor. Comput. Sci., 376(3):205 224, 2007. [47] M. Odersky, L. Spoon, and B. Venners. \nProgramming in Scala: A Comprehensive Step-by-step Guide. Artima Inc, 2008. [48] M. Odersky and M. Zenger. \nIndependently extensible solu\u00adtions to the expression problem. In Proceedings FOOL 12, 2005. http://homepages.inf.ed.ac.uk/wadler/fool. \n[49] U. S. D. of Defense. Reference manual for the Ada program\u00adming language. ANSI/MIL-STD-1815 A, 1983. \n[50] B. C. Pierce. Types and Programming Languages. MIT Press, 2002.  [51] T. W. Pratt and M. V. Zelkowitz. \nProgramming languages: design and implementation. Prentice-Hall, 1995. [52] J. C. Reynolds. User-de.ned \ntypes and procedural data struc\u00adtures as complementary approaches to data abstraction. In New Advances \nin Algorithmic Languages, pages 157 168. IN-RIA, 1975. [53] M. L. Scott. Programming Language Pragmatics. \nMorgan Kaufmann, 2000. [54] R. Sebesta. Concepts of Programming Languages, Eighth Edition. Addison-Wesley, \n2007. [55] J. F. Shoch. An overview of the programming language Smalltalk-72. SIGPLAN Notices, 14(9):64 \n73, 1979. [56] G. Steele. LAMBDA: The ultimate declarative. Technical Report AIM-379, MIT AI LAB, 1976. \n[57] A. B. Tucker and R. E. Noonan. Programming Languages: Principles and Paradigms, Second Edition. \nMcGraw-Hill Higher Education, 2007. [58] P. Wadler. The expression problem. Mail to the java-genericity \nmailing list, 1998. [59] P. Wadler and S. Blott. How to make ad-hoc polymorphism less ad hoc. In POPL \n89: Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages \n60 76. ACM, 1989. [60] N. Wirth. Programming in Modula-2. Springer-Verlag, 1983. [61] W. A. Wulf, R. \nL. London, and M. Shaw. An introduction to the construction and veri.cation of Alphard programs. IEEE \nTransactions on Software Engineering, SE-24(4), 1976. [62] S. N. Zilles. Procedural encapsulation: A \nlinguistic protection mechanism. SIGPLAN Notices, 8(9):142 146, 1973.    \n\t\t\t", "proc_id": "1640089", "abstract": "<p>In 1985 Luca Cardelli and Peter Wegner, my advisor, published an ACM Computing Surveys paper called \"On understanding types, data abstraction, and polymorphism\". Their work kicked off a flood of research on semantics and type theory for object-oriented programming, which continues to this day. Despite 25 years of research, there is still widespread confusion about the two forms of data abstraction, <i>abstract data types</i> and <i>objects</i>. This essay attempts to explain the differences and also why the differences matter.</p>", "authors": [{"name": "William R. Cook", "author_profile_id": "81406596033", "affiliation": "University of Texas at Austin, Austin, TX, USA", "person_id": "P1728823", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640133", "year": "2009", "article_id": "1640133", "conference": "OOPSLA", "title": "On understanding data abstraction, revisited", "url": "http://dl.acm.org/citation.cfm?id=1640133"}