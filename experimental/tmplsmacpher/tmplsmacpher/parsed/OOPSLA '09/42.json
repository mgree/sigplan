{"article_publication_date": "10-25-2009", "fulltext": "\n An Interpretive Domain Speci.c Language Workbench Atzmon Hen-Tov David H. Lorenz Lior Schachter Pontis \nOpen University of Israel Pontis Glil Yam 46905 Israel Raanana 43107 Israel Glil Yam 46905 Israel atzmon@ieee.org \nlorenz@openu.ac.il liors@ieee.org Abstract Domain-speci.c language (DSL) utilization comes in three \nsorts: internal, external, and language workbench. An inter\u00adnal DSL is con.ned to the hosting language. \nAn external DSLis freed from con.nementin the hosting language,but surrendersallnativetool supportin \nreturn.Alanguagework\u00adbench incorporatesexternal DSLs intothedevelopment en\u00advironment, thus bridging the \ntool-supportgap thatexists be\u00adtween external and internal DSLs. DSL workbenches hold the most promise \nfor DSL based development.Yet they are alsothe least utilized.Inthiswork,we presenta concreteex\u00adample \nof a language workbench. Our language workbench facilitates DSL based development in Java, where the \nDSLs are external to Java and yet enjoy Java-like automatic tool support. Categories and Subject Descriptors \nD.2.6[Programming Environments]: Programmerworkbench; D.3.2[Language Classi.cations]: Domain speci.c \nlanguages. General Terms Languages, Design. Keywords Domain Speci.c Languages, Language Work\u00adbench. 1. \nIntroduction Fowler identi.es three kinds of DSLs [Fowler 2009]: inter\u00adnal DSLs, external DSLs, and language \nworkbenches. An internal DSL is expressed within the hosting language, en\u00adjoying native toolingbut con.ned \nto the hosting language s syntaxandexpressiveness.AnexternalDSLisa foreignlan\u00adguage designed for expressing \ndomain speci.c terms, but typically lacks tool support for evolving or programming in that language.Alanguageworkbench \ntreatsexternal DSLs like internal ones. It includes tool support for DSL author- Copyright is held by \nthe author/owner(s). OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10. \n ing.Italsoprovides customtool supportfor programmingin the newly de.ned DSLs. DSL workbenches hold the \nmost promise for DSL based development.Yet they are also the least utilizedof the three kinds.InFowler \nswords[Fowler 2009]: Whereasexternaland internalDSLshavebeen around for longer than I ve been programming, \nlanguage workbenches are a much newer animal. These tools support DSL creation not just in terms of parsing \nand code generationbut alsoinprovidinga better editing experience for DSL users. Toremedythis situation,weneed \nmore concreteexamplesof DSLworkbenches. DSLworkbenchsuccess stories can help explain the concepts better \nas well as sharpen the de.nitions. In this work, we review the evolution of ModelTalk s DSL authoring \ntoolkit [Hen-Tov et al. 2009, 2008], which can be classi.ed as a language workbench. We describe the \nevolutionary path that ModelTalk took from initially using external DSLs with a generative approach to \nusing a language workbench with an interpretive approach. 2. Java with External DSLs ModelTalk started \nout with an architecture centric model driven softwaredevelopment approach(AC-MDSD)[V\u00a8 olter and Stahl \n2006], using external DSLs and applying code generation. The main objective was to dramatically reduce \nthe customization effort in producing commercialbusiness support systems in the telecommunications market. \nInitially, the model centric approach was quite effective. However, as the model grew in size (comprising \nthousands of classes), developers experienced long edit-execute cycles (several minutes per incremental \nchange) causedbythe need to compile, pack and deployto the J2EE application server large amounts of generated \nJava code. Another problem that surfaced was the lack of tool support for de.ning and pro\u00adgramming with \nthe DSLs. These problems became more acute as the DSLs evolved and new programmers joined the development \nteam.  Figure 1. The DSL workbench architecture of ModelTalk 3. ALanguageWorkbench The next evolutionary \nstep was to switch to an interpre\u00adtive approach, applying dependency injection instead of code generation. \nThe interpretive approach lets the language workbench (Fig. 1) avoid code and tool re-generation. As \na result, ModelTalk was able to support short edit-execute cycles for both DSL users and DSL language \ndesigners, and facilitates the evolution of DSLs over time. By sharing a language metamodel across all \nthe DSLs, ModelTalk achieved DSL harmony on the one hand, while avoiding syntax cacophonyon the other \nhand. This language metamodelwasakeyenablerin providing an integrated de\u00advelopment environment (IDE) \nthat handles all DSLs uni\u00adformly. The IDE presents programmers with an editing en\u00advironment (implemented \nwith Eclipse) that has a familiar look-and-feel similar to that of Java. Furthermore, not only do all \nDSLs share their editor and tools with each other,but they also closely interact with the Java editor \nand tools in Eclipse. An example of such an interaction is a Problem-View that reports inconsistencies \nacross DSL and Java code. 4. Discussion and RelatedWork Language workbenches are a relatively new concept. \nCur\u00adrently, we are aware of only few available tools that could be classi.ed as language workbenches: \nMetaEdit+ (Meta-Case), MPS (JetBrains), GME(Vanderbilt university), Xtext (Eclipse), DSLTool (Microsoft), \nand Intentional Software. A main differentiating factor between these tools and ModelTalk is the fact \nthat ModelTalk uses an interpretive approach (to execute the DSLs) whereas the other tools are based \non code generation. Another difference is the ability of these tools to de.ne new custom editors and \nsyntax, which ModelTalk does not support. Indeed, the need to control the concrete syntax is often cited \nasa motive for creatingexternal DSLs.We,however, resorted to external DSLs mostly for three other reasons. \nFirst, the need to better enforce declarative programming. Second, the need to support a system change \nprocess that does not require a new software delivery. Third, the need to provide meta-level expressibility \nthat is unavailable in Java [Hen-Tov et al. 2008]. ModelTalk s language workbench strikes a balance be\u00adtween \nthe pros and cons of internal and external DSLs. On the one hand, DSLs in ModelTalk are external. On \nthe other hand, there is a uniform carrying syntax for all the DSLs. DSLs in ModelTalk are external to \nJava but internal with respect to the language workbench metamodel. Therefore, the generic tools can \nhandle all DSLs uniformly, a property which is usually exclusive to internal DSLs. ModelTalk works well \nin a setting where the DSL users are programmers who need to work with several DSLs. In fact, limiting \nthe diversity of the concrete syntax is particu\u00adlarly advantageous when manyDSLs need to be used simul\u00adtaneously \n[Hen-Tov et al. 2009]. References MartinFowler.Apedagogical framework for domain-speci.c lan\u00adguages. \nIEEE Software, 26(4):13 14, 2009. ISSN 0740-7459. doi: http://doi.ieeecomputersociety.org/10.1109/MS.2009.85. \nAtzmon Hen-Tov, David H. Lorenz, and Lior Schachter. Mod\u00adelTalk:Aframework fordeveloping domain speci.cexecutable \nmodels. In the 8th OOPSLA Workshop on Domain-Speci.c Modeling, pages 45 51, Nashville, TN, October 19-20 \n2008. CoRR, abs/0906.3423:(2009). Atzmon Hen-Tov, David H. Lorenz, Assaf Pinhasi, and Lior Schachter. \nModelTalk: When everything is a domain-speci.c language. IEEE Software, 26(4):39 46, 2009. ISSN 0740-7459. \ndoi: http://doi.ieeecomputersociety.org/10.1109/MS.2009.97. MarkusV\u00a8olter and Thomas Stahl. Model-Driven \nSoftware Devel\u00adopment:Technology, Engineering, Management. Wiley, 2006.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Domain-specific language (DSL) utilization comes in three sorts: internal, external, and language workbench. An internal DSL is confined to the hosting language. An external DSL is freed from confinement in the hosting language, but surrenders all native tool support in return. A language workbench incorporates external DSLs into the development environment, thus bridging the tool-support gap that exists between external and internal DSLs. DSL workbenches hold the most promise for DSL based development. Yet they are also the least utilized. In this work, we present a concrete example of a language workbench. Our language workbench facilitates DSL based development in Java, where the DSLs are external to Java and yet enjoy Java-like automatic tool support.</p>", "authors": [{"name": "Atzmon Hen-Tov", "author_profile_id": "81440622847", "affiliation": "Pontis, Glil Yam, Israel", "person_id": "P1728551", "email_address": "", "orcid_id": ""}, {"name": "David H. Lorenz", "author_profile_id": "81100540418", "affiliation": "Open University of Israel, Raanana, Israel", "person_id": "P1728552", "email_address": "", "orcid_id": ""}, {"name": "Lior Schachter", "author_profile_id": "81440596926", "affiliation": "Pontis, Glil Yam, Israel", "person_id": "P1728553", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1639997", "year": "2009", "article_id": "1639997", "conference": "OOPSLA", "title": "An interpretive domain specific language workbench", "url": "http://dl.acm.org/citation.cfm?id=1639997"}