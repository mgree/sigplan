{"article_publication_date": "10-25-2009", "fulltext": "\n Pro.le-Guided Static Typing for Dynamic Scripting Languages Michael Furr Jong-hoon (David) An Jeffrey \nS. Foster University of Maryland {furr,davidan,jfoster}@cs.umd.edu Abstract Many popular scripting languages \nsuch as Ruby, Python, and Perl include highly dynamic language constructs, such as an eval method that \nevaluates a string as program text. While these constructs allow terse and expressive code, they have \ntraditionally obstructed static analysis. In this paper we present PRuby, an extension to Diamondback \nRuby (DRuby), a static type inference system for Ruby. PRuby augments DRuby with a novel dynamic analysis \nand trans\u00adformation that allows us to precisely type uses of highly dynamic constructs. PRuby s analysis \nproceeds in three steps. First, we use run-time instrumentation to gather per\u00adapplication pro.les of \ndynamic feature usage. Next, we re\u00adplace dynamic features with statically analyzable alterna\u00adtives based \non the pro.le. We also add instrumentation to safely handle cases when subsequent runs do not match the \npro.le. Finally, we run DRuby s static type inference on the transformed code to enforce type safety. \nWe used PRuby to gather pro.les for a benchmark suite of sample Ruby programs. We found that dynamic \nfeatures are pervasive throughout the benchmarks and the libraries they include, but that most uses of \nthese features are highly constrained and hence can be effectively pro.led. Using the pro.les to guide \ntype inference, we found that DRuby can generally statically type our benchmarks modulo some refactoring, \nand we discovered several previously unknown type errors. These results suggest that pro.ling and trans\u00adformation \nis a lightweight but highly effective approach to bring static typing to highly dynamic languages. Categories \nand Subject Descriptors F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages Program \nanalysis; D.2.5 [Programming Languages]: Test\u00ading and Debugging Tracing General Terms Languages Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 2009, October \n25 29, 2009, Orlando, Florida, USA. Copyright c &#38;#169; 2009 ACM 978-1-60558-734-9/09/10. . . $10.00 \nKeywords Ruby, pro.le-guided analysis, RIL, Scripting Languages 1. Introduction Many popular, object-oriented \nscripting languages such as Ruby, Python, and Perl are dynamically typed. Dynamic typ\u00ading gives programmers \ngreat .exibility, but the lack of static typing can make it harder for little scripts to grow into ma\u00adture, \nrobust code bases. Recently, we have been developing Diamondback Ruby (DRuby), a tool that brings static \ntype inference to Ruby.1 DRuby aims to be simple enough for programmers to use while being expressive \nenough to pre\u00adcisely type typical Ruby programs. In prior work, we showed that DRuby could successfully \ninfer types for small Ruby scripts (Furr et al. 2009c). However, there is a major challenge in scaling \nup static typing to large script programs: Scripting languages typi\u00adcally include a range of hard-to-analyze, \nhighly dynamic constructs. For instance, Ruby lets programmers eval strings containing source code, use \nre.ection to invoke methods via send, and de.ne a method missing method to handle calls to unde.ned methods. \nThese kinds of features lend themselves to a range of terse, .exible, and expressive coding styles, but \nthey also impede standard static analysis. In fact, in Ruby it is even hard to statically determine what \nsource .les to analyze, because scripts can perform computation to decide what other .les to load. In \nthis paper, we present PRuby, an extension to DRuby that solves this problem by combining run-time pro.ling \nof dynamic features with static typing.2 Our key insight is that even though script programs may use \nconstructs that appear to be dynamic, in fact their use is almost always heavily constrained, so that \nin practice they act statically. As an extreme example, a call eval x + 2 is morally the same as the \nexpression x + 2, and can be typed just as easily with PRuby. Using pro.ling enables PRuby to statically \ncheck many other, much more complex and interesting examples. And while PRuby is speci.c to typing Ruby, \nour pro.le\u00adguided transformation technique can be applied to many dynamic languages and many static analyses. \n1 http://www.cs.umd.edu/projects/PL/druby/ 2 PRuby uses Pro.ling to handle dynamic features ignored by \nDRuby.  PRuby analyzes Ruby code in three steps. First, it per\u00adforms a source-to-source translation \non the program to be analyzed so that when run, the program records a pro.le of how dynamic features \nwere used in that execution. Among other information, we record what strings are passed to eval, what \nmethods are invoked via send, and what invocations are handled by method missing. Next, the user runs \nthe program to gather a suf.cient pro.le, typically using the program s test suite. Then PRuby uses the \npro.le to guide a program transformation that removes highly dynamic constructs, e.g., by replacing eval \ncalls with the source code seen in the pro\u00ad.le. Lastly, PRuby applies type inference to the transformed \nprogram to detect any type errors. PRuby can also safely handle program runs that do not match the pro.le. \nIn these cases, PRuby instruments newly seen code to include full dynamic checking and blame tracking, \nso that we can detect errors in the code and place the blame appropriately. Notice that PRuby relies \non the programmer to provide test cases to guide pro.ling. We think this is a reasonable approach because \nnot only do most Ruby programs already come with test suites (testing is widely adopted in the Ruby community), \nbut it gives the programmer an easy to un\u00adderstand trade-off: The more dynamic features covered in the \npro.le, the more static checking is achieved. Moreover, run-time pro.ling gives PRuby very precise information \nfor type inference. This is in contrast to using, e.g., purely static string analysis (Livshits et al. \n2005; Christensen et al. 2003; Gould et al. 2004), which could easily over-approximate the set of strings \nseen at run time (Sawin and Rountev 2007). It also allows us to statically analyze effectful dynamic \ncode. For example, in our experiments, we found many cases where eval d strings de.ne methods, and those \nmethods are referred to in other parts of the program. As far as we are aware, techniques such as gradual \ntyping (Siek and Taha 2006, 2007; Herman et al. 2007) would be unsound in the presence of such effects \nin dynamic code static guarantees could be undermined if dynamically eval d code overwrites a method \nused in statically typed code. We formalized pro.ling, transformation, and type check\u00ading for TinyRuby, \na small object-oriented language with eval, send, and method missing. We have proven that our transformation \nis faithful, meaning it does not change the behavior of a program under its pro.le, and that transformed \nprograms that pass our type checker never go wrong at run time, except possibly from code that was instrumented \nwith blame tracking. We applied PRuby to a suite of benchmarks that use dynamic features, either directly, \nvia the standard library, or via a third-party library. We found several interesting results. First, \nour experiments show that dynamic language features are used heavily in Ruby across our benchmarks, pro.led \nexecutions observed 664 unique strings passed to 66 syntactic occurrences of dynamic features, suggesting \nthat handling such features is essential for any Ruby static analysis. Second, we manually categorized \nall the dynamic feature usage in our sample runs, and we found that essentially all of them can be classi.ed \nas static. More precisely, approximately 2/3 of the time, dynamic features are used in a small, .nite \nset of ways determined by the Ruby code that calls them. In the remaining cases, the calls to dynamic \nfeatures depend on the local Ruby environment. We found no cases of arbitrarily dynamic code, e.g., there \nwere no examples that eval d a string read from the command line, or used send to call a method whose \nname was read from the network. Finally, we found that DRuby initially reported many type errors on the \ntransformed program code. Upon closer inspec\u00adtion, we found eight real type errors in widely used libraries. \nThe remaining errors were false positives, but much of the code appeared nearly statically typable, despite \nbeing de\u00adveloped without a static type system in mind. To measure how statically typable this code is, \nwe applied a range of refactorings to our benchmarks until they were accepted by DRuby. We found that \nthe majority of refactorings point to potential improvements to DRuby, and a few more suggest places \nwhere Ruby coding style could be changed to be more amenable to static typing. We only found a few cases \nof code that uses untypable low-level object manipulation or requires dynamic typing. Together, our results \nsuggest that pro.le-guided transfor\u00admation is an effective approach to help bring static typing to dynamic \nlanguages. 2. Motivation Ruby is a class-based, imperative, object-oriented scripting language with a \nrich set of features such a module mix\u00adins, higher-order methods ( code blocks ), and strong reg\u00adular \nexpression support (Thomas et al. 2004; Flanagan and Matsumoto 2008). In this section, we motivate the \nneed for PRuby by giving examples showing uses of its dynamic fea\u00adtures. All of the examples in this \nsection were extracted from the benchmarks in Section 5. PRuby also handles several other dynamic features \nof Ruby, discussed in Section 4. Require To load code stored in a .le, a Ruby program in\u00advokes the require \nmethod, passing the .le name as a string argument. Since this is an ordinary method call, a Ruby pro\u00adgram \ncan actually perform run-time computation to deter\u00admine which .le to load. Figure 1(a) gives two examples \nof this. Lines 1 2, from the sudokusolver benchmark, call dirname to compute the directory containing \nthe currently executing .le, and then call File.join to create the path of the .le to load. We have found \nsimilar calls to require (with computed strings) are common, occurring 11 times across 5 of our benchmarks. \nAs another example, lines 4 7, from the memoize benchmark, .rst modify the load path on line 5 be\u00adfore \nloading the .le memoize on line 7. This example shows  1 require File . join ( File .dirname( FILE ), \n .. , 2 lib , sudokusolver ) 3 4 Dir . chdir ( .. ) if base == test 5 $LOAD PATH.unshift(Dir.pwd \n+ /lib ) 6 ... 7 require memoize (a) Using require with dynamically computed strings 1 alias gem original \nrequire require 2 3 def require (path) 4 gem original require path 5 rescue LoadError => load error 6 \n( if spec = Gem.searcher..nd(path) then 7 Gem.activate(spec.name, = #{spec.version} ) 8 gem original \nrequire path 9 else 10 raise load error 11 end) 12 end end (b) Example of require from Rubygems package \nmanager 1 def initialize (args) 2 args .keys.each do | attrib | 3 self .send( #{attrib}= , args[ attrib \n]) 4 end end (c) Use of send to initialize .elds 1 ATTRIBUTES = [ bold , underscore , ... ] 2 ATTRIBUTES.each \ndo |attr| 3 code = def #{attr}(&#38;blk) ... end 4 eval code 5 end (d) De.ning methods with eval 1 def \nmethod missing(mid, *args) 2 mname = mid.id2name 3 if mname = /=$/ 4 ... 5 @table[mname.chop!.intern] \n= args[0] 6 elsif args . length == 0 7 @table[mid] 8 else 9 raise NoMethodError, unde.ned method... \n10 end 11 end (e) Intercepting calls with method missing Figure 1. Dynamic features in Ruby that even \nwhen require is seemingly passed a constant string, its behavior may actually vary at run time. For a \nmuch more complex use of require, consider the code in Figure 1(b). This example comes from Rubygems,a \npopular package management system for Ruby. In Rubygems, each package is installed in its own directory. \nRubygems re\u00adde.nes the require method, as shown in the .gure, so that require ing a package loads it \nfrom the right directory. Line 1 makes an alias of the original require method. Then lines 3 11 give \nthe new de.nition of require. First, line 4 attempts to load the .le normally, using the old version \nof require. If that fails, the resulting LoadError exception is caught on line 5 and handled by lines \n6 11. In this case, Rubygems searches the .le system for a library of the same name (line 6). If found, \nthe package is activated on line 7, which modi.es the load path (as in Figure 1(a)), and then the .le \nis loaded with the old require call on line 8. This implementation is convenient for package man\u00adagement, \nbut it makes pure static analysis quite dif.cult. Even if we could statically determine what string was \npassed to the new version of require, to .nd the corre\u00adsponding .le we would need to reimplement the \nlogic of the Gem.searcher..nd method. In PRuby, in contrast, we use dynamic pro.ling to discover which \n.les are actually loaded, and thus no matter how complex the logic that .nds them, we can determine the \nloaded .les precisely. Send When a Ruby program invokes e0.send( meth , e1,...,en), the Ruby interpreter \ndispatches the call re.ec\u00adtively as e0.meth(e1, ...,en). Figure 1(c) shows a typical use of this feature, \nfrom the StreetAddress benchmark. This code de.nes a constructor initialize that accepts a hash args \nas an argument. For each key attrib in the hash, line 3 uses send to pass args[attrib], the value corresponding \nto the key, to the method named #{attrib} = , where #{e} evalu\u00adates expression e and inserts the resulting \nvalue into the string. For example, if initialize is called with the argument { x . 1}, it will invoke \nthe method self.x=(1), providing a lightweight way to con.gure a class through the construc\u00adtor. Another \ncommon use of send is in test drivers. For exam\u00adple, the Ruby community makes heavy use of Ruby s stan\u00addard \nunit testing framework (not shown). To write a test case in this framework, the programmer creates a \nclass with test methods whose names begin with test . Given an instance of a test class, the framework \nuses the methods method to get a string list containing the names of the object s methods, and then calls \nthe appropriate ones with send. Eval Ruby also provides an eval method that accepts a string containing \narbitrary code that is then parsed and exe\u00adcuted. Our experiments show that use of eval is surprisingly \ncommon in Ruby in total, eval and its variants are used to evaluate 423 different strings across all \nour benchmark runs (Section 5). Figure 1(d) shows one example of metapro\u00adgramming with eval, taken from \nthe text-highlight bench\u00ad  e ::= x | v | d | e1; e2 | e1 =e2 | let x = e1 in e2 | if e1 then e2 else \ne3 | e0.m(e1,...,en) | eval\u00a3 e | e0.send\u00a3(e1,...,en) | safe eval\u00a3 e | [e]\u00a3 | blame e v ::= s | true | \nfalse | new A | [v]\u00a3 d ::= def\u00a3 A.m(x1,...,xn)= e x . local variable names A . class names m . method \nnames s . strings e . program locations Figure 2. TinyRuby source language mark. This code iterates through \nthe ATTRIBUTES array de.ned on line 1, creating a method named after each array element on lines 3 4. \nWe found many other examples like this, in which Ruby programmers use eval to create methods via macro-style \nmetaprogramming. Method Missing Figure 1(e) gives an example use of method missing, which receives calls \nto unde.ned meth\u00adods. This code (slightly simpli.ed) is taken from the ostruct library, which creates \nrecord-like objects. In this de.nition, line 2 converts the .rst argument, the name of the invoked method, \nfrom a symbol to a string mname. If mname ends with = (line 3), then on line 5 we update @table to map \nmname (with the = removed and interned back into a sym\u00adbol) to the .rst argument. Otherwise there must \nbe no argu\u00adments (line 6), and we read the value corresponding to the in\u00advoked method out of @table. \nFor example, if o is an instance of the ostruct class, the user can call o.foo =(3) to write 3 to foo \nin o, and o.foo() to read it back. Notice that we can use method invocation syntax even though method \nfoo was never de.ned. This particular use of method missing from ostruct is one of two occurrences of \nmethod missing that are dynamically executed by our benchmark test suites. One interesting property of \nmethod missing is that it cannot be directly modeled using other dynamic constructs. In contrast, the \nrequire and send methods are in a sense just special cases of eval. We could implement require by reading \nin a .le and eval ing it, and we could transform o.send(m, x, y) into eval( o.#{m}(x, y) ). 3. Dynamic \nFeatures in TinyRuby We model our approach to statically type checking dy\u00adnamic language features with \nTinyRuby, shown in Figure 2. The core language includes local variables x (such as the distinguished \nlocal variable self) and values v. Values in\u00adclude strings s, booleans true and false, objects created \nwith new A, and wrapped values [v]\u00a3, which indicate values with dynamic rather than static types. We \nannotate [v]\u00a3 with a program location \u00a3 so that we may later refer to it. In TinyRuby, objects do not \ncontain .elds or per-object meth\u00adods, and so we can represent an object simply by its class name. We \ncould add richer objects to TinyRuby, but we keep the language simple to focus on its dynamic features. \nIn TinyRuby, method de.nitions d can appear in arbitrary expression positions, i.e., methods can be de.ned \nanywhere in a program. A de.nition def\u00a3 A.m(x1,...,xn)= e adds or replaces class A s method m at program \nlocation \u00a3, where the xi are the arguments and e is the method body. Note that TinyRuby does not include \nexplicit class de.nitions. Instead, a program may create an instance of an arbitrary class A at any point, \neven if no methods of A have been de.ned, and as we see occurrences of def\u00a3 A.m(...)= ..., we add the \nde.ned method to a method table used to look up methods at invocation time. For example, consider the \nfollowing code: let x = new A in(def\u00a3 A.m() = ...); x.m() The call to x.m() is valid because A.m() was \nde.ned be\u00adfore the call, even though the de.nition was not in effect at new A. This mimics the behavior \nof Ruby, in which changes to classes affect all instances, and allows eval to be used for powerful metaprogramming \ntechniques, as shown in Fig\u00adure 1(d). Our method de.nition syntax also allows de.ning the special method \nmissing method for a class, which, as we saw in Section 2, receives calls to non-existent methods. Other \nlanguage constructs in TinyRuby include sequenc\u00ading e1; e2, the equality operator e1 = e2, let binding, \ncon\u00additionals with if, and method invocation e0.m(e1,...,en), which invokes method m of receiver e0 with \narguments e1 through en. TinyRuby also includes two additional dynamic con\u00adstructs we saw in Section \n2. The expression eval\u00a3 e eval\u00aduates e to produce a string s, and then parses and evalu\u00adates s to produce \nthe result of the expression. The expres\u00adsion e0.send\u00a3(e1,...,en) evaluates e1 to a string and then invokes \nthe corresponding method of e0 with arguments e2 through en. We annotate both constructs with a program \nlocation \u00a3. The last three expressions in TinyRuby, safe eval\u00a3 e, [e]\u00a3, and blame \u00a3, are used to support \ndynamic typing and blame tracking. These expressions are inserted by our translation below to handle \nuses of dynamic constructs we cannot fully resolve with pro.ling. Our approach is some\u00adwhat non-standard, \nbut these constructs in our formalism closely match our implementation (Section 4), which per\u00adforms blame \ntracking without modifying the Ruby inter\u00adpreter. We delay discussing the details of these expressions \nto Section 3.3. 3.1 An Instrumented Semantics To track run-time uses of eval, send, and method missing, \nwe use the instrumented big-step operational semantics shown in Figure 3. Since most of the rules are \nstraightfor\u00adward, we show only selected, interesting reduction rules, and similarly for the other formal \nsystems we discuss below. Full  (VAR) (DEF) (M, V, x) . (M, \u00d8, V(x)) (M, V, d) . ((d, M), \u00d8, false) \n(EVAL) (M, V, e) . (M1, P1, s) (M1, V, parse(s)) . (M2, P2, v) (M, V, eval\u00a3 e).(M2, (P1 .P2 . [e . s]),v) \n(SEND) (M, V,e1).(M1, P1,s) m = parse(s) (M1, V,e0.m(e2,...,en)).(M2, P2,v) (M, V,e0.send\u00a3(e1,...,en)).(M2, \n(P1 .P2 . [e . s]),v) (CALL-M) (Mi, V,ei).(Mi+1, Pi,vi) i . 0..n v0 = new A (def\u00a3 A.m(...)= ...) . Mn+1 \n(def\u00a31 A.method missing(x1,...,xn+1)= e) . Mn+1 s = unparse(m) m= method missing VM =[self . v0,x1 . \ns, x2 . v1,...,xn+1 . vn] (Mn+1, VM,e).(M , PM,v) [ (M0, V,e0.m(e1,...,en)).(MM , (Pi) .PM . [e M . s],v) \ni Figure 3. Instrumented operational semantics (partial) proofs are available in a companion technical \nreport (Furr et al. 2009a). In our implementation, we add the instrumen\u00adtation suggested by our semantics \nvia a source-to-source translation. Reduction rules in our semantics have the form (M, V,e). (M', P,v). \nHere M and M' are the initial and .nal method tables, containing a list of method de.nitions; V is a \nlocal variable environment, mapping variables to values; e is the expression being reduced; v is the \nresulting value; and P is a pro.le that maps program locations (occurrences of eval, send, and method \nmissing de.nitions) to sets of strings. In these rules, we use parse(s) to denote the expression pro\u00adduced \nby parsing string s, and we use unparse(e) to denote the string produced by unparsing e. The .rst rule, \n(VAR), looks up a variable in the local environment and produces the empty set of pro.ling infor\u00admation. \nTo see why we opted to use environments rather than a substitution-based semantics, consider the program \nlet x =2 in eval\u00a3 x +1 . In a substitution-based seman\u00adtics, we would rewrite this program as (eval\u00a3 \nx +1 )[x . 2], but clearly that will not work, since this is equal to (eval\u00a3 x +1 ), i.e., substitution \ndoes not affect strings. We could try extending substitution to operate on string ar\u00adguments to eval, \nbut since the string passed to eval can be produced from an arbitrary expression, this will not work \nin general. Other choices such as delaying substitution until later seemed complicated, so we opted for \nthe simpler se\u00admantics using variable environments. The next rule, (DEF), adds a method de.nition to \nthe front of M and returns false. When we look up a de.nition of A.m in M, we .nd the leftmost occurrence, \nand hence (DEF) replaces any previous de.nition of the same method. The last three rules in Figure 3 \nhandle the novel features of TinyRuby. (EVAL) reduces its argument e to a string s, parses s and then \nreduces the resulting expression to com\u00adpute the .nal result v. The resulting pro.le is the union of \nthe pro.les P1 (from evaluating e), P2 (from evaluating parse(s)), and [\u00a3 . s], which means s should \nbe added to the set of strings associated with \u00a3. In this way, we track the relationship between eval\u00a3 \ne and the string s passed to it a run-time. (SEND) behaves analogously. We evaluate the .rst argu\u00adment, \nwhich must produce a string, translate this to a method name m, and .nally invoke m with the same receiver \nand remaining arguments. In the output pro.le, we associate the location of the send with the string \ns. Finally, (CALL-M) handles invocations to unde.ned methods. In this rule we evaluate the receiver and \nargu\u00adments, but no method m has been de.ned for the receiver class. We then look up method missing of \nthe receiver class and evaluate its body in environment V', which binds the .rst formal parameter to \ns, the name of the invoked method, and binds self and the remaining formal parameters appro\u00adpriately. \nThe output pro.le associates s with \u00a3, the location where method missing was de.ned.  3.2 Translating \nAway Dynamic Features After pro.ling, we can translate a TinyRuby program into a simpler form that eliminates \nfeatures that are hard to analyze statically. Figure 4 gives a portion of our translation. Exclud\u00ading \nthe .nal rule, our translation uses judgments of the form Pf e o e', meaning given pro.le P, we translate \nexpres\u00adsion e to expression e'. For most language forms, we either do nothing, as in (REFL.), or translate \nsub-expressions re\u00adcursively, as in (SEQ.); we omit other similar rules. The .rst interesting rule is \n(EVAL.), which translates eval\u00a3 e. First, we recursively translate e. Next, recall that (EVAL) in Figure \n3 includes in P(\u00a3) any strings evaluated by this occurrence of eval. We parse and translate those strings \nsj to yield expressions ej. Then we replace the call to eval by a conditional that binds e' to a fresh \nvariable x (so that e' is only evaluated once) and then tests x against the strings in P(\u00a3), yielding \nthe appropriate ej if we .nd a match. If not, we fall through to the last case, which eval\u00aduates the \nstring with safe eval\u00a3 x, a safe wrapper around eval that adds additional dynamic checks we describe \nbelow (Section 3.3). This catch-all case allows execution to con\u00adtinue even if we encounter an unpro.led \nstring, and also al\u00adlows us to blame the code from location \u00a3 if it causes a subse\u00adquent run-time type \nerror. In our formalism, adding the form blame \u00a3 allows us to formally state soundness: TinyRuby programs \nthat are pro.led, transformed, and type checked never get stuck at run time, and reduce either to values \nor to blame. In practice, by tracking blame we can also give the user better error messages.  (SEQ.) \nM (REFL.) Pf e1 e 1 e .{x, v, blame e} Pf e2 e2 M Pf e e Pf e1; e2 e1M ; e2 M (EVAL.) Pf e e M Pf parse(sj \n) ej x fresh 1 0 sj .P(e) M let x = e in P(\u00a3) (which by (CALL-M) in Figure 3 contains the methods intercepted \nby this de.nition), we de.ne a method named sj that takes all but the .rst argument of method missing. \nThe method body is e ', except we bind x1, the .rst argument, to ' sj , since it may be used in e . Our \napproach to translating method missing completely eliminates it from the program, and there is no fall-through \ncase. There are two advantages to this approach. First, a static analysis that analyzes the translated \nprogram need not include special logic for handling method missing. Second, it may let us .nd places \nwhere method missing intercepts MM e = BB@ if x=s1 then e1 else if x=s2 then e2 ... CCA else safe eval\u00a3 \nx the wrong method. For example, if our pro.ling runs show Pf eval\u00a3 e e MM that A.method missing is intended \nto handle methods foo and bar, DRuby s type system will complain if it sees a call (SEND.) to an unde.ned \nA.baz method in the translated program. Pf ei e M 0 x fresh We believe this will prove more useful to \na programmer i . 0..n sj .P(e) i let x = e1 M in 1 than simply assuming that a method missing method \nis in\u00ad tended to handle arbitrary calls. However, one consequence of this approach is that if a program \nis rejected by DRuby s type system, then unpro.led calls to method missing would cause the program to \nget stuck. The last step in the translation is to insert empty method M MM if x=s1 then e0.parse(s1)(e2,...,e \nn) M MM else if x=s2 then e0.parse(s2)(e2,...,e n) ... M MM else safe eval\u00a3 e0. + x + (e2, ..., e n) \nM e = BB@ \u00ab CCA Pf e0.send\u00a3(e1,...,en) e M (METH-MISSING.) de.nitions at the top of the program. We \nneed this step so we Pf e e M sj .P(e) can formally prove type soundness. For example, consider a def\u00a3 \nA.parse(s1)(x2,...,xn)=(let x1 = s1 in e M); MM e = program with a method de.nition and invocation: def\u00a3 \nA.parse(s2)(x2,...,xn)=(let x1 = s2 in e M); ... Pf def\u00a3 A.method missing(x1,...,xn)= e e MM ... def\u00a3 \nA.m(...)= e; ... ;(new A).m(...); ... \u00ab (PROG.) M jjj j M The challenge here is that the de.nition of \nA.m might occur Pf e e (def\u00a3j A.m(x1,...,x)= ...) . e n under complex circumstances, e.g., under a conditional, \nor 111 1 def\u00a31 A.m (x1,...,x n1)= blame e1; 222 2 def\u00a32 A.m (x1,...,x n2)= blame e2; ... deep in a method \ncall chain. To ensure (new A).m(...) is ed = valid, we must know A.m has been de.ned. One solution would \nbe to build a .ow-sensitive type sys\u00adtem for TinyRuby, i.e., one that tracks must be de.ned information \nto match uses and de.nitions. However, in our experience, this kind of analysis would likely be quite \ncom\u00adplex, since de.nitions can appear anywhere, and it may be hard for a programmer to predict its behavior. \nInstead, we assume that any method syntactically present in the source code is available everywhere and \nrely on dy\u00adnamic, rather than static, checking to .nd violations of our assumption. Translation Pf e \n= (ed; e '), de.ned by (PROG ) in Figure 4, enforces this discipline. Here ed is ' a sequence of method \nde.nitions, and e is the translation of e using the other rules. For each de.nition of A.m occur\u00adring \nin e ', we add a mock de.nition of A.m to ed, where the body of the mock de.nition signals an error using \nblame \u00a3 to blame the location of the actual de.nition. We could also have built ed from the method de.nitions \nactually seen during execution, e.g., (DEF) in Figure 3 could record what methods are de.ned. We think \nthis would also be a reasonable design, but would essentially require that users have tests to drive \npro.ling runs in order to statically analyze their code, even if they do not use features such as eval. \nThus for a bit more .exibility, we build ed based Pf e = (ed; e M) Figure 4. Transformation to static \nconstructs (partial) (SEND ) is similar to (EVAL ). We recursively trans\u00adlate the receiver e0 and arguments \nei. We replace the invo\u00adcation of send with code that binds fresh variable x to the .rst argument, which \nis the method name, and then tests x against each of the strings sj in P(\u00a3), which were recorded by (SEND) \nin our semantics. If we .nd a match, we invoke the appropriate method directly. While our formal rule \ndu\u00ad ' plicates e for each call to send, in our implementation these i expressions are side-effect free \n(i.e., they consist only of lit\u00aderals and identi.ers), and so we actually duplicate very little code \nin practice. Otherwise, in the fall-through case, we call safe eval with a string that encodes the method \ninvocation ' we concatenate the translated expressions e with appropri\u00ad i ate punctuation and the method \nname x. (Note that in this '' string, by e we really mean unparse(e ), but we elide that ii detail to \nkeep the formal rule readable.) (METH-MISSING ) follows a similar pattern. First, we recursively translate \nthe body as e '. For each string sj in  (SEVAL) (M, V,e).(MM , P,s)parse(s) .\u00a3 e M (MM , V, [e M ]\u00a3).(MMM \n, PM ,v) (M, V, safe eval\u00a3 e).(MM , P.PM ,v) (IF . ) MMM e1 .\u00a3 e1 e2 .\u00a3 e2 e3 .\u00a3 e3 M MM if e1 then e2 \nelse e3 .\u00a3 if [e1]\u00a3 then e2 else e3 (CALL . ) ei .\u00a3 ei M i . 0..n M MM e0.m(e1,...,en) .\u00a3 [e0]\u00a3.m(e1,...,e \nn) (DEF . ) def\u00a31 A.m(x1,...,xn)= e .\u00a3 blame e M (IF-WRAP-T) (M, V,e1).(M1, P1, [true]\u00a3)(M1, V,e2).(M2, \nP2,v2) (M, V, if e1 then e2 else e3).(M2, (P1 .P2),v2) (IF-WRAP-BLAME) (M, V,e1).(M1, P1,v) v .{[s]\u00a3, \n[new A]\u00a3} (M, V, if e1 then e2 else e3).(M1, P1, blame e) (CALL-WRAP) (Mi, V,ei).(Mi+1, Pi,vi) i . 0..n \nv0 = [new A]\u00a311 (def\u00a3 A.m(x1,...,xn)= e) . Mn+1 m = method missing VM =[self . v0,x1 . [v1]\u00a311 ,...,xn \n. [vn]\u00a311 ] (Mn+1, VM ,e).(MM , PM ,v) [ (M0, V,e0.m(e1,...,en)).(MM , (Pi) .PM , [v]\u00a311 ) i Figure 5. \nSafe evaluation rules (partial) on static occurrences of de.nitions, but we might make dynamic method \nde.nition tracking an option in the future.  3.3 Safe Evaluation To handle uses of dynamic features \nnot seen in a pro.le, our translation in Figure 4 inserts calls to safe eval\u00a3 e,a safe wrapper around \neval. Figure 5 gives some of the reduction rules for this form. In the .rst rule, (SEVAL), we reduce \nsafe eval\u00a3 e by evaluating e to a string s, parsing s, ' translating the result to e via the '.\u00a3 relation \n(a source-to\u00ad ' source transformation), and then evaluating [e ]\u00a3, a wrapped ' e '. The expression [e \n]\u00a3 behaves the same as e ', except if it is used type-unsafely then our semantics produces blame \u00a3, meaning \nthere was an error due to dynamic code from \u00a3. This is contrast to type-unsafe uses of unwrapped values, \nwhich cause the semantics to go wrong (formally, reduce to error). ' In practice, we implement [e ]\u00a3 \nby a method that accepts an object and modi.es it to have extra run-time checking (Section 4). ' The \nrelation e'.\u00a3 e rewrites the expression e, insert\u00ading [\u00b7]\u00a3 where needed. We give three example rewrite \nrules. (IF. . ) rewrites each subexpression of the if, wrapping the guard since its value is consumed. \nSimilarly, (CALL. .) wraps the receiver so that at run time we will check the receiver s type and blame \n\u00a3 if the call is invalid. Lastly, (DEF. . ) replaces a method de.nition by blame we can\u00adnot permit methods \nto be rede.ned in dynamically checked code, since this could undermine the type safety of statically \ntyped code.  When wrapped values are used, we unwrap them and ei\u00adther proceed as usual or reduce to \nblame \u00a3. For example, (IF-WRAP-T) evaluates the true branch of an if given a guard that evaluates to \n[true]\u00a3, whereas (IF-WRAP-BLAME) eval\u00aduates to blame \u00a3 if the guard evaluates to a non-boolean. No\u00adtice \nthe contrast with ordinary reduction, which would in\u00adstead go wrong when if is used with a non-boolean \nguard. (CALL-WRAP) handles a method invocation in which the receiver is a wrapped object. Here we must \nbe careful to also wrap the arguments (in the de.nition of V') when evaluating the method body; because \nwe did not statically check that this call was safe, we need to ensure that the arguments types are checked \nwhen they are used in the method body. Similarly, we must wrap the value returned from the call so that \nit is checked when used later. Notice that our semantics for safe eval\u00a3 e does not use any static type \ninformation. Instead, it performs extensive object wrapping and forbids method de.nitions in dynamic \ncode. One alternative approach would be to run DRuby s type inference algorithm at run time on the string \ne returns. However, this might incur a substantial run-time overhead (given the space and time requirements \nof PRuby s type inference system), and it disallows any non-statically typed parts of the program. Another \nalternative would be to only keep objects wrapped until they are passed to statically typed code. At \nthat point, we could check their type against the assumed static type, and either fail or unwrap the \nobject and proceed. This would be similar to gradual typing (Siek and Taha 2006, 2007; Herman et al. \n2007). We may explore this approach in the future, as having static types available at run time could \nreduce the overhead of our wrappers at the expense of additional space overhead.  3.4 Formal Properties \nIt should be clear from the discussions above that our trans\u00adlation preserves the character of the original \nprogram, with respect to the core behavior and the dynamic features seen during the pro.ling run(s). \nWe can prove this formally: THEOREM 1 (Translation Faithfulness). Suppose (\u00d8, \u00d8,e). '' (M, P ,v) and \nP .P and Pf e = e '. Then there exist MP such that (\u00d8, \u00d8,e ' ).(MP , \u00d8,v). In other words, if we translate \nan expression based on its pro.le (or a superset of the information in its pro.le), both the original \nand translated program produce the same result.  Also, since our translation has removed all dynamic \nfeatures, we will record no additional pro.ling information in the second execution, making the .nal \npro.le \u00d8. In our formal system, an expression e always evaluates to the same result and produces the \nsame pro.le, but in prac\u00adtice, programs may produce different pro.les under different circumstances. \nFor example, if we want to test the behav\u00adior of e, we could evaluate e; e1, where e1 is a test case \nfor the expression e, and e; e2, where e2 is a different test case. Based on the above theorem, if our \npro.ling runs are suf.\u00adcient, we can use them to translate programs we have not yet pro.led without changing \ntheir behavior: COROLLARY 2. Suppose (\u00d8, \u00d8, (e; e1)).(M1, P1,v1). Further, suppose that (\u00d8, \u00d8, (e; e2)).(M2, \nP2,v2). Then if P2 .P1 and P1 f (e; e2) = e ', then (\u00d8, \u00d8,e ' ). (M' 2, \u00d8,v2). In other words, if the \ndynamic pro.le P1 of (e; e1) covers all the dynamic behavior of (e; e2), then using P1 to translate e; \ne2 will not change its behavior. In our experiments, we found that many dynamic constructs have only \na limited range of behaviors, and hence can be fully represented in a pro.le. Thus, by this theorem, \nmost of the time we can gather a pro.le and then use that to transform many different uses of the program. \nFinally, the last step is to show that we can perform sound static analysis on the translated program. \nA companion tech\u00adnical report gives a (mostly standard) type system for this language (Furr et al. 2009a). \nOur type system proves judg\u00adments of the form MT f e, meaning under method type table MT, a mapping from \nmethod names to their types, program e is well-typed. In order for our type system to be sound, we forbid \nwell-typed programs from containing eval, send, or method missing (since we cannot check these statically), \nthough programs may contain uses of safe eval and [\u00b7]\u00a3 (which are checked dynamically). We can formally \nprove the following type soundness theorem, where r stands for either a value, blame \u00a3, or error, an \nerror generated if the expression goes wrong: THEOREM 3 (Type Soundness). If \u00d8f e and (\u00d8, \u00d8,e). (M, P,r), \nthen r is either a value or blame \u00a3. Thus, r . = error. This theorem says that expressions that are well-typed \nin this language do not go wrong. Recall that the translation from Section 3.2 eliminates the three dynamic \nfeatures that this type system does not permit, and inserts appropriate mock de.nitions at the beginning \nof the program. Thus, if we start with an arbitrary program, gather information about its dynamic feature \nusage via the instrumentation in Figure 3, and translate it according to Figure 4, we can then apply \nsound static type checking to the resulting program, while still precisely modeling uses of eval, send, \nand method missing in the original program. 4. Implementation As discussed earlier, PRuby is an extension \nto Diamond\u00adback Ruby (DRuby), a static type inference system for Ruby. DRuby accepts standard Ruby programs \nand translates them into the Ruby Intermediate Language (RIL), a much sim\u00adpler subset of Ruby designed \nfor analysis and transforma\u00adtion (Furr et al. 2009b). DRuby performs static type infer\u00adence internally \non RIL code, and reports any type errors to the user. DRuby supports a wide range of typing constructs, \nincluding intersection and union types, optional method ar\u00adguments and varargs methods, self types, object \ntypes with .elds, parametric polymorphism, mixins, tuple types, and .rst class method types, among others \n(Furr et al. 2009c). PRuby is a drop-in replacement for the regular Ruby interpreter. The user runs PRuby \nwith the command druby --dr-profile filename.rb This command runs .lename.rb to gather a pro.le, trans\u00adforms \nthe program to eliminate dynamic constructs accord\u00ading to the pro.le (as in Section 3.2), and then runs \nDRuby s type inference on the resulting program. In the future, we expect pro.ling to be done separately \nand the results saved for later use, but for experimental purposes our current all-in-one setup is convenient. \nAltogether, PRuby, which includes the enhanced DRuby source, comprises approxi\u00admately 16,000 lines of \nOCaml and 800 lines of Ruby. There are three interesting implementation issues in PRuby: performing pro.ling, \nhandling additional dynamic constructs, and implementing safe eval and its relatives. 4.1 Pro.ling PRuby \ncreates pro.les by running an instrumented version of the source code. PRuby .rst must discover what \nsource .les, in addition to the one speci.ed on the command line, are executed and hence need to be instrumented; \nas we saw in Section 2, this is hard to determine statically. To .nd the set of executed .les, PRuby \nruns the original program but with special code prepended to replace the de.nitions of require and load3 \nwith new methods that record the set of loaded .les and log them to disk when the program exits. Since \nboth methods are affected by the current load path, which may be changed by the program, we log that \nas well. Next, PRuby parses all .les seen in require and load calls, translates them into RIL, and adds \ninstrumentation to record uses of eval, send, method missing, and other dy\u00adnamic features, to mimic the \nsemantics in Section 3.1. Fi\u00adnally, we unparse the transformed RIL code into /tmp, and then run the output \ncode to compute a pro.le. The instru\u00admentation is generally straightforward, though care must be taken \nto ensure the program runs correctly when executed in /tmp. 3 Ruby s load is similar to require, but \nit always (re-)evaluates the given .le, even if previously loaded, while require evaluates a .le only \nonce.  4.2 Additional Dynamic Constructs In addition to the constructs discussed in Section 3, PRuby \nalso handles several other closely related dynamic features. Similarly to eval, Ruby includes instance \neval, class eval, and module eval methods that evaluate their string argument in the context of the method \nreceiver (an instance, class, or module, respectively). For example, calling x.class eval( def foo()...end \n) adds the foo method to the class stored in variable x. We pro.le these methods the same way as eval, \nbut we use a slightly different transformation. For example, we replace the above code by x.class eval() \ndo def foo()...end end Here we keep the receiver object x in the transformed pro\u00adgram, because the de.nition \nis evaluated in x s context. DRuby recognizes this form of class eval (which is also valid Ruby code) \nspecially, analyzing the body of the code block in x s context. Our transformation for instance eval \nand module eval is similar. Ruby includes four methods for accessing .elds of ob\u00adjects, {instance, class} \nvariable {get, set}, which take the name of the instance or class variable to read or write. When PRuby \npro.les these methods, it records the variable name and transforms the expression into calls to {instance, \nclass} eval. For example, we transform a.instance variable set ( @x , 2) into a.instance eval do @x = \n2 end. Finally, PRuby also includes support for attr and attr {reader, writer, accessor}, which create \ngetter/setter meth\u00adods given a .eld name, and also for const {get, set}, which directly read or write \nconstants (write-once variables). PRuby pro.les calls to these methods, and replaces the non-literal \n.eld or constant name arguments with the string literals seen at run time. DRuby then specially handles \nthe case when these methods are called with string literals. For example, when DRuby sees const set( \nX , 3), it will give the con\u00adstant X the type Fixnum. These constructs are translated similarly to how \nthe other dynamic features are treated, e.g., by inserting calls to safe eval for unseen strings. Ruby \nincludes some dynamic features PRuby does not yet support. In particular, DRuby s type system treats \ncer\u00adtain low-level methods specially, but these methods could be rede.ned, effectively changing the semantics \nof the lan\u00adguage. For instance, if a programmer changes the Module# append features method, they can \nalter the semantics of module mixins. Other special methods include Class#new, Class#inherited, Module#method \nadded, and Module# included. PRuby also does not support applying dynamic constructs to per-object classes \n(eigen-classes) or calling dynamic features via the Method class. In addition to these features, PRuby \ncurrently does not support const missing, which handles accesses to unde.ned constants, similarly to \nmethod missing; we expect to add support for this in the future. Currently, PRuby does not support nested \ndynamic con\u00adstructs, e.g., eval ing a string with eval inside it, or send ing a message to the eval method. \nIn these cases, PRuby will not recursively translate the nested construct. We believe these restrictions \ncould be lifted with some engineering effort. 4.3 Implementing safe eval We implemented safe eval\u00a3 e, \n[e]\u00a3, and blame \u00a3 as two components: a small Ruby library with methods safe eval(), wrap(), and blame(), \nand druby eval, an external program for source-to-source translation. The druby eval program is written \nusing RIL, and it im\u00adplements the '.\u00a3 translation as shown in Figure 5. For exam\u00adple, it translates method \nde.nitions to calls to blame(), and it inserts calls to wrap() where appropriate. There are a few additional \nissues when implementing '.\u00a3 for the full Ruby language. First, we need not wrap the guard of if, because \nin Ruby, if accepts any object, not just booleans. Second, in addition to forbidding method de.nitions, \nwe must also dis\u00adallow calls to methods that may change the class hierarchy, such as undef method. Lastly, \nwe add calls to wrap() around any expressions that may escape the scope of safe eval, such as values \nassigned to global variables and .elds. Given druby eval, our library is fairly simple to imple\u00adment. \nThe safe eval() method simply calls druby eval to translate the string to be evaluated and then passes \nthe re\u00adsult to Ruby s regular eval method. The blame() method aborts with an appropriate error. Lastly, \nthe wrap() method uses a bit of low-level object manipulation (in fact, exactly the kind PRuby cannot \nanalyze) to intercept method calls: Given an object, wrap() .rst renames the object s methods to have \nprivate names beginning with druby, then calls undef method to remove the original methods, and lastly \nadds a method missing de.nition to intercept all calls to the (now removed) original methods. Our method \nmissing code checks to see if the called method did exist. If so, it dele\u00adgates to the original method \nwith wrapped arguments, also wrapping the method s return value. If not, it calls blame(). One nice feature \nof our implementation of wrap() is that because we do not change the identity of the wrapped object, \nwe preserve physical equality, so that pointer comparisons work as expected. Our approach does not quite \nwork for in\u00adstances of Fixnum and Float, as they are internally repre\u00adsented as primitive values rather \nthan via pointed-to objects. Instead, we wrap these objects by explicitly boxing them in\u00adside of an traditional \nobject. We then extend the compari\u00ad son methods for these classes to delegate to the values inside these \nobjects when compared. 5. Pro.ling Effectiveness We evaluated PRuby by running it on a suite of 13 programs \ndownloaded from RubyForge. We included any dependen\u00adcies directly used by the benchmarks, but not any \noptional components. Each benchmark in our suite uses at least some  Benchmark LoC Req Eval Snd Total \nai4r-1.0 764 4/ 4 2/ 2 4/ 4 10/ 10 bacon-1.0.0 258 \u00b7 \u00b7 \u00b7 \u00b7 hashslice-1.0.4 78 \u00b7 \u00b7 \u00b7 \u00b7 hyde-0.0.4 115 \n2/ 2 1/11 1/ 2 4/ 15 isi-1.1.4 224 \u00b7 1/ 1 \u00b7 1/ 1 itcf-1.0.0 178 \u00b7 \u00b7 \u00b7 \u00b7 memoize-1.2.3 69 \u00b7 \u00b7 1/ 1 1/ \n1 pit-0.0.6 166 2/ 2 \u00b7 \u00b7 2/ 2 sendq-0.0.1 88 \u00b7 \u00b7 \u00b7 \u00b7 StreetAddress-1.0.1 875 1/ 1 \u00b7 1/15 2/ 16 sudokusolver-1.4 \n188 2/ 2 1/ 1 \u00b7 3/ 3 text-highlight-1.0.2 262 \u00b7 2/48 \u00b7 2/ 48 use-1.2.1 193 \u00b7 \u00b7 \u00b7 \u00b7 Total 3,458 11/11 \n7/63 7/22 25/ 96 Req dyn. require and load G/S .eld and constant get/set; Eval eval and variants \nattr and its variants Snd send and send MM method missing n/m n=occ, m=uniq strs Lib Module LoC Req \nEval Snd G/S MM Total archive-tar-minitar date digest .leutils hoe net openssl optparse ostruct pathname \nrake rubyforge rubygems temp.le term-ansicolor testunit Other 539 1,938 82 950 502 2,217 637 964 80 511 \n1,995 500 4,146 134 78 1,293 4,871 \u00b7 \u00b7 1/ 1 \u00b7 1/ 2 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 2/19 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 3/ 33 \u00b7 4/101 \u00b7 1/ 8 \n3/ 2 \u00b7 \u00b7 \u00b7 3/136 1/ 2 4/ 32 \u00b7 1/ 28 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 1/ 2 \u00b7 \u00b7 2/ 4 2/ 2 1/ 1 \u00b7 \u00b7 \u00b7 1/ 2 \u00b7 1/63 \u00b7 2/ 32 \u00b7 1/ \n1 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 4/ 68 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 1/ 9 \u00b7 \u00b7 \u00b7 \u00b7 1/ 2 \u00b7 \u00b7 \u00b7 2/ 32 3/ 33 2/ 2 4/101 2/ 4 \n1/ 8 3/ 20 2/ 4 3/ 11 1/ 1 5/155 1/ 2 8/100 2/ 4 1/ 28 1/ 63 \u00b7 Total 21,437 4/22 20/360 8/74 7/101 2/11 \n41/568 (a) Per-benchmark results (no occ. of MM or G/S) (b) Library results (as covered by benchmarks) \nFigure 6. Dynamic feature pro.ling data from benchmarks of the dynamic language features handled by PRuby, \neither in the application itself or indirectly via external libraries. All of our benchmarks included \ntest cases, which we used to drive the pro.ling runs for our experiments. Finally, many projects use \nthe rake program to run their test suites. Rake normally invokes tests in forked subprocesses, but as \nthis would make it more dif.cult to gather pro.ling information, we modi.ed rake to invoke tests in the \nsame process. 5.1 Dynamic Feature Usage Figure 6 measures usage of the dynamic constructs we saw in our \npro.ling runs. We give separate measurements for the benchmark code (part (a)) and the library modules \nused by the benchmarks (part (b)). We should note that our measure\u00adments are only for features seen during \nour pro.ling runs the library modules in particular include other uses of dy\u00adnamic features, but they \nwere in code that was not called by our benchmarks. For each benchmark or module, we list its lines of \ncode (computed by SLOCCount (Wheeler 2008)) and a summary of the pro.ling data for its dynamic features, \ngiven in the form n/m, where n is the number of syntactic occurrences called at least once across all \nruns, and m is the number of unique strings used with that feature. For Req and G/S, we only count occurrences \nthat are used with non-constant strings. Any library modules that did not execute any dy\u00adnamic features \nare grouped together in the row labeled Other in Figure 6(b). These results clearly show that dynamic \nfeatures are used pervasively throughout our benchmark suite. All of the features handled by PRuby occur \nin some program, al\u00adthough method missing is only encountered twice. Eight of the 13 benchmarks and more \nthan 75% of the library module code use dynamic constructs. Perhaps surprisingly (given its power) eval \nis the most commonly used construct, occurring 27 times and used with 423 different strings metaprogramming \nis indeed extremely common in Ruby. Over all benchmarks and all libraries, there were 66 syntac\u00adtic occurrences \nof dynamic features that cumulatively were used with 664 unique strings. Given these large numbers, it \nis critical that any static analysis model these constructs to ensure soundness.  5.2 Categorizing Dynamic \nFeatures The precision of DRuby s type inference algorithm depends on how much of the full range of dynamic \nfeature usage is observed in our pro.les. To measure this, we manually categorized each syntactic occurrence \nfrom Figure 6 based on how dynamically it is used. For example, eval x + 2 is not dynamic at all since \nthe eval will always evaluate the same string, whereas eval ($stdin.readline) is extremely dynamic, since \nit could evaluate any string. Figure 7 summarizes our categorization. We found that all of the dynamic \nfeatures in our pro.les are used in a con\u00adtrolled manner their use is either determined by the class \nthey are called in, or by the local user s Ruby environment. In particular, we found no examples of truly \ndynamic code, e.g., eval ing code supplied on the command line, suggest\u00ading that pro.ling can be used \neffectively in practice. We now discuss each category in detail. Single The least dynamic use of a construct \nis to always invoke it with the same argument. Three uses of eval and seven uses of send can only be \npassed a single string. For instance, the sudokusolver benchmark includes the code PROJECT = SudokuSolver \nPROJECT VERSION = eval( #{PROJECT}::VERSION )  which is equivalent to SudokuSolver::VERSION. As another \nexample, the ostruct module contains the code meta.send(:de.ne method, name) { @table[name] } This code \nuses send to call the private method de.ne method from outside the class. The other uses of send in this \ncate\u00adgory were similar. Collection A slightly more expressive use of dynamic con\u00adstructs is to apply \nthem to a small, .xed set of arguments. One common idiom (18 occurrences) we observed was to apply a \ndynamic construct uniformly across a .xed collec\u00adtion of values. For example, the code in Fig. 1(d) iterates \nover an Array of string literals, evaling a method de.ni\u00adtion string from each literal. Thus, while multiple \nstrings are passed to this occurrence of eval, the same strings will be used for every execution of the \nprogram. Additionally, any pro.le that executes this code will always see all possible strings for the \nconstruct. Bounded We also found some dynamic constructs that are called several times via different \npaths (in contrast to being called within the same iteration over a collection), but the set of values \nused is still bounded. For example, consider the following code from the pathname module: if RUBY VERSON \n< 1.9 TO PATH = :to str else TO PATH = :to path end path = path. send (TO PATH) Here one of two strings \nis passed to send, depending on the library version. Sometimes dynamic constructs are called in internal \nmethods of classes or modules, as in the following exam\u00adple from the net/https library: def self . ssl \ncontext accessor (name) HTTP.module eval(<<-End, FILE , LINE + 1) def #{name}() ... end # de.nes get \nmethod def #{name}=(val) ... end # de.nes set method end End end ssl context accessor :key ssl context \naccessor : cert store This code de.nes method ssl context accessor, which given a symbol generates get \nand set methods based on that name. The body of the class then calls this method to add several such \nget/set methods. This particular method is only used in the class that de.nes it, and seems not to be \nintended for use elsewhere (nor is it used anywhere else in our benchmarks). Features in this category \nare also essentially static, be\u00adcause their behavior is determined by the class they are con\u00adtained in, \nand pro.ling, even in isolation, should be fully effective. Combining this with the previous two categories \ngives a total of 42 features used with 538 unique strings, which means around 2/3 of the total dynamic \nfeature usage across all runs is essentially static. Category Req Eval Snd G/S MM Total Single \u00b7 3/ 3 \n7/ 7 \u00b7 \u00b7 10/ 10 Collection \u00b7 14/337 1/ 2 3/ 48 \u00b7 18/387 Bounded \u00b7 7/ 69 4/20 3/ 52 \u00b7 14/141 File system \n11/11 3/ 14 \u00b7 \u00b7 \u00b7 14/ 25 Open module 4/22 \u00b7 3/67 1/ 1 2/11 10/101 Total 15/33 27/423 15/96 7/101 2/11 \n66/664 n/m n=occ, m=uniq strs Figure 7. Categorization of pro.led dynamic features File System The \nnext category covers those dynamic fea\u00adtures whose use depends on the local .le system. This in\u00adcludes \nmost occurrences of Req, e.g., the code at the top of Figure 1(a), which loads a .le who name is derived \nfrom FILE , the current .le name. Another example is the fol\u00adlowing convoluted code from rubyforge: con.g \n= File.read( FILE ). split (/ END /).last.gsub( /#\\{(.*)\\}/) { eval $1 } This call reads the current \n.le, removes any text that appears before END (which signals the Ruby interpreter to stop reading), and \nthen substitutes each string that matches the given pattern with the result of calling eval on that string. \nDe\u00adspite its complexity, for any given installation of the library module, this code always evaluates \nthe same set of strings. The other cases of this category are similar to these two, and in all cases, \nthe behavior of the dynamic constructs de\u00adpends on the .les installed in the user s Ruby environment. \nOpen module The last category covers cases in which dy\u00adnamic features are called within a library module, \nbut the library module itself does not determine the uses. For exam\u00adple, the testunit module uses send \nto invoke test methods that the module users specify. Similarly, the rake module loads client-speci.ed \nRuby .les containing test cases. As another example, the ostruct module is used to create record-like \nob\u00adjects, as shown in Figure 1(e). These cases represent an interesting trade-off in pro.ling. If we \npro.le the library modules in isolation, then we will not see all client usage of these 10 constructs \n(hence they are open ). However, if we assume the user s Ruby envi\u00adronment is .xed, i.e., there are no \nnew .rb .les added at run time, then we can fully pro.le this code, and therefore we can perform full \nstatic typing checking on the code. 6. Type Inference Finally, we used PRuby to perform type inference \non each of the benchmarks, i.e. PRuby gathered the pro.ling data reported in Figure 6, transformed the \ncode as outlined in Sections 3 and 4, and then applied DRuby s type inference algorithm on the resulting \nprogram. When we .rst ran PRuby on our benchmarks, it produced hundreds of messages indicating potential \ntype errors. As we began analyzing these results, we noted that most of the messages were false positives, \nmeaning the code would actually execute type safely at run time. In fact, we found  Benchmark Total \nLoC Time (s) ai4r-1.0 21,589 343 bacon-1.0.0 19,804 335 hashslice-1.0.4 20,694 307 hyde-0.0.4 21,012 \n345 isi-1.1.4 22,298 373 itcf-1.0.0 23,857 311 memoize-1.2.3 4,171 9 pit-0.0.6 24,345 340 sendq-0.0.1 \n20,913 320 StreetAddress-1.0.1 24,554 309 sudokusolver-1.4 21,027 388 text-highlight-1.0.2 2,039 2 use-1.2.1 \n20,796 323 Figure 8. Type inference results that much of the offending code is almost statically typable \nwith DRuby s type system. To measure how close the code is to being statically typable, we manually applied \na number of refactorings and added type annotations so that the programs pass DRuby s type system, modulo \nseveral actual type errors we found. The result gives us insight into what kind of Ruby code programmers \nwant to write but is not easily amenable to standard static typing. (DRuby s type system combines a wide \nvariety of features, but most of the features are well\u00adknown.) In the remainder of this section, we discuss \nthe true type errors we found (Section 6.1), what refactorings were needed for static typing (Section \n6.2), and what we learned about the way people write Ruby programs (Section 6.3). Overall, we found that \nmost programs could be made stat\u00adically typable, though in a few cases code seems truly dy\u00adnamically \ntyped. 6.1 Performance and Type Errors Figure 8 shows the time it took PRuby to analyze our modi\u00ad.ed \nbenchmarks. For each benchmark, we list the total lines of code analyzed (the benchmark, its test suite, \nand any li\u00adbraries it uses), along with the analysis time. Times were the average of three runs on an \nAMD Athlon 4600 proces\u00adsor with 4GB of memory. These results show that PRuby s analysis takes only a \nfew minutes, and we expect the time could be improved further with more engineering effort. Figure 9 \nlists, for each benchmark or library module used by our benchmarks, its size, the number of refactorings \nand annotations we applied (discussed in detail in the next section), and the number of type errors we \ndiscovered. The last row, Other, gives the cumulative size of the benchmarks and library modules with \nno changes and no type errors. PRuby identi.ed eight type errors, each of which could cause a program \ncrash. The two errors in the pathname mod\u00adule were due to code that was intended for the development \nbranch of Ruby, but was included in the current stable ver\u00adsion. In particular, pathname contains the \ncode def world readable ?() FileTest . world readable ?(@path) end Module LoC Refactorings Annots Errors \narchive-minitar 538 3 \u00b7 1 date 1,938 58 8 \u00b7 digest 82 1 \u00b7 \u00b7 .leutils 950 1 7 \u00b7 hoe 502 3 2 \u00b7 net 2,217 \n22 3 \u00b7 openssl 637 3 3 1 optparse 964 15 21 \u00b7 ostruct 80 1 \u00b7 \u00b7 pathname 511 21 1 2 pit-0.0.6 166 2 \u00b7 \n\u00b7 rake 1,995 17 7 \u00b7 rational 299 3 25 \u00b7 rbcon.g 177 1 \u00b7 \u00b7 rubyforge 500 7 \u00b7 rubygems 4,146 44 47 4 sendq-0.0.1 \n88 1 \u00b7 \u00b7 shipit 341 4 \u00b7 \u00b7 temp.le 134 1 3 \u00b7 testunit 1,293 3 20 \u00b7 term-ansicolor 78 1 \u00b7 text-highlight-1.0.2 \n262 1 1 \u00b7 timeout 59 1 1 \u00b7 uri 1,867 15 20 \u00b7 webrick 435 4 1 \u00b7 Other 4,635 \u00b7 \u00b7 \u00b7 Total 24,895 226 177 \n8 Figure 9. Changes needed for static typing However, the FileTest.world readable? method is in the \nde\u00advelopment version of Ruby but not in the stable branch that was used by our benchmarks. The second \nerror in pathname is a similar case with the world writable? method. The type error in archive-minitar \noccurs in code that at\u00adtempts to raise an exception but refers to a constant incor\u00adrectly. Thus, instead \nof throwing the intended error, the pro\u00adgram instead raises a NameError exception. The four type errors \nin rubygems were something of a surprise this code is very widely used, with more than 1.6 million downloads \non rubyforge.org, and so we thought any errors would have already been detected. Two type errors were \nsimple typos in which the code incorrectly used the Policy class rather than the Policies constant. The \nthird er\u00adror occurred when code attempted to call the non-existent File.dir? method. Interestingly, this \ncall was exercised by the rubygems test suite, but the test suite de.nes the miss\u00ading method before the \ncall. We are not quite sure why the test suite does this, but we contacted the developers and con\u00ad.rmed \nthis is indeed an error in rubygems. The last type er\u00adror occurred in the =~ method, which compares the \n@name .eld of two object instances. This .eld stores either a String or a Regexp, and so the body of \nthe method must perform type tests to ensure the types are compatible. However, due to a logic error, \none of the four possible type pairings is han\u00addled incorrectly, which could result in a run time type \nerror. Finally, the openssl module adds code to the Integer class that calls OpenSSL :: BN :: new(self). \nIn this call, self has type Integer, but the constructor for the OpenSSL :: BN class takes a string argument. \nTherefore, calling this code always triggers a run-time type error.  6.2 Changes for Static Typing \nTo enable our benchmarks and their libraries to type check (modulo the above errors), we applied 226 \nrefactorings and added 177 type annotations. We can divide these into the following categories. For the \nmoment, we refrain from eval\u00aduating whether these changes are reasonable to expect from the programmer, \nor whether they suggest possible improve\u00adments to PRuby; we discuss this issue in detail in Sec\u00adtion \n6.3. Dynamic Type Tests (177 Annotations) Ruby programs often use a single expression to hold values \nwith a range of types. Accordingly, DRuby supports union types (e.g., A or B) and intersection types \n(e.g., (Fixnum . Fixnum) and (Float . Float)). However, DRuby does not currently model run-time type \ntests specially. For example, if e has type A or B, then DRuby allows a program to call methods present \nin both A and B, but it does not support dynamically checking if e has (just) type A and then invoking \na method that is in A but not in B. To work around this limitation, we developed an anno\u00ad tation for \nconditional branches that allows programmers to indicate the result of a type test. For example, consider \nthe following code: 1 case x 2 when Fixnum: ###% x : Fixnum 3 x +3 4 when String: ###% x : String 5 \nx.concat world 6 end Here, the case expression on line 1 tests the class of x against two possibilities. \nThe annotations on lines 2 and 4 tell DRuby to treat x as having type Fixnum and String, respec\u00adtively, \non each branch. These annotations were extremely common we added them to 135 branches in total.We also \nadded 9 method annotations for intersection types and 33 method annotations for higher order polymorphic \ntypes. Polymorphic type signatures can be used by DRuby given annotations, but cannot currently be inferred. \nDRuby adds instrumentation to check all the above annotations dynami\u00adcally at run time, to ensure they \nare correct. Class Imprecision (81 Refactorings) In Ruby, classes are themselves objects that are instances \nof the Class class. Fur\u00adthermore, class methods are actually methods bound in\u00adside of these instances. \nIn many cases, we found program\u00admers use Class instances returned from methods to invoke class methods. \nFor example, consider the following code: 1 class A 2 def A.foo() ... end 3 def bar() 4 self . class \n.foo() # calls A.foo() 5 end 6 end Here the call on line 4 goes to the class method de.ned on line 2. \nHowever, the class method invoked on line 4 has type () . Class in DRuby, and since Class has no foo() \nmethod, DRuby rejects the call on line 4. To let examples like this type check, we changed self.class \nto use a different method call that dispatches to the current class. For example, def bar() myclass (). \nfoo() end def myclass() A end Similarly, an instance can look up a constant dynamically in the current \nclass using the syntax self . class :: X, requiring an analogous transformation. Block Argument Counts \n(24 Refactorings) In Ruby, higher\u00ad order methods can accept code blocks as arguments. How\u00ad ever, the \nsemantics of blocks is slightly different than regular methods. Surprisingly, Ruby does not require the \nformal pa\u00ad rameter list of a block to exactly match the actual arguments: formal arguments not supplied \nby the caller are set to nil, and extra actual arguments are ignored. DRuby, on the other hand, requires \nstrict matching of the number of block arguments, since otherwise we could never discover mismatched \nargument counts for blocks. Thus we modi.ed our benchmarks where necessary to make argu\u00ad ments lists \nmatch. We believe this is the right choice, because satisfying DRuby s requirement is a very minor change. \nNon-Top Level Requires (21 Refactorings) PRuby uses pro.ling to decide which .les are required during \na run, and therefore which .les should be included during type check\u00ading. However, some of our benchmarks \nhad conditional calls to require that were never triggered in our test runs, but that we need for static \ntyping. For instance, the URI module con\u00adtains the following code: 1 if target . class == URI::HTTPS \n2 require net/https 3 http.verify mode = OpenSSL::SSL::VERIFY PEER Here line 2 loads net/https if the \nconditional on line 1 is true. The method called on line 3 is added by a load-time eval inside of net/https. \nThus, to successfully analyze this code, PRuby needs to not only analyze the source code of net/https, \nbut it also must have its pro.le to know this method exists. However, the branch on line 1 was never \ntaken in our benchmarks, and so this require was never executed and the eval was not included in the \npro.le. We refactored cases like this by moving the require state\u00ad ment outside of the method, so that \nit was always executed when the .le is loaded.  Multiple Con.gurations (10 Refactorings) We encoun\u00adtered \nsome code that behaves differently under different op\u00aderating environments. For example, if de.ned?(Win32) \n.... # win32 code end .rst checks if the constant Win32 is de.ned before using windows-speci.c methods \nand constants in the body of the if. As another example, consider this code from rubygems: 1 if RUBY \nVERSION < 1.9 then 2 File .read .le name 3 else 4 File .read .le name , :encoding => UTF-8 In versions \nprior to Ruby 1.9 (the current development ver\u00adsion of Ruby), the read method only took a single param\u00adeter \n(line 2), whereas later versions accept a second pa\u00adrameter (line 4). When DRuby sees this code, it assumes \nboth paths are possible and reports that read is called with the wrong number of arguments. To handle \nthese type\u00adcon.icting cases, we commented out sections of code that were disabled by the platform con.guration. \nHeterogeneous Containers (12 Refactorings) DRuby sup\u00ad ports homogeneous containers with types such as \nArray<T> and Hash<K,V>. Since arrays are sometimes used heteroge\u00ad neously, DRuby also includes a special \ntype Tuple<T1, ..., Tn>, where the Ti are the tuple element types from left to right. Such a type is \nautomatically coerced to Array<T1 or ... or Tn> when one of its methods is invoked. However, sometimes \nthis automatic coercion causes type errors. For instance, the optparse module contains the fol\u00ad lowing \ncode: 1 def append(*args) 2 update(*args) 3 @list .push(args [0]) 4 end Here, calling the [] method \non line 3 forces args to have a homogeneous array type, losing precision and causing a type error. We \nrefactored this code to list the arguments to append explicitly, allowing DRuby to type check this method. \nWe also encountered several other similar cases, as well as examples where instances of Hash were used \nheterogeneously. Flow-insensitive Locals (11 Refactorings) DRuby treats local variables .ow-sensitively, \nsince their type may be up\u00addated throughout the body of a method. To be sound, we conservatively treat \nany local variables that appear inside of a block .ow-insensitively (Furr et al. 2009c). However, this \ncauses DRuby to report an error if a .ow-insensitive local variable is assigned con.icting types at different \nprogram points. We eliminated these errors by introducing a fresh local variable at each con.icting assignment \nand renaming subsequent uses. Other (65 Refactorings) We also needed a few other mis\u00adcellaneous refactorings. \nIn our benchmarks, there were 32 calls handled by method missing that were never seen in our benchmark \nruns. Hence PRuby reported these calls as going to unde.ned methods. We .xed this by manually copying \nthe method missing bodies for each method name they were called with, simulating our translation rules. \nWe could also have .xed this with additional test cases to expand our pro\u00ad.les, so that PRuby would add \nthese methods automatically during its transformation. In some cases, DRuby infers union types for an \nobject that actually has just one type. For example, rubygems in\u00adcludes a Package.open method that returns \nan instance of either TarInput or TarOutput, depending on whether a string argument is r or w. DRuby \ntreats the result as having ei\u00adther of these types, but as they have different methods, this causes a \nnumber of type errors. We .xed this problem by di\u00adrectly calling TarInput.open or TarOutput.open instead. \nA similar situation also occurred in the uri module. We also refactored a few other oddball cases, such \nas a class that created its own include method (which DRuby would confuse with Module.include) and some \ncomplex ar\u00adray and method manipulation that could be simpli.ed into typable code. Untypable Code (12 \nRefactorings) Finally, some of the code we encountered could not reasonably be statically typed, even \nwith refactorings and checked annotations. One example is the optparse class, which provides an API for \ncommand line parsing. Internally, optparse manipulates many different argument types, and because of \nthe way the code is structured, DRuby heavily con.ates types inside the module. We were able to perform \nlimited refactoring in\u00adside of optparse to gain some static checking, but ultimately could only eliminate \nall static type errors by manually wrap\u00adping the code using the wrap() method from our safe eval library \n(Section 4.3). The other cases of untypable code were caused by uses of low-level methods that manipulate \nclasses and modules di\u00adrectly in ways that DRuby does not support. For example, we found uses of remove \nmethod, undef method, and anony\u00admous class creation. We also found uses of two modules that perform higher-level \nclass manipulation: Singleton, which ensures only one instance of a class exists, and Delegate, which \ntransparently forwards method calls to a delegate class. DRuby does not support code that uses these \nlow\u00adlevel features and will not detect any run-time errors from their misuse.  6.3 Discussion and Future \nWork In our prior work on DRuby, we found that small bench\u00admarks are mostly statically typable. We believe \nour current results with PRuby suggest that even large Ruby programs are mostly statically typable on \nbalance, most of our refac\u00adtorings and type annotations indicate current limitations of DRuby, and a \nfew more suggest places where Ruby pro\u00adgrammers could easily change their code to be typable (e.g., making \nargument counts for blocks consistent). Given the extreme .exibility of Ruby, we think this result is \nvery en\u00adcouraging, and it suggests that static typing could very well succeed in practice.  Our results \nsuggest a number of future directions for PRuby. Dynamic type tests are clearly important to Ruby programmers \nbut are not modeled by DRuby. Occurrence Typing (Tobin-Hochstadt and Felleisen 2008), previously proposed \nfor Scheme, is one possible solution we plan to explore. One challenge we expect is that Ruby contains \na multitude of ways to test the dynamic type of a value, and we need to strike the right balance between \nsupporting com\u00admon uses and producing an easy-to-use system. Similarly, improved handling of the Class \ntype and a more precise anal\u00adysis for .ow-sensitive local variables would be bene.cial. Combined, these \nchanges could eliminate up to 76% of the annotations and 41% of the refactorings we introduced. Other \ncoding idioms may be dif.cult to support with DRuby s type inference algorithm, but could be handled \nwith improvements to our pro.ling technique. For example, currently PRuby performs pro.ling, transformation, \nand type inference in one run (Section 4). If we could combine pro.les from multiple runs, we could run \nadditional tests to improve code coverage. For example, instead of hoisting require to the top-level \nof a .le, a better solution may be to use additional test suites (such as those provided by a library \nmaintainer), or for libraries to ship a pro.le database that could be used by library clients. Along \nthe same lines, commenting out code to handling multiple con.gurations will not work in practice. A better \nsolution might be to annotate particular constants as con.g\u00aduration variables whose values are then pro.led \nby PRuby. DRuby could then use these pro.les to automatically prune irrelevant code sections. Our results \nso far show that PRuby can be applied to existing code bases that were not written with static typing \nin mind. Ultimately, we believe that PRuby will be most useful to programmers while they are developing \ntheir code, so that potential errors can be caught early in the development life cycle. In the future, \nwe plan not only to continue to improve PRuby technically, but also to directly study usability and utility \nof PRuby for software developers. 7. Threats to Validity There are several potential threats to the validity \nof our re\u00adsults. Figures 6(a) and (b) only include dynamic constructs that were observed by our benchmark \nruns. As we men\u00adtioned earlier, there are also other dynamic constructs that are present in the code \n(particularly the library modules) but were not called via our test suites. However, additional pro\u00ad.ling \nto try to exhibit these features would only bolster our claim that dynamic features are important to \nmodel. A more important consequence is that our categorization in Figure 7 may not generalize. It is \npossible that if we examined more constructs, we would .nd other categories or perhaps some features \nused in very dynamic ways. However, this would not affect our other results, and we believe we looked \nat enough occurrences (66 total) to gather useful information. In Ruby, it is possible for code to monkey-patch \nar\u00adbitrary classes, changing their behavior. Monkey patching could invalidate our categorization from \nSection 5.2, e.g., by exposing a dynamic feature whose uses were previously bounded within a class. However, \nthis would only affect our categorization and not PRuby, which can still easily pro.le and analyze the \nfull, monkey-patched execution. Similarly, Ruby s low-level object API could allow a pro\u00adgrammer to subvert \nour analysis, as discussed at the end of Section 6.2. Because we cannot verify these unsafe features, \nthey could potentially disable our run-time instrumentation, causing a Ruby script to fail. However, \nwe hope that pro\u00adgrammers who use unsafe features will treat them with ap\u00adpropriate caution. 8. Related \nWork There are several threads of related work. PRuby is an ex\u00adtension to DRuby (Furr et al. 2009c), \nwhich implements static type inference for Ruby. The key contribution of PRuby is our sound handling \nof highly dynamic language constructs. Our prior work on DRuby avoided these features by sticking to \nsmall examples, using programmer annota\u00adtions for library APIs, and eliminating dynamic constructs with \nmanual transformation. However, as we saw in Sec\u00adtion 5, highly dynamic features are pervasive throughout \nRuby, and so this approach is ultimately untenable. Kris\u00adtensen (2007) has also developed a type inference \nsystem for Ruby based on the cartesian product algorithm. This sys\u00adtem does not handle any of Ruby s \ndynamic features, making it unsound in the presence of these constructs. In addition to DRuby, researchers \nhave proposed a num\u00adber of other type systems for dynamic languages includ\u00ading Scheme (Cartwright and \nFagan 1991; Tobin-Hochstadt and Felleisen 2008), Smalltalk (Graver and Johnson 1990; Strongtalk; Wuyts \n2007), Javascript (Thiemann 2005; Hansen 2007; Anderson et al. 2005), and Python (Salib 2004; Ay\u00adcock \n2000; Cannon 2005), though these Python type systems are aimed at performance optimization rather than \nat the user level. To our knowledge, none of these systems handles send, eval, or similar dynamic features. \nOne exception is RPython (Ancona et al. 2007), a sys\u00adtem that inspired our work on PRuby. RPython translates \nPython programs to type safe back-ends such as the JVM. In RPython, programs may include an initial bootstrapping \nphase that uses arbitrary language features, including highly dynamic ones. RPython executes the bootstrapping \nphase us\u00ading the standard Python interpreter, and then produces a type safe output program based on the \ninterpreter state. The key differences between RPython and PRuby are that PRuby supports dynamic feature \nuse at arbitrary execution points; that we include a formalization and proof of correctness; that we \nprovide some information about pro.le coverage with test runs; and, perhaps foremost, that PRuby operates \non Ruby rather than Python.  Another approach to typing languages with dynamic fea\u00adtures is to use the \ntype Dynamic (Abadi et al. 1991). Exten\u00adsions of this idea include quasi-static typing (Thatte 1990), \ngradual type systems (Siek and Taha 2006, 2007; Herman et al. 2007), and hybrid types (Gronski et al. \n2006). However, we believe these approaches cannot handle cases where dy\u00adnamic code might have side effects \nthat interact with (what we would like to be) statically typed code. For example, re\u00adcall the code from \nFigure 1(d), which uses eval to de.ne methods. Since these de.nitions are available everywhere, they \ncan potentially in.uence any part of the program, and it is unclear how to allow some static and some \ndynamic typ\u00ading in this context. In contrast, PRuby explicitly supports constructs that would look dynamic \nto a standard type sys\u00adtem, but act essentially statically, because they have only a few dynamic behaviors \nthat can be seen with pro.ling; for code that is truly dynamic, PRuby reverts to full dynamic checking. \nSeveral researchers have proposed using purely static approaches to eliminating dynamic language constructs. \nLivshits et al. (2005) use a static points-to analysis to resolve re.ective method calls in Java by tracking \nstring values. Christensen et al. (2003) propose a general string analysis they use to resolve re.ection \nand check the syntax of SQL queries, among other applications. Gould et al. (2004) also propose a static \nstring analysis to check database queries, and several proposed systems use partial evaluation to re\u00adsolve \nre.ection and other dynamic constructs (Braux and Noy\u00b4 e 2000; Thiemann 1996). The main disadvantage \nof all of these approaches is that they rely purely on static anal\u00adysis. Indeed, Sawin and Rountev (2007) \nobserve that pure static analysis of strings is unable to resolve many dynamic class loading sites in \nJava. They propose solving this prob\u00adlem using a semi-static analysis, where partial information is gathered \ndynamically and then static analysis computes the rest. In PRuby, we opted to use a pure dynamic analysis \nto track highly dynamic features, to keep PRuby as simple and predictable as possible. Chugh et al. (2009) \npresent a hybrid approach to infor\u00admation .ow in Javascript that computes as much of the .ow graph as \npossible statically, and performs only resid\u00adual checks at run time when new code becomes available. \nIn Ruby, we found that the effects of dynamic features must be available during static analysis, to ensure \nthat all de.ned methods are known to the type checker. Our runtime instru\u00admentation for blame tracking \nis similar to a proposed sys\u00adtem for tracking NULL values in C (Bond et al. 2007). One difference is \nthat we must check for and allow type-correct methods at runtime, whereas NULL supports no operations. \nFinally, there is an extensive body of work on performing static analysis for optimization of Java. A \nmajor challenge is handling both dynamic class loading and re.ection. Jax (Tip et al. 1999) uses programmer \nspeci.cations to ensure safe modeling of re.ective calls. Sreedhar et al. (2000) de\u00adscribe a technique \nfor ahead-of-time optimization of parts of a Java program that are guaranteed unaffected by dynamic class \nloading. Pechtchanski and Sarkar (2001) present a Java optimization system that reanalyzes code on seeing \nany dy\u00adnamic events that would invalidate prior analysis. Hirzel et al. (2004) develop an online pointer \nanalysis that tracks re.ective method calls and can analyze classes as they are dynamically loaded. All \nof these systems are concerned with optimizing a program, whereas in contrast, PRuby extracts run-time \npro.ling information to guide compile-time (user\u00adlevel) type inference. 9. Conclusion We have presented \nPRuby, a pro.le-guided type inference system for Ruby. PRuby is built on top of DRuby, which performs \npurely static type inference on Ruby. PRuby works by .rst instrumenting source programs to gather pro.les \nthat record how dynamic constructs are used by the program. These pro.les then guide a transformation \nphase that re\u00adplaces dynamic constructs with static constructs specialized to the values seen at run \ntime. We have proven that our tech\u00adnique is sound for TinyRuby, a small Ruby-like calculus with dynamic \nfeatures. We evaluated PRuby on a suite of Ruby programs, and we found that use of dynamic features is \npervasive throughout our benchmarks, but that, neverthe\u00adless, most uses of these features are essentially \nstatic, and hence can be pro.led. We also discovered a number of type errors in our benchmarks and found \nthat, modulo these er\u00adrors, our benchmarks can be made mostly typable by apply\u00ading a number of refactorings. \nWe believe our results show that using pro.les to enhance static analysis is a promising technique for \nanalyzing programs written in highly dynamic scripting languages. Acknowledgments We wish to thank Michael \nHicks and the anonymous review\u00aders for their helpful comments on this paper. This research was supported \nin part by DARPA ODOD.HR00110810073. References M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. Dynamic \ntyping in a statically typed language. ACM TOPLAS, 13(2):237 268, 1991. Davide Ancona, Massimo Ancona, \nAntonio Cuni, and Nicholas Matsakis. RPython: Reconciling Dynamically and Statically Typed OO Languages. \nIn DLS, 2007.  Christopher Anderson, Paola Giannini, and Sophia Drossopoulou. Towards Type Inference \nfor JavaScript. In ECOOP, pages 428 452, 2005. John Aycock. Aggressive Type Inference. In Proceedings \nof the 8th International Python Conference, pages 11 20, 2000. M.D. Bond, N. Nethercote, S.W. Kent, S.Z. \nGuyer, and K.S. McKinley. Tracking bad apples: reporting the origin of null and unde.ned value errors. \nIn Proceedings of the 2007 OOPSLA conference, pages 405 422. ACM New York, NY, USA, 2007. M. Braux and \nJ. Noy\u00b4e. Towards partially evaluating re.ection in Java. In PEPM, pages 2 11, 2000.  Brett Cannon. \nLocalized Type Inference of Atomic Types in Python. Master s thesis, California Polytechnic State University, \nSan Luis Obispo, 2005. Robert Cartwright and Mike Fagan. Soft typing. In PLDI, pages 278 292, 1991. Aske \nSimon Christensen, Anders M\u00f8ller, and Michael I. Schwartzbach. Precise Analysis of String Expressions. \nIn SAS, pages 1 18, 2003. Ravi Chugh, Jeff Meister, Ranjit Jhala, and Sorin Lerner. Staged information \n.ow for javascript. In Proceedings of the 2009 ACM SIGPLAN Conference on Programming Language Design \nand Implementation, Dublin, Ireland, June 2009. To appear. David Flanagan and Yukihiro Matsumoto. The \nRuby Programming Language. O Reilly Media, Inc, 2008. Michael Furr, Jong-hoon (David) An, and Jeffrey \nS. Foster. Pro.le\u00adguided static typing for dynamic scripting languages. Technical Report CS-TR-4935, \nUniversity of Maryland, 2009a. http: //www.cs.umd.edu/projects/PL/druby. Michael Furr, Jong-hoon (David) \nAn, Jeffrey S. Foster, and Michael Hicks. The Ruby Intermediate Language. In Dynamic Language Symposium, \nOrlando, Florida, October 2009b. Michael Furr, Jong-hoon (David) An, Jeffrey S. Foster, and Michael Hicks. \nStatic Type Inference for Ruby. In OOPS Track, SAC, 2009c. Carl Gould, Zhendong Su, and Premkumar Devanbu. \nStatic Check\u00ading of Dynamically Generated Queries in Database Applica\u00adtions. In ICSE, pages 645 654, \n2004. Justin O. Graver and Ralph E. Johnson. A type system for Smalltalk. In PLDI, pages 136 150, 1990. \nJ. Gronski, K. Knowles, A. Tomb, S.N. Freund, and C. Flanagan. Sage: Hybrid Checking for Flexible Speci.cations. \nScheme and Functional Programming, 2006. Lars T Hansen. Evolutionary Programming and Gradual Typing in \nECMAScript 4 (Tutorial), November 2007. D. Herman, A. Tomb, and C. Flanagan. Space-ef.cient gradual typing. \nTrends in Functional Programming, 2007. M. Hirzel, A. Diwan, and M. Hind. Pointer Analysis in the Pres\u00adence \nof Dynamic Class Loading. In ECOOP, 2004. Kristian Kristensen. Ecstatic Type Inference for Ruby Using \nthe Cartesian Product Algorithm. Master s thesis, Aalborg Univer\u00adsity, 2007. Benjamin Livshits, John \nWhaley, and Monica S. Lam. Re.ection Analysis for Java. In ASPLS, 2005. I. Pechtchanski and V. Sarkar. \nDynamic optimistic interprocedural analysis: a framework and an application. In OOPSLA, pages 195 210, \n2001. Michael Salib. Starkiller: A Static Type Inferencer and Compiler for Python. Master s thesis, MIT, \n2004. Jason Sawin and Atanas Rountev. Improved static resolution of dynamic class loading in Java. In \nIEEE International Working Conference on Source Code Analysis and Manipulation, pages 143 154, 2007. \nJeremy Siek and Walid Taha. Gradual typing for objects. In ECOOP, pages 2 27, 2007. Jeremy G. Siek and \nWalid Taha. Gradual typing for functional languages. In Scheme and Functional Programming Workshop, September \n2006. V.C. Sreedhar, M. Burke, and J.D. Choi. A framework for interpro\u00adcedural optimization in the presence \nof dynamic class loading. In PLDI, pages 196 207, 2000. Strongtalk. Strongtalk, 2008. http://www.strongtalk.org/. \nSatish Thatte. Quasi-static typing. In POPL, pages 367 381, 1990. Peter Thiemann. Towards partial evaluation \nof full scheme. In Re.ection 96, pages 95 106, 1996. Peter Thiemann. Towards a type system for analyzing \njavascript programs. In ESOP, pages 408 422, 2005. Dave Thomas, Chad Fowler, and Andy Hunt. Programming \nRuby: The Pragmatic Programmers Guide. Pragmatic Bookshelf, 2nd edition, 2004. F. Tip, C. Laffra, P.F. \nSweeney, and D. Streeter. Practical experience with an application extractor for Java. In OOPSLA, pages \n292 305, 1999. Sam Tobin-Hochstadt and Matthias Felleisen. The Design and Implementation of Typed Scheme. \nIn POPL, pages 395 406, 2008. David A. Wheeler. Sloccount, 2008. http://www.dwheeler. com/sloccount/. \nRoel Wuyts. RoelTyper, May 2007. http://decomp.ulb.ac. be/roelwuyts/smalltalk/roeltyper/.    \n\t\t\t", "proc_id": "1640089", "abstract": "<p>Many popular scripting languages such as Ruby, Python, and Perl include highly dynamic language constructs, such as an eval method that evaluates a string as program text. While these constructs allow terse and expressive code, they have traditionally obstructed static analysis. In this paper we present PRuby, an extension to Diamondback Ruby (DRuby), a static type inference system for Ruby. PRuby augments DRuby with a novel dynamic analysis and transformation that allows us to precisely type uses of highly dynamic constructs. PRuby's analysis proceeds in three steps. First, we use run-time instrumentation to gather per-application profiles of dynamic feature usage. Next, we replace dynamic features with statically analyzable alternatives based on the profile. We also add instrumentation to safely handle cases when subsequent runs do not match the profile. Finally, we run DRuby's static type inference on the transformed code to enforce type safety.</p> <p>We used PRuby to gather profiles for a benchmark suite of sample Ruby programs. We found that dynamic features are pervasive throughout the benchmarks and the libraries they include, but that most uses of these features are highly constrained and hence can be effectively profiled. Using the profiles to guide type inference, we found that DRuby can generally statically type our benchmarks modulo some refactoring, and we discovered several previously unknown type errors. These results suggest that profiling and transformation is a lightweight but highly effective approach to bring static typing to highly dynamic languages.</p>", "authors": [{"name": "Michael Furr", "author_profile_id": "81408592409", "affiliation": "University of Maryland, College Park, MD, USA", "person_id": "P1728773", "email_address": "", "orcid_id": ""}, {"name": "Jong-hoon (David) An", "author_profile_id": "81438594841", "affiliation": "University of Maryland, College Park, MD, USA", "person_id": "P1728774", "email_address": "", "orcid_id": ""}, {"name": "Jeffrey S. Foster", "author_profile_id": "81338488852", "affiliation": "University of Maryland, College Park, MD, USA", "person_id": "P1728775", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640110", "year": "2009", "article_id": "1640110", "conference": "OOPSLA", "title": "Profile-guided static typing for dynamic scripting languages", "url": "http://dl.acm.org/citation.cfm?id=1640110"}