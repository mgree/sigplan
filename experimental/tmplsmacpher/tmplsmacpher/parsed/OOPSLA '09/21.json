{"article_publication_date": "10-25-2009", "fulltext": "\n Executing Code in the Past: Ef.cient In-Memory Object Graph Versioning Fr\u00b4ed\u00b4eric Pluquet Stefan Langerman \n* Roel Wuyts Universit\u00b4e Libre de Bruxelles (Belgium) IMEC, Leuven (Belgium) and Computer Science Department \nKatholieke Universiteit Leuven (Belgium) Faculty of Sciences roel.wuyts@imec.be {fpluquet,stefan.langerman}@ulb.ac.be \n Abstract Object versioning refers to how an application can have access to previous states of its objects. \nImplementing this mechanism is hard because it needs to be ef.cient in space and time, and well integrated \nwith the programming lan\u00adguage. This paper presents HistOOry, an object versioning system that uses an \nef.cient data structure to store and re\u00adtrieve past states. It needs only three primitives, and exist\u00ading \ncode does not need to be modi.ed to be versioned. It provides .ne-grained control over what parts of \nobjects are versioned and when. It stores all states, past and present, in memory. Code can be executed \nin the past of the system and will see the complete system at that point in time. We have implemented \nour model in Smalltalk and used it for three applications that need versioning: checked postconditions, \nstateful execution tracing and a planar point location imple\u00admentation. Benchmarks are provided to asses \nthe practical complexity of our implementation. Categories and Subject Descriptors D.3.3 [Language Constructs \nand Features]: Classes and Objects, Data types and structures; D.3.2 [Language Classi.cations]: Object-Oriented \nLanguages General Terms Algorithms, Design, Experimentation, Languages, Performance Keywords Object Versioning, \nObject-oriented Program\u00adming, Language Design * Ma itre de recherches du FRS-FNRS Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 2009, October 25 \n29, 2009, Orlando, Florida, USA. Copyright &#38;#169; 2009 ACM 978-1-60558-734-9/09/10. . . $10.00 1. \nIntroduction In the algorithmic research community, data structures are called persistent (in the rest \nof this paper we will use the term versioned1) if they support access to multiple lifetime ver\u00ad sions \nof that data structure [Driscoll et al. 1986]. Versioned data structures make it possible to go back \nin time and revisit the state of a data structure at some point in the past. There are several applications \nthat need such versioning support. For examples, debuggers and tracers bene.t from offering insight in \nprevious states of objects. Implementing ef.cient object versioning is hard because of the space and \ntime complexity needed to save past states of potentially all .elds of all objects. Furthermore the ver\u00adsioning \nmechanism should be properly integrated in the pro\u00adgramming language. Last but not least, full support \nfor ob\u00adject versioning ideally should support the same design prin\u00adciples than orthogonal persistence \nbecause this has proven to be useful when dealing with saved object states [Atkinson 1995]: 1. Any object, \nregardless of its type, can be versioned. 2. The lifetime of all objects is determined by their reacha\u00adbility. \n 3. Code cannot distinguish between versioned and non\u00adversioned data.  This paper presents HistOOry, \nan in-memory object ver\u00adsioning system that is general enough to add versioning to any existing program \nand that has the following features: It supports the design principles outlined above: any ob\u00adject can \nbe versioned, unreachable objects are garbage collected and there is no difference between versioned \nand non-versioned objects.  It has a .ne-grained model where certain .elds of an ob\u00adject can be versioned \nwhile other ones are not. Moreover  1 We avoid the word persistent because it has a different meaning \nin the object-oriented and database communities, where it is tied to long-lived data and the suspension \nand resuming of execution. the model allows to specify when the state is saved, be\u00adcause different applications \nhave different requirements. Objects can be versioned without the need for changing the implementations \nof their class.  It is ef.cient. Versioning has a constant cost that does not increase with the number \nof objects that have already been versioned. Querying a past version of the object graph can be done \nwith a cost that is logarithmic to the number of saved versions.  It only requires three primitives, \nmaking it easy to learn and use.  HistOOry saves the versions in memory because we make the past versions \nof objects directly available. The reason is simple: the goal of HistOOry is to re.ect on the past of \nobjects as quickly as possible and not to backup objects on some physical medium to restore them at some \nlater time. This leads us to a different solution than the classical database-or .le-oriented persistency \napproaches. HistOOry is implemented in Squeak/Pharo (a Smalltalk environment), using ef.cient structures \nto keep states (based on the fat node method of Trajan et al.[Driscoll et al. 1986]) and we have used \nit to build three applications using object versioning: we add support for checked postconditions to \nSmalltalk, implement an object execution tracer that keeps track of the states of receiver and arguments, \nand implement a planar point location program. Benchmarks for synthetic cases and for these applications \nshow that the measured execution time penalty is a factor of 7.3 for a synthetic worst case example, \nand a factor of 2.3 in the application benchmarks. This paper is the second in our research on adding \nef\u00ad.cient object versioning to an existing programming lan\u00adguage. A .rst workshop paper [Pluquet et al. \n2008] showed the basic feasibility of the idea and showed that our approach can be ef.cient using a .rst \nprototype. This paper revisits the algorithm (optimizing it even more), presents a much faster, robust \nand ef.cient implementation in Smalltalk and shows how to integrate and use object versioning. The rest \nof the paper is structured as follows. Sec. 2 gives examples of applications that use object versioning. \nSec. 3 and Sec. 4 introduce the terminology and the actual model and implementation of HistOOry. Sec. \n5 revisits the applications and shows how they can be implemented, while Sec. 6 gives benchmark results. \nSec. 7 discusses related work, while Sec. 8 describes some of the extensions we are working on. Sec. \n9 concludes the paper. 2. Examples of Applications that Use Object Versioning A large number of applications \ncurrently use object version\u00ading, either explicitly or implicitly. They typically use ad-hoc solutions \nthat rely on copying objects, which require a lot of effort to implement, are not very ef.cient, and \nare prone to errors. In this section, we present three types of applications using object versioning: \ncapturing stateful execution traces, supporting checked postconditions and solving the planar point location \nproblem. In Sec. 5, we revisit these examples and show how to build them with HistOOry. 2.1 Capturing \nStateful Execution Traces When reengineering legacy systems, one of the few trustable sources of information \nis the execution of the application it\u00adself [Demeyer et al. 2002]. Approaches exist to capture ex\u00ad ecution \ntraces of programs and query or visualize the traces to gain understanding of the system [Lange and Nakamura \n1997, Hamou-Lhadj and Lethbridge 2004]. What these approaches almost never capture (with the exception \nof [Ducasse et al. 2006]) is the state of the receiver or the arguments at the time the message was sent. \nWith state information available we could for example .nd all messages to a particular object that have \nside-effects on a particular variable. Such queries can be expressed quite easily using for example object \nquerying languages [Wuyts 2001, Willis et al. 2006, Hajiyev et al. 2006] once the state information is \navailable. 2.2 Checked Postconditions A postcondition is an assertion (a predicate the developer believes \nto be true) that describes the expected state at the end of some execution [Meyer 1992]. Several languages \nhave support for checked assertions, assertions that are checked and that raise exceptions when they \nare violated. In object-oriented programming, postconditions can typi\u00adcally be found at the end of a \nmethod. They take the form of expressions that use the .nal values of objects used in a method. For example, \na method that has as behaviour to count the number of elements of an array can have a post\u00adcondition \nexpressing that this number is always positive. Another example of a postcondition is one that expresses \nthat the size of a collection grows by one if an element is added. To check this assertion there is a \nneed to know the state before the method is being executed and afterwards, such that the sizes can be \ncompared. The fact that the initial state of an object needs to be compared with the state at the end \nof executing a method holds true for many other examples as well. 2.3 Planar Point Location Our previous \npaper [Pluquet et al. 2008] shows over 20 al\u00ad gorithms, whose implementation would be greatly simpli.ed \nby using our object versioning system. For instance, planar point location is a classical problem in \ncomputational geom\u00adetry: given a subdivision of the plane into polygonal regions (delimited by n segments), \nconstruct a data structure such that, given a query point, the region containing it can be re\u00adported. \nThere is a solution by Dobkin and Lipton [Dobkin and Lipton 1976] that answers queries in O(log n) time. \nIt sub\u00addivides the plane into vertical slabs determined by vertical lines positioned at each vertex. \nUnfortunately, the worst-case space requirement for this structure is T(n2). Another solution, by Sarnak \nand Tarjan [Sarnak and Tar\u00ad jan 1986] uses persistent (versioned) data structures to re\u00ad duce the space \nto O(n). A vertical line sweeps the plane from x = -8 to x =+8, maintaining the vertical order of the \nsegment at every point in a balanced binary search tree. The tree is modi.ed every time the line sweeps \nover a point, but all previous versions of the tree are kept, effectively con\u00adstructing Dobkin and Lipton \ns structure while using a space proportional to the number of structural changes in the tree. 3. Basic \nVersioning Terminology Before we introduce HistOOry, we de.ne a number of basic terms. We de.ne the state \nof a .eld as its value. At each modi.cation of a value, a new state is generated. The state of an object \nis the combination of the states of its .elds. We de.ne a history as an ordered collection of states. \nA .eld is either ephemeral, which means that it only retains its last state and has no memory about its \nprevious states, or versioned, which means that it can access previous states. We have de.ned the state \nof an object as being the com\u00adbination from the state of its .elds, and not as a .rst-class construct \nin itself. The state of an object at any given time is the value of its .elds at this time. This makes \nit possible to have objects that contain versioned and ephemeral .elds, a feature we will use later on \nin the paper. In the rest of the pa\u00adper, we speak about versioned .elds (and versioned objects, that \nhave all their .elds which are versioned). The versioning we are discussing in this paper allows one \nto save modi.cations of an object and to browse the modi.\u00adcations in a read-only mode: a new state can \nbe created only from a last state. This is comparable to back-up systems like Mac OS-X Time Machine: \nit is possible to view previous versions of .les that are included in the back-up, but they cannot be \nchanged. Two other modes of versioning are stud\u00adied in the algorithmic literature: full and con.uent \n[Driscoll et al. 1986], but we will not discuss them here. 4. The Model of HistOOry Before we delve into \nthe details of the model that underlies HistOOry, we give an overview of the goals that drove its design. \n1. Recording and browsing all the available states of any object in an object oriented system, including \narrays and other kinds of collections. This goal can be subdivided into two crosscutting concerns: (a) \nFine-grained selection of what to save. The level of granularity of what to save in HistOOry is the .eld \nof an object. This means that the smallest element that can become versioned is a single .eld of a single \nob\u00adject, even though most applications will choose to ver\u00adsion more elements (for example all objects \nand all of their .elds of some classes of interest). We have taken care of making it easy for the developer \nto choose what becomes versioned. As will be discussed later, we also de.ned a number of rules to make \ncohabita\u00adtion of ephemeral and versioned objects possible. (b) Fine-grained selection of when to save. \nEach modi.\u00adcation of a .eld of an object generates a new state of this object. HistOOry provides a simple \nmechanism to select which states must be kept. 2. Being ef.cient. We have based our solution on an ef\u00ad.cient \ndata structure that reduces the time and space needed to store and retrieve the object history informa\u00adtion \n(discussed in Sec. 4.2). It allows us to save the state in constant time (not dependent on the number \nof states previously saved) and retrieve the states of a .eld with a time complexity that is logarithmic \nto the number of stored states for this .eld. Besides the theoretical advan\u00adtages of the particular algorithm \nwe chose, we have also taken care to implement it in proper object-oriented style. For example, all states \nof an object are saved in the ob\u00adject itself. If an object is no longer used in the system, that object \nand all objects used to save its history will be garbage collected. As shown in Sec. 6, our implemen\u00ad \ntation results in a slowdown that never exceeds a factor of 7.3, regardless of whether we keep a single \nstate or a hundred thousand states. 3. Ease of use. We wanted to integrate object versioning in an object-oriented \nlanguage in such a way that it is easy to version certain parts of an implementation, as well as to use \nthe versioning information. In our approach, no modi.cations to existing code are necessary to version \nobjects. Moreover it is only necessary to learn 3 primi\u00adtives to use HistOOry.  4.1 Recording and Browsing \nObject States The .rst goal of our model is to be general enough to have the possibility to record any \nstate of any object in any object oriented system and then browse them. 4.1.1 Snapshots: When to Save \nFields The developer that uses HistOOry to make an application with versioned objects has full control \nof when states of objects are saved. This is analogous to using a camera. Whenever the user presses a \nbutton, a snapshot is taken, remembering what was visible at that time, while life goes on. This is in \ncontrast to a video camera, that saves a constant stream of images. While the latter can be interesting \nat times (and can be done in our approach as well), lots of applications that need object versioning \nare better served with explicitly taking snapshots than with capturing a huge stream of changes. We can \nillustrate this with a concrete example. Suppose that we have an implementation of a balanced tree. While \ndebugging the tree data structure itself, a developer is in\u00adterested in seeing all the states the tree \ngoes through while adding an element, including internal node rotations and low-level changes in the \ncollections that store the data in the tree nodes. However, while debugging an application that uses \nthe tree that developer might only be interested in see\u00ading consistent states of the tree (the state \nof the tree after element insertions and deletions), without the internal work\u00adings of the tree. For \nthe .rst application, it is necessary to keep all state changes of all objects making up the tree data \nstructure. In the second application, we only want to take snapshots after elements are inserted or deleted. \n 4.1.2 Selection and Deselection: What Fields to Save A developer has full control over what gets saved \nwhen a snapshot is taken. This is analogous to putting a .lter on the lens of the camera. While a camera \nwithout a .lter will always take snapshots of the complete scene, lens .lters will reduce the amount \nof information in a scene and only select items of interest. Filters can be changed at any time and change \nthe results of pictures taken after the new .lter is installed. By default HistOOry makes all .elds of \nall objects ephemeral. In our camera analogy this is comparable with putting the lens cap on: when you \ntake a snapshot you will not see anything. At any given point in time the developer can select what .elds \nbecome versioned. This is comparable to replacing the lens cap with a .lter. When a snapshots is taken, \nit will only save the states of versioned .elds. States of ephemeral .elds are not stored and can therefore \nnot be looked at later on. It is also possible to make a versioned .eld ephemeral again by deselecting \nit. Deselecting a .eld means that future snapshots will not save the state for that .eld. Old states \nare still available but no additional state will be saved: the value of the last state is overwritten \nat each update. A deselected .eld can be obviously re-selected. In contrast with systems where all objects \nare always ver\u00adsioned, our model gives the developer .ne-grained control. This has a number of advantages. \nFirstly, the object version\u00ading is clearly visible in the code because the developer ex\u00adplicitly indicates \nwhich objects are versioned. Secondly, the system does not lose time and space to save modi.cations of \nobjects that will never be used. Thirdly, this choice means that the developer still has the possibility \nof keeping every\u00adthing.  4.1.3 Browsing States Previous sections explained how states can be saved by \nus\u00ading selection and snapshots. We illustrate this with a concrete example. Suppose we are building a \nlibrary system to model the borrowing of books. It uses a class Book that has three .elds: title contains \na pointer to a string that represents the title of the book, state contains a pointer to a string describ\u00ading \nthe state of the book ( clean or dirty ) and borrower   Figure 2. Browsing the past from the time t4 \nthrough the three snapshots taken in Fig. 1 contains a pointer to a client. A client is described by \ntwo .elds: name (a string) and id (an integer). We select only the .elds state and borrower of Book to \nbe versioned. Other .elds remain ephemeral because it is unnecessary in this ap\u00adplication to keep the \nolder versions of the title of a book or the name of the user: only the present values of these .elds \nare available. Fig. 1 shows the evolution of a particular book instance, namely the novel 1984 that will \nbe borrowed by a client named John . The book and the client are introduced in the library system between \nthe time t0 and t1. At time t1 the book is badly titled ( 1985 ), its state is set to be clean and a \nclient with name Jon is set to be the current borrower. We take a snapshot s1 at this time t1. Sometime \nlater the client comes back to the library to return the book in a dirty state. He mentions also that \nhis name is John instead of Jon . A new snapshot s2 is taken at this time t2. Three days later the client \ncomes back to borrow the same book again. During the loan registration, the library employee corrects \nthe title of the book. A snapshot s3 is taken at this time t3. The top part of Fig. 1 shows objects states \nat each time\u00ad stamp. We have colored the versioned .elds in grey, while the ephemeral ones are white. \nThe second line shows saved values in each snapshot. Only the values of selected .elds are saved. Snapshots \nreify the state of the selected part of a system at the time the snapshot was taken. Code can then be \nexecuted in the context of the snapshot. That code sees the saved part of the system exactly like it \nwas when the snapshot was taken. The objects seen in each of the snapshots from the time t4 are shown \nin Fig. 2. When .elds are accessed, three things can happen: The .eld was selected before the creation \nof the snapshot. In that case the stored past state is returned. For example, asking the value of the \nborrower of the book in the second snapshot gives NULL.  The .eld was selected after the snapshot was \ncreated. This means that we try to access the past state of a .eld before it was saved for the .rst time. \nWe raise an exception.  The .eld was not selected (it is therefore an ephemeral .eld) and therefore \nno past state exists. We return the present value of the state (all white .elds in the .gure have their \npresent value). Sec. 4.3 shows other examples in which this choice it is very practical.  A modi.cation \nof a versioned .eld while executing code in the context of a snapshot results in an exception being thrown. \nA modi.cation of an ephemeral .eld changes that .eld, which is normal because the snapshot actually sees \nthe present object. Changing the name of the ephemeral user .eld either in the present or in the context \nof a snapshot would therefore change the present value.  4.2 Being Ef.cient Saving multiple states \nof object graphs and ef.ciently re\u00adtrieving them requires an advanced data structure. Luckily several \nalgorithmic results are known for this problem. Af\u00adter carefully reviewing the available algorithms, \nwe decided to implement the fat node method [Driscoll et al. 1986] that can transform any ephemeral data \nstructure into a partially versioned one. In the rest of the section we .rst outline the fat node method \nitself, we then describe the structure that stores the states and then discuss our implementation. 4.2.1 \nFat Node Method The data structure must remember the states of versioned .elds of objects. A .rst method \ncould be to simply save all objects in the system whenever a snapshot is taken. This con\u00adsumes a lot \nof space because there is no sharing of common state across snapshots, but makes it very easy to browse \nthe states at a certain point in time. Another approach could be to remember every single update to a \n.eld. This approach reuses states between different snapshots, but makes it very hard and costly to reconstruct \nthe complete past system in a  Figure 3. Internal structure in HistOOry for the example shown in Fig. \n1 at time t4. consistent way. Moreover, it must keep all past states to re\u00admain consistent, making it \ncostly when only few snapshots are taken. The fat node method in a sense combines the two previ\u00adous methods. \nLike the second method, it keeps all the past values of a versioned .eld within that .eld itself, but \nlike the .rst method it only remembers a single value per snap\u00adshot (and not all the intermediate values \nthat do not belong to snapshots). Last but not least, it makes it very easy to use the past in a consistent \nway. The key principle is that when a .eld is marked as ver\u00adsioned, it remembers its previous values. \nInstead of having only a reference to the present value of the .eld, a reference to the previously snapshotted \nvalues is kept, together with bookkeeping information that makes it easy to reconstruct the complete \nsystem at a particular point in time. Fig. 3 shows how this works for the example shown in Fig. 1 for \nthe time t4. Ephemeral .elds are not changed and therefore directly store references to objects. Versioned \n.elds on the other hand contain all of the snapshotted values associated with their time. The .gure seems \nto imply that the values are stored in a simple table, which is an abstract view. The actual data structure \nused to keep and access the snapshotted values is detailed in Sec. 4.2.2 where we show how the approach \nfunctions. Two kinds of bookkeeping information are kept. First of all there is a single global version \nnumber that is kept for the system as a whole. Second, each state (remembered value of a .eld) remembers \nwhen it was added by keeping a version number. This works as follows. When updating a versioned .eld \nwith a new value v, the version number of the previous state of this .eld is considered: if it is equal \nto the global version number, the value saved by the state is replaced by v. If not, a new state with \nthe value v and a version number equal to the global version number is created. The global version number \nis incremented only when the system needs to save a new global state. Taking a snapshot therefore boils \ndown to just incrementing the global version number, which is very cheap. 4.2.2 States Structure The \ndata structure that actually stores the states of the .elds is composed of chained arrays (see Fig. 4), \nnot a simple table. Chained arrays offer good performance: new states  Figure 4. Structure to save versions \nof a .eld. can be added in O(1) time, the last version can be accessed in O(1) and the search of a state \nfor a given version number is bounded by lg m +2 in the worst case where m is the number of states in \nthe arrays. Moreover the space used is O(m). We observed that consecutive retrievals of the same ver\u00adsion \nof an object always have to traverse the chained data structure. Therefore, we decided to add a cache. \nThe cache holds a single key-value pair consisting of the last version of the .eld retrieved and the \ncorresponding state. Consecutive retrievals of the same version therefore no longer traverse the chained \narrays but immediately return the object. This simple cache results in good practical performance because \nit is lightweight (only a single value is kept and only a sin\u00adgle version number is compared) and corresponds \nto most practical usage scenarios.  4.2.3 Implementation To explain how our implementation works, we \n.rst show a small part of the implementation of class Book from the library system introduced in Sec. \n4.1.3, namely the setter and getter methods for the borrower .eld (in Smalltalk): Book>>borrower getter \nmethod that returns the borrower of a book borrower Book>>borrower: aClient setter method that sets the \nborrower of a book borrower := aClient When the class Book has none of its .elds selected for versioning, \nit is left untouched. But when we select the .eld borrower, HistOOry transparently modi.es code that \nac\u00adcesses .elds. Accessing a .eld will defer to the active pro\u00adcess instead of directly asking the object. \nSetting a .eld will send a HistOOry speci.c message to the object contained in the .eld. The resulting \ncode does the following (we show later on that this is actually done with bytecode rewriting, not source \nrewriting, but it is easier to show the corresponding source code): Book>>borrower getter method that \nreturns the borrower of a book Processor activeProcess valueOf: #borrower Figure 5. Processes class \ndiagram Book>>borrower: aClient setter method that sets the borrower of a book borrower replacedBy: \naClient atOffset: 3 of: self From the getter method it is clear that class Process2 plays an active \nrole to control the accessing and retrieving of versioned information. By transferring control to instances \nof process we can execute code in the past in one process while executing code in other processes in \nthe present. Fig. 5 describes the class Process and the two methods we extended it with: valueOf: returns \nthe last value of the given object;  newValue:forHStates: asks to the given instance of HStates to update \nthe last state or add a new state with a given value (as described at end of Sec. 4.2.1).  By default, \nthese methods result in the same behaviour as standard Smalltalk, but via an indirection. This is the \noverhead that is present as soon as .elds are selected (see Fig. 7(b)), wether the versioned information \nis used or not. We can now implement other Process classes, as shown in Fig. 5, with speci.c behaviour. \nThe class PastProcess is the process class that is used when executing code in a par\u00adticular past state. \nIt overrides the method valueOf: to fetch the value from the HSnapshot object that will be detailed next. \nAnother example is FullRecordProcess, a process that automatically snapshots just before any modi.cation \nof 2 The class Process is an already de.ned class in Smalltalk, representing the different processes \nexecuted in a Smalltalk image.  Figure 6. Object and states class diagram a .eld (meaning that absolutely \nevery change is captured even when the user does not snapshot explicitly). The indirection through the \nProcess classes allow us to change the semantics of reading and writing of .elds. This is actually done \nin close interaction with the class HStates. A versioned .eld contains an instance of the class HStates. \nThis class contains four important methods: myLastValue returns the last value contained in the chained \narrays data structure that keeps all snapshotted values and was discussed in Sec. 4.2.2;  replacedBy:atOffset:of: \nis called when this in\u00adstance of HStates will be replaced by a new value at a given offset3 of a given \nobject. Depending on the current process, it adds a new couple (version number, value) in the chained \narrays or it updates the last value;  replacedBy:atIndex:of: is the same as the previous one but for \na given index of a given object;  valueBeforeOrAtVersionNumber: returns the value contained in the chained \narrays associated with the high\u00adest version number before or equal to the given version number.  Now \nthat we have introduced the Process and HStates classes and show how they collaborate to read current \nor past .elds by going through the appropriate process class, it is time to look at the writing of .elds. \nWhen selecting .elds 3 The offset of a .eld is the order place of this .eld in the object. For instance, \nthe borrower of a Book instance being the third .eld, its offset is 3. the setter method will not directly \nset the value of a .eld, but instead it sends the message replacedBy:atOffset:of: to the object in the \n.eld. When this .eld is selected, then the object will actually be an instance of HStates and the value \nis saved. When the .eld is not selected, the .eld contains the actual object itself that needs to be \nreplaced. To be transparent, we extend the Smalltalk root class Object with the same interface than the \none used by HStates, as shown in Fig. 6. These implementations do the following: myLastValue returns \nitself;  replacedBy:atOffset:of: puts itself at the given off\u00adset of the given object;  replacedBy:atIndex:of: \nputs itself at the given index of the given object;  valueBeforeOrAtVersionNumber: returns itself. \n As mentioned before we refrained from doing these mod\u00adi.cations to the source code because it would \nbe slower and the developer would then be exposed to the internal work\u00adings of our system when seeing \nthe rewritten code. We also did not want to modify the virtual machine because that would be signi.cantly \nmore dif.cult and a user would need to use our modi.ed virtual machine. Therefore we chose to directly \nmanipulate bytecodes to implement our algorithm. We decided to use Smalltalk because we could use the \nex\u00adcellent ByteSurgeon tool [Denker et al. 2005] and had better re.ection support. We could have implemented \nour approach in statically typed languages like Java or C# as well. We believe that the results would \nbe comparable to the Smalltalk implementa\u00adtion, but more dif.cult to achieve.  4.3 Language Integration \nThe previous sections explain the concepts of our model and how we made it ef.cient to store the data. \nThis section shows how this data can be used effectively by integrating it in an object-oriented language. \nAs discussed before, the developer can select what .elds become versioned, take snapshots, and browse \nthe saved state. For these three basic operations, we give the developer three primitives: 1. selectFields \nselects all .elds of the receiver to be in the next snapshot (essentially versioning the complete object); \n 2. HSnapshot atNow takes a new snapshot and returns it; 3. execute: aBlock, sent to a snapshot, permits \nto exe\u00adcute the speci.ed code block at the time when the snap\u00adshot was taken.  These primitives are \nactually an embedded domain spe\u00adci.c language. Implementation-wise we just had to add a method selectFields \nto the Object root class of Smalltalk and create a Snapshot class to turn snapshots into .rst-class objects. \n The following subsections give a number of examples to show HistOOry in action. 4.3.1 Example of Basic \nUsage This example shows how we can track the changes to a par\u00adticular object, namely a Squeak/Pharo \npackage. The example code .rst .nds the package object named Kernel, makes it a versioned object, changes \nits name to Test, takes a snapshot, and renames it once more to NewKernel. We then print the current \nname of the package on the transcript, which shows NewKernel, as expected. Then, we do the same, but \nexecute it in the context of the saved snapshot. This time the tran\u00adscript prints Test, again as expected. \n|package s| package := PackageInfo named: 'Kernel'. Gets the package named 'Kernel' package selectFields. \nSelects this object package packageName: 'Test'. Renames the package s := HSnapshot atNow. Takes a snapshot \npackage packageName: 'NewKernel'. Renames the package again Transcript show: package packageName. Prints \n'NewKernel' s execute: [Transcript show: package packageName]. Prints 'Test' There are several interesting \nthings in this example. The class PackageInfo is one of the system classes core to the Squeak/Pharo \nSmalltalk language, and not one of our own classes. Yet, it is versioned simply by sending it the selectFields \nmessage. This code illustrates that the original implementation of an object (or its class) does not \nneed to be changed. Behind the scenes, our bytecode rewriting tool takes care of instrumenting the code \nto keep track of all changes to the .elds of this object and puts in place our data structures.  When \nan ephemeral object is versioned, it is exactly the same object and can be continued to be used exactly \nlike any other object. The reason is that we do not change the object itself but update its class, which \nensures that there is no difference except for the fact that its state is saved when snapshots are taken. \n The developer is responsible for taking snapshots. By default, the system will not save anything. It \nis the role of the developer to determine which states are important.  Code can be executed in the \ncontext of a snapshot by using the execute: message and passing the code to be executed in a block. \n Ephemeral objects and versioned objects can live to\u00adgether. In our example, the object Transcript is \nephemeral while the package object is versioned. This is possible because versioned .elds return the \nsaved value at the time of the snapshot while ephemeral .elds return their present value.   4.3.2 Selection \nProtocol Up until this point we have primarily talked about how to make individual .elds versioned, and \njust mentioned that when an object is versioned, its .elds are versioned. In practice however it is important \nto give the developer good control over what .elds of what objects are versioned, and this cannot be \ndone with a single message like the selectFields used above. In fact there is a more re.ned protocol \nto let de\u00advelopers decide what is versioned, consisting of three methods: selectFields, selectFields: \nand defaultFieldsToSelect. The selectFields message by default versions all .elds in the object. However, \na developer can con\u00adtrol this default behavior by overriding the method defaultFieldsToSelect and indicating \nwhat .elds are selected when the message selectFields is sent. This method overriding is a practical \nway for establish\u00ading the default choices for what gets saved. Method defaultFieldsToSelect is implemented \nin Object, the root class, and returns all .elds of the receiver object. The .elds are collected by using \nre.ection and it is therefore not needed to override this method on each class that just wants to indicate \nthat it too has .elds to include. If a developer wants to deviate from the default, the mes\u00adsage selectFields: \ncan also be used. It takes as argument the .elds that need to be versioned, regardless of what is speci.ed \nin method defaultFieldsToSelect. In our Smalltalk implementation, we added methods to existing classes \n(for example the three selection protocol methods to the root class Object). The object versioning is \nnicely integrated in the language, resulting in a small embedded domain-speci.c language. Moreover we \nimple\u00admented our language extension using class extensions4 (also called open classes [Millstein and \nChambers 1999]). Other languages could use their particular language features to integrate a versioning \nmodel, for example through library calls, method annotations, AOP-style inter-type declara\u00adtions [Kiczales \net al. 2001], macros, etc. 4A class extension is a method that is de.ned in a module, but whose class \nis de.ned in another module.  4.3.3 Propagation The previous section talked about selecting individual \n.elds. Of course what happens a lot is that a .eld itself contains an object that you also want to be \nversioned. Take for example the class Set. This class has two .elds: array (the basic collection that \nstores the actual elements in the set) and tally (a number that indicates the position of the last element \nin the array). When the array is full, a new larger array replaces it (in which the old values are copied). \nTo make a Set instance, as a whole, versioned, we can send it the message selectFields. The result is \nthat both .elds are versioned and, therefore, changes to these .elds will be saved when taking snapshots. \nHowever, because the array .eld is itself an object and that object was not versioned, we will not actually \nbe able to revert to the previous contents of the set instance but merely remember changes to the pointer \nitself. To solve this problem, we can make the array variable itself versioned, for example by doing \nthe following: |s| s := Set new. s add: 1; add: 2. s selectFields. (s instVarNamed: #array) selectFields. \n1 to: 100 do: [:each | s add: each. (s instVarNamed: #array) selectFields]. We need to send the message \nselectedFields after each insertion. This ensures that if the array has grown, the new ephemeral array \nthat resulted from the growth is immediately versioned. Because this code is tedious too write and frequently \nneeded we support it directly through either a message or a class extension. The message propagateFields: \ncan be used to make the selection propagate, meaning that the previous code snippet can be rewritten \nas follows: |s| s := Set new. s add: 1; add: 2. s selectFields. s propagateFields: {#array}. 1 to: 100 \ndo: [:each | s add: each]. As an alternative the method defaultFieldsToPropagate can be implemented \non a class to indicate what .elds should be propagated when the object is versioned. In our example, \nwe could add it to the class Set as follows: Set>>defaultFieldsToPropagate NHArray with: #array When \nan instance of the Set class is versioned, all values of the .eld array will also be selected for versioning. \nThe class NHArray is a non HistOOrizable implemen\u00adtation of the class Array that we de.ned in the HistOOry \npackage. No state of its instances will be saved. This class therefore avoids unnecessary indirections \nto the Process classes hierarchy. With the method defaultFieldsToPropagate added to class Set, our code \nsnippet can be written as follows: |s| s := Set new. s add: 1; add: 2. s selectFields. 1 to: 100 do: \n[:each | s add: each].  We stress that this solution is again transparent for the original code: the \noriginal code is not changed, but it is extended with one method residing in another package. 4.3.4 \nHPastObject Suppose that we have made an application versioned and have taken a number of snapshots. \nThen, we want to send messages to an old version of some object. In the very .rst example, we have seen \nthat this can be done by sending the message execute: to the snapshot, passing the code to execute in \nthat snapshot as an argument. The following code example illustrates this. ... ((s execute: [aSet size]) \n< aSet size) &#38;&#38; (s execute: [aSet includes: 0]) ...  To make it easier to repeatedly send messages \nto a previ\u00adous state of a single object, we have provided a proxy-based mechanism that redirects messages \nsent to it to the old state of the object. The next code snippet shows this mechanism in action. ... \noldSet := HPastObject on: aSet during: aSnapshot. oldSet size < aSet size &#38;&#38; oldSet includes: \n0 ... The implementation of the class HPastObject is pretty straightforward. It captures all messages \nsent to it by over\u00adriding the method doesNotUnderstand: [Ducasse 1999]. In that method it sends the message \nto the object to the snap\u00adshot provided when an instance of the class was created. 5. Implementing Versioned \nApplications Using HistOOry Sec. 2 listed a number of applications that, explicitly or implicitly, use \nobject versioning. This section shows how they can be implemented using HistOOry. 5.1 Capturing Stateful \nExecution Traces In this example, we show how we can very easily build an execution tracer that is stateful: \nit saves the messages that are sent, including the state of the receiver before and after sending the \nmessage. Therefore, trace analyzers can not only .nd patterns on the order and nesting of the messages \nsent, but they can also take the state of the receiver into account (for example to .nd all messages \nthat have side effects). In Smalltalk, execution traces can be captured fairly eas\u00adily by using method \nwrappers [Brant et al. 1998] to instru\u00ad ment code. The instrumented method will be replaced by a method \nwrapper where we can add hooks to trace the ac\u00adtivation of methods. The following example shows the key \npart of the implementation of this technique. The wrapped method .rst calls traceEntryIn:on:, then it \ncalls the orig\u00adinal method, and .nally it calls traceExitOf:on:5. MyWrapper>>run: aSelector with: arguments \nin: aReceiver |answer| self traceEntryIn: aSelector on: aReceiver. before call answer := aReceiver withArgs:arguments \nexecuteMethod: originalMethod. self traceExitOf: aSelector on: aReceiver. after call answer The previous \nimplementation only captures the messages being sent. It is easy to extend it to save the state of the \nreceiver before and after sending the message, turning it into a stateful sequence tracer: we make the \nreceiver versioned by sending it the message selectFields. MyWrapper>>run: aSelector with: arguments \nin: aReceiver |answer| aReceiver selectFields. self traceEntryIn: aSelector on: aReceiver at: HSnapshot \natNow. answer := aReceiver withArgs:arguments executeMethod: originalMethod. self traceExitOf: aSelector \non: aReceiver at: HSnapshot atNow. answer Note that repeatedly sending the message selectFields is harmless. \nFor each method call, both states of the receiver are saved by the snapshots. These snapshots will then \nbe used to retrieve the state of the receiver at a given time. This section showed how, with a minimum \nof effort, an execution trace was extended with support for saving the states of the objects.  5.2 Checked \nPostconditions Checking postconditions frequently requires one to compare the states of the receiver \nbefore the method is being executed with the .nal state at the end of the method execution. We show how \nwe have extended Smalltalk with support for checked postconditions by using HistOOry. The developers \nneeded a mechanism to make it possi\u00adble to specify the postconditions they would like to have checked. \nWe opted to do this by extending the Smalltalk class BlockContext, the class implementing delayed code \nevaluation, because it is available in all Smalltalk implemen\u00adtations. An alternative could have been \nto add the postcon\u00addition using method annotations, but these only exist in a number of Smalltalk implementations, \nwith different inter\u00adnal implementations. 5 traceEntryIn:on: and traceExitOf:on: are auxiliary methods \nthat store information about the messages that were sent, such as the timestamp. An example of using \nthe postconditions in Smalltalk is given below. It adds a postcondition for the method swap:with: of \nclass SequenceableCollection (one of the abstract classes in the Collection hierarchy). The post\u00adcondition \nveri.es that the elements were indeed swapped by comparing the identities of the objects: SequenceableCollection>>swap: \noneIndex with: anotherIndex Move the element at oneIndex to anotherIndex, and vice-\u00adversa. [ | element \n| element := self at: oneIndex. self at: oneIndex put: (self at: anotherIndex). self at: anotherIndex \nput: element ] postCond: [:old | (old at: oneIndex) == (self at: anotherIndex) and: [ (old at: anotherIndex) \n== (self at: oneIndex)]]  The original code of the method is put into a Smalltalk block (the square \nbrackets). In the rest of the explanation, we will call this block the method block. The postcondition \nis speci.ed as another block that is given as argument to the postCond: message sent to the .rst block. \nWe will call this the postcondition block. The postcondition block takes one argument (old) that represents \nthe state of the system before the execution of the method body. In the postcondition block, messages \nare sent to old to retrieve values from before the execution of the method block and to self to retrieve \nthe current values. We implement the method postCond: aBlock as an extension of the BlockContext class. \nThe block that receives the message is the method block. The argument block is the postcondition block. \nIt makes the receiver versioned, takes a snapshot, creates a HPastObject object to make it easy to refer \nto the past states, and then executes the method block and the postcondition block. BlockContext>>postCond: \naBlock | old snapshot value | self receiver selectFields. makes the receiver versioned snapshot := HSnapshot \natNow. snapshot before executing the method block create a HPastObject old := HPastObject on: self receiver \nduring: snapshot. execute the method block value := self value. execute postcondition block self assert: \n(aBlock value: old). return the result of the method block value  This implementation is fairly straightforward. \nThe only tweak is the creation of a HPastObject object for the re\u00adceiver in the old state and passing \nit to the postcondition block. The result is that the code in the postcondition can directly send messages \nto the old receiver, as explained in Sec. 4.3.4. Sometimes postconditions need access to other objects, \nfor example to arguments of the method. We therefore added a second method, postCond: aBlock withObjects: \naSetOfObjects, where the objects for which we need to access past states are passed explicitly. The difference \nwith the previous postcondition is that the argument passed can\u00adnot be a HPastObject, because that only \nmakes it easy to send messages to a single object in the past. Instead the ar\u00adgument is a regular snapshot. \nBlockContext>>postCond: aBlock withObjects: aSetOfObjects | snapshot value | make arguments versioned \naSetOfObjects do: [ :each | each selectFields]. snapshot := HSnapshot atNow. value := self value. self \nassert: (aBlock value: snapshot). value We can use this more elaborated postcondition mecha\u00adnism to check \nthat after adding a collection to another col\u00adlection the size of the argument is unchanged while the \nsize of the new collection is the sum of the initial collection sizes. OrderedCollection>>addAll: aCollection \n[ self addAllLast: aCollection ] postCond: [:snapshot | the size of aCollection must not change (snapshot \nexecute: [aCollection size] = aCollection size) and: [ self size = oldSelf size + aCollection size ((snapshot \nexecute: [self size]) + aCollection size) = self size. ] ] withObjects: {self. aCollection}. aCollection \nWe showed in this section how we can add checked post\u00adconditions to Smalltalk by extending the BlockContext \nclass with two methods.  5.3 Planar Point Location To illustrate how HistOOry can simplify the implementa\u00adtion \nof complex data structures, we implemented a random treap [Seidel and Aragon 1996], a randomized binary \nsearch tree. This structure is a mix of a tree and a heap where each node has a key and a random priority. \nAt each insertion, node rotations ensure that constraints on the keys and the priori\u00adties hold. We implement \nthis structure using several classes: a class RandomTreap that inherits from a class Treap and has as \nits root an instance of a class TreapNode. The in\u00adstances of TreapNode have the attributes key, priority, \nleft and right. The two last attributes contain either the default value nil or an instance of TreapNode. \n To turn this structure into a versioned random treap, we simply extend the classes Treap and TreapNode \nwith the following methods: Treap>>defaultFieldsToPropagate NHArray with: #root TreapNode>>defaultFieldsToPropagate \nNHArray with: #left with: #right The following code is placed in a class PlanarPointLocation, that implements \na solution to the planar point location problem. It stores a set of points. In the construction of the \npoint location data structure, each point of the set is swept by the sweepline, its outgoing segments \nare added to the treap, the incoming ones are removed and a snapshot is taken and associated with this \npoint. PlanarPointLocation>>constructRTreap | linkedInfo | rtreap := RandomTreap new. rtreap selectFields. \nself allPointsDo: [ :aPoint | aPoint incomingSegmentsDo: [ :segment | rtreap deleteKey: segment ]. aPoint \noutcomingSegmentsDo: [ :segment | rtreap putKey: segment ]. aPoint associatedSnapshot: (HSnapshot atNow) \n] When a location query of a point p is considered, the slab containing p is determined, searching the \nrightmost point to the left of p in the points of the plane. This point l is the left point of the slab. \nThen the snapshot associated with l is used to browse the treap at the time where only the relevant segments \nwere present. The treap is then used normally, inside the block executed through the snapshot, to locate \nthe point. PlanarPointLocation>>searchPoint: aPPLPoint | thePoint linkedInfo | thePoint := self lastPointBefore: \naPPLPoint. thePoint snapshot execute: [rtreap keyEqualOrJustBefore: aPPLPoint] This section again showed \nhow a data structure can be made persistent without much dif.culty and without chang\u00ading the existing \nimplementation. The next section will look at the ef.ciency of the approach. 6. Measurements This section \npresents performance benchmarks for HistOOry. It .rst gives general measurements about the time and space \nneeded for a number of synthetic examples. Then, it shows measurements for the stateful tracer and the \nchecked postconditions discussed in Sec. 5. All tests were performed on an iMac 2.4 GHz Intel Core 2 \nDuo with 2 gigabytes of RAM and using an empty image of Squeak/Pharo for developers (version 0.1-101166dev08.11.6). \n 6.1 General Measurements We start with some general measurements: the space re\u00adquired and the time required \nto save and retrieve states. 6.1.1 Space Required To show the size required by HistOOry, we create an \nobject with a single .eld (with integer 0 as initial value) and we make this .eld versioned. We then \nincrement the .eld and take a snapshot, and repeat this. Fig. 7(a) shows the size taken by the data structure \nin the .eld after each update. The size grows in steps: every jump corresponds to the creation of a new \narray in the chain of arrays that store the actual states when the last array is full.  6.1.2 Execution \nTimes for Saving States We want to show the overhead in execution time when HistOOry is saving states. \nTherefore, we measure the aver\u00adage time required to update a .eld with an integer value. Fig. 7(b) shows \nfour different benchmark results for this case, de\u00ad pending on how HistOOry is being used: 1. The code \nis executed in a pure Squeak/Pharo image, without HistOOry. 2. The code is executed in a Squeak/Pharo \nimage where the methods are instrumented by HistOOry, but nothing is selected and no snapshots are taken. \n 3. The .eld is selected, but no snapshots are taken. 4. The .eld is selected and snapshots are taken \nafter each update.  When observing the plot, we .rst of all note that the execution time plots are nearly \n.at. This indicates that, as expected, the execution cost when using HistOOry does not depend on the \nnumber of states that are saved (the cost is always a constant overhead). The overhead cost in the .rst \ncase, where HistOOry is not used at all, is zero. This is normal because in that case no instrumentation \nis done and the code runs without any modi.cation. This is an important point, because it shows that \nyou only pay for the features of HistOOry when you need it. Instrumenting a class (the second case) adds \nan overhead of about a factor of 2 that must be paid by all instances created from this class, whether \ntheir .elds are selected or not. As explained in Sec. 4.2.3, the reason for this cost is that all methods \nof this class are instrumented to redirect reads and writes of instance variables to the Process hierarchy. \nSelecting a .eld (the third case) shows that the overhead grows to a factor of about 5.6 and 6.7 when \n.elds are se\u00adlected but no snapshots are taken. An overhead between 6.7 and 7.3 is visible when a .eld \nis selected and snapshots are taken. Having an application run 7.3 times slower might seem like a big \nprice to pay. However this example is a synthetic example where literally each operation results in an \nassign\u00adment that needs to be stored. In practice this is often not the case: not every single operation \nis an assignment (sending a message, for example). Fig. 8, for example, shows the aver\u00ad age execution \ntimes per insertion in a random treap, again for a number of use cases: 1. Treap not instrumented. 2. \nTreap instrumented but none of its .elds selected. 3. All .elds of the treap selected, and no snapshots \nare taken. 4. All .elds selected, and snapshots taken after each inser\u00adtion. 5. All .elds selected \nand snapshots taken after every change (including for example the internal rebalancing happen\u00ading in \nthe treap)  The overall curves remain similar: they still show that for this more complex data structure \nthe cost is constant and does not depend on the number of states being saved. More\u00adover we can see that \nthe biggest execution time overhead is now only about 2.3, which is much better than the 7.3 times in \nthe synthetic example. 6.1.3 Execution Times for Retrieving States We show the cost to retrieve a saved \nstate, depending on the number of states that were saved. Therefore, we select a .eld and update it a \n.xed number of times n, each time followed by taking a snapshot. Then, we take the total time to inspect \nall states saved by the snapshots and divide this time by the number n. This gives us the average execution \ntime to access a single state. Fig. 9 shows the result, on a logarithmic scale. The curve is logarithmic \nas expected (it is the theoretical complexity of the algorithm), indicating that our implementation is \ncorrect. Note that the peaks are again the result of an allocation of a new array in the chained arrays \nthat keep the past states. To show the importance of the introduction of the cache described in Sec. \n4.2.2 we performed an experiment with a random treap in which we insert 1000 values and we take a snapshot \nwe call s. We insert a given number of new values and after each insertion we take a snapshot. Finally \nwe take the time to retrieve the 1000 initial values through the snapshot s. We did this experiment with \nand without the cache. Fig. 10 shows the time as Y-coordinate and the number of snapshots taken after \ns as X-coordinate). The cache reduces the lookup time by a factor of 2 in this example.    Figure \n9. Execution time for retrieving saved states (logarithmic scale).  Figure 10. Time with and without \ncache to retrieve 1000 values in a versioned random treap from a snapshot s depending on the number of \nsnapshots taken after s.  6.2 Capturing Stateful Execution Traces This benchmark shows the performance \nof our stateful ex\u00adecution tracer. We let the tracer record the execution trace for inserting a number \nof elements in a random treap data structure (recording the entry and exit of all methods of the three \ntreap classes) and measure the execution time needed to produce that trace. Dividing this number by the \nnumber of elements that were added gives us the average time per insertion. We do the experiment without \nany tracing, for a stateless tracer that does not keep any state, and for a state\u00adful tracer that uses \nHistOOry as described in Sec. 5.1. Fig. 11 shows the results. Transforming a stateless tracer into a \nstateful tracer only adds a slowdown of a factor of 1.3. Not only was it very easy to upgrade the stateless \ntracer, the performance is also feasible for the added functionality. 6.3 Postconditions In Sec. 5 we \nshowed how we added checked postconditions to Smalltalk, and gave examples on two methods. This sec\u00adtion \nshows how much this addition costs for each of these methods. 6.3.1 swap:with: The method swap:with:, \nde.ned on class SequenceableCollection, swaps the place of the elements on the indices given as argument. \nFor our exper\u00adiment, we create collections of different sizes (ranging in size from 1 to 800 elements). \nWe add either simple integers or array objects of 100 elements pointing to nil). We then perform 10,000 \nswaps at random indices and take the total time. Dividing this total time by 10,000 gives us the average \nexecution time per swap.  We perform the experiment with three implementations of the swap:with: method: \nthe original Smalltalk method, the method with a checked postcondition based on HistOOry and shown in \nSec. 5.2, and the method where we add a checked postcondition based on doing a copy of the receiver before \nexecuting the swap, as follows: SequenceableCollection>>swap: oneIndex with: anotherIndex Move the element \nat oneIndex to anotherIndex, and vice-\u00ad versa. | element old| old := self copy. copying the receiver \nbefore doing the swap element := self at: oneIndex. self at: oneIndex put: (self at: anotherIndex). self \nat: anotherIndex put: element. self assert: ((old at: oneIndex) = (self at: anotherIndex) and: [ (old \nat: anotherIndex) = (self at: oneIndex)]) Fig. 12 shows the results. It shows that an implementation \nthat uses copies has an execution time that grows linearly with the size of the collection (and quickly, \ndepending on the size of the data structure). The implementations based on HistOOry have a constant cost \nthat does depend neither on the number of elements in the collection nor on the kind of the elements \n(integers or arrays). HistOOry does not take full copies of the receiver. When the .rst swap is performed, \nthe .elds are selected and a snapshot is taken. For all the following snapshots, the collection is already \ninstrumented and everything is in place. Only a snapshot must be taken, which boils down to incrementing \nthe global version number, before executing the normal body of the method. The copying approach is faster \nthan the HistOOry based approach for smaller collection sizes. The reason is simple: the performance \nof a copy depends on the number of ele\u00adments in the collection. It is obvious that the performance is \nbetter for small collections. HistOOry offers a low constant cost for any number (and any kind) of elements \nin the col\u00adlection but this constant cost is higher than the simple copy operation for small collections. \n  6.3.2 addAll: The method addAll:, de.ned on class OrderedCollection, adds all elements in the argu\u00adment \ncollection to the receiver collection. We compare two different scenarios. In the .rst scenario, we add \na collection of a given number of elements to an empty receiver collec\u00adtion (and divide by the size of \nthe argument collection to get an average per single insertion). In the second scenario, we add collections \ncontaining a single element, again starting from an empty collection. We compare the original implementation \nwith an imple\u00admentation that has postconditions based on HistOOry as shown in Sec. 5.2 and with an implementation \nthat copies the receiver state before executing the body of the method, as follows: OrderedCollection>>addAll: \naCollection Add each element of aCollection at my end. Answer aCollection. |ans dcs dcc| dcs := self \ncopy. dcc := aCollection copy. ans := self addAllLast: aCollection. self assert: ((dcc size = (aCollection \nsize)) and: [ ((dcs size) + aCollection size) = self size]) ans Fig. 13 shows the results for both applications, \nwith adding the larger collections shown in Fig. 13(a) and adding collections of size 1 shown in Fig. \n13(b). The results are sim\u00ad ilar to the previous experiment: we again see linear execution  (b) time \nfor the implementations based on copying and bounded execution time for the HistOOry-based implementations. \n  6.4 Planar Point Location Fig. 14 shows the time used to search the polygon in which a randomized \npoint is. This curve is logarithmic as expected. 7. Related work We have split the related work in three \nsubsection. We .rst discuss approaches that are directly related to ours, then look at applications that \nuse object versioning internally and therefore have an implicit versioning system built-in, and .nally \nlook at object versioning in Java. 7.1 Similar work In [Marquez 2007], Marquez describes an orthogonal \nobject versioning system in Java, providing long-lived versioned objects. Unfortunately, only an overview \nof the system is given in the 4 page paper, without details about the language design . Neither the actual \ndata structures used nor the per\u00adformance of the system are given. The project seems to have stopped \nin 2005, and it is no longer available, so we were not able to inspect their approach ourselves and properly \ncom\u00adpare it to our work. In contrast, we tried to be very clear about what we did and how, and provide \ndetailed numbers so that future approaches can properly compare their results with ours. In [Bertino \net al. 1998], Bertino et al. extend the Object Database Management Systems model with the notion of time. \nTheir model is formally de.ned and complete. But no details about its implementation are given. The conclusion \nsection mentions in one sentence that B+-trees are used, without more detail. Again we cannot do a proper \ncompari\u00adson of this approach with ours. ObjectFlow [Lienhard et al. 2009] is a tool to follow the .ow \nof an object through a system, from its creation to its destruction. Amongst other things it keeps track \nof assignments made to its .elds. This means that all states of these .elds are kept, which is similar \nto what HistOOry does. While this sounds similar, ObjectFlow also differs on sev\u00aderal key points from \nHistOOry because its goals are differ\u00adent. First of all ObjectFlow .xes the scope of what objects are \nversioned to the process (thread): any object manipulated in the process is versioned. Secondly it always \nrecords all state changes. Note that both of these design choices make perfect sense in the context of \nObjectFlow, so their approach does not offer options to change this. Because we have a gen\u00aderal approach \nwe have options to decide what .elds to save and when. Thirdly ObjectFlow is implemented in the virtual \nmachine while HistOOry is implemented in the source code. Both of these choices have advantages and disadvantages. \nImplementing a very complex data structure in the lower\u00adlevel languages used in the virtual machine is \nnot trivial. On the other hand it would probably be even faster than our current implementation. Finally \nHistOOry and ObjectFlow share that all states are kept in the object space, permitting an automatic garbage \ncollection of no-longer-used states. 7.2 Applications Using Object Versioning One category of applications \nthat frequently use object ver\u00adsioning are advanced debuggers [Pothier et al. 2007, Lien\u00ad hard et al. \n2008, Feldman and Brown 1989, Boothe 2000] and model checking tools that are based on execution, such \nas Java Path.nder [Visser et al. 2000]. The Omniscient De\u00ad bugger, for example, executes a program and \nremembers the states objects went through to give the possibility to the developer to return at any point \nin the execution s past. Other information is also saved during execution, such as the method calls and \nthe method return values. The difference between these applications and HistOOry is that HistOOry was \nfrom the ground up designed to be a language extension to make it easy to remember and use object states, \npaired with an infrastructure to do so ef.\u00adciently. The applications all have their own implementation \nthat is application-speci.c and only meant to keep those states needed by the application. HistOOry can \ntherefore be seen as a general layer that any of these applications could have used. This would have \neased the implementation of these ap\u00adproaches, because developing a full .edged performant ob\u00adject persistence \nmechanism is not trivial. On the other hand, HistOOry is a general-prupose object versioning framework \nand some applications will still bene.t from having speci.c structures and algorithms optimized for their \nparticular us\u00adage. Finally, software transactional memories [Shavit and Touitou 1995] can be also considered \nto be an application of object versioning. Transactional memories can be decom\u00adposed in three parts: \n1. When a transaction begins, the states of interesting ob\u00adjects are saved; 2. During the transaction, \nmodi.cations of states performed in the transaction are not visible outside the transaction; 3. A transaction \nis .nished when either the code of the transaction executed without problem and the modi.ca\u00adtions are \ncommited, or because an error occurred and a rollback of the saved states occurs.  From this breakdown \nit becomes clear that HistOOry is currently not really suited to support software transactional memories. \nOne reason is that the visibility of the states in HistOOry is global. The second is that a rollback \nis not di\u00adrectly supported. While such functionality could be built on top of HistOOry we think that \nthe performance and ease-of\u00aduse will suffer. A modi.ed version of HistOOry that retains the data structure \nbut allows to keep local changes would be interesting. We feel that it would enhance software transac\u00adtional \nmemories with the ability to have internal .ne-grained data-driven rollback where the past states of \nunaffected vari\u00adables can be retained over executions while other ones are recomputed.  7.3 Object Versioning \nin Java We mentioned that this paper is the second in our research on ef.cient object versioning. The \n.rst paper presented the .rst-ever published implementation of the fat node method of [Driscoll et al. \n1986]. It relied on AspectJ to instrument changes to .elds. It scaled very well, due to the properties \nof the chosen algorithm, but also had a big overhead and was not very robust. This paper revisits the \nalgorithms and data structures, adding the cache to substantially improve performance (as shown by Fig. \n10 in Sec. 6.1.3). We also did a complete reimplementation in Smalltalk, where we directly manipu\u00adlate \nthe byte codes to have less overhead than relying on an aspect-oriented programming framework. This implementa\u00adtion \nis also more robust and practical. The Java version, for example, uses one global variable to determine \nwhether or not we are browsing or recording old states. If old states are browsed in a thread, any update \nof a versioned object in any thread raises an error. Our new implementation (described in Sec. 4.2.3) \nuses the Smalltalk processes to save or browse state local to a thread. Last but not least we have fully \ninte\u00adgrated HistOOry in a language, and used it in a number of applications. 8. Future Work HistOOry \nimplements a partial versioning model that only provides viewing of stored states. We are currently working \non a fully versioning model that removes this limitation and makes it possible to create new states in \nthe past by modifying saved states. Algorithms for this use advanced data structures and pose several \ninteresting implementation challenges. Like in this work, we want to have a completely object-oriented \ntransparent solution that is ef.cient and well\u00adintegrated. We also want to make some more algorithmic \nimprove\u00adments. One possible improvement is to introduce the pos\u00adsibility of supporting multiple local \nsnapshots instead of having only one global snapshot. This has the potential to reduce the number of \nstates that need to be saved. Last but not least we will develop more applications that use HistOOry, \nfor example a stateful debugger with built-in query capabilities that can take advantage of the past \nstates. 9. Conclusion This paper introduced HistOOry, an ef.cient in-memory ob\u00adject versioning system. \nThe ef.ciency is due to our object\u00adoriented implementation of, and changes to, an ef.cient data structure \nto keep past states. From the practical point of view, we have shown how existing applications can be \nmade ob\u00adject versioned without much effort, simply by either sending them a message or using a class \nextension to override a de\u00adfault method. Regardless of this choice, .ne-grained control is offered on \nwhat .elds of an object are versioned, and when exactly the states are saved. Therefore, our solution \nis gen\u00aderal enough to support applications that need object version\u00ading but have different needs. Debuggers \nmight want to save every single state change of a lot of objects, while other ap\u00adplications like an execution \ntracer might want to only record certain states for certain messages being sent. Even though it is general, \nour solution only requires three basic primitives, making it easy to learn and use. Properly integrating \nit in the language, like we did in Smalltalk, makes it easy to trans\u00adform existing applications that \ndo not use object versioning into ones that have such support. We have shown how to do this by extending \nthe Smalltalk language with checked postconditions, by extending an execution tracer to become stateful, \nand by implementing a planar point location pro\u00adgram. Benchmarks show that the overhead for storing states \nis constant, and does not scale with the number of states that need to be stored. It is our hope that \nby presenting HistOOry applications that currently use ad-hoc and inef.cient object versioning implementations \nwill be able to take advantage of our approach. Acknowledgments We thank the reviewers as well as Yann-Ga\u00a8eh\u00b4 \nel Gu\u00b4eneuc for their helpful comments on drafts of this paper. References Malcolm Atkinson. Orthogonally \npersistent object systems. Nov 1995. URL http://citeseer.ist.psu.edu/411649. Elisa Bertino, Elena Ferrari, \nGiovanna Guerrini, and Isabella Merlo. Extending the odmg object model with time. In In Pro\u00adceedings \nof the European Conference on Object-Oriented Pro\u00adgramming (ECOOP), pages 41 66, 1998. Bob Boothe. Ef.cient \nalgorithms for bidirectional debugging. In PLDI 00: Proceedings of the ACM SIGPLAN 2000 conference on \nProgramming language design and implementation, pages 299 310, New York, NY, USA, 2000. ACM. ISBN 1-58113\u00ad199-2. \ndoi: http://doi.acm.org/10.1145/349299.349339. John Brant, Brian Foote, Ralph Johnson, and Don Roberts. \nWrap\u00adpers to the rescue. In Proceedings of ECOOP 98, pages 396 417, 1998. Serge Demeyer, St\u00b4ephane Ducasse, \nand Oscar Nierstrasz. Object-Oriented Reengineering Patterns. 2002. ISBN 1-55860-639-4. Marcus Denker, \nStephane Ducasse, and \u00b4Eric Tanter. Runtime \u00b4bytecode transformation for smalltalk. Computer Languages, \nSystems &#38; Structures, 32(2-3):125 139, 2005. D. Dobkin and R. Lipton. Multidimensional searching \nproblems. SIAM Journal of Computing 5, pages 181 186, 1976. James R. Driscoll, Neil Sarnak, Daniel D. \nSleator, and Robert E. Tarjan. Making data structures persistent. Journal of Computer and System Sciences, \npages 86 124, 1986. St\u00b4 ephane Ducasse. Evaluating message passing control techniques in Smalltalk. Journal \nof Object-Oriented Programming (JOOP), 12(6):39 44, 1999. St\u00b4 ephane Ducasse, Tudor G irba, and Roel \nWuyts. Object-oriented legacy system trace-based logic testing. In Proceedings of CSMR 06, pages 35 44, \n2006. Stuart I. Feldman and Channing B. Brown. Igor: a system for program debugging via reversible execution. \nSIGPLAN Not., 24(1):112 123, 1989. ISSN 0362-1340. doi: http://doi.acm.org/ 10.1145/69215.69226. Elnar \nHajiyev, Mathieu Verbaere, and Oege de Moor. Codequest: Scalable source code queries with datalog. In \nProceedings of ECOOP 06, pages 2 28, 2006. Abdelwahab Hamou-Lhadj and Timothy Lethbridge. A survey of \ntrace exploration tools and techniques. In Proceedings IBM Cen\u00adters for Advanced Studies Conferences \n(CASON 2004), pages 42 55, 2004. Gregor Kiczales, Erik Hilsdale, Jim Hugunin, Mik Kersten, Jeffrey Palm, \nand William G. Griswold. An overview of AspectJ. In Proceedings of ECOOP 01, pages 327 353, 2001. Danny \nB. Lange and Yuichi Nakamura. Object-oriented program tracing and visualization. Computer, 30(5):63 70, \n1997. Adrian Lienhard, Tudor G irba, and Oscar Nierstrasz. Practi\u00adcal object-oriented back-in-time debugging. \nIn ECOOP 08: Proceedings of the 22nd European conference on Object-Oriented Programming, pages 592 615, \nBerlin, Heidelberg, 2008. Springer-Verlag. ISBN 978-3-540-70591-8. doi: http: //dx.doi.org/10.1007/978-3-540-70592-5 \n25. Adrian Lienhard, St\u00b4ephane Ducasse, and Tudor Girba. Taking an object-centric view on dynamic information \nwith object .ow analysis. Comput. Lang. Syst. Struct., 35(1):63 79, 2009. A. Marquez. Orthogonal object \nversioning in an odmg compliant persistent java extended abstract, 2007. URL http://www. cs.adelaide.edu.au/~idea/idea7/PDFs/marquez.pdf. \nPresented at the School of Computer Science, University of Adelaide, Australia. Bertrand Meyer. Applying \ndesign by contract. IEEE Computer (Special Issue on Inheritance &#38; Classi.cation), 25(10):40 52, 1992. \nTodd Millstein and Craig Chambers. Modular statically typed multimethods. In Proceedings of ECOOP 99, \npages 279 303, 1999. Fr\u00b4ed\u00b4eric Pluquet, Stefan Langerman, Antoine Marot, and Roel Wuyts. Implementing \npartial persistence in object-oriented lan\u00adguages. In Proceedings of the Workshop on Algorithm Engineer\u00ading \nand Experiments (ALENEX08), 2008. Guillaume Pothier, Eric Tanter, and Jos\u00b4e Piquer. Scalable omni\u00ad \u00b4scient \ndebugging. SIGPLAN Not., 42(10):535 552, 2007. ISSN 0362-1340. doi: http://doi.acm.org/10.1145/1297105.1297067. \nNeil Sarnak and Robert E. Tarjan. Planar point location using persistent search trees. Commun. ACM, 29(7):669 \n679, 1986. ISSN 0001-0782. doi: http://doi.acm.org/10.1145/6138.6151. Raimund Seidel and Cecilia R. Aragon. \nRandomized search trees. Algorithmica, 16(4/5):464 497, 1996. Nir Shavit and Dan Touitou. Software transactional \nmemory, 1995. Willem Visser, Klaus Havelund, and Guillaume Brat. Model check\u00ading programs. In Automated \nSoftware Engineering Journal, pages 3 12, 2000. Darren Willis, David J. Pearce, and James Noble. Ef.cient \nobject querying for java. In Proceedings of ECOOP 06, pages 28 40, 2006. Roel Wuyts. A Logic Meta-Programming \nApproach to Support the Co-Evolution of Object-Oriented Design and Implementation. PhD thesis, Vrije \nUniversiteit Brussel, 2001.    \n\t\t\t", "proc_id": "1640089", "abstract": "<p>Object versioning refers to how an application can have access to previous states of its objects. Implementing this mechanism is hard because it needs to be efficient in space and time, and well integrated with the programming language. This paper presents HistOOry, an object versioning system that uses an efficient data structure to store and retrieve past states. It needs only three primitives, and existing code does not need to be modified to be versioned. It provides fine-grained control over what parts of objects are versioned and when. It stores all states, past and present, in memory. Code can be executed in the past of the system and will see the complete system at that point in time. We have implemented our model in Smalltalk and used it for three applications that need versioning: checked postconditions, stateful execution tracing and a planar point location implementation. Benchmarks are provided to asses the practical complexity of our implementation.</p>", "authors": [{"name": "Fr&#233;d&#233;ric Pluquet", "author_profile_id": "81444606959", "affiliation": "Universit&#233; Libre de Bruxelles, Brussels, Belgium", "person_id": "P1728793", "email_address": "", "orcid_id": ""}, {"name": "Stefan Langerman", "author_profile_id": "81100626725", "affiliation": "Universit&#233; Libre de Bruxelles, Brussels, Belgium", "person_id": "P1728794", "email_address": "", "orcid_id": ""}, {"name": "Roel Wuyts", "author_profile_id": "81100639276", "affiliation": "IMEC and Katholieke Universiteit Leuven, Leuven, Belgium", "person_id": "P1728795", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640118", "year": "2009", "article_id": "1640118", "conference": "OOPSLA", "title": "Executing code in the past: efficient in-memory object graph versioning", "url": "http://dl.acm.org/citation.cfm?id=1640118"}