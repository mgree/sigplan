{"article_publication_date": "10-25-2009", "fulltext": "\n MetaEdit+: Defining and Using Integrated Domain-Specific Modeling Languages Juha-Pekka Tolvanen MetaCase \nYlistonmentie 31 FI-40500 Jyvaskyla, Finland +358 14 641 000 jpt@metacase.com Steven Kelly MetaCase \nYlistonmentie 31 FI-40500 Jyvaskyla, Finland +358 14 641 000 stevek@metacase.com Abstract With MetaEdit+ \nyou can build Domain-Specific Modeling languages and tools without having to write a single line of \ncode. This demonstration shows how different domain-specific languages (DSLs) can be integrated with \nhigh-level metamodels, how languages can be created iteratively while automatically updating existing \nmodels, and how multiple modelers can work together seamlessly. Categories and Subject Descriptors D.2.2 \n[Software Engineering] Design Tools and Techniques - user interfaces, state diagrams D.2.6 [Software \nEngineering] Programming Environments - programmer workbench, graphical environments D.3.2 [Programming \nLanguages] Language Classifications - Specialized application languages, very high-level languages General \nTerm Design, Economics, Languages Keywords Domain-specific modeling, domain-specific language, metamodeling, \ncode generation, language workbench 1. Introduction With MetaEdit+ an experienced developer defines a \ndomain\u00adspecific language containing the domain s concepts and rules in a metamodel, and specifies the \nmapping from that to code in a domain-specific code generator. For the modeling language implementation, \nMetaEdit+ provides a metamodeling tool suite for defining the language concepts, rules, symbols, checking \nreports and generators. Once the metamodel is defined, or even a partial prototype, the rest of the team \ncan start to use it in MetaEdit+. The developers make models with the modeling language and the required \ncode is automatically generated from those models. Based on the metamodel, MetaEdit+ automatically provides \nfull modeling tool functionality such as diagramming editors, browsers, documentation generators, and \nmulti-platform support [1]. MetaEdit+ supports simultaneous multi-user editing via novel locking algorithms \n[2], as we will demonstrate. We will show how MetaEdit+ overcomes the problems of other language workbenches \nby being fast (both for defining and using languages), scalable, and hiding tool implementation details. \nMetaEdit+ is made with Smalltalk. The demo shows advanced features of creating domain-specific modeling \nlanguages, namely language integration, language and model evolution, generator debugging, and different \nways to integrate models and code. Copyright is held by the author/owner(s). OOPSLA 2009, October 25-29, \n2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10.  2. Multiple integrated modeling languages \nOne language is not usually enough: in practice, we need different views or even different languages \nthat can be integrated. MetaEdit+ allows integrated languages to be defined by sharing the same metamodel \nelements or via explicit integration links. Figure 1 illustrates the latter: a metamodel defines references \nbetween models using decomposition or explosion links. These typically support the semantics of top-down \nabstraction where a design element is linked with another graph that provides a more detailed description \nof the respective element. Of the two options, decomposition provides stricter semantics by allowing \nonly one subgraph link for each design object. The link also remains the same even if the object is reused \nsomewhere else. Explosion links, on the other hand, are more flexible: several of them can be attached \nto one element and their scope is limited to one graph only. A given element can thus have a different \nexplosion when it is reused in a new graph, making explosions more like hyperlinks than strict aggregation. \n Figure 1. Multiple integrated modeling languages  3. Language and model evolution When a domain-specific \nmodeling language enters real-life production use, it is inevitable that it will be maintained and modified \nthrough its life-cycle a cycle that may well last for over a decade [3]. The repository of MetaEdit+ \noffers a natural update policy for sharing the DSM solution: the new language version can be automatically \nupdated for all users and their models. Alternatively, the DSM definition can be shared as an individual \nfile (or files) that modelers can import into their current modeling tool.  It is vital to ensure that \ninformation in instance models created with the older version of the metamodel is not lost when the new \nversion is deployed. During the development of MetaEdit+, a lot of effort has been invested in ensuring \nthe seamless updates of metamodels and models. In many cases a conservative approach for modifying the \nexisting metamodels and design data has been adopted. For example, if a concept is removed from the language, \nthe creation of new instances of the type will not be possible, but existing instances of this concept \nare not removed from the models. Since the generators will still produce working code from these old \ninstances, there is no need to destroy them. Instead, the metamodeler can choose to make them more visibly \nobsolete, e.g., by changing their symbol to include a red exclamation mark. Checking reports can also \nbe made to list all such obsolete instances, allowing the modeler to make the appropriate update manually. \nWhere the update can be specified, it can also be automated by writing a model transformation. These \ncan be specified in the metamodeler's language of choice operating via the API, or as an XML transformation \nfor the model files.  4. Testing and debugging of generators In MetaEdit+, generators are defined in \nthe Generator Editor using MERL, a textual DSL designed for turning models into text. Alternative approaches \ninclude accessing model data via the SOAP/Webservices API or generating to intermediate files that are \nthen processed by an external program. While DSM best practice is to keep generators simple, on industrial \nscales generators can still become complex. MetaEdit+ provides a Generator Debugger (Figure 2) to help \nin tracing and debugging of generators. Figure 2. Generator Debugger The Generator Debugger provides \nthe usual operations for controlling the execution of the generator: setting and removing breakpoints, \nstepping into/over commands and restarting the execution. The debugger shows several views on the execution \nstatus and results. The top half of the window shows the execution status: the call tree of generators, \nthe currently executed generator script, and the stack of model elements that have been accessed to reach \nthe current element. The bottom half of the window shows the rssults: the currently generated target \nfiles and output streams, the current output, and the values of the variables used during the generation. \nThe Generator Debugger also offers access to model elements during execution and creates live hyperlinks \nfrom the output text back to the model elements. 5. Integrating models and code There are multiple ways \nto integrate models and code. We would like to demonstrate one particular feature that is especially \ngood when testing the generator or inspecting the generated code. MetaEdit+ provides a feature called \n\"Live code\": a developer may click part of the generated code to jump to the corresponding element in \nthe model. All the generated code provides this capability, so for example in model checking reports \nand documentation reports it is possible to trace back from the output text to models in MetaEdit+. \n6. Summary Tool support for creating and using modeling languages and code generators is crucial for \nautomating software development. For practical industrial use, the tools must be intuitive and scalable. \nMetaEdit+ aims to provide this by providing integrated tools for language designers and hiding the tool \nimplementation details. This approach allows the development of domain-specific languages and code generators \nin a few man-days, not months. Figure 3 illustrates industry experiences in selected domains. Figure \n3. Time to implement modeling tools and generators The demonstration shows tool features that go beyond \neditor creation. We demonstrate how multiple languages can be integrated so the changes in models based \non one language are visible in other models, offering distinct yet integrated views on the system specified. \nWe also show how the tool supports language evolution, automatically updating existing models to the \nnew version of the language. We show how MetaEdit+ offers debugging tools for both modeling and generators: \ngenerated code is linked back to models, so debugging can take place directly in the models. The features \nare all implemented and available in the free MetaEdit+ evaluation version available from www.metacase.com/download. \n  References [1] MetaCase, MetaEdit+ Workbench 4.5 SR1 User s Guide, http://www.metacase.com/support/45/manuals/, \n2009 [2] Kelly, S., CASE Tool Support for Co-operative Work in Information System Design, IFIP TC8/WG8.1 \nWorking Conference on Information Systems in the WWW Environment, Beijing, Chapman &#38; Hall, 1998 [3] \nIEEE Software Special Issue on Domain-Specific Modeling, July/August, 2009  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>With MetaEdit+ you can build Domain-Specific Modeling languages and tools - without having to write a single line of code. This demonstration shows how different domain-specific languages (DSLs) can be integrated with high-level metamodels, how languages can be created iteratively while automatically updating existing models, and how multiple modelers can work together seamlessly.</p>", "authors": [{"name": "Juha-Pekka Tolvanen", "author_profile_id": "81100508185", "affiliation": "MetaCase, Jyv&#228;skyl&#228;, Finland", "person_id": "P1728671", "email_address": "", "orcid_id": ""}, {"name": "Steven Kelly", "author_profile_id": "81100523697", "affiliation": "MetaCase, Jyv&#228;skyl&#228;, Finland", "person_id": "P1728672", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640031", "year": "2009", "article_id": "1640031", "conference": "OOPSLA", "title": "MetaEdit+: defining and using integrated domain-specific modeling languages", "url": "http://dl.acm.org/citation.cfm?id=1640031"}