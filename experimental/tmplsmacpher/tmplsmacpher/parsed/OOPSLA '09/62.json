{"article_publication_date": "10-25-2009", "fulltext": "\n ReLooper: Refactoring for Loop Parallelism in Java Danny Dig Mihai Tarce Cosmin Radoi University of \nIllinois Politehnica University of Timisoara Politehnica University of Timisoara dig@cs.uiuc.edu mihai.tarce@cs.upt.ro \ncosmin.radoi@cs.upt.ro Marius Minea Ralph Johnson Politehnica University of Timisoara University of \nIllinois marius@cs.upt.ro johnson@cs.uiuc.edu Abstract In the multicore era, sequential programs need \nto be refactored for parallelism. The next version of Java provides ParallelArray, an array datastructure \nthat supports parallel operations over the array elements. For example, one can apply a procedure to \neach element, or reduce all elements to a new element in parallel. Refactoring an array to a ParallelArray \nrequires (i) analyzing whether the loop iterations are safe for parallel execution, and (ii) replacing \nloops with the equivalent parallel operations. When done manually, these tasks are non-trivial and time-consuming. \nThis demo presents RELOOPER, an Eclipse-based refactoring tool, that performs these tasks automatically. \nPreliminary experience with refactoring real programs shows that RELOOPER is useful. Categories and Subject \nDescriptors D.1.3 [Software]: Concur\u00adrent Programming Parallel Programming; D.2.3 [Software En\u00adgineering]: \nCoding Tools and Techniques Program Editors General Terms Algorithms, Design Keywords Refactoring, program \nanalysis, program transforma\u00adtion, parallelism and concurrency 1. Introduction In the multicore era, \nunless programmers refactor the existing se\u00adquential programs for parallelism, they will not bene.t from \nthe underlying parallel processors. Refactoring for parallelism is non\u00adtrivial, because the refactored \ncode needs to satisfy two con.icting goals: it needs to be thread-safe (i.e., run correctly when executed \nunder multiple threads) and scalable (i.e., performance continues to improve when adding more cores). \nThe key to scaling performance is to use .ne-grained paral\u00adlelism. Java will include the ParallelArray \nframework [1], a spe\u00adcial kind of array that provides .ne-grained parallel operations. For example, one \ncan apply a procedure to the elements of an array, map elements to new elements, or reduce all elements \ninto a single value like a sum. The framework ef.ciently executes these parallel Copyright is held by \nthe author/owner(s). OOPSLA 09 October 25 29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10 \noperations by splitting the computations on array elements among a pool of worker threads, and relying \non a runtime library to balance the work among the processors in the system. To refactor an existing \narray into a ParallelArray, the pro\u00adgrammer constructs it by using factory methods (e.g., by copy\u00ading \nelements from other arrays). Then the programmer identi.es the loops that iterate over all the array \nelements and she analyzes each loop to infer its intent (e.g., the loop reduces all elements to a value). \nNext, she replaces the loop body with a call to the equivalent parallel operation (e.g., reduce). The \nparallel operation takes an element operator as an argument and executes it on each element. Since Java \ndoes not support anonymous functions (i.e., lambda ex\u00adpressions), the programmer needs to encapsulate \nthe operator in\u00adside an anonymous class, by subclassing one of the 132 operator classes, and override \nthe op method. In addition, since ParallelArray assumes that all parallel computations do not interfere \nwith each other, it runs them without any synchronization. It is the programmer s responsibility to verify \nthat indeed the loop iterations do not have con.icting memory accesses. This analysis and code rewriting \nis non-trivial, and time\u00adconsuming. We have implemented a refactoring tool, RELOOPER, that auto\u00admates \nthe safety analysis and the rewriting of code. RELOOPER is integrated with Eclipse s refactoring engine, \nso it offers all the con\u00advenient features of a refactoring engine: previewing the changes, preserving \nthe formatting, undoing changes, etc. To use RELOOPER, the programmer selects an array and chooses CONVERTTOPARALLELAR-RAY \nfrom the refactoring menu. 2. The Refactoring Tool Figure 1 shows a preview of the changes that RELOOPER \napplies to a small program that works with an array of Complex num\u00adbers. A complex number has the form \na + bi where a is the real part, and b is the imaginary part. The .rst loop in method ComplexTest.test() \ninitializes the array elements using the fac\u00adtory method createRandom(). The second loop iterates over \nall the array elements and computes the square of each complex num\u00adber. The third loop adds all the numbers \nand stores the result in the sum variable. Transformations. RELOOPER changes the type declaration of \nnumbers into a ParallelArray of Complex objects. Then it re\u00adplaces the code that allocates storage for \nthe array with code that creates a ParallelArray with the same capacity, and speci.es the base element \ntype and the pool of worker threads that will be used at runtime (defaultExecutor() arranges to use most \nof the pro\u00adcessors available).  Figure 1. Using RELOOPER to convert an array of Complex numbers to \na ParallelArray. The screenshot shows a preview of the changes, with the original code on the left and \nthe refactored code on the right. For each loop that iterates over the array elements, RELOOPER in\u00adfers \nthe intent of the loop and replaces it with the equivalent parallel operation from ParallelArray. In \nour example, the .rst loop ini\u00adtializes the array elements, so RELOOPER replaces it by invoking the replaceWithGeneratedValue \noperation and passes an operator implemented as an anonymous Generator class. RELOOPER over\u00adrides the \nop() method to create objects like in the original code. RELOOPER correctly replaces the last two loops \nwith the appropriate operations and generates the anonymous classes that encapsulate the operators. Preconditions. \nRELOOPER performs the following program ana\u00adlyses to determine whether the refactoring can be applied \nsafely. First, it checks that a loop iterates over all elements of the array, i.e., from the .rst element \nto the last, without skipping elements. Second, the analysis determines that there are no loop-carried \ndependencies between iterations, i.e., each iteration processes only one element, and the variables in \none iteration do not depend on values coming from other iterations. Even though the sum vari\u00adable is \na loop-carried dependency, the analysis allows it because this dependency is eliminated when sum becomes \nthe accumulator variable for the reduce operation (internally, the reduction creates fresh sum variables, \nand accumulates them in a .nal step). Third, the analysis determines whether the loop iterations have \ncon.icting memory accesses. As one step of this check, our ana\u00adlysis determines that the array elements \nare unique, i.e., the array does not contain duplicate objects. Processing duplicate objects in parallel \ncould introduce data races. To check the uniqueness invari\u00adant, the analysis builds upon a context-sensitive, \n.ow-insensitive, demand-driven pointer analysis [2] implemented in WALA [3]. Our custom analysis determines \nthat elements created in different iter\u00adations are indeed unique. For example, it determines that different \ncalls to createRandom() return unique objects, and that subse\u00adquent loops maintain the uniqueness invariant. \n3. Conclusions Refactoring tools can help programmers retro.t parallelism into se\u00adquential code. This \ndemo presents RELOOPER, a tool for parallelizing loops over arrays. Our preliminary experience with refactoring \ntwo large NLP applications and other medium-size applications shows that RELOOPER is useful: on average, \nthe refactoring .nishes in less than 30 seconds, and the results are correct. As we are currently adding \nmore analysis to check that updates to shared state among loop iterations are not con.icting, the main \nchallenge remains to keep the refactoring both precise and fast enough to be used in an interactive mode. \nRELOOPER can be downloaded from its homepage: http://refactoring.info/tools/ReLooper 4. Acknowledgments \nThis work is partially funded by Intel and Microsoft through the UPCRC Illinois, and a DOE grant ER25752. \nCosmin and Mihai did a part of this work as undergraduate summer interns at the Information Trust Institute \nat the University of Illinois. References [1] D. Lea. ParallelArray package extra166y. http://gee.cs.oswego. \nedu/dl/concurrency-interest/index.html, 2009. [2] M. Sridharan, D. Gopan, L. Shan, and R. Bod\u00b4ik. Demand-driven \npoints\u00adto analysis for Java. In Proceedings of OOPSLA, 2005. [3] WALA: T. J. Watson Libraries for Analysis. \nhttp://wala.sf.net.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>In the multicore era, sequential programs need to be refactored for parallelism. The next version of Java provides <i>ParallelArray</i>, an array datastructure that supports parallel operations over the array elements. For example, one can <i>apply</i> a procedure to each element, or <i>reduce</i> all elements to a new element in parallel. Refactoring an array to a <i>ParallelArray</i> requires (i) analyzing whether the loop iterations are safe for parallel execution, and (ii) replacing loops with the equivalent parallel operations. When done manually, these tasks are non-trivial and time-consuming. This demo presents <i>ReLooper</i>, an Eclipse-based refactoring tool, that performs these tasks automatically. Preliminary experience with refactoring real programs shows that <i>ReLooper</i> is useful.</p>", "authors": [{"name": "Danny Dig", "author_profile_id": "81100198424", "affiliation": "University of Illinois, Urbana, IL, USA", "person_id": "P1728623", "email_address": "", "orcid_id": ""}, {"name": "Mihai Tarce", "author_profile_id": "81444608916", "affiliation": "Politehnica University of Timisoara, Timisoara Romania", "person_id": "P1728624", "email_address": "", "orcid_id": ""}, {"name": "Cosmin Radoi", "author_profile_id": "81444592506", "affiliation": "Politehnica University of Timisoara, Timisoara, Romania", "person_id": "P1728625", "email_address": "", "orcid_id": ""}, {"name": "Marius Minea", "author_profile_id": "81339517379", "affiliation": "Politehnica University of Timisoara, Timisoara, Romania", "person_id": "P1728626", "email_address": "", "orcid_id": ""}, {"name": "Ralph Johnson", "author_profile_id": "81330492373", "affiliation": "University of Illinois, Urbana, USA", "person_id": "P1728627", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640018", "year": "2009", "article_id": "1640018", "conference": "OOPSLA", "title": "Relooper: refactoring for loop parallelism in Java", "url": "http://dl.acm.org/citation.cfm?id=1640018"}