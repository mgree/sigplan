{"article_publication_date": "10-25-2009", "fulltext": "\n Typestate-Oriented Programming Jonathan Aldrich Joshua Sunshine Darpan Saini Zachary Sparks School \nof Computer Science Carnegie Mellon University Pittsburgh, Pennsylvania, USA {aldrich,jssunshi,dsaini,zsparks}@andrew.cmu.edu \nAbstract Objects model the world, and state is fundamental to a faith\u00adful modeling. Engineers use state \nmachines to understand and reason about state transitions, but programming lan\u00adguages provide little \nsupport for reasoning about or imple\u00admenting these state machines, causing software defects and lost \nproductivity when objects are misused. We propose Typestate-Oriented Programming as a nat\u00adural extension \nto the object paradigm, where objects are modeled not just in terms of classes, but in terms of chang\u00ading \nstates. Each state may have its own representation and methods which may transition the object into a \nnew state. A .ow-sensitive, permission-based type system helps develop\u00aders track which state objects \nare in. First-class typestates are a powerful abstraction that will help developers model and reuse objects \nmore ef.ciently and correctly. Categories and Subject Descriptors D.3.1 [Programming Techniques]: Miscellaneous \nTypestate-oriented pro\u00adgramming; D.3.2 [Programming Languages]: Language Classi.cations Typestate-oriented \nlanguages; D.3.3 [Programming Languages]: Language Constructs and Features States General Terms Design, \nDocumentation, Human Factors, Languages, Theory, Veri.cation 1. Introduction Object-oriented programming \nwas originally developed to facilitate simulation [Dahl and Nygaard 1966], but the object and class abstractions \nused proved to be a revolutionary ad\u00advance for effectively building programs in a wide variety of domains. \nPart of the reason for objects success is that they are useful not just for simulation of real-world \nentities, but Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n2009, October 25 29, 2009, Orlando, Florida, USA. Copyright c&#38;#169; 2009 ACM 978-1-60558-768-4/09/10. \n. . $10.00 for building reusable libraries of abstract entities as diverse as collections, streams, and \nwindows. In the last decade, sophisticated object-oriented libraries and frameworks have leveraged the \npower of objects to sup\u00adport widespread component-based reuse. While this reuse has enhanced productivity, \nit has also brought its own prob\u00adlems. Library and framework APIs must often be complex in order to provide \nrich functionality that can be reused in very general ways. In order to effectively leverage these APIs, \nprogrammers must understand how to use them correctly. One critical aspect of correct API use is typestate \nan abstraction of the operations currently available on an ob\u00adject, which may change as the program executes \n[Strom and Yemini 1986]. A familiar example is .les that may be open or closed. In the open state, one \nmay read or write to a .le, or one may close it, which causes a state transition to the closed state. \nIn the closed state, the only permitted operation is to (re-)open the .le. States are a fundamental abstraction \nin computer science, in engineering more broadly, and in the natural world. Look\u00ading just at the Java \nstandard libraries, we see a rich variety of states: streams may be open or closed, iterators may have \nel\u00adements available or not, collections may be empty or not, and even lowly exceptions can have their \ncause set, or not1. Re\u00adsultSets from the JDBC library have dozens of states deal\u00ading with different combinations \nof openness, direction, ran\u00addom access, insertions, etc. Programmers follow engineers and scientists \nin other disciplines in drawing state diagrams, which show the possible states in a system and transitions \nbetween them. Even the natural world has states: are you hungry right now, or full? Perhaps a meal would \nproduce a satisfying state transition. States in.uence behavior, and trying to perform an op\u00aderation \non an object in the wrong state is likely to have unfortunate results as when a code review goes over \ninto lunchtime. While trying to write to a closed .le may not be common, it is easy to make state-related \nmistakes in libraries with less familiar and more complex state spaces. A recent example we observed \ncomes from the ASP.NET framework. 1 the cause of an exception can only be set once  In the drop-down \nlist widget, one must de-select one item before selecting another; simply selecting another item will \nresult in an unhelpful exception thrown, with a stack trace that is completely unrelated to the code \ncontaining the er\u00adror. These problems occur, in part, because states are an implicit part of component \ninterfaces they cannot be ex\u00adpressed in language-level interfaces, yet they are essential for using components \ncorrectly. In this paper, we propose Typestate-Oriented Program\u00adming as a natural extension to the object \nparadigm, where objects are modeled not just in terms of classes, but in terms of their changing states. \nIn our model, each object state may have its own representation and methods which may transi\u00adtion the \nobject into a new state. A .ow-sensitive, permission\u00adbased type system helps developers track which state \nobjects are in. Because states are a natural way of modeling the world, we believe typestate-oriented \nprogramming will yield ab\u00adstraction bene.ts similar to but beyond those provided by object-oriented programming. \nBecause states are ubiquitous in today s software designs, we believe that explicit language support \nfor typestate will express those designs more clearly than the state of the art. Because the cost of \nmisunderstand\u00ading and misusing states is so high, we believe that the im\u00adproved documentation and checking \nprovided by typestate will prevent errors and enhance developers productivity. For all these reasons, \ntypestate-oriented programming has the potential to spark a new revolution in component-based soft\u00adware \nreuse. 2. Context and Approach Before .eshing out the typestate-oriented programming paradigm in section \n3, we consider the historical context and alternative approaches to the problems described in the in\u00adtroduction. \nState-Based Designs. Today s programming languages have no direct support for typestate. Instead, the \nbehavioral as\u00adpects of state must be encoded via the State design pat\u00adtern [Gamma et al. 1995], if-tests \non .ag .elds, and other indirect mechanisms. While the State pattern offers exten\u00adsibility, it does not \nhelp with larger coordination challenges such as ensuring that a client uses only operations that are \navailable in the current state. Typestate Checkers. Recent advances in typestate focus on specifying \nthe interface of a class in terms of states and en\u00adsuring that clients only call functions that are appropriate \nin a given state. The Fugue system [Deline and Fahndrich 2004] was the .rst modular typestate veri.cation \nsystem for object-oriented software. The key veri.cation ideas in Fugue include classifying references \nas not aliased or possi\u00adbly aliased, associating each class state with an invariant de\u00adscribing the state \nof the class s .elds (which is necessary to support modular veri.cation), and a frame-based approach \nto supporting veri.cation in the presence of inheritance. Our Plural system extended Fugue in a number \nof prag\u00admatically important ways, providing a richer set of aliasing abstractions, a state re.nement \nmechanism that ensures sub\u00adtyping, a way to make guarantees about the state of shared mutable objects, \nand a way to dynamically test the state of objects. In a recent case study, we showed that Plural can \nverify typestate properties such as correct iterator use across a 30,000-line program, as well as verify \ncompliance to pro\u00adtocols in a layered system that aliases stateful objects in in\u00adteresting ways [Bierhoff \net al. 2009]. An alternative to tracking typestate through an enhanced type system is specifying state \n-achine constraints on how an abstraction is used, then applying static analysis to check whether they \nare followed [Fink et al. 2008, Bodden et al. 2008]. This pushbutton approach has the advantage of low \noverhead the user simply speci.es the property, runs the tool and gets messages regarding potential errors. \nHowever, the analysis requires good aliasing information to be suc\u00adcessful, which is notoriously challenging. \nBene.ts of a Language-Based Approach. While typestate checking systems are approaching practicality for \nJava-like languages, there are numerous advantages to building types\u00adtate into the object model of the \nlanguage rather than running a separate checker afterward. First, language in.uences thought [Boroditsky \n2009]: by incorporating typestate explicitly into a programming lan\u00adguage, we encourage library writers \nand users to think in terms of states, which should help them to design, document, and reuse library \ncomponents more effectively. Interfaces have states, whether the language does or not; by adding them \nto the language, we encourage library designers and users to think about them and to write better code. \nSecond, support for typestate currently faces a barrier of complexity: Java s generics are rightly viewed \nas complex2, and typestate adds additional complexity on top of that. Fur\u00adthermore, mechanisms like type \nparameterization need to be duplicated for typestate, so that we can talk not only about a list of .les, \nbut also about a list of open .les. By adding type\u00adstate directly to the programming language, we can \nintegrate it better and reuse mechanisms between the type system and the state-tracking system, yielding \na simpler and more un\u00adderstandable design overall. For example, our proposed de\u00adsign has a single parameterization \nconstruct which applies both to traditional types and to states. Third, putting typestate in the programming \nlanguage offers new opportunities for expressiveness. An open .le has a .eld holding the operating system \n.le handle; a closed .le does not. However, in Java, that .eld will be present in both the open and closed \nstates, and so the .eld must be assigned a sentinel value (e.g., nUll) in the closed state. 2 Wildcards \nneed we say more?  This makes reasoning more complex, as the maintainer of the class must be aware of \na class invariant stating that the .eld has a sentinel value if and only if the object is in the closed \nstate. If states are supported in the language, we can simply eliminate the .eld in the closed state. \nThere is never any possibility of misinterpreting the sentinel value as a real one (null pointer exceptions/core \ndumps anyone?) and reasoning about the invariant is simpler because it is built into the state-based \nmodel of the system. Prior Language-Based Approaches. The Actor model [Hewitt et al. 1973] was one of \nthe .rst pro\u00adgramming models to treat states in a .rst class way. An Actor can accept one of several \nmessages; in response, it can perform computation, create other actors, send messages, and .nally determine \nits next state i.e. how to respond to the next message received. Our state-orientated approach draws \ninspiration from actors, but our concurrency ap\u00adproach [Stork et al. 2009] stays within a call-return \nfunction model rather than using messages. Smalltalk [Kay 1993] introduced a become method that allows \nan object to exchange state and behavior with another object, which can be used to model state changes \nin a .rst\u00adclass way. In a related approach, the Self language [Ungar and Smith 1987] allows an object \nto change the objects it delegates to (i.e. inherits from), also providing a way to model state changes. \nThe concept of a state is related to that of a role played in interactions with other object. While most \nresearch in the area uses roles to describe different (simultaneous) views of an object, Pernici proposed \nstate-like roles where objects can transition from one role to another [Pernici 1990]. From the object \nmodeling point of view, the closest work to ours is Taivalsaari s proposal to extend class-based lan\u00adguages \nwith explicit de.nitions of logical states (modes), each with its own set of operations and corresponding \nimple\u00admentations [Taivalsaari 1993]. Our proposed object model differs in providing explicit state transitions \n(rather than im\u00adplicit ones determined by .elds) and in allowing different .elds in different states. \nA number of CAD tools such as iLogic Rhapsody or IB\u00adM/Rational Rose Real-Time support a programming model \nbased on Statecharts [Harel 1987]; such models bene.t from many rich features of Statecharts but lack \nthe dynamism of object-oriented systems. Recently Sterkin proposed em\u00adbedding the principal features \nof Statecharts as a library within Groovy, providing a smoother integration with ob\u00adjects [Sterkin 2008]. \nOur approach focuses on adding states to the object-oriented paradigm, and does not consider other features \nof Statecharts. Prior Type System Support. Our proposal differs from all the approaches above by providing \na type system for track\u00ading state changes. A related notion is allowing class changes state File { pUblic \nfinal String filename; } state OpenFile extends File { private CFilePtr filePtr; pUblic int read() { \n... } pUblic void close() [OpenFile>>ClosedFile] { ... } } state ClosedFile extends File { pUblic void \nopen() [ClosedFile>>OpenFile] { ... } } Listing 1. File states in Plaid in a statically typed language \n[Bejleri et al. 2006, Bettini et al. 2009]. If changing classes are viewed as states, this is very similar \nin spirit to our proposal; in fact the Fickle sys\u00adtem [Drossopoulou et al. 2001] distinguishes state \nclasses, which describe states that can change. The recent advances in typestate systems described above \nhave overcome a num\u00adber of the limitations in Fickle and related systems e.g. the inability to track \nthe states of .elds and leveraging these ad\u00advances opens the way to the new paradigm and accompany\u00ading \nlanguage design we describe in this paper. 3. Typestate-Oriented Programming In this section, we describe \nthe typestate-oriented program\u00adming paradigm through a series of illustrative examples of .les, collections, \nand iterators. Section 4 then demonstrates the generality of the approach through a richer example taken \nfrom the domain of GUI frameworks. Our examples are written in Plaid, a typestate-oriented programming \nlanguage currently under development at Carnegie Mellon University3. To aid in readability, Plaid uses \nJava s syntax wherever possible. 3.1 States Consider the example in Listing 1 which declares the in\u00ad \nterface of a File in terms of OpenFile and ClosedFile states. These abstractions are declared using the \nstate key\u00adword; states are just like Java s classes, except that the state of an object may change as \nan object evolves. We observe that while the filename property is present in all .les, the read and close \nmethods are only available in the Open-File state, and the open method is only available in the ClosedFile \nstate. Methods and .elds are declared much as they are in Java; in fact, the declarations of filename, \nfilePtr, and read are legal Java syntax. Here filePtr refers to some low-level operating system resource \nsuch as a 3 http://www.plaid-lang.org/  int readFromFile(ClosedFile f) { openHelper(f); int x = computeBase() \n+ f.read(); f.close(); retUrn x; } Listing 2. File client in Plaid FILE* in the standard C libraries, \nand is only present in the OpenFile state. The open and close methods introduce the .rst real new bit \nof syntax, as we must specify that the receiver object transitions between the OpenFile and ClosedFile \nstates. In Plaid, any argument that changes state is declared with a pair of before and after states \nseparated with the >> symbol. For example, a function openHelper that opens a .le might be declared as \nfollows: void openHelper(ClosedFile>>OpenFile aFile); For the close and open methods, we are actually \nspec\u00adifying a transition for the receiver this, which is passed implicitly in Java-like languages. We \nallow the developer to specify state changes on the receiver by placing the state change speci.cation \nin brackets [] after the normal argu\u00adment list.  3.2 Tracking State Changes Consider the File client \nshown in Listing 2, which accepts a closed .le, opens it using the openHelper function, reads an integer \nand adds a base number, closes the .le, and returns the computed sum. The readFromFile function accepts \na single argument, ClosedFile f, and since no state transi\u00adtion is speci.ed we take this as syntactic \nsugar for Closed-File>>ClosedFile f. In this case the function signature implies that, though the function \nmay change the state of the .le internally, by the end of the function the .le is once again in the ClosedFile \nstate. The compiler tracks the state of f through the body of the function and alerts the programmer \nif it is used inconsis\u00adtently. In this case the compiler notes that openHelper tran\u00adsitions f from the \nClosedFile state to the OpenFile state. As a result the call to f.read() is legal; if we comment out \nthe openHelper line then the call to f.read() results in a compiler error. Likewise, the compiler notes \nthat the call to f.close() transitions f to the ClosedFile state, which is the correct .nal state according \nto the function signature. If we comment out f.close() then we get an error stating that f should be \nin the ClosedFile state, but it is actually in the OpenFile state. 3.3 Aliasing and Permissions The \ncall to computeBase in Listing 2 points out an impor\u00ad tant subtlety. What if we have stored an alias \nto f somewhere in a global variable or in the heap? In that case we have to consider the possibility \nthat the call to computeBase might close the .le and make the call to f.read() illegal. We rule out this \npossibility using a system of permis\u00adsions [Bierhoff and Aldrich 2007], which abstractly describe whether \nand how an object is shared. One of our permissions is UniqUe, indicating that there are no aliases to \nthe object referred to by a function argument, return value, or .eld. We can therefore declare f with \nthe keyword UniqUe before the speci.ed state, as shown below: int readFromFile(UniqUe ClosedFile f); \nSince the compiler knows there are no aliases to f, the compiler also knows that computeBase will not \nclose the .le, and thus the call to f.read() is OK. Because UniqUe is convenient, we make it the default \npermission, so it is un\u00adnecessary to declare it speci.cally so in fact, the declara\u00adtion of f in Listing \n2 is semantically equivalent to the more detailed declaration above. All references need permissions, \nso in Listing 1, the filePtr .eld, as well as the this argument to all the meth\u00adods shown, are implicitly \nUniqUe. The filename .eld is in\u00adteresting because it has type String, which is an immutable (unchangeable) \ntype in both Java and Plaid. Aliasing gener\u00adally only causes problems for mutable objects, so it is not \na problem for .elds of type String. Thus we should use a second permission kind, iuuUtable, which unlike \nUniqUe allows unlimited aliasing of the object, but prohibits the ob\u00adject from being changed in any way. \nWe could thus declare the filename .eld as: pUblic final iuuUtable String filename; However, all Strings \nin the application are iuuUtable, so we instead declare the whole String state iuuUtable as follows: \niuuUtable state String { ... } The meaning of this declaration is that whenever we use the state String \nto declare a variable, that variable defaults to the iuuUtable permission kind. Thus the code in List\u00ading \n1 does not need to be changed; the filename .eld de\u00adfaults to iuuUtable because String is an iuuUtable \nstate, while the cFilePtr .eld defaults to unique (presum\u00adably because CFilePtr is not an iuuUtable state). \n 3.4 Instantiating Objects Plaid provides a slightly different object construction model than does Java. \nA full discussion is out of scope here, but we provide a new expression form that speci.es the state \nof the object to be created along with values for all its .elds. The new expression requires all .elds \nto be visible, and since .elds tend to be private or protected we will typically provide a factory-style \nstatic method within a state that clients can use4. For example, we might have the following inside ClosedFile: \n pUblic static ClosedFile create(String f) { retUrn new ClosedFile { filename = f; } } Observe that \naccording to our defaulting convention, the returned ClosedFile will be UniqUe.  3.5 Implementing State \nChanges How does the .le get opened? We can de.ne the open function in ClosedFile as follows: pUblic \nvoid open() [ClosedFile>>OpenFile] { this <-OpenFile { filePtr = fopen(filename); } } In the code above, \nthe expression form e <-S { de\u00adcls } transitions the object described by e into the state S, and uses \nthe declarations in decls to initialize the .elds of S that were not already present in e s current state \n(and to as\u00adsign new values to pre-existing .elds). In this case, we tran\u00adsition the receiver into the \nOpenFile state. The OpenFile state has two .elds, filename (inherited from File) and filePtr. The filename \ndoes not need to be re-initialized, because the receiver is already in a substate of File and so filename \nis already de.ned. However, we must provide a value for filePtr, which we do by calling into an imported \nC library function (declaration not shown). 3.6 Shared Objects So far we have introduced UniqUe and \niuuUtable per\u00admissions. Each facilitates reasoning UniqUe because there are no aliases, and iuuUtable \nbecause there are no state changes but many real programs contain mutable, aliased objects. As previously \nproposed in our typestate sys\u00adtem [Bierhoff et al. 2009] we provide additional permissions such as shared, \na permission that indicates sharing and mu\u00adtation via the shared references. It is more dif.cult to track \nthe state of a shared File, because any function call could potentially access an alias to that .le and \nchange its state (e.g. by closing it) without the caller knowing. For this reason, we treat the state \nasso\u00adciated with each shared permission as a state guarantee, which is a state that all clients of the \nobject agree to respect. For example, in the code below, the shared permission is guaranteed to remain \nin the OpenFile state: void logToFile(shared OpenFile logFile){ logFile.write(LOG_TEXT); } 4 In Plaid, \na static method is really an instance method of the object representing the surrounding state, much like \nclass methods in Smalltalk state Collection { type TElem; pUblic void add(TElem>>none e); pUblic TElem \nremoveAny(); pUblic void remove(none>>TElem e); } Listing 3. Collections in Plaid Another approach for \ndealing with shared objects is dy\u00adnamically testing the object s state before performing a sen\u00adsitive \noperation. An example of a state test function is given in the Iterator example below. For a full discussion \nof rea\u00adsoning in the presence of shared and related permissions, see [Bierhoff and Aldrich 2007].  3.7 \nGenericity We would like to be able to store our .les in a collection, and keep track of the fact that \nthe .les are UniqUe (if they are) and whether they are open or closed. As we discussed in Section 2, \nan advantage of building states into the language is that we use a single parameterization mechanism \nrather than having one for types and a separate one for permissions. Listing 3 shows the interface of \na Collection state in Plaid. We declare an abstract type TElem in the Collec\u00adtion state [Milner et al. \n1997]. Abstract types are like type parameters but more modular5, and we provide a syntactic sugar where \nCollection<String> means that the TElem type member of the collection is bound to String. Since Plaid \ntypes include both a state and a permission, the abstract type represents both the permission (UniqUe, \niuuUtable, or shared) and the state the elements are in (e.g. OpenFile vs. ClosedFile). Because the TElem \ntype might be UniqUe, and UniqUe references cannot be duplicated/aliased, we must be care\u00adful about managing \npermissions as objects are moved in and out of the collection. When we add an object, a TElem per\u00admission \nis required to the parameter e, and that permission is stored in the collection and is not returned to \nthe client. This is symbolized by the transition PElem>>none, where the none keyword indicates the lack \nof a permission to the object. The removeAny function removes an arbitrary element and returns it with \na TElem permission. We can also remove a particular element, passing in the element as a parameter without \nany permission, and receiving a TElem permission back from the collection. 5 it allows a client to refer \nto Collection without specifying what TElem is if the element type doesn t matter to that client  An \nexample client might look like this: pUblic void collectionClient( Collection<UniqUe OpenFile> c) { UniqUe \nClosedFile aFile = ClosedFile.create(aFilename); aFile.open(); // aFile is now an OpenFile c.add(aFile); \n... // cannot call aFile.read-no permission c.remove(aFile); // permission restored int readValue = aFile.read(); \n... // use readValue } In our example all functions either add or remove an ele\u00adment from the collection. \nThere is no way to get an element while leaving it in the collection, because that would create an alias \nand if TElem was a UniqUe permission then the in\u00advariant that UniqUe permissions are not aliased would \nbe violated. In contrast, we say that iuuUtable and shared are conserved because they can be duplicated, \nresulting in 2 identical permissions. It is safe to de.ne a getAny function that operates only on conserved \npermissions: <TThis extends UniqUe Collection<conserved TElem>> pUblic TElem getAny()[TThis]; In the \nexample above, TThis is a type parameter of the method getAny. The type parameter has a bound stating \nthat it must be a UniqUe permission to some kind of Collec\u00adtion where the TElem is conserved. The type \nparameter is the bound for the receiver object this.  3.8 Example: Iterators Listing 4 shows how an \nIterator abstraction can be de\u00ad.ned over collections. We add an iterator method that re\u00adturns an iterator \nobject. This method requires a permission TThis to the receiver object this. We want that permission \nto be iuuUtable to enforce the common constraint (e.g. from Java and C#) that collections cannot be modi.ed \nwhile they are iterated over.6 As with getAny, we need the TElem permission to be conserved. The state \nIterator holds an iuuUtable reference to the collection that it is iterating over and the states Avail \nand End are representative of the states that an iterator can be in, as shown in Figure 1. The next() \nmethod of the Avail state changes the state of the iterator from Avail to End if there are no more elements \nin the collection, otherwise the state remains Available. Listing 5 shows how a client may use an iterator \nin Plaid. The usage of the iterator relies on the current state of the variable i. We only call i.next() \nafter checking if i is in the Avail state by using the keyword instate (similar to 6 of course, we want \nto regain a unique permission to the collection after iteration so we can modify it at that point. Our \nsolution to this problem is outlined in [Bierhoff 2006]. state Collection { ... <TThis extends iuuUtable \nCollection<conserved TElem>> pUblic Iterator<TElem> iterator() [TThis>>none]; } state Iterator { conserved \ntype TElem; final iuuUtable Collection<TElem> coll; } state Avail extends Iterator { TElem next() [Avail \n>> (Avail || End)]; } state End extends Iterator { } Listing 4. Iterators in Plaid Figure 1. Iterator \nstate machine Collection<String> c = ... Iterator<String> i = c.iterator(); while(i instate Avail) { \nString o = i.next(); } Listing 5. Iterator client code in Plaid instanceof in Java). 4. Typestate-Oriented \nDesign: Interactors Files, collections, and interators make good explanatory ex\u00adamples due to their familiarity, \nbut one may ask if the idea of states applies in other domains, a question we investigate here.  Figure \n2. Interactor state diagram. state Idle { void start() [Idle >> Running]; } state Running { void stop() \n[Running >> Idle]; void run(InputEvent e); } state MoveIdle extends Idle { GraphicalObject go; void start() \n[Idle >> Running] { this <-Running { void run(InputEvent e) { go.move(e.x,e.y); } void stop() [Running \n>> Idle] { this <-MoveIdle{} } } } } Listing 6. Interactor code in Plaid. Graphical user interfaces (GUIs), \nlike simulations, were one of the earliest applications of object-oriented program\u00adming [Kay 1993]. We \nbelieve typestate-oriented program\u00ad ming can extend the power of objects in this domain. To il\u00adlustrate \nthis, we discuss interactors, an in.uential concept in the GUI framework community. Interactors are reusable \nplu\u00adgins for graphical user interface frameworks that handle user input [Myers 1990]. Each interactor \nencapsulates a high\u00ad level interactive behavior (e.g selection, rotation) and ab\u00adstracts away underlying \nevents (e.g. mouse movement, key click). Interactor methods are called by the framework when user input \nevents are received. A developer adds an interac\u00adtor to her graphical user interface to easily add behavior \nto graphical elements. For example, let s say she is developing a drawing tool and wants all drawn objects \nto be movable. With interactors, she only needs to add a (probably prede\u00ad.ned) move interactor object \nto the window. The interactors we discuss in this example are modeled with the state diagram shown in \nFigure 2. All interactors are either idle or running. An idle interactor transitions to the running state \nwhen the start method is called, and the stop method causes the opposite transition. The code in Listing \n6 de.nes two states, Idle and Run\u00adning with unde.ned methods akin to Java interfaces. The start method \ntransitions the receiver from the Idle state to the Running state and stop acts correspondingly. The \nrun method does not transition the receiver. Instead, the interac\u00adtor acts on the graphical object for \nwhich it is responsible. An idle move interactor is represented as the MoveIdle state. This interactor \ncreates a running move interactor when started. The running interactor is in an anonymous substate of \nRunning. When the run method is called, the object in\u00advokes the move method on the associated graphical \nobject. The stop method transitions the object back to the MoveI\u00addle state. As mentioned earlier, the \nGUI framework calls the appro\u00adpriate interactor methods in response to events. For exam\u00adple, the run \nmethod of a move interactor is called when the mouse moves. Notice that a call to the run method does \nnot change the interactor s state. Assume the framework stores the list of currently running interactors \nand passes incoming events to them. In Plaid, if the framework calls run on an in\u00adteractor, the framework \nis guaranteed to be able to call run again when the next event .res. In Java, on the other hand, a developer \nwho writes a new interactor might erroneously create a run method that stops the interactor under certain \nconditions. In that case the Java framework would have to either perform a dynamic state check before \nevery call to the run method, or throw an exception, neither of which is de\u00adsirable. 5. Challenges In \norder to further investigate the typestate-oriented pro\u00adgramming paradigm, we are currently working on \nan inter\u00adpreter and typechecker for the Plaid language described in this paper.7 Many challenges remain, \nhowever, in making the vision described here a reality: Overhead Because we are documenting and tracking \nmore sophisticated properties in our system than is typical for type systems, a major open question is \nwhether the ap\u00adproach will be practical, or whether the conceptual over\u00adhead or the overhead of declaring \nour permissions will be too high. It is promising that the examples in this paper are not substantially \nmore complex than the equivalent Java code. Sharing We brie.y described the challenges of tracking ob\u00adject \nstate for shared permissions. Prior work has shown that ideas like state guarantees and dynamic state \ntest functions can provide great leverage, but we expect we will need new ideas in this area as well. \nExperience will show whether it is feasible to do the kind of reasoning envisioned in this proposal on \nordinary code. Extensions The language described here is very simple. While we hope Plaid remains straightforward, \nnew fea\u00adtures will be needed to make the language usable in in\u00addustrial practice. Some of these will \npresent challenges; for example, will adding concurrency make it more dif\u00ad.cult to track typestate? At \nthe same time, we hope that 7 Available at http://www.plaid-lang.org/  the ideas in Plaid will provide \nsynergies as well. For ex\u00adample, our companion Onward! paper examines how the kind of permissions used \nhere could make concurrency easier and safer [Stork et al. 2009]. 6. Conclusion This paper presented \na new paradigm, typestate-oriented programming, which introduces states as .rst-class abstrac\u00adtions for \ndescribing object interfaces and representations. In\u00adterfaces can more directly express, and the type \nsystem can enforce, constraints that are only implicit in most object\u00adoriented languages, such as when \nit is legal to read from a .le or call next on an iterator. The representation of ob\u00adjects can change \nin a natural way when their states do, for example allowing an OpenFile to hold a low-level .le re\u00adsource \nthat is not present in closed .les. By integrating states into the language, we can provide this additional \nexpressive power while minimizing added complexity, for example by using a single parameterization mechanism \nrather than one each for states, permissions, and types. Our Interactors ex\u00adample demonstrates that the \nidea of states is not speci.c to common library abstractions like .les and collections, but applies in \nGUI frameworks (and we expect other domains) as well. Much work remains to be done before making the \nvi\u00adsion of typestate-oriented programming a practical reality, and we are actively investigating both \nthe theoretical under\u00adpinnings of the paradigm and the practical tradeoffs involved in building a real \nlanguage, Plaid. However, we believe that states are a fundamental programming abstraction, and that \nthe future of direct language support for states is bright. Acknowledgments This work was supported in \npart by DARPA grant #HR0011\u00ad0710019, NSF grants CCF-0546550 and CCF-0811592, and Army Research Of.ce \ngrant number DAAD19-02-1-0389 entitled Perpetually Available and Secure Information Sys\u00adtems. We thank \nEric Tanter and the Plaid group for their helpful feedback on earlier versions of this paper. References \nAndi Bejleri, Jonathan Aldrich, and Kevin Bierhoff. Ego: Control\u00adling the Power of Simplicity. In Proc. \nFoundations of Object-Oriented Languages, 2006. Lorenzo Bettini, Sara Capecchi, and Ferruccio Damiani. \nA Mecha\u00adnism for Flexible Dynamic Trait Replacement. In Proc. Formal Techniques for Java-like Programs, \n2009. Kevin Bierhoff. Iterator Speci.cation with Typestates. In Proc. Speci.cation and Veri.cation of \nComponent-Based Systems, 2006. Kevin Bierhoff and Jonathan Aldrich. Modular Typestate Checking of Aliased \nObjects. In Proc. Object-Oriented Programming, Systems, Languages, and Applications, 2007. Kevin Bierhoff, \nNels E. Beckman, and Jonathan Aldrich. Practical API Protocol Checking with Access Permissions. In Proc. \nEuropean Conference on Object-Oriented Programming, 2009. Eric Bodden, Laurie Hendren, Patrick Lam, Ondrej \nLhotak, and Nomair A. Naeem. Collaborative Runtime Veri.cation with Tracematches. Oxford Journal of Logics \nand Computation, 2008. Lera Boroditsky. How Does Language Shape the Way We Think? In Max Brockman, editor, \nWhat s Next? Dispatches on the Fu\u00adture of Science, pages 116 129. Vintage, 2009. Ole-Johan Dahl and Kristen \nNygaard. SIMULA: an ALGOL-based Simulation Language. Communications of the ACM, 9(9):671 678, 1966. Robert \nDeline and Manuel Fahndrich. Typestates for Objects. In Proc. European Conference on Object-Oriented \nProgramming, 2004. Sophia Drossopoulou, Ferruccio Damiani, Mariangiola Dezani-Ciancaglini, and Paola \nGiannini. Fickle: Dynamic Object Re-classi.cation. In Proc. European Conference on Object-Oriented Programming, \n2001. Stephen J. Fink, Eran Yahav, Nurit Dor, G. Ramalingam, and Em\u00admanuel Geay. Effective Typestate \nVeri.cation in the Presence of Aliasing. Transactions on Software Engineering and Methodol\u00adogy, 17(2), \n2008. Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns: Elements of Reusable \nObject-Oriented Soft\u00adware. Addison-Wesley, 1995. David Harel. Statecharts: A Visual Formalism for Complex \nSys\u00adtems. Science of Computer Programming, 8(3):231 274, 1987. Carl Hewitt, Peter Bishop, and Richard \nSteiger. A Universal Mod\u00adular Actor Formalism for Arti.cial Intelligence. In Proc. Inter\u00adnational Joint \nConference on Arti.cial Intelligence, 1973. Alan C. Kay. The Early History of Smalltalk. SIGPLAN Notices, \n28(3), 1993. Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. The De.nition of Standard ML \n(Revised). MIT Press, 1997. Brad A. Myers. A New Model for Handling Input. ACM Transac\u00adtions on Information \nSystems, 8(3):289 320, 1990. Barbara Pernici. Objects with Roles. In Proc. Conference on Of.ce Information \nSystems, 1990. Asher Sterkin. State[chart]-Oriented Programming. In Proc. Multi\u00adparadigm Programming \nwith Object-Oriented Languages, 2008. Sven Stork, Paulo Marques, and Jonathan Aldrich. Concurrency by \nDefault: Using Permissions to Express Data.ow in Stateful Programs. In Proc. Onward!, 2009. Robert E \nStrom and Shaula Yemini. Typestate: A Programming Language Concept for Enhancing Software Reliability. \nIEEE Transactions on Software Engineering, 12(1):157 171, 1986. Antero Taivalsaari. Object-Oriented Programming \nwith Modes. Journal of Object-Oriented Programming, 6(3):25 32, 1993. David Ungar and Randall B. Smith. \nSelf: The Power of Simplicity. In Proc. Object-Oriented Programming, Systems, Languages, and Applications, \n1987.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Objects model the world, and state is fundamental to a faithful modeling. Engineers use state machines to understand and reason about state transitions, but programming languages provide little support for reasoning about or implementing these state machines, causing software defects and lost productivity when objects are misused.</p> <p>We propose Typestate-Oriented Programming as a natural extension to the object paradigm, where objects are modeled not just in terms of classes, but in terms of changing states. Each state may have its own representation and methods which may transition the object into a new state. A flow-sensitive, permission-based type system helps developers track which state objects are in. First-class typestates are a powerful abstraction that will help developers model and reuse objects more efficiently and correctly.</p>", "authors": [{"name": "Jonathan Aldrich", "author_profile_id": "81100454133", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1728376", "email_address": "", "orcid_id": ""}, {"name": "Joshua Sunshine", "author_profile_id": "81436601093", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1728377", "email_address": "", "orcid_id": ""}, {"name": "Darpan Saini", "author_profile_id": "81436596600", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1728378", "email_address": "", "orcid_id": ""}, {"name": "Zachary Sparks", "author_profile_id": "81444605838", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1728379", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640073", "year": "2009", "article_id": "1640073", "conference": "OOPSLA", "title": "Typestate-oriented programming", "url": "http://dl.acm.org/citation.cfm?id=1640073"}