{"article_publication_date": "10-25-2009", "fulltext": "\n @Composite Macro Annotations for Java Andrew Phillips qrmedia 25 Stanmore Gardens Richmond, Surrey \nTW9 2HN; UK aphillips@qrmedia.com Abstract Annotations have developed into one of Java s central features, \ndriving many popular frameworks. However, they are completely static and do not conform to OO principles. \n@Composite attempts to address this by adding composition, encapsulation and poly\u00admorphism to annotations, \nadding flexibility and helping to avoid repetition. Categories and Subject Descriptors D.3.3 [Programming \nLanguages]: Language Constructs and Features classes and objects General Terms Design, Experimentation, \nLanguages. Keywords Java, frameworks, annotations, OO principles, com\u00adposition 1. Introduction Since \ntheir introduction in Java 5, annotations have grown from a useful addition into one of the central features \nof present-day enterprise Java development, driving many of the popular frame\u00adworks. Being completely \nstatic and fixed at compile-time, how\u00adever, they do not conform to any OO principles: encapsulation, \npolymorphism etc. Instead, developers must repeat groups of annotations JPA annotations being a good \nexample leading to all the mainte\u00adnance problems this involves. Further, annotation values are fixed \nin the source code and are not externalizable in any way; a change to a database naming convention will \nrequire all annotated entity classes to be updated and the application recompiled. To address these issues, \n@Composite introduces composite or macro annotations, allowing developers to define frequently\u00adused groups \nof annotations in one place. Furthermore, the annota\u00adtion values returned can be generated dynamically, \nallowing changes to be made without requiring rebuilds and deployments from source. 2. Approach @Composite \nallows the user to define composite or macro an\u00adnotations, that are unpacked at runtime into their constituent \ncomponents. These can be defined statically or provided at run\u00adtime by a factory. Copyright is held by \nthe author/owner(s). OOPSLA 2009 October 25-29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10. \n The implementation does not involve bytecode instrumenta\u00adtion or other manipulations of general Java \nannotation reflection. Rather, a dedicated AnnotatedElements interface is queried to retrieve the correct \ncomponents of composite annotations. Anno\u00adtatedElements transparently supports the general Java annota\u00adtion \nreflection methods, so that existing annotations can be accessed without change. Regular and composite \nannotations can be mixed. 2.1 Composite Annotations Composite annotations are normal Java annotations, \ncertain of whose members are the leaf elements to which the composite unpacks . Composite annotations \nmay also contain other mem\u00adbers whose values are available for the dynamic generation of leaves. 2.2 \nLeaf Annotations Leaf annotations are annotation-typed members of a composite annotation. The leaf value \nreturned when the composite is queried can be static simply the value of the leaf member or dynamic, \nin which case a user-configured factory class is called, whose result is returned.  3. Usage 3.1 Guidelines \n@Composite requires annotation reflection to be done via the AnnotatedElements interface. Applications \nmust thus be writ\u00adten to use this interface for annotation reflection, in place of the \"standard\" Class.getAnnotation(...) \nmethods. Of course, all regular annotations are transparently available via this inter\u00adface. One of the \neffects of this is that @Composite should not be used to provide annotations which are used by Java itself, \ne.g. @Target or @Retention, as these won't be visible to the compiler.  3.2 Restrictions A fundamental \nprinciple of @Composite is that it should not al\u00adlow developers to work around restrictions on the use \nof \"regular\" annotations, thereby ensuring the semantics of Java annotations remain consistent. This \nmeans that, amongst others: There may also only be one leaf annotation of a given type per composite. \n  Figure 1. Definition of a composite annotation. The target of a leaf annotation must match that of \nthe com\u00adposite annotation in which it is declared.  There may not be more than one annotation of the \nsame type on a given element, whatever the regular and composite an\u00adnotations on that element.   3.3 \nValidation @Composite includes a Java 6 annotation processor that validates the declaration and usage \nof composite annotation, failing the compilation if composites are incorrectly used. This catches errors \nearly in the development cycle. The same validation checks are also applied on construction of the AtCompositeAnnotatedElements \nentry point, ensuring valid usage at runtime. 3.4 Example See Figure 0. Calling annotatedElements.getAnnotations( \nOtherAnnotatedAnnotation.class) on the example returns [@javax.annotation.Resource(shareable=true, mappedName=, \ndescription=, name=, type=class java.lang.Object, authenticationType=CONTAINER), @java.lang.annotation.Retention(value=CLASS), \n@java.lang.annotation.Target(value=[METHOD])] i.e. the leaves of the composite and the regular annotations. \n  4. Framework Integration 4.1 Spring The main AtCompositeAnnotatedElements entry point is a simple \nJava class that can be instantiated as a POJO, but can also be easily declared as a Spring bean that \nis available for injection. 4.2 Guice As a simple Java class, AtCompositeAnnotatedElements is easily \ninstantiated and injected using Guice.  5. Future Work Although the use of a dedicated interface seems \nappropriate to a concept as complex as annotations have become, investigating the possibility of retro-fitting \n@Composite by hooking into the regular Java annotation reflection is a natural choice. 5.1 AspectJ Interception \nOne possible method of integration would be via AspectJ point\u00adcuts. At first sight, the regular AnnotatedElement \ninterface would seem the correct target for this. Intercepting calls to the AnnotatedElement interface \nwill be the target of a upcoming investigation. Tapping into such a compara\u00adtively low level of the Java \nlanguage is anticipated to be challeng\u00ading. 5.2 Bytecode Instrumentation A standardized interface for \nclass transformation makes bytecode instrumentation another promising potential approach for adding @Composite \nto existing code. However, this is likely to limit the range of dynamism afforded by leaf annotation \nfactories, because, in the case of basic annotation replacement at least, non-static leaf annotation \nvalues need to be known at the moment of class trans\u00adformation.   Acknowledgments My thanks to Wilfred \nSpringer for suggesting this idea.  References [1] Phillips, A. @Composite - Macro annotations for Java. \n http://blog.xebia.com/2009/06/23/composite-macro-annotations-for\u00adjava (2009). [2] Springer, W. Macro \nAnnotations http://agilejava.com/blog/?p=162 (2008).  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Annotations have developed into one of Java's central features, driving many popular frameworks. However, they are completely static and do not conform to OO principles. @Composite attempts to address this by adding composition, encapsulation and polymorphism to annotations, adding flexibility and helping to avoid repetition.</p>", "authors": [{"name": "Andrew Phillips", "author_profile_id": "81546387556", "affiliation": "qrmedia, Richmond, United Kingdom", "person_id": "P1728574", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640005", "year": "2009", "article_id": "1640005", "conference": "OOPSLA", "title": "@composite: macro annotations for Java C", "url": "http://dl.acm.org/citation.cfm?id=1640005"}