{"article_publication_date": "10-25-2009", "fulltext": "\n Dependable, Online Upgrades in Enterprise Systems Tudor Dumitra\u00b8s Carnegie Mellon University tudor@cmu.edu \n Abstract Software upgrades are unreliable, often causing downtime or data loss. I propose Imago, an \napproach for removing the leading causes of upgrade failures (broken dependencies) and of planned downtime \n(data migrations). While imposing a higher resource overhead than previous techniques, Imago is more \ndependable and easier to use correctly. Categories and Subject Descriptors K.6.3 [Management of Com\u00adputing \nand Information Systems]: Software Management General Terms Management, Reliability Keywords software \nupgrades, online upgrades, dependability, hid\u00adden dependencies, data migration 1. Introduction In the \npresence of new user requirements, modi.ed deployment en\u00advironments and bug .xes, enterprise software-systems \nmust evolve continuously. Aside from the known challenges of software evolu\u00adtion [4], a large body of \nanecdotal evidence suggests that the up\u00ad grade procedures used, in practice, for accomplishing the evolution \nare failure-prone and often cause downtime, data corruption or latent errors. I present Imago,1 a mechanism \nfor improving the availability of a system-under-upgrade in the fault-free case by performing an online \nupgrade and in the faulty case by isolating the new version from the upgrade operations and by performing \nan atomic upgrade, end-to-end. While current fault-tolerance mechanisms focus almost entirely on responding \nto, avoiding, or tolerating unexpected faults or secu\u00adrity violations, system unavailability is usually \nthe result of planned events, such as upgrades. A 2007 survey concluded that, on average, 8.6% of upgrades \nfail, with some system administrators reporting failure rates up to 50% [2]. The survey identi.ed broken \ndependen\u00ad cies and altered system-behavior as the leading causes of upgrade failure, followed by bugs \nin the new version. This suggests that most upgrade failures are not due to software defects, but to \nfaults that af\u00adfect the upgrade procedure. Furthermore, even successful upgrades often require planned \ndowntime for changing the data schema or for migrating to a different data store. Because some conversions \nare dif\u00ad.cult to perform on the .y, in the face of live workloads, and owing to concerns about overloading \nthe production system, complex data mi\u00adgrations currently impose downtime on upgrade. Such planned out\u00ad \n1 The imago is the .nal stage of an insect or animal that undergoes a meta\u00admorphosis, e.g., a butter.y \nafter emerging from the chrysalis. Copyright is held by the author/owner(s). OOPSLA 2009, October 25 \n29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10. ages typically last from tens of hours \nto several days, i.e., twice as long as unplanned ones. Previous research has concentrated on performing \nupgrades in\u00adplace [2, 6], which requires tracking the complex dependencies among the distributed components \nof the version that is already de\u00adployed, and on supporting mixed versions [1, 5, 6], which interact \nand synchronize their states in the presence of a live workload. En\u00adsuring the correctness of mixed-version \ninteractions requires manual assistance from the programmer [1, 6] (e.g., establishing constraints to \nprevent old code from accessing new data [6]). Because some de\u00ad pendencies cannot be inferred automatically, \nupgrading approaches based on dependency-tracking ultimately rely on a time-intensive and error-prone \nmanual process (e.g., an in-depth pointer analy\u00adsis [5, 6]), to understand the nature and depth of the \ndependency chain. Moreover, the problem of resolving the dependencies of a component before deployment \nis NP-complete. This suggests that, because of the increasing complexity of enterprise systems, upgrad\u00ading \napproaches that rely on tracking dependencies could become computationally infeasible in the future. \nBecause of these fundamental limitations, industry best-practices recommend rolling upgrades, which upgrade-and-reboot \none node at a time, in a wave rolling through the distributed system. This in-place, mixed-version approach \nis believed to reduce the risks of upgrading because localized failures might not affect the entire distributed \nsystem [7, 8]. However, recent commercial products for rolling upgrades do not guarantee that the interactions \namong mixed versions are safe and leave these concerns to the application develop\u00aders [8]. Through two \nempirical studies, I show that rolling upgrades (i) are failure-prone because the upgrade is not an \natomic opera\u00adtion and it risks breaking hidden dependencies in the system-under\u00adupgrade and (ii) do \nnot support the data migrations required for upgrading a popular Internet service. 2. Goal statement \nI propose to improve the dependability of enterprise upgrades by re\u00admoving the leading cause of upgrade \nfailures broken dependencies and by providing a solution for the leading cause of planned down\u00adtime \n data migrations. A dependable, online upgrade should have three properties: \u00b7 Isolation: the upgrade \noperations must not change, remove, or affect in any way the dependencies of the old version (including \nits performance, con.guration settings and ability to access the data objects). \u00b7 Atomicity: at any \ntime, the clients of the system-under-upgrade must access the full functionality of either the old or \nthe new versions, but not both. The end-to-end upgrade must be an atomic operation. \u00b7 Fidelity: the \nupgrade testing must reproduce realistically the conditions of the deployment environment.  The isolation \nproperty provides an alternative to tracking dependen\u00adcies. By accessing the old version in a non-intrusive, \nread-only man\u00adner, I avoid breaking hidden dependencies during the upgrade. The atomicity and .delity \nproperties imply that the system must not in\u00adclude mixed, interacting versions, which synchronize their \nstates in the back-end and exhibit emerging behaviors that are dif.cult to val\u00adidate through of.ine testing. \nThese properties enable long-running data migrations in the background, during an online upgrade, as \nthe new version is inactive and does not need to be in a consistent state until the atomic switchover. \nMoreover, because it does not require correctness constraints for the mixed-version interactions or knowl\u00adedge \nof the old version s dependencies, this approach reduces the manual interventions needed for preparing \nthe upgrade and is easier to use than the current techniques.  These bene.ts come at a cost. For instance, \nin many cases, guar\u00adanteeing the isolation property requires additional hardware and stor\u00adage resources. \nThe high-level goals of my research are to study these trade-offs and to evaluate how close can we get \nto the zero-downtime ideal. Non-goals. My research does not aim to provide support for minor upgrades, \nsuch as .ne-grained bug .xes or security patches, to per\u00adform upgrades in-place, without the need for \nadditional resources, or to eliminate upgrade failures that are due to software defects. 3. Technical \napproach Imago is a prototype that implements the isolation, atomicity and .delity properties for enterprise-system \nupgrades. Feasibility study. To understand why upgrades fail, I analyze data from three independent sources \n[3]: a user study of system adminis\u00ad tration tasks in an e-commerce system, a survey of database admin\u00adistrators \nand a .eld study of bug reports for the Apache web server. This analysis includes procedural and con.guration \nerrors that oc\u00adcur during upgrades and excludes software defects. 85% of the faults analyzed break a \nhidden dependency (e.g., shared-library con.ict, wrong con.guration, database-schema mismatch). Using \nstatistical cluster-analysis, I establish an upgrade-centric fault model with four categories: (1) simple \ncon.guration or procedural errors (e.g. typos); (2) semantic con.guration errors (e.g. misunderstood \neffects of pa\u00adrameters); (3) broken environmental dependencies (e.g. library or port con.icts); and (4) \nerrors that render the persistent-data partially unavailable. These upgrade faults cause outages or degrade \nthe per\u00adformance and cannot be easily masked using existing techniques. I also study the upgrade history \nof Wikipedia, one of the ten most popular websites to date, in order to determine the common reasons \nfor planned downtime. Incompatible changes to the database schema (e.g. dropping/renaming tables) prevent \nrolling upgrades and require upgrading the schema and the business logic in an atomic step, in order \nto avoid Type 4 upgrade faults. Long-running data conversions compete with the live workload and might \noverload the database. Data dependencies (e.g., resulting from table joins) are hard to syn\u00adchronize \nin response to updates issued by the live workload. Because of these reasons, 50 out of the 55 possible \nupgrades of Wikipedia s business logic would require planned downtime. Dependable, online upgrades with \nImago. Imago achieves the iso\u00adlation property by installing the new version in a parallel universe a \nlogically distinct collection of resources, realized either using additional hardware or through virtualization. \nWhile the old version continues to service the live workload, Imago opportunistically trans\u00adfers the \npersistent data into the new version. Imago reads the old version s data-store without locking objects \nand regulates its data\u00adtransfer rate in order to avoid interfering with the client requests. Imago intercepts \nthe live-request .ow at two points in the old ver\u00adsion: the ingress point, which receives requests from \nthe live version (e.g. the front-end proxy), and the egress point, which stores the per\u00adsistent data \n(e.g. the master database). The egress interceptor moni\u00adtors the data objects updated by the live workload \nand (re-)schedules them for transfer. The ingress interceptor implements the coordinated switchover to \nthe new version. Imago supports a series of iterative testing phases after completing the data-transfer, \nand it provides the opportunity for testing the new version online, using the live requests recorded \nby the ingress interceptor, before exposing the upgrade to the clients. After adequate testing, Imago \nswitches over to the new version, completing the upgrade as an atomic operation. Because it avoids overloading \nthe production system, Imago also enables the integration of long-running data conversions in an online \nupgrade. Imago requires additional resources only for implementing and test\u00ading the online upgrade, which \nsuggests that storage and compute cy\u00adcles could be leased, for the duration of the upgrade, from existing \ncloud-computing infrastructures in order to provide upgrades-as-a\u00adservice. Experimental evaluation. Fault-injection \nexperiments suggest that rolling upgrades are vulnerable to upgrade faults because they create system \nstates with mixed versions, where it is easy to break hidden dependencies. Contrary to the conventional \nwisdom, these faults can have a global impact on the system-under-upgrade, such as outages, throughput-or \nlatency-degradations, security vulnerabilities or latent errors. For instance, the database represents \na single point of failure for an in-place upgrade, and any Type 4 fault leads to an upgrade failure. \nIn contrast, Imago eliminates the single-points-of-failure for Types 1 4 of upgrade faults by avoiding \nan in-place upgrade and by isolating the old version from the upgrade operations. Imago is only vulnerable \nto latent errors that are introduced when con.guring the new version and that remain undetected during \ntesting. Compared with a rolling upgrade, Imago reduces the expected unavailability due to upgrade faults \n(result signi.cant at the p = 0.01 level). More\u00adover, Imago supports all the data migrations recorded \nin Wikipedia s upgrade history, without degrading the throughput or response time of the production system \nduring the upgrade. 4. Conclusions Using a novel, upgrade-centric fault model, I show that current ap\u00adproaches \nfor upgrading enterprise systems are failure-prone because the upgrade is not an atomic operation and \nbecause it risks breaking hidden dependencies among the distributed system-components. I present Imago, \nwhich performs upgrades dependably despite hidden dependencies in the system-under-upgrade. Additionally, \nImago sup\u00adports online upgrades with complex data migrations and allows test\u00ading the new version in its \noperational environment, without overload\u00ading the production system. Because it avoids dependency-tracking \nand mixed-version interactions, Imago will likely be easier to use correctly than existing techniques. \nReferences [1] C. Boyapati et al. Lazy modular upgrades in persistent object stores. In Object-Oriented \nPrograming, Systems, Languages and Applications, pages 403 417, Anaheim, CA, Oct 2003. [2] O. Crameri \net al. Staged deployment in Mirage, an integrated software upgrade testing and distribution system. In \nSymposium on Operating Systems Principles, pages 221 236, Stevenson, WA, Oct 2007. [3] T. Dumitra\u00b8s and \nP. Narasimhan. Why do upgrades fail and what can we do about it? In ACM/IEEE/IFIP Middleware Conference, \nUrbana Champaign, IL, Nov-Dec 2009. [4] T. Mens et al. Challenges in software evolution. In Workshop \non Principles of Software Evolution, pages 13 22, Lisbon, Portugal, Sep 2005. [5] L. Moser et al. Eternal: \nfault tolerance and live upgrades for distributed object systems. In Information Survivability Conference \nand Exposition, pages 184 196, Hilton Head, SC, Jan 2000. [6] I. Neamtiu, M. Hicks, G. Stoyle, and M. \nOriol. Practical dynamic software updating for C. In ACM Conference on Programming Language Design and \nImplementation, pages 72 83, Ottawa, Canada, Jun 2006. [7] Of.ce of Government Commerce. Service Transition. \nInformation Technology Infrastructure Library (ITIL). 2007. [8] Oracle Corporation. Rolling upgrades \nof stateful J2EE applications in Oracle Application Server. White Paper, Aug 2005.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Software upgrades are unreliable, often causing downtime or data loss. I propose Imago, an approach for removing the leading causes of upgrade failures (broken dependencies) and of planned downtime (data migrations). While imposing a higher resource overhead than previous techniques, Imago is more dependable and easier to use correctly.</p>", "authors": [{"name": "Tudor Dumitras", "author_profile_id": "81310501860", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1728546", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1639993", "year": "2009", "article_id": "1639993", "conference": "OOPSLA", "title": "Dependable, online upgrades in enterprise systems", "url": "http://dl.acm.org/citation.cfm?id=1639993"}