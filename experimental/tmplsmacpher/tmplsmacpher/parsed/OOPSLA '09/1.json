{"article_publication_date": "10-25-2009", "fulltext": "\n CZ: Multiple Inheritance Without Diamonds Donna Malayeri Jonathan Aldrich Carnegie Mellon University \nCarnegie Mellon University donna@cs.cmu.edu aldrich@cs.cmu.edu Abstract Multiple inheritance has long \nbeen plagued with the dia\u00admond inheritance problem, leading to solutions that restrict expressiveness, \nsuch as mixins and traits. Instead, we ad\u00address the diamond problem directly, considering two dif.\u00adculties \nit causes: ensuring a correct semantics for object ini\u00adtializers, and typechecking multiple dispatch \nin a modular fashion the latter problem arising even with multiple inter\u00adface inheritance. We show that \nprevious solutions to these problems are either unsatisfactory or cumbersome, and sug\u00adgest a novel approach: \nsupporting multiple inheritance but forbidding diamond inheritance. Expressiveness is retained through \ntwo features: a requires construct that provides a form of subtyping without inheritance (inspired by \nScala [40]), and a dynamically-dispatched super call similar to that found in traits. Through examples, \nwe illustrate that in\u00adheritance diamonds can be eliminated via a combination of requires and ordinary \ninheritance. We provide a sound for\u00admal model for our language and demonstrate its modularity and expressiveness. \nCategories and Subject Descriptors D3.3 [Programming Languages]: Language Constructs and Features General \nTerms Design, Languages Keywords Multiple inheritance, diamond problem, multi\u00admethods, modularity 1. \nIntroduction Single inheritance, mixins [12, 5, 24, 22, 4, 9], and traits [19, 23, 40] each have disadvantages: \nsingle inheritance re\u00ad stricts expressiveness, mixins must be linearly applied, and traits do not allow \nstate. Multiple inheritance is one solution to these problems, as it allows code to be reused along multi- \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n2009, October 25 29, 2009, Orlando, Florida, USA. Copyright c . 2009 ACM 978-1-60558-734-9/09/10. . . \n$10.00 ple dimensions. Unfortunately however, multiple inheritance poses challenges itself. There are \ntwo types of problems with multiple inheri\u00adtance: (a) a class can inherit multiple features with the \nsame name, and (b) a class can have more than one path to a given ancestor (i.e., the diamond problem \n, also known as fork\u00adjoin inheritance) [43, 46]. The .rst, the con.icting-features problem, can be solved \nby allowing renaming (e.g., Eiffel [32]) or by linearizing the class hierarchy [47, 46]. However, there \nis still no satisfactory solution to the diamond problem. The diamond problem arises when a class C inherits \nan ancestor A through more than one path. This is particularly problematic when A has .elds should C \ninherit multiple copies of the .elds or just one? Virtual inheritance in C++ is designed as one solution \nfor C to inherit only one copy of A s .elds [21]. But with only one copy of A s .elds, object initializers \nare a problem: if C transitively calls A s initial\u00adizer, how can we ensure that it is called only once? \nExisting solutions either restrict the form of constructor de.nitions, or ignore some constructor calls \n[39, 21]. There is another consequence of the diamond problem: it causes multiple inheritance to interact \npoorly with modu\u00adlar typechecking of multiple dispatch. Multiple dispatch is a very powerful language \nmechanism that provides direct support for extensibility and software evolution [14, 16]; for these reasons, \nit has been adopted by designers of new programming languages, such as Fortress [2]. Unfortu\u00ad nately \nhowever, modular multimethods are dif.cult to com\u00adbine with any form of multiple inheritance even restricted \nforms, such as traits or Java-style multiple interface inher\u00aditance. Previous work either disallows multiple \ninheritance across module boundaries, or burdens programmers by re\u00adquiring that they always provide (possibly \nnumerous) dis\u00adambiguating methods. To solve these problems, we take a different approach: while permitting \nmultiple inheritance, we disallow inher\u00aditance diamonds entirely. So that there is no loss of ex\u00adpressiveness, \nwe divide the notion of inheritance into two concepts: an inheritance dependency (expressed using a requires \nclause, an extension of a Scala construct [39]) and implementation inheritance (expressed through extends). \nThrough examples, we illustrate that programs that are ex\u00adpressed using diamond inheritance can be translated \nto a hierarchy that uses a combination of requires and extends, without the presence of diamonds. As \na result, our language, CZ for cubic zirconia retains the expressiveness of dia\u00admond inheritance.  We \nargue that a hierarchy with multiple inheritance is conceptually two or more separate hierarchies. These \nhier\u00adarchies represent different dimensions of the class that is multiply inherited. We express dependencies \nbetween these dimensions using requires, and give an extended example of its use in Sect. 5. Our solution \nhas two advantages: .elds and multiple in\u00adheritance (including initializers) can gracefully co-exist, \nand multiple dispatch and multiple inheritance can be combined. To achieve the latter, we make an incremental \nextension to existing techniques for modular typechecking of multiple dispatch.1 An additional feature \nof our language is a dynamically\u00addispatched super call, modelled after trait super calls [19]. When a \ncall is made to A.super. f () on an object with dy\u00adnamic type D, the call proceeds to f de.ned within \nD s immediate superclass along the A path. With dynamically\u00addispatched super calls and requires, our \nlanguage attains the expressiveness of traits while still allowing classes to inherit state. We have \nformalized our system as an extension of Feath\u00aderweight Java (FJ) [28] (Sect. 8) and have proved it sound \n[31]. Contributions: The design of a novel multiple inheritance scheme2 that solves (1) the object initialization \nproblem and (2) the modular typechecking of multimethods, by forbidding diamond inheritance (Sections \n2 and 4).  Generalization of the requires construct and integration with dynamically-dispatched super \ncalls (Sect. 6).  Examples that illustrate how a diamond inheritance scheme can be converted to one \nwithout diamonds (Sec\u00adtions 3 and 5).  Examples from actual C++ and Java programs, illustrat\u00ading the \nutility of multiple inheritance and inheritance di\u00adamonds (Sect. 7).  A formalization of the language, \ndetailed argument of modularity (Sect. 8), and proof of type safety.  An implementation of a typechecker \nfor the language, as an extension of the JastAddJ Java compiler [20].  1 For simplicity and ease of \nunderstanding, our formal system only al\u00adlows dispatch on a method s receiver and its .rst argument, \ncorresponding to double dispatch. The system can be easily generalized to n-argument multimethods, as \nall interesting typechecking issues also arise in the two\u00adargument case. See Sect. 8 for further details. \n2 This is a revised and expanded version of a paper presented at the FOOL 09 workshop [30]. (FOOL has \nno archival proceedings and is not in\u00ad tended to preclude later publication.) The main changes are the \ninclusion of multimethods rather than external methods and a new section on real-world examples (Sect \n7). Figure 1. An inheritance diamond. Italicized class names indicate abstract classes. 2. Object Initialization \nTo start with, diamond inheritance raises a question: should class C with a repeated ancestor A have \ntwo copies of A s instance variables or just one i.e., should inheritance be tree inheritance or graph \ninheritance [13]? As the for\u00ad mer may be modelled using composition, the latter is the desirable semantics; \nit is supported in languages such as Scala, Eiffel, and C++ (the last through virtual inheritance) [39, \n32, 21]. Unfortunately, the object initialization problem occurs in this semantics, depending how and \nwhen the su\u00adperclass constructor or initializer is called [47, 46]. The Problem. To illustrate the problem, \nconsider Fig\u00adure 1, which shows a class hierarchy containing a di\u00adamond. Suppose that the Stream superclass \nhas a con\u00adstructor taking an integer, to set the size of a buffer. InputStream and OutputStream call \nthis constructor with dif\u00adferent values (1024 and 2048, respectively). But, when cre\u00adating an InputOutputStream, \nwith which value should the Stream constructor be called? Moreover, InputStream and OutputStream could \neven call different constructors with dif\u00adfering parameter types, making the situation even more un\u00adcertain. \nPrevious Solutions. Languages that directly attempt to solve the object initialization problem include \nEiffel [32], C++ [21], Scala [39] and Smalltalk with stateful traits [8]. In Eiffel, even though (by \ndefault) only one instance of the repeatedly inherited class is included (e.g., Stream), when constructing \nan InputOutputStream, the Stream con\u00adstructor is called twice. This has the advantage of simplicity, \nbut unfortunately it does not provide the proper semantics; Stream s constructor may perform a stateful \noperation (e.g., allocating a buffer), and this operation would occur twice. In C++, if virtual inheritance \nis used (so that there is only one copy of Stream), the constructor problem is solved as follows: the \ncalls to the Stream construc\u00adtor from InputStream and OutputStream are ignored, and InputOutputStream \nmust call the Stream constructor explic\u00aditly.3 Though the Stream constructor is called only once, this \nawkward design has the problem that constructor calls are 3 Since there is no default Stream constructor, \nthis call cannot be automati\u00adcally generated.  ignored. The semantics of InputStream may require that \na particular Stream constructor be called, but the language se\u00admantics would ignore this dependency by \nbypassing the con\u00adstructor call. Scala provides a different solution: trait constructors may not take \narguments. (Scala traits are abstract classes that may contain state and may be multiply inherited.) \nThis ensures that InputStream and OutputStream call the same super-trait constructor, causing no ambiguity \nfor InputOutputStream. Though this design is simple and elegant, it restricts ex\u00adpressiveness (in fact, \nthe Scala team is currently seeking a workaround to this problem [50]). Smalltalk with stateful traits \n[8] does not contain con\u00ad structors, but by convention, objects are initialized using an initialize message. \nUnfortunately, this results in the same se\u00admantics as Eiffel; here, the Stream constructor would be called \ntwice [7]. The only way to avoid this problem would be to always de.ne a special initializer that does \nnot call the superclass initializer. Requiring that the programmer de.ne such a method essentially means \nthat the C++ solution must be hand-coded. Aside from being tedious and error-prone, this has the same \ndrawbacks as the C++ semantics. Mixins and traits do not address the object initialization problem directly, \nbut instead restrict the language so that the problem does not arise in the .rst place. We compare CZ \nto each of these designs in Sect. 3.2. 3. An Overview of CZ This section describes the CZ language design \nat a high level, including a description of how CZ addresses the object initialization problem and a \ncomparison to related language designs. 3.1 CZ Design CZ s design is based on the intuition that there \nare relation\u00adships between classes that are not captured by inheritance, and that if class hierarchies \ncould express richer intercon\u00adnections, inheritance diamonds need not exist. Suppose the concrete class \nC extends A. As noted by Sch\u00e4rli et al., it is bene.cial to recognize that C serves two roles: (1) it \nis a generator of instances, and (2) it is a unit of reuse (through subclassing) [44]. In the .rst role, \ninheritance is the imple\u00ad mentation strategy and may not be omitted. In the second role, however, it \nis possible to transform the class hierarchy to one where an inheritance dependency between C and A is \nstated and where subclasses of C inherit from both C and A. The key distinguishing feature of CZ is this \nnotion of in\u00adheritance dependency, because while multiple inheritance is permitted, inheritance diamonds \nare forbidden. Consider the inheritance diamond of Fig. 1. To translate this hierarchy to CZ, InputStream \nwould be made abstract and its relationship to Stream would be changed from in\u00adheritance to an inheritance \ndependency, requiring that (con\u00adcrete) subclasses of InputStream also inherit from Stream. In other words, \nInputStream requires the presence of Stream in the extends clause of concrete subclasses, but it need \nnot ex\u00adtend Stream itself. Since InputStream is now abstract (mak\u00ading it serve only as a unit of reuse), \nit can be safely treated as a subtype of Stream. However, any concrete subclasses of InputStream (generators \nof instances), must also inherit from Stream. Accordingly, InputOutputStream must inherit from Stream \ndirectly. We have rei.ed this notion of an inheritance dependency using the requires keyword, a generalized \nform of a similar construct in Scala [40, 39].4 De.nition 3.1 (Subclassing). The subclass relation is \nde\u00ad.ned as the re.exive, transitive closure of the extends rela\u00adtionship. De.nition 3.2 (Requires). When \na class C requires a class B, we have the following:  C is abstract  C is a subtype of B (but not a \nsubclass)  Subclasses of C must either require B themselves (mak\u00ading them abstract) or extend B (allowing \nthem to be con\u00adcrete). This is achieved by including a requires B. or extends B. clause, where B. is \na subclass of B.  In essence, C requires B is a contract that C s concrete subclasses will extend B. \nThe revised stream hierarchy is displayed in Fig. 2. In the original hierarchy, InputStream served as \nboth genera\u00adtor of instances and a unit of reuse. In the revised hierar\u00adchy, we divide the class in two \none for each role. The class ConcreteInputStream is the generator of instances, and the abstract class \nInputStream is the unit of reuse. Accordingly, InputStream requires Stream, and ConcreteInputStream ex\u00adtends \nboth InputStream and Stream. The concrete class InputOutputStream extends each of Stream, InputStream, \nand OutputStream, creating a subtyping diamond, but not a subclassing diamond, as requires does not create \na subclass relationship. The code for InputStream will be essentially the same as before, except for \nthe call to its super constructor (explained further below). Because InputStream is a subtype of Stream, \nit may use all the .elds and methods of Stream, without having to de.ne them itself. Programmers may \nadd another dimension of stream behavior through additional abstract classes, for instance EncryptedStream. \nEncryptedStream is a type of stream, but it need not extend Stream, merely require it. Con\u00adcrete subclasses, \nsuch as EncryptedInputStream must in\u00adherit from Stream, which is achieved by extending ConcreteInputStream. \n(It would also be possible to extend Stream and InputStream directly.) 4 In Scala, requires is used to \nspecify the type of a method s receiver (i.e., it is a selftype), and does not create a subtype relationship. \nAs far as the Scala team is aware, our proposed use of requires is novel [50].  Figure 2. The stream \nhierarchy of Fig. 1, translated to CZ, with an encryption extension in gray. Italicized class names indicate \nabstract classes, solid lines indicate extends, and dashed lines indicate requires. The requires relationship \ncan also be viewed as declaring a semantic mixin if B requires A, then B is effectively stating that \nit is an extension of A that can be mixed-in to clients. For example, EncryptedStream is enhancing Stream \nby adding encryption. Because the relationship is explicitly stated, it allows B to be substitutable \nfor A. Using requires is preferable to using extends because the two classes are more loosely coupled. \nFor example, we could modify EncryptedInputStream to require InputStream (rather than extend ConcreteInputStream). \nA concrete sub\u00adclass of EncryptedInputStream could then also extend a sub\u00adclass of InputStream, such \nas BufferedInputStream, rather than extending InputStream directly. In this way, different pieces of \nfunctionality can be combined in a .exible man\u00adner while avoiding the complexity introduced by inheritance \ndiamonds. Object initialization. Because there are no inheritance di\u00adamonds, the object initialization \nproblem is trivially solved. Note that if class C requires A, it need not (and should not) call A s constructor, \nsince C does not inherit from A. In our example, InputStream does not call the Stream constructor, while \nConcreteInputStream calls the constructors of its su\u00adperclasses, InputStream and Stream. Thus, a subtyping \ndia\u00admond does not cause problems for object initialization. This may seem similar to the C++ solution; \nafter all, in both designs, InputOutputStream calls the Stream construc\u00adtor. However, the CZ design is \npreferable for two reasons: a) there are no constructor calls to non-direct superclasses, and, more importantly, \nb) no constructor calls are ignored. In the C++ solution, InputStream may expect a particular Stream \nconstructor to be called; as a result, it may not be properly initialized when this call is ignored. \nEssentially, CZ does not allow the programmer to create constructor depen\u00addencies that cannot be enforced. \nUsing requires . Introducing two kinds of class rela\u00adtionships raises the question: when should programmers \nuse requires, rather than extends? A rule of thumb is that requires should be used when a class is an \nexten\u00adsion of another class and is itself a unit of reuse. If nec\u00adessary, a concrete class extending \nthe required class (such as ConcreteInputStream) could also be de.ned to allow ob\u00adject creation. Note \nthat this concrete class de.nition would be trivial, likely containing only a constructor. On the other \nhand, when a class hierarchy contains multiple disjoint al\u00adternatives (such as in the AST example in \nthe next section), extends should be used; the no-diamond property is also a semantic property of the \nclass hierarchy in question. The above guideline may result in programmers de.ning more abstract classes \n(and corresponding concrete classes) than they may have otherwise used. However, some argue that it is \ngood design to make a class abstract whenever it can be a base class. This is in accordance with the \nde\u00adsign of classes in Sather [49], traits in Scala and Fortress [39, 2, 3], and the advice that non-leaf \nclasses in C++ be abstract [33]. In Sather and Fortress, for example, only ab\u00ad stract classes may have \ndescendants; concrete classes (called objects in Fortress) form the leaves of the inheritance hi\u00aderarchy \n[49]. Furthermore, a language could de.ne syntactic sugar to ease the task of creating concrete class \nde.nitions; we sketch such a design in Sect. 6.4.  3.2 Related Work Subtyping and subclassing. Since \nrequires provides sub\u00adtyping without subclassing, our design may seem to bear similarity to other work \nthat has also separated these two concepts (e.g. [27, 18, 49, 15, 29]). There is an important difference, \nhowever, regarding information hiding. In a lan\u00adguage that separates subclassing and subtyping, an inter\u00adface \ntype cannot contain private members; otherwise super\u00adclasses would be able to access private members \nde.ned in subclasses. Unfortunately, this restriction can be problem\u00adatic for de.ning binary methods \nsuch as the equals method; its argument type must contain those private members for the method be able \nto access them. But, for this type to con\u00adtain private members, it must be tied to a particular class \nimplementation, as only subclasses (as opposed to subtypes) should conform to this type. See Appendix \nA for an example illustrating this issue. This dif.culty does not arise when using requires, as it establishes \na stronger relationship than just subtyping; concrete subclasses must (directly or indirectly) inherit \nfrom the required class, as opposed to any class that pro\u00advides a particular interface. Therefore, Stream \nmay de\u00ad.ne an equals(Stream) method, and objects of type e.g. InputStream, OutputStream, or InputOutputStream \nmay be safely passed to this method. Since the private member is de\u00ad.ned in Stream and is only accessed \nby a method of Stream, this does not violate information hiding. Mixins. Mixins, also known as abstract \nsubclasses, pro\u00advide many of the reuse bene.ts of multiple inheritance while .tting into a single inheritance \nframework [12, 5, 24, 22, 4, 9]. While mixins allow de.ning state, they have the draw\u00ad backs that they \nmust be explicitly linearized by the pro\u00adgrammer and they cannot inherit from one another (though most \nsystems allow expressing implementation dependen\u00adcies, such as abstract members). If mixin inheritance \nwere allowed, this would be essentially equivalent to Scala traits, which do have the object initialization \nproblem. Addition\u00adally, the lack of inheritance has the consequence that mixins do not integrate well \nwith multiple dispatch; multiple dis\u00adpatch requires an explicit inheritance hierarchy on which to perform \nthe dispatch.  Traits. Traits were proposed as a mechanism for .ner\u00adgrained reuse, to solve the reuse \nproblems caused by mix\u00adins and multiple inheritance [19, 23, 40]. In particular, the linearization imposed \nby mixins can necessitate the de.ni\u00adtion of numerous glue methods [19]. This design avoids many problems \ncaused by multiple inheritance since .elds may not be de.ned in traits. Unfortunately, this restriction \nresults in other problems. In particular, non-private accessors in a trait negatively im\u00adpact information \nhiding: if a trait needs to use state, this is encoded using abstract accessor methods, which must then \nbe implemented by the class composed using the trait. Con\u00adsequently, it is impossible to de.ne state \nthat is private to a trait by de.nition, all classes reusing the trait can access this state. Additionally, \nintroducing new accessors in a trait results in a ripple effect, as all client classes must now pro\u00advide \nimplementations for these methods [8], even if there are no other changes. In contrast, CZ allows a class \nto multiply inherit other classes, which may contain state. In particular, a class may extend other concrete \nclasses, while in trait systems, only traits may be multiply inherited. Stateful traits. Stateful traits \n[8] were designed to address the aforementioned problems with stateless traits. But, as previously mentioned, \nthis language does not address the problem of a correct semantics for object initialization in the presence \nof diamonds. Additionally, stateful traits do not address the information hiding problem, as they have \nbeen designed for maximal code reuse. In this design, state is hidden by default, but clients can unhide \nit, and may have to resort to merging variables that are inherited from multiple traits. While this provides \na great deal of .exibility for trait clients, this design does not allow traits to de.ne private state. \n4. Modular Multiple Dispatch CZ also supports multiple dispatch, which we and others believe is more \nnatural and more expressive than single dispatch [14, 16, 15]. In fact, one common source of bugs in \nJava programs occurs when programmers expect static overloading to behave in a dynamic manner [26]. Multiple \ndispatch also avoids the extensibility problem inherent in the Visitor pattern, as well as the complexity \nintroduced by manual double dispatch. However, typechecking multiple dispatch in a modular fashion is \nvery dif.cult in the presence of any form of multiple inheritance precisely because of the diamond problem. \n4.1 The Problem To see why diamond inheritance causes problems, suppose we have the original diamond \nstream hierarchy, and we now de.ne a multimethod seek in a helper class (supposing that such functionality \ndid not already exist in the classes in question): class StreamHelper { void seek(Stream s, long pos) \n{ // default implementation: do nothing } void seek(Stream@InputStream is, long pos) { // seek if pos \n<= eofPos } void seek(Stream@OutputStream os, long pos) { // if pos > eofPos, .ll with zeros } } The \ndeclaration seek(Stream@InputStream, long) speci.es that the method specializes seek(Stream, long) for \nthe case that the .rst argument dynamically has type InputStream. Unfortunately, in the context of our \ndiamond hierarchy, this method de.nition is ambiguous what if we perform the call h.seek(new InputOutputStream(), \n1024)? Unfortu\u00adnately, it is dif.cult to perform a modular check to determine this fact. When typechecking \nthe de.nition of seek(), we cannot search for a potential subclass of both InputStream and OutputStream, \nas this analysis would not be modu\u00adlar. And, when typechecking InputOutputStream, we can\u00adnot search for \nmultimethods de.ned on both of its super\u00adclasses, as that check would not be modular, either. We pro\u00advide \na detailed description of the conditions for modularity in Sect. 8.1. It is important to note that this \nproblem is not con.ned to multiple (implementation) inheritance it arises in any scenario where an object \ncan have multiple dynamic types on which dispatch is performed. For instance, the problem appears if \ndispatch is permitted on Java interfaces, as in JPred [25], or on traits, as in Fortress [3, 2]. For \nthis reason, some languages restrict the form of dispatch to the single\u00adinheritance case; e.g., MultiJava \ndisallows dispatching on interfaces [16, 17].  4.2 Previous Solutions There are two main solutions \nto the problem of modular typechecking of multiple dispatch in the presence of mul\u00adtiple inheritance. \nThe .rst solution is simply to restrict ex\u00adpressiveness and disallow multiple inheritance across mod\u00ad \n Language Object initialization Multimethod ambiguity Eiffel repeat initialization C++ special constructor \nsemantics Scala no-arg constructors Fortress traits n/a disambiguating methods Stateful traits repeat \ninitialization Mixins linearization JPred n/a disambiguating methods Dubious n/a MI restrictions Table \n1. Summary of related work and solutions to the object initialization and modular multimethod problems. \nule boundaries; this is the approach taken by the System M type system for Dubious [37]. JPred [25] and \nFortress [3] take a different approach. The diamond problem arises in these languages due to multiple \ninterface inheritance and multiple trait inheritance, respec\u00adtively. In these languages, the typechecker \nensures that mul\u00adtimethods are unambiguous by requiring that the program\u00admer always specify a method \nfor the case that an object is a subtype of two or more incomparable interfaces (or traits). In our streams \nexample, the programmer would have to pro\u00advide a method like the following in the StreamHelper class \n(in JPred syntax): void seek(Stream s, long pos) when s@InputStream &#38;&#38; s@OutputStream (In Fortress, \nthe method would be speci.ed using intersec\u00adtion types.) Note that in both languages, this method would \nhave to be de.ned for every subset of incomparable types (that contains at least 2 members), regardless \nof whether a type like InputOutputStream will ever be de.ned. Even if two types will never have a common \nsubtype,5 the program\u00admer must specify a disambiguating method, one that perhaps throws an exception. \nThus, the problem with this approach is that the programmer is required to write numerous addi\u00adtional \nmethods exponential in the number of incomparable types some of which may never be called. JPred alleviates \nthe problem somewhat by providing syntax to specify that a particular branch should be preferred in the \ncase of an ambi\u00adguity, but it may not always be possible for programmers to know in advance which method \nto mark as preferred. Note that neither JPred interfaces nor Fortress traits may contain state and thus \nthe languages do not provide a solution to the object initialization problem; neither does Dubious, since \nit does not contain constructors. These solutions and the previously described related work are summarized \nin Table 1. 5 In Fortress, the programmer may specify that two traits are disjoint, mean\u00ading that there \nwill never be a subtype of both. To allow modular typecheck\u00ading, this disjoint speci.cation must appear \non one of the two trait de.nitions, which means that one must have knowledge of the other; consequently \nthis is not an extensible solution. 4.3 Multimethods in CZ To solve the problem of modular multiple \ndispatch, we use the same solution as for the object initialization prob\u00adlem: inheritance diamonds are \nforbidden, and requires is used as a substitute. An additional constraint is that a multimethod may only \nspecialize a method in a super\u00adclass, not a required class (i.e., specialization is based on subclassing, \nnot subtyping). So, in the CZ hierar\u00adchy of Fig. 2, the typechecker will signal an error, since the de.nitions \nseek(Stream@InputStream, long) and seek(Stream@OutputStream, long) are not valid specializa\u00adtions of \nseek(Stream, long). Let us suppose for a moment that all classes in Fig. 2 have been de.ned, except InputOutputStream. \nAccordingly, we would re-write the seek methods as follows: class StreamHelper { // helper methods void \nseekInput(InputStream s, long pos) { ... } void seekOutput(OutputStream s, long pos) { ... } // multimethods \nvoid seek(Stream s, long pos){ } void seek(Stream@ConcreteInputStream is, long pos) { seekInput(is, pos); \n} void seek(Stream@ConcreteOutputStream os, long pos) { seekOutput(os, pos); } } (Though these de.nitions \nare slightly more verbose than before, syntactic sugar could be provided, particularly for mapping multimethods \nto helper methods.) Note that the typechecker does not require that a method be provided for InputStream \n&#38;&#38; OutputStream, unlike JPred and Fortress. If a programmer now de\u00ad.nes InputOutputStream, but \ndoes not provide a new specialization for seek, the default implementation of seek(Stream) will be inherited. \nAn specialization for InputOutputStream can then be implemented, perhaps one that calls seekOutput(). \nNote that this override need not be de.ned in StreamHelper directly; the method may be de.ned in one \nof its subclasses. Here, it is of key importance that subclassing diamonds are disallowed; because they \ncannot occur, multimethods can be easily checked for ambiguities. Subtyping diamonds do not cause problems, \nas multimethod specialization is based on subclassing. Dispatch semantics. There are two dispatch semantics \nthat can be used for multimethods: asymmetric or symmet\u00adric. In asymmetric dispatching, the order of \narguments af\u00adfects dispatch. In particular, earlier arguments are treated as more important when selecting \nbetween equally speci.c methods. This semantics is used in a number of languages, such as Common Lisp \nand parasitic methods, among others [48, 41, 1, 11, 6].  Other languages employ the symmetric dispatch \nseman\u00adtics, where all arguments have equal priority in determin\u00ading method lookup [15, 45, 17, 36]. Some \nargue that sym\u00ad metric dispatch is more intuitive and less error-prone than asymmetric dispatch [17, \n36], though this form of dispatch adversely affects information hiding. In particular, a class may not \nhide the existence of a particular method special\u00adization; this information is needed to correctly perform \nam\u00adbiguity checking of subclasses [36]. For this reason, and to simplify the type system and method lookup \nrules, CZ mul\u00adtimethod dispatch is asymmetric. However, CZ is compati\u00adble with symmetric dispatch; a \nsymmetric-dispatch version of CZ would simply require additional (modular) checks on multimethod de.nitions. \nIncidentally, method lookup need not change, as these new ambiguity checks would ensure the same result, \nregardless of whether asymmetric lookup or symmetric lookup were used. Section 8 describes these issues \nin more detail. Fragments of CZ. Note that it would be possible to omit multimethods from the language \nand use the CZ design (as is) for only the object initialization problem. That is, our solution can be \nused to solve either the object initialization problem, the modular multimethod problem, or both. 5. \nExample: Abstract Syntax Trees Consider a simple class hierarchy for manipulating abstract syntax trees \n(ASTs), such as the one in Fig. 3. The original hierarchy is the one on the left, which consists of ASTNode, \nNum, Var, and Plus. An ASTNode contains a reference point\u00ading to its parent node, as indicated in the \n.gure. Each of the concrete subclasses of ASTNode implements its own version of the abstract ASTNode.eval() \nmethod. Suppose we wish to add debugging support to our AST, after the original hierarchy is de.ned. \nEach node now ad\u00additionally has a source location .eld, DebugNode.location. Debugging support, on the \nright side of the .gure, is es\u00adsentially a new dimension of AST nodes that has a depen\u00addency on ASTNode. \nWe express this using requires. Now, classes like DebugPlus can multiply inherit from ASTNode and DebugNode \nwithout creating a subclassing diamond. In particular, DebugPlus does not inherit two copies of the parent \n.eld, because DebugNode is a subtype, but not a sub\u00adclass, of ASTNode. Thus, the no-diamond property \nallows .elds and multiple inheritance to co-exist gracefully. In this example, each of these classes \nhas a method eval() which evaluates that node of the AST, as in the code in Fig. 4. Suppose we intend \nDebugNode to act as a generic wrap\u00adper class for each of the subclasses of ASTNode. This can be implemented \nby using a dynamically-dispatched super call of the form ASTNode.super.eval() after performing the debug-speci.c \nfunctionality (in this case, printing the node s string representation). The pre.x ASTNode.super means \nclass DebugNode requires ASTNode { ASTNode eval() { print(this.toString()); // dynamic super call return \nASTNode.super.eval(); } } class DebugPlus extends DebugNode, Plus { ASTNode eval() { // ordinary super \ncall return DebugNode.super.eval(); } } Figure 4. Implementing a mixin-like debug class using dynamically-dispatched \nsuper calls, and performing multi\u00admethod dispatch on the ASTNode hierarchy. .nd the parent class of the \ndynamic class of this along the ASTNode path. At runtime, when eval() is called on an in\u00adstance of DebugPlus, \nthe chain of calls proceeds as follows: DebugPlus.eval() . DebugNode.eval() . Plus.eval(). If the dynamically-dispatched \nsuper call behaved as an ordinary super call, it would fail, because DebugNode has no super\u00adclass. Each \nof the DebugNode subclasses implements its own eval() method that calls DebugNode.eval() with an ordinary \nsuper call. (This could be omitted if the language linearized method overriding based on the order of \ninheritance declara\u00adtions, such as in Scala traits.) Dynamic super calls are a gen\u00aderalization of ordinary \nsuper calls, when the quali.er class is a required class. Adding multimethods. Suppose that after we \nhave de\u00ad.ned these classes, we wish to add a new method that op\u00aderates over the AST. For instance, we \nmay want to check that variables are declared before they are used (assuming a variable declaration statement). \nSince CZ has multimethods, such a method defCheck() could be de.ned in a helper class, rather than in \nthe classes of the original hierarchy: class DefChecker { void defCheck(ASTNode n) { ... } void defCheck(ASTNode@Var \nv) { ... } void defCheck(ASTNode@Plus p) { ... } void defCheck(ASTNode@Num n) { ... } } Note that the \nprogrammer would only have to de.ne cases for ASTNode, Num, Var and Plus; she need not specify what method \nshould be called when an object has a combination of these types such a situation cannot occur (as there \nare no diamonds).  Figure 3. The AST node example in CZ. Abstract classes and abstract methods are \nset in italic. Discussion. The examples illustrate that subtyping allows substitutability; subclassing, \nin addition to providing inher\u00aditance, de.nes semantic alternatives that may not overlap (such as Num, \nVar and Plus in the example above). Because they do not overlap, we can safely perform an unambiguous \ncase analysis on them that is, multimethod dispatch. In other words, dispatch in our system is analogous \nto case\u00adanalyzing datatypes in functional programming (e.g. ML, Haskell). Alternative designs. Traits \ncould be used to express this example, but as previously mentioned (Sect. 3.2), the lack of state results \nin an information hiding problem with acces\u00adsors. Also, as we have noted, stateful traits do not address \nthe object initialization problem. Mixins could express some aspects of the class hierarchy for this \nexample, but as previously mentioned, subclassing or even subtyping cannot be speci.ed among (standard\u00adstyle) \nmixins [12, 24, 4]. For this reason, mixins do not integrate well with multimethods. For details on this \nissue, see [30]. Using Java-style single inheritance would be unwieldy. A forwarding pattern would have \nto be used, along with the de.nition of at least four new interfaces [30]. Additionally, accessors would \nhave to be public, since they would have to be de.ned in an interface (the only way to achieve any form \nof multiple inheritance in Java-like languages). Finally, the Visitor design pattern would have to be \nused in order to allow new operations to be de.ned. 6. CZ Design In this section, we give informal details \nof the typechecking rules in CZ, and provide an intuition as to why typechecking is modular. In Sect. \n8 we formalize CZ and provide a detailed argument showing its modularity. 6.1 Multiple Inheritance CZ \nplaces the following constraints on class de.nitions: C1. If a class C extends D1 and D2 then there must \nnot exist some E, other than Object, such that both D1 and D2 are subclasses of E (the no-diamond property). \nC2. If class C extends D1 and D2 and the unspecialized method m is de.ned or inherited by both D1 and \nD2 then C must also de.ne the unspecialized method m. Also, if method m with specializer B is de.ned \nor inherited by both D1 and D2, then C must also de.ne either (1) m with specializer B., where B is a \nsubclass of B., or (2) an unspecialized method m. Additionally, the calculus assumes an elaboration phase \nthat translates method names to quali.ed names, using the name of the class where the method was .rst \nde.ned; conse\u00adquently, methods have a unique point of introduction. That is, in the calculus, two classes \nonly share a method name if it exists in a common superclass or common required class. This convention \nprevents a name clash if two methods in un\u00adrelated classes A and B coincidentally have the same name \nand a third class inherits from both A and B.6 (Of course, an implementation of the language would have \nto provide a syntactic way for disambiguating methods that accidentally have the same name; this could \nbe achieved through rename directives, e.g., Eiffel [32], or by using quali.ed names, e.g., C# interfaces \nand C++.) We have already described the reason for condition C1, the no-diamond property. We make a special \ncase for the class Object the root of the inheritance hierarchy, since ev\u00adery class automatically extends \nit. (Otherwise, a class could never extend two unrelated classes the existence of Object would create \na diamond.7) Note that this does not result in the object initialization problem, because Object has \nonly a no-argument constructor. Also, this condition does not pre\u00adclude a class from inheriting from \ntwo concrete classes if this does not form a diamond. Condition C2 ensures that if a class C inherits \ntwo iden\u00adtical method de.nitions, either specialized or unspecialized, this will not lead to an ambiguity; \nin such a case, C must provide an overriding de.nition. 6 Incidentally, this is not the convention used \nin Java interfaces, but is that of C#. 7 An alternative design would be to make every abstract class \nimplicitly require Object and every concrete class implicitly extend Object. The prob\u00adlem with this design \nis that it would prevent a class from extending two concrete classes, as a diamond with Object at the \nroot would result.  6.2 Multiple Dispatch CZ allows methods to be specialized on a subclass of the \n.rst argument s class type. Any unspecialized method (i.e., an ordinary method) de.ned or inherited by \na class C may be specialized within C, provided the method s .rst argument type is not Object. In general, \ntypechecking multimethods has two components: exhaustiveness checking (i.e., the pro\u00advided cases provide \nfull coverage of the dispatch hierarchy) and ambiguity checking (i.e., when executing a given method \ncall, there is a unique most speci.c applicable method). Since the core calculus of CZ does not include \nabstract methods, exhaustiveness is automatically handled; we need only ensure there are no ambiguities. \n(Abstract methods are orthogonal to our considerations, as they are adequately handled by previous work \n[37, 16, 35].) We adapt previous techniques for ambiguity checking [37, 16, 35]: M1. A method Dm(A@Bx, \nDx) may only be de.ned if in class C if all of the following hold: 1. A .= Object 2. B .= A 3. B is \na subclass of A 4. a method Dm(A, D) is de.ned or inherited by C.  These conditions, together with \nwith C1 and C2, ensure the absence of ambiguity. In particular, since B must be a strict subclass of \nA, condition C1 ensures that if method m(A@B.) is de.ned or inherited by C, then either B . B. or B.. \nB (since A .= Object and inheritance diamonds are disallowed). Condition C2 ensures that if B = B., there \nexists a disambiguating de.nition m(A@B..) within class C, where B . B... Together, these properties \nensure that if a program typechecks, a unique most-speci.c applicable method always exists. Previous \nwork either disallowed inheritance across mod\u00adule boundaries [37] or did not permit interfaces to be \nspecial\u00ad izers [16]. In CZ, we can remove each of these restrictions, due to the absence of inheritance \ndiamonds. In Sect. 8, we describe a generalization of multimethods to the n-argument case and describe \nwhy this generalization does not introduce new typechecking issues. 6.3 Dynamically-Dispatched Super \nCalls As illustrated in Sect. 5, CZ includes dynamically\u00addispatched super calls. When A requires B (i.e., \nA is act\u00ading as a mixin extension of B), then within A, a call of the form B.super is dynamically resolved, \nsimilar to super calls in traits. Other super calls (i.e., those where the quali.er is a parent class) \nhave the same semantics as that of Java.  6.4 Discussion Extensions. External methods (also known as \nopen classes), could also be added to CZ, without sacri.cing mod\u00adular typechecking. External methods \nare more general than multimethods, since they allow new classes to override an existing external method. \nFor details on the typechecking is\u00adsues that arise, see our previous work [30]. It would also be possible \nto combine our solution with existing techniques for dealing with the object initializa\u00adtion and modular \nmultiple dispatch problems. A program\u00admer could specify that a class C, whose constructor takes no arguments, \nmay be the root of a diamond hierarchy. Then, we would use the Scala solution for ensuring that C s con\u00adstructor \nis called only once. To solve the multiple dispatch problem, if methods m(B) and m(B.) specialize m(C), \nthe typechecker would ensure that m contained a disambiguat\u00ading de.nition for (B . B.) the JPred and \nFortress solutions. Finally, the language could include syntactic sugar to ease the de.nition of concrete \nclasses. If C requires B, and both C and B have no-argument constructors, the compiler could automatically \ngenerate a class C$concrete that extends both C and B; programmers could then more easily de.ne multimethods \nthat dispatch on C$concrete. Encapsulation and the diamond problem. As noted by Snyder, there are two \npossible ways to view inheritance: as an internal design decision chosen for convenience, or as a public \ndeclaration that a subclass is specializing its superclass, thereby adhering to its semantics [47]. Though \nSnyder believes that it can be useful to use in\u00adheritance without it being part of the external interface \nof a class, we argue that the second de.nition of inheritance is more appropriate. In fact, if inheritance \nis being used merely out of convenience (e.g., Stack extending Vector in the Java standard library), \nthen it is very likely that compo\u00adsition is a more appropriate design [10]. For similar reasons, we do \nnot believe a language should allow inheritance with\u00adout subtyping e.g., C++ private inheritance as this \ncan al\u00adways be implemented using a helper class whose visibility is restricted using the language s module \nsystem. Nevertheless, if one takes the view that inheritance choices should not be visible to subclasses, \na form of the di\u00adamond problem can arise in CZ. In particular, suppose class D extends B and C, C extends \nA, and B extends Object a valid hierarchy (recall that condition C1 makes a special ex\u00adception for diamonds \ninvolving Object). Now suppose that B is changed to extend A, and the maintainer of B is unaware that \nclass D exists. Now A, B and C typecheck, but D does not. Thus, the use of inheritance can invalidate \nsubclasses, which violates Snyder s view of encapsulation. This situation highlights the fact that, in \ngeneral, requires should be favored over extends if a class is intended to be reused. 7. Real-World Examples \nIn this section, we present real-world examples (in both C++ and Java) that suggest that multiple inheritance, \nand diamond inheritance in particular, can be useful for code reuse. We also describe how these examples \ncan be expressed in CZ.  7.1 C++ Examples We examined several open-source C++ applications in a variety \nof domains and found many instances of virtual inheritance and inheritance diamonds. Here we describe \ninheritance diamonds in two applications: Audacity8 and Guikachu.9 Audacity. Audacity is a cross-platform \napplication for recording and editing sounds. One of its main storage ab\u00adstractions is the class BlockedSequence \n(not shown), which represents an array of audio samples, supporting operations such as cut and paste. \nA BlockedSequence is composed of smaller chunks; these are objects of type SeqBlock, depicted in Fig. \n5 (a). One subclass of SeqBlock is SeqDataFileBlock, which stores the block data on disk. One superclass \nof SeqDataFileBlock is ManagedFile, an abstraction for tempo\u00adrary .les that are de-allocated based on \na reference-counting scheme. Since both ManagedFile and SeqBlock inherit from Storable (to support serialization), \nthis forms a diamond with Storable at the top. This particular diamond can be easily re-written in CZ \n(Fig. 5 (b)), since the sides of the diamond (SeqBlock and ManagedFile) are already abstract classes. \n(Compare to the example in Fig. 2, where new concrete classes had to be de\u00ad .ned for the sides of the \ndiamond.) Here, we simply change the top two virtual inheritance edges to requires edges, and make SeqDataFileBlock \ninherit from Storable directly. This may even be a preferable abstraction; while in the original hierarchy \nSeqDataFileBlock is serializable by virtue of the fact that SeqBlock is serializable, in the new hierarchy \nwe are making this relationship explicit. Guikachu. Guikachu is a graphical resource editor for the GNU \nPalmOS SDK. It allows programmers to graph\u00adically manipulate GUI elements for a Palm applica\u00adtion in \nthe GNOME desktop environment. In this ap\u00adplication, we found 10 examples of diamonds that in\u00adcluded \nthe classes CanvasItem, WidgetCanvasItem, and ResizeableCanvasItem. CanvasItem is an abstract base class \nthat represents items that can be placed onto a canvas, while objects of type WidgetCanvasItem and ResizeableCanvasItem \nare a type of widget or are resizeable, respectively. Figure 6(a) shows two of these 10 diamonds, formed \nby TextFieldCanvasItem and PopupTriggerCanvasItem, re\u00adspectively. The hierarchy was likely designed this \nway be\u00adcause there exist GUI elements that have only one of the two properties. For instance, Graf.tiCanvasItem \nand LabelCanvasItem (not shown) are not resizeable, but they are widgets. In contrast, the class FormCanvasItem \n(not shown) is resizeable, but is not a widget. In this application, we also observed the use of the \nC++ virtual inheritance initializer invocation mecha\u00ad 8 http://audacity.sourceforge.net/ 9 http://cactus.rulez.org/projects/guikachu/ \nnism: TextFieldCanvasItem (for instance) directly calls the initializer of CanvasItem, its grandparent. \nAs previ\u00adously described, when initializing TextFieldCanvasItem, the initializer calls from WidgetCanvasItem \nand ResizeableCanvasItem to CanvasItem are ignored. In this application, the initializers happen to all \nperform the same operation, but this invocation semantics could introduce subtle bugs as the application \nevolves. The corresponding CZ class hierarchy is displayed in Fig. 6 (b); note its similarity to that \nof Fig. 5 (b). Essen\u00ad tially, the virtual inheritance is replaced with requires and each of the classes \nat the bottom of the diamond inherit from all three of WidgetCanvasItem, ResizeableCanvasItem, and CanvasItem. \nThe CZ design has the advantage that construc\u00adtor calls do not occur more than one level up the hierarchy, \nand no constructor calls are ignored. This example illustrates how a program could be trans\u00adlated from \nC++-style multiple inheritance to CZ-style. In particular, virtual inheritance would be replaced by requires, \nand new concrete classes would be de.ned as necessary (changing instantiations of the now-abstract class \nto instanti\u00adations of the new concrete class). Note that constructor calls can be easily generated for \nthe new concrete classes, as C++ requires a call from the bottom of the diamond to the top of the diamond \nwhen virtual inheritance is used (such a con\u00adstructor call would be necessary for the new concrete class, \nas it would directly extend the class at the top of the dia\u00admond). Discussion. It would be interesting \nto extend the C++ study and perform a more systematic study of the nature of inheritance diamonds, quantifying \nhow often new abstract classes would have to be de.ned (i.e., how often concrete classes appear on the \nsides of the diamond). One could also determine how often the initializer problem occurs in real code. \nHowever, note that the multimethod problem will always arise in a multiple inheritance situation, even \nif a program\u00admer never actually creates an inheritance diamond, and (as noted in Section 4) even if a \nlanguage includes the more be\u00ad nign feature of multiple interface inheritance (e.g., Java-like languages). \n 7.2 Java Example: Eclipse JDT The Eclipse JDT (Java Development Tools) is an example of where multiple \ninheritance could be useful for Java pro\u00adgrams. In the JDT, every AST node contains structural prop\u00aderties. \nA node s structural properties allow uniform access to its components. For example, DoStatement has 2 \n.elds of type StructuralPropertyDescriptor: EXPRESSION_PROP-ERTY and BODY_PROPERTY. To get the expression \nproperty of a DoStatement object, the programmer may call ds.getExpression() or ds.getStructuralProperty( \nDoStatement.EXPRESSION_ PROPERTY). Structural prop\u00ad  (a) (b) Figure 5. An inheritance diamond (a) in \nthe Audacity application, and (b) the re-written class hierarchy in CZ. Abstract classes are set in italic. \n (a) (b) Figure 6. Two inheritance diamonds in the Guikachu application (a) and re-written in CZ (b). \nAbstract classes are set in italic. erty descriptors are often used to specify how AST nodes change when \na refactoring is performed. Through inspection of the JDT code, we found that there was a great deal \nof duplication among the code for getting or setting a node property using the structural property descriptors. \nFor example, 19 AST classes (e.g., AssertStatement and ForStatement) have getExpression/setExpression \nproperties. As a result, in the method internalGetSetChildProperty (an abstract method of ASTNode), there \nare 19 duplications of the following code: if (property == EXPRESSION_PROPERTY) { if (get) { return getExpression(); \n} else { setExpression((Expression) child); return null; } } else if (property == BODY_PROPERTY) { ... \n// code for body property } } Additionally, there are duplicate, identical de.nitions of the EXPRESSION_PROPERTY \n.eld. Without a form of multiple inheritance, however, it is dif.cult to refac\u00adtor this code into a common \nlocation DoStatement, for example, already has the superclass Statement. With multiple inheritance, the \nprogrammer could create an abstract helper class ExprPropertyHelper that requires ASTNode. This new class \nwould contain the .eld def\u00adinition and an override of internalGetSetChildProperty. DoStatement would \nthen inherit from both Statement and ExprPropertyHelper and would have the following body for internalGetSetChildProperty: \nif (property == BODY_PROPERTY) { ... // code for body property } else { return ExprPropertyHelper.super. \ninternalGetSetChildProperty(property, get, child); } Additionally, this is a scenario where multiple \ndispatch would be bene.cial. The framework de.nes various visitors for traversing an AST; these could \nbe omitted in favor of multimethods, which are more extensible. Overall, our real-world examples suggest \nthat multiple in\u00adheritance can be useful, and that even diamond inheritance is used in practice. We have \nshown that the inheritance dia\u00admonds can be easily translated to CZ and that the resulting designs offer \nsome bene.ts over the original ones. In par\u00adticular, CZ avoids the problem of ignored constructor calls \nin C++, while providing more .exible code reuse than with single inheritance. 8. Formal System In this \nsection, we describe the formalization of CZ, which is based on Featherweight Java (FJ) [28]. We use \nthe same conventions as FJ; D is shorthand for the (possibly empty) list D1,. . ., Dn, which may be indexed \nby Di.  The grammar of CZ is presented in Fig. 7. Modi.ca\u00ad tions to FJ are highlighted. Class declarations \nmay extend or require a list of classes. There is also a new syntactic form for multimethods; such methods \ninclude a specializer on the .rst argument type. We relax the FJ convention that a class may not de.ne \ntwo methods with the same name; such a case is permitted as long as one method or both methods have specializers \n(which must be distinct). The type of all other arguments and the return type must remain the same. To \nsimplify the formal system, we assume that all meth\u00adods have at least one argument. A dummy object can \nbe used to simulate a no-argument method. To avoid syntax for resolving different superclass con\u00adstructors, \nall .elds, including those inherited from super\u00adclasses, must be initialized in the constructor. Aside \nfrom dynamically-dispatched super calls, and the removal of casts (they are orthogonal to our goals), \nCZ expression forms are identical to those of FJ. For simplicity, we have not modeled ordinary super \ncalls in our calculus, as this has been considered by others (e.g., [24, 38]) and is orthogonal to the \nissues we are considering. Therefore, the class quali.er of a super call must be a required class. We \nhave added a new subclass ( . ) judgement (Fig. 8), which is the re.exive, transitive closure of extends. \nThe sub\u00adtype judgement (<:) is extended to include the requires re\u00adlationship. Subclassing implies subtyping, \nand if class A requires B then A <: B, but A . B. In CZ, the requires relation is not transitive; subclasses \nmust either require or extend the required class, which is enforced by the type\u00adchecking rules. Subtyping \nallows A be used in place of B, which is in contrast to Scala; Scala only allows such a sub\u00adstitution \nfor the this reference within a class. The auxiliary judgements for typechecking appear after the typechecking \nand evaluation rules, in Fig. 12. We will describe each of these when describing the rules that use them. \nStatic Semantics. The rules for typechecking expressions are in Fig. 9. The rule for method invocations, \nT-INVK, is the same as that in FJ. However, the auxiliary judgement it uses, mtype, is different. The \nCZ judgement mtype (Fig. 12) has an additional rule as compared to FJ; it performs a lookup of methods \nfrom required classes, in the case that the method does not exist in the class itself or superclasses. \nThis judgement considers only unspecialized methods. The rule T-SUPER-INVK checks the dynamically\u00addispatched \nsuper call described in Sect. 6. Essentially, for a call of the form this.B.super.m(e), where this : \nC0, instead of looking up mtype(m, C0), we look up mtype(m, B), where B is a required class of C0. The \nrule T-NEW has one additional premise as compared to FJ: the requires clause must be empty. This ensures \nthat the class is concrete and can be instantiated, which in turn ensures the soundness of the subtyping \nrelation induced by requires. Rules for typechecking methods are displayed in Fig. 10. The rule T-METHOD \nchecks unspecialized methods, and uses the override auxiliary judgement (which is unchanged from FJ). \nIn this rule, we check that method m is a valid override of the same (unspecialized) method in all superclasses \nand required classes. T-MULTI-METHOD checks specialized methods. The .rst two premises are the same as \nthat of T-METHOD. Premises (3), (4) and (5) check conditions 1, 2, and 3, respectively, of constraint \nM1. Premise (6) checks condition 4 of M1; it ensures C de.nes or inherits an unspecialized method with \ntype (A, B) . B, where A is the static type being specialized. The T-CLASS rule (Fig. 11) checks class \nde.nitions. Premises (1 3) are straightforward generalizations of the corresponding premises in FJ. Premises \n(4) and (5) ensure that requires is propagated down each level of the inheritance hierarchy; the extending \nclass must either extend or require its parents required classes. Premise (6) speci.es that a sub\u00adclassing \ndiamond cannot occur, except for the case of Object (condition C1). Finally, premise (7) enforces condition \nC2, ensuring that if C inherits two methods m with the same .rst argument B. (or two unspecialized methods \nm), then C pro\u00advides an overriding de.nition for m. This premise uses the methodDef (m, Di, B.) auxiliary \njudgement: a derivation of methodDef exists if Di de.nes or inherits a method with spe\u00adcializer B. or \n.rst argument type B.. This premise, as well as the methodDef judgement, uses the notation .A@. to spec\u00adify \neither a specialized or unspecialized method (i.e., the A@ part is optional). Dynamic Semantics. The \nevaluation rules and auxil\u00adiary judgements are presented in Fig. 13. Most of the rules are similar to \nFJ, with the exception of E-INVK and E-SUPER-INVK. E-INVK passes the dynamic type of the method s .rst \nargument as an additional argument to mbody, which we describe below. E-SUPER-INVK uses the auxiliary \njudgement super(C, D), which .nds the .rst superclass of the class C that is also a subclass of D. Then, \nmbody is called on the result of the super call. The main changes to the dynamic semantics are encoded \nin the auxiliary judgements mbody, dispatch, and match. The mbody judgement has one additional argument \nas compared with FJ, to (potentially) dispatch on the method s .rst ar\u00adgument. This judgement simply \nextracts the arguments and method body from the result of the dispatch judgement, which contains the \nactual dispatch logic. Method dispatch is performed in two steps. The .rst dispatch rule uses the matchArg \njudgement to search for a method de.ned in C that is applicable for D, the dynamic  Declarations L ::= \nclass C extends C requires C { Cf ; KM } Constructors K ::= C(Cf ) { this. f = f ; } Methods M ::= C0 \nm(Cx) { return e; } | C0 m(C@C. x, Cx) { return e; } Expressions e ::= x | e. f | e.m(e) | e.C.super.m(e) \n| new C(e) Figure 7. CZ grammar Subclassing C . D C . C C . D D . E C . E CT(C) = class C extends D1, \n. . . , Dn \u00b7 \u00b7 \u00b7 { . . . } C . Di Subtyping C <: D C . D C <: D C <: D D <: E C <: E CT(C) = class C \nextends D requires E1, . . . , En C <: Ei { . . . } Figure 8. Subclassing (.) and subtyping (<:) judgement \nG . e : C (T-VAR) (T-FIELD) G . e0 : C0 C0 <: D .elds(D) = C f (T-INVK) G . e0 : C0 mtype(m, C0) = D \n. C G . e : C C <: D G . x : G(x) G . e0. fi : Ci G . e0.m(e) : C (T-SUPER-INVK) G . e0 : C0 class C0 \nextends D0 requires B, E mtype(m, B) = D . C G . e : C C <: D (T-NEW) .elds(C) = D f G . e : C C <: D \nclass C requires G . e0.B.super.m(e) : C G . new C(e) : C Figure 9. Expression typing type of the method \ns .rst argument. This latter judgement considers both specialized and unspecialized methods (via the \n.B@. notation). If such a de.nition exists, it is returned; otherwise, a set of methods ME is composed \nby calling dispatch on each of C s superclasses. Then, the unique most speci.c method that is applicable \nfor argument D is selected. Note the asymmetric dispatch semantics; if an appropriate method does not \nexist in C, its superclasses are searched before dispatching on the argument type. Constructors. As in \nFJ, CZ does not contain state, and thus constructor de.nitions are trivial. However, a full imple\u00admentation \nwould have to ensure that when C extends A, B and A requires B, when creating a C object, its B-part \nmust be initialized before its A-part. Otherwise, this could result in .elds being accessed before they \nexist, since A is permit\u00adted to access B s .elds. Generalizations. To generalize multimethod dispatch \nto n arguments, in the static semantics, we would extend premise (7) of T-CLASS, which corresponds to \ncondition C2. In par\u00adticular, this premise would ensure that if C inherits two method de.nitions that \nhave identical specializer lists (or argument types), then an overriding de.nition exists in C. In particular, \nthe quanti.er .B. would become .B. in this premise. For the dynamic semantics, we would change dispatch \nand matchArg to take a list of dynamic types of the ob\u00adjects passed to the method in question. The latter \njudgement would then select the unique most speci.c method such that each of its specializers (or argument \ntypes, if there is no spe\u00adcializer) is a supertype of the corresponding dynamic type. This could be implemented \nby .rst creating a candidate list of all applicable methods, then selecting the most speci.c one.  M \nok in C x : B, this : C . e0: E0 E0 <: B  . .i . override(m, Di , B . B) .i. override(m, Ei, B . B) \n(T-METHOD) Bm(Bx) { return e0; } ok in C . x : B. , x : B, this : C . e0: E0 . E0 <: B A .= Object \nB0 .= AB0 . A mtype(m, C)=(A, B) . B (T-MULTI-METHOD) Bm(A@B0 x, Bx) { return e0; } ok in C Figure 10. \nSpecialized and unspecialized method typing Declaration Typing L ok i.1..n . .i. .elds(Di)= Figi , Cf \n){ this.gi = gi ; this. f = f } M ok in C .i. class Di requires E., implies .k. Dk . E. or .k. Ek . E. \n. .i. class Ei requires E.., implies .k. Dk . E.. or .k. Ek . E.. .i. .j .= i. .D..= Object. Di . D. \nand Dj . D. ` \u00b4 .m. .B. . .i. .j .= i. methodDef (m, Di, B.) and methodDef (m, Dj, B.) , implies .B.. \n. B.. B.. and B0 m(.A@.B..x, Bx) . M (T-CLASS) class C extends D requires E { Cf ; KM } ok Figure 11. \nClass typing We observe from the form of these judgements (dispatch and matchArg) that there could be \ntwo ways in which more than one method applies: (1) within a single argument posi\u00adtion, more than one \nmethod applies and none is more speci.c than the others, (2) one method is more speci.c at one argu\u00adment \nposition and another method is more speci.c at some other argument position. Note that, in the absence \nof appro\u00adpriate typechecking, either situation can arise, regardless of whether dispatch is performed \non n arguments or just two ar\u00adguments. Premise (6) of T-MULTI-METHOD ensures that there exists at least \none method in the candidate list. CZ s static semantics in particular, conditions C1 and C2 ensure that \nthe .rst situation cannot arise. As a conse\u00adquence of condition C1 (the no-diamond restriction), for \na particular argument position k, all specializer types in the candidate method list are mutually comparable \n(via sub\u00adclassing). That is, if, at argument position k, method mi has specializer Ci and mj has specializer \nCj, then either Ci . Cj or Cj . Ci (for i .= j). This is because both types must be superclasses of Dk \n(the dynamic type at position k) and they also must both be subtypes of Ck, the static type at position \nk. Since Ck cannot be Object, Ci and Cj must be comparable types. C2 ensures that there exists an argument \nposition k such that Ci .= Cj. We observe that two methods in the candidate list could only have identical \nspecializer types (or argument types) if class C inherited two such methods (as there is a syntactic \nrestriction against such a de.nition directly in C). But, C2 ensures that if such a situation were to \noccur, that C would have an overriding de.nition. Therefore, the .rst dispatch rule would apply and superclasses \nwould not be considered. Finally, situation (2) cannot occur, due our assymmetric dispatch semantics. \nTo change to symmetric dispatch (de\u00adscribed in Sect. 4.3), we need only add an additional premise to \nT-CLASS. This new premise would ensure that there is no combination of receiver and argument tuples such \nthat more than one method would apply, using the same modular check implemented in, for instance, MultiJava \nand EML [17, 35]. Note that the dynamic semantics would not need to change, since this new premise would \nensure that asymmetric and symmetric dispatch produce the same result. 8.1 Modularity Here, we describe \nthe conditions under which a class-based system is modular when there is no explicit module system. We \nargue informally that typechecking in CZ is modular based on the structure of the typechecking rules. \n(The other languages we have mentioned also perform modular type\u00adchecking by this de.nition.) Conditions \nfor modular typechecking. 1. Checking a class signature C with methods M should only require examining: \n(a) signatures of methods tran\u00ad  .elds(C)= Cf class C extends D1,. . ., Dn requires E { Cf ; KM } .i \n. .elds( Di )= Bi gi i.1..n .elds(C)= , Cf .elds(Object)= Bi gi mtype(m, C)= D . D class C extends \nD requires E { Cf ; KM } class C extends Bm(Bx) { return e; } . M .k . mtype(m, Dk )= B . B .k. mtype \n(m, Ek)= B . B mtype(m, C)= B . B mtype(m, C)= B . B mtype(m, C)= B . B class C \u00b7\u00b7\u00b7 { Cf ; KM } methodDef \n(m, C, B) class C \u00b7 \u00b7 \u00b7 { C f ; K M } B0 m(.B.@.B x, B x) { return e; } . M class C extends D \u00b7 \u00b7 \u00b7 { \nC f ; K M } B0 m(.B.@.B x, B x) { return e; } /. M .k. methodDef (m, Dk, B) methodDef (m, C, B) methodDef \n(m, C, B) override(m, D, C . C0) mtype(m, D)= D . D0 implies C = D and C0 = D0 override(m, D, C . C0) \nFigure 12. CZ typechecking auxiliary judgements sitively overridden or specialized in M, (b) signatures \nof methods transitively overridden or specialized by C s in\u00adherited methods, (c) class declarations of \nC s supertypes. 2. Checking the de.nition of a particular method m (possi\u00adbly specialized with class \nC) should only require exam\u00adining: (a) the declarations of C and its supertypes, (b) the signature of \nthe method that m specializes, and (c) the signatures of methods called by m. By inspection, checking \na class de.nition C obeys condi\u00adtion 1. Each premise examines only superclasses or required classes, \nand there is, for example, no search for multimeth\u00adods with .rst argument type C. Checking a method de.nition \nm is also modular. If m is an unspecialized method, the only generalization to the typechecking rule \nis additional override checks, which are modular. On the other hand, when a specialized method is checked, \nwe simply ensure that the specializer has the appropriate relationship to its static type (which may \nnot be Object), and call mtype(m, C). Since this judgement only searches up the subtype hierarchy, it \nis modular.  8.2 Type Safety We prove type safety using the standard progress and preser\u00advation theorems, \nwith a slightly stronger progress theorem than that of FJ, due to the omission of casts. Note that in \nour system, type safety implies that all method calls are unam\u00adbiguous, as the dispatch and match judgements \nrequire that there be a unique most-applicable method. We describe be\u00adlow a brief outline of the proof \nof type safety and refer the reader to [31] for further details. Theorem 8.1 (Preservation). If G . e \n: C and e .-. e. , then G . e. : C. for some C. <: C. The proof of preservation is relatively straightforward \nand is similar to the proof of FJ. We make use of an auxiliary lemma (not shown) that proves that mtype \nreturns a unique value. The proof of this lemma makes use of the convention that method introductions \nare unique. Theorem 8.2 (Progress). If \u00b7. e : C then either e is a value or there is an e. with e .-. \ne. . The proof of progress is slightly more complex. The proof requires the following lemma: Lemma 8.1. \nIf mtype(m, C)=(B0, B) . B and G . new C(e) : C and B.. B0 then dispatch(m, C, B.)= M, for some M. However, \nunlike in FJ, we cannot prove this lemma by in\u00adduction on the derivation of mtype, since for the inductive \nstep, we do not have a derivation G . new Dk(e) : Dk. In\u00adstead, we make use of two auxiliary lemmas: \n Evaluation e .-. e. (E-FIELD) (E-INVK) (E-SUPER-INVK) .elds(C)= B f mbody(m, C, D )=(x, x).e0 super(C, \nE)= C. mbody(m, C. , D)=(x, x).e0 `\u00b4 `\u00b4 (new C(e)). fi .-. ei (new C(e)).m new D(e.) , d .-. (new C(e)).E.super.m \nnew D(e.), d .-. .)/x, d/x new C(e)/this, new D(ee0 new C(e)/this, new D(e.)/x , d/xe0 e0 .-. ee0 .-. \nee0 .-. e 00 0 e0. f .-. e0. fe0.m(e) .-. e0.m(e) e0.C.super.m(e) .-. e0.C.super.m(e) ei .-. eei .-. \neei .-. e ii i e0.m(..., ei,... ) .-. e0.C.super.m(..., ei,... ) .-. new C(..., ei,... ) .-. e0.m(..., \nei,... ) e0.C.super.m(..., ei,... ) new C(..., ei,... ) Auxilliary Judgements mbody(m, C, D )= x.e super(C, \nD)= E dispatch(m, C, D)= .E.. D. class C extends E. B0 m(.B@.B. x, Bx) { return e; } class C extends \nEE . DC extends B .k. super(C, Bk)= E mbody(m, C, D )= x.e super(C, D)= E super(C, D)= E dispatch(m, \nC, D)= M  .M. . matchArg(m, D, M)= M. matchArg(m, D, M)= M. ME = {Mi | dispatch(m, Ei, D)= Mi}. unique \nM.. . matchArg(m, D, ME)= M.. class C \u00b7\u00b7\u00b7 { Cf ; KM } class C extends dispatch(m, C, D)= M. dispatch(m, \nC, D)= M.. matchArg(m, D, M) = M M. = B0 m(.B@.D x, B x) { return e; } M. . M matchArg(m, D, M) = M. \nB0 m(.B@.D x, B x) /. M class D extends E . unique (k, M.). matchArg(m, Ek, M) = M. matchArg(m, D, M) \n= M. Figure 13. Evaluation rules and auxiliary judgements  Lemma 8.2. If D :: mtype(m, C)=(B0, B) . \nB and D does not contain the rule MTYPE3 and B. . B0, then dispatch(m, C, B.) = M, for some M. Lemma \n8.3. If G . new C(e) : C and C <: D and D :: mtype(m, D)= B . B, then there exist D. and D. such that \nC . D. and D. :: mtype(m, D.)= B . B does not contain the rule MTYPE3. Lemma 8.2 is needed because it \nis the rule MTYPE3 that could result in mbody not being de.ned it is the only rule that has no dispatch \ncounterpart. We use Lemma 8.3 to produce such an mtype derivation. With these lemmas, the rest of the \nproof of progress is straightforward. 9. Related Work Here we describe related work that was not previously \ndis\u00adcussed in Sections 2, 3.2, and 4.2. As mentioned in Sect. 4.2, JPred [25] and Fortress [3] perform \nmodular multimethod typechecking by requiring that programmers provide disambiguating methods, some of \nwhich may never be called. However, we observe that the JPred and Fortress dispatch semantics may be \nmore expres\u00adsive than that of CZ. In CZ, in the class hierarchy Fig. 2, the abstract class InputStream \nmay not be used as a specializer for Stream, because it is not a subclass of Stream. In con\u00adtrast, if \nthis hierarchy were expressed in e.g. Fortress a mul\u00adtimethod de.ned on Stream could be specialized for \neither InputStream or OutputStream. Note, however, that program\u00admers can achieve a similar effect in \nCZ by having concrete classes call helper methods (which may themselves perform multiple dispatch) de.ned \non the abstract classes.  Cecil [14, 15] also provides both multiple inheritance and multimethod dispatch, \nbut it does not include construc\u00adtors (and therefore provides ordinary dispatch semantics for methods \nacting as constructors), and it performs whole\u00adprogram typechecking. Like JPred, the language Half &#38; \nHalf [6] provides multi\u00ad method dispatch on Java interfaces. In this language, if there exist specialized \nmethod implementations for two incompa\u00adrable interfaces A and B, the visibility of one of the two in\u00adterfaces \nmust be package-private. Like System M, this effec\u00adtively disallows multiple (interface) inheritance \nacross mod\u00adule boundaries (where a package is a module). Half &#38; Half does not consider the problem \nof multiple inheritance with state. Pirkelbauer et al have considered the problem of integrat\u00ading multimethods \ninto C++, which is especially dif.cult due to existing rules for overload resolution [42]. However, this \nproposal is not modular; because of the potential for inheri\u00adtance diamonds, the design requires link-time \ntypechecking. It is worth noting that multimethods cannot be simulated with C# 3.0 extension methods \nor partial classes [34]. The former, extension methods, are merely syntactic sugar and cannot be overridden \nwith a more speci.c type for the receiver. Partial classes, on the other hand, are simple a compile-time \nmechanism for splitting a class s de.nition across multiple compilation units. In particular, compared \nto multimethods, they have the following limitations: 1) they cannot span assemblies (so if the AST node \nclasses are in a library, some other mechanism would be needed, such as the Visitor pattern); 2) partial \nclasses may not be used to perform dispatch on interfaces, in contrast to multimethods; and 3) typechecking \neach part of a partial class is not modular, as all parts are composed before typechecking. This last \nproblem can cause compilation errors if two programmers implement a partial class in incompatible ways, \nso it is unclear what should be the appropriate level of granularity when partial classes are used in \na team environment. 10. Conclusions We have presented a language that solves two major prob\u00adlems caused \nby inheritance diamonds: object initialization and modular typechecking of multiple dispatch. We have \nalso shown how programs written with traditional multiple inheritance can be converted to programs in \nour language. We note that though diamonds can still cause encapsula\u00adtion problems (depending on the \nde.nition of encapsula\u00adtion), this problem can be ameliorated by preferring requires over extends. We \nemphasize that although programmers may indeed have to decide ahead of time whether they want to make \na class re-usable by making it abstract and by using re\u00adquires instead of extends potentially a dif.cult \ndecision to make it is a decision the class designer must already make, as a class must be designed carefully \nif it is to be a unit of reuse (e.g., see item 17 in [33]). One might also raise the objection that CZ \nwould result in a proliferation of abstract classes, for which a corresponding concrete class would have \nto be de.ned. We believe that this problem can mostly be solved through a syntactic sugar for de.ning \nconcrete classes (Section 6.4). Additionally, note that our proposed solution requires just as many abstract \nclasses as there would be mixins or traits (which also can\u00adnot be instantiated) if those solutions were \nto be used (Sec\u00adtion 3.2). Acknowledgements We would like to thank Neelakatan Krishnaswami, Gi\u00adlad Bracha, \nNels Beckman, Ciera Jaspan, Kevin Bierhoff, William Lovas, and the anonymous reviewers of FTfJP, FOOL, \nECOOP, and OOPSLA for helpful feedback on ear\u00adlier versions of this paper. This research was supported \nin part by NSF CAREER award CCF-0546550, DARPA grant HR0011-0710019, and Army Research Of.ce grant DAAD19-02-1-0389 \nentitled Perpetually Available and Se\u00adcure Information Systems. References [1] R. Agrawal, L. DeMichiel, \nand B. Lindsay. Static type checking of multi-methods. In OOPSLA, pages 113 128, 1991. [2] E. Allen, \nD. Chase, J. Hallett, V. Luchangco, J. Maessen, S. Ryu, G. Steele, Jr., and S. Tobin-Hochstadt. The Fortress \nLanguage Speci.cation, Version 1.0. Available at http: //research.sun.com/projects/plrg/Publications/fortress.1.0.pdf, \n2008. Accessed 3/09. [3] E. Allen, J. J. Hallett, V. Luchangco, S. Ryu, and G. L. Steele Jr. Modular \nmultiple dispatch with multiple inheritance. In SAC 07, pages 1117 1121. ACM, 2007. [4] D. Ancona, G. \nLagorio, and E. Zucca. Jam -designing a Java extension with mixins. ACM Trans. Program. Lang. Syst., \n25(5):641 712, 2003. [5] D. Ancona and E. Zucca. An algebraic approach to mixins and modularity. In Algebraic \nand Logic Programming, pages 179 193, 1996. [6] G. Baumgartner, M. Jansche, and K. L\u00e4ufer. Half &#38; \nHalf: Multiple dispatch and retroactive abstraction for Java. Technical Report OSU-CISRC-5/01-TR08, Dept. \nof Computer and Information Science, The Ohio State University, March 2002. [7] A. Bergel. Personal communication, \nOctober 2008.  [8] A. Bergel, S. Ducasse, O. Nierstrasz, and R. Wuyts. Stateful traits and their formalization. \nComputer Languages, Systems &#38; Structures, 34(2-3):83 108, 2008. [9] L. Bettini, V. Bono, and S. Likavec. \nA core calculus of higher-order mixins and classes. In SAC, pages 1508 1509, 2004. [10] J. Bloch. Effective \nJava: Programming Language Guide. Addison-Wesley, 2001. [11] J. Boyland and G. Castagna. Parasitic methods: \nAn implementation of multi-methods for Java. In OOPSLA, pages 66 76, 1997. [12] G. Bracha and W. Cook. \nMixin-based inheritance. In ECOOP 90, 1990. [13] B. Carr\u00e9 and J. Geib. The point of view notion for multiple \ninheritance. In OOPSLA/ECOOP 90, pages 312 321. ACM, 1990. [14] C. Chambers. Object-oriented multi-methods \nin Cecil. In ECOOP 92, 1992. [15] C. Chambers and the Cecil Group. The Cecil language: speci.cation and \nrationale, Version 3.2. Available at http://www.cs.washington.edu/research/projects/cecil/, 2004. Accessed \n3/09. [16] C. Clifton, G. T. Leavens, C. Chambers, and T. Millstein. MultiJava: modular open classes \nand symmetric multiple dispatch for Java. In OOPSLA 00, pages 130 145, 2000. [17] C. Clifton, T. Millstein, \nG. T. Leavens, and C. Chambers. MultiJava: Design rationale, compiler implementation, and applications. \nACM Trans. Program. Lang. Syst., 28(3):517 575, 2006. [18] W. Cook, W. Hill, and P. Canning. Inheritance \nis not subtyping. In POPL, pages 125 135, 1990. [19] S. Ducasse, O. Nierstrasz, N. Sch\u00e4rli, R. Wuyts, \nand A.P. Black. Traits: A mechanism for .ne-grained reuse. ACM Trans. Program. Lang. Syst., 28(2):331 \n388, 2006. [20] T. Ekman and G. Hedin. JastAdd. http://www.jastadd.org, 2008. Accessed 3/09. [21] M. \nEllis and B. Stroustrup. The Annotated C++ Reference Manual. Addison-Wesley Longman Publishing Co., Inc., \nBoston, MA, USA, 1990. [22] R.B. Findler and M. Flatt. Modular object-oriented pro\u00adgramming with units \nand mixins. ACM SIGPLAN Notices, 34(1):94 104, 1999. [23] K. Fisher and J. Reppy. A typed calculus of \ntraits. In Proceedings of the 11th Workshop on Foundations of Object\u00adoriented Programming, January 2004. \n[24] M. Flatt, S. Krishnamurthi, and M. Felleisen. Classes and mixins. In POPL 98, 1998. [25] C. Frost \nand T. Millstein. Modularly typesafe interface dispatch in JPred. In FOOL/WOOD 06, January 2006. [26] \nD. Hovemeyer and W. Pugh. Finding bugs is easy. SIGPLAN Not., 39(12):92 106, 2004. [27] N. C. Hutchinson. \nEMERALD: An object-based language for distributed programming. PhD thesis, University of Washington, \nSeattle, WA, USA, 1987. [28] A. Igarashi, B. Pierce, and P. Wadler. Featherwieght Java: a Minimal Core \nCalculus for Java and GJ. In OOPSLA 99, November 1999. [29] E. Johnsen, O. Owe, and I. Yu. Creol: A type-safe \nobject\u00adoriented model for distributed concurrent systems. Theor. Comput. Sci., 365(1):23 66, 2006. [30] \nD. Malayeri. CZ: Multiple inheritance without diamonds. In FOOL 09, January 2009. [31] D. Malayeri and \nJ. Aldrich. CZ: Multimethods and multiple inheritance without diamonds. Technical Report CMU\u00adCS-09-153, \nSchool of Computer Science, Carnegie Mellon University, August 2009. [32] B. Meyer. Object-Oriented Software \nConstruction, 2nd Edition. Prentice-Hall, 1997. [33] S. Meyers. Effective C++: 50 speci.c ways to improve \nyour programs and designs. Addison Wesley Longman Publishing Co., Inc. Redwood City, CA, USA, 1992. [34] \nMicrosoft Corporation. C# language speci.cation, version 3.0. Available at http://download.microsoft.com/download/ \n3/8/8/388e7205-bc10-4226-b2a8-75351c669b09/csharp% 20language%20speci.cation.doc, 2007. Accessed 8/09. \n[35] T. Millstein, C. Bleckner, and C. Chambers. Modular typechecking for hierarchically extensible datatypes \nand functions. In ICFP 02, 2002. [36] T. Millstein, C. Bleckner, and C. Chambers. Modular typechecking \nfor hierarchically extensible datatypes and functions. ACM Trans. Program. Lang. Syst., 26(5):836 889, \n2004. [37] T. Millstein and C. Chambers. Modular statically typed multimethods. Inf. Comput., 175(1):76 \n118, 2002. [38] N. Nystrom, S. Chong, and A. Myers. Scalable extensibility via nested inheritance. In \nOOPSLA 04, pages 99 115, 2004. [39] M. Odersky. The Scala language speci.cation. Available at http://www.scala-lang.org/docu/.les/ScalaReference.pdf, \n2007. Accessed 3/09. [40] M. Odersky and M. Zenger. Scalable Component Abstrac\u00adtions. In OOPSLA 05, 2005. \n[41] A. Paepcke. Object-Oriented Programming: The CLOS Perspective. The MIT Press, 1993. [42] P. Pirkelbauer, \nY. Solodkyy, and B. Stroustrup. Open multi\u00admethods for C++. In GPCE 07, pages 123 134, 2007. [43] M. \nSakkinen. Disciplined inheritance. In ECOOP, pages 39 56, 1989. [44] N. Sch\u00e4rli, S. Ducasse, O. Nierstrasz, \nand A.P. Black. Traits: Composable Units of Behaviour. In ECOOP 03. Springer, 2003. [45] A. Shalit. The \nDylan Reference Manual: The De.nitive Guide to the New Object-Oriented Dynamic Language. Addison-Wesley, \n1997. [46] G. Singh. Single versus multiple inheritance in object oriented programming. SIGPLAN OOPS \nMess., 5(1):34 43, 1994.  [47] A. Snyder. Encapsulation and inheritance in object-oriented programming \nlanguages. In OOPSLA, pages 38 45, 1986. [48] G. L. Steele, Jr. Common LISP: The Language. Digital Press, \nsecond edition, 1990. [49] C. Szyperski, S. Omohundro, and S. Murer. Engineering a programming language: \nThe type and class system of Sather. In J. Gutknecht, editor, Programming Languages and System Architectures, \nvolume 782 of Lecture Notes in Computer Science. Springer, 1993. [50] G. Washburn. Personal communication, \nDecember 2008. A. Subtyping vs. Subclassing In CZ, the use of requires provides subtyping without inheri\u00adtance, \nbut it also places constraints on concrete subclasses they must inherit from their parent s required \nclasses. This raises the question of whether simply providing subtyping without inheritance would be \nsuf.cient to encode the desired relationships. When separating subtyping from inheritance, we may use \nnominal subtyping or structural subtyping. However, in either case, private members are problematic. \nIf private members are included in a subtyping relationship, this can violate information hiding, if \nthey are not, it can restrict expressiveness. Concretely, consider the following program: class A{ private \nint i; boolean equals(A other) { ... // can access other.i? } }  class B subtypes A{ ... // declare \ni? } Suppose that the subtypes keyword provides nominal sub\u00adtyping without inheritance (but without \nthe additional con\u00adstraints of requires). The question then arises: are private members considered when \nchecking subtyping? If so, then B must declare a private .eld i. Unfortunately, this also means that \nA.equals can access B.i, which violates information hid\u00ading; one class should not be able to access private \nmembers de.ned in another class. On the other hand, if we assume that subtyping does not include private \nmembers, then A.equals cannot access other.i, which is problematic if the de.nition of equality depends \non this .eld. An analogous problem oc\u00adcurs if structural subtyping is used. The problem can be avoided \nif inheritance or requires is used for types that contain binary methods. Since requires is tied to a \nparticular class, if we change the above code to B requires A (or B extends A), then A.equals(A other) \nmay safely access other.i, even if an object of type B is passed to this method. Note that an information \nhiding problem does not arise here the private state has not been rede.ned in B, but is rather (eventually) \ninherited from A in the concrete B implementation that was passed in.     \n\t\t\t", "proc_id": "1640089", "abstract": "<p>Multiple inheritance has long been plagued with the \"diamond\" inheritance problem, leading to solutions that restrict expressiveness, such as mixins and traits. Instead, we address the diamond problem directly, considering two difficulties it causes: ensuring a correct semantics for object initializers, and typechecking multiple dispatch in a modular fashion-the latter problem arising even with multiple interface inheritance. We show that previous solutions to these problems are either unsatisfactory or cumbersome, and suggest a novel approach: supporting multiple inheritance but forbidding diamond inheritance. Expressiveness is retained through two features: a \"requires\" construct that provides a form of subtyping without inheritance (inspired by Scala), and a dynamically-dispatched \"super\" call similar to that found in traits. Through examples, we illustrate that inheritance diamonds can be eliminated via a combination of \"requires\" and ordinary inheritance. We provide a sound formal model for our language and demonstrate its modularity and expressiveness.</p>", "authors": [{"name": "Donna Malayeri", "author_profile_id": "81339515455", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1728714", "email_address": "", "orcid_id": ""}, {"name": "Jonathan Aldrich", "author_profile_id": "81100454133", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1728715", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640092", "year": "2009", "article_id": "1640092", "conference": "OOPSLA", "title": "CZ: multiple inheritance without diamonds", "url": "http://dl.acm.org/citation.cfm?id=1640092"}