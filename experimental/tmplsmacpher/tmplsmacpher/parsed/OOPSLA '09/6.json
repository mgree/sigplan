{"article_publication_date": "10-25-2009", "fulltext": "\n Thorn Robust, Concurrent, Extensible Scripting on the JVM \u00a8 Bard Bloom1 , John Field1 , Nathaniel \nNystrom2* , Johan Ostlund3 , Gregor Richards3 , sa4 , Jan Vitek3 , Tobias Wrigstad5 Rok Strni. 1 IBM \nResearch 2 University of Texas at Arlington 3 Purdue University 4 University of Cambridge 5 Stockholm \nUniversity Abstract Scripting languages enjoy great popularity due to their sup\u00adport for rapid and exploratory \ndevelopment. They typically have lightweight syntax, weak data privacy, dynamic typing, powerful aggregate \ndata types, and allow execution of the completed parts of incomplete programs. The price of these features \ncomes later in the software life cycle. Scripts are hard to evolve and compose, and often slow. An additional \nweakness of most scripting languages is lack of support for concurrency though concurrency is required \nfor scalability and interacting with remote services. This paper reports on the design and implementation \nof Thorn, a novel program\u00adming language targeting the JVM. Our principal contribu\u00adtions are a careful \nselection of features that support the evo\u00adlution of scripts into industrial grade programs e.g., an \nex\u00adpressive module system, an optional type annotation facility for declarations, and support for concurrency \nbased on mes\u00adsage passing between lightweight, isolated processes. On the implementation side, Thorn \nhas been designed to accommo\u00addate the evolution of the language itself through a compiler plugin mechanism \nand target the Java virtual machine. Categories and Subject Descriptors D.3.2 [Programming Languages]: \nLanguage Classi.cations Concurrent, dis\u00adtributed, and parallel languages; Object-oriented languages; \nD.3.3 [Programming Languages]: Language Constructs and Features Concurrent programming structures; Modules, \npackages; Classes and objects; Data types and structures; D.3.4 [Programming Languages]: Processors Compilers \nGeneral Terms Design Keywords Actors, Pattern matching, Scripting * Work done while the author was af.liated \nwith IBM Research. Work done while the author was af.liated with Purdue University. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 2009, October 25 \n29, 2009, Orlando, Florida, USA. Copyright c &#38;#169; 2009 ACM 978-1-60558-734-9/09/10. . . $10.00 \n 1. Introduction Scripting languages are lightweight, dynamic programming languages designed to maximize \nshort-term programmer productivity by offering lightweight syntax, weak data en\u00adcapsulation, dynamic \ntyping, powerful aggregate data types, and the ability to execute the completed parts of incomplete programs. \nImportant modern scripting languages include Perl, Python, PHP, JavaScript, and Ruby, plus languages \nlike Scheme that are not originally scripting languages but have been adapted for it. Many of these languages \nwere orig\u00adinally developed for specialized domains (e.g., web servers or clients), but are increasingly \nbeing used more broadly. The rising popularity of scripting languages can be at\u00adtributed to a number \nof key design choices. Scripting lan\u00adguages pragmatic view of a program allows execution of completed \nsections of partially written programs. This fa\u00adcilitates an agile and iterative development style at \nevery step of the way a working piece of software [9]. Execu\u00adtion of partial programs allows instant \nunit-testing, interac\u00adtive experimentation, and even demoing of software at all times. Powerful and .exible \naggregate data types and dy\u00adnamic typing allow interim solutions that can be revisited later, once the \nunderstanding of the system is deep enough to make a more permanent choice. Scripting languages focus \non programmer productivity early in the software life cycle. For example, studies show a factor 3 60 \nreduced effort and 2 50 reduced code for Tcl over Java, C and C++ [38, 39]. However, when the exploratory \nphase is over and require\u00adments have stabilized, scripting languages become less ap\u00adpealing. The compromises \nmade to optimize development time make it harder to reason about correctness, harder to do semantic-preserving \nrefactorings, and in many cases harder to optimize execution speed. Even though scripts are suc\u00adcinct, \nthe lack of type information makes the code harder to navigate. An additional shortcoming of most scripting \nlan\u00adguages is lack of .rst-class support for concurrency. Concur\u00adrency is no longer just the province \nof specialized software such as high-performance scienti.c algorithms it is ubiqui\u00adtous, whether driven \nby the need to exploit multicore archi\u00adtectures or the need to interact asynchronously with services \non the Internet. Current scripting languages, when they sup\u00adport concurrency at all, do so through complex \nand fragile libraries and callback patterns [20], which combine browser\u00adand server-side scripts written \nin different languages and are notoriously troublesome. Currently, the weaknesses of scripting languages \nare largely dealt with by rewriting scripts in either less brittle or more ef.cient languages. This is \ncostly and often error\u00adprone, due to semantic differences between the scripting lan\u00adguage and the new \ntarget language. Sometimes parts of the program are reimplemented in C to optimize a particularly intensive \ncomputation. Bridging from a high-level scripting language to C introduces new opportunities for errors \nand in\u00adcreases the number of languages a programmer must know to maintain the system. Design Principles. \nThis paper reports on the design and the implementation status of Thorn, a novel programming language \nrunning on the Java Virtual Machine (JVM). Our principal design contributions are a careful selection \nof fea\u00adtures that support the evolution of scripts into robust indus\u00adtrial grade programs, along with \nsupport for a simple but powerful concurrency model. By robust , we mean that Thorn encourages certain \ngood software engineering prac\u00adtices, by making them convenient. The most casual use of classes will \nresult in strong encapsulation of instance .elds. Pattern matching is convenient and pervasive and provides \nsome of the type information which is lost in most dynami\u00adcally typed languages. Code can be encapsulated \ninto mod\u00adules. Components provide fault boundaries for distributed and concurrent computing. Thorn has \nbeen designed to strike a balance between dynamicity and safety. It does not support the full range of \ndynamic features commonly found in scripting languages, though enough of them for rapid prototyping. \nIt is static enough to facilitate reasoning and static analyses. Thorn runs on the JVM, allowing it to \nexecute on a wide range of operating systems and letting it use lower-level Java libraries for the Thorn \nruntime and system services. Thorn has the following key features: Scripty: Thorn is dynamically-typed \nwith lightweight syn\u00adtax and includes powerful aggregate data types and .rst\u00adclass functions. Object-oriented: \nThorn includes a simple class-based multiple inheritance object model that avoids the main complexities \nby simple static restrictions. Patterns: Thorn supports an expressive form of pattern matching for both \nbuilt-in types and objects. Immutable data types: Thorn encourage the use of im\u00admutable data, which typically \neases code composition and evolution. Concurrency and distribution: Non-sequential program\u00adming is done \nby lightweight, isolated, single-threaded components that communicate by message passing. Modules: An \nexpressive module system makes it easy to wrap scripts as reusable components. Constraints: Optional \nconstraint annotations on declara\u00adtions permit static or dynamic program checking, and fa\u00adcilitate optimizations. \nExtensibility: An extensible compiler infrastructure writ\u00adten in Thorn itself allows for language experimentation \nand development of domain speci.c variants. It is important to note what Thorn does not support. Threads: \nThere is no shared memory concurrency in Thorn, hence data races are impossible and the usual problems \nassociated with locks and other forms of shared memory synchroniza\u00adtion are avoided. Dynamic loading: \nThorn does not support dynamic loading of code. This facilitates static optimization, enhances security, \nand limits the propagation of failures. However, Thorn does support dynamic creation of compo\u00adnents, \nwhich can be used in many applications that currently require dynamic loading. Introspection: Unlike \nmany script\u00ading languages, Thorn does not support aggressively intro\u00adspective features. Unsafe methods: \nThorn can access Java li\u00adbraries through an interoperability API, but there is no access to the bare \nmachine through unsafe methods as in C# [22]. Java-style interfaces: Their function is subsumed by mul\u00adtiple \ninheritance. Java-style inner classes: These are com\u00adplex and dif.cult to understand, and are largely \nsubsumed by simpler constructs such as .rst-class functions. Implicit coercions: Unlike some scripting \nlanguages, Thorn does not support implicit coercions, e.g., interpreting a string \"17\" as an integer \n17 in contexts requiring an integer. Targeted Domains. Thorn is aimed at domains includ\u00ading client-server \nprogramming for mobile or web applica\u00adtions, embedded event-driven applications, and distributed web \nservices. The relevant characteristics include a need for rapid prototyping, for concurrency and, as \napplications ma\u00adture, for packaging scripts into modules for reuse, deploy\u00adment, and static analysis. \nThorn plugins provides language support for specialized syntax and common patterns, e.g., web scripting \nor streaming. They make it possible to adapt Thorn to specialized domains and allow more advanced op\u00adtimizations \nand better error handling than with macros. Implementation Status and Availability. Thorn is joint project \nbetween IBM Research and Purdue.There are cur\u00adrently two implementations of Thorn on the JVM: a feature\u00adcomplete \nreference implementation in the form of an inter\u00adpreter, and a slightly restricted bytecode compiler. \nWe are re-engineering the compiler to extend it to the full language. The only features discussed in \nthis paper that are not fully supported in the interpreter (but available in the compiler) are general \ntype constraints and language plugins. All of the examples in this paper have been tested on the refer\u00adence \nimplementation. More information is available from the Thorn web site at http://www.thorn-lang.org. An \nopen source version of Thorn is expected in late 2009. 2. From Scripts to Programs As an example of \nthe succinctness that scripting requires, here is a simple variant of the Unix grep program written in \nThorn. The call argv() returns the list of command-line arguments. for (l <-argv()(0).file().contents().split(\"\\n\")) \nif (l.contains?(argv()(1))) println(l); Subscripting uses parentheses and is 0-based, so argv()(0) is \nthe .rst argument. The file() method produces a .le ob\u00adject with the given name, and contents() gets \nthe contents of the .le as a string, and split(\"\\n\") breaks it into a list of lines. for iterates over \nthe list, binding l to successive lines. The if tests whether the second command-line argument is in \nthat line, and, if so, prints it. 2.1 Dining Philosophers Figure 1 is a Thorn solution to the Dining \nPhilosophers prob\u00adlem. We will cover of all of the Thorn constructs used in here in detail in subsequent \nsections; here are a few highlights. Forks and philosophers are represented as components, analogous \nto threads or processes, which communicate by sending messages back and forth, and do not share any state. \nThe Fork component describes a fork with two state vari\u00adables, holder for the philosopher currently holding \nthe fork, and waiter for the one waiting for it. These variables can be null if there is no such philosopher. \nThe local function taken() describes what to do when philosopher phil picks up the fork: viz., change \nthe holder variable, and send the message \"taken\" to the philosopher. The main behavior of a Fork is \ngiven in its body section which loops inde.nitely, waiting to receive one of three kinds of messages. \nUpon re\u00adception of the string \"die\" it breaks from the while loop, ending the body and thus the component. \nIf a record with a .eld labeled take is received from any philosopher phil, it will respond appropriately \nto phil: either giving him the fork or making him wait. Finally, it responds to \"drop\" by having the \nholding philosopher put the fork down, and, if necessary, the waiting one pick it up. In Thorn, blocks \nare enclosed in braces, as in C-derived languages. However, blocks begun with a keyword or iden\u00adti.er \ncan optionally be closed by the same symbol immedi\u00adately after the }, as in }Fork closing the component. \nOnce the de.nition of Fork is complete, the program spawns three instances of Fork, using a list comprehen\u00adsion \nexpression forks=%[...|for i<-0..2]. The values in the list are component handles, immutable references \nto the components, which can be used to send messages to them. The list is bound to a variable, forks, \nwhose scope includes the ensuing component declaration for Phil. One important property of the Thorn \ncomponent model is that, semanti\u00adcally, no state is shared between component instances. As an optimization, \nthe implementation may share immutable state; but this is invisible to Thorn. When a global constant, \nlike forks, is used within a component de.nition, no state component Fork(n) { var holder := null; var \nwaiting := null; fun taken(phil) {holder := phil; phil <<< \"taken\";} body { while (true){ receive{ \"die\" \n=> {break;} | {: take:_ :} from phil => { if (holder == null) taken(phil); else waiting := phil; } | \n\"drop\" from phil => { phil <<< \"dropped\"; if (waiting != null){  taken(waiting); waiting := null; } \nelse holder := null; }}}} }Fork; forks = %[ spawn Fork(i) | for i <-0 .. 2]; component Phil(name, ln, \nrn, iter) { body { left = forks(ln); right = forks(rn); for(i <-1 .. iter) { # THINK: I think, therefore \nI am. left <<< {: take:name :}; receive{\"taken\" => {}}; right <<< {: take:name :}; receive{\"taken\" => \n{}}; # CRITICAL: I eat, therefore I am fed. right <<< \"drop\"; receive{\"dropped\" => {}}; left <<< \"drop\"; \nreceive{\"dropped\" => {}}; }} }Phil; phils = [ spawn Phil(\"Kant\", 0, 1, 10), spawn Phil(\"Hume\", 1, 2, \n12), spawn Phil(\"Marx\", 0, 2, 8)]; # A 3-way philosophical dinner now ensues. Figure 1. Dining Philosophers \nin Thorn is shared; forks is treated as a parameter to the component, and, thus, passed by copy. The \nPhil component has several parameters: philoso\u00adpher name, index of the left and right forks, and the \nnum\u00adber of times to think. A philosopher starts out by bind\u00ading his left and right forks to two variables. \nThe state\u00adment left = forks(ln) introduces an immutable binding to a fresh variable. Thorn distinguishes \nbetween mutable (var) and immutable (val or =) variables. The statement holder := phil, for example, \nassigns to an extant mutable variable; it cannot be used on an immutable one. As shad\u00adowing of variable \nnames is forbidden, it is all but impossible to introduce a new variable when the intent was to update \nan extant one, or vice-versa. Most scripting languages allow the assignment operation to create new variables \nas well as modify them. Thorn s approach is nearly as convenient, and safer. The philosopher iterates \niter times, thinking and eating. After thinking, it picks up its left fork. This is done in two parts: \nleft <<< {: take:name :}, which constructs a record with one .eld take bound to the philosopher s name, \nand sends it to the left fork. Then it waits for the fork to reply. The reply needs to be the string \n\"taken\"; other incoming messages (of which this example has none) are ignored. No particular action needs \nto be done when the message shows up, hence the empty block in the receive. The philosopher repeats the \nsame send and receive with the right fork. After the critical section, the philosopher drops the forks \nin the opposite order, using the same mechanisms to communicate. The example concludes with the spawning \nof three fa\u00admous philosophers. Each is provided with its proper forks; Marx s forks are reversed to break \nthe symmetry and al\u00adlow the usual Dining Philosophers solution to work. When a philosopher is spawned, \nit starts executing its body clause, picking up forks and so on. The system runs philosophically from \nthis point on.  2.2 A Server in Thorn We now turn to a more complex example: a matchmaking application. \nThe heart of the service is a date service com\u00adponent that interacts with a client components acting \non be\u00adhalf of customers seeking dates. The service advertises it\u00adself through a central registry, here \npresented for brevity in a minimalist form only capable of registering a single dating service. The code \nshown here could run within a single JVM as the previous example, but we have chosen to distribute it. \nmodule dating { fun registry() = site(\"thorn://localhost:5555\"); fun sum([]) = 0; | sum([x,y...]) = x \n+ sum(y); class Profile(interests, limit) : pure { def compatible?(other) = other != null &#38;&#38; \nthis.compat?(other) &#38;&#38; other.compat?(this); def likes?(topic) = %exists(t==topic | for {: topic:t \n:} <-interests); def compat?(other : Profile) { matches = %[ weight | for {:topic, weight:} <-interests, \nif other.likes?(topic)]; sum(matches) > limit; } } }dating spawn Registry { var datesvc; sync dateServicePlz() \n= datesvc; sync registerDateSvc(datesvc ) { datesvc := datesvc ; } body { while (true) serve;} }; Figure \n2. Dating module and registry in Thorn. Every component (marked by the keyword spawn) runs in a different \nJVM. Component handles contains suf.cient infor\u00admation to identify the node and port on which the component \nruns. Thorn allows shared code to be organized in modules: bindings of names to components, classes, \nvalues, functions, and so on. Figure 2 de.nes the dating module, which ex\u00adports the de.nition of the \nregistry and sum functions, and the Profile class: the data structure that explains what a client of \nthe dating service is looking for. Methods in classes are declared using the def keyword. Functions and \nmethods always return a value, which is the last expression computed within the function body. Profile \nde.nes three methods; by convention method names ending in ? return Boolean values. The pure annotation \non Profile indicates that the class can\u00adnot refer to mutable or component-local state, and thus, its \ninstances are suitable for transmission between components. The DateService and SampleClient components, \nshown in Figure 3, both import the de.nitions in the module dating. In particular they share the Profile \nclass. The key\u00adword spawn is used here to create a singleton instance of the component de.nition that \nfollows it, the component name is optional. The Registry component is intentionally simpli.ed. All it \ndoes is hold a component handle, the DateService com\u00adponent in this case, and provides an interface for \naccessing that handle. Thorn enjoys two communication models. The Dining Philosophers used the send/receive \nmodel, which is suit\u00adable for intricate communication patterns. The dating ser\u00advice uses the serve model, \nmore suitable for client/server and RPC-style coordination. Thorn components can have communication declarations \nwhich de.ne code to be exe\u00adcuted upon receipt of certain messages. The DateService component de.nes three. \nThe sync communications (here register and makeMeAMatch) return a value to the sender, and, thus, are \nblocking. The async communications (here, stop) return nothing and are not blocking. An expression of \nthe form datesvc <-> register(\"Whale\", whale) sends a message to a component then awaits a reply (in \nthis case, a string). Alternatively, a message can be sent asynchronously, as in datesvc <--stop(), in \nwhich case the sender contin\u00adues on without waiting for a reply. The difference between c <<< v and c \n<--m(s) is that former tosses the value v into c s mailbox with no further semantics implied, while the \nlatter evaluates the body of c s async named m. Thorn s built-in types include lists, records, and a \npower\u00adful associative table type. The expression {: source:sender, name, profile, picked:[name] :} in \nthe register method is a record constructor. It yields a record with four .elds (source, name, profile, \npicked). For convenience, an iden\u00adti.er occurring alone in a record constructor serves as both .eld name \nand value, so name abbreviates name:name. The expression [name] constructs a list with a single element. \n spawn DateService { import dating.*; var done := false; val customers = table(name) { val source, profile; \nvar picked; }; async stop() { done := true;} sync register(name, profile) from sender { if (customers(name)==null) \ncustomers(name) := {: source:sender, name, profile, picked:[name] :}; null; } sync makeMeAMatch(name) \n{ if (customers(name) ~ +r) findMatchFor(r); else {: failed: \"Please register first!\" :}; } fun findMatchFor({: \nprofile:pr, name:nm, picked :}) { first(for {: profile:pr , name:nm :} <~ customers, if pr.compatible?(pr \n) &#38;&#38; !(nm in picked)) { customers(nm).picked := nm :: picked; return {: date: nm :}; } else return \n{: failed: \"No match\":}; }findMatchFor body { registry() <-> registerDateSvc(thisComp()); while (!done) \nserve; } }DateService; spawn SampleClient { import dating.*; body { datesvc = registry() <-> dateServicePlz(); \nporpoise = Profile([ {: topic: \"swimming\", weight: 15:}, {: topic: \"moon\", weight: 7:}, {: topic: \"watersports\", \nweight: 10:}], 10); whale = Profile([ {: topic: \"swimming\", weight: 15:}, {: topic: \"singing\", weight: \n10:}, {: topic: \"watersports\", weight: 3:}], 5); # Register some clients... datesvc <-> register(\"Porpoise\", \nporpoise); datesvc <-> register(\"Whale\", whale); # Exercise the dating service. date = datesvc <-> makeMeAMatch(\"Porpoise\"); \n#...a whale noDate = datesvc <-> makeMeAMatch(\"Porpoise\"); #...failure } }SampleClient; Figure 3. Dating \nService program in Thorn. Conceptually, a table such as customers in DateService is simply a collection \nof records, or rows, de.ned over a common set of .eld names, or columns. The subscripting expression \ncustomers(name) retrieves the row whose key equals name, or null if there is no such row. A table is \ncre\u00adated with an expression such as table(name){val source, profile; var picked;} which yields a new \ntable mapping names to three values. Thorn has a rich collection of query expressions, e.g., first which \nseeks a suitable set of values and binds them to variables if they exist, or executes an else clause \nif they do not. The serve statement in the body of DateService and registry explicitly waits for a single \nincoming message: one of the component s syncs or asyncs. Incoming messages to a component are queued \nand their corresponding com\u00admunication bodies are executed serially. Each component has only a single \nthread of control. Data races are impos\u00adsible. They are replaced by message races, which are gener\u00adally \nmore benign: programmer error may result in operations happening in the wrong order, but not happening \nsimultane\u00adously. 3. Related Work Designing Thorn, we carefully examined a variety of pro\u00adgramming languages: \nJava, Scala, Perl, Python, Smalltalk, Lua, Ruby, JavaScript, Haskell, ML, Scheme, Lisp, Er\u00adlang, and \nothers. Thorn takes some aspects of these lan\u00adguages and extends them with novel variations. The syn\u00adtax \nof Thorn is in.uenced primarily by Scala [37] and Python [57]. Thorn supports a class-based object model, \ndescribed in Section 4.1, similar to Java s or Scala s, but simpler to program. Thorn supports multiple \ninheritance with restrictions to avoid the diamond problem. Other re\u00adcent languages [50, 42, 37, 3, 31] \ndistinguish between dif\u00adferent modes of inheritance for different kinds of entities (e.g., interfaces, \ntraits, mixins) to avoid these problems. Like Kava [7] and X10 [41], Thorn provides pure classes, which \nencourage a functional programming style while preserving the extensibility and .exibility of object-orientation. \nThorn provides pattern matching features in.uenced by ML data types [29, 33], Scala extractors [17], \nactive patterns [53], views [58], and more directly from our previous on Match\u00adete [23]. Thorn includes \nassociative data types and queries which are inspired by the design of SETL [43], SQL [13], LINQ [32], \nHaskell s list comprehensions [24], and CLU iterators [30]. Thorn s module system is based upon the Java \nModule System [51, 52]. Most scripting and concurrency-oriented programming languages have poor support \nfor modularity, often lacking even weak hierarchical visibility (selective ex\u00adporting combined with optional \nre-exporting) and support for versioning. For example, Ruby [54] only focuses on code reuse with its \nmixins [11]. Erlang s modules [1] sup\u00adport selective importing and exporting of functions, where imported \nnames are automatically merged into the local namespace, which leads to fragile module de.nitions. In \nPython [2], each source .le creates its own namespace, which depends on its location in the .le system. \nWhile se\u00adlective importing is supported, the imported names can eas\u00adily be merged with the local namespace, \nagain leading to fragility. PLT Scheme [18] is a rare exception, de.ning an expressive module system \nthat supports both weak hierarchi\u00adcal visibility, versioning, selective importing, and renaming. But, \nas with Python, each source .le de.nes a module, and imported names are merged into the local namespace. \n Inspired by Erlang [1], actors [6, 37, 47], and lan\u00adguages like Concurrent ML [40], Thorn supports concurrent \nand distributed programming through lightweight single\u00adthreaded components that communicate asynchronously \nthrough message passing. Thorn components are logically separate. This style of distributed programming \nimproves system robustness by isolating failures. Clojure [15] sup\u00adports asynchronous message passing \nthrough agents. Agents react to messages and can update a single memory lo\u00adcation associated with the \nagent. Recent languages for high-performance computing such as X10 [41, 14] and Chapel [12] support partitioned \nglobal address spaces; these languages permit references to remote data, and hence do not readily support \nfailure isolation. A central idea in Thorn is that it supports the evolution of scripts into programs \nthrough optional annotations and compiler plugins. Pluggable and optional type systems were proposed \nby Bracha [10]. Compiler plugins use the type annotations to reject programs statically that might other\u00adwise \nhave dynamic type errors. By contrast, Thorn plugins can perform arbitrary transformations of the program. \nJava 5 [50] annotations adapt the pluggable type system idea to Java, which retains its original type \nsystem and run-time typing semantics. JavaCOP [5] is a pluggable type system framework for Java annotations \nin which annotations are de\u00ad.ned in a meta language that allows type-checking rules to be speci.ed declaratively. \nThorn provides a richer annota\u00adtion language than Java s, permitting arbitrary syntactic ex\u00adtensions \nthat enable more natural domain-speci.c annota\u00adtions rather than requiring that annotations .t into a \nnar\u00adrow annotation sub-language. An instance of optional an\u00adnotations in Thorn is its gradual typing \nsystem. This type system builds on recent work on gradual typing in dynamic languages [4, 44, 21, 45, \n56, 55]. The Thorn compiler is built on an extensible compiler in\u00adfrastructure, providing a compiler \nplugin model similar to X10 s [35]. Plugins support both code analysis and code transformations. The \ndesign of the compiler itself is based on the design of the extensible compiler framework Poly\u00adglot [34]. \nThe meta-programming features and syntax ex\u00adtension features of Thorn were in.uenced by Lisp [48] and \nScheme macros [46]. Thorn is one of many dynamic languages and scripting languages implemented on the \nJVM [27, 25, 8, 15, 28]. We examined the implementation of several of these languages when designing \nThorn to avoid some of the performance pit\u00adfalls. For example, the decision to disallow dynamic exten\u00adsion \nof objects was motivated by the requirement that objects be implemented ef.ciently. Unlike Groovy [8], \nfor instance, we do not use re.ection to implement method dispatch. 4. Thorn for Scripts Thorn data can \nbe classi.ed into the categories listed in Fig\u00adure 4. Every datum in Thorn, including atomic values such \nas integers, is an instance of a primitive object. Conceptually, a primitive object is a bundle containing \nsome state (perhaps mutable) and a collection of methods (possibly empty). We will use the term object \nexclusively for referring to instances of classes, and data created using the object construct. Class \nand component de.nitions are not data in Thorn, though class and component handles are. atomic value \nboolean, numerics, immutable string record immutable set of named values list immutable vector of values \ntable mutable associative aggregate ord mutable ordered collection object anonymous or class instance \nclosure anonymous or named function component handle lightweight process reference Figure 4. Thorn data \ncategories. 4.1 Classes Some scripting languages have a very slippery (or, if you prefer, .exible) concept \nof class . Lua, and to some extent JavaScript, lets programmers de.ne their own concept alto\u00adgether. \nRuby and Python are not quite this extreme, but ob\u00adject structure is determined at runtime. In such languages, \nit would be perfectly normal to have a class Person, one instance of Person that has a name .eld, and \nanother that does not. If programmers take advantage of this feature, their code is likely to be dif.cult \nto understand or maintain. Thorn has a more concrete concept, hearkening to the statically\u00adstructured \nworld of Java and C++. A class statically deter\u00admines the structure of its instances: their .elds, methods, \nsuperclasses, and so on. The syntax for classes is relatively lightweight. Formal Class Parameters. Inspired \nby Scala, Thorn classes can be de.ned with formal parameters, which induce .elds, constructors, and the \nextractors introduced in Section 4.2. For example, class Point(x,y) {}  abbreviates the more Java-like \nclass Point { val x; val y; new Point(x ,y ) { x = x ; y = y ; } } Class formals passed as arguments \nto parent classes do not induce variables. So, the following declaration produces a subclass of Point \nwith one new .eld t. class TastyPoint(x,y,t) extends Point(x,y) {} Methods. Methods are introduced by \nthe keyword def and are called by the traditional r.m(x,y) syntax.1 As in Scala, single-expression methods \ncan be introduced with a compact syntax, and methods whose bodies are larger can use {}\u00adblocks. class \nRectangle(xl, yl, xh, yh) { def well_formed?() = xl < xh &#38;&#38; yl < yh; def area() { if (this.well_formed?()) \n{(xh-xl) * (yh-yl);} else throw \"Degenerate rectangle\"; } } Instance Variables. The treatment of instance \nvariables is a sweetened version of Smalltalk s. An object s instance variables are visible inside its \nde.nition; no other object s are. Thorn provides default getters and setters for all in\u00adstance variables, \nunless the user has provided different ones. From outside, all access to .elds is done by method call. \nThe syntax x.f is simply an abbreviation for the nullary method call x.f(), and x.f:=g; is sugar for \nx. f:= (g);.2 The class A below, from outside, seems to have var .elds including b, c, and e, and val \n.eld d. a.b:=a.b+1 will incre\u00adment the b .eld of Aa. a.c:=3 will work, but a.c:=4 will not, as assignment \nto the c .eld is specialized to only work for primes. There is no instance variable named e, but A s \nbe\u00adhave from the outside as if there were one: a.e:=a.e+1; does just what one would expect. Attempts \nto access the repre\u00adsentation variable secret from outside the class will always throw exceptions. class \nA{ var b; # implied getter: def b() = b; # implied setter: def b:= (b2){b:= b2;} var c; # implied getter: \ndef c() = c; def c:= (v) { if (v.prime?) c:=v; } val d=1; # implied getter: def d() = d; var secret; \n1 Unlike Java, the receiver r is required, even when it is this. Otherwise it would not be possible to \ndistinguish between a call to a function f and a call to a method named f, or, more confusingly, a method \nnamed f that the class itself does not de.ne but some subclass does. 2 Nearly any string can be used \nas an identi.er, by surrounding it in back\u00adquotes. This is used for methods with symbols as names, such \nas f:= (.eld assignment) and + (addition operation). def e() = secret; def e:= (v) { secret := v; } def \nsecret() {throw \"Please don t\";} def secret:= (x) {throw \"Please don t\";} } Many scripting languages \nhave all .elds actually public, which is delightfully convenient in the short term, but in\u00adhibits good \nsoftware engineering practices like data hid\u00ading and enforcement of representation invariants in the \nlong term. Our approach retains the convenience by default all .elds appear public but, since the actual \nrepresentation is always defended by an abstraction barrier, allows good prac\u00adtices as well. Constructors. \nConstructor invocations look like function calls: A() creates a new instance of the class A. Constructors \nare de.ned with the new keyword. Within the constructor body (and only there), new may be called with \narguments to evaluate the code of another constructor, rather the way that this can be called with arguments \nin Java. A cons cell class could be de.ned: class Pair { val fst; val snd; new Pair(f,s) { fst = f; snd \n= s; } new Pair(f) { new(f,null); } } New pairs can be created by calls like Pair(1,2), or, where snd \nis to be null, Pair(3). The class Pair has two immutable val .elds, which must be bound exactly once \ninside the constructor and cannot be rebound thereafter. A pernicious source of errors in many languages \nis the ability of a constructor to leak references to the object be\u00ading constructed before it is fully \ninitialized, exposing state changes in immutable .elds. Thorn disallows the use of this inside constructors, \navoiding this problem. There are, of course, situations where one needs to refer to a newly\u00adconstructed \nobject; e.g., it is sometimes desirable to put ev\u00adery Person object into a list. Such bookkeeping can \nbe put into the distinguished init() method, that, if present, is called after the constructor body but \nbefore the constructor returns, and, like any method, can refer to this. Multiple Inheritance. Multiple \ninheritance, in its full gen\u00aderality, is extremely powerful but sometimes extremely con\u00adfusing. Thorn \nsupports a restricted form of multiple inheri\u00adtance, designed to be reasonably straightforward to under\u00adstand \nand to give most of the advantages of fuller forms of multiple inheritance with only a modest amount \nof ex\u00adtra work. The following is the de.nes a class TastyPoint as the composition of two classes, Point \nand Flavor. class Flavor(fl) {} class TastyPoint(x,y,fl) extends Point(x,y), Flavor(fl) {} The .rst \nknot that Thorn cuts is method precedence. If Point and Flavor were expanded to provide a predicate nice?(), \n but TastyPoint were not, what would tp.nice?() do? Some languages have elaborate precedence rules to \ncontrol this situation. Thorn simply forbids it. If two parents of a class both have a method with the \nsame name and arity, then the class must override that method. Often the code for this de.nition will \ninvolve a supercall to one or the other parent s method, using the super syntax to say which to call: \ndef nice?() = super@Point.nice?() &#38;&#38; super@Flavor.nice?(); The second knot that Thorn cuts is \nmultiple inheritance of mutable state. If class A has a single var .eld a, and B and C both extend A, \nand D extends B and C, then how many .elds do instances of D have? In some cases, it is desirable for \nthe a inherited from B to be the same as that from C; in other cases, they should be different. If they \nare the same, which constructor gets to initialize it? C++ has a subtle answer to these questions. Thorn \nhas a simpler answer: multiple inheritance of mutable state is forbidden altogether. Similar restrictions \nforbid inheritance of immutable .elds that could be .xed at different values depending on which inheritance \npath is taken. Anonymous Objects. It is sometimes convenient to have anonymous objects: that is, to construct \nan object without bothering to code a whole class for it. Java uses anonymous objects extensively for \ncallbacks, comparators, and other bits of code packaged to be .rst-class. They are less important in \nThorn, since Thorn has closures and is not as fussy about types. Nonetheless, they can be convenient. \nThey are built thus: fun makeCounter() { var n := 0; object { def inc() {n += 1;} } } Each call to makeCounter() \nproduces a separate counter object. Making n a .eld of the object, or returning a closure, would be more \nidiomatic Thorn. Operator Overloading. Just like in Smalltalk, operators are implemented through method \ncalls: 1+2 is syntactic sugar for 1. + (2). The usual .ora of operators are al\u00adlowed to be called without \nthe dot syntax. Like in Ruby but unlike Smalltalk, operator expressions have their tradi\u00adtional precedence \nhierarchy. So, 1+3*2 is correctly treated as 1. + (3. * (2)) rather than Smalltalk s (1. + (3)). * (2). \nSince Thorn is untyped, operations on all objects (e.g., user\u00adde.ned Complex numbers) have the same precedence \nhierar\u00adchy.  4.2 Pattern Matching Thorn provides a powerful set of facilities for matching pat\u00adterns \nand extracting data from objects and built-in data struc\u00adtures. Patterns provide a good way to specify \nthe expected structure of values, and to disassemble them and use their parts. This mitigates some of \nthe disadvantages of having an untyped language. Indeed, it provides expressive power beyond most type \nsystems: pattern matching can be used to check that this list contains three elements just as easily \nas this list contains only integers . It also provides a degree of convenience that programmers will \nappreciate. Several con\u00adstructs in Thorn do pattern matching; for this section we only use exp ~ pat \nwhich returns true if exp s value matches pat, and false otherwise. Most built-in types provide patterns \nthat parallel their constructors. For example, as an expression, 1 is an inte\u00adger; as a pattern, 1 matches \nprecisely the integer 1. As an expression [h, t...] produces a list whose head is h and whose tail is \nt, a synonym for h@t. As a pattern, it matches such a list; e.g., it would match the list [1,2,3,4] binding \nh to 1 and t to [2,3,4]. Some built-in pattern constructs do not correspond to Thorn types: +p matches \na non-null value that matches p. $(e) matches the value of the expres\u00adsion e, and (e)? matches if the \nboolean expression e eval\u00aduates to true. Type tests are available in patterns as well: [x:int, p:Person] \nmatches a two-element list containing an integer followed by a Person. The conjunctive pattern p &#38;&#38; \nq matches a value that matches both p and q. For example, r &#38;&#38; {: source:$(sender) :} matches \na record whose source .eld is equal to sender it may have an arbitrary set of other .elds as well and \nbinds that record to r, thus behaving like ML s as. However, &#38;&#38; is more powerful than as. The \npattern [_..., 1, _...] &#38;&#38; [_..., 2, _...] matches a list containing both 1 and 2 in either \norder. x &#38;&#38; (x>0)? matches a positive number and binds it to x. This trick eliminates the need \nfor side conditions in pat\u00adtern expressions, and allows .ner control of when pattern matching is stopped \nthan side conditions do: the match lst~[x:int &#38;&#38; (x != 0)?, $(32 div x)] is true on [4,8] and \nfalse (rather than dividing by zero) on [0,0]. Thorn also has disjunctive and negative patterns. p||q \nsucceeds if either p or q succeeds, and !p succeeds iff p fails. For example, [(3||!(_:int))...] matches \nlists whose in\u00adtegral elements are all 3, such as [3, true]. Note that this could not be expressed as \nnicely as a Boolean combination of non-Boolean patterns. These patterns produce no externally\u00advisible \nbindings. It is often desirable to look for something, and return it if it was found, or a note that \nit was not found otherwise. Thorn s idiom for this uses the +e operation, and its inverse the +p pattern. \n+e (pronounced positively e ) packages the value of expression e in a way guaranteed to be non-null. \n+p matches a subject that is non-null, and, when + is in\u00adverted, matches p. E.g., +1~+x is true and binds \nx to 1, and +null~+y is true and binds y to null, but null~+z is false. This pair of operations gives \na convenient idiom for func\u00adtions that search for something and return what they .nd. For instance, assoc(x,lst) \nsearches a list of 2-element lists lst for a list whose .rst element is x, and returns the second element \npackaged with + to distinguish the case where the second element is null from the case where x was not \nfound. fun assoc(x, []) = null; | assoc(x, [[$(x), y], _...]) = +y; | assoc(x, [_, tail...]) = assoc(x,tail); \nThen, assoc(a,b)~+c will succeed and bind the value b associates with a to c, or fail if a is not found. \nThe functionality of +e could be achieved by boxing e, and having +p unbox it. However, this operation \nis quite common in Thorn, and we do not want to pay for all the boxes. So, Thorn avoids constructing \nnew data structures in nearly all cases. +x == x for nearly all Thorn values. Obvi\u00adously, +null cannot \nbe null, so it is an otherwise undistin\u00adguished constant not used for anything else as are ++null and \nso on, though they rarely arise in programs. Patterns may be nested arbitrarily. Bindings produced by \nmatching are available to the right of the binding site: [x,!$(x)...] matches a list of size two or more, \nwhose later elements are not equal to the .rst element. Quite intricate structures can be described quite \nsuccinctly in this way, and, if one is careful, they can even be understood with suf.cient study. The \nformal parameters of classes de.ne extractors, in\u00adverse to their default constructors. So, for the class \nde.ni\u00adtion class Point(x,y){}, we can use Point as an extractor. Matching Point(1,2) against pattern \nPoint(1,z) succeeds and binds z to 2. Matching Control Structures. Matching is used in a num\u00adber of contexts. \nThe match construct matches a subject against a sequence of patterns, evaluating a clause for the .rst \nthat matches. One way to write the function to sum a list is: fun sum(lst) { match (lst) { [] =>{0;} \n| [h,t...] => { h + sum(t); } }} Functions and methods can match on their arguments. An\u00adother way to \nwrite sum is: fun sum([]) = 0; | sum([h,t...]) = h + sum(t); The binding operation = allows patterns, \nnot just simple variables, on the left. For example, [h,t...]=lst binds h and t in the following code \nif lst is a nonempty list, and throws an exception if lst is anything else. This is use\u00adful for destructuring \nin the Lisp sense: when one is cer\u00adtain what some structure is, and wishes to take it apart and use the \npieces. Iteration over a list includes destructuring. So, to loop over a list of two-element pairs, one \nmight use for([fst, snd]<-pairs). When one is less certain, the ~ operation is used. s~p matches subject \ns against pattern p, returning true or false. It also introduces the bindings inspired by p into code \nthat the match guards, i.e., that is obviously evaluated iff the match succeeds. A conjunction of patterns \nin the test of an if introduce bindings into the then-clause. The function zip, turning two lists into \na list of pairs (zip([1,2,3],[11,22]) =[ [1,11], [2,22] ]) can be written: fun zip(a, b) { if (a ~ [ha, \nta...] &#38;&#38; b ~ [hb, tb...]) { # ha, ta, hb, tb are bound here [ [ha, hb], zip(ta,tb)... ]; } \nelse { []; # They re not bound here. } }  This behavior combined with + gives the Thorn searching idiom. \nTo do something with the value associated with a in B, as in the previous section: if ( assoc(a,B) ~ \n+c ) doSomething(c); else dealWithMissing(a);  Similarly, matches in while loops produce bindings in \nthe loop body. p = Person(); thingsHappen(p); while (p.spouse ~ +q) { # q is bound to p s spouse here \notherThingsHappen(p,q); } # Now p is not married and q is unbound. Dually, until loops can produce \nbindings after the loop. The plot of many romance novels can be formalized as: p = Person(); do { seekSpouse(p) \n} until (p.spouse ~ +q); # q is bound to p s spouse here.  4.3 Built-in Data Types Thorn enjoys a selection \nof built-in data types, with their constructors, pattern matches, and methods. Strings are ordi\u00adnary \nimmutable Unicode strings. As in some other scripting languages, the $ character interpolates values \ninto strings: x = \"John\"; \"Dear $x\" evaluates to \"Dear John\". Ranges are .nite lists of consecutive integers: \n1..4 has elements 1,2,3,4. Ranges are, of course, implemented ef.\u00adciently. Ranges are a useful utility \nclass: e.g., for(i<-1..4) is an ordinary loop over integers; lst(1..4) is a slice of the list lst; and \nn mod 2..5 is the number between 2 and 5 con\u00adgruent to n mod 4. Lists are immutable ordered collections. \nThe term [a,b,c] constructs or matches a .xed-size list. A post.x ellipsis ... in a list expression indicates \na sublist to be appended or matched. So, the standard map function could be de.ned as: fun lstmap(f, \n[]) = []; | lstmap(f, [x, y...]) = [f(x), lstmap(f,y)...];  Lists can be subscripted: lst(0) gets the \n.rst element, lst(-1) the last element, and lst(1,-1) is the tail of lst. Records are .nite collections \nof immutable named .elds. The syntax {: a:1, b:2 :} is used for record constructors and patterns. A lone \nidenti.er a abbreviates a:a in a record. The selector r.a gets single .elds from records; pattern matching \ncan get several .elds out at once. Both .eld se\u00adlector and record pattern notation get .elds out of objects \nas well, albeit mediated by methods. This allows script-writers to start out using records, and, if more \nexotic behavior is nec\u00adessary, upgrade to objects, and the record-based code will generally continue \nto work. 4.4 Tables The table type is a generalized map, or variation on a theme of a database table. \nHere s the customers table from Fig\u00ad ure 3, which stores, for each customer, a name, pro.le, and other \ninformation: customers = table(name) { val source, profile; var picked; } Tables have a statically-determined \nset of columns describ\u00ading the information they hold (name, source, etc.), and a dynamically-determined \nset of rows expressing the informa\u00adtion currently in the table. The columns are named by Thorn identi.ers; \nthe table can be regarded as a set of records whose .elds are the columns of the table. One or more columns, \nthe key(s), look like formal param\u00adeters to the table. The vector of keys determines a unique row of \nthe table, and can be used as a subscript to get a row of the table as a record. So customers(n) looks \nup the customer whose key (name .eld) has value n. The following destruc\u00adturing assignment lets us get \nthe corresponding profile and picked .elds (note that the pattern matching semantics of destructuring \nassignment allows us to pick out just a subset of the row .elds if we wish): {: profile, picked :} = \ncustomers(n); Rows can be inserted by a method call: customers.ins({: name, profile, source, picked:[] \nor, using the key: case of maps or dictionaries, associating one datum to a single key, appears in many \nscripting languages. Thorn has syntactic sugar to let tables serve as maps. Programs using maps instead \nof tables frequently evolve to have several parallel maps, having in effect a poor man s table structure. \nSo, Thorn maps are also tables; upgrading from one column to several neither requires introducing extra \ndata structures nor breaks extant code using it as a map. A single non-key column of a table may be singled \nout by the map keyword. m= table(k){map var v; val a; }; Subscripting such a table with brackets gets \nthe map .eld. The usual subscripting with parentheses still works, and still gets the whole row: m(1) \n:= {: v:2, a:3 :}; #(*) # m[1] == 2 # m(1) == {: k:1, v:2, a:3 :} (*) m[1] := 22; # m(1) == {: k:1, \nv:22, a:3 :} (*) Adding a new column b to m would require just the code which inherently mentions all \ncolumns, (*) ed above. The other lines, which work with just the map .eld, would not need to be changed. \nThe construct map() constructs a table with key k and a map var .eld v.(k and v are hardwired into this \nconstruct.) This, plus the subscripting-with-[] syntax, provides the fa\u00admiliar maps and dictionaries \nof many scripting languages as a special case of a more powerful table construct. Further\u00admore, at need, \nmap() can be expanded into a table declara\u00adtion with more columns. 4.5 Ords Thorn lists are immutable, \nwhich is the right behavior for most situations. However, it is sometimes useful to have mu\u00adtable ordered \nstructures. Thorn provides the ord, short for ordered table . Like tables, ords have many .elds, one \nof which can be designated by map to be of particular interest. Like tables, ord() produces an ord of \na .xed simple struc\u00adture, which is often a good place to start. primes = ord(); :}); for (i <-2 .. 12) \nif (i.prime?) primes @= i; #add a value to end primes @= i adds a new row to the ord, with the map .eld \ncustomers(name):={: profile, source, picked:[] :}; set to i and all other .elds (if any) null. As with \ntables, or deleted by key. adding a new .eld to an ord is straightforward, and obviates customers(\"Whale\") \n:= null; the need for constructing parallel lists of related data. A row can be added as follows: This \nis semantically sound because the row of values being emails = ord{ var name, address }; inserted with \nthe previous operation is never null. In a table, for ( {: name, email :} <-dataset) var .elds can be \nupdated without requiring the whole row to emails.add( {: address:email, name :} ); be replaced: Ords \nallow integer subscripts, and can be mutated via them: customers(n1).picked := y.n2 :: picked; emails(0) \n:= null; # delete first entry Tables work nicely when one wishes to associate several emails(2).name \n:= \"Kim\"; # modify field of second pieces of information with one or more keys. The common  4.6 Queries \nThorn has a constellation of queries, which encapsulate a variety of common patterns of iteration, decision, \nselection, and grouping over collections. They are inspired by list com\u00adprehensions, higher-order libraries, \nand database queries. All of these could be done by the loops and conditionals you have written ten thousand \ntimes. Encapsulating them as queries makes them more convenient and less error-prone, and may introduce \noptimization opportunities. The queries all use the same set of controls, which de\u00adtermine how iteration \nwill proceed and what values are bound to what. Controls inspire iteration (for), or .lter it (if, while), \nor manipulate bound values (var, val). We start with list comprehensions. To compute the list of squares \nof primes up to 100: %[ n*n | for n <-1..100, if prime?(n)] The % symbol is used to distinguish queries; \noperations with [] produce lists, {} tables, and () arbitrary data. The while query control stops iteration \naltogether when a test becomes false, and val allows simple bindings. A crude primality test can be de.ned \nas: fun prime?(n) = %some(n mod k == 0 | for k <-2 .. n-1, while k*k <= n) The %sort query returns a \nlist sorted on some keys. %< keys are sorted in ascending order; %> in descending. To sort some people \nby last name, and, for those sharing a last name, by .rst name: %sort[ p %< p.lastname %< p.firstname \n| for p <-some_people] The var query control allows pseudo-imperative accumu\u00adlation of partial results, \nlike reduce in Common Lisp or fold_left in ML. var sum:=0 %then sum+n means that sum is zero before the \n.rst iteration, and sum+n on each succes\u00adsive iteration. The %after query returns a value from after \nthe last iteration. (Iteration-bound variables like n are not available in the result, but var variables \nare.) The sum of a list can be computed as: %after( sum | for n <-L, var sum:=0 %then sum+n ) Some operations \ndo not make sense without at least one iteration; e.g., computing the maximum of a list. %then1 handles \nthis case; on the .rst iteration, m is bound to the .rst value of n, and on later ones, to max(m,n): \n%after(m | for n <-L, var m := n %then1 max(m,n)) Dually, the %first query returns a value from the .rst \nitera\u00adtion. This is useful in searching, and so it can also be written %find. It throws an exception \nif no value is found, or, with an additional clause, can be given a value to return instead. To .nd the \n.rst record in custs whose src .eld is snd, one can use: row = %find(r | for r <-custs, if r.src == snd); \n This query has a statement form, written first or find: find(for r <- custs, if r.src == snd) { println(\"Found \n$r\"); } else { println(\"Not found\"); } This kind of search happens quite frequently, and it would be \na shame if we had a powerful pattern matching idiom but couldn t search a list for an element matching \na pattern. for has two alternatives. The form we have seen before is for [fst,snd]<-pairs, which will \nthrow an exception if any element of the list doesn t match the pattern [fst,snd]. The searching form \nuses <~ rather than <-, and simply skips non-matching elements. So .nding the .rst record in custs with \nsrc .eld equal to snd can be written: row = %find(r | for r &#38;&#38; {:src:$(snd):} <~ custs); Boolean \nquanti.ers %every, %some and integer quanti.er %count can detect whether a predicate is always true, \nsome\u00adtimes true, or count how often it is true. To tell how many friendships there are between A and \nB: %count(a.likes?(b) | for a <-A, for b <-B) To produce a table giving several pieces of information \nabout each of several things, use %table. The syntax echoes table, except that all .elds must be initialized. \nThe follow\u00ading produces a table of elementary arithmetic operations: %table(x =x, y= y){ sum = x+y; prod \n= x*y; diff = x-y; | for x <-1 .. 100, for y <-1 ... 100} As database programmers discovered long ago, \nit is often useful to aggregate information: GROUP BY in SQL; %group in Thorn. A characteristic use of \nthis is to split a list based on whether or not the elements satisfy a predicate. The follow\u00ading code \ncomputes the lists of primes and composites up to 1000 in a single pass, and their number and their root-mean\u00adsquare, \ndeclaratively. The common special cases %count and %list X evaluate to the number of items in the group \nand the list of values that X takes. %first F%then T%after A allows a fairly general accumulation of \nvalues, F for the .rst one, and T for later ones, and then uses A (if supplied) to pro\u00advide the .nal \nresult. In this case, rms is used as an accumu\u00adlator to calculate the sum of squares in the %first and \n%then clauses, and converted to the actual RMS by the %after. prime_or_not = %group(prime=n.prime?()) \n{ map numbers = %list n; number = %count; rms= %first n*n %then rms+n*n %after sqrt(rms / n); | for n \n<-1 .. 1000;}; primes = prime_or_not[true]; rmsComposites = prime_or_not(false).rms;  4.7 Equality \nand Identity The intent of equality is that a==b means that a and b have the same state at the moment. \nThe == operator is provided automatically for built-in data types and for pure classes (see Section 5.4) \nto check structural equality, and is sim\u00adply not de.ned by default on other classes (but can be pro\u00advided \nby users). Object identity is a different matter, and, unlike Java, for example, Thorn tries to avoid \nconfusing identity and equality. Objects can get a VM-local identity by extending the system class Identity. \nIdentity de.nes a unique identity for all objects that extend it. The value of the identity .eld is unspeci.ed. \nHowever, Identity imple\u00adments the method a.same?(b) that returns true iff a and b are the same object. \nFor distributed applications, the class GlobalIdentity gives an object a globally unique identi.er. The \nreasons for splitting global and local identity into sepa\u00adrate concerns are purely pragmatical. Guaranteeing \nglobally unique ids is tricky and may degrade performance. Most ob\u00adjects will only need local identity, \nand the refactoring step for a class that needs to evolve into a distributed system is a simple one. \n5. Concurrency in Thorn Scripting languages are heavily used for running web sites and similar Internet \nprograms. Quite large businesses and organizations implement massive amounts of web function\u00adality in \nRuby, Python, or Perl, none of which was designed with web programming as a primary initial goal. Thorn \nfo\u00adcuses on distributed and concurrent computing. In the distributed setting in particular, entities \nrunning at the same time are, potentially, physically and logically quite separate. They can, potentially, \nfail independently: it is quite normal for two processes to have a conversation and one of them to fall \nsilent for seconds, or for eternity. 5.1 Components Conceptually, each Thorn process called a component \nto avoid confusion with, say, Java threads or operating system processes has a single strand of control, \nand a private data store isolated from all others. Objects are not shared, which eliminates the need \nfor locking locally and cache-updating algorithms globally. Processes communicate exclusively by passing \nmessages. The values communicated must be im\u00admutable; they can be, e.g., strings, lists, records, and \nobjects of certain classes which are immutable by construction. If objects of user-de.ned class are transmitted, \nthe re\u00adceiver must have that class available. Values constructed en\u00adtirely from built-in types (records, \nlists, tables, strings) are universal, and will be understood by any Thorn component. Indeed, they can \noften be understood outside of Thorn. They correspond roughly to the values that can be transmitted via \nthe JSON protocol [26], and should, provide a convenient way to communicate with any JSON-compliant program, \nThorn or not. The component construct de.nes a kind of component, rather the way class de.nes a kind \nof object. Components can have local var or val data, as well as functions (fun) and communication operations \n(sync and async). They have a body section, giving code that they are to run when started. For example, \na parallel Life program with many worker threads could have the general structure: component LifeWorker \n{ var region; async workOn(r) {region := r;} sync boundary(direction, cells) {...} body { ... } # code \nto run Conway s Life here. } A component can be spawned, alarmingly enough, by the spawn command: regions \n= /* compute regions */; for (r <-regions) { c= spawn(LifeWorker); c <--workOn(r); } spawn returns a \nhandle to the component, which can be used to communicate with it. Since many components are one\u00adoffs, \nspawn can take a component body as well, and indeed this is how it is most often used: c= spawn { var \nregion; async workOn(r) {region := r;} ...# as above };  5.2 High-level Communication Thorn provides \ntwo communication models. The high\u00adlevel model provides named communication, which may re\u00adquire an answer \n(synchronous, keyword sync) or not (asyn\u00adchronous, keyword async). The syntax for high-level com\u00admunication \nparallels that of methods, as shown in Figure 5. spawn { sync findIt(aKey) { logger <--someoneSought(sender, \naKey); # ... code to look it up ... return theAnswer; } body { while (true) serve;}  } logger = spawn \n{ var log := []; async someoneSought(who, what) { # do not answer, just cons onto log. log ::= {: who, \nwhat :}; } body { while (true) serve;} } Figure 5. High-level Communications.  However, communication \ndiffers from method calls in sev\u00aderal important respects the .rst one being that sending a message can \nin general have higher latency than perform\u00ading a method call, and, indeed, may never return at all even \nwhen it ought to so the syntax makes it very clear which one you are doing. Asyncs use comp <--m(x), \nand syncs use comp <-> m(x), or, if they are to tolerate the failure of the peer to answer quickly, comp \n<-> m(x) timeout(n) { dealWithIt(); } The arrows are intended to suggest both the duration and direction \nof the communication. The receiver has control over when it accepts commu\u00adnication. The serve statement \ncauses a component to wait for a single high-level communication event. serve has an optional timeout(n){...} \nclause in cases where waiting in\u00adde.nitely for a message to come in is undesirable. A typi\u00adcal reactive \ncomponent will have a skeleton of the following form: spawn { var done := false; async quit() prio 100 \n{ done := true;} sync do_something_real() { ... } body { while (!done) serve;} } The high-priority quit() \nallows the outside to stop the com\u00adponent any time it is between doing real things. It is not an interrupt. \nserve simply looks for high-priority communica\u00adtions before lower-priority ones. Often it is desirable \nfor a client to send a synchronous request to a server (response=server<->command()), and for the server \nto call upon a worker component to actually do the computation. With the model as presented so far, this \ndoes not work properly: the server would need to have code: sync command() { srvResponse = worker <-> \nsubcommand(); srvResponse; } and, by that code, the server would need to wait for the worker to respond. \nThorn thus allows split sync, allowing the server thread to pass responsibility for answering the request \nto the worker. The server code is written: sync command() envelope e{ worker <--subcommand(e); throw \nsplitSync(); } where splitSync() is a library function understood by the server s serve command as an \ninstruction not to send a response to command. The envelope e clause captures the message together with \nits metadata in variable e; the worker will need the entire envelope to respond. The worker s part of \nthe split sync is: async subcommand(e) { workerResponse = ... # compute it syncReply(e, workerResponse); \n} syncReply is a library function that sends workerResponse as reply to the message with envelope e. \nThis is transpar\u00adent to the client. The client uses the same synchronous call, server<->command(), regardless \nof whether the server s evaluation of command is ordinary or split. 5.3 Low-level Communication The \nlow-level communication model allows sending un\u00adadorned values from component to component. The state\u00adment \nc<<<v sends value v to component c. The value simply goes into c s mailbox, a list in c s underlying \ndata struc\u00adtures holding messages which c s code has not yet actively seen. A component can retrieve \nvalues from its mailbox by the receive statement, a variation on Erlang s, which scans through the mailbox, \nlooking for the highest priority mes\u00adsage that matches one of a set of patterns. When it .nds one, it \nexecutes the corresponding code block, much like a match. For example, the following looks for an emergency \nstop message anywhere in the mailbox, and stops if it .nds one. If there is none, it looks for a message \nasking it to post some data, or scan for data with some parameter p; their priorities default to zero. \nIf none of those three is present, and none arrives within ten seconds, it marks itself bored instead. \nreceive { {: stop_right_now: _ :} prio 1=> {return;} | {: please: \"post\", data: x :} => {do_post(x);} \n| {: please: \"scan\", want: p :} => {do_scan(p);} | timeout(10000) => {bored := true;} }  5.4 Pure Values \nand Messages Allowing the communication of complex values between components and computers raises some \ntroublesome issues. Consider the following Thorn fragment: var x := 0; class Counter { def incr() { x++; \n} } c <<< Counter();  This code is problematic, since the class Counter has a reference to mutable sender-local \nstate, which is inaccessible on the receiving end. It could be cloned, but that introduces a number of \ncomplexities. Cloning is not sensible for all objects, arguably including Counter: if the intent of a \nsingle Counter is to maintain a universal count, a clone will not suf.ce. Even when cloning is sensible, \nthere are subtleties: e.g., sending a single Counter to c twice should, arguably, result in c getting \ntwo references to a single clone. The situation is not much better in the following case: module M{ \nn = 10000.rand(); class RandRef { def mn() = n; } } c <<< RandHolder(); While M.n is immutable, the sender \ns and receiver s values will likely differ. One can make a good case that r.mn() should return either \nthe sender s or the receiver s value. Thorn avoids all such troublesome issues, in the same way that \nit avoids subtleties of multiple inheritance. We restrict communication to pure values, which cannot \nexhibit them. Atomic constant data types (e.g., numbers and strings) are pure. Lists and records whose \n.elds are all pure are pure. Tables are never pure; they are inherently mutable. Classes may be annotated \nas pure, which makes their instances pure. Dynamic and static checks ensure that instances of pure classes \ncannot refer to external variables or anything impure, and cannot have mutable state. Pure classes have \nconstant data. However, they can be given mutable data to operate on, and they can use local variables. \nThey can thus formalize a wide variety of com\u00adputations, albeit with the mutability supplied by the outside \nor localized within a method call. The following bit of highly imperative code adds up many values of \nf(i); when it is ap\u00adplied, it inserts all the values of i to the ord accum, as well as returning the \nsum of their squares. class C: pure { def sum3np1(f, n) { var sum := 0; var i := n; while (i !=1){ sum \n+= f(i); if (i mod 2==0)i :=i div 2; else i := 3*i+1; } sum; } }C # ... accum = ord(); fun fAdd(i) { \naccum @= i; i*i; } c = C(); someone <<< c; c.sum3np1(fAdd, 100); In addition to checking the purity \nof data that are to be sent as messages, any variable or .eld references within a com\u00adponent body and \nwhich are de.ned outside its scope must be checked for purity before the component is spawned. Like message \ndata, all such captured references must be (effec\u00adtively) copied after the component is spawned to ensure \niso\u00adlation from the spawning component. 6. Thorn for Programs Thorn is intended to support writing large \nprograms, initially as untyped prototype scripts which can then be packaged into reusable modules or \nincrementally hardened by addi\u00adtion of annotations. Thorn s syntax supports adding arbitrary constraint \nannotations to declarations. As with Java annota\u00adtions, these are intended to be used by compilers and \ntools to facilitate static analysis and optimization. We have explored a similar system in previous work \n[36], and plan to add it to Thorn in the future. 6.1 Types and Like Types Dynamic typing, sometimes \ncalled duck-typing, is .exible and allows code to operate on objects as long as the neces\u00adsary behavior \nis implemented and returns compatible results. In Thorn, the type dyn (for dynamic) is assumed as default \n(and never written explicitly). At the other extreme, Thorn supports concrete types, as used in statically \ntyped program\u00adming languages. A variable of a concrete type T is guaran\u00adteed to refer to a value of that \ntype (or a subtype). Concrete types in Thorn use nominal subtyping. When the program\u00admer declares a variable \nas int, the Thorn compiler can use a 32-bit word and integer JVM bytecodes rather than a boxed integer \nand method calls, and similarly for other primitive types. While concrete types help with performance \nand cor\u00adrectness, they introduce restrictions on how software can be used and make rapid development \nmore dif.cult; scripting languages do not favor them. As an intermediate step between the two, we propose \nlike types, getting some of the safety of concrete types while retaining the .exibility of dynamic types. \nConcrete types for var x:T or fun f(x:T) are used in two main places. At a method call x.m(), a static \ntype check ensures that x actually has an m method. At a binding or assignment, like x := y; or f(y), \na static type check can ensure that y s value makes sense to assign to x, can reject it entirely, or \ncan inspire a dynamic check. Like types, var x: like T or fun f(x:like T), give the expressive power \nof concrete type checks on method calls, but do not constrain binding or assignment. They do require \nruntime checks and thus may cause programs to fail with runtime type errors: sometimes fewer and never \nmore than dynamic types do. Like types provide three speci.c advantages over dy\u00adnamic types. 1. Documentation: \nfun f(p: like Point) explains to hu\u00admans how its argument can be used. 2. Code Understanding: Inside \nf, a programming environ\u00adment could provide code completion on p s methods. 3. Error Detection: Some \nerrors can be detected at compile time. E.g., typing p.mvoe(q) rather than p.move(q) will be caught, \nif Point has a move but not a mvoe method.  Like types provide nearly all the advantages, and nearly \nall the other .aws, of dynamic types. A variable declared to be of type like T is constrained by the \ncompiler to have methods invoked on it according to the interface of T, but at runtime may refer to any \nvalue. For example, assuming a class Point with x(), y() and move(), like types allow us to type the \nparameter to the move() method thus: class Point(var x, var y) { def x():int= x; def y():int= y; def \nmove(p: like Point) { x := p.x(); y := p.y(); # p.hog(); would raise compile time error } } Declaring \nvariable p to be like a Point makes the compiler check all method calls on that variable against the \ninterface of Point. Thus, p.hog() would be statically rejected since there is no method hog in Point. \nAs assignments and bindings to like-typed variables are unconstrained, Thorn must check at runtime that \nthe meth\u00adods called are actually present. p.move(true); would pass the static check because there is \nno static check on bind\u00ading of like types, even the binding of actuals to formals in a method call. The \ncall p.x() would fail for p==true, though our error message could be somewhat more detailed than simply \nmethod not understood . Like-typed formals, like dynamically-typed formals, are only constrained to have \nthe methods that are actually used. Consider the following Thorn singleton object: origin = object { \ndef x(): int = 0; def y(): int = 0; } origin has no move() method. It implements the relevant parts of \nPoint s protocol for move() to run successfully x() and y(). So p.move(origin) works .ne, just as with \ndynamic typing. It would not pass the static type check if move() had used concrete rather than like \ntypes. The method move() even works with an untyped Pair class Pair(x,y) { def x() = x; def y() = y; \n} In this case, the run-time return value of x() and y() would be type-tested against their explicit \nconcrete type int, so p.move(Pair(1,2)) works, but not p.move(Pair(\"f\", \"b\")). If x() and y() in Point \nwere typed like int, checking the return type would not be necessary as assigning to a like type always \nsucceeds. An important difference between like types and gradual typing systems like that of [44], is \nthat code completely annotated with like types can go wrong due to a run-time type error. On the other \nhand, a code completely annotated with concrete types will not go wrong.  6.2 Modules A language should \nprovide some form of information hiding, to encapsulate the design decisions that are likely to change. \nThis minimizes redundancy, and maximizes opportunities for reuse. Unfortunately, most object-oriented \nlanguages use classes as their main encapsulation mechanism, which does not scale well. Thorn s module \nsystem, on the other hand, provides a way to encapsulate, package, distribute, deploy, and link large \nbodies of code. The core of the Thorn s mod\u00adule system is inspired by the upcoming Java Module Sys\u00adtem \n[51, 52]. In line with our previous work [49], we: (i) use a more intuitive and expressive name resolution, \nwhere mod\u00adules become robust against interface evolution of the mod\u00adules they import; and (ii) allow \nusers to control the sharing and isolation of module instances. Namespace control &#38; robustness. To \npromote rapid pro\u00adtotyping, all module members are exported by default. Mem\u00adbers can be hidden by declaring \nthem private, and members imported from other modules can be re-exported by declar\u00ading them public. This \nlocalizes the in.uence of a single module, which is essential for scalability. Figure 6 shows a module \nM, which imports modules N under its own name N, and O under the name S. M also de.nes a class A and \na value n, both of which are exported by default, and a variable x, which is hidden from module s clients. \nM also re-exports S.C, but cannot re-export N.A. The names and aliases of members must be distinct from \neach other, as must exported and re-exported names; therefore, re-exporting N.A from M would clash with \nM.A. These two conditions guarantee that any non-fully-quali.ed name can be disambiguated, and that a \nfully-quali.ed name (e.g., N.A) is never ambiguous. The name resolution algorithm .rst checks within \nthe module s own namespace, and only then in the exported namespaces of imported modules. For example, \nin Figure 6, A resolves to a local de.nition, even though N exports A. Suppose that M de.nes B; then, \nif N and/or S started exporting B, B would still resolve to the local de.nition this is a useful form \nof robustness. Now suppose that M does not de.ne B, and that B is only exported by N; then, if S starts \nexporting B, too, a compile-time ambiguity error occurs a way to module M{ # this module is named M import \nN; # shared instance of N import own S = O; # own instance of O as S class A extends B {} # B must come \nfrom M xor N xor S val n = A(); # A is M.A var x: private = N.A(); # x not exported public S.C; # re-exported \nas M.C #public N.A; # ERROR: M.A alre ady exported } Figure 6. Thorn Modules: A simple example.  protect \nagainst such breakage is to use fully-quali.ed names (or their aliases) for names that resolve within \nimports. Sharing vs. isolation. In a single Thorn runtime, we can have multiple module instances of a \nsingle module de.\u00adnition. There can be a single shared module instance for each component, and as many \nnon-shared instances as re\u00adquired. (Nothing, of course, is shared between components.) The statement \nimport N; imports the component-wide in\u00adstance of N, while import own O; creates a non-shared in\u00adstance. \nThis approach allows the developer to share module instances when required, and to have multiple clients \nthat rely on con.icting invariants of a single module de.nition coexisting within a component [49]. In \nthe following example, A and B refer to the shared instance of NN, and thus A.n and B.n are the same \nvariable. C and D are distinct non-shared instances, and hence C.n and   D.n are different variables \nfrom each other and from A.n: module NN { var n := 0; } import A = NN; # shared instance import B = NN; \n# shared instance import own C = NN; # non-shared #1 import own D = NN; # non-shared #2 A.n := 1; B.n \n:= 2; C.n := 3; D.n := 4; # A.n == B.n == 2 # C.n == 3 &#38;&#38; D.n == 4 Module instance state. Thorn \nclasses cannot de.ne static state. However, Thorn modules can de.ne their own state, e.g., M.n and M.x \nin Figure 6. Classes within M can use module-level variables in the ways that Java classes use static \nstate. Each module instance has its own state; this is the main differentiator between module instances. \nClasses from different modules instances are incompatible because their invariants rely on different \nstate. 7. Extensibility A key design goal of the Thorn compiler is to support lan\u00adguage evolution by \nallowing the syntax and semantics to be extended through plugins into the runtime system. The architecture \nfacilitates construction of domain-speci.c lan\u00adguages based on Thorn. Unlike Java annotations, syntactic \nextension in Thorn is not limited to annotations on class or method declarations; arbitrary syntactic \nextension is per\u00admitted. This allows developers the freedom to support natu\u00adral domain-speci.c extensions \nof the core language without having to wedge these extensions into a restricted syntax. Plugins provide \na semantics for new syntax by translation into the core language. Semantic extensions can support ad\u00additional \nstatic analyses (e.g., taint checking) or code trans\u00adformations.  7.1 Plugins The runtime system provides \na number of hooks for exten\u00adsion. Plugins may add new abstract syntax tree (AST) nodes and new passes \nover the AST. Plugins may also extend the parser and other passes over the AST to support new syntax \nor new semantics. Passes added by the plugin may perform static analysis or code transformations, including \ntranslating extended abstract syntax into the base Thorn language be\u00adfore evaluation. When the Thorn \nruntime starts up the initial component, it loads the bootstrap class, which can loads one or more plugins. \nPlugins can be installed by initializing the runtime with an overridden version of the bootstrap class. \nThe loaded plugins are composed and then applied to the code in the component. Other components may be \nspawned with different sets of plugins. After plugins are loaded for a given component, parser extensions \nare composed into a sin\u00adgle parser for Thorn code loaded into the component. Once an (extended) AST is \nconstructed, plugins run their analysis and transformation passes on the AST, ending with a base language \nAST. Plugins add new passes to the compiler by registering a set of goals with the compiler s pass scheduler. \nA goal speci.es prerequisite goals and a pass to run to satisfy the goal. The scheduler ensures that \na goal s prerequisites are satis.ed before the goal s pass is run. Plugins also hook into the existing \npasses such as name resolution. This core lan\u00adguage AST is compiled to Java bytecode and evaluated or \ncompiled to disk for future execution. 7.2 Syntax extensions The base Thorn compiler provides a parser \nthat plugins can extend to implement syntax extensions. Parser extensions are speci.ed using a domain-speci.c \nextension of Thorn, itself implemented as a plugin, that supports parsing expres\u00adsion grammars (PEG). \nParsing is performed by a packrat parser [19]. Plugins export productions and semantic actions for constructing \nASTs. When the plugin is loaded, these new productions are composed with the current parser to create \na new extended parser. The parser plugin translates the PEG grammar speci.cation into a Thorn class that \nimplements the parser. Since packrat parsers are scannerless, plugins can de.ne their own tokens. Thorn \ns packrat parser supports left recursive rules using Warth et al. s algorithm [59], overcom\u00ading one of \nthe limitations of PEG grammars and simplify\u00ading development of parser extensions. Plugins may freely \nde.ne new AST node classes and have the parser generate them. AST classes implement a visitor interface \nto interop\u00aderate with compiler passes. Plugins currently cannot extend the compiler itself to support \nnew AST nodes; rather, these are translated into core language nodes for the compiler sub\u00adsequently to \nevaluate or are compiled to disk. 7.3 The Assert Plugin Figure 7 shows the complete code for a plugin \nthat adds an assert construct to Thorn. The plugin is implemented object AssertPlugin extends Plugin \n{ class AssertGoal(unit) extends def parser(_next) = AssertGrammar(_next); Goal(\"Assert\"), plugin.DesugaringGoal \n{ def prereqs() = []; class Assert(e,m) extends Exp { } def run() = unit.setAst(unit.ast().accept(AssertDesugarer())); \nclass AssertGrammar(next) extends } Delegate(next), thorn.grammar.GrammarUtil { rule Exp = assert Exp \n : String class AssertDesugarer() extends Visitor { { Assert(Exp, String) } def visit(n) { / assert \n Exp { Assert(Exp) } match (n.rewriteChildren(this)) { / next.Exp; Assert(e,m) => @ (unless(@,(e)) throw \nm) rule assert = \"assert\" Spacing? { \"assert\" }; | m => m rule Keywords = \"assert\" / next.Keywords; \n} } } } def goals(unit) = [AssertGoal(unit)]; } # end of object AssertPlugin Figure 7. An assert plugin. \nIt adds the statements assert <exp> and assert <exp> : \"Message\" to Thorn. as a singleton object called \nAssertPlugin, extending the Plugin class. The plugin s functionality is provided by sev\u00aderal nested classes. \nThe AssertGrammar class de.nes the syntax of the new construct. The parser method of the Plugin class \nis overridden to return the new grammar def\u00adinition. The new grammar will be composed with the exist\u00ading \ngrammar. By overriding the rules of the existing gram\u00admar the plugin can rede.ne the syntax, much like \nordinary overriding of methods when subclassing. Normally an over\u00adriding rule will add a delegation call \nto the overridden rule next.Exp as its last case, which calls the Exp rule of the pre\u00adceding plugin. \nThe plugin also overrides the Keywords rule to add the assert keyword. The Assert class implements the \nnew AST node that is returned from the semantic actions. The AST node inherits methods for interacting \nwith visitors. A plugin extends the compilation process by de.ning goals that, in turn, run passes over \nthe AST. The goal may have prerequisite goals required to be met before processing the plugin s goal. \nIn this example the plugin has no opinion on the order and just returns an empty list from its prereqs \nmethod. The AssertGoal class creates an AssertDesugarer visitor and applies the visitor to the AST. The \ndesugarer pattern matches on the method argument. If the argument is an Assert then the assertion expression \ne and the associated message m are extracted and used to construct a semantically equivalent unless expression. \nThe new expression throws an exception, carrying the message, if e does not hold. The @ and @, expressions \nare meta-operators (also implemented by a plugin) used to generate the AST for the unless, a feature \nin.uenced by Scheme. 8. JVM Implementation Thorn s interpreter, like many interpreters written in Java, \nis not particularly fast. The performance of the compiler is closer to what we would expect from a production \nlanguage. This section describes some of our choices in implementing the compiler. Method Dispatch. \nThorn sports several features that, at face value, are incompatible with the Java object model and the \nJVM. The most striking difference between Java and Thorn is that Thorn is dynamically typed while the \nJVM re\u00adquires type information to do method lookup and dispatch. We use the same solution as JRuby [25] \nand Jython [27], generating a dispatch interface for each method that is im\u00adplemented by all classes \nthat has a method with a matching signature. For example the method def foo(x) will generate an interface \nIfoo_1 declaring a method IObject foo(IObject). At the call site it is determined, with an instanceof \ninstruc\u00adtion, that the receiver actually implements the called method before calling the method with \nan invokeinterface instruc\u00adtion. The instanceof is used for error reports when a mes\u00adsage is not understood \nby the receiver. Multiple Inheritance. Thorn s multiple inheritance con\u00ad.icts with Java s model of single \ninheritance plus inter\u00adfaces. As a consequence, Thorn inheritance cannot be imple\u00admented as Java inheritance \nand Thorn method calls cannot simply be implemented as JVM method calls; the JVM has the wrong notion \nof supercall, and does not know which of several parent JVM classes contains the code of an inherited \nmethod. Instead, every Thorn method in every Thorn class gives rise to an instance method in every Thorn \nclass that inherits it, and a static method in the de.ning class in the JVM. The instance method simply \ncalls the static method and returns the result. The static method contains the actual compiled body of \nthe Thorn method. (We use a single static method and an extra method call to avoid massive duplica\u00adtion \nof code, and to enable separate compilation.) As men\u00adtioned earlier, Thorn forbids dispatch ambiguities, \nso there is no need to search for the right method at runtime. Field Access. Field access is done via \nJava method call. Fields inherited from Thorn superclasses are redeclared in the implementations of child \nclasses (which do not inherit from the implementations of superclasses). Furthermore,\n\t\t\t", "proc_id": "1640089", "abstract": "<p>Scripting languages enjoy great popularity due to their support for rapid and exploratory development. They typically have lightweight syntax, weak data privacy, dynamic typing, powerful aggregate data types, and allow execution of the completed parts of incomplete programs. The price of these features comes later in the software life cycle. Scripts are hard to evolve and compose, and often slow. An additional weakness of most scripting languages is lack of support for concurrency - though concurrency is required for scalability and interacting with remote services. This paper reports on the design and implementation of Thorn, a novel programming language targeting the JVM. Our principal contributions are a careful selection of features that support the evolution of scripts into industrial grade programs - <i>e.g.</i>, an expressive module system, an optional type annotation facility for declarations, and support for concurrency based on message passing between lightweight, isolated processes. On the implementation side, Thorn has been designed to accommodate the evolution of the language itself through a compiler plugin mechanism and target the Java virtual machine.</p>", "authors": [{"name": "Bard Bloom", "author_profile_id": "81100272990", "affiliation": "IBM Research, Yorktown Heights, NY, USA", "person_id": "P1728737", "email_address": "", "orcid_id": ""}, {"name": "John Field", "author_profile_id": "81100419562", "affiliation": "IBM Research, Yorktown Heights, NY, USA", "person_id": "P1728738", "email_address": "", "orcid_id": ""}, {"name": "Nathaniel Nystrom", "author_profile_id": "81100144238", "affiliation": "University of Texas at Arlington, Arlington, TX, USA", "person_id": "P1728739", "email_address": "", "orcid_id": ""}, {"name": "Johan &#214;stlund", "author_profile_id": "81388600832", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P1728740", "email_address": "", "orcid_id": ""}, {"name": "Gregor Richards", "author_profile_id": "81438595000", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P1728741", "email_address": "", "orcid_id": ""}, {"name": "Rok Strni&#353;a", "author_profile_id": "81318491338", "affiliation": "University of Cambridge, Cambridge, UNK, United Kingdom", "person_id": "P1728742", "email_address": "", "orcid_id": ""}, {"name": "Jan Vitek", "author_profile_id": "81100018102", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P1728743", "email_address": "", "orcid_id": ""}, {"name": "Tobias Wrigstad", "author_profile_id": "81323497904", "affiliation": "Stockholm University, Stockolm, Sweden", "person_id": "P1728744", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640098", "year": "2009", "article_id": "1640098", "conference": "OOPSLA", "title": "Thorn: robust, concurrent, extensible scripting on the JVM", "url": "http://dl.acm.org/citation.cfm?id=1640098"}