{"article_publication_date": "10-25-2009", "fulltext": "\n To Pull or Not to Pull Andrea Janes Center for Applied Software Engineering Free University of Bolzano/Bozen, \nItaly andrea.janes@unibz.it Abstract The Toyota Production System promotes pull scheduling to reduce \nthe production of parts that do not comply to what the customer needs. The use of pull within software \nrepresents a radical change in the way activities are planned. This article gives two examples of the \npossible application of pull within software engineering and de\u00adscribes a measurement tool to assess \nthe current costs and amount of rework within a software development project. The described approach \naims to help practitioners to under\u00adstand whether to use pull or push in their organizations. Categories \nand Subject Descriptors D.2.8 [Software]: Engineering Metrics General Terms Management, Measurement \nKeywords Lean Management, Pull, Just-in-time 1. Introduction The success of the way Toyota produces cars \n- the Toyota Production System - and its underlying philosophy lean thinking (Womack and Jones 1996) \nare evident: Toyota is the No. 1 carmaker in the world (New York Times 2009). The strategy of Toyota \nis straightforward: Our goal has never been to sell the most cars in the world. We simply want to be \nthe best in quality. After that, sales will take care of themselves (BBC News 2007). Womack and Jones \n(1996) elaborated the principles be\u00adhind the Toyota Production System coining the term lean thinking \n. The objective of lean thinking is the delivery of value to the customer. This is achieved through the \ncreation of a lean production process, which (ideally) consists only of value creating activities. This \nobjective might seem obvious: every company has Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for profit or commercial advantage and that copies bear this notice and the full cita\u00adtion \non the first page. To copy otherwise, or republish, to post on servers or to redis\u00adtribute to lists, \nrequires prior specific permission and/or a fee. OOPSLA 2009, October 25-29, 2009, Orlando, FL, USA. \nCopyright &#38;#169; 2009 ACM 978-1-60558-768-4/09/10 $10.00.   Giancarlo Succi Center for Applied \nSoftware Engineering Free University of Bolzano/Bozen, Italy giancarlo.succi@unibz.it to provide value \nto its customers. The distinctive character\u00adistic of lean thinking is the choice of its methods to achieve \nthis objective and the willingness to accept production in\u00adterruptions and local inefficiencies in exchange \nof a glob\u00adally more efficient and effective process (Ohno 1988). One of these methods is pull instead \nof push . Tradi\u00adtionally, production planning defines the production sched\u00adule individually for every \nwork station; then parts are produced independently by every work station, temporarily stored in work-in-progress \ninventories, and used from there when needed. This approach has the advantage to decouple the production \nof one work station from the remaining ones, and to be able to assemble different products using the \nparts in stock, but it requires the handling of invento\u00adries, which produce a series of costs (Ohno 1988) \nconserva\u00adtion costs, shrinkage costs, management costs, etc. The described production method represents \nthe push approach: the upstream processes produce parts and push them to the later ones. These, as soon \nas parts are available, process them further, and so on. Figure 1. A production line that uses pull \n. Using a pull approach means that only what is needed as output from the last work station is planned. \nThe last work station pulls, i.e. requests the needed parts from the previous work stations, which perform \nthe requested opera\u00adtion (if needed also requests parts from other work sta\u00adtions), and delivers the \nresult to the requester. The goal of this approach is to align the entire production to the desired output \nand so to spend resources only to produce what is valued by the customer.  The activation of the upstream \nprocesses occurs just-in\u00adtime , i.e. at the latest possible moment before a delay in the upstream process \nwould cause a delay in the entire pro\u00adduction. It is one of the fundamental assumptions of software en\u00adgineering \nthat the cost of changing a program raises over time (Beck 1999). Conventional wisdom suggests finding \nproblems as early as possible during the development proc\u00adess. The just-in-time approach takes this into \naccount and delays every decision as late as possible to avoid the risk of having to change or remove \ncode that has already been written: it is easier to change a decision that has not yet been made (Poppendieck \nand Poppendieck 2003). Pull has several advantages: (a) the costs of invento\u00adries do not arise, (b) over \nproduction is avoided, (c) if a later station discovers problems with the produced parts of earlier processes, \nthere are only few erroneous parts that have to be thrown away, and (d) the contribution of each activity \nto the final outcome becomes visible, which helps to remove unnecessary activities. The pull approach \nis also known under the name of a frequently used mechanism to trigger the different activi\u00adties: Kanban \n. Kanban means card and it is used to specify (a) pickup information (how much of what is taken from \none workstation), (b) transfer information (where should it be transported), and (c) production information \n(how much of what should be produced at one workstation) (Ohno 1988). Within software development, Kanbans \nare used to pull user stories into development. By limiting the amount of kanbans that are available \none can limit the amount of user stories currently developed, i.e., the work\u00adin-progress or in other \nwords, the amount of code that is not finished yet (Kniberg 2009). It is important to point out that \nthe use of Kanban is not a method per se; the Kanban concept is used to justify the triggering of activities; \nit is an instrument to put pull into practice. In this context, Kaban is used as an instrument to organ\u00adize \nthe activities within a team using a behavioral control mechanism (Ouchi 1977). We think that the pull \nprinciple deserves significant attention also for software production since the misalign\u00adment of development \nactivities to what provides value for the customer is still one of the major reasons for the failure \nof software development projects (El Emam 2008). The contribution of this article is twofold: first, \nwe pro\u00advide two examples of popular software development prac\u00adtices that follow a push approach and provide \npossible pull alternatives to raise the awareness among practitio\u00adners of the advantages that pull approaches \ncan offer. Second, we propose a tool to measure the amount of time that is lost due to the use of push \ninstead of pull to help practitioners to decide which approach fits their needs bet\u00adter. The article \nis organized as follows: section 2 provides two examples of the application of push within software engineering, \nsection 3 describes a tool to automatically measure and visualizes the costs and the amount of rework, \nsection 4 mentions related work, section 5 concludes with a summary and future work. 2. Push vs pull \nin software engineering The push approach is present whenever activities are triggered as soon as other \nactivities finish their work, ob\u00adtaining their output as input. The risk involved with the push approach \nis that the product or service, once it is pushed to the next activity, does not correspond to what is \nrequired for further processing. There already exist approaches within software engi\u00adneering that follow \nthe pull principle but in many cases they are not seen as such. For example, the test-first prac\u00adtice \n(Beck 2003) promotes the idea to write an executable test case first, and then the code. Studies have \nanalyzed its effect on code quality, on performance (Erdogmus and Mo\u00adrisio 2005), etc. but its underlying \npull philosophy and its benefits to concentrate on the essential are not. We present two, in our view \ncommonly used software development practices, which adopt a push approach and analyze a possible pull \nalternative: first, the practice of beginning the development collecting requirements and pushing them \ninto to the development process; and second, the practice of developing code bottom-up . Requirements-first \ndevelopment Beginning the software development process with the col\u00adlection of requirements is practiced \nin nearly all software development approaches. Some approaches try to collect all requirements up-front, \nsome iteratively collect a part of the requirements and implement them into an intermediate so\u00adlution \nuntil all requirements are implemented; still, both approaches push requirements to the development proc\u00adess. \nThe definition of requirements converts business objec\u00adtives into requirements that take into consideration \nthe technical possibilities and their costs. This step requires considering the benefits and the costs \nof a technological solution in solving a business problem. Usually the origina\u00adtors of requirements lack \nthis knowledge, which causes a large number of change requests during and after develop\u00adment (Schnabel \nand Pizka 2006). This causes costs related to the following situations: (a) the requirements do not/not \noptimally contribute to fulfill the business objectives; (b) requirements change because old requirements \nhave shown not to contribute to the fulfillment of the business objec\u00adtives; (c) the implementation of \nthe requirements costs more than an alternative implementation that fulfills the business objectives \nin the same way; (d) requirements that would contribute to the business objectives and that would not \nbe costly to implement, are not requested.  A possible pull approach can be achieved through Goal-driven \nSoftware Development (Schnabel and Pizka 2006), in which goals are collaboratively identified before \nsetting the requirements and uses these goals to pull re\u00adquirements and their priorities from the stakeholders. \nKnowing the goals, technicians can clarify issues earlier, offer ideas on what could be done to achieve \nthese goals, inform the business side on the different costs of possible alternatives to allow prioritization \nof goals, and generate the technical requirements to fulfill the overall goals. The result is a development \napproach in which require\u00adments are not refined down to an implementation , i.e., taken as the starting \npoint to develop an implementation that represents those requirements, but where the business objectives \nare mapped to the capabilities of the technical platform to equally consider and adjust business goals \nand technical aspects to come to an optimal solution corre\u00adsponding to the current situation (Schnabel \nand Pizka 2006).  Bottom-up development In bottom-up development the development begins with building \nblocks that will be used to create those parts that the end customer requires; similar to the process \nof build\u00ading a house: the fundaments are built first. When develop\u00ading top-down, the designer begins \nby determining what overall functions will be performed by the software system, in what order, and under \nwhat conditions. He then proceeds to develop a working top-level computer program, contain\u00ading all the \nlogic controlling the sequencing between func\u00adtions, but inserting dummy programs or stubs for the functions. \nThe succeeding steps consist of fleshing out the stubs into a lower-level sequence of control logic, \ncomputa\u00adtion, and subfunctions, each of which is again represented by a stub (Boehm 2007). Developers \nintuitively embark into the bottom-up pa\u00adradigm since it is less complex to design, implement, reuse, \nand test the single building blocks, and then continue to construct parts of the code using these building \nblocks in\u00adstead of the opposite approach. The building blocks represent unfinished parts put on inventory \nproducing costs because of risks, e.g., often, dif\u00adferent assumptions have been made during the development \nof the individual components, which can lead to a high\u00adlevel control and data structure that are simply \nkludged\u00adup, which makes it difficult, i.e., costly to maintain such an architecture if requirements change \n(Boehm 2007). Moreover, a bottom-up development approach makes it difficult to understand if and how \nmuch value is provided by the single development activities. Introducing a pull approach can be achieved \nadopting a top-down approach as described above and introducing pull mechanisms such as test-driven development \n(Beck 2003): test cases that are developed before the development define the goals of the upcoming development \nstep. These test cases are motivated by the relative business objectives and pull the minimum amount \nof code that is necessary to fulfill them.  3. Measuring the costs of push Changing from a push to pull \napproach is associated to costs: it means to change which activities are executed, how they are sequenced, \netc. It takes time to tailor the new approach to company specific aspects. Practitioners need a way to \nestimate the cost-advantage that they gain when switching to pull to decide if it is worth to face the \ntransition costs. The central assumption of pull is that it aligns the pro\u00adduction on what provides value \nfor the customer and in this way avoids rework (Ohno 1988, Womack and Jones 1996). Rework in this context \nis all work that transforms a re\u00adleased imperfect product into a finished product free of such issues \n(Erdogmus 2007) ; this definition excludes evolutionary rework that adds value to an evolving prod\u00aduct \nto provide new capabilities in the next version (Fairley and Willshire 2005). To get an estimation of \nthe gravity of the problem of re\u00adwork within a development team, we want to evaluate the costs that are \ngenerated because of rework. The main cost driver in software development projects is typically the effort \n(Jorgensen and Shepperd 2007), i.e., the development time. For this reason we measure the time as an \nindicator for cost. Since the European software sector is characterized by small and medium enterprises \n(Perchaud 2003) we chose the metrics used for assessment under one premise: its col\u00adlection should be \nfully automatic, i.e., inexpensive. To assess the rework effort, we make use of the code churn metric, \nwhich is the amount of lines added, modified or deleted from one version to another within a module (Munson \nand Elbaum 1998). We chose to collect the data on a very granular level, i.e., per method. To define \nour measurement strategy we use the following GQM plan (Ba\u00adsili and Rombach 1994): Goal: To evaluate \nthe effort spent on rework from the point of view of software developers in the context of a small or \nmedium software development company.  Figure 2. Treemap visualization of the effort and the amount \nof rework within a given time period Questions: 1. How much code is modified because of rework tasks? \nMetric: Code churn per method, which is associated to a rework task within the issue tracking system, \nto iden\u00adtify the edited code because of rework 2. How much effort is spent (per file) because of rework \n tasks? Metric: Editing time per method, which is associated to a rework task within the issue tracking \nsystem, to measure the effort related to the edited code because of rework The two questions address \ntwo aspects of rework: the first evaluates the magnitude of the problem in size terms; the second evaluates \nthe costs arising because of rework. The developed measurement tool consists of the follow\u00ading components: \n(a) a effort measurement component that logs the time spent editing code per method, (b) a code churn \ncomponent that interfaces with a configuration man\u00adagement system, (c) an issue tracking component that \nis able to filter out only those effort and code churn that is related to maintenance tasks. In a first \nimplementation of the measurement tool, we developed the effort measurement component as a plugin for \nEclipse1 and Microsoft Visual Studio2 , the code churn component as an application accessing SVN3 , and \nthe issue tracking component as an application accessing Trac4 . The data is stored in a PostgreSQL5 \ndatabase following a data warehouse paradigm. The requirements to use this component are: the devel\u00adopers \nhave to use a configuration management system, an issue tracking system, track which issues are linked \nto which commits, and define which issues are maintenance issues. The result of the data collection is \nthe list of modules currently contained in the analyzed repository, together with the code churn and \nediting effort of a given time pe\u00adriod, which was generated because of maintenance tasks. Data interpretation \nThe collected data shows if rework - what pull prom\u00adises to avoid - is a concern in the specific development \nteam, i.e., if the total amount of effort spent for rework is 1 http://www.eclipse.org 2 http://msdn2.microsoft.com/vs2008/products \n3 http://subversion.tigris.org 4 http://trac.edgewall.org 5 http://www.postgresql.org  high enough to \nthink about changing existing development processes. If it is a concern, it is possible to understand \nwhich parts of the application generate the highest costs in terms of rework and derive a strategy to \nimplement a pull ap\u00adproach to drive the development of that part as late as pos\u00adsible (just-in-time). \nThe collected data shows if the effort is concentrated on one specific part of the application or if \nit is spread across the application but maybe concerns always some specific aspect contained in different \ncomponents. The distribution of the effort across the application can be used to choose an effective \npull strategy. We chose to use a treemap visualization (Shneiderman 1992), which allows to visualize \nhierarchical data in a compact way. The visualization algorithm displays hierar\u00adchical data as nested \nrectangles. In our case, nesting describes a part of relationship within the code. A method 1 that is \npart of a method 2 within the namespace 3 will be depicted as a box 3 containing a box 2 , which contains \na box 1 . Moreover, the size of each box represents the relative effort of rework (the largest box represents \nthe method with the highest value for rework effort) and the color represents the relative code churn \nconnected to rework (the darkest box represents the method with the highest value for code churn). We \nconducted a preliminary study, replacing package names, class names and method names with unique num\u00adbers \nfor confidentiality. The result is shown in figure 2: the methods responsible for a large part of the \nrework costs are those with the highest surface (e.g., 2300), methods with a dark shading had the highest \nvalues for code churn.  Limitations This approach collects data about the amount of code that is changed \nbecause of rework and the effort editing the code during the rework. Due to the automatic data collec\u00adtion, \nthe results are imprecise: the effort measurement component does not consider the time needed to think \nfor a solution, the discussions among developers searching for the best solution, etc.  4. Related work \nSeveral works are available in the literature that describe studies to characterize rework effort (see \nfor example (Ba\u00adsili et al. 1997) and (Kiew et al. 2002)) or ways to estimate the rework effort (see \nfor example (Lavazza and Valetto 2000, Chua et al. 2008)). Our approach contributes to the existing works \nproviding an automatic way to measure the rework effort suited for small and medium sized teams. As shown \nin section 2, the concept of pull exists al\u00adready within software engineering, e.g., Test-first in Ex\u00adtreme \nProgramming (Beck 1999), but its adoption is still controversially discussed since the benefits and costs \nare depend on the specific context. The here proposed tool aims to be of help for practitioners to evaluate \nthe possible benefits before changing (understanding the amount of re\u00adwork currently performed) and to \nevaluate if the change was successful. 5. Summary and future work Lean thinking advises to use pull \ninstead of push approaches to concentrate the spent effort on activities that deliver value to the customer. \nThis article aims to raise the awareness among practitioners of the advantages that pull approaches can \noffer. The concrete advantages of adopting pull within soft\u00adware engineering depend on the organization, \nthe market, and the product. The here presented tool aims to provide practitioners with the needed information \nto make an in\u00adformed decision whether pull for them is worth to try or not. The future work will study \nthe effects of the introduc\u00adtion of pull using the described tool.  References Basili, V. R., and Rombach, \nH. D. 1994. Goal Question Metric Paradigm in Encyclopedia of Software Engineering. Vol\u00adume 1. John Wiley \n&#38; Sons. Basili, V. R., Condon, S. E., El Emam, K., Hendrick, R. B., and Melo W. 1997. Characterizing \nand Modeling the Cost of Re\u00adwork in a Library of Reusable Software Components. Inter\u00adnational Conference \non Software Engineering, pp. 282, 19th International Conference on Software Engineering (ICSE'97) BBC \nNews. Toyota 'world's largest carmaker'. BBC News, 24 April 2007, http://news.bbc.co.uk/2/hi/business/6586679.stm \n(accessed June 10, 2009) Beck, K. 1999. Extreme Programming Explained: Embrace Change. Addison-Wesley \nProfessional. Beck, K. 2003. Test Driven Development By Example (Addison-Wesley Signature Series). Addison-Wesley \nProfessional Boehm, B. W. 2007. Software engineering: Barry W. Boehm's lifetime contributions to software \ndevelopment, management, and research, ed. Richard W. Selby, Wiley-IEEE, ISBN 047014873X, 9780470148730 \nChua, B. B., Bernardo, D. V., Verner, J. 2008. Criteria for Esti\u00admating Effort for Requirements Changes. \nSoftware Process Improvement, Communications in Computer and Information Science, Volume 16. ISBN 978-3-540-85934-5. \nSpringer-Verlag Berlin Heidelberg, 2008, p. 36 de Bruin, H. and van Vliet, H. 2003. Quality-driven software \nar\u00adchitecture composition. J. Syst. Softw. 66, 3 (Jun. 2003), 269\u00ad 284. Erdogmus, H. 2007. A cost effectiveness \nindicator for software development. First International Symposium on Empirical Software Engineering and \nMeasurement (ESEM 2007)  Erdogmus, H., Morisio, T. 2005. On the Effectiveness of Test\u00adfirst Approach \nto Programming. Proceedings of the IEEE Transactions on Software Engineering, 31(1). January 2005. Fairley, \nR.E., Willshire, M.J., 2005. Iterative rework: the good, the bad, and the ugly. Computer , vol.38, no.9, \npp. 34-41, Sept. 2005 Kiew, L. Y., Mashkuri, Y. and Ow, S.H. 2002. QualPro-RP - An Error Management And \nRework Effort Measurement Tool. Malaysian Journal of Computer Science 15(1), June 2002: 68-76. Kniberg, \nH. 2009. One day in Kanban land. Henrik Kniberg's Blog, entry June 26, 2009, http://blog.crisp.se/henrikkniberg/2009/06/26/124605306000 \n0.html (accessed August 8, 2009) Lavazza, L. and Valetto, G. 2000. Requirements-Based Estima\u00adtion of \nChange Costs. Empirical Softw. Engg. 5, 3 (Nov. 2000), pp. 229-243. Munson, J.C., Elbaum, S.G. 1998. \nCode Churn: A Measure for Estimating the Impact of Code Change. icsm, pp.24, 14th IEEE International \nConference on Software Maintenance (ICSM'98) New York Times. Toyota Motor Corporation. New York Times \nTopics, http://topics.nytimes.com/top/news/business/companies/toyot a_motor_corporation/index.html (accessed \nJune 10, 2009). Ouchi, W.G. 1977. The Relationship Between Organizational Structure and Organizational \nControl, Administrative Science Quarterly (22:1), March 1977, pp 95-113. Papadopoulos, G. A. and Arbab, \nF. 1998 Coordination Models and Languages. Technical Report. UMI Order Number: SEN-R9834., CWI (Centre \nfor Mathematics and Computer Sci\u00adence). Poppendieck, M. 2007. Lean Software Development. International \nConference on Software Engineering Companion, pp. 165\u00ad166, 29th International Conference on Software \nEngineering (ICSE'07 Companion) Poppendieck, M., Poppendieck, T. 2003. Lean Software Devel\u00adopment: An \nAgile Toolkit for Software Development Man\u00adagers. Addison-Wesley. Royal Academy of Engineering. 2004. \nThe Challenges of Com\u00adplex IT Projects: The Report of a Working Group from the Royal Academy of Engineering \nand the British Computer Society. Study presented at the International Conference of Software Engineering, \nMay 26, in Edinburgh, Scotland, UK Schnabel, I., Pizka, M. 2006. Goal-Driven Software Development. SEW. \n2006. IEEE Computer Society. Shneiderman, B. 1992. Tree visualization with tree-maps: 2-d space-filling \napproach. ACM Trans. Graph. 11, 1 (Jan. 1992), 92-99. Womack, J. P., Jones, D. T. 1996. Lean thinking, \nNew York, NY, USA: Simon and Schuster.   \n\t\t\t", "proc_id": "1639950", "abstract": "<p>The Toyota Production System promotes \"pull\" scheduling to reduce the production of parts that do not comply to what the customer needs. The use of \"pull\" within software represents a radical change in the way activities are planned. This article gives two examples of the possible application of \"pull\" within software engineering and de-scribes a measurement tool to assess the current costs and amount of rework within a software development project. The described approach aims to help practitioners to under-stand whether to use \"pull\" or \"push\" in their organizations.</p>", "authors": [{"name": "Andrea Janes", "author_profile_id": "81100166625", "affiliation": "Free University of Bolzano/Bozen, Bolzano, Italy", "person_id": "P1728324", "email_address": "", "orcid_id": ""}, {"name": "Giancarlo Succi", "author_profile_id": "81350590159", "affiliation": "Free University of Bolzano/Bozen, Bolzano, Italy", "person_id": "P1728325", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640052", "year": "2009", "article_id": "1640052", "conference": "OOPSLA", "title": "To pull or not to pull", "url": "http://dl.acm.org/citation.cfm?id=1640052"}