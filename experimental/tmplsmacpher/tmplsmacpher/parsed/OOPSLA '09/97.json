{"article_publication_date": "10-25-2009", "fulltext": "\n Silhouette: Visual Language for Meaningful Shape Clayton Myers Elisa Baniassad The Chinese University \nof Hong Kong {clayton, elisa}@cse.cuhk.edu.hk Abstract Programmers use many views of their code to assess \nits structure and behavior: call graphs, data-.ow diagrams, structural diagrams, etc. The motivation \nfor using such views is that the semantics of textual code is dif.cult to stand back and assess : If \nyou step back from code, it just appears as a mass of unreadable text. However, the diagrams themselves \nare also of limited use: the shapes only summarize limited semantic information, so the visual presentation \ncan be as disorganized and confusing as the original code. In this pa\u00adper we propose Silhouette, a visual \nprogramming language and design tool that allows developers to capture the mean\u00ading of their program \nin the visual structure of their code. The shapes chosen by the developer represent abstractions of the \nunderlying functionality or structure, and can be in\u00ad.nitely nested to allow different levels of abstraction. \nThe goal is for programmers to build a correspondence between the shape of their program and its meaning. \nWe believe that Silhouette gives programmers more .exibility in matching their high-level abstractions \nto code and enables a wide va\u00adriety of design strategies. Categories and Subject Descriptors D.1.7 [Visual \nPro\u00adgramming]; D.2.2 [Design Tools and Techniques]: Modules and Interfaces General Terms Languages Keywords \nVisual Programming, Lateral Design 1. Introduction Software design approaches attempt to draw motivation \nfrom the design of buildings ( Architecture ). However, when probing the common approaches between the \ntwo (software design and architecture) the metaphor breaks down. Architecture relies on the relationship \nbetween phys\u00adical form and physical principles of function; software has Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 2009 October 25 29, 2009, Orlando, Florida, \nUSA Copyright c &#38;#169; 2009 ACM 978-1-60558-768-4/09/10. . . $10.00 no physical form, so we need \nto establish some analogous relationship. Our goal is to work towards a correspondence of shape and meaning \nfor programs. Buildings are physical: they have shape and form, and their stability and integrity proceed \nphysically from that. Ar\u00adchitecture relies completely on the fact that the shape is vis\u00adible, and has \nactual meaning. If you look at the image A in Figure 1, you d probably know that it was incorrect if \nwe la\u00adbeled E the kitchen or bathroom, and D the master bed\u00adroom. Certainly A would not be the bathroom, \nliving room, or any other room. B would make a bad bathroom, and C is a little ambiguous could be a bedroom, \nor maybe a den. With a little more shape information (shown in Fig\u00adure 1B), the reasoning based on the \noutline is con.rmed. Look at the drawing on the right. Now it would be really absurd to call E a bathroom \nit is clearly a bedroom. We don t need words to tell us this. If we put the wrong labels on the rooms, \nit wouldn t matter, because we d just ignore them. So, is shape important in software as it is in Architec\u00adture? \nWe think so. We think that what is missing is a con\u00adnection between shape and abstraction, between form \nand meaning. We believe that it is important to be able to physi\u00adcally step back from code, and immediately \nsee the shape of the program not the interaction of linguistic formalisms, necessarily, but the interrelation \nof abstractions that deter\u00admines the meaning of the program. To address this, we pro\u00adpose Silhouette: \na language and design tool which allows a programmer to use nested, free-form shapes to specify the abstractions \nof their program at a high level. 2. The Signi.cance of Shape What information is lost by bad visualization? \nConversely, what stands to be gained? Why is it so important to give code a shape? For physical objects, \nshape communicates several impor\u00adtant things. The .rst and most obvious of these is the bound\u00adaries between \nobjects. In looking at a scene, we are used to being able to quickly (subconsciously) divide the substance \nof our perception into distinct objects. However, although we conceive of programs as divisible into \ndiscrete syntactic and semantic units, it is very dif.cult to make this distinction visually.  Figure \n1. Two views of an Apartment Layout with Increas\u00ading Levels of Semantic Shape Information Shape, in the \nreal world, also provides information on the nature of objects. It does not just tell us that two things \nare different, it tells us what they are. This is both because of simple recognition, and because many \nattributes are physi\u00adcally dependent on shape. This latter fact means that we can often determine something \nabout an unknown object simply by looking at it. Textual formatting conventions, which func\u00adtion as a \nsort of visual representation, provide useful visual information about the programming-language structures \nof code (to readers familiar with the programming language). That is, an if-statement looks different \nfrom a for-loop or a function de.nition. However, formatting does not convey information about the meaning \nof code: two very different de.nitions may look the same: class Point { class Deque { void setX(int x); \nvoid addH(int e); int getX(); int getH(); void setY(int y); void addT(int e); int getY(); int getT(); \nbool zero(); bool empty(); }} Figure 2. Are these the same? How about if you squint? Finally, and most \nimportantly, shape provides a notion of proximity. We can say when objects are close to each other, and \nwe infer that nearby objects relate or interact more closely, or can be considered as a single compound \nobject. In this way proximity gives rise to zoomable detail. At a low level of detail, we see nearby \nobjects as a single unit, but as the level of detail increases, such units resolve into their individual \ncomponents. Code, which is nonphysical, has no .xed concept of proximity. Instead, apparent prox\u00adimity \nis determined by its visual representation. The primar\u00adily linear textual representation of most code \ndoes somewhat poorly at communicating the often tree-shaped relationships of syntax in most languages, \na large then-clause can sepa\u00adrate the else-clause from the conditional of an if-statement by a long distance \nand extremely poorly at communicat\u00ading the more complex relationships of semantics. In fact, the only \nsemantic relationship conveyed well by textual repre\u00adsentations is order of evaluation, and even that \nis only pre\u00adserved locally (within a method body, say, but not between multiple methods). By adopting \na shaped visual representation we stand to gain a more intuitive understanding of the abstract mean\u00ading \nand relationships in a program. However, not any visual representation will do. We need concepts of shape \nand prox\u00adimity that communicate useful information. Consider the two images depicted in Figure 3. Both \nA and B show a UML diagram for the structure of the design pattern Abstract Factory. In the top image, \nthe text of the diagram has been removed. In the bottom image, the shapes have been removed. Obviously \nthe one with the words is much more speci.c, and gives more of a hint at the program semantics than the \ntop image. The depiction in the top image (a collection of objects that have some relationships to each \nother) is, on the other hand, quite generic. The depiction is also somewhat unnecessary: most of the \nrelationships depicted in the .rst image can be derived from the words in the second image. Now, it is \nnot true that the top image provides no informa\u00adtion about the program it depicts. In fact, it is an \nacceptable, but quite limited, example of the use of shapes. We can see two shapes and three relationships, \nand with their ordinary meanings they signify two class hierarchies, with one sub\u00adclass being able to \ngenerate instances of the other subclass. We also see that two of the classes (in the same hierarchy) \nhave at least one method each that contains some code. The problem here is not that the visual depiction \ndoes not provide information; the problem is that the informa\u00adtion it provides is largely redundant and \nuseless. Well, not quite useless: we know that replacing one of the code shapes with a class shape doesn \nt make sense. We also know that a change to the second subclass must be carefully made to ensure that \nits relationship to the .rst subclass is main\u00adtained, and so on. This is actually quite a lot of informa\u00adtion, \nand some of it is semantic in the sense that it relates to program behavior, but there is one very important \nsense in which this diagram does not communicate program se\u00admantics : There is no hint of what these \nclasses mean to the programmer. Knowing that the entities depicted are classes Figure 3. Two views of \na UML diagram; one with only shapes, one with only text  and code fragments is not so useful if we \nare programming in, say, Java, where everything is classes and code fragments. The point of this is that \nwe gain nothing in drawing the .rst diagram which is to say we waste the opportunity for vi\u00adsual expression \nwhen we are limited to mimicing the shape of the code.  3. The Napkin Diagram Theory One of the basic \npremises of our work on Silhouette is this: programmers use abstractions to think about their program, \nand those abstractions do not (always) match up with the abstractions provided by programming languages. \nWe call this the Napkin Diagram theory after the observation that programs as code, as architecture are \nfrequently conceived as rough sketches, as on the proverbial cocktail napkin close at hand, and that \nthese sketches seem meaningful yet rarely correspond closely to the programs ultimate forms. It is dif.cult, \nto the point of being comical, to imagine a .rst program sketch being correctly formed in terms of classes, \nor algebraic datatypes, or other formal linguistic abstractions. And yet these are the components from \nwhich the code must be formed. Why is there such a disconnect? If the linguistic abstractions are to \nbe preferred, what does it mean that programmers seem to think in other terms? 3.1 Program vs. Code \nIt is important to stop here and explain what we see as a use\u00adful distinction between the program and \nthe code . We are used to thinking of the program as being equivalent to all of the source code, and \nof course there is nothing incorrect about this usage. But there is more to the program than just that: \nthe program is a conceived, designed, and built artifact with a purpose. The program necessarily has \nan intention, not in the anthropomorphic sense, but in the sense that the programmer or programmers mean \nfor it to do something. In fact, they mean for it to mean something as well. One can describe the semantic \nrules for regular expressions concatenation, alternation, etc. andfrom that goontode\u00adscribe the input-output \nbehavior of grep, but this does not get directly at the point that grep is a program for search\u00ading text. \nThis distinction is even more applicable to more complicated programs. A window manager, say, is a piece \nof code that performs a lot of complicated operations on the machine, but it is also a program for arranging \nand manipu\u00adlating visual information on the screen. This is information that is captured at best indirectly \nby the code, and so we will frequently use the term program to refer to the human, in\u00adtentional aspects \nof a piece of software and code for the formal, linguistic aspects.  3.2 Postmodernity In the conventional \nmodern view, each program must have a strict formal de.nition which is then reduced to a code im\u00adplementation. \nThe corollary of this is that if a program is informally understood, if its formal de.nition is not known, \nthe formal de.nition must be discovered through exploratory programming but until this is done there \nis no program , strictly speaking. The program abstractions are meaningful precisely insofar as they \nare formal; to be informal is sim\u00adply to be unknown or unspeci.ed. The only real meaning of a program \nis in its formal programming-linguistic abstrac\u00adtions. In Notes on Postmodern Programming [11], Noble \nand Biddle write Computer scientists with a formal bent often claim than design and implementation are \nan exercise in the re.nement calculus you can gradually transform a prob\u00adlem statement into a program... \nFrom a postmodern perspec\u00adtive, however, such a de.nition is not a problem statement, but rather an abstract \nde.nition of a solution where re\u00ad.nement simply makes a solution more concrete. In other words, once \nyou have formal abstractions, you already have a solution, which means that the problem solving, the \npro\u00adgramming, comes from .nding those formal abstractions. Abstraction in Silhouette is founded on a \npostmodern principle: We do not believe that the conceptual abstrac\u00adtions of a program depend on the \nlinguistic abstractions of code. Instead, program abstractions precede the code imple\u00admentations, and \ncontinue to inform the code until the soft\u00adware is complete. The Law of Leaky Abstractions1 holds that \nAll non-trivial abstractions, to some degree, are leaky , and implies that implementation details cannot \nbe ignored. We take it to mean that abstraction details cannot be ignored: The code abstraction the implementation \ncannot substi\u00ad 1 http://www.joelonsoftware.com/articles/LeakyAbstractions.html tute for the program \nabstraction. Programming is a matter of bringing the leaky details in line with the programmer s abstract \nconception of the program. This leads to a key insight: visualizing a program is different from visualizing \ncode. Our goal is the former.  4. Silhouette To that end, we sketch a programming environment called \nSilhouette which has the goal of using shape to convey in\u00adformation about the underlying abstractions \nof a program. Silhouette is not a programming language in its own right; it does not provide a new model \nof computation. Instead, it provides a visual layer on top of existing programming languages. A program \nbeing developed in Silhouette is com\u00adposed of code in a conventional programming language, ar\u00adranged \ninto visual components called elements. The arrange\u00adment of these elements nested and interconnected \nis in\u00adtended to re.ect and express the abstract structure of the program. By abstract structure , we \nmean the set of con\u00adcepts and abstractions that underly the programmers un\u00adderstanding of their program, \nand not the modules and data structures that the underlying programming language uses as its abstractions. \nThe organization of Silhouette elements, moreover, controls the composition of their code, so that a \nchange to the visual structure of a Silhouette program causes a corresponding change to the architecture \nof the code. The mechanism for this control most be programmer-controlled and very .exible to allow Silhouette \nelements to mediate between between high-level programmer abstractions and lower-level code abstractions. \nIn particular, we wish to avoid a situation where Silhouette becomes a cumbersome visual representation \nfor existing code structures. Elements are intended to represent abstractions that are more informal, \nlike design concerns, than formal, like mod\u00adules or classes. Such abstractions may be hierarchical nested \nbut they may just as easily overlap. As has been identi.ed particularly by the AOP and SOP communities \n(but by most if not all programmers informally) some code naturally .ts into multiple concerns that may \nbe otherwise independent. Silhouette allows (and in fact encourages) overlapping structure of elements \nto represent this. This preserves locality of concerns everything related to one abstraction is within \na single element while avoiding du\u00adplication. It also has signi.cant consequences for program design, \nas we will see below. Abstractions frequently are interrelated in that they refer to each other or are \nde.ned in terms of each other. In more formal abstractions like data types, this gives rise to the interface/implementation \ndis\u00adtinction; for the more informal abstractions of Silhouette elements, we permit connections between \nelements to repre\u00adsent indirect reference. A Silhouette program is made of these visual elements, which \nmay contain, overlap,or connect with each other to represent various degrees of conceptual proximity. \nBased on this simple, admittedly informal description, we will go on to examine the kind of programming \nthis suggests, and explain further aspects of the Silhouette model as we encounter them.  5. Programming \nStyle: Up, Down, and Sideways Frequently, programming languages implicitly or explicitly limit the programing \nstyles or methodologies with which they are compatible. In many cases it is particularly dif.\u00adcult to \nuse any design methodology other than top-down de\u00adsign. This is true of object-oriented and relational \nlanguages, which require signi.cant infrastructure around the core functionality. In practice, it is \nvery dif.cult to change de\u00adsign decisions late in the programming process, once the programmer has acquired \nsigni.cant and potentially useful domain knowledge. Another, related dif.culty is that strict insistence \non formal language abstractions can make it un\u00adclear or dif.cult to know how to structure the program \nin the .rst place. For all that methodologies like OOD use pow\u00aderful language abstractions and compiler \nsupport to make higher-level programming easy, they leave out a necessary and dif.cult .rst step, where \nthe programmer must struggle to map his own abstractions into classes and objects, or al\u00adgebraic datatypes, \nor whatever abstraction framework is re\u00adquired. This must be done before design can begin but this is \ndesign as well, and all the more dif.cult because it is, by de.nition, outside the language and methodology \nframe\u00adwork. Silhouette can solve these problems with its loose, .ex\u00adible structure and focus on abstractions. \nAbstraction-based elements can keep the program organized even while sig\u00adni.cant architectural changes \nare being made to the code; conversely, it is easy to work with abstractions, including more or less \ncode within an element, without modifying the base-language structure of the code at all. Because of \nthis, Silhouette enables the simultaneous use of a wide range of programming styles. 5.1 Top-down A Silhouette \nelement containing base code can be opened up and its contents replaced by an internal program of fur\u00adther \nelements. This permits iterative re.nement of a pro\u00adgram, beginning with a few general or compliated \nelements and decomposing them into individual units of structure or functionality. Because an element \ncorresponds to the com\u00adplete implementation of an abstraction or concern, there is no danger that this \ninternal re.nement can create inconsis\u00adtencies with the rest of the program. 5.2 Bottom-up A Silhouette \nelement may be constructed around a group of other elements. The new element becomes a compound ele\u00adment \nwith the constituent elements as its internal structure. This enables related components to be built \ninto useful struc\u00adtures or abstractions which may then be referenced as a unit elsewhere in the program. \nMost importantly for bottom-up design and programming, this is possible even if the rela\u00adtionship between \nelements was not known when they were de.ned. Elements can be encircled in this way even if they are \nalready components of another structure. This can create overlapping structure if some of the elements \nencircled are already subelements of a different element(this is not quite a formal de.nition, but the \nsituation can be readily visualized). During bottom-up design, overlapping concerns arise (and are shown) \nnaturally as useful abstractions are found which combine elements in different structures. These overlapping \nelements may then be manipulated like any other elements: moved, further enclosed, renamed, and so on. \n 5.3 Lateral the presence of overlapping elements introduces a new mode of design for which we suggest \nthe term lateral by analogy to top-down and bottom-up . Lateral design operations in Silhouette have \nsimilarities both to refactoring techniques and to aspect-oriented decomposition; they involve adding \nor removing overlapping structure in order to move between different decompositions and emphasize the \nmodularity of different structures or abstractions. While overlapping ele\u00adments in Silhouette may be \nfreely built and manipulated, such overlapping structure complicates modular reasoning and makes certain \ndesign and editing operations more dif.\u00adcult. This is somewhat analogous to the problem of crosscut\u00adting \nconcerns as identi.ed in object-oriented programming by the aspect-oriented programming communitee. However, \noverlapping in Silhouette is symmetric in the sense that a program has no grain or built-in primary decomposition \nto be crosscut by another abstraction. The basic structure of Silhouette elements is neutral with regard \nto base code struc\u00adtures (classes, functions, etc.) and the vocabulary of shapes and relationships is \nuser-de.ned, so no one type of Silhou\u00adette decomposition is preferred as in OOP. Therefore, over\u00adlapping \nconcerns can be resolved according to constraints of the program and the problem domain, not the language. \nTo that end, Silhouette de.nes lateral restructuring operations. (we avoid the term refactoring for the \nsame reason we avoid crosscutting : restructurings move between equally meaningful decompositions, rather \nthan orthogonally to the primary program structure.) In general, an overlap represents some code relevant \nto multiple concerns or abstractions. To remove an overlap, we can replace ownership of a shared element \nwith a reference (connection) to it. Alternatively, overlapping elements can be merged into a single \nelement. The various operations convert between overlaps and connections in different ways, as shown \nby Figures 4 through 6. Lateral design in Silhouette describes the process of using these operations \n(and similar manual edits) to move between Figure 4. A very simple overlapping structure. Figure 5. \nOverlap replaced with connection.  Figure 6. Overlapping elements merged. different con.gurations and \nabstraction hierarchies. The ar\u00adrangement of structures or abstractions can be changed as the program \nevolves; it can also be adjusted temporarily to fa\u00adcilitate particular editing operations. At the same \ntime, these transformations are not simply different views on a sin\u00adgle decomposition. The power of lateral \nediting is that dif\u00adferent structures and decompositions are easily interchange\u00adable, they represent \ngenuinely different architectures for the resulting program. 5.4 Program Evolution Figure 7 shows (what \nwe imagine to be) the way programs are developed in Silhouette. The program is initially con\u00adceived as \na set of ideas without much sense of organization. In the .rst step, the program is divided into a few \nmain com\u00adponents or abstractions, without much concern for how these will be implemented. This is the \nnapkin diagram phase. At this point, the programmer can begin to use top-down design, working inside \nthe elements to subdivide and re.ne them. In general, the goal of this process is to build an ab\u00adstraction \nhierarchy that suits the problem domain and the  Figure 7. The design process of a Silhouette program, \nincluding top-down, bottom-up, and lateral design. programmer s own conception of their program. The \ntop\u00addown design might continue until the abstractions are quite .ne-grained, but the initial design is \nunlikely to match up precisely with the base language abstractions. To resolve this, the programmer can \nbegin to work bottom-up by adding new elements containing useful chunks of base code and grouping related \nelements into new ab\u00adstractions that better .t the problem domain and the base language. The goal of \nbottom-up design at this step is to produce abstractions of base code and language function\u00adality, from \nwhich the higher-level functionality can in turn be constructed. Because of Silhouette s use of overlapping \nstructure, this bottom-up work complements, rather than con.icting with, the top-down design already \nperformed. The program by this stage is a mix of higher-level design abstractions and lower-level base \ncode abstractions re.ect\u00ading various levels of understanding of the program and its implementation. However, \nby this point, a lot of overlapping structure has probably been developed, leading to a very complicated \npro\u00adgram. Lateral design can resolve such complications, when necessary, by replacing overlaps with dependencies \nand con\u00adnections. If it hasn t happened already, this will motivate the creation of new relationships \nassociated with the existing shapes. In lateral design, the programmer manipulates that various high-and \nlow-level abstractions that they have cre\u00adated in order to .nd a structure that balances the constraints \nof the program design and the base language. This is an open-ended and quite creative process, since \nthere is no single, ultimate, ideal form for a program. In fact, top-down, bottom-up, and lateral design \ndo not only follow each other in this single sequence. As the program and its requirements evolve, the \nprogrammer will use all three forms of design. At any given time they may be working down, to re.ne abstractions \ninto simpler components; up, to build or identify reusable components; or sideways, to combine and recombine \nthe abstractions into better forms. In laying out the future of software development, Gregor Kiczales, \nin his 2007 OOPSLA Keynote address, said that a key component would be what he termed effectiveness . \nEffectiveness in this case does not refer to whether some\u00adthing is functional or practical, but instead \nto whether or not high-level views have effects on the code they describe. We see Silhouette as a step \ntowards effective views: views that operate on the code underneath them, rather than simply re.ect the \nunderlying structure; where high-level changes propagate down.  6. Related Work Silhouette merges two \n.elds of research: visual program\u00adming languages, and program visualization approaches. Visual Programming \nand visual languages fall into sev\u00aderal categories, including data-.ow languages such as Pro\u00adgraph [10], \niconic languages, functional/imperative/logic/ visual object-oriented [6] languages, diagrammatic lan\u00adguages \nand pictorial sequence languages. Those closest in intent to Silhouette are those which allow shapes \nto be arbi\u00adtrarily de.ned by the programmer. Show And Tell (STL) [7], for instance, allows a developer \nto program using arbitrary shapes, such as circle, square or pencil-drawn. However, most of these programming \nlanguages enforce visualiza\u00adtion down to the lowest level of syntax. This means that a programmer using \nthese languages must fully commit to visualization. There are several modeling and programming languages \nthat allow visual and textual code to be mixed. UML 2.1 [13, 12], for instance, provides the developer \nwith a full-.edged modeling language for ob ject oriented systems. While this language (and its relatives) \nclearly has real programming power, it does not allow the visual abstraction necessary to step back and \nappreciate the shape of code. As was illus\u00adtrated in the Introduction, UML shapes are mainly syntactic \nones: they do not change based on the semantics of the pro\u00adgram. A cat, a dog, and an orange are all \nrepresented as box\u00adshapes in UML. This means that, without examining the text closely, the boxes and \narrows of two UML diagrams could be almost identical, even if the code they represent is dra\u00admatically \ndifferent. There is also a set of tools that provide an automatically\u00adgenerated high-level view of the \ncode to the programmer. A very early offering was C2 [9], which provided developers with a constantly \nupdating high-level architectural view of the. One window allowed browsing of ordinary C code, and another \nprovided the developer with a high-level view of the structure of the code. More recent approaches include \nSoftware Terrain Maps [3] and Code Thumbnails [4]. In each of these cases, a visual representation is \ngenerated to give the developer a sense of how the underlying code looks . Code thumbnails give a zoomed-out \nview of the text of the code in each code .le; Software Terrain Maps show a developer a view of the code \nthat looks like a landmass. Since these representations are generated based on structural elements of \nthe code, they appear as generic as the earlier visual languages discussed above. It is impossible to \nread the text of the code in the thumbnails, and the semantic details of the code depicted in the terrain \nmaps are completely obscure. While these languages have been shown to serve as an effective code-location \nreminder for programmers who are already some what familiar with a codebase, they do not allow a new \ndeveloper to walk up and get a sense of what happens in the code. In some ways, Silhouette can be seen \nas an extension of Subject-Oriented Programing [2, 15]. Hyperslices as propsed by Tarr et al. bear signi.cant \nsimilarities to Sil\u00adhouette elements in that they modularize code in a way orthogonal to ordinary language \nstructures, and that they are intended to represent a single design concern or ab\u00adstraction. However, \nSilhouette goes further in eliminating the dominant decomposition and using overlapping struc\u00adture to \npermit simultaneous localization of overlapping con\u00adcerns. Other approaches to more general abstraction-based \nprogramming include Fluid AOP [8] and Relationship As\u00adpects [14]. Fluid AOP uses tool support to add \nediting oper\u00adations that apply across related but separate parts of the un\u00adderlying code, similar to \nlateral editing in Silhouette. Unlike Silhouette, though, the operations in Fluid AOP are different views \nof a single code structure. Relationship Aspects are a means of formalizing inter-object relationships \nin object\u00adoriented code and therefor have some similarities to our use of connections and relationships. \nFinally, Noble and Bid\u00addle s theory of postmodern programming [11], particularly in its analysis of program \nabstractions as semiotics, provides much of the motivation for Silhouette s abstraction-based structure. \n 7. Conclusion In this paper we have introduced Silhouette, a visual, language\u00adindependent design tool \nthat allows the developer to step back from their code, and reshape it by graphical manipula\u00adtion. We \noutlined the components of a Silhouette program: overlapping, nested elements representing abstractions, \nand connections representing dependency or indirect reference. We described how Silhouette uses a loose, \nprogrammer\u00adde.ned coupling between Silhouette elements and program structures to enable description of \nhigh-level abstractions. This means that programming does not need to adhere to a top-down approach, \nbecause abstractions can be directly formed by the modi.cation and movement of existing ab\u00adstractions. \nSilhouette s goal is to enable programmers to build a correspondence between the shape and the mean\u00ading \nof their programmers, to allow for .exible but powerful new design techniques. Silhouette s overlapping \nstructure means that no matter how complicated and interwoven the abstractions are, all of the code related \nto a single abstraction really can be in the same place. This has the added bene.t that interwoven ab\u00adstractions \nproduce interwoven structures, and separate ab\u00adstractions produce separate structures. In short, the \nvisual ap\u00adpearance of a Silhouette program in terms of density, depth, and complication precisely matches \nthe abstract conception of the program. Silhouette does not enforce a particular basis set of ab\u00adstractions, \nbecause the base language can be used for that. In fact, the base language can be used at whatever minimum \nresolution or granularity the programmer feels is appro\u00adpriate, from complex base-language abstractions \nlike struc\u00adtures or classes down to individual syntactic forms or expres\u00adsions. Silhouette avoids the \ntedious wiring-up of visual com\u00adponents that could more easily be manipulated textually whatever the \nprogrammer wants that to mean. The obvious next step for Silhouette is a full implemen\u00adtation, followed \nby an empirical study within the context of a range of software engineering tasks. We wish to better \nun\u00adderstand how providing developers with this kind of system affects their development style, and their \ndesign style.  References [1] B. B. Bederson, J. Grosjean, and J. Meyer. Toolkit design for interactive \nstructured graphics. IEEE Trans. Softw. Eng., 30(8):535 546, 2004. [2] S. Clarke, W. Harrison, H. Ossher, \nand P. Tarr. Subject\u00adoriented design: towards improved alignment of require\u00adments, design, and code. \nSIGPLAN Not., 34(10):325 339, 1999. [3] R. DeLine. Staying oriented with Software Terrain Maps (2005). \nProc. of the Workshop on Visual Languages and Computation, 2005. [4] R. DeLine, M. Czerwinski, B. Meyers, \nG. Venolia, S. Drucker, and G. Robertson. Code Thumbnails: Using Spatial Memory to Navigate Source Code. \nProceedings of the Visual Languages and Human-Centric Computing (VL/HCC 06)-Volume 00, pages 11 18, 2006. \n[5] J. Edwards. Subtext: uncovering the simplicity of program\u00adming. In OOPSLA 05: Proceedings of the \n20th annual ACM SIGPLAN conference on Object oriented programming, systems, languages, and applications, \npages 505 518, New York, NY, USA, 2005. ACM Press. [6] C. Grant. The Visula programming language and \nenviron\u00adment. Proceedings of the Visual Languages and Human-Centric Computing (VL/HCC 06)-Volume 00, \npages 203 206, 2006. [7] W. Hansen, B. Bell, G. McKaskle, G. Smedley, D. Kimura, and J. Poswig. The 1994 \nVisual Languages Comparison. Visual Languages, 1994. Proceedings., IEEE Symposium on, pages 90 97, 1994. \n[8] T. Hon and G. Kiczales. Fluid aop join point models. In OOPSLA 06: Companion to the 21st ACM SIGPLAN \nsym\u00adposium on Object-oriented programming systems, languages, and applications, pages 712 713, New York, \nNY, USA, 2006. ACM. [9] M. Kopache and E. Glinert. C 2: a mixed textual/graphical environment for C. \nVisual Languages, 1988., IEEE Workshop on, pages 231 238, 1988. [10] MacTech. Prograph cpx -a tutorial. \nMacTech, 10(11), November 1994. [11] J. Noble and R. Biddle. Notes on postmodern programming. In Proceedings \nof the Onward Track at OOPSLA 02, the ACM conference on Object-Oriented Programming, Systems, Languages \nand Applications, pages 49 71, 2002. [12] OMG. Uni.ed Modeling Language: Infrastructure -Version 2.1.1. \nObject Management Group, February 2007. [13] OMG. Uni.ed Modeling Language: Superstructure -Version \n 2.1.1. Object Management Group, February 2007. [14] D. J. Pearce and J. Noble. Relationship aspects. \nIn AOSD 06: Proceedings of the 5th international conference on Aspect\u00adoriented software development, \npages 75 86, New York, NY, USA, 2006. ACM. [15] P. Tarr,H.Ossher,W.Harrison,and S. M.Sutton, Jr. N degrees \nof separation: multi-dimensional separation of concerns. In ICSE 99: Proceedings of the 21st international \nconference on Software engineering, pages 107 119, New York, NY, USA, 1999. ACM.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Programmers use many views of their code to assess its structure and behavior: call graphs, data-flow diagrams, structural diagrams, etc. The motivation for using such views is that the semantics of textual code is difficult to \"stand back and assess\": If you step back from code, it just appears as a mass of unreadable text. However, the diagrams themselves are also of limited use: the shapes only summarize limited semantic information, so the visual presentation can be as disorganized and confusing as the original code. In this paper we propose Silhouette, a visual programming language and design tool that allows developers to capture the meaning of their program in the visual structure of their code. The shapes chosen by the developer represent abstractions of the underlying functionality or structure, and can be infinitely nested to allow different levels of abstraction. The goal is for programmers to build a correspondence between the shape of their program and its meaning. We believe that Silhouette gives programmers more flexibility in matching their high-level abstractions to code and enables a wide variety of design strategies.</p>", "authors": [{"name": "Clayton Myers", "author_profile_id": "81414610905", "affiliation": "The Chinese University of Hong Kong, Sha Tin, Hong Kong", "person_id": "P1728337", "email_address": "", "orcid_id": ""}, {"name": "Elisa Baniassad", "author_profile_id": "81414615851", "affiliation": "The Chinese University of Hong Kong, Sha Tin, Hong Kong", "person_id": "P1728338", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640057", "year": "2009", "article_id": "1640057", "conference": "OOPSLA", "title": "Silhouette: visual language for meaningful shape", "url": "http://dl.acm.org/citation.cfm?id=1640057"}