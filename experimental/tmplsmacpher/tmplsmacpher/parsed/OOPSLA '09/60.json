{"article_publication_date": "10-25-2009", "fulltext": "\n DEMO: Thorn Robust, Concurrent Scripting on the JVM \u00a8 Bard Bloom1 , John Field1 , Nathaniel Nystrom2* \n, Johan Ostlund3 , Gregor Richards3 , sa4 , Jan Vitek3 , Tobias Wrigstad5 Rok Strni. 1 IBM Research \n2 University of Texas at Arlington 3 Purdue University 4 University of Cambridge 5 Stockholm University \nAbstract Scripting languages enjoy great popularity due to their sup\u00adport for rapid and exploratory development. \nThey typically have lightweight syntax, weak data privacy, dynamic typing, powerful aggregate data types, \nand allow execution of the completed parts of incomplete programs. The price of these features comes \nlater in the software life cycle. Scripts are hard to evolve and compose, and often slow. An additional \nweakness of most scripting languages is lack of support for concurrency though concurrency is required \nfor scalability and interacting with remote services. This paper reports on the design and implementation \nof Thorn, a novel program\u00adming language targeting the JVM. Our principal contribu\u00adtions are a careful \nselection of features that support the evo\u00adlution of scripts into industrial grade programs e.g., an \nex\u00adpressive module system, an optional type annotation facility for declarations, and support for concurrency \nbased on mes\u00adsage passing between lightweight, isolated processes. On the implementation side, Thorn \nhas been designed to accommo\u00addate the evolution of the language itself through a compiler plugin mechanism \nand target the Java virtual machine. Categories and Subject Descriptors D.3.2 [Programming Languages]: \nLanguage Classi.cations Concurrent, dis\u00adtributed, and parallel languages; Object-oriented languages; \nD.3.3 [Programming Languages]: Language Constructs and Features Concurrent programming structures; Modules, \npackages; Classes and objects; Data types and structures; D.3.4 [Programming Languages]: Processors Compilers \nGeneral Terms Design Keywords Scripting, Actors, Pattern matching * Work done while the author was af.liated \nwith IBM Research. Work done while the author was af.liated with Purdue University. Copyright is held \nby the author/owner(s). OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10. \n 1. Introduction Scripting languages are lightweight, dynamic programming languages designed to maximize \nshort-term programmer productivity by offering lightweight syntax, weak data en\u00adcapsulation, dynamic \ntyping, powerful aggregate data types, and the ability to execute the completed parts of incomplete programs. \nImportant modern scripting languages include Perl, Python, PHP, JavaScript, and Ruby, plus languages \nlike Scheme that are not originally scripting languages but have been adapted for it. Many of these languages \nwere orig\u00adinally developed for specialized domains (e.g., web servers or clients), but are increasingly \nbeing used more broadly. The rising popularity of scripting languages can be at\u00adtributed to a number \nof key design choices. Scripting lan\u00adguages pragmatic view of a program allows execution of completed \nsections of partially written programs. This fa\u00adcilitates an agile and iterative development style at \nev\u00adery step of the way a working piece of software . Execu\u00adtion of partial programs allows instant unit-testing, \ninterac\u00adtive experimentation, and even demoing of software at all times. Powerful and .exible aggregate \ndata types and dy\u00adnamic typing allow interim solutions that can be revisited later, once the understanding \nof the system is deep enough to make a more permanent choice. Scripting languages fo\u00adcus on programmer \nproductivity early in the software life cycle. For example, studies show a factor 3 60 reduced ef\u00adfort \nand 2 50 reduced code for Tcl over Java, C and C++. However, when the exploratory phase is over and require\u00adments \nhave stabilized, scripting languages become less ap\u00adpealing. The compromises made to optimize development \ntime make it harder to reason about correctness, harder to do semantic-preserving refactorings, and in \nmany cases harder to optimize execution speed. Even though scripts are suc\u00adcinct, the lack of type information \nmakes the code harder to navigate. An additional shortcoming of most scripting lan\u00adguages is lack of \n.rst-class support for concurrency. Con\u00adcurrency is no longer just the province of specialized soft\u00adware \nsuch as high-performance scienti.c algorithms it is ubiquitous, whether driven by the need to exploit \nmulticore architectures or the need to interact asynchronously with ser\u00advices on the Internet. Current \nscripting languages, when they support concurrency at all, do so through complex and frag\u00adile libraries \nand callback patterns, which combine browser\u00adand server-side scripts written in different languages and \nare notoriously troublesome.  Currently, the weaknesses of scripting languages are largely dealt with \nby rewriting scripts in either less brittle or more ef.cient languages. This is costly and often error\u00adprone, \ndue to semantic differences between the scripting lan\u00adguage and the new target language. Sometimes parts \nof the program are reimplemented in C to optimize a particularly intensive computation. Bridging from \na high-level scripting language to C introduces new opportunities for errors and in\u00adcreases the number \nof languages a programmer must know to maintain the system. Design Principles. This paper reports on \nthe design and the implementation status of Thorn, a novel programming language running on the Java Virtual \nMachine (JVM). Our principal design contributions are a careful selection of fea\u00adtures that support the \nevolution of scripts into robust indus\u00adtrial grade programs, along with support for a simple but powerful \nconcurrency model. By robust , we mean that Thorn encourages certain good software engineering prac\u00adtices, \nby making them convenient. The most casual use of classes will result in strong encapsulation of instance \n.elds. Pattern matching is convenient and pervasive and provides some of the type information which is \nlost in most dynami\u00adcally typed languages. Code can be encapsulated into mod\u00adules. Components provide \nfault boundaries for distributed and concurrent computing. Thorn has been designed to strike a balance \nbetween dynamicity and safety. It does not support the full range of dynamic features commonly found \nin scripting languages, though enough of them for rapid prototyping. It is static enough to facilitate \nreasoning and static analyses. Thorn runs on the JVM, allowing it to execute on a wide range of operating \nsystems and letting it use lower-level Java libraries for the Thorn runtime and system services. Thorn \nhas the following key features: Scripty: Thorn is dynamically-typed with lightweight syn\u00adtax and includes \npowerful aggregate data types and .rst\u00adclass functions. Object-oriented: Thorn includes a simple class-based \nmultiple inheritance object model that avoids the main complexities by simple static restrictions. Patterns: \nThorn supports an expressive form of pattern matching for both built-in types and objects. Immutable \ndata types: Thorn encourage the use of im\u00admutable data, which typically eases code composition and evolution. \nConcurrency and distribution: Non-sequential program\u00adming is done by lightweight, isolated, single-threaded \ncomponents that communicate by message passing. Modules: An expressive module system makes it easy to \nwrap scripts as reusable components. Constraints: Optional constraint annotations on declara\u00adtions permit \nstatic or dynamic program checking, and fa\u00adcilitate optimizations. Extensibility: An extensible compiler \ninfrastructure writ\u00adten in Thorn itself allows for language experimentation and development of domain \nspeci.c variants. It is important to note what Thorn does not support. Threads: There is no shared memory \nconcurrency in Thorn, hence data races are impossible and the usual problems associated with locks and \nother forms of shared memory synchroniza\u00adtion are avoided. Dynamic loading: Thorn does not support dynamic \nloading of code. This facilitates static optimization, enhances security, and limits the propagation \nof failures. However, Thorn does support dynamic creation of compo\u00adnents, which can be used in many applications \nthat currently require dynamic loading. Introspection: Unlike many script\u00ading languages, Thorn does not \nsupport aggressively intro\u00adspective features. Unsafe methods: Thorn can access Java libraries through \nan interoperability API, but there is no ac\u00adcess to the bare machine through unsafe methods as in C#. \nJava-style interfaces: Their function is subsumed by mul\u00adtiple inheritance. Java-style inner classes: \nThese are com\u00adplex and dif.cult to understand, and are largely subsumed by simpler constructs such as \n.rst-class functions. Implicit coercions: Unlike some scripting languages, Thorn does not support implicit \ncoercions, e.g., interpreting a string \"17\" as an integer 17 in contexts requiring an integer. Targeted \nDomains. Thorn is aimed at domains includ\u00ading client-server programming for mobile or web applica\u00adtions, \nembedded event-driven applications, and distributed web services. The relevant characteristics include \na need for rapid prototyping, for concurrency and, as applications ma\u00adture, for packaging scripts into \nmodules for reuse, deploy\u00adment, and static analysis. Thorn plugins provides language support for specialized \nsyntax and common patterns, e.g., web scripting or streaming. They make it possible to adapt Thorn to \nspecialized domains and allow more advanced op\u00adtimizations and better error handling than with macros. \nImplementation Status and Availability. Thorn is joint project between IBM Research and Purdue.There \nare cur\u00adrently two implementations of Thorn on the JVM: a feature\u00adcomplete reference implementation in \nthe form of an inter\u00adpreter, and a slightly restricted bytecode compiler. We are re-engineering the compiler \nto extend it to the full language. The only features discussed in this paper that are not fully supported \nin the interpreter (but available in the compiler) are general type constraints and language plugins. \nAll of the examples in this paper have been tested on the refer\u00adence implementation. More information \nis available from the Thorn web site at http://www.thorn-lang.org. An open source version of Thorn is \nexpected in late 2009.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Scripting languages enjoy great popularity due to their support for rapid and exploratory development. They typically have lightweight syntax, weak data privacy, dynamic typing, powerful aggregate data types, and allow execution of the completed parts of incomplete programs. The price of these features comes later in the software life cycle. Scripts are hard to evolve and compose, and often slow. An additional weakness of most scripting languages is lack of support for concurrency - though concurrency is required for scalability and interacting with remote services. This paper reports on the design and implementation of Thorn, a novel programming language targeting the JVM. Our principal contributions are a careful selection of features that support the evolution of scripts into industrial grade programs <i>e.g.</i>, an expressive module system, an optional type annotation facility for declarations, and support for concurrency based on message passing between lightweight, isolated processes. On the implementation side, Thorn has been designed to accommodate the evolution of the language itself through a compiler plugin mechanism and target the Java virtual machine.</p>", "authors": [{"name": "Bard Bloom", "author_profile_id": "81100272990", "affiliation": "IBM Research, Hawthorne, NY, USA", "person_id": "P1728610", "email_address": "", "orcid_id": ""}, {"name": "John Field", "author_profile_id": "81100419562", "affiliation": "IBM Research, Hawthorne, NY, USA", "person_id": "P1728611", "email_address": "", "orcid_id": ""}, {"name": "Nathaniel Nystrom", "author_profile_id": "81100144238", "affiliation": "University of Texas at Arlington & IBM Research", "person_id": "P1728612", "email_address": "", "orcid_id": ""}, {"name": "Johan &#214;stlund", "author_profile_id": "81388600832", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P1728613", "email_address": "", "orcid_id": ""}, {"name": "Gregor Richards", "author_profile_id": "81438595000", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P1728614", "email_address": "", "orcid_id": ""}, {"name": "Rok Strni&#353;a", "author_profile_id": "81318491338", "affiliation": "University of Cambridge", "person_id": "P1728615", "email_address": "", "orcid_id": ""}, {"name": "Jan Vitek", "author_profile_id": "81100018102", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P1728616", "email_address": "", "orcid_id": ""}, {"name": "Tobias Wrigstad", "author_profile_id": "81323497904", "affiliation": "Stockholm University & Purdue University", "person_id": "P1728617", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640016", "year": "2009", "article_id": "1640016", "conference": "OOPSLA", "title": "Thorn: robust concurrent scripting on the JVM", "url": "http://dl.acm.org/citation.cfm?id=1640016"}