{"article_publication_date": "10-25-2009", "fulltext": "\n Harmony-Oriented Programming and Software Evolution Sebastian Fleissner Elisa Baniassad Department of \nComputer Science and Engineering The Chinese University of Hong Kong Shatin, N.T., Hong Kong {seb, elisa}@cse.cuhk.edu.hk \nAbstract Software evolution draws its complexity from a variety of factors, including extensibility, \nmaintainability, and the dif\u00ad.culty of changing a program s design. It is widely accepted that even well-designed \nobject-oriented programs can be\u00adcome brittle as they evolve, because their design has to be .xed at some \npoint, and the more their implementation has progressed, the more dif.cult it becomes to adjust object \nin\u00adterfaces and relationships. We assert that the complexity of software evolution can be reduced by \nrelaxing strong encapsulation and informa\u00adtion hiding, and introducing concepts such as continuous information \n.ow. These principles are captured in harmony\u00adoriented programming, a paradigm inspired by concepts of \nAsian philosophy, such as harmony, resonance, and .elds of interactions. This paper illustrates the constructs \nof harmony-oriented programming and several studies aimed at showing that, in comparison with traditional \nobject-oriented programming, harmony-oriented programming is a more suitable approach for dealing with \nsoftware evolution ef\u00adfectively. Categories and Subject Descriptors D.3.3 [Software / Programming Languages]: \nLanguage Constructs and Fea\u00adtures General Terms Languages Keywords Harmony, Resonance 1. Introduction \nObject-oriented programming is strongly in.uenced by ideas of ancient Greek philosophy and thought. As \ndescribed in [6], ancient Greeks had a strong sense of personal agency and considered themselves to be \nindividuals with unique, Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. Copyright c &#38;#169; 2009 ACM \n978-1-60558-768-4/09/10. . . $10.00 distinctive attributes and goals. Greek philosophers, such as Plato \nand Aristotle, posited the view that the world is a static and unchanging collection of objects that \ncan be described and analyzed through categorization and formal logic. It was the habit of Greek philosophers \nto regard ob\u00adjects, such as persons, places, and things, in isolation from their context and to analyze \ntheir attributes. The attributes were used as the basis of categorization of an object, and the resulting \ncategories are employed to construct rules gov\u00aderning the behavior of the object. The relevance of possi\u00adble \noutside forces that can affect an object was completely ignored. Object-oriented software design and \ndevelopment strongly resembles the world view put forward by these Greek philosophers. It is common practice \nin object-oriented programming to isolate objects from their context and then describe them by their \nattributes (i.e. methods and instance variables). It is generally accepted that even well-designed object\u00adoriented \nprograms can become more brittle as they evolve. To cope with software evolution, the traditional object\u00adoriented \napproach of making a complete software design before coding has been replaced with other strategies, \nsuch as design for extensibility and maintainability. However, such design is non-trivial, as interfaces \nand object relation\u00adships have to be .xed at some point, and any subsequent change to the interface of \none object can lead to many po\u00adtential changes to dependent objects. As pointed out in [2], software \nevolution can eventually causes brittleness even in well-designed object-oriented programs. Ancient Chinese \nphilosophers did not focus on objects and their attributes, but rather considered the broad context, \nand saw the world in terms of harmony, context, roles, obliga\u00adtions, and resonance. For example, a person \nwas consid\u00adered not as an individual with a constant unique identity, but rather as a member of several \ncollectives. As described in [7], ancient Chinese philosophers considered the world as a mass of continuously \ninteracting substances rather than a collection of discrete objects. Our previous work [1, 4] introduces \nthe conceptual idea and initial principles of harmony-oriented programming (HOP), a programming paradigm \ninspired by concepts of Eastern thinking and reasoning, such as context and reso\u00adnance. The main idea \nbehind harmony-oriented program\u00adming is that pieces of a program always interact with their environment \nas a whole and usually not with other program parts directly. Table 1 illustrates important conceptual \ndif\u00adferences between harmony-oriented software programming and object-oriented programming (OOP).  \nTable 1. Object-Orientation and Harmony-Orientation Harmony-oriented programming relaxes established \nand widely accepted object-oriented principles, such as strong encapsulation and information hiding, \nand favors more .ex\u00adible and ah-hoc approaches for structuring and implementing programs. 1.1 Hypothesis \nSoftware evolution is signi.cantly affected by the following factors: Ease of changing the program s \ndesign, extensibility and maintainability of the program, quality feedback, and error recovery. The hypothesis \nof this research is that in comparison to object-oriented programming, harmony-oriented program\u00adming \nimproves the ease of dealing with some of these fac\u00adtors, and thus the ease of dealing with software \nevolution ef\u00adfectively. In particular, the hypothesis posits that harmony\u00adoriented programming has the \nfollowing advantages over traditional object-oriented programming: 1. Improved changeability: Fewer changes \nare required in order to re.ect adjustments of a program s design in the code. 2. Improved extensibility \nand maintainability: Extending a program requires less effort (steps/changes).  2. Principles of Harmony \nOrientation This section presents a revised and extended discussion of the principles of harmony-orientation \noriginally intro\u00adduced in [4]. Harmony, resonance, and context are three key concepts found in Asian \n(in particular Chinese) philos\u00adophy. These three concepts are the basis of the principles of harmony-oriented \nprogramming (.gure 1), which are de\u00adnoted as balance, exposure, spaciality, information sharing, and \ninformation diffusion. Figure 1. Principles of Harmony-Oriented Programming 2.1 Balance The balance \nprinciple is inspired by the concept of harmony and refers to balance of data production and consumption. \nThe overall goal of a harmony-oriented program is a bal\u00adanced state, which is achieved when any data \nproduced by one part of the program is consumed by one or more other parts of the program. 2.2 Exposure \nThe design of object-oriented programming and other pro\u00adgramming languages is based on the principle \nof encapsula\u00adtion. Unlike encapsulation, the exposure principle suggests decomposing a program into pieces \ncalled snippets, without the need to encapsulate these pieces using constructs with well de.ned boundaries, \nsuch as modules, functions, and ob\u00adjects. Hence, snippets do not conform to or expose any spe\u00adci.c interface. \nHowever, the code inside snippets can contain constructs based on the encapsulation principle. In the \nsim\u00adplest case, a snippet is a single statement. Figure 2. Exposure Principle 2.3 Spaciality Every \npart of a program is assigned to one or more locations in a virtual space. Related parts of a program \nare positioned close to each other to form a speci.c context. For example, snippets that implement a \nuser interface are placed in each others vicinity to form a user interface context, and snippets that \nimplement a certain part of business logic are placed somewhere else to form another context.  2.4 Information \nSharing and Diffusion The information sharing principle suggests that all data is shared between the \npieces of a program. This principle facil\u00aditates the resonance concept, as one part of the program can \n  Figure 3. Spaciality Principle react to changes made by any other part of the program. The information \nsharing principle is the basis for the information diffusion principle. Diffusion is a gradual process \nin which a substance is spread over a space over time. The information diffusion princi\u00adple states that \ndata or a description of the data generated by any part of the program is diffused throughout the vir\u00adtual \nprogram space. Data has an associated intensity that de\u00adcreases the further it is diffused. The combination \nof the dif\u00adfusion and code positioning principles ensures that data gen\u00aderated by one code fragment (or \nthe description of that data) reaches other code fragments that are located close within the virtual \nspace .rst. Figure 4. Information Diffusion Principle 3. Anatomy of Harmony-Oriented Programs A harmony-oriented \nprogram consists of virtual spaces with two or more dimensions that contain spatial constructs. Spaces \nserve as the runtime environment of the harmony\u00adoriented program. Each spatial construct is assigned \nto a speci.c location in a space and can interact with the space by putting data into and consuming data \nfrom its location. Spatial constructs are only aware of the space containing them and can not see or \ninteract with other spatial constructs. Whenever a space receives data from a spatial construct, it automatically \ndiffuses it. Because of the diffusion, the data eventually reaches the locations of other spatial constructs, \nwhich then can consume the data. Hence, the diffusion pro\u00adcess facilitates indirect data exchange between \nthe spatial constructs inside a space. In addition to spatial constructs, concrete harmony-oriented programming \nlanguages and runtime environments can choose to support object-oriented constructs like classes and \nobjects for the purpose of realizing abstract data types and accessing existing application programming \ninterfaces. As a result, harmony-oriented programming can be realized as an extension to object-oriented \nprogramming. However, when writing harmony-oriented programs, the primary decompo\u00adsition is always in \nterms of spaces and spatial constructs, and not objects. 3.1 Spatial Constructs Spatial constructs are \nprogram constructs that are assigned to a location in a spaces. As mentioned above, spatial con\u00adstructs \ncan only interact with the space containing them and not with other spatial constructs directly. In particular, \nspa\u00adtial constructs can put data into its location in the space, con\u00adsume data from its location in the \nspace, and observe data inside its location in the space. The most important spatial construct is the \nsnippet. A snip\u00adpet is a piece of source code that is not encapsulated using a construct with well-de.ned \nboundaries. In the simplest case, a snippet is a single statement or a list of statements. Like objects, \nsnippets can maintain a state. However, objects use encapsulation and information hiding to isolate their \nstate from other parts of the program. The state of a snippet, on the other hand, is owned by the space \ncontaining the snippet, and, like any other data placed into the space, is diffused and thus available \nto other spatial constructs.  3.2 Spaces Spaces can have two or more dimensions and serve as a runtime \nenvironment for spatial constructs. In particular, spaces are responsible for maintaining and diffusing \ndata generated by spatial constructs. Spaces can contain other spaces, and space hierarchies can be constructed \nto organize huge programs. Harmony-oriented programs use dynamic typing and sup\u00adport data tagging. Tags \nare used by spatial constructs to de\u00adscribe and .lter data. When a spatial construct puts data into the \nspace, it is stored in the same location the spatial con\u00adstruct is in. For example, if the location of \na spatial construct is (30, 50) in a two-dimensional space, then this location contains the state of \nthe spatial construct, and initially all data the snippet explicitly puts into the space (before diffu\u00adsion \nbegins). If a spatial construct puts several values of the same data type into a space, the location \nstores the various values. As a result, no data generated by a spatial construct is ever discarded and \nspaces can be considered as the memory of a harmony-oriented program.  3.2.1 Substances and Diffusion \nSpaces use so-called virtual substances to diffuse the state of and data produced by spatial constructs. \nEach time a new spatial construct is created, the space generates a corre\u00adsponding substance in the same \nlocation. Figure 5 shows two substances and their corresponding spatial constructs (snip\u00adpets). A substance \nabsorbs all data the spatial construct im\u00adplicitly or explicitly produces, and the space starts diffusing \nit after it absorbs data for the .rst time. The diffusion pro\u00adcess gradually increases the area covered \nby the substance. At its origin, substances have a very high intensity, which decreases when going towards \nthe edges. Figure 5. Substances and Diffusion As shown in .gure 5, the diffusion process eventually \nin\u00adcreases the extent of the substance so far, that it covers the locations of other spatial constructs. \nOnce this happens, the space makes the data carried by the substance available those other spatial constructs. \nIn particular, when a spatial con\u00adstruct requests data from the space for consumption or ob\u00adservation, \nthe space goes through the substances covering its location and selects and passes a matching data. If \nmore than one substance contains data matching the requirements of the spatial construct, the space selects \nthe data from the substance with the highest intensity value at the spatial con\u00adstruct s location. 4. \nHarmony-Oriented Smalltalk Harmony-Oriented Smalltalk (HOS)1 is a harmony-oriented runtime and visual \ndevelopment environment that allows programmers to implement harmony-oriented programs whose snippets \nare written in Squeak Smalltalk. The visual development environment is based on Morphic and provides \nprogrammers with tools for inspecting spaces, editing snip\u00adpets, changing diffusion settings and debugging. \nSince HOS is based on Smalltalk, programmers have access to a vast object-oriented library providing \nnetworking, .le access, and multimedia features. However, when construct\u00ading harmony-oriented programs, \nthe primary decomposition is always in terms of spaces and spatial constructs, and not classes and objects, \neven though those are available. 5. Evaluation This section presents studies comparing harmony-oriented \nand object-oriented programming in regard to factors affect\u00ading software evolution. The harmony-oriented \nparts of the studies are implemented using Harmony-Oriented Smalltalk and the object-oriented parts are \nimplemented in plain Squeak Smalltalk. 5.1 Changeability Study: Relationships Several object-oriented \ndesign patterns that facilitate dy\u00adnamic relationships between objects, such as the Observer pattern, \nare proposed in [5]. The purpose of the Observer pattern is to realize a one-to-many dependency between \nob\u00adjects, such that when one object changes its state, all other objects are noti.ed. Figure 6. The \nObserver Design Pattern ([5]) Figure 6 illustrates the conceptual design of the Observer pattern. To \nattach and detach observers to a subject, the At\u00adtach and Detach methods have to be invoked for each \nob\u00adserver. These methods change an internal observer list that the subject instance maintains. Whenever \nthe state of a sub\u00adject changes, the following sequence of statements (proto\u00adcol) is executed: 1. The \nsubject invokes its Notify method. 1 http://www.squeaksource.com/hos.html  2. The Notify method iterates \nthrough the subject s observer list and invokes the Update method of each observer. 3. The Update method \nof each observer invokes the Get-State method of the subject and processes the new state.  Although \nthe implementation of the Observer pattern is not very complex, its existence alone underlines the lack \nof mechanisms for de.ning relationships, other than static in\u00adheritance relationships, between objects \nin OOP. In harmony\u00adoriented programming, code snippets interact with their space exclusively and are \nnot aware of other snippets. How\u00adever, programmers can set up subject-observer and other relationships \nthrough the spaciality principle: A relationship between two snippets can be established by moving them \nclose to each other in the space, and broken off by moving them apart from each other. This study considers \nan implementation of a subject-observer relationship between a subject that maintains a bank ac\u00adcount \nstate and an observer that is interested in being noti.ed whenever the balance of the account changes. \n5.1.1 Object-Oriented Implementation The subject is an instance of a class called AccountSubject, the \nobserver is an instance of a class called AccountOb\u00adserver, and the state itself is maintained by an \ninstance of a class called Account that provides methods related to man\u00adaging the account s balance, \nsuch as deposit and withdraw methods. Whenever the subject changes the state of the ac\u00adcount, the observer \nis noti.ed and provided with the Account instance. Listings 1 and 2 show the methods of the AccountSubject \nand AccountObserver classes. As shown in listing 1, the object-oriented implementation maintains its \nobservers in an ordered collection. Listing 3 contains a Smalltalk script set\u00adting up instances of AccountSubject \nand AccountObserver, and changing the state of the subject multiple times. 5.1.2 Harmony-Oriented Implementation \nThe harmony-oriented implementation consists of a single space and two snippets called account subject \nand ac\u00adcount observer snippets. The account subject snippet reuses the Account class from the object-oriented \nimple\u00admentation to realize its state. As explained in section 3.1, the state of a snippet is owned and \ndiffused by the space, just like all other data in harmony-oriented programs. The implemen\u00adtation of \nthe account subject snippet is a list of statements that change the type of the snippet state toAccount \nand then access it to change the balance (deposit, withdraw, etc). The implementation of the account \nobserver snippet ob\u00adserves the space and processes any Account objects that are diffused to its location. \nFigure 7 illustrates the harmony\u00adoriented implementation of the account subject-observer re\u00adlationship \nand listings 4 and 5 show the code of the subject and observer snippets. 1 2 3 4 5 6 7 8 9 10 11 12 13 \n14 15 16 17 1 2 3 1 2 3 4 initialize observers := OrderedCollection new. account := Account new. attach \n: anObserver observers add : anObserver . detach : anObserver observers remove: anObserver. notify observers \ndo:[: observer | observer update :  balance : aNumber . account balance : self notify . withdraw : \naNumber account withdraw : deposit : aNumber account deposit : account .]. aNumber . aNumber. self notify \n. aNumber. self notify . Listing 1. Methods of AccountSubject class (OOP). update : anAccount Transcript \ncr; show: Observer : , anAccount balance asString . Listing 2. Methods of AccountObserver class (OOP). \nsubject := AccountSubject new. subject attach : AccountObserver new; balance :100; deposit : 50.5; withdraw \n: 20; detachAll . Listing 3. Account subject and observer example (OOP). In the harmony-oriented program \nshown in .gure 7, the account subject-observer relationship is established already, since the substance \ndiffusing the state of the account subject snippet reaches the account observer snippet. Moving the two \nsnippets further apart from each other results in breaking off the subject-observer relationship.  5.1.3 \nComparison As the implementations in listings 4 and 5 show, it is not nec\u00adessary to explicitly implement \nsupport for subject-observer  Figure 7. Account Subject and Account Observer (HOP) 1 Account Subject \n2 state type: Account; 3 balance :100; deposit : 50.5; withdraw : 20. Listing 4. Account subject snippet \n(HOP). 1 Account Observer 2 space observe: Account do:[:acc | 3 log show: Observer : , 4 acc balance \nasString . 5 ]. Listing 5. Account observer snippet (HOP). relationships in harmony-oriented programs. \nIt is enough to de.ne two snippets: A subject snippet whose state is of type Account and an observer \nsnippet that consumes data of type Account. In the object-oriented implementation, however, support for \nthe subject-observer relationship has to be implemented ex\u00adplicitly. Apart from de.ning the AccountSubject \nand Ac\u00adcountObserver classes, the programmer has to: De.ne nine methods (eight methods in AccountSubject \nand one method in AccountObserver).  Implement the methods (containing a total of 18 message sends). \n The minimal implementation overhead for supporting subject\u00adobserver relationships in object-oriented \nprograms is as fol\u00adlows: The subject class has to create a list for maintain\u00ading observers and provide \nmethods for attaching, detaching, and notifying observers. Additionally, it has to manually in\u00advoke the \nobserver s noti.cation method each time its state changes. The observer class has to implement a method \npro\u00adcessing the updated state.  5.2 Extensibility and Maintainability Study The extensibility and maintainability \nstudy considers the ex\u00adample of an extensible application server (EAS) that receives requests from clients \nvia a TCP socket and then passes these requests to registered applications, which process them and produce \na replies. EAS is extensible in two ways: Firstly, it is possible to add new protocols for interacting \nwith clients, such as XML-RPC, SOAP and others. Secondly, it is possi\u00adble to register and unregister \napplications during runtime. Harmony-Oriented EAS Figure 8 shows a possible harmony-oriented implementation \nof the EAS. This particular implementation contains two registered applications called Bank Account Application \nand Counter Application , and supports the XML-RPC pro\u00adtocol for interacting with clients. The snippets \nimplementing the server are: Socket Reader A snippet that listens on a speci.ed TCP port, creates sockets \nfor incoming connections, and puts any data chunks received from these sockets into the space. XML-RPC \n. Action Request A snippet that consumes data chunks containing XML-RPC. The XML-RPC is converted into \na protocol in\u00addependent ActionRequest object, which is put into the space. Bank Account Application \nand Counter Application These two snippets represent registered applications. They observe the space \nand consume any ActionRequest objects matching the functionality they provide. After an ActionRequest \nhas been consumed, the snippet performs the corresponding action, generates an ActionResponse object \nand puts it into the space.  Action Response . XML-RPC A snippet that consumes ActionResponse objects \ncon\u00adverts them into a XML-RPC response string. The gen\u00aderated XML-RPC string is put into the space as \na data chunk.  Socket Writer  A snippet that consumes data chunks and passes them to the client. To \nadd support for additional protocols, it is suf.cient to implement two additional snippets converting \nrequests and responses to and from ActionRequest and ActionResponse. New applications can be added by \ncreating a new snippet implementing the desired functionality and placing it in the  Figure 8. Harmony-Oriented \nExtensible Application Server center of the space, close to the other two application snip\u00adpets. These \napplications can be unregistered without being shut down by moving them far away from the other snippets \nof the extensible application server. Object-Oriented EAS An object-oriented version of the of the extensible \napplica\u00adtion server requires signi.cant design before coding. In par\u00adticular, the programmer has to design \ninterfaces for imple\u00admenting and registering new protocols and applications. Figure 9. Minimal Object-Oriented \nEAS Design One possible minimal object-oriented design is shown in .g\u00adure 9. It de.nes a Server class \nand two abstract base classes for applications and protocols called Application and Proto\u00adcol. The Server \nclass provides methods for registering and unregistering applications and protocols. The Protocol class \nprovides a method for checking wether a certain request string received by a socket is a valid request \nin the protocol it implements. In addition, the protocol class has two methods for encoding and decoding \nrequests and responses into and from instances of protocol-independent ActionRequest and ActionResponse \nclasses.The Application class exposes a sin\u00adgle method that takes an ActionRequest object as a parame\u00adter \nand returns an ActionResponse object. Using this design, protocols and applications can be registered \nprogrammati\u00adcally during startup. Comparison: Dealing With Unpredicted Changes The following paragraphs \nbrie.y examine the complexity of applying initially unexpected extensions to both versions of EAS. Lets \nconsider a scenario where EAS is updated to support applications that process continuous data streams, \nsuch as video or audio, and do not use a request-response model for interacting with their clients. To \nsupport stream based EAS applications in the harmony\u00adoriented version of the server, it is suf.cient \nto update the Socket Reader snippet to add tags to data chunks that in\u00addicate which client they come \nfrom. A stream-based EAS application can then be implemented as a snippet consuming data chunks that \nare not consumed by the snippets process\u00ading protocol messages. After a chunk has been processed, it \nis put back into the space. The socket writer then receives the processed chunk and passes it back to \nthe client. No major changes to snippets or data are required. In the object-oriented version of the \nEAS, both logical and structural changes are required for supporting stream based applications. These \nchanges include, but are not limited to: De.ning a new abstract class for stream based applica\u00adtions, \nor changing the interface of the existing Appli\u00adcation class. If the interface of the Application class \nis changed, all subclasses have to be adjusted as well.  Changing the interface of the Server class \nto support registration of the new type of applications.  Changing the logic of the Server to treat \nand process incoming data as a stream, if none of the Protocol classes can process it.   5.3 Summary \nThe previous sections provide evidence that, in comparison to traditional object oriented programming, \nthe strengths of harmony-oriented programming are ease of changing the program s design, extensibility, \nand maintainability. Table 2 summarizes how factors affecting software evolution are ful.lled by harmony-oriented \nprogramming. Factor Harmony-Oriented Programming Ease of change Improved in comparison with OOP, as the \nstructure of programs can be changed easily by moving snippets. Extensibility Improved in comparison \nwith OOP, because new snippets can be added at runtime, and existing snippets do not have to be changed. \nMaintainability Improved in comparison with OOP, because snippets do not have any di\u00adrect dependencies \non each other. Table 2. Study Results 6. Related Work Harmony-oriented programming utilizes diffusion, \na process in which substance or matter is spread over space over time, has been adapted in computer graphics \n[8] and multi-agent systems, such as [12], [10], [11], and [9]. For example, in [11] Repenning proposes \ncollaborative diffusion as an agent\u00adbased arti.cial intelligence system for computer games. On the surface, \nthe harmony-oriented programming runtime environment appears to be similar to multi-agent systems, such \nas [11] . However, agent systems can be considered as a speci.c application domain while harmony-oriented \npro\u00adgramming is a new approach for implementing arbitrary pro\u00adgrams. Snippets and agents are different \nfrom each other: Agents have features like autonomy, social ability, reactiv\u00adity, goal-orientation, and \nadaptability. It is possible to write snippets that implement agent features, but as a conceptual construct, \nsnippets are not comparable to agents. Spreadsheet programming languages and languages inspired by spreadsheets, \nsuch as subtext [3], share the following similarities with harmony-oriented programming: Firstly, spreadsheets \nand harmony-oriented programs are continu\u00adously executing, even when code and data are being edited. \nHence, any change is immediately applied and visualized. Secondly, like harmony-oriented programs spreadsheets \nar\u00adrange code and data in a two dimensional space and are data driven. The difference is that spreadsheet \nlanguages are functional programming languages while harmony-oriented programming is based on principles \nlike information diffu\u00adsion, balance, and code exposure. 7. Conclusion This paper presents principles \nand constructs of harmony\u00adoriented programming and studies that illustrate the strengths of the harmony-oriented \nprogramming approach in the con\u00adtext of software evolution. The studies presented in this paper are only \nthe .rst step towards evaluating and vali\u00addating harmony-oriented programming. We expect further research \nto focus on the following areas: One area is to vali\u00addate harmony-oriented programming in the context \nof large real world applications, such as application servers. The sec\u00adond area is work towards designing \na pure harmony-oriented programming language and corresponding virtual machine. References [1] E. Baniassad \nand S. Fleissner. The geography of program\u00adming. In OOPSLA 2006 Companion, pages 560 573. ACM Press, \n2006. [2] O. Ciupke. Automatic detection of design problems in object\u00adoriented reengineering. In TOOLS \n99 Proceedings, page 18, 1999. IEEE Computer Society. [3] J. Edwards. Subtext: uncovering the simplicity \nof program\u00adming. In OOPSLA 05 Proceedings, pages 505 518, 2005. ACM Press. [4] S. Fleissner and E. Baniassad. \nTowards harmony-oriented programming. In OOPSLA 08 Companion, pages 819 822. ACM Press, 2008. [5] E. \nGamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. \nAddison Wesley, 1995. [6] E. Hamilton. The Greek Way. Avon, 1973. [7] C. Hansen. Language and Logic in \nAncient China. University of Michigan Press, 1983. [8] M. J. Harris, G. Coombe, T. Scheuermann, and A. \nLastra. Physically-based visual simulation on graphics hardware. In HWWS 02 Proceedings, pages 109 118, \n2002. Eurographics Association. [9] T. Hogg. Coordinating microscopic robots in viscous .uids. Autonomous \nAgents and Multi-Agent Systems, 14(3):271 305, 2007. [10] Y. Jiang, J. Jiang, and T. Ishida. Agent coordination \nby trade\u00adoff between locally diffusion effects and socially structural in.uences. In AAMAS 07 Proceedings, \npages 1 3, 2007. ACM. [11] A. Repenning. Collaborative diffusion: programming antiobjects. In OOPSLA \n06 Companion, pages 574 585, 2006. ACM. [12] K. C. Tsui and J. Liu. Multiagent diffusion and distributed \noptimization. In AAMAS 03 Proceedings, pages 169 176, 2003. ACM.    \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Software evolution draws its complexity from a variety of factors, including extensibility, maintainability, and the difficulty of changing a program's design. It is widely accepted that even well-designed object-oriented programs can become brittle as they evolve, because their design has to be fixed at some point, and the more their implementation has progressed, the more difficult it becomes to adjust object interfaces and relationships.</p> <p>We assert that the complexity of software evolution can be reduced by relaxing strong encapsulation and information hiding, and introducing concepts such as continuous information flow. These principles are captured in harmony-oriented programming, a paradigm inspired by concepts of Asian philosophy, such as harmony, resonance, and fields of interactions. This paper illustrates the constructs of harmony-oriented programming and several studies aimed at showing that, in comparison with traditional object-oriented programming, harmony-oriented programming is a more suitable approach for dealing with software evolution effectively.</p>", "authors": [{"name": "Sebastian Fleissner", "author_profile_id": "81339499723", "affiliation": "Chinese University of Hong Kong, Sha Tin, Hong Kong", "person_id": "P1728366", "email_address": "", "orcid_id": ""}, {"name": "Elisa Baniassad", "author_profile_id": "81414615851", "affiliation": "Chinese University of Hong Kong, Sha Tin, Hong Kong", "person_id": "P1728367", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640069", "year": "2009", "article_id": "1640069", "conference": "OOPSLA", "title": "Harmony-oriented programming and software evolution", "url": "http://dl.acm.org/citation.cfm?id=1640069"}