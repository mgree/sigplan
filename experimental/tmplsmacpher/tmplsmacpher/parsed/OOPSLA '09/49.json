{"article_publication_date": "10-25-2009", "fulltext": "\n How Lock Contention Affects Energy Use in a CMP Server Takeshi Ogasawara Ken Sakamura Applied Computer \nScience Course, Graduate School of Applied Computer Science Course, Graduate School of Interdisciplinary \nInformation Studies, Interdisciplinary Information Studies, the University of Tokyo the University of \nTokyo IBM Tokyo Research Laboratory YRP Ubiquitous Networking Laboratory takeshi@jp.ibm.com ken@sakamura-lab.org \nAbstract A server application running on a chip multiprocessor with many hardware threads often requires \nextra processor speed (and energy) because of lock contention. We show that boosting the processor speed \nfor frequently contended critical sections in a Java VM can save more energy on a DVFS-enabled server. \nCategories and Subject Descriptors D.3.4 [Processors]: Run\u00adtime environments General Terms Languages, \nPerformance Keywords lock contention, energy ef.ciency, DVFS, Java, CMP  1. Introduction Given a CMP \n(Chip MultiProcessor) system with many hardware threads, the maximum performance of a typical server \napplication can be less than the ideal performance because of lock contention [6]. We are considering \nsituations in which the lock contention degrades the performance while the processor speeds have been \nreduced by DVFS (Dynamic Voltage and Frequency Scaling). This loss of performance calls for additional \nprocessor speed to handle the incoming request rate. If optimization of the lock mechanism can reduce \nthe lock contention with negligible energy increase and improve the performance, then the system processor \nspeed can be further lowered to save more energy while sustaining the same throughput. This means that \nreducing lock contention can reduce the energy consumption. 2. Performance degradation from lock contention \nWe analyzed how the throughput of a multithreaded Java program is degraded by lock contention as the \nprocessor speed is slowed down. We created an emulation program that emulates the system tested by Ueda \net al. [6]. Our emulation program was designed to reproduce the performance degradation that they observed \non their system (a T2000 server with 32 threads at 1.2 GHz and Java 1.4.2). It was written in the same \nprogramming language (Java) and used the same Java API methods to implement the same critical section. \nThe program iterates a transaction code block. Each transaction Copyright is held by the author/owner(s). \nOOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10.  100% 90% 80% \n70% 60% 50% 40% 30% 20% 10% 0% 100% 80% 60% 40% 20% Processor speed Original DFB trendline (Original) \ntrendline (DFB) Normalized relative performance Figure 1. Performance without and with DFB corresponds \nto the task of handling one request as de.ned by Ueda et al. Each transaction executes a pair made of \na critical section and non-critical section. To investigate the performance degradation by lock contention \nin a more recent environment than [6], we used a Sun T5220 server with twice as many hardware threads \nas the T2000 (but the same processor speed) and Java 6, which has more ef.cient locks than Java 1.4. \nSince the Sun T5220 does not support DVFS, we simulated slowing down the processors by inserting into \nthe emulation program some delay code that executed a busy loop to consume CPU cycles. We measured the \nthroughput of the emulation program. We ob\u00adserved the throughput degradation due to lock contention at \nvarious processor speeds (for example, 30% degradation at 100% speed). The line denoted by Original in \nFigure 1 shows the relative per\u00adformance normalized to the throughput at 100% processor speed, which \ncan be regarded as the maximum throughput of this program on the server. If the incoming request rate \nis 84% of the maximum throughput, the DVFS control algorithm will choose 75% processor speed based on \nthe performance characteristics shown in Figure1.  3. Reducing lock contention to reduce energy consumption \nPerformance degradation from lock contention results in extra en\u00adergy consumption. If we can improve \nthe performance by reducing lock contention, we can achieve the same throughput at lower pro\u00adcessor speeds. \nWe are developing a DFB (Dynamic Frequency (and voltage) Boost) for the contended critical sections in \na Java VM. The key idea is to increase the frequency and voltage of the processor to their maximum values \nwhen the frequent contention occurs in a critical section. Many locks are ubiquitously used on multithreaded \napplications in Java. However, since most of them are rarely con\u00adtended for [1], we can focus on accelerating \nonly critical sections whose locks are contended for. More importantly, critical sections are usually \ndesigned as being short in the total execution time. Therefore, we can reduce the energy consumption \nin total, since the power is reduced most of the time while the power is increased only a fraction of \nthe execution time in the target critical sections.  4. Analysis of potential energy reduction To investigate \nthe feasibility of our approach, this section evaluates how our approach improves energy consumption \non a server with many hardware threads by using a modern Java VM with optimized locks. We .rst show how \nthe required processor speed for a given input is reduced by our approach. We then show how the reduced \nprocessor speed reduces energy consumption. 4.1 Methodology We evaluated our approach by running the \nemulation program with different DVFS delays. To emulate processor speed increases by DFB, we remove \nthe delay code from the critical section. We eval\u00aduated our approach on an ideal con.guration (with zero \noverhead) and on more practical con.gurations with different overheads as\u00adsociated with the DVFS delays. \nWe emulated different overheads by inserting different amounts of delay code into the program. The majority \nof the overhead is in DVFS delays, which are the times required for transitions from one P-state to another. \nWe .rst estimated how much DFB can reduce the processor speed while retaining the same performance capacity. \nWe .rst calculated an equation that represents an order two polynomial trend line for each of the two \ndata sets (Original and DFB with no DVFS delays) as shown in Figure 1: y = f(x) where x denotes the processor \nspeed and y denotes the normalized relative performance. Then we obtained the processor speed x that \nshows the given f-1 performance y for Original and DFB by calculating x =(y). We obtained the processor \nspeed reduction by DFB by comparing f-1 (y) for each input load y between Original and DFB. We then estimated \nhow much energy DFB can save by using the data from reductions in processor speed. We rely on the pro\u00adcessor \nvoltage being proportional to the processor frequency [3] and the energy consumption being proportional \nto the square of the voltage [2, 4]. The energy consumption without DFB at x%pro\u00adcessor speed, Eoriginal(x),isgiven \nby E * (x/100)2 where E is energy consumption at 100% processor speed. The energy con\u00adsumption with DFB \nat x% processor speed, EDF B (x),isgivenby E * (x/100)2 * (1 - r(x)) + E * r(x),where r(x) is the ratio \nof the execution time of the critical section to the total execution time. The ratio r(x) is given by \ncsLen/(csLen+noncsLen*(100/x)), where csLen and noncsLen denote the relative execution times of a critical \nsection and a non-critical section, respectively. In the emulation program, csLen is 1 and noncsLen is \n126. The execu\u00adtion time of the non-critical section is increased by 100/x times at x% processor speed. \nWe compare the energy consumptions, Eoriginal(f-1 (y)) and EDF B (f-1 (y)), for an input load originalDF \nB y. 4.2 Ideal con.guration The .rst con.guration has no overhead from our approach. With this con.guration, \nwe can discuss the theoretically optimal perfor\u00admance. The results of the experiments are shown by DFB \nin Fig\u00adure 1. There is no change at 100% processor since the system ran at the maximum speed and no boost \nwas required. Our approach improved the performance at 75%, 50%, 33%, and 24% proces\u00adsor speeds by 8.9%, \n9.6%, 3.0%, and 1.7%, respectively. The ideal DFB consistently reduced the processor speed, up to 30.6% \nand 23.4% on average. The ideal DFB consistently reduced the energy consumption, up to 48.8% and by 39.5% \non average. 4.3 Practical overheads The second con.guration has a small overhead, 100 nanoseconds, for \neach P-state change. We show that we can achieve similar energy savings to the ideal con.guration. Kim \net al. recently re\u00adduced DVFS delays to tens of nanoseconds [3]. The ratios of 100 nsec to the execution \ntime of each iteration are negligible: 0.083%, 0.055%, 0.036%, and 0.027% at 75%, 50%, 33%, and 25% proces\u00adsor \nspeeds, respectively. For 1-through 10-usec DVFS delay [5], DFB also improves the energy consumption. \nFor 1-usec DVFS delay (a 2-usec DFB overhead), DFB can improve the performance at every processor speed. \nFor 10-usec DVFS delay (a 20-usec DFB overhead), DFB can improve the performance at 75% and 50% processor \nspeeds but not at 33% and 24%. For 100-usec DVFS delay (a 200-usec DFB overhead), DFB is ineffective. \n 5. Conclusion By using simulation experiments, we showed that a typical multi\u00adthreaded server application \nwith lock contention suffers from per\u00adformance degradation even when the processor speeds are reduced \nwith DVFS. We studied the feasibility of dynamically boosting the processor speed for contended critical \nsections to reduce the fre\u00adquency of lock contentions with various DVFS delays. We con\u00ad.rmed that our \napproach can consistently save energy in the emu\u00adlation program, by up to 48.8% and 39.5% on average \nat various re\u00adduced processor speeds. It does this by improving the performance with reduced lock contention \nfor the 100-nsec overhead of DFB, based on the leading-edge technology for DVFS.  References [1] David \nF. Bacon, Ravi Konuru, Chet Murthy, and Mauricio Serrano. Thin locks: featherweight synchronization for \nJava. In PLDI 98: Proc. ACM SIGPLAN 1998 Conf. on Programming language design and implementation, pages \n258 268, 1998. [2] Vincent W. Freeh, Tyler K. Bletsch, and Freeman L. Rawson, III. Scaling and packing \non a chip multiprocessor. In IEEE International Parallel and Distributed Processing Symposium (IPDPS \n07), pages 1 8, 2007. [3] Wonyoung Kim, Meeta S. Gupta, Gu-Yeon Wei, and David Brooks. System level analysis \nof fast, per-core DVFS us\u00ading on-chip switching regulators. In International Symposium on High-Performance \nComputer Architecture (HPCA), pages 123 134, 2008. [4] Jian Li and Jose F. Martinez. Power-performance \nimplications of thread-level parallelism on chip multiprocessors. In Inter\u00adnational Symposium on Performance \nAnalysis of Systems and Software (ISPASS), pages 124 134, 2005. [5] Xiaotao Liu, Prashant Shenoy, and \nMark D. Corner. Chameleon: Application-level power management. IEEE Transactions on Mobile Computing, \n7(8):995 1010, 2008. ISSN 1536-1233. doi: http://doi.ieeecomputersociety.org/10. 1109/TMC.2007.70767. \n[6] Yohei Ueda, Hideaki Komatsu, and Toshio Nakatani. Scala\u00adbility study of a Java application server \non two multi-core sys\u00adtems. In Eleventh Workshop on Computer Architecture Evalu\u00adation using Commercial \nWorkloads (CAECW), 2008.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>A server application running on a chip multiprocessor with many hardware threads often requires extra processor speed (and energy) because of lock contention. We show that boosting the processor speed for frequently contended critical sections in a Java VM can save more energy on a DVFS-enabled server.</p>", "authors": [{"name": "Takeshi Ogasawara", "author_profile_id": "81100012455", "affiliation": "IBM Tokyo Research Laboratory, Yamato, Japan", "person_id": "P1728572", "email_address": "", "orcid_id": ""}, {"name": "Ken Sakamura", "author_profile_id": "81100065818", "affiliation": "the University of Tokyo, Tokyo, Japan", "person_id": "P1728573", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640004", "year": "2009", "article_id": "1640004", "conference": "OOPSLA", "title": "How lock contention affects energy use in a CMP server", "url": "http://dl.acm.org/citation.cfm?id=1640004"}