{"article_publication_date": "10-25-2009", "fulltext": "\n The Anti-Goldilocks Debugger Helping the Average Bear Debug Transparently Transformed Programs Myoungkyu \nSong and Eli Tilevich Dept. of Computer Science Virginia Tech, Blacksburg, VA 24061, USA {mksong,tilevich}@cs.vt.edu \nAbstract The practice of enhancing the bytecode of Plain Old Java Objects (POJOs) with additional capabilities, \nincluding per\u00adsistence, distribution, and security, has become an indis\u00adpensable part of enterprise software \ndevelopment. The re\u00adsulting transparently-applied, large-scale structural changes to the bytecode signi.cantly \ncomplicate symbolic debug\u00adging. This demonstration will showcase the Anti-Goldilocks Java (AGJ) debugger, \nwhich enables the programmer to trace and debug transparently transformed programs, without the distraction \nof the bytecode-level enhancements obfuscat\u00ading the program s source code. AGJ executes a structurally\u00adenhanced \nprogram, while dynamically reinterpreting the de\u00adbugging output (e.g., step , print variable , etc.) \nto display program information as pertaining to the original version of the code. AGJ is based on a new \ndebugging architecture that leverages our domain-speci.c language for describing enhancements. A paper \nin the main technical program of OOPSLA 2009 [5] describes the design rationale and implementation details \nof AGJ. This demonstration will showcase the functionality of our reference implementation by using it \nto locate bugs in a framework-based enterprise application from the .nan\u00adcial industry. Using the domain \nof transparent persistence, this demonstration will compare AGJ to the standard JDK debugger, thereby \nhighlighting the capabilities of AGJ to cut through the morass of transparent bytecode enhancements in \norder to .nd obscure bugs. Categories and Subject Descriptors D.2.5 [Software Engi\u00adneering]: Testing \nand Debugging debugging aids, tracing General Terms Languages, Design, Experimentation Copyright is held \nby the author/owner(s). OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10. \n Keywords Debugging, program transformation, bytecode enhancement 1. Introduction Modern enterprise \nframeworks enable the programmer to build business logic components using Plain Old Java Ob\u00adjects (POJOs) \napplication objects that do not implement special interfaces or call framework API methods. POJO\u00adbased \nframeworks have become mainstream in the enterprise Java community, as they improve separation of concerns, \nspeed up development, and improve portability [3]. To provide services to a POJO, enterprise frameworks \ncommonly enhance its bytecode, either statically, as an ex\u00adtra build step, or dynamically, at class load \ntime. A typical bytecode enhancement constitutes a structural transforma\u00adtion that adds methods and .elds, \nchanges direct .eld ac\u00adcesses with setter/getter methods, adds new super classes/in\u00adterfaces, etc. As \na consequence of such bytecode enhance\u00adments, the running version of an enterprise application con\u00adtains \nfunctionality that has no representation at the source code level, making the source-level debugging \nof enterprise applications containing enhanced bytecode nontrivial. En\u00adhancements play an essential role \nin the architecture of an enterprise application, as they enable POJOs to interact with a framework one \ncannot simply turn off the enhancements to make the debugging process easier. As a result, tracing, analyzing, \nand .xing buggy programs with enhanced byte\u00adcode presents a challenge exacerbating the development of \nframework-based applications. Standard debuggers fall short when used to debug pro\u00adgrams containing enhanced \nbytecode, as they attempt to show both the original logic and the transparently intro\u00adduced enhancements, \neven though they have no source level representation. When it comes to debugging, bytecode en\u00adhancement \nstealthily obfuscates the program, often making it impossible to map the debugged version back to the \norigi\u00adnal source code. The programmer debugging a program that contains enhanced POJOs can feel utterly \nconfused and frus\u00adtrated. Indeed, seeing your code having been stealthily mod\u00adi.ed by some external entity \nconjures up feelings similar to that experienced by a proverbial bear from Goldilocks and the Three Bears \n[1], with the programmer tempted to scream in utter frustration: Someone s changed my POJO! 2. Anti-Goldilocks \nDebugger To help debug transparently-enhanced programs, we have created a new debugging architecture \nthat augments a stan\u00addard debugger with the functionality required to dynami\u00adcally reinterpret the source \ncode information pertaining to enhancements. Speci.cally, the debugger, on demand, sym\u00adbolically undoes \nthe enhancements that have been made to the debugged code. Our implementation, showcased in this demonstration, \nis called Anti-Goldilocks Java or AGJ for short. The intuition behind the name is that we aim at coun\u00adteracting \nthe actions of Goldilocks, who has meddled with the bears belongings, surreptitiously altering them. \nBy anal\u00adogy, Goldilocks is a transparent bytecode enhancer. Figure 1 demonstrates the AGJ architecture, \nwhich inte\u00ad grates a SER interpreter. To debug the enhanced bytecode, AGJ takes as input a SER script \ndeclaratively describing the enhancements, using it to transform the debugging output reported to the \nprogrammer, as if the original version of the As a fully-functional debugger, AGJ can step through the \ncode, set breakpoints, and print variable values. AGJ lever\u00adages the Java Platform Debugger Architecture \n(JPDA)[6], adding special translation modules to the standard layers of protocols and interfaces provided \nby the JVM. AGJ uses a special purpose domain-speci.c language, called Structural Figure 1. AGJ Architecture. \n3. Demonstration Plan From the programmer s perspective, AGJ is a plug-in re\u00adplacement for the standard \nJDK command-line debugger, providing the capabilities to step through the code, set break\u00adpoints, print \nvariable values, etc. In this demonstration, the utility of AGJ will be shown by tracking bugs in framework \napplications that use bytecode enhancement as part of their software development cycle. Example applications \nwill include the enhancements used by commercial enterprise frameworks and the ones used in research \nprototypes. The demonstration will start with a quick overview of the Structural Enhancements Rules (SER) \nlanguage, which is used for expressing bytecode enhancements. SER is a declarative, domain-speci.c language \nwe have created. We will brie.y walk through the basic building blocks of SER and show how this language \ncan be used to express various bytecode enhancement strategies. Then, the main part of the demonstration \nwill consist of using AGJ to .nd several seeded bugs in two types of appli\u00adcations. The seeded bugs will \nconcern the business logic of the applications, including throwing a NullPointerException and using incorrect \ncalculations. The .rst application calculates mortgage eligibility and could be used by a bank. This \napplication implements its per\u00adsistence functionality using the JDO framework [4], which statically enhances \nthe persisted classes to enable them to interact with the framework s runtime. The second applica\u00adtion \nis the remoting enhancement used in prior research projects [2, 7] to provide remote access to a class \nby means of distribution middleware. For both applications, we will .rst show the program\u00admer s experience \nwhen trying to locate the bug using the standard JDK debugger. Then we will demonstrate how AGJ makes \nit easier to .nd the bug, by undoing the JDO frame\u00adwork s enhancements, which complicate the debugging \npro\u00adcess. We aim at demonstrating how AGJ has the potential to become an effective aid in locating bugs \nin enhanced pro\u00adgrams. References [1] A. C. Elms. The Three Bears : Four interpretations. The Journal \nof American Folklore, 90(357):257 273, 1977. [2] M. Philippsen and M. Zenger. JavaParty transparent remote \nobjects in Java. Concurrency Practice and Experience, 9(11):1225 1242, 1997. [3] C. Richardson. Untangling \nenterprise Java. ACM Queue, 4(5):36 44, 2006. [4] C. Russell. Java Data Objects 2.1, June 2007. http: \n//db.apache.org/jdo/specifications.html. [5] M. Song and E. Tilevich. Enhancing source-level program\u00adming \ntools with an awareness of transparent program trans\u00adformations. In OOPSLA 09: Proceedings of the 24th \nannual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications, 2009. \n[6] Sun Microsystems. Java Platform Debugger Architecture. http://java.sun.com/javase/technologies/core/ \ntoolsapis/jpda/. [7] E. Tilevich and Y. Smaragdakis. J-Orchestra: Automatic Java application partitioning. \nIn Proceedings of the European Conference on Object-Oriented Programming (ECOOP), pages 178 204. Springer-Verlag, \nLNCS 2374, 2002.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>The practice of enhancing the bytecode of Plain Old Java Objects (POJOs) with additional capabilities, including persistence, distribution, and security, has become an indispensable part of enterprise software development. The resulting transparently-applied, large-scale structural changes to the bytecode significantly complicate symbolic debugging. This demonstration will showcase the Anti-Goldilocks Java (AGJ) debugger, which enables the programmer to trace and debug transparently transformed programs, without the distraction of the bytecode-level enhancements obfuscating the program's source code. AGJ executes a structurally enhanced program, while dynamically reinterpreting the debugging output (e.g., 'step', 'print variable', etc.) to display program information as pertaining to the original version of the code. AGJ is based on a new debugging architecture that leverages our domain-specific language for describing enhancements.</p> <p>A paper in the main technical program of OOPSLA 2009 [5] describes the design rationale and implementation details of AGJ. This demonstration will showcase the functionality of our reference implementation by using it to locate bugs in a framework-based enterprise application from the financial industry. Using the domain of transparent persistence, this demonstration will compare AGJ to the standard JDK debugger, thereby highlighting the capabilities of AGJ to cut through the morass of transparent bytecode enhancements in order to find obscure bugs.</p>", "authors": [{"name": "Myoungkyu Song", "author_profile_id": "81436594687", "affiliation": "Virginia Tech, Blacksburg, VA, USA", "person_id": "P1728661", "email_address": "", "orcid_id": ""}, {"name": "Eli Tilevich", "author_profile_id": "81100650102", "affiliation": "Virginia Tech, Blacksburg, VA, USA", "person_id": "P1728662", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640027", "year": "2009", "article_id": "1640027", "conference": "OOPSLA", "title": "The anti-goldilocks debugger: helping the average bear debug transparently transformed programs", "url": "http://dl.acm.org/citation.cfm?id=1640027"}