{"article_publication_date": "10-25-2009", "fulltext": "\n The Observer Effect of Pro.ling on Dynamic Java Optimizations Elena Machkasova Kevin Arhelger Fernando \nTrinciante University of Minnesota, Morris University of Minnesota, Morris University of Minnesota, Morris \nelenam@morris.umn.edu arhel005@morris.umn.edu trinc002@morris.umn.edu Abstract We show that the bytecode \ninjection approach used in com\u00admon Java pro.lers, such as HPROF and JPro.ler, disables some program optimizations \nthat are performed when the same program is running without a pro.ler. This behavior is presentinboththe \nclientandthe servermodeofthe HotSpot JVM. Categories and Subject Descriptors D.3.4[Programming Languages]: \nProcessors optimization,run-time environ\u00adments; D.2.8[SoftwareEngineering]:Metric performance measures \nGeneral Terms Measurement, Performance Keywords Java,HotSpot,JVM, pro.ler,HPROF,inlining,dead code elimination \n1. Introduction In a traditional implementation JavaTMprograms are com\u00adpiledto bytecodesand then ranbyaJavaVirtual \nMachine (JVM). Because of the need to dynamically load and reload Java classes, most Java optimizations \nare performed dynam\u00adically by Just-in-Time compilers (JITs). Most modern JITs employ an adaptive compilation \napproaches when only fre\u00adquentlyexecuted code (so-called hot spots)gets compiled to native code and/or \noptimized.AJIT-equippedJVMisa so\u00adphisticated system that achieves signi.cant speed improve\u00adments. However,detecting \nspeci.c program optimizations in this complex run-time environment is very challenging. A common tool \nfor monitoring a program performance is a pro.ler. Many pro.lers for Java, such as HPROF and JPro.ler, \nuse a technique called bytecode injection (see sec\u00adtion 2.2) to keep track of methods being executed. \nWhile pro.lers areextremely useful for monitoring memory usage, garbage collection, and other important \naspects of run-time behavior, we show that theyalso have an observer effect Copyright is held by the \nauthor/owner(s). OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10. \n on programs: a mere use of a pro.ler may disable some program optimizations, such as dead code elimination \nand method inlining, that are performed when the program is running without pro.ling. We use small Java \nsample programs in which some parts of code trigger the dynamic optimizations in question. To prove that \nthe optimizations take place, we time the pro\u00adgramsand comparethemwith hand-optimized versionsof the \nprograms Then we run the same programs witha pro.ler and study its output and timing.We show that while \nthe opti\u00admizations take place fora non-pro.led program, theyare not happeningwhenthe programisbeing pro.led.Our \nobserva\u00adtions are also applicableto other bytecode-based languages, such as JRuby and Jython, and to \nmore languages if their pro.lers employa similar technique. 2. Background In this project we used Java \nHotSpotTMJVM by Sun Mi\u00adcrosystems in both the client and the server mode [3].We used HPROF [2] and JPro.ler \nby ej-technologies. 2.1 Overview of HotSpot optimizations Thekeyfeatureof HotSpotJVMisthatit startseach \nmethod by just interpreting its bytecodes. Itlater compiles to native code and/or optimizes only those \nmethods that are executed over a speci.ed number of times (known as compilation threshold). By default \nthis threshold is 1500 in the client modeand 10000inthe server mode.Amethod needstoget over the threshold \nto get all bene.ts of dynamic compilation. Executing methodsenoughtimestogetoverthe thresholdis called \nJVM warmup. In our examples the large number of method calls guarantees that the threshold is reached. \n 2.2 OverviewofJavaPro.ling A pro.ler obtains some method execution information by periodically samplingthe \nstack. However,this information is inaccurate since it does not detect what happens in-between the sample \npoints. An alternative bytecode injection ap\u00adproach inserts a small sequence of bytecode instructions \nat the beginning and end of each method to record the time spentinthe method.HPROFand JPro.lerusethis \napproach.  run Complex (S) Easy (S) Hand (S) Complex (C) Easy (C) Hand(C) Unix 0.282 0.284 0.282 6.446 \n6.45 6.456 Unix, -XX:-Inline 11.92 14.06 0.28 29.878 18.174 6.372 Unix, hprof (fewer loops) 4.634 4.876 \n0.176 4.92 4.64 0.204 Windows 0.43 0.474 0.45 7.982 8.05 7.972 Windows, -XX:-Inline 21.578 20.706 0.422 \n27.048 26.992 7.864 Windows, hprof (fewer loops) 5.882 5.268 0.244 5.482 5.242 0.252 Table 1. Mean runtimes \nfor inlining (in seconds): server (S) and client (C) 3. Tests and Results Detecting program optimizations \nis challenging since very little run-time information is available from a JVM. We tested our sample programs \nin two different environ\u00adments:  Linux workstation with AMD AthlonTM64 Processor running Fedora Core \n7.  LenovoThinkpadT42pwithIntelPentiumMTMProcessor runningWindowsXP SP3.  We used Sun JDK 1.6.0 04. \nOur sample programs repeat the method or the code that we are studying a very large number of times in \na loop (2147483647 for inlining exam\u00adples) to produce total running times of several seconds. This makes \ndifferences between different running times clearly observable and JVM startup andwarmup times insigni.cant. \nWerepeatall tests6times,dropthe .rst run sinceittakesex\u00adtra time for memory allocation for the JVM, and \nrecord the meanof the remaining5runs. When using a pro.ler, we had to reduce the number of loops becauseofthe \ntimingoverheadofa pro.ler.Thusthe pro.led results are comparable to each otherbut not compa\u00adrableto non-pro.led \nresultsin termsof absolute times. We wrote three small programs that perform the same task: repeatedly \nincrement a variable. Two of them call a method to accomplish this task; theydifferin the complex\u00aditylevelofthe \nmethod. EasyInline has a simple method return1 that just returns 1. It is called in a loopto incre\u00adment \nthe instance variable counter: for(int i=0;i<2147483647;i++) counter += return1(); ComplexInline has \na more convoluted method public int addCount(int add) { add=add+1; return add; } to accomplishes the \nsame task; it is called in a similar loop as in EasyInline. HandInline has the functionality of the method \nhand-inlined directly into the loop: for(int i=0;i<2147483647;i++) counter++; The test results are summarized \nin table 2.1. While the ab\u00adsolute times differ for the Linuxworkstation and forWin\u00addows system, the pattern \nis the same. When no .ags are speci.ed, the three examples run in the same time. The two programs that \ncall a method have the same runtime as the hand-inlined program, indicating that the method is in\u00adlined. \nThis is con.rmed by running the same three exam\u00adples with -XX:-Inline .ag to turn off JIT inlining: the \nhand-inlinedversion does not change its running time,but the other two programs increase their time drastically. \nWhen the programs are pro.led, however, the methods that are supposed to be inlined show up in the pro.ling \nlog, e.g. HPROF log for EasyInline (client mode, Linux): 1 60.31% 60.31% ... EasyInline.method1 2 38.72% \n99.03% ... EasyInline.return1 method1 is the method that contains the main loop. Here the .rst percentage \nvalue is the percent of time the method is being executed, and the second number is the combined percent \nof the top methods up to the given one. The other pro.ling logs also show that the method that was supposed \nto be inlined is still in the second place in the log. Note that the pro.led runs are muchfaster for \nthe hand-inlinedversion than for the other two (see table 2.1), which is another indication that inlining \ndoes not happen. JPro.ler results have the same pattern as HPROF.We also observeda similar effect of \npro.ling for dead code elimination, see [1]. 4. Conclusions and FutureWork We have shown that bytecode \ninjection in a pro.ler has an observer effect , i.e. it changes the performance of the pro\u00adgram simplyby \nmonitoring its behavior. This has signi.cant implications for software developers who use pro.lers for \nperformance tuning. Alternative methods for detecting the optimizations include JVM .agsthat may display \nsome rele\u00advant information, suchasLogCompilation added in Java 1.6. However, their usefulness needs to \nbe checked, and they require Unlock Diagnostics option that may itself have an observer effect . References \n[1]K. Arhelger,F.Trinciante,andE. Machkasova.Useof pro.lers for studying java dynamic optimizations. \nProceedings of Midwest Instruction and Computing Symposium (MICS),2009. [2] K. O Hair. HPROF:Aheap/cpu \npro.ling toolin j2se 5.0. Sun Microsystems, java.sun.com, 2004. [3] Sun Developer Network. The Java HotSpot \nperformance engine architecture. Sun Microsystems, 2007.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>We show that the bytecode injection approach used in common Java profilers, such as HPROF and JProfiler, disables some program optimizations that are performed when the same program is running without a profiler. This behavior is present in both the client and the server mode of the HotSpot JVM.</p>", "authors": [{"name": "Elena Machkasova", "author_profile_id": "81339515330", "affiliation": "University of Minnesota, Morris, Morris, MN, USA", "person_id": "P1728564", "email_address": "", "orcid_id": ""}, {"name": "Kevin Arhelger", "author_profile_id": "81444608553", "affiliation": "University of Minnesota, Morris, Morris, MN, USA", "person_id": "P1728565", "email_address": "", "orcid_id": ""}, {"name": "Fernando Trinciante", "author_profile_id": "81444608648", "affiliation": "University of Minnesota, Morris, Morris, MN, USA", "person_id": "P1728566", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640000", "year": "2009", "article_id": "1640000", "conference": "OOPSLA", "title": "The observer effect of profiling on dynamic Java optimizations", "url": "http://dl.acm.org/citation.cfm?id=1640000"}