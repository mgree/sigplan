{"article_publication_date": "10-25-2009", "fulltext": "\n Reimagining Literate Programming James Dean Palmer Eddie Hillenbrand Northern Arizona University Northern \nArizona University James.Palmer@nau.edu eh88@nau.edu Abstract In this paper we describe Ginger, a new \nlanguage with .rst class support for literate programming. Literate pro\u00adgramming is a philosophy that \nargues computer programs should be written as literature with human readability and understanding of \nparamount importance. While the intent of literate programming is to make understanding computer programs \nsimpler, most literate programming systems are quite complex and consist of three different languages \ncorre\u00adsponding to 1) an implementation language, 2) a documenta\u00adtion language, and 3) a literate programming \nglue language. In Knuth s original implementation these were Pascal, TEX, and WEB respectively. Antithetical \nto the goals that literate programming espouses, this three language paradigm creates a truly challenging \nenvironment for new programmers. In this paper we reimagine literate programming as a core programming \nlanguage feature and describe a novel system for literate programming based on G-expression transforma\u00adtions. \nWe show that Ginger code can be used to naturally represent code, prose, and literate connections, which \nin turn uni.es, simpli.es and signi.cantly extends the literate programming experience. Categories and \nSubject Descriptors D.3.1 [Programming Languages]: Formal De.nitions and Theory Syntax; D.2.7 [Software \nEngineering]: Distribution, Maintenance, and Enhancement Documentation General Terms Design, Documentation, \nLanguages Keywords Ginger, Literate Programming, Program Com\u00adprehension Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 2009, October 25 29, 2009, Orlando, \nFlorida, USA. Copyright c &#38;#169; 2009 ACM 978-1-60558-768-4/09/10. . . $10.00 1. Introduction Literate \nprogramming is a programming paradigm that em\u00adphasizes human comprehension and readability by adopting \nthe mantra that programs should be read and written as lit\u00aderature. While literate programming systems \ndo support the development of documentation, literate programming is not a documentation system. Literate \nprogramming s intent is to support distinctly human cognitive abstractions for breaking up problems into \ntractable parts and communicating the relationships between these parts and their neighbors. In the same \nway that object oriented programming represents a paradigm or way of thinking and not a speci.c set of \nobject oriented languages, literate programming intends to transform the way we think about software \ndevelopment in terms of cognitively rooted abstractions. Literate programming systems describe these \ncognitive abstractions between implementation and description with a cognitive unit called a chunk. Chunks \nare not limited to the abstractions and forms of either the implementation or documentation language. \nCode and documentation chunks can be connected or nested to form a literate web that describes a program. \nMost literate programming systems act as heavy handed preprocessors that recognize very little about \nthe underlying documentation and implementation languages they act on. While workable and perhaps even \npragmatic, we believe current literate programming systems obscure and limit the true power of the paradigm \nby treating literate programming as simply a macro driven preprocess\u00ading step fundamentally divorced \nand different from both the documentation and implementation languages. In this paper we describe Ginger, \na language that is speci.cally designed to support literate programming. Un\u00adlike existing literate programming \nsystems, Ginger uses homoiconic G-expressions to represent code, prose, and literate connections. The \nresult is that code and documen\u00adtation are represented both internally and externally in ex\u00adactly the \nsame form. Thus, a uniform interface exists for implementation and documentation chunks to manipulate, \ntransform and inspect each other to such an extent that the boundary between implementation and cognitive \ndescription is blurred.  1.1 A Brief Overview of Literate Programming Literate programming was conceived \nby Donald Knuth in the early 1980s as an alternative to structured programming. In Knuth s original vision, \nliterate programs were essentially essays or exposition that describe software in ordinary prose while \ninterleaving traditional source code. Literate program\u00adming tools can be used to weave literate programs \ninto formatted human readable documentation with rich cross\u00adreferencing, indexing and bibliographies \nor tangle them into a format suitable for a compiler while preserving mean\u00adingful compiler warnings and \nerrors and debugging tool support. The literate programming glue language that Knuth developed is called \nWEB and has given rise to a number of other systems that have improved or simpli.ed various aspects of \nWEB. As Knuth worked with WEB, he realized early on that literate programming was changing how he wrote \nsoftware and enabling him to write software of much greater complexity, quality, and sophistication [2]. \nOver the years literate programming practitioners have identi.ed three distinguishing characteristics \nof literate programs: Psychological arrangement: Literate programs intend to communicate complex ideas \nand algorithms using plot, narrative, rhythm, and distinctly human story telling conventions instead \nof the restrictive and rigid structure of a programming language. Enhanced readability: Literate programs \npresent programs in a form that maximizes readability and understanding by providing cross-references, \nindicies, bibliographies and syntax markup. Versimilitude: Code and documentation are written to\u00ad gether \nin the same document such that both documen\u00ad tation and code are active and evolve together. At its core, \nliterate programming is a philosophy that forces a fundamental shift in thinking and problem solv\u00ading \nthat focuses on communication. Literate programming changes the perspective of the programmer -emphasiz\u00ading \nhuman communication over language dictated program structure. The paradigm forces programmers to consciously \nand continuously evaluate the presentation and readability of their code. This mentality fundamentally \nchanges the way programmers approach software development. When it becomes dif.cult to explain the logic \nof a particular piece of code, it is often easier to rewrite the code than explain why the code is dif.cult \nto understand [1]. Writing software that better communicates its message tends to make software simpler, \nmore .exible, and easier to maintain [20, 5, 16, 1]. 1.2 The Need for Literate Software A common attitude \namong software developers is that doc\u00adumentation is of little use [13]. At the same time, roughly 50% \nof the time spent on software maintenance is related to simply understanding the function of program \ncode and may contribute anywhere from 30-90% of the total cost of the software over its entire life [4, \n21]. The disconnect between an obvious need to improve communication and problem understanding and a \ndisdain for software documentation may stem from a genuine inadequacy in traditional software documentation. \nThe large investment and poor returns associated with traditional program documentation has, in part, \nfueled ag\u00adile methodology that deemphasizes artifacts that do not contribute to working code. Many believe \nthat with its deemphasis of formal written artifacts, agile methodology is incompatible with literate \nprogramming. In a position paper by Pieterse, Kourie and Boake a case is made that, to the contrary, \nliterate programming is fundamentally compatible with agile processes and goals [14]. They point out \nthe positive role literate programming has in supporting com\u00admunication between developers and other \nstake holders and the positive association between literate programming and high-quality low-defect software. \nOne of their principle ar\u00adguments is that literate programming documentation should simply not be considered \na separate artifact and instead should be considered an intrinsic part of the deliverable and programming \nprocess.  1.3 Related Work Knuth s seminal work on literate programming [8, 9] laid the foundation for \na host of different literate programming systems including WEB, CWEB, Noweb [15, 7], Nuweb [10], Funnelweb \n[22], and others. Many of these efforts have sought to make literate programming more portable (supporting \nmore target languages) and simpler to use. While the syntax used by literate programming systems may \ndiffer considerably they all de.ne a cognitive unit called a chunk. Chunks are not limited to the abstractions \nand forms of the underlying programming language and provide a mechanism for supporting conceptual abstractions. \nCode and documentation chunks can be connected or nested to form a literate web that describes a program. \nMany people often confuse embedded documentation systems, which include Perl s POD, Java s JavaDoc and \nPython s pydoc, with literate programming systems. These tools enable documenting interfaces at the actual \nfunction prototype de.nitions. The advantage to documenting in this way is that it becomes easier to \nkeep the documentation closely aligned to the actual interface. This kind of docu\u00admentation process has \nlittle to nothing in common with the literate programming process and embedded documentation tools generally \nlack necessary literate capabilities [3]. Somewhere between embedded documentation and true literate \nprogramming lives semi-literate programming. Semi-literate programming systems generally make sweep\u00ading \nsimpli.cations that compromise what most literate programmers would call a truly literate system in order \nto simplify the literate programming process. The most com\u00admon simpli.cation is to disable arbitrary \ncode reordering, thus .xing the direction of the narrative to the actual .ow of the program. Examples \nof semi-literate systems include Haskell [6] and PyLit [11].  A few literate programming systems have \ntaken a much different tack based on novel user interfaces. Edward Ream s literate editor, Leo, uses \nvisual outlines that allow users to attach metadata and descriptions to program descriptions and data \n[17]. Unfortunately, truly literate programs may break Leo s hierarchical outline based paradigm. Stritzinger \nand Sametinger have developed a hypertext .avored browser for navigating literate documentation speci.cally \nfor object oriented programming [19, 18]. In the same way that Leo has a bias toward heirarchical structures, \nStritzinger and Sametinger s work has a bias toward object oriented rela\u00adtionships.  2. Literate Ginger \nUnlike other literate programming systems which mix sev\u00aderal, often incompatible, syntaxes together, \nliterate Ginger programs are completely made up of G-expressions. A G-expression is made up of symbols, \nnumbers, strings, literals, S-expression based lists, indented blocks and other G-expressions. A detailed \ndescription of G-expressions is given in [12]. One of the keys to literate programming in Ginger is a \nfeature called colon-quoting, which begins a special kind of quote which ends at the end of the corre\u00adsponding \ncommand, line or block. Unescaped parenthesis in a colon-quoted string break out of the block and their \nresult is appended to the string. Consider this example, 1 define x 3.14 2 :println The value of x is \n(x). which is semantically identical to 1 define x 3.14 2 println \"The value of x is \" (x) \".\" and would \noutput: 1 The value of x is 3.14. Colon quotes don t require a function to act on. An alternate rendering \nof our last example using colon-quotes without a default function call would be: 1 define x 3.14 2 println \n(: The value of x is (x).) Another colon-quote form is the block colon-quote which acts on blocks of \ntext at the same indentation level: :println 2 This is a much longer colon-quote and 3 shows the value \nof x is (x), but the 4 value of y is (y). Simple literate statements like, 1 :title Koch Snowflakes \nin Ginger do not represent a special documentation language; they are simply calls to normal Ginger functions. \nWe feel this syntax is easily on par with LATEX in terms of simplicity, readability and ease of use. \n 2.1 A Simple Example In the remainder of this section we will describe how literate programs are constructed \nin Ginger. We shall motivate this discussion with a simple but complete example of literate programming \nin Ginger. Please note that this example has been designed for brevity while at the same time illustrating \nkey literate programming features. 1 :title Koch Snowflakes in Ginger 2 3 :section Introduction 4 5 :doc \n16 chunk 6 The following program demonstrates 7 literate programming in Ginger in much 8 the same spirit \nas the primes programs 9 that appears in (:cite knuth:literate). 10 This program will generate a Koch \n11 snowflake using turtle-style graphics. 12 We shall begin as Knuth did, by reducing 13 the entire program \nto its top-level 14 description. 15 * 17 :$ program to display a Koch snowflake 18 :section Implementation \nPlan 19 20 21 :doc 22 Sometimes the best beginning is the end. 23 What we would like to do in this program \n24 is generate a fractal snowflake with 25 \"sides\" of length 100 which we will store 26 in a file called \n27 (:code koch-snowflake.png). 28 29 chunk (: create a snowflake) 30 Koch-snowflake 100 31 save-canvas \n\"koch-snowflake.png\" 32 33 :doc 34 While (:code save-canvas) is implemented 35 by the graphics library, \nwe will need to 36 define functions that implement the 37 snowflake. These include the 38 (:code Koch-snowflake) \nfunction we have 39 already alluded to in the previous chunk 40 and the (:code Koch-curve) function on \n 41 which it is based. 95 (:code Koch-curve \\(/ x 3\\)) calls. 42 96 43 chunk (: program functions) chunk \n(: recursive case) 97 44 :$ Koch snowflake function Koch-curve (/ x 3) 98 45 :$ Koch curve function \n99 left-turn 60 46 100 Koch-curve (/ x 3) 47 :doc right-turn 120 101 48 The program structure is then \na simple 102 Koch-curve (/ x 3) 49 matter of providing the function left-turn 60 103 50 implementation \nand using that Koch-curve (/ x 3) 104 51 implementation to create the desired 105 52 106 output. :doc \n53 107 A Koch curve has infinite length since 54 chunk (: program to display a Koch snowflake) 108 each \nrecursive step generates four new 55 :$ program functions 109 segments one-third the length of the 56 \n:$ create a snowflake 110 original segment. The total length of 57 111 the curve becomes one-third longer \nwith 58 :doc 112 each recursive step (:cite koch:curve). 59 In the remaining sections we will delve Stated \nmore formally, the length of 113 60 into the process of creating fractal 114 the curve at step (:math \nn) is 61 curves and snowflakes. (:math \\(4/3\\)^n). A related measure, 115 62 116 the fractal dimension, \ndescribes how 63 :section Koch Curves and Bump Fractals 117 how the complexity of the fractal 64 118 \nincreases as it scales. The fractal 65 :doc 119 dimension of a Koch curve is 66 A Koch curve is a \"bump \nfractal.\" The 120 (:math log 4 / log 3) or approximately 67 general recipe for generating a bump 121 \n1.26. 68 fractal is to draw the fractal at one 122 69 level of recursion and then replace each 123 Though \nthe fractal has infinite 70 (:code forward) call with a recursive 124 length and is composed of an infinite \n71 call. The Koch curve is based on a 125 number or segments, the resolution of 72 single triangular \nbump illustrated here: our display is finite. It is convenient 126 73 127 to end the recursion at the \nsmallest 74 image \"bump.png\" width: 1.8 128 representable length -a pixel. Our base 75 129 case is then \nto simply draw a line of 76 :doc length (:code x), where (:code x < 1). 130 77 By thinking like a turtle \nwe can easily 131 78 come up with the corresponding drawing 132 chunk (: base case) 79 code which is \nrelative to the horizontal 133 forward x 80 measure or extent, (:code x). 134 81 135 :doc 82 :code 136 \nWe combine the base case and the 83 forward x 137 recursive cases to form our Koch-curve 84 left-turn \n60 function that generates a single Koch 138 85 forward x 139 curve whose horizontal measure is 86 140 \nright-turn 120 (:code x): 87 forward x 141 88 left-turn 60 142 chunk (: Koch curve function) 89 forward \nx 143 define Koch-curve (x) 90 144 if (< x 1) 91 :doc 145 :$ base case 92 We generate the recursive case \nby using else: 146 93 the bump fractal recipe and replacing the :$ recursive case 147 94 (:code forward \n\\(/ x 3\\)) calls with 148 149 :section Koch Snowflakes 150 151 :doc 152 The (:code Koch-snowflake) function \nis 153 trivially implemented by repeating three 154 Koch curves to form an equilateral 155 triangle. \n 156 157 chunk (: Koch snowflake function) 158 define Koch-snowflake (x) 159 repeat 3 160 Koch-curve \nx 161 right-turn 120 162 163 :section Results 164 165 :doc 166 After the program is executed, the 167 \nfollowing image is generated. 168 169 image \"koch-snowflake.png\" width: 1.25 170 171 :bibliography koch.bib \n 2.2 The Tangled Program The code from Section 2.1 can be compiled with the Ginger compiler to create \nan executable program or to create high quality documentation. The executable code extracted from this \nexample follows. 1 define Koch-curve (x) 2 if (< x 1) 3 forward x 4 else: 5 Koch-curve (/ x 3) 6 left-turn \n60 7 Koch-curve (/ x 3) 8 right-turn 120 9 Koch-curve (/ x 3) 10 left-turn 60 11 Koch-curve (/ x 3) 12 \n 13 define Koch-snowflake (x) 14 repeat 3 15 Koch-curve x 16 right-turn 120 17 18 Koch-snowflake 100 \n19 save-canvas \"koch-snowflake.png\" 2.3 The Literate Result While the executable code is far simpler, \nthe literate render\u00ading that follows is full of subtle detail and mental process completely missing in \nthe bare implementation.   Koch Snow.akes in Ginger 1. Introduction The following program demonstrates \nliterate programming in Ginger in much the same spirit as the primes program that appears in [1]. This \nprogram will generate a Koch snow.ake using turtle-style graphics. We shall begin as Knuth did by reducing \nthe entire program to its top-level description. (*1)= (program to display a Koch snow.ake 2) 2. Implementation \nPlan Sometimes the best beginning is the end. What we would like to do in this program is generate a \nfractal snow.ake with sides of length 100 which we will store in a .le called koch-snowflake.png. (create \na snow.ake 2)= Koch-snowflake 100 save-canvas \"koch-snowflake.png\" While save-canvas is implemented by \nthe graphics library, we will need to de.ne functions that implement the snow.ake. These include the \nKoch-snowflake function we have already alluded to in the previous chunk and the Koch-curve function \non which it is based. (program functions 3)= (Koch snow.ake function 7) (Koch curve function 8) The program \nstructure is then a simple matter of provid\u00ading the function implementation and using that implementa\u00adtion \nto create the desired output. (program to display a Koch snow.ake 2)= (program functions 3) (create a \nsnow.ake 2) In the remaining sections we will delve into the process of creating fractal curves and snow.akes. \n 3. Koch Curves and Bump Fractals A Koch curve is a bump fractal. The general recipe for generating \na bump fractal is to draw the fractal at one level of recursion and then replace each forward call with \na recursive call. The Koch curve is based on a single triangular bump illustrated here:  x x/3 x/3 \nx/3 By thinking like a turtle we can easily come up with the corresponding drawing code which is relative \nto the horizontal measure or extent, x. forward (/ x 3) left-turn 60 forward (/ x 3) right-turn 120 forward \n(/ x 3) left-turn 60 forward (/ x 3) We generate the recursive case by using the bump frac\u00adtal recipe \nand replacing the forward (/ x 3) calls with Koch-curve (/ x 3) calls. (recursive case 5)= Koch-curve \n(/ x 3) left-turn 60 Koch-curve (/ x 3) right-turn 120 Koch-curve (/ x 3) left-turn 60 Koch-curve (/ \nx 3) A Koch curve has in.nite length since each recursive step generates four new segments one-third \nthe length of the original segment. The total length of the curve becomes one-third longer with each \nrecursive step [2]. Stated more formally, the length of the curve at step n is (4/3)n . A related measure, \nthe fractal dimension, describes how how the complexity of the fractal increases as it scales. The fractal \ndimension of a Koch curve is log 4/ log 3 or approximately 1.26. Though the fractal has in.nite length \nand is composed of an in.nite number or segments, the resolution of our display is .nite. It is convenient \nto end the recursion at the smallest representable length -a pixel. Our base case is then to simply draw \na line of length x,where x<1. (base case 6)= forward x We combine the base case and the recursive cases \nto form our Koch-curve function that generates a single Koch curve whose horizontal measure is x: (Koch \ncurve function 7)= define Koch-curve (x) if (< x 1) (base case 5) else: (recursive case 6)  4. Koch \nSnow.ake The Koch-snowflake function is trivially implemented by repeating three Koch curves to form \nan equilateral triangle. (Koch snow.ake function 8)= define Koch-snowflake (x) repeat 3 Koch-curve x \nright-turn 120  5. Results After the program is executed, the following image is gener\u00adated.   References \n[1] Donald E. Knuth. Literate programming. The Computer Journal, 27(2):97 111, 1984. [2] H. von Koch, \nSur une courbe continue sans tangente, obtenue par une construction g\u00b4eom\u00b4etrique \u00b4ementaire, el\u00b4Arkiv \nf\u00a8or Matematik, vol. 1, pp. 681-704, 1904.  2.4 Code Chunks The base unit for most literate programming \nsystems is the chunk. In Ginger, a code chunk is a labeled piece of code that may include ordinary Ginger \ncode or references to other chunks. The chunk function is used to implement code chunks and takes two \narguments: the chunk name (a string) and the code itself (a G-expression that may include chunk references). \nChunk references are formed with the $ function, which takes the chunk s name as its single argument. \nSection 2.1 contains several different examples of code chunks and chunk references. Lines 16-17 illustrate \na code chunk that simply references another code chunk. In this case the * denotes a special code chunk \nthat serves as the root of the program. The chunk on lines 142-147 mixes reference to other chunks with \nordinary Ginger code. 2.5 Documentation Chunks Documentation chunks need not be explicitly de.ned like \ncode chunks. They are simply the blocks of codes that surround code chunks and develop the documentation. \nOne of the most common documentation chunks is de.ned with the doc function, which takes a single G-expression \nargu\u00adment. Other functions like title and section also produce documentation chunks. Super.cially, many \nof the documentation commands look and act like TEXor LATEX commands but often the syntax is slightly \ndifferent and Ginger s document model has been deeply in.uenced by docbook and HTML. Documentation Figure \n1. Source documents are transformed into docu\u00admentation or code by manipulating how G-expressions are \nevaluated. 2.6 Untangling programs and documentation The code and documentation chunks described in \nthe pre\u00advious two sections connect to each other forming a web of connections and content that ultimately \nde.nes both the program and the description of the program. As with other literate programming systems, \nGinger must weave and tangle this literate web to extract the usable program and documentation. While \nthe process illustrated in Figure 1 is similar to other literate systems its implementation is quite \ndifferent. All of the subprocesses in the middle box happen within the Ginger compiler; each transition \nsave the last to either documentation or executable works on in-memory G-expressions. G-expressions are \nmanipulated such that their evaluation forms one or more programs or documentation. End users need only \nknow that the Ginger compiler can target executables or documentation and each can be generated with \na single invocation of the ginger compiler command.  3. Implementation Details Ginger s simplifying \nassumptions that unify a single syntax used for code, documentation and literate glue also simplify the \nactual implementation. Since G-expressions implement every aspect of the literate program, we can simply \nmanip\u00adulate these hierarchical data structures to generate a set of G-expressions that generate code \nor a set of G-expressions that generate documentation. Ginger s read function plays triple duty; parsing \nliterate documentation, code and chunks in a single step. Evaluating the resulting tree directly yields \nto the literate result. To extract the actual program we add each chunk de.nition to a dictionary keyed \nwith the chunk s name. We then begin substituting chunk references in top level nodes with their respective \nde.nitions. We continue this substitution process until no more substitutions can be made. The resulting \ntree can then either be evaluated or compiled. While our current work focuses on Ginger as the base programming \nlanguage, the base language can be any G\u00adexpression based language. In other work we have exper\u00adimented \nwith the development of non-functional and non\u00adhomoiconic languages based on G-expressions. The literate \nprogramming system described here could be used almost transparently with such languages.  4. Challenges \nand Future Work In this paper we have describe the literate programming system used in the Ginger language. \nWhile literate pro\u00adgramming in Ginger shares many commonalities with other literate programming systems \nit uni.es the literate pro\u00adgramming experience with a single language, which is based on a powerful homoiconic \nG-expressions syntax. Literate programs written in Ginger use a single parser that constructs a G-expression \nbased tree that can be trivially transformed such that evaluation generates either human readable documentation \nor computer executable code. While this has the effect of simplifying the programming ex\u00adperience for \nusers it also makes powerful inspection and manipulation of both documentation and code possible.  Both \nthe Ginger language and information about this evolving work are available at http://ging3r.org.  References \n[1] K. Beck. A theory of programming. Dr. Dobb s Journal,Nov. 2007. [2] A. Binstock. Interview with Donald \nKnuth. InformIT,Apr. 2008. [3] M.-J. Dominus. POD is not literate programming. http://www.perl.com/pub/a/tchrist/litprog.html, \nMar. 2000. [4] R. Fjeldstad and W. Hamlen. Application program mainte\u00adnance study: Report to our respondents. \nTutorial on Software Maintenance, 1982. [5] P. Grubb and A. A. Takang. Software Maintenance: Concepts \nand Practice. World Scienti.c Publishing Company, Sept. 2003. [6] P. Hudak, J. Hughes, S. P. Jones, and \nP. Wadler. A history of Haskell: being lazy with class. In Proceedings of the third ACM SIGPLAN conference \non the history of programming languages. ACM, 2007. [7] A. L. Johnson and B. C. Johnson. Literate programming \nusing noweb. The Linux Journal, Oct. 1997. [8] D. E. Knuth. Literate programming. The Computer Journal, \n27(2):97 111, 1984. [9] D. E. Knuth. Literate programming. Center for the Study of Language and Information, \nStanford, CA, USA, 1992. [10] M. W. Mengel and P. Briggs. Nuweb home page. http: //nuweb.sourceforge.net/. \n[11] G. Milde. PyLit home page. http://pylit.berlios.de/. [12] J. D. Palmer. Ginger: Implementing a new \nlisp family syntax. In Proceedings of the 47th Annual Southeast Regional Conference. ACM, Mar. 2009. \n[13] D. L. Parnas and P. C. Clements. A rational design process: How and why to fake it. IEEE Transactions \non Software Engineering, 12(2):251 257, 1986. [14] V. Pieterse, D. G. Kourie, and A. Boake. Literate \nprogramming to enhance agile methods. In J. Eckstein and H. Baumeister, editors, XP, volume 3092 of Lecture \nNotes in Computer Science, pages 250 253. Springer, 2004. [15] N. Ramsey. Literate programming simpli.ed. \nIEEE Software, 11(5):97 105, 1994. [16] J. Raskin. Comments are more important than code. ACM Queue, \n3(2):64 ff, 2005. [17] E. Ream. Leo home page. http://webpages.charter. net/edreamleo/front.html. [18] \nJ. Sametinger. Object-oriented documentation. ACM SIG-DOC Asterisk Journal of Computer Documentation, \n18(1):3 14, 1994. [19] J. Sametinger and A. Stritzinger. A documentation scheme for object-oriented software \nsystems. ACM SIGPLAN OOPS Messenger, 4(3):6 17, 1993. [20] D. D. Smith. Designing Maintainable Software. \nSpringer, May 1999. [21] T. A. Standish. An essay on software reuse. IEEE Trans\u00adactions on Software Engineering, \n10(5):494 497, September 1984. Special Issue on Software Reusability. [22] R. Williams. FunnelWeb home \npage. http://www.ross. net/funnelweb/.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>In this paper we describe Ginger, a new language with first class support for literate programming. Literate programming is a philosophy that argues computer programs should be written as literature with human readability and understanding of paramount importance. While the intent of literate programming is to make understanding computer programs simpler, most literate programming systems are quite complex and consist of three different languages corresponding to 1) an implementation language, 2) a documentation language, and 3) a literate programming glue language. In Knuth's original implementation these were Pascal, TeX, and WEB respectively. Antithetical to the goals that literate programming espouses, this three language paradigm creates a truly challenging environment for new programmers. In this paper we reimagine literate programming as a core programming language feature and describe a novel system for literate programming based on G-expression transformations. We show that Ginger code can be used to naturally represent code, prose, and literate connections, which in turn unifies, simplifies and significantly extends the literate programming experience.</p>", "authors": [{"name": "James Dean Palmer", "author_profile_id": "81100162495", "affiliation": "Northern Arizona University, Flagstaff, AZ, USA", "person_id": "P1728374", "email_address": "", "orcid_id": ""}, {"name": "Eddie Hillenbrand", "author_profile_id": "81444606641", "affiliation": "Northern Arizona University, Flagstaff, AZ, USA", "person_id": "P1728375", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640072", "year": "2009", "article_id": "1640072", "conference": "OOPSLA", "title": "Reimagining literate programming", "url": "http://dl.acm.org/citation.cfm?id=1640072"}