{"article_publication_date": "10-25-2009", "fulltext": "\n From Platform-Independent to Platform- Speci.c Models using Democles Christian Glodt Pierre Kelsen \nNuno Am\u00e1lio University of Luxembourg University of Luxembourg University of Luxembourg ...................... \n.................... .................. Qin Ma University of Luxembourg ............. Abstract Democles \nis an executable modeling tool. It is based on a for\u00admally de.ned language named EP that allows both \nthe structure and behavior of a system to be represented. Earlier versions of the tool allowed platform-independent \nmodels to be described using EP-models, which have the same level of granularity as classes. The present \ndemonstration will focus on two new features of De\u00admocles: a high-level grouping of EP-models into domains \nwhich more faithfully represent the different subject matters that make up a complex software system, \nand a mechanism for mapping the platform-independent model to a concrete platform, namely Java, using \nplatform bindings. Categories and Subject Descriptors D.1.5 [Programming Tech\u00adniques]: Object-oriented \nProgramming; D.1.7 [Programming Tech\u00adniques]: Visual Programming; D.2.6 [Programming Environ\u00adments]: \nGraphical Environments; D.2.6 [Programming Environ\u00adments]: Integrated Environments General Terms Design, \nLanguages Keywords executable models, platform-independent model, platform\u00adspeci.c model, domains, visual \nprogramming, code generation 1. Introduction The Democles tool is a research tool whose main purpose \nis to advance the state of the art in executable modeling.It targets a model-centric approach to software \ndevelopment. At its core is a declarative executable modeling language named EP that allows both structure \nand behavior of a system to be speci.ed. The high-level modules of a software system modeled with De\u00admocles \nare domains and bridges. Domains represent distinct, self\u00adcontained subject matters while bridges provide \nmechanisms for propagating behavior across domains. Democles provides an exe\u00adcutable modeling environment. \nWhile several other tools exist for Copyright is held by the author/owner(s). OOPSLA 2009, October 25 \n29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10. executable modeling (e.g., executable \nUML [7]), our tool distin\u00adguishes itself from these other tools by having a formally de.ned modeling \nlanguage [3, 5] and providing a declarative description of behavior. 2. The Underlying Framework In this \nsection we give a brief overview of the theoretical frame\u00adwork in [2, 4] that underlies the Democles \ntool. At the heart of the framework is the EP-language that expresses both the structure and behavior \nof a system. The key concepts are events and properties. These are grouped in EP-models (similar to UML \nclasses). A prop\u00aderty expresses a structural feature of an EP-model while an event represents a behavorial \nfeature. Events can impact properties and thereby modify the state of a system. Event propagation is \nrepre\u00adsented by edges connecting events. EP-models constituted of events and properties can be used to \ndescribe a platform-independent model of a system. This was demonstrated by an earlier version of the \nDemocles tool [1]. In the present version of Democles two more important features have been included: \na higher-level structuring concept based on domains and bridges was introduced, and a mechanism for mapping \nto a concrete platform has been provided with platform bindings. In the remainder of this section we \ndescribe domains and bridges in more detail. Platform bindings will be discussed in the next two sections. \nComplex software applications deal with many different subject matters. As an example consider a Web \nApplication for electronic banking. Such an application has a business domain dealing with the business \nobjects relevant for a banking application, a graphical user interface domain representing concepts related \nto the graphi\u00adcal user interfaces of web applications, a security domain that ex\u00adpresses the security \npolicies, to name just a few. To express these different subject matters we introduce the no\u00adtion of \ndomain as a .rst-class concept: a domain is a self-contained subject matter. It is expressed as a collection \nof EP-models that constitute the domain and that do not have references external to this domain. Domains \nare not suf.cient to express a working sys\u00adtem since the domains have to interact to realize a software \nsystem. As an example consider the GUI and Banking domains of the afore\u00admentioned banking system: events \nin the GUI domain (triggered by the user) may affect the accounts managed in the Banking domain (e.g., \nby adding a new account). This implies that we have to be able to propagate behavior from one domain \ninto another domain. Bridges constitute the main mechanism for effecting this prop\u00adagation. A bridge \nis de.ned over a number of domains. In con\u00adtrast to domains, bridges have external links into the domains \nover which they are de.ned. Through these external links events can be propagated from one domain to \nanother domain. Bridges are also responsible for converting data types from one domain to another domain. \n We can view the bridge and its underlying domains as a new domain since the union of these structures \ndoes not have external links. We can thus view a system model as a hierarchy of domains, with a single \ntop-level domain representing the application. 3. Tool Functionalities 3.1 Modeling Domain Hierarchies \nDemocles provides a fully featured environment for modeling us\u00ading Domain Hierarchies and the EP language. \nIn addition to the graphical modeling tools, it offers, among other features, immedi\u00adate syntax checking, \nmodel refactorings and model debugging[6]. The modeling process is supported by a number of views: (1) \nDomain View: displays the structure of a domain hierarchy as a collection of domains and bridges; (2) \nEvent Tree View: displays a graphical representation of the event propagation across domains and bridges; \n(3) Code View: allows quick viewing and editing of code snippets associated with certain model elements;(4) \nEvent Navigator View: lists events within a system and allows quick access to the containing models. \nIn order to simplify the evolution of models in a system a num\u00adber of refactorings are available. These \nallow to rename bridges, domains, models, events and properties, resulting in changes to all entities \nthat refer to them by name, thus maintaining the integrity of the system.  3.2 Platform Bindings An \nimportant feature of Democles is that it generates compilable and executable Java code from the domains \nand bridges in a sys\u00adtem. Recently, platform bindings for domains have been added, allowing them to be \nrealized and to interact and integrate with the underlying platform. Several such bindings can be present \nfor each domain. Thus, a generic domain, eg. a GUI domain containing models of graph\u00adical user interface \nelements, can have realizations using different GUI libraries (for example Swing and SWT). Only one binding \nper domain can however be marked as active at runtime. By not acti\u00advating any binding, a system can still \nbe executed as a platform\u00adindependent model, and interacted with using Democles debug\u00adging component. \nIn addition to its previously-described modeling functionalities [6], Democles now provides support for \ncreating, exporting, im\u00adporting and managing these platform bindings. 4. Tool Architecture The Democles \ntool is an Eclipse plugin that makes use of the graph\u00adical editing framework GEF and the OCL component \nof Eclipse s model development tools project. It was developed using current best practices such as revision \ncontrol, issue tracking, unit testing and continous integration. Democles implements platform bindings \nfor domains using adapter classes. These adapter classes effectively map EP seman\u00adtics to platform semantics. \nIn general they instantiate a platform speci.c counterpart for a model instance, and forward events and \nproperty changes both ways, from platform to EP runtime and vice\u00adversa. These adapters are instantiated \nat runtime by a factory, using a naming convention to locate the adapter class for a model instance. \nSwitching between different platform binding implementations for a domain is currently implemented by \nadjusting the Classpath such that the desired implementation is found. When needed, more elab\u00adorate adapter \nlookup schemes can easily be implemented. For the EP runtime to be able to use the adapters, they must \nimplement the IBinding interface which speci.es methods that the runtime will call on certain EP-level \noccurrences, namely changes of property values and event invocations. The adapters must also provide \na constructor taking an IInstance object, representing the EP model instance that they bind to the platform, \nas parameter. This protocol for implementing adapters leaves freedom to the binding developer to cope \nwith different platform idioms. For ex\u00adample, Components in Swing are added to their parents by calling \nthe parent s add(. . . ) method, while Widgets in SWT take their par\u00adent as a constructor parameter. \n5. What the audience will see In order to introduce the audience to Democles, we will .rst give a quick \noverview of the structure and semantics of the EP language. Using an example application we will show \nhow Domains are used in Democles to model self-contained subject matters, and how Bridges are used to \ncombine Domains into functional applications. This part of the demonstration will make use of Democles \ndomain view, as well as other features that simplify the modeling process. To illustrate the runtime \nbehaviour of EP systems, we will run the example application under Democles debugger, without using any \nplatform bindings. The application s object graph will be clearly inspectable, and while the application \nwill not be able to perform input or output operations, the debugger will allow interacting with it in \norder to simulate user interaction. Next we will demonstrate the platform bindings of the GUI domain. \nThe application will be run with the Swing and the SWT implementation of the bindings, resulting in the \ncorresponding user experiences. We will show the structure of platform bindings, and the idioms employed \nin the development of these bindings, by elaborating on the implementation of a binding of a common GUI \nwidget. References [1] Democles Website. ............................. [2] Pierre Kelsen and Qin Ma. \nDomain Hierarchies: a Basic Theoretical Framework for Integrating Software Domains, Extended Abstract, \nTASE 2009, July 29 -31, 2009, Tianjin, China. [3] P. Kelsen and Q. Ma. A formal de.nition of the EP language. \nTechnical Report, University of Luxembourg, 2008. ................ ............................................. \n[4] P. Kelsen and Q. Ma. A language for domain hierarchies with applications to the domain integration \nproblem. TR-LASSY-08-05, University of Luxembourg, 2008. .......................... ................................... \n[5] P. Kelsen and Q. Ma. A lightweight approach for de.ning the formal semantics of a modeling language. \nMODELS 2008, LNCS 5301, pages 690 704, 2008. [6] C. Glodt, P. Kelsen, E. Pulvermueller: DEMOCLES: a tool \nfor executable modeling of platform-independent systems. OOPSLA Companion 2007: 870-871. [7] C. Raistrick, \nP. Francis, and J. Wright. Model Driven Architecture with Executable UML(TM). Cambridge University Press, \n2004.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Democles is an executable modeling tool. It is based on a formally defined language named EP that allows both the structure and behavior of a system to be represented. Earlier versions of the tool allowed platform-independent models to be described using EP-models, which have the same level of granularity as classes. The present demonstration will focus on two new features of Democles: a high-level grouping of EP-models into domains which more faithfully represent the different subject matters that make up a complex software system, and a mechanism for mapping the platform-independent model to a concrete platform, namely Java, using platform bindings.</p>", "authors": [{"name": "Christian Glodt", "author_profile_id": "81319492459", "affiliation": "University of Luxembourg, Luxembourg, Luxembourg", "person_id": "P1728628", "email_address": "", "orcid_id": ""}, {"name": "Pierre Kelsen", "author_profile_id": "81100410448", "affiliation": "University of Luxembourg, Luxembourg, Luxembourg", "person_id": "P1728629", "email_address": "", "orcid_id": ""}, {"name": "Nuno Am&#225;lio", "author_profile_id": "81338487691", "affiliation": "University of Luxembourg, Luxembourg, Luxembourg", "person_id": "P1728630", "email_address": "", "orcid_id": ""}, {"name": "Qin Ma", "author_profile_id": "81323493451", "affiliation": "University of Luxembourg, Luxembourg, Luxembourg", "person_id": "P1728631", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640019", "year": "2009", "article_id": "1640019", "conference": "OOPSLA", "title": "From platform-independent to platform-specific models using democles", "url": "http://dl.acm.org/citation.cfm?id=1640019"}