{"article_publication_date": "10-25-2009", "fulltext": "\n Dynamically Inferring, Re.ning, and Checking API Usage Protocols Michael Pradel Laboratory for Software \nTechnology ETH Zurich, Switzerland Abstract Using a set of API methods often requires compliance with \na pro\u00adtocol, whose violation can lead to errors in the program. However, most APIs lack explicit and \nformal de.nitions of these protocols. We propose a dynamic program analysis for automatically infer\u00adring \nand re.ning speci.cations of correct method call sequences. Our experiments with several Java programs \nshow that we can infer meaningful protocols, such as widely respected programming rules. Furthermore, \nour analysis .nds violations of the inferred speci.ca\u00adtions that point out potential bugs to the programmer. \nCategories and Subject Descriptors D.2.5 [Software Engineer\u00ading]: Testing and Debugging General Terms \nLanguages, Reliability, Veri.cation Keywords Speci.cation mining, Runtime veri.cation 1. Introduction \nFormal speci.cations of correct method call sequences on appli\u00adcation programming interfaces (APIs) are \nuseful for .nding bugs, verifying the correctness of a program and also serve as documen\u00adtation. Since \nno such API usage protocols exist for many existing libraries and frameworks, speci.cation mining techniques, \nwhich infer legal method call sequences from runtime data of a program, have been proposed [Ammons et \nal. 2002, Yang et al. 2006, Gabel and Su 2008]. Unfortunately, inferred speci.cations are often er\u00adroneous \nand incomplete. This can happen because method calls that are relevant for one speci.cation are interleaved \nwith irrelevant calls, or because the analyzed program execution does not fully uti\u00adlize the API. Another \nlimitation of many existing techniques is to focus on method calls on single classes or objects. As a \nresult, they miss more complex API usages that encompass multiple related objects. Our approach addresses \nthese problems by (i) iteratively re.n\u00ading speci.cations based on several executions of programs using \na particular API and (ii) considering protocols involving multiple related objects. Copyright is held \nby the author/owner(s). OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10. \n 2. Approach We propose a dynamic analysis that infers, re.nes, and checks API usage protocols in two \nphases: The inference phase derives .nite state machines (FSMs) that describe legal method call sequences, \nsuch as Figure 1. In the checking and re.nement phase the analysis detects con.rmations and violations \nof the inferred protocols; it uses them to re.ne the speci.cations and to report potential bugs. File(String) \nFileWriter(File) FileWriter. FileWriter. close() write(String) FileWriter. write(String) Figure 1. \nAn inferred object usage protocol. 2.1 Inferring speci.cations The .rst phase of the analysis infers \nprotocols from method traces [Pradel and Gross 2009], which we obtain by instrument\u00ading and running an \napplication that uses the API. The inserted instructions report for each method call and return the signature \nof the invoked method, as well as the object identity and type of caller, callee, arguments, and return \nvalue of the call. Instead of an\u00adalyzing these data as a whole, we transform it into small episodes of \nrelated calls that can be analyzed separately. Roughly, each such an episode consists of the methods \ncalled during the execution of a single method. To eliminate method calls that are not relevant for a \nparticular speci.cation, we further .lter the call sequences: First, we observe that related method calls \nare linked by a data.ow relation. For instance, m1() and m2() are linked if m2() is invoked on the return \nvalue of m1(). Second, related calls often belong to classes in the same package. Based on these two \nobservations, we extract call sequences in which all calls are data.ow-related and belong to the same \npackage. Similar call sequences lead us to FSMs that describe typical usage protocols. Two call sequences \nare considered to be similar if the same sets of methods are called on the involved objects. The order \nof calls can be different, though. To construct FSMs, we map each method to a state and create a transition \nwhenever two calls are observed consecutively. Each transition is labeled with the method signature of \nthe state that it points to (see Figure 1).  2.2 Checking and re.ning speci.cations Inferred speci.cations \ncan be used to verify at runtime whether an application conforms to the detected rules. We perform such \nruntime monitoring using similar episodes of related calls as in the inference phase (Section 2.1). If \na call sequence matches parts of a protocol, we analyze whether the calls conform to the speci.cation \nand report a con.rmation or a violation. For example, a method that creates a FileWriter and writes to \nit triggers the protocol in Figure 1. If the programmer forgot to call close() at the end, though, a \nviolation is reported. Dynamic speci.cation inference can derive only API usage pro\u00adtocols that actually \noccur in the analyzed execution of a program. Hence, legal method calls may be missing. In Figure 1, \nfor instance, calls to FileWriter..ush() should be permitted before closing the writer. However, a program \nexecution calling .ush() would trig\u00adger a violation of the protocol in Figure 1. Another source of false \npositives are transitions resulting from incidental method calls that are not necessarily part of the \nspeci.cation. For example, a call to File.canWrite() may precede creating the FileWriter but is not re\u00adquired. \nOur approach to correct incomplete and erroneous speci.ca\u00adtions is to exploit the results from runtime \nmonitoring to iteratively re.ne the inferred speci.cations. Each new program execution pro\u00adduces a list \nof con.rmations and violations. A speci.cation with many con.rmations and several violations resulting \nfrom a miss\u00ading transition in a particular state is likely to be correct, but must be extended with the \nmissing transition. In contrast, a speci.cation with various violations is likely to be the result of \nan incidental call sequence in the initially analyzed program execution and therefore should be discarded. \nIn addition to re.ning protocols, we also re\u00admove erroneous ones by simply pruning all speci.cations \nwhose con.rmation/violation ratio is below a certain threshold. 3. Experiments We implemented our approach \nand evaluated it with real-world Java applications. The following reports on a case study on infer\u00adring \nusage protocols for objects from the Java standard library. We analyzed method traces from six applications: \nEclipse, PMD, and ANTLR (all as part of the DaCapo benchmark suite [Blackburn et al. 12 3 2006]); jEdit, \nJabRef, and XMLUnit. Overall, we analyzed around three million runtime events. The method traces from \nfour of the six programs were given as input to the inference phase. Focusing on API calls to the Java \nstandard library, 131 speci.cations were generated. Using these protocols, we checked traces from three \napplications and pruned all protocols with more violations than con.rmations. 44 speci.\u00adcations remain, \nout of which 22 come from two or more distinct call sites in the source code. The results suggest that \nour inference technique, combined with a simple pruning, produces a signi.cant amount of typical usage \nprotocols, rather than incidental call se\u00adquences. A larger case study is reported on in [Pradel and \nGross 2009]. To illustrate the effect of our re.nement technique, consider a protocol of StringBuffer, \ninferred from ANTLR. Initially, it per\u00admits to append Strings and ints to the buffer, followed by a call \nof toString(). Only 52 % of the checked StringBuffer uses follow this protocol. In a .rst re.nement step, \nwe also permit appending other objects (char, etc.) and calling toString() right after creating the buffer. \nThis increases the con.rmation rate to 70 %. In a second step, we also permit calls to StringBuffer.length(), \nraising the con\u00ad 1 http://jedit.org 2 http://jabref.sf.net 3 http://xmlunit.sf.net .rmation rate to 74 \n%. All the re.nement steps were inferred from violations of the protocol. Violations of protocols are, \nbesides being useful to re.ne spec\u00adi.cations, indicators of potential bugs. For instance, we detected \na bug using the protocol in Figure 1. A method in the XMLUnit project initializes a FileWriter without \nclosing it at the end of the method or passing it to another method for doing so. The proto\u00adcol in Figure \n1 was initially found in an execution of JabRef. The example illustrates that our approach is able to \nautomatically infer common programming practices ( close all writers that you open ) and detect violations \nof them. 4. Related Work Ernst et al. present techniques for dynamically discovering pro\u00adgram invariants \n[Ernst 2000]. Ammons et al. mine API usage pro\u00adtocols from method traces with a probabilistic FSM learner \n[Am\u00admons et al. 2002]. Gabel et al. enhances the performance of such an approach by focusing on prede.ned \nmicro-patterns [Gabel and Su 2008]. Alternatively, correct method call sequences can also be inferred \nstatically [Whaley et al. 2002]. As an application of our re\u00adsults, we are currently investigating how \nto check the protocols that our analysis generates with existing static and dynamic veri.cation techniques, \nsuch as type state checking [Bierhoff and Aldrich 2007] and runtime monitoring frameworks [Chen and Rosu \n2007]. 5. Concluding Remarks This work contributes by considering protocols of multiple related objects \nand re.ning its results iteratively. It is therefore a further step to make API usage protocols accessible \nwithout the need to write them manually. Acknowledgments Special thanks to my PhD advisor Thomas R. Gross. \nReferences Glenn Ammons, Rastislav Bod\u00b4ik, and James R. Larus. Mining speci.ca\u00adtions. In POPL, 2002. \nKevin Bierhoff and Jonathan Aldrich. Modular typestate checking of aliased objects. In OOPSLA, 2007. \nStephen M. Blackburn et al. The DaCapo benchmarks: Java benchmarking development and analysis. In OOPSLA, \n2006. Feng Chen and Grigore Rosu. MOP: An ef.cient and generic runtime veri.cation framework. In OOPSLA, \n2007. Michael Dean Ernst. Dynamically discovering likely program invariants. PhD thesis, University of \nWashington, 2000. Mark Gabel and Zhendong Su. Javert: Fully automatic mining of general temporal properties \nfrom dynamic traces. In FSE, 2008. Michael Pradel and Thomas R. Gross. Automatic generation of object \nusage speci.cations from large method traces. In ASE, 2009. John Whaley, Michael C. Martin, and Monica \nS. Lam. Automatic extraction of object-oriented component interfaces. In ISSTA, 2002. Jinlin Yang, David \nEvans, Deepali Bhardwaj, Thirumalesh Bhat, and Manu\u00ad vir Das. Perracotta: Mining temporal API rules from \nimperfect traces. In ICSE, 2006.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Using a set of API methods often requires compliance with a protocol, whose violation can lead to errors in the program. However, most APIs lack explicit and formal definitions of these protocols. We propose a dynamic program analysis for automatically inferring and refining specifications of correct method call sequences. Our experiments with several Java programs show that we can infer meaningful protocols, such as widely respected programming rules. Furthermore, our analysis finds violations of the inferred specifications that point out potential bugs to the programmer.</p>", "authors": [{"name": "Michael Pradel", "author_profile_id": "81444603091", "affiliation": "Swiss Federal Institute of Technology (ETH), Zurich, Switzerland", "person_id": "P1728581", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640008", "year": "2009", "article_id": "1640008", "conference": "OOPSLA", "title": "Dynamically inferring, refining, and checking API usage protocols", "url": "http://dl.acm.org/citation.cfm?id=1640008"}