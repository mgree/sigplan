{"article_publication_date": "10-25-2009", "fulltext": "\n Static Extraction and Conformance Analysis of Hierarchical Runtime Architectural Structure using Annotations \n Marwan Abi-Antoun Jonathan Aldrich School of Computer Science, Carnegie Mellon University {marwan.abi-antoun, \njonathan.aldrich}@cs.cmu.edu Abstract An object diagram makes explicit the object structures that are \nonly implicit in a class diagram. An object diagram may be missing and must extracted from the code. \nAlternatively, an existing diagram may be inconsistent with the code, and must be analyzed for conformance \nwith the implementation. One can generalize the global object diagram of a system into a runtime architecture \nwhich abstracts objects into com\u00adponents, represents how those components interact, and can decompose \na component into a nested sub-architecture. A static object diagram represents all objects and inter\u00adobject \nrelations possibly created, and is recovered by static analysis of a program. Existing analyses extract \nstatic object diagrams that are non-hierarchical, do not scale, and do not provide meaningful architectural \nabstraction. Indeed, archi\u00adtectural hierarchy is not readily observable in arbitrary code. Previous approaches \nused breaking language extensions to specify hierarchy and instances in code, or used dynamic analyses \nto extract dynamic object diagrams that show ob\u00adjects and relations for a few program runs. Typecheckable \nownership domain annotations use exist\u00ading language support for annotations and specify in code object \nencapsulation, logical containment and architectural tiers. These annotations enable a points-to static \nanalysis to extract a sound global object graph that provides architec\u00adtural abstraction by ownership \nhierarchy and by types, where architecturally signi.cant objects appear near the top of the hierarchy \nand data structures are further down. Another analysis can abstract an object graph into a built runtime \narchitecture. Then, a third analysis can compare the built architecture to a target, analyze and measure \ntheir structural conformance, establish traceability between the two and identify interesting differences. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n2009 October 25 29, 2009, Orlando, Florida, USA Copyright &#38;#169; 2009 ACM 978-1-60558-734-9/09/10. \n. . $10.00 Categories and Subject Descriptors D.3.3 [Programming Languages]: Classes and Objects General \nTerms Experimentation, Languages, Theory 1. Introduction During software evolution, the most reliable \nand accurate de\u00adscription of a software system is its source code. In addition, high-level architectural \ndiagrams of the system s organiza\u00adtion can be useful. For instance, a diagram can help locate the components \nthat must be modi.ed, or indicate the mag\u00adnitude of the impact of a change based on the dependencies \namong entities. Often, such a diagram is missing, hence the need to extract one from the code. Alternatively, \nthe diagram may exist but may be inconsistent with the code, hence the need to analyze its conformance \nwith the implementation. Reverse engineering or architectural extraction can ex\u00adtract various complementary \nhigh-level views. For example, a class diagram is an important and widely used description of an object-oriented \nsystem that shows the static code ar\u00adchitecture in terms of classes and inheritance relationships. Today, \nmany tools can recover class diagrams from code. Another important view is an object diagram or object \ngraph, where nodes represent objects, i.e., instances of the classes in a class diagram, and edges correspond \nto relations between objects. An object diagram makes explicit the struc\u00adture of the objects instantiated \nby the program and their rela\u00adtions, facts that are only implicit in a class diagram. While in the class \ndiagram a single node represents a class and sum\u00admarizes the properties of all of its instances, an object \ndi\u00adagram represents different instances as distinct nodes, with their own properties [36]. For example, \nGamma et al. used a class diagram and an object diagram to explain each standard design pattern [14]. \nRecent empirical evidence con.rms the importance of how objects connect to each other at runtime when \nI want to understand code that is unknown: an object diagram is more interesting than a class diagram, \nas it ex\u00adpresses more how [the system] functions [21]. A static object diagram shows all possible objects \nand relations between objects, across all program runs, and is recovered by static analysis over the \ncode. A dynamic ob\u00adject diagram shows the objects and the relationships that are  and proved unique \nobject and domain representatives.This paper describes the extraction analysis using a clearer for\u00admalization, \nwhich allows us to prove, in addition to unique object and domain representatives, edge soundness. Edge \nsoundness means that the built architecture shows all pos\u00adsible communication, which is a prerequisite \nfor enforcing communication integrity. An object graph, however, is often not isomorphic to a target \narchitecture. The primary contribution of this pa\u00adper is an integrated extract-abstract-check approach \nthat abstracts an object graph to a standard Component-and-Connector (C&#38;C) runtime architecture, \nthen analyzes com\u00admunication integrity against a target architecture. In Sec\u00adtion 5, we discuss how SCHOLIA \nabstracts an object graph. In Section 6, we map an abstracted object graph into a stan\u00addard component-and-connector \narchitecture. Also, SCHOLIA leverages our prior structural comparison algorithm [6] for the architectural \ncomparisons in Section 7. SCHOLIA computes conformance metrics to help managers track architectural conformance \nover time, and derives trace\u00adability information that allows the architect to effectively trace architectural \nviolations to code. In Section 8, we evalu\u00adate SCHOLIA and demonstrate that it can be applied to exist\u00ading \nsystems while changing only annotations in the code, that SCHOLIA can .nd interesting architectural violations \nthat can be traced to code, and that SCHOLIA computes sen\u00adsible conformance metrics in practice. We conclude \nwith a discussion (Section 9) and related work in Section 10.  2. Code vs. Runtime Architecture As a \nrunning example, we use Aphyds, a system of 8,000 source lines of Java code. A partial class diagram \nfor Aphyds shows one Vector class, and Node and Net classes that have a dependency on Vector (Fig. 3). \nThe class diagram suggests that a Node object and a Net object might share the same Vector object, but \nan object diagram may show this is not the case (Fig. 4(a)). In a hierarchical object diagram, an object \ncan contain other objects. As a result, one can collapse several nodes into one. This is a classic approach \nto shrink a graph. How\u00adever, SCHOLIA collapses object nodes based on contain\u00adment, ownership and type \nstructures, not according to where objects are declared in the program, a naming convention or a graph \nclustering algorithm, as we discuss below. Instead of objects being directly inside other objects, we \nuse an extra level of hierarchy and group related objects inside a domain. A domain is similar to an \narchitectural runtime tier,a conceptual partitioning of functionality [11]. The visualization uses box \nnesting to indicate contain\u00adment (Fig. 4(a)). E.g., DB is inside circ. Dashed-border white-.lled boxes \nrepresent domains. Sold-.lled boxes rep\u00adresent objects. Solid edges represent .eld references. An object \nlabeled obj:T indicates an object reference obj of -circuit \u00abinstantiate\u00bb -circuit -circuit -tnode -tnet \n\u00abinstantiate\u00bb  Figure 3. Code architecture of Circuit, Node and Net. type T, which we then refer to \neither as object obj oras T object , meaning for brevity, an instance of the T class . An object can \nhave a public domain to de.ne a concep\u00adtual group of contained objects. For instance, inside object circ, \na public domain DB contains object net. This makes net part of circ. Part of means conceptual or logical \ncon\u00adtainment, indicated by a thin border. Namely, nested objects are still accessible to the outside. \nFor instance, an object that can reference the object circ can also reference the inner object net inside \nthe DB domain. Each object can have domains. In turn, net has a pri\u00advate domain OWNED and object terms \ninside OWNED.Apri\u00advate domain de.nes strict instance encapsulation or object ownership. In other words, \nterms cannot be leaked to, nor accessed from, outside the net object. A thick border indi\u00adcates strict \nencapsulation. Unlike the class diagram which shows one Vector class, the object diagram shows distinct \nVector objects. In turn, those two Vector objects refer to the same term object in DB. Finally, hierarchy \nallows varying the abstraction level, by collapsing or expanding the sub-structure of objects such node \nand net. In Fig. 4(b), the (+) symbol on an object indicates that it has a collapsed sub-structure. In \naddition, several object references that a program de\u00adclares may alias, i.e., refer to the same object \nat runtime. An object graph such as Fig. 4(a) must conservatively show as one two objects that may alias \ndue to subtyping, a fact that may be implicit when looking at the code. Otherwise, an ar\u00adchitecture would \nbe deceptive if it mapped potentially the same runtime object into two architectural components. For \nexample, class Stack is a subtype of Vector. If there were a Stack object in the OWNED domain inside \nNet,the Stack and the Vector objects would be displayed as one.  3. Annotations A static object diagram \nis extracted by a static analysis over the code. To achieve hierarchy in the object diagram, SCHO-LIA \nrelies on local, modular (one class at a time) annota\u00adtions in the code that clarify the design intent. \nThe type\u00adcheckable annotations specify object encapsulation, logical containment and architectural tiers, \nwhich are not explicit constructs in a general purpose programming language.   (b) Collapsing the substructures \nof net and node. Figure 4. Runtime architecture of Circuit, Node and Net. 1 class Circuit { 2 public \ndomain DB; // Public domain 3 domain OWNED; // Private domain 4 DB Node node; 5 DB Net net; 6 DB Terminal \nterminal; 7 OWNED Map<String,DB Node> nodes; 8 } 9 class Node<OWNER>{ // Implicit parameter 10 domain \nOWNED; // Private domain 11 OWNED Vector<OWNER Terminal> terms; 12 } 13 class Net<OWNER>{// Implicit \nparameter 14 domain OWNED; // Private domain 15 OWNED Vector<OWNER Terminal> terms; 16 } 17 class ViewerUI<M>{ \n// Domain parameter 18 M Circuit circuit; 19 } 20 class Main { // Root class 21 domain MODEL, UI; // \nTop-level domains 22 MODEL Circuit circuit; 23 UI ViewerUI<MODEL> viewerUI; 24 } Figure 5. Re.ned annotations. \nThe annotations assign each object to a single ownership domain that does not change at runtime. An ownership \ndo\u00admain is a conceptual group of objects with an explicit name 1 @DomainParams({\"M\"}) // Domain parameter \n2 class ViewerUI { 3 @Domain(\"M\") Circuit circuit; 4 } 5 @Domains({\"MODEL\",\"UI\"}) // Actual domains 6 \nclass Main { 7 @Domain(\"MODEL\") Circuit circuit; 8 @Domain(\"UI<MODEL>\") ViewerUI viewerUI; 9 } Figure \n6. Using the concrete Java 1.5 annotations. and explicit policies that govern how it can reference objects \nin other domains [7]. Fig. 5 shows the annotations that a de\u00adveloper might add to some Aphyds classes. \nOur tools use existing language support for annotations [2], which tends to be verbose (Fig. 6), but \nthis paper uses a more readable syntax similar to the formal system (Fig. 9). A developer in\u00addicates \nthe domain of an object by annotating each reference to that object in the program (lines 4 6). A developer \ntypi\u00adcally chooses domain names to convey architectural intent. By convention, capital letters for domain \nnames help distin\u00adguish them from other program identi.ers. Each class can declare one or more public \nor private do\u00admains to hold its internal objects (lines 2 3), thus support\u00ading hierarchy. Although a \ndomain is declared at the level of a class in a program, each instance of that class has its own runtime \ndomain. Thus, the domains within an object express a substructure within the object, one that consists \nof other domains and objects that represent its parts. In particular, an annotation can refer to the \npublic domain D of an object obj, as if it were a .eld, using the obj.D syntax. Whenever our analysis \ndistinguishes two objects obj1 and obj2,italso distinguishes the domains that these objects contain in \nturn, such as obj1.D and obj2.D. An instance of the ViewerUI class accesses other objects in the MODEL \ndomain, by declaring a formal domain param\u00adeter M on the ViewerUI class (line 17), and binding that pa\u00adrameter \nto domain MODEL (line 23). A typechecker validates the annotations and identi.es where the annotations \nare in\u00adconsistent with each other or with the code. For instance, a public method cannot return an alias \nto an object inside a private domain. Thus, instance encapsulation is stronger than making a .eld be \nprivate to restrict its module visibility.  4. Architectural Extraction A Runtime Object Graph (ROG) \nrepresents the runtime structure of an object-oriented program. Nodes correspond to runtime objects. \nEdges correspond to relations between objects such as points-to .eld reference relations. The goal of \nthe static analysis is to extract from an annotated program a sound hierarchical approximation of any \nRuntime Object Graph, the Ownership Object Graph (OOG).  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \n19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Circuit c = new Circuit(); OObject(c, \nCircuit<null>) (O0) analyze(c, []) this . c, [] class Circuit { ODomain(c.DB, Circuit::DB) (D1) public \ndomain DB; ODomain(c.OWNED, Circuit::OWNED) (D2) domain OWNED; OObject(c.DB.nd, Node<c.DB>) (O1) OEdge(c, \nc.DB.nd) (E1) Node<DB>nd= new Node<DB>(); OObject(c.DB.term, Terminal<c.DB>) (O3) analyze(c.DB.term, \nTerminal::OWNER . c.DB) Terminal<DB> term = new Terminal<DB>(); OEdge(c, c.DB.term) (E3) ... } this . \nc.DB.nd, [OWNER . c.DB] class Node<OWNER>{ ODomain(c.DB.nd.OWNED, Node::OWNED) (D3) domain OWNED; OObject(c.DB.nd.OWNED.terms,Vector<c.DB.nd.OWNED>) \n(O5) OWNED Vector<OWNER Terminal> terms = new Vector<...>(); analyze(c.DB.nd.OWNED.terms, Vector::ELTS \n. c.DB) OEdge(c.DB.nd, c.DB.nd.OWNED.terms) (E5) } } Figure 7. Abstract interpretation of the Circuit \nclass. At a high level, the analysis distinguishes between ob\u00adjects in different domains, and abstracts \nobjects to pairs of domains and types. The analysis also substitutes formal do\u00admain parameters with actual \ndomains. Finally, the analysis adds edges between objects. Object merging. Different executions may generate \na different number of objects, for instance of Node objects. But a static object graph must represent \nall possible execu\u00adtions. To address this, an object graph summarizes multiple 1 this . c.DB.net, [OWNER \n. c.DB] 2 class Net<OWNER>{ 3 ODomain(c.DB.net.OWNED, Net::OWNED) (D4) 4 domain OWNED; 5 OObject(c.DB.net.OWNED.terms,Vector<c.DB.net.OWNED>) \n(O6) 6 OWNED Vector<OWNER Terminal> terms = new Vector<...>(); 7 analyze(c.DB.net.OWNED.terms, Vector::ELTS \n. c.DB) 8 OEdge(c.DB.net, c.DB.net.OWNED.terms) (E7) 9 } 10 11 12 13 ELTS T obj; 14 }  Figure 8. \nAbstract interpretation of the Circuit class. runtime objects with one canonical object in a domain, \ne.g., one Node object in the DB domain Object aliasing. The object graph maintains an aliasing invariant, \ni.e., no one runtime object appears as two different canonical objects in the graph. The ownership domains \ntype system give some precision about aliasing, without requir\u00ading an alias analysis. The type system \nguarantees that two objects in different domains cannot alias. But two objects in the same domain may \nalias. So, the analysis merges two objects declared in the same domain with the same types. 4.1 Example \nThe analysis takes as input a user-selected root type, in this case, Circuit (Fig. 7). First, the analysis \ncreates an OObject (O0) for an object allocation of the root type. Then, it analyzes the class Circuit, \nafter binding the receiver this to c. Inside Circuit, the analysis creates an ODomain for the domain \nDB (D1) and another for OWNED declared in class Circuit (D2). In turn, for the object allocations inside \nCircuit, it creates OObjects nd (O1), net (O2) and term (O3) inside DB, and an OObject nodes inside OWNED \n(O4). Then, the analysis adds OEdgesfromO0toO1(E1), O0 to O2 (E2) and O0 to O3 (E3). The analysis then \nprocesses class Node by binding the re\u00adceiver to c.DB.nd.In Node, the analysis creates an ODomain for \nOWNED (D3), and an OObject for terms (O5). In addi\u00adtion, the analysis adds an OEdge (E5) from O1 to O5. \nNext, the analysis processes terms by binding the re\u00adceiver to c.DB.OWNED.terms, and interpreting the \nvir\u00adtual .eld declaration obj inside Vector. After substitut\u00ading formals to actuals, the analysis .nds \nall OObjectsin the ODomain c.DB, the types of which are subtypes of Terminal. For instance, the analysis \n.nds the OObject O3. So, it creates an OEdge (E6) from the OObject correspond\u00adingtothe terms (O5), to \nthat OObject (O3). Similarly, the  cdef ::= class C<a, \u00df> extends C'<a> dom ::= { dom Tf md }[public] \ndomain d; md e n p T ::= ::= ::= ::= ::= TR m(T x) Tthis { return eR; }x | new C<p>() | e.f | e.m(e) \n| f | fee d | v a | n.d | shared C<p> v, f . locations S ::= f . C<p>(v) S ::= f . T G ::= x . T Figure \n9. Simpli.ed FDJ abstract syntax [7]. G . OGraph ::= (Objs = PtO, Doms = PtD, Edgs = PtE) ::= (PtO, PtD, \nPtE) D . ODomain ::= ( Id = Did, Domain = C::d ) ::= ( Did,C::d ) O . OObject ::= ( Id = Oid, Type = \nC<D> ) ::= ( Oid,C<D> ) E . OEdge ::= ( From = Osrc, Field = f, To = Odst ) ::= ( Osrc,f, Odst ) PtO \n::= \u00d8| PtO .{ O } Object map PtD ::= \u00d8| PtD .{ (O, d) . D } Domain map PtE ::= \u00d8| PtE .{ E } Edge map \n. ::= \u00d8| . .{ C<D> } Visited objects H ::= f . O Runtime object map K ::= f.d . D Runtime domain map \nDshared ::= ( Ds, ::shared ) Shared domain Oworld ::= ( Oworld, Object<> ) Root context Figure 10. Data \ntype declarations for the OGraph. analysis processes net and terms inside Net (Fig. 8). Note how the \ndomain sensitivity of the analysis allows it to map the same virtual .eld declaration (lines 35, 50) \nto two different OEdgesinthe OGraph, E6 and E8, respectively. 4.2 Formalization Syntax. We formalize \nthe analysis following ownership do\u00admains and Featherweight Domain Java (FDJ) [7]. We simpli\u00ad.ed the \nFDJ abstract syntax (Fig. 9) to exclude generic types, casts, etc. In FDJ, a type C<d> consists of the \nclass of an object and actual ownership domain parameters. An over\u00adbar represents a sequence. The .rst \nactual domain, d1,isthe owner (Aux-Owner [7]). In FDJ, locations represent object identity. A store S \nmaps a location \u00a3 to its contents, the type of the object, and the values stored in its .elds. S[\u00a3] denotes \nthe store entry for \u00a3. Each \u00a3.d refers to a domain named d that is part of the runtime object \u00a3. S[\u00a3, \ni] denotes the value in the ith .eld of S[\u00a3]. The store type S gives a type to each location in S, one \nthat is consistent with the classes and ac\u00adtual ownership domain parameters in S. dom() returns the mathematical \ndomain of a mapping, rng() its range. Data Types. In Fig. 10, an OGraph G is the triplet G = (PtO, PtD, \nPtE). PtO is a set of OObjects. PtD maps a pair consisting of an OObject O and a local domain or a domain \nparameter d in the abstract syntax, i.e., (O, d),toan ODomain D. Effectively, PtD maintains a mapping \nfrom formal domain parameters to actual domains. PtE is a set of OEdges. The analysis distinguishes between \ndifferent instances of thesameclass C that are in different domains, even if created at the same new \nexpression. In addition, the analysis treats an instance of class C with actual parameters p differently \nfrom another instance that has actual parameters p'. Hence, the datatype of an OObject uses C<D> instead \nof just a type and an owning ODomain.AsinFDJ,an OObject s owning ODomain is the .rst element D1 of D. \nA domain d is declared at the level of a class C in a program, but each instance of class C gets its \nown run\u00adtime domain \u00a3.d. Whenever the analysis distinguishes two runtime objects \u00a3 and \u00a3', it also distinguishes \nthe domains that these objects contain in turn, such as \u00a3.d and \u00a3'.d.Be\u00adcause each runtime domain \u00a3.d \nhas an ODomain representa\u00adtive, a domain declaration d in the code can create multiple ODomains Di. To \ndeal with recursive types, as we discuss later, an ODomain can have multiple parent OObjects, rather \nthan a single one, so an ODomain does not have an owning OOb\u00adject in its representation. Each OEdge E \nis a directed edge from a source OObject to a target OObject, and indicates the .eld named f. Abstract \nInterpretation. The analysis is an abstract in\u00adterpretation of the program that maps concrete domain \nand .eld declarations in the program to abstract values in an OGraph, namely OObjects, ODomains, and \nOEdges. We use a constraint-based speci.cation (Fig. 11) instead of transfer functions, which makes it \neasier to prove sound\u00adness. The judgement form is as follows: G, .,P tO,P tD,P tE fO, H e G is the typing \ncontext (Fig. 9). . is needed for handling recursion (Fig. 10), as we discuss later. The O subscript \non the turnstile captures the context-sensitivity. H is part of the instrumentation that maps locations \nto OObjects (Fig. 10). We omit H for most of the rules that do not need it. The interpretation starts \nwith a program P consisting of a class table CT and a root expression e, which gets analyzed in the context \nof Oworld. We require an OObject, Oworld, which has a single ODomain, Dshared, which corresponds to the \nglobal domain shared. For clarity, we quality a do\u00admain d by the class that declares it, as C::d. We \nqualify shared as ::shared.  .i . 1..|p| Di = PtD[(O, pi)] params(C)= a OC = ( Oid,C<D> ){OC }. PtO \n{(OC ,ai) . Di}. PtD PtO, PtD, PtE fO ptdomains(C<p>, OC ) PtO, PtD, PtE fO ptfields(C<p>, OC ) .m. mbody(m, \nC<p>)=(x : T, eR) C<D> . .=.{x : T, this : C<p>}, . .{C<D>}, P tO, P tD, P tE fOC eR [PT-NEW] G, ., \nP tO, P tD, P tE fO new C<p>()e .(domain dj ) . domains(C<p>) Dj = (Didj ,dj ){(OC ,dj ) . Dj }. PtD \n[PT-DOM] PtO, PtD, PtE fO ptdomains(C<p>, OC ) .(Tk fk) . fields(C<p>) owner(Tk)= p ' k Dk = PtD[(O, \np ' k)] .Ok PtO, PtD, PtE fO ptlookup(Dk,Tk)= Ok {( OC ,fk,Ok )} . PtE [PT-FIELDS] PtO, PtD, PtE fO \nptfields(C<p>, OC ) '' ' Ok = ( Oid,C<D> ). PtO D1 = DT = C <p ' > C<: C ' '' .i . 1..|p '| D = PtD[(O, \np i)] D = Di ii [PT-LOOKUP][PT-VAR] PtO, PtD, PtE fO ptlookup(D, T ' )= Ok G, ., P tO, P tD, P tE fO \nx G, ., P tO, P tD, P tE fO e0 [PT-LOC][PT-READ] G, ., P tO, P tD, P tE fO f G, ., P tO, P tD, P tE fO \ne0.fk G, ., P tO, P tD, P tE fO e0 G, ., P tO, P tD, P tE fO e [PT-INVK] G, ., P tO, P tD, P tE fO e0.m(e) \nOC = H[f]G, ., P tO, P tD, P tE fOC e [PT-CONTEXT] G, ., P tO, P tD, P tE fO, H fee .f . dom(S), S[f]= \nC<p> H[f]= O = (Oid,C<D>). PtO .m. mbody(m, C<p>)=(x : T, eR) {x : T, this : C<p>}, \u00d8, P tO, P tD, P \ntE fO, H eR [PT-SIGMA] PtO, PtD, PtE fCT,H S Figure 11. Constraint-based speci.cation of the object \ngraph extraction analysis. In PT-NEW, the analysis interprets a new object allocation in the context \nof an OObject O as follows. First, PT-NEW checks that PtO has an OObject OC for the newly allocated object. \nSince PtD maintains the binding from each formal domain parameter to some ODomain,PT-NEW ensures that \nthe representatives of the actual domains p bound to the parameters of class C are in PtD. PT-NEW then \nuses the auxiliary judgement PT-DOM to ensure that PtD has an ODomain corresponding to each domain that \nthe class C locally declares. In PT-DOM,the domains auxiliary judgement from FDJ returns the owner\u00adship \ndomains that a class declares, after substituting formal domain parameters with actual domains. domains \nalso in\u00adcludes inherited domains, including the private domains. In FDJ, private domains are misnamed, \nand really have a pro\u00adtected semantics [7, Rule Aux-Domains (Fig. 14)]. PT-NEW then relies on the auxiliary \njudgement PT-FIELDS to ensure that PtE has an OEdge from OC to each object in the target domain that \nis type compatible with the target type, using PT-LOOKUP.In PT-FIELDS,the fields auxiliary judgement \nfrom FDJ returns the .elds that a type declares, after substituting formal domain parameters with actual \ndomains, and includes inherited .elds. ' Finally, PT-NEW obtains each expression e in each ' method m \nin C, and processes e in the context of the OOb\u00adject OC . Before PT-NEW checks these expressions recur\u00adsively, \nit adds the current combination of a type and actual domain parameters to ..If PT-NEW discovers by looking \nat . that it previously analyzed that same combination, it does not recurse into the same OObject, thus \navoiding in.nite recursion. Although the case for new expressions is the most inter\u00adesting, the analysis \nrequires rules for all the expression types to make the induction work. The rules for PT-VAR,PT-LOC, \nPT-READ, and PT-INVK are self explanatory. PT-CONTEXT analyzes method calls in progress \u00a3ce, where \u00a3 \nis the receiver, by moving into the context of the receiver object OC . Finally, the induction requires \nan aug\u00admented store typing rule, PT-SIGMA, to ensure that method bodies have been analyzed for all objects \nin the store.  Recursion. The analysis must handle recursive types, which can lead an OGraph to grow \narbitrarily deep. To en\u00adsure termination, the OGraph is .nite, and can contain cy\u00adcles. The analysis \ncreates a cycle in the OGraph when it reaches a similar context. We chose to unify domains. For instance, \nin Fig. 12, the OWNED domain inside nwQT is the same as the OWNED domain inside aQT. Because the same \nODomain can now appear as the child of two OObjects, an ODomain cannot have an owning OObject. The visualiza\u00adtion, \nhowever, expands the OGraph to a limited depth the user sees the graph above the thick dashed line Fig. \n12. 4.3 Soundness The soundness proof relies on an instrumentation of the FDJ runtime semantics, an approximation \nrelation, and standard Progress and Preservation theorems. We summarize below the key results. In addition \nto the FDJ store S, the instru\u00admentation maintains the maps H and K (Fig. 10). The instrumented evaluation \nhas the judgement form: e; S; H; K .G e ' ; S ' ; H ' ; K ' where G = (PtO, PtD, PtE)is the statically \ncomputed object graph. This instrumentation is safe since discarding it produces exactly the previous \nsemantics. In IR-NEW (Fig. 13), the actual domains pi passed to the class C being allocated are runtime \ndomains, which K maps to static ODomainsin PtD.Weuse H to lookup the OObject Ok for each value vk passed \nto initialize the kth .eld of the object being allocated, and ensure that the OEdge is in PtE. We de.ne \nthe approximation relation ~ as follows: . S f S, (S, H, K) ~ (PtO, PtD, PtE) iff .f . dom(S), S[f]= \nC<f ' .d> implies H[f]= OC = (Oid,C<D>). PtO and .f ' j .dj . f'.d K[f ' j .dj ]= Dj = (Didj ,dj ). rng(PtD) \nand .di . domains(C<f ' .d>) K[f.di]= Di = (Didi ,di ). rng(PtD) and {(OC ,di) . Di}. PtD and fields(S[f]) \n= Tf and .k, .f ' S[f, k]= f ' =. Ek = (H[f],fk,H[f ' ]). PtE Theorem: Object Graph Soundness. .G = (PtO, \nPtD, PtE)f P =(CT,e) CT,e well-typed .e; \u00d8; \u00d8; \u00d8 .* G e; S; H; K .S f S PtO, PtD, PtE fCT,H S (S, H, \nK) ~ (PtO, PtD, PtE) The theorem states that, given any Runtime Object Graph (ROG) represented by a well-typed \nstore S, and an OGraph main OWNED OWNED  Domain Object Main main = new Main(); class Main { domain \nD; QT<D> aQT = new QT<D>(); } this . main.D.aQT, [M . main.D] class QT<M>{ domain D; QT<M> nwQT = \nnew QT<M>(); } this . main.D.aQT.D.nwQT, [M . main.D] class QT<M>{ domain D; QT<M> nwQT = new QT<M>(); \nOEdge(main.D.aQT.D.nwQ, main.D.aQT.D.nwQT) } Figure 12. Example with recursive types. produced from the \nsame program P , there exists a map H that maps each location \u00a3 in the store to a unique OObject, and \na map K that maps each runtime domain in the store to a unique ODomain, and this mapping is consistent \nwith  IR-NEW f . dom(S) S ' = S[f . C<p>(v)] p = f ' .d Di = K[fi' .di] OC = (Oid,C<D>) OC . PtO H ' \n= H[f . OC ] .dj . domains(C<p>) Dj = PtD[(OC ,dj )] K ' = K[f.dj . Dj ] .(Tk fk) . fields(C<p>) Ok \n= H[vk] Ek = (OC ,fk,Ok) Ek . PtE ''' new C<p>()v; S; H; K .G f; S ; H ; K Figure 13. Instrumented runtime \nsemantics. respect to the ownership relation. In addition, the OEdges in the OGraph soundly abstract \nall .eld points-to relations between any two objects in an ROG. More details and the proof are in [1, \nChap. 3].  5. Architectural Abstraction An extracted object graph provides architectural abstraction \nby ownership hierarchy and by types. But an object graph may not be isomorphic to an architect s intended \narchitec\u00adture, and may require further abstraction. 1. Elide and summarize private domains. Object graphs \ntend to expose the implementation of data structures [29, p. 252]. In SCHOLIA, when internal state is \nplaced in pri\u00advate domains, the OOG abstraction step can leverage the semantic distinction between private \nand public domains. For instance, the Aphyds designed architecture (Fig. 20) shows a circuit object, \nas well as node and net objects in\u00adside circuit. In the Aphyds object graph, the private domain OWNED \non Circuit stores Mapsof Node and Net objects (Fig. 15), and these objects are not architecturally signi.\u00adcant. \nSo the analysis, based on user input, can elide private domains and the objects they contain. To preserve \nsound\u00adness, however, the analysis may add summary edges to ac\u00adcount for communication through elided \nobjects. For exam\u00adple, if there is an edge from objects a to b and b to c, eliding b produces a summary \nedge between a and c (Fig. 14). 2. Skip single domains. In an OOG, each object is in a domain, so a systematic \nconversion would create each Component in a Group. Architects typically de.ne tiers only at the top level, \nand those map to the top-level domains. For example, requiring the Aphyds designed architecture to have \na single DB tier inside circuit would be counterin\u00adtuitive. Unless the developer requests otherwise, \nthe conver\u00adsion does not create a single tier inside a Component. Unlike eliding private domains, skipping \nsingle domains still creates the substructure for those unmapped domains. For example, after eliding \nthe private domain OWNED inside Circuit,the conversion skips the single public domain DB and creates \nnode and net and the connections between them, directly in\u00adside circuit (Fig. 23). Even though domains \nplay a central role in the annota\u00adtions, they often disappear after they serve their purpose, DOM1 a: \nA b: B c: C DOM1 a: A c: C (a) Showing objects a,b,c.(b) Eliding object b. Figure 14. Example of a summary \nedge. which is to distinguish between internal and public state. Re\u00adcall how in ownership domains, the \nowner of an object is a domain instead of another object, unlike other ownership type systems [10]. Indeed, \nboth public and private domains produce hierarchy in an object graph. But we often elide pri\u00advate domains, \nend up with a single public domain in a given object, then skip that domain. Some type systems embody \nthis idea and hard-code in each class, one private and one public boundary domain [31]. 3. Skip objects \nbeyond a certain depth. The analy\u00adsis converts an OOG object hierarchy up to a user-selected depth, typically \nthe depth of the hierarchical decomposition in the designed view. Reducing the size of the built archi\u00adtecture \nin this manner speeds up the comparison, but does not affect conformance, because lifted edges account \nfor the elided substructures.  6. Architectural Description SCHOLIA can represent the information that \nit reverse engi\u00adneers from the code using different graphical (or non graph\u00adical) notations. Documenting \nan architecture in an architec\u00adture description language (ADL) enables performing various architectural-level \nanalyses. We use the Acme general purpose ADL [15], partly be\u00adcause of its available tool support. Acme \nrepresents archi\u00adtectural structure as a hierarchical graph with types and at\u00adtributes on nodes and edges \nand has no execution semantics. Most ADLs also support the following elements [25]. A Component is a \nunit of computation and state. A Port is a point of interaction on a Component.A Connector rep\u00adresents \nan interaction between Components. A System is a con.guration of Components and Connectors. A Com\u00adponent \ncan optionally be decomposed into a nested sub\u00adarchitecture. A Property is a name and value pair associated \nwith an element. A Group is a named set of elements, such as a tier. To improve the precision of the \nstructural comparison, the base architectural model has types and properties [6]. A Port that provides \nservices has type ProvideT, and a Port that uses services has type UseT. The structural comparison uses \nthe type information, when available, to avoid matching a ProvideT Port to a UseT Port, for example. \nComponents and Sub-Components. SCHOLIA assumes that an OOG has a single root. So the root object maps \nto a System. The top-level domains declared by the class of the root object map to the top-level tiers \nin the System. Each   other: Other DOM2 DOM1  DOM2(a) Edge source showing.(b) Edge source lifted. \n other: Other DOM1  DOM2  (c) Edge target showing.(d) Edge target lifted.  Figure 16. Examples of \nlifted edges. Figure 17. C&#38;C view lifts edge to outer component. object in the OOG maps to a Component. \nThe OOG hier\u00adarchy creates architectural decomposition. If an OOG object declares domains and descendent \nobjects, the corresponding Component has a sub-architecture. Ports. References between objects create \nPortsasfol\u00adlows. If object A has a .eld reference of type T to object B, the corresponding Component \nA has a Port of type UseT and name B.The Component corresponding to B has a Port of type ProvideT and \nname T.Anda Connector connects A to B. By default, the analysis does not represent the uninter\u00adesting \nself-edges in an OOG. Edge Lifting. The representation of an OOG as a C&#38;C view also lifts edges. \nConsider an OOG with an edge from other to inner inside outer s public domain CBS (Fig. 16(c)). A C&#38;C \nview lifts that edge to component outer, shows a connector from other to outer, and a connection from \nouter to inner (Fig. 17). Domains and Tiers. An ownership domain d in the OOG maps to a Group g. If an \nobject o in a domain d, the corre\u00adsponding Component is in Group g. To be structurally com\u00adparable, both \nthe built and the designed architectures fol\u00adlow similar topological constraints. For instance, in Acme, \na Component can be included in more than one Group.But in ownership domains, each object is in exactly \none domain and that domain never changes. So a predicate enforces that a Component or Connector is in \nexactly one Group. More\u00adover, if Connector c connects two Components that are in the same Group g, c \nmust be also in g.  7. Architectural Conformance SCHOLIA can just extract the up-to-date built runtime \narchi\u00adtecture from the code and document it an in ADL. If a doc\u00adumented target architecture exists, SCHOLIA \ncan analyze its conformance with the code. A designed architecture is often more abstract than the built \narchitecture, but it must still represent all communica\u00adtion that could exist in the implementation. \nA conformance analysis can enforce the communication integrity principle and ensure that the designed \narchitecture is a conservative abstraction of all the objects in the implemented system and the relations \nbetween those objects at runtime. A static anal\u00adysis can of course suffer from false positives, and indicate \npotential object relations that can never exist at runtime. But here, the goal is to have no false negatives \nin the designed architecture, and show the worst case of possible communi\u00adcation between objects at runtime. \n 7.1 Analyzing and Displaying Conformance In the terminology of Murphy et al. [28], the conformance \nanalysis identi.es: Convergence: a node or an edge that is in both the built and the designed architectures; \n Divergence: a node or an edge that is in the built archi\u00adtecture, but not in the designed architecture; \n Absence: a node or an edge that is in the designed archi\u00ad  tecture, but not in the built architecture. \nThe analysis produces a conformance view as a copy of the designed architecture. The conformance view \nshows conver\u00adgences and absences graphically, and represents divergences by showing additional connectors \nthat are present in the im\u00adplementation but are missing from the designed architecture. The analysis \nalso sets various properties on the conformance view elements. Some of these properties decorate the \ngraph\u00adical representation of an element. For instance, all elements have a .nding property, set to convergent \n(shown as ), di\u00advergent (shown as )or absent (shown as ). As a positive side effect of the conformance \nanalysis, SCHOLIA also establishes traceability between an intended architecture and the underlying source \n.les, for the bene.t of other code quality tools. The various steps thread through the traceability information \nas follows. The abstraction of an OOG into a C&#38;C view copies the traceability of each OOG element \ninto the traceability property of the corresponding C&#38;C element, as a set of .lename and line number \npairs. Similarly, the conformance view derives its traceability in\u00adformation from the built C&#38;C view. \nA tool can use this in\u00adformation in the conformance view to trace to the pertinent lines of code, and \nsave a developer the effort of having to potentially review the entire code base to investigate a sus\u00adpected \narchitectural violation. Of course, the conformance analysis sets the traceability on only convergent \nand diver\u00adgent elements, and not on absent ones. The components an architect includes in the designed \nview may be more relevant than those she omits. And she often chooses names to convey her architectural \nintent. So, when analyzing conformance, SCHOLIA considers the de\u00adsigned view to be more authoritative \nthan the built one, and worksasfollows: 1. Match components, but use the names from the de\u00adsigned view. \nElements in the designed and the built views may not have exactly matching names. The structural com\u00adparison, \nhowever, can detect renames. Unlike view synchro\u00adnization, the conformance analysis does not propagate \nthe built names to the designed view. For Aphyds, the analysis correctly matches built compo\u00adnents ViewerUI \nand FloorPlanUI to designed component viewerUI and .oorplanUI, respectively, but does not rename them \n(Fig. 18). 2. Highlight differing connections. The analysis shows differing connections as divergences \nor absences. In Aphyds, the built view has only a connector between FloorPlanUI  (a) As-designed view. \n(b) As-built view. (c) Conformance view. Figure 18. Displaying a convergence and a divergence. (a) \nAs-designed view. (b) As-built view. (c) Conformance view. Figure 19. Showing a divergence as a summary \nconnector. and ViewerUI, and the latter match the designed compo\u00adnents .oorplanUI and viewerUI. So the \nanalysis shows a di\u00advergent connector from .oorplanUI to viewerUI (Fig. 18). This requires the following \nstylized use of ports, which may also make ports easier to understand [8]. An Acme Port has no built-in \ndirectionality. Its type spec\u00adi.es whether it provides services (ProvideT) or uses services (UseT). In \nsome cases, the designed view may have a con\u00adnector between two components, but the connection in the \nbuilt view may be in the reverse direction. The conformance analysis could make the Connector bi-directional, \nby assign\u00ading to the connection s endpoints both the ProvideT and UseT types. But this does not .t with \nshowing divergences and absences. Instead, we adopt unidirectional ports, i.e., the type can be ProvideT \nor UseT, and never both. So the anal\u00adysis shows a divergent connector, as well as ProvideT and UseT Ports, \nfor the communication in the opposite direction. 3. Summarize divergent components. If there are com\u00adponents \nin the built architecture that are not in the designed architecture, the analysis works differently from \nview syn\u00adchronization. Adding these components directly to the de\u00adsigned architecture would clutter it \nwith implementation de\u00adtails. Instead, the analysis accounts for communication in the built architecture \nthat is not in the designed architecture, and may add summary connectors to abstract these divergent \ncomponents and enforce communication integrity.  In the built view, Node connects to Terminal and Terminal \nto Net (Fig. 19(b)). The designed view has node and net, but has no component that matches Terminal (Fig. \n19(a)). The analysis matches node to Node, and net to Net, respectively. It then shows a divergent connector \nfrom node to net, since the designed view does not already have one (Fig. 19(c)). If the designed view \ndoes have such a connector, the analysis marks it as convergent. Since a summary connector can be either \ndivergent or convergent, the analysis sets a property isSummary on a connector sep\u00adarately from its .nding. \nA decorator overlays the symbol on a connector when isSummary is set to true. Viewed differently, the \nanalysis represents using a sum\u00admary connector any objects in the built view that do not have counterparts \nin the designed view. This allows a designed view to have a coarser granularity of components, and ab\u00adstract \nmultiple interacting objects with a connector. Indeed, the JavaDoc for Aphyds states that Terminal is \na connec\u00adtion between a Node and a Net . To help a developer update an incomplete designed ar\u00adchitecture, \nthe analysis can optionally show in the confor\u00admance view the divergent components, but without showing \nany connections to these components. A developer can add some of the divergent components to the designed \nview and re-run the conformance analysis. 4. Analyze matching substructures recursively. De\u00adsigned architectures \nare often hierarchical, but do not typi\u00adcally have deep hierarchies. An OOG provides architectural abstraction \nprimarily through ownership hierarchy. When an OOG is abstracted into a C&#38;C view whether restricting \nthe depth of the hierarchy or not, more components in the built C&#38;C view will have substructures \nthan their designed counterparts. To avoid generating many false positives, the analysis ignores the \nsubstructures that are in the built view but not in the designed one. Skipping unmatched substruc\u00adtures \ndoes not compromise soundness, because both an OOG (Figs. 16(b), 16(d)) and a built C&#38;C view (Fig. \n17) lift edges to represent any communication through their substructures. For instance, viewerUI in \nthe designed view does not de.ne a substructure. So the analysis matches viewer to ViewerUI in the built \nview, and ignores the substructure of the latter. But the designed circuit has substructure and matches \nthe built Circuit. In that case, the analysis recur\u00adsively analyzes the substructures of circuit and \nCircuit. Had the OOG abstraction step not excluded private domains, the conformance analysis would have \nprocessed the corre\u00adsponding OWNED tier in the built C&#38;C view, and generated several undesired divergences, \nsince both domains OWNED and DB are in Circuit s substructure, and its designed coun\u00adterpart also has \nsubstructure. 7.2 Measuring Conformance SCHOLIA counts convergent edges (CE), divergent edges (DE), absent \nedges (AE), and summary edges (SE). In ad\u00addition, SCHOLIA counts convergent nodes (CN), divergent nodes \n(DN), and absent nodes (AN). In SCHOLIA, a high AN or DN often indicate that the designed view is missing \ncomponents compared to the built view, or uses a different system decomposition (Table 1). SCHOLIA combines \nedge divergences and edge absences into one number. In terms of face validity, this metric is simi\u00adlar \nto a graph edit distance, which models inconsistencies by transforming one graph into another [12]. Typical \nedit oper\u00adations include the deletion, insertion and relabeling of nodes and edges. Each edit operation \nis assigned an application\u00addependent cost. SCHOLIA assigns renames a zero cost and counts insertions \n(divergences) and deletions (absences). The Core Conformance Metric (CCM) counts divergent edges (DE) \nand absent edges (AE) that would make the designed architecture account for all communication in the \nimplementation. To get a percentage, we divide by the total number of edges and subtract from 100%. Of \ncourse, fewer absences and divergences are better and mean the system is closer to the target architecture. \nSo, a higher CCM value indicates a higher structural conformance. AE + DE CCM =1 - CE + AE + DE SCHOLIA \nquali.es the conformance metrics by measur\u00ading the percentage of the program that lacks annotations. \nFor simplicity, SCHOLIA uses a derived measure, WARN, namely the number of annotation warnings that the \nannota\u00adtion typechecker generates. Except for some defaults, every .eld, variable declaration, or method \nreturn, that is a refer\u00adence to an object and has a missing or incorrect annotation, generates a warning \n(we mostly avoid multiple warnings due to one missing annotation). To get a percentage, the metric WARN% \nnormalizes WARN by the number of declared ob\u00adject references in the program. Thus, WARN% is an indica\u00adtor \nof how many annotations are missing to make an OOG soundly represent the built architecture. A lower \nWARN% is better. For a program without annotations, WARN% will be high. As valid annotations are added, \nor warnings are ad\u00addressed, WARN% decreases. For Aphyds, WARN% is 5%. The remaining warnings are due \nto expressiveness challenges in the type system, which we discuss elsewhere [2]. We believe however these \nwarn\u00adings do not contribute to missed architectural violations.  8. Evaluation Our evaluation demonstrates \nthe feasibility of SCHOLIA and that hierarchical object graphs provide architectural abstrac\u00adtion, something \nthat had been missing in previous static anal\u00adyses of the runtime structure. In future work, we plan \nto eval\u00aduate SCHOLIA s usefulness, i.e., if it can provide actual as\u00adsistance to a developer in ful.lling \na code modi.cation task based on an object diagram, as well as the usability or ease of learning and \napplying the approach.  Research question. The evaluation aimed to answer the re\u00adsearch question: Can \nSCHOLIA identify interesting struc\u00adtural differences between built and designed architectures in real \nsystems? A .nding is interesting if it identi.es undocu\u00admented information, contradicts available documentation, \nor highlights a potential design or implementation defect. We re.ne the research question into the following \nhypotheses: A developer can control the annotations to extract a built architecture that expresses his \narchitectural intent and conveys architectural abstraction. The measurable criteria are to minimize annotation \nwarnings, reduce the number of top-level objects compared to a .at object graph, and not display low-level \nobjects.  The conformance analysis can match the built and the designed architectures, display a readable \nconformance view, enable tracing a .nding to the code, and compute sen\u00adsible conformance metrics. The \nmeasurable criteria are to minimize false positives and to be able to trace to the right code locations. \n Methodology. A developer documents the designed archi\u00adtecture in an ADL. She then adds annotations \nto the code, invokes a typechecker and addresses annotation warnings. Just as there are multiple architectural \nviews of a system, there is no single right way to annotate a program. Good annotations minimize the \nnumber of top-level objects, by pushing low-level objects underneath more architecturally\u00adrelevant ones. \nFor a meaningful comparison, the designed and the built architectures must have similar tiers, similar \nhi\u00aderarchical decomposition, and similar components and tiers at each hierarchy level. Using a tool, \nshe extracts a hierarchical object graph, and re.nes the annotations until the number of top-level objects \nis roughly comparable to that in the designed architecture. She then invokes a tool to abstract the extracted \nobject graph into a built architecture. She then uses another tool to com\u00adpare the built and the designed \narchitectures. She typically only con.rms the results of the comparison. But if the com\u00adparison mismatches \nsome elements, she can manually force or prevent matches between those elements, and rerun the comparison. \nFinally, she examines the results of the confor\u00admance analysis, studies unexpected .ndings and traces \nsus\u00adpicious ones to the code. The developer can iteratively: (a) re.ne the annotations; (b) manually \nguide the comparison if it fails to perform the proper match; (c) correct the code, if she decides that \nthe de\u00adsigned architecture is correct, and the implementation vio\u00adlates the architecture; or (d) update \nthe designed architecture if she considers that the implementation highlights an error or omission in \nthe target architecture. Tools. To support the methodology, SCHOLIA uses several Eclipse plugins to relate \nC&#38;C views, OOGs and source .les: AcmeStudio is an Acme modeling environment [15], to document the \ndesigned architecture and display the con\u00adformance view. AcmeStudio is an Eclipse perspective, so a developer \ncan trace seamlessly from a conformance view to the Java code in Eclipse;  ArchDomJ typechecks the annotations \nadded to the code as Java 1.5 annotations and displays warnings in the Eclipse problem window. A developer \ncan go from a warning to the offending line of code;  ArchRecJ extracts an OOG from annotated code; \n ArchCog abstracts an OOG into a C&#38;C view (Section 5). A developer can elide private domains or \nrestrict the projection depth;  ArchConf analyzes conformance between two C&#38;C views, generates a \nconformance view and computes the metrics (Section 7). ArchConf allows a developer to con\u00ad.rm the results \nof the structural comparison, or to manu\u00adally force or prevent matches and rerun the comparison;  CodeTraceJ \nloads the traceability of an element in the conformance view, opens the corresponding source .les and \nhighlights the appropriate lines;  ArchMod modi.es the original designed architecture, by taking a divergent \nelement from the conformance view and adding it to the designed view, or deleting an absent element from \nthe designed view.  Aphyds case study. We now describe analyzing the confor\u00admance of the Aphyds system \nusing the above methodology and tools. The experimenter (one of us, hereafter we ) de\u00adveloped several \nof the tools, but none of the subject sys\u00adtems. The process was iterative as a whole, and involved both \nmacro-and micro-iterations. A macro-iteration consists of documenting the designed architecture, adding \nthe anno\u00adtations, extracting an OOG, abstracting it into a built C&#38;C view, and analyzing its conformance. \nA micro-iteration can consist of iterating the annotations and the OOG extraction before converting the \nOOG into a C&#38;C view, until the OOG has a reasonable abstraction level, e.g., by abstracting away \nlow-level objects such as Vectors from the top-level do\u00admains. Retrospectively, we present our evaluation \nas two macro-iterations, and show the evolution of the conformance metrics across the two macro-iterations \n(Table 1). Designed architecture. We formalized the Aphyds de\u00adsigned architecture based on the informal \ndiagram (Fig. 20), but iterated it a few times while formalizing it. When con\u00adnecting two components \nin a group, we initially forgot to put the connector into that group, which resulted in the confor\u00admance \nanalysis badly matching those connectors. In an early iteration, we set the analysis to add the di\u00advergent \ncomponents to the conformance view, and noticed a partitionUI component. For consistency, since .oorPlanUI \nand placeRouteUI interact with .oorplanner and placeR\u00adouter, respectively, we added to the designed architecture \nIteration 1. We initially organized the Aphyds objects into two top-level domains, UI and MODEL. UI holds \na ViewerUI object and several subsidiary user interface objects. MODEL holds a Circuit object and computational \nobjects that act on it, such as Floorplanner. We also de.ned several pri\u00advate domains to hold objects \nencapsulated by their parent,  1 such as Map objects inside a Circuit object, as the (+) sign 2 3 \nindicates in Fig. 21. These annotations produce a hierarchi\u00ad 4 cal OOG that has many objects in the \ntop-level domains. 5 Conformance metrics. The conformance analysis does not produce good conformance \nmetrics (Table 1). For exam-6 ple, Node and Net are peers of Circuit instead of being 7 in its substructure \n(Fig. 22). So the conformance analysis 8 marks as absent the node and net components inside circuit,9 \n10 hence the 2 node absences. 11 The built view has many more components in the top\u00adlevel tiers than \nthe designed view, which explains the high node divergence. Moreover, the conformance analysis gener\u00adates \nmany summary connectors to account for possible tran\u00adsitive communication, which leads to a high number \nof edge divergences and an unreadable conformance view. For example, Displayer communicates with Terminal, \nand Terminal with Placer. In reality, Terminal is part of Circuit, and Circuit already communicates with \nPlacer. Ideally, the analysis should just mark as conver\u00adgences the connection between Displayer and \nCircuit, and the one between Circuit and Placer. Since the anal\u00adysis lacks information about logical \ncontainment, it shows instead a divergent summary connector from Displayer toFigure 21. Aphyds OOG using \nprivate domains and many peer objects, e.g., Node, Net, Terminal and Circuit. class Circuit<OWNER>{ // \nImplicit parameter domain OWNED; // Private domain OWNER Node node; // Make peer to self OWNER Net net; \nOWNER Terminal terminal; // The outer OWNED annotation is for the Map object // The inner OWNER annotation \nis for the map elements // String objects have manifest ownership OWNED Map<String, OWNER Node> nodes; \n} // Everything else is exactly the same as Fig. 5 Figure 22. Initial annotations. Placer, and many others. \nThis turns the conformance view into an unreadable fully-connected graph. The low CCM and the many summary \nedges (SE) 97 in total, may not mean that the designed view is only 21% accurate, but that the built \narchitecture is not yet meaningfully comparable to the designed one. In SCHOLIA, a developer controls \nthe architectural ab\u00adstraction using annotations. So in the second iteration, we re\u00ad.ned the annotations \nto get a better match, without changing the code. The reader can visually compare the annotations  \nFigure 23. Aphyds conformance results. in Fig. 22whichweusedinIteration1,tothoseinFig.5, which we adopted \nin Iteration 2. Iteration 2. Using the designed architecture as a guide (Fig. 20), we de.ned several \npublic domains to logically contain objects that should not be in the top-level domains. For example, \nViewer has a DISPLAY public domain to hold a Displayer object. Displayer is not in the developer s di\u00adagram \n(Fig. 20), but is not encapsulated either. Displayer is only logically contained inside ViewerUI, and \nmany other UI objects such as FloorPlanUI reference it directly. Other public domains abstract low-level \nobjects into more architecturally relevant ones. For example, Circuit holds objects such as Node and \nNet inside its DB public domain, to re.ect the designed architecture (Fig. 20). In most cases, de.ning \npublic domains required mostly local and incremental changes to the annotations. With the re.ned annotations, \nmany objects that were in the MODEL top-level domain, such as Node, Net and Terminal, moved into public \ndomains of other objects, such as Circuit (Fig. 15). As a result, both the extracted OOG and the ab\u00adstracted \nbuilt view now have a system decomposition that is closer to the desired architecture (Fig. 20). Conformance \nmetrics. Iteration 2 matched the compo\u00adnents better, with 0 node absences and 1 node divergence, which \ncorresponds to Terminal. The analysis now marks as convergent, both node and net inside circuit,aswellas \nthe connectors between them (Fig. 23). In the built system, node and net do not communicate directly, \nbut only do so through Terminal.Sothetwo convergent connectors in\u00adside circuit have the summary decoration \n. As an aside, the edges from Node to Terminal and from Net to Terminal Table 1. Aphyds conformance metrics. \nIteration CN DN AN CE DE AE SE CCM 1 11 11 2 23 89 0 97 21% 2 13 1 0 16 11 1 2 57% are in fact lifted \nedges. This example justi.es the different kinds of edge summarization, such as edge lifting in a C&#38;C \nview, then adding summary connectors in the C&#38;C view. Overall .ndings. As one would expect from an \ninformal diagram, the designed architecture (Fig. 20) is only about 60% accurate, based on the CCM metric. \nIndeed, SCHOLIA identi.ed a divergent component partitionUI, several diver\u00adgences between viewerUI and \nother UI components, between UI and MODEL components, and between MODEL compo\u00adnents. Many connections \nwhich the developer thought to be uni-directional were bi-directional in reality. One divergence that \ncrosses tiers, from placer in MODEL to placeRouteUI in UI, was a red .ag (this is the connec\u00adtor we manually \nset to be darker in color in Fig. 23). A multi-threaded application must respect certain framework\u00adspeci.c \nconventions to call back from a worker thread ex\u00adecuting a long-running operation into the user interface \nthread. We used CodeTraceJ to trace this divergence to a PlaceRouteUI .eld inside class Placer, and checked \nthat the Aphyds code handled this callback correctly. Tool performance. The tools are suf.ciently interactive \nto allow iteration. On an Intel \u00ae Core 2 Quad Processor (2.4 GHz) with 4GB of RAM running Windows XP, \nthe OOG extraction takes around 10 seconds, and the structural comparison takes between 57 seconds (Iteration \n1) and 33 seconds (Iteration 2). 9. Discussion Internal threats to validity may indicate that factors \nother than the technique determined the results. External threats limit the extent to which the results \ncan be generalized. Internal validity. One threat to internal validity is that, even though we did not \nauthor Aphyds, we previously studied it in various ways [6, 8]. We believe the results of this case study \nare due to using SCHOLIA and not to any previous knowl\u00adedge of the code. The code base is non-trivial \nenough for anyone to memorize. Moreover, we previously represented the desired architecture differently \n[6, Fig. 19]: we did not consider tiers, had one model component with planner, par\u00adtitioner and others \nas sub-components, and ignored circuit s substructure. Although the experimenter also designed sev\u00aderal \nof the tools, a typechecker kept him honest. He could not insert an arbitrary annotation without getting \na warning, or otherwise manipulate the extracted architectures. Another threat is that an electrical \nengineering professor, not a professional architect, drew the Aphyds intended ar\u00adchitecture. However, \nwe only mined the diagram for the ar\u00adchitecturally signi.cant objects and tiers it shows, and for the \nhierarchical system decomposition it uses for circuit,all general concepts in modeling architectures \n[11].  Another confound is whether the built and the designed architectures represent the same information. \nFor instance, when we redrew the original developer s diagram (Fig. 20), we reversed the direction of \nsome arrows [8, p.192] and excluded data .ow edges. For a meaningful conformance analysis, the designed \nand the built architectures must have the same kind of connectors, here, points-to relations. Can SCHOLIA \nidentify at least as many violations as the state-of-the-art in the static enforcement of runtime archi\u00adtectures? \nThe state-of-the-art would be library-based [24] or language-based [8, 32] solutions. For instance, the \nC2 ADL mandates a speci.c architectural framework [24], but requires developers to follow strict guidelines \nto avoid intro\u00adducing architectural violations. There are no tools to check that an implementation obeys \nthose rules (N. Medvidovic, personal communication, 2008). Language-based solutions, .rst exempli.ed \nby ArchJava, radically extend the language to incorporate architectural components and ports, and en\u00adforce \ncommunication integrity using a type system [8, 32]. Aldrich et al. previously studied Aphyds and identi\u00ad.ed \nsimilar architectural violations, but only after they re\u00adengineered it to ArchJava [8]. ArchJava speci.es \nin code architectural hierarchy and instances. In ArchJava, an ob\u00adject is architecturally signi.cant \nif its declared type is a component class. However, in ArchJava, a method can neither take as an argument, \nnor return a reference to an instance of a component class. Because real object\u00adoriented code passes \naround object references liberally, using ArchJava in an existing Java code base is harder than simply \nconverting each Java class into an ArchJava component class [5]. Adopting ArchJava often requires a non-trivial \nre-engineering that changes how objects are passed around. When using ArchJava, one may de.ne ad\u00additional \ncomponent classes to capture the intended sys\u00adtem decomposition. For Aphyds, Aldrich et al. speci.ed \n20 ArchJava component classes and over 80 ports, re\u00adengineered the program to obey ArchJava s restrictions, \nand inadvertently injected defects [8]. SCHOLIA achieves hierarchy using annotations and with\u00adout additional \nclasses. In SCHOLIA, all objects are instances of regular Java classes, and there are no restrictions \non pass\u00ading object references. The more architectural objects are higher in the ownership hierarchy. \nIn particular, logical con\u00adtainment can impose an arbitrary hierarchy on an object graph, and allows \nSCHOLIA to support arbitrary object\u00adoriented code better. Of course, specifying strict encapsu\u00adlation \nto avoid the representation exposure may require a change to the code, e.g., to return a copy of an internal \nlist instead of an alias [7]. During our Aphyds evaluation, we only added annotations. Could any other \nstatic approach .nd the violations that SCHOLIA found? It is a genuine threat to validity to compare \na designed runtime architecture to a built code architecture, or vice versa. All previous static conformance \napproaches, e.g., [28], address the code architecture. The closest to a stat\u00adically extracted runtime \narchitecture for an object-oriented system would be an object graph extracted by a static anal\u00adysis, \nwhether it uses annotations [20] or not [17, 29]. All previous graphs with the exception of our own \nprevious work [4] are .at, and would not convey enough architec\u00adtural abstraction to enable conformance \nanalysis. Of course, we could compare SCHOLIA s results to those obtained by a dynamic analysis [34, \n33]. But a dynamic analysis cannot claim to represent all possible executions. Could a conformance analysis \nof the code architecture detect all the violations in a runtime architecture? For ex\u00adample, could Re.exion \nModels (RM) [28] .nd all the vio\u00adlations that SCHOLIA found? In fact, we modeled SCHO-LIA closely after \nRM, which is a standard bearer in analyz\u00ading the conformance of code architectures. In RM, a third\u00adparty \ntool extracts a source model from the implementation. A developer posits an as-designed high-level model \nand a map between the source and high-level models. RM pushes each interaction described in the source \nmodel through the map to infer edges between high-level model entities. RM then compares the inferred \nedges with the edges stated in the high-level model. There are similarities between SCHOLIA and RM. For \nexample, WARN is similar to how RM tracks unmapped entries in the source model. A major difference is \nthat RM is designed for the code architecture. There are also several minor differences. For example, \nRM has no divergent or absent nodes. In RM, if the map generates a node that is not the designed view, \nRM automatically adds that node to the designed view. In other words, RM has no divergent or absent nodes, \nnor does it compute summary edges. To our knowledge, other static conformance checking techniques of \nthe code architecture are not more expressive than RM. In Aphyds, many important classes are instantiated \nonce, so for those classes, the object graph is somewhat similar to a class diagram with associations. \nOf course, there are still non-trivial differences related to the different instan\u00adtiations of the various \ncontainer classes such as Vector. Out of curiosity, we ran jRM [18] on Aphyds. jRM sup\u00adports neither \ntiers nor hierarchical target architectures, so we used a simpli.ed high-level model without tiers and \nignored Circuit s substructure. Indeed, RM found the divergence from placer to placeRouteUI, because \nit corresponds to a di\u00adrect .eld reference declared in class Placer. However, RM showed absences between \nviewerUI and .oorPlanUI instead of the correct divergences and convergences (See RM s out\u00adput for Aphyds \nin [1, Chap. 7]). In the OOG, a ViewerUI object does not directly point to a FloorPlanUI object. Instead, \na ViewerUI points to a Displayer, and Displayer references a FloorPlanUI. Moreover, Displayer is in a \npublic domain of ViewerUI.  When ViewerUI s substructure is elided, the OOG lifts that relation to ViewerUI, \nand shows a lifted edge from ViewerUI to FloorPlanUI, shown as a dotted edge in the OOG (Figs. 21, 15). \nSimilarly, RM would not correctly handle circuit s sub\u00adstructure, such as the communication between node \nand net. Unlike RM, SCHOLIA distinguishes the Vector of Terminalsinside Net from the one inside Node, \nand this distinction produces the communication between Node, Net and Terminal. Then, SCHOLIA represents \nthe communica\u00adtion between node and net through edge lifting and summary connectors. Thus, in general, \na tool for the code architecture cannot handle the runtime architecture. Does SCHOLIA generate many false \npositives? False pos\u00aditives are possible in general, but SCHOLIA attempts to re\u00adduce them. For example, \nthe edges in an OOG are more precise than super-imposing associations from a class dia\u00adgram. Also, SCHOLIA \nanalyzes only matching substructures, and not the entire object hierarchy. There are several sources \nof false positives in SCHOLIA. The OOG extraction uses a whole-program and not a reachability analysis \nthat excludes infeasible paths. Also, the conformance analysis may add summary edges that are false positives, \nas in the .rst itera\u00adtion which had 97 summary edges. But if the built and the designed architectures \nhave a similar hierarchical decom\u00adposition and a similar number of components at each hi\u00aderarchy level, \nthe analysis adds fewer summary edges. In\u00addeed, the second iteration had only 2 summary edges, and neither \none was a false positive. In our Aphyds evaluation, we used CodeTraceJ to trace each .nding to the code, \nand con.rmed that it does not correspond to an obvious false positive. Aphyds was written by a professor \nfor one of his classes. So this may explain the absence of infeasible paths. External validity. Can SCHOLIA \n.nd architectural viola\u00adtions in other systems? Yes. We have applied SCHOLIA to two other systems. Due \nto space limits, we highlighted here the Aphyds evaluation. The others are available in the .rst author \ns dissertation [1, Chap. 7]. JHotDraw (15 KLOC) is designed by experts in object-oriented analysis and \ndesign. HillClimber (15 KLOC) is designed by undergraduates, and was previously re-engineered to ArchJava \nto specify its ar\u00adchitecture [5]. We also added annotations to, and extracted OOGs from LbGrid, a 30-KLOC \nmodule that is part of a 250-KLOC commercial system [3]. The architects did not provide us, however, \nwith a designed runtime architecture, so we could not analyze it. In all the architectures we analyzed, \nSCHOLIA found many omitted components or connections. For example, the JHotDraw architecture omitted \ncomponents that were added later to support undoing commands. Can SCHOLIA analyze architectures that \nspecify .ne\u00adgrained object structures or multiplicities? An OOG and its abstracted C&#38;C view provide \narchitectural abstraction by merging equivalent instances in a domain or tier. So SCHOLIA cannot express \nvery .ne-grained object structures. Similarly, as with most static object diagrams, SCHOLIA does not \nprovide any precision regarding multiplicities. Would an outside developer understand the SCHOLIA technique? \nUntil there are better tools for adding annota\u00adtions, our approach does not have the characteristic of \nRe\u00ad.exion Models that third-party users can easily run on large code bases [28]. As a result, a study \nwith an outside de\u00adveloper would be dif.cult given the nature of the approach. We did, however, conduct \na .eld study and con.rmed that, indeed, an outside professional programmer understood ab\u00adstraction by \nownership hierarchy and by types [3]. Admittedly, the need to iteratively improve the annota\u00adtions, .ne-tune \nhow an OOG is abstracted into a C&#38;C view, and follow all the steps in the tool chain may be a chal\u00adlenge \nto the average developer. However, this situation is not unique to SCHOLIA. For example, previous work \non code ar\u00adchitectures using semi-automated clustering algorithms, re\u00adquired that developers spend signi.cant \neffort .ne-tuning the clustering parameters to derive a good match [9]. In SCHO-LIA, a developer uses \nannotations to control the abstraction and does not rely on a tool s hard-coded heuristics. Is SCHOLIA \nmore lightweight than other static con\u00adformance approaches? For example, is adding ownership annotations \nto an existing system less invasive than re\u00adengineering it to ArchJava to expose its architecture? Our \npreliminary evidence showed that to be the case [5]. The annotations, unlike ArchJava, do not change \nthe system s runtime semantics, and support common object-oriented id\u00adioms, such as passing references \nto objects. For example, an ArchJava component class cannot have public .elds. When using ownership annotations, \nsuch legal Java .elds can be placed in public domains. Aldrich et al. added own\u00adership types to the model \npart of Aphyds (3.5 KLOC) in 4 hours, a quarter of the time they spent re-engineering that same part \nto ArchJava [8]. To more reliably estimate the annotation effort, we con\u00adducted a week long on-site .eld \nstudy. The .rst author spent 35 hours adding annotations and extracting OOGs from the 30-KLOC LbGrid \nmodule (WARN is still high). Based on our previous experience with ArchJava [5], we could not have re-engineered \nLbGrid to ArchJava in the same few days that it took us to add the annotations, even after accounting \nfor possible tool and language familiarity. Thus, adding an\u00adnotations to an existing system seems more \nlightweight than re-engineering it to use an extended language like ArchJava. Would SCHOLIA work with \nan ownership type system other than ownership domains? In principle, SCHOLIA could use a type system \nthat assumes a single context per object [10]. There is, however, a crucial expressiveness ad\u00advantage \nin ownership domains that can reduce the number of objects in the top-level domains. In an owner-as-dominator \ntype system, any access to a child object must go through its owning object [10]. In contrast, ownership \ndomains sup\u00adport pushing almost any object underneath any other object in the ownership hierarchy. A \nchild object may or may not be encapsulated by its parent object: a child object can still be referenced \nfrom outside its owner if it is part of a public domain of its parent, or if a domain parameter is linked \nto a private domain [7]. SCHOLIA can readily use an ownership type system such as Simple Loose Ownership \nDomains [31], which enforces a boundary-as-dominator property.  For arbitrary object-oriented implementation \ncode, it is easier to use logical containment with public domains, rather than the strict encapsulation \nof private domains and both can reduce the number of objects in the top-level domains. Why structural \ncomparison? SCHOLIA compares the de\u00adsigned and the built architectures using a structural com\u00adparison \nthat works with hierarchical views, does not as\u00adsume unique identi.ers, detects renames and allows forc\u00ading \nor preventing matches between selected view elements. These assumptions closely match the problem of \nanalyz\u00ading conformance after the fact. SCHOLIA does not assume that the architectural components have \nunique identi.ers, which would simplify the graph comparison considerably [12]. Using structural comparison \nenables SCHOLIA to de\u00adtect renames between the built and the designed architec\u00adtures, which can partly \noccur due to the OOG extraction. The OOG extraction nondeterministically selects a label for a given \nobject o based on the name or the type of one of the references in the program that points to o. Thus, \ndetecting renames ensures a developer can still rename .elds or local variables or types without impacting \nconformance. Avoiding the rename problem would require additional annotations to specify in code the \ndisplayed labels. Assumptions. SCHOLIA makes the following assumptions: Sources available: The program \ns whole source code and portions of external libraries that are in use have anno\u00adtations that typecheck; \n Single entry point: The program operates by creating a main object. The class of that object declares \ndomains, but has no domain parameters;  Summarized external entities: Re.ection, dynamic code loading \nor native calls may introduce unknown objects and edges into the system. Such external entities can be \nsummarized using virtual .eld annotations [2].  Limitations. SCHOLIA has the following limitations: \nAnnotations. The manual annotation effort is a poten\u00adtial obstacle for practical adoption, but ownership \nannota\u00adtions are amenable to automated ownership inference, which could alleviate this problem, at least \npartially [23]. With pre\u00adcise and scalable ownership inference, SCHOLIA can scale to large systems. Architectural \nextraction. SCHOLIA applies to applica\u00adtions that run in a single virtual machine, so it handles nei\u00adther \nheterogeneous nor distributed systems, nor does it ad\u00address dynamic architectural recon.guration. Structural \ncomparison. If the views are very different, an automated structural comparison may fail to match the \nbuilt and the designed views. In that case, the comparison will not be useful since all components will \nbe absences. One can then manually match some view elements at the cost of additional effort. Finally, \nthe algorithm is quadratic in the view sizes. So, while it scales to up to a few thousand nodes [6], \nvery large architectures may be intractable. 10. Related Work View synchronization. Our conformance analysis \nspecial\u00adizes our view synchronization work [6]. The key changes include: (a) processing the view differences \nmore selectively (Section 7), such as skipping unmatched hierarchical de\u00adcompositions, instead of making \nthe two views identical; (b) computing summary connectors; and (c) including tiers in the hierarchical \ndata used by the structural comparison, i.e., a Component or a Connector is a child of its owning Group. \nWe observed empirically that this extra level of hierarchy improves the precision of the structural comparison, \nand en\u00adables it to distinguish better the connectors within a given tier (which would belong to the same \nGroup) from the ones that cross tiers (which would not be inside a Group). Code architecture. Several \napproaches analyze the confor\u00admance of code architectures, e.g., [28]. Generally, an ap\u00adproach designed \nfor the code architectures, e.g., [28], can\u00adnot handle correctly the runtime architecture. However, sev\u00aderal \ntechniques we used, namely hierarchy, lifted edges and summary edges, have previously been applied to \ncode ar\u00adchitectures. We showed how the above techniques translate naturally to runtime architectures. \nHierarchy. Re.exion Models (RM) uses non-hierarchical high-level models and maps. Koschke et al. extended \nRM with hierarchical models [19]. In SCHOLIA, all the repre\u00adsentations are hierarchical. Lifted edges. \nApproaches that handle code architectures also lift edges [19, 37], for example, from a function call \nto a module. We use edge lifting in several places: an OOG lifts object relations from child objects \nto their parents; and a C&#38;C view also lifts edges from inner components (Fig. 17). Summary edges. \nOmmering et al. create a second mod\u00adule view that displays the transitive closure of a relation in one \nmodule view [37]. Our summary edges (Fig. 14) or sum\u00admary connectors (Fig. 19) show transitive communication. \nDynamic analyses. Several approaches uses dynamic analy\u00adsis to extract the built architecture [33, 13] \nor monitor con\u00adformance [22, 34]. For example, DISCOTECT [33] recov\u00aders from a running system a built \nC&#38;C view that has ar\u00adchitectural types. In place of annotations, DISCOTECT re\u00adquires rules that map \nentries in a runtime trace to architec\u00adtural events, e.g., a method invocation leads to the creation \nof a port. In DISCOTECT, it may be possible to reuse a mapping across several similar systems, which \nis not the case with our annotations. Because DISCOTECT is a dynamic analysis, the results re.ect only \nthe particular inputs and exercised use cases. Also, DISCOTECT generates non-hierarchical C&#38;C views \nthat show one component for each instance created at runtime. Finally, DISCOTECT only extracts built \nviews and does not analyze conformance.  Several dynamic analyses infer hierarchical object graphs without \nusing annotations, e.g. [16], but their results de\u00adscribe only the structure for those program runs. \nThey also adopt restrictive notions of ownership which cannot express many design idioms. The expressiveness \nin ownership do\u00admain avoids a built architecture with many components in the top-level tiers. Our evaluation \nshowed how crucial that can be for a meaningful conformance analysis. Code generation. Some approaches \nassume that developers always re.ne an architectural model into code to ensure conformance by design. \nSCHOLIA is designed to analyze the conformance of an arbitrary system after the fact, requiring only \nannotations. Static analysis. Lam and Rinard proposed a type system and a static analysis (LR) that uses \nnon-ownership annotations to extract non-hierarchical object graphs [20] (LR does not analyze conformance). \nLR supports a .xed set of statically declared global tokens, and the result of the analysis is a graph \nshowing which objects appear in which tokens. Using token parameters, the same code element can be mapped \nto different design elements depending on context. Unlike ownership domains, LR has a statically .xed \nnumber of tokens, all at the top level, so LR cannot show hierarchy. For Aphyds, LR would produce an \nobject graph with even more top-level objects than Fig. 21, which would make it even less suitable for \nconformance analysis. Our previous work. We previously presented an earlier de.nition of the extraction \nstatic analysis, using an alternate formalization based on rewriting rules [4]. This paper s ver\u00adsion \nis different in several respects. Here, we use abstract interpretation, which makes the analysis more \ncomparable to previous points-to analyses. The soundness proof now in\u00adcludes edges. This more principled \nformalization side-steps determining a depth at which to cutoff the recursion and the potential unsoundness \nof selecting an incorrect depth. The earlier system proved partial soundness on an intermediate cyclic \nrepresentation, which is then projected or unfolded into a graph that the user sees. Points-to analysis. \nAll previous points-to analysis pro\u00adduce non-hierarchical graphs [36, 27]. Our static analysis is similar \nto a .ow-insensitive Andersen-style points-to anal\u00adysis. The state-of-the-art is considered an object-sensitive \nanalysis [27]. Our analysis is object-insensitive but can be considered domain-sensitive, since it distinguishes \nbetween objects in different domains. Since domains are coarser\u00adgrained than objects, our analysis is \nmore scalable than an object-sensitive one. However, our analysis suffers from some of the imprecisions \nthat object-sensitivity addresses such as .eld assignment through a superclass [27]. Although points-to \nanalysis is often used for compiler optimization, its value for program understanding has been recognized \n[36]. In the same vein as SCHOLIA, Milanova [26] uses the results of a points-to analysis to construct \nan Object Relation Diagram, which is a class diagram where the type of the pointed-to object is potentially \nmore precise than the declared type. To our knowledge, SCHOLIA is the .rst approach to abstract the output \nof a static points-to analysis into a hierarchical runtime architecture represented as a standard Component-and-Connector \n(C&#38;C) view, then using that to analyze conformance of runtime architectures. Shape analysis. Shape \nanalysis, e.g., [30] produces very precise shape graphs consisting of nodes to represent a set of objects, \nand edges to represent points-to relations. However, a shape graph is non-hierarchical: all the nodes \nare at the same level, and objects are not collapsed underneath other objects. This works well in an \nintra-procedural case to show that a method preserves the list-ness of a data structure it takes as a \nparameter. Moreover, a heavyweight shape analy\u00adsis may also achieve more precision than SCHOLIA in many \ncases. But a .at object graph will not scale to an entire sys\u00adtem. Although SCHOLIA sacri.ces some precision \nto gain scalability of the analysis, it conveys architectural abstrac\u00adtion primarily through hierarchy. \n 11. Conclusion SCHOLIA is the .rst approach to extract statically a hierar\u00adchical runtime architecture \nfrom a program in a widely used object-oriented language, using annotations. If an intended architecture \nexists, SCHOLIA can also analyze, at compile\u00adtime, communication integrity between the code and the target \narchitecture. In practice, SCHOLIA found interesting structural differences between existing systems \nand their tar\u00adget architecture. Our evaluation con.rms what others have reported [28, 8], that informal \ndiagrams often omit impor\u00adtant communication. Thus, analyzing conformance after the fact is practically \nrelevant during software evolution. Finally, SCHOLIA can establish traceability between an implementation \nand an intended runtime architecture. To our knowledge, SCHOLIA is the .rst approach that allows a developer \nto trace from an element such as a component or a port in a runtime architecture, extracted entirely \nstatically, to the corresponding lines of code in a general purpose object\u00adoriented language like Java. \nThis facility was available only when tracing from UML class diagrams to Java code. Until now, developers \nevolving an object-oriented system had to contend with high-level views of the code architecture or partial \nviews of the runtime architecture obtained using dynamic analysis. SCHOLIA now completes the picture. \nAcknowledgments. This work was supported in part by Aldrich s NSF CAREER award CCF-0546550, DARPA contract \nHR00110710019, and Army Research Of.ce grant number DAAD19-02-1-0389 entitled Perpetually Available and \nSecure Information Systems.  The authors thank the other Ph.D. thesis supervisors, Nenad Medvidovic, \nBrad A. Myers, and William Scherlis, as well as David Garlan, Bradley Schmerl and Mary Shaw.   References \n[1] M. Abi-Antoun. Static Extraction and Conformance Analysis of Hierarchical Runtime Architectural Struc\u00adture. \nPhD thesis, Carnegie Mellon University. Avail\u00adable as Technical Report CMU-ISR-09-119. [2] M. Abi-Antoun \nand J. Aldrich. Ownership Domains in the Real World. In IWACO, pages 93 104, 2007. [3] M. Abi-Antoun \nand J. Aldrich. A Field Study in Static Extraction of Runtime Architectures. In PASTE, 2008. [4] M. Abi-Antoun \nand J. Aldrich. Static Extraction of Sound Hierarchical Runtime Object Graphs. In Types in Lang. Design \nand Impl. (TLDI), pages 51 64, 2009. [5] M. Abi-Antoun, J. Aldrich, and W. Coelho. A Case Study in Re-engineering \nto Enforce Architectural Con\u00adtrol Flow and Data Sharing. J. Systems &#38; Software, 80(2):240 264, 2007. \n[6] M. Abi-Antoun, J. Aldrich, N. Nahas, B. Schmerl, and D. Garlan. Differencing and Merging of Architectural \nViews. Automated Software Eng., 15(8):35 74, 2008. [7] J. Aldrich and C. Chambers. Ownership Domains: \nSep\u00adarating Aliasing Policy from Mechanism. In ECOOP, pages 1 25, 2004. [8] J. Aldrich, C. Chambers, \nand D. Notkin. ArchJava: Connecting Software Architecture to Implementation. In ICSE, pages 187 197, \n2002. [9] A. Christl, R. Koschke, and M.-A. Storey. Equipping the Re.exion Method with Automated Clustering. \nIn WCRE, 2005. [10] D. G. Clarke, J. M. Potter, and J. Noble. Ownership Types for Flexible Alias Protection. \nIn OOPSLA, pages 48 64, 1998. [11] P. Clements et al. Documenting Software Architecture. Addison-Wesley, \n2003. [12] D. Conte, P. Foggia, C. Sansone, and M. Vento. Thirty Years of Graph Matching in Pattern Recognition. \nInt. J. Pattern Recognit. Artif. Intell., 18(3):265 298, 2004. [13] C. Flanagan and S. N. Freund. Dynamic \nArchitecture Extraction. In FATES-RV, 2006. [14] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. De\u00adsign \nPatterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1994. [15] D. Garlan et al. \nThe Acme Architectural Description Language. http://www.cs.cmu.edu/~acme. [16] T. Hill, J. Noble, and \nJ. Potter. Scalable Visualizations of Object-Oriented Systems with Ownership Trees. J. Visual Lang. and \nComput., 13(3):319 339, 2002. [17] D. Jackson and A. Waingold. Lightweight Extraction of Object Models \nfrom Bytecode. TSE, 27(2), 2001. [18] jRM. http://jrmtool.sourceforge.net, 2003. [19] R. Koschke and \nD. Simon. Hierarchical Re.exion Models. In WCRE, 2003. [20] P. Lam and M. Rinard. A Type System and Analysis \nfor the Automatic Extraction and Enforcement of Design Information. In ECOOP, pages 275 302, 2003. [21] \nS. Lee, G. Murphy, T. Fritz, and M. Allen. How can di\u00adagramming tools help support programming activities. \nIn VL/HCC, pages 246 249, 2008. [22] D. C. Luckham and J. Vera. An Event-Based Architec\u00adture De.nition \nLanguage. TSE, 21(9):717 734, 1995. [23] K.-K. Ma and J. S. Foster. Inferring Aliasing and Encapsulation \nProperties for Java. In OOPSLA, 2007. [24] N. Medvidovic, P. Oreizy, J. E. Robbins, and R. N. Tay\u00adlor. \nUsing Object-Oriented Typing to Support Architec\u00adtural Design in the C2 Style. In FSE, 1996. [25] N. \nMedvidovic and R. N. Taylor. A Classi.cation and Comparison Framework for Software Architecture Description \nLanguages. TSE, 26(1), 2000. [26] A. Milanova, A. Rountev, and B. G. Ryder. Construct\u00ading Precise Object \nRelation Diagrams. In ICSM, 2002. [27] A. Milanova, A. Rountev, and B. G. Ryder. Parameter\u00adized Object \nSensitivity for Points-To Analysis for Java. TOSEM, 14(1):1 41, 2005. [28] G. C. Murphy, D. Notkin, and \nK. J. Sullivan. Software Re.exion Models: Bridging the Gap between Design and Implementation. TSE, 27(4):364 \n380, 2001. [29] R. W. O Callahan. Generalized Aliasing as a Basis for Program Analysis Tools. PhD thesis, \nCMU, 2001. [30] M. Sagiv, T. Reps, and R. Wilhelm. Parametric Shape Analysis via 3-Valued Logic. In POPL, \n1999. [31] J. Sch\u00a8 A Parameterized afer and A. Poetzsch-Heffter. Type System for Simple Loose Ownership \nDomains. Journal of Object Technology, 5(6):71 100, 2007. [32] J. Sch\u00a8afer, M. Reitz, J.-M. Gaillourdet, \nand A. Poetzsch-Heffter. Linking Programs to Archi\u00adtectures: an Object-Oriented Hierarchical Software \nModel based on Boxes. In Common Component Modeling Example (CoCoME), pages 238 266, 2008. [33] B. Schmerl, \nJ. Aldrich, D. Garlan, R. Kazman, and H. Yan. Discovering Architectures from Running Sys\u00adtems. TSE, 32(7):454 \n466, 2006. [34] M. Se.ka, A. Sane, and R. H. Campbell. Monitoring Compliance of a Software System with \nits High-Level Design Models. In ICSE, pages 387 396, 1996. [35] M.-A. Storey, C. Best, and J. Michaud. \nSHriMP Views: An Interactive Environment for Exploring Java Pro\u00adgrams. In IWPC, page 111, 2001. [36] \nP. Tonella and A. Potrich. Reverse Engineering of Object Oriented Code. Springer-Verlag, 2004. [37] R. \nvan Ommering, R. Krikhaar, and L. Feijs. Lan\u00adguages for Formalizing, Visualizing and Verifying Soft\u00adware \nArchitectures. Computer Languages, 27(1-3):3 18, 2001.  \n\t\t\t", "proc_id": "1640089", "abstract": "<p>An object diagram makes explicit the object structures that are only implicit in a class diagram. An object diagram may be missing and must extracted from the code. Alternatively, an existing diagram may be inconsistent with the code, and must be analyzed for conformance with the implementation. One can generalize the <i>global</i> object diagram of a system into a runtime architecture which abstracts objects into components, represents how those components interact, and can decompose a component into a nested sub-architecture.</p> <p>A static object diagram represents all objects and inter-object relations possibly created, and is recovered by static analysis of a program. Existing analyses extract static object diagrams that are non-hierarchical, do not scale, and do not provide meaningful architectural abstraction. Indeed, architectural hierarchy is not readily observable in arbitrary code. Previous approaches used breaking language extensions to specify hierarchy and instances in code, or used dynamic analyses to extract dynamic object diagrams that show objects and relations for a few program runs.</p> <p>Typecheckable ownership domain annotations use existing language support for annotations and specify in code object encapsulation, logical containment and architectural tiers. These annotations enable a points-to static analysis to extract a sound global object graph that provides architectural abstraction by ownership hierarchy and by types, where architecturally significant objects appear near the top of the hierarchy and data structures are further down.</p> <p>Another analysis can abstract an object graph into a built runtime architecture. Then, a third analysis can compare the built architecture to a target, analyze and measure their structural conformance, establish traceability between the two and identify interesting differences.</p>", "authors": [{"name": "Marwan Abi-Antoun", "author_profile_id": "81100299343", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1728779", "email_address": "", "orcid_id": ""}, {"name": "Jonathan Aldrich", "author_profile_id": "81100454133", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1728780", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640113", "year": "2009", "article_id": "1640113", "conference": "OOPSLA", "title": "Static extraction and conformance analysis of hierarchical runtime architectural structure using annotations", "url": "http://dl.acm.org/citation.cfm?id=1640113"}