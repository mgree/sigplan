{"article_publication_date": "10-25-2009", "fulltext": "\n Debug All Your Code: Portable Mixed-Environment Debugging Byeongcheol Lee Martin Hirzel Robert Grimm \nKathryn S. McKinley University of Texas at Austin IBM Watson Research Center New York University University \nof Texas at Austin bclee@cs.utexas.edu hirzel@us.ibm.com rgrimm@cs.nyu.edu mckinley@cs.utexas.edu Abstract \nProgrammers build large-scale systems with multiple lan\u00adguages to reuse legacy code and leverage languages \nbest suited to their problems. For instance, the same program may use Java for ease-of-programming and \nC to interface with the operating system. These programs pose signi.cant debugging challenges, because \nprogrammers need to under\u00adstand and control code across languages, which may execute in different environments. \nUnfortunately, traditional multi\u00adlingual debuggers require a single execution environment. This paper \npresents a novel composition approach to building portable mixed-environment debuggers, in which an intermediate \nagent interposes on language transitions, controlling and reusing single-environment debuggers. We implement \ndebugger composition in Blink, a debugger for Java, C, and the Jeannie programming language. We show \nthat Blink is (1) relatively simple: it requires modest amounts of new code; (2) portable: it supports \nmultiple Java Virtual Machines, C compilers, operating systems, and component debuggers; and (3) powerful: \ncomposition eases debugging, while supporting new mixed-language expression evalua\u00adtion and Java Native \nInterface (JNI) bug diagnostics. In real\u00adworld case studies, we show that language-interface errors require \nsingle-environment debuggers to restart execution multiple times, whereas Blink directly diagnoses them \nwith one execution. We also describe extensions for other mixed\u00adenvironments to show debugger composition \nwill generalize. Categories and Subject Descriptors D.3.4 [Programming Languages]: Processors Debuggers; \nD.2.5 [Software En\u00adgineering]: Testing and Debugging Debugging aids General Terms Languages, Design, \nReliability Keywords Foreign Function Interface, JNI, Composition Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 2009, October 25 29, 2009, Orlando, \nFlorida, USA. Copyright c &#38;#169; 2009 ACM 978-1-60558-734-9/09/10. . . $10.00. 1. Introduction In \nan ideal world, programmers would write correct pro\u00adgrams in a single language. In the real world, time-to\u00admarket \npressures and evolving software requirements re\u00adsult in mixed-language programs. Software developers \nre\u00adsort to multiple languages because (1) they can leverage legacy code and existing libraries, and (2) \nthey can choose a language well-suited to their needs for new code. Large programs are hard to get correct, \neven when written in a sin\u00adgle language, because an individual developer is typically an expert on only \na small fraction of the code. Mixed-language programs require additional developer expertise, and lan\u00adguage \ninterfaces add another source of errors. For example, the literature reports hundreds of mixed-language \ninterface bugs [6, 7, 13, 29]. Unfortunately, traditional debuggers are not much help with mixed-language \nprograms, because they are limited to a single execution environment. For example, native programs and \ntheir debuggers (e.g., the gdb debugger for C, C++, and Fortran) require language implementations to \nuse the same Application Binary Interface (ABI). The ABI is machine de\u00adpendent and thus precludes portable \nexecution environments for managed languages, such as Java, C#, Ruby, JavaScript, and Python, which enforce \ntype and memory safety. For portability, these languages rely on virtual machine (VM) execution, using \ninterpretation, just-in-time compilation, and garbage collection, while also hiding internal code, stack, \nand data representations. Debuggers for managed lan\u00adguages, such as the standard Java debugger jdb, operate \non VM abstractions, e.g., through the Java Debug Wire Protocol (JDWP), but do not understand native code. \nCurrent mixed\u00adlanguage debuggers are limited to XDI and dbx, which sup\u00adport Java and C within a single \nJVM [18, 27], and the Visual Studio debugger, which supports managed and native code in the Common Language \nRuntime (CLR) [22]. While these debuggers understand all environments, they are behemoths that are not \nportable. The challenge when building a mixed\u00adenvironment debugger is that each environment has different \nrepresentations; managed debuggers operate at the level of bytecodes and objects, whereas native debuggers \ndeal with machine instructions and memory words. This paper presents a novel debugger composition runtime \ninterposition erating systems (Unix and Windows). By comparison, Harmony JVM. mixed-language programs. \nTo summarize, the contributions of this work are: gers that composes single-environment debuggers. Prior \ndebuggers either support only a single environment or re\u00adimplement functionality instead of reusing it. \n2. Blink, an implementation of this approach for Java, C, and Jeannie, which is simple, portable, powerful, \nand open source [9]. 3. Two advanced new debugger features: a mixed-environ\u00adment interpreter and a dynamic \nchecker for detecting JNI misuse. 4. A description of the requirements and mechanisms for composing \nlanguage execution environments that lays the groundwork for generalizing debugger composition.  2. \nMotivation: A Language Interface Bug This section illustrates that debugging across language in\u00adterfaces \nwith current tools is at best painful and that Blink signi.cantly improves the debugging experience. \nConsider the code in Figure 1, which distills fragments from the Eclipse SWT windowing toolkit and the \njava\u00adgnome Java binding for the GNOME desktop to illustrate a Figure 1. Example bug: a typo in Java code \n(Line 15) causes a crash in C code (Line 31). common class of JNI bugs that is due to JNI s re.ection-like \nAPI [8]. Execution starts at Line 6 in Java code. Line 8 calls the dispatch method, passing either \"mouseEvent\" \nor \"keyboardEvent\" as a parameter. The dispatch method is declared in Java (Line 10) but de.ned in C \n(Line 20). Line 22 calls another C function, call_java_wrapper, de\u00ad.ned in Line 24. Line 28 looks up \nthe Java method identi\u00ad.er (mid) based on the parameter string. This lookup fails for \"keyboardEvent\" \nbecause of the capitalization error (Line 15 expects \"keyBoardEvent\"). With the current state of the \nart, this bug is dif.cult to diagnose. For example, exe\u00adcuting Sun s JVM with the -Xcheck:jni .ag results \nin the following output: FATAL ERROR in native method: JNI call made with exception pending at EventHandlerBug.dispatch(Native \nMethod) at EventHandlerBug.main(EventHandlerBug.java:8) This call stack shows only Java line numbers, \nand does not mention the C function call_java_wrapper where the error occurs. The user would at best \ninspect the code to .nd JNI calls, and then re-execute the program with break\u00adpoints potentially on all \nJNI operations. Existing static bug\u00addetectors do not .nd this problem either, because they do not currently \nhandle the array lookup and string manipulation on Line 8, which are dif.cult to analyze statically [7, \n13, 30]. Blink improves over both approaches it detects the in\u00advalid JNI usage, automatically inserts \na breakpoint, and prints the following diagnostic message: JNI warning: Missing Error Checking: CallStaticVoidMethod \n [1] call_by_name_wrapper (EventHandlerBug.c:31) [2] Java_EventHandlerBug_dispatch (EventHandlerBug.c:22) \n [3] EventHandlerBug.main (EventHandlerBug.java:8) blink> _ This message shows the mixed C and Java \nstack, and iden\u00adti.es the call at Line 31 as erroneous. Since mid is invalid, the user would next determine \nthat mid is derived from the string cstr and print cstr: blink> print cstr \"keyboardEvent\" Variable \ncstr holds \"keyboardEvent\" instead of \"key-BoardEvent\", but where does that value come from? Line 8, \nmentioned in the original stack trace, contains the expression EVENT_NAMES[idx]+\"Event\". To examine the \nJava array from the C breakpoint, the user employs Blink s mixed\u00adlanguage expression evaluation as follows: \nblink> print EventHandlerBug.EVENT_NAMES[1] \"keyboard\" To .x the bug, the user would either change the \nstring in EVENT_NAMES[1] or the method name in Line 15. 3. Debugger Composition Approach This section \ndescribes our approach to building mixed\u00adenvironment debuggers by composing them out of single\u00adenvironment \ndebuggers. We use our implementation of Blink for Java and C as our running example. Section 6 presents \nrequirements and mechanisms for generalizing composition to other mixed-language environments. 3.1 Debugger \nFeatures Our goal is to provide all the standard debugging features in a mixed environment. When a user \ndebugs a program, she wants to .nd and correct a defect that results in erroneous data or control .ow, \nwhich leads to erroneous output or a crash [37]. Rosenberg identi.es three essential features in support \nof this quest [20]: Execution control: The debugger controls the execution of the debuggee process by \nstarting it, halting it at break\u00adpoints, single-stepping through it, and eventually tearing it down. \nTypical interactive commands are run, break, step, continue, and exit. Context management: The debugger \nkeeps track of where in the code the debuggee process is, and, on demand, Figure 2. Agent-based debugger \ncomposition approach. reports source code listings and call stack traces. Typical interactive commands \nare list and backtrace. Data inspection: Users query the debugger to inspect data with source language \nexpressions, such as print or eval. 3.2 Intermediate Agent Our approach to implementing these standard \ndebugger features for a mixed environment is to compose single\u00adenvironment debuggers through an intermediate \nagent. The mixed-environment debugger consists of a controller and one driver for each single-environment \ncomponent debug\u00adger. Figure 2 illustrates this structure for the case of Java and C using jdb for Java, \nand gdb or cdb for C (depending on whether we run on Linux or Windows). The debuggee process runs both \nJava and C, and the intermediate agent coordinates the debuggers. The intermediate agent has two complementary \nresponsibilities: Language transition interposition: When the debuggee switches environments on its own, \nthe agent alerts the corresponding single-environment debugger, so this de\u00adbugger can track context or \ntake over if necessary. Debugger context switching: When an interactive user com\u00admand requires the debugger \nto switch environments, the agent transitions the debuggee into the appropriate state, and issues the \ncommand to the appropriate single\u00adenvironment debugger. The following subsections detail the agent responsibilities \nand how to satisfy them.  3.3 Language Transition Interposition Language transition interposition is \nrequired for execution control, because otherwise single-stepping is incomplete. Consider a Java and \nC debuggee suspended at a Java break\u00adpoint: the Java debugger is in charge and the C debugger is dormant. \nA single-step on a return statement to C causes a language transition to C. The agent must detect this \ntransi\u00adtion, because otherwise the Java debugger waits for control to return to Java code while the C \ndebugger remains dor\u00admant. Language transition interposition is also required for con\u00adtext management, \nbecause otherwise stack traces are incom\u00adplete. Language transitions result in different portions of \nthe stack belonging to different environments, but each single\u00adenvironment debugger understands only \nthe portions corre\u00adsponding to its own language. To prepare for reporting the entire mixed-language stack, \nthe agent must track all the seams. Therefore, the agent must capture all environment transi\u00adtions, whether \nthey are debuggee-or user-initiated. With two languages, there are four kinds of local transitions: mixed\u00adlanguage \ncalls and returns (e.g., Java call to C, C call to Java, Java return to C, and C return to Java). The \nagent must also capture non-local control .ow such as exceptions. Our approach instruments all environment \ntransitions to call agent code. For instance, in Figure 2, we interpose on transitions between Java and \nC code, instrumenting them to call the agent. One option for realizing this instrumentation is to modify \nthe compiler or interpreter. However, to achieve portability across different JVMs and C compilers, we \ndo not want to modify them. Instead, we leverage the fact that Java s foreign function interface (FFI) \nis wrapper-based and instrument the wrappers.  3.4 Debugger Context Switching When one single-environment \ndebugger is active and the user issues a command that only the other debugger can perform, the agent \nmust assist in debugger context switch\u00ading. For example, when the program is at a breakpoint in Java \nand the user wants to set a breakpoint in C, the agent must suspend the Java debugger and issue the command \nto the C debugger. Similarly, commands such as backtrace and print require one or more context switches \nto tap into functionality from both single-environment debuggers. We switch debugger contexts with the \nfollowing steps: 1. Set a breakpoint in a helper function in the other environ\u00adment. 2. Call the helper \nfunction using expression evaluation. 3. At the breakpoint, activate the other debugger. 4. When the \nother debugger completes, return from the helper function, which returns control back to the original \ndebugger.   Figure 3. Debugger context switching example, using j2c helper function to switch from \njdb to gdb/cdb. Blink also has a c2j helper function for switching in the other direction. Figure 3 illustrates \ncontext switching on the example of switching from jdb to gdb. Each vertical line represents an execution \ncontext, with the currently active context marked by a box overlaying the line. Horizontal arrows show \ncontrol transfers between execution contexts. From top to bottom, the application starts out executing \nJava code and hits a Java breakpoint, thus suspending itself and activating jdb. Now, suppose the user \nrequests a gdb debug action. At the moment, gdb is inactive and cannot accept user commands. Blink therefore \ninitiates a debugger context switch by using the jdb function evaluation feature to call the debugger \nagent method j2c. The method j2c is a Java method that uses JNI to call C and has a breakpoint in the \nC part of the code. When execution hits the C breakpoint, gdb is activated, and can perform the debug \naction requested by the user. When complete, gdb s continue returns from the C code and Java method, \nat which point jdb wakes up again and is ready to accept commands. The user can either request additional \ndebugging actions in Java or C, or resume normal application execution with continue. 3.5 Soft-Mode \nDebugging Debugger composition requires soft-mode debugging, in which the debuggee process executes basic \ncommands, such as break, step, and backtrace, on behalf of the debugger. In contrast, hard-mode debugging \ndoes not require the de\u00adbuggee to run code on the debugger s behalf, except when users explicitly request \nit, for example, with a command to evaluate a function call. Debuggers for C, including gdb and cdb, \nare typically hard-mode. Java debuggers are typically soft-mode because Java s JDWP (Java Debugger Wire \nPro\u00adtocol) expects an agent in the JVM that issues commands to the debuggee. Soft-mode debugging is \nless desirable than hard-mode because running code in the debuggee changes debuggee state and behavior, \nand may thus lead to Heisenberg effects. The very act of debugging may change the behavior of the bug. \nNotably, the user may set a breakpoint in a C library shared by the application and JVM. The user expects \nto reach the breakpoint through a JNI call, but JVM code may instead reach the breakpoint through internal \nservice code. Since the JVM is typically not reentrant (i.e., it assumes that no user code runs in the \nmiddle of a JVM service), debugger actions may now crash the JVM. For example, the JVM s allocator may \ntemporarily leave a data structure in an in\u00adconsistent state, thus making it unsafe for the agent to \nal\u00adlocate objects. Furthermore, even if the native breakpoint is not reachable from the JVM, JNI disallows \nJNI operations when exceptions are pending or garbage collection is dis\u00adabled. Reentering the JVM without \n.rst clearing the excep\u00adtion or re-enabling garbage collection may crash or deadlock the system [13, \n14]. Blink mitigates its use of soft-mode debugging by warn\u00ading users on actions that might trigger a \nsoft-mode incon\u00adsistency. Debugging actions in C are safe as long as the program entered native code \nthrough JNI, exceptions are cleared, and garbage collection is enabled. Since we already rely on language \ninterposition, we detect whether the JVM is in a safe state. If the debugger is about to perform an action \nin C, but the JVM is in an unsafe state, the debugger warns the user. Instead of just warning the user, \nwe could refuse to perform debug actions altogether. We chose a warning over refusal since unreliable \ninformation is better than no infor\u00admation. 4. Advanced Features This section shows how interposition \nfor composition fa\u00adcilitates two advanced debugging features: (1) identifying mixed-language interface \nerrors, and (2) mixed-language ex\u00adpression evaluation, which helps users manipulate and ex\u00adamine state \nacross multiple languages. 4.1 Environmental Transition Checker Interposition makes it easy to control \nand compose debug\u00adgers, and it also makes it easy to add dynamic checks that .nd language interface bugs. \nThis section demonstrates how to build a powerful Environmental Transition Checker that detects two common \nlanguage interface bug classes: (1) un\u00adcaught exceptions, and (2) unexpected null values. We leave to \nfuture work the exploration of more powerful bug .nders. Dynamic checking is complementary to static \nanalysis: dynamic checking misses true bugs if code is not executed, whereas static analyses report some \nfalse bugs that can never occur. At the same time, dynamic checking has the advan\u00adtage that it does not \nneed to access the whole program s source code, unlike static analysis [13, 29]. At failure points, our \ndynamic checker prints the mixed-environment calling context and local variables, which are important \nclues to .nding the root cause. In the case of Java and C, the boundary is de.ned by the Java Native \nInterface (JNI), and we classify bugs as either Java-to-C or C-to-Java. We focus here on C-to-Java bugs. \nJNI s API is complex and brittle; consequently, it is a major source of bugs [8, 13, 29, 30]. Programmers \ntend to make mistakes with respect to the Java type system and do not carefully follow the JNI rules \n[14]. For instance, C code must correctly name .elds or methods of Java objects, which cannot be easily \nchecked statically because of dynamic class loading. Programmers must also ensure that the JVM has no \npending exception when the program calls a JNI function. The JNI function speci.cation exposes the Java \ntype system and low-level JVM details, such as the exception model and the garbage collector, which many \nprogrammers do not understand and have no interest in. We now motivate our choice of bug classes and \ndescribe the extensions to the intermediate agent to dynamically check for missing exception checks and \nunexpected null values. 4.1.1 Exception Checking The JNI speci.cation disallows JNI calls when an exception \nis pending. Since C does not support exceptions, users must handle them by hand. In particular, when \nan exception is raised, the C code must clean up resources such as acquired locks, and unwind call frames \nuntil it .nds an exception han\u00addler or exit. C macros and nested function calls complicate the task of \nwriting C code that unwinds the stack and re\u00adleases resources. Furthermore, since exceptions are rare, \nthis code is hard to exercise and test, which leads to bugs. Pre\u00advious work shows that programmers tend \nto write JNI code that incorrectly propagates exceptions [13, 29]. We thus add code to Blink that automatically \ndetects missing error check\u00ading, which is key to integrating languages with and without automatic exception \nhandling. To detect missing error-checking, Blink adds to the inter\u00admediate agent, which instruments \nand interposes on all JNI function calls. For example, Blink wraps CallStaticInt-Method as follows: int \nwrapped_CallStaticIntMethod(JNIEnv* env, ...) { if (jvm_ExceptionCheck(env)) cbreak(env, \"Missing JNI \nError Check!\"); return jvm_CallStaticIntMethod(env, ...); } The agent changes the pointer CallStaticIntMethod \nto refer to wrapped CallStaticIntMethod instead of the original jvm CallStaticIntMethod. The wrapper \nchecks if the JVM has a pending exception. If it does, it executes cbreak, a native breakpoint set during \nagent initialization, which reports a breakpoint hit to the native component de\u00adbugger and, in turn, \nto Blink, which displays the error mes\u00adsage to the user together with the current calling context.  \n4.1.2 Null Checking The JNI speci.cation requires that some function arguments must be non-null pointer \nvalues and previous work reports these errors are common [14]. If JNI functions receive un\u00adexpected arguments, \nthe JVM may crash or silently pro\u00adduce incorrect results. Neither outcome is desirable, and the programmer \nshould inspect and correct all these errors. Blink dynamically detects obviously invalid arguments to \nJNI functions, i.e., NULL or (jobject)0xFFFFFFFF. We ex\u00adtend Blink s intermediate agent interposition \non every JNI function call to check that the arguments are valid as in the following example function: \njstring wrapped_NewStringUTF(JNIEnv* env, char* utf) { if ( (utf == NULL) || (utf == 0xFFFFFFFF) ) cbreak(env, \n\"Invalid JNI Argument!\"); return jvm_NewStringUTF(env, utf); } So, when C passes NULL as the utf argument, \nthe agent calls the C breakpoint function cbreak and reports an error mes\u00adsage and the current stack. \nAt this point, the user probably needs to examine variables and expressions from both lan\u00adguages to determine \nthe root cause of the invalid argument. We therefore provide mixed-language expression evaluation, as \ndescribed in the next section.  4.2 Jeannie Mixed-Environment Expressions The more powerful a debugger \ns data inspection features, the easier it is for the user to determine whether she is on the right track \nto .nding a bug. For example, gdb provides ex\u00adpression evaluation with a read-eval-print loop (REPL). \nAn interactive interpreter evaluates arbitrary source language expressions based on the current application \nstate. While im\u00adplementing a language interpreter requires a signi.cant engi\u00adneering effort, expression \nevaluation makes it easier to deter\u00admine whether the current state is infected, especially if the evaluator \nsupports function calls and side effects. Besides debugging, expression evaluation is useful for rapid \nproto\u00adtyping, program understanding, and testing, as users of lan\u00adguages with REPLs readily attest. Blink \nadvances the state of the art of expression evalu\u00adation by accepting mixed-environment expressions, which \nnest subexpressions from multiple languages and environ\u00adments with a language speci.cation operator. \nIt is based on the insight that, given single-environment interpreters, mixed-environment expression \nevaluation reduces to hand\u00ading off subexpressions to the component debuggers and passing intermediate \nresults between them. Blink implements mixed-environment expressions writ\u00adten in the Jeannie programming \nlanguage syntax [12], which mixes Java and C code using the incantation backtick pe\u00adriod language , i.e., \n.C and .Java. A single backtick toggles when there are only two languages, as in Blink. For example, \nconsider this native Java method declaration from the BuDDy binary decision diagram library [15]: public \nstatic native int makeSet(int[] var); The C function implementing this Java method looks as follows: \njint BuDDyFactory_makeSet( JNIEnv *env, jclass cls, jintArray arr ){ ... /* C code using parameters through \nJNI */ } In the C function, the variable arr is an opaque refer\u00adence to a Java integer array. Single-language \nexpression evaluation could only print its address, which is not help\u00adful for debugging. But the mixed-environment \nexpression .C(( .Java arr).length) (or (( arr).length) for short) changes to the Java language and accesses \nthe Java .eld length of the C variable arr, returning the length of the Java array, which is much more \nmeaningful to the user. Clearly, mixed-environment expression evaluation makes data inspection more convenient. \nWe add two features to Blink s debugger agent to support expression evaluation: Convenience variables \nstore the results of a (sub)expression evaluation in temporary variables. Mixed-environment data transfer \ntranslates and transfers data between environments. 4.2.1 Convenience Variables Application variables \nare named locations in which appli\u00adcation code stores data during execution. Convenience vari\u00adables are \nadditional named locations provided by the debug\u00adger, in which the user interactively stores data for \nlater use in a debugger session. Convenience variables behave like variables in many scripting languages: \nthey are implicitly created upon .rst use, have global scope, and are dynam\u00adically typed. In addition \nto user-de.ned convenience vari\u00adables, some debuggers support internal convenience vari\u00adables, for example, \nto hold intermediate results during ex\u00adpression evaluation. In the mixed-environment case, the de\u00adbugger \nmust remember not only the values of convenience variables, but also their languages. Since gdb provides \ncon\u00advenience variables (written $var ), Blink reuses them to store C values. Since jdb and cdb lack this \nfeature, Blink implements convenience variables in the debugger agent, us\u00ading a table to map names to \nvalues and languages. The table is polymorphic to support dynamic typing. 4.2.2 Mixed-Environment Data \nTransfer Mixed-environment data transfer is the only case where Blink must discover enough type information \nto treat the value appropriately, since the single-language debuggers usually perform this function. \nThe Blink agent transfers data from a source to a target environment by .rst storing data in an array \nin the source environment. It then uses a helper Java method or JNI function to read from the array and \nre\u00adturns the value to the target environment. One complication is that the array and the retrieval function \nmust have the cor\u00adrect type, since the semantics of a value depend on its type and language. For example, \nBlink must convert an opaque JNI reference in C to a pointer in Java; a struct or union in C, on the \nother hand, does not have a direct correspon\u00addence in Java. In the case of C values, gdb provides exactly \nwhat Blink needs: the whatis command .nds the type of an expression without executing it, and in particular, \nwithout causing any side effects or exceptions. Since jdb lacks the necessary functionality, Blink distinguishes \nbetween differ\u00adent Java types for primitive values, such as numbers, charac\u00adters, or booleans, and for \nreferences, i.e., objects or arrays, using a simple work-around. Blink instructs jdb to pass the value \nto a helper method that is overloaded for the different primitive and reference types. Jdb s expression \nevaluation automatically selects the appropriate method, thus ensuring that values can be correctly transferred \nto C.  4.2.3 Expression Evaluation (REPL) This section explains each step of Blink s read-eval-print \n(REPL) loop. Read. As suggested by Rosenberg [20], the read stage of Blink s REPL reuses syntax and grammar \nanalysis code. We reuse the Jeannie grammar, which composes Java and C grammars [10, 12]. It is written \nin Rats!, a parser gen\u00aderator that uses packrat parsing for expressiveness and per\u00adformance. The Jeannie \ngrammar and Rats! are designed for composition. Section 7 discusses Jeannie in more detail. Whereas a \ntraditional compiler annotates the AST with types, Blink annotates the AST with: (1) the language (Java \nor C), and (2) whether each AST node is an r-value (read\u00adonly) or an l-value (written-to on the left-hand \nside of an assignment). Figure 4 shows how Blink annotates the AST for the expression x = $y + z , assuming \nthat the cur\u00adrent language is Java. Node x is an l-value and node z is aC r-value because z s parent \nis the language toggle backtick . Blink uses the component debuggers for symbol resolu\u00adtion. As is usual \nin debuggers, application symbols such as variable and function names are resolved relative to the cur\u00adrent \nexecution context. User convenience variables, on the other hand, have global scope and do not require \ncontext\u00adsensitive lookup. Eval. The interpreter visits the AST in depth-.rst left-to\u00adright post-order. \nEach node is executed exactly once and in the right order, to preserve language semantics in the pres\u00adence \nof side effects, and to not surprise users if an excep\u00adtional condition, such as a segmentation fault, \ncuts expres\u00adsion evaluation short.  Figure 4. Reading the expression x = $y + z when the current language \nis Java.  Figure 5. Evaluating the expression x = $y + z when the current language is Java. To evaluate \nan expression one AST node at a time, Blink uses temporary storage for subexpression results. For r\u00advalues, \nBlink evaluates the node, and then stores the result in an internal convenience variable. For l-values, \nBlink eval\u00aduates their children, but delays their own evaluation. These l-values are evaluated later \nas part of their parent, which is by de.nition an assignment. Figure 5 shows the exam\u00adple expression \nx = $y + z , assuming that the conve\u00adnience variable $y is currently the number 99, and the C application \nvariable z is currently an opaque JNI local ref\u00aderence localRef$3. All leaves are variables, which Blink \nevaluates through the component debuggers REPL. Blink directly uses any leaf literals without lookup. \nAt inner nodes, Blink needs to perform evaluation actions. For the language toggle operator , Blink performs \na mixed-environment data transfer as described in Section 4.2.2. For Figure 5, Blink discovers that the \nJNI reference localRef$3 on the C side refers to the Java string \" bottles\" on the Java side. For other \noperators, such as + and =, Blink falls back on the REPL in the component debuggers. Note that in general, \nan inner node may call a user function and may thus execute arbitrary user code. Print. When expression \nevaluation reaches the root of the tree, Blink prints the result. As recommended by Rosenberg, Blink \ndisables user breakpoints for the duration of expres\u00adsion evaluation, because the user would probably \nbe sur\u00adprised when expression evaluation hits a breakpoint in a callee [20]. But there may be other exceptional \nconditions during expression evaluation, such as Java exceptions or C segmentation faults. In this case, \nBlink aborts the evaluation of the current expression, and the debug session continues at  Figure 6. \nTransitions between Java and C. user breakpoints. 5. Blink Implementation section explains Blink s implementation \nin detail. 5.1 Blink Debugger Agent Debugger context switching. Blink supports switching contexts between \nits component debuggers as illustrated in Figure 3. The helper functions j2c and c2j are part of the \nBlink debugger agent, and contain hardcoded internal break\u00adpoints. These internal breakpoints force the \napplication to surrender control to the respective debugger. Runtime transition interposition. The Blink \nagent inter\u00adposes on all environment transitions to report full mixed run\u00adtime stack traces and to control \nsingle-stepping between en\u00advironments. Figure 6 shows the four possible transitions be\u00adtween Java and \nC. Java exceptions are automatically prop\u00adagated by JNI, and thus do not result in additional environ\u00adment \ntransitions. j2c call: Line 8 in Figure 7 is an example of a call from Java to C. It looks just like \nan ordinary method call, and in fact, with virtual methods, the same call in the source code may invoke \nnative methods or Java methods. To in\u00adterpose on j2c calls, the Blink agent wraps all JNI native methods. \nFor example, the wrapper function for the native method PingPong_cPong on Line 14 in Figure 7 conceptu\u00adally \nreads: Figure 7. JNI mutual recursion example. jint wrapped_PingPong_cPong(...) { j2c_call(); /* interposed \nj2c call */ jint result = PingPong_cPong(...); j2c_return(); /* interposed j2c return */ return result; \n} Because wrappers are largely generic, i.e., pass arguments to and results from the original native \nmethod implementation while also invoking the debugger agent, Blink uses assembly code templates to instantiate \neach native method s wrapper. This approach is simple and general, i.e., does not require the full power \nof dynamic code generation. However, it does require some porting effort across architectures and operat\u00ading \nsystems. In our experiences with IA32 and PowerPC for Unix and Windows, the non-portable code amounts \nto only 10 20 lines of assembly. j2c return: The Blink agent interposes on returns from a C function \nto a Java method through the JNI native method wrapper function shown above. The return looks just like \nan ordinary function return, and, in fact, the same C function can return sometimes to Java and sometimes \nto C. c2j call: All calls from C to Java go through a JNI inter\u00adface function, such as CallStaticIntMethod \nin Figure 7 on Line 19. Blink instruments every c2j interface function. All interface functions reside \nin a struct of function point\u00aders pointed to by variable JNIEnv* env on Line 15 of Fig\u00adure 7. During \nJVMTI initialization, Blink replaces the origi\u00adnal function pointers by pointers to wrappers. Conceptually, \nthe wrapper for CallStaticIntMethod reads: int wrapped_CallStaticIntMethod(...) { c2j_call(); /* interposed \nc2j call */ int result = jvm_CallStaticIntMethod(...);  c2j_return(); /* interposed c2j return */ return \nresult; } Note that, for demonstration purposes, Section 4.1.1 showed a different wrapper for CallStaticIntMethod. \nIn the ac\u00adtual implementation, the wrapper also performs the check for pending exceptions. c2j return: \nThe same wrappers that interpose on c2j calls also interpose on c2j returns, as shown above. 5.2 Context \nManagement One basic debugger principle from Rosenberg s book [20] is: Context is the torch in the dark \ncave. Users, unable to follow all the billions of instructions executed by the program, feel like they \nare being taken blind-folded into a dark cave when searching for the source of a bug. When the program \nhits a breakpoint, the debugger must provide context. Source line number information. The most important \nquestion in debugging is: Where am I? Debuggers answer it with a line number. Java compilers provide \nline number information to jdb, and C compilers provides line number information to gdb or cdb, which \nBlink borrows. Calling context backtrace. While Where am I? is the most important question, How did I \nget here? is a close second. Debuggers answer this question with a calling con\u00adtext backtrace, which \nshows the stack of function calls lead\u00ading up to the current location. The JNI code in Figure 7 is an \nexample of mixed-runtime calls that produce a mixed stack. In the beginning, the main method on Line \n4 calls the jPing method with argument 3, yielding the following stack: main:4 . jPing(3):7 Since i > \n0, control reaches Line 8, where the Java method jPing calls native method cPong de.ned in C code as \nfunc\u00adtion PingPong_cPong: main:4 . jPing(3):8 . cPong(2):17 The C function cPong calls back into Java \nmethod jPing by .rst obtaining its method ID on Line 18, then using the method ID in the call to CallStaticIntMethod \non Line 19: main:4 . jPing(3):8 . cPong(2):19 . jPing(1):7 Finally, after one more call from jPing to \ncPong, the mixed\u00adenvironment mutual recursion comes to an end as it reaches the base case i =0: main:4 \n. jPing(3):8 . cPong(2):19 . jPing(1):8 . cPong(0):17 At this point, the stack contains multiple and \nalternating frames from each environment. Unfortunately, the single\u00adenvironment debuggers only know about \na part of the stack each, since each environment uses its own calling conven\u00adtion. For example, a standard \nJava debugger shows all Java fragments, with gaps for the C parts of the stack: main:4 . jPing(3):8 \n. ?(C) . jPing(1):8 . ?(C) A standard C debugger has even less information. It only shows the bottom-most \nC fragment: ?(Java/C) . cPong(0):17 Neither gdb nor cdb understand the JVM implementation details for \nJava frames. Blink weaves the complete stack from JVM call frames and native method frames by exploiting \nthe Java native method wrappers discussed in Section 5.1. The j2c wrapper saves its frame pointer and \nprogram counter in a thread lo\u00adcal variable, and the c2j wrapper retrieves the saved frame pointer and \nprogram counter while also overwriting its old frame pointer and return address. Modifying the proces\u00adsor \nstate accordingly guides the C debuggers to skip JVM\u00adspeci.c native frames between j2c and c2j wrappers \nand yields the following C frames: cPong(2):19 . wrapped_CallStaticIntMethod . wrapped_PingPong_cPong \n. cPong(0):17 Blink recognizes its agent wrapper functions and presents the interleaved Java and C stack: \nmain:4 . jPing(3):8 . cPong(2):19 . jPing(1):8 . cPong(0):17 Blink thus recovers and reports the full \nstack to the user as needed. These implementation details will vary for other languages, their environments, \nand their debuggers. As de\u00adscribed below, the user can also inspect data from both lan\u00adguages at a breakpoint. \n 5.3 Execution Control If context is the torch in the dark cave, then execution con\u00adtrol is the means \nby which the user can get from point A to B in the cave when tracking down a bug. The debugger con\u00adtrols \nexecution by starting up, tearing down, setting break\u00adpoints, and stepping through program statements \nbased on user commands. Start-up and tear-down. The Blink controller starts the program in the JVM, attaches \njdb and either gdb or cdb, and loads the Blink debugger agent. To load the agent, Blink uses JVMTI and \nthe -agentlib JVM command line argument. To initialize the agent, Blink issues internal commands, such \nas setting two internal breakpoints: one for Java and the other for C.1 After it initializes and connects \nall the processes, but before the user program commences, Blink gives the user a command prompt. When \nthe program terminates, Blink tears down jdb and gdb/cdb and exits. 1 The internal breakpoints are multiplexed \nfor several conditions. See Sec\u00adtion 8.3 for the performance impact of evaluating these conditions. \nBreakpoints. Breakpoints answer the question: How do I get to a point in program execution? Users set \nbreakpoints to inspect program state at points they suspect may be erro\u00adneous. The debugger s job is \nto detect when the breakpoint is reached and then transfer control to the user. One of the key challenges \nfor a mixed-environment debugger is setting a breakpoint for a location in an inactive environment. This \nfunctionality requires the debugger to transfer control to the other environment s debugger, set the \nbreakpoint, and return control to the current environment s debugger. Blink takes the breakpoint request \nfrom the user, and checks if the re\u00adquest is for Java or C. If the current environment does not match \nthe breakpoint environment, Blink switches the de\u00adbugging context to the target environment and directs \nthe breakpoint request to the corresponding debugger. Single stepping. Once the application reaches a \nbreak\u00adpoint, the question is: What happens next? Users want to single step though the program, examining \ncontrol .ow and data values to .nd errors. The step into, or simply step, command executes the next dynamic \nsource line, which may be the .rst line of a method call, whereas the step over, or next, command treats \nmethod calls as a single step. The challenge for mixed-environment single-stepping is that while jdb \ncan step through Java and gdb or cdb can step through C, they lose control when stepping into a call \nto the other environment or when returning to a caller from the other environment. Blink maintains control \nduring a step command as fol\u00adlows. It sets internal breakpoints at all possible language transitions, \nso if the current component debugger loses con\u00adtrol in a single-step, then the other component debugger \nim\u00admediately gains control. Blink only enables transition break\u00adpoints from the current environment to \nthe other environ\u00adment when the user requests a single-step. Furthermore, when the user requests step-over \nas opposed to step-into, Blink enables return breakpoints, as opposed to both call and return breakpoints. \nNote that Blink does not make any attempts to decode the current instruction, but rather aggres\u00adsively \nsets needed internal breakpoints just in case the single\u00adstep causes an environment transition, and then \noperates on the user command. This approach greatly decreases debug\u00adger development effort, since accurate \nJava single-stepping requires interpreting the semantics of all byte codes, and ac\u00adcurate C single-stepping \nrequires platform-dependent disas\u00adsembly. Once Blink sets the internal breakpoints, it implements single-stepping \nby issuing the corresponding command to jdb or gdb/cdb. There are three possible outcomes: The component \ndebugger s single-step remains in the same environment. Blink performs no further action.  There is \nan environment transition and consequently an internal breakpoint intercepts it. Blink steps from the \ninternal breakpoint to the next line.  An exceptional condition, such as a segmentation fault, occurs. \nBlink abandons single stepping. In all cases, Blink then disables its internal breakpoints, as usual \nfor breakpoint algorithms [20]. 5.4 Data Inspection Once the user arrives at an interesting point, the \nmain ques\u00adtion becomes: Is the current state correct or infected? This question is hard to answer automatically, \nso data inspection answers the simpler question What is the current state? Blink delegates the inspection \nof application variables, in\u00adcluding locals, parameters, statics, and .elds, to the compo\u00adnent debugger \nfor the current environment, which provides the most local origin for a variable. If, however, the current \ncomponent debugger does not recognize the variable, Blink tries the other component debugger. 6. Generalization \nThe previous sections focus on composing debuggers for Java and C. Below, we discuss how to generalize \nour ap\u00adproach to more environments. Section 7 describes our ex\u00adperience with extending Blink to include \nthe Jeannie pro\u00adgramming language, which mixes Java and C in the same methods. Requirement 1: Single-environment \ndebuggers. As might be expected, debugger composition requires single-environ\u00adment debuggers to compose. \nThe single-language debuggers must support the features discussed in Section 3.1. The con\u00adtroller can \nextract these features through a command line in\u00adterface (which is what we use), an API, or a wire protocol. \nRequirement 2: Language transition interposition. Our approach requires instrumenting local and non-local \ncontrol .ow in all directions across environment boundaries. For Blink, we leverage Java s wrapper-based \nFFI to meet this requirement and instrument the wrappers. However, there are other viable implementation \nstrategies for interposition. For example, for an interpreted language, the interpreter can call the \ninstrumentation when encountering a transition. For a compiled language, the compiler can inject a call \nto the instrumentation when compiling a transition. Finally, when only compiled code is available, static \nor dynamic binary instrumentation can implement interposition. Requirement 3: Debugger context switching. \nOur ap\u00adproach requires external interfaces to single-environment debugging functions, such as print or \neval. Most single\u00adenvironment debuggers provide these commands, includ\u00ading jdb and gdb. This ability \nis also a de.ning feature for languages with interactive interpreters, such as Perl, Python, Scheme, \nand ML. If, on the other hand, the single\u00adenvironment debugger does not support direct function invo\u00adcation, \nwe must call the helper function through other means, for example, using an agent helper thread, or a \nlower-level API underlying the single-environment debuggers.  Figure 8. Jeannie line number example. \nComposing environments. Given two environments where one environment is the native C environment, it \nis easy to sat\u00adisfy the above criteria. For instance, Perl, Python, and Ruby have debuggers and foreign \nfunction interfaces to C. We can thus satisfy the three requirements as follows: (1) reuse the perldebug, \npdb, or ruby-debug single-environment de\u00adbuggers and their interfaces; (2) extend the runtime systems \nto interpose calls to native methods; and (3) use perldebug, pdb, or ruby-debug to evaluate calls to \nnative methods that trigger a C breakpoint. For more than two environments (N> 2), there are N\u00b7(N-1) \npossible language transitions to interpose on and 2 debugger context switches to perform. In theory, \nwe could implement composition by adding agents for each pair of en\u00advironments. In practice, the native \nC environment often acts as a bridge environment, since most environments imple\u00adment foreign function \ninterfaces to C. Using C as a bridge environment, all the essential requirements are satis.able: (1) \nN single-environment debuggers handle their corre\u00adsponding N environments; (2) interposition captures \ntran\u00adsitions between the N environments and C, because every transition goes through C; and (3) debugger \ncontext switch\u00ading to any environment also goes through the bridging C environment. 7. Language Extension \nCase Study: Debugging Jeannie This section shows how composition generalizes Blink to the Jeannie programming \nlanguage [12]. Jeannie programs combine Java and C syntax in the same source .le. This de\u00adsign eliminates \nmany language-interface errors and simpli\u00ad.es resource management and multi-lingual programming. The \nJeannie compiler produces C and Java code that exe\u00adcutes in a native and JVM environment, respectively. \nThus adding Jeannie to Blink serves as an example of debugging more languages in Blink s mixed environment.2 \n2 Debugging Jeannie is distinct from borrowing Jeannie s expression evalu\u00adation functionality, which \nBlink also does and Section 4.2 described. Jeannie nests Java and C code in each other in the same .le. \nCompared to JNI, Jeannie is more succinct and less brittle. For example, JNI obscures the Java type system, \nwhereas Jeannie programs directly refer to Java .elds and methods, which the Jeannie compiler type checks. \nIn Jean\u00adnie, .language speci.es the language. As a shortcut, back\u00adtick toggles. For example, in Figure \n8, the body of Java method f is the block A of C code. Block A contains a nested block B of Java code, \nwith a nested C expression C, which, in turn, nests Java expression D. The Jeannie compiler emits separate \nJava and C .les that implement the expected nesting semantics using JNI. In the example, the Jeannie \ncompiler separates the code for the Java method declaration and snip\u00adpets B and D into a Java .le and \nputs the code for C snippets A and C into a C .le. Jeannie s design supports adding more languages, but \nthat is beyond the scope of this paper. To add Jeannie to Blink, we changed the Jeannie com\u00adpiler to \ngenerate and maintain debug tables for line num\u00adbers, method names, and variable locations, and we changed \nBlink to use these tables for Jeannie source-level debugging. The following sections illustrate how we \nextended Blink to support context management, execution control, and data in\u00adspection for Jeannie. 7.1 \nContext Management Line numbers answer the question: Where am I? Call stacks answer the question: How \ndid I get here? Source line number information. To report the current lo\u00adcation to the user, the debugger \nneeds to map from low-level code offsets to source-level line numbers. The Jeannie com\u00adpiler has access \nto source line numbers during translation, but relies on other compilers to generate low-level code. \nFor debugging, we need to preserve line numbers through the second step. For Jeannie-generated Java code, \nwe wrote a post-processor that rewrites Java bytecodes to reestablish the original line numbers from \nJeannie sources. For Jeannie\u00adgenerated C code, we rely on #line directives, which are supported by C \ncompilers precisely to preserve debugging information for intermediate C code. Calling context backtrace. \nSince Jeannie is a single lan\u00adguage, Blink should show only the user-speci.ed Jeannie methods and functions \non the stack, instead of showing the generated single-language functions, which are just an im\u00adplementation \ndetail. For example, for the C source snippets A and C in Figure 8, the Jeannie compiler generates C \nfunc\u00adtions f_A and f_C. For the Java snippets B and D, the Jean\u00adnie compiler generates Java methods f_B \nand f_D. When the application is suspended in D, the low-level call stack is: ... . f . f_A . f_B . f_C \n. f_D but this trace is not re.ected in the user s code. We changed the Jeannie compiler to generate \na table mapping names of generated functions back to the original functions. Blink uses this mapping \nto hide low-level call frames and instead reports source-level names, e.g., just ... . f .  7.2 Execution \nControl Breakpoints answer the question How do I get to a point in program execution? Single-stepping \nanswers the question What happens next? Breakpoints. To support breakpoints in another language, the \ndebugger needs to map from source-level lines to low\u00adlevel code offsets. This requires similar debugging \ntables as for context management (Section 7.1), except in the opposite direction. In the case of Jeannie, \nthere is one additional issue: Blink must delegate the breakpoint to the correct component debugger by \nusing debugger context switching if necessary. Single stepping. Stepping in Jeannie adds the challenge \nthat a single source line may involve multiple languages. Line 6 in Figure 8 is an example. As discussed \nin Section 7.1, the Jeannie compiler tracks original line numbers even when code ends up in different \nsource .les. Blink implements Jeannie stepping by inspecting line numbers and iterating: it keeps stepping \nuntil the source line differs from the starting source line. For step-over, Blink records the current \nstack depth and then iterates, stepping until stack depth is less than or equal to the initial depth. \n 7.3 Data Inspection Data inspection helps users determine if the current state is correct or infected. \nThe compiler for each language must generate a table that maps source-level variable names to un\u00adderlying \nvariable access expressions in the generated code. The Jeannie compiler stores local variables in explicit \nenvi\u00adronment records [12]. We extended the Jeannie compiler to provide the necessary mapping information \nthrough a sepa\u00adrate symbol .le, which Blink reads on demand. 8. Evaluation This section evaluates our \nclaim that debugger composition is an economical way to build mixed-environment debuggers and that the \nresulting debuggers are powerful. We show that Blink is relatively concise, new development cost is low, \nthe space and time overheads are low, and the resulting tool is portable. Through the use of case studies, \nSection 8.4 demonstrates that Blink helps programmers to quickly .nd mixed-language interface bugs. \n8.1 Methodology We rely on single-environment debuggers, JVMs, C compil\u00aders, and operating systems. We \nuse JDK 1.6 as implemented by Sun and IBM. For the debuggee running on Linux/IA32 machines, we use Sun \ns Hotspot Client 1.6.0 10 [25] and IBM s J9 1.6.0 (build pxi3260-20071123 01) [1]. We also use Sun s \njavac 1.6.0 10 and gcc 4.3.2 with the -g op\u00adtion. For Windows, we use Sun s Hotspot Client 1.6.0 10, \nDebugger SLOC #Files Blink 9,481 41 Controller (front-end) 4,575 18 jdb driver (back-end) 391 1 gdb driver \n(back-end) 511 1 cdb driver (back-end) 546 1 Agent -Java (back-end) 1,515 9 Agent -C (back-end) 1,943 \n11 Java debugger -jdb 86,579 769 jdb (user-interface) 18,360 122 JDI (front-end) 16,983 256 JDWP Agent \n(back-end) 40,171 356 JVMTI (back-end) 11,065 35 C debugger -gdb 6.7.1 1,017,069 2,331 gdb 419,921 1,524 \ninclude 32,039 215 bfd 286,981 398 opcodes 278,128 194 Table 1. Debugger SLOC (source lines of code). \n Sun s javac 1.6.0 10, and Microsoft s C/C++ compiler (cl.exe) 15.00.21022.08. We use Sun s JDK 1.6.0 \njdb and Microsoft s cdb 6.9.0003.113 debuggers, and GNU gdb 6.8 debugger running on Cygwin 1.5.25, a \nUnix compatibility layer for Windows. 8.2 Building Blink Blink s modest construction effort leverages \nthe large engi\u00adneering effort and supported platforms of existing single\u00adenvironment debuggers. To quantify \nthis claim, we count non-blank non-commenting source lines of code (SLOC), which is an easily available, \nbut imperfect measure of the ef\u00adfort to develop and maintain a software package. Given the orders of \nmagnitude differences in SLOC, we are con.dent that this metric re.ects substantial differences in engineering \neffort. 8.2.1 Construction Effort Table 1 shows the code sizes of Blink, jdb, gdb, and their components. \nThe jdb line counts are for the jdb 1.6 sources in demo/jpda/examples.jar of Sun s JDK 1.6.0-b105. The \nJDI line counts are for the JDI imple\u00admentation in the Eclipse JDT. The JDWP and JVMTI line counts are \nfor the corresponding subdirectories of the Apache DRLVM. Blink adds a modest 9,481 SLOC to inte\u00adgrate \n1,103,648 SLOC from the Java and C debuggers. The SLOC of the existing debugger packages are 9 to 107 \ntimes larger than Blink s. Although other researchers show how to build single-environment debuggers \nmore economically than gdb [19, 21], Blink adds modestly to this effort. Blink only adds new code for \ninterposing on environment tran\u00adsitions and for controlling the individual debuggers. Blink otherwise \nreuses existing debuggers for intricate platform\u00addependent features such as instruction decoding for \nsingle\u00adstepping or code patching for breakpoints.  Figure 9. Blink portability and SLOC.  8.2.2 Portability \nTo evaluate the effort required for porting Blink to multiple platforms, we measure the amount of platform-independent \nand -dependent code. The basic composition framework requires 4,575 SLOC. Blink needs an additional 4,265 \nSLOC to support our initial con.guration, which uses Sun s Hotspot JVM, jdb, and gdb running on Linux/IA32. \nOut of Blink s total 9,481 SLOC, approximately 1,500 SLOC implement platform-speci.c code in the agent \nand debugger drivers, representing about 16% of Blink s code base. Our native agent contains a small \namount of non-portable platform-and ABI-speci.c code to access the native call stack. Furthermore, a \nsmall amount of debugger-speci.c code is required because cdb exposes a different user interface than \nthe more expressive gdb. Con\u00adsequently, Blink employs an internal adaptation layer to pro\u00advide uniform \naccess to either gdb on GNU platforms or cdb on Windows. Figure 9 plots the cumulative SLOC for the Blink \ncon\u00adtroller; then the code for supporting Hotspot, jdb, and gdb on Linux; then the code for supporting \nJ9 on Linux; then gcc and gdb under Cygwin on Windows; and .nally Microsoft s C and cdb on Windows. As \nshown in the .gure, Blink re\u00adquires no additional code to support IBM s J9 and Cygwin. Furthermore, it \nrequires only 640 SLOC to support cdb on Windows. These results show that Blink s debugger compo\u00adsition \nis effective and requires only small amounts of code when adding more operating systems, JVMs, C compilers, \nand component debuggers.  8.2.3 Portability Tests We now brie.y describe some of our functionality tests. \nThey give us con.dence that our implementation is correct and complete on all supported platforms. Context \nmanagement. This test sets two breakpoints, at jPing (PingPong.java:7) and cPong (PingPong.c:17) in Figure \n7. During execution, the application stops at each of these breakpoints twice, and, each time, the test \nissues the backtrace command. Execution control. This test .rst sets a breakpoint at the main method \nof the mutual recursion example in Figure 7. From there, the test repeatedly uses the step command until \nthe end of the program. This test exercises all cases of mixed-language stepping through calls and returns. \nData inspection. This test .rst sets a breakpoint in a nested context of two example programs in the \nBlink regression test suite. (The interested reader can .nd these programs in the open-source distribution \nof Blink [9].) When the application hits the breakpoint, the test evaluates a variety of expres\u00adsions, \ncovering primitive and compound data, pure expres\u00adsions and assignments, language transitions, and user \nfunc\u00adtion calls. Results. Currently, all these and other functionality tests succeed for the following \ncon.gurations on IA32: Sun JVM Linux ++ gdb IBM JVMCygwin The Cygwin case uses Windows with the GNU \nC com\u00adpiler, instead of Microsoft s C compiler. We also tried the tests on PowerPC, but found that gdb \ndid not interact well with the JVM on that platform. Using a Linux/Power Mac G4 machine running IBM JDK \n1.6.0 (SR1) and gdb 6.8, gdb reports an illegal instruction signal (SIGILL) when the debuggee resumes \nexecution after a breakpoint in a shared library. We leave further investigation of different architec\u00adtures \nto future work. We also test Blink with Microsoft s C compiler and Microsoft s C debugger: Sun JVM + \nWindows + cdb In this con.guration, context management and execution control are fully supported, but \ndata inspection is only par\u00adtially supported because cdb s expression evaluation fea\u00adtures are incomplete \nwhen compared to gdb.  8.3 Time and Space Overhead This section shows that the time and space overheads \nof Blink s intermediate agent are low. Time Overhead. The time overhead of the intermediate agent is \nlinearly proportional to the number of dynamic tran\u00adsitions between Java and C, since it installs wrappers \nin both Java native methods and JNI functions. These wrappers add a small number of instructions to the \ndynamic instruction stream for each transition between Java and C. To measure the performance impact \nof interposition in the intermediate agent, we ran several large Java programs with the Blink agent. \nWe measured runtime and dynamic transition counts with Sun Hotspot 1.6.0 10 running on a Linux/IA32 machine \non the SPECjvm98 and DaCapo Java v.2006-10 Benchmarks [23, 3]. These Java benchmarks exer\u00adcise C code \ninside the standard Java library. The initial heap size was 512MB, and the maximum heap size was 1GB. \nThe experiments used a Pentium D 2 GHZ running Linux 2.6.27. Each benchmark iterated once. The results \nare the median of 16 trials. Benchmark Environmental transition counts Java . C Java . C Java . C Execution \ntime in seconds Base Active Interposed Checked JVMTI transitions transitions Normalized execution time \nActive Interposed Checked JVMTI transitions transitions antlr 221,309 249,411 470,720 4.58 4.41 4.64 \n4.65 0.96 1.01 1.02 bloat 594,644 233,795 828,439 8.50 8.48 9.32 9.41 1.00 1.10 1.11 chart 346,317 677,240 \n1,023,557 9.28 9.17 9.90 9.87 0.99 1.07 1.06 eclipse 2,631,281 6,206,930 8,838,211 50.70 50.88 59.76 \n58.69 1.00 1.18 1.16 fop 540,899 1,439,441 1,980,340 3.74 3.88 4.25 4.31 1.04 1.14 1.15 hsqldb 130,959 \n73,750 204,709 5.61 5.65 5.76 5.78 1.01 1.03 1.03 jython 13,525,019 42,859,171 56,384,190 11.83 11.66 \n12.27 12.37 0.99 1.04 1.05 luindex 441,090 936,565 1,377,655 9.28 9.35 9.94 10.01 1.01 1.07 1.08 lusearch \n2,015,481 1,513,508 3,528,989 8.34 9.17 9.89 10.05 1.10 1.19 1.21 pmd 531,579 436,124 967,703 8.45 8.58 \n9.05 9.09 1.02 1.07 1.08 xalan 769,991 362,868 1,132,859 19.10 19.54 22.34 22.27 1.02 1.17 1.17 compress \n5,958 9,960 15,918 3.71 3.73 3.96 4.00 1.01 1.07 1.08 jess 92,272 62,917 155,189 2.63 2.56 3.23 3.16 \n0.97 1.23 1.20 raytrace 18,170 12,375 30,545 1.44 1.43 1.64 1.68 0.99 1.14 1.17 db 53,225 80,733 133,958 \n9.54 9.57 9.72 9.74 1.00 1.02 1.02 javac 184,566 71,972 256,538 6.54 7.28 7.46 7.30 1.11 1.14 1.12 mpegaudio \n25,733 21,588 47,321 2.81 2.81 2.77 2.79 1.00 0.99 0.99 mtrt 18,784 13,427 32,211 1.80 1.72 2.01 2.02 \n0.96 1.12 1.12 jack 418,681 886,216 1,304,897 3.90 3.87 4.22 4.38 0.99 1.08 1.12 GeoMean 1.01 1.09 1.10 \n Table 2. Performance characteristics of the Blink debug agent with Hotspot VM 1.6.0 10. Table 2 shows \nthe results. Column environmental tran\u00adsition counts shows the number of dynamic transitions be\u00adtween \nJava and C. The following columns show execution times in the four con.gurations Base, Active JVMTI, \nIn\u00adterposed transitions, and Checked transitions and normal\u00adized execution times for the debugger con.gurations. \nThe Base con.guration represents production runs without any debugging-related overhead. In contrast, \nthe fully functional agent needs to activate JVMTI, interpose transitions, and check transitions. Figure \n10 illustrates Blink s runtime normalized to the production runs. JVMTI, interposition, and transition \ncheck\u00ading add 1%, 8%, and 1% overhead, respectively. There are a few counter-intuitive speedups because \nthe JIT and GC add non-determinism to the runtime. On average, Blink s total overhead is 10%. Figure \n11 shows that the overhead is sub\u00adlinear to the total dynamic transition counts. Although the agent overhead \nis linearly proportional to the dynamic tran\u00adsition counts in theory, it is less in practice because \nenviron\u00admental transitions contribute little to overall execution time. For an interactive tool, a 10% \noverhead is modest. Space Overhead. The space overhead of running Blink is mostly due to additional \ncode loaded into the debuggee. In particular, on Linux/IA32, the intermediate agent itself re\u00adquires \n388 KB, and the 229 JNI function wrappers introduce 174 KB of constant space overhead. Additionally, \neach na\u00adTable 3. Studied JNI Bugs. The two JNI bugs in UnitTest and gconf.BasicGConfApp are found when \nrunning these two programs with Blink. BadErrorChecking models exception handling bugs reportedly common \nin both user-and system-level JNI code [13, 29]. Main Java class Program Java/C SLOC Bug type Bug site \n(source .le:line) UnitTest gconf.BasicGConfApp BadErrorChecking Java-gnome 4.0.10 libgconf-2.16.2 Blink-testsuite \n1.14.3 64,171/67,082 796/1,157 15/9 Null parameter Null parameter Exception state Environment.c:48 org \ngnu gconf ConfClient.c:425 BadErrorChecking.c:21 Main Java class Production run Hotspot VM J9 VM Runtime \nchecking (-Xcheck:jni) Hotspot VM J9 VM Debugging sessSingle environment jdb gdb ion with J9 VM Mixed \nenvironment Blink UnitTests gconf.BasicGConfApp BadErrorChecking running running running crash crash \ncrash warning warning running crash warning error crash fault crash fault crash fault breakpoint breakpoint \nbreakpoint Table 4. Impact of JNI bugs under different con.gurations. Running: continue executing with \nunde.ned state. Crash: abort the JVM with a fatal error (e.g., segmentation fault). Error: exit JVM with \nerror message. Fault: suspended by debugger due to an error inside the JVM, which becomes inoperable. \nBreakpoint: suspended by debugger, while JVM remains operable. tive method incurs 11 bytes space overhead \nfor its wrapper, instantiated from an assembly code template. Finally, each thread requires 156 bytes \nof thread-local storage used by the intermediate agent, and less than 160 bytes for each wrapper activation \non the stack for an environment transition. We do not measure total space overhead in a live system, \nsince it is small by design.  8.4 Feature Evaluation This section explores how Blink saves programmers \ntime and effort when diagnosing the source of mixed-environment bugs. We compare Blink to other tools \nusing three case stud\u00adies. In these studies, the other tools are not helpful, whereas Blink directly \npinpoints the bugs. We examine three common mixed-environment errors: one arti.cially recreated and two \nfound in JNI programs in the wild. Table 3 lists the programs, lines of code, bug types, and bug sites. \nBlink directly identi.es the two JNI bugs in UnitTest and gconf.BasicGConfApp. We also recre\u00adated an \nexception-handling bug in BadErrorChecking, which is reported as common in both user-and system\u00adlevel \nJNI code [13, 29]. For each of these bugs, Table 4 compares Blink to production runs of Hotspot and J9, \nwith runtime checking in Hotspot and J9 (con.gured with the -Xcheck:jni command line option), and with \njdb and gdb. In production runs with runtime checking, Hotspot and J9 behave differently, but neither \nJVM helps the user .nd bugs. Hotspot tends to silently ignore bugs without terminating, whereas J9 either \ncrashes or reports errors. While seemingly improving stability, ignoring bugs in production runs may \nalso corrupt state, which is clearly undesirable. The JVMs runtime checking does not help much for two \nreasons. First, error messages are largely dependent on JVM internals and are inconsistent across the \ntwo JVMs. Second and more importantly, the JVMs cannot interpret code and data in native code, where \nthe JNI bugs originate. Single-environment debuggers are also of limited use. The JNI bugs trigger segmentation \nfaults, which are machine level events below the managed environment. As a result, the managed environment \ndebugger (jdb) cannot catch the fail\u00adure. The unmanaged environment debugger (gdb) catches this low-level \nfailure, but detection is too late. For instance, the fault-inducing code never appears in the calling \ncontexts of any thread when gdb detects the segmentation fault for J9 running BadErrorChecking. Blink \nstops the programs immediately after it detects the JNI error conditions, because it understands both \nenviron\u00adments. At the point of failure, programmers can inspect all the mixed-environment runtime state. \nWe next discuss these errors in more detail, grouping them in two categories: (1) null parameters and \n(2) exception state checking. Null Parameters. Semantics for JNI functions are unde\u00ad.ned when their arguments \nare (jobject)0xFFFFFFFF or NULL [14]. Hotspot ignores these errors and J9 crashes in gconf.BasicGConfApp \nand UnitTests, which pass NULL to the NewStringUTF JNI function (see Table 4). NewStringUTF takes a C \nstring and creates an equivalent Java string. Returning NULL for a NULL input may improve reliability, \nbut violates the speci.cation of NewStringUTF: Returns NULL if and only if an invocation of this function \nhas thrown an exception. [14] When Hotspot returns NULL, it should also post an excep\u00adtion. In addition, \nreturning NULL may mislead JNI program\u00admers into believing that NewStringUTF returns a null Java string \nwhen the input parameter is NULL [24]. J9 crashes and presents a low-level error message with register \nvalues and a stack trace. The error message does not include any clue to the cause of the bug. JVM runtime \nchecking does improve the error message. Blink detects the NULL parameter and presents the Java and C \nstate on entry to the JNI function. Given the JNI fail\u00adure in gconf.BasicGConfApp, a mixed-environment \ncall\u00ading context tells the programmer that NewStringUTF does not return a null Java string for a NULL \ninput with the fol\u00adlowing useful error message: JNI warning: NULL parameter to JNI Function: NewStringUTF \n425 return (*env)->NewStringUTF(env, val); blink> where [1] Java_org_..._1client_1get_1string (ConfClient.c:425) \n [2] org.gnu.gconf.ConfClient.getString (ConfClient.java:440) [3] gconf.BasicGConfApp.createConfigurableLabel \n(BasicGConfApp.java:128) ... blink> _ Missing Exception State Checking. JNI does not de.ne the JVM s \nbehavior when C code calls a JNI function with an exception pending in the JVM. Consider this C source \ncode from the BadErrorChecking micro-benchmark. 16. #include <jni.h> 17. JNIEXPORT void Java_BadErrorChecking_call \n( 18. JNIEnv *env, jobject obj) { 19. jclass cls = (*env)->GetObjectClass( env, obj);  20. jmethodID \nmid = (*env)->GetMethodID( env, cls, \"foo\", \"()V\");  21. (*env)->CallVoidMethod(env, obj, mid); 22. \nmid = (*env)->GetMethodID( env, cls, \"bar\", \"()V\");  23. (*env)->CallVoidMethod(env, obj, mid); 24. \n}  At the call to Java in Line 21, the target Java method foo may raise an exception and then continue \nwith the C code in Line 22, while the JVM has a pending exception. JNI rules require that the C code \neither returns immediately to the most recent Java caller or invokes the ExceptionClear JNI function. \nConsequently, the call to the JNI function GetMethodID in Line 22 leaves the JVM state unde.ned. In fact, \nHotspot keeps running while J9 crashes. This rule applies to 209 JNI functions out of 229 functions in \nJNI 6.0. Writing the corresponding error checking code is tedious and error-prone. Previous work [13, \n29] reports hundreds of bugs in JNI glue code. We brie.y inspected the Java\u00adgnome 4.0.10 code base and \nfound two cases of missing error checking. One case never happens unless the JVM implements one JNI function \nincorrectly. The other case happens only when the JVM is running out of memory, throwing an OutOfMemoryError \nexception, which is rare and thus hard to .nd and test. For these reasons, we created the BadErrorChecking \nmicro benchmark. The intermediate agent in Blink detects calls to JNI func\u00adtions while an exception is \npending, and asks Blink to stop the debuggee. Blink then warns the user of missing error checking, and \npresents the calling context. JNI warning: Missing Error Checking: GetMethodID [1] Java_BadErrorChecking_call \n(BadErrorChecking.c:22) [2] BadErrorChecking.main (BadErrorChecking.java:5) ... blink> _  9. Related \nWork This section describes how our paper advances the state of the art in building mixed-environment \ndebuggers and how Blink compares to prior work. 9.1 Mixed-Environment Debuggers One contribution of this \npaper is an implementation of the most portable and powerful debugger for Java and C to date. Blink s \npower and portability derives from composing existing powerful and portable debuggers. In retrospect, \nthis idea may seem obvious, but we believe that it was previously unclear whether composition could provide \nfully featured debugging across language environments. The closest work to compositional debugging is \nby White, who describes a manual technique for mixed-environ\u00adment debugging for Java and C that attaches \nsingle-environ\u00adment debuggers to the same process [35, 36]. The result\u00ading system is limited because \nit cannot examine a mixed stack, cannot step into cross-environment calls, and can\u00adnot set breakpoints \nin one environment when stopped in the other, all of which Blink supports. There are three mixed-environment \ndebuggers (dbx, XDI, and the Visual Studio debugger) that are practical, but unlike this paper, do not \nuse a compositional approach. These de\u00adbuggers are not easily extended nor are they portable. The dbx \ndebugger extends an existing C debugger for Java [27]. XDI extends an existing Java debugger for C [18]. \nBoth XDI [18] and dbx [27] are powerful but they are less portable than Blink. XDI works only with the \nHarmony JVM, which is a non-standard JVM. Dbx only works with Sun s JVM on Solaris, and, with limited \nfunctionality, on Linux. Blink is more portable; it supports multiple JVMs (HotSpot and J9) and C debuggers \n(cdb and gdb) on both Linux and Windows. The Visual Studio debugger debugs C# and C in the CLR (Common \nLanguage Runtime) [22]. It is also exten\u00adsible through debug engines [34]. However, in contrast to Blink, \nwhere multiple debuggers attach to a single mixed\u00adenvironment program, each Visual Studio s debug engine \nis responsible for one program. The CLR provides two debug\u00adging APIs: one native and one managed. To \nhandle a mixed\u00adenvironment program, a debug engine must use both APIs. Given two CLR debuggers, one for \nthe native API and one for the managed API, our compositional approach would yield a mixed-environment \ndebugger.  9.2 Single-Environment Multi-Lingual Debuggers Some multi-lingual debuggers require all the \nlanguages to implement a single interface in the same environment [4, 16, 21]. For example, the GNU debugger, \ngdb, can debug C to\u00adgether with a subset of Java statically compiled by gcj [4]. Many real-world Java \napplications however exceed the gcj subset and require a full JVM to run. Compared to these ap\u00adproaches, \nours is the only one that leverages independently\u00addeveloped debuggers. 9.3 Portable Debuggers Portability \nof debuggers depends on their construction mech\u00adanisms: reverse engineering or instrumentation. In the \nre\u00adverse engineering model, debuggers interpret machine-level state with symbol tables emitted by compilers, \nand gener\u00adalize the symbol table formats to add more platforms. For instance, dbx, gdb, and ldb recognize \nportable symbol ta\u00adble formats including dbx stabs [16], DWARF [5], and even PostScript [19]. In the \ninstrumentation model, a de\u00adbuggee process executes its debugger code. By construc\u00adtion, the instrumentation-based \ndebuggers are as portable as the languages of the in-process debuggers. For instance, TIDE [33], smld \n[32], and Hanson s machine-independent debugger [11] do not need any extra effort for additional platforms. \nHowever, instrumentation causes a factor 3 4 slowdown, which may impede adoption. Blink leverages portability \nof its component debuggers, and the construction mechanisms are portable. For reverse engineering, the \nsymbol table for Jeannie discussed in Sec\u00adtion 7 is platform-independent. For instrumentation, the in\u00adtermediate \nagent has only 10 20 lines of low-level assembly code.  9.4 Advanced Mixed-Language Debugger Features \nThe following subsections discuss work related to Blink s advanced debugger features. 9.4.1 Mixed-Language \nInterpreters One contribution of this paper is Blink s read-eval-print loop (REPL) for mixed Java and \nC expressions. Debuggers that support multiple languages, such as gdb, often include an interpreter for \nexpressions in each language. Blink is novel in that it interprets expressions by delegating subexpressions \nto the appropriate single-language debuggers. Blink s REPL uses a syntax for embedding Java in C and \nvice versa that was developed in an earlier paper on Jeannie [12]. The Jean\u00adnie paper described the language \nand its compiler, but did not describe an interpreter, let alone a debugger.  9.4.2 Mixed-Language Bug \nCheckers Another contribution of this paper is Blink s dynamic er\u00adror checker for Java native interface \n(JNI) calls. The clos\u00adest related work is the -Xcheck:jni .ag, which turns on dynamic error checking \nin Sun s and IBM s JVMs. Table 3 in [13] summarizes how each JVM behaves for a variety of bugs with and \nwithout this .ag. For example, the .ag traps uses of invalid local references, or double-frees of resources. \nBlink provides similar functionality in a JVM-independent way, and, as an added bene.t, provides a stack \ntrace and breakpoint for debugging the problem. There are various static bug checkers for Java and C. \nStatic analyses are a valuable asset for detecting bugs early. However, they suffer from false positives: \nnot every reported bug is an actual bug. As a dynamic checker, Blink has no false positives. Each existing \nstatic JNI bug checker is de\u00adsigned to look only for some class of bugs, and some yield false negatives \neven for their chosen class of bugs. J-Saf.re infers and checks Java types from C code [8]. Kondoh and \nOnodera check type-state properties on JNI code based on BEAM [13]. Tan and Croft use static analyses \nto study se\u00adcurity issues in Java s standard library [29]. Of course, static multi-lingual bug checkers \nare not restricted to Java and C. For example, Quail performs string analysis for Java/SQL safety [31]. \nStatic analysis is complementary to dynamic de\u00adbugging, which helps .nd some bugs static analysis misses. \nFurthermore, the hundreds of bugs in widely-used libraries reported by these papers motivate our work. \nAn alternative to .nding bugs in mixed-language pro\u00adgrams is to rewrite those programs in a language \nthat pre\u00advents some bugs from occurring in the .rst place. For exam\u00adple, SWIG [2] generates stubs for \nC to be called from Tcl. SafeJNI [28] combines Java with CCured [17] instead of C. Jeannie [12] provides \na type-checked syntactic embedding for Java and C. While these approaches are the right long term solution, \nthey may never be adopted because they re\u00adquire substantial code rewrites. Blink is synergistic since \nit supports debugging JNI and Jeannie. Furthermore, Blink is an enabling technology for transitioning \nto better languages. 10. Conclusions Debugging is one of the most time-consuming tasks in soft\u00adware development. \nIt requires a knack for formulating the right hypotheses about bugs and the discipline to systemati\u00adcally \ncon.rm or reject hypotheses until the cause of the bug is found [37]. Single-environment developers have \nlong had good tools to help them navigate the debugging task system\u00adatically. But mixed-language developers \nhave been left in the dark. We propose and evaluate a new way to build cross\u00adenvironment debuggers more \neasily using scalable composi\u00adtion. We use our compositional approach to develop Blink, a debugger for \nJava, C, and Jeannie. The open-source release of Blink is available as part of the xtc package [9]. Blink \nis full-featured and portable across different JVMs, operating systems, and C debuggers. Furthermore, \nBlink includes an interpreter (read-eval-print loop) for cross-environment ex\u00adpressions, thus providing \nusers with a powerful tool not just for debugging, but also for testing, program understanding, and prototyping. \n Acknowledgments This work is supported by the National Science Founda\u00adtion (CCF-0429859, CNS-0448349, \nCNS-0615129, CNS\u00ad0719966, and CCF-0811524), Samsung Foundation of Cul\u00adture, Microsoft, and CISCO. Any \nopinions, .ndings and conclusions expressed herein are the authors and do not necessarily re.ect those \nof the sponsors. References [1] C. Bailey. Java technology, IBM style: Introduction to the IBM developer \nkit. http://www.ibm.com/ developerworks/java/library/j-ibmjava1.html, May 2006. [2] D. M. Beazley. SWIG: \nAn easy to use tool for integrating scripting languages with C and C++. In USENIX Tcl/Tk Workshop (TCLTK), \n1996. [3] S. M. Blackburn, R. Garner, C. Hoffmann, A. M. Khang, K. S. McKinley, R. Bentzur, A. Diwan, \nD. Feinberg, D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump, H. Lee, J. E. B. Moss, B. Moss, \nA. Phansalkar, D. Stefanovi\u00b4c, T. VanDrunen, D. von Dincklage, and B. Wiedermann. The DaCapo benchmarks: \nJava benchmarking development and analysis. In Object-Oriented Programming, Systems, Languages, and Applications \n(OOPSLA), 2006. [4] P. Bothner. Compiling Java with GCJ. http://www. linuxjournal.com/article/4860, Jan. \n2003. [5] Free Standards Group. DWARF 3 debugging information format. http://www.dwarfstd.org/Dwarf3.pdf, \nDec. 2005. [6] M. Furr and J. S. Foster. Checking type safety of foreign function calls. In Programming \nLanguage Design and Implementation (PLDI), 2005. [7] M. Furr and J. S. Foster. Polymorphic type inference \nfor the JNI. In European Symposium on Programming (ESOP), 2006. [8] M. Furr and J. S. Foster. Checking \ntype safety of foreign function calls. Transactions on Programming Languages and Systems (TOPLAS), 30(4), \n2008. [9] R. Grimm. xtc eXTensible C. http://www.cs.nyu. edu/rgrimm/xtc/. [10] R. Grimm. Better extensibility \nthrough modular syntax. In Programming Language Design and Implementation (PLDI), 2006. [11] D. R. Hanson. \nA machine-independent debugger revisited. Softw. Pract. Exper., 29(10):849 862, 1999. [12] M. Hirzel \nand R. Grimm. Jeannie: Granting Java native inter\u00adface developers their wishes. In Object-Oriented Program\u00adming, \nSystems, Languages, and Applications (OOPSLA), 2007. [13] G. Kondoh and T. Onodera. Finding bugs in Java \nnative interface programs. In International Symposium on Software Testing and Analysis (ISSTA), 2008. \n[14] S. Liang. The Java Native Interface: Programmer s Guide and Speci.cation. Addison-Wesley, 1999. \n[15] J. Lind-Nielsen. BuDDy. http://buddy.sourceforge. net/. [16] M. A. Linton. The evolution of Dbx. \nIn Usenix Technical Conference, 1990. [17] G. C. Necula, S. McPeak, and W. Weimer. CCured: Type\u00adsafe \nretro.tting of legacy code. In Principles of Programming Languages (POPL), 2002. [18] V. Providin and \nC. Elford. Debugging native methods in Java applications. In EclipseCon User Conference, Mar. 2007. [19] \nN. Ramsey and D. R. Hanson. A retargetable debugger. In Programming Language Design and Implementation \n(PLDI), 1992. [20] J. B. Rosenberg. How Debuggers Work: Algorithms, Data Structures, and Architecture. \nJohn Wiley &#38; Sons, 1996. [21] S. Ryu and N. Ramsey. Source-level debugging for multiple languages \nwith modest programming effort. In International Conference on Compiler Construction (CC), 2005. [22] \nM. Stall. Mike Stall s .NET debugging blog. http: //blogs.msdn.com/jmstall/default.aspx. [23] Standard \nPerformance Evaluation Corporation. SPECjvm98 Documentation, release 1.03 edition, March 1999. [24] Sun \nMicrosystems, Inc. Bug database Bug 4207056 was opened 1999-01-29. http://bugs.sun.com. [25] Sun Microsystems, \nInc. Java SE HotSpot at a glance. http: //java.sun.com/javase/technologies/hotspot/. [26] Sun Microsystems, \nInc. JVMTM tool interface, version     1.1. http://java.sun.com/javase/6/docs/platform/ jvmti/jvmti.html, \n2006. [27] Sun Microsystems, Inc. Debugging a Java application with dbx. http://docs.sun.com/app/docs/doc/819-5257/ \nblamm?a=view, 2007. [28] G. Tan, A. W. Appel, S. Chakradhar, A. Raghunathan, S. Ravi, and D. Wang. Safe \nJava native interface. In International Symposium on Secure Software Engineering (ISSSE), 2006. [29] \nG. Tan and J. Croft. An empirical security study of the native code in the JDK. In Usenix Security Symposium \n(SS), 2008. [30] G. Tan and G. Morrisett. ILEA: Inter-language analysis  across Java and C. In Object-Oriented \nProgramming Systems and Applications (OOPSLA), 2007. [31] Z. Tatlock, C. Tucker, D. Shuffelton, R. Jhala, \nand S. Lerner. Deep typechecking and refactoring. In Object-Oriented Pro\u00adgramming Systems Languages and \nApplications (OOPSLA), 2008. [32] A. P. Tolmach and A. W. Appel. Debugging standard ML without reverse \nengineering. In LISP and Functional Programming (LFP), 1990. [33] M. van den Brand, B. Cornelissen, P. \nOlivier, and J. Vinju. TIDE: A generic debugging framework tool demonstra\u00adtion. Electronic Notes in \nTheoretical Computer Science, 141(4), 2005. [34] Visual studio debugger extensibility. http://msdn. microsoft.com/en-us/library/bb161718(VS.80) \n.aspx. [35] M. White. Debugging integrated Java and C/C++ code. http://web.archive.org/web/20041205063318/ \nwww-106.ibm.com/developerworks/java/library/ j-jnidebug/, Nov. 2001. [36] M. White. Integrated Java technology \nand C debugging using the Eclipse platform. In JavaOne Conference, 2006. [37] A. Zeller. Why Programs \nFail: A Guide to Systematic Debugging. Morgan Kaufmann, Oct. 2005.   \n\t\t\t", "proc_id": "1640089", "abstract": "<p>Programmers build large-scale systems with multiple languages to reuse legacy code and leverage languages best suited to their problems. For instance, the same program may use Java for ease-of-programming and C to interface with the operating system. These programs pose significant debugging challenges, because programmers need to understand and control code across languages, which may execute in different environments. Unfortunately, traditional multilingual debuggers require a <i>single</i> execution environment.</p> <p>This paper presents a novel <i>composition</i> approach to building portable mixed-environment debuggers, in which an intermediate agent interposes on language transitions, controlling and reusing single-environment debuggers. We implement debugger composition in <i>Blink</i>, a debugger for Java, C, and the Jeannie programming language. We show that Blink is (1) relatively simple: it requires modest amounts of new code; (2) portable: it supports multiple Java Virtual Machines, C compilers, operating systems, and component debuggers; and (3) powerful: composition eases debugging, while supporting new mixed-language expression evaluation and Java Native Interface (JNI) bug diagnostics. In real-world case studies, we show that language-interface errors require single-environment debuggers to restart execution multiple times, whereas Blink directly diagnoses them with one execution. We also describe extensions for other mixed-environments to show debugger composition will generalize.</p>", "authors": [{"name": "Byeongcheol Lee", "author_profile_id": "81444600875", "affiliation": "University of Texas at Austin, Austin, TX, USA", "person_id": "P1728761", "email_address": "", "orcid_id": ""}, {"name": "Martin Hirzel", "author_profile_id": "81100572340", "affiliation": "IBM Watson Research Center, Hawthorne, USA", "person_id": "P1728762", "email_address": "", "orcid_id": ""}, {"name": "Robert Grimm", "author_profile_id": "81100553777", "affiliation": "New York University, New York, USA", "person_id": "P1728763", "email_address": "", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "University of Texas at Austin, Austin, TX, USA", "person_id": "P1728764", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640105", "year": "2009", "article_id": "1640105", "conference": "OOPSLA", "title": "Debug all your code: portable mixed-environment debugging", "url": "http://dl.acm.org/citation.cfm?id=1640105"}