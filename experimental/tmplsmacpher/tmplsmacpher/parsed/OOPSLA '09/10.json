{"article_publication_date": "10-25-2009", "fulltext": "\n Accelerating the Creation of Customized, Language-Speci.c IDEs in Eclipse Philippe Charles, Robert \nM. Fuhrer, Stanley M. Sutton Jr., Evelyn Duesterwald IBM T. J. Watson Research Center P.O. Box 704, \nYorktown Heights, NY 10598 pcharles, rfuhrer, suttons, duester@us.ibm.com Abstract Full-featured integrated \ndevelopment environments have become critical to the adoption of new programming lan\u00adguages. Key to the \nsuccess of these IDEs is the provision of services tailored to the languages. However, modern IDEs are \nlarge and complex, and the cost of constructing one from scratch can be prohibitive. Generators that \nwork from lan\u00adguage speci.cations reduce costs but produce environments that do not fully re.ect distinctive \nlanguage characteristics. We believe that there is a practical middle ground be\u00adtween these extremes \nthat can be effectively addressed by an open, semi-automated strategy to IDE development. This strategy \nis to reduce the burden of IDE development as much as possible, especially for internal IDE details, \nwhile open\u00ading opportunities for signi.cant customizations to IDE ser\u00advices. To reduce the effort needed \nfor customization we pro\u00advide a combination of frameworks, templates, and genera\u00adtors. We demonstrate \nan extensible IDE architecture that em\u00adbodies this strategy, and we show that this architecture can be \nused to produce customized IDEs, with a moderate amount of effort, for a variety of interesting languages. \nCategories and Subject Descriptors D.2.6 [Software Engi\u00adneering]: Software integrated development environments \nGeneral Terms Languages Keywords IDE, Eclipse, generation, meta-tooling, IDE workbench. 1. Introduction \nAfter decades of activity, programming languages remain a vital area of active research, and new languages \nare intro- Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n2009October 25 29, 2009, Orlando, Florida, USA. Copyright 2009ACM978-1-60558-734-9/09/10...$10.00 c Jurgen \nVinju CWI Amsterdam, Netherlands jurgen.vinju@cwi.nl duced with surprising frequency. Motivations include \nbasic research into new computing and system architectures, new application domains, new programming \nparadigms, and ped\u00adagogical purposes. Some topics of recent special interest in\u00adclude parallel languages \n(e.g., X10 (Charles et al. 2005)), domain-speci.c languages, scripting languages (e.g., Ruby (ruby-lang.org) \nor Python (python.org)), and aspect-oriented languages (e.g., AspectJ (eclipse.org/aspectj)). In fact, \nthis trend may even deepen: language-oriented programming (Fowler) aims to make the development of languages \ncost\u00adeffective even for use in a single application. Alongside this proliferation of languages, the last \n25 years have seen Integrated Development Environments (IDEs) rise from novelty status to fundamental \nneed. IDEs provide critical tooling, such as editors, viewers, dependency man\u00adagement, and build support, \nthat enable programming lan\u00adguages to be used most effectively. The existence of a full\u00adfeatured IDE \nhas become critical to a language s widespread adoption. Such a rich feature set comes at a cost, however: \nmod\u00adern IDEs are large and complex software systems, incorpo\u00adrating large amounts of highly customized \nlanguage-speci.c functionality. As a result, constructing a modern IDE from scratch requires a level \nof effort and cost that is often pro\u00adhibitive. An alternative approach to IDE development relies on au\u00adtomatic \ngeneration. Examples include the Synthesizer Gen\u00aderator (Reps and Teitelbaum 1984), the ASF+SDF Meta-Environment \n(van den Brand et al. 2001), and SmartTool\u00ads (Attali et al. 2001). In this approach, meta-tools consume \na speci.cation of the syntax and (possibly) semantics of the language, and generate tools such as parsers, \ncompilers, in\u00adterpreters, and debuggers. Some of these systems are capable of generating IDE tooling, \nsuch as editors and viewers. Al\u00adthough this can greatly relieve the burden of producing the IDE, it comes \nwith signi.cant limitations. Speci.cally, while generation-based IDEs provide basic functionality for \nthe given language, they do so at the expense of the language\u00adspeci.c customizations in appearance and \nbehavior that give the greatest productivity boost. Often, their feature sets pro\u00advide only the lowest-common \ndenominator across all lan\u00adguages, resulting in IDEs that do not offer the leverage that makes IDEs popular. \nAdditionally, the meta-tools for gen\u00aderation often dictate the use of speci.c parsing or compiler technology. \nThis can be highly impractical in cases where a compile front-end already exists that would have to be \nre\u00adwritten to match the required parsing technology. For these reasons, generation-based approaches, \nwhile successful in limited applications such as parser generators, have not had corresponding success \nin the domain of IDEs.  In fact, these two development approaches represent the end-points of a spectrum. \nBuilding a high-powered IDE from scratch is feasible when a sizable group of people with the appropriate \nexpertise make a substantial and sustained resource commitment. Generating an IDE from a language speci.cation \ncan be performed by a small group (or an indi\u00advidual) when the main interest and expertise is in language \ndevelopment and a basic IDE is adequate to their purpos\u00ades. We see a practical middle ground between \nthese two extremes of IDE development, one where a high degree of reuse is balanced with ful.llment of \nlanguage-speci.c re\u00adquirements, where incremental efforts are rewarded by in\u00adcremental value, and where \ndevelopers can pick the degree of functionality and the level of investment. We hypothesize that this \nmiddle ground can be effectively addressed by an open, semi-automated strategy for IDE de\u00advelopment. \nFirst, we relieve the IDE developer of as much of the burden of IDE development as possible, particularly \nfor those parts of the IDE that are of least interest, such as the internal details of user interface \ncomponentry. Second, to af\u00adford maximum .exibility for customization, we de.ne open interfaces for the \nimplementation of IDE services and make it possible to provide a service in entirely original ways. To \nreduce the effort that is needed, we facilitate the implemen\u00adtation and customization of IDE services \nby a combination of frameworks, templates, generators, and domain-speci.c languages. Finally, we provide \nother avenues to IDE cus\u00adtomization, including the ability to select which services are incorporated \ninto the IDE and the ability to introduce ser\u00advices ad hoc. This strategy effectively combines the power \nof tool generation with the .exibility of manual construction. Our contribution in this paper is two-fold. \nFirst, we demonstrate an extensible IDE architecture that separates and encapsulates the language-independent \nframework, ex\u00adposes signi.cant points for language-speci.c extensions and customizations, and generally \nenables these extensions and customizations to be implemented with minimal reference to the underlying \nframework. Second, we show that this ar\u00adchitecture is practical and can be used to produce useful IDEs \nfor a variety of interesting languages with a moderate amount of effort. Additionally, we have implemented \nour approach as the IDE Metatooling Platform (IMP), which is available as an Eclipse Project on www.eclipse.org/imp. \nThis paper updates and elaborates work previously pub\u00adlished in (Charles et al. 2007), describing new \nfeatures, giv\u00ading additional details about the development process and architecture, and reporting new \ninformation on experience and evaluation. The rest of this paper is organized as follows. Section 2 states \nour vision of an IMP IDE and contrasts this brie.y with some other approaches. Section 3 states our goals \nand approach more speci.cally. As a means to document the lev\u00adel of effort involved in developing an \nIMP IDE, the IMP IDE development process is explained in Section 4. Sec\u00adtion 5 presents the IMP architecture, \nhighlighting aspects that make the IMP approach to IDE development possible. Section 6 describes experience \nwith IMP (mostly our own) and Section 7 gives an evaluation based mainly on that expe\u00adrience. Section \n8 discusses related work. Section 9 presents some open issues, and we conclude in Section 10.  2. An \nIMP IDE As stated earlier, our primary goal is to facilitate the devel\u00adopment of language-speci.c IDEs \nin Eclipse. The premier example for such an IDE is the Java Development Toolkit (JDT) (eclipse.org/jdt). \nThe JDT exempli.es both a sensible approach to IDE architecture and a useful set of tools, fea\u00adtures, \nand functions. On the architectural level, the JDT consists of a collec\u00adtion of Java-oriented tools which \noperate on an abstract mod\u00adel of Java workspaces, projects, and programs. Some of the JDTs tools are \nde.ned as extensions of more general user\u00adinterface elements provided by the Eclipse framework. Ad\u00additional \nservices that support software development in gen\u00aderal, such as resource management, version control, \nprefer\u00adences support, and support for plug-in development, are also provided by Eclipse. Moreover, the \nEclipse framework s ex\u00adtensibility permits the creation of additional Java-speci.c or Java-compatible \ntools and services. Similarly, an IMP IDE is a collection of mainly language\u00adspeci.c tools organized \naround an abstract program mod\u00adel that are situated in the larger context of an Eclipse workspace. IMP \nalso supports the development of language\u00adindependent IDE features. Many IMP-based tools extend el\u00adements \nin the Eclipse framework. Users of an IMP IDE are able to draw on other components available through \nEclipse to address services that IMP does not support. Like Eclipse, IMP is itself extensible and offers \nsupport for an expanding variety of tools and functions. Although IMP provides support speci.cally for \nbuilding IDEs in Eclipse, many aspects of its approach generalize readily to other IDE frameworks. Also, \nIMP does not di\u00adrectly address IDE development through infrastructure such as noti.cation mechanisms, \ncommunication buses, or object repositories (e.g., (Reiss 1990; Purtilo 1994; Kadia 1992)). At the same \ntime, IMP does nothing to prevent the use of such mechanisms; e.g., Eclipse provides an extensive frame\u00ad \n  Figure 1. An IMP-based IDE for the LPG grammar speci.cation language work for tool noti.cation and \nresource management that in\u00adteroperates with IMP. Similar to the JDT, an IMP IDE offers what many devel\u00adopers \nhave come to expect from a modern IDE: a language\u00adsensitive editor with features such as syntax highlighting, \nhover help, hyper-linking (e.g., from references to declara\u00adtions), and content assist; structural and \nnavigational views (e.g. outline views); and program building services. Figure 1 shows a screenshot of \nan IMP-based IDE with various el\u00adements called out. While the look and feel of the depicted IDE is similar \nto the JDT, the language for which it is in\u00adtended is the grammar speci.cation language for the LPG parser \ngenerator (lpg.sourceforge.net). Figure 2 shows a listing of IDE services that are available (or under \ndevelopment) in IMP, as an image of the menu by which service implementations are created. Many of these \nservices will be familiar to users of modern IDEs; several are discussed in detail later in the paper. \nA few menu en\u00adtries are not targeted at speci.c services but instead represent generic hooks for the \nintroduction of arbitrary functionality in different contexts. These include the Editor Actions Con\u00adtributor, \nwhich adds commands to the editor s context menu, the Introduced Editor Service, which speci.es functions \nto be invoked automatically along with other editor services, and the Refactorings Contributor, which \naugments the set of language-speci.c program refactorings. The LPG category of services in Figure 2 addresses \nsyntax de.nition and parser generation via the LPG pars\u00ader generator (lpg.sourceforge.net). However, \nIMP does not mandate any particular technology for syntax de.nition, parsing, or program representation \n the IDE developer can choose any desired technology (see Sections 4 and 5). Nonetheless, the IMP distribution \nincludes, as an option, the LPG parser generator and an accompanying IDE in order to offer a more complete \npackage for out-of-the-box IDE development. As of this writing, IMP does not provide any framework components \nor meta-tooling for developing or interacting with language runtimes and debuggers. Although IMP s ag\u00adnostic \nposition with respect to language technology makes  Figure 2. IMP support for IDE services. de.ning \nruntime and debug-time tooling more dif.cult (re\u00adquiring a bridging layer of semantic descriptions), \nwe be\u00adlieve it is still eminently possible. This is an open area for research and further development. \n 3. Goals and Approaches Through a hybrid approach to IDE development, combining the .exibility of manual \nconstruction with those of automat\u00aded generation, we hope to achieve the following goals: To support \nthe development of IDEs by people whose primary competency is not IDE development or user\u00adinterface frameworks. \nThis includes, for example, lan\u00adguage developers. To support the development of effective IDEs,that is, \nIDEs that have a substantial subset of the features and functions that are expected in a modern IDE, \nand that have acceptable performance and size characteristics. We consid\u00ader the Eclipse Java Development \nToolkit (eclipse.org/jdt) as the gold standard of IDE effectiveness. To signi.cantly reduce the time \nand effort required to develop a useful IDE. Where it might now take several IDE specialists person-months \nof effort to develop a modest IDE for a moderately sized language, our goal is to reduce that to a few \nperson-weeks of effort by a non-specialist. Ultimately, we intend to shift the economics of IDE development \nsuch that IDEs can be developed on demand as a normal part of language de.nition, application development, \nresearch projects, and academic courses. To enable signi.cant customization of both the set of IDE features, \nand the behavior of those features. Cus\u00adtomization for speci.c languages, users, and purposes is a key \nto an IDE s success. To accommodate alternative tooling for key IDE com\u00adponents such as parsers, AST \nrepresentations, and edi\u00adtors. This allows IDE developers to use whatever software assets they already \nhave to lower development costs, and still gain the bene.ts of an IDE framework. To allow IDEs to be \ndeveloped selectively, iteratively and incrementally. This allows IDE developers to focus .rst on priority \nfeatures, and allowing them to add additional features if and when the need arises. To realize these \ngoals, we further base our approach to IDE meta-tooling on the following design principles: Build IDE \ncomponents and services upon models of the program under development (rather than linking services directly \nto one another). This enables incremental devel\u00adopment of IDE services and increases the substitutability \nof IDE components.  Enable as much of the IDE as possible to function inde\u00adpendently of any particular \nservice. This facilitates selec\u00adtive and incremental development.  Provide templates for IDE service \nimplementations that help developers focus on language-speci.c customiza\u00adtions and other important aspects \nof IDE behavior and appearance.  Provide language independent base classes for service implementations. \nWhere possible, provide concrete class\u00ades that provide a useful level of functionality without modi.cation. \n Separate the creation, management, and invocation of editor services from the editors and other views, \nso that the editor is replaceable.   Support an open-ended set of services with public exten\u00adsion points. \nThis supports the usability, extensibility, and customizability of developed IDEs. The following sections \naddress our implementation of these approaches.  4. IMP Development Process This section gives an overview \nof the process of developing an IMP-based IDE. We illustrate that IMP affords the follow\u00ading bene.t automatically: \n(i) that in-depth knowledge of the framework (especially that of the underlying Eclipse frame\u00adwork) is \nnot required to implement substantial, customized IDE services; (ii) that the effort required is proportional \nto the bene.t received (i.e., that there is low development over\u00adhead relative to the functionality of \ninterest); and (iii) that the expertise required for IDE development centers around knowledge of the \nlanguage. Before beginning development of the various services, the developer must supply basic information \nabout the lan\u00adguage. This is done through a New Programming Lan\u00adguage wizard, which collects a list of \n.lename extensions a\u00adlong with a unique identi.er for the language (used to match content to the appropriate \nservice implementations). For the most part, the IDE developer can select the de\u00adsired services and implement \nthem in any order. The most obvious exception to this is the parsing service, which gener\u00adally comes \n.rst, since most services rely on the token stream and ASTs. There are a few additional (though fairly \nobvi\u00adous) dependencies that imply an order (e.g., content assist typically depends on reference resolution). \nEach step in the process is initiated by means of a wizard through which the user identi.es the target \nproject, language, and service implementation classes. Certain wizards permit limited customization through \nadditional .elds, rather than by modifying the service implementation code. Finishing the wizard typically \nhas two effects. First, an extension is created in the plug-in meta-data that register\u00ads the service \nimplementation with the IMP runtime. Sec\u00adond, a skeletal service implementation is generated, which may \nprovide limited functionality without further implemen\u00adtation (e.g., the skeletal token-colorer highlights \nkeyword\u00ads). However, most services naturally require additional work to implement the desired functionality. \nIMP alleviates the burden of this additional work by factoring the language\u00adindependent infrastructure \nconcerns into framework classes, enabling the developer to focus on language-speci.c con\u00adcerns. IMP also \nprovides domain-speci.c languages for cer\u00adtain services, to minimize syntactic and semantic overhead. \nThe generated skeletons contain an example implemen\u00adtation for a simple, block-structured, imperative \nlanguage, called LEG ( Little Expression Grammar ). The generat\u00aded .les are automatically opened in the \nappropriate editor and positioned where customizations are to be performed. 4.1 IDE Services IDE services \ncan be divided into user visible services (e.g. token coloring) and internal services (such as parsing \nand reference resolution). We discuss below the implementation of a representative selection of services \nof both kinds. The .rst service typically implemented is the parser ser\u00advice, which must implement the \nparse controller interface. IMP is designed to work with any parser, whether hand\u00adcoded or generated, \nso this interface is appropriately neutral. For example, it includes methods to parse a string (returning \nthe resulting AST), to get the keywords of the language, or to return an iterator over tokens within \na given range in the source text. Additionally, IMP interfaces typically represent abstract syntax trees \n(ASTs) and other language-speci.c en\u00adtities as plain objects. To facilitate the creation of a parser, \nthe IMP meta-tooling includes a complete IMP-based IDE for the LPG parser generator (lpg.sourceforge.net). \n(Similar support can easily be added to IMP for other parser generators.) Like many modern parser generators, \nLPG features include automatic generation of AST classes from the grammar, as well as AST visitor classes \nto assist in AST traversal. For developers using other parser generators, or existing parsers, or who \nwant to write their parser manually, IMP also provides a parser-wrapper wizard that creates a skeleton \nfor the parse controller class that delegates all operations to the existing parser class. Once this \nstep is complete, the nascent IDE is already (minimally) usable: the source editor provides live pars\u00ading, \npresenting syntax errors as source annotations. Perhaps the simplest user-visible service to implement \nis token coloring (syntax highlighting). The principal method in the requisite interface for this service \nis getColoring(IParseController, Object) where the Object represents the text to be colored and the parse \ncontroller provides access to the AST, among oth\u00ader things. The Object given to getColoring is typically \na lexical token. In any case, the entity s kind is used to deter\u00admine the text attributes to apply to \nthe corresponding source. Information about the context of the token in the surround\u00ading AST can also \nbe consulted. To determine how much text to re-color for any given textual change, the token colorer \ninterface de.nes the method calculateDamageExtent(IRegion) which takes a damaged (modi.ed) text region \nand returns a possibly larger one whose coloring needs to be updated. By default, this method simply \nreturns the region it was given. The label provider and documentation provider ser\u00advices are implemented \nsimilarly to the token colorer in that both take a program entity (often representing an AST node) and \nreturn a value based on the type of the entity. In the for\u00admer case, the value returned is the text or \nimage to be used to represent the given entity in various UI views. In the latter, the value is the relevant \ndocumentation for the given entity (e.g., its JavaDoc).  Some IMP services, such as the source-text \nfolder and tree-model builder1, are easily implemented using AST visitors. The service implementor provides \na visit(...) method for each AST-node type for which source folding or an outline item is desired. For \na source folder, the trivial visit(...) method for any foldable AST-node type con\u00adsists of a call to \nthe method FolderBase.makeFoldable(). For a tree-model builder, the visitor implementation is on\u00adly slightly \nless trivial, as it typically must ensure that the tree model mirrors the AST s structure. Both the source \nfolder and tree-model builder permit more complex logic, e.g., to fold regions of text that don t correspond \nexactly to AST nodes or to rearrange the tree model (e.g. sorting a node s children based on their type \nor labels). As shown in Section 7, though, the typical implementation of a visitor method is just a couple \nof lines. As a result, the size of these service implementations depends mainly on the number of nodes \naddressed. Reference resolution is a core internal service in IMP that is used by several other services. \nThe principal method to implement is getLinkTarget(...). If a compiler front end is available to provide \nbinding information, this method can simply return the precomputed binding. If not, it must produce this \ninformation by other means. The hover-help service is one for which IMP provides a default implementation \nbut which also facilitates consider\u00adable customization. This implementation takes advantage of a reference \nresolver and a documentation provider, if avail\u00adable. First, if a reference resolver exists, it is used \nto .nd the declaration corresponding to the AST node over which the cursor hovers, if that node is a \nreference node; otherwise, the hovered node is used. Next, if a documentation provider exists, the hover \nhelper returns whatever the provider pro\u00adduces for that node. If no documentation provider exists, the \nhover helper simply returns the source text associated with that AST node. Finally, if no reference resolver \nexists, the default hover helper simply returns the source text associat\u00aded with the given AST node, \nif different from the hovered node. Of course, if the above logic is insuf.cient, the de\u00adveloper can \nalways create a custom hover implementation to completely control the information that is presented. \nIn all cases, however, note that the IDE developer is responsible only for de.ning what to display, rather \nthan how or when to display it.  4.2 Arbitrary Services IMP provides extension points and supporting \nmechanisms explicitly designed for a number of anticipated IDE services such as token coloring and text \nfolding (see Section 7 for a more complete list). The following additional extension 1 The tree model \nis available for any client s use; the standard IMP outline view uses it to present the source text s \nstructure. points allow for the introduction of arbitrary services in a number of speci.c contexts: \nThe model listener extension point permits arbitrary clients to be noti.ed whenever the source model \n(AST) changes in response to text edits.  The refactoring contributor extension point allows IDE plugins \nto contribute one or more language-speci.c refactorings. Refactorings are generally triggered on be\u00adhalf \nof a selected program entity (e.g., in the source editor or outline), via the context menu.  The editor \nactions contributor extension point allows IDE plugins to programmatically contribute actions to the \nEclipse menu bar, tool bar, and status bar.  IMP provides wizards for each of these extension kinds \nthat generate very basic implementation skeletons.In the case of the New Refactoring wizard, however, \nthe code skeletons themselves encapsulate nontrivial knowledge about the re\u00adlationship among several \nkey Eclipse APIs for refactoring, structured text rewriting, undo support, and the like. 4.3 Help for \nthe IDE Developer The IMP development process is well documented, with a User s Guide and Eclipse cheat \nsheets. Cheat sheets are in\u00adtegrated into the IMP IDE, and provide a semi-interactive, step-by-step guide \nthrough the development process. Also included is documentation for LPG, the PrefSpecs language for specifying \npreferences and preference pages, and the source formatting language and IDE. The IMP IDE devel\u00adoper \ncan actually run through all of the IMP wizards and create an operational LEG IDE without editing any \ncode; this IDE can then be used for experimenting with alternative language formulations or service implementations. \nThe IMP release contains the source for several functioning IMP IDEs that are part of IMP itself, notably \nfor the LPG, PrefSpecs, and source formatting languages, as well as others that are under development. \nThe IMP-based IDE for X10 is available as open-source on SourceForge.  5. IMP Architecture 5.1 Meta-Tooling \nand Runtime IMP consists of two kinds of components: meta-tooling components, which are used when developing \nan IDE, and runtime components, which are used during the execution of that IDE. The relationship between \nthese two sets of compo\u00adnents is depicted in Figure 3. The meta-tooling components includes wizards, \ntemplates, and generators that are used (as described in Section 4) to declare a language and develop \nspeci.c IDE services. The meta-tooling also includes sev\u00aderal IMP-based IDEs for domain-speci.c languages \nto aid in implementing certain services. Among these languages are LPG grammar and preference page speci.cations \n(see Sections 2 and 4).  Figure 3. IDE Development and IDE Runtime The IMP runtime framework builds \non the Eclipse Rich Client Platform , a set of generic, mostly programming\u00adoblivious components, comprising \ntext editors, tree views, and so forth. IMP components extend these to provide user\u00advisible IDE services \nthat are relevant to most programming languages such as source editors, parser problem annotations and \nmarkers and structural views. The IMP runtime frame\u00adwork also provides internal functions critical to \nan IDE s execution, such as the identi.cation, instantiation, and dis\u00adpatching of language-speci.c services \n(discussed below). The IMP meta-tooling and runtime frameworks are lan\u00adguage independent, but they naturally \nrely on language\u00adspeci.c code to provide the language-speci.c behavior for the various IDE services. \nTo plug language-speci.c services into the language-independent framework, IMP uses the Eclipse extension-point \nmechanism (Bolour). Speci.cally, most IDE services managed by the IMP runtime framework correspond directly \nto IMP-or Eclipse-de.ned extension points. Thus, as mentioned in Section 4, IMP service cre\u00adation wizards \ntypically create one or more implementation classes and register them as extensions of the corresponding \nextension point. IMP runtime components (such as the Uni\u00adversal Editor) then query the extension registry \nto .nd the implementations for the language service in question. As shown in Figure 4, IMP locates language-speci.c \nservice implementations using an IMP-maintained mapping from .lename extensions to known languages. This \nmapping is de.ned by extensions of the IMP language descriptor extension point.2 Likewise, the extension \nmetadata for each service implementation identi.es the language for which it is intended. 2 This is done \nin part so that service implementations can be distributed across multiple plug-ins. these is token coloring, \nwhich identi.es the text attributes to be used in displaying each source text entity. For this service, \nIMP de.nes the tokenColorer extension point. Extensions of this extension point must implement the IMP \nITokenColorer interface. The New Token Colorer wizard generates a skeleton implementation of this inter\u00adface, \nand automatically registers it as an extension of the tokenColorer extension point. (The implementation \nwill typically be customized by the IDE developer.) At runtime, when the IMP editor opens a .le belonging \nto a given lan\u00adguage, it consults the IMP Language Registry and Service Manager (as shown in Figure 4) \nto locate the extension of the tokenColorer extension point for that language. If one exists, the implementation \nclass is used to color the source.  5.2 Runtime Operation The execution .ow of the token colorer is \ntypical of most language services: it is invoked by the IMP framework, per\u00adforms some language-speci.c \nanalysis on its arguments, and returns the results to the framework. Interactions between the service \nand the rest of the IDE infrastructure are man\u00adaged entirely by IMP. This arrangement enables the service \nimplementations to focus on language-speci.c structure and semantics rather than on user interface APIs \nor other infras\u00adtructure components. Figure 5 depicts the .ow of events that lead from user editing actions \nto the resulting analyses and view updates. To .rst order, source document changes result in the updating \nof one or more models, such as the token stream, AST, and search indices. Changes to these models are \npropagated to listeners that form the basis for nearly all IDE services. In more detail, editing actions, \nsuch as inserting text, re\u00adsult in a region of damaged source text, managed by the underlying Eclipse \ntext components. The damaged region is propagated in the foreground (i.e., in the same thread) to an \nIMP service controller class, which mediates between the IMP framework components (e.g., the editor) \nand the language-speci.c services. In particular, this controller in\u00ad  Figure 5. Service scheduling \n Figure 6. Service dependence on analyses vokes the parsing service to produce the new token stream \nand AST from the source text. Certain light-weight listeners are noti.ed synchronously (e.g., for token \ncoloring). Oth\u00ader listeners are noti.ed of model changes pending suf.cient idle time. If more edits arrive \nin the interim, pending noti.\u00adcations are abandoned, and another model update cycle be\u00adgins.3 For heavier-weight \nanalyses, such as search index cre\u00adation, background jobs listen for changes to resources with\u00adin the \nworkspace, and perform the appropriate processing to update their results. Certain services, e.g., refactoring, \nmay require additional analyses that are too expensive to perform eagerly; hence they are only performed \non demand. Depen\u00addences of various services on various kinds of analysis are shown in Figure 6. 3 In \nfact, parsing and other analyses can be interrupted, if the parser supports the appropriate API. At present, \nmodel changes are represented as entirely new models; in the future, some analyses may process changes \nincrementally.  5.3 Architectural Substitution The same architectural features that accommodate pluggable \nIDE services also supports substitution of major IDE com\u00adponents, such as the editor. Editor substitution \nis useful for languages with unusual syntactic requirements that are oth\u00aderwise amenable to typical IDE \nservices. For example, lega\u00adcy languages such as FORTRAN or COBOL are column\u00adsensitive and require specialized \nediting functionality that the Eclipse text editor does not support. By separating the Language Registry \nand Service Manager from the IDE com\u00adponents, as shown in Figure 4, and by encapsulating the ini\u00adtialization \nand con.guration of the IMP runtime framework, editor substitution is straightforward. A foreign editor \ncan be integrated by extending or wrapping it and using the Lan\u00adguage Registry and Service Manager to \naccess IMP meta\u00addata and services. It is similarly straightforward to do like\u00adwise with other services \nand views.  6. Experience We have substantial experience in using IMP and IMP-based IDEs. Several IMP-based \nIDEs are part of the IMP release: The LEG language is a simple, procedural language that is provided \nfor pedagogical purposes.  The Box (van den Brand and Visser 1996) language is a simple DSL for text-formatting \nrules. This IDE was orig\u00adinally developed to support the debugging of Box tools and is now an integral \npart of IMP s source formatting speci.cation editor.  The PrefSpecs language is a DSL for the speci.cation \nof preference pages, .elds and values. We have used this IDE for the preferences of IMP itself, as well \nas for other IDEs listed here.  The LPG grammar speci.cation language is used by the LPG parser generator. \nWe have used the LPG IDE in specifying the grammars for a wide variety of languages (e.g., Box, X10, \nPrefSpecs, COBOL, and the LPG gram\u00admar speci.cation language itself). The LPG IDE can be used separately \nfrom IMP.  The PSP language is a DSL for declarative aspects of IDE presentation.  We and others have \nalso used IMP to develop IDEs that are not part of the IMP release: The X10DT, an IDE for the X10 language \n(Charles et al. 2005), an extension of Java for highly concurrent applica\u00adtions such as scienti.c and \nengineering applications (this IDE is available as part of the X10 release (X10.source\u00adforge.net))  \n An extension to an existing COBOL IDE to provide sup\u00adport for COBOL development on Eclipse (released \nas part of IBM s Rational Developer for zSeries (RD/z))  An IDE for SDF and ASF+SDF, which is a port \nof The Meta-Environment (van den Brand et al. 2001) to Eclipse using IMP.  An IDE for Rascal, a DSL \nfor source code analysis and manipulation based on a combination of algebraic spec\u00adi.cation and relational \ncalculus primitives (Vinju et al. 2008). Its intended application domain is implementation of static \nanalyses and refactorings for other DSLs intend\u00aded for use in IDEs.  An IDE for ToolBus Script, a coordination \nlanguage based on algebra of communicating processes (ACP). It connects tools written in arbitrary languages \nto a coor\u00addination bus which is scripted in a formal language that can be easily analyzed (Fokkink et \nal. 2008).  Spoofax/IMP is an IDE tooling platform integrating S-DF and Stratego/XT into Eclipse. It \nuses SDF(Heering et al. 1989) for de.ning grammar rules and Stratego (Viss\u00ader 2004) for semantic rules \nand realizes the IDE using IMP (Kats and Kalleberg 2009).  IMP is also used to develop IDEs as part \nof other projects in IBM Research, such as an IDE for the SPADE stream\u00adprocessing speci.cation language \n(Gedik et al. 2008). Most of the IDEs listed above are publicly available. To give just a few observations \nabout our experience, the above languages range in grammar size from fewer than two dozen rules (for \nBox), to over 1000 rules (for COBOL). The size of the IDEs also varies widely, in terms of both code \nsize and the number of features realized. Some representative numbers on code size are given in Section \n7.3. Regarding the number of features, the set of typical core features for the IDEs that have been developed \nas part of IMP include Parsing with error annotations and problem markers  Syntax highlighting (token \ncoloring)  Source-text folding  Tree model builder (used, e.g., in outlining)  Label provider (used, \ne.g., in outlining)  Reference resolution (used, e.g., in hover help and occur\u00adrence marking)  Hover \nhelp  Occurrence marking  Content assist  Documentation provider  Project building  These are all \nfound in the LEG, LPG, and PrefSpecs IDEs and in X10DT. Additionally, the PrefSpecs IDE has a second \ndocumentation provider and the LPG IDE provides several refactoring and context-menu actions. The LPG \nand X10 IDEs have an IMP-based preference page (as does IMP itself). Some IMP-based IDEs implement only \na subset of these features. The COBOL IDE offers only six of the above-listed services, but these are \nused in conjunction with other ser\u00advices and tools developed earlier outside of Eclipse. The Box IDE \nhas only parsing, syntax highlighting, and a builder, which were suf.cient for its intended purpose of \nsupport\u00ading debugging of Box tooling. The Rascal IDE has parsing, syntax highlighting, outlining, and \na custom console. This clearly demonstrates that IMP reduces the cost of building IDEs to the point that \nit can be sensible to do so even for a relatively modest payoff. The kinds of languages that have been \nsupported through IMP include both speci.cation languages and programming languages; the former have \nbeen mainly domain speci.c, while the latter have been more general purpose. In developing IMP we have \nseen a number of opportuni\u00adties where a domain-speci.c language could facilitate IDE development. Taking \nadvantage of such opportunities was considerably easier because IMP made it practical to develop IDEs \nfor these languages. Other IMP users have also found it opportune to couple IMP with DSLs to support \naspects of IDE development (e.g., as for The Meta-Environment, Ras\u00adcal (Vinju et al. 2008), and Spoofax/IMP \n(Kats and Kalle\u00adberg 2009)). IMP has also provided the leverage to move some existing IDEs (e.g., for \nCOBOL, The Meta-Environment) onto a new platform (i.e., Eclipse).  7. Evaluation This section evaluates \nIMP against the goals set in Section 3. The basis for this evaluation is our experience in using IMP \nto build the IDEs described in the previous section. As dis\u00adcussed there, these languages and their IDEs \nvary widely is character and size. Many are in regular use, and most are publicly available. Table 1 \nlists several of the languages and gives measurements of the size of their grammars. Language # non-terminals \n#rules Box 9 21 LEG 23 37 PrefSpecs 66 71 LPG 66 100 ToolBus Script  118 X104 69 204 Rascal5 200 582 \nCobol 535 1124  Table 1. Languages with IMP IDEs and their grammar sizes 7.1 Ease of IDE Development \nHow hard is it for someone who is not an IDE expert to build an IMP IDE? In principle this could be measured \nex\u00adperimentally, but such experiments are beyond the means of our project. Thus, we have not had the \nopportunity to con\u00adduct trials that would allow a truly robust quantitative eval\u00aduation. So, while the \nevidence collected to date is primarily anecdotal and qualitative, it nevertheless suggests that we have \nmade substantial progress toward our goal. We have observed a number of novice IMP users that were able \nto construct nontrivial IDEs with no particular background in IMP or the Eclipse infrastructure and with\u00adout \nhelp much beyond the available documentation. We continue to .nd that IMP attracts both novice and experi\u00adenced \nIDE developers, both within IBM and externally (see news://eclipse.org/imp/). Furthermore, we know from \nour own experience that the amount of time needed to develop a nontrivial IDE or a signi.cant IDE service \nis relatively small (hours, days, or weeks, depending on the scale of the effort). Also, the amount of \ncode that needs to be written for many services is small in an absolute sense or relative to the complexity \nof the target language (e.g., the number of AST node types). Further details on these points are provided \nin Section 7.3. Finally, we have made several decisions in the design of IMP in large part (if not entirely) \nto ease the burden of IDE development. Examples include: Use of simple speci.cation languages and generators \nfor some services, such as preference pages and IDE presen\u00adtation  The provision of base classes and \nimplementation skele\u00adtons for many services that such that typical implementa\u00adtions can be programmed \nconcisely and without signi.\u00adcant reference to the Eclipse platform  The handling of IDE related extensions \nand extension points (e.g., for service registrations and lookup) by the IMP meta-tooling and runtime, \nthus freeing the IDE de\u00adveloper from involvement with these details  Additionally, IMP s ability to \nsupport iterative and incre\u00admental development makes it possible for novice developers to go slowly as \nthey are gaining experience. We regard this as an area for continuous improvement in IMP. For example, \nwe continue to re.ne base classes and interfaces as users help us discover how to improve their us\u00adability. \nAt the same time, we take care to preserve opportu\u00adnities for more sophisticated implementation approaches \nfor those users with more demanding requirements. 5 X10 data exclude elements of the Java, which serves \nas a base language. 5 Rascal data include elements adopted from the Java statement and expres\u00adsion languages. \n 7.2 Effectiveness of IDEs We consider the ability of IMP to support the development of effective IDEs \nfrom two angles: the set of services supported and IDE size and performance. 7.2.1 Supported Services \nThe set of services that an IDE may support is effectively open-ended. IMP provides direct support for \na signi.cant set of speci.c services, and the opportunity to add further, unanticipated services. Most \nof the services for which IMP provides development support are shown in Figure 2. This compares relatively \nfavorably with the range of services provided by industry-leading Java IDEs, such as the Eclipse JDT \n(eclipse.org/jdt). As noted previously, IMP s support for execution, runtimes, debugging, and refactoring \nis presently very limited.6 Support for indexing and searching in IMP is still under development. Also, \nIMP is lacking in the area of project-level navigation and support for entity-creation wizards (e.g., \nNew Project wizards). Most of the services indicated in Figure 2 are common in modern IDEs. The JDT in \nparticular is a highly advanced IDE that has been in commercial development for almost a decade and continues \nto advance. In contrast, basic IMP\u00adbased IDEs can be constructed within days or weeks, de\u00adpending on \nthe complexity of the language, features of inter\u00adest, and desired level of functionality.  7.2.2 Size \nand Performance We examine IDE size and performance metrics for a set of IMP IDEs to which we have access. \nSpeci.cally, we mea\u00adsured code size, memory footprint and interactive respon\u00adsiveness. Table 2 shows \nthe total size of the JAR .les that comprise the distribution of the IDEs under consideration. The size \nvaries widely depending on the size of the language and features in the IDE, among other things. For \nexample, the Cobol IDE provides fewer services than some of the others but for a much larger language, \nwhile the LPG IDE includes refactoring, search, and view support that is not found in most of the other \nIDEs. Also, unlike the other IDEs, the release for X10 does not include the AST representation (as the \nX10 compiler is packaged separately from the X10 IDE). Generally, though, these values are well within \nthe range of typical IDE-scale software systems, which may be megabytes larger (a recent JAR .le for \nJDT core source alone was about 3.5 MB). To give an indication of the runtime size of an IMP IDE, we \nmeasured the heap memory footprint using a synthetic workload that consisted of running the IDE and opening \nsix editors. The resulting memory footprint ranged from 23 MB for our smallest IMP-based IDE, the LEG \nIDE, up to 41 MB for our most complex IDE, the X10 IDE. For comparisons 6 IMP provides minimal support \nfor execution and debugging for languages that translate to Java.  IDE JAR Size (KB) LEG 164 PrefSpecs \n298 LPG 1,299 X10 1,425 Cobol 2,815 Table 2. Size of exported JAR .les for selected IMP IDEs. (Includes \nsource, binaries, meta-data, and miscellaneous .les.) we ran the same experiment with the JDT, which \nresulted in a memory footprint of 35 MB. This demonstrates that the size of an IMP-based IDE can vary, \ndepending on features of the IDE, but is generally within an acceptable range for an Eclipse IDE. To \nassess IDE responsiveness we instrumented several IMP IDEs to measure IDE start-up time. Cold start-up \ntime is measured as the time it takes to initially invoke the IDE with a representative input .le until \nthe IDE has initial\u00adized all views and is responsive to user input, excluding the Eclipse start-up time. \nWarm start-up time is the time it takes for consecutive editors to open. We measured cold and warm start-up \ntimes as the average over 4 experiments. Cold start-up times ranged from 2.3 seconds for the LEG IDE \n(opening a .le with 15 LOC) up to 4.7 seconds for the X10 IDE (opening a .le with 400 LOC). Consecutive \nwarm start-up times ranged from 0.04 seconds for the LEG IDE to 1.0 second for the X10 IDE. These numbers \nare more or less comparable to our experience with the Eclipse JDT and demonstrate that IMP-based IDEs, \neven complex ones, are suf.ciently responsive for interactive use.  7.3 Reduction of Time and Effort \nOur IMP IDEs have not been developed under controlled conditions, but our experience indicates that useful \nIMP IDEs can be developed in days or weeks. For example, development of the initial PrefSpecs IDE took \nabout one week by one person, beginning with the speci.cation of the grammar and generation of the parser \nusing LPG, and including implementations for token coloring, outlining, text folding, reference resolution, \ncontent assist, two alternative documentation providers, and a builder. For the Cobol IDE, the time required \nto implement vari\u00adous services has ranged from one hour or less (e.g., for the token colorer and source-text \nfolder) to several hours (e.g., for the occurrence marker). The very simple Box IDE took less than one \nday. The Rascal IDE (with parser, token col\u00adorer, outlining, and a custom console) took an experienced \nIMP developer less than two days. The ToolBus Script IDE was developed by two people in two days. Despite \nthe em\u00adphasis that we have placed on feature richness, sometimes a simple language-sensitive editor will \nmeet a developer s needs. In our experience, the most dif.cult part of building an IMP IDE may be de.ning \nthe grammar. Grammer de.nition requires careful consideration for any non-trivial language. IMP shields \nthe language developer from the complexities of IDE development, but we do not attempt to obviate the \nintellectual challenges of language design. For a complex language, the de.nition of the grammar may \ntake more time than the construction of a basic IDE using IMP. In order to provide an objective approximation \nof IDE development effort using IMP we measured the amount of custom code the IDE developer has to write \nin order to complete an IDE service implementation. Table 3 shows, for a representative set of services, \nthe numbers of custom lines of code (LOC), the number of AST node types to which the service applies, \nand the corresponding LOC per AST node type. The top part of Table 3 shows four user-visible services \nand the bottom part shows four internal IDE services. Most services shown in Table 3 require very little \ncus\u00adtom code, especially when considering the amount of cus\u00adtom code per relevant AST node type. Builders \nare a ser\u00advice that tends to be either trivial (e.g., LEG and PrefSpecs builder) or highly customized \nin a fairly complex way (e.g., X10 builder). Services like the occurrence marker and the tree-model builder, \nwhich are typically based on the Visitor pattern, may be relatively large (if there are many AST node \ntypes) but still conceptually simple. The amount of custom code for most reference resolvers is relatively \nsmall. The one exception here is for PrefSpecs which, unlike the other IDEs, builds its own symbol table \nrather than relying on one pro\u00advided by the parser. Note that the Cobol IDE does not yet have a builder \nand documentation provider. Some IMP services may not need any customization. The IMP framework provides \na default hover helper implemen\u00adtation that works automatically with an existing reference resolver and \ndocumentation provider. This has worked well for the LEG, LPG, and X10 IDEs; the PrefSpecs IDE used a \nnon-default hover helper to obtain more control over the source of documentation. Table 3 shows that \nthe service implementations for IMP\u00adbased IDEs are relatively small, often quite small in propor\u00adtion \nto the number of AST node types involved. Considering that most of the service implementations are also \nfairly styl\u00adized (e.g., implementing a visitor), this demonstrates sub\u00adstantial success in isolating \nthe language-speci.c elements of these service implementations and in simplifying their customization \nby IDE developers.  7.4 Enabling of Customization IMP affords many points of customization to the IDE \ndevel\u00adoper, such as customization of the parsing technology, the AST representation, and the editor. \nBeyond that, an IMP\u00adbased IDE can be customized with respect to the services or features it includes. \nWith very few restrictions, the available services can be combined in almost arbitrary ways, and the \nTable 3. Size of templates and additional custom lines of code (LOC) for representative service implementation \nin representative IDEs. Also shown, the number of AST node types referenced in the service implementation \nand the cor\u00adresponding LOC per referenced node type (approximate w\u00adhole number).  Service LEG Pref-LPG \nSpecs Cobol X10 Occurence marker (Template = 255 LOC) LOC 176 272 70 AST nodes 14 30 3 LOC/AST node 12 \n9 23 153 10 15 59 10 6 Token Colorer (Template = 46 LOC) LOC 8 38 26 AST nodes 4 26 6 LOC/AST node 2 \n2 4 27 14 2 12 9 2 Source folder (Template = 26 LOC) LOC 4 24 82 AST nodes 1 6 17 LOC/AST node 4 4 5 \n68 17 4 65 21 3 Builder (Template = 79 LOC) LOC 1 1 450 N/A 977 Document provider (Template = 38 LOC) \nLOC 8 79 17 AST nodes 3 31 4 LOC/AST node 3 3 4 N/A -- 576 35 16 Label provider (Template = 83 LOC) LOC \n20 56 113 AST nodes 6 19 50 LOC/AST node 3 3 2 145 35 4 178 18 9 Reference resolver (Template = 23 LOC) \nLOC 5 178 11 AST nodes 1 2 1 LOC/AST node 5 89 11 5 2 3 60 14 4 Tree-model builder (Template = 44 LOC) \nLOC 22 133 247 AST nodes 5 19 26 LOC/AST node 5 7 8 258 35 7 56 19 3 IMP framework provides extension \npoints for the introduc\u00adtion of arbitrary services. Individual IDE services can be customized through \npa\u00adrameters speci.ed at the time that initial implementations are generated or through the way in which \nservice imple\u00admentations are completed or extended. To facilitate service implementation, we provide \nbase classes and default, skele\u00adton implementations for many services. Some open points in the default \nimplementations for se\u00adlected services are shown in Table 4. However, customiza\u00adtions are not restricted \nto prede.ned points; any service can be implemented using an arbitrary program. Following are some examples \nof customizations that were made in the IDEs we evaluated: Service Example Customizations Syntax colorer \nDe.nition of text attributes Assignment of text attributes to tokens Use of non-local information (e.g., \nfrom AST) Determination of region to re-color Outliner Included elements Element order Indentation structure \nText labels and icons Use of extra information Builder Tests for .le types (src, incl, ...) Marker IDs \nDependency computation Compile method Overrides of defaults for message management, dialogs, ... Table \n4. Example customizations for selected IDE services The use of Polyglot (Nystrom et al. 2003) rather \nthan LPG as the basis for representing AST nodes in the X10 IDE.  The use of a javacup-based parser \nin the ToolBus Script IDE  The use of a preexisting column-oriented editor in the Cobol IDE rather than \nthe standard IMP editor  The use of a custom console in the Rascal IDE based on the the ScriptConsole \nclass from the Dynamic Languages Toolkit (eclipse.org/dltk).  The provision of language-oriented documentation, \nrather than the more common program-oriented doc\u00adumentation , in hover help for the PrefSpecs IDE  The \nuse of different algorithms for reference resolution in the X10 (prescreening link source nodes), LPG \n(no prescreening link source nodes), and PrefSpecs (use of token stream instead of the AST to .nd references) \n The recognition of specially-formatted comment tags  (e.g. TODO ) in the X10 compiler The computation \nof cross-compilation unit dependencies in the X10 compiler These are in addition to the selection of \ndifferent service sets for different IDEs and more routine choices about syntax coloring, and outline \nconstruction.  7.5 Iterative, Incremental, and Selective Development IMP supports the ability to freely \nselect which services to provide in an IDE. No two of the evaluated IMP IDEs offer exactly the same set \nof services. Furthermore, development of an IMP IDE is incremental since services are generated one at \na time and are mostly individually completed. This incrementality is bene.cial in that it allows IMP \nIDEs to be veri.ed at each stage of development.  Iterative development is possible both for adding \nnew services to an IDE and for re.ning or replacing existing services. However, not all incremental changes \nto an IMP IDE can be localized impact-free. For instance, the biggest crosscutting concern in any IMP \nIDE is inevitably the AST representation and node types. If the underlying grammar changes, the AST types \nwill generally also change, with more or less impact. If new AST node types are added, the existing IDE \nservices should continue to work, albeit ignor\u00ading the new node types. The services can be updated indi\u00advidually \nas needed to address the new types. If existing node types are modi.ed or deleted, then dependent IDE \nservices will have to be repaired before they can be recompiled and used. Better support for IDE evolution \nis a topic for future work. Finally, an important advantage of IMP s incremen\u00adtal development is the \nability to construct basic limited\u00adfunctionality IDEs with very little effort. In situation where simple \nIDEs with limited functionality are suf.cient, IMP provides an ideal framework to arrive at a solution \nquickly.  7.6 Accommodating Language Changes Several of the above languages (notably LPG, PrefSpecs, \nand X10) were evolving while their IDEs were under devel\u00adopment. This raises another important question \nin assessing the effectiveness of our framework: how dif.cult is it to keep an IDE implementation in \nsync with language changes? This section offers some qualitative experience to address that is\u00adsue. Speci.cally, \nthe LPG grammar was refactored and aug\u00admented to effect various syntactic enhancements. In this case, \nthe bulk of the IDE implementation (coloring, fold\u00ading, outlining, reference resolution, etc.) was affected \nlit\u00adtle, requiring only a few isolated lines of alteration. The grammar refactoring implementations and \ngrammar analy\u00adsis, however, were naturally impacted more signi.cantly by the changes to the AST hierarchy. \nLikewise, the PrefSpecs language was enhanced to sup\u00adport additional preference data types, multiple \nhierarchical preference pages, and to make various speci.cation item\u00ads optional. Again, the bulk of the \nIDE required little or no work to accommodate these changes. On the other hand, the PrefSpecs compiler \nthat generates Java implementation classes for various user interface componentry, and its da\u00adta structures \nand code generator required signi.cant adapta\u00adtion, as one would expect. The X10DT, on the other hand, \nfaced signi.cant changes of two different kinds: (a) in the initialization and invocation of the underlying \nPolyglot compiler framework and the orga\u00adnization of compiler passes (which the X10DT s builder ex\u00adtends), \nand (b) in the AST hierarchy and type system APIs, in partial support of generic types. In essence, the \nformer changes were more dif.cult to accommodate, requiring a nontrivial reworking of the life cycle \nof the IParseController and related classes. It seems unlikely that the IDE framework could do much to \ninsulate the IDE developer from such prob\u00adlematic API changes without a tight integration between the \nIDE framework and the compiler, which would violate one of our key design goals (technology agnosticism). \nThe sec\u00adond set of changes, on the other hand, corresponds more di\u00adrectly to language changes, and was \nactually much easier to accommodate, particularly as they were systematic. In short, for the most part, \nthe bulk of the effort in ac\u00adcommodating language changes lies mainly in the code that is intrinsically \ncomplex, as it should be.  8. Related Work There is a long tradition of work on the automatic generation \nof programming-related tools from language de.nitions and related speci.cations (Reps and Teitelbaum \n1984; Borras et al. 1988; Henriques et al. 2005; van den Brand et al. 2001). These systems differ from \none another, and from IMP, in the form of language de.nition used, the particular tools or ser\u00advices \ngenerated, and aspects of processing, architecture, and infrastructure. Here, though, we are more concerned \nwith the general goals and approach. All of these systems, including IMP, share the goal of simplifying \nthe creation of program\u00adming tools, thereby making it easier to develop and adopt new programming languages, \nand improving the quality of programs and the programming process. All also make use of some combination \nof language-independent library com\u00adponents and language-speci.c generated components. The main difference \nbetween IMP and the earlier ap\u00adproaches is that IMP puts a heavier emphasis on customiza\u00adtion of the \nresulting IDE. In the previous work, once the tools are generated, they are done. This certainly minimizes \nthe subsequent work of the IDE developer, but at the cost of customizability. With IMP, once tools are \ngenerated, ad\u00additional customization is possible, if not required. In effect, IMP shifts the focus of \ncustomization from the language def\u00adinition to the tool implementation. This means that the pro\u00adgrammer \ntypically has work to do subsequent to tool gener\u00adation, but it affords very broad opportunities for \ncustomiza\u00adtion. We have attempted to minimize the amount of work that is required of programmers, though, \nby providing default im\u00adplementations where feasible, introducing speci.cation lan\u00adguages to enable some \nimplementations to be customized declaratively, and by stripping away most of the IDE-related parts of \ntool implementations so that the developer can focus on the language-related parts. MPS (Jetbrains.com) \nhas goals that are very similar to IMP s. Its authors claim that it is an implementation of Lan\u00adguage \nOriented Programming that facilitates the de.nition of domain-speci.c languages with full IDE support \n(code completion, navigation, refactoring, and more) that also al\u00adlows the user to add specialized support \n(such as special edi\u00adtors). Unfortunately, not enough technical detail on this work is available in the \nliterature to enable us to make a detailed comparison to IMP.  The work on Gen-Voca (Batory et al. 2002) \ndescribes the application of a sort of aspect-oriented composition frame\u00adwork to the creation of variant \nIDEs for variants of Java. Language variants are de.ned by extensions to Java; IDE variants are de.ned \nby extensions of tools in the Java IDE. In contrast, IMP starts with a language-independent IDE framework, \nand it incorporates language-speci.c extensions through extension point and object-oriented mechanisms. \nWhereas (Batory et al. 2002) focused mainly on the com\u00adbination of existing modules in alternative ways, \nIMP is focused on supporting the initial development of the mod\u00adules. IMP might bene.t from compositional \ntechnologies like Gen-Voca, but research in that area is beyond our current scope. Marama is an Eclipse-based \nset of meta-tools for gener\u00adating visual programming languages that support diagram\u00adming applications \n(Grundy et al. 2008). As with IMP, a goal for Marama is to enable the rapid development of simple modeling \ntools while allowing more complex tooling to be developed over time. Unlike IMP, both the meta-modeling \ntools and the resulting modeling notations are highly visual (although constraints and behaviors can \nbe speci.ed in tex\u00adtual formulae and, as a last resort, in Java). Also unlike IMP, but like most generation-based \nIDEs for textual languages, a major part of the framework and tooling are dedicated to execution support. \nVisual languages are beyond the current scope of IMP, but the prospect of combining meta-tooling for \ntextual and visual languages is an interesting challenge for the future. The Dynamic Languages Toolkit \n(DLTK) (eclipse.org/dltk) is an Eclipse technology project aimed at facilitating the de\u00advelopment of \nJDT-like IDEs for dynamic languages. In this it shares some context and high-level goals with IMP. How\u00adever, \nthe DLTK and IMP differ in important ways. Since the DLTK is targeted toward dynamic languages it can \nadopt a common tooling approach: common AST representation, common runtime, and common services. It provides \nexe\u00adcution support for these languages and aims for language interoperability. IMP, in contrast, does \nnot restrict its focus to a particular family of languages. To maintain language\u00adindependence the IMP \nframework provides language-neutral APIs to language-speci.c services. For example, it does not rely \non any particular internal representation; it supports custom ASTs and accommodates the use of alternative \ncom\u00adpiler front-ends. IMP does not provide any special support for program execution or language interoperability. \nHowev\u00ader, one of our goals for future work is to support IDE and language extensibility. 9. Open Issues \nThere is a clear tension between our desire to provide a framework that is independent of any particular \nlanguage technology and our desire to make things easy for IDE devel\u00adopers, who obviously must select \na speci.c language tech\u00adnology. As a consequence, our APIs are necessarily agnos\u00adtic, e.g., using Object \nto represent tokens or AST nodes. To help resolve this tension, our runtime framework provides base classes \nto ease the implementation of language process\u00ading for LPG-based parsers and scanners, and program analy\u00adses \nfor Polyglot-based front-ends. Similarly specialized base classes can easily be provided for other parser/compiler \ntech\u00adnologies and program representations. Better support for ex\u00adecution and debugging is a topic for \nfuture work. Another challenge which language-technology indepen\u00addence presents is the ability to introspect \non the target lan\u00adguage s syntax or semantics. For example, the presentation speci.cation language IDE \nwould bene.t from being able to query the sets of non-terminals and terminals (e.g. for con\u00adtent assist), \nregardless of the kind of parser generator be\u00ading used. It requires carefully crafted APIs that are both \nag\u00adnostic of particular parsing technologies but accommodat\u00ading to them. The IParseController interface \ndoes this for parsing services, but the analogous interface exposing language properties has yet to be \ndesigned. Such an in\u00adterface would enable promoting certain development-time meta-tooling services that \nare presently language-speci.c in\u00adto the language-independent framework. Another ongoing concern is how \nbest to create new IDE service implementations. This is presently handled by a combination of wizards, \ndomain speci.c languages, gen\u00aderators, and Java implementation. All have proven useful, but the most \nappropriate balance among them is not clear. IMP currently relies to a signi.cant degree on wizards to \nini\u00adtiate the development of an IDE service. In so doing, many details of setting up the service can \nbe hidden from the us\u00ader, simplifying the process. However, the user may not have a clear mental model \nof the wizard s effect on the system. In particular, the user may wish to change a decision made when \ninteracting with a wizard, but not know whether it is safe to re-run the wizard.7 Moreover, decisions \nmade when interacting with a wizard often disappear into the code (or the meta-data), making it hard \nto discover later on what choices were already made. In contrast, most IDE develop\u00aders have well-de.ned \nexpectations regarding compilers and builders. Thus, it may be more user-friendly to move more of the \nsetup and creation of IDE services out of wizards and into a DSL compiler. This might keep the speci.cation \nof IDE services simple while providing greater transparency to developers. This raises another issue, \nhowever, that of the tradeoff be\u00adtween implementation via DSLs versus Java. The issue is ex\u00adacerbated \nby the relatively large number of services support\u00aded by IMP. On the speci.cation side, it is generally \nconsid\u00adered that DSLs are easier to write than imperative programs, 7 Sadly, there seems to be little \nconsistency in this regard among wizards in general.  since speci.cations tend to be more abstract and \nyet more concise.One extreme is to provide a separate DSL for each service. This requires learning a \nnew language for each ser\u00advice though each language may be relatively simple. The other extreme is to \nuse one DSL for many services. Although this requires learning just one language, the language will naturally \nbe more complex. On the programming side, the IMP IDE developer almost certainly has good knowledge of \nJava, and many IMP services can be implemented with very little code. As a result, the IDE developer \nmay be more com\u00adfortable implementing services in Java than specifying them in one or more DSLs. Fortunately, \nIMP s use of the Eclipse extension point mechanism permits implementation of any given service by any \nof the above means, so that an IDE de\u00adveloper need not make a single choice for all services.8 We are \nstill evaluating the various approaches. 10. Conclusions We have presented an approach to the construction \nof language-speci.c IDEs in Eclipse that draws on both au\u00adtomated generation and manual implementation. \nWe do this by a combination of meta-tooling and carefully engineered runtime interfaces that cleanly \nseparate language-speci.c concerns from the details of IDE and UI infrastructure and interoperation. \nFor the IDE developer, this approach is in\u00adtended to strike a .exible balance between customizabili\u00adty \nand ease of development. For the IDE user, the bene.t should be IDEs that offer a good range of features \nthat are well adapted to details of language syntax and semantics. This combination of functionality \nand language sensitivity appears to be critical for the widespread adoption of an IDE. Our design goals \nrepresent a unique blend of elements that distinguishes our work from prior work in the area. In this \nregard, important aspects of our approach are our em\u00adphasis on language-speci.c customization, great \n.exibili\u00adty in the selection of IDE features, neutrality with respect to language/parsing technology \nand program representation, and the ability to swap out major components of the archi\u00adtecture, such as \nthe editor. This combination makes the ap\u00adproach a practical solution for a wide range of IDE develop\u00adment \nscenarios. We have realized our approach in the Eclipse IDE Meta\u00adtooling Platform IMP (http://www.eclipse.org/imp/). \nIMP has been used, by us and others, to develop IDEs for a wide variety of domain-speci.c and general-purpose \nlanguages. IMP has been used to develop entirely new IDEs (often for new languages) and to help migrate \nexisting IDEs on\u00adto Eclipse. Some of the IDEs support meta-tooling in IDE development (e.g., in support \nof grammar speci.cation and parser generation), while others represent tooling for appli\u00adcation development \n(e.g., in COBOL). Many of these IDEs are in regular use and most are publicly available. 8 In fact, the \nSpoofax IDE uses a single DSL interpreter as the implementa\u00adtion for a signi.cant subset of the IDE services \nthat IMP supports. We have also presented an evaluation of IMP that ad\u00addresses (a) ease of IDE development, \n(b) feature sets and performance of IMP-based IDEs, (c) reduction of IDE de\u00advelopment effort, (d) enabling \nof IDE customization, and (e) support for incremental, iterative, and selective IDE de\u00advelopment. Our \nmeasurements and experience to date sug\u00adgest that IMP signi.cantly simpli.es IDE development, pro\u00adduces \npractical IDE implementations, and signi.cantly re\u00adduces IDE development effort. Overall, IMP appears \nto offer an effective solution to many crosscutting problems present\u00aded by this complex development domain. \nOne present limitation of our framework is that the ab\u00adstraction of language-processing technologies \nand program representations makes it somewhat more dif.cult to provide execution and debugging support. \nSimilarly, we currently have limited capability to introspect on grammar structure, which complicates \nproviding certain meta-tooling services in a language-independent way. We are investigating how to provide \nadditional leverage in these areas. Another area of ongoing research is how best to support IDE developers, \nespecially novice developers, in the imple\u00admentation of IDE services. We currently use a combination \nof wizards, DSLs, generators, and manual programming. All are useful, but we continue to look for further \nopportunities to simplify and clarify the IDE development process.   Acknowledgments This work is based \nin part upon work supported by the De\u00adfense Advanced Research Projects Agency under its Agree\u00adment No. \nHR0011-07-9-0002.  References Isabelle Attali, Carine Courbis, Pascal Degenne, Alexandre Fau, Didier \nParigot, and Claude Pasquier. Smarttools: A generator of interactive environments tools. In CC, pages \n355 360, 2001. Don Batory, Roberto E. Lopez-Herrejon, and Jean-Philippe Martin. Generating product-lines \nof product-families. In IEEE Conf. on Automated Software Engn., page 81, 2002. Azad Bolour. Notes on \nthe eclipse plugin architecture. http://www.eclipse.org/articles/Article-Plug-\u00adin-architecture/plugin-architecture.html. \nP. Borras, D. Clement, Th. Despeyroux, J. Incerpi, G. Kahn, B. Lang, and V. Pascual. Centaur: the system. \nIn ACM Symposium on Practical Software Development Environments, pages 14 24, 1988. Philippe Charles, \nChristian Grothoff, Vijay Saraswat, Christopher Donawa, Allan Kielstra, Kemal Ebcioglu, Christoph von \nPraun, and Vivek Sarkar. X10: an object-oriented approach to non-uniform cluster computing. In OOPSLA, \npages 519 538, 2005. ISBN 1-59593-031-0. Philippe Charles, Robert M. Fuhrer, and Stanley M. Sutton Jr. \nIMP: a meta-tooling platform for creating language-speci.c IDEs in eclipse. In 22nd IEEE/ACM International \nConference on Automated Software Engineering (ASE 2007), November 5-9, 2007, Atlanta, Georgia, USA, pages \n485 488, 2007.  eclipse.org/aspectj. AspectJ project. http://www.eclipse.org/aspectj/. eclipse.org/dltk. \nDynamic Languages Toolkit. http://www.eclipse.org/dltk/. eclipse.org/jdt. Eclipse Java Development Tools. \nhttp://www.eclipse.org/jdt/. Wan Fokkink, Paul Klint, Bert Lisser, and Yaroslav S. Usenko. Towards formal \nveri.cation of toolbus scripts. In AMAST 2008: Proceedings of the 12th international conference on Algebraic \nMethodology and Software Technology, pages 160 166, Berlin, Heidelberg, 2008. Springer-Verlag. M. Fowler. \nLanguage workbenches: The killer-app for domain speci.c languages? http://www.martinfowler.com/articles/language\u00adWorkbench.html. \nBugra Gedik, Henrique Andrade, Kun-Lung Wu, Philip S. Yu, and Myungcheol Doo. Spade: the system s declarative \nstream processing engine. In SIGMOD 08: Proceedings of the 2008 ACM SIGMOD international conference on \nManagement of data, pages 1123 1134, New York, NY, USA, 2008. ACM. John Grundy, John Hosking, Jun Huh, \nand Karen Na-Liu Li. Marama: an eclipse meta-toolset for generating multi-view environments. In ICSE \n08: Proceedings of the 30th international conference on Software engineering, pages 819 822, New York, \nNY, USA, 2008. ACM. J. Heering, P. R. H. Hendriks, P. Klint, and J. Rekers. The syntax de.nition formalism \nsdf reference manual . SIGPLAN Not., 24(11):43 75, 1989. ISSN 0362-1340. Pedro Rangel Henriques, Maria \nJoao Varanda Pereira, Marjan Mernik, Mitja Lenic, Jeff Gray, and Hui Wu. Automatic generation of language-based \ntools using LISA. IEE Proceedings -Software, 152(2):54 69, April 2005. Jetbrains.com. JetBrains Meta \nProgramming System. http://www.jetbrains.com/mps/. R. Kadia. Issues encountered in building a .exible \nsoftware development environment: lessons from the arcadia project. SIGSOFT Softw. Eng. Notes, 17(5):169 \n180, 1992. ISSN 0163-5948. Lennar Kats and Karl Trygve Kalleberg. StrategoXT Spoofax-IMP. http://strategoxt.org/Stratego/Spoofax-IMP, \n2009. lpg.sourceforge.net. LPG. http://www.sourceforge.net/projects/lpg/. N. Nystrom, M. Clarkson, and \nA. Myers. Polyglot: An extensible compiler framework for Java. In CC, pages 138 152, 2003. James M. Purtilo. \nThe polylith software bus. ACM Trans. Program. Lang. Syst., 16(1):151 174, 1994. ISSN 0164-0925. python.org. \nPython. http://www.python.org/. Steven P. Reiss. Connecting tools using message passing in the .eld environment. \nIEEE Softw., 7(4):57 66, 1990. ISSN 0740-7459. T. Reps and T. Teitelbaum. The synthesizer generator. \nIn ACM Symposium on Practical Software Development Environments, pages 42 48, April 1984. ruby-lang.org. \nRuby. http://www.ruby-lang.org/. Mark van den Brand and Eelco Visser. Generation of formatters for context-free \nlanguages. ACM Trans. Softw. Eng. Methodol., 5(1):1 41, 1996. ISSN 1049-331X. Mark van den Brand et al. \nThe ASF+SDF meta-environment: A component-based language development environment. In Computational Complexity, \npages 365 370, 2001. Jurgen Vinju, T. van der Storm, Paul Klint, Bas Basten, and Arnold Lankamp. Rascal: \nA domain speci.c language for software analysis and transformation. Poster presentation, Scienti.c ICT-Research \nEvent Netherlands (SIREN), Sep. 29, 2008, 2008. Eelco Visser. Program transformation with Stratego/XT: \nRules, strategies, tools, and systems in StrategoXT-0.9. In C. Lengauer et al., editors, Domain-Speci.c \nProgram Generation, volume 3016 of Lecture Notes in Computer Science, pages 216 238. Spinger-Verlag, \nJune 2004. X10.sourceforge.net. X10. http://www.sourceforge.net/projects/x10/.  \n\t\t\t", "proc_id": "1640089", "abstract": "<p>Full-featured integrated development environments have become critical to the adoption of new programming languages. Key to the success of these IDEs is the provision of services tailored to the languages. However, modern IDEs are large and complex, and the cost of constructing one from scratch can be prohibitive. Generators that work from language specifications reduce costs but produce environments that do not fully reflect distinctive language characteristics.</p> <p>We believe that there is a practical middle ground between these extremes that can be effectively addressed by an open, semi-automated strategy to IDE development. This strategy is to reduce the burden of IDE development as much as possible, especially for internal IDE details, while opening opportunities for significant customizations to IDE services. To reduce the effort needed for customization we provide a combination of frameworks, templates, and generators. We demonstrate an extensible IDE architecture that embodies this strategy, and we show that this architecture can be used to produce customized IDEs, with a moderate amount of effort, for a variety of interesting languages.</p>", "authors": [{"name": "Philippe Charles", "author_profile_id": "81100261077", "affiliation": "IBM T. J. Watson Research Center, Yorktown Heights, NY, USA", "person_id": "P1728756", "email_address": "", "orcid_id": ""}, {"name": "Robert M. Fuhrer", "author_profile_id": "81421599609", "affiliation": "IBM T. J. Watson Research Center, Yorktown Heights, NY, USA", "person_id": "P1728757", "email_address": "", "orcid_id": ""}, {"name": "Stanley M. Sutton", "author_profile_id": "81452606101", "affiliation": "IBM T. J. Watson Research Center, Yorktown Heights, NY, USA", "person_id": "P1728758", "email_address": "", "orcid_id": ""}, {"name": "Evelyn Duesterwald", "author_profile_id": "81100028046", "affiliation": "IBM T. J. Watson Research Center, Yorktown Heights, NY, USA", "person_id": "P1728759", "email_address": "", "orcid_id": ""}, {"name": "Jurgen Vinju", "author_profile_id": "81100623272", "affiliation": "CWI, Amsterdam, Netherlands", "person_id": "P1728760", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640104", "year": "2009", "article_id": "1640104", "conference": "OOPSLA", "title": "Accelerating the creation of customized, language-Specific IDEs in Eclipse", "url": "http://dl.acm.org/citation.cfm?id=1640104"}