{"article_publication_date": "10-25-2009", "fulltext": "\n Executing Code in the Past: Ef.cient In-Memory Object Graph Versioning Fr\u00b4ed\u00b4eric Pluquet Stefan Langerman \n* Universit\u00b4 e Libre de Bruxelles Computer Science Department Faculty of Sciences {fpluquet,stefan.langerman}@ulb.ac.be \nAbstract This paper is an abstract of the paper titled Executing Code in the Past:Ef.cient In-Memory \nObject Graph Versioning (written by the same authors), accepted in the Research Program of the 2009 ACM \nSIGPLAN Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 09). Categories \nand Subject Descriptors D.3.3 [Language Constructs and Features]: Classes and Objects, Data types and \nstructures; D.3.2 [Language Classi.cations]: Object-Oriented Languages General Terms Algorithms, Design, \nExperimentation, Lan\u00adguages, Performance Keywords Object Versioning, Object-oriented Programming, Language \nDesign 1. Introduction In the algorithmic research community, data structures are called persistent (in \nthe rest of this paper we will use the term versioned1) if they support access to multiple lifetime versions \nof that data structure [Driscoll et al. 1986]. Versioned data structures make it possible to go back \nin time and revisit the state of a data structure at some point in the past. There are several applications \nthat need such versioning support. Debuggers and tracers bene.t from offering insight in previous states \nof objects. Implementing ef.cient object versioning is hard because of the space and time complexity \nneeded to save past states of poten\u00adtially all .elds of all objects. Furthermore the versioning mecha\u00adnism \nshould be properly integrated in the programming language. Last but not least full support for object \nversioning ideally should support the same design principles than orthogonal persistence be\u00adcause this \nhas proven to be useful when dealing with saved object states [Atkinson 1995]: * Ma itre de recherches \ndu FRS-FNRS 1 We avoid the word persistent because it has a different meaning in the object-oriented \nand database communities, where it is tied to long-lived data and the suspension and resuming of execution. \nRoel Wuyts IMEC, Leuven and Katholieke Universiteit Leuven roel.wuyts@imec.be 1. any object, regardless \nof its type, can be versioned. 2. the lifetime of all objects is determined by their reachability. \n3. code cannot distinguish between versioned and non-versioned data.  We present HistOOry, an in-memory \nobject versioning system that is general enough to add versioning to any existing program and that has \nthe following features: it supports the design principles outlined above: any object can be versioned, \nunreachable objects are garbage collected and there is no difference between versioned and non-versioned \nobjects.  it has a .ne-grained model where certain .elds of an object can be versioned while other ones \nare not. Moreover the model allows to specify when the state is saved, because different applications \nhave different requirements. objects can be versioned without the need for changing the implementations \nof their class.  it is ef.cient. Versioning has a constant cost that does not increase with the number \nof objects that have already been versioned. Querying a past version of the object graph can be done \nat a cost logarithmic in the number of saved versions.  it only requires three primitives.  HistOOry \nsaves the versions in memory because we make the past versions of objects directly available. The goal \nof HistOOry is to re.ect on the past of objects as quick as possible and not to backup objects on some \nphysical medium to restore them later on. This leads us to a different solution than the classical database-or \n.le\u00adoriented persistency approaches. HistOOry is implemented in Squeak/Pharo (a Smalltalk envi\u00adronment) \nand we have used it to build three applications using object versioning: we add support for checked postconditions \nto Smalltalk, implement an object execution tracer that keeps track of the states of receiver and arguments, \nand implement a planar point location program. Benchmarks for synthetic cases and for these ap\u00adplications \nshow that the measured execution time penalty is a factor of 7.3 for a synthetic worst case example, \nand a factor of 2.3 in the application benchmarks. 2. Recording and Browsing Object States Copyright \nis held by the author/owner(s). OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. Our model is \ngeneral enough to record any state of any object in ACM 978-1-60558-768-4/09/10. any object oriented \nsystem and then browse them.  2.1 Snapshots: When to Save Fields The developer that uses HistOOry to \nmake an application versioned has full control of when states of objects are saved. This is analo\u00adgous \nto using a camera. Whenever the user presses a button, a snap\u00adshot is taken, remembering what was visible \nat that time, while life goes on. This is in contrast to a video camera, that saves a constant stream \nof images. While this is sometimes interesting (and can be done in our approach as well), lots of applications \nthat need object versioning are better served with explicitly taking snapshots than with capturing a \nhuge stream of changes. 2.2 Selection and deselection: what .elds to save A developer has full control \nover what gets saved when a snap\u00adshot is taken. This is analogous to putting a .lter on the lens of the \ncamera. While a camera without a .lter will always take snapshots of the complete scene, lens .lters \nwill reduce the amount of infor\u00admation in a scene and only keep items of interest. Filters can be changed \nat any time and change the results of pictures taken after the new .lter is installed. By default HistOOry \nmakes all .elds of all objects non versioned. In our camera analogy this is comparable with putting the \nlens cap on: when you take a snapshot you will not see anything. At any given point in time the developer \ncan select what .elds become versioned. This is comparable to putting a .lter on the lens of the camera. \nWhen a snapshots is taken it will only save the states of versioned .elds. States of non versioned .elds \nare not stored and can therefore not be looked at later on.  2.3 Browsing States When .elds are accessed \nthroughout a snapshot, three things can happen: the .eld was selected before the creation of the snapshot. \nIn that case the stored past state is returned.  the .eld was selected after the snapshot was created. \nThis means that we try to access the past state of a .eld before it was saved for the .rst time. We raise \nan exception.  the .eld was not selected, and therefore no past state exists. We return the present \nvalue of the state. The full version paper shows other examples in which this choice it is very practical. \n A modi.cation of a versioned .eld while executing code in the context of a snapshot results in an exception \nbeing thrown. A modi.cation of an ephemeral .eld changes that .eld, which is normal because the snapshot \nactually sees the present object. 3. Being Ef.cient Saving multiple states of object graphs and ef.ciently \nretrieving them requires an advanced data structure. Luckily several algo\u00adrithmic results are known for \nthis problem. After carefully review\u00ading the available algorithms we decided to implement the fat node \nmethod [Driscoll et al. 1986] that can transform any ephemeral data structure into a partially versioned \none. All details are given in the full paper. 4. Implementation In the full paper, we show deeply how \nan object oriented language can be extended to integrate the object versioning. We introduce only three \nbasic primitives to the language and we show that it is suf.cient to work with versioning. All details \nare given in the full paper. 5. Measurements The paper shows a lot of measurement on size and time consump\u00adtion \ndue to the introduction of object versioning in an object ori\u00adented language. These benchmarks shows \nthat the maximum factor cost is about 7.3 (if all operations are an assignment) and a factor of 2.3 for \nreal application benchmarks. An important properties of HistOOry is that these factors are constant and \nso independent of the number of taken states. 6. Conclusion We presented an overview of HistOOry, an \nef.cient in-memory ob\u00adject versioning system. The ef.ciency is due to our object-oriented implementation \nof, and changes to, an ef.cient data structure keep\u00ading states. Fine-grained control is offered on what \n.elds of an ob\u00adject are versioned, and when the states are saved. Therefore our solution is general enough \nto support applications that need object versioning but have different needs. Only requires three basic \nprim\u00aditives, making it easy to learn and use. Properly integrating it in the language, like we did in \nSmalltalk, makes it easy to transform ex\u00adisting applications that do not use object versioning into ones \nthat have such support. Benchmarks show that the overhead for storing states is constant, and does not \nscale with the number of states that need to be stored. References James R. Driscoll, Neil Sarnak, Daniel \nD. Sleator, and Robert E. Tarjan. Making data structures persistent. Journal of Computer and System Sciences, \npages 86 124, 1986. Malcolm Atkinson. Orthogonally persistent object systems. Nov 1995. URL http://citeseer.ist.psu.edu/411649. \n  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>This paper is an abstract of the paper titled \"Executing Code in the Past:Efficient In-Memory Object Graph Versioning\" (written by the same authors), accepted in the Research Program of the 2009 ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA'09).</p>", "authors": [{"name": "Fr&#233;d&#233;ric Pluquet", "author_profile_id": "81444606959", "affiliation": "Universit&#233; Libre de Bruxelles, Brussels, Belgium", "person_id": "P1728578", "email_address": "", "orcid_id": ""}, {"name": "Stefan Langerman", "author_profile_id": "81100626725", "affiliation": "Universit&#233; Libre de Bruxelles, Brussels, Belgium", "person_id": "P1728579", "email_address": "", "orcid_id": ""}, {"name": "Roel Wuyts", "author_profile_id": "81100639276", "affiliation": "IMEC and Katholieke Universiteit Leuven, Leuven, Belgium", "person_id": "P1728580", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640007", "year": "2009", "article_id": "1640007", "conference": "OOPSLA", "title": "Executing code in the past: efficient in-memory object graph versioning", "url": "http://dl.acm.org/citation.cfm?id=1640007"}