{"article_publication_date": "10-25-2009", "fulltext": "\n A Market-BasedApproach to Software Evolution David F. Bacon Yiling Chen David Parkes IBM Research and \nHarvard University Harvard University Harvard University dfb@watson.ibm.com yiling@eecs.harvard.edu parkes@eecs.harvard.edu \nMalvika Rao Harvard University malvika@eecs.harvard.edu Abstract Software correctness has bedeviled \nthe .eld of computer science since its inception. Software complexity has increased far more quickly \nthan our ability to control it, reaching sizes that are many orders of magnitude beyond the reach of \nformal or automated veri.cation techniques. We propose a new paradigm for evaluating correctness based \non a rich market ecosystem in which coalitions of users bid for features and .xes. Developers, testers,bug \nreporters, and analysts share in the rewards for responding to those bids. Infact, we sug\u00adgest that the \nentire software development process can be driven by a disintermediated market-based mechanism driven \nby the desires of users and the capabilities of developers. The abstract, unspeci.able, and unknowable \nnotion of absolute correctness is then replaced by quanti.able notions of correctness demand (the sum \nof bids forbugs) and correctness potential (the sumof theavailable pro.t for .xing thosebugs).We thensketch \nthe componentsofa market design intendedto identifybugs, elicit demand for .xingbugs, and sourceworkers \nfor .xingbugs. The ul\u00adtimate goal is to achieve a more appropriate notion of correctness, in which market \nforces drive software towards a correctness equi\u00adlibrium in whichallbugsfor which thereis enoughvalue,and \nwith low enough cost to .x, are .xed. Categories and Subject Descriptors D.2.4 [Software/Program Veri.cation]: \nReliability; D.2.10 [Design]: Methodologies; J.4 [Social and Behavioral Sciences]: Economics; K.6.3[Software \nManagement]: Software development General Terms Design, Economics, Reliability,Veri.cation 1. Introduction \nSpeci.cation. Implementation. Veri.cation. Testing. Correctness. These are the concepts upon which rests \nthe human enterprise of software creation, and the discipline of software engineering. And at their intellectual \ncore, even if rarely obtained in practice: Proof Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. Copyright \nc &#38;#169; 2009ACM 978-1-60558-768-4/09/10... $10.00 the notion that we can, in principle, create a \nspeci.cation for a software artifact, implement it, and prove it correct. This intellectual foundation \nfor software engineering, the Pla\u00adtonic ideal of thebug-free program, has dominated both practical methodology \nand theoretical study in computer science. One of the progenitors of this idealized approach, Edsger \nDijk\u00adstra, suggestedin his 1972TuringAward lecture that well before the seventies have run to completion, \nwe shall be able to design and implement the kind of systems that are now straining our programming ability, \nat the expense ofonlyafewpercentin man-yearsofwhattheycostusnow, and that besides that, these systems \nwill be virtually free of bugs. Today this suggestion seems remarkably na\u00efve, and if anything the situation \nhas gotten worse rather than better. Various approaches to correctness have been used: formal proofs \n(with signi.cant progress in recent years using mechani\u00adcal systems like the Coq proof assistant) and \nmodel checking are both severely limited in the scale of software artifact to which they can be applied. \nSome researchers have acknowledged that absolute correctnessis inachievable and suggested alternate approaches, \nno\u00adtably Rinard s work in failure oblivious computing [13]. Our belief is that we need a fundamental \nchange in our ap\u00adproach to large-scale software systems which relies on organic, self-regulating mechanisms \nrather than attempting to achieve some absolute, centralized notion of correctness. In this paper, we \nexplore the possibility of using a market mechanism to drive the evolution of software. The goal is not \nto bebugfree,butrathertobefreeofbugsthatpeople careabout,and that can be .xed economically. We begin \nby summarizing some approachestousingmarket systemsinvariouspartsofthesoftware development process, and \nthen describe our proposed approach. 2. Crowd-sourcing approaches Unlike traditional approaches that \nseek technical advancements to ensure the correctness of software, many recent systems are crowd-sourcing\" \nvarious software development and improvement tasks to the participantsof the software ecosystem. Crowd-sourcing \nis a process that involves the use of a competitive process (though payments, prizes or other forms of \nreward) for the sourcing of work or information, usually involving problem decomposition into small, \nmodular chunks.Inthis sectionwereviewexistingbug track\u00ading systems, vulnerability markets, and online \nmarketplaces that take a crowd-sourcing approach. As we will see, these systems, some of which are market-based, \ntypically only focus on one par\u00adticular aspect of the software ecosystem.  In their paper \"The principles \nof distributed innovation,\" Lakhani andPanetta describe three different industries where distributed \nin\u00adnovation systems have been implemented successfully [7]. The authors discuss the motivation for people \nto participate in such systems and the organizing principles of production. The paper considers the Linux \noperating system as anexample that highlights the bene.ts of work that is organized such that many individuals \ncan self-selectandlead elementsofdevelopment withoutmuchex\u00adante guidance and control. Infact LinusTorvalds, \nthe founder of Linux, is quoted as follows: \"Iwould muchrather have Brownian motion where a lot of microscopic \ndirected improvements end up pushing the system slowly in a direction that none of the individual developers \nreally had the vision to see on their own.\" The paper also points out that there is a relatively high \nfailure rate in these systems. Moreover distributed innovation systems do not seem to be ef.cient in \nmilestone-based innovation development which re\u00adquires strict planning and delivery on demand. 2.1 Bug \nandVulnerability Reporting It is natural to engage and incentivize users and free-market testers to reportbugs \nand identify vulnerabilityof software.Voting-based approaches have been used to allow users to express \ntheir prefer\u00adencesover the importanceof thebugs. Market-based approaches have been proposed to provide \nincentives for reporting critical se\u00adcurity or vulnerability issues. 2.1.1 Voting-Based Bug Reporting \nSystems Bug reporting systems often try to get users preferences over dif\u00adferent reported bugs. One way \nfor users to express such prefer\u00adencesisto allowthemtovoteonbugsor related issues thatthey care about.Forexample, \nSun uses BugParade to trackbugsin the JavaVirtual Machine.InBugParade,every unique email address is given \nsome tokens that could be used to vote on the importance of particularbugs. Similarly, the Adobe Flex \nbug and issue management system uses a system called JIRA to report and track bugs for the Flex Builder/SDK \nand ActionScript Compiler projects. JIRA allows a user to cast votes for various issues that may be of \nrelevance to the user. It also allows a user to track a particular issue and be noti.ed of any updates \nregarding that issue [6]. The aggregated votes allocatedtobugs are thoughtto re.ectthelevelof interest \nfrom the user community. As each user is allocated a limited num\u00adber of votes, users must consider how \nto cast their votes carefully. Users could also unvote on issues that no longer interest them this ensures \nthat more important issues are dealt with .rst [1]. While voting-based systems offer expressiveness in \norder to understand user preferences theydo not provide direct incentives for reporting, other than indirectly \nthrough the potential to infuence whichbugs receive attention. 2.1.2 Market-BasedVulnerability Reporting \nSystems For security-related issues,bug reports are essential to ensure the integrity of the software. \nHence, several market-based vulnerability reporting systems have been introduced with the goal of incentiviz\u00ading \nusers to report bugs and vulnerabilities. We review two such systems below. The .rst one is currently \nused in practice, while the second one is a proposed theoretical framework. Mozilla Security Bug Bounty. \nThe Mozilla Foundation offers a cashawardof $500anda MozillaT-shirttoanyonewho reportsa valid, critical, \nsecuritybug [8]. Thebug must meet certain criteria including the following: the bug must be new, it must \nexist in the latest supported version of Firefox or Thunderbird released by Mozilla, and thebug .nder \nmust not have written thebuggy code or reviewed that code or contributed in any way towards that code. \nBug reporters are encouraged to work with Mozilla engineers in resolvingthebug. Securityvulnerabilities \nare treatedina special way because the consequences of a vulnerability being exploited canbeextremely \nserious. Securitybug reportsmaybekeptprivate for a limited amount of time to enable Mozilla engineers \nto .x the bug beforeitismadepublic.Howeverthebug reporterisallowedto decidewhento disclosethebugtothepublic.Thebug \nreportermay chooseto disclose earlierifthebugisbeing ignored,forexample. By not publicizing information \nabout the bug immediately upon discovery and instead reporting it to Mozilla, the bug reporter acts in \nthe interests of the Mozilla project and is compensated accordingly. Vulnerability Markets. Schechter \n[14] proposes to use a vulner\u00adability market to incentivize testers to identify vulnerabilities in software. \nIn a vulnerability market, software producers offer time\u00advariant rewards to the .rsttesters who identify \nvulnerabilities in the software.A minimum rewardvalue R0 is initially offered, which then grows over \ntime at a rate decided by the producer. When a new vulnerability is reported it is .rst veri.ed to be \ngenuine. On passing veri.cation, the tester responsible for the report is awarded some portion of the \nreward. The reward amount is then reset to the minimum amount R0. Only the .rst reporter receives the \nre\u00adward. Hence a tester that waits to report a vulnerability increases the amount of the rewardbut also \nincreases the likelihood that an\u00adother tester may report the vulnerability .rst thereby cutting him out \nof the reward. Clearly in such a scheme the most frequently occurring vulnerabilities will be found .rst. \nIf the reward remains unclaimed the product is considered to be safe enough to protect information whose \ntotal value is at most the amount of the reward. Firms have an incentive to cooperate with the vulnerability \nmarket as it provides a measure of the quality of their products and hence their reputation. Ozment[10]explainsthatthe \nvulnerabilitymarketis essentially an auction in the style of an open .rst-price ascending auction, or \nreverse Dutch auction. There is onebuyer of vulnerability in the auction, the producer, and potentially \nunlimited number of sellers, the testers. The initial price is setto be relatively low and the price \nrises continuously until accepted by a seller. The valuations of the sellers or testers are private because \nthey depend on the amount of work or cost incurred in locating a vulnerability. The minimum reward value \nR0 is the auction s reserve price. Interestingly it appears that the quality of software and the soft\u00adware \nproducer s investment in patching technology are strategic substitutes. If it is possible to release \na patch then software produc\u00aders enter the market sooner and with software containing a greater number \nofbugs [9]. It has also been shown that software produc\u00aderstendto issue patches laterthanis socially \noptimal[9].We note that while both the Mozilla Bug Bounty and the vulnerability mar\u00adket provide incentives \nfor reporting vulnerabilities, the valuation of users for a patch for a particular vulnerability is not \ncaptured.  2.2 Online Freelance Marketplaces Whereasbug and vulnerability reporting systems are used \nto iden\u00adtify issuesin software,theyoftendo not couple this identi.cationof issues with a sourcing process \nto perform work in addressing these issues. Thisgapis .lled with online freelance marketplaces, which \nare platforms that connect individuals, small-business owners, and evenFortune 500 companies with freelance \ntechnology specialists to satisfy their technological needs. The sites provide vivid details about workers \nhistories and quali.cations, and some even feature toolsthat let thebusinesses monitor thework they are \npaying for [4].Web developers, software programmers and other IT special\u00adists from different countries \nare readily available and often charge a fractionofthepriceoflocalworkers.Wewillexaminetwosuch online \ncompanies, RentACoder and TopCoder, below. While tasks typically are independent projects in RentACoder, \nindividual tasks often are componentsofa larger projectinTopCoder.We will also brie.y reviewthe iTune \nApp Store,whichisamarketplacefor soft\u00adware applications for the iPhone.  2.2.1 TopCoder TopCoder Inc. \nuses programming competitions to build profes\u00adsional grade software outsourcedbyclients ranging from \nindividual entrepreneurs to global Fortune 1000 companies. For every task, participants compete against \neach other for cash award. The top one or two contestants win the award. TopCoder members can work for \na variety of outsourced software projects including the \"Bug Races,\" which is a competition for .xing \nbugs. Members can.x postedbugsandthe .rst submission thatisveri.edtobe fully functional (according to \ntests and design criteria) is awarded a prize. Other types of software developement projects (software \ndesign, software architecture, etc.) use a similar competition for\u00admat. Boudreau et al. [3] argue that \nthe competition platform of TopCoder can increase the quality of the best solution by broad\u00adening the \nsearch for innovation.We note thatTopCoder seems to be used mainly for de novo design rather than for \nimprovements or .xes to existing software systems. CentraltoTopCoder s methodology appearstobethe modular\u00adization \nof software development work [5]. Each project is broken down to the most granular level possible. As \na result most pieces of work can be completed in a few hours [2]. In addition the mod\u00adularization of \nprojects allows for simple evaluation criteria when determiningifa submitted software solution orbug \n.xis indeed complete. It also reduces the likelihood that newly submitted code may exert unintended effects \non the existing code base. Hence the winning programmer may be rewarded for his work as soon as it is \nvalidated.Thishasthe bene.tof reducing uncertaintyforTopCoder as well as for the programmers. Interestingly, \nthis modularization (and architecting, more broadly)is itself performed withinthe same competition platform. \nWhileTopCoder provides some monetary incentives for its par\u00adticipants, its .xed pricing for tasks may \nnot be ef.cient in identi\u00adfyingthe best participantsto performa task. Moreover,TopCoder is also more \nthan a software crowd-sourcing platform, in that it also provides value in establishing a community of \ntalented coders and helping companies to identify talent.TopCoder is also an eas\u00adily accessible practicing \nground for programmers looking to hone their skills. All submissions to a task receive feedback from \na peer review process involving multiple metrics on a scorecard, which provides valuable information \non how a submission could have been improved [2]. Firms like Google and Microsoft often spon\u00adsor screening \ncontests [3], and seem to hire talented participants. 2.2.2 Rent-a-Coder Rent-a-Coder is another online \nmarketplace that connects buyers to coders. All projects are protected by escrow and through arbi\u00adtration. \nBuyers post new projects on the site. Sellers (coders) post questions and submit bids on the projects. \nThebuyer then selects the seller that he or she wants to award the project to and puts the funds into \nescrow as a payment guarantee. When the work is completed, thebuyer releases funds from the escrow accountto \nthe seller.Ifthe seller completestheworkbutthebuyer withholdsthe funds, an arbitrator will step in, test \nthe software if necessary, and release the funds to the seller as appropriate [2]. Different auction \ntypes are alllowed within Rent-a-Coder. In an open auction all members of Rent-a-Coder can bid for a \nproject. In a private auction only those coders that thebuyer invites may participate. Other arrangements \nare also possible such as \"Pay for Time\" where thebuyer paysa coder for the time spent ona project rather \nthan for an end result. Rent-a-Coder charges coders a fee ranging from 7.5% to 15% on the pro.t from \nwork done [12]. Once theworkis completed thebuyers and sellers may rate each other.ThisisdifferentfromTopCoder,wheremostofthe \nreputation information is aggregated from directly measurable performance metrics such as the fractionof \ntests passedbydeveloped code.  2.2.3 iTunesApp Store Another system that provides a market-based approach \nto a dif\u00adferent part of the application development ecosystem is the iTunes App Storeforthe iPhone.TheApp \nStorehasabuilt-in micropay\u00adment system where developers can make signi.cant pro.ts even with applications \npriced at $0.99. There is also a rating system. Popular applications have thousands of ratings, and it \nis interest\u00ading that a large proportion of which include comments from users about outstandingbugs and \ndesired features. Developers often ad\u00address these issues explicitly in their comments when releasing \nup\u00addates. In this way, the App Store is effective in better connecting end users and developers. The \nApp Store shows that a micropayment-based model for software delivery is eminently practical and well-received \nby con\u00adsumers,but lacksawayfor multiple programmersto contributeto a project or for users to vote or \nbid for features and .xes in an organizedfashion. 3. Market-Driven Software Wenowdescribe our proposal \nfor usingamarket-based mechanism to drive the evolution of software to increase its correctness and its \nfunctionality.We unify manyof the previous partial market-based mechanisms, incorporatingbug reporters \n(as in vulnerability mar\u00adkets),bugvoters(asinBugParade) anddevelopers andvalidators (asinTopCoder and \nRent-a-Coder). This proposal is not yet completely .eshed out (or at all im\u00adplemented).To get some intuitive \nsense of what we have in mind, imagineacombinationoftheiTunesApp Storeand Bugzilla where users can bid \nmicropayments for the .xingofbugs or implementa\u00adtion of new features, and anyquali.ed developer can obtain \naccess to the code and perform the requested work. Users could offer as little as a pennyfor a .x or \nfeature, and aggregate demand could still be suf.cient to make it worthwhile for a developer to satisfy \nthem. Furthermore,the demandcanbeusedbythedevelopertode\u00adcide how to concentrate effort to increase quality \nand attract more users. One missing element of existing voting-based systems such as Bug Parade is that \nthey do not directly elicit additional work in .xing bugs in released software. Rather, they are used \nto focus existing programmer resources on problems identi.ed as important by a user community. Our approach \nis designed to allow users to elicit additional work (and encourage new developers to work with the software) \nby offering rewards for the work. More speci.cally, we consider a market ecosystem around a particularpieceof \nsoftware.Theevolutionof softwareisadynamic process. However we will .rst present a static snapshot of \nthe soft\u00adware market ecosystem. The ecosystem comprises the following basic entities: UUsers of the software. \nUsers might be individuals, corporations, or other entities. J Jobs which the users would like to have \nperformed on the software. W Workerswho may perform jobs. Note that workers may also be users and vice \nversa.  KKinds which are (optionally) used to categorize jobs. Examples are correctness, feature, security, \nmac, etc. Label Lkj is1if job jhas kind k,0otherwise. Reward Rtuj offeredbyuser ufor job jat time t. \nIf user u does not offer a reward for job jat time t, then Rtuj = 0. Cost Ct wj toworker w for performing \njob jat time t. Ifworker w is incapable of or uninterested in performing job jat time t, then 1 we consider \nCt wj = 8. The labels exist for categorization and to allow the calculation of aggregate statistics about \ndifferent categories of work items. The market is agnostic as to these categories. However, users may \nexpress preferencesbyofferingrewardsfor particularkindsofjobs; we will expand on this below. We assume \nthat rewards are in an actual currency (denoted $ ) and consider for the most part an open market in \nwhich the only barrier to entry for a particular worker is their ability to complete a particular job \n(as opposed to the availability of the source code).Akeyfeatureof our marketis thatit incorporates both \nthe aggregationof user bids (likebugvoting systems) and multiple competingworkers (likeTopCoder). Thisexchange \nstructure, with informationand preferences (e.g., costsfordifferent kindsofwork, values for different \nkinds of .xes) on both sides, is designed to provide for a more ef.cient market place. For the time being, \nwe make a number of simplifying assump\u00adtions: that users bids are correctly aggregated (that is, we can \nde\u00adterminewhentwo usersofferarewardfor.xingthe same bug) and that a single worker can perform a job in \nits entirety (which requiresjobstobe modularized appropriately,asisthe caseinTop-Coder for example). \nIn Section 4.4 we discuss how to use market mechanisms to handle a more realistic scenario. 3.1 User \nDemand Given the ecosystem described above, the total reward for a job j at time t is Rtj = . Rtuj, (1) \nu.U and we de.ne the user demand on a piece of software as the aggregate of the available rewards: R \nt = . Rtj (2) j.J When R = 0, there is no demand for changes or additions to the software. Note that \nthis does not imply that users are satis.ed: the demand might be0because users don t like the software \nand no oneis using it.We denote the demand fora particular kind kof job at time t as R t[k]= . Rtj\u00b7 Lkj \n(3) j.J As discussed in the introduction, software has traditionally been considered to havesome ideal \ncorrect state in which there are no more bugs.\" Henceforth we will refer to this notion as absolute correctness. \nWhile it is a laudable goal, for anything but small modules absolute correctness is unachievable, and \nin many large systems, can not even be completely speci.ed. However,in ourmarket,we canexpressthe correctness \ndemand in period t as simply R t[correctness]. If the correctness demand is0,it does not mean that there \nare nobugsin the software but 1Note that we can allow for workers that are capacity constrained by allowing \nthe cost for a worker to adjust to 8 when already working on anotherjob. Moreover,cost canbe consideredto \nalreadyfactorinaworker s pro.t margin so that cost Ct wj indicates the reward thataworker requires for \njob jat time t to be willing to perform the work. itdoes meanthattherearenobugstowhichany users attachvalue \nfor .xing. Analogously, we can quantify the demand for security, new features, support for a particular \nplatform, and so on. 3.2 MarketPotential and Equilibrium Intuitively, the jobs that are worth doing \nfor workers are those where the cost of performing the work is less than the expected reward. More speci.cally, \nwe can de.ne the potential value of a job jat time t as Pt = max(Rtj-Ct (4) j wj,0) w.W That is, the \npotential value of a job is the reward net cost that can be obtained by the worker who can perform it \nfor the lowest cost(provided thattherewardisat least theircost).We de.nethe potential value of the entire \njob market as: Pt = . Ptj (5) j.J The correctness potential of a system in period t is then Pt[correctness]. \nNote that Pt[correctness] = R t[correctness], so that if there is no correctness demand then there is \nnecessarily no correctness potential. The user demand Rtj can be thought as the price at which users \ndemand for thework onjob j(or the bid price). Ct wj then represents the price at which worker w is willing \nto supply the work for job j (or the ask price). Ideally, whenever the bid price is greater than or equal \nto the ask price, the market should drive the work to happen. Hence, we de.ne that a system is in correctness \nequilibrium when Pt[correctness]= 0.Asystemin correctness equilibriumis one whereallofthebugsthatare \nworth .xing havebeen.xed. There may stillbe plentyof latentbugs, oreven signi.cant correctness demand,but \nthere are no longer anybugs whichaworker can .x without losing money.  3.3 Dynamics in the Market The \nnotions of correctness demand, potentia and equilibrium have sofarbeen discussedinthe contextofan (implicitly) \nstatic system, where a group of users bid rewards for a job to be performed, and workers decide whether \nto perform the jobs based on their costs and the economic rewards. However, a real system is dynamic: \nthe reward for a job may .uctuate (up when users post additional rewards for the job or down if the user \nhas speci.ed an expiration date for the reward). Furthermore, workers may decide to attack a problem \nat different times depending on how pro.table a job is and whether the reward for a job might increase \nfurther, as well as considerations about the level of competition with other works and other opportunities. \nThus a piece of software with a large and vibrant user community may have a user demand and a market \npotential that remain high: as some jobs are resolved, others are submitted. Aperfect equilibrium, for \nexample withPt[correctness]= 0 for correctness, may never be reached in reality. Instead the system will \ntend to constantly move towards equilibrium, pushed forwards by market pressure to perform jobs that \ncomes from the potential value associatedwithajob.We shouldexpectthatjobswithhigh correctness potential \nto be prioritized ahead of jobs with lower correctness potential; e.g, because there exists a worker \nwho can performthejobatlowcostandextractalarge fractionofthereward available for completing the job. \nAlow correctness potential in steady state could indicate either that the system is well-written with \nlittle to .x, or easy-to-make .xes, or that it has a large or wealthy user base that values im\u00adprovements, \neven if they are costly to implement.  3.4 Inability to Measure Cost We have de.ned market potential \n(e.g., correctness potential) in terms of the costs to each worker of performing each job and the demand \nfor a job. However, it should be noted that these costs may not be known a priori, even by the worker \nconsidering the job (and we all know how inaccurate programmers development time estimates can be). Furthermore, \nwhile an individual worker can probably evaluate their cost effectively once theyhave completed a job, \nsuch a worker may not wish to share this information with the marketplace. Nevertheless, the de.nitions \nof market potential are useful to provide a framework within which to discuss the behavior of the system. \nAnd in fact, the inability of users in the marketplace to knowthe cost functions is important for stimulating \nrewards (otherwise users would stop offering rewards as soon as thevalue potentialofthejobexceeded0).Arichmarket \neconomy could include market analysts who estimate the cost function, and sell the information to participants \nin the system. 3.5 Ef.ciency Another importantfactor not captured sofar is market ef.ciency. Given a \nset of jobs, generally speaking we would like each job to be performed by the the worker that provides \nthe best tradeoff between solution quality and cost of performing the work, rather than simpler the cheapestwork. \nBut the model as proposed does not differentiate between different qualities of work; rather, whether \nor not the reward is available is a binary determination. Another criteria to consider is the number \nof jobs completed. This could be important, for example, if solving a larger number of jobs provides \na positive externality on the overall user experience, or helps to have ripple effects in making other \njobs easier to complete. Thus we would like to be able to quantify the ef.ciency of a particular work \nallocation, really a work allocation policy in the context of a dynamic system, and to design a market \nmechanism in such a way that it maximizes ef.ciency. Quantifying ef.ciency within a formal model of this \ndynamic system will be an important direction for future work.  3.6 Bundled Rewards Sofar wehave discussed \nindividual rewards postedby users.How\u00adever, some users may wish to in.uence the broader direction of \nthe software rather than fund particular jobs. Other users may simply not have the time or expertise \nto offer rewards for particular jobs. Bundled rewards provide an approach for handling both of these \nissues.A user couldofferarewardtobesplit acrossasetofjobs, andin particularover allof the jobsofa speci.c \nkind.A user who was primarily interested in the stability of the system could offer a reward to be split \nacross all of the correctness jobs; another user mightfavor security;another might allocate funds to \nencourage development on the mac platform. This is analogous to investors who invest in the Dow Jones \nIndustrialAverage instead of in par\u00adticular stocks. Funds couldbedividedevenly across all the jobsin \nthebundle, or proportionately to the existing rewards ( matching funds ) in ordertoleveragetheinformationextantinthe \ncurrentrewardoffers. Another question is whether the allocation should be made across the jobsextant \nwhen thebundled rewardisoffered, or whetherit should adaptively allocate funds as newjobs are posted. \nIn the latter case, it seems that some amount ofhysteresis will be desirable so thatworkers are not subjecttoexcessive \nprice .uctuations. 4. Market Design: Components and Challenges In the previous section we made two major \nsimplifying assump\u00adtions: that an individual worker can complete a job, and that work\u00aders always perform \nquality work that adequately addresses an is\u00adsue. In particular, there is no quality control in the system. \nQuality control implies multiple agents with checks and balances.We now present the elements of a market \ndesign for a realistic market sys\u00adtem that removes these assumptions. There are four fundamental principles \nthat underly our design: Autonomy. All of the actions necessary to bring jobs to com\u00adpletion should \nbe driven by market forces; the process is never gated by an entity outside of the market.  Inclusiveness. \nEveryone who provides information or performs work that leads to improvements should share in the rewards. \n Transparency. The system should be transparent with respect to both the .owof moneyin the market and \nthe tasks performed by workers in the market.  Reliability. The system should be immune to manipulation, \nrobust against attack, and prevent shallow work which would have to be re-done later.  There are two \nfundamental problems that the system must sup\u00adport. First, information aggregation from the user base, \nthrough an expressive, non-manipulable and easy-to-use process. Speci.cally the system must capture user \nvaluations for various jobs. It must alsoelicit certaintypesof information(forexample,the stepsto re\u00adproduceabug)thatwouldbe \nusefulin performingthejob. Finally the system must aggregate all users preferences and information regarding \nparticular jobs. Second, work allocation: the system must support the ef.cient allocation of sub-tasks \nwithin the software producer organization and across outside programmers in the case of open software \ndevelopment. In providing this functionality, it will be important to identifytherightpeopletoperformataskandtoprovide \nincentives so that an appropriate effort level and technical solution is provided. Jobsalsoneedtobe prioritized,factoringboththevaluetothe \nuser base and the cost to perform them. The components of our market design seek to integrate these two \nfundamental subproblems into a comprehensive solution. 4.1 Funding The .rst question we must answer \nis how the market is funded. This depends on what kind of business model is being used for the software. \nHowever, the market is designed in such a manner that whether the system is open-or closed-source, there \nare no downstream dependencies by other parts of the market that must differentiate where the funding \noriginated. Ageneral feature of the proposed market-based system is that bids are placed in escrow and \nhave an expiration date;if the bid expires (no one has performed the work by the deadline ), then the \nmoney is returned to the bidder (or they can choose to let it ride ).Anumberof methods are possible, \nwhich can all co-existif desired: Direct Bidding.A user can directly offer a cash reward. Escrow from \nSale. When a user purchases a piece of software, a fraction of the sale price is placed in escrow for \nthe market. The user can then use this capital to bid. If the user does not bid after some period of \ntime, the money can be returned to the seller or placed into a general fund that tracks the market as \na whole. Escrow from Contribution. For a shareware model, since the contribution is voluntary the user \ncan choose the fraction of the shareware contribution to place in the market, and can also choose to \nwithdraw the money when it expires (rather than having it returned to the seller, as above). Escrowfrom \nRegistration. Even if the software is free, there may still be capital available. Manylarge open-source \nprojects have signi.cant sources of corporate support (for instance, Mozilla s largest source of income \nis from sales of placements in the Firefox search bar). Some of this money can then be placed in the \ngeneral fund and have portions allocated to users upon registration.Ifthe usersdonotbid,thecapitalin \nescrowexpires and reverts to the general fund.  Note thatin allof these cases, regardlessofbusiness \nmodel, the proposed market is funded with real money, which can be earned by those contributing to the \nsoftware. The only differences are the degree to which the moneyin the market is fungible to the bidders. \nThe moneyin escrowis handledbya trusted third party(not by the seller of the software), which we designate \nas the bank.\"  4.2 Reputation System Autonomyis thekeypropertyin making the marketwork.To the greatest \nextent possible we wish to use decentralized market mech\u00adanisms ratherthan centralized controlto achieve \nour goals.Forex\u00adample, rather than having a centralized authority that validates a bug.x,we proposeamarket \nmechanism (similartothat adoptedin TopCoder) in which other workers are rewarded for providing test cases, \nand competingdevelopers can challenge the correctnessofa solution and possibly steal the win from their \ncompetitor. We do acknowledge that there always needs to be some form of centralized control for most \nsoftware systems, in particular when making large-scale architectural decisions, or choosing among competing \nsets of features. Open source projects (for example, Linux, Firefox, and Jikes RVM) all have a core group \nwhich exerts this centralized control, even as they accept work from a wide range of contributors. Thus, \nsimply having a bazaar [11] is untenable we at least need a small church next to it. However, centralized \ncontrol suffers from lack of scaling, is often unncessarily rigid, and can lead to a lack of responsive\u00adness. \nIn order to address this issue, we propose to design a hy\u00adbrid reputation-based system: every contributor \nhas a rating, and every kind of task has a minimal rating prerequisite. Ratings can be seeded (or adjusted) \nby the central authority, so it can directly give its members privileges to perform various operations, \nor de\u00adauthorize external contributors who it decides are acting against the interest of the user base. \nAs contributors perform work, when they are paid their reputa\u00adtion increases. The idea is that ratings \nwillnaturally .ow from the initial core group designated by the central authority out to an organically \ngrowing base of contributors. If the contributor com\u00admunity reaches critical mass the rating system can \nbecome self\u00adregulating, without requiring direct intervention by the central au\u00adthority. Nevertheless, \nthe central authority can retain the right to intervene when needed. 4.3 Payments Eachjobwillhaveasetofworkerswho \ncontributedtovariouspor\u00adtionsofthework.ow; e.g.,the reporterofa problem,thedeveloper of a test, and the \ndeveloper of a .x. Generally speaking, we pro\u00adpose that all contributors share in the reward for the \njob when it is delivered, although some (partial) payments may be made earlier in orderto encourage certain \nkindsof activities.Payments can alsobe made over time to ensure that contributions are robust; if a contri\u00adbution \nis discovered to be .awed after it is delivered, the remaining payments can be halted, and the funds \ndiverted to workers who .x the problem. The exact way in which the reward is to be divided among the \ncontributorsisstillopentodesign,butweseethisbeing modulated by a number of factors: the type of task \nperformed, the rating of the contributor, and the shape of the demand trajectory (see Section 4.5). It \nalso seems desirable for the system to be self\u00adadapting. If a job stalls at a particular point in its \nwork.ow, the fraction of the reward for performing the next task can be made to growover time.This canalsobeusedtofeedintothe \nglobaldefault fraction for that typeof task.For instance,if many work.ows stall in the testing phase, \nthe fraction of the reward allocated for testing will go up over time. 4.3.1 Applicability to Closed \nSource Systems A major question is whether the kind of market system we are proposing will work for closed-source \nsoftware, where the pro\u00adducer maintains some form of monopoly control over the code. While closed source \nreduces the opportunities for contributions, it does not preclude using the market. First of all, some \ntasks, like reportingbugs, creating test cases, and writing documentation can be handledby users with \nno access to source code. Secondly, the market may be used to drive allocation of devel\u00adopment resources \nwithin the company. This could range from direct control by managers who merely use the market data as \nuseful in\u00adput about what issues are important to the user base, and collect the payments on behalf of \nthe company, to a system where developers receive a base salary and must earn the rest of their pay from \nthe softwaremarket.Inthe latter case,the producercanseedthemarket with moneythat is intended primarily \nto .ow back to its employees as incentive-driven compensation. Finally,theifthereis demandforworkinthemarketwhichonly \nthe producer can perform (due to its monopoly status), the producer can hire contractors to perform the \nwork, funding them out of the accumulatedrewardsinthe market.Ineffect,the marketprovidesa way for the \ndemand to tunnel through the organizational bound\u00adary created by the producer s closed-source monopoly, \nand allow it to repond with a higher degree of elsasticity to the demand for work on the software.  \n 4.4 Work.ows Different kinds of work have different work .ows that require various types of contributors \nin order to complete. 4.4.1 BugWork.ow Webeginbydescribingthework.ow associatedwith reportingand .xing \nabug: Report. Filinga reportofabug. This canbe assimple as clicking abutton on a popup box ( Send Report \nto Provider ) when the application crashes, or .ling an explicit report of a problem in a bug database. \nThe former can be made available to anyone (except perhaps spammers with negative reputation ratings); \nthe latter would typically require some non-zero rating. Bid. Bidding an amount to contribute to the \nreward Rj for .xing thebug. Organize. Determining when tworeports are instances of the same bug, or when \nwhat appears to be onebug isinfact two differ\u00adentbugs, or thatabug has already been resolved,is sometimes \na dif.cult task. Therefore it is explicitly recognized as an in\u00addependent part of the work.ow, and requires \na relatively high rating. Organization can also include categorization of a bug, for instance as a security \nexposure. Reproduce. Creating and .lingawayof reproducing thebug, so that .xers can begin to work on \nit. Fix. Developa.xforthebug. This canbe opento contributors witha wide rangeof ratings,butabug.x submittedbyalow\u00adrated \ncontributor will have to be committed by someone with a proportionately higher rating. Test.Test the \n.x, either by providing an executable testcase or by exercising the system. Since the latter requires \na large degree of trust,itwould typically requirea high rating.A test thatis failed by a .x receives \na higher reward than one that passes.  Figure 1. Characteristic DemandTrajectoriesofVariousTypesof \nBugs Commit. Commit the .x to the canonical code repository. This will typically require a high rating. \nDistribute Patch. In some systems, it may be desirable to make either source-or object-code patchesavailable \nbefore thebug .x can be incorporated into a full release. Bidders could be allowedto specify whethertheywouldpayforapatch,orwould \nrather wait for a new release. Some tasksinthework.owmaybe designatedasbeing antago\u00adnistic (for instance \n.xing and testing). Antagonistic tasks will either be prevented from being performed by the same contibutor, \nor will require a relatively high rating to allow it.  4.4.2 OtherWork.ows Various other kinds of work.ows \nwould address other parts of the overall software lifecycle. For the development of new features, TopCoder \nprovides a good model. Their process includesConcep\u00adtualization, Speci.cation, Architecture, Component \nDesign, Com\u00adponent Development, andAssembly. Depending on their scope (mi\u00adnor localized features versus \nlarge-scale changes across the appli\u00adcation) the work.ow might be condensed or extended. Documen\u00adtation \ncould also be a work.ow in which tasks might be Outlining, Terminology, Section Writing, Integration, \nand Proofreading.  4.5 Using the DemandTrajectory An interesting aspect of the system is that the demand \ntrajectory, that is how the demand (i.e. aggregate bid value) varies over time, can be used to extract \ninformation about how the market values bugs and how the rewards should be divided between various con\u00adtributors \nto the work.ow for a job. Figure1tracks the aggregare reward for four differenthypothet\u00adicalbugs.Acriticalsecuritybugduetoabufferover-runwouldbe \nhigh priority(itsrewardwouldrise drammaticallyas soonasitwas discovered), a .x would be submitted and \nvalidated quickly, and the .x would then be delivered immediately to the .eld. Thus the payouts would \nbe made rapidly. On the other hand, a low priority bug that takes a lot of time to .x may never get .xed \nat all, and have a very slowly growing (or even shrinking) reward. In Section 4.4 we described realistic \nscenario involving different playersinabugwork.ow:adeveloperwould .x thebug and then testers would test \nthe .x. Moreover the .x might only be accepted if some other worker of high reputation validates the \n.nal solution. In the case of security vulnerabilities the mechanism must also incentivize users to report \ndefects. The dynamics of our proposed market mechanism function as follows: At time T0 user U reports \nabug B. The software producer (company or organization or open source community) pertinent information \nregarding B in a public database. Now users start to contribute moneyon Bre.ecting theirvaluefora.x.At \nsometime T1 the reward riding on the bug has grown to an amount RTB 1.A developer, who decides that enough \nmoneyhas been contributed to make correcting Bpro.table, jumpsinandbeginsworkon B. Later at time T2 the \ndeveloper has completed his work and other users or testers test the software to see if the .x is indeed \nrobust. If at some time T3 .aws are found in the solution submitted by the developer then the persons \nresponsible for the detection of the .aws share in the reward money RT3. B We can consider a payment \nscheme that distributes the re\u00adward money RB among thebug .nder, thebug .xer, and thebug testerin different \nproportions re.ecting the strength of their rela\u00adtive contributiontothe resolutionofthebug.Forexample,the \nratio RB/(T1-T0) is computed when ascertaining the signi.cance of the intial discoveryofthebug.If this \nratiois reltivelyhigh thenitim\u00adplies that the discovery was very useful as a large sum of money was accumulated \nin a very short time. Clearly some portion of the user base would derive signi.cant utility from a .x \nfor the bug. Similarly if the time taken to .x T2- T1 is long then it tends to indicate that the .xwas \nnon-trivial and thebug .xerexpended con\u00adsiderable effort (recall that there is a competitive process \nhere, so it is not easy for one developer to arti.cially delay this window). Likewise the longer the \nperiod T3 - T2 the more robust the .x. Therefore the sooner testers can .nda .awthe greater their share \nin the pie. The discovererof thebugis determinedtobe the .rst personto.nda particularbugthatisveri.edtobe \ngenuine.Many peoplemayworkon .xingthebug;howeveronlythe .rst personto submitaworking solution (including.xingany.aws)ispaid.Any \ntester who either detects a new and valid .aw in the .x or devises a thorough acceptance test can share \nin the reward.  4.6 Design Challenges A market structure seems better suited to address the problem \nof ef.ciently resolving neglected bugs than existing non-market systems. However bug management is a \nnontrivial problem with complex interdependencies and side-effects and there remain some interesting \nchallenges, that point to the richness of the problem and are intrinsictothe problem.Forexample,the unintended \nside\u00adeffect of introducing new bugs while .xing an existing bug is a common occurrence in software development. \nUnder currentbug management systems these new bugs are simply discovered and then loggedin thebug database \nfor futureexamination.However withamarket-based approach whereapaymentis made conditional on a .x, we \ncan no longer afford to ignore these side-effects and a market-based approach will need to develop techniques \nto promote good\" .xes that don tlead to lots of new unintended side-effects. Challenge 1: Certifying \n.xes. A fundamental challenge is how to determine whethera .x hasinfact thoroughly .xed thebugin question.Thisis \nimportantinorderto ensurethatthe paymentfora .xisfairandrobustagainst manipulations.Forexample, usersmay \ninitiallybe unableto reproducethebugfor the work.ows typically used by these users. However some time \nlater some user executing adifferentwork.owmay reproducethe .xed bug.Ifthe payment for that bug has already \nbeen made there is little incentive for developersto prioritizea.x.Orelseifthebugis treatedasa\"new\" bug \n(thereby requiring that a further reward be provided for its .x) then the system s ef.ciency deteriorates. \nJust allowing users time to validate a .x is unlikely to be enough. One idea is to incentivize testers \nto either provide a certi.cate of .x or show that thebug has not been properly .xed. Challenge 2: Deep \nversus shallow .xes. Anatural question that arises outofexamining Challenge1ishowto design incentivesin \norder to obtain robustbug .xes and to preempt anystrategizing on thepartofthe.xers.Thesystemmust incentivize \ndeep\".xesover shallow\" .xes.Adiscounted payment scheme mightbe oneway of addressing this, so that follow-on \n.xes to augment an earlier .x are assigned rewards in a way that ensures that the aggregate payment is \ngreater if a good, deep .x is completed initially. Challenge 3: Externalities caused by bug .xes. One \nor more bug .xes may unintentionally .xa numberof other reportedbugs. Likewise one or morebug .xes may \nunintentionally introduce new bugs. Let us consider the following scenario: users have logged severalbugs \nin thebug database. In response3developers decide to tackle bugs X, Y, and Z. They simultaneously submit \n.xes to their respectivebugs.Asa result several otherbugs D, F,G,M, and Qappear to be resolved as well. \nNow we are left with the question of which of the original 3 bug .xes resolved the other bugs and how \nshould the payment be determined. A preliminary solution mightbetopermitonlyonebug.xatatimetobe enteredintothe \nsoftware.Veri.cationof theeffectsofabug .x may require time and effort from testers who can certify that \nthebug .x is indeed correct, that otherbugs were (not) .xed, and that newbugs were (not) introduced. \nHowever leaving a timegap between two .xes slows down the process and could cause bottlenecks. Alternatively \ncould there be some kind of automatic market-driven method to verifytheeffectsofabug.x?Forexample,woulditbe \npossibleto generateabug dependencygraph that could allow propagationof credit? Challenge4: Eliciting \nexpressivebugreports. The system must elicit and aggregateexpressivebug reports needed for robust .xes. \nWe may want to examine the tradeoffs between private versus public disclosure of bugs. Publicly sharing \ninformation on bugs wouldhelp usersto coordinatetheireffortsandexchangevaluable information regarding \nthe bug and potential workarounds. One way to accomplish this would be to set up a Bug Information Exchange. \nThiswould increase the qualityof thebug reports and reduce the numberof duplicatebugs.In theevent thata \nreasonable workaround is found users would then have a better sense of how much they value an immediate \n.x for thatbug. Challenge 5: The public goods problem. A user who chooses not to invest money or effort \non a bug which is .xed by others nonetheless bene.ts from the .x. As the user base grows the public goods \nor free-riding problem appears to be unavoidable. Peer\u00adproduction systems alsoface similar issues. Some \nfunding models, such as escrow from sale\" already address this problem. But the problem will likely still \nremain in most such systems in some form or other. Future work should explore this challenge; e.g., how \ncan its effect can be minimized, or can bounds be established on its impact on social welfare?  5. Acknowledgements \nWe thank Karim Lakhani, Ben Lubin, Rob O Callahan, and the Harvard EconCS group for valuable feedback \nand discussions. References [1] Adobe bug and issue management system. http://bugs.adobe.com/.ex/. [2]BENNETT,A. \nItworld: Finding freelance jobs:6 sites for talented techies. http://www.itworld.com/career/65739/.nding-freelance\u00adjobs-6-sites-talented-techies, \nApril 2009. [3] BOUDREAU,K.J.,LACETERA,N., AND LAKHANI,K.R.Parallel search, incentives and problem type: \nRevisiting the competition and innovation link. working paper, no. 09-041. Tech. rep., Harvard Business \nSchool, September 2008. [4] FLANDEZ, R. The wall street journal: Help wanted and found. http://online.wsj.com/article/SB122347721312915407.html, \nOctober 2008. [5]HOWE,J.Wiredmagazine sjeffhowe talks about crowdsourcingand topcoder. http://www.topcoder.com/direct/blogs/?p=174, \nFebruary 2009. [6] Jirabug and issue tracker. http://www.atlassian.com/software/jira/. [7]LAKHANI,K.R., \nAND PANETTA,J.A. The principlesof distributed innovation. Innovations:Technology,Governance, Globalization2,3 \n(2007), 97 112. [8] Mozilla website. https://www.mozilla.org/security/bug-bounty.html. [9] NIZOVTSEV, \nD., AND THURSBY, M. Economic analysis of incentives to disclose software vulnerabilities. In InFourthWorkshop \non the Economics of Information Security (2005). [10] OZMENT,A. Bug auctions:Vulnerability markets reconsidered. \nIn In ThirdWorkshop on the Economicsof Information Security (2004). [11] RAYMOND,E.S. The Cathedral and \nthe Bazaar,2nd ed. O Reilly &#38;Associates, 2001. [12] Rentacoder inc. website. http://www.rentacoder.com. \n[13] RINARD, M. Acceptability-oriented computing. In Companion of the 18th annualACM SIGPLAN conference \non Object-oriented programming, systems, languages, and applications (Anaheim, CA, USA, 2003), pp. 221 \n239. [14]SCHECHTER,S.E. Howtobuy better testing: using competition to get the most security and robustness \nfor your dollar. In In Infrastructure Security Conference (2002).    \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Software correctness has bedeviled the field of computer science since its inception. Software complexity has increased far more quickly than our ability to control it, reaching sizes that are many orders of magnitude beyond the reach of formal or automated verification techniques.</p> <p>We propose a new paradigm for evaluating \"correctness\" based on a rich market ecosystem in which coalitions of users bid for features and fixes. Developers, testers, bug reporters, and analysts share in the rewards for responding to those bids. In fact, we suggest that the entire software development process can be driven by a disintermediated market-based mechanism driven by the desires of users and the capabilities of developers.</p> <p>The abstract, unspecifiable, and unknowable notion of absolute correctness is then replaced by quantifiable notions of correctness demand (the sum of bids for bugs) and correctness potential (the sum of the available profit for fixing those bugs). We then sketch the components of a market design intended to identify bugs, elicit demand for fixing bugs, and source workers for fixing bugs. The ultimate goal is to achieve a more appropriate notion of correctness, in which market forces drive software towards a correctness equilibrium in which all bugs for which there is enough value, and with low enough cost to fix, are fixed.</p>", "authors": [{"name": "David F. Bacon", "author_profile_id": "81100628167", "affiliation": "IBM Research and Harvard University, Hawthorne, MA, USA", "person_id": "P1728358", "email_address": "", "orcid_id": ""}, {"name": "Yiling Chen", "author_profile_id": "81100127631", "affiliation": "Harvard University, Cambridge, MA, USA", "person_id": "P1728359", "email_address": "", "orcid_id": ""}, {"name": "David Parkes", "author_profile_id": "81100009066", "affiliation": "Harvard University, Cambridge, MA, USA", "person_id": "P1728360", "email_address": "", "orcid_id": ""}, {"name": "Malvika Rao", "author_profile_id": "81444594268", "affiliation": "Harvard University, Cambridge, MA, USA", "person_id": "P1728361", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640066", "year": "2009", "article_id": "1640066", "conference": "OOPSLA", "title": "A market-based approach to software evolution", "url": "http://dl.acm.org/citation.cfm?id=1640066"}