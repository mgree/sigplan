{"article_publication_date": "10-25-2009", "fulltext": "\n Versatile Language Semantics with Re.ective Embedding Tom Dinkelaker Technische Universit\u00a8at Darmstadt \nHochschulstr. 10, 64289 Darmstadt, Germany dinkelaker@informatik.tu-darmstadt.de Abstract Often, for \none programming language, various implementa\u00adtions exist that have subtle but important variations in \ntheir syntax and semantics. While current technology provides good support for syntax variability in \nform of syntax ex\u00adtensions, there is only limited support for semantic vari\u00adability in language implementations. \nMy thesis is about a novel approach for adaptable language implementations that uses a meta-object protocol \nto embed language abstractions into the host language and that uses re.ective techniques to adapt the \nlanguage implementation. The techniques devel\u00adoped in my thesis open up several possibilities for adaptation \nin language implementations not addressed by related work. Similarly to the role of a meta-object protocol \nin general\u00adpurpose languages for adapting object-oriented abstractions, the meta-object protocol allows \nto adapt language abstrac\u00adtions of advanced language features, such as the abstractions of aspect-oriented \nprogramming and domain abstractions in domain-speci.c languages. Categories and Subject Descriptors D.3.3 \n[Software En\u00adgineering]: Language Constructs and Features Classes and Objects, Frameworks General Terms \nDesign, Languages Keywords Embedded Domain-Speci.c Languages, Meta-Object Protocols, Aspect-Oriented \nProgramming 1. Motivation Often, for one programming language, various implemen\u00adtations exist that have \nsubtle but important variations in their syntax and semantics. For example, there is a myr\u00adiad of domain-speci.c \nlanguages (DSLs) for state machines, or there are various implementations of the aspect-oriented programming \n(AOP) [5] paradigm for the same base lan- Copyright is held by the author/owner(s). OOPSLA 2009, October \n25 29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10.  guage. Variations in languages exist \nbecause of the diver\u00adsity in applications. Actually in every problem domain or programming paradigm, \nthere can be a dis-consensus on the right syntax and semantics. In traditional language development, \nfor every new syn\u00adtax and semantics, a new language is implemented from scratch resulting in high development \ncosts. Current lan\u00adguage development approaches target to improve these costs, e.g., using extensible \ncompilers or run-times as well as component-based, model-driven, or generative language de\u00advelopment. \nWhile current technology provides good support for syntax variability in form of syntax extensions, there \nis only limited support for semantic variability in language im\u00adplementations. In general, meta protocols \nare not available for most languages, particularly for new languages, such as DSLs. DSLs facilitate writing \nprograms in a certain applica\u00adtion domain by providing direct means to express domain\u00adspeci.c abstractions \nand operations. Although using a DSL results in more declarative code, DSL programs may also suffer from \ntangling and scattering in the presence of domain\u00adspeci.c crosscutting concerns. To improve modularization \nin DSL programs, aspect-oriented features could be used to modularize crosscutting concerns. But, while \nAOP infras\u00adtructures exist for most general-purpose languages, AOP is in general not available for arbitrary \nDSLs, since aspects must be composed in a special way. Embedded domain-speci.c languages [4] have been \npro\u00ad posed to avoid the high development costs for DSLs. Roughly, an embedded language is implemented \nas a library in a host\u00ading language. On the one hand, a new language can be im\u00adplemented without implementing \na new parser and compiler. And on the other hand, the most host language s features are reused for the \nembedded language. Thus, the development cost is signi.cantly reduced and new language features can incrementally \nbe added. While it is commonly agreed that embedded DSLs are the fasted way to implement a DSL, it remains \nan open question whether this approach can be used to embed advanced language features, such as aspects. \nThe motivation of this thesis is to combine the research in embedded DSLs with the research of advanced \nlanguage features, such as re.ective programming [7, 6] and aspect\u00adoriented programming [5]. By using \nre.ective programming in DSLs and aspect-oriented languages, we would like to leverage the same .exibility \nthat is provided by re.ective programming for general-purpose languages to these lan\u00adguages. By using \nDSLs in re.ective programming, we would like to leverage domain-speci.c re.ective languages that al\u00adlow \nmore declarative and therefore allow robust adaptations. In the following, the research hypothesis is \nsummarized in Sec. 2, the plans for an evaluation are presented in Sec. 3, and .nally, Sec. 4 reports \nfuture work. 2. Thesis My thesis is: Adopting re.ective techniques for embedding lan\u00adguages enables languages \nthat are open for syntacti\u00adcal and semantics extensions at the application level, and open for composability. \nMy research combines the approaches of re.ective pro\u00adgramming [7, 6] with embedding languages [4]. The \nap\u00ad proach is therefore called re.ective embedding. The ap\u00adproach uses re.ective features of the host \nlanguage in form of a meta-object protocol (MOP) [6] that is used to enable open syntax, semantics, and \ncompositions of languages. Re\u00ad.ective embedding is demonstrated in the Groovy language, but it could \nalso be implemented in other languages provid\u00ading similar re.ective features, such as Ruby or CLOS. To \nenable an open syntax, re.ective embedding uses the MOP to embed language abstractions into the host \nlanguage. A language is decomposed into language components. A language component consists of (1.) an \ninterface that de.nes syntax abstractions (i.e., the keywords), (2.) an implemen\u00adtation of this interface \nthat binds the syntax abstractions to (3.) a language model that provides the concrete semantics. These \nartifacts are packed together as a library in the host language. In the language components, each of \nthe above three parts can be replaced to adapt the implementation. At runtime, the MOP implicitly maps \nthe language abstractions used in programs to method calls on meta-level classes in the language model. \nTo enable open semantics, re.ective embedding uses re\u00ad.ective features to extend the implementations \nof existing language abstractions for alternative semantics. For exam\u00adple, alternative language semantics \ncan enable an interpre\u00adtation that provides certain guarantees, an optimized execu\u00adtion, or other semantic \nanalyzes of the same program. In a nutshell, re.ection is used to extend the language semantics by overriding \nthe methods that are called on the language model classes for executing the semantics. To enable open \ncompositions, re.ective embedding uses re.ective features to compose several language components. In \na nutshell, extensible composition operators are provided for composing syntax and semantics of language \ncompo\u00adnents as if the composed parts would have been implemented as one language component. Internally, \nin the composition operators, the MOP delegates the usage of a keyword in a program that is given in \nthe composed syntax to the right lan\u00adguage component. Different styles of composition are sup\u00adported. \nA language component can be extended using an in\u00adheritance mechanism. Several components can be composed \nusing black-box composition and gray-box composition. 3. Evaluation For a qualitative evaluation, the \n.exibility of the concept is validated by solving existing problems in four case studies. Case Study \n1: Versatile Semantics for DSLs. The se\u00admantics of a given DSL is subject to evolution and to dis\u00adconsensus \non the right semantics. For example, a state ma\u00adchine can be realized either as a Moore or a Mealy automa\u00adton. \nSimilarly, the execution semantics of UML state ma\u00adchines has several variations [1], such as various \nimplemen\u00ad tation strategies for transition selection and event consump\u00adtion. Despite this, semantics \nvariations in DSL implementa\u00adtions have only been little explored by means of extensible DSL compilers \nand interpreters. The need for supporting application-speci.c semantic variability for DSLs is compa\u00adrable \nto the need for adapting the semantics of a general\u00adpurpose language implementation in a particular application \ntargeted by meta-object protocols [6]. Re.ective embedding enables meta-level architectures for DSLs. \nIn a nutshell, while a language designer imple\u00adments a DSL as a library using re.ective embedding, an\u00adother \nlanguage designer in the user domain can adapt the language implementation using the MOP. The adaptability \nis enabled because the language is embedded in a host lan\u00adguage and the MOP of the host language makes \nthe language abstraction adaptable. We instantiate the approach by build\u00ading a DSL for state machines \nthat supports variations in state machine semantics that have been demanded previously in literature \n[1] but that are currently not supported in related DSL approaches. Case Study 2: Versatile Semantics \nfor AOP. Re.ective embedding can be used to embed abstractions of a program\u00adming paradigm, such as AOP. \nAdditionally when using re\u00ad.ective embedding, the paradigm semantics stays open for extensions. A problem \nwith the existing AOP technology is that alternative semantics for aspect-oriented abstractions can be \nde.ned only by compiler experts using extensible aspect compiler frameworks and infrastructure. Application \ndevelopers are prevented from tailoring the language seman\u00adtics in an application-speci.c manner. To \naddress this problem, in [2], we present a new archi\u00ad tecture for aspect-oriented languages with an explicit \nmeta\u00adinterface to language semantics, called a meta-aspect pro\u00adtocol. We demonstrate the bene.ts of such \na meta-level ar\u00adchitecture for AOP by presenting several scenarios in which programs use the meta-interface \nof the language to tailor its semantics to a particular application execution context. Case Study 3: \nEnabling AOP for DSLs. The re.ec\u00adtive embedding of domain abstractions and programming paradigm abstractions \ncan be combined to improve the mod\u00adularization of crosscutting concerns in DSL programs. Like programs \nwritten in general-purpose languages, programs written in DSLs may also suffer from tangling and scattering \nin the presence of domain-speci.c crosscutting concerns. An open problem is that there is no adequate \ngeneric approach to enable dynamic AOP for DSLs. In [3], we present a framework that supports aspect\u00ad \noriented features for domain-speci.c base languages. We use re.ective techniques to extend the interpretation \nof DSL implementations, such that domain-speci.c join points are intercepted and control is transferred \nto the framework that composes in domain-speci.c aspects. Using this framework to implement domain-speci.c \naspect languages has several advantages. First, the framework facilitates the implementa\u00adtion of new \naspect languages because large parts of aspect\u00adoriented semantics can be reused. Second, both base pro\u00adgrams \nand advice can be written in different DSLs. Third, the framework can compose aspects into DSL programs \neven as late as at runtime. Case Study 4: Domain-speci.c Meta-Protocols. A well\u00adknown critique on meta-object \nprotocols is that they are too powerful in that they allow to perform program and language adaptations \nthat may result in incorrect programs. To address this problem, we propose to use domain\u00adspeci.c abstractions \non top of meta-protocols. Instead of using the full power of the protocol, the programmer uses a domain-speci.c \nlanguage to specify adaptations on a more abstract level. These abstract adaptation speci.cation is then \nactually performed through the implementation of that domain-speci.c language. This DSL internally calls \nthe underlying meta-protocol that then performs the more technical operations. Because of that abstract \nspeci.cation and because the speci.cation can be analyzed in the DSL implementation before actually executing \nthe adaptation, the obtained domain-speci.c meta-protocol allows to de\u00advelop more robust adaptations. \nWe have instantiated a sim\u00adple domain-speci.c language for specifying the detection and resolution of \naspect interactions that is implemented on top of our meta-aspect protocol. For a quantitative evaluation, \nthe plan is to evaluate the development and the runtime costs of re.ective embedding. Development Costs. \nThe plan is to measure the costs for implementing new languages and compare them to the costs of traditional \nstand-alone implementations. For evaluating the approach s quality for developing DSLs, we are devel\u00adoping \nan open source project that develops the same DSL (for implementing state machines) using different traditional \nimplementation technologies, and we compare the qualities of the obtained language implementations with \nthe one ob\u00adtained using our approach. For evaluating the approach s quality for developing new aspect-oriented \nlanguages, we will measure the development costs of implementing exist\u00ading domain-speci.c aspect languages, \nsuch as COOL and RIDL, and compare them to the costs of implementing the languages from scratch. Besides \ngeneral metrics, such as lines of code, the reuse when growing a DSL implementa\u00adtion is measured, e.g., \nwhen incrementally adding new do\u00admain abstractions or when reusing aspect-oriented features from the \nAOP framework and comparing it to what it would cost for a stand-alone implementation. Runtime Costs. \nThe runtime costs of the DSLs in the case studies are measured using benchmarks and compared with related \nimplementations. For DSLs without aspect-oriented features, as for DSLs in general no adequate benchmarks \nare available, new benchmarks will be designed to measure the runtime overhead imposed by the indirections \nnecessary for enabling versatile language semantics by comparing execu\u00adtion time to stand-alone DSLs. \nFor measuring the overhead imposed by the meta-aspect protocol, the execution times will be compared \nto the ones of existing aspect-oriented compilers and run-times without versatile AOP semantics. For \nDSLs with aspect-oriented features, we will compare to existing domain-speci.c aspect language implementations. \n4. Future Work Currently, we are comparing re.ective embedding to other language implementation techniques, \nsuch as other embed\u00adding approaches, component-oriented language implemen\u00adtations, and monads. Improving \nperformance by using a spe\u00adcialized meta-object protocol is future work. References [1] F. Chauvel and \nJ.-M. J\u00b4ez\u00b4equel. Code Generation from UML Models with Semantic Variations Points. In UML MoDELs, volume \n3713 of LNCS, 2005. [2] T. Dinkelaker, M. Mezini, and C. Bockisch. The Art of the Meta-Aspect Protocol. \nIn International Conference on Aspect-Oriented Software Development (AOSD.09), 2009. [3] T. Dinkelaker, \nM. Monperrus, and M. Mezini. Untangling Crosscutting Concerns in Domain-speci.c Languages with Domain-speci.c \nJoin Points. In Workshop on Domain-speci.c Aspect Languages (co-located with AOSD), 2009. [4] P. Hudak. \nModular Domain Speci.c Languages and Tools. In P. Devanbu and J. Poulin, editors, International Conference \non Software Reuse, pages 134 142. IEEE Press, 1998. [5] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda, \nC. Lopes, J. Loingtier, and J. Irwin. Aspect-Oriented Programming. In ECOOP, pages 220 242, 1997. [6] \nG. Kiczales, J. d. Rivi` eres, and D. G. Bobrow. The Art of the Metaobject Protocol. MIT Press, Cambridge, \nMA, 1991. [7] P. Maes. Computational Re.ection. PhD thesis, Vrije Universiteit Brussel, 1987.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Often, for one programming language, various implementations exist that have subtle but important variations in their syntax and semantics. While current technology provides good support for syntax variability in form of syntax extensions, there is only limited support for semantic variability in language implementations. My thesis is about a novel approach for adaptable language implementations that uses a meta-object protocol to embed language abstractions into the host language and that uses reflective techniques to adapt the language implementation. The techniques developed in my thesis open up several possibilities for adaptation in language implementations not addressed by related work. Similarly to the role of a meta-object protocol in general-purpose languages for adapting object-oriented abstractions, the meta-object protocol allows to adapt language abstractions of advanced language features, such as the abstractions of aspect-oriented programming and domain abstractions in domain-specific languages.</p>", "authors": [{"name": "Tom Dinkelaker", "author_profile_id": "81100381772", "affiliation": "Technische Universit&#228;t Darmstadt, Darmstadt, Germany", "person_id": "P1728676", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640034", "year": "2009", "article_id": "1640034", "conference": "OOPSLA", "title": "Versatile language semantics with reflective embedding", "url": "http://dl.acm.org/citation.cfm?id=1640034"}