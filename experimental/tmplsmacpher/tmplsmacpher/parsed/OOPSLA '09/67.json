{"article_publication_date": "10-25-2009", "fulltext": "\n ORTS: A Tool for Optimized Regression Testing Selection Sheng Huang, Jun Zhu, Yuan Ni IBM China Research \nLab, Pudong New District Shanghai 201203, China {huangssh, zhujun, niyuan}@cn.ibm.com Abstract This \npaper presents ORTS, a tool for facilitating testers to gener\u00adate optimized regression test suite for \ncommercial Java applica\u00adtions. The aspects emphasized by the demonstration are: (1) how to help testers \ncapture runtime traces of test execution; (2) how to identify change points during the build update; \n(3) how does ORTS improve the efficiency of the regression testing and reduce the cost by generating \noptimized regression test suite. The whole design strategy is lightweight, making the regression test \nselection process more automated and effective, and scalable to commercial regression testing scenarios \nwith resource and time constraints. Categories and Subject Descriptors D.2.5 [SOFTWARE ENGINEERING]: \nTesting and Debugging Testing tools. General Terms Verification. 1. Introduction Regression testing \nis the process of validating the modified soft\u00adware to provide the confidence that the changed parts \nof the soft\u00adware behave as intended and the unchanged parts of the software have not been adversely affected \nby modifications [1]. A variety of strategies [2] have been proposed to select a subset of regres\u00adsion \ntests for execution to verify the modified program in aca\u00addemic research. However, most of these test \nselection approaches are source code based. For a large commercial system, it is hard to build the data \nflow or control flow required in these approaches [2]. In addition, only considering the changes in programming \nlanguage level is not enough in large commercial systems. To the best of our knowledge, ORTS is the first \ntool that targets at re\u00adgression testing selection for commercial Java applications. ORTS pursues the \nfollowing three unique features which are not well addressed by existing approaches, but required in \nregression scenarios of commercial Java applications. Feature 1: Scalable runtime profiling. We have \ndone a sur\u00advey on current commercial Java applications, and it shows that most of them are Web applications. \nExisting regression tools for java application such as Contest [4] lack of support to popular IT artifacts \nused in Java Web Applications such as JavaScript (JS), JSP. ORTS has the capability of capturing Java \nmethod invoca\u00adtions, JavaScript method invocations and JSP loading events. In this manner, ORTS guarantees \nthat no IT artifact traversed during Copyright is held by the author/owner(s). OOPSLA 2009, October 25-29, \n2009, Orlando, FL, USA. ACM 978-1-60558-768-4/09/10. 10. the execution is missed. In addition, the run \ntime profiling incurs little overhead to test execution. Therefore, ORTS is scalable for runtime profiling \nof commercial Java applications. Feature 2: Build Oriented change identification. Current test\u00ading services \nare likely to be distributed in different regions as the testing team is separated. The testing team \nalways has no access to source codes. An alternative solution by decompiling binary files [3] is proposed, \nbut it is illegal. In ORTS the change points are derived by analyzing the builds (EAR/WAR/JAR) of two \nversions. Besides the logic changes caused by modifications to Java/JS/JSP, the configuration level changes, \nsuch as frameworks for Inverse of Control, Data Access Object, etc, are also taken into consideration. \nThis feature gives ORTS the ability of identi\u00adfying complete change points of commercial Java applications. \nFeature 3: Optimized regression test suite. Similar to the safe regression strategy in [2], only test \ncases traversing change points would be selected out in ORTS, consequently lots of unnecessary test cases \nwould be avoided. Even in this way, the test suite size may still exceed the deliver pressure. To address \nthis problem, ORTS prioritizes the regression test suite in terms of risk and guides the rerun schedule \nunder the time pressure. In the next section, we provide an overview of ORTS by de\u00adscribing main components \nand demonstrate how the above three features are addressed in the design and implementation of ORTS. \nAn effectiveness evaluation is presented in Section 3. Section 4 describes the demonstration plan.  \n2. Overview of ORTS As illustrated in Fig. 1, the ORTS tool consists of two main com\u00adponents: ORTS Agent \nand ORTS Server. The testers could login to ORTS Server from the Web to consume the testing service. \nORTS Agent needs to be downloaded from ORTS Website and executed with target applications for test profiling. \nHow to enable scalable profiling? The Weaver of ORTS Agent is used to run static instrumentation to the \ntargeted applica\u00adtions. The Weaver utilizes AspectJ [5] to instrument binary java code and executes a \ncustomized Ajax like instrumentation over Figure 1. Tool overview  JSP/JS to collect JSP loading events \nand JS method invocations. With the lightweight instrumentation approaches, the Profiler could profile \napplications without incurring obvious latency proved by pilot evidence. After test execution, the Profiling \nmod\u00adule would upload profiling data of tests to ORTS Server through the Web. How to enable build oriented \nchange identification? After extracting IT artifacts from the build, the Language Change Ana\u00adlyzer extracts \nthe Java method changes by analyzing binary Java class directly and runs a syntax analysis to identify \nmethod level changes of JS and page level changes of JSP. Furthermore, the Framework Change Analyzer \nparses the entire configuration files in the build such as configurations of spring, struts, ibatis, \netc., and maps these configuration changes to Java/JS/JSP changes which are linked to the test case profiling \ndata. How to generate optimized regression suite? Firstly, the Corrlator derives all the test cases traversing \nchange points and passes them to Risk Calculator. Secondly, the Risk Calculator utilizes a normalized \nmetrics of integrated factors to measure the risk of test cases. The integrated factors include the number \nof change point excised by a test case, the change types of test cases, the invocation counts of change \npoints per test case, the count of IT artifacts traversed by a test case, bug history of test cases, \nand business value. Finally, the Regression Test Group Generator utilizes a greedy algorithm to generate \na series of test groups. Each group covers all the change points. The groups are ranked by normalized \nrisk metrics. In addition, as the time consuming of test execution in previous version gives accurate \nrerun time esti\u00admation, tester could select Top-K test groups to cover the most risky test cases within \nlimited time.  3. Efficiency Evaluation The tool has been piloted over an IBM internal project to select \nregression test suite during version iteration. Meanwhile, the test\u00aders identify changes and select regression \ntest suite manually. As illustrated in Fig. 2, both approaches could identify 100% change points, while \nORTS is more accurate in locating the change im\u00adpacted files since updates causing no syntax differences \nconsid\u00adered in manual approach are ignored in ORTS. Compared with 113 test cases selected by testers, \nonly 21 test cases are selected out by ORTS to rerun. Both approaches could reveal 5 defects. Based on \nthe IBM best practice, one experienced tester could select out 20 test cases per day or execute 8 test \ncases per day, 5.5 person days (PD) are needed for test selection, and 14 PD are needed for test execution \nin manual approach. On the other hand, test selection process of ORTS only takes several minutes, and \nonly 2.5 PD is required to run the test suite. Consequently, ORTS could significantly cut 85% cost by \nsaving 17 PDs.   4. Demonstration The goal of demonstration. Through the demo, we plan to show the \nfollowing three aspects of ORTS. For a commercial java ap\u00adplications : (1) how to help testers capture \nruntime traces of test execution;(2) how to identify change points during build up\u00addate;(3) how does \nuser improve the regression testing efficiency by running regression test suite generated by ORTS. Figure \n3 Regression process in ORTS The way of demonstration. In the demonstration session, we plan to let participants \ninteract with the tool directly, especially experience the regression process in ORTS as illustrated \nin Fig. 3. A sample commercial Java Web Application Scenario will be provided and deployed on the demo \nclient computer. Some bugs are reported from customer after version 3 is delivered, expected to be resolved \nin one week. The testing team gets a new build v4 (Claimed to have fixed the bugs in v3) from the develop \nteam. The build is about 24M, including 156 JSP files, 89 JS files, 369 Java files and 74 JARs. The demonstration \nmainly includes the following steps: First of all, with the help of regression wizard, we would like \nto let participants upload builds of v3 and v4 to ORTS and run build change identification. A report \nshowing the change points of Java/JS/JSP and frameworks from v3 to v4 would be generated only in several \nminutes. In the next step, the participants could generate the regression plan automatically. Only 10% \nof test cases need to be rerun to check if the changes have caused adversely impact. Finally, the participants \nwould be motivated to act as testers to rerun the test cases with and without the monitoring of ORTS \nagent. We would demonstrate that no obvious latency occurs under monitoring mode and various IT artifacts \ntraversed are captured, including JS/JSP/JAVA codes. Besides, we hope to discuss with participants to \nsee how the regression process should be improved and what additional fea\u00adtures are needed in ORTS to \nrefine the design and implementa\u00adtion.  References [1] M. J. Harrold, J. A. Jones, T. Li, D. Liang, \nA. Orso, M. Pennings, S. Sinha, S. A. Spoon, and A. Gujarathi. Regression test selection for java software. \nIn Proceedings of 16th OOPSLA, 2001, 312-326. [2] G. Rothermel and M. J. Harrold. Analyzing regression \ntest selection techniques. Software Engineering, IEEE Transactions on Volume 22, Issue 8, 1996 , 529-551. \n[3] J. Zheng, B. Robinson, L. Williams, and K. Smiley. Applying Re\u00adgression Test Selection for COTS-based \nApplications. In Proceedings of 28th ICSE, 2006, 512-521. [4] http://www.alphaworks.ibm.com/tech/contest \n[5] http://www.eclipse.org/aspectj  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>This paper presents ORTS, a tool for facilitating testers to generate optimized regression test suite for commercial Java applications. The aspects emphasized by the demonstration are: (1) how to help testers capture runtime traces of test execution; (2) how to identify change points during the build update; (3) how does ORTS improve the efficiency of the regression testing and reduce the cost by generating optimized regression test suite. The whole design strategy is lightweight, making the regression test selection process more automated and effective, and scalable to commercial regression testing scenarios with resource and time constraints.</p>", "authors": [{"name": "Sheng Huang", "author_profile_id": "81452601009", "affiliation": "IBM China Research Lab, Shanghai, China", "person_id": "P1728639", "email_address": "", "orcid_id": ""}, {"name": "Jun Zhu", "author_profile_id": "81452604273", "affiliation": "IBM China Research Lab, Shanghai, China", "person_id": "P1728640", "email_address": "", "orcid_id": ""}, {"name": "Yuan Ni", "author_profile_id": "81541759656", "affiliation": "IBM China Research Lab, Shanghai, China", "person_id": "P1728641", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640023", "year": "2009", "article_id": "1640023", "conference": "OOPSLA", "title": "ORTS: a tool for optimized regression testing selection", "url": "http://dl.acm.org/citation.cfm?id=1640023"}