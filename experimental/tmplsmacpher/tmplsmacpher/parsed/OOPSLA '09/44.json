{"article_publication_date": "10-25-2009", "fulltext": "\n MiningScenario-BasedSpeci.cationswithValue-BasedInvariants David Lo Shahar Maoz School of Information \nSystems Dept. of Computer Science and Applied Mathematics Singapore Management University The Weizmann \nInstitute of Science, Israel davidlo@smu.edu.sg shahar.maoz@weizmann.ac.il Abstract There have been \na number of studies on mining candidate speci.cations from execution traces. Some extract speci.\u00adcations \ncorresponding to value-based invariants, while oth\u00aders work on inferring ordering constraints. In this \nwork, we merge our previous work on mining scenario-based speci\u00ad.cations, extracting ordering constraints \nin the form of live sequence charts (LSC), a visual speci.cation language, with Daikon, a tool for mining \nvalue-based invariants. The result\u00ading approach strengthens the expressive power of the mined scenarios \nby enriching them with scenario-speci.c value\u00adbased invariants. The concept is illustrated using a prelimi\u00adnary \ncase study on a real application. Categories and Subject DescriptorsD.ngineering]:Dis- 2.7[SoftwareEtribution, \nMaintenance, and Enhancement Reverse Engineering; D.2.1 [Software Engineering]: Speci.cations General \nTerms Algorithm,Design,Docum sentation  1. Introduction A speci.cation usually imposes constraints both \non sequenc\u00ading of method calls or statement executions (ordering con\u00adstraints), and on the values that \na method parameters or some variables at a program point could have (value constraints). One tells a \nseparate picture from the other, and each indepen\u00addently, although interesting, might not be able to \npresent the full picture on the requirements that a system should follow. Motivated by the lack of documented \nspeci.cations, re\u00adcently a number of studies have investigated mining of spec\u00adi.cations from program \nexecutions. One pioneering work, Daikon, mines for value-based invariants that hold at speci\u00ad.ed program \npoints [3]. Recently, we have investigated min\u00ading an expressive visual sequence-diagram-like scenario\u00adbased \nspeci.cation in the form of live sequence charts (LSC) using a data mining approach [6]. However, [6] \nhas only Copyright is held by the author/owner(s). OOPSLA 2009, October 25 29, 2009, Orlando, Florida, \nUSA. ACM 978-1-60558-768-4/09/10. considered ordering constraints among method calls. In this work, \nwe merge the two approaches. The resulting approach strengthens the expressive power of the mined scenarios \nby enriching them with value-based invariants. We are interested in universal live sequence charts (LSC) \n[2, 4], which are sequence diagrams divided into pre-chart (whose events are drawn with blue, dashed \nlines) and main\u00adchart (red, solid lines). An LSC speci.es a universal re\u00adquirement: whenever the events \nin the pre-chart occur in the speci.ed order, eventually the events in the main-chart must occur in the \nspeci.ed order. The semantics of LSC is de\u00ad.ned in [2, 4]. In scenario-based speci.cation mining [6], \nwe are interested in mining statistically signi.cant LSCs, ones which occur frequently in the trace and \nwhose pre-is fol\u00adlowed by the main-chart with high likelihood. Fig. 1(left) shows an example LSC; the \nblue segment corresponds to the pre-chart, while the red segment corre\u00adsponds to the main-chart. A chart \nconsists of lifelines, de\u00adnoting objects participating in a scenario, and messages, cor\u00adresponding to \nmethod invocations. The example LSC states that whenever the RootPanel calls the start() method of FTPServer, \neventually, the FTPServer will call the updateStatus() method of RootPanel and RootPanel will call the \nstop() method of FTPServer. In Fig. 1(right), we have guards on the executions of method calls repre\u00adsented \nas conditions on the messages between lifelines. While the previous work in [6] has mined for the order\u00ading \nconstraints, it is not able to mine for the value-based invariants and add them to the mined scenario. \nThis is the challenge addressed in our present work. In this abstract we omit formal de.nitions and summarize \ntechnical details.  2. MiningFramework Mining for LSCs with value-based invariants serving as guards \nconsists of the following 4-steps process: 1. Mine LSCs without value-based invariants using the technique \nin [6]1 2. For each mined LSC, slice the trace considering only the events involved in the witnesses \nof the scenarios corresponding to a selected mined LSC.  1 In this study, for simplicity, we remove \nobject identities from the traces. Interested readers could note the discussion in [5, 6].  3. Provide \nthe sliced traces to Daikon and let it search for value-based invariants. 4. Merge the mined Daikon \ninvariants with the corre\u00adsponding LSC, attaching them as guards to the meth\u00adods between the lifelines. \n The .rst step above mines for signi.cant LSCs in the ex\u00adecution traces. An LSC is considered signi.cant \nif its in\u00adstances appear more than a minimum number of times and the pre-chart is followed by the main-chart \nwith a high likeli\u00adhood. We borrow the terms support and con.dence from data mining to indicate the number \nof times an LSC instance ap\u00adpears in the trace and the proportion of pre-charts followed by main-charts. \nThe user speci.es minimum threshold pa\u00adrameters for support and con.dence to determine whether a chart \nis detected as signi.cant or not. Each LSC induces a set of witnesses, namely segments of the trace where \nthe LSC is satis.ed. To extract for value\u00adbased invariants pertaining to a speci.c scenario we slice \nthe trace so as to consider only the events that are part of these witnesses trace segments. The sliced \ntraces are fed to the next step for Daikon to mine for value-based invariants. In the third step, Daikon \nwould consider various val\u00adues that hold at a set of program points (in particular, we consider method \nentries and exits) and then compute likely invariants by generalizing the values that it sees for each \nprogram point under consideration. Note that for scenario\u00adspeci.c invariants, we are not interested in \ninvariants that hold across the entire execution of a program. Instead, we are interested in properties \nthat hold in the context of a par\u00adticular scenario under consideration, in all its instances. For example, \nin an application the same set of methods could be used for various scenarios, however the value-based \nin\u00advariants that hold at each of the separate scenarios could be different. By slicing the input traces \naccording to the scenar\u00adios, we are able to instruct Daikon to only mine for scenario\u00adspeci.c value-based \ninvariants. In the .nal step, we merge the scenario under considera\u00adtion with the mined scenario-speci.c \nvalue-based invariants, resulting in a more expressive mined speci.cation: LSCs with guards capturing \nboth ordering and value-based con\u00adstraints. The mined speci.cations could be presented visu\u00adally to the \nuser, converted to runtime monitors [8], used for veri.cation, etc.  3. PreliminaryExperiments We experimented \nwith crossFTP [1], in particular methods from the RootPanel and FTPServer classes. CrossFTP is a commercial \nopen source FTP server built on top of Apache FTP server spanning 18841 LOC. A mined LSC without value-based \ninvariants is shown in Fig. 1 (left). This LSC was enriched with value-based invariants mined via Daikon \nafter trace slicing, to form the LSC shown in Fig. 1 (right). Note the constraints in the enriched LSC. \nFor example, the runner and serverSocket attributes of FTPServer are always null before start() method \nis called. Also, after method stop() is called, the runner and serverSocket are always null. Other invariants \nstate that some instance variables are unchanged by the method call. For example, ftpConfig == orig states \nthat the value of the variable ftpConfig is the same before and after the call to start(). These invariants \nhold in the context of the mined scenario, but do not necessarily hold when the same methods are used \nin other contexts. 4. Discussion&#38;FutureWork Lorenzoli et al. merge a technique to mine an automaton \nmodel with value-based invariants from Daikon [7]. Differ\u00adent from their work, we infer scenario-based \nspeci.cations with value-based invariants. The automaton model mined in [7] reports the overall model \nunder consideration, while our mined scenarios report strongly observed scenario-based invariants. The \nscenarios specify not only method call signa\u00adtures but also their caller and callee information and come \nwith a universal interpretation rather than a weaker existen\u00adtial interpretation. We have experimented \nmining of LSCs with value-based invariants on a preliminary case study. Planned future work includes \nfurther evaluation using additional case studies.  References [1] CrossFTPServer. sourceforge.net/projects/crossftpserver/. \n[2] W. Damm and D. Harel. LSCs: Breathing Life into Message Sequence Charts. J. on Formal Methods in \nSystem Design, 19(1):45 80, 2001. [3] M. Ernst, J. Cockrell, W. Griswold, and D. Notkin. Dynamically \ndiscovering likely program invariants to support program evolution. TSE, 27(2):99 123, 2001. [4] D. \nHarel and S. Maoz. Assert and Negate Revisited: Modal Semantics for UML Sequence Diagrams. Software and \nSystems Modeling, 7(2):237 252, 2008. [5] D. Lo and S. Maoz. Mining Symbolic Scenario-Based Speci.cations. \nIn PASTE, 2008. [6] D. Lo, S. Maoz, and S.-C. Khoo. Mining Modal Scenario-Based Speci.cations from Execution \nTraces of Reactive Systems. In ASE 07, 2007. [7] D. Lorenzoli, L. Mariani, and M. Pezz`e. Automatic Generation \nof Software Behavioral Models. In ICSE, 2008.   \n\t\t\t", "proc_id": "1639950", "abstract": "<p>There have been a number of studies on mining candidate specifications from execution traces. Some extract specifications corresponding to value-based invariants, while others work on inferring ordering constraints. In this work, we merge our previous work on mining scenario-based specifications, extracting ordering constraints in the form of live sequence charts (LSC), a visual specification language, with Daikon, a tool for mining value-based invariants. The resulting approach strengthens the expressive power of the mined scenarios by enriching them with scenario-specific value-based invariants. The concept is illustrated using a preliminary case study on a real application.</p>", "authors": [{"name": "David Lo", "author_profile_id": "81452603381", "affiliation": "School of Information Systems, Singapore Management University, Singapore, Singapore", "person_id": "P1728562", "email_address": "", "orcid_id": ""}, {"name": "Shahar Maoz", "author_profile_id": "81320492363", "affiliation": "The Weizmann Institute of Science, Rehovot, Israel", "person_id": "P1728563", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1639999", "year": "2009", "article_id": "1639999", "conference": "OOPSLA", "title": "Mining scenario-based specifications with value-based invariants", "url": "http://dl.acm.org/citation.cfm?id=1639999"}