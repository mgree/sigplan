{"article_publication_date": "10-25-2009", "fulltext": "\n Centralizing Clone Group Representation and Maintenance Robert Tairas Department of Computer and Information \nSciences University of Alabama at Birmingham Birmingham, AL 35294 tairasr@cis.uab.edu Abstract This \nposter describes contributions to improve clone group representation and maintenance tasks. Centralizing \nthe representation of clones enables displaying their properties without the need to look at individual \ninstances. Centralizing their maintenance enables removal to be performed simultaneously. The benefits \nof centralizing clone groups are demonstrated in an Eclipse plug-in. Categories and Subject Descriptors \nD.2.7 [Software Engineering]: Distribution, Maintenance, and Enhancement restructuring, reverse engineering, \nand reengineering. General Terms Management, Languages. Keywords Code clones, analysis, refactoring, \nmaintenance 1. Motivation The detection of code clones, which represent duplicated sections of code, \ncan be assisted by the utilization of automated clone detection tools. Using various detection techniques, \nthese tools provide in some form the location of each clone and a grouping of clones representing the \nsame duplicated code (i.e., clone groups). A programmer can evaluate each clone in the group by observing \ndirectly the actual sections of code that represent the clones. However, in some instances, the clones \ncan be scattered in several files and opening each file containing the clones can clutter the view of \nthe code in an IDE, decreasing the ability to understand the connections within a clone group. This motivates \nthe need to provide a centralized representation of the clones that displays the properties of each clone \nand the relationships among them. After the clones have been detected and presented to the programmer \nin some form, a subsequent step is to determine what to do with the clones. One possibility is to remove \nthe duplication associated with the clones through refactoring activities. For example, the duplication \ncan be eliminated in some cases by moving one copy of the duplicated code into a new method and replacing \neach clone instance with a call to the new method (i.e., Extract Method refactoring). IDEs such as Eclipse \nprovide refactoring support, although the refactoring of all clones at once is still limited. This motivates \nthe need to extend the refactoring capabilities of Eclipse to provide a refactoring mechanism where clones \nare maintained together in a centralized process. Copyright is held by the author/owner(s). OOPSLA 2009, \nOctober 25-29, 2009, Orlando, FL, USA. ACM 978-1-60558-768-4/09/10. This poster describes two benefits \nthat result from clone group centralization as implemented in an Eclipse plug-in called CeDAR (Clone \nDetection, Analysis, and Refactoring). A representation of a clone group (where the information about \neach clone in the clone group can be viewed in one location) is described in Section 2. In addition, \nan effort to extend the refactoring capabilities of Eclipse to allow simultaneous refactoring of a group \nof clones is described in Section 3. The remaining sections summarize related work, provide a conclusion, \nand outline future work.  2. Clone Group Representation In order to provide a centralized representation \nof the clones in a clone group, the code associated with one of the clones is used to display information \nregarding all the clones in the group. That is, the code related to one clone is highlighted in its original \nlocation in the IDE editor and the differences and implicit similarities among the clones within a clone \ngroup are displayed. Figure 1 provides a sample view of a centralized clone group representation for \na code fragment in the clones. Figure 1. Sample code fragment display The elements of the code that \ndiffer are called the parameterized elements of the clones. These are highlighted in Figure 1 in the \ndeclaration for variable message. Clones containing parameterized elements represent clones that are \nsyntactically identical but differ in identifier values [2]. Most clone detection tools allow the detection \nof such clones in addition to exact matching clones. One reason for the existence of parameterized clones \noccurs when a section of code is copied and pasted into another location of the program and some attributes \n(e.g., variable names) are renamed. However, variable renaming is just one example of differing values \namong clones. The clone group representation, as implemented in CeDAR, displays differing values above \nthe highlighted section of code. For example, in Figure 1 the variable file and the string Unable to \ndelete file differ among the clones and are highlighted. In addition, the differing values are conveniently \ndisplayed above the highlighted section of code when it is moused over. In the figure, Clone 4 contains \na different string value, which also implies that Clones 1-3 contain the same value as that presented \nin the code.  The rest of the section outlines the technique used to determine the parameterized elements \namong the clones in a clone group and some benefits of this centralized representation of clones. Detecting \nparameterized elements The input for CeDAR does not rely on a specific clone detection tool, because \nit can parse the output of several tools to obtain the two main outputs of clone location and clone grouping. \nAfter the clone information has been parsed from the results of a selected clone detection tool, the \ncode associated with the clones is converted into the corresponding abstract syntax tree (AST) representation \nfor further analysis. In order to identify the parameterized elements of the clones, comparisons are \nmade on the AST representation of each clone. One of the clones in the group is used as the default clone \nto be compared with the other remaining clones. This is the same clone whose corresponding section of \ncode is used to display the clone group representation. The first clone listed in the clone group is \ninitially used as the default clone, but the user is allowed to change this to any of the other clones. \nThe comparisons of the AST representation start with the top\u00adlevel node representing the syntactic block \nof the clones and utilize the Eclipse JDT s AST sub-tree matcher. The matcher is customized to allow \ncertain nodes to differ corresponding to the parameterized elements of the clones. The matcher can identify \ndiffering variable names and string literals as seen in Figure 1. It can also identify situations where \nin one clone a simple variable is used and in another clone a method call is used instead. Benefits \nof centralized representation The representation of clones in a clone group in one location allows the \nprogrammer to learn about the clones without the need to open every occurrence of the clone in the file \nor application classes. In addition, as it relates to the task of removing the duplication associated \nwith the clones, the clone group representation provides a quick summary of which parts of the clones \ndiffer. This knowledge is useful in the refactoring process of clone removal as the complexity of the \nclones can be observed in the single representation. For example, clones containing only renamed local \nvariable names can be considered easier to refactor. Moreover, the technique of detecting the parameterized \nelements in the clones can be utilized in the actual refactoring process, as described in the next section. \n  3. Clone Group Maintenance After clones are detected, some clones can be considered for removal. Refactoring \nprovides a set of code manipulation procedures that can remove the duplication associated with clones. \nIDEs such as Eclipse provide mechanisms to perform refactoring, but support for refactoring all clones \nat once is still limited. For example, Eclipse can detect duplicated sections of code in a single class \nand remove them using Extract Method, but only clones containing renamed variables are supported. The \ntechnique described in this section extends the refactoring capabilities of Eclipse to allow for more \ntypes of parameterized clones to be refactored simultaneously and in a more centralized manner. The first \nextension is the use of the results from a clone detection tool as a replacement of the current feature \nthat identifies clones containing only renamed variables. The complexity of refactoring the clones is \nhigher when the clones contain more than just renamed variables, as other parameterized elements in the \nclones must be taken into account. For example, in the case of Extract Method, both the renamed variable \nand the value of the string in Figure 1 must be passed as parameters into a newly created method containing \nthe duplicated code. The second extension is the utilization of the detection of parameterized elements \ndescribed in Section 2.1 to determine elements of the code that must be passed into the newly created \nmethod that represents the duplicated code. 4. Related Work The clone detection tool CloneDR [1] provides \nwhat is called Clone Abstraction, which lists the parameterized elements associated to a group of clones. \nHowever, this feature is only available for the tool itself, whereas CeDAR can parse detection results \nfrom several tools. My previous work investigated the ability of representing associated clones through \na domain\u00adspecific language (DSL) [4]. The DSL representation allowed the representation of all the clones \nin a clone group using models. However, this work assumes that the determination of the parameterized \nelements is already provided. In [3], the task of clone removal is considered, but it is not associated \nwith an IDE and hence would not be able to utilize the refactoring engine infrastructure to accommodate \nrelated refactoring procedures other than Extract Method. 5. Conclusion and Future Work This poster \ndescribes techniques to present and maintain clones in a more centralized manner. The clone group representation \nallows the display of clone properties for all the clones in a clone group on just one clone instance. \nThe extension of the Eclipse refactoring feature allows the maintenance of all clones to be performed \nin one unified process. Future work on the clone group representation includes recognition of more differences \nbetween the elements of the code associated with the clones. In terms of maintenance, support for more \ntypes of clone-related refactorings will be included.  Acknowledgement This material is based upon \nwork supported by the National Science Foundation under Grant No. 0702764.  References [1] Baxter, I., \nYahin, A., Moura, L., Sant'Anna, M., and Bier, L. Clone Detection using Abstract Syntax Trees. In Proc. \nOf Int. Conf. on Software Maintenance, Bethesda, MD, Nov. 1998, pp. 368-377. [2] Bellon, S., Koschke, \nR., Antoniol, G., Krinke, J., and Merlo, E. Comparison and Evaluation of Clone Detection Tools. Transactions \non Software Engineering, vol. 33, no. 9, Sep. 2007, pp. 577-591. [3] Juillerat, N. and Hirsbrunner, B. \nAn Algorithm for Detecting and Removing Clones in Java Code. Workshop on Software Evolution through Transformations, \nNatal, Brazil, Sep. 2006, pp. 63-74. [4] Tairas, R., Liu, S., Jouault, F., and Gray, J. CoCloRep: A DSL \nfor Code Clones. In Proc. of Int. Workshop on Software Language Engineering, Nashville, TN, Oct. 2007, \npp. 91-99.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>This poster describes contributions to improve clone group representation and maintenance tasks. Centralizing the representation of clones enables displaying their properties without the need to look at individual instances. Centralizing their maintenance enables removal to be performed simultaneously. The benefits of centralizing clone groups are demonstrated in an Eclipse plug-in.</p>", "authors": [{"name": "Robert Tairas", "author_profile_id": "81319502795", "affiliation": "University of Alabama at Birmingham, Birmingham, AL, USA", "person_id": "P1728596", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640012", "year": "2009", "article_id": "1640012", "conference": "OOPSLA", "title": "Centralizing clone group representation and maintenance", "url": "http://dl.acm.org/citation.cfm?id=1640012"}