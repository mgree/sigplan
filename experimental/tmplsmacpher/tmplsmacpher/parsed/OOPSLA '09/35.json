{"article_publication_date": "10-25-2009", "fulltext": "\n Modular Typestate Checking in Concurrent Java Programs Nels E. Beckman Institute for Software Research \nSchool of Computer Science Carnegie Mellon University  nbeckman@cs.cmu.edu Abstract In previous work \n[2] we described a modular static analysis based on access permission annotations, which describe the \nways in which a reference can be aliased, for preventing the improper use of object protocols in concurrent \nprograms. That system was based on atomic blocks, a mutual exclusion primitive not yet in wide use. Now \nwe extend that system to programs written using synchronized blocks, which are in wide use today. This \nsystem can verify con\u00adcurrent programs without any concurrency-speci.c annotations. Categories and Subject \nDescriptors D.1.3 [Concurrent Pro\u00adgramming]; F.3.1 [Specifying and Verifying and Reasoning about Programs]: \nMechanical veri.cation General Terms Veri.cation Keywords Java, concurrency, typestate, static analysis \n1. Introduction and Motivation This work describes an approach for verifying that object proto\u00adcols are \nobeyed in concurrent, object-oriented programs that use synchronized blocks as a means of mutual exclusion. \nMany APIs de.ne object protocols, which are rules about the order in which methods can be called. Much \nrecent work has focused on check\u00ading, either statically or dynamically, that clients are using these \nobject protocols correctly. (Static protocol checking is also known as typestate checking.) While most \nof this work has focused on single-threaded programs, object protocols also exist in concurrent programs. \nIn recent work we developed a modular static analysis for Java for ensuring that object protocols were \nused correctly even in the face of concurrent modi.cation by multiple threads [2]. One limi\u00adtation of \nthis work was its assumption that atomic blocks would be used as the mutual exclusion primitive. Atomic \nblocks are a mu\u00adtual exclusion primitive provided by transactional memory systems that, while showing \nmuch promise, are not currently in wide use. Currently, using our analysis on code that uses other forms \nof mu\u00adtual exclusion will result in false positives, as our analysis will as\u00adsume that mutual exclusion \ndoes not exist. Therefore we have extended our approach to work with pro\u00adgrams that use synchronized \nblocks as the primary means of mutual Copyright is held by the author/owner(s). OOPSLA 2009, October \n25 29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10. exclusion. While our approach does \nin some ways limit the .exi\u00adbility of the locking discipline allowed, in return it does not require any \nadditional annotations describing synchronization procedure.  2. Approach Our approach is similar to \nour earlier work in that we require pro\u00adgrammers to annotate methods with pre-and post-conditions as \nwell as access permissions, static typing annotations which de\u00adscribe the ways in which a method parameter \ncan be aliased. These permissions will act as an approximation of the thread sharedness of the object. \nHowever, where our earlier approach used atomic blocks to enable the tracking of possibly thread-shared \nobjects, we will use synchronized blocks. In our approach, every program reference is associated with \na permission kind. The permission kind forms a part of the type of that reference, and it tells our analysis \nwhether or not that refer\u00adence points to an object reachable through other references, and whether this \nand those other references can be used to read or read and modify the object. Permissions have two important \nproperties: First, permissions are always conservative. If a permission says that a reference is the \nonly reference to an object (which we call, unique permission) then we are guaranteed that this is true. \nSecond, per\u00admissions can act as a sound approximation of thread sharing when we assume that other references \nare held by other threads. For ex\u00adample, if the permission associated with a reference r indicates that \nr can be used to modify the object to which it points, but also that other modifying references may exist \n(which we call share), our analysis assumes that this object could be concurrently modi.ed. If, on the \nother hand, the permission is unique, meaning we have the only reference to the object, we take this \nto mean the object is thread-local. The way that the analysis works, at a high level, is to associate \nan abstract state with each reference as it .ows through a method s body. The abstract state of that \nreference may change depending on the pre-and post-conditions of the methods called on that reference. \nMost importantly, if the permission associated with a reference in\u00addicates that other modifying references \nexist, we must conserva\u00adtively assume that the object could be concurrently modi.ed, and therefore we \nactively discard knowledge about the abstract state of that object. Speci.cally, we do this for references \nassociated with share (meaning that the reference may modify, but that other modi\u00adfying references exist) \nand pure (meaning that the reference may only read but that other modifying references exist) permission. \nThe only way that we do not have to discard the abstract state of a pure or share reference is if we \nknow statically that we have pre\u00adviously synchronized on that reference. As we will see later, this will \nbe enough to ensure that the object is not being concurrently modi.ed. To better illustrate the entire \napproach, consider the exam\u00adple shown in Figure 1. In this contrived example, the interface  1 interface \nBlockingQueue { 2 @Full(requires=\"OPEN\", ensures=\"OPEN\") 3 void enqueue(int i); 4 5 @Full(requires=\"OPEN\", \nensures=\"CLOSED\") 6 void close(); 7 8 @TrueIndicates(\"OPEN\") 9 @Pure boolean isOpen();  10 11 @Pure(requires=\"OPEN\", \nensures=\"OPEN\") 12 int dequeue(); 13 } 14 15 void enqueWaitClose(@Full(requires=\"OPEN\" 16 ensures=\"CLOSED\") \n) BlockingQueue q) { 17 for(int i=0; i<5; i++) { 18 // full(q) in OPEN 19 q.enque(i); 20 } 21 Thread.sleep(2000); \n22 q.close(); 23 // full(q) in CLOSED 24 } 25 26 int sumFromQueue(@Pure BlockingQueue q) { 27 int sum \n= 0; 28 while(true){ 29 //synchronized(q) { 30 if(q.isOpen()) { 31 // pure(q) in ? 32 sum += q.dequeue(); \n// ERROR 33 } 34 else 35 return sum; 36 //} 37 } 38 } Figure 1. A blocking queue interface, and two methods \nthat use it, each to be called by a different thread. Because the producer has full permission, it can \nmaintain the knowledge that the queue remains open, while the consumer must synchronize on the queue \nto maintain that knowledge. for a thread-shared queue is de.ned. This queue is meant to be used by a \nproducer thread, with full (exclusive modifying but other readers may exist) permission to the queue. \nThat thread will call the enqueue and close methods, as illustrated in the enqueWaitClose method. The \nconsumer thread, who will have a pure (read-only) permission, will only be able to call the isOpen and \ndequeue methods.1 Our approach works within a method and follows permissions to references as they .ow \nfrom method pre-conditions to post\u00adconditions. In the enqueWaitClose method this means that we track \na full permission to the q reference that is initially in the OPEN state. This satis.es the pre-condition \nto both the enqueue and close methods, so our analysis signals no errors. After the call to close, the \npost-condition of that method indicates that the queue will be transferred to the CLOSED abstract state, \nwhich satis.es the calling method s post-condition. 1 Readers may wonder how the dequeue method can be \nimplemented if the receiver has non-modifying permission but will have to modify the underlying structure \nof the queue in some way to remove the item. In our complete solution [1], this is achieved through dimensions, \nwhich allow clients to have different permissions to different logical parts of an object. The important \nthing to note here is that because the thread executing the enqueWaitClose method has the only modifying \nreference to the queue (i.e. full) our analysis does not have to assume the queue can be concurrently \nmodi.ed, and we maintain knowledge of the queue s state from one line to the next. Things are different \nin the sumFromQueue method where the pure permission to the queue tells our analysis there may be other \nmodifying references held by other threads. In the example as given, our analysis will discard the abstract \nstate implied by the true branch of the conditional on line 30. This means that the pre\u00adcondition of \nthe dequeue method cannot be satis.ed, and our anal\u00adysis will signal an error. If instead we were to \nuncomment the syn\u00adchronized block on line 29, veri.cation of this method would suc\u00adceed, since the queue \nwould no longer subject to concurrent modi\u00ad.cation. Our approach statically tracks the references on \nwhich the current thread is known to have synchronized. There is one more essential aspect of our approach. \nWe also check that protocols are implemented correctly with respect to their speci.cation. Abstract states \nare de.ned by concrete predicates over the .elds of an object. Our approach veri.es that these predi\u00adcates \nare valid whenever a method claims to transition the receiver to a particular state. When checking a \nmethod, access to the these predicates is only available inside a block synchronizing on this, if the \nreceiver is as\u00adsociated with share, pure, or full permission2. In effect this forces .eld reads and stores \nto occur within critical regions. The result is that clients of a thread-shared object are allowed to \nactually re\u00admember which state the object is in when it holds the lock associ\u00adated with that object, \nsince the object could not be modi.ed without acquiring the lock. This requirement also ensures that \nobjects ref\u00aderenced from a unique .eld of a thread-shared object can still be treated as thread local, \nsince the outer object will be itself be re\u00adquired to provide mutual exclusion. The fact that programmers \nare required to synchronize on the re\u00adceiver object does prohibit programmers from using private objects \nfor the purposes of mutual exclusion. However, it has the bene.t of being implicit in our analysis, and \ntherefore we do not require pro\u00adgrammers to specify which locks protect which pieces of memory, a common \nsource of speci.cation burden in other modular static analyses. Our approach requires just the aliasing \nannotations that would be required in a single-threaded analyses. 2.1 Related Work We believe our approach \nis the .rst to statically and modularly check object protocols in concurrent Java programs. While similar \nbehavioral checkers exist (e.g., [3]), they generally require speci\u00ad.cations describing which locks protect \nwhich objects, or method speci.cations describing whether or not locks must be held when called, and \ndo not focus on typestate.   References [1] N. E. Beckman. Verifying concurrent software using atomic \nblocks and alias control. Thesis Proposal, January 2009. [2] N. E. Beckman, K. Bierhoff, and J. Aldrich. \nVerifying correct usage of atomic blocks and typestate. In The 2008 Conference on Object-Oriented Programming \nSystems, Languages and Applications. ACM Press, 2008. [3] B. Jacobs, F. Piessens, K. R. M. Leino, and \nW. Schulte. Safe concur\u00adrency for aggregate objects with invariants. In SEFM 05: Proceedings of the Third \nIEEE International Conference on Software Engineering and Formal Methods, pages 137 147, Washington, \nDC, USA, 2005. IEEE Computer Society. 2 These permissions are the only ones that indicate that an object \nmay be thread-shared and can be modi.ed by at least one thread.   \n\t\t\t", "proc_id": "1639950", "abstract": "<p>In previous work we described a modular static analysis based on access permission annotations, which describe the ways in which a reference can be aliased, for preventing the improper use of object protocols in concurrent programs. That system was based on atomic blocks, a mutual exclusion primitive not yet in wide use. Now we extend that system to programs written using synchronized blocks, which are in wide use today. This system can verify concurrent programs without any concurrency-specific annotations.</p>", "authors": [{"name": "Nels E. Beckman", "author_profile_id": "81363604007", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1728539", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1639990", "year": "2009", "article_id": "1639990", "conference": "OOPSLA", "title": "Modular typestate checking in concurrent Java programs", "url": "http://dl.acm.org/citation.cfm?id=1639990"}