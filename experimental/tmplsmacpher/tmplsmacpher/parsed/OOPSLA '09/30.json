{"article_publication_date": "10-25-2009", "fulltext": "\n Software Evolution and the Moving Picture Metaphor Mark Mahoney Carthage College Kenosha, WI USA mmahoney@carthage.edu \nAbstract Software systems evolve over time. Currently we do not do a good job of documenting this evolution. \nThis essay discusses the need to better document software evolution and introduces the Moving Picture \nMetaphor. Source Control Management systems are more like collections of still photographs than moving \npic\u00adtures. Still photography is not ideal when trying to capture evolu\u00adtional changes. Moving pictures \ndo a much better job. A storyteller can use moving pictures to tell compelling stories that are easier \nto digest than traditional documentation. We can learn a great deal from watching stories that document \na system s evolu\u00adtion. Categories and Subject Descriptors D.2.7 [Distribution, Main\u00adtenance, and Enhancement] \nGeneral Terms Documentation. Keywords Software Evolution, Source Control Management. 1. Introduction \nWhen describing the complexity of modern software development to a layman I find it useful to emphasize \nthe inherent invisibility of software. In almost no other engineering endeavor is it so diffi\u00adcult to \nvisualize what is being constructed. We are at a great dis\u00adadvantage because we cannot pick up and examine \nsoftware from different angles, see how the parts fit in relation to one another, or take a step back \nand see how the construction of the whole is coming along like one can when building something tangible. \nIt is easy for a non-expert to marvel at the multitude of moving parts in a high performance sports car \nor the grandeur of a magnificent piece of architecture, it is not so easy to convince someone of the \nmonumental complexity in the relationships that exist in a million lines of source code. Ultimately, \nthe text files that we create and the binary files that get generated from them are not a satisfying \nrepresentation of the enormously complex wonder that is modern software. Software construction is often \ncompared to skyscraper con\u00adstruction. Both are massively complex and require a great design along with \nmany skilled workers to realize it. However, this anal\u00adogy falls apart because skyscraper construction \nbenefits from being a highly visual process. In my software design courses I ask my students to imagine \nwhat it would be like to build a sky- Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advantage and that copies bear this notice and the full citation on the first \npage. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior \nspecific permission and/or a fee. OOPSLA 2009, October 25-29, 2009, Orlando, Florida, USA. Copyright \n&#38;#169; 2009 ACM 978-1-60558-734-9/09/10 $10.00. scraper in total darkness where every person working \non the sky\u00adscraper has only a small flashlight on their safety helmet. The workers would not be completely \nblind, but they would only be able to see about ten feet in front of them at any one time. In this situation, \none can appreciate some of the beauty in the engineer\u00ading, but a great deal of the architectural splendor \ncan only be fath\u00adomed by a masterful mind. Since most people (including a majority of the people actually \nbuilding the system) do not posses such a mind it is difficult to appreciate the complex nature of software \ndevelopment. This is one of the challenges in modern software development whether there is a single person \non the team or a thousand. I remember piecing together mock hydrogen and oxygen at\u00adoms to form water \nmolecules in high school. These abstractions were powerful and compelling and made it easier to understand \nsomething that was not easy to see. One of the great advance\u00adments in the field of software engineering \nhas been our increased ability to model software from different perspectives. We are no longer limited \nto just having to view software from the source code level. However, I don t believe we have come anywhere \nnear developing such an accurate and succinct set of models in our discipline as others have. Unlike \nthe water molecule model, the UML [6] sequence dia\u00adgram lacks a certain elegance and value. In fact, \nI can think of many instances where I was developing software and chose not to create such a model. As \nfurther evidence of the lack of great mod\u00adels, the Agile Software [1] community believes that too much \ndocumentation (modeling) is worse than too little. That is, when in doubt, they would rather you attempt \nto write the code than create another model that describes what you want the code to do. In his seminal \npaper, Jack Reeves [5] said that, programming is a design activity and that a program listing is a document \nthat represents a software design . Furthermore, the designs are ex\u00adecutable. We get valuable feedback \nfrom seeing our code execute. Sometimes it works, more often it does not. In either case it is exciting \nto have our creativity validated when the code eventually does work. We don t get any feedback or feel \nany of the excite\u00adment when we create a new UML model. Modern software suffers from another essential \ndifficulty, it is constantly evolving. I tell my students that you know your soft\u00adware is successful \nif your customer comes back to you and begs you to add more to it. If they don t, they probably aren \nt using it or you may have built the wrong system for them. Unlike the skyscraper, which is only delivered \nto the customer once it is structurally complete, great software is never really finished. Generally, \nit is as likely that one aspect of the system will be extended or modified to satisfy a customer request \nas any other over its lifetime. This means that the overall architecture might evolve just as quickly \nas the low level code that implements it.  Figure 1. 1965 World Heavyweight Championship The fact that \nsoftware is constantly evolving leads to the topic of this essay, documenting the evolution process. \nOne can learn a great deal about a piece of software by understanding how it has evolved. Important evolutionary \ninformation is typically lost due to our current documentation techniques. We are missing an op\u00adportunity \nto tell a story about how our systems are created. Stories are more compelling than terse documentation. \nOur current source control systems capture snapshots of our systems but provide no means to animate them. \nAnimation is beneficial to telling a story.  2. The Moving Picture Metaphor Perhaps our greatest tool \nto capture evolutional changes in soft\u00adware is Source Control Management (SCM). These tools have been \naround for quite a long time and there are several examples being used today- CVS[3], Subversion[7], \nand Git[4] to name a few. SCM tools capture the state of our systems at fixed points in time. We document \neach release to our customers, each bug fix, and each experimental new feature that we are developing. \nThis is valuable in case we ever need to revert the system to a previous state because our assumptions \nwere incorrect or our designs were faulty. These tools provide another equally important purpose, they \ndocument how the software has evolved over time. In my mind, the snapshots that are recorded with SCM \ntools can be thought of as still photographs. Still photos can be incredi\u00adbly expressive and contain \nan enormous amount of detail. How\u00adever, when the subject being photographed is undergoing an evolutionary \nprocess, still photography fails to capture important details about the subject s growth. Figure 1 shows \none of my fa\u00advorite still photos. In it, Muhammad Ali has just vanquished Son\u00adny Liston in the 1965 World \nHeavy Weight Championship. The photo conveys the domination of an opponent as well as the strength and \ndetermination that made Ali great. This iconic photo defines the great characteristics of Ali but it \ndoes not say much about his opponent, the history between the two, or the actual fight itself. Those \ndetails are lost due to the nature of still photog\u00adraphy. If you were to watch the fight in its entirety \nyou might be sur\u00adprised to find out that Liston was aggressive in chasing Ali around the ring and attacking \nthe body. That information is not apparent from the still. There are several other still photographs \nof the same fight that if you placed them in chronological order you still might not know Liston s strategy. \nThe point is that most prize\u00adfights evolve slowly. Because of the scoring rules in boxing it is not uncommon \nfor the outcome to be decided very late in the fight. In this case, a still medium is not an ideal way \nto record the evolution of the fight. Instead, moving pictures do a better job of capturing the evolution \nin its entirety. Moving pictures can then be used to construct a story. Another way to document evolutionary \nchange is with stop motion photography. I particularly enjoy seeing things like the blooming of a flower \nor the construction of a skyscraper. One obvious difference between stop motion photography and regular \nmoving picture photography is the time scale in between taking consecutive pictures. A video camera might \nshoot thirty frames per second while the stop motion construction of a skyscraper might take place at \nthe rate of one shot per thirty minutes. The amount of time in between shots does not necessarily define \nwhat a moving picture is, what matters is that the difference is not too great where important evolutionary \nchange is missed. Since sky\u00adscrapers are constructed very slowly this is an efficient way to document \nand later observe the building s evolution. The time in between traditional SCM snapshots is usually \ntoo long, and more importantly, evolutionary information is lost be\u00adcause of the lack of an animated \nnarrative in the successive snap\u00adshots. The Moving Picture Metaphor takes the idea that evolutionary \nchange is best documented with moving media rather than still media and applies it to telling stories \nabout soft\u00adware development. Most programmers have probably had one type of Moving Picture experience \nbefore, it goes something like this. The pro\u00adgrammer is writing some code that leads down a dead path. \nShe must rewrite the code from scratch. She has not checked in her code in a while so she wipes out what \nshe has been working on and begins again. When she is almost done with the new solution she realizes \nthere is a bit of the old code that might come in handy. She continuously hits the undo command in her \ntext editor until she is brought back to the old section of code she needs. She then copies the code \nto the clipboard for use in a past\u00ading operation. Lastly, she continuously hits the redo command to get \nher code back to the state where she can perform the paste. The interesting part is that last step. Watching \nthe code being reentered in the text editor is absolutely fascinating. With most text editors the rate \nthat the code is reentered is constant and much faster than the rate it was written, but slow enough \nto read as it is reentered. Sometimes, several hours worth of thinking, working, and refactoring can \nbe shown in just a few seconds. Whenever I experience this I have an internal dialogue about the decisions \nI made, what my code is doing, and why. This informa\u00adtion is still fresh in my mind and has not yet evaporated \ninto the ether. We can use experiences like this to tell stories about how a system is created. These \nstories will be recorded as a form of documentation. The author s internal dialogue needs to be exter\u00adnalized, \nedited, and synchronized with the code to make a com\u00adpelling story. This is equivalent to creating a \nshort documentary movie that describes one aspect of the development of the system.  A movie that tells \na story about the system s development is incredibly valuable. It is valuable to the author of the code \nbe\u00adcause the reasons for the decisions we make do not stay in our heads very long. I often wish I knew \nwhat I was thinking when I am asked to explain my own code. The movie is valuable to any other developer \nwho has to maintain or understand the source code because it documents its evolution. It is valuable \nto new team members so they can see how the code has evolved from inception to the present state. It \nis also valuable as a learning tool to experience how other people go about developing code. This is \nprecisely the information that one hopes is present in source code comments but rarely is. When writing \ncomments there are some pretty serious constraints placed on an author. Comments generally are placed \nabove or next to individual lines of code. Their granularity is very fine and usually applies to one \nor a few lines of consecutive code at a time. Coarse grained de\u00adtails tend not to make it into the comments \nbecause it is awkward to determine where to place them. They tend not to make it in the external documentation \neither because developers are averse to writing and reading external documentation. So, this information \nusually sits (at least for a little while) in the heads of the develop\u00aders. This causes a great deal \nof context about the system to be lost. It is hard to convey anything about the order the code was written, \nthe state of the code previous to the latest addition, why an old solution did not work, what discussions \nthe team had about the solution, etc. The greatest benefit from creating moving pictures is that the \ndevelopers can use the construction of their code to tell a story. The story of how the code was created \nand how it has evolved is vitally important yet is not currently documented well at all. It is difficult \nto tell a story in technical documentation (maybe this is why people are so averse to reading such documents). \nWatching a movie requires far less effort than reading a terse technical docu\u00adment. A moviemaker can \nexplicitly show what is important, to whom it is important, and how this piece relates to that piece. \nOften the same information can be found in traditional written documentation but most authors don t put \nin the effort to guide the reader to those conclusions. It takes a good deal of effort to understand \nmost technical documents, motion pictures are inher\u00adently digestible. Viewers of these stories will have \na leg up when trying to comprehend a large set of code. Imagine one was asked to extend a relatively \nsmall fifty thousand line system. This can be over\u00adwhelming, but it would be easier to understand the \nsystem if there were a few good movies documenting key coding and design decisions in addition to the \nnormal documentation.  3. Realizing the Metaphor We have a wonderful opportunity to tell new kinds of \nstories that document the interesting parts of a system. As a member of a development team I would be \nexcited to know that in our posses\u00adsion we have one or more Architecture stories, Feature stories, Algorithm \nstories, Refactoring stories, Security stories, Bug Fix stories, or Debugging stories. A story is not \nrequired for every single aspect of a system, only the really interesting and useful aspects warrant \na story. The uninteresting parts of the system are still very important and are present in the code and \ncan be refer\u00adenced when necessary. There are, of course, many different ways to tell a story. Each has \nadvantages and disadvantages. In this essay I focus on using moving pictures to tell a story about system \ndevelopment. How\u00adever, that is not to say that this is the only device we should be using to tell our \nstories. Good moving pictures have the advantage of being easily digestible. They require less time and \neffort to consume than reading. I admit that very few Hollywood movies made from novels express as much \ndetail and emotion as the au\u00adthor s words on the page. However, watching a movie requires less of an \ninvestment in effort and time than reading a book. Whereas a novel requires us to stretch our imagination \na movie does not ask us to expend that much effort. Many of us are willing to make this tradeoff for \nefficiency s sake. Of course, a great deal of effort is required to gain these effi\u00adciencies when translating \na novel into a movie. A novel must be reduced to its fundamental elements. The director must provide \na visual interpretation on film and still tell a coherent and interest\u00ading story. I imagine that deciding \nwhat to leave out from the novel is one of the most challenging tasks a movie director faces. If we are \nto create moving pictures that tell stories about system devel\u00adopment then we too must have the tools \nto efficiently and effec\u00adtively move a story forward. SCM tools contain evolutionary information, but \nthey do not do a very good job in animating the evolution. One can compare this situation with a set \nof pictures in a flipbook. In a flipbook several pieces of paper are bound together and pictures are \ndrawn in the corners of each page. One can quickly flip through the pag\u00ades to create an animation. To \ncreate a flipbook one draws a single picture on a page. Each successive page has slight differences that \nrepresent motion. In this analogy, SCM tools hold the pictures from a flipbook but they provide no mechanism \nto animate them. We need tools to make it easier to see the evolution of our sys\u00adtems. One way to realize \nthe moving picture metaphor is to use a new process for animating source code. The programmer s key\u00adstrokes \nare the pictures from the flipbook. They can be animated by showing how the code was constructed and \nhow the system has evolved as a result of it. Little films can be created from the keystrokes that convey \nuseful information such as the develop\u00adment of a feature, a refactoring session, a debugging session, \nor a test driven development session. All good moving pictures require a cohesive narrative and a good \neditor. A cohesive narrative allows one to follow a complex plot. A film s editing plays a huge role \nin the quality of the narra\u00adtive and the quality of the finished work. If we are to apply the metaphor \nto software development then the same narrative and editing requirements will hold. Creating a story \nabout a new feature, for example, requires some thought about presenting a plot. A good story has a begin\u00adning, \nmiddle, and an end. A good story also has protagonists and antagonists. The beginning of most stories \nset up the context of the environment, introduces the reader to the main characters, and describes a \ndilemma that needs to be resolved. When creating a story about a system s development the same holds \ntrue. One certainly needs to describe the state of the system before the fea\u00adture was developed, why \nthis feature is needed, and how it will affect other aspects of the system. A system development story \ncan also have protagonists, like patterns or proposed solutions, and antagonists like system constraints \nand existing features. These characters will make the story more compelling. The middle part of a story \nusually guides the reader through knowledge gathering and attempts to resolve the dilemma. Most good \nstories will have unexpected twists and turns that result from the protagonist s actions. Again, the \nsame holds true. When add\u00ading a feature one must gather information and think about how adding it will \naffect the system. Attempts are made at including the feature but they are rarely added without a twist \nor turn that requires significant refactoring. The end of a story shows how the dilemma was resolved \nand wraps up any loose ends. One should feel satisfied that they have taken a real journey once the story \nhas ended.  One can create a story like this if they have the right building blocks to piece together \nand tools to support the construction. Although I will not go into any details about tooling in this \nessay I do believe the essential building blocks will come from devel\u00adopers. While a programmer is writing \ncode they should be con\u00adstantly narrating into a microphone what they are doing and why. This audio is \nsynchronized with the recording of each keystroke. This mass of information will become important later \non in the editing phase. This dialogue includes short term goals, ideas for possible solutions, potential \nconflicts with other parts of the sys\u00adtem, effects of the code on other parts of the system, future ideas \nfor implementations based on the current code, explanations of why something works well or doesn t work \nat all. We are thinking all of these thoughts in our heads anyway, we might as well vo\u00adcalize them into \na microphone to document them. A headset with a microphone will become an important tool in the coding \nproc\u00adess. In some forms of Agile Software Development, Pair Pro\u00adgramming [2] is advocated. I like pair \nprogramming mostly be\u00adcause it turns an inherently solitary experience (coding) into a social activity. \nAn experienced pair programming author will be constantly explaining their decisions to their partner \nwhile writing code. An inexperienced author should be prompted by their part\u00adner to elicit the same information. \nIn either case, it forces the author to externalize the thoughts that are going through their head while \nthe code is being written. Traditionally, none of this information is recorded. At least with pair programming \nit travels from one person s head to another. It would be beneficial to the team if everyone had access \nto this information at anytime. The amount of information captured in this phase might seem overwhelming. \nHowever, one can consider this the rehearsal be\u00adfore the final performance. Rehearsals are a time for \nexploration and experimentation. This information is recorded so that we remember all of our brilliant \nideas. This will also be an excellent source of information later on when someone asks why some piece \nof code was written the way it was. External storage is cheap enough where we no longer have to worry \nabout the costs of storing large amounts of information. Great stories require great storytellers who \nhave a vision, know who their audience will be, and see the value in telling a story. I imagine that \narchitects and lead developers will be the great storytellers. They are the ones who will recognize the \nneed to tell a story and they will have the ability to understand and piece together the building blocks. \nA set of great tools will make their jobs much more practical. Currently, these tools do not exist but \nthey are an exciting area of future research. I can envision something like an IDE Plug-In with many \nof the same features one would find in film editing software. Once a story has been told in the code \nand documented with a movie, the moving picture must be stored as a permanent part of the system documentation. \nThese movies will be available to the development team and should be organized in such a way that different \naudiences will be able to find the right movie for them. For example, an overview movie might be made \nfor developers just joining the team. If the team is broken up by feature an over\u00adview movie of each \nfeature may be created. A movie can be made for extensions to a single feature. A debugging movie might \nbe made for a particularly difficult bug that was fixed, and so on.  4. Conclusion One can learn a great \ndeal from watching things evolve. I remem\u00adber watching a film about Pablo Picasso in which he painted \na picture from start to finish on screen. It made me appreciate the abstract forms so much more than \nif I had just seen the final work. I believe humans are particularly good at learning from watching things \nevolve. However, our current documentation techniques do not facilitate capturing and animating evolutionary \nchange. When a developer writes code, their organization owns all of the working code. However, it should \nalso own the knowledge gained while building the system and all the mistakes and inferior solutions made \nalong the way. This historical information is a treasure trove of details, decisions, coding strategies, \nand software engineering best practices. How and why things change are the types of information that \nis often allowed to walk out of the build\u00ading when there is turnover in the development team. This infor\u00admation \ncan and should be gathered to tell a story of how the code was developed. Stories are more compelling \nthan traditional documentation. Although our SCM tools capture some of the evolutionary information in \na system they do not provide a means to animate them.  Acknowledgments I would like to thank Ralph Johnson \nfor guiding me through the shepherding phase. I would also like to thank the rest of the re\u00adviewers for \ntheir valuable comments and insight.  References [1] The Agile Manifesto. http://agilemanifesto.org/. \n[2] Kent Beck. Extreme Programming Explained: Embrace Change. Addison-Wesley Professional. 1999. [3] \nConcurrent Versioning System. http://www.nongnu.org/cvs/ [4] Git. http://git-scm.com/ [5] Robert C. Martin. \nAgile Software Development Principles, Patterns, and Practices. Prentice Hall 2003. Appendix D pp. 517-524. \n[6] The Unified Modeling Language. http://uml.org/ [7] Subversion. http://subversion.tigris.org/  \n\t\t\t", "proc_id": "1640089", "abstract": "<p>Software systems evolve over time. Currently we do not do a good job of documenting this evolution. This essay discusses the need to better document software evolution and introduces the <i>Moving Picture Metaphor</i>. Source Control Management systems are more like collections of still photographs than moving pictures. Still photography is not ideal when trying to capture evolutional changes. Moving pictures do a much better job. A storyteller can use moving pictures to tell compelling stories that are easier to digest than traditional documentation. We can learn a great deal from watching stories that document a system's evolution.</p>", "authors": [{"name": "Mark Mahoney", "author_profile_id": "81325489250", "affiliation": "Carthage College, Kenosha, WI, USA", "person_id": "P1728817", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1640089.1640130", "year": "2009", "article_id": "1640130", "conference": "OOPSLA", "title": "Software evolution and the moving picture metaphor", "url": "http://dl.acm.org/citation.cfm?id=1640130"}