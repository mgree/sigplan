{"article_publication_date": "10-25-2009", "fulltext": "\n Query-Point Debugging Salman Mirghasemi School of Computer and Communication Sciences, Ecole Polytechnique \nF\u00b4erale de Lausanne, ed\u00b4Switzerland salman.mirghasemi@ep..ch Abstract debugging process and is also \nthe focus of this paper. Lo\u00adcating defects is mainly carried out by the examination of Software Debugging \nis still one of the most challenging and buggy execution, therefore the bug should be reproducible. time \nconsuming aspects of software development. Monitor-In this paper, when we talk about debugging and bugs, \nwe ing the software behavior and .nding the causes of this be\u00admean locating defects and reproducible \nbugs respectively. havior are located at the center of debugging process. Al-There are two traditional \napproaches to debugging: log\u00adthough many tools and techniques have been proposed to based debugging and \nbreakpoint-based debugging. The .rst support developers in this job, none of them could replace approach \nconsists in inserting logging statements within the or improve the traditional debugging methods. This \npaper source code, in order to produce an ad-hoc trace during pro\u00adpresents Query-Point debugging as a \nnew debugging ap\u00adgram execution. This technique exposes the actual history proach and explains how it \ncan facilitate debugging for de\u00adof execution but (a) it requires cumbersome and widespread velopers. \n modi.cations to the source code, and (b) it does not scale Categories and Subject Descriptors D.2.5 \n[Software En-because manual analysis of huge traces is hard. The second gineering]: Testing and Debugging \napproach consists in running the program under a dedicated debugger which allows the programmer to pause \nthe exe- General Terms Algorithms, Design, Human Factors, Lan\u00adcution at determined points, inspect memory \ncontents, and guages then continue execution step-by-step. Although not subject Keywords dynamic breakpoint \nassignment, execution mon\u00adto the two issues of log-based debugging, breakpoint-based itoring, locating \ndefects, program traces, query debugging is limited: when execution is paused, the infor\u00admation about \nthe previous state and activity of the program 1. Problem Statement is limited to introspection of the \ncurrent call stack [1]. Software Debugging has little changed during the past Omniscient debuggers, which \nare built based on capture\u00addecades and remained one of the most challenging and time replay techniques, \nhave been proposed to overcome men\u00adconsuming aspects of software engineering. Today, debug-tioned issues. \nWhile the advantages of omniscient debug\u00adging is much more an art and the predominant techniques for \nging over traditional approaches are incredibly clear, it has .nding bugs are data gathering (e.g., print \nstatements) and had a very limited impact in production environments, and hand simulation. Software developers \nspend huge amounts is still mostly seen as an unrealistic approach [1]. We can of time, up to half of \ntheir time, debugging. Finding and .x-brie.y mention three main issues about omniscient debug\u00ading bugs \nfaster and more effectively directly increases pro-gers. First, capturing the execution trace has a huge \nover\u00adductivity and can improve program quality by eliminating head over normal execution. Second, the \ncaptured execution more defects with available resources [2]. is different with live execution and many \nuseful data such as Fixing a bug consists of three main stages, reproducing GUI and memory heap states \nare not available to the devel\u00adthe bug, locating the defects and .nally .xing the defects. oper. Third, \nquerying the huge amount of collected data is The second stage, locating defects, located at the heart \nof expensive. This work provides two main contributions to debugging: (a) Query-Point debugging, as a \nnew debugging approach, which provides a systematic method to debugging; and (b) Techniques which let \napplying Query-Point debugging on live executions instead of captured ones. Copyright is held by the \nauthor/owner(s). OOPSLA 2009, October 25 29, 2009, Orlando, Florida, USA. ACM 978-1-60558-768-4/09/10. \n  2. Query-Point Debugging Before getting into the approach explanation, we need to de.ne a few concepts. \nWe can suppose a hypothetical line, execution trace line, corresponding to the program execution trace. \nAn execution point is a point on this line. A query selects a set of points on the execution trace line. \nChecking the correctness of program state, Check State Problem (CSP), at a given point is the problem \narises many times during debugging and is one main source of debugging complexity. A buggy point is an \nexecution point with a data\u00ad.ow or control-.ow problem in the program execution or program state. Consider \nthat the buggy point is determined according to the developer s expectation which can be de\u00ad.ned by a \nset of assertions. Therefore, at least one of the de.ned assertions at a buggy point should be violated. \nThis de.nition might be inconsistent (due to defects in the devel\u00adoper s mental model) or it might change \nduring debugging. Two basic approaches are used for the navigation on buggy execution trace: forward \nand backward check-search. Each one of these approaches has its own features and usu\u00adally a mixture of \nboth is used. Answering to CSP is easier in forward check-search while backward check-search is more \nnatural for .nding the cause of an error. Query-Point debugging works based on a few simple facts: 1. \nLocating defects problem can be reduced to locating the .rst buggy point (defect point) on the buggy \nexecution trace line and providing an explanation of how the prob\u00adlem at the defect point eventually \ncauses the bug. 2. From the defect point to the point the bug appears, all points are buggy points. \nConsider that program state con\u00adsists of all data affect the program execution. For example when a program \nstores data in a database table, the table should also be considered as part of program state. 3. To \nanswer to CSP at a point, a developer needs to know at which stage of computation scenario the point \nis located. Then the developer can use collected data to determine expectations which become the basis \nfor answering to CSP at the point.  Query-Point debugging is an iterative process in which the developer \nincrementally increase her knowledge about the buggy execution. Execution trace line is the central ref\u00aderence \nview during debugging and, points on this line and their associated assertions are the developer s discoveries \nup to now. In addition to keeping track of past steps, it helps de\u00adveloper to only focus on the interval \nfrom the last non-buggy point to .rst buggy point. Queries are appropriate means for specifying new points. \nThe Query-Point debugging process can be explained in a few high-level steps: Query-Point Debugging: \n1) Convert the bug to a buggy point on the execution trace line. 2) Start backward check-search from \nthe first buggy point or forward check-search from the last non-buggy point. 3) Answer to CSP at next \npoint . Go to step 2. Forward Check-Search: 1) Define the next point. Backward Check-Search: 1) If there \nis a data-flow problem: 1.1)A wrong value next point: the last place the variable has been changed. 2) \nIf there is a control-flow problem: 2.1)A wrong instruction. next point: last fork point. 2.2)A missed \ninstruction. next point: last fork point. To start debugging, the developer should determine at least \none buggy point on the execution trace line. This point is usually the point the bug appears. Sometimes \nthe devel\u00adoper has some initial data (e.g., the error location in source code) about this point, therefore \nthe developer can use these initial data to query the execution and .nd the point. Other\u00adwise the developer \nhas to go through forward check-search to .nd the .rst buggy point on the execution trace line. After \nthe .rst step, the developer continues by adding a new point and therefore reducing the examination interval \nat every it\u00aderation. 3. Implementation Techniques We brie.y explain three main implementation techniques: \n(a) Querying live execution; (b) Point .xation; and (c) Back\u00adward movement. Once a bug is reproducible, \nthe live buggy execution can be used for examination. Querying the live ex\u00adecution is carried out by \ndynamic breakpoints assignment. It means that, the debugger determines places that might be in the result \nset of query and checks all these points during the execution. One advantage of querying the live execution \nis that the developer can de.ne more complex constraints in a boolean method which can be called at every \npoint. Point .xation means recognizing the same points on the trace line in the following executions. \nThe primary technique for point .xation is using the index of point in the query result set. There are \nsome cases (e.g., when two threads do the same job) that the index in the result set is not enough for \n.nding the same point. In these cases additional data around the point (e.g., a method parameter value) \ncan be used to uniquely de.ne the point. Backward movement can be managed by .xing the current point \nand re-execution. Acknowledgments I would like to thank Claude Petitpierre for advising me in this research. \nReferences \u00b4 debugging. In OOPSLA, 2007. [1] G. Pothier, E. Tanter and J. Piquer. Scalable omniscient \n[2] A. Zeller. Why Programs Fail: A Guide to Systematic Debug\u00adging. Morgan Kaufmann, 2005.  \n\t\t\t", "proc_id": "1639950", "abstract": "<p>Software Debugging is still one of the most challenging and time consuming aspects of software development. Monitoring the software behavior and finding the causes of this behavior are located at the center of debugging process. Although many tools and techniques have been proposed to support developers in this job, none of them could replace or improve the traditional debugging methods. This paper presents Query-Point debugging as a new debugging approach and explains how it can facilitate debugging for developers.</p>", "authors": [{"name": "Salman Mirghasemi", "author_profile_id": "81444606310", "affiliation": "Ecole Polytechnique F&#233;d&#233;rale de Lausanne, Lausanne, Switzerland", "person_id": "P1728571", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1639950.1640003", "year": "2009", "article_id": "1640003", "conference": "OOPSLA", "title": "Query-point debugging", "url": "http://dl.acm.org/citation.cfm?id=1640003"}