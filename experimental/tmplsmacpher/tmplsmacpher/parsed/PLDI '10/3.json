{"article_publication_date": "06-05-2010", "fulltext": "\n Jinn: Synthesizing Dynamic Bug Detectors for Foreign Language Interfaces Byeongcheol Lee Ben Wiedermann \nMartin Hirzel Robert Grimm\u00a7 Kathryn S. McKinley University of Texas at Austin IBM Watson Research Center \n\u00a7New York University {bclee,ben,mckinley}@cs.utexas.edu hirzel@us.ibm.com rgrimm@cs.nyu.edu Abstract \nProgramming language speci.cations mandate static and dynamic analyses to preclude syntactic and semantic \nerrors. Although indi\u00advidual languages are usually well-speci.ed, composing languages is not, and this \npoor speci.cation is a source of many errors in mul\u00adtilingual programs. For example, virtually all Java \nprograms com\u00adpose Java and C using the Java Native Interface (JNI). Since JNI is informally speci.ed, \ndevelopers have dif.culty using it correctly, and current Java compilers and virtual machines (VMs) inconsis\u00adtently \ncheck only a subset of JNI constraints. This paper s most signi.cant contribution is to show how to synthesize \ndynamic analyses from state machines to detect foreign function interface (FFI) violations. We identify \nthree classes of FFI constraints encoded by eleven state machines that capture thou\u00adsands of JNI and \nPython/C FFI rules. We use a mapping function to specify which state machines, transitions, and program \nentities (threads, objects, references) to check at each FFI call and return. From this function, we \nsynthesize a context-speci.c dynamic anal\u00adysis to .nd FFI bugs. We build bug detection tools for JNI \nand Python/C using this approach. For JNI, we dynamically and trans\u00adparently interpose the analysis on \nJava and C language transitions through the JVM tools interface. The resulting tool, called Jinn, is \ncompiler and virtual machine independent. It detects and diagnoses a wide variety of FFI bugs that other \ntools miss. This approach greatly reduces the annotation burden by exploiting common FFI constraints: \nwhereas the generated Jinn code is 22,000+ lines, we wrote only 1,400 lines of state machine and mapping \ncode. Over\u00adall, this paper lays the foundation for a more principled approach to developing correct multilingual \nsoftware and a more concise and automated approach to FFI speci.cation. Categories and Subject Descriptors \nD.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation Assertion Checkers, Relia\u00adbility; D.2.5 [Software \nEngineering]: Testing and Debugging Debugging Aids; D.3.4 [Programming Languages]: Processors Run-time \nEnvironments General Terms Design, Languages, Reliability, Veri.cation Keywords Multilingual Programs, \nForeign Function Interfaces (FFI), Java Native Interface (JNI), Python/C, Dynamic Analysis, FFI Bugs, \nSpeci.cation, Speci.cation Generation Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 10, June 5 10, 2010, Toronto, Ontario, Canada. Copyright c &#38;#169; \n2010 ACM 978-1-4503-0019-3/10/06. . . $10.00 1. Introduction Programming language designers spend years \nprecisely specify\u00ading languages [12, 15, 24]. Likewise, language implementors ex\u00adert considerable effort \nenforcing speci.cations with static and dy\u00adnamic checks. Many developers, however, compose languages \nto reuse legacy code and leverage the languages best suited to their needs. Such multilingual programs \nrequire additional speci.cation due to syntactic and semantic language differences. Well-designed and \nwell-speci.ed foreign function interfaces (FFIs) include recent integrated language designs [13, 25] \nand language binding synthe\u00adsizers [5, 22], but programmers have not yet widely adopted them. FFIs currently \nin wide use, such as the Java Native Interface (JNI) and Python/C, are large, under-speci.ed, and hard \nto use cor\u00adrectly. They have hundreds of API calls and complex usage rules. For example, JNI has 229 \nAPI calls and 1,500+ rules, although it is well-encapsulated and portable [19]. This complexity arises \ndue to language impedance mismatches in object models, type systems, memory management, and exceptions. \nExample JNI calls include: look up a class by name, speci.ed as a string, and return its class descriptor; \nlook up a method by class descriptor and signature, again speci.ed as a string, and return a method descriptor; \nand invoke a method by its descriptor. Example JNI constraints include: when a program calls from C to \nJava, the actuals must match the formals declared types; also when calling from C to Java, a program \nmust not have a pending Java exception; and a program must issue an extra request to maintain more than \n16 local cross-language references. While language differences easily lead to large and complex FFIs, \nthey also make complete static enforcement of FFI usage rules impossible. For example, JNI s use of string \narguments to describe class names and method signatures cleanly abstracts over the underlying JVM and \nits implementation. Unfortunately, these strings prevent standard static type checking, and even advanced \ninterprocedural static analysis is incomplete [10, 28]. Similarly, complete static checking of pending \nexceptions and the count of local references is impossible. Overall, voluminous, complex, and context-dependent \nFFI rules lead to three problems. (1) Some rules are statically undecidable and require dynamic validation. \n(2) Language implementations are inconsistent and often diverge when they do dynamically enforce a rule, \nfor example, by signaling an exception versus terminating a program. (3) Writing correct FFI code that \nfollows all rules is hard for programmers. As a direct consequence of these three problems, real-world \nmultilingual programs are full of FFI bugs [10, 11, 16, 17, 18, 26, 27]. This paper signi.cantly improves \non this sorry state by present\u00ading a systematic and practical approach to dynamic FFI validation. We \n.rst demonstrate that JNI s 1,500+ usage rules boil down to three classes of rules: Default Behavior \nLanguage Static Dynamic Analysis JNI Pitfall HotSpot J9 Design Analysis HotSpot J9 Jinn 1. Error checking \nrunning crash [13], [25] [16], [18] warning error exception 2. Invalid arguments to JNI functions running \ncrash [13], [25] [11], [27] running crash exception 3. Confusing jclass with jobject crash crash [13], \n[25] [11] error error exception 6. Confusing IDs with references crash crash [13] [11] error error exception \n8. Terminating Unicode strings running NPE [13], [25] running NPE running/NPE 9. Violating access control \nrules NPE NPE [13], [25] NPE NPE exception 11. Retaining virtual machine resources leak leak [13], [25] \n[16] running warning exception 12. Excessive local reference creation leak leak running warning exception \n13. Using invalid local references crash crash [13] [16] error error exception 14. Using the JNIEnv across \nthreads running crash [13] error crash exception 16. Bad critical region deadlock deadlock [13] [16] \nwarning error exception Table 1. JNI pitfalls [19]. Running: continues to execute in spite of unde.ned \nJVM state. Crash: aborts without diagnosis. Warning: prints diagnosis and continues. Error: prints diagnosis \nand aborts. NPE: raises a null pointer exception. Exception: raises a Jinn JNI exception. JVM state constraints \nrestrict JVM thread context, critical sec\u00ad tion state, and/or exception state. Type constraints restrict \nparameter types, values (e.g., not NULL), and semantics (e.g., no writing to .nal .elds). Resource constraints \nrestrict the number of multilingual pointers and resource lifetimes, e.g., locks and memory. Furthermore, \neleven state machines express all these rules. Com\u00adpared to Liang s speci.cation, this concision is unexpected \n[19]. Using the state machines, we present a new way to synthesize context-sensitive dynamic analysis \nthat precisely identi.es FFI vi\u00adolations. We parameterize each state machine by program entities: threads, \nreferences, and objects. The synthesizer attaches state ma\u00adchines to JNI parameters, return values, and \nthreads. For JNI analy\u00adsis, we observe it is suf.cient to transition state machines and check constraints \nat language boundaries. Consequently, the synthesizer inserts wrapper functions with generated code before \nand after FFI calls. These functions transition the state machines and dynami\u00adcally verify the FFI speci.cation. \nWhereas we wrote about 1,400 non-comment lines of state machine and mapping code for JNI, our tool generates \n22,000+ lines, demonstrating that this approach greatly reduces the annotation burden for FFI speci.cation. \nWe dynamically and transparently inject the analysis into user code using language interposition. We \nimplement interposition with vendor-neutral JVM interfaces in a tool called Jinn. The JVM loads Jinn \ntogether with the program during start-up, and then Jinn interposes on all Java and C transitions. To \nthe JVM, Jinn looks like normal user code, whereas to user code Jinn is invisible. Jinn checks JNI constraints \nat every language transition and diagnoses bugs when the program violates a constraint. Jinn is more \npractical than the state-of-the-art for .nding JNI bugs, in part because it does not depend on the JVM \nor C compiler. The experimental results section shows that Jinn works with un\u00admodi.ed programs and VMs, \nincurs only a modest overhead, and that programmers can examine the full program state when Jinn de\u00adtects \na bug. Table 1 compares Jinn to prior work qualitatively and quantitatively. It shows that prior dynamic \ntools are incomplete. For the subset of errors that static analysis .nds, they are preferable since Jinn \nonly .nds exercised bugs. However, static tools cannot conclusively identify many dynamic resource bugs \nand type errors that Jinn .nds with no false positives. We explore the generality of our FFI speci.cation \nand approach using the Python/C FFI. We .nd that Python/C requires the same three rule classes and similar \nstate machines. Just as for Java and C, the Python/C rules re.ect fundamental language semantic mis\u00admatches. \nWhereas C relies on manual resource management and is weakly typed, Python automates memory reclamation, \nprovides a stronger typing discipline (in this case dynamic), enforces well\u00adformed resource access, and \nautomates error propagation. We im\u00adplement and evaluate a Python/C bug detector for a few unique rules, \nproviding further evidence for the generality of our approach. In summary, the contributions of this \npaper include: Synthesis of dynamic FFI analysis from state machines.  The .rst rigorous state machine \nspeci.cation of JNI based on its informal speci.cation [19].  Jinn, the most practical JNI bug detector, \nwhich is generated by our synthesizer.  A demonstration of Jinn on JNI microbenchmarks and on real\u00adworld \nprograms.  A demonstration of the generality of this approach for Python/C.  We believe that by identifying \nand specifying the three classes of FFI constraints, this paper helps lay a foundation for a more principled \napproach to developing correct multilingual software, foreign function interfaces, and perhaps other \ninterfaces. 2. Motivation and Related Work This section shows that JNI has inconsistent implementations, \nwhich likely stems from poor speci.cation and certainly compli\u00adcates portable JNI programming. It then \nquantitatively and qualita\u00adtively compares Jinn to prior work that uses language design, static analysis, \nand dynamic analysis to diagnose FFI bugs. Finally, it reviews other work on synthesizing analyses from \nstate machines. FFI programming is challenging because programmers must reason about multiple languages \nand their semantic interactions. For example, Chapter 10 of the JNI manual identi.es .fteen pit\u00adfalls \n[19]. We list the most serious of these in Table 1, using Liang s numbering scheme, and include bad critical \nregion from Chap\u00adter 3.2.5 as a 16th pitfall. We created small JNI programs to exercise each pitfall \nand executed them with HotSpot and J9. Columns two and three show that JNI mistakes cause a wide variety \nof crashes and silent corruption. The two JVMs behave differently on four of the pitfalls. Columns six \nand seven show the JVMs are not much better with built-in JNI checking (turned on by the -Xcheck:jni \ncommand-line .ag). Table 1 also compares language designs, static analysis tools, and our Jinn implementation. \nAn empty entry indicates that we are not aware of a language feature or static analysis that handles \nthis pitfall. We .ll in entries based on our reading of the litera\u00adture [11, 13, 16, 18, 25, 27]. We \ndid not execute the static tools. Language designs cover the widest class of JNI bugs [13, 25], but new \nlanguages require developers to rewrite their code. Static anal\u00adysis catches some, but not all, pitfalls. \nFor example, statically en\u00adforcing non-nullness without language support (e.g., a @NonNull annotation) \nis undecidable. At the same time, dynamic and static FFI analysis are complementary. Dynamic analysis \nmisses unexer\u00adcised bugs, whereas static analysis reports false positives. The last column shows that \nJinn detects all but one of these serious and common errors. Pitfall 8 depends on how C code uses character \nbuffers and requires analysis or instrumentation of a program s entire C code, which is beyond our more \ntargeted dynamic analysis. Consequently, the program exhibits the same behavior as a production run without \nJinn, i.e., it either keeps on running (HotSpot) or signals a null pointer exception (J9). When Jinn \ndetects any of the other errors, it throws a JNI failure exception and stops execution to help programmers \ndebug. Jinn works out\u00adof-the-box on unmodi.ed JNI, which makes it practical for use on existing programs. \nIt systematically .nds more errors than all the other approaches. 2.1 Language Approaches to FFI Safety \nTwo language designs propose to replace the JNI. SafeJNI [25] combines Java with CCured [21], and Jeannie \nsafely and directly nests Java and C code into each other using quasi-quoting [13]. Both SafeJNI and \nJeannie de.ne their language semantics such that static checks catch many errors and both add dynamic \nchecks in translated code for other errors. From a purist perspective, prevent\u00ading FFI bugs while writing \ncode is more economical than spending time to .x them after the fact. Another approach generates language \nbindings for annotated C and C++ header .les [5, 14]. Ravitch et al. reduce the annotations required \nfor generating idiomatic bind\u00adings [22]. Jinn is more practical than these approaches, because it does \nnot require developers to rewrite or annotate their code in a different language. 2.2 Static FFI Bug \nCheckers A variety of static analyses verify foreign function interfaces [10, 11, 16, 18, 26, 27]. All \nstatic FFI analysis approaches suffer from false positives because the speci.cation includes dynamic \nproper\u00adties, such as non-null reference parameters, valid Java class and method names in string parameters, \nand less than 16 local refer\u00adences. Static analysis cannot typically guarantee these properties. For \ninstance, J-Saf.re reports false positives and warnings [11]; Tan et al. report a false positive rate \nof 15.4% [18]; and BEAM reports a false positive, while missing the bug in Section 3.1. In contrast, \nJinn never generates false positives, but only .nds bugs actually triggered during program execution. \nFurthermore, whereas prior static analyses for JNI require the native library to be written in C and \navailable in source form, Jinn is neither restricted to C nor does it require source code access. For \ninstance, Jinn found FFI bugs in the Subversion Java binding written in C++. In summary, static analysis \n.nds a subset of FFI bugs without executing the pro\u00adgram, but suffers from false positives. In comparison, \nJinn .nds more FFI bugs, but only when they are exercised; suffers from no false positives; and requires \nno source code access.  2.3 Dynamic FFI Bug Checkers Some JVMs provide built-in dynamic JNI bug checkers, \nenabled by the -Xcheck:jni command-line .ag. While convenient, these error checkers only cover limited \nclasses of bugs, and JVMs imple\u00adment them inconsistently. NaturalBridge s BulletTrain ahead-of\u00adtime Java \ncompiler performed several ad-hoc JNI integrity checks on language transitions [20]. The Blink debugger \nprovides JNI bug checkers that work consistently for different JVMs, but its coverage is limited to two \nbugs: validating exception state and nullness con\u00adstraints [17]. These kinds of checks are easy to implement, \nbecause they require no preparatory bookkeeping. Jinn covers a larger class of JNI bugs, works consistently \nwith any JVM that implements the JVM Tools Interface (JVMTI), and explicitly throws an exception at the \npoint of failure. Exceptions provide a principled and language supported approach to software quality, \nfor example, enabling a GUI-based program to report the bug in a dialog instead of relying on the user \nto sift through the system log. Furthermore, when the exception s error message and calling context do \nnot suf.ce to identify the cause of the failure, programmers can rerun the program with both Jinn and \na Java de\u00adbugger. The debugger then catches the exception, and the program\u00admer can access the detailed \nprogram state at the point of failure. 2.4 State Machine Speci.cations Several programmable bug checkers \ntake state machine speci.\u00adcations, and report errors when state machines reach error states. For instance, \nMetal [9] and SLIC [4] are languages for specifying state machines that are then used to .nd bugs through \nstatic anal\u00adysis. Dwyer et al. survey state-machine driven static analyses [8]. On the dynamic side, \nAllan et al. turn FSMs into dynamic anal\u00adyses by using aspect-oriented programming [2]; Chen and Rosu \nsynthesize dynamic analyses from a variety of speci.cation for\u00admalisms, including FSMs [7]; and Arnold \net al. implement FSMs for bug detection in a JVM, controlling the runtime overhead by sampling [3]. While \nin principle these speci.cation languages are expressive enough to describe many FFI constraints, in \npractice none of them address the unique challenges of multi-lingual soft\u00adware. Also, unlike Jinn, most \nof them require source code access. 3. An Example JNI Bug and Detector This section illustrates and motivates \nour approach using an exam\u00adple. It describes some JNI background, an example JNI bug, and a state machine \nthat captures this bug. It then describes how to use this state machine to dynamically detect the example \nbug on lan\u00adguage transition boundaries at JNI calls and returns. We explain how our system attaches state \nmachines to program entities, i.e., objects, individual references, and threads, and how it transitions \nentity states on JNI calls and returns, i.e., through explicitly passed arguments and results as well \nas the implicit threads. The JNI is designed to hide JVM implementation details from native code, while \nalso supporting high-performance native code. Hiding JVM details from C code makes multilingual Java \nand C programs portable across JVMs and gives JVM vendors .exibility in memory layout and optimizations. \nHowever, achieving portabil\u00adity together with high performance leads to 229 API functions and over 1,500 \nusage rules. For instance, JNI has functions for calling Java methods, accessing .elds of Java objects, \nobtaining a pointer into a Java array, and many more. To hide JVM implementation de\u00adtails, these functions \ngo through an indirection, such as method and .eld IDs, or require the garbage collector to pin arrays. \nDevelopers using JNI avoid indirection overhead on the C side by, for example, caching method and .eld \nIDs, and pinning resources. At the same time, JVM developers avoid implementation complexity by requir\u00ading \nexplicit calls to mark references as global and to release pinned objects. 3.1 Example FFI Bug Figure \n1 shows a simpli.ed version of an FFI bug from the GNOME project s Bugzilla database (Bug 576111) [29]. \nGNOME is a graphical user interface that makes heavy use of several C libraries. In the example, Line \n1 de.nes a C function Java Call\u00ad 1. JNIEXPORT void JNICALL Java Callback bind(JNIEnv *env, 2. jclass \nclazz, jclass receiver, jstring name, jstring desc) 3. { /* Register an event call-back to a Java listener. \n*/ 4. EventCallBack* cb = create event callback(); 5. cb->handler = callback; 6. cb->receiver = receiver; \n/* receiver is a local reference.*/ 7. cb->mid = .nd java method(env, receiver, name, desc); 8. if \n(cb->mid != NULL) register callback(cb); 9. else destroy callback(cb); 10. } /* receiver is a dead \nreference. */ 11. static void callback(EventCallBack* cb, Event* event) { 12. JNIEnv* env = .nd env \npointer from current thread(); 13. jvalue* jargs = marshal event(cb, env, event); 14. /* BUG: dereference \nof now invalid cb->receiver. */ 15. (*env)->CallStaticVoidMethodA( 16. env, cb->receiver, cb->mid, \njargs); 17. }  Figure 1. JNI invalid local reference error in a call-back routine from GNOME (Bug 576111) \n[29]. State Language Triggering transition transition functions Acquire Call:Java.C Native method taking \nreference e.g., Java Callback bind Return:Java.C JNI function returning reference e.g., GetObjectField \nRelease Return:Java.C DeleteLocalRef Return:C.Java Any native method e.g., Java Callback bind Use Call:C.Java \nJNI function taking reference e.g., CallStaticVoidMethodA Return:C.Java Native method returning reference \ne.g., Class.getClassContext Figure 2. A resource tracking state machine for local references and the \nmapping from state transitions to Java/C language transi\u00adtions (calls and returns) to dynamically detect \nthe bug in Figure 1. back bind that implements a Java native method using the JNI. An example call from \nJava to C takes the following form: Callback.bind(receiverClass, methodName , description ); This call \ninvokes the C function Java Callback bind, which registers a new C heap object cb storing the receiver \nclass and method name passed as parameters from Java. The C function callback referenced on Line 5 is \nde.ned starting at Line 11. It uses the cb parameter object to call from C code to the speci.ed Java \nmethod. Line 15 shows this call from C to Java. It uses a JNI API function CallStaticVoidMethodA, which \nresides in a struct referenced by the JNI environment pointer env. This code is buggy. The parameter \nreceiver in Line 2 is a local reference. A local reference in JNI is only valid until the enclosing function \nreturns, because, otherwise, the garbage collector would need to communicate with the C runtime about \nlive references. Thus, cb->receiver becomes invalid when the function returns at Line 10. But Line 6 \nstores receiver in a heap object, letting it escape. When Line 16 retrieves receiver from the heap and \nuses it as a parameter to CallStaticVoidMethodA, it is an invalid dangling 1. void wrapped Java Callback \nbind(JNIEnv *env, 2. jclass clazz, jclass receiver, jstring name, jstring desc) 3. { 4. /* Instrument \nCall:Java.C for Acquire state transition. */ 5. jobject set refs = jinn acquire thread local jobject \nset(); 6. if (clazz != NULL) { jinn refs acquire(refs, clazz); } 7. if (receiver != NULL) { jinn refs \nacquire(refs, receiver); } 8. if (name != NULL) { jinn refs acquire(refs, name); } 9. if (desc != NULL) \n{ jinn refs acquire(refs, desc); } 10. /* Call the wrapped native method. */ 11. Java Callback bind(env, \nclazz, receiver, name, desc); 12. /* Instr. Return:C.Java for Release state transition. */ 13. jinn \nrelease thread local jobject set(refs); 14. }  Figure 3. Wrapper for function Java Callback bind from \nFigure 1 with instrumentation for Acquire and Release state transitions. 1. void wrapped CallStaticVoidMethodA(JNIEnv \n*env, 2. jclass clazz, jmethodID mid, jvalue *args) 3. { 4. /* Instrument Call:C.Java for Use state \ntransition. */ 5. jobject set refs = jinn get thread local jobject set(); 6. if ((clazz != NULL) &#38;&#38; \n!jinn refs contains(refs, clazz)) { 7. /* Raise a JNI exception. */ 8. return jinn throw JNIException(env, \nError: dangling ); 9. } 10. /* Call the wrapped JNI function. */ 11. CallStaticVoidMethodA(env, clazz, \nmid, args); 12. }  Figure 4. Wrapper for function CallStaticVoidMethodA from Fig\u00adure 1 Line 15 with \ninstrumentation for Use state transition. reference, and the JVM s garbage collector may have either \nmoved the object or reclaimed it and reused the corresponding memory. The JNI speci.cation merely says \nthat this reference is invalid and leaves the consequences up to the vendor s Java implementa\u00adtion [19]. \nThis kind of bug is dif.cult to .nd with static analysis, because it involves complex data .ow through \nthe heap, and com\u00adplex control .ow through disjoint indirect calls and returns across languages. For \ninstance, the syntax analysis in J-BEAM [16] misses this bug. The other static analyses in Table 1 can \ngenerate warnings on all such stores (e.g., at Line 6), but will also generate thousands of false alarms. \n 3.2 Example FFI Bug Detector This section shows how to identify this bug dynamically using a state machine. \nFigure 2 shows a simpli.ed state machine that enforces local usage rules, applied to the receiver parameter \nat runtime. On entry to the method (Figure 1: Line 1), the state of receiver transitions from Before \nAcquire to Acquired. When the method returns back to Java (Line 10), the state transitions from Acquired \nto Released. Finally, the call from C to Java at Line 16 uses the reference cb->receiver, triggering \na transition to the Error: Dangling state and thus detecting the bug. The table in Figure 2 shows more \ngenerally where state tran\u00adsitions occur. For example, dynamic analysis must execute the Acquire transition \nfor all reference parameters on all calls from Java to C. On return from C to Java, dynamic analysis \nmust ex\u00adecute the Release transition for all local references. To instrument both calls and returns, \nwe wrap these calls. For example, our dy\u00adnamic checker replaces Java Callback bind with the wrapper func\u00adtion \nwrapped Java Callback bind shown in Figure 3. The instrumen\u00adtation attaches state machines to entities \n(threads, parameters, and return values) by using thread-local storage (refs). We also instrument the \nJNI functions that implement the C API for interacting with the Java virtual machine. For example, the \nUse transition in the table happens on calls from C to Java if the callee is a JNI function taking a \nreference, such as CallStaticVoidMethodA. Such a use is an error if the reference is in the Released \nstate. Figure 4 shows the wrapper with the instrumentation. For illustration purposes, these example \nwrappers omit other checks our system performs. For example, JNI limits the number of available local \nreferences, so there is another possible error state for over.ow. Developers may manually manage the \nnumber of avail\u00adable local references with the JNI functions PushLocalFrame and PopLocalFrame and the \ncorresponding dynamic analysis requires instrumentation to count references. The .gures also omit checks \nfor thread state, exception state, and parameter nullness. Section 5 explains all the constraints we \ncheck and their encoding in state machines. 4. Dynamic Analysis Synthesis We use state machine speci.cations \nlike the one in Figure 2 to synthesize a dynamic analysis. Each state machine speci.cation describes \nstate transitions, which are triggered by language tran\u00adsitions. Their cross-product yields thousands \nof checks in the dynamic analysis. For example, before executing the JNI call in Line 15 of Figure 1, \nthe analysis enforces at least eight constraints: The Java interface pointer, env, matches the current \nC thread.  The current JVM thread does not have pending exceptions.  The current JVM thread did not \ndisable GC to directly access Java objects including arrays.  cb->mid is not NULL.  cb->receiver is \nnot NULL.  cb->receiver is not a dangling JNI reference.  cb->receiver is a reference to a Java Class \nobject.  The formal arguments of cb->mid are compatible with the ac\u00adtual arguments in cb->receiver and \njargs.  Hand-coding all these constraints would be tedious and error\u00adprone. Instead, we specify state \nmachines as follows. De.ning state machine states and transitions: Each FFI con\u00adstraint is de.ned by \na state machine. The individual states are encoded as C data structures and the transitions as C code, \nwhich also checks whether a transition has, in fact, been trig\u00adgered. For example, the if-statement in \nLine 6 of Figure 4 is a transition check for determining whether the entity is cur\u00adrently in the Released \nstate and should therefore transition to the Error: Dangling state. Each state machine speci.cation Mi \nhas a set of state transitions Mi.stateTransitions. Mapping state transitions to language transitions: \nEach speci\u00ad.cation has a function Mi.languageTransitionsFor that maps state transitions to language transitions. \nThe synthesizer con\u00adsults this mapping to inject context-speci.c instrumentation into wrapper functions. \nFor example, Figure 2 illustrates a map\u00adping. Figures 3 and 4 show generated wrappers. Each state transition \nsa .sb may occur at a set L = Mi.languageTransitionsFor(sa .sb) of language transitions. Each language \ntransition e in this set is a record containing the .elds function, direction (Call or Return), and entities \n(threads, parameters, and return values). Applying state machines to entities: At runtime, the wrappers \nat\u00adtach state machines to entities and then transition the entity\u00adspeci.c state machine(s) based on context, \nencoding the state machine states in thread-local storage. For example, the wrap\u00adper in Figure 3 associates \na state machine with the receiver ref-Algorithm 1 Input: state machine speci.cations M1,...,Mn. Output: \nFFI wrapper functions instrumented with dynamic checker. 1: for each state machine speci.cation Mi .{M1,...,Mn} \ndo 2: for each state transition sa .sb . Mi.stateTransitions do 3: let L = Mi.languageTransitionsFor(sa \n.sb) 4: for each language transition e . L do 5: let w be the wrapper for e.function 6: add the following \nsynthesized code to the start or end of w, depending on whether e.direction is Call or Return: 7: for \neach entity e . e.entities do 8: if e satis.es the transition check for sa .sb then 9: modify the state \nmachine encoding to record the transition of e from sa to sb. Figure 5. Structure of Jinn Synthesis. \nerence, transitions its state to Acquired, and encodes this infor\u00admation by adding the reference to the \nthread-local list refs. As already mentioned above, the analysis developer speci.es state machine encodings \nas a set of mutable data structures and func\u00adtions that manipulate those structures. The state machine \nspeci.cations consisting of these three compo\u00adnents (state transitions, mappings from state transitions \nto language transitions, and state machine encodings) serve as input to Algo\u00adrithm 1. The algorithm computes \nthe cross product of state transi\u00adtions and FFI functions, and then generates a wrapper for each FFI \nfunction that performs the appropriate state transformations and er\u00adror checking. This functionality \nis the core of the Jinn Synthesizer component in Figure 5. The synthesizer takes two additional inputs: \nan analysis driver and a custom exception. The output of the synthesizer is Jinn a shared object .le \nthat the JVM dynamically loads using the JVM tools interface (JVMTI). The analysis driver initializes \nthe state ma\u00adchine encodings and dynamically injects the generated, wrapped FFI functions into a running \nprogram. The custom exception de\u00ad.nes how the dynamic analysis reports errors. Jinn monitors run\u00adtime \nevents and program state. When Jinn detects a bug, it throws the custom exception. If the exception is \nnot handled, the JVM prints a message with the JNI constraint violation and the faulting JNI function \ncall. If Jinn is invoked within a debugger, the program\u00admer can inspect the call chain, program state, \nand other potential causes of the failure. We now turn our attention to specifying the state machines. \n 5. JNI Constraint Classi.cation This section describes how three classes of constraints summarize all \nJNI constraints and how to encode these constraints in eleven state machines. These JNI constraints encompass \n1,500+ rules from the JNI manual. As far as we are aware, no other work speci.es the JNI FFI, other FFIs, \nor any other API so concisely. Constraint Count Description JVM state constraints JNIEnv* state 229 \nCurrent thread matches JNIEnv* thread Exception state 209 No exception pending for sensitive call Critical-section \nstate 225 No critical section Type constraints Fixed typing 157 Parameter matches API function signature \nEntity-speci.c typing 131 Parameter matches Java entity signature Access control 18 Written .eld is non-.nal \nNullness 416 Parameter is not null Resource constraints Pinned or copied 12 No leak or double-free string \nor array Monitor 1 No leak Global or weak global 247 No leak or dangling refer\u00adreference ence Local reference \n284 No over.ow or dangling reference Table 2. Classi.cation and number of JNI constraints. We classify \nJNI constraints into three classes. (1) JVM state constraints ensure that the JVM is in the right state \nbefore calls from C. (2) Type constraints ensure that C passes valid arguments to Java. (3) Resource \nconstraints ensure that C code manages JNI resources correctly. Table 2 summarizes these constraints \nand in\u00addicates the number of times Jinn s language interposition agent checks them. For example, the \nJNIEnv* state constraint appears 229 times, because Jinn checks its validity in all 229 JNI functions. \nFor each of the three classes, Figures 6, 7, and 8 summarize the state-machine representations, the entities \nto which they apply, and the errors they .nd. The remainder of this section describes in detail each \nconstraint, its state machine representation, and how it detects errors. 5.1 JVM State Constraints To \nenter the JVM through any JNI function, C code must satisfy three conditions. (1) The JNI environment \npointer JNIEnv* and the caller belong to the same thread. (2) Either no exception is pending, or the \ncallee is exception-oblivious. (3) Either no critical region is active, or the callee is critical-region \noblivious. Figures 6 shows the state machines for these three types of JVM constraints. JNIEnv* state \nconstraint. All calls from Java to C implicitly pass a pointer to the JNIEnv structure, which speci.es \nthe JVM-internal and thread-local state. All calls from C to Java must explicitly pass the correct pointer \nwhen invoking a JNI function. When the pro\u00adgram creates a native thread, Jinn learns about the JNIEnv* \npointer from the JVM, and retrieves the thread ID from the operating sys\u00adtem. It enters both into the \nstate machine encoding, which is a map from thread ID to JNIEnv* pointer. Later, when a native thread \ncalls any of the 229 JNI functions, Jinn looks up the expected JNIEnv* from the state machine encoding \nand compares it to the actual pa\u00adrameter of the call, reporting an error if the pointers differ. Exception \nstate constraints. When Java code throws an excep\u00adtion and returns to C, the C code does not automatically \ntransfer control to the nearest exception handler. The program must explic\u00aditly consume or propagate \nthe pending exception. This constraint JNIEnv* state Observed entity: A thread. Error(s) discovered: \nJNIEnv* mismatch. State machine encoding: Map from thread IDs to their expected JNIEnv* pointers. State \nmachine diagram: Trivial, omitted for brevity. State Language Triggering transition transition functions \nJNI call Call:C.Java Any JNI function e.g., CallVoidMethod Exception state Observed entity: A thread. \nError(s) discovered: Unhandled Java exception. State machine encoding: Internal JVM structures. State \nmachine diagram:  State transition Language transition Triggering functions JNI return Return:Java.C \nAny JNI function e.g., CallVoidMethod Clear or return to Java Return:Java.C Return:C.Java ExceptionClear \nReturn from any native method Exception\u00adoblivious call Call:C.Java Small set of clean-up functions e.g., \nReleaseStringChars Exception- Call:C.Java All other JNI functions sensitive call e.g., GetStringChars \nCritical-section state Observed entity: A thread. Error(s) discovered: Critical section violation. State \nmachine encoding: Map from a critical resource Ri to the num\u00adber of times a given thread has acquired \nthat resource. State machine diagram: State transition Language transition Triggering Functions Acquire \nReturn:Java.C GetStringCritical or GetPrimitiveArrayCritical Release Return:Java.C ReleaseStringCritical \nor ReleasePrimitiveArrayCritical Critical-section sensitive call Call:C.Java All other JNI functions \ne.g., CallVoidMethod Figure 6. State machines for JVM state constraints.  Fixed typing Observed entity: \nA reference parameter. Error(s) discovered: Type mismatch between actual and formal parameter to JNI \nfunction. State machine encoding: Map from entity IDs to their signatures. State machine diagram: Trivial, \nomitted for brevity. State Language Triggering transition transition functions JNI call Call:C.Java \nJNI function de.ning a parameter with a .xed type, e.g., clazz parameter to CallStaticVoidMethod Access \ncontrol Observed entity: A .eld ID. Error(s) discovered: Assignment to .nal .eld. State machine encoding: \nMap from .eld IDs to their modi.ers. State machine diagram: Trivial, omitted for brevity. State Language \nTriggering transition transition functions JNI call Call:C.Java Set<Type>Field or SetStatic<Type>Field \nEntity-speci.c typing Observed entity: A pair of ID parameters. Error(s) discovered: Type mismatch for \nJava .eld assignment or between actual and formal of a Java method. State machine encoding: Map from \nentity IDs to their signatures. State machine diagram: Trivial, omitted for brevity. State Language Triggering \ntransition transition functions  JNI call Call: JNI function de.ning parameters C.Java with interrelated \ntypes, e.g., clazz and method in CallStaticVoidMethod Nullness Observed entity: A reference parameter. \nError(s) discovered: Unexpected null value passed to JNI function. State machine encoding: None. State \nmachine diagram: Trivial, omitted for brevity. State Language Triggering transition transition functions \nJNI call Call:C.Java JNI function de.ning a parameter that must not be null, e.g., method parameter to \nCallStaticVoidMethod Figure 7. State machines for type constraints. results from the semantic mismatch \nin how C and Java handle ex\u00adceptions. Any JNI call may lead to Java code that throws an ex\u00adception, which \ncauses a transition to the exception pending state when the JNI call returns. The JVM internally records \nthis state transition for each Java thread, so Jinn does not need to interpose on JNI returns to track \nexception states, and can instead simply rely on the JVM-internal data structure for its state machine \nencoding. If the program returns from a JNI call and an exception is pending, the program must consume \nor propagate the exception. To do so, the programmer may .rst select from one of 20 exception-oblivious \nJNI functions that query the exception state and release JVM re\u00adsources, before calling JNI s ExceptionClear \nfunction. If the pro\u00adgrammer calls any of the remaining exception-sensitive JNI func\u00adtions while an exception \nis pending, Jinn intercedes and wraps the pending exception in an error report to the user. Critical-section \nstate constraints. JNI de.nes the phrase JNI critical section to describe a piece of C code that has \ndirect access to a Java string or array, during which the JVM may take drastic measures such as disabling \nthe garbage collector. A critical sec\u00adtion starts with GetStringCritical or GetPrimitiveArrayCritical, \nand ends with the matching ReleaseStringCritical or ReleasePrimitive-ArrayCritical. C code should hold \nthese resources only for a short time. To prevent deadlock, C code must not interact with the JVM other \nthan to acquire or release critical resources. In other words, during a critical section, C code must \nonly call one of the four functions that get/release arrays/strings. We call these four func\u00adtions critical-section \ninsensitive, and all the remaining JNI func\u00adtions critical-section sensitive. Jinn encodes the state \nmachines by keeping, for each thread, a tally of the number of times that thread has acquired a speci.c \ncritical resource. Jinn instruments the four get and release calls to manage these counts. Each acquisition \nof a resource Ri must be matched by a corresponding release. When the list of critical resources for \na thread toggles between empty and non-empty, the critical-section state machine transitions corre\u00adspondingly. \nJinn interposes on all the 225 critical-section sensitive functions to verify that the thread currently \nmaintains no critical resources and that releases are well-matched. Critical sections are tricky because \nthey prohibit calls to most JNI functions, including those that Jinn uses for its own error checking. \nFor example, Jinn does not check whether the argument to ReleaseStringCritical is in fact a Java string, \nsince that would require calling IsAssignableFrom from within a critical region. At the same time, C \ncode cannot exercise much JNI functionality while in a critical section and can legally call only four \nfunctions to acquire more critical sections and to release them again. 5.2 Type Constraints When Java \ncode calls a Java method, the compiler and JVM check type constraints on the parameters. But when C code \ncalls a Java method, the compiler and JVM do not check type constraints, and type violations cause unspeci.ed \nJVM behavior. For example, given the Java code Collections.sort(ls, cmp); the Java compiler checks that \nclass Collections has a static method sort, and that the actual parameters ls and cmp conform to the \nformal parameters of sort. Consider the equivalent code expressed with Java re.ection. Class clazz = \nCollections.class; Method method = clazz.getMethod( sort , List.class, Comparator.class); method.invoke(Collections.class, \nls, cmp); The Java compiler cannot statically verify its safety, but if the program is unsafe at runtime, \nthen the JVM throws an exception. In JNI, this code is expressed as follows. jclass clazz = (*env)->FindClass(env, \njava/util/Collections ); jmethodID method = (*env)->GetStaticMethodID(env, clazz, sort , (Ljava/lang/List;Ljava/util/Comparator;)V \n); (*env)->CallStaticVoidMethod(env, clazz, method, ls, cmp); Since the C code expresses Java type information \nin strings, stan\u00addard static type checking cannot resolve the types and even sophis\u00adticated interprocedural \nanalysis cannot always resolve them [10, 28]. Consequently, the C compiler does not statically enforce \ntyp\u00ading constraints on the Collections and sort names or the ls and cmp parameters. Furthermore, and \nunlike Java re.ection, JNI does not even dynamically enforce typing constraints on the clazz and method \ndescriptors. In contrast, Jinn does enforce these and other JNI type con\u00adstraints dynamically. Figure \n7 summarizes the four constraints on types and the remainder of the section discusses them in detail. \nThe .gure omits the trivial state machines for brevity. Fixed typing constraints. Type constraints require \nthe runtime type of actuals to conform to the formals. For many JNI func\u00adtions, the parameter type is, \nin fact, .xed by the the function it\u00adself. For example, in CallStaticVoidMethod(env, clazz, method, ls, \ncmp), the clazz actual must always conform to type java.lang.Class. We extracted this and comparable \nconstraints by scanning the JNI header .le for C parameters (e.g., jstring) with well-de.ned cor\u00adresponding \nJava types (e.g., java.lang.String). We extracted ad\u00additional .xed typing constraints from the informal \nJNI explana\u00adtion in [19]. For example, FromRe.ectedMethod has a jobject pa\u00adrameter, whose expected type \nis either java.lang.re.ect.Method or java.lang.re.ect.Constructor. Overall, Jinn interposes on 151 JNI \nfunctions to verify 157 .xed typing constraints. For each check, Jinn obtains the class of the actual \nusing GetObjectType and then checks compatibility with the expected type through IsAssignableFrom. Entity-speci.c \ntyping constraints. A plethora of JNI functions call Java methods or access Java .elds. JNI references \nJava meth\u00adods and .elds via entity IDs. For example, in CallStaticVoid\u00adMethod(env, clazz, method, ls, \ncmp), parameter method is a method ID. In this case, the method must be static, and the method param\u00adeter \nconstrains the other parameters. In particular, the clazz must declare the method, and ls and cmp must \nconform to the formal parameters of the method. Jinn records method and .eld signatures upon return from \nJNI functions that produce method and .eld IDs. The entity ID constrains the types of method parameters \nor .eld values, and the receiver class (for static entities) or object (for in\u00adstance entities), for \neach of 131 JNI functions that access a Java entity. When a program calls one of these functions that \ntake an entity ID, Jinn interposes on the call to verify that the function conforms to the entity s typing \nconstraints. Access control constraints. Even when type constraints are satis\u00ad.ed, Java semantics may \nprohibit accesses based on visibility and .nal modi.ers. For example, in SetStaticIntField(env, clazz, \n.d, 42), the .eld identi.ed by .d may be private or .nal, in which case the assignment follows questionable \ncoding practices. The JNI speci.\u00adcation is vague on legal accesses with respect to their visibility and \n.nal constraints. After some investigation, we found that in prac\u00adtice, JNI usually ignores visibility, \nbut honors the .nal modi.er. Ig\u00adnoring visibility rules seems surprising, but as it turns out, this per\u00admissiveness \nis consistent with the behavior of re.ection, which may suppress Java access control when setAccessible(true) \nwas success\u00adful. Honoring .nal is common sense. Despite the fact that re.ection may mutate .nal .elds, \nmutating them interferes with JIT optimiza\u00adtions, concurrency, and complicates the Java memory model. \nAs with entity-speci.c typing, Jinn keeps track of .eld IDs, as well as which .elds are .nal. Jinn raises \nan error if native code calls any of the 18 JNI functions that might assign to a .nal .eld. Nullness \nconstraints. Some JNI function parameters must not be null. For example, in CallStaticVoidMethod(env, \nclazz, method, ls, cmp), the parameters env, clazz, and method must not be null. At the same time, some \nJNI functions do accept null parameters, for example, the initial array elements in NewObjectArray. Since \nthe JNI speci.cation is not always clear on which parameters may be null, we determined these constraints \nexperimentally. We uncov\u00adered 416 non-null constraints among the 210 JNI functions that de\u00ad.ne parameters. \nJinn reports to the user when the program violates any of these constraints.  5.3 Resource Constraints \nA JNI resource is a piece of Java-related data that C code can ac\u00adquire or release through JNI calls. \nFor example, C code can acquire a Java string or array. Depending on the JVM implementation, the JVM \neither pins the string or array to prevent the garbage collec\u00adtor from moving it, or copies the array, \nand then passes C code a pointer to the contents. Other JNI resources include various kinds of opaque \nreferences to Java objects, which C code can pass to JNI functions, and which give C code some control \nover Java mem\u00adory management. Finally, JNI can acquire or release Java monitors, which are a mutual-exclusion \nprimitive for multi-threaded code. APIs with manual or semi-automatic memory management suf\u00adfer from \nwell-known problems. (1) Section 3.2 illustrated one such problem: a use after a release corrupts JVM \nstate through a dangling reference. There are three other common resource er\u00adrors. (2) An acquire at \ninsuf.cient capacity causes an over.ow. (3) A missing release at the end of reference lifetime causes \na leak. (4) A second release is a double-free. The Jinn analysis depends on the resource (e.g., array, \nstring reference, object). In a few cases, Jinn cannot detect certain error conditions, because they \nare under\u00adspeci.ed or hidden in C code. For instance, Jinn currently cannot detect when C code uses an \ninvalid C pointer without calling a JNI function. In a few cases, Jinn need not check resource-related \nerrors, since the JVM or other Jinn state machines already trap them. For example, when the JVM throws \nan OutOfMemoryError exception, Jinn already checks for correct exception handling.  While the state \nmachines and error cases for all kinds of JNI resources are similar, they differ in the details due to \nthe above rea\u00adsons. Figures 8 shows these four different resource cases separately, and we now discuss \neach in more detail. Pinned or copied string or array constraints. C code can tem\u00adporarily obtain direct \naccess to the contents of a Java string or array. JVMs may pin or copy the object to facilitate garbage \ncollection. To make sure the JVM unpins the object or frees the copy, the C code must properly pair acquire/release \ncalls. Jinn reports a leak for any resource that has not been released at program termination. Jinn reports \na double-free for a resource it has already evicted from its state machine representation due to an earlier \nfree. Jinn does not check for dangling references, because their uses happen in C code. Jinn does not \ncheck for over.ow (i.e., an out-of-memory condition) in this state machine, because its exception checking \nsubsumes this check. Monitor constraints. A monitor is a Java mutual exclusion prim\u00aditive. Jinn need \nnot check over.ow or double-free for monitors, since the JVM already throws exceptions. Jinn cannot check \ndan\u00adgling monitors, since that requires divining when the programmer intended to release it. Jinn does \nreport if a monitor is not released at program termination, which indicates a risk of deadlock. Global \nreference or weak global reference constraints. A global or weak global reference is an opaque pointer \nfrom C to a Java object that is valid across JNI calls and threads. These references are explicitly managed, \nbecause the garbage collector needs to up\u00addate them when moving objects and also treat global (but not \nweak) references as root. Jinn reports a leak for any unreleased global or weak global reference at program \ntermination. Jinn reports a dan\u00adgling reference error if the program uses a reference after a free. Double-free \nis a special case of the dangling reference error and over.ow is a special case of Jinn s exception state \nconstraints. Pinned or copied string or array Observed entity: A Java string or array that is pinned \nor copied. Error(s) discovered: Leak and double-free. State machine encoding: A list of acquired JVM \nresources. State machine diagram:  State transition Language transition Triggering functions Acquire \nReturn:Java.C Get<Type>ArrayElements and similar getter functions Release Return:Java.C Release<Type>ArrayElements \nand similar release functions Program termination JVMTI callback Global reference or weak global reference \nObserved entity: A global or weak global JNI reference Error(s) discovered: Leak and dangling reference. \nState machine encoding: A list of acquired global references. State machine diagram:  State Language \nTriggering transition transition functions Acquire Return:Java.C NewGlobalRef and NewWeakGlobalRef Release \nReturn:Java.C DeleteGlobalRef and DeleteWeakGlobalRef Use Call:C.Java JNI function taking reference e.g., \nCallVoidMethod Return:C.Java Native method returning reference, e.g., Class.getClassContext Program \ntermination JVMTI callback Monitor Observed entity: A monitor. Error(s) discovered: Leak. State machine \nencoding: A set of monitors currently held by JNI and, for each monitor, the current entry count. State \nmachine diagram: State Language Triggering transition transition functions Acquire Call:C.Java MonitorEnter \nRelease Call:C.Java MonitorExit Program termination JVMTI callback Local reference Observed entity: \nA local JNI reference Error(s) discovered: Over.ow, leak, dangling, and double-free. State machine encoding: \nFor each thread, a stack of frames. Each frame has a capacity and a list of local references. State \nmachine diagram: State Language Triggering transition transition functions Acquire Call:Java.C Native \nmethod taking reference Return:Java.C JNI function returning reference e.g., GetObjectField Release Return:Java.C \nDeleteLocalRef or PopLocalFrame Return:C.Java Return from any native method Use Call:C.Java JNI function \ntaking reference e.g., CallVoidMethod Return:C.Java Native method returning reference, e.g., Class.getClassContext \n Figure 8. State machines for resource constraints. Local reference constraints. JNI manages local references \nsemi-and removes it upon release. Jinn performs bookkeeping to sup\u00adautomatically: acquire and release \nare more often implicit than ex-port over.ow checks, since the JNI speci.cation only guarantees plicit. \nNative code implicitly acquires a local reference when a space for up to 16 local references. If more \nare needed, the user Java native call passes it to C, or when a JNI function returns must explicitly \nrequest additional capacity with PushLocalFrame, it. The JVM releases local references automatically \nwhen native and later release that space with PopLocalFrame. Jinn keeps track code returns to Java, but \nthe user can also manually release one of local frames and checks four error cases as follows. (1) Jinn \nde\u00ad(DeleteLocalRef) or several (PopLocalFrame) local references. Jinn tects over.ow if the current local \nframe exceeds capacity. (2) JNI enters the reference into its state machine encoding upon acquire releases \nindividual local references automatically; Jinn checks for leaked local reference frames when native \ncode returns to Java. (3) Jinn checks that local references passed as parameters to JNI functions are \nnot dangling and, furthermore, belong to the current thread. (4) Jinn detects a double-free when DeleteLocalRef \nis called twice for the same reference, or if nothing is left to pop on a call to PopLocalFrame. 6. Experimental \nResults This section evaluates the performance, coverage, and usability of Jinn to support our claim \nthat it is the most practical FFI bug .nder to date. 6.1 Methodology Experimental environments. We used \ntwo production JVMs, Sun HotSpot Client 1.6.0 10 and IBM J9 1.6.0 SR5. We conducted all experiments on \na Pentium D T3200 with 2GHz clock, 1MB L2 cache, and 2GB main memory. The machine runs Ubuntu 9.10 on \nthe Linux 2.6.31-19 kernel. JNI programs. We used several JNI programs: microbench\u00admarks, SPECjvm98 [23], \nDaCapo [6], Subversion 39004 (2009\u00ad08-31), Java-gnome-4.0.10, and Eclipse 3.4. The microbenchmarks are \na collection of 16 small JNI programs, which are designed to trigger one each of the error states in \nthe eleven state machines shown in Figures 6, 7, and 8. The microbenchmarks also cover all pitfalls in \nTable 1 with exception of Pitfall 8, which cannot be detected at the language boundary. SPECjvm98 and \nDaCapo are written in Java, but exercise native code in the system library. Subversion, Java-gnome, and \nEclipse mix Java and C in user-level libraries. Except for Eclipse 3.4, we use .xed inputs. Dynamic JNI \ncheckers. We compare three dynamic JNI check\u00aders: runtime checking in IBM and SUN JVMs, which is turned \non by the -Xcheck:jni option, and Jinn, which is turned on by the -agentlib:jinn option in any JVM. Experimental \ndata. We collected timing and statistics results by taking the median of 30-100 trials to statistically \ntolerate exper\u00adimental noise. The runtime systems show non-deterministic be\u00adhavior from a variety of \nsources: micro-architectural events, OS scheduling, and adaptive JIT optimizations. 6.2 Performance \nThis section evaluates the performance of Jinn. Table 3 shows the results. Jinn adds instructions to \nevery language transition between the JVM and native libraries, interposing and checking transitions. \nThe second column counts the total number of transitions between Java and C in the system libraries using \nHotSpot. The third column shows the execution times of runtime checking for HotSpot. Exe\u00adcution times \nare normalized to production runs of HotSpot without any dynamic checking. The fourth column reports \nJinn s frame\u00adwork overhead due to interposition on language transitions. The .fth column reports the \ntotal time, which includes state machine encoding, transitions, and error checking. On average, Jinn \nhas a modest 14% execution time overhead and most of the overhead (all but 4%) comes from runtime interposition, \nrather than executing the analysis code.  6.3 Coverage of Jinn and JVM Runtime Checking This section \nshows that Jinn covers qualitatively and quantitatively more JNI bugs than the state-of-art dynamic checking \nin production JVMs. Quality. We run the 16 microbenchmarks with HotSpot, J9, and Jinn. Figure 9 compares \ntheir error messages on the representa\u00adtive ExceptionState microbenchmark, which violates the exception \nLanguage Normalized execution times transition Runtime Jinn Benchmark counts checking Interposing Checking \nantlr 441,789 1.04 0.98 1.05 bloat 839,930 1.02 1.19 1.20 chart 1,006,933 1.02 1.08 1.12 eclipse 8,456,840 \n1.01 1.17 1.20 fop 1,976,384 1.07 1.14 1.37 hsqldb 206,829 0.88 1.04 1.05 jython 56,318,101 1.03 1.10 \n1.16 luindex 1,339,059 1.03 1.08 1.13 lusearch 4,080,540 1.04 1.09 1.21 pmd 967,430 1.04 1.10 1.13 xalan \n1,114,000 1.01 1.17 1.19 compress 14,878 0.98 1.09 1.08 jess 153,118 0.99 1.22 1.17 raytrace 29,977 1.04 \n1.16 1.14 db 133,112 0.99 1.01 1.02 javac 258,553 1.06 1.16 1.14 mpegaudio 46,208 1.00 1.01 1.04 mtrt \n32,231 1.01 1.11 1.14 jack 1,332,678 1.04 1.10 1.21 GeoMean 1.01 1.10 1.14  Table 3. Jinn performance \non SPECjvm and DaCapo with HotSpot. state constraints of Section 5.1. The C code in the benchmark ig\u00adnores \nan exception raised by Java code and calls two JNI functions: GetMethodID and CallVoidMethod. HotSpot \nreports that there were two illegal JNI calls, but does not identify the offending JNI func\u00adtion calls. \nJ9 reports the .rst JNI function (GetMethodID), but does not show the calling context for the .rst bad \nJNI call because J9 aborts the JVM. Jinn reports both illegal JNI calls, their calling contexts, and \nthe source location of the original Java exception. In addition to precise reports, Jinn s error reporting \nintegrates with debuggers. Java debuggers like jdb and Eclipse JDT can catch the custom exception, and \nprogrammers can then inspect the Java state to .nd the failure s cause. Even better, the Blink Java/C \ndebugger [17] can present the entire program state, including the full calling context consisting of \nboth Java and C frames. Quantity. The behavior of the production runs without dynamic checkers ranges \nfrom ignoring the bug to simply crashing to rais\u00ading a null pointer exception none of which is correct. \nThe dy\u00adnamic checkers built into the HotSpot and J9 JVMs also behave inconsistently in more than half \nof our microbenchmarks (9 of 16). Jinn is the only dynamic bug-.nder that consistently detects and reports \nthe JNI bugs in our 16 microbenchmarks by throwing an exception. Quantitative coverage of Jinn, HotSpot, \nand J9 is 100%, 56%, and 50%, respectively, with exceptions, warnings (print to console and keep running), \nand errors (print to console and termi\u00adnate) counting as valid bug reports. Jinn s 100% coverage on our \nown, speci.cally designed testsuite is hardly surprising and does not imply that Jinn catches all JNI \nbugs. But the low JVM coverage demonstrates that error checking in previous practice was at best in\u00adcomplete. \nFurthermore, JNI constraint violations are common and well-documented [10, 11, 16, 17, 18, 26, 27], underlining \nthe need for better constraint enforcement. 6.4 Usability with Open Source Programs This section evaluates \nthe usability of Jinn based on our experience of running Jinn over Subversion, Java-gnome, and Eclipse. \nAll WARNING in native method: JNI call made with exception pending at ExceptionState.call(Native Method) \nat ExceptionState.main(ExceptionState.java:5) WARNING in native method: JNI call made with exception \npending at ExceptionState.call(Native Method) at ExceptionState.main(ExceptionState.java:5) (a) HotSpot \nJVMJNCK028E JNI error in GetMethodID: This function cannot be called when an exception is pending JVMJNCK077E \nError detected in ExceptionState.call()V JVMJNCK024E JNI error detected. Aborting. JVMJNCK025I Use -Xcheck:jni:nonfatal \nto continue running when errors are detected. Fatal error: JNI error (b) J9 Exception in thread main \nJNIAssertionFailure: An exception is pending in CallVoidMethod. at jinn.JNIAssertionFailure.assertFail \nat ExceptionState.call(Native Method) at ExceptionState.main(ExceptionState.java:5) Caused by: jinn.JNIAssertionFailure: \nAn exception is pending in GetMethodID. ... 3 more Caused by: java.lang.RuntimeException: checked by \nnative code at ExceptionState.foo(ExceptionState.java:9) ... 2 more (c) Jinn Figure 9. Representative \nJVM and Jinn error messages using a microbenchmark that violates the exception state constraint. these \nopen-source programs are in wide industrial and academic use with a long revision history. These case \nstudies show that Jinn .nds errors in widely-used programs. 6.4.1 Subversion Running Subversion s regression \ntest suite under Jinn, we found two over.ows of local references and one dangling local reference. Over.ow \nof local references. Jinn found that Subversion allo\u00adcated more than 16 local references in two call \nsites to JNI func\u00adtions: line 99 in Outputer.cpp and line 144 in InfoCallback.cpp. Fig\u00adure 10 compares \nthe time-series of acquired local references for the original and the .xed program. The original program \nover.ows the pool of 16 local references without requesting more capacity as detected by Jinn when acquiring \nyet another local reference. One reported source line is: jstring jreportUUID = JNIUtil::makeJString(info->repos \nUUID);  After looking at the calling context, we found that the program misses a call to DeleteLocalRef. \nWe inserted the following lines: env->DeleteLocalRef(jreportUUID); if (JNIUtil::isJavaExceptionThrown()) \nreturn NULL; After re-compiling, the program passes the regression test even under Jinn, since the number \nof active local references never ex\u00adceeds 8. This over.ow did not crash HotSpot and J9, but represents \na time bomb. A highly optimized JVM may crash if it assumes that JNI code is well-behaved and eliminates \nbound checking of the bump pointer for local references. Use of dangling local reference. The use of \na dangling local reference happens at the execution of a C++ destructor when the C++ variable path goes \nout of scope in .le CopySources.cpp. { JNIStringHolder path(jpath); env->DeleteLocalRef(jpath); } /* \nThe destructor of JNIStringHolder is executed here. */ At the declaration of path, the constructor of \nJNIStringHolder stores the JNI local reference jpath in the member variable path::m jtext. Later the \ncall DeleteLocalRef releases the jpath local reference, and thus, path::m jtext becomes dead. When the \nprogram exits from the C++ block, it calls the destructor of JNIStringHolder. Unfortunately, this destructor \nuses the dead JNI local reference: JNIStringHolder::~JNIStringHolder() {if (m jtext &#38;&#38; m str) \nm env->ReleaseStringUTFChars(m jtext, m str); } The JNI function ReleaseStringUTFChars uses the dangling \nJNI reference (m jtext). This bug is not syntactically visible to the programmer because the C++ destructor \nfeature obscures con\u00adtrol .ow when releasing resources. In our experience, this bug did not crash production \nJVMs. To understand this better, we looked at the internal implementation of ReleaseStringUTFChars in \nan open-source Java virtual machine (Jikes RVM). In Jikes RVM, ReleaseStringUTFChars ignores its .rst \nparameter, rendering the fact that the actual is a dangling reference irrelevant. If other JVMs are implemented \nsimilarly, this bug will remain hidden. But the code again represents a time bomb, because the bug will \nbe exposed as soon as the program runs on a JVM where the implementation of ReleaseStringUTFChars uses \nits .rst parameter. For example, a JVM may internally represent strings in UTF8 format as proposed by \nZilles [30] and then share them directly with JNI. 6.4.2 Java-gnome Running Java-gnome s regression \ntest suite under Jinn, we found one nullness bug and one dangling local reference. Nullness. Jinn reports \na bug identi.ed in the Blink debugger paper [17]. Note, however, that Blink requires running the Java \nprogram in a full-.edged debugger, while Jinn is a light-weight dynamic checker. Use of dangling local \nreference. Jinn reports and diagnoses bug 576111 for the Java-gnome project, which violates a con\u00adstraint \non semi-automatic resources. Jinn reports that Line 348 of binding java signal.c violates a local reference \nconstraint. (*env)->CallStaticVoidMethodA(env, bjc->receiver, bjc->method, jargs); The bjc->receiver \nis a dead local reference. A Java-gnome devel\u00adoper con.rmed the diagnosis. This bug did not crash HotSpot \nand J9, but, as noted before, bugs that are only benign due to implemen\u00ad tation characteristics of a \nspeci.c JVM vendor are time bombs and should be .xed.  6.4.3 Eclipse 3.4 We opened a Java project in \nEclipse-3.4, and Jinn reported one violation of the entity-speci.c subtyping constraint in line 698 of \ncallback.c in its SWT 3.4 component. result = (*env)->CallStaticSWT PTRMethodV(env, object, mid, vl); \nThe object must point to a Java class which has a static Java method identi.ed by mid. The actual class \ndid not have the static method, but its superclass declares the method. It is challenging for the programmer \nto ensure this constraint, because the source of the error involves dynamic callback control and a Java \ninner class. Because the production JVM may not use the object value, this bug has survived multiple \nrevisions.  6.5 Limitations While Jinn consistently detects more JNI bugs than previous work, it currently \nfalls short on three categories of bugs: (1) con\u00adstraint checking requires currently forbidden JNI functionality, \n(2) correctness is not black-and-white, and (3) checks at the lan\u00adguage boundary are insuf.cient. The \nprimary example for Cat\u00adegory 1, JNI functionality being forbidden, are the JNI critical sections discussed \nin Section 5.1, which prevent Jinn from calling IsAssignableFrom to enforce type constraints. An example \nfor Cate\u00adgory 2, correctness gray-zone, is whether or not Jinn should report C code accessing private \n.elds of Java objects. The JNI speci.ca\u00adtion is silent about this, and accessing private Java .elds from \nC is an entrenched practice. Another gray-zone example is whether or not a piece of code must be guarded \nby a monitor. After all, one person s race condition is another person s optimization. An example for \nCategory 3, checks at the language boundary being in\u00adsuf.cient, is Pitfall 8 from Table 1. JNI does no \nterminate Unicode strings with NULL characters when returning them to C. Since C code subsequently manipulates \nthe string data directly without calls through JNI functions, correctness checking at the language boundary \nas done by Jinn is insuf.cient. It instead requires check\u00ading C memory safety as performed, for instance, \nby SafeJNI [25]. Another example for Category 3 is the currently omitted dangling state of the state \nmachine for a pinned or copied string or array (see Figure 8). As before, since C code manipulates the \nstring or array directly, Jinn s language boundary checks are insuf.cient. 7. Generalization This section \ndemonstrates that our technique generalizes to other languages by applying it to Python/C 2.6 [1]. We \n.rst discuss the similarities and differences between JNI and Python/C. We then present a synthesized \ndynamic checker for Python/C s manual memory management. We leave to future work the full speci.cation \nof Python/C FFI constraints and the complete implementation of a dynamic analysis for these constraints. \n 7.1 Python/C Constraint Classi.cation Like JNI, the Python/C speci.cation describes numerous rules that \nconstrain how programmers can combine Python and C. These constraints fall into the same classes from \nSection 5: (1) interpreter state constraints, (2) type constraints, and (3) resource constraints. State \nconstraints. Python/C constrains the behavior of excep\u00adtions and threads. Python/C s exception constraints \nmirror those of JNI: C code should immediately handle the exception or prop\u00adagate it back to Python. \nWhile not explicitly stated in the man\u00adual, these constraints also imply that native code should not \ninvoke 1. static PyObject* dangle bug(PyObject* self, PyObject* args) { 2. PyObject *pythons, *.rst; \n 3. /* Create and delete a list with a string element.*/ 4. pythons = Py BuildValue( [ssssss] , 5. \nEric , Graham , John , Michael , Terry , Terry ); 6. .rst = PyList GetItem(pythons, 0); 7. printf( \n1. .rst = %s.\\n , PyString AsString(.rst)); 8. Py DECREF(pythons); 9. /* Use dangling reference. */ \n 10. printf( 2. .rst = %s.\\n , PyString AsString(.rst)); 11. /* Return ownership of the Python None \nobject. */ 12. Py INCREF(Py None); 13. return Py None; 14. }  Figure 11. Python/C dangling reference \nerror. The borrowed ref\u00aderence .rst becomes a dangling reference when pythons dies. other Python/C functions \nwhile an exception is pending. For thread constraints, Python/C differs slightly from JNI because Python \ns threading model is simpler than Java s. For each instantiation of the Python interpreter, a thread \nmust possess the Global Interpreter Lock (GIL) to execute. The Python interpreter contains a sched\u00aduler \nthat periodically acquires and releases the GIL on behalf of a program s threads. Python/C permits C \ncode to release and re-acquire the GIL around blocking I/O operations. It also permits C code to create \nits own threads and bootstrap them into Python. Because C code may manipulate thread state directly, \nthe programmer may write code that deadlocks. For example, the programmer may accidentally acquire the \nGIL twice. As a result, Python/C requires bookkeeping for the GIL similar to that for JNI critical sections \ndiscussed in Section 5.1. Type constraints. Because Python is dynamically typed, types in Python/C are \nless constrained than in JNI. The Python interpreter performs dynamic type checking for many operations \non built\u00adin types. However, sometimes the interpreter forgoes these type checks as well as some null \nchecks for performance reasons. Consequently, if a program passes a mistyped value to a Python/C call, \nthe program may crash or exhibit unde.ned behavior. A dy\u00adnamic analysis based on the type constraints \nof Section 5.2 would enable reliable detection of these errors, at the cost of reintroducing dynamic \nchecking for some Python/C functions. Resource constraints. Python employs reference counting for memory \nmanagement. To Python code, reference counting is trans\u00adparent and fully automatic. However, native-code \nprogrammers must manually increment and decrement a Python object s refer\u00adence count, according to the \nPython/C manual s instructions. To this end, the Python/C manual de.nes a notion of reference co\u00adownership. \nEach reference that co-owns an object is responsible for decrementing the object s reference count when \nit no longer needs that object. Neglecting to decrement leads to memory leaks. C code may also borrow \na reference. Borrowing a reference does not increase its reference count, but using a borrowed reference \nto a freed object is a dangling reference error. The Python/C manual speci.es which kinds of references \nare returned by the various FFI functions. A dynamic checker must track the state of these refer\u00adences \nin order to report usage violations to the user. 7.2 Synthesizing Dynamic Checkers To ensure that FFI \nprograms correctly use co-owned and bor\u00adrowed references, we implemented a use-after-release checker \nfor Python/C s reference counting memory management. Example memory management error. Figure 11 contains \nan ex\u00adample Python/C function that mismanages its references. The refer\u00adence .rst in Line 6 is borrowed \nfrom the reference pythons. When Line 8 decrements the reference count for pythons, the reference dies. \nThe Python/C manual states that the program should no longer use .rst, but the program uses this reference \nat Line 10. This use is a dangling reference error, and Python s semantics are unde.ned for such a case. \nIn practice, Figure 11 s behavior depends on whether the interpreter reuses the memory for .rst between \nthe implicit re\u00adlease in Line 8 and the explicit use in Line 10. Synthesizer and generated checker. \nOur synthesizer takes a speci.cation .le that lists which functions return new or borrowed references. \nThe generated checker detects memory management er\u00adrors by tracking co-owned references and their borrowers. \nFor ex\u00adample, the checker determines that pythons is a co-owned reference and that .rst borrows from \npythons. When a co-owner relinquishes a reference by decrementing its count, all its borrowed references \nbecome invalid. If the program uses an invalid borrowed reference, as Figure 11 does on Line 10, then \nthe checker signals an error. Interposing on language transitions. Integrating the dynamic analysis with \nPython/C is more challenging than for JNI. Python lacks an interface comparable to the JVM tools interface, \nthus re\u00adquiring that the dynamic analysis be statically linked with the inter\u00adpreter. Furthermore, Python/C \nbakes in some of the Python inter\u00adpreter s implementation details, which makes the API less portable \nthan JNI and complicates interposing on language transitions. In particular, (1) Python/C makes prevalent \nuse of C macros, (2) the Python interpreter internally uses Python/C functions, and (3) some variadic \nfunctions lack non-variadic counterparts. Python/C makes extensive use of C macros. Some macros di\u00adrectly \nmodify interpreter state without executing a function call. Because Python/C does not execute a function, \nour dynamic anal\u00adysis has nothing to interpose on and cannot track the behavior. We overcame this limitation \nby replacing the macros with equivalent functions. This change requires programmers to re-compile their \nnative code extensions against our customized interpreter, but it does not require them to change their \ncode. Because the Python interpreter internally calls Python/C func\u00adtions, the dynamic analysis cannot \neasily detect application-level language transitions. Even if it could detect such transitions, func\u00adtion \ninterposition and transition detection would signi.cantly slow down the interpreter. We overcame this \nlimitation by creating an interpreter-only copy of every Python/C function. We then used au\u00adtomatic code-rewriting \nto make the interpreter call the unmodi.ed copies. Our dynamic analysis interposes on the originals, \nwhich are used by native code extensions. A variadic C function such as printf takes a variable number \nof arguments. Our synthesizer interposes on each variadic function by wrapping it with code that calls \nan equivalent, non-variadic ver\u00adsion of the function such as vprintf. Python does not provide non\u00advariadic \nequivalents for all its variadic functions; where necessary, we added the non-variadic equivalents. Despite \nthese implementation challenges, our Python/C dy\u00adnamic analysis substantially follows from our JNI dynamic \nanaly\u00adsis, thus demonstrating the generality of our approach. Both FFIs have large numbers of constraints \nthat fall into three classes. Both FFIs also support specifying the constraints as state machines, map\u00adping \nstate machine transitions to language transitions, and then applying the state machines to program entities. \n8. Conclusion This paper seeks to improve the correctness of multilingual pro\u00adgrams using thorough FFI \nspeci.cation and dynamic analysis. We identify three classes of FFI constraints and shows how to encode \nthem in about a dozen state machines. The three classes capture the key semantic mismatches that multilingual \ninterfaces must negoti\u00adate. The state machines, in turn, capture the complete constraints for correctly \nusing such interfaces. We also show how to use syn\u00adthesis for mapping the state machine speci.cations \ninto context\u00adsensitive dynamic bug checkers inserted a language transitions. No\u00adtably, we generate dynamic \nbug checkers for JNI and Python/C. We show that Jinn, the synthesized bug checker for JNI, uncovers previously \nunknown bugs in widely-used Java native libraries. Our approach to multilingual constraint representation, \nconstraint gen\u00aderation, and FFI usage veri.cation is the most concise, practical, and effective on to \ndate. Acknowledgments We thank our shepherd Alex Aiken and the anonymous reviewers for their feedback \non this paper. We thank Mike Bond for feed\u00adback on the text and his suggestion of wrapping Python/C macros, \nJungwoo Ha for explaining some details of hardware performance counter libraries, and Jennifer Sartor \nfor referring to Accordion Ar\u00adrays. This work is supported by NSF CNS-0448349, NSF CNS\u00ad0615129, NSF SHF-0910818, \nNSF CSR-0917191, NSF CCF\u00ad0811524, NSF CNS-0719966, NSF CCF-0448128, NSF CCF\u00ad0724979, Samsung Foundation \nof Culture, and CISCO. Any opin\u00adions, .ndings, and conclusions expressed herein are the authors and do \nnot necessarily re.ect those of the sponsors. References [1] Python/C API reference manual. Python Software \nFoundation, http: //docs.python.org/c-api, Nov. 2009. [2] C. Allan, P. Avgustinov, A. S. Christensen, \nL. Hendren, S. Kuzins, O. Lhot\u00b4ak, O. de Moor, D. Sereni, G. Sittampalam, and J. Tibble. Adding trace \nmatching with free variables to AspectJ. In ACM Conference on Object-Oriented Programming Systems, Languages, \nand Applications (OOPSLA), pages 345 364, 2005. [3] M. Arnold, M. Vechev, and E. Yahav. QVM: An ef.cient \nruntime for detecting defects in deployed systems. In ACM Conference on Object-Oriented Programming, \nSystems, Languages, and Applica\u00adtions (OOPSLA), pages 143 162, 2008. [4] T. Ball and S. K. Rajamani. \nSLIC: a specifcation language for inter\u00adface checking (of C). Technical Report MSR-TR-2001-21, Microsoft \nResearch, Jan. 2002. [5] D. M. Beazley. SWIG: An easy to use tool for integrating scripting languages \nwith C and C++. In USENIX Tcl/Tk Workshop (TCLTK), pages 129 139, 1996. [6] S. M. Blackburn, R. Garner, \nC. Hoffmann, A. M. Khang, K. S. McKinley, R. Bentzur, A. Diwan, D. Feinberg, D. Frampton, S. Z. Guyer, \nM. Hirzel, A. Hosking, M. Jump, H. Lee, J. E. B. Moss, B. Moss, A. Phansalkar, D. Stefanovi\u00b4c, T. VanDrunen, \nD. von Dincklage, and B. Wiedermann. The DaCapo benchmarks: Java benchmarking development and analysis. \nIn ACM Conference on Object-Oriented Programming, Systems, Languages, and Applica\u00adtions (OOPSLA), pages \n169 190, 2006. [7] F. Chen and G. Rosu. MOP: An ef.cient and generic runtime ver\u00adi.cation framework. \nIn ACM Conference on Object-Oriented Pro\u00adgramming, Systems, Languages, and Applications (OOPSLA), pages \n569 588, 2007. [8] M. B. Dwyer, G. S. Avrunin, and J. C. Corbett. Patterns in property speci.cations \nfor .nite-state veri.cation. In ACM International Con\u00adference on Software Engineering (ICSE), pages 411 \n420, 1999. [9] D. Engler, B. Chelf, A. Chou, and S. Hallem. Checking system rules using system-speci.c, \nprogrammer-written compiler extensions. In USENIX Symposium on Operating Systems Design and Implementa\u00adtion \n(OSDI), pages 1 16, Oct. 2000.  [10] M. Furr and J. S. Foster. Checking type safety of foreign function \ncalls. In ACM Conference on Programming Language Design and Implementation (PLDI), pages 62 72, 2005. \n[11] M. Furr and J. S. Foster. Polymorphic type inference for the JNI. In European Symposium on Programming \n(ESOP), pages 309 324, 2006. [12] J. Gosling, B. Joy, G. Steele, and G. Bracha. The Java Language Speci.cation. \nAddison-Wesley, third edition, June 2005. [13] M. Hirzel and R. Grimm. Jeannie: Granting Java native \ninterface de\u00advelopers their wishes. In ACM Conference on Object-Oriented Pro\u00adgramming, Systems, Languages, \nand Applications (OOPSLA), pages 19 38, 2007. [14] A. Kaplan, J. Bubba, and J. C. Wileden. The Exu approach \nto safe, transparent and lightweight interoperability. In IEEE International Computer Software and Applications \nConference (COMPSAC), page 393, 2001. [15] B. W. Kernighan and D. M. Ritchie. The C Programming Language. \nPrentice Hall, second edition, Apr. 1988. [16] G. Kondoh and T. Onodera. Finding bugs in Java native \ninterface programs. In ACM International Symposium on Software Testing and Analysis (ISSTA), pages 109 \n118, 2008. [17] B. Lee, M. Hirzel, R. Grimm, and K. S. McKinley. Debug all your code: Portable mixed-environment \ndebugging. In ACM Conference on Object-Oriented Programming, Systems, Languages, and Applica\u00adtions (OOPSLA), \npages 207 226, 2009. [18] S. Li and G. Tan. Finding bugs in exceptional situations of JNI programs. In \nACM Conference on Computer and Communications Security (CCS), pages 442 452, 2009. [19] S. Liang. The \nJava Native Interface: Programmer s Guide and Spec\u00adi.cation. Addison-Wesley, 1999. [20] NaturalBridge. \nBulletTrain JNI Checking Examples. http:// web.archive.org/web/*/http:///www.naturalbridge.com/ jnichecking.html, \nJan. 2001. [21] G. C. Necula, S. McPeak, and W. Weimer. CCured: Type-safe retro.tting of legacy code. \nIn ACM Symposium on Principles of Programming Languages (POPL), pages 128 139, 2002. [22] T. Ravitch, \nS. Jackson, E. Aderhold, and B. Liblit. Automatic gener\u00adation of library bindings using static analysis. \nIn ACM Conference on Programming Language Design and Implementation (PLDI), pages 352 362, 2009. [23] \nStandard Performance Evaluation Corporation. SPECjvm98 Docu\u00admentation, release 1.03 edition, March 1999. \n[24] B. Stroustrup. The C++ Programming Language. Addison-Wesley, special edition, Feb. 2000. [25] G. \nTan, A. W. Appel, S. Chakradhar, A. Raghunathan, S. Ravi, and D. Wang. Safe Java native interface. In \nIEEE International Sympo\u00adsium on Secure Software Engineering (ISSSE), pages 97 106, 2006. [26] G. Tan \nand J. Croft. An empirical security study of the native code in the JDK. In Usenix Security Symposium \n(SS), pages 365 377, 2008. [27] G. Tan and G. Morrisett. ILEA: Inter-language analysis across Java and \nC. In ACM Conference on Object-Oriented Programming Systems and Applications (OOPSLA), pages 39 56, 2007. \n[28] Z. Tatlock, C. Tucker, D. Shuffelton, R. Jhala, and S. Lerner. Deep typechecking and refactoring. \nIn ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOP-SLA), pages \n37 52, 2008. [29] The GNOME Project. GNOME bug tracking system. Bug 576111 was opened 2009-03-20. http://bugzilla.gnome.org. \n[30] C. Zilles. Accordion arrays: Selective compression of unicode arrays in Java. In ACM International \nSymposium on Memory Management (ISMM), pages 55 66, 2007.    \n\t\t\t", "proc_id": "1806596", "abstract": "<p>Programming language specifications mandate static and dynamic analyses to preclude syntactic and semantic errors. Although individual languages are usually well-specified, composing languages is not, and this poor specification is a source of many errors in <i>multilingual </i>programs. For example, virtually all Java programs compose Java and C using the Java Native Interface (JNI). Since JNI is informally specified, developers have difficulty using it correctly, and current Java compilers and virtual machines (VMs) inconsistently check only a subset of JNI constraints.</p> <p>This paper's most significant contribution is to show how to synthesize dynamic analyses from state machines to detect foreign function interface (FFI) violations. We identify three classes of FFI constraints encoded by eleven state machines that capture thousands of JNI and Python/C FFI rules. We use a mapping function to specify which state machines, transitions, and program entities (threads, objects, references) to check at each FFI call and return. From this function, we synthesize a context-specific dynamic analysis to find FFI bugs. We build bug detection tools for JNI and Python/C using this approach. For JNI, we dynamically and transparently interpose the analysis on Java and C language transitions through the JVM tools interface. The resulting tool, called Jinn, is compiler and virtual machine <i>independent</i>. It detects and diagnoses a wide variety of FFI bugs that other tools miss. This approach greatly reduces the annotation burden by exploiting common FFI constraints: whereas the generated Jinn code is 22,000+ lines, we wrote only 1,400 lines of state machine and mapping code. Overall, this paper lays the foundation for a more principled approach to developing correct multilingual software and a more concise and automated approach to FFI specification.</p>", "authors": [{"name": "Byeongcheol Lee", "author_profile_id": "81444600875", "affiliation": "University of Texas at Austin, Austin, USA", "person_id": "P2184494", "email_address": "", "orcid_id": ""}, {"name": "Ben Wiedermann", "author_profile_id": "81322510080", "affiliation": "University of Texas at Austin, Austin, USA", "person_id": "P2184495", "email_address": "", "orcid_id": ""}, {"name": "Martin Hirzel", "author_profile_id": "81100572340", "affiliation": "IBM Watson Research Center, Hawthorne, USA", "person_id": "P2184496", "email_address": "", "orcid_id": ""}, {"name": "Robert Grimm", "author_profile_id": "81100553777", "affiliation": "New York University, New York, USA", "person_id": "P2184497", "email_address": "", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "University of Texas at Austin, Austin, USA", "person_id": "P2184498", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1806596.1806601", "year": "2010", "article_id": "1806601", "conference": "PLDI", "title": "Jinn: synthesizing dynamic bug detectors for foreign language interfaces", "url": "http://dl.acm.org/citation.cfm?id=1806601"}