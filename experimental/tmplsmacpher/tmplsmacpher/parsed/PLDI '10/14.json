{"article_publication_date": "06-05-2010", "fulltext": "\n Detecting Inef.ciently-Used Containers to Avoid Bloat GuoqingXu AtanasRountev OhioStateUniversity \n{xug,rountev}@cse.ohio-state.edu Abstract Runtimebloatdegrades signi.cantlytheperformance andscalabil\u00adity \nof software systems. An important source of bloat is the inef.\u00adcient use of containers. It is expensive \nto create inef.ciently-used containers and toinvoke their associated methods, as this may ulti\u00admately \nexecutelarge volumes of code, with call stacksdozensdeep, and allocate many temporary objects. This paper \npresents practical static and dynamic tools that can .ndinappropriate use of containersinJavaprograms.Atthe \ncore of thesetoolsis abase staticanalysisthatidenti.es,for eachcontainer, the objects that are added \nto this container and the key statements (i.e.,heaploads and stores) that achieve the semantics of common \ncontainer operations such as ADD and GET. The static tool .nds problematic uses of containersby considering \nthe nesting relation\u00adships among theloops where these semantics-achieving statements arelocated, whilethedynamictool \ncaninstrumentthese statements and .ndinef.cienciesbypro.ling theirexecutionfrequencies. Thehighprecision \nofthebase analysisis achievedbytakingad\u00advantage of a context-free language(CFL)-reachabilityformulation \nofpoints-to analysis andby accountingfor container-speci.cprop\u00aderties.Itisdemand-driven and client-driven,facilitating \nre.nement speci.c to eachqueried container object andincreasing scalability. The tools built with the \nhelp of this analysis can be used both to avoid the creation of container-relatedperformanceproblems \nearly during development, and to help with diagnosis when problems are observedduring tuning.Our experimental \nresults show that the statictoolhasalowfalsepositiverateandproduces morerelevant information thanitsdynamic \ncounterpart.Further case studies sug\u00adgest thatsigni.cant optimization opportunities canbefoundbyfo\u00adcusing \non statically-identi.ed containers for which high allocation frequencyis observed at run time. Categories \nand Subject Descriptors F.3.2[Logics and Meaning of Programs]: Semantics of Programming Languages Program \nanalysis; D.3.4[ProgrammingLanguages]:Processors Memory management, optimization; D.2.5 [Software Engineering]: \nTest\u00ading andDebugging Debugging aids GeneralTerms Algorithms,Languages,Performance Keywords Containerbloat,CFLreachability,points-to \nanalysis Permission to make digital or hard copies of all or part of this work for personal or classroomuseisgranted \nwithoutfeeprovided that copiesarenot madeordistributed forpro.tor commercial advantage andthat copiesbearthis \nnotice andthefull citation onthe .rstpage.Tocopy otherwise,torepublish,topostonserversortoredistribute \ntolists, requiresprior speci.cpermission and/or afee. PLDI 10, June5 10,2010,Toronto,Ontario,Canada. \nCopyright c . 2010 ACM 978-1-4503-0019-3/10/06... $10.00 1. Introduction While Java developers need not \nworry about memory correctness issues, it remains challenging for them to ef.ciently use memory. Asaresult,memorybloat[22,23,26,35,42]commonly \nexistsin large-scale Java applications. Evidence has been found that bloat has signi.cantimpactonperformance,leading \nto reduced scalabil\u00adityand usability[22]. The inef.cient use of containers is an important source of \nsys\u00adtemicbloat.Programminglanguages such asJavainclude a collec\u00adtionframework whichprovides abstractdata \ntypesfor representing groups of relateddataobjects(e.g.,lists,sets,andmaps).Based on this collectionframework, \none can easily construct application\u00adspeci.c container types such as trees and graphs. Real-world pro\u00adgrams \nmake extensive use of containers, both through collection classes and through user-de.ned container types. \nProgrammers al\u00adlocate containers in thousands of code locations, using them in a variety of ways, such \nas storing data, implementing unsupported languagefeatures such as returning multiple values, wrappingdata \ninAPIs toprovidegeneral servicefor multiple clients, etc. Containers are easy to misuse. A memory leak \ncould occur if objects added to a container are not removed after they are no longer used[3,4,15,44].Anotherproblematic \nsituationis when a container, while not strictly necessary for what it is supposed to accomplish, is \nused nevertheless. Although most such containers are eventually garbage-collected and allocating them \nmay not lead to OutOfMemory errors, they canhave conspicuous impact onper\u00adformance.Forexample,as reportedin[42], \n.ndingand specializing inef.ciently-usedHashMapcan reducethe number of allocated ob\u00adjectsin a server \napplicationbymore thanhalf.Identifying contain\u00aders that consume excessive resources(for what they accomplish)is \nan important step toward .nding potential container-related opti\u00admization opportunities. Motivation andproblems \nThe extensive use ofcontainersinJava software makes it impossible to manually inspect the choice and \nthe use of each container in the program. Dynamic analysis has typically been the weapon of choice for \ndetecting memory leaks and bloat in real-world Java software. A dynamic bloat detector .ndsperformanceproblemsusing \na from-symptom-to-cause ap\u00adproach: it starts by observing suspicious behaviors and then at\u00adtempts tolocate \nthe causefrom the observed symptom.Onefunda\u00admentalproblemfor such approaches is the selection of appropriate \nsymptoms.Itcanbe extremelydif.culttode.ne symptomsthat can precisely capture the target bloat in many \ncases, the suspicious behaviors that the tool intends to capture are not unique charac\u00adteristics for \nthe problematic program entities. Very often, they can also be observed from entities that function appropriately, \nleading tofalsepositivesandimprecisereports.The .rst researchproblem investigated in this paper is whether \nit is possible to alleviate this limitation of purely dynamic bloat analyses by using a static or a hybrid \ntechnique. A static(or ahybrid static/dynamic) technique  class CUP$LexParse$actions { RegExp makeNL(){ \nVector list = new Vector(); list.addElement(new Interval( \\n , \\r )); list.addElement(new Interval( \\u0085 \n, \\u0085 )); list.addElement(new Interval( \\u2028 , \\u2029 )); RegExp1 c = new RegExp1(sym.CCLASS, list); \n... } } (a) class Httpd extends HttpConnection{ Reply recvReply(Request request){ if (request.getPath().equals(\"/admin/enable\")){ \nHashtable attrs = cgi(request); String config = (String) attrs.get(\"config\"); String filter = (String) \nattrs.get(\"filter\"); ... }else if(request.getPath().equals(\"/admin/createConfig\")){ Hashtable attrs \n= cgi(request); String config = (String) attrs.get(\"config\"); ... } ... } Hashtable cgi(Request request){ \n Hashtable attrs = new Hashtable(13); String query = request.getQueryString(); String data = request.getData(); \nif (query != null){  StringTokenizer st = new StringTokenizer(decode(query), \"&#38;\"); while (st.hasMoreTokens()){ \nString token = st.nextToken(); String key = token.substring(0, token.indexOf( = )); String value = token.substring(token.indexOf( \n= ) + 1); attrs.put(key, value); } } ... return attrs; } } (b) Figure1. (a)An example ofan underutilized \ncontainer, extracted from program JFlex, a scanner generator for Java. Vector list is used only to pass \nthe three Interval objects to the constructor of RegExpr1;(b) An example of an overpopulated container, \nex\u00adtracted from program Muf.n, a WWW .ltering system written in Java. Given a request, method cgi always \ndecodes the entire re\u00adquest string into Hashtable attrs. However, this HashMap is later subjected to \nat most twolookup operations. maybe able to reducefalsepositivesby exploiting certainprogram propertiesinherentin \nthe source code. The second major problem addressed in the paper is related to understanding the semantics \nof containers. Of existing dynamic bloatdetection techniques, toolsfrom[44]and[35]weredesigned speci.cally \nfor .nding container-related problems. Both tools re\u00adquirethe usertoprovide annotationsfor eachcontainertype, \nwhich are subsequently used to understand the container semantics and relate container behavior to the \npro.ling frameworks. However, it maybe aheavyburdenfortheprogrammerto completethese anno\u00adtations. In \naddition, when the interface of a container changes, its annotationshave tobe revised as well.Creating \nsuch annotationsis alsoimpractical whenthe containertypes comefromlargelibraries andframeworksdevelopedby \nothers(e.g., containers of transac\u00adtion data in enterprise applications). To reduce such an annotation \nburden and make the container analysis more general, the paper explores the possibility of extracting \nthe container semantics au\u00adtomatically from the container implementation, with minimal need for userinteraction. \nTargeted container inef.ciencies We aim to detect containers that areinef.ciently usedin thefollowing \ntwo ways: Underutilized container. A container is underutilized if it holds a very small number of elements \nduring its lifetime. It is wasteful to use an underutilized container to hold data. First, a container \nis usually created with a default number of slots(e.g.,16), and abigportion ofthe memory spaceis wasted \nif only a few slots are occupied. If the size of the con\u00adtainer is .xed (e.g., 1), a specialized container \ntype such as Collections.singletonSet canbe employed to replace the originalgeneral type(e.g., HashSet).Second, \nthefunctionality associated with the container type may be much more general than what is actually needed. \nFor example, the process of re\u00adtrieving an element from a HashSet involves dozens of calls. If thereis \na small number of objectsin the HashSet, it may be possible for a performance expert to replace this \nHashSet by introducing extralocal variables,parameters, or an array. Figure 1(a) illustrates an example \nof this type of problem, which was reportedby our tool.The exampleis extractedfrom JFlex, a scanner generator \nfrom our benchmark set. Method makeNL creates a Vector objectthatbydefault allocatesa10\u00adelement array. \nThe only purpose of this object is to pass the three Interval objectsinto the constructor of RegExpr1.This \nVector object is allocated more than 10,000 times during the execution of a large test case. In fact, \nthere are many locations in the code where Vector objects are created solely for this purpose. Creating \nspecialized constructors of RegExpr1 that allow the direct passing of Interval objects can avoid the \nallocation/deallocation of thousands of objects.  Overpopulated container. This problem occurs if there \nis a container that, whileholding many objects,islooked up only a fewtimes.Dueto unnecessarydata elements,memoryis \nwasted andittakeslongertoperform a container operation.Inthis case, a programmer may be able to inspect \nthe code to .nd which objects will de.nitely not be retrieved from the container, and then .nd a way \nto avoid adding these objects or even creating them(if they are never used).Figure 1(b) shows an example \nof this problem, which was found by our analysis in Muf.n,a WWW .ltering system from our benchmark set. \nMany strings aregenerated and addedinto a Hashtable,but only the entries with keys \"config\" and \"filter\" \nare eventually requested. Instead of decoding and bookkeeping the entire request string, a specialized \nversion of method cgi coulddeclare an additional stringparameter representing the requestedkey, and returnthe \ncorresponding valueimmediately when thegivenkeyisfound.  Base static analysis: extracting container \nsemantics There are three majortechnicalchallengesinautomatically extracting seman\u00adtics for different \ncontainer types and implementations. The .rst challenge is to establish a uni.ed model for different \ncontainer types.For example,considertwo concrete container classesinJava, Hashtable and LinkedList. The \nuni.ed model has to capture the common behaviors that characterize their container property whileignoringthedifferencesintheir \nspeci.cimplementations and usage domains. To address this challenge, we propose to treat all container \nclasses as an abstractdatatype withtwobasic operations: ADD and GET.Consider Hashtable and LinkedList \nagain: de\u00adspite their many differences, we are interested only in the process by which objects are added \nto (ADD) and retrieved from (GET) these containers.Detailsof theirimplementations and usage(e.g., whether \nthey store key-value pairs or individual objects) are ab\u00adstracted away. The second challenge is to select \nprogram entities that corre\u00adspond to these abstract operations. Researchfrom[35,44]focuses on methods. \nFor example, methods put and get implement the semantics of ADD and GET, respectively, for class Hashtable. \nWhile identifying abstract operations at the method level is a straightforward idea, it is impossible \nto perform without user an\u00adnotations because different container types use different methods for these \noperations.To automate thisprocess, wepropose to oper\u00adate at the statement level.The keyinsight is that \nthe core behavior of each operation can be implemented by a single statement. The statements that implement \nthe ADD and GET operations are usu\u00adally heap stores and loads, respectively. Such statements will be \nreferred to semantics-achieving statements. For example, for class ArrayList, the statement achieving \nthe functionality of ADD is a heap store array[i] = o in method ArrayList.add, where array refers to \nthe backing array of the list and o is a formal pa\u00adrameter referring to the object1 tobe added.Identifying \nsemantics\u00adachieving statements bridges the gap between the low-level code analysis and thehigh-level \ncontainer semantics.  The third challenge is to develop precise and ef.cient al\u00adgorithms to discover \ncontainer structures. The identi.cation of semantics-achieving statements for a particular container \nobject requires reasoning about the container data structure, in order to detect the objects that are \nadded to the container from the client code(i.e., element objects) as well as the helper objects that \nare created by the container (i.e., inside objects). There are usually multiplelayersin thedata structure \nof a container type, and a naive approachbased onpoints-to analysis may notbe abletodistinguish among \nelements added to different container objects that have the same type. To obtain precise information \nabout the use of a con\u00adtainer, it is crucial to prune, context-sensitively, nodes and edges irrelevant \nto the containerin thepoints-tograph.Whilethere exists abody ofprecise reasoning techniques such as shape \nanalysis(e.g., [6,7,34])anddecisionproceduresfor veri.cation ofpointer-based data structures(e.g.,[17,20]), \nthese analyses tendto be expensive anddo not scale well tolarge applications. Our analysis attempts to \nre.ne the object sub-graph rooted at each container object by taking advantage of the CFL-reachability \nformulation of pointer aliasing. The key observation is that if an object o can be reached from a container \nobject c through(direct or transitive) .eld dereferences, there must exist a chain of stores of the form \na0 .f0 = o;a1 .f1 = b0 ;a2 .f2 = b1 ;... ;an.fn = bn-1 ;bn = c, such that the two reference variables \nin each pair (ai,bi)for 0 = i = n are aliases. Because aliasing relationships canbecomputedby solvingCFL-reachability \nona .owgraph[37], thegoal of ouranalysisisto .nd validpaths(intermsofbothheap accesses and method calls) \non the .ow graph that contain such chains of stores. We consider all objects o that have such paths reaching \nthe container object and that are notinside objects created by the container. Among those, element objects \nare the ones that have a chain of stores a0 .f0 = o;a1 .f1 = b0 ;... such that all ai and bi along the \nchain point to inside objects of the container. We have successfullyapplied thisdemand-driven analysistolargeJava \napplications, including the eclipse framework(and its plugins). Thedescription of the analysis canbefoundinSection \n2. Static inference and dynamic pro.ling of execution frequencies If the ADD operations of a container \nare executed a very small number of times,the container may sufferfrom an underutilization problem. If \nthe frequency of its GET operations is much smaller than the frequency of its ADD operations, the container \nmay be overpopulated. The next step of the analysis is to compare the fre\u00adquencies of these operations, \nusing the semantics-achieving state\u00adments(annotated withthe relevant calling contexts) identi.edby thebase \nanalysis. 1From now on we will use object to denote the static abstraction (i.e., allocation site) of \na set of run-time objects created by the allocation site. Anaturalchoicefor comparingthefrequencies ofthe \nsemantics\u00adachieving statements is to instrument these statements and to de\u00advelop a dynamic analysis by \npro.ling the observed frequencies. However, the usefulness of this approach may be limited because it \ndoes not directly point to the underlying cause of the problem. Furthermore, the generated results depend \ncompletely on the spe\u00adci.c inputs and runs being observed: containers whose behaviors are suspicious \nin one particular run may behave appropriately in other runs, makingithard toidentifyproblematic containers. \nAn alternative is to design a static analysis that detects perfor\u00admanceproblems bylooking for certain \nsource codeproperties that can approximate the relationship between execution frequencies, regardless \nof inputs and runs. There exist a number of analyses that can be employed to infer such a relationship. \nFor example, semantics-achieving statements are often nested in loops. Various techniques such asinterval \nanalysis[40]and symbolicbound anal\u00adysis[11,12]maybe usedtodiscovertheloopbounds.However, suchtechniques \nare oftenineffectiveinhandlingdynamicheapdata structures, and it is dif.cult to scale them to large programs. \nWe takeamuch simplerapproach wheredata .owdoesnot need tobe considered: relative frequencies are inferred \nbased on the nesting of theloopswherethesemantics-achieving statementsarelocated. Despite this simplicity, \nthe inferred relationships are execution in\u00addependent and, in our experience, lead to low false positive \nrates when used to .nd optimizable containers. We have implemented both the dynamic frequency pro.ler \n(Section 3.1)andthestaticinference analysis(Section 3.2).De\u00adtailed comparison between them is provided \nin Section 3.2 and demonstrated experimentallyinSection 4. Featuresof thebase analysis Thebase analysis \nneeds tobe suf\u00ad.cientlyprecise, as both the static inference algorithm and the dy\u00adnamic frequency pro.ler \nrely on it to .nd problematic containers. Our algorithmic design is focused on three important features \nof the analysis. First, since we are interested only in containers, the algorithm is demand-driven, so \nthat it can perform only the work necessary to answer queries about the usage of containers. Sec\u00adond,because \na container type canbeinstantiated many timesinthe program, failure to distinguish elements added into \ndifferent con\u00adtainer objects of the same type could result in a large number of false positives. To avoid \nthis, if the analysis cannot .nd a highly\u00adprecise solution under a client-de.ned time budget, it does \nnot re\u00adportany ADDand GET operations(instead of reportingthembased on over-conservative approximations).In \napractical tool thatiden\u00adti.espotentialbloat, thepreciseidenti.cation ofinef.ciently-used containers(i.e.,reducing \nthefalsepositive rate)ismuch moreim\u00adportant than reporting all potentially problematic ones with many \nfalse warnings(i.e., reducing thefalse negative rate).This choice aims athigherprogrammerproductivity \nand real-world usefulness. Finally, the analysis is client-driven, as the amount of information itproduces \ncanbe controlledby the client-de.ned timebudget. Evaluation Section 4presentsexperimental resultsshowing \nthat the static tool successfully .nds inef.cient uses of containers. It generates a total of 295 warnings \nfor the 21 Java programs in our benchmark set. For each benchmark, we randomly picked 20 warnings for \nmanual inspection. Among those, we found a very small number offalsepositives(e.g.,4forthelargestbenchmark \neclipse).Further experiments showed that(1) most of the stat\u00adically reported containers indeed exhibit \nproblematic behaviors at runtime,and(2) theinef.cient uses of these containers are much easier to understand \nthan the uses of containers reportedby thedy\u00adnamic analysis. The static inference approach is useful \nfor detecting container problems during coding, before performance tuning has started. It isagoodprogrammingpracticeto \n.x(static) performancewarn\u00ad  1 class ContainerClient{ 2 static void main(String[] args){ 3 ContainerClient \nclient = new ContainerClient(); 4 Container c = new Container(); 5 for(int i = 0; i < 1000; i++){ 6 client.addElement(c, \nnew Integer(i)); 7} 8 client.foo(c); 9 client.bar(); 10 } 11 void foo(Container n){ 12 Integer i = (Integer)n.get(10); \n13 Container d = new Container(); 14 addElement(d, new String(\"first\")); 15 addElement(d, new String(\"second\")); \n16 String s = (String)d.get(0); 17 } 18 void bar(){ 19 for(int j = 0; j < 5; j++){ 20 Container a = new \nContainer(); 21 for(int i = 0; i < 10; i++) 22 addElement(a, new Double(i)); 23 for(int i = 0; i < a.size(); \ni++){ 24 Double b = (Double)a.get(i); 25 ... 26 } 27 } 28 } 29 void addElement(Container c, Object e){ \n30 c.add(e); 31 } 32 } 33 34 class Container{ 35 Object[] arr; 36 int pos =0; 37 Container(){ 38 t = \nnew Object[1000]; this.arr = t; 39 } 40 void add(Object e){ 41 t = this.arr; t[pos++] = e; 42 } 43 Object \nget(int index){ 44 t = this.arr; ret = t[index]; return ret; 45 } 46 } Figure2. Running example. ings \nearly,in order to avoidpotentialperformanceproblemsbefore they pile up and become observable. It has \nalready been recog\u00adnized [22] that bloat can easily accumulate when insuf.cient at\u00adtention is paid to \nperformance during development. Once coding is complete and performance tuning starts, information about \nrun\u00adtimefrequency of container allocation canfocus theprogrammer s attention on statically-identi.ed \ncontainers that are most likely to provide optimizationpayoffs.2 Usingthis approach, we studied the warningsfortheDaCapo \nbloat andchart benchmarks, andeasily identi.ed.xesthatreducedobject creationratesby30%for bloat and5%for \nchart,leadingtoexecutiontime reduction of24.5%for bloat and 3.5% for chart. These promising initial .ndings \nsug\u00adgest that our tools could be useful in practice to .nd and exploit opportunitiesforperformancegains. \n2. FormulationofContainerOperations This section starts with an outline of the CFL-reachability formu\u00adlation \nof context-sensitive points-to/alias analysis for Java [37]. We formulate the base analysis for identi.cation \nof semantics\u00adachieving statements as a newCFL-reachabilityproblem, and then presentalgorithms to solve \nthisproblem. 2Allocation frequencies can even be collected before the static analysis, allowing thedemand-driven \nstaticalgorithmtofocusonhot containers. 2.1 CFL-ReachabilityFormulationofPoints-toAnalysis A variety \nof program analyses can be stated as CFL-reachability problems[30].CFL-reachabilityisanextension ofstandardgraph \nreachabilitythat allowsfor .lteringof uninterestingpaths.Givena directed graph with labeled edges, a \nrelation R over graph nodes can be formulated as a CFL-reachability problem by de.ning a context-freegrammar \nsuch thatapairof nodes (n,n ' ). R if and only if there exists a path from n to n ' for which the sequence \nof edge labels along the path is a word in the language L de.ned by the grammar. Such a path will be \nreferred to as an L path. If there exists an L path from n to n ' , then n ' is L-reachable from n (denoted \nby nL n ' ). For anynon-terminal S in L s grammar, S paths and nS n ' arede.ned similarly. Existing work \nonpoints-to analysisforJava[37,39]employs this formulation to model (1) context sensitivity via method \nen\u00adtries and exits, and (2) heap accesses via object .eld reads and writes. A demand-driven analysis \nis formulated as a single-source L-reachability problem which determines all nodes n ' such that nL n \n' for a given source node n. The analysis can be expressed by CFL-reachability for language LF n RC. \nLanguage LF , where F standsfor .ows-to ,ensuresprecisehandling of.eld accesses. RegularlanguageRC ensures \nadegree ofcallingcontextsensitivity. Bothlanguages encode balanced-parenthesesproperties. LF -reachability \nis performed on a graph representation G of a Java program (sometimes referred to as a .ow graph), such \nthat if a heap object represented by the abstract location o can .ow to variable v during the execution \nof the program, there exists an LF path in G from o to v. The .ow graph is constructed by creating edges \nfor the following canonical statements: an edge newassign o - . x is created for an allocation x = new \nO; an edge y ---. store(f) x is created for an assignment x = y; edges y - --. x and load(f) y - --. \nx arecreatedfora .eldwrite x.f = yanda .eldreadx = y.f,respectively.Parameterpassing isrepresented asassignments \nfrom actuals toformals;method return values are treatedsimilarly. Writes and reads of array elements \nare handled by collapsing all elementsintoanarti.cial.eldarr elm. Language LF Consider a simpli.ed .ow \ngraph G with only new and assign edges. In this case the language is regular and its grammar can be written \nsimply as .owsTo . new (assign )* , which shows the transitive .ow due to assign edges. Clearly, o .owsTo \nv inGmeans that o belongs to thepoints-to setof v. For .eldaccesses,inverseedgesareintroducedtoallowaCFL\u00adreachability \nformulation.For eachgraph edge x . y labeled with t, an edge y . x labeled with t is introduced. For \nany path p, \u00afan inverse path p\u00afcan be constructed by reversing the order of edgesin pandreplacingeachedge \nwithitsinverse.Inthegrammar this is captured by a new non-terminal .owsTo used to represent the inverse \npaths for .owsTo paths. For example, if there exists a .owsTo path from object o to variable v, there \nalso exists a .owsTo pathfromv to o. May-alias relationships can be modeled by de.ning a non\u00adterminal \nalias such that alias . .owsTo .owsTo. Two vari\u00adables a and b may alias if there exists an object o such \nthat o can .ow toboth a and b.The .eld-sensitivepoints-torelationshipscan be modeledby.owsTo . new (assign \n|store(f)alias load(f))* . This production checks for balanced pairs of store(f)and load(f) operations, \ntaking into account the potential aliasing between the variables through which the store and theload \noccur. Language RC The context sensitivity of the analysis ensures that method entries and exits are \nbalanced parentheses: C . entry(i)C exit(i)|CC|o. Here entry(i)and exit(i)correspond to the i-th call \nsiteintheprogram.Thisproductiondescribes only asubsetof thelanguage, whereallparentheses arefullybalanced. \n doa  . . . . . . ..  . . . . . . . .. . .. . .. .. . . . .... . . .. . . .    ret    \n this this t t e oe oothisn oo bi t c o s Figure3. Flowgraphfor the running example. Since a realizable \npath does not need to start and end in the same method, the full de.nition of RC also allows a pre.x \nwith unbal\u00adanced closedparentheses and a suf.x withunbalanced openparen\u00adtheses[37].Inthe absence ofrecursion,thebalanced-parentheses \nlanguageisa .niteregularlanguage(thusthenotation RC instead of LC );approximations are introduced as \nnecessary to handle re\u00adcursive calls.Context sensitivityis achievedbyconsidering entries and exits along \na LF path and ensuring that the resulting string is in RC .For the purposes of this context-sensitivity \ncheck, an entry edgeis treated as an exit edge and vice versa. 2.2 Example The code in Figure 2 shows \nan example used for illustration of the static analysis throughout thepaper.The exampleisbased on a common \nusage scenario of Java containers. A simple implemen\u00adtation of a data structure Container is instantiated \nthree times (at lines 4, 13 and 20) by a client ContainerClient. In the ex\u00adample code, statement t[pos++] \n= e (at line 41) is the one that achievesthefunctionalityofADD, andstatement ret = t[index](at line 44)is \nthe one achieving the functionality of GET. Of course, thesestatementsdonot make much senseby themselves.Foreach \nsemantics-achieving statement, we also need toidentifythe calling contextsthatarerelevanttothecontainer \nofinterest.The(state\u00adment,contexts)pairisusedlaterto .nd underutilized and overpop\u00adulated containers. \nThrough this example, we show how the CFL-reachability for\u00admulation of points-to analysis works. We will \nuse ti to denote the variable twhose .rstoccurrenceisatline i, andoi todenotethe ab\u00adstract objectforthe \nallocation site atline i.For example, e40 ando4 represent variable e declared at line 40 and the Container \nobject created at line 4. As another example, o14 represents the String object created atline 14. Node \ntmpi denotes a temporary variable createdarti.ciallytoconnect an objectandan actualparameter.For example, \ntmp6 is used tolink the Integer object createdatline6 and the actualparameter of the call to addElement. \nThe program representation for the example is shown in Fig\u00adure 3; for simplicity, the inverse edges are \nnot shown. Each entry and exit edge is also treated as an assign edge for language LF to represent parameter \npassing and method returns. The analysis can conclude thatthepoints-to set ofi12 has a single objecto6 \n,because there exists a .owsTo path between them. To see this, .rst note that this41 alias this38 because \nobject o4 can .ow to both this41 and this38 . Similarly, this44 alias this38 and this41 alias this44 \ncan be derived. Second, t41 and t44 are aliases because object o38 can .owtoboth t41 and t44 .For example, \no38 .owsTo t41 canbe derived asfollows: o38 new t38 store(arr)this38 alias this41 load(arr)t41 . o38 \n.owsTo t41 Finally, o6 .owsTo i12 canbederived asfollows: o6 new tmp6 store(arr elm)t41 alias t44 load(arr \nelm)i12 . o6 .owsTo i12 In addition, this .owsTo path is a realizable interprocedural pathbecauseitcontains \nmatchedpairs ofentry andexit edges.The chain of entry and exit edges along the path is entry6 . entry30 \n.entry30 .entry6 .entry4 .entry4 .entry8 .entry12 . exit12 , which does not have any unmatched pair of \nmethod entry and return.(Recall that an entry edgeis treated as an exit edge.) 2.3 FormulationofContainerOperations \nThis sectionpresents ourformulation ofcontainer operationsbased on theCFL-reachabilityformulation ofpoints-to \nanalysis. DEFINITION 1. (Container).Acontainertype Gis an abstractdata type with a set S of element objects, \nand two basic operations ADD and GET that operate on S.A container object .n is an instantiation of G \nwith n elements forming an element set S.. ADD maps a pair of a container object and an element object \nto a container object. GET maps a container object to one of its elements.Theeffectsof theoperations \nareasfollows: ADD(.n ,o):.post m = o/S.pre .o . S.post .m=n+1 . pre . .p : p. S.pre . p . S.post GET(.n): \no = o . S. Following the common Java practice, the de.nition does not allow a container to have primitive-typed \nelements.3 Furthermore, for the purposes of our tool, operations that reduce the size of a container \nare ignored. Despite their simplicity, these two abstract container operations capture many common usage \nscenarios for Java containers. To identify semantics-achieving statements for a container, we .rst introduce \nrelation reachFrom (short for reachable from ). For each abstract object o, set {o ' |o ' reachFrom o}consists \nof the objectitselfandother abstract objects whose run-timeinstances could potentially be reached from \nan instance of o through one or morelevel(s)of .elddeference(s).Thesemanticdomainsthat will be used arede.nedin \na standard wayasfollows: Obj.: Domainof abstract objects,asrepresentedbyobject allocation sites C. . \nObj.: Domain of container objects V. : Domainof variableidenti.ers F. : Domainofinstance.eldidenti.ers \nCall.: Domain of method entryand exit edges DEFINITION 2. (Relation reachFrom). reachFrom . Obj. \u00d7 Obj. \nisde.ned by thefollowingproduction reachFrom . .owsTo store(f).owsTo reachFrom |o In addition, the stringconsisting \nof entry and exit edgelabels on a reachFrom path has tobe accepted bylanguage RC. For example, there \nexists a reachFrom path from o6 to o4 . To see this, .rst note that o38 reachFrom o4 holds, because of \no38 .owsTo t38 store(arr) this38 .owsTo o4 . Second, there exists 3Forbrevity,wemayuse container instead \nof containerobject . a reachFrom path from o6 to o38 , because of o6 .owsTo e40 store(arr elm) t41 .owsTo \no38 . Finally, o6 reachFrom o4 due to the transitive property of the relation. In addition, this entire \nreachFrom path does not contain any unmatched pair of method entryand exit. Notethat an object subgraph \nreachablefrom a container(i.e., containing only nodes relevant to the container)can be computed by searching \nfor the reachFrom paths ending at the container object. Nodes irrelevant to the container can be .ltered \nout by the context-sensitivity check of language RC.Finding reachFrom paths is a single-target CFL-reachability \nproblem with O(n 3 k3 ) complexity, where n isthenumberof nodesinthe .owgraph and k isthe size oflanguage \nLF.However, checking context sensitivity is exponential, asthe size oflanguage RC is exponentialinthe \nsize of theprogram(duetothe exponential number of call chains).To ensurebothhighprecision and scalability, \natime constraint(dis\u00adcussed later)is imposed on the analysis to inspect each container in the program. \nIf no valid reachFrom paths are found within the giventimebudget,the analysisgives uponthe container \nandmoves on to check the next one. Based on reachFrom, we can distinguish element objects and inside \nobjects from the set of all objects reachable from the con\u00adtainer object. DEFINITION 3. (Elementobject \nandinside object). An object i . Obj. is aninside object withrespect to a container object c (where i \nisdifferentfromc)if(1)(i,c). reachFrom, and(2)i is created inthe container class,its(direct or transitive)superclass, \nor any other class speci.ed by the user. An object e . Obj. is an element object with respect to c if \n(1)(e,c). reachFrom,(2)e is neither c, nor an inside object of c, and(3)for some reachFrom path from \ne to c, all object nodes along the path(except for e and c)are inside objects with respect to c. In our \nexample,o4 , o13 ando20 are container objects.Object o6 is an elementobjectfor o4 ;o14 ando15 are element \nobjectsfor o13 ; and o22 is an element objectfor o20 .Object o38 is aninside object for all three containers. \nIn the rest of the discussion we will use Ic and Ec todenote thedomains ofinside objects andelement objects \nwith respect to a container c . . C. The de.nition of inside objects provides the .exibility to use a \nprogrammer-de.ned list that separates the client classes from the classes that are involved in the implementation \nof the container functionality. At present, the tool does not require such a list, as it targets only \ncontainers from the Java collections framework. In this case, it is suf.cient to distinguish a client \nobject from a Java collectioninternalobjectbycheckingifthe objectis createdwithin the java.util package. \n(Note that the tool does not check the ef.cient use of containers within the JDK library code.)However, \nthe class list will be useful if the tool is extended to inspect user\u00adde.ned containers, because such \ncontainers may use an object createdin a non-container class as aninternal object.Such a(non\u00adcontainer)utilityclass \nshouldbe explicitlylistedas such. The semantics-achieving statements are the loads/stores that read/write \nelement objectsfrom/toinside objects ofa container. DEFINITION 4. (Semantics-achieving statements). A \nstatement that achieves the functionality of ADD with respect to a container object c is a store of the \nform a.f = b (where a, b . V. , f . F. ), such that there exists an addTo path from an object ob that \nb points to, to the container object c. This addTo path has the following components:(1)a .owsTo path \nbetween ob and b,(2) store(f) an edge b - --.a representing the store,(3)a .owsTo path be\u00adtween a and \nan object oa , and(4)a reachFrom path from oa to c. Using .todenotepath concatenation, thepath is store(f) \n addTo(ob ,c) . .owsTo(ob ,b).b - --. a ..owsTo(a,oa ) .reachFrom(oa ,c) where oa , ob . Obj. , oa . \nIc , and ob . Ec . A statement that achieves the functionality of GET with respect to a container object \nc is a load of the form b = a.f (wherea, b . V. F. , f . ), suchthat there exists a getFrom path from \nan object ob that b points to, to the container object c where load(f) getFrom(ob ,c). .owsTo(ob ,b).b \n- --. a ..owsTo(a,oa ) .reachFrom(oa ,c) where oa , ob . Obj. , oa . Ic , and ob . Ec . In addition, \nthe string consisting of entry and exit labels on an addTo or a getFrom path has tobe accepted bylanguage \nRC. Thegoalofthe analysisistoidentifysemantics-achievingstate\u00admentsby.ndingalladdTo and getFrom pathsfor \neach container. An addTo path is a reachFrom path from ob to c, which mod\u00adels the process of element \nobject ob being added to the container. Hence, the computation of addTo paths can be performed along \nwiththe computation ofreachFrom paths.However, the computa\u00adtion of a getFrom path requiresaprioriknowledge \nof reachFrom paths and cannot be performed until all reachFrom paths, ele\u00admentobjects, andinside objects \nareidenti.ed.Inthe runningexam\u00adple, there exists an addTo path from o6 to o4 , and the semantics\u00adachieving \nstatement on this path is the store t[pos++]= e. There also exists a getFrom path from o6 to o4 , because \nof o6 .owsTo ret and t44 .owsTo o38 reachFrom o4 .The semantics-achieving statement on thispathis theload \nret = t[index]atline44. Theidenti.cationof semantics-achieving statementsisnot suf\u00ad.cient to understand \nthe usage of a particular container object, as different container objects can have the same semantics-achieving \nstatements.Forexample, all of the addTo (orgetFrom)paths be\u00adtween o6 and o4 , o14 and o13 , and o22 and \no20 have t[pos++] = e at line 41 (or ret = t[index] at line 44) as their semantics\u00adachieving statement. \nThese statements are executed from multiple calling contexts and itis crucial toidentify the contexts \nthat corre\u00adspond to the container object tobeinspected. DEFINITION 5. (Relevant context).For each addTo \nor getFrom path p that ends at container object c, let r be the pre.x of p that appears before the semantics-achieving \nstatement on p. In other words, r is the .owsTo path before the corresponding store/load statement that \nachieves theADD/GETfunctionality.Let l . Call.. be the chain of entry and exit edges (some of which may \nbe inverted)along r.The relevant contextfor the semantics-achieving statement on p is a sub-chain ofl \nthatcontains onlythe unbalanced entry and exit edges. The chain of entry and exit edges before the semantics\u00adachieving \nstatement on p represents the method invocations that cause the element object ob to .ow to variable \nb. This chain mod\u00adels theprocess of the element objectbeing added to/retrievedfrom the container. The \nremaining entry and exit edges on p are ir\u00adrelevant for this adding/retrieving process, because they \nrepresent calls that cause the inside objects(rather than the element objects) to .ow into the container. \nWe do not need to consider balanced entry/exit edges, as they represent completed invocations along the \ndata .ow. An example will be given shortly to illustrate this modeling.Note that there couldbe multiple \nrelevant contexts for a semantics-achieving statement, because a container can have mul\u00adtiple element \nobjects andeachelement objects canbe addedto(and retrievedfrom)the container through multiple calls. \n Algorithm1: Solving single source addTo-reachability. Input: Flow graph, container c, context-insensitive \npoints-to solution pts Output: Map solution: pairs (heap store achieving ADD, relevant contexts) 1 Map(Statement, \nSet(Stack)) solution . \u00d8 2 Set(AllocNode) reachFrom . {c} // reachable objects 3 Set(AllocNode) elemObj \n. \u00d8 // element objects 4 List(AllocNode) objectList . {c} // worklist 5 List(Set(Stack)) contextSetList \n. {{EMPTY STACK}} 6 while objectList = \u00d8 do 7 remove an allocation node o from the headof objectList \n8 remove a set contexts of context stacks from the head of contextSetList 9 Set(Stack) baseContexts . \n\u00d8 10 foreach store a.f = b such that o . pts(a)do 11 foreach context stack s . contexts do 12 baseContexts \n. baseContexts . COMPUTEFlowsTo (o, a, s) 13 Set(Stack) rhsContexts . \u00d8 14 foreach allocation node ob \n. pts(b)do 15 foreach context stack s . baseContexts do 16 rhsContexts . rhsContexts . COMPUTEFlowsTo \n(b, ob , s) 17 if rhsContexts = \u00d8 then 18 reachFrom . reachFrom . {ob } 19 if (o = c OR o is an inside \nobject)AND (ob is NOT an inside object) then 20 elemObj . elemObj . {ob } // An element object is found \n21 solution . solution . (a.f = b, rhsContexts) 22 else 23 objectList . append(objectList, ob ) 24 contextSetList \n. append(contextSetList, rhsContexts) 25 return solution The chain ofunbalanced entry and exit edges,together \nwiththe semantics-achieving statement, can be used to represent a speci.c (ADD or GET)operation executed \non a speci.c container object. For example, the chain of entry and exit edges on the addTo path from \no6 to o4 before semantics-achieving statement t[pos++] = e is entry6 .entry30 , whichis the relevant \ncontextfor the store op\u00aderation with respect to container o4 .As another example, the chain on the getFrom \npath from o6 to o4 before the load operation ret = t[index]isentry6 .entry30 .entry30 .entry6 .entry4 \n. entry4 . entry8 . entry12 . Hence, the relevant context for this getFrom path is entry8 . entry12 , \nwhich captures the fact that element object o6 is retrievedfrom containero4 .Later we will con\u00adsider \nthe relationship between the execution frequencies of state\u00adments t[pos++] = e and ret = t[index]only \nunder their respective relevant contexts entry6 .entry30 and entry8 .entry12 .  2.4 AnalysisAlgorithms \nThe algorithms for solving addTo-and getFrom-reachability are showninAlgorithm 1 andAlgorithm 2, respectively. \nBoth algorithms rely on an initial context-insensitive points-to set to .nd candidates for semantics-achieving \nstatements. Algo\u00adrithm 1 iteratively computes a set of reachable objects. The i-th element of list contextSetList \nkeeps a set of relevant contexts for the i-th object in worklist objectList. Each context is represented \nby a stack, which contains exactly the chain of unbalanced entry and exit edges of a .owsTo path.Initially,objectList \ncontains the container object c and contextSetList contains an empty stack. Map solution containspairs \nof semantics-achieving statement and relevant contexts,which willbereturned afterthefunction .nishes. \n3 4 5 6 7 8 9 10 11 12 Algorithm2: Solving single source getFrom-reachability. Input:Flowgraph, container \nc, context-insensitivepoints-to solution pts, relation reachFrom, set elemObj Output: Map solution:pairs(heapload \nachieving GET, relevant contexts) 1 Map(Statement,Set(Stack)) solution .\u00d8 2 foreach allocation node o \n. elemObj do foreach load b = a.f , such that o . pts(b)do Set(Stack) lhsContexts .\u00d8 lhsContexts . COMPUTEFlowsTo \n(o, b, EMPTY STACK) Set(AllocNode) ins . pts(a)n reachFrom Set(Stack) baseContexts .\u00d8 foreach AllocNode \noa . ins do // A candidate load foreach context stack s . lhsContexts do baseContexts . baseContexts \n. COMPUTEFlowsTo (a, oa , s) if baseContexts \u00d8 then = solution . solution . (b = a.f , lhsContexts) 13 \nreturn solution Function COMPUTEFlowsTo (o, a, s)at line12 attemptsto .nd .owsTo paths from an object \no to a variable a, under calling con\u00adtext s thatleadstothemethod creating o.Due to space limitations \nthisfunctionisnot shown; conceptually,itissimilartotheFIND\u00adPOINTSTOalgorithmdescribedin[37].Thefunction \nreturns aset of contexts(i.e., stacks) that are chains of unbalanced edges on the identi.ed.owsTo pathsfromo \nto a.An empty set returned means that theredoes not exist any valid .owsTo pathbetween them. Similarly, \nfunction COMPUTEFlowsTo (b, ob, s)at line16 at\u00adtempts to .nd a flowsTo path from variable b to object \nob, under calling context s thatleads to the method declaring b.Thepurpose of this function is to connect \nthe chain of entry and exit edges on the .owsTo pathfromo to a withthe chain of entry and exit edges \non the .owsTo path from b to ob, and to check if the combined chain corresponds to a realizable call \npath. If the combined chain is a realizable path(i.e., rhsContexts \u00d8 at line17),ob is added = to set \nreachFrom of reachable objects.Furthermore,if ob isfound tobe an element object(line20 and line21),itisincludedin \nset elemObj, which willbe usedlaterbyAlgorithm 2.At this time,it is clear that store a.f = b is a semantics-achieving \nstatement, and its relevant contexts are contained in set rhsContexts. If ob is not an element object, \nwe append ob tothe worklist(and also append rhsContexts to contextSetList)forfurtherprocessing.Some sub\u00adsequentiteration \nof the while loop will use this context set to com\u00adpute .owsTo pathfrom object od to variable dfor a \nnew store c.f = d (line12), etc.Inthis case, rememberingand eventually using rhsContexts ensures that \nno unrealizable paths can be produced during thediscovery of the container sdata structure. Note that \nwe omit a check for recursive data structures in the algorithm.Infact, an objectis not added into the \nworklist,ifithas been visited earlier during the processing of reachable objects. In other words, theback \nreference edgesbetweeninside objectsinthe objectgraph areignored,because theyhave nothing todo with the \nelement objects. It is also possible for an element object to have a back reference edge going to an \ninside object or the container object(although thisis notlikely tohappen inpractice).Thisback edgeis \nalsoignored,because we areinterestedintheprocess where the element objectis addedtothe container, ratherthaninthe \nshape of thedata structure of the container object. Algorithm 2 inspects each element object o computed \ninAlgo\u00adrithm 1(line2)and attemptsto .ndload statementsof theform b = a.f such that b could point to o. \nAs before, the algorithm starts from a context-insensitive solution, andthen checksifthere exists a .owsTo \npathfromo to b(line5).Ifsuch .owsTo paths arefound, ituses the set of contexts returned(i.e., chains \nofunbalanced edges extractedfromthesepaths)to compute .owsTo pathsfroma to ob\u00adjectoa that a maypotentiallypointto.Notethat \nwe use anintersec\u00adtionbetween pts(a)and reachFrom (line6)to .lteroutirrelevant objects that are not reachable \nfrom container c.If a .owsTo path canbefound(line11-line12),thisloadis a semantics-achieving statement \nand the relevant contexts for it are contained in the set lhsContexts. Precisionimprovement Not allload \nstatements identi.edin get-From paths correspond to GET operations. For example, methods equals and remove \nin many container classes need to load el\u00adement objects for comparison (rather than returning them to \nthe client).To avoid theimprecise resultsgeneratedin these situations, we employ a heuristic when selecting \nstatements that implement GET operations. A load b = a.f is selectedif(1) itis on a valid getFrom path, \nand(2) thepoints-to set of b and the points-to set of the return variable of the method where theload \nislocated have a non-empty intersection. This heuristic is based on the common usage ofJava containers: \nonly methods that can return element ob\u00adjects canbe usedto retrieve objectsby a client. It would be interesting \nto investigate other heuristics in future re.nements of the analysis. In situations where individual \nstate\u00adments are notprecise enough to capture the semantics of ADD and GET, it may be possible to .nd \ncourser-grained program entities (e.g., methods)thatcorrespond tothese abstract operations.For ex\u00adample,asplay \ntreemayperformboth storesandloadsforasingle GET operation.Atpresent,itis unclearhow togeneralize the \nanal\u00adysis to modelsuch cases. 3. ExecutionFrequencyComparison This section describes the dynamic pro.ling \nalgorithm and the staticinference algorithmtocomparetheexecutionfrequencies of semantics-achieving statements. \n 3.1 DynamicFrequencyPro.ling During the execution, the pro.ling framework needs to record, for each \ncontainer object, its ADD and GET frequencies. A key challenge is how to instrument the program in a \nway so that the frequencies of semantics-achieving statements can be associated with their corresponding \ncontainer objects.In many cases, the con\u00adtainer object is not visible in the method containing its semantics\u00adachieving \nstatements.For example, the store thatimplements ADD forHashMap islocatedin the constructor ofclass HashMap.Entry \nwhere the root HashMap object cannot be referenced. In this and similar cases, it is unclear where the \ninstrumentation code should beplaced to access the container object. We use relevant contexts to determine \nthe instrumentation points. Given a pair (s,e0 ,e1 ,...,en) of a semantics-achieving statement s and \nits context, we check whether the receiver of each call site ei canbethe container object c.This checkisperformedin \nabottom-up manner(i.e.,from n down to 0).The instrumentation code is inserted before the .rst call site \nei : a.f()found during the check such that the points-to set of a includes c. For example, one instrumentation \nsite for HashMap is placed before the call to addEntry in method put,because the receiver variable of \nthe call site canpoint to the HashMap object: class HashMap{ ... void put(K key, V value){ ... // increment \nthe ADD frequency for \"this\" container recordADD(this); this.addEntry(..., key, value, ...); } void addEntry(..., \nK key, V value, ...){ ... table[...] = new Map.Entry(..., key, value, ...); } } class Entry{ Entry(..., \nK key, V value, ...){ // these are stores achieving ADD this.key = key; this.value = value; } } 3.2 \nStaticInferenceofPotentially-SmallerRelationships This subsection describes the static inference algorithm \nthat de\u00adtects inef.ciencies by inferring potentially-smaller/larger relation\u00adships for the execution \nfrequencies of two (semantics-achieving statement, contexts) pairs. These relationships are computed \nby traversing an interprocedural inequality graph, which models the interprocedural nesting among theloops \ncontaining the semantics\u00adachieving statements. DEFINITION 6. (Inequality graph). An inequality graph \nIG = (N,E) has node set N .L.M, where L is the domain of loop head nodes, and M is the domain of method \nentry nodes. The edge set is E.C.I, where C represents call edges and I represents inequality edges. \n3.2.1 InequalityGraphConstruction For two statements s1 and s2 that arelocatedinloops l1 and l2 re\u00adspectively, \nwe say that the executionfrequency of s1 ispotentially\u00adsmaller than the execution frequency of s2 if \nl2 is nested within l1 .Such a relationshipdoes not necessarily re.ectthe real run-time executionfrequencies(thustheuseof \npotentially ).Forexample, ifs2 isguardedby a non-looppredicateinside l2 ,itispossible that itis executedlessfrequentlythans1 \nbecausethepathcontaining s2 can be skipped many times inside the body of l2 . One example of this situation \ncomesfrom a common containerimplementation sce\u00adnario.When the client attempts to add an objectinto the \ncontainer, the implementation .rst checks if the object is already in the con\u00adtainer, and storesit onlyifthe \ncontainerdoes nothaveit already.In this situation, the semantics-achieving statement is under the non\u00adlooppredicate \nthat checks whether the element objectis alreadyin the container. Despite this potential imprecision, \nthis modeling of execution frequency,toalargedegree, capturesthehigh-levelprogrammer s intent. For example, \nin many cases the programmer just wants to add objects using the nested loops without even caring about \nwhether they have been added before. Even though the statically\u00adinferredpotentially-smaller relationshipmay \nnotholdfor somepar\u00adticular runs of a program, the problems found using this relation\u00adship may re.ect \ninef.cient uses of containers in general. In addi\u00adtion,theloop nesting relationshipitself may clearly \nsuggest a .xif a problem really exists. For example, the problem may be solved simply by pulling some \noperations out of a loop. We have found this approach based onloop nesting to work wellinpractice. The \nalgorithmfor constructing theinequalitygraphis shownin Algorithm 3.For each method m in the callgraph,intraprocedural \ninequalityedges are .rst added(line4-line11).For eachloophead, we .nd theloopinwhichitisnested(line6).Ifitisnotnestedin \nanyloop(line7-line8), we create aninequalityedgebetweenthe entry node of the method and the loop head \nnode. Otherwise, the edge is created between the head of the surrounding loop and the node(line9-line11). \nFor each caller of m, a call edge is added to connect the two methods(line14-25).Speci.cally,theloop \nwherethe call sitefor m islocated(or the entrynode of the caller)isfound(line17), and a call edgeis created \ntolink thehead of theloop(or the entry node of the caller) and m sentry node.Call edgesareusefulin .ltering \noutirrelevant calling contextsduring the traversal of theinequality graph.Figure4shows aninequalitygraphforthe \nrunning example. Algorithm3:Algorithmfor constructingtheinequalitygraph. Input:CallgraphCG Output:Inequalitygraph \nIG 1 foreach method m in the callgraph do 2 EntryNode entry . GETENTRYNODE(m) 3 CFG cfg . BUILDCFG(m) \n 4 foreach loop l . cfg do // add inequality edges 5 LoopHeadNodehead . GETLOOPHEADNODE(l) 6 Loopl ' \n. FINDSURROUNDINGLOOP(head , cfg) 7 if l ' = null then = 8 CREATEINEQUALITYEDGE(entry -. head) 9 else \n' 10 LoopHeadNodehead . GETLOOPHEADNODE(l ' ) =' 11 CREATEINEQUALITYEDGE(head -. head ) 12 foreach incoming \ncallgraph edge e do // add call edges 13 Method caller . SOURCE(e) 14 CFG cfg . GETCFG(caller ) 15 Loopl \n= FINDSURROUNDINGLOOP(e.callsite , cfg) 16 if l = null then ' 17 EntryNode entry . GETENTRYNODE(caller \n) call(e) ' 18 CREATECALLEDGE(entry - ---. entry) 19 else 20 LoopHeadNodehead . GETLOOPHEADNODE(l) call(e) \n21 CREATECALLEDGE(head - ---. entry) Here we use ei todenote the entrynodefor the methoddeclared at linei, \nandli todenotetheloopheadnodelocatedatline i.Eachcall edgeis annotated with calli, which represents the \ncallsite atline i. Each inequality edge is annotated with =i, where i is a globally\u00adnamed index.Inverse \nedges are allowed for call edges:if thereis a calledge calle between nodesm andn, an edge calle existsbetween \nn and m. Unlike in the .ow graph, there are no exit edges in the inequalitygraphbecauseitisnotnecessarytomodelanydata \n.ow. Aninequalityedgeis used to represent onlypotentially-smaller relationships.Thepotentially-larger \nrelationships couldpotentially be represented by inverse edges; however, wedo not allow the use of such \ninverse edges because a path in the graph must represent only one of these two relationships(i.e., either \nsmaller orlarger, but notboth). DEFINITION 7. (Valid potentially-smaller path). Given two in\u00adequality \ngraph nodes m and n, a path p from m to n is a valid potentially-smaller path if the chain of call edges \n(including in\u00adverse edges)on p forms a realizable interprocedural path(i.e., the sequence of edge labels \non the chain forms a string in language RC).Pathp is a strictly-smallerpath if(1)p is a validpotentially\u00adsmallerpath \nand(2)p contains atleast one inequality edge. One can easily de.ne a grammar with starting non-terminal \npotentially-smaller to capture the abovede.nition ofvalidity.Sim\u00adilarly to the .owsTo computation, .nding \na valid potentially\u00adsmaller path in the inequality graph requires a context-sensitivity check of call \nand call edges.  3.2.2 Inef.ciencyDetectionasSource-SinkProblems Detectingunderutilizedcontainers To \n.ndan underutilizedcon\u00adtainer, we need to compare the execution frequencies of the con\u00adtainer allocation \nsite c and each store s that implements the func\u00adtionality of ADD under relevant context r with respect \nto c. In the following de.nition, lh(s)denotes the loop head(if s is within a loop) or the entry node \nof the method(if s is not in a loop) for statement s. l   . . ... .   call call e e =  el Figure4. \nInequalitygraphfor the running example. DEFINITION 8. (Underutilized container). Given a container al\u00adlocation \nsitec and a set of statement-contextspairs thatimplement ADD operations for c, an underutilized container \nproblem occurs for c if there does not exist a pair (store,contexts)for which (1) a strictly-smaller \npath p exists from lh(c)to lh(store), and (2)there exists a context t . contexts such that p ends with \nthe chain of call edges represented by t. Informally, an underutilized container problem is reported \nif there does not exist an ADD operation such that the loop where itislocatedis nestedwithintheloopwherethe \ncontainer allocation siteislocated. Consider again the running example. Recall that the statement\u00adcontexts \npair that achieves ADD operation for container o4 is (t[pos++]= e, {entry6 . entry30 }).There exists \na strictly-smaller path =1 . call6 . call30 from node e2 to e40 , which are the method entry nodes for \nthe allocation site of o4 (line 4) and for t[pos++]= e (line41), respectively. In addition, thispathcontains \nthe callchain call6 . call30 , whichis exactlythe context contained in set{entry6 . entry30}inthepair(comparingonlylabels \nonthe call edges and the entry edges). Hence, no underutilized container problem willbe reportedfor container \no4 . As another example,the statement-contextspairforADDon o13 is(t[pos++]= e, {entry14 . entry30, entry15 \n. entry30 }). The tool reports that o13 exhibits an underutilized container problem, because no strictly-smaller \npaths from the entry node e11 of its allocation site (line 13) to the entry node e40 of t[pos++] = e \ncan be found, under relevant calling context entry14 . entry30 or entry15 . entry30 .Theproblem does \nnot occurfor container o20 , since there is a strictly-smaller path =4 . call22 . call30 from the allocation \nsite at line 20 to the store operation t[pos++] = e thatimplements ADD,underthe relevant callingcontext \nentry22 . entry30 . Note that although the number of elements added to container o13 (i.e.,2)isinfact \nlarger than the number oftimesits allocation site can be executed (i.e.,1), it is not a false positive \nto report it as an underutilized container. This is because the creation of the container(which could \ncosthundreds of run-timeinstructions)can be easilyavoidedbyintroducingextra variablesfor storingthedata. \nIt could be the case that, while the ADD operations for a container areinthesameloopasthe allocation \nsiteofthe container,itmaynot be easy to perform an optimization because there could be a large number \nof distinct ADD operations(e.g., the programmer intends to add many elements without using loops). However, \nwe have foundthatthis situation rarelyoccursin real-worldprograms.Once an underutilized container problem \nis reported, there is usually an obvious container thatholds a very small number of elements, and a specialization \ncanbe easily created. Detecting overpopulated containers To .nd an overpopulated container,itis necessaryto \ncompare the number of GET operations against the number of ADD operationsfor the container. DEFINITION \n9. (Overpopulatedcontainer). Given a container al\u00adlocation site c, a set S1 of statement-contextspairs \nthat implement ADD for c, and a set S2 of statement-contexts pairs that imple\u00adment GET for c, c is an \noverpopulated container if for any pair (store,contexts1 ) . S1 and any pair (load,contexts2 ) . S2 ,(1) \nthere exists a validpotentially-smallerpath p fromlh(load) to lh(store), and(2) there exist a context \nt1 . contexts1 and a context t2 . contexts2 such that p starts withthe chain of(in\u00adverse) call edges \nrepresented by t2 and ends with the chain of call edges represented by t1 . Informally, an overpopulated \ncontainer is reported if for every pair ofGET and ADDoperations, apotentially-smaller relationship canbeinferredbetween \nthem. Intherunning example,anoverpopulated containerproblemis detected for container o4 . Recall that \nthe statement-contexts pair that implements ADD is (t[pos++] = e, {entry6 . entry30 }), and the statement-contexts \npair that implements GET is (ret = t[index],{entry8 . entry12 }).There exists anpotentially-smaller path \nbetween these two statements: call12 . call8 .=1 . call6 . call30 . This path contains the call edges \ncall6 . call30 (i.e.t1 )and call8 . call12 (i.e.,t2 ).Containero13 is also overpop\u00adulated, because there \nexists a valid potentially-smaller path from the GET to any of the two ADD operations. Containero20 is \nnotoverpopulated, since no potentially-smaller path can be found from its GET operation (i.e., the statement\u00adcontexts \npair (ret = t[index], {entry24 })) to its ADD operation (i.e.,pair(t[pos++] = e, {entry22 . entry30 })). \n 3.2.3 AnalysisAlgorithm In general, both the proof and the disproof of a certain path under certain \ncalling contexts requires a traversal of theinequalitygraph. Thetraversalhastofollowthe calledges representedby \nastart con\u00adtext and an end context, which are the relevant contexts associated with semantics-achieving \nstatements.The start contextis an empty stackif the statementis the allocation site of the container.A \nstan\u00addard worklist-based algorithm is used in the expected way to per\u00adform abreadth-.rst traversal of \nthegraph.The traversal terminates immediately if call edges in the path are detected to form a cycle, \nbecause there is no way to reason about the number of ADD and GET operationsfor a containerif calls connecting \nthese operations areinvolvedin recursion. Trade-off between the analysis scalability and the amount of \nin\u00adformation produced Because the inequality graph does not con\u00adtain any data .ow information, the graph \ntraversal algorithm can follow arbitrary call and call edges when selecting the path. The start and end \ncontexts are useful when the algorithm attempts to decide which call/call edge tofollow. Suppose the \nalgorithm is in\u00adspecting method m. The algorithm decides to leave m through a call edgeif(1) this edgeis \non the end context, or(2) it canlead to the end context. On the other hand, it follows a call edge if(1) \ntheedgeisonthe start context, or(2) theredoes notexistany call edge going out of m that is on the end \ncontext or can lead to the end context.A call edgeis leading to acontext whenthemethod thatthe call edgegoesto \ncan(directly ortransitively) invokethe sourcemethod of the .rst call edgeonthecontext.Inaddition,we keeptrack \nofthe set of methods thatthe related addTo and getFrom paths have passed. The traversal of the inequality \ngraph never en\u00adters a methodif this methodis notin this set. While the startand end contexts are useful, \nthe worst-case time complexity of a naivegraph traversal algorithmis still exponential, as the number \nof distinct calling contexts is exponential in the size of the program. This motivates the need to de.ne \na trade\u00adoff framework to handle the analysis scalability and the amount ofinformationproduced. One factor \nconsidered by this framework is the number of un\u00adbalanced call/call edges in a valid potentially-smaller \npath. These numbers represent the length of the method sequences on the call stack that the path crosses, \nand they implicitly determine the run\u00adning time of the algorithm. A path crossing too many calls is usually \nanindicator of an unrealizableinterproceduralpath(e.g., due to spurious call graph edges). Furthermore, \neven though an inef.ciently-used container can be found by traversing a long in\u00adterprocedural path on \nthe inequality graph, it may be hard to op\u00adtimize it as the data it carries might be needed by many places \nin theprogram.In thisframework, the number of unbalanced call/call edges allowed in a path can be pre-set \nas a threshold. While this introduces unsoundness, itimproves the scalability andpresents to the user \na set of containers that arepotentially easy to specialize. Anotherfactor(orthogonal to the number of \nunbalanced call/ call edges) that is taken into account is the time used to inspect each container. If \na TimeOutException is caught during the in\u00adspection of a container, the analysis moves ontothe next container, \nwithoutgenerating any warnings about this current one.We exper\u00adimented with different time thresholds, \nand some of these results aredescribedinSection 4. 3.3 ComparisonbetweenStaticInferenceandDynamic Pro.ling \nComparedwith all existingbloatdetection techniquesbased ondy\u00adnamic analysis[22,23,26,35,42], a major \nweakness of a static analysis approach is its inability to estimate precisely the execu\u00adtionfrequencies \nof various statements.However,ithasthefollow\u00ading threeadvantages overthedynamicapproaches.First,thestatic \nanalysis can be used as a coding assistance tool to .nd container\u00adrelated problems during development, \nbefore testing and tuning have begun. It is desirable to avoid inef.cient operations early, even before \nmeaningful run-time executions are possible. Second, a problem detected by the static analysis usually \nindicates a pro\u00adgrammerintent(ormistake) thatisinherentintheprogram, while the resultsfrom adynamic analysis \ndepend heavily on the speci.c run-time executionbeing observed.Finally, theprocess oflocating the underlying \ncause from the dynamically-observed symptoms is either completely manual orinvolves adhoc techniques \nthatdo not quicklyleadatoolusertotheproblematic code.Forexample, apro\u00ad.lercan .nd acontainerexhibitingfewlookup \noperations,butitis hard for it to effectively explain this behavior to the programmer. The statictoolexplicitly \nreports theloops that cause thegeneration ofthewarnings,thusreducing theeffortto connectthedots from \nthe manifestation of theproblem to the core cause. 4. EmpiricalEvaluation Wehaveimplementedthe static \nanddynamic analysesbased onthe Sootprogram analysisframework[41], andevaluatedtheir effec\u00adtiveness onthe \nset of21Javaprograms showninTable 1.All exper\u00adiments used adual-core machine with anIntelXeon2.80GHzpro\u00adcessor, \nrunning Linux 2.6.9 and Sun JDK 1.5.0 with 4GB of max heap space. The Sridharan-Bodik analysis framework \nfrom [37] was adapted to computeCFL-reachability.Aparallel version ofthe analysis was used: 4 threads \nwere ran to simultaneously inspect containers. Note that the total numbers of reachable methods for some \nprograms are signi.cantly larger than the numbers shown in previous work[37]forthe sameprograms.Thisisbecause \nof the Benchmark #M(K) #Con T1 =20 min T2 =40 min Dynamic vsStatic #UC #OC #NC #FP RT(s) #UC #OC #NC \n#FP RT(s) #DU #DO #SN #DN #MS jack 12.5 34 javac 13.4 45 soot-c 10.4 15 sablecc-j 21.4 29 jess 12.8 4 \nmuf.n 21.4 108 jb 8.2 9 polyglot 8.6 18 j.ex 20.2 44 jlex 8.2 16 java-cup 8.4 10 antlr 12.9 15 bloat \n10.8 260 chart 17.4 286 xalan 12.8 1 hsqldb 12.5 1 luindex 10.7 1 ps 13.5 42 pmd 15.3 39 jython 27.5 \n75 eclipse1 41.0 1623 eclipse2 41.0 1623 8 12 0 3 2 4 1 1 2 1 1 2 18 15 0 0 0 0 8 5 18 47 4 10 1 5 2 \n7 7 6 5 0 3 2 46 29 1 0 1 8 7 26 25 121 2 5 3 0 0 78 0 1 17 0 0 0 118 52 0 0 0 0 0 5 1097 351 * * 0 1 \n0 0 0 1 0 0 0 0 1. 1. 0 0 0 0 0 0. 0. 3. 1725 5040 1235 1140 790 28213 64 1259 6785 474 519 584 34542 \n26406 222 99 69 1077 1322 7055 447465 32151 8 12 0 --5 -0 2 --- 24 21 --- --5 18 47 4 10 1 --16 -6 5 \n--- 76 38 --- --26 32 137 0 5 0 --56 -1 14 --- 17 12 --- --1 956 104 * * 0 --0 -0 0 ---2. 1. ---- -0. \n0. 4. 2561 5040 1440 --66472 -2447 16092 --- 49844 35406 --- --9745 825897 57897 8 12 0 3 2 5 1 0 2 1 \n1 2 24 21 0 0 0 0 5 5 18 45 4 ** * 10 ** * 1 00 0 5 04 0 2 00 0 16 0 18 2 7 00 0 6 21 1 5 18 0 0 00 0 \n3 00 0 2 02 0 72 2 18 1 36 3 16 1 1 00 0 0 00 0 1 00 0 8 05 0 7 0 19 0 21 1 17 2 27 0 20 0 110 5 20 0 \n Table1. #M is the number of methods(in thousands) inSoot sSpark context-insensitive callgraph. #Con \nis the total number of containers inspected in the application code.There are two rowsfor eclipse:(1) \nanalyzing allplugins together and(2) analyzing them one at a time. Results are shown with T1 = 20 minutes \nand T2 = 40 minutes limit for the static tool to inspect each container. The last part of the table compares \nthe static anddynamic analyses. use of the JDK 1.5.0 library which is much larger than the JDK 1.3library \nusedin thatprevious work.Many of theprograms were chosenfrom theDaCapo[2]benchmarkset.The analysis was \nable to run on all oftheDaCapoprograms,but we excludedfromthe ta\u00adbletheprograms thatdo notuse anyJava \ncontainers.For eclipse, we analyzed the main framework and the following plugins that are necessary for \ntheDaCapo run: org.eclipse.jdt, org.eclipse.core, org.eclipse.text, org.eclipse.osgi, and org.eclipse.debug. \nStatic analysis The .rstpartofTable 1(T1 and T2 ) shows the warnings generated by the static tool, the \nfalse positives, and the running times for two different con.gurations: 20 and 40 minutes allowed to \ninspect each container. If all containers can be com\u00adpletely inspected under the .rst con.guration, the \nsecond con.g\u00aduration is not applied, and - marks the corresponding column. The table shows the number \nof underutilized container warnings (#UC), the number of overpopulated container warnings (#OC), the \nnumber of containers whoseinspectionis not completeddue to time out(#NC),the number offalsepositives(#FP), \nandthe total running timein seconds(RT).Forprograms withmany warnings, we randomly picked 20 warnings \n(including both types of prob\u00adlems)for manual checking; the numbers offalsepositivesfoundin these samples \nare reported and marked with ..The analysis running time shown in the table includes the identi.cation \nof semantics\u00adachieving statementsand theinference ofpotentially-smaller rela\u00adtionships. They are not \nlisted separately because the running time isdominatedby theformer. Wehavetuned theanalysisby adjusting \nthemaximum number of unbalanced call/call edges traversed. All numbers from 3 to 10 were evaluated.We \nobserved thatproblems caused by certain con\u00adtainer usagepatterns are missinginthe reports whenthisparameter \nis setto a numberlessthan7.Hence,7was chosen astheparameter value for the experiments. This value appears \nto be an appropriate choice for the set of benchmarks we used, and it may need to be re-adjustedforprograms \nwithdifferent container usagepatterns. Falsepositives aredeterminedbymanuallyinspecting eachpro\u00adgram.Given \nawarning, weexaminethecode andcheck whetherthe containeris appropriately used, and whetherthereis abetter \nway of usingit.Thisis a subjective choicein which we are trying to simu\u00adlatewhat an intelligentprogrammer \nwoulddo.Although thereis no objective perfect answer, such an evaluation provides valuable indication \nof the real-world usefulness of the tool. For programs such as jack and javac whose source code is not \npublicly avail\u00adable, we mark the #FP columns with * , meaning that the warn\u00adings are not checked. Overall, \nthe results of study are promising, sincethe number offalsepositivesislow acrossthebenchmark set. Ingeneral,false \nnegatives canbeintroducedbythe unsoundness of the analysis. For example, a container problem can be missed \nif the container structure cannot be completely discovered within the allowed time limit, or if the call \nchain required to expose the problem is too long. The numbers of false negatives were not investigated \nbecause they can be reduced by increasing the resourcebudget(i.e.,timelimit and maximum call chainlength). \nFor example, for most programs in our study, a budget of T = 40 min allows the analysis to successfullyinspect \nall containersin the application code(i.e., to achieve #NC =0). The tool could not .nish the inspection \nof many container ob\u00adjects ineclipse1 . This performance is caused in part by the ex\u00adtremely large code \nbase of eclipse, and in part by the lack of precise contexts in many .owsTo or .owsTo paths computed \nby the underlyingSridharan-Bodikframework(because of the use of match edges [37]). In our current work \nwe decided to use the framework as-is and to focus on demonstrating that the approach successfullyidenti.esproblematic \ncontainers.Future work canim\u00adprove theSridharan-Bodikmachinery toprovide moreprecise con\u00adtextinformationfor \nour analysis. Splittingalarge codebasefor scalability Notethatbothanalysis time and the number oftimed-out \ncontainersdecrease substantially when eclipse plugins are analyzedindividually(roweclipse2 ). This is \nbecause the number of calling contexts for each container method is reduced signi.cantly. In general, \nit is not always valid to analyze separatelythe components of alargeprogram.However, separate analysis \ncan be made more general by .rst employing a relatively inexpensive escape analysis, which identi.es \ncontainer objectsthat maybepassed acrosstheboundaries of components(or plugins). A container that can \nnever escape the component where it is created can be safely analyzed in the absence of other com\u00adponents. \nThis is similar to the observation that context sensitiv\u00adity is not necessary for an object that never \nescapes its creating method. While element objects could still .ow in and out of com\u00adponents, there exist \ntechniques tohandle incompleteprograms,for example,by creatingplaceholdersfor missing objects[33].For \na non-escaping container, all semantics-achieving statements under the relevant calling contexts triggered \nby the creating component wouldbe con.ned to that component. Comparison withadynamic approach Thedynamic \nanalysisin\u00adstruments each semantics-achieving statement, runs the program, and reports containers whose \n(1) ADD frequencies are smaller than10, and(2) ADD frequency/GET frequency ratios are greater than2.Theintersectionsbetweenthe \nsets of statically anddynami\u00adcallygenerated warnings are showninthelastpart ofTable 1: #DU and #DO are \nthe numbers of containers reportedby the static anal\u00adysis(from #UC and #OC, respectively) that also appear \nin the dy\u00adnamic analysis reports.Notethat mostinef.ciently-used containers foundbythe static analysis \nare also reportedbythedynamic analy\u00adsis, which showsthatthe static warningsindeedproduce containers that \nexhibitproblematic run-timebehavior. It is not as easy to use the dynamic analysis to .nd containers \nthat are optimizable across all inputs and runs, compared to using the static analysis. Columns #SN and \n#DN show the numbers of containers reportedby the static analysis and thedynamic analysis, respectively, \nfor which we did not manage to come up with opti\u00admization solutions.Todetermine #SN, we examined each \ncontainer that was already subjected to a manual check for false positives (withT =40min, and with20 \nrandomly chosen containersforpro\u00adgrams withmore than20 warnings).Todetermine #DN, we exam\u00adined all dynamically-reported \ncontainers, if there were at most 20 of them; otherwise, we examined the 20 containers with the high\u00adestpotentialforperformanceimprovement: \nthe ten containers with thelargest number of ADD operations, and the ten containers with the largest \nratio of ADD to GET operations. Among all these ex\u00adamined containers, #DN isthe number ofthosefor whichwe \ncould notdetermine an appropriate optimization. In the course of this experiment, it became clear that \nthe prob\u00adlems reported by the static analysis are easier to .x than those reported by the dynamic analysis. \nFor instance, among the top 20 dynamically-reported containers for bloat, a program analy\u00adsis framework \nin DaCapo, we eventually came up with optimiza\u00adtion solutions for only two, and one of them was also \nin the static analysis report.The remaining containers are used tohold various kinds of program structures \nsuch as CFGs and ASTs. While they are not retrievedfrequentlyin oneparticular run(with theinputs providedbyDaCapo),itishard \nto optimize them as their elements maybeheavily used when theprogramis run with otherinputs.In contrast, \nmost ofthe containerproblems reportedbythe static anal\u00adysis arestraightforward and theprogrammer canquickly \ncome up with optimization solutions after she understands the loop nesting relationships that cause the \ntool to report the warnings. Whilestatic analysis reports canpreciselypinpointthe causes of inef.ciency \nproblems, they cannot say anything about the severity of the warnings. When the analysis is used during \ndevelopment (i.e.,withoutanytest runs) to .nd container-relatedproblems,this information may not be required \nbecause a programmer should, ideally, .xallreported warningstoavoidpotentialbloat.However, ranking of \nwarnings becomes highly necessary when the tool is usedforperformancetuning andproblemdiagnosis, asthe \nreported warnings have different performance impact and importance. For example, when we attempt to .nd \noptimization opportunities for bloat,itis unclear, among the total of100 warningsgenerated by the static \nanalysis, which ones to inspect .rst. It is impractical to examineand .xall of them,atask that canbeverylabor-intensive \nand time-consuming. A natural solution is to rank the statically\u00adreported containers based on their run-time \nallocationfrequencies; this was the approach usedin thetwo case studiesdescribedbelow. As discussed \nearlier, the time budget limitations and the con\u00adstraints on call chain length may cause the static analysis \nto miss problematic containersthat are(mis-)usedincomplexways.Con\u00adsider the top inef.ciently-used containers \nfrom the dynamic re\u00adports(the same20 orless containers examined whendetermining #DN). Column#MS shows \nthe number of such containers that are missedby the static analysis.While there are onlyfew missed con\u00adtainers, \na more comprehensive study of their properties could be performed in future work, in order to identify \nnew usage patterns that maybe used to re.ne our current static analysis. Performance improvement from \nspecializing containers For bloat we found that among the containers that have warnings, the most frequently-allocated \ncontainer is an ArrayList created by method children for each expression tree node toprovide ac\u00adcess \nto its children nodes. The number of objects added in this container is always less than three, and in \nmany cases, it does not containany objects.Westudied thecodeandfound aneven worse problem: even when \nthe children do not change, this container is never cachedinthe node.Everytime method children isinvoked, \na newlistis created and the node s children are added.By creating a specialized version that takes advantage \nof container types such as Collections.emptyList and Collections.singletonList and that caches the children \nlist in each node, we were able to re\u00adduce the number of objects created from 129253586 to 89913518 (30% \nreduction), and the running time from 147 seconds to 110 seconds(24.5% reduction). We have also inspected \nthe report generated for chart. Many problems reported are centered around method getChunks de\u00adclaredin \naninterface, which returns an ArrayList. Thisinterface is implemented by more than 10 classes, each of \nwhich has its own implementation of getChunks. While many of these con\u00adcrete classes do not have any \nchunks associated, they have to create and return an empty ArrayList, in order to be consis\u00adtent with \nthe interface declaration. By further studying the clients that invoke these getChunks methods, we found \nthat many of them need only toknow the number of chunks(i.e.,byinvoking getChunks().size()).Wequicklymodi.ed \nthe code to replace the empty ArrayList withthe specialized Collections.emptyList, add a method getSize \nin each of the corresponding classes that calculatesthe number of chunks without creating a newlist, \nand re\u00adplace the callsgetChunks().size()with calls to the new getSize method.Thisprocesstook uslessthan \nanhour.Themodi.ed ver\u00adsion achieved 3.5% running time reduction and 5% reduction of the number of generated \nobjects. Note that these case studies only addressed two obviousproblems anddid notgointo anydepth; in \ngeneral, signi.cantoptimizations maybepossibleif adeveloperfa\u00admiliar withthe code thoroughly analyzes \nthe reportedinef.ciently\u00adused containers and creates appropriate specialized versions. 5. RelatedWork \nBloat detection Mitchell et al. [24]propose a manual approach that detects bloat by structuring behavior \naccording to the .ow of information,and theirlaterwork[23]introducesawayto .nddata structures that consume \nexcessive amounts of memory. Work by Dufouret al. [9]uses ablended escape analysis to characterize and \n.nd excessive use of temporary data structures. By approximating object lifetimes, the analysis has been \nshown to be useful in clas\u00adsifying the usage of newly created objects in the problematic ar\u00adeas. Shankar \net al. proposeJolt[36], atoolthat makes aggressive methodinliningdecisionsbased ontheidenti.cation of \nregionsthat makeextensiveuseoftemporary objects.Recentwork[26].nds memory leaks and bloat in C/C++ programs \nby segregating ob\u00adjectsbasedon their allocation contexts and staleness.The research from[42]detects memory \nbloatbypro.lingcopy chains.Ourpre\u00advious work proposes a container pro.ling approach to detecting Java \nmemoryleaks[44]andthe workin[35]dynamicallyidenti\u00ad.esinappropriately-usedJava collections.The workfrom[43]pro\u00adposesadynamictechniqueto \n.ndlow-utilitydatastructuresbased on thepro.ling of cost andbene.t.Our workdiffersfrom all these existingdynamicapproachesinthatitproposesthe \n.rst statictech\u00adnique to .nd memory inef.ciencies. It can be used both in the de\u00advelopmentphaseto .nd \nmistakesandinappropriatecodingpatterns that may lead to bloat, and in the tuning phase, with the help \nof a dynamic allocation-frequency pro.le, to detect inef.ciently-used containers that can be optimized \nacross inputs, environments, and con.gurations. CFL-reachability It is well known that method calls \nand returns canbe treated aspairs ofbalancedparentheses using a context-free language [28, 30, 31, 32]. \nSridharan and Bodik propose a CFL\u00adreachabilityformulation toprecisely modelheap accesses and call\u00adingcontextsfor \ncomputing apoints-to solutionforJava[37].As an extension ofthisformulation,Zheng andRugina[46]de.ne aCFL\u00adreachability \nformulation for C/C++ alias analysis. Our previous work [45] proposes the CFL-reachability formulation \nof a must\u00adnot-alias analysis(based on a simpli.ed context-freelanguage) in order to scale theSridharan-Bodikpoints-to \nanalysis. CFL-reachability can be used to implement polymorphic .ow analysis [27], shape analysis [29], \nand information .ow analy\u00adsis [19]. The work in [16, 21] studies the connection between CFL-reachabilityand \nset-constraints, shows the similaritybetween the two problems, and provides new implementation strategies \nfor problemsthatcanbeformulatedinthis manner.Whilebased onthe Sridharan-Bodik formulation of points-to \nanalysis, our approach takes into account container-speci.c structures, and could poten\u00adtiallyhave a \nrange of applications inproblems that need reasoning about containerbehavior.Examples of suchproblemsinclude \nsum\u00admary generation for containers for more scalable static analyses, staticcontainer-based memoryleakdetection[13],andothertech\u00adniques(e.g.,thinslicing[38])thatneedtotrackthe \n.owof con\u00adtainer elements while ignoring objects that form the internal con\u00adtainer structures. Object \nreachability analysis The work closest to ours is the dis\u00adjoint reachability analysis proposed by Naik \nand Aiken [25] for eliminating false positives in their Java data race detector. This analysis is also \n.ow-insensitive and takes into account loop in\u00adformation to distinguish instances created by the same \nallocation site.Unlike this analysis, which uses object-sensitivity to compute reachability information, \nwe employ a CFL-reachability formula\u00adtion that is capable of .ltering out information irrelevant to con\u00adtainer \nobjects;asa result,our analysis may scaletolargerprograms. Other reachability analysis algorithms range \nfrom .ow-sensitive approximations ofheap shape(e.g.,[6,7,34])todecisionproce\u00addures(e.g.,[17,20]).Whileour \nanalysisislesspreciseindiscov\u00adering theshape ofdatastructures,itismorescalable andhasbeen shown tobe \neffectiveindetecting containerproblems. There exists alargebody of work on ownership types and their \ninference algorithms[1,5,8,10,13,18].Ownershiptypesprovide a way ofspecifying object encapsulation and \nenablelocal reasoning about program correctness in object-oriented languages. Existing ownership type \ninference algorithms may not be able to provide precise container information, because containers are \nusually de\u00adsigned to have polymorphic object ownership some objects of a containertype may owntheir elements \nwhile others may not.In ad\u00addition, containers are complicated because they can be nested: the elementsin \na container may themselvesbe containers.As apointer to a container is passed around, ownership of the \ncontainer may transfer.Whilethe workfrom[14]proposes an abstractobject own\u00adership model speci.cally for \ncontainers, it requires the tool users to specify correctinterfacesfor containerimplementation routines, \nwhich are then usedin the ownership inference algorithm.Our ap\u00adproach is completely automated and does \nnot require any user an\u00adnotationsfordetectingproblems with thebuilt-inJava collections. 6. Conclusions \nThis paper presents practical static and dynamic analyses that can automatically .nd inef.ciently-used \ncontainers. The goal of these analysesisto check,for each container, whetherithas enoughdata added and \nwhether it is looked up suf.cient number of times. At the heart of these tools is a base static analysis \nthat abstracts con\u00adtainer functionality into basic operations ADD and GET, and de\u00adtects them by formulating \nCFL-reachabilityproblems. The identi\u00ad.ed operations can be used by a static inference engine that infers \nthe relationship between their execution frequencies, and by a dy\u00adnamicanalysisthatinstrumentsthesestatementsand \n.ndsbloatby pro.lingtheirfrequencies.Experimentalresults showthatthe static analysis can scale to large \nJava applications and can generate pre\u00adcise warnings about the suspicious usage of containers. Promising \ninitial case studies suggest that the proposed techniques could be usefulforidentifying container-related \noptimization opportunities. Acknowledgments We thank Gary Sevitsky for his helpful com\u00adments on an earlierdraft \nof thispaper.We would alsolike to thank the anonymous reviewers for their valuable and thorough com\u00adments.This \nresearch was supportedby theNationalScienceFoun\u00addation under CAREER grant CCF-0546040 and by an IBM Soft\u00adwareQualityInnovationFacultyAward. \nReferences [1] J.Aldrich,V.Kostadinov,andC.Chambers.Aliasannotationsforpro\u00adgram understanding. In ACM \nSIGPLAN International Conference on Object-Oriented Programming,Systems,Languages, andApplications (OOPSLA),pages311 \n330,2002. [2] S.M.Blackburn,R.Garner,C.Hoffman,A.M.Khan,K.S.McKin\u00adley, R. Bentzur, A. Diwan, D. Feinberg, \nD. Frampton, S. Z. Guyer, M.Hirzel,A.Hosking,M.Jump,H.Lee,J.E.B.Moss,A.Phansalkar, D. Stefanovi\u00b4c, T. \nVanDrunen, D. von Dincklage, and B. Wieder\u00admann. The DaCapo benchmarks: Java benchmarking development \nand analysis. In ACMSIGPLANInternationalConference onObject\u00adOrientedProgramming,Systems,Languages, andApplications(OOP\u00adSLA),pages169 \n190,2006.  [3] M. D. Bond and K. S. McKinley. Bell: Bit-encoding online memory leak detection. In International \nConference on Architectural Support forProgrammingLanguages andOperatingSystems(ASPLOS),pages 61 72,2006. \n[4] M. D. Bond and K. S. McKinley. Leak pruning. In International Conference on Architectural Support \nfor Programming Languages and Operating Systems(ASPLOS),pages277 288,2009. [5] C. Boyapati, B. Liskov, \nand L. Shrira. Ownership types for object encapsulation. In ACM SIGPLAN-SIGACT Symposium on Principles \nof ProgrammingLanguages(POPL),pages213 223,2003. [6] C. Calcagno, D. Distefano, P. OHearn, and H. Yang. \nCompositional shape analysis by means ofbi-abduction. In ACMSIGPLAN-SIGACT Symposium onPrinciples ofProgramming \nLanguages(POPL),pages 289 300,2009. [7] B. Chang and X. Rival. Relational inductive shape analysis. In \nACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages(POPL),pages247 260,2008. [8] D. Clarke \nand S. Drossopoulou. Ownership, encapsulation and the disjointness of type and effect. In ACM SIGPLAN \nInternational Conference on Object-Oriented Programming, Systems, Languages, and Applications(OOPSLA),pages292 \n310,2002.  [9] B. Dufour, B. G. Ryder, and G. Sevitsky. A scalable technique for characterizing the \nusage of temporaries in framework-intensive Java applications. In ACM SIGSOFT International Symposium \non the Foundations ofSoftwareEngineering(FSE),pages59 70,2008. [10] C.Grothoff,J.Palsberg,andJ.Vitek.Encapsulating \nobjectswith con\u00ad.ned types. In ACM SIGPLAN International Conference on Object\u00adOrientedProgramming,Systems,Languages, \nandApplications(OOP\u00adSLA),pages241 255,2001. [11] S. Gulwani, S. Jain, and E. Koskinen. Control-.ow re.nement \nand progressinvariants forboundanalysis. In ACMSIGPLANConference onProgrammingLanguageDesign andImplementation(PLDI),pages \n375 385,2009. [12] S. Gulwani, K. Mehra, and T. Chilimbi. SPEED: Precise and ef.\u00adcient staticestimation \nofprogramcomputational complexity. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Lan\u00adguages(POPL),pages127 \n139,2009. [13] D. L. Heine and M. S. Lam. A practical .ow-sensitive and context\u00adsensitiveC andC++ memoryleakdetector. \nIn ACMSIGPLANConfer\u00adenceonProgramming LanguageDesign andImplementation(PLDI), pages168 181,2003. [14] \nD.L.Heine andM.S.Lam. Staticdetection ofleaksinpolymorphic containers. In International Conference on \nSoftware Engineering (ICSE),pages252 261,2006. [15] M.JumpandK.S.McKinley.Cork:Dynamicmemoryleakdetection \nforgarbage-collectedlanguages. In ACM SIGPLAN-SIGACTSympo\u00adsium onPrinciples ofProgrammingLanguages(POPL),pages31 \n38, 2007. [16] J. Kodumal and A. Aiken. The set constraint/CFL reachability con\u00adnection in practice. \nIn ACM SIGPLAN Conference on Programming Language Design and Implementation(PLDI),pages207 218,2004. \n[17] T. Lev-Ami, N. Immerman, T. Reps, M. Sagiv, and S. Srivastava. Simulating reachability using .rst-order \nlogic with applications to veri.cation of linked data structures. In International Conference on Automated \nDeduction(CADE),pages99 115,2005. [18] Y. Liu and A. Milanova. Ownership and immutability inference for \nUML-based object access control. In International Conference on Software Engineering(ICSE),pages323 332,2007. \n[19] Y. Liu and A. Milanova. Static analysis for inference of explicit information .ow.InACMSIGPLAN-SIGSOFTWorkshoponProgram \nAnalysisforSoftwareTools andEngineering(PASTE), pages 50 56, 2008. [20] S. McPeak and G. Necula. Data \nstructure speci.cations via local equality axioms. In International Conference on Computer Aided Veri.cation(CAV),pages476 \n490,2005. [21] D.Melski andT.Reps. Interconvertibility of aclass of set constraints and context-free-language \nreachability. Theoretical Computer Sci\u00adence,248:29 98,2000. [22] N. Mitchell, E. Schonberg, and G. Sevitsky. \nFour trends leading to Java runtimebloat. IEEESoftware,27(1):56 63, 2010. [23] N.Mitchell andG.Sevitsky. \nThecauses ofbloat,thelimits ofhealth. In ACMSIGPLANInternationalConference onObject-OrientedPro\u00adgramming, \nSystems, Languages, and Applications (OOPSLA), pages 245 260,2007. [24] N. Mitchell, G. Sevitsky, and \nH. Srinivasan. Modeling runtime be\u00adhavior in framework-based applications. In European Conference on \nObject-Oriented Programming(ECOOP),pages429 451,2006. [25] M. Naik and A. Aiken. Conditional must not \naliasing for static race detection. In ACM SIGPLAN-SIGACT Symposium on Principles of ProgrammingLanguages(POPL),pages327 \n338,2007. [26] G. Novark, E. D. Berger, and B. G. Zorn. Ef.ciently and precisely locating memory leaks \nand bloat. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), pages \n397 407,2009. [27] J.RehofandM.F\u00a8ahndrich. Type-based .owanalysis:Frompoly\u00admorphic subtyping to CFL-reachability. \nIn ACM SIGPLAN-SIGACT Symposium onPrinciples ofProgramming Languages(POPL),pages 54 66,2001. [28] T. \nReps. Solving demand versions of interprocedural analysis prob\u00adlems. In International Conference on Compiler \nConstruction (CC), pages389 403,1994. [29] T.Reps. Shape analysis asageneralizedpathproblem. In ACM SIG-PLAN \nSymposium on Partial Evaluation and Semantics-based Pro\u00adgramManipulation(PEPM),pages1 11,1995. [30] T. \nReps. Program analysis via graph reachability. Information and Software Technology, 40(11-12):701 726, \n1998. [31] T. Reps, S. Horwitz, and M. Sagiv. Precise interprocedural data.ow analysis via graph reachability. \nIn ACM SIGPLAN-SIGACT Sympo\u00adsium onPrinciples ofProgrammingLanguages(POPL),pages49 61, 1995. [32] T. \nReps, S. Horwitz, M. Sagiv, and G. Rosay. Speeding up slicing. In ACM SIGSOFT International Symposium \non the Foundations of Software Engineering(FSE),pages11 20,1994. [33] A. Rountev, A. Milanova, and B. \nG. Ryder. Fragment class analysis for testing of polymorphism in Java software. IEEE Transactions on \nSoftware Engineering,30(6):372 387, 2004. [34] M. Sagiv, T. Reps, and R. Wilhelm. Parametric shape analysis \nvia 3-valued logic. ACM Transactions on Programming Languages and Systems,24(3):217 298, 1999. [35] O. \nShacham, M. Vechev, and E. Yahav. Chameleon: Adaptive selec\u00adtion of collections. In ACM SIGPLAN Conference \non Programming LanguageDesign andImplementation(PLDI),pages408 418,2009. [36] A. Shankar, M. Arnold, \nand R. Bodik. JOLT: Lightweight dynamic analysis and removal of object churn. In ACMSIGPLANInternational \nConference on Object-Oriented Programming, Systems, Languages, and Applications(OOPSLA),pages127 142,2008. \n[37] M. Sridharan and R. Bodik. Re.nement-based context-sensitive points-to analysis for Java. In ACM \nSIGPLAN Conference on Pro\u00adgramming LanguageDesign andImplementation(PLDI),pages387 400,2006. [38] M. \nSridharan, S. J. Fink, and R. Bodik. Thin slicing. In ACM SIG-PLANConference onProgrammingLanguageDesign \nandImplemen\u00adtation(PLDI),pages112 122,2007. [39] M. Sridharan, D. Gopan, L. Shan, and R. Bodik. Demand-driven \npoints-to analysis for Java. In ACM SIGPLAN International Con\u00adference on Object-Oriented Programming, \nSystems, Languages, and Applications(OOPSLA),pages59 76,2005. [40] Z. Su and D. Wagner. A class of polynomially \nsolvable range con\u00adstraintsforinterval analysis without widenings. TheoreticalComputer Science, 345(1):122 \n138, 2005. [41] R. Vall\u00b4ee-Rai,E. Gagnon,L. Hendren,P. Lam,P. Pominville, and V. Sundaresan. Optimizing \nJava bytecode using the Soot framework: Is it feasible? In International Conference on Compiler Construction \n(CC),pages18 34,2000. [42] G.Xu,M.Arnold,N.Mitchell,A.Rountev,andG.Sevitsky. Gowith the .ow: Pro.ling \ncopies to .nd runtime bloat. In ACM SIGPLAN Conference on Programming Language Design and Implementation \n(PLDI),pages419 430,2009. [43] G.Xu,N.Mitchell,M.Arnold,A.Rountev,E.Schonberg,andG.Se\u00advitsky. Findinglow-utility \ndata structures. In ACMSIGPLANConfer\u00adence onProgramming LanguageDesign andImplementation(PLDI), 2010. \n[44] G. Xu and A. Rountev. Precise memory leak detection for Java software using container pro.ling. \nIn International Conference on Software Engineering(ICSE),pages151 160,2008. [45] G.Xu,A.Rountev,andM.Sridharan.ScalingCFL-reachability-based \npoints-to analysis using context-sensitive must-not-alias analysis. In European Conference on Object-Oriented \nProgramming (ECOOP), pages98 122,2009. [46] X. Zheng and R. Rugina. Demand-driven alias analysis for \nC. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages(POPL),pages197 208,2008.  \n \n\t\t\t", "proc_id": "1806596", "abstract": "<p>Runtime bloat degrades significantly the performance and scalability of software systems. An important source of bloat is the inefficient use of containers. It is expensive to create inefficiently-used containers and to invoke their associated methods, as this may ultimately execute large volumes of code, with call stacks dozens deep, and allocate many temporary objects.</p> <p>This paper presents practical static and dynamic tools that can find inappropriate use of containers in Java programs. At the core of these tools is a base static analysis that identifies, for each container, the objects that are added to this container and the key statements (i.e., heap loads and stores) that achieve the semantics of common container operations such as <i>ADD</i> and <i>GET</i>. The static tool finds problematic uses of containers by considering the nesting relationships among the loops where these <i>semantics-achieving statements</i> are located, while the dynamic tool can instrument these statements and find inefficiencies by profiling their execution frequencies.</p> <p>The high precision of the base analysis is achieved by taking advantage of a context-free language (CFL)-reachability formulation of points-to analysis and by accounting for container-specific properties. It is demand-driven and client-driven, facilitating refinement specific to each queried container object and increasing scalability. The tools built with the help of this analysis can be used both to avoid the creation of container-related performance problems early during development, and to help with diagnosis when problems are observed during tuning. Our experimental results show that the static tool has a low false positive rate and produces more relevant information than its dynamic counterpart. Further case studies suggest that significant optimization opportunities can be found by focusing on statically-identified containers for which high allocation frequency is observed at run time.</p>", "authors": [{"name": "Guoqing Xu", "author_profile_id": "81350590981", "affiliation": "Ohio State University, Columbus, OH, USA", "person_id": "P2184534", "email_address": "", "orcid_id": ""}, {"name": "Atanas Rountev", "author_profile_id": "81100162864", "affiliation": "Ohio State University, Columbus, OH, USA", "person_id": "P2184535", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1806596.1806616", "year": "2010", "article_id": "1806616", "conference": "PLDI", "title": "Detecting inefficiently-used containers to avoid bloat", "url": "http://dl.acm.org/citation.cfm?id=1806616"}