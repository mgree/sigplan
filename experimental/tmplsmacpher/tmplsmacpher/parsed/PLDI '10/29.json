{"article_publication_date": "06-05-2010", "fulltext": "\n MemSAT: Checking Axiomatic Speci.cations of Memory Models Emina Torlak Mandana Vaziri Julian Dolby \nIBM T. J. Watson Research Center, Hawthorne, NY, USA {etorlak, mvaziri, dolby}@us.ibm.com Abstract Memory \nmodels are hard to reason about due to their complexity, which stems from the need to strike a balance \nbetween ease-of\u00adprogramming and allowing compiler and hardware optimizations. In this paper, we present \nan automated tool, MEMSAT, that helps in debugging and reasoning about memory models. Given an ax\u00adiomatic \nspeci.cation of a memory model and a multi-threaded test program containing assertions, MEMSAT outputs \na trace of the program in which both the assertions and the memory model ax\u00adioms are satis.ed, if one \ncan be found. The tool is fully automatic and is based on a SAT solver. If it cannot .nd a trace, it \noutputs a minimal subset of the memory model and program constraints that are unsatis.able. We used MEMSAT \nto check several existing memory models against their published test cases, including the current Java \nMemory Model by Manson et al. and a revised version of it by Sevcik and Aspinall. We found subtle discrepancies \nbe\u00adtween what was expected and the actual results of test programs. Categories and Subject Descriptors \nD.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation Formal Methods, Model Checking; D.1.3 [Programming \nTechniques]: Concurrent Pro\u00adgramming; F.3.1 [Logics and Meaning of Programs]: Specifying and Verifying \nand Reasoning about Programs Assertions, Me\u00adchanical Veri.cation General Terms Algorithms, Design, Languages, \nVeri.cation Keywords Memory Models, Axiomatic Speci.cations, Bounded Model Checking, SAT 1. Introduction \nIn a multi-threaded shared-memory system, a memory (consis\u00adtency) model speci.es how concurrent accesses \nto shared mem\u00adory are permitted to behave. In particular, a memory model deter\u00admines which writes to \na given location any read of that location may observe. The most intuitive memory model is sequential \ncon\u00adsistency [16], which requires simply that all accesses appear to exe\u00adcute one at a time, respecting \nthe program order of each thread. But this simplicity comes at a price: the strict ordering requirements \nim\u00adposed by sequential consistency disallow many compiler and hard\u00adware optimizations that reorder instructions. \nAs a result, most sys- Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 10, June 5 10, 2010, Toronto, Ontario, Canada. Copyright c &#38;#169; 2010 ACM 978-1-4503-0019-3/10/06. \n. . $10.00 tems exhibit relaxed memory models (e.g., [1, 19]), which enable common instruction optimizations \nby stipulating weaker, and more complex, ordering rules. To make such rules accessible to program\u00admers, \nformal speci.cations of memory models are usually supple\u00admented with small programs, called litmus tests, \nthat illustrate how the rules work. Litmus tests elucidate a memory model insofar as they are con\u00adsistent \nwith its formal speci.cation. Many automated techniques have therefore been developed for checking litmus \ntests and other micro-benchmarks against relaxed memory models. Tools based on model checking [7, 31], \nconstraint solving [4, 11, 33], and cus\u00adtom search [24] have been successfully applied to axiomatic spec\u00adi.cations \nof hardware memory models, such as the Intel Itanium and x86-CC Model, and to operational approximations \nof the Java Memory Model (JMM) [19]. But the JMM itself, which is given axiomatically, has so far eluded \nautomatic checking despite a rec\u00adognized need for it [3]. The large state space induced by the model \ns committing semantics has often been cited as prohibitive for model checking [2]. This paper presents \nMEMSAT, the .rst automated tool for de\u00adbugging and reasoning about memory models that can handle the \nfull axiomatic speci.cation of the JMM. MEMSAT takes as input a memory model described by a set of constraints \nand a litmus test containing assertions. It then searches for a trace of the program in which both the \nassertions and the memory model constraints are satis.ed. Assertions provide a convenient means of encoding \nthe expected outcome of a litmus test, in that they express whether the computation of a given value \nat a given program point is permitted by the memory model. Constraints provide a natural means of ex\u00adpressing \nmemory models. As argued in prior work [34], axiomatic speci.cations are easier to write and to understand \nthan operational speci.cations, since they naturally decompose into the constituent rules of a memory \nmodel. Operational speci.cations, on the other hand, tend to be monolithic and coupled to speci.c data \nstructures. MEMSAT is fully automatic, requiring no user guidance, and is based on the Kodkod constraint \nsolver [28], which works by reduction to SAT. The test program is translated into constraints that are \nassembled with the constraints describing the memory model. We then employ an optimization based on Kodkod \ns ability to complete a partial model to reduce the search space. If the combined result is satis.able, \nour tool outputs a concrete execution of the program, called a witness, that is permitted by the memory \nmodel. Otherwise, it outputs a minimal subset of the constraints that are collectively unsatis.able, \ncalled a minimal unsatis.able core. Either a witness or a minimal core can help in debugging the test \nprogram or the memory model: a witness provides a concrete trace of memory operations that the user can \nexamine as to whether it is intended, and a core shows which constraints i.e., which rules in the memory \nmodel prevent the assertions in the program from being satis.ed. We used MEMSAT to check several existing \nmemory models against their published test cases. We considered the Java Memory Model by Manson et al. \n[19] and a revised version of it by Sevcik and Aspinall [25]. We also studied .ve well-known memory mod\u00adels \nwith existing axiomatic descriptions [34], including processor and causal consistency. For the JMM, our \nexperiments con.rmed that two causality test cases [6] did not behave as expected for the original model \nand that the revised version .xes these. We also discovered that the original JMM [19] correctly allows \ntwo other causality test cases that Aspinall and Sevcik report as forbidden [3]. For the other models, \nwe found several discrepancies between the expected and actual results of tests. Our case studies indicate \nthat MEMSAT can be used to quickly and easily run litmus tests against different memory models. For litmus \ntests that contain no loops, the result of MEMSAT is sound and complete, meaning that there are no spurious \nwitnesses, and if a witness exists, it is found. Otherwise, MEMSAT uses an under\u00adapproximation, and may \nmiss witnesses, so it is sound but not complete. In practice, however, we have found that most litmus \ntests for memory models at the programming language level do not contain loops. 2. Overview MEMSAT is \ndesigned as an extensible framework for specifying, testing and debugging memory models. It takes as \ninputs a multi\u00adthreaded test program with one or more assertions; a speci.cation of a memory model in \nrelational logic [14]; and a set of code .ni\u00adtization parameters, such as the number of times to unwind \nloops and the length of bitvectors used to represent integers. The test pro\u00adgram is then .nitized (by \nunwinding loops and bounding recur\u00adsive method calls) and translated to relational logic. The resulting \nconstraints are combined with the memory model constraints and checked with a SAT-based constraint solver. \nIf the combined con\u00adstraints are satis.able, the program is said to be legal with respect to the memory \nmodel, and the output of the tool is a concrete wit\u00adness of legality, expressed in terms of the relations \nconstrained by the memory model. Otherwise, the program is said to be illegal, and the output is a proof \nof illegality, expressed as a minimal un\u00adsatis.able core of the combined constraints. 2.1 Test program \nA test program consists of an (implicit) initialization thread and two or more user threads. The initialization \nthread executes .rst, writing initial values to all shared memory locations referenced in the program. \nThe user threads execute after initialization has com\u00adpleted, running either in parallel or in a partial \norder speci.ed by the user. Programs are encoded in a subset of Java that includes control .ow constructs, \nthe synchronized construct (which generates lock and unlock instructions on a given monitor), method \ncalls, .eld and array accesses, integer and boolean operations, and assertions. Figure 1 shows a test \nprogram from Manson et al. [19] both in a standard schematic notation [19, 25] and as an annotated Java \nprogram accepted by MEMSAT. The program consists of an initialization thread and two user threads that \nexecute in parallel. In the schematic notation (Fig. 1(a)), threads that run in parallel are separated \nby a vertical bar; threads whose execution is partially ordered are separated by horizontal bars. In \nthe Java encoding (Fig. 1(b)), the implicit static initialization method holds the code for the initialization \nthread, while the methods annotated with @thread indicate user threads. The (static) variables x and \ny refer to shared memory locations, and r1 and r2 refer to thread-local registers.  2.2 Memory model \nspeci.cation A memory model is speci.ed as a set of constraints in relational logic (\u00a73) that is, .rst \norder logic with quanti.ers, set-theoretic 1 public class Test0 { s0 2 static int x = 0; a01 3 static \nint y = 0; a02 4 e0 5 @thread 6 public static void t1() { s1 7 int r1=x; a11 x=y=0 8 y = 1; a12 r1 = \nx r2 = y 9 assert r1 == 1; y=1 x=1 10 } e1 11 @thread 12 public static void t2() { s2 13 int r2=y; a21 \n14 x = 1; a22 15 assert r2 == 1; 16 } e2 17 } r1 == r2 == 1? (a) Schematic notation (b) Annotated Java \nencoding Figure 1. A sample litmus test for memory consistency models. operators, transitive closure, \nand bitvector arithmetic.1 These con\u00adstraints are given over relations that describe properties of test \npro\u00adgrams (such as control .ow) and their executions (such as the value written by a given write instruction). \nEach MEMSAT relation is de.ned in terms of memory-related operations, or actions, that are performed \nwhen a test program is executed. Actions are partitioned into thread start, thread end, (volatile) read, \n(volatile) write, lock, unlock, and special operations. Read, write, lock and unlock ac\u00adtions are generated \nby executing read, write and synchronize in\u00adstructions. Special actions are generated by calls to methods \nthat are designated as special in the de.nition of a given memory model (e.g., I/O methods in the Java \nMemory Model). Thread start and end actions mark the beginning and termination of a thread and do not \ncorrespond to any instructions. Our framework provides two kinds of relations for specifying memory models: \nrelational constants and relational variables. Re\u00adlational constants capture static program properties, \nand MEMSAT infers their values directly from the program text. For example, the relative ordering of \nactions within a program s control .ow graph is represented by the constant binary relation co. The value \nof co for the program in Fig. 1 is the set {(s0, a01), (a01, a02), (a02, e0), (s1, a11), (a11, a12), \n(a12, e1), (s2, a21), (a21, a22), (a22, e2)}, where aij represents the action performed by the jth memory\u00adrelated \ninstruction of the ith thread, and si and ei represent the start and end actions of the ith thread. In \nthis example, it suf.ces to think of an action as the memory operation performed by a given statement; \nhowever, the relationship can be more complex under the JMM, due to its speculative executions. Relational \nvariables capture execution properties. In our frame\u00adwork, an execution E is a structure .A, W, V, l, \nm, O1,..., On.in which the relation A denotes the subset of the program s actions that are executed; \nthe write-seen relation W maps each executed read to the write of which the value is seen by that read; \nthe value\u00adwritten relation V maps each write action to the value that is writ\u00adten; the location-accessed \nrelation l maps each read and write to the memory location that it accesses; and the monitor-used relation \nm maps each lock and unlock to its associated monitor. The de.nition of an execution may also include \nany number of ordering relations Oi over A (e.g., happens-before) that are speci.c to a given mem\u00adory \nmodel. Example: Sequential Consistency Sequential consistency (SC) is perhaps the best known and most \neasily understood mem\u00ad 1 Relational constraints are provided to MEMSAT using a Java API, rather than \nthe illustrative syntax used in this paper. ory model. It requires simply that all executed actions \nappear in a (weak) total order that is consistent with the program order. Fig\u00adure 2 shows a relational \nspeci.cation of sequential consistency without synchronization, transcribed from Yang et al. [34]. Con\u00adstants \nare displayed in the sans-serif font, logic keywords in the roman font, and variables in italics. The \nexpression r[x], where r is a binary relation and x is a scalar (or, in relational logic, a singleton \nunary relation), denotes the relational image of x under r; r[x, y] denotes a formula that evaluates \nto true only if the relation r maps x to y; and r + denotes the transitive closure of r. The operator \none constrains its argument relation to contain exactly one tuple. 1 .i, j : A | i = j =. (ord[i, j] \n. ord[j, i]) 2 .i, j : A | ord[i, j]=.\u00ac ord[j, i] 3 .i, j, k : A | (ord[i, j] . ord[j, k]) =. ord[i, \nk] + 4 .i, j : A | (t[i]= t[j] . co [i, j]) =. ord[i, j] + 5 .i, j : A | (t[i]= t[j] . to[t[i], t[j]]) \n=. ord[i, j] 6 .k :A n Read | one W [k] . W [k] . (A n Write) 7 .k :A n Read | l[k]= l[W [k]] 8 .k :A \nn Read |\u00ac ord[k, W [k]] 9 .k :A n Read,j : A n Write|\u00ac(l[j]= l[k] . ord[W [k],j] . ord[j, k]) Figure \n2. Sequential consistency in relational logic. We de.ne sequential consistency in terms of the execution \nstructure E = A, W, V, l, m, ord and program constants co, to, t, Read and Write. The variable ord models \nthe ordering of the executed actions A; the constant t maps each action in a program to the thread that \nexecutes it; the constant to denotes the partial exe\u00adcution order among threads; and Read and Write model \nall actions in a program whose action kind is a read or a write, respectively. The .rst three formulas \nin Fig. 2 constrain ord to be weakly total, asymmetric and transitive. The fourth and .fth formulas specify \nthat it is consistent with the program order and the thread execution order. The sixth and seventh formulas \nconstrain W to be a function from executed reads to executed writes and to be consistent with the location-accessed \nrelation. The last two formulas require that W be consistent with ord: a read k cannot see a write that \nfol\u00adlows it in the ord relation, and no write to l[k] is ordered (by ord) between W [k] and k. Example: \nJava Memory Model. The Java Memory Model (JMM) speci.es what behavior is legal for a given program using \na committing semantics [2, 3, 19, 25]. An execution is legal if it can be derived from a sequence of \nspeculative executions of the program, constructed according to the following rules. The .rst execution \nin the sequence is well-behaved [3]: its reads can only see writes that happen-before them. The happens-before \nordering (hb) transitively relates reads and writes in an execution according to the program order (po) \nand the synchronizes-with (sw) order implied by synchronization constructs. The remaining executions \nin the sequence are derived from the initial well-behaved execution by committing and executing data \nraces. After each execution, one or more data races from that execution are chosen, and the reads and \nwrites involved in those data races are remembered, or committed. The committed data races are then executed \nin the next execution: each read in the execution must either be committed and see a committed write \nthrough a race, or it must see a write through the happens-before relation. The committed writes must \nalso be executed, and they must write the committed values. Any execution reachable through this process \nis legal under the JMM. Figure 3 presents a relational formalization of the revised JMM, transcribed \nfrom Sevcik and Aspinall [25]. A JMM execution E = A, W, V, l, m, po, so, hb, sw includes four ordering \nrela\u00ad a WELL-FORMED(E) ..i: [1..k] | WELL-FORMED(Ei) Si=k b A = i=0 Ci . C0 = \u00d8..i:[1..k] | Ci-1 . \nCi c .i :[1..k] | Ci <li = Ci <l . Ci <mi = Ci <m 1 .i :[1..k] | Ci . Ai 2 .i :[1..k],r : Ci n Read | \n(hb[W [r],r] .. hbi [W [r],r]) .\u00achbi [r, W [r]] 3 .i :[1..k] | Ci <Vi = Ci <V 4 .i :[1..k] | Ci-1 <Wi \n= Ci-1 <W 5 .i :[1..k],r :(Ai \\ Ci) n Read | hbi [Wi(r),r] 6 .i :[1..k],r :(Ci \\ Ci-1) n Read | W [r] \n. Ci-1 7 .i :[1..k],y :Ci,x: Ai | (y . Special . hb[x, y]) =. x . Ci Figure 3. Revised JMM in relational \nlogic. tions: po, so, hb, and sw. The relation po models the program order, which is total over the \nactions of a single thread and which does not relate actions from different threads; so is a total order \nover all synchronization actions in A (i.e., the lock, unlock, thread start and thread end actions); \nsw consists of the tuples (a, b) in so such that a is an unlock and b is a lock on a given monitor, or \na is a write and b is a read of a given volatile location in shared memory; and hb is the transitive \nclosure of po . sw. An execution is well\u00adformed, denoted by WELL-FORMED(E), if its constituent relations \nsatisfy De.nition 7 of the revised JMM [25], which we omit here for brevity. A well-formed execution \nE is legal if there is a .nite se\u00adquence of sets Ci, where 0 = i = k, and a .nite sequence of well\u00adformed \nexecutions Ei = Ai,Wi,Vi,li,mi, poi , soi , hbi , swi , where 1 = i = k, that satisfy the constraints \nin Fig. 3. The upper bound on the number of speculative executions, denoted by k, can either be provided \nas an input to the tool or MEMSAT will compute a sound k from the program text. The symbol < denotes \ndomain re\u00adstriction, and all other symbols have their previously de.ned or standard meaning. 2.3 Proof \nof legality (witness) Given a test program P and a memory model M, MEMSAT gen\u00aderates a legality formula \nF (P, M) of the form Vi=k F (P, E) . Fa(P, E) . i=1 F (P, Ei) . MP (E, E1,...,Ek), where k = 0; F (P, \nE) is true only if the execution E respects the intra-thread semantics of P ; Fa(P, E) is true only if \nE satis.es all of the assertions in P ; and MP (E, E1,...,Ek) is true only if the constraints that constitute \nM are satis.ed with respect to the constants and variables that describe P and E, E1,...,Ek. A model \nof the formula F (P, M) is an assignment of relational values (i.e., sets of tuples) to the variables \nin E, E1,...,Ek which makes each constraint in the formula true. This assignment, if it exists, is a \nconcrete witness that at least one execution of P is both legal with respect to M and satis.es all the \nassertions in P . The tuples that comprise a MEMSAT model are drawn from a .nite set, or universe, of \nsymbolic values computed by the tool based on the program text and the values of the .nitization parameters. \nFigure 4 shows a witness that demonstrates the legality of the program in Fig. 1 with respect to the \nrevised JMM (Fig. 3). For readability, MEMSAT displays formatted snippets of the model produced by the \nconstraint solver rather than the complete assign\u00adment from variables to values. Each action in the set \nA (or Ai) of executed actions is annotated with its action kind. Read and write actions are additionally \nannotated with the location they ac\u00adcess and the value they read or write. For example, the annotation \n::read(x,0) on the action a11 in the set A1 means that a11 was a read of the value 0 from the .eld x \n(i.e. V1[W1[a11]] = 0 and l1[a11]= x). The values assigned to orderings such as hb are E1 A1 = { s0::start, \na01::write(x,0), a02::write(y,0), e0::end, s1::start, s2::start, a11::read(x,0), a21::read(y,0), a12::write(y,1), \na22::write(x,1), e1::end, e2::end } W1 = {(a11, a01), (a21, a02)} hb1 = {(s0, a01), (a01, a02), (a02, \ne0), (e0, s1), (e0, s2), (s1, a11), (a11, a12), (a12, e1), (s2, a21), (a21, a22), (a22, e2)} C1 = {a12, \na22} E2 A2 = { s0::start, a01::write(x,0), a02::write(y,0), e0::end, s1::start, s2::start, a11::read(x,0), \na21::read(y,0), a12::write(y,1), a22::write(x,1), e1::end, e2::end } W2 = {(a11, a01), (a21, a02)} hb2 \n= {(s0, a01), (a01, a02), (a02, e0), (e0, s1), (e0, s2), (s1, a11), (a11, a12), (a12, e1), (s2, a21), \n(a21, a22), (a22, e2)} C2 = A2 E A = { s0::start, a01::write(x,0), a02::write(y,0), e0::end, s1::start, \ns2::start, a11::read(x,1), a21::read(y,1), a12::write(y,1), a22::write(x,1), e1::end, e2::end } W = {(a11, \na22), (a21, a12)} hb = {(s0, a01), (a01, a02), (a02, e0), (e0, s1), (e0, s2), (s1, a11), (a11, a12), \n(a12, e1), (s2, a21), (a21, a22), (a22, e2)} Figure 4. A witness for the program in Fig. 1 under the \nrevised JMM (Fig. 3). shown partially; we only display the tuples in their transitive re\u00adduction. Operationally, \nthe execution E in Fig. 4 is justi.ed as follows. We start with the well-behaved execution E1, in which \neach read sees the write that happens before it. Both the read of x by the thread t1 and the read of \ny by t2 see the initial writes of 0 to these locations. The execution E1 has two data races that can \nbe committed: a11 and a22 form a data race on x, and a12 and a21 form a data race on y. MEMSAT chooses \nto commit both, setting C1 to {a12, a22}. The next execution, E2, performs the committed writes: a12, \na22 . A2, and each writes 1 to its respective location. Note that the reads of E2 still see the default \nwrites since they have not been committed to C1. We next commit the reads and all the remaining actions \nto C2. The .nal execution, E, performs the actions from C2, with each committed read seeing the write \nof 1 in the opposite thread.  2.4 Proof of illegality (minimal core) A formula that has no models is \nsaid to be unsatis.able. Unsatis\u00ad.ability of a legality formula F (P, M) means that the (.nitized) program \nP has no executions that are legal with respect to M and that also satisfy all the assertions in P . \nTo aid in the understanding of causes of illegality, MEMSAT produces a minimal unsatis.able core of the \nformula F (P, M). A minimal unsatis.able core is an unsatis.able subset of the formula s constraints \nthat becomes satis\u00ad.able if any of its members are removed. In other words, a minimal core represents \nan irreducible cause of unsatis.ability. constraint source V [a01]=0 Fig. 1(b), line 2 V [a02]=0 Fig. \n1(b), line 3 V [W [a11]] = 1 Fig. 1(b), line 9 V [W [a21]] = 1 Fig. 1(b), line 15 .i, j :A | i = j =. \n(ord[i, j] . ord[j, i]) Fig. 2, line 1 .i, j, k :A | (ord[i, j] . ord[j, k]) =. ord[i, k] Fig. 2, line \n3 + .i, j :A | (t[i]= t[j] . co [i, j]) =. ord[i, j] Fig. 2, line 4 .k :A n Read |\u00ac ord[k, W [k]] Fig. \n2, line 8 Figure 5. A minimal core for the program in Fig. 1 under sequen\u00adtial consistency (Fig. 2). \nFigure 5 shows a minimal core that illustrates why the program in Fig. 1 has no sequentially consistent \nexecutions. The .rst two constraints2 encode the meaning of the instructions on lines 2 and 3 of Fig. \n1(b). The next two constraints encode the assertions on lines 9 and 15. The remaining constraints are \ndrawn from the de.nition in Fig. 2. According to this core, the sample program is not sequentially consistent \nbecause all initial writes write 0; all assertions expect 1; all actions must be executed in a total \norder consistent with co (which, in this case, means that at least one of reads must occur before the \nnon-initial write to the same location); and no read can observe an out-of-order write. 3. Approach \nA MEMSAT analysis of a test program P and a memory model M involves .ve steps: 1. Converting P into an \nintermediate form I(P ); 2. Translating I(P ) into a relational representation R(P ); 3. Combining \nR(P ) and M into the legality formula F (P, M); 4. Computing a set of bounds B(P, M) on the space to \nbe searched for a model or a core of F (P, M); and 5. Finding a model or a core of the relational satis.ability \nproblem de.ned by F (P, M) and B(P, M).  The .rst and last steps use off-the-shelf tools, the WALA \n[29] pro\u00adgram analysis library and the Kodkod [26, 28] constraint solver. Translation, constraint assembly, \nand bounds computation com\u00adprise the core technical innovations of MEMSAT. 3.1 A brief introduction to \nrelational logic A key ingredient of our approach is the use of relational logic [14], which extends \n.rst-order logic with relational algebra and signed bitvector arithmetic. The basic concept in this logic \nis a relation: a set of tuples of equal length, drawn from a common universe of atoms. Atoms can denote \nintegers or uninterpreted symbolic values. The arity of a relation, which can be any positive integer, \ndetermines the length of its tuples. We refer to unary relations (i.e., relations of arity 1) as sets \nand to singleton unary relations as scalars. The kernel of the logic, shown in Fig. 6, includes standard \nbitvector operators; connectives and quanti.ers of .rst order logic; and the operators of relational \nalgebra. The latter include relational join (.), product (.), union (.), intersection (n), difference \n(\\), and transitive closure (+). The join (.) of two relations is the pair\u00adwise join of their tuples, \nwhere (a0, \u00b7\u00b7\u00b7 ,ak).(ak, \u00b7\u00b7\u00b7 ,an) yields 2As explained in the next section, MEMSAT encodes F (P, E) and \nevaluate to the action (if any) generated by E while executing the jth in-Fa(P, E) in terms of the variables \naij , each of which is constrained to struction of the ith thread. Expr := r |\u00d8| Expr+ | Expr rop Expr \n|{decl | Formula}|Formula ? Expr : Expr | Bits(Bitvec) Formula := Expr rcmp Expr | Bitvec bcmp Bitvec \n| [l]one Expr | \u00ac Formula | Formula fop Formula |. decl | Formula | . decl | Formula | true | false Bitvec \n:= v |\u00ac Bitvec | Bitvec bop Bitvec | bits(Expr) | |Expr| r := relation decl := x : Expr | decl, decl \n\u00d8 := empty relation rop := . | . |.|n |\\ rcmp := .| .| = | = fop := .|.| =. | .. bcmp := < |=| = | > \n|= bop := + |-|*| / | % |.|.|. Figure 6. Relational logic. (a0, \u00b7\u00b7\u00b7 ,ak-1,ak+1, \u00b7\u00b7\u00b7 ,an). We use e.r \nand r[e] interchange\u00adably to represent the join of e and r. The product (.) of two relations is the pairwise \nproduct of their tuples, which is de.ned as (a0, \u00b7\u00b7\u00b7 ,ak).(am, \u00b7\u00b7\u00b7 ,an) = (a0, \u00b7\u00b7\u00b7 ,ak,am, \u00b7\u00b7\u00b7 ,an). \nThe formulas lone Expr and one Expr are true for relations with at most one and exactly one tuple, respectively. \nThe cardinality ex\u00adpression |r| gives the number of tuples in r as a bitvector; bits(r) computes the \nsum of atoms representing integers in the set r as a bitvector; and Bits(v), where v is the bitvector \nb0 ...bk, evaluates to the set of integer atoms 2i for which bi 0. All other expres\u00ad = sions and formulas \nhave their standard meaning.  3.2 Preprocessing To translate a test program P to relational logic, MEMSAT \n.rst .nitizes P s code by unwinding all loops and inlining all method calls. The .nitized code is then \ntransformed into an intermediate structure I(P )= efg, guard, ptsTo, maySee , in which efg denotes the \nextended control .ow graph of P ; guard maps each instruction in efg to the control conditions that guard \nits execution; ptsTo maps each variable to the heap objects, if any, that it may point to at runtime; \nand maySee maps each read in efg to the set of writes that it may observe. All four components of I(P \n) are computed using standard WALA analyses [29]. of threads whose execution is partially ordered. The \nnodes of the graph are comprised of WALA statements3 (Fig. 8) in the Static Single Assignment (SSA) form, \nwhich gives a new name to every new de.nition of a variable. Variable de.nitions are merged using f statements, \nand heap accesses are expressed as explicit read and write statements. The synthetic start and end statements \nindicate the start and end of a thread. The value of guard(s, vi), where s is vj = f(\u00b7\u00b7\u00b7 ,vi, \u00b7\u00b7\u00b7 ), \nis the condition under which s assigns vi to vj . For all other statements, guard(s) evaluates to the \nconjunction of control conditions that must be true for s to execute [9]. JStmt := start | end | branch(JExpr) \n| assert(JExpr) | vi = JExpr | vj = f(\u00b7\u00b7\u00b7 ,vi, \u00b7\u00b7\u00b7 ) | lock(vref ) | unlock(vref ) | vi = read([vref \n, ] Field) | write([vref , ] Field, JLeaf ) JExpr := JLeaf | new(Class) | JExpr op JExpr | !JExpr JLeaf \n:= vi | null | true | false | 0 | -1 | 1 | -2 | 2 | ... Field := identi.er op := + |-|*| / | % | < | \n> | == | &#38;&#38; | | Class := identi.er Figure 8. Syntax for statements in the intermediate representation. \n 3.3 Translation The translation of a preprocessed program I(P ) to its relational representation R(P \n) relies on a translation function T : JExpr . Expr (Fig. 9) that takes a WALA expression and returns \na relational expression. Unlike prior relational encodings (e.g., [9]) for sequen\u00adtial programs, the \nfunction T does not interpret heap accesses. That is, if a variable vi is de.ned by a read statement \ns, T [vi] is an un\u00adconstrained unary relation .vi , which acts as a placeholder for the value read by \ns. In a sequential setting, a relational encoding for the value seen by a read can be computed directly \nfrom the pro\u00adgram text. In a concurrent setting, however, these values are deter\u00admined both by the program \nsemantics and by the memory model. The placeholders are a key feature of our framework that allows us \nto separate the encoding of program semantics from the speci\u00ad.cation of the memory model: T encodes the \nprogram semantics in terms of the placeholders, which the constraint assembler (\u00a73.4) then replaces with \nrelational expressions dictated by the memory model. 1 public class Test1 {2 static int x = 0; S 8 >>< \n>>: if def (vi) is:  T [e1 == e2] := E[T [e1] = T [e2]] T [false] := False 8 y=r1; T [e1 + e2] 9 else \n:= E[B[T [e1]] + B[T [e2]]] 10 y=1; E[f] := f ? True : False := bits(e) B[e] F[E[f]] := f 11 assert \nr1 == 1; E[b] := Bits(b) E[F[e]] := e B[E[b]] := b 12 }F[e] := e . True E[B[e]] := e .vi vi =read(*) \nstatic int y = 0; T [vi] := vi =e T [e] j=1F[T [guard(def (vi),vj )]] ? T [vj] :\u00d8 @thread n vi =f(v1,..., \nvn) 5 public static void t1() {6 int r1 = x; T [e1 &#38;&#38; e2] := E[F[T [e1]] .F[T [e2]]] T [true] \n:= True if (r1 != 0) ( @thread public static void t2() {L[s] :=int r2 = y; f s .{read(f), write(f, \ne)} f .T [vref ]T [vref ] s .{read(vref ,f), write(vref , f, e)}s .{lock(vref ), unlock(vref )} 16 x=1; \n V[s] := T [e] 17 assert r2 == 1; s .{write(*,e), assert(e)} G[s] := F[T [guard(s)]] 18 }19 } Figure \n9. Translation function T and representation functions L, V, and G. (a) Annotated Java encoding (b) Intermediate \nform Figure 7. The intermediate form for a test program. The label ij for a statement s indicates that \ns is the jth statement in the ith thread. An example of I(P ) is shown in Fig. 7. The extended control \n.ow graph of P is the union of the control .ow graphs of P s threads, with additional edges between the \nexit and entry blocks For expressions that are not de.ned by heap reads, the function T yields the same \nrelational expressions as a prior encoding [9] for sequential programs. Figure 9 reproduces a representative \nsam\u00adpling of those. The function def takes a variable in SSA form and returns the statement that de.nes \nits value. True and False are con\u00ad 3 For the sake of brevity, we omit the formal description of arrays \nand method calls that correspond to special actions. F(R(P ),MP (E, E1,...,Ek)) := F(R(P ),E) . Fa(R(P \n),E) . stant unary relations whose values are the atoms true and false, V j=1 F(R(P ),Ej) . MP (E, E1,...,Ek) \n respectively. The function E converts formulas and bitvectors to k expressions, and F and B do the reverse. \nAll integer and boolean F(R(P ),Ei) := ( s.ops(I(P )) lone F(s, Ei)) . (1) operations are translated \nusing their corresponding operators in re\u00ad ( (2) VVVV lational logic. s.ops(I(P )) s(G[s],Ei) .. F(s, \nEi)= \u00d8) . ' ' F(s, Ei)nF(s,Ei)= \u00d8) . s.ops(I(P )) F(s, R(P ),Ei)) . S ( (3) s,s'.ops(I(P )),s =s The \nrelational representation R(P ) is a structure I(P ), L, V, ( (4) G , which captures the semantics of \nthe program I(P ) with the (Ai F(s, Ei).li F(s, Ei).li F(s, Ei).Vi = s.ops(I(P )) F(s, Ei)) (5) partial \nfunctions L, V and G. The function L maps reads, writes, F(s,R(P ),Ei) := 8 >>< = s(L s ,Ei) s. read(*) \n= s(L[ s] ,Ei) . = s(V[s],Ei) F(s, Ei).mi = s(L[s],Ei) s. write(*) s.{lock(*),unlock(*)} locks and unlocks \nto relational expressions that represent the heap locations or monitors accessed by these statements. \nIf s is a read i >>: := a or a write of a static .eld f, L[s] yields the constant relation f whose value, \n{(f)}, consists of the atom that represents the .eld f. If s reads or writes an instance .eld f , L[s] \nyields f .T [vref ], whose value is a set of two unary tuples, one of which represents the .eld f and \nthe other the object referenced by vref . For monitor F(s, Ei) s Fa(R(P ),E) := s.(assert(*)nI(P )) \ns(G[s] .F[V[s]],E) s(fe,Ei) := fe .{.v .Vi[Wi[F(def (v),Ei)]] | v .vars(I(P ))} Figure 11. Constraint \nassembly function F . The auxiliary function V statements, L[s] produces an expression that evaluates \nto the object that is locked or unlocked by s. The function V maps writes and assertions to relational \nencodings of the values that they write or assert. The function G takes each statement s in its domain \nto a relational formula that represents the guard of s. Figure 10 shows L, V, and G for the program in \nFig. 7. ops yields all statements in I(P ) that perform memory related operations, and vars returns \nthe de.ned variables. The operator . performs syntactic substitution: fe .{x . y} replaces all free occurrences \nof x in the formula or expression fe with y. formuals: (1) a statement executed by Ei can perform at \nmost one action; (2) a statement performs an action if and only if its guard acts(s) s is true in the \ncontext of Ei; (3) different statements, if executed, must perform different actions; (4) the value-written \n(Vi), location\u00adaccessed (li) and monitor-used (mi) relations of Ei are consistent with the corresponding \nvalues given by V and L; and (5) the set Ai of all actions executed by Ei is the union of the actions \nperformed by the executed statements. The step Fa ensures that the main execution E satis.es all assertions \nin P . 3.5 Bounds assembly The last phase of the analysis .nding a model or a core of the assembled \nlegality formula is delegated to the Kodkod constraint solver [26]. Kodkod takes as input a relational \nsatis.ability prob\u00adlem, which is solved by reduction to boolean satis.ability and ap\u00adplication of a SAT \nsolver (e.g., [10]) to the resulting boolean con\u00adstraints. A relational satis.ability problem consists \nof a formula in relational logic, a universe of atoms in which the formula is to be interpreted, and \na lower and upper bound on the value of each relation in the formula. These bounds are given as sets \nof tuples drawn from the provided universe. The upper bound Bu(r) spec\u00adi.es the tuples that the relation \nr may contain in a model of the formula. The lower bound Bl(r) . Bu(r) designates the tuples that r must \ncontain, if any. The total number of unknown tuples P 00 01 02 03 10 11 13 14 15 16 20 21 22 23 24 start \nwrite(x, 0) write(y, 0) end start r1 = read(x) write(y, r1) write(y, 1) assert(r1 ==1) end start r2 = \nread(y) write(x, 1) assert(r2 ==1) end L[s]x y x y y y x V[s]Bits(0) Bits(0) .r1 Bits(1) .r1 = Bits(1) \nBits(1) .r2 = Bits(1) G[s]true true true true true true .r1 = Bits(0) .r1 = Bits(0) true true true true \ntrue true true {a00}{a01}{a02}{a03} {a10}{a11}{a13}{a13} {a16} {a20}{a21}{a22} {a24} rBu(r) Bl(r) Ai \nWi Vi li mi {(a00), (a01), (a02), (a03), (a10), (a11), (a13), (a16), (a20), (a21), (a22), (a24)} {(a11, \na01), (a11, a22), (a21, a02), (a21, a13)} {a01, a02, a13, a22}\u00d7{-8, 1, 2, 4} {a01, a11, a22} \u00d7 {x} . \n{a02, a13, a21} \u00d7 {y} Bu(Ai)\\{(a13)} { } { } Bu(li) {} {} Figure 10. Relational representation functions, \nactions and sample bounds for the program in Fig. 7. 3.4 Constraint assembly Our tool encodes the legality \nof a program R(P ) with respect to a memory model MP (E,E1,...,Ek) using the recursive constraint assembly \nprocedure de.ned in Fig. 11. The procedure F takes as input a relational representation R(P ) and a memory \nmodel spec\u00adi.cation MP (E, E1,...,Ek) and produces the legality formula F (P, M). The base step, F(s, \nEi), allocates a fresh unary rela\u00adtion a i for each statement s and execution Ei .{E,E1,...,Ek} s to \nrepresent the action that Ei performs if it executes s. The func\u00adtion s(fe,Ei) replaces all placeholder \nrelations .v in the formula or expression fe with Vi[Wi[F(def (v),Ei)]], which is the value observed \nby the read that de.nes the variable v in the context of Ei. In other words, the application of s replaces \nthe placeholders generated in the translation stage with the values speci.ed by the memory model. The \nrecursive step F(R(P ),Ei) constrains the execution Ei to respect the semantics of R(P ) by generating \nthe following i.e., |Bu(r) \\ Bl(r)| determines the exponent in the size of r the search space explored \nby Kodkod. We therefore use the algo\u00adrithms in Figs. 12 and 13 to set the bounds judiciously, so that \nthe resulting search space is both compact and includes all potential witnesses. Figure 12 shows the \nMEMSAT functions for computing the uni\u00adverse and bounds for a legality formula F(R(P ),MP (E, E1,..., \nEk)). Both the universe and the bounds are de.ned in terms of the auxiliary function acts, discussed \nbelow, which maps each memory-related statement s . ops(I(P )) to a set of atoms rep\u00adresenting the actions \nthat the execution of s may generate. The uni\u00adverse consists of .ve kinds of symbolic values: 1) primitive \nval\u00adues (bits, booleans, and null); 2) heap objects that may be allo\u00adcated by P ; 3) locations (.elds) \nreferenced within P ; 4) threads that comprise P ; and 5) memory actions that may be performed by P . \nThe bounds are drawn from the universe based on the (sound) information computed by the preprocessor. \nFor example, the upper bound on asi is the set of all unary tuples drawn from acts(s). Its lower bound \nis empty, unless the guard of s is the constant true and acts(s) has exactly one action atom. In this \ncase, the lower and upper bounds on asi are the same; i.e., every Ei is guaranteed to ex\u00ad S U(F (P, \nM)) := bits . bool . nil . objs . threads(I(P )) . .elds(I(P )) . s.ops(I(P ))acts(s) S i Bu(F (P, M)) \n:= i.{\",1,...,k}{r . Bu(r, ops(I(P ))) | r . Ei}.{a s .Bu(s) | s .ops(I(P ))} S i Bl(F (P, M)) := i.{\",1,...,k}{r \n. Bl(r, ops(I(P ))) | r . Ei}.{a s .Bl(s) | s .ops(I(P ))} r, S Ss.S Bu(s) s.S acts(s)\u00d7Bu(r, s) .\u00af arity(r)=1 \narity(r)=2 s (x) | x . acts(s) S Wi,s x.maySee(s)acts(x) s . read(*) Vi,s bits bool ptsTo(vref ).nil \ns . write(*,eint ) s . write(*,ebool ) s . write(*,vref ) li,s {f} {f}.ptsTo(v) s . rw(f) s . rw(f, \nv) mi,s ptsTo(v) s . ul(v)  ... Bu(...) precondition r, S Ss.S Bl(s) s.S acts(s)\u00d7Bl(r, s) arity(r)=1 \narity(r)=2 s Bu(s) guard(s)= true . |acts(s)| =1 Wi,s \u00d8 Vi,s \u00d8 li,s {f} {f} {f}.ptsTo(v) s . rw(f) \ns . rw(f, v) .\u00ac sole(s, v) s . rw(f, v) . sole(s, v) mi,s ptsTo(v) ul(s, v) . sole(s, v)  ... S Bl(...) \nprecondition S bits := {-2b-1 , 1,..., 2b-2} bool := {true, false} rw(f) := {read(f), write(f, e)} \nul(v) := {lock(v), unlock(v)} S objs := v.vars(I(P ))ptsTo(v) nil := {null} rw(f, v) := {read(v, f), \nwrite(v, f, e)} sole(s, v) := |acts(s)| =1 .|ptsTo(v)| =1 Figure 12. Computing the universe (U) and bounds \n(Bl, Bu) for the legality formula F (P, M)= F(R(P ),MP (E,E1,...,Ek)). All functions return \u00d8 if applied \nto arguments that violate their preconditions. The auxiliary function threads returns a set of objects \nthat represent the threads in a given program, and .elds yields the set of .elds that are referenced \nin the program s read and write statements. Epsilon (E) stands for the empty string, and b is the integer \n.nitization parameter provided by the user. COMPUTE-ACTS(efg, ptsTo) REPRESENTATIVE-ATOMS(cfgi) 1 acts \n. map() 1 ms . MAX-EXECUTABLE-SETS(cfgi,si0) 2 for 0 = i< |threads(efg)| do 2 ra . map() 3 cfgi . restrict(efg,i) \n3 for k . domain(ms) do 4 R . REPRESENTATIVE-ATOMS(cfgi) 4 for sij . ms[k] do 5 for s . ops(cfgi) do \n5 ra[sij ] . aij 6 S . {} 6 return ra ' 7 for s . domain(R) do ' ' MAY-GEN-SAME-ACT(ptsTo, s, s ) 8 \nif MAY-GEN-SAME-ACT(ptsTo, s, s ) then ' ' 1 mayAlias . .v..v ' . ptsTo(v) n ptsTo(v )= \u00d8 9 S . S .{R[s \n]} 2 switch(s) 10 acts[s] . S ' 3 case start, end : return s = s 11 return acts ' 4 case read(f) : return \ns = read(f) ' MAX-EXECUTABLE-SETS(cfgi,s) 5 case write(f, e) : return s = write(f, e ' ) '' ' 1 ms \n. map() 6 case read(v, f) : return s = read(v ,f) . mayAlias(v, v ) ' '' ' 2 for s . succs(cfgi,s) do \n7 case write(v, f, e) : return s = write(v ,f,e ' ) . mayAlias(v, v ) '' '' ' 3 ms . MAX-EXECUTABLE-SETS(cfgi,s \n) 8 case lock(v) : return s = lock(v ) . mayAlias(v, v ) ' '' ' 4 for k . domain(ms ) n domain(ms) do \n9 case unlock(v) : return s = unlock(v ) . mayAlias(v, v ) ' 5 if |ms [k]| > |ms[k]| then ' KEY(ptsTo,s)6 \nms[k] . ms [k] ' 1 switch(s) 7 for k . domain(ms ) \\ domain(ms) do 2 case start, end : return list(kind(s)) \n' 8 ms[k] . ms [k] 3 case read(f), write(f, e) : return list(kind(s),f) 9 k . KEY(s) 4 case read(v, f), \nwrite(v, f, e) : return list(kind(s),f,ptsTo(v)) 10 ms[k] .{s}. (k . domain(ms) ? ms[k] : {}) 5 case \nlock(v), unlock(v) : return list(kind(s), ptsTo(v)) 11 return ms Figure 13. COMPUTE-ACTS procedure for \ncomputing the assignment of actions to statements. The auxiliary function restrict(efg,i) restricts a \ngiven efg to the control .ow graph of the ith thread; domain(m) yields the set of all keys mapped by \nthe map m; and kind(s) returns the kind of the statement s as a string (e.g. read , write , etc.). Other \nauxiliary functions are self-explanatory. ecute s and, therefore, to perform the action acts(s). Other \nbounds are derived from acts and I(P ) in a similar fashion. The procedure COMPUTE-ACTS for computing \nthe acts func\u00adtion is presented in Fig. 13. It works, thread by thread, as follows. Given a thread ti, \nwe use the function KEY to partition the state\u00adments of ti into equivalence classes. For example, two \nreads of the same static .eld have equal keys and are in the same equivalence class. Then, for each class \nof statements C, MAX-EXECUTABLE-SETS .nds the largest subset Cmax . C such that all elements of Cmax \nappear on a single path through the CFG of ti. We say that the statements in Cmax are representative \nof C. Following the gen\u00aderation of Cmax for each C, REPRESENTATIVE-ATOMS creates a unique atom aij for \nevery representative statement sij and records the correspondence between the two in a map. The size \nof this map is an upper bound on the number of actions that any execution of ti may generate, and it \nis bounded above by the total number of memory-related statements in ti. The last few lines of COMPUTE-ACTS \nuse the representatives map to compute acts(s) for all s in ti. In particular, acts(s) contains the atom \naij if s and sij may generate the same memory event (e.g., a read of the .eld f). An example of the \nacts mapping and of the resulting bounds is shown in Fig. 10. The sample mapping illustrates four key \nproper\u00adties of acts, which ensure that our bounds are both compact and do not exclude any witnesses: \n1. each statement s is mapped to at least one atom; 2. if s and s' may both be performed in some execution, \nthe union of their acts sets contains at least two atoms; 3. if s and s' may produce the same memory \nevent, the intersection of their acts contains at least one atom; and   Table 1. MEMSAT results for \n.ve classic memory models on Nemos test cases [20]. The column label w.exp./w.fnd stands for witness \nexpected / witness found. 4. if s and s ' may never produce the same memory event, the intersection of \ntheir acts sets is empty. The .rst two properties ensure that witnesses are not missed be\u00adcause the search \nspace excludes executions that perform particular statements or combinations of statements. For example, \nif acts(s) is empty for some s, then both the lower and the upper bound on the relation a i are also \nempty, which forces the solver to treat a i as the ss constant relation \u00d8. As a result, the only way \nto satisfy the legality constraint s(G[s],Ei) .. F(s, Ei)= \u00d8 is to have the guard of s evaluate to false. \nAn empty acts set for s therefore rules out all wit\u00adnesses that perform s. Similarly, if acts(s) . acts(s \n' ) contains just one atom aij, then Bu(a is)= Bu(a is)= {(aij)}. In this case, the only way to satisfy \nthe legality constraint F(s, Ei)nF(s ' ,Ei)= \u00d8 is to set either a is or a is ' (or both) to the empty \nset, thus ruling out all witnesses that execute both s and s ' . The third property ensures that witnesses \nare not missed because the memory model equates actions performed by different state\u00adments in the context \nof different executions. For example, the pro\u00adgram in Fig. 7 is legal under the Java Memory Model. In \nits witness execution E, statement 11 reads the value 1 from x, which causes statement 13 to execute \nand write the value 1 to y; i.e. a13 . A. The execution E is justi.ed by a speculative execution E1, \nin which statement 11 reads the value 0 from x, causing statement 14 to exe\u00adcute and write the value \n1 to y; i.e., a141 . A1. As a result, the only way to speculatively commit a write of 1 to y is to commit \nthe result of executing a141 , but the only way to honor this commitment in E is by executing a13. Hence, \nwe must have a13 = a141 , which means that Bu(a13)nBu(a141 ) (and, by extension, acts(s13)nacts(s14)) \nmust be non-empty. The fourth property ensures compactness of the search space. If s and s ' may never \nperform the same event, then a commitment to perform an action generated by s in a speculative execution \nEi can never be honored by executing s ' in Ei+1. We can therefore leave acts(s) n acts(s ' ) empty to \nget a smaller search space without losing any witnesses. 4. Case Studies We used MEMSAT to check seven \nexisting memory models using their published test cases: the Java Memory Model (JMM) by Man\u00adson et al. \n[19], a revised version of it by Sevcik and Aspinall [25], and .ve classic memory models with existing \naxiomatic descrip\u00adtions [34]. Our experiments revealed several discrepancies between what was expected \nand the actual results of the tests. 4.1 Classic memory models Table 1 presents the results of applying \nMEMSAT to the classic memory models speci.ed in the Nemos framework [34] and the test cases provided \nwith the NemosFinder tool [20]. The test pro\u00adgrams consist of 2-8 threads, each of which performs up \nto four memory accesses.4 For every model and every test, the table shows whether a witness was expected \nand whether we found one; the total analysis time, rounded to the nearest second; and the size of the \n.nal SAT problem, as measured by the number of variables and clauses. All experiments were performed \non a 2.4 GHz Intel Core 2 Duo machine with 4 GB of RAM. We found that sequential consistency, coherence \nand PRAM be\u00adhave as expected on all tests, while causal consistency allows wit\u00adnesses for tests 10 and \n12 15, against expectation. Our initial ex\u00adperiments also revealed that the Nemos de.nition of processor \ncon\u00adsistency (PC) behaves as sequential consistency on the given tests, due to an overconstraint in the \nmapConstraints predicate [34]. We isolated the faulty constraint from the minimal core generated for \ntest 2. The PC results that are shown in Table 1 re.ect our .x to mapConstraints, which involved replacing \nan equality with an im\u00adplication. The analysis time for all tests was negligible. 4.2 Java Memory Model \nThe Java Memory Model (JMM) was .rst de.ned in the Java Language Speci.cation [12]. A few years later, \nPugh [21] showed that this initial de.nition was .awed, leading to a formal revision process [15]. Manson \net al. [19] eventually re-de.ned the model in its current form, which we call the original JMM. Sevcik \nand Aspinall [25] then formalized the original JMM in the Isabelle theorem prover [13] and discovered \nthat it disallows causality tests 17 20 [6], contrary to expectation. They .xed this .aw in a revision \nof the model, which we call the revised JMM, by weakening rules 2 and 7 of legality [19]. The revised \nmodel also omits rules 3 and 8; restricts executions to be .nite; and modi.es the handling of initial \nwrites. 4 Note that a program with t threads, which perform n memory operations each, has roughly (n!)t \ncandidate executions under a relaxed memory model [24]. As a result, even tests as small as these are \ntoo dif.cult for manual analysis.  Table 2. MEMSAT results for the original [19] and revised [25] de.nition \nof the JMM on standard causality tests [6] and program transformation tests [25]. Table 2 shows the results \nof applying MEMSAT to both the original and the revised JMM on two sets of test cases: the standard causality \ntests by Pugh et al. [6] and the program transformation tests by Sevcik and Aspinall [25]. Causality \ntests are labeled 1 20 and transformation tests are T1 T5.t. All tests consist of 2 to 4 threads, each \nwith up to 10 lines of code. Two of the tests contain loops, which were unwound once. We initially found \nthat none of the tests pass for the revised JMM, because its speci.cation of the synchronizes-with relation \nfails to include edges from the end of the initialization thread to the start of the user threads. The \nomission was immediately apparent from the minimal cores, which showed that it was impossible for any \nreads to see the initial writes without these edges. We .xed the de.nition to include the missing edges \nand repeated the experiments to obtain the results in Table 2. The highlighted entries show that the \noriginal JMM does not behave as expected on tests 19 and 20, con.rming the .ndings by Aspinall and Sevcik \n[3]. The cores produced by MEMSAT for these tests consist of program constraints and rules 2 and 7 of \nthe original JMM. The revised JMM, which weakens both rules, correctly validates tests 19 and 20. Our \n.ndings disagree with those of Aspinall and Sevcik [3, 25] on the causality tests 17 18 and on the transform \ntest T5. In particular, we found that the original JMM allows both tests 17 and 18. The witnesses for \nthese tests would have been dif.cult to construct by hand, since each consists of an unusual justifying \nsequence that has two different statements, only one of which is guarded by a conditional, performing \nthe same action. We also found that the revised JMM allows the transform test T5, against expectation. \nThis test was designed to show that rule 9 of both the original and revised JMM forbids reordering of \nstatements with special actions. The test indeed fails for the original model, and MEMSAT produces a \nminimal core that includes rule 9. Upon closer inspection of rule 9 in the revised model, we found that \nits speci.cation is weaker than in the original model. The difference between the two rules is undocumented. \n Most of our experiments on the JMM completed in a few sec\u00adonds. The most notable exceptions tests 15 \nand T1 had three or more user threads each and no witnesses. The resulting cores were hence large and \nrelatively expensive to minimize. The core mini\u00admization feature [27] of Kodkod can be turned off for \nbetter perfor\u00admance. Without it, MEMSAT would simply output an unsatis.able core that is not guaranteed \nto be minimal. 5. Related Work Many memory models have been proposed both at the hardware interface (see \n[1] for a detailed survey) and at the programming language level [17, 19, 23]. The dif.culty of reasoning \nabout these proposals was recognized early, prompting the development of nu\u00admerous techniques for formalizing \nand analyzing memory models. Automated Analyses of the Java Memory Model. A number of automated analyses \nhave been developed for various incarnations of the JMM. Yang et al. [31] present an analysis of the \nJMM CRF model [17]. In this work, the model is hard-coded in a tool based on the Mur. model checker [8], \nand test programs are given in the Mur. input language. Roychoudhury and Mitra [22] propose their own \noperational speci.cation of the JMM that they devised from the Java Language Speci.cation [12], based \non guarded com\u00admands. They use XSB logic programming [30] for search-space exploration. For input test \nprograms, the user needs to specify the paths taken in each thread. De et al. [7] developed OpMM, an \nop\u00aderational under-approximation for the current version of the JMM [19]. They use a model checker similar \nto JavaPathFinder for state exploration, with the semantics of OpMM built into it. Aspinall and Sevcik \n[2] formalized the data race free guarantee of the current JMM and proved it using the Isabelle theorem \nprover [13]. Finally, Manson [18] developed a simulator for the current version of the JMM that enumerates \nall possible executions for a given program. Since MEMSAT supports an axiomatic style for specifying \nmemory models, the JMM speci.cation can be provided directly as an input with no need for an operational \napproximation. Our tool is based on a SAT solver, so it suffers less from the state\u00adexplosion problem \nfaced by explicit-state model checkers, and its test programs are given in Java. Unlike Manson s simulator \n[18], MEMSAT does not need to explicitly enumerate all executions, and it can be used to check memory \nmodels other than the JMM. Unlike techniques based on theorem proving, MEMSAT cannot be used to verify \nproperties of memory models. Instead, it is intended as a debugging and rapid prototyping tool to help \nsupport reasoning about them. Automated Analyses of Other Memory Models. Aside from the JMM, other memory \nmodels have been the focus of formalization and analysis in prior work. Sober [5] is a scalable model \ncheck\u00ading technique for detecting program executions that are not se\u00adquentially consistent due to store \nbuffer relaxation. CheckFence [4] is a SAT-based tool for checking that a data structure, imple\u00admented \nin C, is sequentially consistent under a hard-coded relaxed memory model, which approximates several \ndifferent hardware\u00adlevel memory models. Unlike these tools, MEMSAT was devel\u00adoped for checking different \nmemory models against small pro\u00adgrams, rather than for checking larger programs against a speci.c low-level \nmemory model. While both MEMSAT and CheckFence are based on SAT, their translation techniques are fundamentally \ndifferent. MemSAT uses a template-based translation with place\u00adholders, which enables it to handle different \ninput memory models. MemSAT also incorporates optimizations that allow it to handle high-level memory \nmodels with speculative executions and arbi\u00adtrary ordering relations. Yang et al. [11, 33] devised a \ntechnique based on SAT for evalu\u00adating tests against the Itanium memory model. To encode transitiv\u00adity \nconstraints, the tool generates a functional program for each in\u00adput test that, when executed, produces \na set of propositional clauses to be analyzed by a SAT solver. The authors report debugging one of their \ntest cases by examining the propositional clauses in a low\u00adlevel core generated by the SAT solver. MEMSAT, \nby contrast, generates cores that are meaningful and minimal at the speci.ca\u00adtion level. Moreover, our \nbackend engine supports transitive closure naturally, simplifying the expression of transitivity constraints. \nSarkar et al. [24] used the HOL theorem prover to formalize a semantics for multiprocessor x86 programs \nwith an integrated relaxed memory model. They also developed two automated tools written in OCaml, one \nto check litmus tests against the axiomatic memory model and one to run the tests on actual hardware. \nUnlike these tools, which are dedicated checkers for the x86-CC memory model, MEMSAT takes a memory model \nspeci.cation as input and targets Java rather than machine code. Frameworks for Memory Model Analysis. \nSeveral frameworks for checking memory models have been proposed. The Uni.ed Memory Model (UMM) [32] \nis a framework for describing oper\u00adational memory models. Memory models in the UMM are given using guarded \ncommands, with a transition table for specifying the behavior of instructions, and a bypass table for \nspecifying allowed instruction reorderings. The framework is based on the Mur. model checker. Yang et \nal. also developed the Nemos frame\u00adwork [34], which is based on SAT and supports simple axiomatic speci.cations \nof low-level memory models. Litmus tests are pro\u00advided as traces i.e., sequences of reads and writes. \nOur tool improves on the UMM and Nemos in several ways. First, unlike either of these tools, MEMSAT can \nprovide proofs of illegality in the form of minimal cores. Second, Nemos encodes memory models with a \nlimited set of predicates, which cannot ex\u00adpress rules about locking or speculative executions. MemSAT \nhan\u00addles memory models with both of these features. Finally, Nemos requires users to manually enumerate \ncomplete traces, which our tool does automatically based on the program and the assertions being checked. \n6. Conclusions We presented MEMSAT, a fully automated tool for debugging and reasoning about axiomatic \nspeci.cations of memory models. We used MEMSAT to check the JMM [19], a revised version of it [2, 25], \nand several well-known memory models. Our experiments con.rmed previously reported discrepancies in the \nexpected behav\u00adior of test programs, and uncovered new ones. To the best of our knowledge, our tool is \nthe .rst fully automated technique that can handle the current axiomatic speci.cation of the JMM. In \nthe fu\u00adture, we plan to investigate applying MEMSAT to hardware mem\u00adory models. References [1] S. V. \nAdve and K. Gharachorloo. Shared memory consistency models: A tutorial. Computer, 29(12):66 76, 1996. \n[2] D. Aspinall and J. Sevcik. Formalising Java s data race free guarantee. In TPHOLs 07, pages 22 37, \n2007. [3] D. Aspinall and J. Sevc\u00b4ik. Java memory model examples: good, bad and ugly. In VAMP 07, Lisbon, \nPortugal, September 2007. [4] S. Burckhardt, R. Alur, and M. M. K. Martin. CheckFence: checking consistency \nof concurrent data types on relaxed memory models. In PLDI 07, 2007. [5] S. Burckhardt and M. Musuvathi. \nEffective program veri.cation for relaxed memory models. In CAV 08, 2008. [6] Causality test cases for \nthe Java Memory Model. http://www.cs. umd.edu/~pugh/java/memoryModel/CausalityTestCases.html. [7] A. \nDe, A. Roychoudhury, and D. D Souza. Java memory model aware software validation. In PASTE 08, 2008. \n[8] D. Dill. The Mur. veri.cation system. In CAV 96, 1996. [9] J. Dolby, M. Vaziri, and F. Tip. Finding \nbugs ef.ciently with a SAT solver. In FSE 07, pages 195 204, 2007. [10] N. E\u00b4en and N. S\u00a8orensson. An \nextensible SAT-solver. In SAT 03, 2003. [11] G. Gopalakrishnan, Y. Yang, and H. Sivaraj. QB or Not QB: \nAn ef.cient execution veri.cation tool for memory orderings. In CAV 04, 2004. [12] J. Gosling, B. Joy, \nand G. Steele. The Java Speci.cation Language. Addison-Wesley, 1996. [13] Isabelle Theorem Prover. http://isabelle.in.tum.de/. \n[14] D. Jackson. Software Abstractions: logic, language and analysis. MIT Press, 2006. [15] JSR-133: \nJava memory model and thread speci.cation revision. http://www.cs.umd.edu/~pugh/java/memoryModel. [16] \nL. Lamport. How to make a multiprocessor computer that correctly executes multiprocess program. IEEE \nTrans. Comput., 28(9), 1979. [17] J.-W. Maessen, Arvind, and X. Shen. Improving the Java Memory Model \nusing CRF. In OOPSLA 00, 2000. [18] J. Manson. The Java memory model. PhD thesis, University of Maryland, \nCollege Park, 2004. [19] J. Manson, W. Pugh, and S. V. Adve. The Java memory model. In POPL 05, pages \n378 391, New York, NY, USA, 2005. ACM. [20] NemosFinder. http://www.cs.utah.edu/formal veri.cation/. \n[21] W. Pugh. Fixing the Java memory model. In Java Grande 99, 1999. [22] A. Roychoudhury and T. Mitra. \nSpecifying multithreaded Java semantics for program veri.cation. In ICSE 02, 2002. [23] V. A. Saraswat, \nR. Jagadeesan, M. Michael, and C. von Praun. A theory of memory models. In PPoPP 07, pages 161 172, New \nYork, NY, USA, 2007. ACM. [24] S. Sarkar, P. Sewell, F. Z. Nardelli, S. Owens, T. Ridge, T. Braibant, \nM. O Myreen, and J. Alglave. The semantics of x86 CC multiproces\u00adsor machine code. In POPL 09, 2009. \n [25] J. Sevc\u00b4ik and D. Aspinall. On validity of program transformations in the Java memory model. In \nECOOP 08, 2008. [26] E. Torlak. A constraint solver for software engineering: .nding models and cores \nof large relational speci.cations. PhD thesis, MIT, 2009. [27] E. Torlak, F. S.-H. Chang, and D. Jackson. \nFinding minimal unsatis.able cores of declarative speci.cations. In FM 08, 2008. [28] E. Torlak and D. \nJackson. Kodkod: A relational model .nder. In TACAS 07, 2007. [29] Watson libraries for analysis (WALA). \nhttp://wala.sourceforge.net. [30] The XSB logic programming system. http://xsb.sourceforge.net. [31] \nY. Yang, G. Gopalakrishnan, and G. Lindstrom. Analyzing the CRF Java memory model. In APSEC 01, 2001. \n[32] Y. Yang, G. Gopalakrishnan, and G. Lindstrom. Specifying Java thread semantics using a uniform memory \nmodel. In JGI 02, 2002. [33] Y. Yang, G. Gopalakrishnan, G. Lindstrom, and K. Slind. Analyzing the Intel \nItanium memory ordering rules using logic programming and SAT. In CHARME 03, 2003. [34] Y. Yang, G. Gopalakrishnan, \nG. Lindstrom, and K. Slind. Nemos: a framework for axiomatic and executable speci.cations of memory consistency \nmodels. In IPDPS 04, pages 26 30, 2004.   \n\t\t\t", "proc_id": "1806596", "abstract": "<p>Memory models are hard to reason about due to their complexity, which stems from the need to strike a balance between ease-of-programming and allowing compiler and hardware optimizations. In this paper, we present an automated tool, MemSAT, that helps in debugging and reasoning about memory models. Given an axiomatic specification of a memory model and a multi-threaded test program containing assertions, MemSAT outputs a trace of the program in which both the assertions and the memory model axioms are satisfied, if one can be found. The tool is fully automatic and is based on a SAT solver. If it cannot find a trace, it outputs a minimal subset of the memory model and program constraints that are unsatisfiable. We used MemSAT to check several existing memory models against their published test cases, including the current Java Memory Model by Manson et al. and a revised version of it by Sevcik and Aspinall. We found subtle discrepancies between what was expected and the actual results of test programs.</p>", "authors": [{"name": "Emina Torlak", "author_profile_id": "81100616499", "affiliation": "IBM T. J. Watson Research Center, Hawthorne, NY, USA", "person_id": "P2184580", "email_address": "", "orcid_id": ""}, {"name": "Mandana Vaziri", "author_profile_id": "81309485668", "affiliation": "IBM T. J. Watson Research Center, Hawthorne, NY, USA", "person_id": "P2184581", "email_address": "", "orcid_id": ""}, {"name": "Julian Dolby", "author_profile_id": "81100506419", "affiliation": "IBM T. J. Watson Research Center, Hawthorne, NY, USA", "person_id": "P2184582", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1806596.1806635", "year": "2010", "article_id": "1806635", "conference": "PLDI", "title": "MemSAT: checking axiomatic specifications of memory models", "url": "http://dl.acm.org/citation.cfm?id=1806635"}