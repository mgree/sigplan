{"article_publication_date": "06-05-2010", "fulltext": "\n Mint:Java Multi-stage Programming UsingWeak Separability EdwinWestbrook Mathias Ricken Jun Inoue YilongYao \nTamer Abdelatif1 WalidTaha Rice University {emw4,mgricken,ji2,yy3}@cs.rice.edu, eng.tamerabdo@gmail.com, \ntaha@cs.rice.edu Abstract Multi-stage programming (MSP) provides a disciplined approach to run-time code \ngeneration. In the purely functional setting, it has been shown how MSP can be used to reduce the overhead \nof abstractions, allowing clean, maintainable code without pay\u00ading performance penalties. Unfortunately, \nMSP is dif.cult to com\u00adbine with imperative features, which are prevalent in mainstream languages. The \ncentral dif.culty is scope extrusion, wherein free variables can inadvertently be moved outside the scopes \nof their binders. This paper proposes a new approach to combining MSP with imperative features that occupies \na sweet spot in the design space in terms of how well useful MSP applications can be ex\u00adpressedandhoweasyitisfor \nprogrammersto understand.Thekey insight is that escapes (or anti-quotes ) must be weakly separable from \nthe rest of the code, i.e. the computational effects occurring inside an escape that are visible outside \nthe escape are guaranteed tonot contain code.Todemonstratethe feasibilityofthis approach, we formalize \na type system based on Lightweight Java which we prove sound, and we also provide an implementation, \ncalled Mint, to validate both the expressivity of the type system and the effect of staging on the performance \nof Java programs. Categories and Subject Descriptors D.3.1[Programming Lan\u00adguages]: Formal De.nitions \nand Theory; D.3.3 [Programming Languages]: Language Constructs and Features General Terms Languages Keywords \nMulti-staged languages, Multi-stage programming, Type systems, Java 1. Introduction Abstraction mechanisms, \nsuch as re.ection and design patterns, are useful for writing clean, maintainable code. Often, however, \nsuch mechanisms come with a steep performance overhead, mak\u00ading them less useful in real systems. Our \ngoal is to allow software developerstousesuch abstractions,buthavethembeexecutedinan ef.cient manner. \nOne approach to this problem is multi-stage pro\u00adgramming (MSP), a language feature that provides a disciplined \nform of runtime code generation. Just by inserting staging anno\u00adtations, a form of quasi-quotation, the \ndeveloper can change pro\u00ad 1Ain Shams University. Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. PLDI 2010 June 5-10, 2010,Toronto, Canada. Copyright c &#38;#169; \n2010 ACM 978-1-4503-0019-3/10/06. . . $10.00 grams that use expensive abstractions into program generators, \nwhich generate programs without the abstractions. This reduces the runtime cost of abstractions, because \nthe overhead is only paid whenthe generatorsareexecuted,notatthetimethe programsthey generate are run. \nAkeyissue for MSP is type safety, which ensures statically that all programs generated at runtime will \nbe well-formed. Although it had been known how to ensure type safety for MSP in the purely functional \nsetting [4, 27, 28], it previously remained an open chal\u00adlengehowtoextendthis guaranteeto mainstream \nlanguagessuchas Java. In particular,standard features of mainstream languages, such as imperative assignment, \ncan lead to scope extrusion, in which variables in code fragments may moveout of the scopes where they \nare de.ned. Several approaches to this problem havebeen proposed [1, 11, 12, 14] that give the expert \nMSP user .ne-grained control over scoping in code; however, there is still a need for a type sys\u00adtem \nthat makes MSP accessible to general programmers. Mint pro\u00advides a type system that is well-suited for \nthe prevalent culture of programming in languages like Java. Speci.cally, Mint allows im\u00adperative generators \nand does not require a functional programming style, a style that often is inconvenient in Java. The \ntype system re\u00admains simple while being more expressive than anyprevious type system that statically \nensures type safety of generated code. Contributions TomakeMSP accessible to programmers in mainstream \nlanguages, we propose a new approach to type-safe MSP that we argue occu\u00adpies a sweet spot in the design \nspace in terms of how well useful MSP applications can be expressed and how easy it is for program\u00admers \nto understand. Our contributions include: After a brief introduction to staging in Java (Section 2), \nwe analyze and explain why scope extrusion can arise with naive approaches to MSP in Java or in similar \nlanguages (Section 3).  We introduce the notion of weak separability as a solution to the scopeextrusion \nproblem (Section4).Weak separability ensures that any effects that can be observed outside escaped expressions \nwill not involve code objects. We present a type system that realizes this idea, and show that it is \nsuf.cient to prevent scope extrusion.  We demonstrate the expressivity of the type system using a number \nof small examples illustrative of important classes of programs for which MSP can be useful (Section \n5). The exam\u00adples show the use of MSP forbuilding interpreters, numerical code, and re.ective programs. \nThe examples also emphasize that the type system allows expressing imperative generators that, for example, \nthrow exceptions or store code in locations that cannot escape the scope of a surrounding dynamic binder. \n We formalize the semantics and prove the type safety of a core calculus illustrating thekeyfeatures \nof the proposed type sys\u00adtem. (Section 6). Proving type safety establishes that a well\u00ad   p u b l i \nc s t a t i c p u b l i c s t a t i c I n t e g e r p o w e r ( I n t e g e r x , I n t e g e r n ) { \nC o d e < I n t e g e r > s p o w e r ( C o d e < I n t e g e r > x , i n t n ) { i f ( n = = 1 ) if \n( n == 1) r e t u r n x ; r e t u r n x ; e l s e e l s e r e t u r n x * p o w e r ( x , n -1 ) ; r \ne t u r n <| x * ( s p o w e r ( x , n -1 ) ) | > ; } } (a) The Unstaged Power Function (b) The Staged \nPower Function Figure 1. Staging the Power Function in Mint typed program is guaranteed to be free of \nany runtime errors, including possible scope extrusion and generation (and execu\u00adtion) of ill-formed \ncode. The novelty of the type system is in the use of a stack of store typings, instead of a single store \ntyp\u00ading, to mirror the dynamic binding structure of the term. This captures thefact that heap locations \nallocated inside dynamic binders may not be visible outside those binders. Lemmas are only stated here; \nfull proofs are given in the companion techni\u00adcal report [29] . We have implemented the type system in \nan MSP extension of OpenJDK [17] called Mint [18]. The implementation was used totypecheckallexamples \npresentedinthepaper.Wealsouse the implementation to con.rm that MSP in Java a language typically implemented \nusing JIT compilation can lead to performance speedups similarto those seenbyMSPextensions of other \nlanguages (Section 7). 2. Multi-Stage Programming in Mint MintextendsJava6withthethree standardMSP constructs: \nbrack\u00adets, escape, and run (see e.g. [26]). Brackets are written as <| |> anddelaythe enclosed computationbyreturningitasacodeobject. \nFor example,<|2+ 3|> is a value. Brackets can contain a block of statementsif the blockis surroundedby \ncurly braces: <| { C.foo(); C.bar(); } |> // has type Code<Void> Code objects have type Code<T>, where \nT is the type of the expres\u00adsion contained.Forexample, <| 2 |> has type Code<Integer>.A bracketed block \nof statements always has type Code<Void>. Code objects can be escaped or run. Escapes are written as \n and allow code objects to be spliced into other brackets to create bigger code objects.Forexample, Code<Integer> \nx = <| 2 + 3 |>; Code<Integer> y = <| 1 + x |>; stores <|1+ (2+3) |> into y. Run is provided as a method \nrun() that code objects support.Forexample,executing int z = y.run(); after the above example sets z \nto 6. Mint also allows cross-stage persistence (CSP), wherein a vari\u00adable bound outside brackets can \nbe used inside the brackets, as in int x = 1; Code<Integer> c = <| x + 1 |>; Weak separability, the \nrequirement Mint uses to ensure safety, places certain restrictions on CSP; see Section 4. Basic MSP \nin Mint can be illustrated using the classic power example. Figure 1(a) displays the unstaged power function \nin Java. Figure 1(b) displays a staged version. The staged method spower takes in an argument x that \nis a piece of code for an integer, along with an integer n,and returns code that multipliesx byitselfn \ntimes. 3. The Scope Extrusion Problem One of the mostimportant properties of MSP languages is the guar\u00adantee \nthat program generators will always produce well-formed code. It is known how to achieve this in the \npurely functional set\u00adting [4, 27, 28]. In the presence of imperative features, however, guaranteeing \nthis is more challenging because of the possibility of scope extrusion, where a code object containing \na variable is used outside the scope of the binder for that variable. If such a code ob\u00adject were allowed \nto be compiled and run, a runtime error would be emitted, because the result of compiling and running \ncode with free variables is unde.ned. Scope extrusion can be caused by the following situations: 1. Assigning \na code object to a variable or .eld that is reachable outside the escape, for example: Code<Integer> \nx; <| { Integer y = foo(); (x = <| y|>); }|>; 2. Throwing anexception that containsacode object, forexample: \nCode<Integer> meth(Code<Integer> c) { throw new CodeContainerException(c); } <| { Integer y; (meth(<| \ny |>)); } |> 3. Cross-stage persistence (CSP) of a code object, an example of which is displayed in Figure \n2. The .rst two cases are straightforward; the .rst example ex\u00adtrudes y from its scopebyassigning <|y \n|> to thevariable x bound outside of the scope of y, while the second example throws an ex\u00adception containing \n<| y|> outside the scope of y. The third exam\u00adple, however, is more subtle. This example creates an anonymous \ninner subclass of Thunk, whose call method returns a code object containing thevariable y. This Thunk \nobject is then passed to doCSP in the escape, yielding the code object <| { Integer y = foo(); Code<Integer> \nd = T.call(); } |> where T is the anonymous inner subclass of Thunk.Inasubstitution\u00adbased semantics that \nsubstitutes values directly for variables, no scope extrusion would occur, because running this code \nobject would substitutethe returnvalueoffoo() for y in T,thus producing a new copy of T whose call method \nreturns <| r |>, where r is the return value of foo(). Such a semantics, however, would be impractical \nfor a language like Java, because it would involve traversing the (possibly compiled) method de.nitions \nof T, and it would also be confusing, because thecall method of T itselfwould not be called when this \nexample was run. In an environment-based semantics, which moves the value to some location in a separate \nenvironment and substitutes an index of that location (usually the variable itself) for the variable, \nrunning the above code would simply return the value of T.call(), which would produce the code object \n<| y|>, with y being out of its scope. The cross-stage persistence of the Thunk is essentially the same \nas storing the value of T in a global reference cell or hash table, and as soon as that is done, the \nThunk has been moved outside the scope of y. Our formalization of Mint properly models this indirection, \nalthough we model the environment as part of the heap rather than as a separate entity (see Section 6). \n 4. Weak Separability The three situations mentioned in the previous section necessarily all involve \ncode objects; effects that do not involve code cannot cause scopeextrusion.We therefore .rst de.ne the \nterm code-free: De.nition 1. Atype is code-free if it is not a subtype of Code<T>, the types of all of \nits .elds are code-free, all of its methods return types are code-free, and its class is .nal.A value \nis code-free if its type is code-free. If a value x is code-free, then no code object is reachable from \nx, and scope extrusion cannot occur due to effects involving x. The requirement thata classis .nal means \nthatthe classis not allowed to be subclassed. This restriction ensures that a subclass with an additional \n.eld of type Code<T> cannot be substituted at runtime. Making Java classes .nal is unusual, but only \nbecause there are almost no bene.ts to declaring a class .nal. In our ex\u00adperience, most Java classes \nwritten by application developers can be .nal. Commonly used code-free types include number types such \nas Integer and Double, the String class, arrays of code-free types, and all of Java s re.ection classes \nsuch as Class and Field. It does not include Object, for example, as this type is not .nal, and an Object \ncould be a code object at runtime. Scope extrusion can be prevented by requiring that escapes are weakly \nseparable, which we de.ne informally: Informal De.nition 1. Aterm is weakly separable if both side effects \nobservable outsidethe term and cross-stage persistence in\u00advolve only code-free values. Intuitively, requiring \nescapes to be weakly separable will pre\u00adventscopeextrusion, becausenocodeobjectcanbemoved outside of \nan escape.Asimilarbut stronger restrictionwas usedin the sys\u00adtems of Kameyama et al. [11, 12] to ensure \nthat no effects occur\u00adring inside escapes could be visible outside the escapes.1 We call the condition \nintroduced by Kameyama et al. separability. We leave the notion of weak separability only informally \nde\u00ad.ned here both because formalizing it would require complex se\u00admantic de.nitions and because it is \nundecidable in general. Instead, we provide a conservative approximation of weak separability that is \nused by Mint. This approximation is decidable, and we show below that it still leaves an expressive language. \nUnless otherwise speci.ed, the phrase weakly separable in the remainder of this document refers to this \napproximation: De.nition 2. AMint terme is weakly separable iff: 1. Assignment is made only to variables \nbound within e, or to .elds or variables of code-free types; 2. Exceptions are only thrown by a throw \nnew C(e1, ..., en); construct where the ei are code-free, or the exception is caught by an enclosing \ntry-catch construct before it can leave e; 3. Cross-stage persistence occurs only for final variables \nof code\u00adfree types; 4. Only weakly separable methods and constructors are called.  1Technically, Kameyama \net al. placed this restriction on future-stage binders. We are using the word term to describe an expression, \nstate\u00adment, or method body. The notion of pseudo-expression in Section 6.2 is a direct formalization \nof this kind of term. The .rst three of the clauses in the de.nition above directly preclude the three \ncases of scope extrusion in the previous section. The restrictiononthrowingexceptionsis syntacticandallowsfora \nstatic check of code-freedom. Note that the final restriction on CSP variables exists so that the value \nof the variable does not change over the lifetime of the code object; Java has a similar restriction \nforvariables referenced inside anonymous inner classes. The last clause ensures that all methods called \nfrom the body of a weakly separable term also satisfy weak separability. To check this condition, methods \nthat are going to be called from the body of an escape are explicitly annotated in Mint with the keyword \nseparable. To demonstrate how weak separability works in practice, the following code gives examples \nshowing how each of the four clausesof weak separability canfail. Since allof theseexamples occur in \nthe method foo, which is marked as separable, each of these examples represents a type error in the program. \nThe .rst example, which assigns to x.c, violates clause 1 of De.nition 2 since x.c has the non-code-free \ntype Code<C>. The secondexample violates clause 2 since it passes a code object to the constructor of \nan exception which is being thrown. The third example violates clause3 becauseit uses cross-stage persistence \non thevalue x of type C;the typeC is not code-free because it contains the .eld c of type Code<C>. Finally, \nthe fourthexample violates clause4because it calls the method bar(), which is not marked with the separable \nkeyword. class C { Code<Integer> c; void bar() { ... } separable C foo(final C x) { // x.c is not code-free \n(1) x.c = <|1|>; // CodeContainerException takes a // non-code-free argument (2) throw new CodeContainerException(<|x|>); \n // not a throw new C(e1, ..., en); // construct (2) CodeFreeException e = new CodeFreeException (); \nthrow e; // error // CSP of x but C is not code-free (3) Code<C> y = <|x|>; // bar() is not marked separable \n(4) bar (); } } 5. Expressivity Weak separability is a highlyexpressive notion that excludes only a few \ncoding patterns, such as generators that store open code in a global data structure. Such situations \ncan be addressed by introducing a local data structure and ensuring that it is not used outside the dynamic \nbinder. The separability restriction is only problematic when the coding pattern requires scope extrusion. \nIn an imperative language like Java, being able to write code generators with side effects is a desirable \nproperty: An imperative programming style .ts better into the language s culture, while  interface Thunk \n{ Code<Integer> call(); } Code<Code<Integer>> doCSP(Thunk t) { return <| t.call() |>; } <| { Integer \ny = foo (); Code<Integer> d = (doCSP(new Thunk() { Code < Integer > call () { return <| y |>; }})); } \n| >. run (); Figure 2. Cross-stage Persistence of Code Objects functional programming in Java can often \nbe inconvenient and verbose. Weak separability does not severely restrict expressiveness be\u00adcausethereisa \ntendencyforthe computationaleffectsusedincode generators to be separable: It is rare that generators \nare required to export code objects through side effects; all other side effects not involving code are \nweakly separable and therefore allowed. Fur\u00adthermore, the run() method is onlycalled outside of anybrackets \nin almost all applications of MSP, and cross-stage persistence is mostlyusedforprimitivetypes. Generatedcodeisnot \nrestrictedby weak separability at all. Toillustrate these points, the remainder of this section describes \nthe implications of weak separability and examines a number of MSP examples in Mint, namely: staging \nan interpreter, a classic MSPexample; staging arrayviews[22]to removeabstractionover\u00adhead; and loop unrolling. \nThe staged interpreter shows that throw\u00adinga code-freeexceptionina code generatoris allowed. Both stag\u00ading \narray views and loop unrolling demonstrate generators for im\u00adperative code. Section 5.3 gives another \nexample, a staged serial\u00adizer that uses Mint s re.ection capabilities. The performance of all these examples \nis evaluated in Section 7. 5.1 Staged Interpreter Staged interpreters are a classic application of MSP. \nTo demon\u00adstrate that staged interpreters can be written in Mint, we have im\u00adplemented an interpreter \nfor a small programming language called lint [26], which supports integer arithmetic, conditionals, and \nre\u00adcursive function de.nitions of one variable. The unstaged interpreter represents expressions with \nthe Exp interface, and instantiates this interface with one class for each kind of AST node in the language. \nThis interface speci.es the single method eval for evaluating the given expression, which takes two environments, \none for looking up variables and the other for looking up de.ned functions. The environments are modeled \nas functions, implemented using anonymous inner classes. The empty environments unconditionally throw \nan exception. Application of de.ned functions, for example, is implemented as follows: class App implements \nExp { private String _s; private Exp _a; // argument public App(String s, Exp a) { _s =s; _a =a; } public \nint eval(Env e, FEnv f) { return f.get(_ s).apply(_ a.eval(e, f)); }} where f.get(_s) looksupthe de.ned \nfunction namedbythe string _s as an object of the class Fun. The Fun class has an apply method for applying \na function to an argument, and this is used here to apply the function to the result of evaluating the \nargument _a. If _s does not name a valid, de.ned function in f, then get throws an exception. The staged \ninterpreter rede.nes the eval method to return Code<Integer>, so that evaluating an expression yields \ncode to compute its value. This method is marked as separable so that it canbe called from insidean escape.Forexample, \nstagingthe App class above yields the following: class App implements Exp { /* ... */ separable Code<Integer> \neval(Env e, FEnv f) { return <| (f.get(_ s)).apply( (_ a.eval(e,f))) |>; }} The get method is again used \nto look up the function named by _s. The return type of get is now Code<Fun>, meaning that get returns \ncode for the de.ned function. This code is spliced into the returned code, and its result is applied \nto the evaluation of the argument using the apply method. The argument for apply is obtained by splicing \nin the code object returned by _a.eval. If _s does not name a valid, de.ned function, then the get method \nthrows an exception. interface Env { public separable Code<Integer> get(String y); } static separable \nEnv ext(final Env env, final String x, final Code<Integer> v) { return new Env () { public separable \nCode<Integer> get(String y) { if (x==y) return v; // lookup succeeded else return env.get(y); // recurse \n} }; } Env env0 = new Env() { // empty environment public separable Code<Integer> get(String s) { throw \nnew Yikes (); // unconditional throw } }; Note that this is the only computational effect in the whole \nstaged interpreter that happens inside a code generator. It is weakly separable, however, because the \nthrown exception need only con\u00adtain the string argument _s that was not found in the environment; the \nexception therefore is code-free.  5.2 ArrayViews As discussed, weak separability does not restrict \nthe computational effects in generated code; it only restricts effects in the code gen\u00aderators themselves. \nAs an example of this, we use staging to re\u00admove overhead in array views, which are useful for parallel \npro\u00adgramming. Itcanbe challengingfora compilerto parallelizeJavacodethat uses multi-dimensional arrays, \nimplemented in Java as nested one\u00addimensional arrays. This arrangement prevents the compiler from assuming \nthat A[i][j] and A[i+1][j] refer to different locations. In one-dimensional arrays,eachindex referstoadifferent \nlocation, and this knowledge allows for simpler parallelization. To address the problems with multi-dimensional \narrays in Java, the Habanero project [8] provides array views, which map subsec\u00adtions of multi-dimensional \narrays to one-dimensional arrays with\u00adout requiring the programmer to perform the arithmetic manually \n[22]. Much simpli.ed, an array view stores a reference to a one\u00addimensional base array and provides get \nand set methods for several numbers of dimensions. The example below shows get and set for a two-dimensional \ndouble array:  class DoubleArrayView { double [] base ; public double get(int i, int j) { return base[offset \n+ (j-j0) + jSize*(i-i0)]; } public void set(double v, int i, int j) { base[offset + (j-j0) + jSize*(i-i0)] \n= v; }} The methods calculate the index in the base array for the coor\u00addinates (here: i, j)using the \nminimumvalues for those dimensions (here: i0, j0), the size of the dimensions (here: iSize, jSize)and \nthe start indexof the view(offset). This calculation is performed for every array access. The overhead \nof this calculation can be removed by staging the array view. The base array itself and the parameters \ni0, j0, iSize, jSize, and offset describing the array view are replaced by code values that can be spliced \ntogether as needed. The get method returns Code<Double>, code to retrieve the value in the array. The \nset method returns Code<Void> and is a generator for code performing the array assignment. class SDoubleArrayView \n{ Code < double [] > base ; public separable Code<Double> get(final int i, final int j) { return <| (base)[ \n(offset) + (j- (j0)) + (jSize)*(i- (i0))] |>; } public separable Code<Void> set(final Code<Double> v, \nfinal int i, final int j) { return <| { (base)[ (offset) + (j- (j0)) + (jSize)*(i- (i0))] = (v); } |>; \n} } Staging allows us to work with the array view at a high level without payingfortheoverheadat runtime.Forexample,a \nmatrix transpose can be written as public Code<Void> stranspose(int m, int n, final SDoubleArrayView \ninput , final SDoubleArrayView output) { Code <Void > stats = <| { } |>; for(int i=0; i<m; i++) for(int \nj= 0; j <m; j++) stats = <| { stats ; (output.set(input.get(i,j),j,i)); } |>; return stats ; } Code<Void> \nc = stranspose(4, 4, a, b); This method generates code consisting of direct array accesses: b[0+(0-0)+4*(0-0)] \n= a[0+(0-0)+4*(0-0)]; b[0+(0-0)+4*(1-0)] = a[0+(1-0)+4*(0-0)]; // ... An optimizing compiler will replace \nthe computations with constants, completely removing the cost of the abstraction in the generated code. \nNote that the size of the dimensions does not have to be known statically,butat generation time;onlythe \nnumberof dimensionsof the array has to be known statically. Therefore, the size of the array can vary, \nand this optimization is applicable in manysituations. Thisexample performs loop unrolling as well. The \ncode objects that perform the array assignments, returned by the set method, are accumulated into another \ncode object stats. At the end of the two nested loops, stats will contain the sequence of statements \nfor the entire matrix transpose operation. The code generator is written in an imperative style consistent \nwith the prevalent Java culture. The body of the method is weakly separable because stats is bound inside \nthe method; the code inside stats returned by the stranspose methodis not weakly separable,but thatis \nnot required of generated code. Staged array views and loop unrolling serve as compelling ex\u00adampleshowMSPcan \nreduce abstractionoverheadinan imperative setting.  5.3 Staged Re.ection Primitives Neverov observed \nthat staging and re.ection in languages like C# and Java can be highly synergistic [15]. He also noticed \nthat fully exploiting this synergy requires providing a special library of staged re.ection primitives. \nMint provides such a library. The primitives are basedon the standard re.ection primitives in the Java \nlibrary, including the Class<A> and Field classes. 2 To represent these in Mint, the library adds two \ncorresponding types, ClassCode<A> and FieldCode<A,B>. The ClassCode<A> type is indexed by the class itself, \njust like the type Class<A> it is mod\u00adeled after.Forexample, the corresponding class for Integer objects \nhas type ClassCode<Integer>. Any ClassCode<A> object provides methods for manipulating the class, corresponding \nto the methods of Class<A>.For example, the cast method of ClassCode<A> takes anycode object of type \nCode<Object> and insertsa castinthecode object, yielding a code object of type Code<A>. Because the cast \nis inserted into the code, any exceptions raised by the cast will not happen until the code is run with \nthe run() method. The class also provides methodsfor lookingupa classby nameandfor retrieving the .elds \nof a class. The type FieldCode<A,B> represents a .eld in class A that has type B. It provides a get method \nwhich takes a Code<A> value and returns a value of type Code<B>. This method constructs .eld se\u00adlection \n(intuitively, a <| ( a).f |> code fragment) on that object. The type also provides a getFieldClassCode \nmethod to return a ClassCode<B> object for the type B. The .elds of a class are returned using the getFields() \nmethod in ClassCode<A>. The return type of getFields() is FieldCode<A,?>[], where the ? represents an \nexistential type in Java s generics. The method therefore returns an array of .elds contained in class \nA, all of which have some type. The following example illustrates the use of these classes. The code \nde.nes a serializer, which recursively converts an object and all of its .elds to a string representation. \nSerializers are often slow, however, because they must use Java s re.ection primitives to determine the \n.elds of an object at runtime. Here we show how to write a staged serializer, which generates a serializer \nfor a given static type. This approach performs the necessary re.ection when the serializer is generated, \nand produces code to serialize all of a given object s .elds without re.ection: public static separable \n<A> Code<Void> sserialize(ClassCode<A> t, final Code<A> o) { if (t.getCodeClass()==Byte.class) return \n<| { writeByte( ((Code<Byte>)o)); } |>; else if (t.getCodeClass()==Integer.class) return <| { writeInt( \n((Code<Integer >)o)); } |>; Code<Void> result = <| { } |>; for(FieldCode <A,?> fc: t.getFields()) { result \n= <| { result; (sserializeField(fc, o)); } |>; } return result; } 2The Mint re.ection library does not \nsupport all re.ection primitives.For example, Method and Constructor have multiple parameters. Thiswould \nrequire adding indexed types to Java, and is therefore outside the scope of this work.  The code to \nwrite primitive .elds is generated directly. Non\u00adprimitive .elds are visited recursively. The code is \nthen spliced together and returned. This example was inspired by a similar ex\u00adamplegivenbyNeverov and \nRoe [15]. 6. Type Safety We now turn to formalizing a subset of Mint, called Lightweight Mint (LM), and \nto proving type safety. Type safety implies that scope extrusion is not possible in Mint. LM is based \non Lightweight Java [25] (LJ), a subset of Java that includes imperative features. LM includes staging \nconstructs (brackets, escapes, and run), assignments, and anonymous inner classes (AICs). These features \nespecially the staging constructs and AICs make the operational semantics and type system large; staging \nconstructs alone double the number of rules in the opera\u00adtional semantics, while AICs increase the complexity \nof the type system. All of these features, however, are necessary to capture the safety issues that arise \nin Mint. Speci.cally, assignments are required to cause manyforms of scope extrusion, and AICs are re\u00adquired \nto create the scopes (i.e., the additional variable bindings) that can be extruded. AICs also lead to \nmore complex possibilities for scopeextrusionasshown,forexample,in Figure2of Section 3, which uses an \nAIC in combination with CSP to perform scope extrusion.We wish to show that such possibilities are preventedby \nour system. A noteworthy feature of the type system is the use of a stack of store typings instead of \na single store typing. The standard way to express type preservation of programs with mutable references \nis to have a store typing S that assigns types to locations that are allocated during evaluation. Preservation \nthen states that, if e1, typable with store typing S, takes a computation step to e2 (possibly allocating \nnew store locations), then e2 is typable with a new, possibly extended, store typing S/. Instead, we \nuse a stack of store typings, represented as a sequence. Each time evaluation enters the scope of a variable \nbinding, say of x, we push a new S to the right of the sequence that may type heap locations holding \ncode values containing x free. During execution, type assignments to non-code-free heap locations l allocated \nwithin this scope are always added to this S. The S is popped from the right upon leaving the scope of \nx, so references to l are only typable in the scope of x. When we pop a S from the stack of S s, we always \nsalvage code-free locations and tack them on to the S s that remain, so that those locations can be used \nelsewhere. The Smashing Lemma guar\u00adantees that this contraction, or smashing, of the store typing stack \nis safe. For this strategy to work, the S s must obey a condition somewhat similar to the Barendregt \nvariable convention: whenever S is appended to the store typing stack, the locations in S must be fresh \nwith respect to other S s in the same typing derivation; i.e., the domains of all distinct S s appearing \nin a single derivation tree must be disjoint. Otherwise, a location l that types (|x|) under one S can \nbe used to type an incompatible object in a disjoint subtree of the derivation tree.A more rigorous de.nitionof \nthis constraint can be found in the companion technical report [29]. To simplify the formalism, LM disallows \nassignments to local variables; all assignments must be to object .elds. This restriction by itself would \ncompletely rule out assignments in escapes, how\u00adever.To rectify this problem, we adda restricted formof \nlet, writ\u00adten as let x <= new C (...) in ... which always allocates a new instance of a class C that \nis not an AIC. We then relax the restrictions on escapes to allow .eld assignmentsifthe object containingthe \n.eldwas allocatedbya let inside the escape. Local variable assignment can then be modeled extensible \nclass names D .nal class names F variables x .eld names f method names m heap locations l classes C ::= \nD | F separability marker S ::= sep | insep types t ::= C | Code(S,t) class declarations CL ::= class \nC extends D {(ti fi)Ii ; (Mj 0)Jj } method declarations Mn ::= Stm((ti xi)i){e n} class hierarchy P ::= \n(CLi)i programs p ::= P, e0 n nnn expressions e ::= x | l | e .f | (e .f := e ) | e n .m((e ni )i) nn \n| let x . new C((ei )i) in e n | new D((ei )Ii ){(Mjn)Jj } | (|e n+1|) | e n-1[n> 0] | e n .run() nn-1 \nvalues v ::= l | e [n> 0] NB: Production rules marked [n> 0] can be used only if n> 0. Figure 3. Lightweight \nMint syntax. by replacing anylocal variable binding x of type C for which there isan assignmentbya let-binding \nof a new variable x_cell of type CCell, de.ned as follows: public class CCell { public C x; } Uses of \nx, including assignments to x, can thenbe replacedby uses of x_cell.x. Thus, we model the environment \nas part of the heap, meaningthatthevaluesofvariablesarealwaysheap locations.This is equivalent to an \nenvironment-based semantics, which models variables as locations in a special environment object. 6.1 \nSyntax In this section, we formalize the syntaxof LM.We use the follow\u00ading sequence notation: Notation. \nWe write(a, b, c, . . .) for sequences, with the shorthand (Ai)Ji=I for (AI ,AI+1,...,AJ ). I may be \nomitted, and it defaults to 1. J may also be omitted when clear from context. The empty sequence is written \n(). Concatenation of sequences s1 and s2 is written s1 . s2, with the shorthand (Ai)i,A for (Ai)i .(A).We \nalso use (ei)Ji=I [i0 . x] to denote (ei)i with ei0 replaced by x. The syntaxofLMisgivenin Figure3. Expressions \nare strati.ed into levels. An expression is at level n if, for every point in the expression, the nesting \nof escapes is at most n levels deeper than brackets. Clearly, a level-n expression is also a level-(n \n+ 1) expression. This strati.cation inducesasimilar structure on method declarations. A complete program \nmust not have any unmatched escapes, so the bodies of methods declared in the class hierarchy are required \nto be at level 0. Likewise, the initial expression in a program is required to be at level 0. Values \nare also strati.ed: a value at level 0 is just a heap location, and a value at any level n> 0 is any \nexpression at level <n. Remark. The n in e n isa constraintontheshapesof termsthatthis metavariable ranges \nover and is not something that forms a part of anyconcrete term. Similar precautions apply to other superscripted \nmetavariables in this formalism, like v n and Mn . We categorize classes(C)as .nal(F )or extensible(D)de\u00adpending \nupon their names. In the implementation, they are rather categorized according to the manner in which \nthey are declared, but using disjoint sets of names gives a simpler system. The types (t)include classes \nas well as the code typeCode(S,t ), which is considered distinct from the classes.  This code type Code(S,t \n) is indexed by a separability marker S, which indicates whether a code object is itself separable, and \nthe type t of the expression in the code object. Speci.\u00adcally, Code(sep,t) is the type of code objects \ncontaining sepa\u00adrable code, which is a subtype of the standard code type, written Code(insep,t). This \ndistinction is necessary in the case of a sep\u00adarable expression which itself contains a nested escape \ne, since we must know for type preservation that e is guaranteed to reduce only to separable code. In \nthis case, e must havetype Code(sep,t ). We do not allow an AIC to have .elds or methods that its parent \ndoes not, although we allow method overrides. Additional .elds or methods can be emulated by declaring \n(statically) a new subclass with those .elds and creating anonymous subclasses of those. We do not include \nthe syntax (new C( ... )) for instantiating ordinary (i.e., non-AIC) classes because one can write (let \nx . new C( ... ) in x) instead. Sequencing (e1; e2) is also omitted because this code can be written \nseq.call(e1,e2), where seq.call is a method that ignores its .rst argument and returns its second. All \njudgments and functions in the following discussions im\u00adplicitly take a class hierarchy P asa parameter.Weavoid \nwriting it out explicitly because it is .xed for each program and there is no fear of confusion.  6.2 \nOperational Semantics Figure4shows the small-step semantics for Lightweight Mint. This n .gure de.nes \nthe judgment H1,eb1 H2,eb2 which states that heap H1 and pseudo-expression be1 evaluateina single stepatlevel \nn to H2 and eb2,respectively.The notionofheapis standard;aheap is a .nite mapping from locations to heap \nelements, where a heap element contains a runtime type tag with either the contents of the object or \na code value if the tag is Code. The notion of a pseudo\u00adexpression, de.ned as either an expression or \na method body, is used becauseexecution can occur within bodiesof methods de.ned at level > 0. Similarly,we \nde.ne the notion of pseudo-value, which is eitheravalueoramethodbodywithno unresolved escapesatthe current \nlevel. Figure4containsanumberof helper functions. .elds() extracts the .elds of a type. method() looks \nup a method, respecting overriding rules. mbody() extracts the speci.ed method s formal arguments and \nbody. Code types do not have methods(run() is formally not a method). mname extracts the method name \nfrom a method declaration. n The single-stepevaluation judgment is de.ned as the closure k of the primitiveone-step \nrelation under n, k-evaluation contexts prim En,k. These are pseudo-expressions witha hole . This hole \ncan be .lled with an expression e, written En,k[e];the superscriptsn and k express that .lling the hole \nwith a level k expression yields a level n pseudo-expression. Most of the primitive reduction steps are \nstraightforward, including rules for class instantiation, method invocation, and assignment. These reductions \nonly occur at level 0, to prevent reductions from occurring inside code objects. As lo\u00adcal variables \nare immutable, we can model method invocation and let-execution by substitution. The local environment \nL found in LJ [25] is therefore unnecessary, and the small-step judgment is made between heap-term pairs \nrather than environment-heap-term triples.Thisisnotthe sameasusingasubstitution-based semantics, because \nonly heap locations are substituted for variables, i.e., vari\u00adables are instantiated by their location \non the heap. This is equiva\u00adlent to an environment-based semantics, as discussed in the begin\u00ad operational \nterms .n heaps H : l . h runtime type tags T :: = C | sub D {(Mi 0)i} | Code heap elements h :: = (C, \n(li)i) | (Code, (|e 0|)) | (sub D {(Mi 0)i}, (lj )j ) nn | Mn pseudo-expressions be :: = e n | Mn-1 pseudo-values \nvbn :: = v [n> 0] evaluation contexts En,k ::= En,k |En,k e M En,k ::= Stm((ti xi)i){Een,k }[n> 0] M \nEen,k ::= [n = k] |Een,k .f | (Een,k .f := e n) n .f := En,k n ) |En,k n in)i, En,k n | (v ee .m((ei \n)i) | v .m((v e , (ej )j ) in)i, En,k n n | let x . new C((v e , (ej )j ) in e n | let x . new C((vi \n)i) in Een,k [n> 0] in)i, En,k n | new D((v e , (ej )j ){(Man)a} | new D((vin)i){(Mn-1)j , En,k , (Mn)a}[n> \n0] j Ma | (|Een+1,k|) | Een-1,k[n> 0] |Een,k .run() nn nn H, en H, en and H, eb H, eb prim l . dom H \n000 H, new D((li)i){(Mj )j } H[l . (sub D {(Mj )j }, (li)i)],l prim H(l)=(T, (li)i) .elds(T )= (fi)i \n0 H, l.fi0 H, li0 prim H(l)=(T, (li)i) /0// H, (l.fi0 := l) H[l . (T, (li)i[i0 . l])],l prim H(l)=(T,...) \nmbody(m, T )=((xi)i,e 0) 00 H, l.m((li)i) H, [(li)i/(xi)i][l/this]e prim l . dom H 000 H, let x . new \nC((li)i) in e H[l . (C, (li)i)], [l/x]e prim H(l)=(Code, (|e 0|)) H(l)=(Code, (|e 0|)) 10 00 H, l H,eH,l.run() \nH, e prim prim l . dom H 000 H, (|e |) H[l . (Code, (|e |))],l prim kkk H1,e 1 H2,e 2 prim H1, En,kk \nH2, En,kk [e1 ] n[e2 ] Figure 4. Small-step semantics for Lightweight Mint. ning of this section,but \nmakes the formalism simpler because of the removal of the local binding L found in LJ.  Each staging \nconstruct induces a primitive reduction rule. Es\u00adcape and run extract expressions from brackets. Escape \nreduces onlyatlevel1and runonly reducesatlevel0. These are standardin multi-stage languages [27], except \nthat the code values are on the heap. Brackets allocate a code object on the heap. CSP, which can be \nregarded as execution at arbitrarily high levels, is automatically taken care of by substitution and \ndoes not give rise to a redex.  6.3 Type System Figure5showsthetype system.Avariabletyping(ortypeenviron\u00adment) \ncomes in pairs, separated by a | . The predicate iscf(Fi)(t ) asserts that t is code-free assuming that \nthe .nal classes (Fi)are. Thus iscf()(t), also written iscf(t), means that t is code\u00adfree. Note, however, \nthat iscf() does not require method types to be code-free because the formal language does not model \nclass declarations within anonymous inner classes. The auxiliary func\u00adtions ftypes(), ftypei(), and mtype() \nare similar to .elds() and method(),but they extract type information. The top-level judg\u00adment f p asserts \nthat program p is a valid initial state of exe\u00adcution: the class hierarchy P contained in p must be well-formed \nand the expression e contained in p must be well-typed and free of heap locations.A class hierarchy P \nis well-formed, written f P , if P is acyclic, .eld names and types (including inherited ones) do notclashwithineachclass,andeachclassis \nwell-formed.Weomit a formalizationofthe.rsttwochecksbutwillusethem implicitly by assuming that auxiliary \nfunctions like .elds() and mtype() are always unambiguous and that the sequence returned by .elds() is \n.nite and has no duplicates. Classes are well-formed if they con\u00adtain no locations, their methods are \nwell-typed, and anyoverridden methods have the same types as in the superclass. The bottom half of Figure5de.nes \ntyping for pseudo-expres\u00adsions with the judgment (Si)i;G fn ebn : tb|S,which states that the pseudo-expression \nebn has type tbat level n under the stack (Si)i of store typings and the pair G of contexts. If S = sep,this \njudgment further states that the pseudo-expression ebn is weakly separable. Variable typing G is partitioned \ninto two parts in order to check weak separability of .eld assignments. The right part contains the variables \nthat were bound within the current method or enclosing escape, which are precisely the variables whose \n.elds can be as\u00adsigned to without violating weak separability.We always assume that no variables are \nrepeated in G. Most of the rules for typing pseudo-expressions are straightfor\u00adward. The .rst rule generalizes \nsubtypes to supertypes. (Subtyping rules are omitted due to space limitations; they are the same as in \nplain Java.) The next two rules look up the types for variables and locationsinthevariableand store typings, \nrespectively.CSPisonly allowed (by k> 0 or n> 0, respectively) if the associated type is code-free. The \nnext rule is typing let-expressionsbyextending the current context with the let-bound variable, while \nthe rule follow\u00adingistyping .eld lookupsbytypingtheobjectandthen lookingup the relevant .eld type. In \ntyping the body of a future-stage let,a new frame S is added to the current stack (Si)i to allow for \nthe possibility of heap locations containing code objects with the vari\u00adable x free. The next three rules \ntype .eld assignments (e1.f := e2) by checking that e1 has some t1 and that the type t2 of e2 matches \nthe appropriate .eld type of t1. The .rst of these rules applies to arbitrary e1 and types the assignment \nas weakly separable only if the .eld has code-free type. The second and third rule handle assignments \nof non-code-free type in a weakly separable context. The second rule requires e1 to be a variable x and \nallows the assignment to be typed as separable only if the variable is in G2 (recalling that G2 gives \nprecisely the variables whose .elds can be modi.ed without violating weak separability). The third rule \nessentially captures how a judgment using the .rst or the second rule transforms under substitution of \na location l for the x in the second rule: it requires that either the location l is in the topmost store \ntyping or the type of the .eld is code-free. Therulefollowingistyping methodcallsbylookingupthetype of \nthe given method. The rule on the immediate right checks well\u00adformedness of AIC de.nitions. Finally, \nthe last three rules type brackets, escape, and run, where typing (|e|) requires typing e at the next \nlevel and adds the code type; typing e requires typing e at a code type on the previous level and removes \nthe code type; and typing e.run() types e at a code type on the same level and removes the code type. \nBrackets can always be weakly separable, run is never weakly separable, and escapes e are only weakly \nseparable if e has type Code(sep,t ). The remainder of Figure 5 de.nes the following judgments. (Si)i;G \nfn sub D {(Min)} states that an anonymous subclass of D with method de.nitions (Min) is well-formed. \nThis re\u00adquires the methods (Min) to have the appropriate types. It also requires, if n =0, that all the \nlocations in the AIC are contained in dom(.iSi),ensuring that no new frames can be added to the stack \nMnS of store typings. The judgment (Si)i;G fn : (ti)i . t |S states that method M has input types (ti), \noutput type t , and fur\u00adther is weakly separable if S = sep. Note that this rule is allowed to push a \nnew frame onto the stack of store typings when the level n> 0. This is because there may be some locations \nin the store that contain code that include the free variables bound inside M. Note also that passing \ninside a method resets the vertical bar | in G to the end, indicating that weakly separableexpressionsinthe \nmethod cannot freely access variables bound at or before the method M. The judgment (Si)i;G f H states \nthat the store H is well\u00adformed under the given stack of store typings. This judgment in\u00adcludes the typing \ncontext G because the store may contain code with free variables. This judgment requires that, for all \nlocations l in the stack of store typings, the heap for H(l) is well-typed. Note that there may be more \nlocations in H than in the domain of (Si)i, allowing the possibility that other frames could be pushed \nonto this stack. The judgment (Si)i;G f h : t is then used to state that heap form h has type t. The \nrules for this judgment require that theexpressions containedin the heap form h are well-typed. The typing \ncontext used to type these expressions is the restriction of G to the variables of level greater than \n0. This is because heap forms are allowedtohave code objects with freevariablesin them,but these free \nvariables must be bound in other code objects, meaning they must have been bound at level greater than \n0. Note that, as a side effect of these de.nitions, if (Si)i;G f H holds then H re\u00adstricted to dom(.iSi) \nis closed under reachability, meaning that no location in this domain can reference a location outside \nof it.  6.4 Soundness We now outline thekey parts of our type soundness proof. Com\u00adplete proofs can \nbe found in the companion technical report [29]. Type soundness is proved by the usual Preservation and \nProgress lemmas. Progress follows directly from Unique Decomposition, which statesthatanywell-typedexpressionis \neitheravalueor con\u00adtains a unique redex, which can be contracted by the operational rules. Uniqueness \nalso ensures that our semantics is deterministic. Lemma 1 (Unique Decomposition). If (Si)i;G fn ebn : \nt |S and be n is not a pseudo-value then be n is uniquely decomposed as n En,m[r eb= m], where = denotes \nsyntactic equality modulo a conversion. The proof of Preservation is more complicated. One technical \ndif.culty is that the extra S added in the rules for binding con\u00adstructs are unrestricted and therefore \nmay include locations that are notin the current heap.Toavoid this problem, we introduce typing for con.gurations \npairs of heaps and pseudo-expressions. The typing terms  (Si)i;G fn sub D {(Min)} .n variable typing \nG: x . tn fn Mn ((Si)i;G1|G2, this : Dnj : tj |Sj )j .n store typing S: l . t n> 0 . dom(.iSi) . locs(sub \nD {(Mjn)j }) variable typing pair G ::= (G|G) (Si)i;G1|G2 fn sub D {(Mjn)j } S pseudo-types tb::= t|(ti)i \n. t where tj = mtype(mname(Mjn),D). iscf(Fi)(t), iscf(t ) S Mn (Si)i;G fn : (ti)i . t |S (Si)i, S; G1, \nG2, (xi : tin)i|\u00d8 fn e n : t |S F .(Fi) iscf()(t ) .i. iscf(Fj),F (ftypei(F )) S iscf(Fi)(F ) iscf(t \n) iscf(Fj)(F ) (Si)i;G1|G2 fn Stm((ti xi)i){e n} : (ti)i . t|S/ (Si)i;G f H cf(S), locs(eb), ftypes(t), \nftypei(t), ftype(f, t) .l . dom(.iSi). (Si)i;G f H(l):(.iSi)(l) cf(S) = S|L where L = {l . dom(S) : iscf()(S(l))}. \nlocs(be)= {l : l is a subterm of eb}(Si)i;G f H ftypes(t )= (ti)i assuming .elds(t )= (ti fi)i ftypei(t \n) = ftype(fi,t )= ti assuming ti fi . .elds(t) (Si)i;G f h : t f p, f P , f CL (Si)i;G f h : tt t / \n((.iSi)(lj ) ftypej (C))j (Si)i;G f h : t/ (Si)i;G f (C, (lj )): C f P (); \u00d8|\u00d8 f0 e 0 : t |S locs(e \n0)= \u00d8 0/ 0 (Si)i;G =1 f0 (|e |) : Code(S,t)|S f P, e (Si)i;G f (Code, (|e 0|)): Code(S,t) inheritance \nis acyclic no .eld names clash (f CLi)i 0 f(CLi)i (Si)i;G =1 f0 sub D {(Mj )j } ((.iSi)(lk) ftypek(D))k \n0 00 f0 (locs(Mi )= \u00d8)i ((); \u00d8|this : CMi )i 0 (Si)i;G f (sub D {(Mj )j }, (lk)k): D (mtype(mname(Mi),D)= \nundef or mtype(Mi 0))i f class C extends D {(tj fj )j ;(Mi 0)i} where G =1 (x)= t n .. G(x)= t n . n \n= 1. (Si)i;G fn e n : t |S Additional constraints on (Si)i are discussed in the text. n t / t (Si)i;G \nfn e : t /|S G(x)= tn iscf(t ) . k =0 (.iSi)(l)= t iscf(t ) . n =0 (Si)i;G fn e n : t |S (Si)i;G fn+k \nx : t |S (Si)i;G fn l : t |S ((Si)i;G1|G2 fn e nj : ftypej (C)|S)j fnn n (Si)i, S; G1, G2|x : Cn e : \nt|S (Si)i;G fn e : t|S nn (Si)i;G1|G2 fn (let x . new C((ej )j ) in e ): t |S (Si)i;G fn e n .f : ftype(f, \nt)|S nn jj=1 1 ((Si)i;G fn e : tj |S)2 G(x)= tn (Si)i;G1|G2 fn e : t2|sep ftype(f, t1)= t2 S = insep \n. iscf(t2) x . dom G2 ftype(f, t1)= t2 (Si)i;G fn (e1.f := e2): t2|S (Si)i;G1|G2 fn (x.f := e n): t2|sep \nnn (.iSi)(l)= t1 iscf(t2) . (n =0 . l . dom SI ) (Si)i;G fn e : t|S ((Si)i;G fn ej : tj |S)j nS ftype(f, \nt1)= t2 (Si)Ii ;G fn e : t2|sep mtype(m, t )= (tj )j . t (Si)Ii ;G fn (l.f := e n): t2|sep (Si)i;G fn \ne n .m((ejn)j ) : t|S n ((Si)i;G fn ej : ftypej (D)|S)j n (Si)i;G fn sub D {(Mkn)k} (Si)i;G1, G2|\u00d8 \nfn+1 e : t |S (Si)i;G fn e : Code(S,t )|sep n / (Si)i;G fn+1 (Si)i;G fn new D((ej )j ){(Mkn)k} : D|S \n(Si)i;G1|G2 fn (|e|) : Code(S,t )|S e : t|S (Si)i;G fn e : Code(S,t)|S/ (Si)i;G fn e.run()|insep Figure \n5. Type system for Lightweight Mint. judgment (Si)i;G fn (H, ebn): t|S then speci.es that the con.g\u00aduration \n(H, ebn) is well-typed. Con.guration typing rules are iden\u00adtical to pseudo-expression typing rules except \nthat each rule also requires the heap H to be well-formed under the current context. For example, the \nrule forlet becomes: ((Si)i;G fn (H, enj ) : ftypej (C)|S)j (Si)i, S; G,x : Cn (H, en): t |S (Si)i;G \nf H fn nn (Si)i;G fn (H, let x . new C((ej )j ) in e ): t |S Asecond technicaldif.cultyisthatareductionstep \ninsidealet form or AIC that pushes a new frame S onto (Si)i might modifya code-free location in dom(.iSi) \nto referencealocationinthenew frame S. Then the resulting heap is ill-formed under (Si)i, be\u00adcause this \nportion of the heap is not closed under reachability. The SmashingLemmasolvesthisproblembysmashingthetoptwo \nS s of (Si)i into one, giving a shorter store typing stack. Informally, it states that the side-effects \nof a small-step happening inside a dy\u00adnamic binder are invisible from outside except for allocations \nof code-free locations. Lemma2 (Smashing). If 1. G/1 . G2/. G1 . G2 2. (Si)Ii ;G1|G2 f H1 3. (Si)Ii \n, S; G/1|G/2 f H2 4. H1|L = H2|L where L = dom(.Ii=1Si) -dom(cf(.iI =1Si))  then (Si)I-1 , (SI . cf(S)); \nG1|G2 f H2. i The different store typing stacks capture different views of the heap. The stack (Si)I \ncaptures the locations that can legally be i referenced outside the binder (the outer view). The stack \n(Si)Ii , S captures what can be referenced from inside the binder (the inner view). Similarly, the variable \ntyping pair G1|G2 is used outside the binder while G/1|G/2 is used inside the binder. The inner variable \ntyping pair contains typings for the new variables in addition to those in the outer variable typing \npair (condition 1). Code inside the binder may refer to locations that were illegal outside, namely those \nwith code values that (may) contain free variables in (G/1 . G/ 2) \\ (G1 . G2). The extra S available \nin the inner view provides this extension to set of visible locations in the outer view. Suppose a small-step \nin the inner context takes the heap from H1 to H2. Our concern is whether H2 is still well-formed, espe\u00adcially \nin the outer view. The heap had better be well-formed at the beginning in both the inner and outer views; \nthe outer one matters here (condition 2). After the small-step, we can easily show in the proof of Preservation \nthat the new heap H2 is well-formed in the innerview,bya suitable inductivehypothesis (condition3). Recall \nthat any new allocations during the small-step are attributedto the topmost store typing S, so the pre.x \n(Si)I remains the same as in i the check on H1. All the code-free restrictions on side effects exist \nto ensure that the small-step could not have touched anynon-code\u00adfree locations that are visible in the \nouter view (condition 4). The lemma then asserts under these conditions that H2 is indeed well\u00adformed \nin the outer view, provided that we salvage any new code\u00adfree allocations from S into (Si)Ii .We add \nthese new allocations to the topmost store typing, SI , in compliance with the convention of only modifying \nthe topmost store typing. The Smashing Lemma implies the absence of scope extrusion, as it states that \nanycode locations that could potentially cause scope extrusion are not reachable outside their respective \nscopes. n Lemma3 (Preservation). If (Si)i, SR;G1|G2 fn (H1,eb1 ): t|S and (H1,eb1 ) n e2 ), then .S/ \nn (H2, bnR suchthat 1. S/ R . SR 2. (Si)i, S/(H2, b2 ): t|S R;G1|G2 fn e n Benchmark speedup unstaged \n\u00b5s staged \u00b5s power 9.2 0.060 0.0065 fib 8.8 0.058 0.0065 mmult 4.7 13 2.7 eval-fact 20 0.83 0.042 eval-fib \n24 18 0.73 av-mmult 65 20 0.30 av-mtrans 14 1.0 0.071 serialize 26 1.5 0.057 Figure 6. Benchmark results. \n3. H1|L = H2|L where L = dom(.iSi) - dom(cf(.iSi)) This statement is an abridged version. As mentioned \nat the be\u00adginning of this section, we need freshness assumptions about heap locations in S, and this \nlemma must be expanded to incorporate them. The companion technical report contains a complete state\u00adment \nand a proof of this lemma. 7. Performance To validate both the expressivity of our type system as well \nas the potential usefulness of MSP for Java, we extended the Java OpenJDK compiler [17] with our proposed \ntype system and with runtime support for staging. All examples presented earlier in the paper were type-checked \nusing this implementation [18]. In this section, we present timing results that con.rm that MSP can affect \nthe performanceofJava programsinaway similar that observedin other languages. 7.1 Benchmarks In order \nto measure the performanceimpact of MSP in Mint, we have benchmarked the following Mint examples: power \nis thepowerexample from Section2, called with base2 and exponent 17.  fib recursively computes the 17th \nelement of the generalized Fibonacci function starting from2and3.  mmult performs sparse matrix multiplication, \nin which every 1 in the left matrix omits the .oating-point multiplication at runtime andevery0omits \nthe multiplication and the addition. The benchmark is multiplies an 11-by-11 unsymmetric sparse matrix \n[6] with itself.  eval-fact calculates the factorial of 10 using the lint inter\u00adpreter discussed in \nSection 5.1.  eval-fib calculates the 10th number in the standard Fibonacci sequence using the lint \ninterpreter.  av-mmult performs the same sparse matrix multiplication as mmult,but accesses the matrix \nusing the array views described in Section 5.2.  av-mtrans performs a matrix transpose using array views. \n serialize uses the serializer generator discussed in Section 5.3 to write the primitive.elds contained \nin an object hierarchytwo levels deep to an output stream.  For each operation in the benchmarking process \n(unstaged, staged), we .rst determine the number of repetitions that are re\u00adquired for the operation \nto run for 1-2 s. This calibration phase also allows the JIT compiler to .nish optimizing the program \nboth for the unstaged and the staged code.We then run as manyrepetitions of the operation as determined \nin the previous step and record the total time. The average runtime of a single repetition is calculated \nfor each operation and used for the benchmark.  Timings were recorded on an Apple MacBook with a 2.0 \nGHz Intel Core Duo processor, 2 MB of L2 cache, and 2 GB main memory, running Mac OS 10.4.11 Tiger and \nthe SoyLatte 1.0.3 JVM [24].  7.2 Results The results are given in Figure 6. Performance improved in \nall cases. The speedups, de.ned as unstaged time divided by staged time, range from 4.7 to 65. The staged \nversions of power and fib executed approximately nine times faster than the unstaged code due to the \nremoval of recursion. The mmult benchmark involved mostly tight for loopsand couldonlybespedupbyafactorof4.7. \nStaging the lint interpreter removed call overhead and improved the performance of the eval-fact and \neval-fib benchmarks by factors of 20 and 24, respectively. In theav-mmult and av-mtrans benchmarks, loops \nwere unrolled and the layer of indirection in the formof arrayviewswas replacedbydirect array accesses, \nresulting in speedups of 65 and 14, respectively. Finally, the serializer benchmark also bene.ted from \nstaging through the removal of re.ection,andexecutiontimewas reducedbyafactorof26. These improvements \nmake it clear that the presence of JIT technology in Java does not subsume the need for staging techniques, \nand that the performance bene.ts reported in previous work [5, 26] on languages without JIT technology \napply to Java as well. 8. RelatedWork A distinguishing feature of Mint is a strong, expressive, and safe \ntype system that permits both manipulation of open terms and im\u00adperative programming. Few multi-level \nimperative languages have suchatype system,andfeweryet comewith rigoroustypesafety proofs. C [19] and \nJumbo [13] do not guarantee well-formedness of generated code. Cyclone [23] statically guarantees type \nsafety (including well-formedness) of generated code,but does not treat code as .rst-classvalues. This \ndesign helps Cyclone sruntime code generatortobeveryfastand still produce high-quality code,but limits \nprogrammers in the way they can write generators. Other works on staging extensions to Java by Sestoft \n[21], Schultz et al. [20], and Zook et al. [30] focus on exploring novel uses of staging and/or quantifying \nperformance bene.ts. As such, these authors do not attempt to establish safety properties of their extensions. \nSome multi-stage systems based on Java offer safety proper\u00adties,but formalizations and proofs are often \nabsent or incomplete. Metaphore [15] comes with a core typed, Java-like calculus but its type soundness \nis left unproved. The calculus also leaves out side effects. SafeGen [10] is claimed to guarantee well-typedness \nof generated code, but the authors do not prove such a result or formalize their system. MorphJ [9] focuses \non re.ection and does not allow manipulation of arbitrary code values (in particular open terms). The \npaper proves soundness,but the system does not model sideeffects.F\u00a8ahndrichetal.[7] proposeasystem similartoMorphJ \nthat allows the user to perform limited manipulations of code val\u00adues,using re.ection,ina type-safe manner.DynJava[16]has \nstatic type checking for dynamically generated code based on annota\u00adtions about the types of free variables \nin code fragments. The au\u00adthorsclaimtypesafety,butdonot appeartooffera rigorousproof. The type annotations \nalso make their code generation system un\u00adhygienic (i.e.a equivalencefails for dynamic code). Much of \nthe work on type safety proofs in the literature are for functional languages, where imperative extensions \nsimilarly cause scopeextrusion[2,3,11,12,14]. Mint either comparesfavorably or is competitive with all \nof these systems. Calcagno et al. [3] allow imperative operations on codebutdo not support imperative \noperations on open terms. Aktemur [1] and Kim et al. [14] support unrestricted imperative operations \non open terms but give up a\u00adequivalencefor future-stage code.Kimetal.delegatehygienetoa specialized binder \n. *, whose semantics can be explained only in termsofa gensym. Type termsalsotendtobeverylargeintheir \nsystems which may limit the programmer s ability to write down or interpret types and correct type errors; \nthis problem is offset to some extent, however, by type inference. Aktemur s and Kim et al. s systems \nallow storing open terms in global variables that can (potentially) outlive the scope of the variables \ntheycontain, which cannot be done in Mint. However, we are not aware of any use for this technique, apart \nfrom examples by Kim et al. that deliberately violatehygiene [14]. Unhygienic generation bringsup the \nproblem of inadvertent variable capture, and preventing it is a desirable feature of MSP. Ancona and \nMoggi [2] and Kameyama et al. [11, 12] are the onlyworksweknowofthat combine imperativeoperationsonopen \nterms and a-equivalence. Kameyama et al. s approach [12] is clos\u00adest to the weak separability approach \npresented in this paper,in that they limit the effects allowed within escapes. What distinguishes Mint \nfrom Ancona and Moggi s and Kameyama et al. s systems is that Mint allows effects occurring in escapes \nto be visible outside the escapes as long as they do not involve code objects, whereas Ancona and Moggi \nand Kameyama et al. unconditionally prohibit such effects. This difference makes our system more expressive, \nwhich is demonstrated in Section 5.1, where we throw an excep\u00adtion in a code generator, and in Section \n5.2, where we accumulate code in a for-loop. Neither Ancona and Moggi s nor Kameyama et al. s system \ncan directly express either of these examples. Even if we consider extending these systems, it is unclear \nhow to extend themto handle Section5.1 sexample.ToallowtheexampleinSec\u00adtion 5.2, their calculi must incorporate \narrays, which is a nontrivial theoretical exercise. Our type system is thus better suited to Java programming, \nwhich in general makes heavy use of effects. Furthermore, Kameyama et al. take delimited control operators \nas the primitives for effects, which are not found in mainstream languages like Java. In order to track \nthe use of delimited control operators,they must useaneffecttype system, which complicates types and \ntyping rules. It is true that delimited control allows Kameyama et al. to express computations that are \nnot easy to transcribe to assignment-based systems like Mint; however, the advantage of their system \nis in the underlying imperative primitive and is not in an essential limitation of the weak separability \nidea itself. Ancona and Moggi s system executes effects within dynamic binders not at code generation \ntimebut at the time the generated codeis run.In otherwordsif dynamic binders areinvolved, Ancona and \nMoggi s system cannot express effectful code generators al\u00adthough it can express generators that generate \neffectful code. Their system is similar to Aktemur s[1] and Kim et al. s [14] in that they use fresh \nnames. All such calculi currently requireexplicitly listing the free variables in the code type, and \nexplicitly managing hy\u00adgiene and free variables explicitly in terms. Most importantly, the extra constraints \nin the type require polymorphism and structural subtyping to be introduced in the language. Mainstream \nobject\u00adoriented languagessuchasJavaandC# support nominal subtyping, not structural subtyping. 9. Conclusion \nThis paper has proposed a practical approach to adding MSP to mainstream languages in a type-safe manner \nthat prevents scope extrusion. The approach is simpler than prior proposals, and we expect that it will \nbe easily and intuitively understood by program\u00admers.Thekeyinsightisthatsafetycanbe ensuredwithweaksepa\u00adrability, \nwhich places straightforward restrictions on the forms and typesof computationaleffects that occur inside \nescapeexpressions, so that these effects cannot cause code to leak outside of escapes. The proposalhasbeenvalidatedbothbyprovingthatweak \nsepara\u00adbility is enough to ensure safety and by demonstrating by example that manyuseful MSP applications \ncan still be written that adhere to these restrictions.  Afuture direction for this work is to try to \nsimplify the idea of weak separability to more closely match the intuition behind the concept.We believe \nthere is some system similar to environment classi.ers, in which quantifying on type variables can be \nused to implicitly capture the property that we wish to express. Instead of quantifying a type variable \nat the occurrence of run() as in environment classi.ers, however, we believethat weak separability can \nbe expressed by quantifying a type variable at the occurrence of an escape. Thiswould simplify the type \nsystem and possibly add more expressive power to the language. Acknowledgments We thank Yannis Smaragdakis, \nJulia Lawall and Samuel Kamin for their helpful comments.We thank the anonymous reviewers for their valuable \nfeedback. References [1] Baris Aktemur. Type Checking Program Generators Using the Record Calculus, 2009. \nhttp://loome.cs.uiuc.edu/pubs/ transformationForTyping.pdf. [2] Davide Ancona and Eugenio Moggi. Afresh \ncalculus for name man\u00adagement. In GPCE 04: Proceedings of the 3rdInternational Confer\u00adence on Generative \nProgramming and Component Engineering, vol\u00adume 3286, pages 206 224, 2004. [3] Cristiano Calcagno, Eugenio \nMoggi, andWalidTaha. ClosedTypes as a Simple Approach to Safe Imperative Multi-stage Programming. In \nICALP 00: Proceedings of the 27th International Colloquium on Automata, Languages and Programming, pages \n25 36, 2000. [4] Cristiano Calcagno, Eugenio Moggi, andWalidTaha. ML-like infer\u00adence for classi.ers. \nIn ESOP 04: Proceedings of the 13th European Symposium on Programming, pages 79 93, 2004. [5] Cristiano \nCalcagno,WalidTaha, Liwen Huang,andXavier Leroy. Im\u00adplementing multi-stage languages using asts, gensym, \nand re.ection. In GPCE 03: Proceedings of the 2nd International Conference on Generative Programming \nand Component Engineering, pages 57 76, NewYork,NY, USA, 2003. Springer-VerlagNewYork, Inc. [6] Tim Davis \nand Yifan Hu. The University of Florida Sparse Ma\u00adtrix Collection. http://www.cise.ufl.edu/research/sparse/ \nmatrices/Pajek/Tina DisCal.html. [7] ManuelF\u00a8 Re.ective ahndrich, Michael Carbin, and James R. Larus. \nprogram generation with patterns. In GPCE 06: Proceedings of the 5th International Conference on Generative \nProgramming and Component Engineering, pages 275 284, 2006. [8] Habanero Multicore Software Research \nProject. http://habanero.rice.edu. [9] Shan Shan Huang and Yannis Smaragdakis. Expressive and safe static \nre.ection with MorphJ. In PLDI 08: Proceedings of the 2008 ACM SIGPLAN Conference on Programming Language \nDesign and Implementation, pages 79 89, 2008. [10] Shan Shan Huang, David Zook, andYannis Smaragdakis. \nStatically safe program generation with safegen. In GPCE 04: Proceedings of the 3rdInternational Conference \non Generative Programming and Component Engineering, pages 309 326, 2005. [11] Yukiyoshi Kameyama, OlegKiselyov,and \nChung chieh Shan. Closing the stage: from staged code to typed closures. In PEPM 08: Proceed\u00adings of \nthe 2008 ACM SIGPLAN Symposium on Partial Evaluation and Semantics-based Program Manipulation, pages \n147 157, 2008. [12] Yukiyoshi Kameyama, OlegKiselyov,and Chung chieh Shan. Shifting the stage: Staging \nwith delimited control. In PEPM 09: Proceedings of the 2009 ACM SIGPLAN Workshop on Partial Evaluation \nand Program Manipulation, pages 111 120, 2009. [13] Sam Kamin, Lars Clausen, and Ava Jarvis. Jumbo: Run-time \ncode generation for Java and its applications. In CGO 03: Proceedings of the International Symposium \non Code Generation and Optimization, pages 48 56, 2003. [14] Ik-SoonKim,KwangkeunYi,and Cristiano Calcagno.Apolymorphic \nmodal type system for lisp-like multi-staged languages. In POPL 06: Conference record of the 33rd ACM \nSIGPLAN-SIGACT symposium on Principles of programming languages, pages 257 268, NewYork, NY, USA, 2006.ACM. \n[15] Gregory Neverov and Paul Roe. Metaphor: A Multi-stage, Object-Oriented Programming Language. In \nGPCE 04: Proceedings of the 3rd International Conference on Generative Programming and Component Engineering, \npages 168 185, 2004. [16]Yutaka Oiwa, Hidehiko Masuhara, and AkinoriYonezawa. DynJava: Type safe dynamic \ncode generation in Java. In PPL 01: Proceed\u00adings of the 3rdJSSSTWorkshop on Programming and Programming \nLanguages, March 2001. [17] OpenJDK Project. http://openjdk.java.net. [18] Rice PLT. Mint Multi-stage \nJava Compiler. Available at http://www.javamint.org. [19] Massimiliano Poletto, Wilson C. Hsieh, Dawson \nR. Engler, and M. Frans Kaashoek. Cand tcc: a language and compiler for dynamic code generation. ACMTransactions \nonProgramming Languages and Systems, 21(2):324 369, 1999. [20] U.P. Schultz and J.L. Lawall C.Consel. \nAutomatic Program Special\u00adization for Java. ACMTransactions on Programming Languages and Systems, 25(4):452 \n499, 2003. [21] Peter Sestoft. Runtime code generation with JVM and CLR.Available at http://www.dina.dk/sestoft/publications.html, \n2002. [22] Jun Shirako, Hironori Kasahara, andVivek Sarkar. Languageexten\u00adsions in support of compiler \nparallelization. In Languages and Com\u00adpilers for Parallel Computing: 20th International Workshop, LCPC \n2007, Urbana, IL, USA, October 11-13, 2007, Revised Selected Pa\u00adpers, pages 78 94, Berlin, Heidelberg, \n2008. Springer-Verlag. [23] Frederick Smith, Dan Grossman, J. Gregory Morrisett, Luke Hornof, andTrevor \nJim. Compiling for template-based run-time code genera\u00adtion. Journal of Functional Programming, 13(3):677 \n708, 2003. [24] SoyLatte Project. http://landonf.bikemonkey.org/static/ soylatte/. [25] Rok Strni.sa, \nPeter Sewell, and Matthew Parkinson. The Java mod\u00adule system: Core design and semantic de.nition. In \nOOPSLA 07: Proceedings of the 22nd AnnualACM SIGPLAN Conference on Ob\u00adject Oriented Programming Systems \nand Applications,pages 499 514, 2007. [26] Walid Taha. A gentle introduction to multi-stage programming. \nIn DSPG 03: Proceedings of the International Seminar on Domain-Speci.c Program Generation, 2003. [27] \nWalid Taha, Zine el-abidine Benaissa, and Tim Sheard. Multi-Stage Programming: Axiomatization andType \nSafety (Extended Ab\u00adstract). In ICALP 98: 25th International Colloquium on Automata, Languages, and Programming, \npages 918 929, 1998. [28]WalidTaha and Michael Florentin Nielsen. Environment classi.ers. In POPL 03: \nProceedings of the 30thACM SIGPLAN-SIGACT sym\u00adposium on Principles of programming languages, pages 26 \n37, New York,NY, USA, 2003.ACM. [29] Edwin Westbrook, Mathias Ricken, Jun Inoue, Yilong Yao, Tamer Abdelatif, \nandWalidTaha. Multi-stage Programming for Mainstream Languages. Technical Report TR09-02, Rice University, \n2009. [30] David Zook, Shan Shan Huang, andYannis Smaragdakis. Generating AspectJ Programs with Meta-AspectJ. \nIn GPCE 04: Proceedings of the 3rdInternational Conference on Generative Programming and Component Engineering, \npages 1 18, 2004.    \n\t\t\t", "proc_id": "1806596", "abstract": "<p>Multi-stage programming (MSP) provides a disciplined approach to run-time code generation. In the purely functional setting, it has been shown how MSP can be used to reduce the overhead of abstractions, allowing clean, maintainable code without paying performance penalties. Unfortunately, MSP is difficult to combine with imperative features, which are prevalent in mainstream languages. The central difficulty is scope extrusion, wherein free variables can inadvertently be moved outside the scopes of their binders. This paper proposes a new approach to combining MSP with imperative features that occupies a \"sweet spot\" in the design space in terms of how well useful MSP applications can be expressed and how easy it is for programmers to understand. The key insight is that escapes (or \"anti-quotes\") must be weakly separable from the rest of the code, i.e. the computational effects occurring inside an escape that are visible outside the escape are guaranteed to not contain code. To demonstrate the feasibility of this approach, we formalize a type system based on Lightweight Java which we prove sound, and we also provide an implementation, called Mint, to validate both the expressivity of the type system and the effect of staging on the performance of Java programs.</p>", "authors": [{"name": "Edwin Westbrook", "author_profile_id": "81100094090", "affiliation": "Rice University, Houston, TX, USA", "person_id": "P2184602", "email_address": "", "orcid_id": ""}, {"name": "Mathias Ricken", "author_profile_id": "81100301844", "affiliation": "Rice University, Houston, TX, USA", "person_id": "P2184603", "email_address": "", "orcid_id": ""}, {"name": "Jun Inoue", "author_profile_id": "81435595564", "affiliation": "Rice University, Houston, TX, USA", "person_id": "P2184604", "email_address": "", "orcid_id": ""}, {"name": "Yilong Yao", "author_profile_id": "81464650170", "affiliation": "Rice University, Houston, TX, USA", "person_id": "P2184605", "email_address": "", "orcid_id": ""}, {"name": "Tamer Abdelatif", "author_profile_id": "81464672282", "affiliation": "Ain Shams University, Cairo, Egypt", "person_id": "P2184606", "email_address": "", "orcid_id": ""}, {"name": "Walid Taha", "author_profile_id": "81100239752", "affiliation": "Rice University, Houston, TX, USA", "person_id": "P2184607", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1806596.1806642", "year": "2010", "article_id": "1806642", "conference": "PLDI", "title": "Mint: Java multi-stage programming using weak separability", "url": "http://dl.acm.org/citation.cfm?id=1806642"}