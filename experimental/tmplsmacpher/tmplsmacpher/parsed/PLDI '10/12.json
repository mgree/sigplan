{"article_publication_date": "06-05-2010", "fulltext": "\n Parameterized Veri.cation of Transactional Memories * Michael Emmi Rupak Majumdar Roman Manevich University \nof California, Los Angeles {mje,rupak,rumster}@cs.ucla.edu Abstract We describe an automatic veri.cation \nmethod to check whether transactional memories ensure strict serializability a key property assumed of \nthe transactional interface. Our main contribution is a technique for effectively verifying parameterized \nsystems. The technique merges ideas from parameterized hardware and proto\u00adcol veri.cation veri.cation \nby invisible invariants and symmetry reduction with ideas from software veri.cation template-based invariant \ngeneration and satis.ability checking for quanti.ed for\u00admul\u00e6 (modulo theories). The combination enables \nus to precisely model and analyze unbounded systems while taming state explosion. Our technique enables \nautomated proofs that two-phase locking (TPL), dynamic software transactional memory (DSTM), and trans\u00adactional \nlocking II (TL2) systems ensure strict serializability. The veri.cation is challenging since the systems \nare unbounded in sev\u00aderal dimensions: the number and length of concurrently executing transactions, and \nthe size of the shared memory they access, have no .nite limit. In contrast, state-of-the-art software \nmodel checking tools such as BLAST and TVLA are unable to validate either system, due to inherent expressiveness \nlimitations or state explosion. Categories and Subject Descriptors D.1.3 [Programming tech\u00adniques]: Concurrent \nProgramming; D.2.4 [Software engineering]: Software/Program Veri.cation General Terms Reliability, Veri.cation \nKeywords Transactional memory, Parameterized veri.cation 1. Introduction Transactional Memories Transactional \nmemory (TM) [19, 23] is a model of concurrent programming which allows programmers to write code with \ncoarse-grained atomic blocks whose interactions, and possible con.icts, are managed at run time by a \ntransaction man\u00adager. The transaction manager provides the illusion that application\u00adlevel transactions \n(atomic sequences of data reads/writes, followed by a commit) execute sequentially, at the expense of \ntracking, and potentially aborting or re-executing, con.icting transactions. By freeing the programmer \nfrom low-level book-keeping for concurrency, TM systems hold the promise of higher programmer * This \nresearch was sponsored in part by the NSF grants CCF-0546170 and CCF-0702743, and DARPA grant HR0011-09-1-0037. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n10 June 5 10 2010, Toronto, Ontario, Canada. Copyright c &#38;#169; 2010 ACM 978-1-4503-0019-3/10/06. \n. . $10.00 productivity without sacri.cing highly concurrent operations. Since TM systems form the core \nalgorithms on which the entire software stack depends, it is crucial that they are implemented correctly. \nThis is not trivial, as transactional memories employ sophisticated mechanisms to ensure ef.ciency, and \nin fact, several bugs have been uncovered in existing TM implementations [12]. Ensuring Strict Serializability \nThe above considerations indicate that the formal veri.cation of TM systems should be a rich and important \ntarget for software veri.cation research. Indeed, there have been several attempts to verify TM algorithms \n[6, 15]. What is missing, however, from the initial research is the automatic ver\u00adi.cation of transactional \nmemories against a correctness property such as strict serializability [27]. In principle, by encoding \nthe TM algorithm and the strict serializability speci.cation as transition systems, a state-exploration \ntechnique such as model checking can prove the property automatically. Unfortunately, TM algorithms are \nunbounded in several dimensions: in the number of interacting threads and shared memory locations, and \nin the number and length of transactions. This precludes simple applications of model check\u00aders, and \ntwo approaches have been taken in previous work. First, Cohen et al. [6, 7] and Tas\u00b8iran [33] manually \nspecify the re.nement relation between implementation and speci.cation in order to use an automated theorem \nprover. This annotation requires a thorough understanding of both the implementation and speci.cation, \nand like most manual veri.cation effort, carries a high cost. Second Guerraoui et al. [15, 16] rely on \na meta-theorem on the structure of the TM algorithm to prove a small model result that says that the \nTM algorithm is correct if and only if it is correct for two threads and two locations. The small instance \ncan be discharged using .nite\u00adstate model checking. While this goes a long way, the missing piece is \nthe (essentially manual) proof of the meta-theorem for each new TM implementation. Parameterized Veri.cation \nIn this paper, we describe a novel tech\u00adnique for the fully automatic, parameterized veri.cation of TM \nim\u00adplementations. Our starting point is the formalization of TM systems [15] and the deterministic speci.cation \nof strict serializability [16]. Given a TM implementation parameterized by the number of threads n and \nthe number of shared locations k, our goal is to automatically construct a family of simulation relations \nthat demonstrates, for all n> 0 and k> 0, that the TM implementation with n threads and k locations re.nes \nthe strict serializability speci.cation. Using standard techniques, this reduces to a uniform invariant \nveri.cation problem on the composition of the TM implementation and the strict serializability speci.cation. \nParameterized veri.cation of program invariants is undecidable in general [1], and our models do not \nfall into a known syntactic class with a .nite-model property, so we adopt a sound but potentially incomplete \ntechnique. The standard approach [25] of showing that a property . is a uniform invariant of a family \nM of parameterized systems (i.e., . is an invariant for every M(n, k) in the family) .nds a uniform inductive \ninvariant . of M that implies ., thus breaking veri.cation into two sub-problems: (A) to come up with \npotential invariants ., and (B) to check that . is a uniform inductive invariant of M and implies .. \nThese problems are hard, since parameterized systems typically involve quanti.ed transitions and invariants. \n We propose solutions to problems (A) and (B) that exploit the structure of transactional memory implementations \nin the following way. In transactional memory systems, con.icts (e.g., distinct threads reading from \nor writing to the same location) are a central notion. We notice that (i) the transition relation of \nthese systems is symmetric (i.e., thread identi.ers are not made explicit), and (ii) in the transition \nrelations of these systems, an executing thread, e.g., t, interacts only with either arbitrary threads \nu, or threads that are con.ict-adjacent (i.e., threads u that con.ict with t, but not threads u' that \ncon.ict with u but not t). The symmetry suggests that we can reason about arbitrary threads (and memory \nlocations), while con.ict adjacency suggests we can restrict reasoning to small neighborhoods surrounding \nparticular threads. We propose the following techniques that utilize these observations. A. Candidate \nInvariant Generation Inspired by the method of veri.cation by invisible invariants [2, 28], we generate \ncandidate invariants from the set of reachable states of bounded instantiations M(n0,k0) of the parameterized \nsystem M for small .xed values of n0 and k0. On its own this is not enough, since the resulting candidate \ninvariants generated directly from the reachable states are too large to be effectively discharged in \nthe following validation step, and as suggested by Arons et al. [2], are often too speci.c to be uniform \ninvariants the arbitrary Boolean structure of the formula prevents separating out parts of the candidate \nthat are uniform invariants from parts that are speci.c to the particular instance.  We .x these problems \nby combining the technique with a novel application of template-based invariant generation [8, 32]. In \nparticular, we .x a template language of formul\u00e6, and look for invariants of M(n0,k0) that are expressible \nas a conjunction of templates instantiated with system predicates. The use of conjunctive templates has \ntwo advantages. First, even if a conjunction of candidate invariants is not a uniform invariant, we can \ngenerate weaker candidates by discarding conjuncts which are not uniform invariants. (Indeed this is \nnecessary, since in our experiments, often fewer than half of the small candidate invariants could be \nvalidated.) Second, we can bias the search toward smaller invariants. Intuitively, the small neighborhood \nobservation of transactional memory systems suggests that interesting system behaviors are exercised \nwith few threads and memory locations, and that small template formul\u00e6 (e.g., involving few quanti.ed \nvariables) obtained by generalizing the reachable states of small instances should describe the interesting \nbehaviors. Symmetry suggests that the resulting invariants apply to any arbitrary threads and locations. \nB. Invariant Validation Checking that candidate invariants are uniform reduces to checking the validity \nof quanti.ed .rst order formul\u00e6. While this validity checking problem is undecidable in general, relying \non well-engineered automatic (sound, but incom\u00adplete) theorem provers [9, 13, 34] has worked for our \nexperiments. We have implemented the steps above in a veri.cation tool built on top of TVLA s abstract \nreachability engine [24] and the SPASS theorem prover [34], and we have used our implementation to automatically \nverify the correctness of several TM systems: two-phase locking, DSTM [20], and TL2 [10]. The end-to-end \nveri.cation for TL2, the most complicated algorithm, took about 100 minutes, .nding a quanti.ed invariant \nwith 416 conjuncts. The size of the invariant shows the utility of having an automatic veri.cation algorithm. \nIn contrast, our attempts to verify the same algorithms with state-of-the-art software model checkers \nsuch as BLAST and TVLA, as well as our implementation of the algorithm by Arons et al. [2], failed due \nto expressiveness limitations (e.g., BLAST cannot infer or reason with quanti.ed invariants) or due to \nscalability reasons (e.g., with manually provided instrumentation predicates, TVLA timed out on the examples). \nThe key contributions of this paper are summarized as: 1. We develop an algorithm capable of automatically \nverifying that common TM systems ensure strict serializability, and 2. We introduce an effective invariant \ngeneration technique by combining veri.cation by invisible invariants with template\u00adbased invariant generation, \neffectively extending the applicability of existing parameterized veri.cation techniques.  Although \nwe have applied our technique to transactional memory systems, our algorithmic contributions are general, \nand are likely to be useful in many other instances of parameterized software veri.cation. 2. Transactional \nMemory Veri.cation Transactions Let Thd be a set of threads and Loc a set of shared memory locations. \nFor each thread t . Thd, let At = {read(t, v), write(t, v): v . Loc}.{commit(t), abort(t)} be S the set \nof system actions performed by t, and A = {At : t . Thd}. A system trace is a .nite sequence w . A * \n. Let w . A * be a system trace. The projection w|= a1a2 ... . t A * t of w on a thread t . Thd is the \nsubsequence of w consisting only of actions performed by t. An action ai is .nishing in w|if t it is \na commit or abort, and is starting in w|if i =1, or ai-1 is t .nishing in w|. t A consecutive subsequence \nu = b1b2 ...bm of w|is a trans\u00ad t action of t if (i) b1 is starting in w|, (ii) if bi is .nishing in \nw| tt then i = m, and (iii) if bm is not .nishing in w|then bm is the t last action of w|. The transaction \nu is committing when bm is a t commit, aborting when bm is an abort, and un.nished otherwise. For w . \nA *, we de.ne the word com(w) . A * to be the subse\u00adquence of w consisting of every action of committing \ntransactions of w. If bi = read(t, v) (resp., bi = write(t, v)) for some i we say u reads (resp., writes) \nto location v, and call bi a read (resp., write) to v. If bi is a read to v and for some j<i, bj is a \nwrite to v, we call bi a local read; bi is otherwise a global read. By this de.nition of transaction, \nwe restrict our attention to the case where all reads and writes to locations v . Loc occur within some \ntransaction. Strict Serializability We consider a correctness criterion for trans\u00adactional systems called \nstrict serializability [15, 16, 27] (SS). Intu\u00ad itively, SS insists that each system trace may be reordered \n(while preserving a con.ict order, de.ned below) into an observationally equivalent sequence such that \ntransactions of distinct threads do not overlap and the order of non-overlapping transactions is preserved. \nThis notion is a useful abstraction for programmers of concurrent systems since each transaction can \nthen be thought to execute in isolation. We formalize SS following Guerraoui et al. [15]. Let w . A * \nand let u1 and u2 be two transactions in w, possibly of different threads. We say u1 precedes u2 in w, \nwritten u1<wu2, when the last action of u1 occurs before the .rst action of u2 in w. A trace in which \ntransactions are totally ordered by <w is called sequential. Actions a1 of a transaction u1 and a2 of \na transaction u2 with u2 = u1 are said to con.ict in a trace w when there exists a location v . Loc such \nthat either (i) a1 is a global read of v, u2 writes to v, and a2 is a commit action, or (ii) a1 and a2 \nare commit actions, and both u1 and u2 write to v. This notion of con.ict assumes the deferred update \nsemantics of transactions [23], where values written by a transaction u are not observed by other transactions \nuntil u commits. Two traces w1 = a1a2 ... and w2 are strictly equivalent when (i) w1|= w2|for every thread \nt . Thd,  tt (ii) ai occurs before aj in w2 whenever i<j and ai and aj con.ict in w1, and (iii) if u1<w1 \nu2 and u1 is not un.nished then u2<w2 u1. A trace w is said to be strictly serializable when there exists \na sequential trace w ' that is strictly equivalent to com(w). The set of strictly serializable traces \nis written LSS . Transactional Memory A multi-threaded program .n,k with n threads and k locations is \nan n-tuple (p1,...,pn) of programs, where for i =1,...,n the program pi : B* . Ati is a map from in.nite \nbinary trees to actions performed by thread ti. The representation of programs as in.nite binary trees, \nwhere intuitively the left branch denotes successful execution and the right branch denotes aborted execution \nof an operation, abstracts from speci.c S control .ow structures. Let .= {.n,k : n, k . N>0} be the set \nof all multi-threaded programs. A transactional memory (TM) M is a function from multi\u00adthreaded programs \nin p . . to sets M(p) . A * of traces. A TM M is said to ensure strict serializability if for each multi-threaded \nprogram p . ., and each trace w . M (p), w is strictly serializable, i.e., M(p) . LSS . The veri.cation \nproblem we study here is: Problem 1 (TM Veri.cation). Does a given transactional memory M ensure strict \nserializability? Typical software transactional memory systems ensure strict se\u00adrializability [15]. For \nexample, a two-phase locking (2PL) protocol ensures that its traces are serializable by prohibiting overlapping \ntransactions from accessing write-open (resp., read-or write-open) memory locations for reading (resp., \nwriting). More complex sys\u00adtems (i.e., those allowing more concurrent behavior) such as Dy\u00adnamic Software \nTransactional Memory [20] (DSTM), and Trans\u00ad actional Locking II [10] (TL2), use more intricate mechanisms \nto ensure strict serializability for which it is not obvious whether strict serializability is ensured. \n3. Parameterized Systems The TM veri.cation problem is an instance of parameterized veri.cation, as the \nproperty must be proved for programs with arbitrarily many threads and arbitrarily many locations. We \nnow describe our veri.cation approach on a logical representation for parameterized systems. Systems \nWe .x a set T = {Thd, Loc} of sorts of threads and locations, and a sorted set X = {t, t1,t2,...}.{v, \nv1,v2,...}of logical variables, where by convention t, t1,... have sort Thd and v, v1,... have sort Loc. \nWhen not clear from the context, we explicitly write, e.g., t : Thd or v : Loc. We assume the only logical \nvariables occurring in formul\u00e6 come from X. For a set of ranked and sorted predicates P ,a P -formula \n(resp., P -sentence) is a .rst-order logical formula (resp., sentence) over a language consisting of \nthe equality symbol = and the predicates in P . We additionally de.ne the set P ' = {p ' : p . P }of \nranked and sorted predicates p renamed to p '. For a P -formula . we write . ' for the P '-formula . \n' = .[P ' /P ], where each predicate p of . is renamed to p '. We omit the ranks and sorts of predicates \nfor readability. We write . . when . and . are syntactically equal formul\u00e6. For n, k . N>0, the parameterized \nsystem M(n, k) of size (n, k) is a tuple (U, P, A, T, g, .) consisting of: a sorted universe U of n \nthreads and k memory locations,  a .nite set P of ranked and sorted predicates with sorts in T,  a \n.nite set A of actions a(xx) where xx is a vector of sorted logical variables in X,  a P -sentence T \nspecifying the initial condition,  for each action a(xx) . A,a P -formula ga(xx) (called the guard of \na), and  for each action a(xx) . A,a P . P '-formula .a(xx) of the form .pI.P I .x' (xxx  y.p y) = \n.(xy), where . is a P -formula called the transition of a. We call M(n, k) an (n, k) instance of M, and \nwe use M to denote the family of instances {M(n, k): n, k . N>0}. A state s of M(n, k) is an interpretation \nof the predicates P over the universe U; we use S to denote the set of states. A binding b to logical \nvariables X is a map from X to U, and b(x) . U denotes the binding of x. We lift b to vectors of variables, \nwriting b(xx)= uxwhen |xx| = |ux| and b(xi)= ui for each 0 <i =|xx|. We denote the empty binding with \n\u00d8. For a P -formula .(xx), a state s, and a binding b to xx, we de.ne the satisfaction relation s, b \n|= . in the usual way [21]. When . is a sentence (i.e., contains no free variables), we write s |= . \ninstead of s, \u00d8|= .. We write . |= . when for all s and b such that s, b |= ., we have s, b |= .. We \nwrite (s, s '),b |= . when . is over the language of primed and unprimed predicates and each p . P is \ninterpreted in s, and each '' ' p . P = {p : p . P } is interpreted in s . For an action a(xx) and a \nbinding b of xx such that xu = b(xx), we say a(xu) is enabled in a state s when s, b |= ga, and when \n(s, s '),b |= ga . .a we call s ' an a(xu)-successor of s. We say M(n, k) is deterministic when for each \nstate s, binding b, and action a, there is at most one a(xu) successor of s, and M is deterministic if \nM(n, k) is deterministic for each n, k. Let AU = {a(b(xx)) : a(xx) . A, b is a binding of xx to U}. For \nw . A * U ,a w-computation s of M(n, k) is a S-sequence s0s1 ... such that 1. s0 is initial, i.e., s0 \n|=T, and 2. for each e =0, 1,..., the state s\u00a3+1 is an a(xu)-successor of s\u00a3, and w\u00a3 = a(xu).  The \nlanguage L(M(n, k)) of M(n, k) is the set of words w for which there exists a w-computation: L(M(n, k)) \n= {w : .s.s is a w computation of M(n, k)} S and we write L(M)= {L(M(n, k)) : n, k . N>0}. A state s \nis reachable in M(n, k) when s occurs in some computation. A sentence . is an invariant of M(n, k) if \ns |= . for every reachable state s, and . is inductive when T |= . and . . _ .u.gxa(xu) . .a(xu) |= . \n' . a(iu).AU A sentence . is a uniform invariant of M, written M |= ., if . is an invariant of M(n, k) \nfor all n, k . N>0; in this case we also say that M is .-safe. Example 1 (Speci.cation of Strict Serializability). \nA TM speci.\u00adcation for strict serializability is a parameterized system SS(n, k) such that L(SS)= LSS \n. Guerraoui et al. [16] show a deterministic TM speci.cation for strict serializability. We brie.y recall \nits key components; Appendix D contains the full description. The set of predicates P consists of the \nstatus predicates SS..nished(t), SS.started(t), SS.pending(t), SS.invalid(t), and SS.rs(t, v), SS.ws(t, \nv) read &#38; write sets SS.prs(t, v), SS.pws(t, v) prohibited-read &#38; -write sets SS.wp(t1,t2). weak-predecessor \nThe predicate SS.rs(t, v) (resp., SS.ws(t, v)) holds when thread t has read (resp., written) location \nv in its un.nished transac\u00adtion. When SS.prs(t, v) (resp., SS.pws(t, v)) holds, t will be\u00adcome SS.invalid \nby reading (resp., writing) location v. When SS.wp(t1,t2) holds, t1 must serialize after the un.nished \ntransac\u00adtion of t2 in order for both threads to commit their transactions. As syntactic sugar, we indicate \nstatus predicate valuations with atomic formul\u00e6, e.g., by writing SS.status(t)= .nished to mean  SS..nished(t) \n.\u00acSS.started(t) .\u00acSS.invalid(t) .\u00acSS.pending(t). The set ASS of actions is {read(t, v), write(t, v), \ncommit(t), abort(t)}. The initial condition is given by the sentence .t1,t2, v.SS.status(t1)= .nished \n.\u00acSS.wp(t1,t2) .\u00ac(SS.rs(t1,v) . SS.ws(t1,v) . SS.prs(tt,v) . SS.pws(t1,v)). The guards and actions are \nsomewhat complex (see Appendix D), though as an example, for the commit(t) action, the guard is \u00acSS.invalid(t) \n.\u00acSS.wp(t, t), and the update formula for the SS.wp predicate is .t1,t2.SS.wp ' (t1,t2) = t1 = t . t2 \n= t . (SS.wp(t1,t2) . SS.wp(t, t2) . (SS.wp(t1,t) ..v.SS.ws(t1,v) . SS.ws(t, v))). It is interesting \nto note that the operational speci.cation of strict se\u00adrializability is more complex than the TM implementations \nwe con\u00adsider in this work. Whereas the SS speci.cation does not correspond to an ef.cient implementation, \neach actual TM implementation con\u00adservatively disallows many serializable concurrent interactions in \norder to ef.ciently decide which transactions are allowed to commit. Thus we rely on the result of Guerraoui \net al. [16] to know that this complex operational speci.cation is correct. Example 2 (DSTM). We model \ndynamic software transactional memory [20] as a parameterized system with the status predi\u00adcates DSTM..nished(t), \nDSTM.validated(t), DSTM.invalid(t), DSTM.aborted(t), and DSTM.rs(t, v), DSTM.os(t, v). read &#38; own \nsets The set of actions is ASS .{validate(t)}. The initial condition is .t, v.DSTM.status(t)= .nished \n.\u00acDSTM.rs(t, v) .\u00acDSTM.os(t, v). The full speci.cation is given in Appendix B; as an example, the commit(t) \naction is guarded by DSTM.validated(t), and updates the DSTM.validated predicate by the formula .t1.DSTM.validated \n' (t1) = t1 = t . DSTM.validated(t1) . \u00ac.v.DSTM.rs(t1,v) . DSTM.os(t, v). Re.nement Let M1 = (U, P1,A1, \nT1,g1,.1) and M2 = (U, P2,A2, T2,g2,.2) be two parameterized systems. We say M1 is compatible with M2 \nif A2 . A1 and P1 nP2 = \u00d8, and we say M1 re.nes M2, written M1 . M2, if L(M1(n, k))|. L(M2(n, k)) A2 \nfor every n, k . N>0, where L|is the projection of a language L A to the alphabet A. If M1(n, k) is compatible \nwith M2(n, k), we de.ne the compo\u00adsition M1 \u00d7M2(n, k)= (U, P1 . P2,A1, T1 . T2, g, .) of M1 and M2 where \n( g1a(x ) if a . A1 \\ A2 ga(x )= g1a(x ) . g2a(x ) if a . A2 (V .1a(x ) . p.P2 p ' (x ) = p(x ) if a \n. A1 \\ A2.a(x )= .1a(x ) . .2a(x ) if a . A2 Lemma 1. Let M1 and M2 be parameterized systems such that \nM1 is compatible with M2 and M2 is deterministic. M1 . M2 iff ^ M1 \u00d7M2 |= .xx. g1a(x )=. g2a(x ). a(ix).A2 \nThe proof is a standard reduction from the search for a simulation relation to an invariant check [22]. \nSince M2 is deterministic, the condition is both necessary and suf.cient [11]. Thus we reduce the TM \nveri.cation problem to a parameterized model checking problem on the product of the implementation and \na deterministic strict serializability model. For example, to show L(DSTM) . LSS , we construct the deterministic \nspeci.cation SS, and check if ^ DSTM\u00d7SS |= .xx. gDSTM,a(x )=. gSS,a(x ). a(ix).ASS It turns out that \nthe guards for all actions of SS except for commit(t) are true, and the guard for the commit(t) action \nin SS and DSTM are respectively, \u00acSS.invalid(t) .\u00acSS.wp(t, t), and DSTM.validated(t). Thus the re.nement \nveri.cation question systematically reduces to DSTM\u00d7SS |= .t.DSTM.validated(t) =.\u00acSS.invalid(t) .\u00acSS.wp(t, \nt). (1) This invariant veri.cation problem still is a dif.cult one, since there is no bound on the parameters \n(i.e., the number of threads n and locations k), and the transition relations for SS and DSTM use universal \nor existential quanti.cation over threads and locations. 4. Parameterized Safety Veri.cation Here we \npresent a technique to check if an .rst-order sentence . is a uniform invariant of a parameterized system \nM. Our method is based on the deductive safety veri.cation rule [25]: I1 :T |= . W I2 : . ..xx.ga . .a \n|= . ' a(ix).A I3 : . |= . (INV) M |= . To show that . is a uniform invariant of M, we use an auxiliary \ninductive invariant . such that (I1) the initial condition T of M satis.es .,(I2) transitions of M preserve \n., and (I3) . is stronger than .. Conditions I1 and I2 imply . is a uniform inductive invariant of M. \nThe steps of deductive veri.cation are (i) generating the inductive invariant ., and (ii) validating \nthat . satis.es Conditions I1, I2, and I3. In our approach, we solve these issues as follows: (i) Invariant \nGeneration We generate candidate invariants by in\u00adstantiating formul\u00e6 from a .xed template language. \nWe then performing reachability analysis on instances M(n, k) of the parameterized family for small .xed \nvalues of n, k. Candidates which are not invariants of the small instances are discarded. Since M(n, \nk) is .nite, the reachability analysis terminates. The candidate inductive invariant is the conjunction, \nover all formul\u00e6 instantiated from the template, of the formul\u00e6 that are invariants of M(n, k) (i.e., \nthat contain the set of reachable states of M(n, k)). (ii) Invariant Validation Since our formul\u00e6 use \nuniversal and ex\u00adistential quanti.ers, checking each step of the deductive safety veri.cation rule INV \nis undecidable. Rather than develop our own quanti.er instantiation heuristics, we choose to rely on \nhighly engineered theorem provers to ef.ciently discharge each implication query.   Input : Parameterized \nsystem M(n, k); initial bounds n0,k0,j0; formula ., template enumeration TL. Result: Whether or not M \n|= .. 1 (n, k).(n0,k0); j . j0; Invariant . true; 2 repeat // 1a. Explore the bounded instance 3 rs . \nReach(M(n, k)); 4 if rs |= . then 5 return M is not .-safe ; 6 end // 1b. Discard non-invariants 7 candidates \n.{. : . generated by TL[j] and rs |= .}; // 2. Candidate invariant weakening 8 recheck . true; 9 while \ncandidates = \u00d8 and recheck do 10 recheck . false; 11 foreach . . candidates do V 12 let .a(ix) = Invariant \n. candidates 13 ..xx.(ga . .a); 14 if exists a(x ) .A s.t. not Check( .a(ix) |= . ' ) 15 or not Check( \nT |= . ) then 16 candidates . candidates \\{.}; 17 recheck . true; 18 end 19 end 20 end // 3. Check invariant \nstrength V 21 Invariant . Invariant . candidates; 22 if Check( Invariant |= .) then 23 return M is .-safe \n24 end // Retry with bigger bounds 25 increment n, k, j; 26 end Algorithm 1: Parameterized safety veri.cation. \nOur parameterized veri.cation technique is summarized by Algorithm 1. It takes as input a parameterized \nsystem M and a property .. The parameters n0 and k0 range over the number of threads and locations in \n.nite instances, and the parameter j0 is used to as an initial template enumeration index. The algorithm \nhas three phases. The .rst phase (lines 3 7) generates a set of candidate invariants. The set of reachable \nstates rs of a .nite instance M(n, k) are computed (line 3); if some reachable state violates . (lines \n4 6), . cannot be a uniform invariant of M, and a safety violation is reported. Otherwise, a set of candidates \nis generated by choosing each formula in the current invariant template TL[j] that contains the set of \nreachable states (line 7). The second candidate invariant weakening phase (on lines 8 20) discards candidates \nthat can not be proved inductive, either because they are not preserved by some transition (line 14), \nor because they are not initially valid (line 15). The conjunction of candidates remaining at the end \nof the loop of lines 8 20 is a uniform inductive invariant. In the third phase the inductive invariant \nstrength is checked. If the current invariant implies ., then by the INV rule, . is a uniform invariant. \nOtherwise, we increase the indexes n, k, and j, and repeat the top-level loop of line 2. It is easy to \nsee that Algorithm 1 is sound. However, since it is impossible to know the size (i.e., the number of \nquanti.ers and literals) of the required candidate invariants, there is no bound on the template enumeration \nindex j, and thus there is no telling when the procedure may terminate. Supposing that the required invariants \nare expressible in .rst-order logic, and the Check routine is complete (though in actuality it is not), \nsome template is guaranteed to capture the required invariant, and termination would be eventually guaranteed. \n5. Template-Based Candidate Generation We generate candidate invariants following the idea of veri.cation \nby invisible invariants [2, 28]. We compute the set of reachable states of M(n, k) for .xed, .nite thread-and \nlocation-count values of n and k; this is possible since the state space of M(n, k) is .nite. A candidate \nuniform invariant for M is proposed by generalizing invariants for M(n, k). We depart from the technique \nof Arons et al. [2] to generate candidate invariants for two reasons. First, the generated invariant \ncan be too speci.c. For example, let R be the set of reachable states of M(n, k). The synthesized invariant \nof Arons et al. [2] has the W form .xx. s.R .s(x ) where each .s is a minterm corresponding to a complete \ninterpretation of the predicates P on the variables x (i.e., for every predicate p . P and sublist xy \nof variables in x with the proper sorts, either p(xy) or \u00acp(xy) appears in .s). Symmetries between distinct \nminterms for example, minterms which are identical up to variable renaming are not exploited, leading \nto much redundancy and overly-speci.c invariants. Checking the validity of such a large invariant is \nexpensive. Second, the invariant is often too speci.c to n and k to be a uniform invariant as a whole. \nHowever, if a (monolithic) candidate invariant derived from M(n, k) is not a uniform invariant, there \nis no clear way to proceed to generate weaker candidate invariants. Example 3. Let M = DSTM\u00d7SS. Although \nthe sentence .t, v.(SS.pending(t) . SS.wp(t, t)) (2) . (DSTM.rs(t, v) .\u00acSS.pending(t)) .\u00acDSTM.aborted(t) \nis an invariant of M(2, 1), it is not an invariant of M(3, 2), and hence not a uniform invariant. However, \nconsider the invariants .t.SS.pending(t) . DSTM.aborted(t) . SS.wp(t, t), .t, v.SS.pending(t) . DSTM.aborted(t) \n(3) .\u00acDSTM.rs(t, v) whose conjunction is logically equivalent to Equation 2. Both are invariants of M(2, \n1), though only the second is uniform. Here, even though the conjunction it not uniform, we can extract \na weaker candidate (i.e., the second conjunct) that is. Example 3 indicates that we should look for conjunctive \ncan\u00addidate invariants. Algorithm 1 (lines 8-20) shows how conjunctive invariants can be individually \nchecked for inductiveness and weak\u00adened by discarding conjuncts that are not inductive. We restrict the \nshape of the extracted invariants by imposing template-based invariant generation [8, 32] while generating \ncandidate invariants. Let F be a .nite set of symbolic predicate variables.A template t is a F-sentence \nin prenex form, and a template schema T is a .nite set of templates. Let . be a set of atomic formulas \nwhose free variables are a subset of the quanti.ed variables of t . A sentence . is generated by template \nt when there exists a binding f from the predicate variables F to atomic formulas in . such that the \nformula t[f(F)/F] obtained by replacing each f . F with f(f) is syntactically equal to .. We say . is \ngenerated by template schema T when . is generated by some t . T .  To generate candidate invariants, \nwe .x a template schema T and .x the set of atomic formul\u00e6 .= {p(\u00afx), \u00acp(\u00afx) | p . P }.{true}. Then, \nfor each . generated from T , we check if . is an invariant of M(n, k). If so, it is added as a conjunct \nof the candidate invariant; otherwise it is discarded. This is shown in line 7 of Algorithm 1. In practice \nwe restrict the template schema to small templates, since enumerating all formulas generated by a template \nis expensive. We found that templates of the form .t, v.f1 . f2 . f3 suf.ced to generate suf.ciently \nstrong uniform invariants. If a necessary uniform invariant cannot be generated by a tem\u00adplate schema, \nthen the veri.cation will fail. In this case, Algorithm 1 achieves relative completeness by incrementing \nthe template enu\u00admeration index j; for every .rst-order formula . there is some j such that . is generated \nby TL[j] (lines 7 and 25). In practice, increment\u00ad ing j has not been necessary. Example 4. Using the \ntemplate schema .t, v.f1 .f2 . f3 and the set of atomic formulas {p(\u00afv), \u00acp(\u00afv) | p . PSS . PDSTM}.{true}, \nwe generated 525 candidate invariants from the (2, 1)-instance of DSTM\u00d7SS; 341 of these proved to be \nuniform. The found invariants include: .t, v.SS.rs(t, v) .\u00acDSTM.aborted(t) . DSTM.rs(t, v) .t, v.SS.ws(t, \nv) .\u00acDSTM.aborted(t) . DSTM.os(t, v) .t.DSTM.validated(t) .\u00acSS.wp(t, t) .t.DSTM.validated(t) .\u00acSS.invalid(t) \n.t.DSTM.validated(t) .\u00acSS.pending(t). Notice that the re.nement veri.cation obligation of Equation 1 \nis implied by the conjunction of these invariants. 6. Implementation and Experimental Evaluation We have \nimplemented our technique by extending the TVLA framework [24] to compute the reachable state space of \nbounded instances of the input systems and extract quanti.ed candidate invariants. The candidate invariants \nare subsequently checked using the SPASS automated theorem prover [34]. Our models of the two-phase locking \n(TPL), dynamic software transactional memory (DSTM), and transactional locking II (TL2) implementations, \nalong with the deterministic strict serializability speci.cation, are derived from the parameterized \nautomaton models provided by Guerraoui et al. [15, 16]. The models are listed in full in Appendices A \nD. Since the SS speci.cation remains .xed, we use our technique to initially generate a uniform inductive \ninvariant of SS once-and-for\u00adall, before considering the implementation and speci.cation product systems. \nWe then use this invariant to strengthen the invariants of each product system. Experimental setting \nFor our experimental evaluation we use the .xed template schema .x, y.f1 . f2 . f3 to generate ev\u00adery \npossible three-term formula over two universally quanti.ed variables modulo typing concerns, and obvious \nsyntactic sym\u00admetries, e.g., .x.p(x) . q(x) . r(x) is logically equivalent to .x.q(x) . p(x) . r(x) and \n.x.p(x) .\u00acr(x) .\u00acq(x). Following Algorithm 1, we perform an initial .ltering to discard the candidate \ninvariants . which are not invariants of a small system instance M(n0,k0) by .nding a reachable state \nof M(n0,k0) which does not satisfy .. To further reduce the number of candidates, we discard invariants \nthat are redundant with i.e., implied by the conjunction of the known system constraints and previously\u00adextracted \ncandidates. For example, constraints on the DSTM system dictate that a single thread cannot be both DSTM.validated \nand DSTM.aborted, so the invariant .t, v. DSTM.validated(t) .\u00acDSTM.rs(t, v) .\u00acDSTM.aborted(t) is redundant \nw.r.t. system constraints, while the uniform invariant of Equation 3 is redundant w.r.t. the stronger \ninvariant .t, v.DSTM.aborted(t) .\u00acDSTM.rs(t, v). Due to scalability limitations of our inef.cient implementation, \nwe did not check redundancy w.r.t. all previously generated candi\u00addates. Instead, we split the generated \ncandidates into 40 partitions, and only redundancy w.r.t. candidates of the same partition (and sys\u00adtem \nconstraints) is considered. Note that full redundancy elimination may sometimes drop potential uniform \ninvariants (and consequently fail to verify a system), since a uniform invariant may be considered redundant \nw.r.t. to a simpler non-uniform candidate. For example, suppose the predicates x =0 and x = 0 are both \ninvariants of a .nite instance, but only x = 0 is a uniform invariant. By eliminating x = 0 because it \nis redundant w.r.t. x =0, we may not .nd a strong enough uniform invariant. The second phase of our implementation \nchecks inductiveness of the remaining candidate invariants. In each weakening iteration we attempt to \nvalidate each candidate via theorem prover with a 10 second time limit. When a candidate cannot be validated \neither due to non-uniformity, or prover incompleteness/timeout it is discarded. At the end of a weakening \niteration where no candidates were discarded, we conclude that the conjunction of candidate invariants \nis inductive. When a weakening iteration .nishes after discarding some candidate, we are obliged to start \nanother iteration to ensure that the discarding of one candidate does not invalidate another. Table 1 \nlists our experimental measurements. For each small in\u00ad stance of each system, we record the number of \nreachable states and the time spent exploring them in the second column group ( bounded exploration ). \nThe third column group ( template instantiations ) lists (1) the total number of formul\u00e6 generated from \ntemplates (column total ), (2) the number of candidate formul\u00e6 from (1) which were invariants of the \ngiven instance (column invs. ), (3) the number of non-redundant candidates from (2) (column non-red. \n), and (4) the number of non-redundant candidates from (3) that were .nally validated as uniform invariants \nin the subsequent validation and invariant weakening steps (column val. ). The fourth column group (column \niter ) lists the number of invariant weakening iter\u00adations, and .nally the last column group ( validation \ntime ) lists the average per-candidate validation time, and the total runtime, including validating (or \nrefuting) each candidate for each weakening iteration. Discussion In all cases except TPL, our crude \nprototype imple\u00admentation only scales to systems with at most two threads and two memory locations. For \nlarger instances our tool runs for several min\u00adutes before exhausting a 2GB memory limit. Based on the \nsystem instances we did explore, varying the number of memory locations has little effect on the system \nbehavior, though varying the number of threads has a noticeable effect: only about half of the invariants \nof one-thread DSTM and TL2 systems are invariants of the two-thread systems. It would be interesting \nto measure how invariants vary with more than two threads using a more scalable tool. In the case of \nthe simplistic TPL system, it is clear that all possible system behaviors between two threads are expressed \nwith only two threads, since every (2, 1)-invariant is uniform. Although not strictly required, .ltering \ncandidate formul\u00e6 that are either not invariants on the bounded instance, or are redundant with other \ncandidates, can greatly reduce the runtime of the subse\u00adquent invariant validation step. For example, \nin the (2, 1) instance of DSTM \u00d7 SS, only 525 of 14, 724 candidates survived the .ltering.  system (n, \nk) bounded states exploration time total template insinvs. tantiations non-red. val. iter. validation \ntime per-cand. total SS (1, 1)(1, 2)(2, 1)(2, 2) 4 16 74 7296 2.5s 3.7s 5.7s 3m28s 3,520 2,542 2,542 \n1,313 1,237 780 780 432 402 346 346 377 377 6 6 3 3 0.38s 0.38s 0.65s 0.42s 35m45s 35m26s 19m0s 12m29s \nTPL \u00d7 SS (1, 1)(1, 2)(2, 1)(2, 2)(2, 3)(3, 2)(3, 3) 4 16 8 64 512 196 2,744 10.5s 8.0s 8.5s 14.0s 43.7s \n20.5s 3m26s 4,924 3,344 3,330 434 430 430 430 2 1 0.38s 0.41s 0.38s 0.39s 0.46s 0.44s 0.41s 7m28s 8m38s \n4m5s 4m15s 5m13s 4m56s 4m25s DSTM \u00d7 SS (1, 1)(1, 2)(2, 1)(2, 2) 8 32 184 15.6K 5.4s 9.1s 9.7s 5m6s 14,724 \n9,806 9,806 4,512 4,308 1,230 1,230 525 453 298 298 341 346 6 6 3 3 0.92s 0.74s 1.71s 0.97s 71m10s 55m15s \n38m10s 21m56s TL2 \u00d7 SS (1, 1)(1, 2)(2, 1) 6 36 344 100K 3.6s 5.4s 13.4s 55m21s 14,706 10,068 10,068 4,695 \n * 1178 1,178 556   416  2  5.06s   100m4s (2, 2) Table 1. Transactional memory veri.cation \nexperiments. The parameters n and k indicate the number of threads and memory locations per instance. \nThe per-candidate theorem prover timeout was set to 30s. The candidate invariants could not be proved \ninductive. *Invariant extraction did not scale here. Assuming the same 1.71s average time1 per validation \nstep, the total validation time without .ltering the candidates would have been at least seven hours, \nrather than only 38 minutes. Similarly, the size of the initial bounded instance can seriously affect \nthe validation time by reducing the number of candidates. For instance, 5, 294 (705 non-redundant) quanti.ed \ninvariants of the (1, 1) DSTM \u00d7 SS instance are not invariants of the (2, 1) instance, thus cannot be \nuniform invariants, and can be .ltered from the concrete instance in a few seconds. Note that the reachability \ncomputation (i.e., bounded exploration) can be soundly terminated at any point, effectively shifting \nthe validation effort toward the theorem prover back-end. It should also be noted that this redundant \ncandidate elimination scheme can result in somewhat unpredictable behavior. In the case of TL2, discarding \ncandidate invariants extracted from the (1, 1)and (1, 2) instances that are redundant with previously \nextracted candidates failed to produce an uniform inductive candidate subset. The candidates extracted \nfrom the (2, 1) instance were suf.cient, though the our extraction tool was unable to process the large \nnumber of reachable states in the (2, 2) instance. Although we did not implement more intricate redundant \ncandi\u00addate elimination schemes, there are several possibilities. One idea is to temporarily discard each \nredundant candidate ., while record\u00ading the candidates {.i}i rendering . redundant. When some .i is subsequently \ninvalidated, . can be reconsidered since it is no longer redundant. This scheme would very likely reduce \nthe overall runtime of veri.cation for TL2 \u00d7 SS. We leave all such strategies for future work. In only \ntwo cases did our very simple template schema not produce strong enough candidate invariants. An important \ninvariant of SS states that weak-predecessors of a thread t that are not SS.invalid or SS.pending have \na read-write con.ict with t, e.g., .t1,t2.SS.wp(t1,t2) . SS..nished(t2) ..v.SS.rs(t2,v) . SS.ws(t1,v). \n1 Though in actuality the time spent validating each candidate increases as the number of candidates \nincreases. Second, a necessary invariant of TL2\u00d7SS states that a thread which is both TL2..nished and \nSS.invalid or SS.pending must have some memory location in both its read set and modi.ed set. Although \nthese invariants can be captured by the template schema .x, y.f1 . f2 ..z.f3 . f4, due to scalability \nlimitations of our crude prototype implementation, we prefer instead to augment the systems with the \nadditional predicates SS.rwc(t1,t2) and TL2.rmc(t) to encode read-write con.icts in SS, and read-modi.ed \ncon.icts in TL2. These additional predicates, along with the template schema .xed above, allow us to \nexpress all the required invariants for our proofs. Finally, probably due to the greater complexity of \nthe TL2 system, we found it necessary to extend the 10s theorem prover timeout to 30s in the candidate \nvalidation step. Bug .nding In addition to the veri.cation of these models, our technique was able to \n.nd (from a (2, 1)-size instance in 6.4 seconds) the known bug [15] in a TL2 implementation which swaps \nthe order of the lock and validate actions: the trace write(t1,v) write(t2,v) read(t2,v) read(t1,v) validate(t1) \nvalidate(t2) lock(t2,v) commit(t2) lock(t1,v) commit(t1) is allowed by this alternate implementation, \nthough is not strictly serializable. Limitations Although here we restrict the invariant language to \n.rst-order logic, we have found that expressing inductive invariants of certain TMs requires transitive \nclosure. The TL2 model we ve veri.ed executes the validate and commit actions atomically, though an implementation \nperforming these actions separately seems to require the invariant there are no SS.wp-cycles involving \nonly TL2.validated transactions. The systems we verify are modeled using high-level abstract data types, \ne.g., the read-and write-sets are modeled as mathemat\u00adical sets rather than a low-level heap encoding \nof sets. Although real-world software TM implementations are indeed programmed using linked data structures, \nestablishing the link between ADT speci.cations and ADT implementations is an orthogonal problem and \nis better understood [29, 36].  7. Related Work Our starting point is the formalization of transactional \nmemory implementations, and the strict serializability speci.cation, as .nite\u00adstate automata by Guerraoui \net al. [15]. Even with these models, automatic parameterized veri.cation for transactional memory systems \nremained beyond the ability of existing veri.cation tools. The problem of verifying transactional memories \nhas been stud\u00adied before [6, 7, 15 17, 33]. Cohen et al. [6] veri.ed re.nement mappings between small \nTM instances and a strict serializability speci.cation by explicit state model checking; they subsequently \nextended their approach to parameterized TM veri.cation via an interactive proof assistant [7]. In both \ncases the proofs required manually prescribing the re.nement mappings a task which re\u00adquires familiarity \nwith the implementation, the speci.cation, and the relationship between the two. Tas\u00b8iran [33] took a \nsimilar approach, using existing software veri.cation tools to verify TM implementa\u00adtions which were \nmanually annotated with pre-and post-conditions corresponding to an insightful proof decomposition. In \ncontrast, our use of intermediate invariants is invisible to the user, and the resulting proof is automatic. \nThe approach of Guerraoui et al. [15, 16, 17] is based on a small model theorem reducing parameterized \nTM veri.cation to veri.ca\u00adtion on an instance with two threads and two memory locations; their theorem \napplies only to systems satisfying certain conditions, some of which are easy to check syntactically \n(e.g., thread symmetry), and others which would be dif.cult to check for an arbitrary imple\u00admentation, \nand seem to require human insight. In contrast, our proof technique is sound for any transactional memory \nimplementation regardless of the conditions of Guerraoui et al. [15], except for symmetry but like any \nheuristic, may fail to verify a given imple\u00admentation. Our experimental results demonstrate that our \napproach does succeed for common implementations. Our experiments with existing software veri.cation \ntools fell short. Software model checkers based on predicate abstraction and counterexample-guided abstraction \nre.nement, such as SLAM [3] and BLAST [18], typically implement a very coarse memory model (e.g., based \non an imprecise alias analysis) which is not suf.ciently detailed to reason about the interactions between \narbitrarily many threads and memory locations. In our experiments, the BLAST model checker was unable \nto verify even .nite instances of the implementa\u00adtions because of a coarse modelling of arrays. In addition, \nthe default counterexample re.nement procedure in BLAST, which looks indi\u00advidually at abstract counterexamples, \ncould not infer the universally quanti.ed invariants that were required in the proof, instead entering \nan in.nite re.nement loop. Tools based on three-valued shape analysis [31] or separation logic [30], \nsuch as TVLA [24] and SPACEINVADER [35], can the\u00ad oretically prove properties of programs manipulating \nunbounded heaps. In practice, however, their most successful applications have been in proving complex \ndata structure invariants in small code, or simple data structure invariants in large code. Our attempts \nto verify transactional memory using TVLA failed for two reasons: .rst, it required intensive manual \ninteractions to identify the instrumenta\u00adtion predicates necessary to rule out abstract counterexamples, \nand second, the tool exhausted our time and space limitations before .nishing, even with a small number \nof instrumentation predicates. We use and extend the idea of veri.cation by invisible invari\u00adants [2, \n28] from the parameterized hardware and protocol veri.ca\u00ad tion setting. Instead of generating invariants \nwith arbitrary Boolean structure, we combine the idea with template-based invariant gener\u00adation to restrict \ninvariants to the simple form of template formul\u00e6 conjunctions. This ensures that even when the candidate \nformula as a whole is not an invariant, useful parts of the formula can be salvaged. In contrast, if \nthe inductiveness check fails for a arbitrarily structured Boolean formula, it is not clear how invalid \nparts of it can be discarded. Our original attempt to synthesize inductive invariants from concrete executions \nproduced formulas containing hundreds, or thousands, of cubes which we were not able to reduce. Various \noptimization techniques, e.g., using BDDs, did not help. With tem\u00adplates we manage the size and complexity \nof potential invariants, and can bias the search for candidate invariants using observations made for \nthe class of systems we consider. While template-based invariant generation has been studied before, \napplications so far have been limited to arithmetic constraints [5, 8, 32]. In contrast, our tem\u00ad plates \nrange over quanti.ed predicates relating the data structures of concurrently executing threads. The initial \n.ltering of candidate invariants on small system instances can be seen as a variation of dynamic detection \nof likely invariants [14], though there the initial candidate set is restricted to much simpler formul\u00e6 \n(e.g., whether or not a pointer-value can be null) or user-speci.ed candidates. Our idea of exploiting \nthread and memory location symmetry is inspired by techniques from parameterized safety proofs in hard\u00adware \nveri.cation [26]. However, while the proof obligations in that hardware setting after symmetry reduction \nwere essentially Boolean problems, we have generalized the techniques to incorporate expres\u00adsive .rst-order \ntheories. Besides the increase in expressive power, this enables us to reason about transition relations \nand inductive invariants including both universal and existential quanti.ers. In contrast, the proof \narguments of McMillan [26] require manually speci.cation of witnesses for existential formul\u00e6 explicitly \nby in\u00adcluding them as auxiliary state in the models. Berdine et al. [4] extend three-valued shape analysis \nto reduce reasoning about parameterized concurrent programs to the behavior of individual threads. However, \ntheir technique does not handle existentially quanti.ed properties and requires manually speci.ed instrumentation \npredicates. 8. Conclusion Although we have demonstrated the automatic veri.cation of trans\u00adactional memory \nsystems with respect to strict serializability, there are several additional complications to consider \nin real-world im\u00adplementations. Some systems allow nested transactions, or non\u00adtransactional shared memory \naccesses, and may be running on top of weak memory models. Also, the actual implementations use heap-based \ndata structures; analysis generally requires showing a correspondence between the abstract data types \n(e.g., read-and write-sets) and the underlying implementations. Additional safety (e.g., opacity) and \nliveness properties (e.g., obstruction freedom) are also expected to hold, and should be veri.ed. Another \ninteresting direction is to apply our template-based algorithm to other systems, such as cache coherence \nprotocols. Acknowledgments We would like to thank the anonymous referees, and Amit Goel, Ranjit Jhala, \nand Todd Millstein for their helpful comments. References [1] K. R. Apt and D. Kozen. Limits for automatic \nveri.cation of .nite-state concurrent systems. Inf. Process. Lett., 22(6):307 309, 1986. [2] T. Arons, \nA. Pnueli, S. Ruah, J. Xu, and L. D. Zuck. Parameterized veri.cation with automatically computed inductive \nassertions. In CAV, pages 221 234, 2001. [3] T. Ball and S. K. Rajamani. The SLAM project: debugging \nsystem software via static analysis. In POPL, pages 1 3, 2002.  [4] J. Berdine, T. Lev-Ami, R. Manevich, \nG. Ramalingam, and S. Sagiv. Thread quanti.cation for concurrent shape analysis. In CAV, pages 399 413, \n2008. [5] D. Beyer, T. A. Henzinger, R. Majumdar, and A. Rybalchenko. Invariant synthesis for combined \ntheories. In VMCAI, pages 378 394, 2007. [6] A. Cohen, J. W. O Leary, A. Pnueli, M. R. Tuttle, and L. \nD. Zuck. Verifying correctness of transactional memories. In FMCAD, pages 37 44, 2007. [7] A. Cohen, \nA. Pnueli, and L. D. Zuck. Mechanical veri.cation of transactional memories with non-transactional memory \naccesses. In CAV, pages 121 134, 2008. [8] M. Col\u00b4 Linear invariant on, S. Sankaranarayanan, and H. Sipma. \ngeneration using non-linear constraint solving. In CAV, pages 420 432, 2003. [9] L. M. de Moura and N. \nBj\u00f8rner. Z3: An ef.cient SMT solver. In TACAS, pages 337 340, 2008. [10] D. Dice, O. Shalev, and N. Shavit. \nTransactional locking II. In DISC, pages 194 208, 2006. [11] D. L. Dill, A. J. Hu, and H. Wong-Toi. Checking \nfor language inclusion using simulation preorders. In CAV, pages 255 265, 1991. [12] A. Dragojevi\u00b4c, \nR. Guerraoui, and M. Kapalka. Dividing transactional memories by zero. In TRANSACT, 2008. [13] B. Dutertre \nand L. de Moura. The YICES SMT solver. http: //yices.csl.sri.com. [14] M. D. Ernst, J. H. Perkins, P. \nJ. Guo, S. McCamant, C. Pacheco, M. S. Tschantz, and C. Xiao. The Daikon system for dynamic detection \nof likely invariants. Sci. Comput. Program., 69(1-3):35 45, 2007. [15] R. Guerraoui, T. A. Henzinger, \nB. Jobstmann, and V. Singh. Model checking transactional memories. In PLDI, pages 372 382, 2008. [16] \nR. Guerraoui, T. A. Henzinger, and V. Singh. Completeness and non\u00addeterminism in model checking transactional \nmemories. In CONCUR, pages 21 35, 2008. [17] R. Guerraoui, T. A. Henzinger, and V. Singh. Software transactional \nmemory on relaxed memory models. In CAV, pages 321 336, 2009. [18] T. A. Henzinger, R. Jhala, R. Majumdar, \nand G. Sutre. Lazy abstraction. In POPL, pages 58 70, 2002. [19] M. Herlihy and J. E. B. Moss. Transactional \nmemory: Architectural support for lock-free data structures. In ISCA, pages 289 300, 1993. [20] M. Herlihy, \nV. Luchangco, M. Moir, and W. N. S. III. Software transactional memory for dynamic-sized data structures. \nIn PODC, pages 92 101, 2003. [21] S. Kleene. Introduction to Metamathematics. North Holland, 1980. [22] \nL. Lamport. Specifying concurrent program modules. ACM Trans. Program. Lang. Syst., 5(2):190 222, 1983. \n[23] J. R. Larus and R. Rajwar. Transactional Memory. Morgan &#38; Claypool Publishers, 2006. [24] T. \nLev-Ami and S. Sagiv. TVLA: A system for implementing static analyses. In SAS, pages 280 301, 2000. [25] \nZ. Manna and A. Pnueli. The Temporal Logic of Reactive and Concurrent Systems: Speci.cation. Springer-Verlag, \n1992. [26] K. L. McMillan. Veri.cation of in.nite state systems by compositional model checking. In CHARME, \npages 219 234, 1999. [27] C. H. Papadimitriou. The serializability of concurrent database updates. J. \nACM, 26(4):631 653, 1979. [28] A. Pnueli, S. Ruah, and L. D. Zuck. Automatic deductive veri.cation with \ninvisible invariants. In TACAS, pages 82 97, 2001. [29] J. Reineke. Shape analysis of sets. Master s \nthesis, Universit\u00a8at des Saarlandes, Germany, June 2005. [30] J. C. Reynolds. Separation logic: A logic \nfor shared mutable data structures. In LICS, pages 55 74, 2002. [31] S. Sagiv, T. W. Reps, and R. Wilhelm. \nParametric shape analysis via 3-valued logic. ACM Trans. Program. Lang. Syst., 24(3):217 298, 2002. [32] \nS. Srivastava and S. Gulwani. Program veri.cation using templates over predicate abstraction. In PLDI, \npages 223 234, 2009. [33] S. Tas\u00b8iran. A compositional method for verifying software transac\u00adtional memory \nimplementations. Technical Report MSR-TR-2008-56, Microsoft Research, April 2008. [34] C. Weidenbach, \nD. Dimova, A. Fietzke, R. Kumar, M. Suda, and P. Wischnewski. SPASS version 3.5. In CADE, pages 140 145, \n2009. [35] H. Yang, O. Lee, J. Berdine, C. Calcagno, B. Cook, D. Distefano, and P. W. O Hearn. Scalable \nshape analysis for systems code. In CAV, pages 385 398, 2008. [36] K. Zee, V. Kuncak, and M. C. Rinard. \nFull functional veri.cation of linked data structures. In PLDI, pages 349 361, 2008. A. Model of Two-Phase \nLocking The two-phase locking system is a transaction manager which ensures sequential behavior by associating \ntwo separate locks to each memory location. Read-access is granted to any number of threads so long as \nno thread has write-access, while any thread with write-access to a location is guaranteed exclusive \naccess. Our TPL model uses the predicates TPL.rs(t, v) and TPL.ws(t, v) to mean that t has read or write \naccess to v. The initial condition .t, v.\u00acTPL.rs(t, v) .\u00acTPL.ws(t, v) asserts that all access sets are \nuninhabited. The system is further constrained by an invariant stating that only one thread is allowed \nwrite access at any given time: .t1,t2, v.TPL.ws(t1,v) . TPL.ws(t2,v) . t1 = t2. Although in principle \nthis constraint can be encoded in the transition relation, we state it here to avoid redundancy. This \ninvariant should be considered implicitly, without the need for validation, since it corresponds to the \nimplementation strategy of associating a write\u00adlock per location. Read The read(t, v) action for TPL \nis guarded by .t1.TPL.ws(t1,v) . t1 = t, and the transition formula is given by the conjunction of .t1,v1.TPL.rs \n' (t1,v1) = TPL.rs(t1,v1) .\u00acTPL.ws(t, v) . t1 = t . v1 = v .t1,v1.TPL.ws ' (t1,v1) = TPL.ws(t1,v1). In \nother words, t can read v when no other thread has write-access, in which case v is added to the read-set \nof t if v is not already in the write set of t. From this point on we will omit writing identity predicate \nupdate formul\u00e6 of the form .xx.p ' (x ) = p(x ); its presence will be implicit whenever the update formula \nfor p is omitted. Write The write(t, v) action for TPL has the guard .t1.TPL.rs(t1,v) . TPL.ws(t1,v) \n. t1 = t, and the transition formula is given by .t1,v1.TPL.ws ' (t1,v1) = TPL.ws(t1,v1) . t1 = t . v1 \n= v. In other words, t can write to v when no other thread has read-or write-access. In that case, v \nis added to the write set of t. Commit &#38; Abort The commit(t, v) and abort(t, v) actions for TPL are \nalways enabled (i.e., they have the guard true), and their transition formul\u00e6 are given by the conjunction \nof .t1,v1.TPL.rs ' (t1,v1) = TPL.rs(t1,v1) . t1 = t .t1,v1.TPL.ws ' (t1,v1) = TPL.ws(t1,v1) . t1 = t. \nBoth the commit and abort action for TPL are essentially no-ops; the read-and write-sets of the acting \nthread are simply cleared.  B. Model of Dynamic Software Transactional Memory The DSTM system is a transaction \nmanager which ensures perceived sequential behavior by allowing only one transaction write-access to \na memory location, and ensuring that all values read by a transaction have not been altered by other \nthreads before committing. Our DSTM model uses the thread-status predicates DSTM..nished(t), DSTM.validated(t), \nDSTM.invalid(t), DSTM.aborted(t), as well as the predicates DSTM.rs(t, v) and DSTM.os(t, v) to mean that \nt has read-or ownership-access to v. As syntactic sugar, we indicate status predicate valuations with \natomic formul\u00e6, e.g., by using the formula DSTM.status(t)= .nished to mean DSTM..nished(t) .\u00acDSTM.validated(t) \n.\u00acDSTM.invalid(t) .\u00acDSTM.aborted(t). The initial condition .t.DSTM.status(t)= .nished ..t, v.\u00acDSTM.rs(t, \nv) .\u00acDSTM.os(t, v) asserts that all access sets are initially uninhabited, and threads begin in the .nished \nstate. The system is further constrained by the invariants .t. exactly one of DSTM..nished(t), DSTM.validated(t), \nDSTM.invalid(t), DSTM.aborted(t) holds, and .t1,t2, v.DSTM.os(t1,v) . DSTM.os(t2,v) . t1 = t2. The .rst \nconstraint is an artifact of encoding the four-phase DSTM state with predicates, and the second corresponds \nto the implemen\u00adtation strategy of associating a write-lock per location. Read The read(t, v) action \nfor DSTM has the guard \u00acDSTM.aborted(t) . (\u00acDSTM.os(t, v) . DSTM..nished(t)), and the transition formula \ngiven by .t1,v1.DSTM.rs ' (t1,v1) = DSTM.rs(t1,v1) .\u00acDSTM.os(t, v) . t1 = t . v1 = v. In other words, \nany thread t that has not aborted can read v so long as t is in the .nished state, or already owns v. \nIf t does not already own v, then v is added to t s read set. Write The write(t, v) action has the guard \n\u00acDSTM.aborted(t) and the transition formula given by the conjunction of .t1.DSTM..nished ' (t1) = DSTM..nished(t1) \n. (\u00acDSTM.os(t, v) .\u00ac.t,v (t1)) abt .t1.DSTM.validated ' (t1) = DSTM.validated(t1) . (\u00acDSTM.os(t, v) \n.\u00ac.t,v (t1)) abt .t1.DSTM.invalid ' (t1) = DSTM.invalid(t1) . (\u00acDSTM.os(t, v) .\u00ac.t,v (t1)) abt .t1.DSTM.aborted \n' (t1) = DSTM.aborted(t1) .\u00acDSTM.os(t, v) . .t,v abt(t1) .t1,v1.DSTM.rs ' (t1,v1) = DSTM.rs(t1,v1) . \n(\u00acDSTM.os(t, v) .\u00ac.t,v (t1)) abt .t1,v1.DSTM.os ' (t1,v1) = (DSTM.os(t, v) . DSTM.os(t1,v1)) . (\u00acDSTM.os(t, \nv) . (t1 = t . v1 = v . DSTM.os(t1,v1)) .\u00ac.t,v abt(t1)) def where the sub-formula .t,v (t1)= t1 = t \n. DSTM.os(t1,v) abtindicates that t1 is being aborted. In other words, any non-aborted thread t is allowed \nto write to v; if t does not already own location v, then any previous owners are evicted to the abort \nstate. Validate The validate(t) action has the guard DSTM..nished(t) and the transition formula given \nby .t1.DSTM..nished ' (t1) = t1 = t . DSTM..nished(t1) .\u00ac.t abt(t1) .t1.DSTM.validated ' (t1) = t1 = \nt . DSTM.validated(t1) .\u00ac.t abt(t1) .t1.DSTM.invalid ' (t1) = DSTM.invalid(t1) .\u00ac.t abt(t1) .t1.DSTM.aborted \n' (t1) = DSTM.aborted(t1) . .t abt(t1) .t1,v1.DSTM.rs ' (t1,v1) = DSTM.rs(t1,v1) .\u00ac.t abt(t1) .t1,v1.DSTM.os \n' (t1,v1) = DSTM.os(t1,v1) .\u00ac.t abt(t1) def where .t = t1 = t..v1.DSTM.rs(t, v1).DSTM.os(t1,v1). abt(t1) \nIn other words, any thread t in the .nished state is allowed to validate its read set; in doing so, every \nowner of a location which t read becomes aborted. Commit The commit(t) action has DSTM.validated(t) as \nthe guard, and the transition formula given by the conjunction of .t1.DSTM..nished ' (t1) = t1 = t . \nDSTM..nished(t1) .\u00ac.t inv(t1) .t1.DSTM.validated ' (t1) = t1 = t . DSTM.validated(t1) .\u00ac.invt (t1) .t1.DSTM.invalid \n' (t1) = DSTM.invalid(t1) . .t inv(t1) .t1.DSTM.aborted ' (t1) = DSTM.aborted(t1) .\u00ac.t inv(t1) .t1,v1.DSTM.rs \n' (t1,v1) = t1 = t . DSTM.rs(t1,v1) .t1,v1.DSTM.os ' (t1,v1) = t1 = t . DSTM.os(t1,v1), where .t def \nt..v1.DSTM.os(t, v1).DSTM.rs(t1,v1). inv(t1)= t1 =In other words, any thread t in the validated state \nis allowed to commit; in doing so, every read by another thread to a location v which t owned becomes \ninvalid, since t is updating v s value.2 Abort The abort(t) action for DSTM has the guard true and the \ntransition formula given by the conjunction of .t1.DSTM..nished ' (t1) = t1 = t . DSTM..nished(t1) .t1.DSTM.validated \n' (t1) = t1 = t . DSTM.validated(t1) .t1.DSTM.invalid ' (t1) = t1 = t . DSTM.invalid(t1) .t1.DSTM.aborted \n' (t1) = t1 = t . DSTM.aborted(t1) .t1,v1.DSTM.rs ' (t1,v1) = t1 = t . DSTM.rs(t1,v1) .t1,v1.DSTM.os \n' (t1,v1) = t1 = t . DSTM.os(t1,v1). The abort action simply clears the state of t. 2 This is due to \nthe deferred update semantics we ve assumed.  C. Model of Transactional Locking II Transactional locking \nII is a transaction manager which ensures perceived sequential behavior by giving exclusive locks to \nlocations a thread has written to upon committing, while ensuring that all values read by a transaction \nhave not been altered by others before committing. Our TL2 model uses the status predicates TL2..nished(t), \nTL2.validated(t), and TL2.aborted(t), as well as predicates TL2.rs(t, v), TL2.ws(t, v), read &#38; write \nsets TL2.ls(t, v), TL2.ms(t, v). lock &#38; modi.ed sets The initial condition .t.TL2.status(t)= .nished \n..t, v.\u00acTL2.rs(t, v) .\u00acTL2.ws(t, v) .\u00acTL2.ls(t, v) .\u00acTL2.ms(t, v) asserts that threads begin in the .nished \nstate, all access sets are initially uninhabited. The system is further constrained by the invariant \n.t. exactly one of TL2..nished(t), TL2.validated(t), TL2.aborted(t) holds. This constraint is an artifact \nof encoding the three-phase TL2 state with predicates. Although here we list separately TL2 s validate \nand commit actions, due to the limitation mentioned in Section 6, the model we verify assumes that validate(t) \nand commit(t) execute together atomically. Read The read(t, v) action for TL2 has the guard TL2..nished(t) \n. (TL2.ms(t, v) . TL2.ws(t, v)) and the transition formula given by the conjunction of .t1,v1.TL2.rs \n' (t1,v1) = TL2.rs(t1,v1) .\u00acTL2.ws(t, v) . t1 = t . v1 = v. In other words, any thread t in the .nished \nstate can read v, so long as v is only marked as modi.ed when t has written to v. In that case, v is \nadded to t s read-set if t has not already written to v. Write The write(t, v) action has the guard TL2..nished(t) \nand the transition formula given by the conjunction of .t1,v1.TL2.ws ' (t1,v1) = TL2.ws(t1,v1) . t1 = \nt . v1 = v. In other words, any thread t in the .nished state can write to v, in which case v is added \nto t s write-set. Lock The lock(t, v) action for TL2 has the guard, TL2..nished(t) . TL2.ws(t, v), and \nthe transition formula given by the conjunction of .t1.TL2..nished ' (t1) = TL2..nished(t1) .\u00ac.t,v (t1) \nabt .t1.TL2.validated ' (t1) = TL2.validated(t1) .\u00ac.t,v (t1) abt .t1.TL2.aborted ' (t1) = TL2.aborted(t1) \n. .t,v (t1) abt.t1,v1.TL2.ls ' (t1,v1) = TL2.ls(t1,v1) . t1 = t . v1 = v def where .t,v = t1 = t . TL2.ls(t1,v). \nIn other words, any abt(t1) thread t in the .nished state that has written to location v can lock v; \nby doing so, threads that have previously locked v are evicted to the aborted state. Validate The validate(t, \nv) action for TL2 has the guard TL2..nished(t) . \u00ac.v1.TL2.rs(t, v1) . TL2.ms(t, v1) ..v1.TL2.ws(t, v1) \n= TL2.ls(t, v1) and the transition formula given by the conjunction of .t1.TL2..nished ' (t1) = TL2..nished(t1) \n.\u00ac.t abt(t1) .t1.TL2.validated ' (t1) = t1 =t . TL2.validated(t1) .\u00ac.t abt(t1) .t1.TL2.aborted ' (t1) \n= TL2.aborted(t1) . .t abt(t1) .t1,v1.TL2.rs ' (t1,v1) = TL2.rs(t1,v1) .\u00ac.t abt(t1) .t1,v1.TL2.ws ' \n(t1,v1) = TL2.ws(t1,v1) .\u00ac.t abt(t1) def where .t == t ..v2.TL2.rs(t, v2) . TL2.ws(t1,v2). abt(t1) t1 \nIn other words, any thread t in the .nished state that has the lock to every location it has written, \nand has not read from a modi.ed location, is allowed to validate its read set. By doing so, any thread \nthat has written to a location that t has read becomes aborted. Commit The commit(t) action is guarded \nby TL2.validated(t) and has a transition formula given by the conjunction of .t1.TL2..nished ' (t1) = \nt1 = t . TL2..nished(t1) .t1.TL2.validated ' (t1) = t1 = t . TL2.validated(t1) .t1,v1.TL2.rs ' (t1,v1) \n= t1 = t . TL2.rs(t1,v1) .t1,v1.TL2.ws ' (t1,v1) = t1 = t . TL2.ws(t1,v1) .t1,v1.TL2.ls ' (t1,v1) = t1 \n= t . TL2.ls(t1,v1) .t1,v1.TL2.ms ' (t1,v1) = t1 = t . (TL2.ms(t1,v1) . TL2.ws(t, v1) . .act(t1)), def \nwhere .act(t1)= .v2.TL2.rs(t1,v2) . TL2.ws(t1,v2). In other words, t can commit after it has validated; \nby doing so, the locations that t has written to are added to the modi.ed sets of all other active threads. \nD. Model of Strict Serializability The strict serializability system is a deterministic executable speci.\u00adcation \nwhose behaviors include exactly the set of strictly serializable traces [16]. Our SS model uses the status \npredicates SS..nished(t), SS.started(t), SS.invalid(t), and SS.pending(t), as well as predi\u00adcates encoding \nthe read-sets SS.rs(t, v), write-sets SS.ws(t, v), pro\u00adhibited read-sets SS.prs(t, v), prohibited write-sets \nSS.pws(t, v), and weak-predecessors SS.wp(t, t1) of each thread t. The initial condition .t.SS.status(t)= \n.nished ..t1,t2.\u00acSS.wp(t1,t2) ..t, v.\u00acSS.rs(t, v) .\u00acSS.ws(t, v) .\u00acSS.prs(t, v) .\u00acSS.pws(t, v) asserts \nthat threads begin in the .nished state, all access sets are initially uninhabited, and the weak-predecessor \nrelation is empty. SS is further constrained by the invariant, .t. exactly one of SS..nished(t), SS.started(t), \nSS.invalid(t), SS.pending(t) holds. The constraint is an artifact of encoding the four-phase SS state \nwith predicates. Read The read(t, v) action for SS has the guard true and the transition formula given \nby the conjunction of .t1.SS..nished ' (t1) = SS..nished(t1) .\u00acSS.ws(t, v) . t1 =t .t1.SS.started ' (t1) \n= (SS.ws(t, v) . SS.started(t1)) . (\u00acSS.ws(t, v) . t1 = t . SS.started(t1) . t1 = t . (SS.started(t1) \n. SS..nished(t1))  .\u00acSS.prs(t, v)) .t1.SS.pending ' (t1) = SS.pending(t1) . (\u00acSS.ws(t, v) .\u00ac.t,v (t1)) \ninv .t1.SS.invalid ' (t1) = SS.invalid(t1) .\u00acSS.ws(t, v) . .t,v (t1) inv.t1,v1.SS.rs ' (t1,v1) = SS.rs(t1,v1) \n.\u00acSS.ws(t, v) . t1 = t . v1 = v .t1,t2.SS.wp ' (t1,t2) = SS.wp(t1,t2) .\u00acSS.ws(t, v) . (t1 = t . t2 = \nt . SS.ws(t1,v) . t1 = t . t1 = t . SS.prs(t2,v) . t1 = t . SS.pending(t2) . SS..nished(t1)), def where \n.t,v (t1)= = t .SS.prs(t, v). In other words, any thread invt1 t can always try to read a location v. \nIf t has already written to v, this action is a no-op. Otherwise, if t has been prohibited from writing \nto v (i.e., SS.prs(t, v)), then t s status is set to invalid; if not, then t s status is set to started. \nSince the commit of a write will invalidate the value read from v, t becomes a weak-predecessor of any \nthread that has written to v,3 and any thread that has been prohibited from reading v becomes a weak-predecessor \nof t. Additionally, if this was t s .rst action for a given transaction, then any pending threads also \nbecome weak-predecessors. Write The write(t, v) action for SS has the guard true and the transition formula \ngiven by the conjunction of .t1.SS..nished ' (t1) = t1 = t . SS..nished(t1) .t1.SS.started ' (t1) = (SS.started(t1) \n. SS..nished(t1) . t1 inv(t1) = t) .\u00ac.t,v .t1.SS.pending ' (t1) = SS.pending(t1) .\u00ac.t,v (t1) inv .t1.SS.invalid \n' (t1) = SS.invalid(t1) . .t,v (t1) inv .t1,v1.SS.ws ' (t1,v1) = SS.ws(t1,v1) . t1 = t . v1 = v .t1,t2.SS.wp \n' (t1,t2) = SS.wp(t1,t2) . t1 = t . t2 = t . SS.rs(t2,v) . t1 = t . t2 = t . SS.pws(t2,v) . t1 = t . \nSS.pending(t2) . SS..nished(t1), def where .t,v (t1)= t1 = t .SS.pws(t, v). In other words, a thread \nt inv may always try to write to location v, though if t has been prohibited from writing to v (i.e., \nSS.pws(t, v), then t s status is set to invalid; otherwise, t s status is set to started. Any threads \nthat have already read v, or have been prohibited from writing to v, become weak\u00adpredecessors of t. Additionally, \nif this was t s .rst action for a given transaction, then any pending threads also become weak\u00adpredecessors. \nCommit The commit(t) action for SS has the guard \u00acSS.invalid(t) .\u00acSS.wp(t, t) and the transition formula \ngiven by the conjunction of .t1.SS..nished ' (t1) = t1 = t . SS..nished(t1) .\u00acSS.wp(t, t1) .t1.SS.started \n' (t1) = t1 = t . SS.started(t1) .\u00acSS.wp(t, t1) .t1.SS.pending ' (t1) = t1 = t . SS.pending(t1) . .t \npend(t1) .t1.SS.invalid ' (t1) = SS.invalid(t1) . .t inv(t1) .t1,v1.SS.rs ' (t1,v1) = t1 = t . SS.rs(t1,v1) \n.t1,v1.SS.ws ' (t1,v1) = t1 = t . SS.ws(t1,v1) 3 Again, the deferred update semantics guides this decision. \n.t1,v1.SS.prs ' (t1,v1) = t1 = t . (SS.prs(t1,v1) . SS.wp(t, t1) . (SS.prs(t, v1) . SS.ws(t, v1))) .t1,v1.SS.pws \n' (t1,v1) = t1 = t . (SS.pws(t1,v1) . SS.wp(t, t1) . (SS.pws(t, v1) . SS.ws(t, v1) . SS.rs(t, v1))) .t1,t2.SS.wp \n' (t1,t2) = t1 = t . t2 = t . (SS.wp(t1,t2) . SS.wp(t, t2) . (SS.wp(t1,t) ..v.SS.ws(t, v) . SS.ws(t1,v))) \nwhere .t def inv(t1)= t1 = t . SS.wp(t, t1) ..v1.SS.ws(t, v1) . SS.ws(t1,v1), and .t def pend(t1)= t1 \n= t . SS.wp(t, t1) . \u00ac.v1.SS.ws(t, v1) . SS.ws(t1,v1). In other words, any thread t that whose status \nis not invalid, and is not a self weak-predecessor can commit. In that case, all state involving t is \ncleared, and the status of every weak-predecessor t1 of t is either set to invalid, if t1 had a write-write \ncon.ict with t, or pending otherwise. All weak-predecessors of t are then prohibited from reading any \nlocation which t has written to, or has itself been prohibited from reading. Similarly, all weak-predecessors \nof t are prohibited from writing to any location which t has read or written, or has itself been prohibited \nform writing to. Finally, any weak\u00adpredecessor t2 of t becomes a weak-predecessor of any thread t1 which \nt preceded, or had a write-write con.ict with. Abort The abort(t) action for SS has the guard true and \nthe transition formula given by the conjunction of .t1.SS..nished ' (t1) = t1 = t . SS..nished(t1) .t1.SS.started \n' (t1) = t1 = t . SS.started(t1) .t1.SS.pending ' (t1) = t1 = t . SS.pending(t1) .t1.SS.invalid ' (t1) \n= t1 = t . SS.invalid(t1) .t1,v1.SS.rs ' (t1,v1) = t1 = t . SS.rs(t1,v1) .t1,v1.SS.ws ' (t1,v1) = t1 \n= t . SS.ws(t1,v1) .t1,v1.SS.prs ' (t1,v1) = t1 = t . SS.prs(t1,v1) .t1,v1.SS.pws ' (t1,v1) = t1 = t \n. SS.pws(t1,v1) .t1,v1.SS.wp ' (t1,t2) = t1 = t . t2 = t . SS.wp(t1,t2). In other words, a thread t is \nalways abort-enabled, and upon aborting t s state is completely cleared.  \n\t\t\t", "proc_id": "1806596", "abstract": "<p>We describe an automatic verification method to check whether transactional memories ensure strict serializability a key property assumed of the transactional interface. Our main contribution is a technique for effectively verifying parameterized systems. The technique merges ideas from parameterized hardware and protocol verification--verification by invisible invariants and symmetry reduction--with ideas from software verification--template-based invariant generation and satisfiability checking for quantified formul&#230; (modulo theories). The combination enables us to precisely model and analyze unbounded systems while taming state explosion.</p> <p>Our technique enables automated proofs that two-phase locking (TPL), dynamic software transactional memory (DSTM), and transactional locking II (TL2) systems ensure strict serializability. The verification is challenging since the systems are unbounded in several dimensions: the number and length of concurrently executing transactions, and the size of the shared memory they access, have no finite limit. In contrast, state-of-the-art software model checking tools such as BLAST and TVLA are unable to validate either system, due to inherent expressiveness limitations or state explosion.</p>", "authors": [{"name": "Michael Emmi", "author_profile_id": "81333488438", "affiliation": "University of California, Los Angeles, CA, USA", "person_id": "P2184524", "email_address": "", "orcid_id": ""}, {"name": "Rupak Majumdar", "author_profile_id": "81100319213", "affiliation": "University of California, Los Angeles, CA, USA", "person_id": "P2184525", "email_address": "", "orcid_id": ""}, {"name": "Roman Manevich", "author_profile_id": "81100232411", "affiliation": "University of California, Los Angeles, CA, USA", "person_id": "P2184526", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1806596.1806613", "year": "2010", "article_id": "1806613", "conference": "PLDI", "title": "Parameterized verification of transactional memories", "url": "http://dl.acm.org/citation.cfm?id=1806613"}