{"article_publication_date": "06-05-2010", "fulltext": "\n Lock Elision for Read-Only Critical Sections in Java Takuya Nakaike Maged M. Michael IBM Research -Tokyo \nIBM Thomas J. Watson Research Center nakaike@jp.ibm.com magedm@us.ibm.com Abstract It is not uncommon \nin parallel workloads to encounter shared data structures with read-mostly access patterns, where operations \nthat update data are infrequent and most operations are read-only. Typically, data consistencyis guaranteed \nusing mutual exclusion or read-write locks. The cost of atomic update of lock variables result in high \noverheads and high cache coherence traf.c under active sharing, thus slowing down single thread performance \nand limiting scalability. In this paper, we present SOLERO (Software Optimistic Lock Elision for Read-Only \ncritical sections),a new lock implementation called for optimizing read-only critical sections in Java \nbased on sequential locks. SOLERO is compatible with the conventional lock implementation of Java. However, \nunlike the conventional implementation, only critical sections that may write data or have side effects \nneed to update lock variables, while read-only critical sections need only read lock variables without \nwriting them. Each writing critical section changes the lock value to a new value. Hence, a read-only \ncritical section is guaranteed to be consistent if the lock is free and its value does not change from \nthe beginning to the end of the read-only critical section. UsingJavaworkloads including SPECjbb2005 \nand the HashMap and TreeMap Java classes, we evaluate the performance impact of applying SOLERO to read-mostly \nlocks. Our experimental re\u00adsults show performance improvements across the board, often sub\u00adstantial, \nin both single thread speed and scalability over the con\u00adventional lock implementation (mutual exclusion) \nand read-write locks. SOLERO improves the performance of SPECjbb2005 by 3\u00ad5% on single and multiple threads. \nThe results using the HashMap and TreeMap benchmarks show that SOLERO outperforms the conventional lock \nimplementation and read-write locks by substan\u00adtial multiples on multi-threads. Categories and Subject \nDescriptors D3.4 [Programming Lan\u00adguages]: Processors Optimization General Terms Algorithms, Languages, \nPerformance Keywords Java, Just-In-Time compiler, synchronization, monitor, lock, optimization, lock \nelision Permission to make digital or hard copies of all or part of this work for personal or classroomuseisgrantedwithout \nfeeprovidedthat copies arenot madeordistributed forpro.torcommercialadvantage andthatcopiesbearthisnoticeandthefullcitation \nonthe .rstpage.To copy otherwise,to republish,topostonserversorto redistribute tolists, requirespriorspeci.cpermission \nand/ora fee. PLDI 10, June5 10,2010,Toronto,Ontario, Canada. Copyright c . 2010 ACM 978-1-4503-0019-3/10/06. \n. . $10.00 1. Introduction Locking is the most common mechanism used by programmers for maintaining \nthe consistency of shared data in multithreaded pro\u00adgrams. The Java programming language supports the \nsynchronized construct, which guarantees mutual exclusion among code blocks associated with an object \ns lock. A mutual exclusion [6] lock can be held by at most one thread at anytime. A common sharing pattern \nin multithreaded programming is the read-mostly pattern where most operations on a set of shared data \nare read-only, but occasionally some operations up\u00addate the data or have external side effects. Read-write \nlocks [3, 10] allow the concurrent execution of read-only operations. Read\u00adwrite locks are supported \nin Java (5.0 and later) as part of the java.util.concurrent package. A read-write lock has two modes: \nread mode and write mode. Multiple threads may hold a read-write lock in read mode concurrently. While \na thread holds such a lock in write mode, no other thread can hold the lock, whether in read mode or \nin write mode. In both mutual exclusion and read-write locks, lock acquisi\u00adtion involves atomic instructions \nsuch as Compare-And-Swap or the pair Load-Linked and Store-Conditional. These instructions are substantially \nslower than regular load and store instructions. Fur\u00adthermore, acquisition and release of a lock involve \nwriting to lock variables, resulting in extra cache coherence traf.c that is not in\u00adherent to the data \naccesses protected by the locks. Sequential locks have been used to elide writes to lock variables for \nread-only critical sections in the Linux kernel. In sequential locks, the lock variable is implemented \nas a counter. The lock value is incremented for both lock acquisition and lock release. If the lock value \nis odd, then the lock is held. Otherwise, the lock is free. At the beginning of a read-only critical \nsection, the lock value is read. At the end of the critical section, the lock value is compared with \nthe value read at the beginning of the critical section. If the lock value is unchanged during the execution \nof the critical section, the execution of the critical section is completed without acquiring the lock. \nHowever, sequential locks are applicable only in limited cases, as theyhave manyrestrictions.Forexample, \nsequential locks are not re-entrant, and do not allow pointer accesses and loops in read-only critical \nsections that avoid writing to lock variables. In this paper, we propose a new lock implementation called \nSOLERO (Software Optimistic Lock Elision for Read-Only critical sections) to elide writes to lock variables \nfor read-only critical sections in Java. The idea of eliding writes to lock variables is based on the \nsequential lock. However, our lock implementation is capable of providing the full functionality of the \nconventional lock implementation used by synchronized blocks, and thus it can replace the conventional \nlock implementation of Java. In SOLERO, the lock variable contains a counter value when the lock is free. \nAt the beginning of a writing critical section which may have writes or side effects, a thread reads \nthe counter value into a local variable and writes its id to the lock variable with a lock bit atomically, \nso that other threads can detect that the lock is acquired and the thread can acquire the lock recursively, \nif needed. At the end of the critical section, the thread updates the lock variable with a new counter \nvalue, so that other threads can detect that the lock was acquired and released. In a read-only critical \nsection, a thread does not update the lock variable. If the lock is free and its value is the same at \nthe beginning and at the end of the read-only critical section, then it can be concluded that the lock \nremained free throughout the duration of such critical section and no writing occurred, hence the reads \nperformed in the critical section are guaranteed to be consistent. If the lock value is found to have \nchanged, then the consistency of reads cannot be guaranteed and the read-only critical section is re-executed. \nSOLEROincludes mechanisms for recovery fromfaults caused by inconsistent reads. Since read-only critical \nsections are allowed to proceed optimistically without preventing a concurrent writing critical section \nfrom updating shared data, then it is possible for the speculatively read values to be mutually inconsistent. \nRead inconsistency may lead to faults such as null pointer dereference, divisionby zero, or in.nite loops.We \nuseJavaexception handling mechanisms to catch exceptions due to faults. Our design also exploits infrequent \nasynchronous events, which are normally used to checkgarbage collectionevents, for readvalidation which \ndetect and recover from in.nite loops induced by inconsistent reads. Our Java Just-In-Time (JIT) compiler \nidenti.es synchronized blocks as read-only if they do not include writes to heap data and events that \nmay have side-effects, such as wait/notify and system calls. Our JIT compiler can also accept annotations \nto specify read\u00adonly synchronized blocks, in cases where it is dif.cult to identify a synchronized block \nas read only if the synchronized block includes virtual method invocations. SOLERO can coexist with bi-modal \nlocking [1, 11] mechanisms which are widely used by various JVMs. In a bi-modal locking mechanism, each \nlock has two modes: thin mode and fat mode. Our JVM employs the tasuki lock which is a bi-modal locking \nmechanism and allows the lock mode to switch bidirectionally. SOLERO supports the bidirectional switching \nof the lock mode the same as in the conventional lock implementation, though it can elide locks only \nin the thin mode. UsingJavaworkloads including SPECjbb2005 and the HashMap and TreeMap Java classes, \nwe evaluate the performance impact of applying SOLERO to read-mostly locks. Our experimental re\u00adsults \nshow performance improvements across the board, often sub\u00adstantial, in both single thread speed and scalability \nover the con\u00adventional lock implementation (mutual exclusion) and read-write locks. On SPECjbb2005, SOLERO \nimproves the performance by 3-5% on a single thread and multiple threads. On the HashMap andTreeMap benchmarks, \nSOLEROoutperforms the conventional lock implementation and read-write locks by substantial multiples \nin the multi-thread performance. The only case of underperfor\u00admance by SOLERO was when lock elision was \nnot applicable, and the overhead over conventional locking is less than 1% in all the benchmarks. The \ncontributions of this paper are: The design and implementation of SOLERO in a commercial JVM. It is \nthe .rst JVM implementation of lock elision for read\u00adonly critical sections.  Experimental study of \nthe performance impact of lock elision for read-only critical sections.  Flat lock FLC bit Inflation \nbit  Inflated lock Figure 1. Conventional lock structure of Java 1: while (true) { 2: v = obj->lock; \n 3: if(v==0){ 4: if (CAS(&#38;obj->lock,0,thread_id)) { 5: break; /* Fast path lock acquire */ 6: \n} 7: }else{ 8: slow_enter(obj); 9: break; 10: } 11: } 12: ... /* Critical section */ 13: if ((obj->lock \n&#38; 0xff) == 0) { 14: obj->lock = 0; /* Fast path lock release */ 15: }else{ 16: slow_exit(obj); \n 17: } Figure 2. Conventional lock operations (six recursion bits) Our experimental results indicate \nthe superior performance of SOLERO over conventional lock implementations of both mu\u00adtual exclusion locks \nand read-write locks. The rest of the paper is organized as follows. Section2presents brief descriptions \nof typical lock implementation in Java and se\u00adquential locks. Section3 describes SOLERO, our new lock \nimple\u00admentationina commercial JVM. Section4presents ourexperimen\u00adtal results. We describe mechanisms \nto extend SOLERO in Sec\u00adtion 5. In Section 6, we discuss related work. We conclude with Section 7.  \n2. Background 2.1 Conventional Lock Implementation inJava In Java, bi-modal locking mechanisms [1, 11] \nare commonly used to optimize lock operations. Tasuki lock is one of the state-of-the\u00adart bi-modal locking \nmechanisms, and it is employed by our JVM. In tasuki lock, a lock has two modes: thin mode and fat mode. \nA lock is called .at in the thin mode, and it is called in.ated in thefat mode.Fora.atlock,a threadcanacquirethelockatalowcostby \nwriting its id to the lock variable atomically. If contention occurs frequently on a .at lock, the lock \nis transformed (in.ated) into an in.ated lock.For an in.ated lock,a thread needs to paya high cost to \nacquire the lock by using an OS monitor. If contention occurs rarely on an in.ated lock, the lock can \nbe reverted (de.ated) to a .at lock. Figure 1 shows the structure of a typical lock variable. A lock \nvariable is initialized to zero. If the in.ation bit of a lock is set, the lock is in thefat mode. Otherwise, \nthe lock is in the thin mode. The FLC (.at-lock contention) bit is set when contention is detected on \na .at lock, and it is used to in.ate the lock. 0: void three_tier_locking(Object *obj) { 1: for(i=0;i<tir3;i++){ \n 2: for(j=0;j<tier2;j++){ 3: v = obj->lock; 4: if(v==0){ 5: if (CAS(&#38;obj->lock,0,thread_id)) { \n 6: return; /* Acquired a flat lock */ 7: } 8: }elseif((v&#38;0xff)!=0){ 9: /* Recursive, inflated, \nor FLC */ 10: goto END_OF_SPIN; 11: } 12: for (k = 0; k < tier1; k++); 13: } 14: yield(); 15: } \n 16: END_OF_SPIN: 17: ... 18: return; 19: } Figure 3. Three-tier locking scheme Figure2 shows pseudocode \nfor acquiringa .at lock.If the lock value is zero, the thread tries to write its id to the lock variable \natomically1.If the lockvalueis not zero, the thread calls the slow\u00adpath code(slow_enter)that: 1) checks \nif the thread already holds the lock for recursive locking, 2) resolves lock contention if the lock is \nheld by another thread, and 3) enters the OS monitor if the lock in thefat mode. Contention on a .at \nlock is resolved using a three-tier lock\u00ading scheme with three nested loops [7]. Figure 3 shows the psue\u00addocode \nfor three-tier locking. In the middle-tier loop, lock acquisi\u00adtion (atomic updates to the lock variable) \nis tried repeatedly (line 5).Ifthelock acquisitionfails,CPUcyclesarewastedinthe inner\u00admost loop (line \n12), as a backoff mechanism. When a lock cannot be acquired after a number of attempts in the middle-tier \nloop, the CPU is yielded in the outermost loop (line 14). When a .at lock cannot be acquired after a \nnumber of outermost loop iterations, the lock is in.ated. The in.ation can also occur when the bits of \nthe recursion counter saturate. For in.ation, a thread retrieves an OS monitor mapped to a monitor object, \nand then writes the pointer of the OS monitor to the lock variable after entering the OS monitor and \nacquiring the .at lock. An in.ated lock can be de.ated by writing zero to the lock variable in the slow\u00adpath \ncode for lock release (in slow_exit in Figure 2).  2.2 SequentialLocks Sequential locks (also called \nseqlocks) are used to elide writes to lock variables in read-only critical sections in the Linux kernel, \nand they are the algorithmic basis of our lock implementation. Fig\u00adure 4(a) shows the pseudocode to acquire \nand release a sequential lock in a writing critical section. The lock variable is implemented as a counter. \nWhen a lock is acquired, the lock value is incremented. When a lock is released, the lock value is incremented \nagain. When 1The atomic update of the lock variable can use the Compare-and-Swap (CAS) atomic primitive \nor alternatively the pair Load-Linked (LL) and Store-Conditional (SC) available on all mainstream processor \narchitec\u00adtures. In its simplest form, CAS takes three arguments: a memory location, an expected value, \nand a new value. If the memory location holds the ex\u00adpected value, the new value is written to it, atomically. \nA Boolean return value indicates whether the write occurred. If it returns true, it is said to succeed. \nOtherwise,itissaidtofail. LL/SC canbeusedtoimplement CAS. For generality, we present the algorithms in \nthis paper using CAS. 1: while (true) { 2: v=lock; 3: if((v&#38;0x1)==0){ 4: if (CAS(&#38;lock,v,v+1)) \n{ 6: break; /* Acquired lock */ 7: } 8: } 9: } 10: ... /* Writing critical section */ 11: lock++; \n/* Release lock */ (a) Lock acquisition and release in a writing critical section 1: while (true) { \n 2: v=lock; 3: if ((v &#38; 0x1) != 0) continue; 4: ... /* Read-only critical section */ 5: if (v \n== lock) 6: break; /* Success. Lock unchanged */ 7: } (b) Lock elision in a read-only critical section \n Figure 4. Lock acquisition, release, and elision in sequential locks the lowest bit of the lock value \nis not zero, in other words, the lock value is odd, the lock is held. Otherwise, the lock is free. Figure \n4(b) shows the pseudocode to elide writes to lock vari\u00adables in read-only critical sections. At the beginning \nof the critical section, the lock value is stored in a local variable. If the lowest bit of the lock \nvalue is zero, the critical section is executed. At the end of the critical section, the lock value is \ncompared with the value read at the beginning of the critical section. If the lock value is un\u00adchanged \nduring the execution of the critical section, the execution of the critical section is considered to \nbe completed successfully. Otherwise, the critical section is re-executed. Although a sequential lock \nallows eliding writes to lock vari\u00adables in read-only critical sections, it has the following limitations: \n Sequential locks are not re-entrant, because lock variables do not hold information about lock owners. \n Sequential locks do not allow pointer accesses and loops in\u00adside read-only critical sections. Inconsistent \nreads, which can be caused by the speculative execution of read-only critical sec\u00adtions, can causefaults \nsuch as invalid pointer dereference, divi\u00adsion by zero, and in.nite loops.   3. SOLERO In this section, \nwe describe SOLERO, our new lock implementa\u00adtion, which provides complete Java lock functionality and \nallows eliding writes to lock variables for read-only critical sections. 3.1 Lock Operationsfor Writing \nCritical Sections The in.ated lock structure for SOLERO is the same as in con\u00adventional lock implementation. \nThe SOLERO .at lock structure is shown in Figure 5. Each SOLERO .at lock contains a lock bit. When the \nlock bit is set, the lock is held. Otherwise, the lock is free. When a lock is free, the higher bits \nof the lock variable hold a counter value like a sequential lock. When a lock is held, the higher bits \nhold a thread id. One bit from the recursion bits is used for the lock bit. Figure6showsthe pseudocodeto \nacquireand releasea lockin SOLERO. Before each acquisition of a lock, the lower three bits of the lock \nvalue are masked out. If all of the lower three bits are  Lock is free Lock bit FLC bit Inflation bit \nCounter bits Recursion bits 0 0  Lock is held Figure 5. SOLEROlock structure 1: while (true) { 2: \nv1 = obj->lock; 3: if((v1&#38;0x7)==0){ 4: val = thread_id+LOCK_BIT; 5: if (CAS(&#38;obj->lock,v1,val)) \n{ 6: /* Fast path for lock acquisition */ 7: break; 8: } 9: }else{ 10: v1 = solero_slow_enter(obj); \n 11: break; 12: } 13: } 14: ... /* Writing critical section */ 15: v2 = obj->lock; 16: if ((v2 &#38; \n0xff) == LOCK_BIT) { 17: /* Fast path for lock release */ 18: obj->lock = v1 + 0x100; 19: } else { \n 20: solero_slow_exit(obj,v1); 21: } Figure 6. SOLEROlock operations for writing critical sections \nzero, the lock variable is atomically updated with the thread id plus thelockbit.Thelockvalueread beforethe \natomicupdateiskeptin a local variable until the lock is released. We refer to such a local variable as \nthe local lock variable in the remainder of this paper. In this .gure, the local lock variable is v1. \nWhen the lower three bits are not zero, the slow-path code(solero_slow_enter)is called. Before each release \nof the lock, the lower eight bits are masked out from the lock value and compared with the lock-bit value \nwhere only the lock bit is set. If only the lock bit is set among the lowest eight bits, then the .at \nlock is released by incrementing the value of the local lock variable and updating the lock variable \nwith the incremented value. SOLERO needs the following operations for acquisition and release of a lock \nin addition to the lock operations of the conventional lock implementation: Masking out the lower three \nbits of the lock value before lock acquisition  Adding the lock bit to the thread id as a value to be \nwritten to the lock variable for lock acquisition  Keeping the lock value read before lock acquisition \nin a local variable until lock release  Incrementing the value stored in the local lock variable for \nlock release   3.2 Lock Elisionfor Read-Only Critical Sections Our JIT compiler identi.es read-only \nsynchronized blocks by look\u00ading for writes and side effects within synchronized blocks.For syn\u00adchronized \nblocks without potential writes or side effects, it gener\u00adates the code to elide writes to lock variables. \nThe following oper\u00adations are not allowed in read-only synchronized blocks:  Writes to instance variables, \nstatic variables, and array elements  Writes to the local variables that are live at the beginning of \nthe critical section  Invocations of methods, other than those involved in throwing runtime exceptions \n  We chose not to apply lock elision to synchronized blocks with writes to local variables that are \nlive at the beginning of the critical section, because otherwise we would need to keep and restore the \nvalues that has been kept in such local variables before executing the critical section if the speculative \nexecution of the critical section fails to complete [17]. Although we do not explicitly forbid read\u00adonly \nsynchronized blocks from creating new objects by using the new construct, object creation rarely occurs \nin read-only synchro\u00adnized blocks because they involve the invocation of constructors where writes to \ninstance variables typically occur. Throwing runtime exceptions such as NullPointerException and ArrayIndexOutOfBoundsException \nis allowed in read-only syn\u00adchronized blocks as long as the references of the exception objects are not \nwritten within the read-only synchronized block. Although throwing runtime exceptions involves the creation \nof objects and writes to the instance variables, the exception objects are not visi\u00adble until the exception \nare caught by the catch blocks and the refer\u00adences of the exception objects are written to shared area. \nIn order to expand the applicability of lock elision, we intro\u00adduce an annotation @SoleroReadOnly to \nspecify read-only syn\u00adchronized blocks. This annotation can be added to a method that includes read-only \nsynchronized blocks. Our JIT compiler recog\u00adnizes the synchronized blocks included in the annotated method \nas read-only. The annotation is useful even when the JIT compiler uses the inter-procedure analysis to \nidentify the synchronized blocks that include the method invocations as read-only, because it is dif.cult \nto identify the invocation targets in Java where invocation targets are determined dynamically by dynamic \nclass loading and virtual methods. Figure7 shows the pseudocode to elide writes to lockvariables for \na read-only critical section. At the beginning of the critical section, the lower three bits of the lock \nvalue are masked out. If the lower three bits are zero, a thread proceeds to the inside of the critical \nsection after keeping the lock value in a local lock variable. At the end of the critical section, the \nvalue of the local lock variable is compared with the latest lock value. If the lock value is unchanged \nthroughout the duration of the critical section, the critical section is considered to have completed \nsuccessfully. In the fast path, the read-only critical section does not write to lock variables, and \nit has fewer operations than the conventional lock implementation. If the lower three bits of the lock \nvalue are not zero at the beginning of the read-only critical section, the thread calls the slow\u00adpath \ncode(solero_slow_read_enter) shown in Figure 8. If a thread already holds the .at lock, it increments \nthe recursion count. If the lock is already in.ated (the in.ation bit is set), the in.ated lock is acquired \nby using the OS monitor. If the lock is .at and is held by another thread, then the thread waits for \nthe lock to be released in three-nested loops like the three-tier locking scheme. If at some point in \nthe three-nested loops, the lowest three bits of lock value are found to be zero, the thread exits the \nloops, stores the lock value in the local lock variable, and proceeds to execute the read-only critical \nsection. However, if the lowest three bits of 1: v = obj->lock; 2: if((v&#38;0x7)!=0) 3: v = solero_slow_read_enter(obj); \n 4: while (true) { 5: ... /* Read-only critical section */ 6: if (v == obj->lock) { 7: /* Lock elision \nsucceeded */ 8: break; 9: } else if (solero_slow_read_exit(obj,v)) { 10: break; 11: }else{ 12: /* \nRe-execute the critical section */ 13: v = solero_slow_enter(obj); 14: } 15: } Figure 7. Lock elision \nin SOLERO for a read-only critical section the lock value are not zero throughout the three-nested loops, \nthe thread in.ates the lock. Before in.ation, a thread must enter the OS monitor that is mapped to the \nmonitor object and acquire the .at lock. This is the same as the conventional lock implementation. Additionally, \nSOLERO needs to increment the counter value that is read before the acquisition of the .at lock and to \nstore the incremented value in the OS monitor. When a lock is de.ated, the incremented value in the OS \nmonitor is written back to the lock variable. As a result, concurrent threads executing speculative read-only \ncritical sections while the lock is in.ated and de.ated can detect the change in the lock value. After \nthe in.ated lock is acquired, zero is returned from the slow-path code(solero_slow_read_enter)and stored \nin a local lock variable to force the thread to call the slow-path code (solero_slow_read_exit)at the \nend of the critical section. The lock value never matches with zero because the in.ation bit of the lock \nvalue is set. Figure 9 shows the pseudocode of the slow-path code called at the end of the critical section. \nIf a thread already holds the .at lock and the recursion count is not zero, it decrements the recursion \ncount. If a thread holds the .at lock and the recursion count is zero, it releases the .at lock by incrementing \nthe value of the local lock variable and updating the lock variable with the incremented value. If a \nthread holds the in.ated lock, it releases the in.ated lock. In these three cases, a non-zero value is \nreturned and the critical section is completed. If the lock value does not match these three cases, then \nit must be the case that the lock value was changed by another thread during the execution of the read-only \ncritical section. As a result, a zero value is returned, and the critical section is re\u00adexecuted. As \nshown in Figure 7, solero slow enter is called to acquire the lock when solero_slow_read_exit returns \nzero. This is the fallback mechanism to avoid starvation. In our implementation, the fallback occurs \nafter one failure to execute the read-only critical section. This can be expanded so that the fallback \noccurs after a larger number offailures.  3.3 Recovery from Inconsistent Reads Since read-only critical \nsections are allowed to proceed optimisti\u00adcally without preventing a concurrent writing critical section \nfrom starting, then it is possible for read values to be inconsistent. Read inconsistency can lead to \nfaults such as null pointer dereference, divisionby zero, and in.nite loops.If not handled, thesefaults \ncan occur to correct programs. Therefore, SOLERO must prevent or detect and recover from suchfaults. \n 1: int solero_slow_read_enter(Object *obj) { 2: if (test_recursion(obj)) { 3: obj->lock += 0x8; 4: \nreturn 0; 5: } 6: for(i=0;i<tier3;i++){ 7: for(j=0;j<tier2;j++){ 8: v = obj->lock; 9: if((v&#38;0x7)==0){ \n 10: return v; 11: }elseif((v&#38;0x3)!=0){ 12: goto INFLATION; 13: } 14: for (k = 0; k < tier1; \nk++); 15: } 16: yield(); 17: } 18: INFLATION: 19: ... 20: return 0; 21: } Figure 8. Slow-path \nentry code for SOLERO read-only critical sections 1: int solero_slow_read_exit(Object *obj, int v) { \n 2: if (test_recursion(obj)) { 3: obj->lock -= 0x8; 4: return 1; 5: } else if (hold_flat_lock(obj)) \n{ 6: obj->lock = v + 0x100; 7: check_flc(obj); 8: return 1; 9: } else if (hold_inflated_lock(obj)) \n{ 10: release_inflated_lock(obj); 11: return 1; 12: }else{ 13: return 0; 14: } 15: } Figure 9. \nSlow-path exit code for SOLEROread-only critical sec\u00adtions To detect and recover from read inconsistency, \nour JIT compiler generates a catch block for each synchronized block so that any ex\u00adception raised in \nthe synchronized block can be caught before leav\u00ading the synchronized block. Note that this mechanism \nis not speci.c to SOLERO and it is required for the conventional lock implemen\u00adtation to force a lock \nto be released before leaving the synchronized block. The difference between SOLEROand the conventional \nlock implementation is that the latter releases the lock and throws the ex\u00adception to the next higher \ncatch block, while in SOLERO, read con\u00adsistency is validated by comparing the lock variable with the \nlocal lock variable. If they are equal, then the reads are consistent and the exception is genuine, i.e., \ninherent to the program and not merely due to SOLERO allowing reads to be inconsistent, and the excep\u00adtion \nis thrown to the higher level. However, if the values are not equal, then the consistencyof reads is \nnot guaranteed, and hence it is possible that the exception is not genuine, then the exception is ignored \nand the execution of the read-only critical is retried. In order to avoid in.nite loops due to inconsistent \nreads, our JVM sends occasionally asynchronous events to threads. Each thread checks the existence of \nthe event at an asynchronous check point which is inserted by the JIT compiler at method entries and \nbefore backward branches of loops. When a thread receives the event, it validates the consistency of \nreads by comparing the lock value with the local lock value. If a thread .nds that reads may be inconsistent, \nit throws an exception to go back to the begin\u00adning of the critical section and retry executing the read-only \ncritical section. For read consistency validation, our JIT compiler prepares the information about the \nlocal lock variables and the local variables that hold the references to monitor objects. Note that storing \na local reference to a held lock is not speci.c to SOLERO. Conventional lock implementations use such \nlocal references to held locks to release a lock when an exception occurs inside a synchronized block \nand escapes outside the synchronized block. When a thread receives an event to validate read consistency, \nit walks the call stack and checks whether or not it is in a read-only critical section. If a thread \nis in a read-only critical section, it compares the value of the local lock variable with the lock value \nread from the monitor object. If the lock value is changed, an exception is thrown (which is then caught \nas described above and then causes the retry of the critical section).  3.4 Memory Ordering Compiler \noptimizations and multiprocessor architectures with weak memory models often reorder independent memory \naccesses or cause them to appear out of program order to other threads. However, the correctness of the \nalgorithms for SOLERO lock op\u00aderations depends on enforcing certain orderings among memory accesses within \nthese operations. In this subsection we describe required ordering in thefast paths of SOLERO operations. \nInthefastpathofa writing critical section (Figure6),theCAS of the lock variable in line 5 must be ordered \nbefore loads and stores inside the critical section (line 14), and these loads and stores must be ordered \nbefore the store to the lock variable in line 18. In the fast path of a read-only critical section (Figure \n7), the load from the lockvariablein line1 mustbe ordered before loadsin the read-only critical section \n(line 5), and these loads must be ordered before the load of the lock variable in line 6. The above ordering \nrequirements are needed for guaranteeing that mutual atomicity of critical sections protected by the \nsame lock. The Java Memory Model [9] implies certain ordering require\u00adments related to locks. Relevant \nto SOLERO are the requirements that (a) loads and stores that precede a critical section in program order \nmust notbe reordered after the correspondingexit section,(b) loads and stores that follow a critical \nsection in program order must not be reordered before the corresponding entry section, and (c) all critical \nsections for the same lock must have a total serial order. In order to conform to the above mentioned \nJava lock ordering semantics, loads and stores that precede read-only critical sections must be ordered \nbefore loads inside the critical section, and the latter loads must be ordered before loads and stores \nthat follow the critical section. On the PowerPC architecture, its weak memory model requires memory-fence \ninstructions to enforce the above orderings. On the X86 architecture and on SPARC architectures with \nTSO (Total Store Order) memory model, no explicit fences are needed, except for ordering stores that \nprecede a read-only critical sections before the loads inside the critical sections, if the lock acquisition \nis elided.  4. Experimental Results 4.1 Experimental Environment We used a 16-way 4.7GHz Power6 multiprocessor \nsystem for per\u00adformance evaluation. All of the performance measurements were done on a .xed hardware \ncon.guration where sixteen processors are active. When we see the scalability or the single-thread perfor\u00admance, \nwe changed the number of the software (Java) threads.We implemented SOLERO in a 64-bit commercial JVM \nwhere each object has a 64-bit lock variable. In the conventional lock imple\u00admentation, a .at-lock variable \nconsists of: one in.ation bit, one FLC bit, six recursion bits, and 56-bit thread id .eld. In SOLERO, \na .at-lock variable consists of: one in.ation bit, one FLC bit, one lock bit, .ve recursion bits, and \nthe 56-bit counter or thread id .eld. We did not take into account for the wrap around of the counter \nbe\u00adcause the 56-bit counter is impossible to wrap around in less than 68 years, assuming the fastest \nrate for acquiring and releasing the lock. As mentioned in Section 3.4, we need to choose the appropriate \nPowerPC memory-fence instructions for SOLERO. At the begin\u00adning of a writing critical section, we inserted \nthe lwsync instruc\u00adtion [16] immediately after the atomic update to the lock variable (line6in Figure6).Atthebeginningofa \nread-only critical section, we inserted the sync instruction immediately after the store of the lock \nvalue to the local lock variable. Since both the lwsync and sync instructions are more expensive than \nthe isync instruction which is inserted at the beginning of a critical section in the conven\u00adtional lock \nimplementation, SOLERO on the PowerPC architecture has a larger overhead of memory ordering than the \nconventional lock implementation. However, read-only critical sections avoid the overheads of atomic \ninstructions. We used SPECjbb2005 [15], the da-capo benchmarks [2], and the following three micro-benchmarks \nfor performance evaluation: Empty: This executes an empty synchronized block iteratively.  HashMap: \nThis accesses a single java.util.HashMap object in a synchronized block. The number of entries is 1K. \n TreeMap: This accesses a single java.util.TreeMap object in a synchronized block. The number of entries \nis 1K.  We used the version 9.10 of the da-capo benchmarks to evaluate the performance of SOLERO with \nthe four multi-thread applications: 1) h2, 2) tomcat, 3) tradebeans, and 4) tradesoap. We used the an\u00adnotation \nto specify a read-only synchronized block for the methods which call the get methods of the HashMap andTreeMap \nclasses. In SPECjbb2005 and the da-capo benchmarks, we relied on the JIT compiler to .nd read-only synchronized \nblocks without using the annotation.Table1 shows the lock statistics of each benchmark. We compared the \nfollowing three lock implementations. Lock: The conventional lock implementation used by synchro\u00adnized \nblocks  RWLock: The read-write lock in java.util.concurrent package  SOLERO: Our lock implementation \n  We manually replaced synchronized blocks with read-write locks in three micro-benchmarks. The read \nmode is applied for read\u00adonly synchronized blocks such as the synchronized block to get an object from \na java.util.HashMap object. We ran each benchmark .ve times on each lock implementation and calculated \nthe average throughput. On each run, the throughput is continuously measured .ve times and the best score \nis used to calculate the average throughput. The reason why we used the best Table 1. Lock statistics \n Benchmarks Lock frequency Ratio of read\u00ad (millions locks per sec) only locks (%) Empty 12.8 100.0 HashMap \n5.4 100.0 (0% writes) HashMap 5.3 95.0 (5% writes) TreeMap 1.7 100.0 (0% writes) TreeMap 1.6 95.0 (5% \nwrites) SPECjbb2005 6.2 53.6 h2 2.0 0.0 tomcat 7.3 3.7 tradebeans 1.7 0.3 trradesoap 3.4 11.4 Normalized \nexecution time to Lock 3.5 3 2.5 2 1.5 1 0.5 0 Lock RWLock SOLERO Unelided-WeakBarrier-SOLERO SOLERO \nscore is to exclude the impact of the JIT compilation time from the performance evaluation.  4.2 Experimental \nResults Figure 10 shows the lock overhead of each lock implementation on Empty. Of course, the empty \nsynchronized block is treated as read\u00adonly.For SOLERO, we measured theexecution time when we did not \nelide locks for read-only critical sections (Unelided-SOLERO), and when we used the same memory-fence \ninstructions as the conventional lock implementation, in other words, we used the incorrect memory-fence \ninstructions (WeakBarrier-SOLERO). As shown in this .gure, SOLERO reduces the lock overhead by 50% compared \nto the conventional lock implementation though it pays a signi.cant overhead for memory ordering. SOLERO \ndegrades the performance by 1.4% compared to the conventional lock when it does not elide locks in the \nempty synchronized block. Note that 1.4% is the upper bound of the overhead, and the overhead of SOLEROis \nmuch smaller in more realistic cases as shown below. Figure 11 shows the single-thread performance of \neach lock im\u00adplementation. Under the 0% writes (i.e. 100% read-only) con.gu\u00adration of HashMap, SOLERO \nimproves the performance by 7.8% compared to the conventional lock implementation. Under the 5% writes \ncon.guration of HashMap, SOLERO improves the perfor\u00admance by 6.4%. In SPECjbb2005, SOLERO improves the \nperfor\u00admance by 4.2%. In contrast, SOLERO has little performance im\u00adprovement in TreeMap. This is because \nTreeMap has a lower lock frequencythanthe othertwo benchmarksasshowninTable1.Inall of the micro-benchmarks, \nread-write locks substantially underper\u00adform the conventional lock implementation, as they are not inlined \nand involve a level of indirection in accessing lock variables, unlike SOLERO and the conventional Java \nlock implementation. Similarly with the Empty benchmark, we measured the perfor\u00admance of SOLERO in the \nHashMap, TreeMap, and SPECjbb2005 benchmarks without eliding locks and with the incorrect memory\u00adfence \ninstructions though we do not plot the results in Figure 11. In the three benchmarks, the performance \ndegradation of SOLERO compared to the conventional lock implementation is less than 1% when locks are \nnot elided. This is the only disadvantage of SOLERO to the conventional lock implementation. In the HashMap,TreeMap, \nand SPECjbb2005 benchmarks, SOLEROhas 20%, 7%, and 5% overhead for memory ordering respectively. Figure \n12 shows the multi-thread performance of each lock im\u00adplementation in HashMap. Under the 0% writes con.guration \nof HashMap, SOLERO shows almost linear scalability though the other two lock implementations degrade \nthe performance as the number of threads increases. Under the 5% writes con.guration of HashMap, SOLERO \nshows higher performance than the other two lock implementations though it drops the performance when \nthe number of thread is more than two. The reason for the performance degradation is lock contentions \nand failures in the speculative ex\u00adecution of read-only critical sections. Figure 15 shows the ratio \nof thefailuresinthe speculativeexecution.The5% writes con.gura\u00adtion of HashMap shows 23%failures on sixteen \nthreads. Figure 12(c) shows the performance of a .ne-grained version of HashMap. In the .ne-grained version, \nmultiple hash-map objects are prepared, and each hash-map object is accessed through its own lock. In \nthis experiment, the number of the hash-map objects equals to the number of threads. In the .ne-grained \nversion, SOLERO improves the performance until eight threads. Although the other two lock implementations \nalso improve the performance as the number of threads increases, SOLERO has higher performance than the \nother two lock implementations on anynumber of threads. The .ne-grained lock version of HashMap shows \n3% failures on sixteen threads. Figure 13 shows the multi-thread performance of TreeMap. Under the 0% \nwrites con.guration ofTreeMap, SOLERO shows almost linear scalability and higher performance than the \nother two lock implementations. Under the 5% writes con.guration of TreeMap, SOLERO improves the throughput \nuntil eight threads and shows higher performance than the other two lock implemen\u00adtations on any number \nof threads. The failure ratio in TreeMap is 35% on sixteen threads. Figure 14 shows the multi-thread \nperformance of SPECjbb2005. SPECjbb2005 is known to be highly scalable with minimal lock contention, \nas such it offered little opportunity for SOLERO to show its potential for higher scalability than the \nother lock im\u00adplementations. However, the single-thread advantage of SOLERO over the other lock implementations \ncarried over proportionally to higher number of threads, yielding the highest throughput across the various \nnumbers of threads. SPECjbb2005 shows almost 0% failures on anynumber of threads. Finally, we show the \nperformance of the da-capo benchmarks in Figure 16. Unfortunately, we could not see a major difference \nbetween the conventional lock implementation and SOLERO. This is because the ratio of the read-only synchronized \nblocks is low compared to the other benchmarks as shown in Table 1. The read\u00adonly ratios of the da-capo \nbenchmarks do not exceed 11% while SPECjbb2005 has 53% read-only ratio. While SOLERO has little performance \nimprovement to the conventional lock implementa\u00ad Relative performance to Lock (%) 120 100 80 60 40 20 \n0  Figure 11. Single-thread performance of HashMap, TreeMap, and SPECjbb2005 (the performance of read-write \nlocks is not measured in SPECjbb2005) tion, its performance degradation is negligible (less than 1%). \nThis indicates that SOLEROhas negligible overheads even in the appli\u00adcations where there are few read-only \ncritical sections. 5. SOLERO Read-Mostly Extension In this section, we present an extension to apply \nSOLERO to criti\u00adcal sections that are likely to be read-onlybut there is some chance that they may involve \nwrites or side effects. In this extension of SOLERO, the JIT compiler identi.es a critical section that \ncontains writes or side effects as read-mostly if the execution of those writes or side effects is rare. \nThe JIT compiler generates the code to elide locks for read-mostly critical sections the same as for \nread-only critical sections. In addition, it inserts the code to acquire the lock before each write or \nside effect within read-mostly critical sections. Figure 17 shows the pseudocode for a read-mostly critical \nsec\u00adtion with the capability to acquire the lock if a write or a side effect is encountered. Before a \nthread executes writes or actions with side effects, it .rst tries to acquire the lock using the local \nlock value read at the beginning of the critical section. The CAS for lock ac\u00adquisition uses the local \nlock value in order to guarantee that all the prior reads in the so-far read-only critical section are \nconsistent. If the lock acquisition succeeds or the thread already holds the lock, then the thread can \ncontinue the critical section without returning to its beginning. If the thread fails to acquire the \nlock using the local lock value and it does not already hold the lock, then it is unsafe to proceed with \nthe remainder of the critical section. The thread calls solero_slow_enter to acquire the lock. It then \nre-executes the critical section,but this time while holding the lock. 6. RelatedWork The seqlock mechanism \nused in the Linuxkernel is the algorithmic basis of our SOLERO implementation. It is applied in limited \ncases where a single variable is read. The mechanism is attributed to Stephen Hemminger. We are not aware \nof prior work in the literature that studies the design or performance of seqlocks. In this paper, we \nexpand the core seqlock mechanism by de\u00adveloping it to be applicable to general critical section that \naccess multiple locations. We describe our design for a Java implemen\u00adtation that we prototyped in a \ncommercial JVM. We evaluate the performance of that design using standard benchmarks and data structures. \n David Dice [4] discusses using sequential locks in Java at the programmer level, using Java constructs \nand concurrency library. The SOLEROimplementation is at the JVM/JIT level, with no need for Java program \nchanges. Many optimizations have been proposed to reduce the locking overhead for Java. One of the major \noptimizations is bi-modal locking which reduces the overhead by avoiding the use of OS monitors [1, 11]. \nA three-tier locking scheme can be used with bi-modal locking to further reduce the locking overhead \n[7]. As described in this paper, these lock optimizations can co-exist with SOLERO. Eliminating atomic \noperations such as Compare-And-Swap or the pair Load-Linked and Store-Conditional on objects that turn \nout to be thread private is also popular to reduce the locking over\u00adhead [8, 14]. This kind of technique \nis complementary to the SOLERO mechanism. The former mechanisms are useful when locks turn out to be \nused by a single thread, and thus are unnec\u00adessary. While SOLERO is useful when locks are indeed shared \nby multiple threads, but the critical sections under these locks are mostly read-only. In the absence \nof employing lock elimination mechanisms for private locks, the SOLERO mechanism can be useful in partially \nreducing the unnecessary lock overheads if some of the critical sections are read-only. There are some \ntechniques to elide locks based on transactional memory (TM) runtime systems or TM-like runtime systems \nwhich are implemented in hardware or software [5, 12, 13, 18]. These lock elision techniques allow a \nthread to enter a critical section specu\u00adlatively without acquiring the lock. The runtime system forces \na thread to rollback to the beginning of the critical section when the thread causes data con.icts or \nencounters an operation that cannot be executed speculatively, such as I/O. After rollback, the thread \ncan fallback to conventional locking and execute the critical sec\u00adtion non-speculatively. The existing \nlock elision techniques require memory access tracking within critical sections for data con.ict detection. \nAl\u00adthough the overhead of memory access tracking is very small when the runtime system is implemented \nin hardware, currently, no such hardware is available. If the runtime system is implemented in soft\u00adware, \nthe large overhead is caused by memory access tracking. Since SOLEROdoes not need memory access tracking \nwithin crit\u00adical sections, it does not require any extra hardware support and its overhead is very small \nthough it has a smaller coverage of spec\u00ad 18 16 14 12 Figure 16. Performance of da-capo benchmarks \n SOLERO failure ratio (%) Normalized throughput Normalized throughputNormalized throughput Normalized \nexecution time to Lock Normalized throughputNormalized throughputNormalized throughput 10 8 0 0 4 8 12 \n16 # threads (a) 0% writes 2.5 2 1.5 1 0.5 0 (b) 5% writes 0 4 8 12 16 Figure 13. Multi-thread performance \nofTreeMap # threads (a) 0% writes 16  14 12 10 8 6 4 2 0 0 4 8 12 16 # threads Figure 14. Multi-thread \nperformance of SPECjbb2005 (b) 5% writes 40 35 30 25 20 15 10 5 0 0 4 8 12 16 # threads (c)5% writes \n(.ne-grained version) Figure 15. Ratio of failures in the speculative execution of read-Figure 12. Multi-thread \nperformance of HashMap (the .ne\u00adonly synchronized blocks in SOLERO grained version uses multiple hash-map \nobjects to reduce lock con\u00adtentions) 1: v = obj->lock; 2: if((v&#38;0x7)!=0) 3: v = solero_slow_read_enter(obj); \n 4: while (true) { 5: /* Read-mostly critical section */ 6: ... 7: /* Write encountered. Must hold \nlock */ 8: if (CAS(&#38;obj->lock,v,thread_id+LOCK_BIT) || 9: hold_lock(obj)) { 10: /* Now holding \nlock -Safe to write */ 11: }else{ 12: /* Not holding lock -Slow acquire */ 13: v = solero_slow_enter(obj); \n 14: continue; /* Re-execute critical section */ 15: } 16: /* Rest of critical section and exit code \n*/ 17: ... 18: } Figure 17. Lock acquisition within a read-mostly critical section ulatively executed \ncritical sections than transactional lock elision techniques. 7. Conclusion In this paper we presented \nSOLERO a Java implementation of a lock elision mechanism that avoids writing to lock variables when used \nfor read-only critical sections. SOLERO provides full lock functionality, including reentrance, bi-modality, \nand multi-tier con\u00adtention management, and hence it is suitable for replacement of conventional locks, \nwithout requiring source code modi.cation.We implemented SOLERO in a commercial JVM, and evaluated its \nperformance in comparison to the conventional lock implementa\u00adtion of synchronized blocks (i.e., mutual \nexclusion locks) and read\u00adwrite locks. Our performance results indicate that SOLERO consistently outperforms \nconventional lock implementation and read-write locks on a single thread and multiple threads, and under \nhigh read concurrency. On the SPECjbb2005 benchmark, SOLERO outper\u00adforms the conventional lock implementation \nby 3-5% on single and multiple threads. The results using the HashMap andTreeMap benchmarks show that \nSOLEROoutperforms the conventional lock implementation and read-write locks by substantial multiples \non multi-threads. However, SOLERO by itself does not reduce write contention. Therefore, under high write \ncontention, .ne-grained designs may be useful. If the .ne-grained designs are lock-based, there is no \ninherent impediment to applying SOLERO to .ne-grain locks. The only disadvantage of SOLERO is the overhead \nof ac\u00adquiring and releasing locks. However, the overhead is less than 1% in all of the benchmarks. Acknowledgments \nWe are grateful to the JIT compiler development team at IBM Toronto for advising us on our paper and \nfor participating in helpful discussions. We also thank the members of our group at the IBM Research \n-Tokyo and the IBM T. J. Watson Research Center for advising us about the paper. References [1] D. F. \nBacon, R. Konuru, C. Murthy, and M. Serrano. Thin locks: Featherweight synchronization for java. In PLDI \n98: Proceedings of the ACM SIGPLAN 1998 conference on Programming language design and implementation, \npages 258 268,June 1998. [2] S. M. Blackburn, R. Garner, C. Hoffman, A. M. Khan, K. S. McKinley, R. Bentzur, \nA. Diwan, D. Feinberg, D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump, H. Lee, J. E. B. Moss, \nA. Phansalkar, D. Stefanovi\u00b4c, T. VanDrunen, D. von Dincklage, and B. Wiedermann. The DaCapo benchmarks: \nJava benchmarking development and analysis. In OOPSLA 06: Proceedings of the 21st annual ACM SIGPLAN \nconference on Object-Oriented Programing, Systems, Languages, and Applications, pages 169 190, Oct. 2006. \n[3]P.-J. Courtois,F.Heymans, andD.L.Parnas. Concurrentcontrol with readers and writers . Commun.ACM, \n14(10):667 668, Oct. 1971. [4] D. Dice. Seqlocks in java -readers shouldn t write synchronization metadata. \nDavid Dice sWeblog, Sept. 2006. [5] D. Dice, Y. Lev, M. Moir, and D. Nussbaum. Early experience with \na commercial hardware transactional memory implementation. In ASPLOS 09: Proceedings of the 14th international \nconference on Architectural support for programming languages and operating systems, pages 157 168, Mar. \n2009. [6] E. W. Dijkstra. Solution of a problem in concurrent programming control. Commun.ACM, 8(9):569, \nSept. 1965. [7] R. Dimpsey, R. Arora, and K. Kuiper. Java server performance: A casestudyofbuildingef.cient,scalable \njvms. IBM Systems Journal, 39(1):151 174, 2000. [8] K. Kawachiya, A. Koseki, and T. Onodera. Lock reservation: \nJava locks can mostly do without atomic operations. In OOPSLA 02: Proceedings of the 17th ACM SIGPLAN \nconference on Object\u00adoriented programming, systems, languages, and applications, pages 130 141, 2002. \n[9] J. Manson, W. Pugh, and S. V. Adve. The java memory model. In POPL 05: Proceedings of the 32nd ACM \nSIGPLAN-SIGCAT symposium on Principles of programming languages, pages 378 391, 2005. [10] J. M. Crummey \nand M. L. Scott. Scalable reader-writer synchroniza\u00adtion for shared-memory multiprocessors. In PPoPP \n91: Proceedings of the Third ACM Symposium on Principles and Practice of Parallel Programming, pages \n106 113, Apr. 1991. [11] T. Onodera and K. Kawachiya. A study of locking objects with bimodal .elds. \nIn OOPSLA 99: Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, \nlanguages, and applications, pages 223 237, 1999. [12] R. Rajwar and J. R. Goodman. Speculative lock \nelision: enabling highly concurrent multithreaded execution. In Proceedings of the 34th annual ACM/IEEE \ninternational symposium on Microarchitecture, pages 294 305, Nov. 2001. [13] A. Roy, S. Hand, and T. \nHarris. A runtime system for software lock elision. In Proceedings of the 4th ACM European conference \non Computer systems, pages 261 274, Apr. 2009. [14] K. Russel and D. Detlefs. Eliminating synchronization-related \natomic operations with biased locking and bulk locking. In OOPSLA 06: Proceedings of the 21st annualACM \nSIGPLAN conference on Object\u00adoriented programming systems, languages, and applications, pages 263 272, \n2006. [15] SPECjbb2005. http://www.spec.org/jbb2005/. [16] J. Wetzel, E. Siha, C. May, B. Frey, J. Furukawa, \nand G. Fraizier. BookII:PowerPCVirtual Environment Architecture. [17] P. Wu, M. M. Michael, C. von Praun, \nT. Nakaike, R. Bordawekar, H. W. Cain, C. Cascaval, S. Chatterjee, S. Chiras, R. Hou, M. F. Mergen, X. \nShen, M.F. Spear, H.Wang, and K.Wang. Compiler and runtime techniques for software transactional memory \noptimization. Concurrency and Computation: Practice and Experience, 21(1):7 23, Jan. 2009. [18] L. Ziarek, \nA. Welc, A.-R. Adl-Tabatabai, V. Menon, T. Shpeisman, and S. Jagannathan. A uniform transactional execution \nenvironment for java. In ECOOP 08: Proceedings of the 22nd European conference on Object-Oriented Programming, \npages 129 154,July 2008.   \n\t\t\t", "proc_id": "1806596", "abstract": "<p>It is not uncommon in parallel workloads to encounter shared data structures with read-mostly access patterns, where operations that update data are infrequent and most operations are read-only. Typically, data consistency is guaranteed using mutual exclusion or read-write locks. The cost of atomic update of lock variables result in high overheads and high cache coherence traffic under active sharing, thus slowing down single thread performance and limiting scalability.</p> <p>In this paper, we present <i>SOLERO (Software Optimistic Lock Elision for Read-Only critical sections)</i>, a new lock implementation called for optimizing read-only critical sections in Java based on sequential locks. SOLERO is compatible with the conventional lock implementation of Java. However, unlike the conventional implementation, only critical sections that may write data or have side effects need to update lock variables, while read-only critical sections need only read lock variables without writing them. Each writing critical section changes the lock value to a new value. Hence, a read-only critical section is guaranteed to be consistent if the lock is free and its value does not change from the beginning to the end of the read-only critical section.</p> <p>Using Java workloads including SPECjbb2005 and the HashMap and TreeMap Java classes, we evaluate the performance impact of applying SOLERO to read-mostly locks. Our experimental results show performance improvements across the board, often substantial, in both single thread speed and scalability over the conventional lock implementation (mutual exclusion) and read-write locks. SOLERO improves the performance of SPECjbb2005 by 3-5% on single and multiple threads. The results using the HashMap and TreeMap benchmarks show that SOLERO outperforms the conventional lock implementation and read-write locks by substantial multiples on multi-threads.</p>", "authors": [{"name": "Takuya Nakaike", "author_profile_id": "81413601085", "affiliation": "IBM Japan, Ltd., Yamato-shi, Kanagawa-ken, Japan", "person_id": "P2184561", "email_address": "", "orcid_id": ""}, {"name": "Maged M. Michael", "author_profile_id": "81332515587", "affiliation": "IBM Corporation, Yorktown, NY, USA", "person_id": "P2184562", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1806596.1806627", "year": "2010", "article_id": "1806627", "conference": "PLDI", "title": "Lock elision for read-only critical sections in Java", "url": "http://dl.acm.org/citation.cfm?id=1806627"}