{"article_publication_date": "06-05-2010", "fulltext": "\n An Analysis of the Dynamic Behavior of JavaScript Programs Gregor Richards Sylvain Lebresne Brian Burg \nJan Vitek S3 Lab, Department of Computer Science, Purdue University, West Lafayette, IN {gkrichar,slebresn,bburg,jv}@cs.purdue.edu \nAbstract The JavaScript programming language is widely used for web programming and, increasingly, for \ngeneral purpose computing. As such, improving the correctness, security and performance of JavaScript \napplications has been the driving force for research in type systems, static analysis and compiler techniques \nfor this lan\u00adguage. Many of these techniques aim to reign in some of the most dynamic features of the \nlanguage, yet little seems to be known about how programmers actually utilize the language or these fea\u00adtures. \nIn this paper we perform an empirical study of the dynamic behavior of a corpus of widely-used JavaScript \nprograms, and an\u00adalyze how and why the dynamic features are used. We report on the degree of dynamism \nthat is exhibited by these JavaScript pro\u00adgrams and compare that with assumptions commonly made in the \nliterature and accepted industry benchmark suites. Categories and Subject Descriptors D.2.8 [Software \nEngineer\u00ading]: Metrics; D.3.3 [Programming Languages]: Language Con\u00adstructs and Features General Terms \nExperimentation, Languages, Measurement Keywords Dynamic Behavior, Execution Tracing, Dynamic Met\u00adrics, \nProgram Analysis, JavaScript 1. Introduction JavaScript1 is an object-oriented language designed in 1995 \nby Brendan Eich at Netscape to allow non-programmers to extend web sites with client-side executable \ncode. Unlike more traditional languages such as Java, C# or even Smalltalk, it does not have classes, \nand does not encourage encapsulation or even structured programming. Instead JavaScript strives to maximize \n.exibility. JavaScript s success is undeniable. As a data point, it is used by 97 out of the web s 100 \nmost popular sites.2 The language is also 1 The language is standardized as ECMAScript [16]. Its various \ndialects (and their extensions) are referred to by names such as JScript, Ac\u00adtionScript, and JavaScript \n(of.cially, Mozilla s implementation of EC-MAScript). In this paper, we refer to all implementations \ncollectively as JavaScript. 2 http://www.alexa.com 2 http://code.google.com/closure/compiler/ 3http://code.google.com/webtoolkit/ \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n10, June 5 10, 2010, Toronto, Ontario, Canada. becoming a general purpose computing platform with of.ce \nappli\u00adcations, browsers and development environments [15] being devel\u00adoped in JavaScript. It has been \ndubbed the assembly language of the Internet and is targeted by code generators from the likes of Java2,3 \nand Scheme [20]. In response to this success, JavaScript has started to garner academic attention and \nrespect. Researchers have focused on three main problems: security, correctness and performance. Security \nis arguably JavaScript s most pressing prob\u00adlem: a number of attacks have been discovered that exploit \nthe lan\u00adguage s dynamism (mostly the ability to access and modify shared objects and to inject code via \neval). Researchers have proposed ap\u00adproaches that marry static analysis and runtime monitoring to pre\u00advent \na subset of known attacks [6, 12, 21, 27, 26]. Another strand of research has tried to investigate how \nto provide better tools for de\u00advelopers for catching errors early. Being a weakly typed language with \nno type declarations and only run-time checking of calls and .eld accesses, it is natural to try to provide \na static type system for JavaScript [2, 1, 3, 24, 13]. Finally, after many years of neglect, modern implementations \nof JavaScript have started to appear which use state of the art just-in-time compilation techniques [10]. \nIn comparison to other mainstream object-oriented languages, JavaScript stakes a rather extreme position \nin the spectrum of dy\u00adnamicity. Everything can be modi.ed, from the .elds and methods of an object to \nits parents. This presents a challenge to static analy\u00adsis techniques, to type systems, and to compiler \noptimizations, all of which leverage the parts of a program that are .xed to make guar\u00adantees about that \nprogram s run-time behavior. If nothing is .xed then there is very little that traditional techniques \ncan do. To cope with this, researchers have considered subsets of JavaScript based on reasonable (or \nsane) assumptions about common behavioral patterns of programs. Similarly, JavaScript implementations \nare of\u00adten compared using benchmarks which were ported from other lan\u00adguages and are relatively simple. \nWhat if these assumptions were wrong and the benchmarks were not representative of actual work\u00adloads? \nThen it could well be the case that type systems and static analysis techniques developed for JavaScript \nhave little or no appli\u00adcability to real-world programs, and that compiler writers would be steered towards \nimplementing optimizations that make unrealistic benchmark code run fast but have little effect in the \nreal world. This paper sets out to characterize JavaScript program behav\u00adior by analyzing execution traces \nrecorded from a large corpus of real-world programs. To obtain those traces we have instrumented a popular \nweb browser and interacted with 103 web sites. For each site multiple traces were recorded. These traces \nwere then analyzed to produce behavioral data about the programs. Source code cap\u00adtured when the programs \nwere loaded was analyzed to yield static metrics. In addition to web sites, we analyzed three widely \nused benchmark suites as well as several applications. We report both on traditional program metrics \nas well as metrics that are more indica\u00adtive of the degree of dynamism exhibited by JavaScript programs \nin the wild. Copyright c &#38;#169; 2010 ACM 978-1-4503-0019-3/10/06. . . $10.00  2. Motivation and \nRelated Work The original impetus for our interest in JavaScript was to assess the feasibility of a static \ntype system able to successfully and mean\u00adingfully type check existing JavaScript programs. Other dynamic \nlanguages such as Scheme have had recent success introducing gradual typing systems [25], but they have \nstopped short of type checking object-oriented extensions (implemented by macros in Scheme). For JavaScript, \nAnderson et al. proposed a type system with de.nite and potential types [2, 1, 3], while Heidegger and \nThiemann following up on some of their earlier work [24, 18] pro\u00adpose recency types in [13], and Furr \net al. proposed a related system for DRuby [9]. While all of these type systems acknowledge some minor \nsimpli.cations to the target language, they rely on fairly sim\u00adilar assumptions. For instance, Thiemann \nwrites: Usually, no fur\u00adther properties are de.ned after the initialization and the type of the properties \nrarely changes. This suggests that object types are stable at run-time and can be described using, e.g., \ntraditional row\u00adtypes. In fact all the proposals take the view that an object s type should be the sum \nof all possible .elds and methods that it could contain, with some of them being unde.ned; they differ \nmostly on how to perform strong updates to avoid polluting all properties with unde.ned values. Interestingly, \nlanguage implementors make sim\u00adilar assumptions. For instance, Google s V8 JavaScript engine is reported \nto optimistically associate classes to objects on the as\u00adsumption that their shape will not change too \nmuch, though with a fallback case for highly dynamic objects 3. This design is simi\u00adlar to implementations \nof one of JavaScript s in.uences, Self [5], and is expected to work for the same reasons. As the above \nmen\u00adtioned hypothesis is crucial for the applicability and usefulness of the results, it deserves careful \nstudy. In fact, we have found a num\u00adber of similar assumptions in the literature which we list below. \nWe .rst review the salient features of the language to provide suf.cient background for readers unfamiliar \nwith JavaScript. JavaScript in a Nutshell. JavaScript is an imperative, object\u00adoriented language with \nJava-like syntax, but unlike Java it employs a prototype-based object system. An object is a set of properties, \na mutable map from strings to values. A property that evaluates to a closure and is called using the \ncontext of its parent object plays the role of a method in Java. Each object has prototype .eld which \nrefers to another object. Property lookup involves searching the current object, then its parent, and \nits parent until the property is found. The JavaScript object system is extremely .exible. As a result, \nit is dif.cult to constrain the behavior of any given object. For example, it is possible to modify the \ncontents of any prototype at any time or to replace a prototype .eld altogether. In JavaScript, any function \ncan be a constructor for a class of objects, and contains a prototype .eld, initially referencing an \nempty object. The new keyword creates an object based on the prototype .eld and using the function as \na constructor. The semantics of new is simple, but unusual: .rst, an empty object is created, with its \nparent set to the object referenced by the prototype .eld of the constructor function; second, the constructor \nis called, with this bound to the new object. The object referenced by the keyword this is not determined \nby lexical scoping, but instead by the caller; .nally the return value from the constructor (if any) \nis discarded, and the new expression evaluates to this. Common Assumptions about the dynamic behavior \nof JavaScript. We proceed to enumerate the explicit and implicit assumptions that are commonly found \nin the literature and in implementations. 1. The prototype hierarchy is invariant. The assumption that \nthe prototype hierarchy does not change after an object is created 3 As reported in a presentation by \nKevin Millikin at Google Developer Day 2008. is so central to the type system work that [2, 3] chose \nto not even model prototypes. Research on static analysis typically does not mention prototype updates \n[6, 12, 24, 17]. Yet, any modi.cation to the prototype hierarchy can potentially impact the control .ow \ngraph of the application just as well as the types of affected objects. 2. Properties are added at object \ninitialization. Folklore holds that there is something akin to an initialization phase in dy\u00adnamic languages \nwhere most of the dynamic activity occurs and after which the application is mostly static [14]. For \nJavaScript this is embodied by the assumption that most changes to the .elds and methods of objects occur \nat initialization, and thus that it is reasonable to assign an almost complete type to ob\u00adjects at creation, \nleaving a small number of properties as poten\u00adtial [3, 24, 13, 2]. 3. Properties are rarely deleted. \nRemoval of methods or .elds is dif.cult to accommodate in a type system as it permits non\u00admonotonic evolution \nof types that breaks subtyping guarantees usually enforced in modern typed languages. If deletion is \nan exceptional occurrence (and one that can be predicted), one could use potential types for properties \nthat may be deleted in the future. But, this would reduce the bene.ts of having a type system in the \n.rst place, which is probably why related work chooses to forbid it [3, 24, 18, 2]. Static analysis approaches \nare usually a bit more tolerant to imprecision and can handle deletes, but we have not found any explanation \nof its handling in existing data .ow analysis techniques ([12, 6, 17]). 4. The use of eval is infrequent \nand does not affect seman\u00adtics. The use of eval on arbitrary strings has the potential of invalidating \nany results obtained by static analysis or static type checking. Thus many works simply ignore it [3, \n17, 24, 2], while other assume that uses are either trivial or related to de\u00adserialization using the \nJSON protocol [12, 18]. 5. Declared function signatures are indicative of types. Type systems for JavaScript \ntypically assume that the declared arity of a function is representative of the way it will be invoked \n[3, 24, 2]. This is not necessarily the case because JavaScript allows calls with different arities. \n 6. Program size is modest. Some papers justify very expen\u00adsive analyses with the explicit assumption \nthat handwritten JavaScript programs are small [18], and others implicitly rely on this as they present \nanalyses which would not scale to large systems [17, 12]. 7. Call-site dynamism is low. Some JavaScript \nimplementations such as Google V8 rely on well-known implementation tech\u00adniques to optimize JavaScript \nprograms such as creating classes (in the Java sense) for objects and inline caches. These tech\u00adniques \nwill lead to good performance only if the behavior of JavaScript is broadly similar to that of other \nobject-oriented lan\u00adguages. 8. Execution time is dominated by hot loops. Trace-based Just\u00adin-time compilers \nsuch as TraceMonkey [10] rely on the tra\u00additional assumption that execution time is dominated by small \nloops. 9. Industry benchmarks are representative of JavaScript work\u00adloads. Standard benchmark suites \nsuch as SunSpider, Dro\u00admaeo and V8, are used to tune and compare JavaScript im\u00adplementations and to evaluate \nthe accuracy of static analysis techniques [18]. But conclusions obtained from use of those benchmarks \nare only meaningful if they accurately represent the range of JavaScript workloads in the wild.  The \ngoal of this paper is to provide supporting evidence to either con.rm or invalidate these assumptions. \nWe are not disputing the validity of previous research, as even if a couple of the above assumptions \nproved to be unfounded, previous work can still serve as a useful starting point for handling full JavaScript. \nBut we do want to highlight limitations to widespread adoption of existing techniques and point to challenges \nthat should be addressed in future research. Related Work. Until now, to the best of our knowledge, there \nhas been no study of the dynamic behavior of JavaScript programs of comparable depth or breadth. Ratanaworabhan \net al. have per\u00adformed a similar study concurrently to our own, and its results are similar to ours [22]. \nThere have been studies of JavaScript s dy\u00adnamic behavior as it applies to security [28] [8], but the \nbehaviors studied were restricted to those particularly relevant to security. We conducted a small scale \nstudy of JavaScript and reported prelimi\u00adnary results in [19], and those results are consistent with \nthe new results presented here. Holkner and Harland [14] have conducted a study of the use of dynamic \nfeatures (addition and deletion of .elds and methods) in the Python programming language. Their study \nfocused on a smaller set of programs and concluded that there is a clear phase distinction. In their \ncorpus dynamic features occur mostly in the initialization phase of programs and less so during the main \ncomputation. Our results suggest that JavaScript is more dynamic than Python in practice. There are many \nstudies of the runtime use of selected features of object-oriented languages. For example, Garret et \nal. reported on the dynamism of message sends in Self [11], Calder et al. characterized the difference \nof between C and C++ programs in [4], and Temporo et al. studied the usage of inheritance in Java in \n[23]. These previous papers study in great de\u00adtail one particular aspect of each language. In this particular \nwork, we strive for an overview of JavaScript, and leave detailed analysis for future work. Finally, \nwe were inspired by the work of Dufour et al. [7] and their rigorous framework for discussing runtime \nmetrics for Java. 3. Tracing and Analysis Infrastructure The tracing infrastructure developed for this \npaper is based on an instrumented version of the WebKit 4 web browser engine inte\u00adgrated into Apple s \nSafari browser. While there are standalone in\u00adterpreters available, they would not be able to deal with \nthe mix\u00adture of DOM and AJAX that is commonplace in most JavaScript\u00adenabled sites. For .exibility, analysis \nis performed of.ine. Our in\u00adstrumented browser records a trace containing most operations per\u00adformed \nby the interpreter (reads, writes, deletes, calls, de.nes, etc.) as well as events for garbage collection \nand source .le loads. In\u00advocations to eval trigger an event similar to the one for source .le loads, \nand the evaluated string is saved and traced like any other part of the program s execution. Complete \ntraces are compressed and stored to disk. While it does have some performance overhead, our instrumentation \ndoes not cause a noticeable slowdown in inter\u00adactive applications, and none of our users complained about \nper\u00adformance. Traces are analyzed of.ine and the results are stored in a database which is then mined \nfor data. The of.ine trace analy\u00adsis component is essentially an abstract interpreter for the event stream. \nIt is able to replay any trace creating an abstract represen\u00adtation of the heap state of the corresponding \nJavaScript program. The trace analyzer maintains rich and customizable historical in\u00adformation about \nthe program s behavior, such as access histories of each object, call sites and allocation sites, and \nso on. Finally, sev\u00aderal static analyses (eval classi.cation, code size metrics) are per\u00ad 4 webkit.org. \n formed on the recovered source .les using the parsing framework from the Rhino JavaScript compiler.5 \nAs WebKit does not hide its identity to JavaScript code, it is pos\u00adsible for code to exhibit behavior \npeculiar to WebKit. Techniques like this are often used to work around bugs in JavaScript imple\u00admentations \nor browsers. For instance, the Prototype JavaScript li\u00adbrary includes the following check for WebKit. \nWebKit: ua.indexOf( AppleWebKit/ ) > -1, It then uses that check to create different implementations \nof setOpacity, getRootElement, shouldUseXPath and other functions which may exhibit browser-dependent \nbehavior. Although this does introduce a possible bias which is very dif.cult to detect, all other JavaScript \nimplementations are equally detectable and so create comparable bias. We would be interested in comparable \nstudies using other engines, to determine whether the results differ in sig\u00adni.cant ways. 4. Corpus and \nMethodology We have selected 100 web sites based on the Alexa list of most popular sites on the Internet, \nalong with a number of sites of par\u00adticular interest (including 280slides, Lively Kernel, and a medley \nof different web sites visited in a single session). Moreover we also recorded traces for the three main \nindustry benchmark suites (Sun-Spider, Dromaeo, and V8). For each of these sites we asked several of \nour colleagues to interact with the site in a meaningful manner. Each interaction with a different web \nsite was saved in a different trace. Multiple traces for the same site are averaged in our metrics. In \nthe remainder of this paper we focus on the results of 17 sites that we believe to be representative \nof the full range of behaviors and usage of popular libraries. The list of sites we have retained is \nshown in Figure 1. Data for all the web sites, as well as our tracing and analysis framework, database, \nand graphs are available on the project web site6. For each site, we also list publicly-available JavaScript \nlibraries utilized by the site, if any. Sites that use the same libraries tend to have similar coding \nstyles and program structure. It is instructive to see whether similarities also exist in the dynamic \nbehavior of these programs, regardless of different application logic and use cases. 280S Objective-J1 \n280slides.com BING bing.com BLOG blogger.com DIGG jQuery2 digg.com EBAY ebay.com FBOK facebook.com FLKR \nflickr.com GMAP Closure3 maps.google.com GMIL Closure gmail.com GOGL Closure google.com ISHK Prototype4 \nimageshack.us LIVE research.sun.com/projects/lively MECM SproutCore5 me.com TWIT jQuery twitter.com WIKI \nwikipedia.com WORD jQuery wordpress.com YTUB youtube.com ALL Average over 103 sites Figure 1. Selected \nJavaScript-enabled web sites. 1 cappuccino.org 2jquery.com 3code.google.com/closure 4prototypejs.org \n5sproutcore.com 5 www.mozilla.org/rhino. 6 http://www.cs.purdue.edu/homes/gkrichar/js 5. General Program \nMetrics We start with general program metrics that can easily be related to less-dynamic languages. \n5.1 Corpus Size Figure 2 gives the size of the programs loaded by the JavaScript interpreter (including \nstrings passed to eval) in bytes. They range from small, with 280S at only 116 KB, to quite large with \nFBOK at 14 MB, and include all libraries required by the applications. These numbers include the results \nof multiple page loads of the same code, as from the interpreter s stand point there is no guarantee \nthat requesting the same .le twice will return the same result. The second column gives the unique lines \nof code. Notice that code size remains large, topping at 1.7MB for GMIL. The third column gives the length \nof traces in events. This is not directly correlated to the computation time: since most sites using \nJavaScript are interactive in nature, there is unfortunately no meaningful notion of wall-clock time \nthat we can use to gauge computational effort. The number of recorded events vary from thousands to millions. \nNot surprisingly, LIVE, which is a programming environment written in JavaScript, generates the biggest \ntraces, followed by MECM and GMAP, two highly-interactive and data-intensive web sites. The fourth column \nof the .gure gives the number of functions statically occurring in the loaded code including functions \nadded by eval expressions. A few dynamic behaviors are expected to be similar in most languages. For \nexample, the 90/10 rule holds, i.e. 90% of execu\u00adtion time is spent in 10% of functions or less. The \ncolumn labeled Hot gives the number of functions accounting for 90% of execu\u00adtion. This metric is obtained \nby counting the number of trace events recorded in each function, sorting the functions by size and count\u00ading \nthe functions that comprise 90% of the events. ISHK and WORD spend 90% of their time in 1% or less of \nthe program s functions. All other programs range between 6% and 15% hot with a median of 8%. The numbers \nare noticeably higher than the hot percentages for Java programs reported in [7] where the average is \n3%. From the point of view of an optimizing compiler, smaller numbers are better. We also report the \nproportion of live functions, functions that have been executed at least once. This number ranges between \n13% (FLKR) and 61% (GMAP). Due in part to the popularity of large framework-like JavaScript libraries, \nin each site no more than 61% of the de.ned functions are live, with a median of 35% live. The proportion \nof live to loaded code is slightly higher than that observed for Java programs [7], but this is not surprising \nwhen one considers the typical size of JavaScript versus Java libraries and programs.  Site Source size \nUnique source size Trace size Func. count Hot Live 280S 116 KB 81KB 11,931 K 4,293 6.8% 44% BING 815 \nKB 186KB 1,199 K 2,457 6.4% 46% BLOG 1,347 KB 775KB 91 K 5,087 11.5% 16% DIGG 1,106 KB 759KB 1,734 K \n2,957 8.7% 39% EBAY 3,156 KB 1,034KB 2,239 K 10,791 11.7% 31% FBOK 14,904 KB 1,604KB 5,309 K 43,469 5.8% \n19% FLKR 8,862 KB 246KB 490 K 19,149 14.0% 13% GMAP 1,736 KB 833KB 13,125 K 5,146 7.8% 61% GMIL 2,084 \nKB 1,719KB 6,047 K 10,761 7.6% 38% GOGL 2,376 KB 839KB 1,815 K 10,250 15.0% 28% ISHK 915 KB 420KB 5,376 \nK 2,862 0.6% 35% LIVE 1,081 KB 938KB 48,324 K 2,936 7.4% 49% MECM 4,615 KB 646KB 14,084 K 14,401 6.6% \n24% TWIT 837 KB 160KB 2,252 K 2,967 9.2% 45% WIKI 1,009 KB 115KB 53 K 1,226 14.6% 24% WORD 1,386 KB 235KB \n6,403 K 3,118 1.0% 42% YTUB 2,897 KB 562KB 541 K 11,321 13.0% 22% ALL 2,544 KB 790KB 4,151 K 10,625 2.2% \n26% Figure 2. Program sizes. Source size is the total amount of source seen by the interpreter, including \nsource loaded more than once and evals. Unique source size excludes multiple loads of the same source, \nbut still includes eval.  Figure 3 gives the average size of the code functions occurring in the JavaScript \nprogram source. These seem fairly consistent across sites. More interestingly, Figure 4 shows the number \nof events per function, which roughly corresponds to the number of bytecodes evaluated by the interpreter \n(note that some low-level bytecodes such as branches and arithmetic are not recorded in the trace). It \nis interesting to note that the median is fairly high, around 20 events. This suggests that, in contrast \nto Java, there are fewer short methods (e.g. accessors) in JavaScript and thus possibly fewer opportunities \nto bene.t from inlining optimizations.  5.2 Instruction Mix using dot notation (e.g. x.f), hash refers \nto access using indexing notation (e.g. x[s]), indx refers to accesses using indexing notation with a \nnumeric argument. The overall number of calls is high, 20%, as the interpreter does not perform any inlining. \nException handling is rather infrequent with a grand total of 1,328 throws over478milliontraceevents.Therearesomeoutlierssuchas \nISHK, WORD and DIGG where updates are a much smaller proportion of operations (and in.uenced by the sheer \nnumber of objects in these sites), but otherwise the traces are consistent. 5.3 Prototype Chains One \nhigher-level metric is the length of an object s prototype chain, which is the number of prototype objects \nthat may potentially be traversed in order to .nd an object s inherited property. This is roughly comparable \nto metrics of the depth of class hierarchies in class-based languages, such as the Depth of Inheritance \n(DIT) met\u00adric discussed in [23]. Studies of C++ programs mention a maximum DIT of 8 and a median of 1, \nwhereas Smalltalk has a median of 3 and maximum of 10. Figure 6 shows that in all but four sites, the \nmedian prototype chain length is 1. Note that we start our graph at chain length 1, the minimum. All \nobjects except Object.prototype have at least one prototype, which if unspeci.ed, defaults to the Object.prototype. \nThe maximum observed prototype chain length is 10. The majority of sites do not seem to use prototypes \nfor code reuse, but this is possibly explained by the existence of other ways to achieve code reuse in \nJavaScript (i.e., the ability to assign clo\u00adsures directly into a .eld of an object). The programs that \ndo utilize prototypes have similar inheritance properties to Java [23]. 5.4 Object Kinds Figure 7 breaks \ndown the kinds of objects allocated at run-time into a number of categories. There are a number of frequently \nused built-in data types: dates (Date), regular expressions (RegExp), doc\u00adument and layout objects (DOM), \narrays (Array) and runtime er\u00adrors. The remaining objects are separated into four groups: anony\u00admous \nobjects, instances, functions, and prototypes. Anonymous ob\u00adjects are constructed with an object literal \nusing the {...} notation, while instances are constructed by calls of the form new C(...). A function \nobject is created for every function expression eval\u00aduated by the interpreter and a prototype object \nis automatically added to every function in case it is used as a constructor. Over all sites and traces, \narrays account for 31% of objects allocated. Dates and DOM objects come next with 12% and 14%, respec\u00adtively. \nFunctions, prototypes, and instances each account for 10% of the allocated objects, and .nally anonymous \nobjects account for  Figure 6. Prototype chain length. The per-site quartile and max-Figure 7. Kinds \nof allocated objects. The per-site proportion of imum prototype chain lengths. runtime object kinds (averaged \nover multiple traces). 7%. It is interesting to observe that some sites are outliers: for in\u00adstance, \nthe proportion of objects allocated by WORD is dominated by 150K Date objects, and similarly for DIGG7. \nOther sites, LIVE and 280S notably, are more array-intensive. It should be noted that in JavaScript, \nany object can be treated as an array (using the index notation x[3]) but our analysis has shown that \nin practice, only objects created by the built-in Array constructor are routinely ac\u00adcessed by this syntax \nwith numeric indices. 6. Measuring Program Dynamism Different dimensions of dynamism are captured in \nthe execution traces; we discuss them next. 6.1 Call Site Dynamism Dynamic binding is a central feature \nof object-oriented program\u00adming. Many authors have looked at the degree of polymorphism of individual \ncall sites in the program source as a re.ection of how object-oriented a given program is. More pragmatically, \nwhen a call site is known to be monomorphic, i.e. it always invokes the same method, then the dispatching \ncode can be optimized and the call is a candidate for inlining. It is not unusual to be able to identify \nthat over 90% of call sites are monomorphic in Java. To estimate polymorphism in JavaScript, one must \n.rst overcome a complica\u00adtion. A common programming idiom in JavaScript is to create ob\u00adjects inline. \nSo the following code fragment for (...) { ... = { f : function (x) { return x; } }; } will create many \nobjects, that all have a method f(), but each has a different function object bound to f. Naively, one \ncould count calls, x.f(), with different receivers as being polymorphic. We ar\u00adgue that for our purposes \nit is preferable to count a call site as poly\u00admorphic only if it dispatches to a function with a different \nbody, i.e. calls to clones should be considered monomorphic. Figure 8 shows the frequency of clones across \nall traces. While 150,422 functions objects have a distinct body, we found 16 bodies that are shared \nby tens of thousands of function objects, with 1 function body shared by 41,244 objects. GMAP, LIVE and \nMECM each had function bod\u00adies with over 10,000 associated function objects. Figure 9 demonstrates that \nonly 81% of call sites in JavaScript are actually monomorphic; this is an upper bound for what a com\u00adpiler \nor static analysis can hope to identify. In practice, it is likely that there are fewer opportunities \nfor devirtualization and inlining in JavaScript programs than in Java programs. It is noteworthy that \nevery program has at least one megamorphic call site, with a maxi\u00admum of one call site having 1,437 different \ntargets in 280S (which is otherwise perfectly predictable with 99.99% of the call sites be\u00ading monomorphic!). \nBING, FBOK, FLKR, GMIL, GMAP and GOGL each had at least one call site with more than 200 targets. FBOK \nis another outlier with 3.5% of the call sites having 5 or more targets.  6.2 Function Variadicity The \ndeclared arity of a function in JavaScript does not have to be respected by callers. If too few arguments \nare supplied, the value of the remaining arguments will be set to undefined. If more arguments are supplied \nthan expected, the additional arguments are accessible in the arguments variable, which is an array-like \nobject containing all arguments and a reference to the caller and callee. Furthermore, any function can \nbe called with an arbitrary number of arguments and an arbitrary context by using the built-in 7 Upon \nfurther investigation, both sites make extensive use of certain UI/an\u00adimation libraries that allocate \nDate objects for use with callback timers.  Figure 8. Clones. Plots the number of function objects per \nfunc\u00adtion body (x-axis) and the sum of such function bodies (y-axis) over all traces, in log-scale. For \nexample, the second from left point rep\u00adresents the roughly 10,000 function bodies that each have 2 corre\u00adsponding \nfunction objects (and thus, 1 clone). Callsites with N function bodies Site 1 2 3 4 >5 Max 280S 99.9% \n0.0% 0.0% 0.0% 0.0% 1,437 BING 93.6% 4.8% 1.0% 0.3% 0.3% 274 BLOG 95.4% 3.4% 0.5% 0.2% 0.5% 95 DIGG 95.4% \n3.2% 0.4% 0.3% 0.7% 44 EBAY 91.5% 7.1% 0.5% 0.5% 0.5% 143 FBOK 76.3% 14.8% 3.7% 1.7% 3.5% 982 FLKR 81.9% \n13.2% 3.6% 0.5% 0.8% 244 GMAP 98.2% 0.8% 0.4% 0.2% 0.4% 345 GMIL 98.4% 1.2% 0.2% 0.1% 0.2% 800 GOGL 93.1% \n5.5% 0.6% 0.3% 0.6% 1,042 ISHK 90.2% 8.1% 1.0% 0.0% 0.8% 42 LIVE 97.0% 1.7% 0.5% 0.3% 0.5% 115 MECM 94.2% \n4.1% 1.2% 0.2% 0.4% 106 TWIT 89.5% 7.2% 1.7% 0.3% 1.3% 60 WIKI 87.9% 6.7% 1.9% 0.2% 3.2% 32 WORD 86.8% \n7.9% 2.7% 1.9% 0.6% 106 YTUB 83.6% 10.6% 5.4% 0.1% 0.4% 183 All 81.2% 12.1% 3.0% 1.2% 2.5% 1,437 Figure \n9. Call site polymorphism. Number of different function bodies invoked from a particular callsite (averaged \nover multiple traces). call method8. As such, functions may be variadic without being declared as variadic, \nand may have any degree of variadicity. Many built-in functions in JavaScript are variadic: some promi\u00adnent \nexamples include call, Array methods like push, pop, slice, and even the Array constructor itself (which \ninitializes an array with any number of provided arguments). Libraries such as Proto\u00adtype and jQuery \nuse call and apply frequently to control the execu\u00ad 8 The built-in function apply is identical to call \nin utility, but avoids a variadic design by expecting a context and an array argument instead of a context \nand a variable number of arguments. Functions with N distinct arities Site 1 2 3 4 >5 Max 280S 99.3% \n0.6% 0.0% 0.1% 0.1% 9 BING 94.2% 4.9% 0.7% 0.2% 0.0% 4 BLOG 97.1% 2.3% 0.4% 0.2% 0.0% 4 DIGG 92.5% 6.3% \n0.9% 0.3% 0.1% 5 EBAY 95.9% 3.6% 0.3% 0.0% 0.3% 9 FBOK 93.9% 4.8% 0.6% 0.6% 0.1% 6 FLKR 94.2% 4.6% 0.9% \n0.3% 0.0% 4 GMAP 93.4% 5.5% 0.6% 0.3% 0.2% 6 GMIL 95.3% 3.8% 0.6% 0.2% 0.2% 30 GOGL 94.6% 4.3% 0.7% 0.2% \n0.2% 9 ISHK 97.6% 2.3% 0.1% 0.0% 0.0% 3 LIVE 92.7% 6.1% 0.8% 0.3% 0.1% 7 MECM 91.9% 6.5% 0.6% 0.5% 0.5% \n7 TWIT 90.9% 7.4% 1.3% 0.5% 0.0% 4 WIKI 96.7% 3.3% 0.0% 0.0% 0.0% 2 WORD 92.6% 6.6% 0.6% 0.2% 0.0% 4 \nYTUB 98.5% 1.4% 0.1% 0.0% 0.0% 4 All 93.5% 4.8% 0.7% 0.4% 0.6% 30 Figure 10. Function variadicity. Proportion \nof functions used variadically.   tion context when invoking callback closures. These two libraries \n(and many other applications) also use arrays for their internal rep\u00adresentation, which leads to many \nuses of variadic Array-related functions. Depending on the coding style, functions with optional arguments \ncan either declare these optional arguments (leading to some calls of arity less than the declared arity), \nor test for the pres\u00adence of optional (unnamed) arguments in the arguments object. Both coding styles \nare seen in real-world JavaScript programs, so both calls of arity less than and calls of arity greater \nthan that de\u00adclared are often observed. In practice, variadic functions are common and were observed \nin every website analyzed. Figure 10 indicates the portion of func\u00adtion bodies which are called with \ndiffering arities (that is, which are used variadically). In all sites, at least 90% of functions are \nnon\u00advariadic. However, highly-variadic functions, with as many as 30 distinct arities, also occur, and \nfew sites have less than 5% variadic functions.  6.3 Uses of eval One of the most dynamic features of \nJavaScript, and of most dy\u00adnamic languages, is eval which runs arbitrary code provided as a string. A \nkey question for any static approach is how that fea\u00adture is used. Figure 11 shows that all sites use \nit, from a handful of times in ISHK to 428 times for BLOG. Clearly this means that eval can t be discounted. \nThe next question is thus: what do pro\u00adgrams do within eval strings? Figure 11 further breaks down evals \nin three sub-categories. The .rst one (JSON) is a simple form of deserialization. JavaScript Object Notation \n(JSON) is a standard format for exchanging data in the form of strings, the syntax of which coincides \nwith that for JavaScript object literals. Therefore, evaling a JSON string results in the construction \nof a new object. This is a relatively innocuous use of eval and in sites such as FBOK it accounts for \nthe vast majority of calls. The second category ap\u00adpearing in Figure 11 (trivial) is that of trivial \nuses of eval. This is another surprisingly common use in which the argument is an identi.er. Trivial \nuses of eval are essentially a very powerful form of re.ection. Consider if (eval(\"flash\"+i+\"Installed\")==true) \n... Figure 11. Uses of eval. Count of the invocations of eval (aver\u00adaged over multiple traces). Sites \nsorted by total number of invoca\u00adtions, descending. from FLKR, which is called multiple times to perform \na different action depending on what version of Flash is installed, referencing the .eld i in the current \nscope. The remaining invocations of eval (arbitrary code) are by a wide margin the most common, and are \noften complicated code, involving variable assignment, changing functions, etc. It is important to stress \nhere the sheer variety of arbitrary code. The following is a random selection of eval d arbitrary code \nstrings throughout the traces, edited only for readability and privacy: window.dc_AdLinkBold = false \n playlist[204] = new function() { this.album_id = 204; this.album_name = \"[elided]\"; this.album_rating_avg \n= 3.9; this.OA = 1255051920; this.album_rating_user = -0.1; };  this.load = function() { var a = arguments, \nlen = a.length, s = \"\"; for (var i=0; i<len; i++) s += \",a[\" + i + \"]\"; return eval( this._processEvent(\"load\" \n+ s + ) ); }  typeof(l[i].parent.onAfterLoad) == function  objRef.onHandleInteraction=new Function() \n It is clear that eval is signi.cant to the logic of many JavaScript programs, and furthermore that its \nbehavior is neither constrained nor consistent in real programs. Some of these behaviors would be quite \ndif.cult to emulate without eval, as they perform arbitrary changes to the environment of the JavaScript \nprogram. Every possi\u00adble change that eval d code could make would need to be predicted ahead of time \nand implemented in support functions. JavaScript and the DOM provide means other than eval to inject \ncode at runtime, such as the document.write of a script tag, or document.createElement(\"script\");, but \nthese methods are entirely reliant on the browser s document object model. Since our tracing infrastructure \ninstrumented only the JavaScript interpreter and not the rest of the browser, we were unable to detect \nthese other mechanisms. Somewhat related to trivial uses of eval is JavaScript s hashmap syntax for \naccessing .elds. The following two expressions are equivalent: l.map and l[\"map\"]. However, the latter \nmay be used with any string constructed at runtime, even strings that are not syntactically valid identi.er \nnames. Thus it can obscure from the compiler or veri.er which .eld will be accessed. Code review suggests \nthat this occurs when (a) objects are in fact hash maps, (b) libraries, such as Prototype, construct \nclasses based on dynamic descriptions, (c) when the code needs to update an unknown .eld. Traces do not \nindicate any consistency in the behavior and use of hashmap notation. Figure 12 shows, for all objects \nwhich are ever accessed with hashmap notation, for traces using the Prototype library (above) and jQuery \n(below), which style of access is used over time (Direct access is x.f and Hashmap access is x[\"f\"]). \nIf there was a clear separation between hashmaps and normal objects one would expect to see only hashmap \naccesses in the .gure. Instead, the fact that the majority of object accesses are still direct accesses \nsuggests that objects are accessed with a mixture of direct and hash notation. The Prototype library \nuses hashmap notation to build class-like prototypes from abstract descriptions. As expected, sites using \nthis library (e.g., ISHK) have far more hashmap activity during construction than post-construction (the \ndashed line in the graph indicates the end of the object s initialization). Other sites, however, are \nless consistent.  6.4 Object Protocol Dynamism It is often asserted that although properties can be \nadded to objects at any point, they are generally added only during initial construc\u00adtion, and are later \nonly read and updated. The measure of the num\u00adber of .elds/methods that are added or deleted after initialization \nis thus likely to be a good metric of the dynamism of JavaScript pro\u00adgrams. For so-called instance objects, \ni.e. objects that are created by invoking a constructor function, there is a clear sense of what ob\u00adject \ninitialization means: it is the time spent in the constructor. For anonymous objects, things are much \nless clear. Figure 13 shows the accesses performed on constructed objects over the lifespan of the object \nfor two sites: a site showing the expected and desired behav\u00adior (TWIT), and a poorly-behaved site (GOGL). \nTime is measured in events that have the object as a target for a read, add, delete and update operation. \nObject lifespans are normalized to construction time, such that the vertical line in the graph separates \nthe construc\u00adtor from post-constructor accesses. Although it is clear that .eld additions are far more \ncommon during the constructor, most sites add .elds to objects well into their lifespan. Furthermore, \nmany ob\u00adjects have a hump of .eld adds immediately after the constructor ends, suggesting that a heuristic \nto determine when an object is fully constructed, and for that matter when its type is well-de.ned, would \nbe quite dif.cult to .nd. This hump is created by factory methods, inheritance emulation and other patterns \nwhich consis\u00adtently add .elds to an object immediately after it is instantiated. Field deletions are \nuncommon, but occur in FBOK, GMIL, GOGL and YTUB. Another view of the same information is provided in \nFigure 14. Although most sites have far greater protocol-changing accesses (.eld additions and deletions) \nduring construction time, post-construction protocol changes are as many as 10% of accesses on some sites. \nThis is in spite of the fact that Figure 14 extends our heuristic for the termination of initialization \nto after the post\u00adconstruction hump mentioned above.   6.5 Constructor Polymorphism JavaScript s mechanism \nfor constructing objects is more dynamic than that of class-based languages because a constructor is \nsimply a function that initializes .elds programmatically. Contrast the fol\u00adlowing constructor function \nto the declarative style imposed by a class-based language: function C(b) { if(b) this.y = 0; else this.x \n= 0; } The objects returned by new C(true) and new C(false) will have different (in this case, disjoint) \nsets of properties. If one can envi\u00adsion as the set of properties returned by a constructor as a type \n, then it is natural to wonder how many constructors return different types at different times during \nthe execution of a program. Fig\u00adure 15 gives an overview of the polymorphism of constructors over all \ntraces. The majority of constructors always return the same set of properties. But, 573 constructors \nreturn two different sets of properties, and one outlier that returns 246 different types was observed \nin GMIL. This polymorphism can arise for a number of reasons, but a common one is that the dynamism of \nJavaScript allows libraries to abstract away the details of implementing object hierarchies. Of\u00adten, \nthese abstractions end up causing all object construction to use a single static constructor function, \nwhich is called in different con\u00adtexts to create different objects, such as the following constructor \nfunction from the Prototype library. function klass() { this.initialize.apply(this, arguments); } All \nuser objects inherit this constructor, but have distinct initialize methods. As a result, this constructor \nis polymorphic in the objects it creates.  6.6 Constructor Prototype Modi.cation The prototype .eld \nof a constructor de.nes which properties an object created by this constructor will inherit. However, \nthe value of the prototype .eld can be changed, which means that two ob\u00adjects created by the same constructor \nfunction may have different prototypes, and so different APIs. Changing the prototype .eld is generally \ndone before any objects are created from that prototype, and is often done by helper functions such as \nthe following from the Prototype library to mimic subclassing. function subclass() {}; ... if (parent) \n{ subclass.prototype = parent.prototype; klass.prototype = new subclass; parent.subclasses.push(klass); \n} We did not record the number of occurrences this pattern at run\u00adtime, but clearly the possibility \nthat the above code will be executed can not be discounted. 6.7 Changes to the Prototype Chain An object \ns protocol can change over time by adding or deleting .elds from any of its prototypes. Although we found \nthis behavior to be uncommon for user-created types, it is very common for li\u00adbraries to extend the builtin \ntypes of JavaScript, in particular Object and Array. For instance, the Prototype library includes a num\u00adber \nof collection-like classes, but also extends String.prototype and Array.prototype such that they can \nbe used as collections, by adding e.g. the toArray, truncate and strip methods to them, as well as extending \nArray to include all of the de.nitions from Pro\u00adtotype s Enumerable type: Object.extend(Array.prototype, \nEnumerable); Some code uses this ability to change prototypes as a form of modularity. Since prototypes \ncan be modi.ed at any time, features can be implemented in separate parts of the code even if they affect \nthe same type. Again, we do not report runtime occurrences, but observe that this is something that must \nbe accounted for by tools and static type disciplines. 6.8 Object Lifetimes As in many languages, most \nobjects in JavaScript are generally very short-lived. Figure 16 shows the percentiles of object lifetimes \nseen across all traces, in terms of events performed on those objects (we do not record wall clock time \nin traces). 25% of all objects are never used, and even the 90th percentile of objects are alive for \nonly 7 events. This does not include any integers or strings which the runtime never boxes into an object \n(which is to say, numbers and strings that never have .elds accessed). The conclusion is clearly that \nmuch of data is manipulated very infrequently and thus suggest that lazy initialization may be a winning \noptimization. Percentile 25 50 75 85 90 95 97 98 99 100 Events 0 1 3 6 9 14 25 37 74 1,074,322  Figure \n16. Object lifetimes. The longevity of objects in terms of the number of events performed on them. 6.9 \nThe Effects of JavaScript Libraries Many contemporary sites utilize JavaScript libraries; in our corpus, \n44 sites used a publicly-available library, and 7 sites used more than one library simultaneously. The \nmost popular were jQuery and Prototype, appearing on 21 and 9 sites, respectively. Such libraries provide \nsimpli.ed and well-tested coding patterns for problems in\u00adcluding UI widgets, animation, DOM manipulation, \nserialization, asynchronous page loading, and class-based workarounds built on top of JavaScript s prototype-based \nsystem. In general, the presence of a particular library does not imply a major change in the pro\u00adgram \ns dynamic behavior. This is in part due to the large feature sets of most libraries. Prototype offers \nall of the functionality mentioned above (besides UI widgets and animation), and jQuery similarly of\u00adfers \nall of the above (except an implementation of classes ). Be\u00adcause there are many use cases for each library, \nthere are few char\u00adacteristic runtime behaviors exhibited. Exceptions to this tend to be artifacts of \nimplementation techniques speci.c to a library (such as Prototype s dynamic construction of prototype \nobjects, or the dis\u00adproportionate allocation of Date objects by animation libraries). 7. Measuring the \nBehavior of Benchmarks There are several popular benchmark suites used to determine the quality and speed \nof JavaScript implementations. However, using these benchmarks as metrics assumes that they are representative \nof JavaScript programs at large. We looked at three suites in partic\u00adular to determine their relevance: \nSunSpider: (SUNS) A wide range of compute-intensive benchmarks. Includes deserialization, a ray\u00adtracer, \nand many other primarily mathematical tasks. V8: (V8BM) The benchmarks associated with Google s Chrome \nbrowser. Again they include computationally-intensive benchmarks., such as cryp\u00adtography and another \nraytracer. Dromaeo: (DROM) Unlike the other suites, these benchmarks are intended to test the browser \ns DOM, as opposed to the JavaScript engine itself. In several ways, these benchmarks have proven to be \ninconsistent with the real-world JavaScript code we tested. We discuss our main observations: 7.1 Object \nKinds Benchmarks tend to heavily stress a few types of objects, which have little similarity to the object \ntypes used by real-world sites. Figure 17 shows the benchmarks disproportionate number of in\u00adstances \nand arrays. Comparing the benchmarks to the All Sites bar, one can clearly observe that constructed objects \n(instances) are overrepresented in V8BM and SUNS, whereas DROM is almost ex\u00adclusively preoccupied with \narrays. The extensive use of constructed objects in benchmarks is no\u00adtable. In SUNS, 39% of objects are \ninstances, and in V8BM, 63% are. In the real-world sites, only GMAP and LIVE produced more than 10% instance \nobjects (with GMAP and LIVE producing 35% and 24%, respectively). It seems likely therefore that a JavaScript \nimplementation that favored other object types would be poorly represented by SUNS and V8BM.  7.2 Uses \nof eval While SUNS has benchmarks which use eval, performing 2785 evals in our trace with only 33 deserializing \nJSON data, V8BM performs no evals. DROM performed 32 evals, with only 1 deseri\u00adalizing JSON data. This \nsuggests that SUNS is more representative of real-world workloads, the others less so. The latter is \nnot surpris\u00ading given the nature of the benchmarks (there is a lot of mathemat\u00adical computation which \nis not typical of most JavaScript programs in the wild).   7.3 Object Protocol Dynamism Although many \nsites have relatively sane and stable use of ob\u00adjects, with object initialization occurring mostly during \nconstruc\u00adtion, several do not. Figure 18 shows the object timelines of SUNS and V8BM. The behavior of \nmost sites at construction time is mod\u00adeled by SUNS, with a post-construction hump as seen in several \nreal-world sites. However, the lifetime of objects in SUNS is atyp\u00adical, with most objects fairly long-lived. \nV8BM s object dynamism is completely dissimilar to any real-world site, to the bene.t of Google s V8 \nJavaScript engine. The lifetimes of objects in V8BM is similar to object lifetimes of real-world JavaScript, \nwith the ex\u00adception that objects have fairly constant lifetimes, as shown by the steep dropoffs in living \nobjects in Figure 18. This peculiarity was not seen in any real-world sites. DROM uses no constructed \nob\u00adjects, as its intention is primarily to test the implementation of the DOM API, and is thus not very \nuseful as general purpose JavaScript benchmark. 7.4 Function Variadicity and Polymorphism Variadicity \nin the benchmarks was not dissimilar to real-world pro\u00adgrams. DROM and SUNS each had about 5% of functions \nused vari\u00adadically (close to the 6% seen accross all sites), and V8BM had about 2% variadic. Polymorphism \nwas rarer in the benchmarks, with 3%, 2% and 1% of call sites being polymorphic in DROM, SUNS and V8BM \n(respectively). As 19% of call sites were polymor\u00adphic across all sites, implementations which do not \nhandle poly\u00admorphic call sites well will perform better with benchmarks than real-world JavaScript. \n8. Conclusion This paper has provided the .rst large-scale study of the runtime behavior of JavaScript \nprograms. We have identi.ed a set of rep\u00adresentative real-world programs ranging in size from hundreds \nof kilobytes to megabytes, using an instrumented interpreter we have recorded multiple traces per site, \nand then with an of.ine analysis tool we have extracted behavioral information from the traces. We use \nthis information to evaluate a list of nine commonly made as\u00adsumptions about JavaScript programs. Each \nassumption has been addressed, and most are in fact false for at least some real-world code. To summarize, \nwe found that: 1. The prototype hierarchy is invariant. Libraries often change JavaScript s builtin prototypes \nin order to add behavior to types which would be .xed in a less-.exible language, such as Object and \nArray. Although changes to user-created types are more rare, they do occur as a means of modularity. \n 2. Properties are added at object initialization. This assertion is only true for a subset of sites, \nwith particularly poorly-behaved sites adding and deleting .elds late in the lifespan of very long-lived \nobjects. This presents a challenge to any attempt at imposing a type upon objects at runtime, as even \nthe very simple notion of type being a list of .elds is subject to changes over objects lifespans. 3. \nProperties are rarely deleted. Deletions were found to be in fact quite common on some sites. Most JavaScript \nprograms do not, however, use .eld deletion at all. 4. The use of eval is infrequent and does not affect \nsemantics. Our data shows that evals are not infrequent, and on most sites they have arbitrary and unpredictable \nbehavior. The secondary assumption, that eval is used primarily for deserialization, also turns out to \nbe false for most sites. Furthermore, nearly every site that uses JavaScript also uses eval. 5. Declared \nfunction signatures are indicative of types. In most languages, variadic functions are rare. Our data \nindicates that nearly 10% of functions are variadic in JavaScript. 6. Program size is modest. When analyzing \nthe amount of code the interpreter must parse and run, many sites are (with re\u00adpeated code) running megabytes \nof code. Even ignoring identi\u00adcal reloaded code, most sites load hundreds of kilobytes. Full\u00adprogram \nanalysis is likely infeasible with this amount of code, even if it was all known statically (i.e. not \ncreated by eval) 7. Call-site dynamism is low. Across all traces only 81% of call\u00adsites are monomorphic. \nEven if determining which sites are monomorphic statically was achievable, the number of poly\u00admorphic \ncall sites and degree of polymorphism is high enough that they would provide a signi.cant hurdle to statically \nanalyz\u00ading code paths. 8. Execution time is dominated by hot loops. This assumption is in fact true, \nbut less so than in Java. Our data shows that 10% of the functions ever called are hot, and only 50% \nof functions are ever called.  Figure 19 gives a subjective opinion on which sites violated which of \nthese assumptions. Although the opinion on whether the assumption is violated is subjective, they rely \non the same underlying data as the rest of this paper. 9 Only egregious violators are noted here, as \nonly one site had no arbitrary evals at all 10 These are sites for which the 90-10 rule (that 90% of \nexecution time is spent in 10% of functions) does not hold 1 2 3 49 5 6 7 810 280S X BING X X BLOG X \nX X DIGG X X X X X EBAY X X X FBOK X X X X X X FLKR X X X GMAP X X X X GMIL X X X X X GOGL X X X X X \nX X ISHK X X X LIVE X X X X X MECM X X X X X TWIT X X X WIKI X X WORD X X X X YTUB X X X X X Figure 19. \nViolations. For each assumption (above), a subjective opinion of which sites (left) violate that assumption. \n Given how thoroughly these common assumptions are violated, it seems that JavaScript is indeed a harsh \nterrain for static analysis. However, no sites violate all of the assumptions, so optimizations based \non them could work in many cases. Optimizations requiring whole-program analysis are unlikely to be successful, \nas many sites use a large amount of JavaScript, and eval is frequent and unpre\u00addictable. Rigidly static \ntype systems are unlikely to be usable with JavaScript; any applicable type system must be open to the \nvery real possibility of object protocol changes. Any typing framework which depends on the typing of \nfunction parameters will struggle with JavaScript s high degree of variadicity. Acknowledgments \u00a8enthusiasm \nand work on the early stages of this project; as well as the anonymous reviewers and Manuel Serrano for \ntheir comments. This work is supported in part by NSF grants CCF 0938232 and CNS 0716659 as well as ONR \naward N000140910754. The authors thank Tobias Wrigstad and Johan Ostlund for their References [1] Christopher \nAnderson. Type Inference for JavaScript. PhD thesis, Department of Computing, Imperial College London, \nMarch 2006. [2] Christopher Anderson and Sophia Drossopoulou. BabyJ: From object based to class based \nprogramming via types. Electr. Notes Theor. Comput. Sci., 82(7), 2003. [3] Christopher Anderson and Paola \nGiannini. Type checking for JavaScript. Electr. Notes Theor. Comput. Sci., 138(2), 2005. [4] Brad Calder, \nDirk Grunwald, and Benjamin Zorn. Quantifying behavioral differences between c and c++ programs. Journal \nof Programming Languages, (4), 1994. [5] Craig Chambers, Dave Ungar, and Erin Lee. An ef.cient implemen\u00adtation \nof SELF a dynamically-typed object-oriented language based on prototypes. SIGPLAN Not., 24(10):49 70, \n1989. [6] Ravi Chugh, Jeffrey A. Meister, Ranjit Jhala, and Sorin Lerner. Staged information .ow for \nJavaScript. In Programming Language Design and Implementation, (PLDI), 2009. [7] Bruno Dufour, Karel \nDriesen, Laurie J. Hendren, and Clark Ver\u00adbrugge. Dynamic metrics for java. In Proceedings of the Conference \non Object-Oriented Programming Systems, Languages and Applica\u00adtions (OOPSLA), 2003.  [8] Ben Feinstein \nand Daniel Peck. Caffeinemonkey: Automated collection, detection and analysis of malicious JavaScript. \nIn Black Hat USA 2007, Las Vegas, NV, USA, 2007. [9] Michael Furr, Jong hoon An, Jeffrey Foster, and \nMichael Hicks. Static type inference for ruby. In Symposium on Applied Computing (SAC), 2009. [10] Andreas \nGal, Brendan Eich, Mike Shaver, David Anderson, David Mandelin, Mohammad R. Haghighat, Blake Kaplan, \nGraydon Hoare, Boris Zbarsky, Jason Orendorff, Jesse Ruderman, Edwin W. Smith, Rick Reitmaier, Michael \nBebenita, Mason Chang, and Michael Franz. Trace-based just-in-time type specialization for dynamic languages. \nIn Conference on Programming Language Design and Implementation (PLDI), 2009. [11] C.D. Garret, Jeff \nDean, David Grove, and Craig Chambers. Measure\u00adment and application of dynamic receiver class distributions. \nUniv of Washington, 1994. [12] Arjun Guha, Shriram Krishnamurthi, and Trevor Jim. Using static analysis \nfor ajax intrusion detection. In International Conference on World Wide Web (WWW), 2009. [13] Phillip \nHeidegger and Peter Thiemann. Recency types for dynamically-typed, object-based languages. In Foundations \nof Object Oriented Languages (FOOL), 2009. [14] Alex Holkner and James Harland. Evaluating the dynamic \nbehaviour of Python applications. In Australasian Computer Science Conference (ACSC), 2009. [15] Daniel \nIngalls, Krzysztof Palacz, Stephen Uhler, Antero Taivalsaari, and Tommi Mikkonen. The lively kernel a \nself-supporting system on a web page. In Self-Sustaining Systems, 2008. [16] ECMA International. ECMA-262: \nECMAScript Language Speci.ca\u00adtion. ECMA (European Association for Standardizing Information and Communication \nSystems), Geneva, Switzerland, third edition, December 1999. [17] Dongseok Jang and Kwang-Moo Choe. Points-to \nanalysis for JavaScript. In Symposium on Applied Computing (SAC), 2009. [18] Simon Holm Jensen, Anders \nM\u00f8ller, and Peter Thiemann. Type analysis for JavaScript. In Static Analysis Symposium (SAS), 2009. \u00a8 \nand Jan Vitek. Understanding the dynamics of JavaScript. In Workshop on Script to Program Evolution (STOP), \n2009. [19] Sylvain Lebresne, Gregor Richards, Johan Ostlund, Tobias Wrigstad, [20] Florian Loitsch and \nManuel Serrano. Hop client-side compilation. In Symposium on Trends on Functional Languages, 2007. [21] \nSergio Maffeis, John C. Mitchell, and Ankur Taly. Isolating JavaScript with .lters, rewriting, and wrappers. \nIn European Symposium on Research in Computer Security (ESORICS), 2009. [22] Paruj Ratanaworabhan, Benjamin \nLivshits, and Benjamin Zorn. JSMeter: Comparing the behavior of JavaScript benchmarks with real web applications. \nIn USENIX Conference on Web Application Development (WebApps), June 2010. [23] Ewan D. Tempero, James \nNoble, and Hayden Melton. How do java programs use inheritance? an empirical study of inheritance in \njava software. In European Conference on Object-Oriented Programming (ECOOP), 2008. [24] Peter Thiemann. \nTowards a type system for analyzing JavaScript programs. In European Symposium on Programming (ESOP), \n2005. [25] Sam Tobin-Hochstadt and Matthias Felleisen. The design and implementation of Typed Scheme. \nIn POPL, pages 395 406, New York, NY, USA, 2008. ACM. [26] Philipp Vogt, Florian Nentwich, Nenad Jovanovic, \nEngin Kirda, Christopher Kr\u00a8ugel, and Giovanni Vigna. Cross site scripting prevention with dynamic data \ntainting and static analysis. In Network and Distributed System Security Symposium (NDSS), 2007. [27] \nDachuan Yu, Ajay Chander, Nayeem Islam, and Igor Serikov. JavaScript instrumentation for browser security. \nIn Symposium on Principles of Programming Languages (POPL), 2007. [28] Chuan Yue and Haining Wang. Characterizing \ninsecure JavaScript practices on the web. In 18th International World Wide Web Conference, pages 961 \n961, April 2009.   \n\t\t\t", "proc_id": "1806596", "abstract": "<p>The JavaScript programming language is widely used for web programming and, increasingly, for general purpose computing. As such, improving the correctness, security and performance of JavaScript applications has been the driving force for research in type systems, static analysis and compiler techniques for this language. Many of these techniques aim to reign in some of the most dynamic features of the language, yet little seems to be known about how programmers actually utilize the language or these features. In this paper we perform an empirical study of the dynamic behavior of a corpus of widely-used JavaScript programs, and analyze how and why the dynamic features are used. We report on the degree of dynamism that is exhibited by these JavaScript programs and compare that with assumptions commonly made in the literature and accepted industry benchmark suites.</p>", "authors": [{"name": "Gregor Richards", "author_profile_id": "81438595000", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P2184483", "email_address": "", "orcid_id": ""}, {"name": "Sylvain Lebresne", "author_profile_id": "81438593830", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P2184484", "email_address": "", "orcid_id": ""}, {"name": "Brian Burg", "author_profile_id": "81464657039", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P2184485", "email_address": "", "orcid_id": ""}, {"name": "Jan Vitek", "author_profile_id": "81100018102", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P2184486", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1806596.1806598", "year": "2010", "article_id": "1806598", "conference": "PLDI", "title": "An analysis of the dynamic behavior of JavaScript programs", "url": "http://dl.acm.org/citation.cfm?id=1806598"}