{"article_publication_date": "06-05-2010", "fulltext": "\n Decoupled Lifeguards: Enabling Path Optimizations for Dynamic Correctness Checking Tools Olatunji Ruwase1, \nShimin Chen2, Phillip B. Gibbons2, Todd C. Mowry1 1Carnegie Mellon University 2Intel Labs Pittsburgh \noor@cs.cmu.edu, {shimin.chen,phillip.b.gibbons}@intel.com, tcm@cs.cmu.edu Abstract Dynamic correctness \nchecking tools (a.k.a. lifeguards) can detect a wide array of correctness issues, such as memory, security, \nand concurrency misbehavior, in unmodi.ed executables at run time. However, lifeguards that are implemented \nusing dynamic binary in\u00adstrumentation (DBI) often slow down the monitored application by 10 50X, while \nproposals that replace DBI with hardware still see 3 8X slowdowns. The remaining overhead is the cost \nof perform\u00ading the lifeguard analysis itself. In this paper, we explore compiler optimization techniques \nto reduce this overhead. The lifeguard software is typically structured as a set of event\u00addriven handlers, \nwhere the events are individual instructions in the monitored application s dynamic instruction stream. \nWe propose to decouple the lifeguard checking code from the application that it is monitoring so that \nthe lifeguard analysis can be invoked at the granularity of hot paths in the monitored application. In \nthis way, we are able to .nd many more opportunities for eliminating redundant work in the lifeguard \nanalysis, even starting with well\u00adoptimized applications and hand-tuned lifeguard handlers. Experi\u00admental \nresults with two lifeguard frameworks one DBI-based and one hardware-assisted show signi.cant reduction \nin monitoring overhead. Categories and Subject Descriptors F.3.2 [Logics and Meanings of Programs]: Semantics \nof Programming Languages Program analysis; D.3.4 [Programming Languages]: Processors Code generation, \noptimization General Terms Design, Performance, Reliability, Security Keywords Dynamic code optimizations, \nDynamic correctness checking, Dynamic program analysis 1. Introduction Dynamic correctness checking tools \nhave become quite popular thanks to the availability of powerful dynamic binary instrumen\u00adtation (DBI) \nframeworks such as Valgrind [21], Pin [17], and Dy\u00adnamoRio [3]. These dynamic tools (a.k.a. lifeguards) \nhave the ad\u00advantages that they do not require source code (because they start with binary executables \nas input) and they can observe the full dy\u00adnamic behavior of the application as it executes. Lifeguards \nare Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n10 June 5 10, 2010, Toronto, Ontario, Canada. Copyright c &#38;#169; 2010 ACM 978-1-4503-0019-3/10/06... \n$10.00 complementary to tools that perform either static analysis [4, 10, 11] or post-mortem crash analysis \n[18, 36]. Particularly valuable are sophisticated lifeguards that invoke a lifeguard handler after nearly \nevery instruction in the monitored application s dynamic in\u00adstruction stream [21]. Such instruction-grain \nlifeguards are used to check a diverse set of correctness issues, including memory [22], security [24], \nand concurrency [31] misbehavior. While instruction-grain lifeguards offer many compelling ad\u00advantages, \ntheir major disadvantage is runtime overhead: lifeguards such as MEMCHECK [22] or TAINTCHECK slow down \nCPU\u00adintensive benchmarks by 10 50X [21, 24]. Why are the overheads so large? One reason is that DBI itself \nimposes a signi.cant over\u00adhead when it is performed at an instruction-by-instruction gran\u00adularity. For \nexample, the NULLGRIND no instrumentation life\u00adguard has a slowdown of roughly 4X on SPEC benchmarks \n[21], even though it performs no real work. To eliminate the binary in\u00adstrumentation overhead, recent \nproposals such as DISE [8] and LBA [5, 6] propose hardware-assisted mechanisms for extracting the instruction-level \ninformation of the monitored application and feeding it to the lifeguard software as a stream of events. \nWhile these approaches signi.cantly reduce the runtime overhead, there is still a slowdown of roughly \n3 8X [5] for instruction-grain life\u00adguards, due to the cost of performing the lifeguard analysis itself. \nIn a recent paper, Chen et al. [5] observe that redundancy often exists dynamically across lifeguard \nhandlers (e.g., when access\u00ading lifeguard state (called metadata), when performing redundant checks, \nand when performing unnecessary copying), and they pro\u00adpose adding hardware accelerators to help reduce \nthese unneces\u00adsary overheads. In this paper, we explore an alternative approach, which is to recognize \nand eliminate this redundancy through soft\u00adware. 1.1 Key Optimization Stumbling Block: Performing Lifeguard \nChecks Synchronously For decades, optimizing compilers have successfully improved software performance \nby recognizing and eliminating redundant computations along execution paths [1]. For traditional static \nanal\u00adysis, a control .ow graph is typically used to summarize the set of all possible execution paths; \nfor more recent JIT-style dynamic code analysis, the optimizations are typically applied to an ob\u00adserved \nset of hot paths. Our goal is to apply these types of redundancy-elimination optimizations across the \nlifeguard checking code. Unfortunately, a key structural property of most existing lifeguard frameworks \nmakes it dif.cult to do this: their lifeguards perform correctness checks synchronously such that the \nchecking for a given instruction (which is typically implemented as a call to an event-driven handler \nthat handles certain classes of instructions) is completed before that instruction executes. On the one \nhand, it makes intuitive sense to check an application instruction before it executes, because this makes \nit straightforward to prevent bad things from happening. On the other hand, one implication of this synchronous \napproach is that the lifeguards behave much like interpreted code, where the dynamic instruction stream \nfrom the monitored application serves as the input. With this interpreter-like structure, there is little \nor no opportunity to optimize across lifeguard handlers to exploit redundancy caused by the structure \nand repeated patterns of the monitored application.  1.2 Our Approach: Decoupling Lifeguard Checks to \nEnable Path Optimizations To enable more aggressive redundancy elimination of lifeguard checking code, \nwe propose to decouple the lifeguard checking code from the application that it is monitoring. In contrast \nto traditional synchronous frameworks that invoke lifeguard analysis at the gran\u00adularity of individual \ninstructions in the monitored application (in\u00adstruction handlers), our decoupled framework makes it possible \nto invoke the equivalent lifeguard analysis at the granularity of hot paths (potentially spanning large \nnumbers of basic blocks) in the monitored application (path handlers). By exposing the lifeguard analysis \nassociated with an entire hot path to our optimizer, we can .nd many more opportunities for eliminating \nredundant work in the lifeguard analysis. In addition to exploiting the usual forms of redundancy elimi\u00adnation \nthat are utilized by modern optimizing compilers, we also use domain-speci.c knowledge about the lifeguard \nbehaviors to perform more aggressive optimizations. We incorporate our de\u00adcoupled approach into two diverse \nlifeguard frameworks: one that uses DBI [21] and one that uses hardware-assisted logging [5]. Per\u00adhaps \nsurprisingly, we show that, even starting with well-optimized applications and hand-tuned lifeguard handlers, \nour optimizations can .nd and eliminate signi.cant redundancy in both frameworks, greatly reducing monitoring \noverhead. 1.3 How Decoupled Lifeguards Deal with Correctness Issues that Have Already Happened While \nthe bene.t of our decoupled approach is that it exposes more opportunities for optimizing the lifeguard \ncode, it also creates a po\u00adtential complication. Namely, because the lifeguard checks are lag\u00adging behind \nthe monitored application, by the time the lifeguard observes a correctness issue in the running application, \nthe applica\u00adtion has already continued executing beyond that point. To address this problem, a decoupled \nlifeguard framework must be able to (i) contain the damage to the application caused by such correctness \nissues, and (ii) protect the lifeguard state from corruption caused by such issues. For requirement (i), \nwe make sure that all remaining lifeguard checking codes are executed before certain critical events. \nFor ex\u00adample, we ensure that all checks are complete before executing system calls. We also complete \nall checks before application indi\u00adrect jumps to ensure that executed application code is well de.ned. \nThus, the paths selected for path handlers do not cross application system calls or indirect jumps. Requirement \n(ii) is trivially satis.ed when a lifeguard and the monitored application are in separate address spaces, \nsuch as in LBA [5] and Speck [25], where corruption is not possible. How\u00adever, when the lifeguard and \nthe application share the same address space, we must protect three key memory components of this ad\u00address \nspace: the lifeguard code, any dynamically instrumented ap\u00adplication code, and any metadata maintained \nby the lifeguard. The .rst two can be protected using page protection mechanisms, while the third is \nslightly more involved see Section 2.2.  1.4 Related Work Our approach builds upon a large body of previous \nwork on opti\u00admizing interpreters [15, 28], partial evaluation [14], and dynamic code optimization [2, \n7, 16, 35]. In contrast to this earlier work, our context is unusual because we are using the runtime \nbehavior of one program (the monitored application) to optimize something else (the lifeguard). Perhaps \na more closely related topic is work on optimizing ma\u00adchine simulators [7, 35] by compiling sequences \nof simulator code to match hot paths in the simulated application. In both cases, an application path \nis the input to the optimization process; in our case, however, the lifeguard analysis is more closely \nconnected with the structure of the monitored application than the work done in a ma\u00adchine simulator. \nHence the lifeguard domain-speci.c optimizations that we explore are different from this earlier work. \nFinally, there have been a number of proposals for accelerat\u00ading lifeguard functionality [5, 9, 25, 29, \n30, 32]. Raksha [9] and Hardgrind [32] accelerate monitoring by implementing most of the checking and \npropagation functionality of a particular lifeguard in hardware and handling exceptional cases in software. \nOur sys\u00adtem eliminates redundant checks and propagation in software and is applicable to all lifeguards. \nChen et al. [5] propose hardware mechanisms for accelerating the most frequent operations com\u00admonly performed \nby lifeguards. These include mechanisms for fast metadata lookup, redundant checks elimination and propaga\u00adtion \ninheritance tracking. Our optimizer similarly eliminates re\u00addundant lookups, checks and propagations, \nbut without the need for such hardware accelerators. LIFT [29] observed that TAINT-CHECK oftenperforms \nredundantpropagationsbecausethesources and destination were typically untainted. It therefore skips prop\u00adagation \nentirely within a program path if the live-in and live-out register/memory data of the path are untainted. \nIn contrast, our op\u00adtimizations do not rely on the runtime values of metadata for re\u00addundancy elimination \nand are therefore complementary to LIFT. While our redundant checks elimination within program paths \nis similar to LIFT s, our optimizations go further to eliminate checks across loop path iterations. Recent \nworks accelerate lifeguards by parallelizing their monitoring task, either for sequential [25, 30] or \nparallel [13, 34] programs; our work is complementary to these ef\u00adforts. 1.5 Contributions This paper \nmakes the following main contributions: To our knowledge, this is the .rst study to explore dynamic \ncode optimization techniques for lifeguards.  We propose to decouple the lifeguard checking code from \nthe monitored application so that the lifeguard analysis can be in\u00advoked at the granularity of hot paths \nin the monitored applica\u00adtion for more aggressive redundancy elimination.  Beyond the usual redundancy \nelimination optimizations, we propose and evaluate lifeguard domain-speci.c optimizations that improve \nperformance further.  We evaluate our approach on a diverse set of instruction-grain lifeguards on two \nlifeguard platforms: a popular DBI platform, Valgrind, and a simulated hardware-assisted platform, LBA. \nFor CPU-intensive benchmarks, we observe reductions in mon\u00aditoring overhead of up to 31% on Valgrind \nand 53% on LBA.  2. Understanding Dynamic Correctness Checking In this section, we .rst discuss several \nrepresentative lifeguards. We then discuss frameworks for supporting lifeguards, and how decoupled lifeguards \nwould .t in. Finally, we analyze lifeguards common characteristics to point out optimization opportunities. \n Figure 1. (a) x86 code path of a monitored program (denoted path1), and (b) the corresponding invoked \nTAINTCHECK instruc\u00adtion handlers. 2.1 Representative Lifeguards In our study, we focus on the following \nfour instruction-grain life\u00adguards that represent a wide range of functionality: ADDRCHECK [20] checks \nwhether every application memory access is to an allocated memory area. In particular, for every ap\u00adplication \nbyte, it maintains a 1-bit allocated state as its metadata. The metadata are updated when ADDRCHECK observes \nmemory allocation calls such as malloc and free. TAINTCHECK [24] detects security exploits by monitoring \nsus\u00adpect data in the application s address space. It maintains for ev\u00adery application byte a 1-bit tainted \nmetadata, which is initial\u00adized to untainted. Unveri.ed input data, such as those from network or from \nuntrusted disk .les, are marked as tainted. TAINTCHECK tracks the propagation of tainted data: For each \nexecuted applica\u00adtion instruction, TAINTCHECK computes and updates the tainted state of the destination \nof the instruction by performing a logical OR operation on the tainted states of all the source operands. \nIf tainted data are used in critical ways, such as in jump target ad\u00addresses or printf-like calls format \nstrings, then TAINTCHECK .ags a violation. MEMCHECK [22, 23] enhances ADDRCHECK with protection against \nuninitialized values. Such protection is non-trivial because it is not an error to read an uninitialized \nvalue, e.g., when copy\u00ading a partially initialized data structure. Instead, errors are raised only when \nuninitialized values are actually used improperly: e.g., dereferenced as pointers or passed into system \ncalls. MEMCHECK maintains a 1-bit allocated state and a 1-bit initialized state for ev\u00adery application \nbyte. The allocated state is updated and checked as in ADDRCHECK, while the initialized state is propagated \nlike the tainted state in TAINTCHECK. LOCKSET [31] monitors each application memory access to detect \ndata races in parallel programs. For each shared memory location of the application, LOCKSET maintains \nthe set of common locks held by different application threads when accessing the location. If the common \nlock set becomes empty, LOCKSET reports a potential data race. Since the total number of possible lock \nsets is typically much smaller than the number of memory locations, an optimization is to store the lock \nsets in a separate data structure and keep a pointer to the data structure as the per-location metadata. \n 2.2 Lifeguard Frameworks and Decoupled Lifeguards As the monitored application executes, a sequence \nof application instruction events occur (conceptually). A lifeguard registers an event handler for every \napplication event type that it cares about. For example, ADDRCHECK registers for memory read and write \nevent types, while TAINTCHECK cares about almost every type of instruction. On x86, an instruction that \nperforms multiple types of operations, such as memory access and computation, will be mapped to multiple \nevent types. For each observed instruction event, the lifeguard framework invokes the registered lifeguard \nevent handler with the dynamic event values (e.g., the effective ad\u00address for a memory access) as handler \narguments. Figure 1 shows an example application event sequence and the corresponding Figure 2. (a) TAINTCHECK \npropagation handler, (b) TAINT-CHECK checking handler, and (c) an implementation of the taint() function \nfor retrieving the taint status of a memory location.  TAINTCHECK handler calls. (In this paper, destination \noperands appear to the left of source operands.) Implementations of a propa\u00adgation handler and a checking \nhandler are shown in Figure 2. There are also special handlers for high-level events such as malloc and \nfree; these are typically invoked via an instrumentation of the corresponding library call. This event-driven \nmodel can be supported both in software and in hardware. The software-only approach is typically based \non Dynamic Binary Instrumentation (DBI) [3, 17, 21], where exe\u00adcuting application code is modi.ed (instrumented) \nto insert life\u00adguard event handlers in between application instructions. Log Based Architectures (LBA) \n[5] is a state-of-the-art general-purpose hardware-assisted design, which runs a monitored application \nand a lifeguard on two separate cores in a multi-core system. Instruction records are extracted at the \ncore running the application, transferred through a log buffer to the core running the lifeguard, and \ndelivered in the event-driven fashion. In this design, lifeguard checking can lag the monitored application \n(by tens of thousands of instructions). This is a conscious design choice to enable hardware optimizations \nsuch as compressing sequences of log records prior to transfer. For correctness, LBA contains detected \nerrors within the applica\u00adtion s process boundary by stalling the application at system calls and waiting \nfor the lifeguard to catch up and complete necessary checking. This paper proposes to decouple the lifeguard \nchecking code from the monitored application so that the lifeguard analysis can be invoked at the granularity \nof hot paths in the monitored application for more aggressive optimizations. Note that this differs from \nLBA because LBA does not provide hot-path capabilities and because we propose to use decoupled lifeguards \neven within DBI frameworks. As discussed in Section 1.3, frameworks in which the lifeguard and the application \nshare the same address space (e.g., DBI, DISE) raise additional challenges for correct execution of decoupled \nlife\u00adguards. Namely, we must protect the lifeguard code, the instru\u00admented code, and the lifeguard metadata \nfrom spurious applica\u00adtion writes that may arise before the lagging lifeguard analysis de\u00adtects the problem \nin the application. The lifeguard code can be easily protected using page protection mechanisms. Similarly, \nin\u00adstrumented code pages can be protected after generation. Note that containment (requirement (i) of \nSection 1.3) ensures that corrupted code can never use system calls to remove page protections. It is \nmore challenging to protect the lifeguard metadata, which for instruction-grain lifeguards is primarily \na one-to-one mapping from every memory location/byte in the application s address space to a lifeguard-speci.c \nshadow value [21] (examples above). This is Figure 3. Metadata maintained by the lifeguard shadow all \nthe data segments in the shared address space. Metadata either (i) shadow application data and are accessed \nby the lifeguard for correctness checking or (ii) shadow lifeguard data but should never be accessed \nbecause the lifeguard does not self-check.  because we must ensure that the lifeguard can update this \nmetadata, but the application cannot. A simple, but costly, approach would be to insert a range check \nbefore every application write to ensure that it does not fall in the metadata range. A better-performing \napproach (see Figure 3) is to observe that, because a lifeguard maps the entire address space including \nthe monitored application and the lifeguard to the metadata, the metadata must itself be mapped to a \nsub-range of the metadata. The lifeguard would normally never need to access this self-referenced range, \nso we can protect the range (e.g., via mprotect) with little overhead. If the application either directly \naccesses the self-referenced range or accesses anywhere else in the metadata causing the lifeguard to \naccess the corresponding self\u00adreferenced range, an exception will be triggered. We can register a signal \nhandler to detect and report such application misbehavior.  2.3 Lifeguard Optimization Opportunities \nIn this section we discuss lifeguard optimization opportunities when using decoupled lifeguards. The \nconcern is that even de\u00adcoupled lifeguards provide little opportunity for optimization be\u00adcause (i) lifeguard \nevent handlers are already well optimized by existing compilers and are sometimes even hand-tuned; and \n(ii) the sequence of event handler calls corresponds to the sequence of application instructions in a \nwell-optimized application, so that any redundant calls would seem to map back to redundant appli\u00adcation \ninstructions that would have been optimized away. Fortu\u00adnately, despite these realities, there remains \nplenty of optimization opportunities, because of the following common properties of our representative \nlifeguards. First, a lifeguard s behaviors are much simpler than the moni\u00adtored application because an \nevent type often corresponds to many different instructions. For example, ADDRCHECK and LOCKSET only \ncare about memory accesses; they do not distinguish the com\u00adputation operations (e.g., addition or multiplication \nusing a memory location as a source operand are both regarded as a memory read). In TAINTCHECK and MEMCHECK, \nany computation in the appli\u00adcation is converted into a logical OR of the source(s) metadata. Because \nof the many-to-one mapping of operations, even well\u00adoptimized application code sequences can result in \nsub-optimal lifeguard code sequences. Second, metadata accesses are the most important operations in \nany lifeguard. Metadata in lifeguards are often constructed as a two-level data structure [23]. The .rst \nlevel is a pointer array, pointing to metadata chunks in the second level. The higher part of an application \neffective address is used to index the .rst level, while the lower part indexes the second level chunk. \nThis organi\u00adzation saves space and is more .exible than allocating a monolithic metadata block for the \nentire application s virtual address space: metadata are allocated only when the corresponding virtual \nmem\u00adory space is actually used by the application. Moreover, the mono\u00adlithic approach may not be feasible \nfor large metadata such as those in LOCKSET. As a result, any metadata access has to perform an indirect \nmemory access with several shift and mask operations. For example, as shown in Figure 2(c) retrieving \nthe taint status of mem\u00adory locations in TAINTCHECK requires up to six x86 instructions. Therefore, reducing \nmetadata accesses may signi.cantly improve lifeguard performance. Third, spatial locality of application \ndata accesses results in spa\u00adtial locality of metadata accesses. The common metadata design among the \nfour lifeguards we study is that each second level meta\u00addata chunk shadows a 216 byte range in the application \naddress space, thus subsequent accesses to a metadata chunk can be done cheaply (avoiding the .ve instruction \nsequence in Figure 2(c)), by expressing the new location as an offset of a previously accessed location \nwithin the chunk. Fourth, temporal locality of data accesses in the application code is mapped to temporal \nlocality of metadata accesses in the lifeguard code. Given the many-to-one mapping of operations, it \nis possible that different or even dependent operations on the same memory location in the application \nare mapped to redundant life\u00adguard operations. For example, for a sequence of application in\u00adstructions \nwith multiple loads/stores to a given location without in\u00adtervening memory (de)allocation calls, ADDRCHECK \nwill perform a check per load/store. However, because the checks all read the same metadata, an optimization \nis to use only a single check for that location, removing all the other redundant checks. Perform\u00ading \nsuch optimizations requires knowledge of both the monitored program s control .ow and the lifeguard s \nchecking and/or prop\u00adagation rules. Unfortunately, existing optimizers are not aware of either as they \nsee only the lifeguard code. Finally, most lifeguards (including the four in our study) care only about \nthe data .ow pattern of the application in terms of the source and destination addresses. They do not \ncare about the actual data values. Because handlers are insensitive to data values, they are simple (recall \nFigure 2(a)) and abundantly reused, making redundancies more likely. The key to taking advantage of these \nopportunities is to bundle multiple handler calls together and optimize them as a unit, as enabled by \nour decoupled lifeguard approach, and described next. 3. Effective Optimization of Lifeguard Code In \nthis section, we present our solution for effectively optimizing lifeguard code by exploiting the observations \nin the preceding sec\u00adtion. One constraint that we want to satisfy is to keep our solution generic so \nthat it can be applied to a wide range of lifeguards. In the following discussions, we present our solution \nstep by step. Our optimizations rely on the following assumptions on life\u00adguard instruction event handlers. \nFirst, a lifeguard maintains unique metadata (i.e., shadow values) for each application register/memory \nlocation for the program properties that the lifeguard is monitoring. Second, the metadata are often \norganized using a two-level data structure as discussed in Section 2.3. Third, event handlers that correspond \nto application instruction events can access only the metadata associated with the handler arguments. \nThese instruction event handlers are frequently executed and are the focus of our study. Fourth, the \nchecks performed by these instruction event han\u00addlers are deterministic functions of the handler arguments \nand the metadata states. Two checks with the same handler arguments and the same associated metadata \nvalues are idempotent, giving the same outcome. Finally, the updates performed by the instruction event \nhandlers are also deterministic given the handler arguments and the metadata states. A handler may read \nsource metadata lo\u00adcations and write to destination metadata locations. If the handler arguments and \nthe source metadata values are the same, then the destination metadata values will be the same. (An example \nof an Figure 4. A high level view of how (a) a traditional JIT optimizer is used on application code, \nand (b) a JIT lifeguard optimizer would .t into a decoupled lifeguard system. event handler not satisfying \nthis assumption is a pro.ling han\u00addler that increments a counter each time it is called.) The above assumptions \ntypically hold for the implementations of instruction\u00adgrain lifeguards [21], including the four in our \nstudy as described in Section 2.1. 3.1 JIT Optimization of Decoupled Lifeguards We propose dynamic optimization \nfor decoupled lifeguards. In Fig\u00adure 4, we show how a JIT lifeguard optimizer .ts into a decou\u00adpled lifeguard \nsystem in comparison to how traditional JIT optimiz\u00aders are used. As shown in Figure 4(a), a traditional \nJIT optimizer pro.les the execution environment (e.g., using performance coun\u00adters, interpreters) to \ndiscover the frequently executed code paths of the application. The optimizer then reads a hot code path \nfrom the application binary, optimizes the hot code path, and dynamically patches the application binary \nwith the optimized code for future execution. In contrast, as shown in Figure 4(b), the decoupled life\u00adguard \noptimizer obtains hot control .ow pro.les from a log that streams program counter values and effective \naddresses from the application to the lifeguard. It then reads the hot code path from the application \nbinary, reads the relevant instruction event handlers from the lifeguard binary, and composes the appropriate \nsequence of event handlers into a path handler. (Example path handlers are shown in Figure 5.) The optimizer \nthen applies the optimizations described later in this section to the path handler and patches the lifeguard \nbinary with the optimized path handler, which is used for analyzing future executions of the hot code \npath. Note that the op\u00adtimizer is designed to execute off the critical path of application-to\u00adlifeguard \ncommunication and hence should have minimal adverse impact on application and lifeguard performance. \nIn this paper, a path is an acyclic sequence of dynamic instruc\u00adtions that can contain up to a prede.ned \nnumber (e.g., 8 in our experiments) of forward branches or terminates at the .rst back\u00adward branch, indirect \njump, or system call. This not only simpli.es path identi.cation (each path is identi.ed by its starting \naddress and taken/not taken branch pattern), but also satis.es the containment requirement as discussed \nin Section 1.3. Extending Lifeguard Frameworks to Support Path Handlers. With the decoupled lifeguard \napproach, there is an opportunity to look ahead in the log to see application events that have not yet \nbeen delivered to the lifeguard. Thus, a lifeguard framework can identify when an application path matches \na previously determined hot path, and invoke the corresponding path handler. If a match is not found, \nthe framework falls back to invoking an instruction handler for each event, until the next match. For \ncorrectness, it is required that the lifeguard operations (i.e., metadata updates and checks) performed \nby a path handler must Figure 5. TAINTCHECK and ADDRCHECK handlers for path1 in Figure 1(a), before optimizations. \n be equivalent to the operations performed by the individual event handlers comprising the path handler. \nGiven the way that the path handler is constructed, it is suf.cient to satisfy that the same event arguments \nare supplied to the event handler calls inside the path handler as before. To achieve this, the lifeguard \nframework is ex\u00adtended to record in an array all event arguments since the start of the path. Because \nthe number of event arguments is .xed for any event, the argument location of a particular event in a \npath will be found at a .xed offset from the array start. Therefore, we can supply an array reference \nwith a constant index for any non-register event argument in a path handler. Register event arguments \ncan be represented as small integer constants (i.e., register IDs). Communicating argu\u00adments to event \nhandlers in this way enables the composing and in\u00adlining of non-trivial handlers, in contrast to copy-and-annotate \n[21] approaches such as in Pin, which work only for simple handlers. Traditional Compiler Optimizations \non Path Handlers are Sub\u00adoptimal. After constructing a path handler, we could simply use a traditional \ncompiler to optimize the path handler by inlining the event handler calls of the path handler. As shown \nin our experi\u00adments in Section 5 (the path(stdopts) bars), this approach indeed reduces lifeguard overhead \nin many cases, albeit only modestly. However, examining the generated lifeguard path handler code, we \n.nd that a lot of redundancy still exists in the code. But why? 3.2 Removing Redundant Lifeguard Operations \nwithin Individual Path Handlers To understand why traditional compilers fail to remove many re\u00addundant \nlifeguard operations, let us look at the example path han\u00addler shown in Figure 5(b). We can see that \nthe third check is clearly a duplicate of the second check. However, the two-level metadata structure \nhinders traditional compilers from recognizing this fact. Disambiguating the metadata manipulated by \nlifeguard event han\u00addlers is quite dif.cult because metadata are accessed using indirect memory references \n(as discussed in Section 2.3; see Figures 2(c) and 8(a) for examples), for which existing alias analysis \ntechniques are quite ineffective. However, without such disambiguations, it would be impossible to verify \nthat checks or propagations are re\u00addundant because potentially any metadata could be read or updated. \nThus, traditional compilers have to conservatively retain the redun\u00addant lifeguard operations. But why \ndo we intuitively know that the third check is a du\u00adplicate? This is because we understand the mapping \nfrom appli\u00adcation address to metadata address, and we understand the high\u00adlevel semantics of the event \nhandlers. check allocated per\u00adforms a metadata read, and the same application address is mapped to the \nsame lifeguard metadata address, whose value may change only upon application memory (de)allocation events. \nHowever, this analysis may not apply to another lifeguard, e.g., TAINTCHECK. If two propagation handler \ncalls share a common address argu\u00adment, the determination of whether the second is a duplicate must distinguish \nbetween cases where the common address is used in a source or destination operand in each respective \ncall. In other words, detecting redundant checks and propagations requires rea\u00adsoning about the runtime \neffects of the event handler calls on meta\u00adFigure 6. Applying our alias analysis to path1 handlers in \nFigure 5. Symbolic address expressions expose potential redundancies. data. To do this analysis at compile \ntime, there are two challenges: (i) understanding the effects of each lifeguard event handler, e.g., \nwhether it performs propagations or checks; and (ii) disambiguat\u00ading which metadata are manipulated. \nWe tackle the .rst challenge by using an instruction handlers description con.guration .le written by \nthe lifeguard writer that describes how each handler manipulates (reads/writes) the meta\u00addata of its \narguments, and whether the handler obeys the assump\u00adtions (idempotency, determinism) on common handlers \nthat were listed at the beginning of Section 3. The con.guration .le also in\u00addicates the size of metadata \nvalues, e.g., ADDRCHECK maintains 1 bit for each application byte. For the second challenge, we exploit \nthe 1-1 mapping from ap\u00adplication addresses to lifeguard metadata addresses. Rather than disambiguating \nmetadata references in a path handler, we disam\u00adbiguate the corresponding memory and register references \nin the corresponding hot code path in the monitored application. We ex\u00adpect reasonable success with this \napproach because (i) registers are trivial to disambiguate and (ii) memory references in the applica\u00adtion \ncode are often dominated by direct memory references, for which alias analysis is more effective. In \nthis way, we convert the dif.cult task of disambiguating indirect memory references in the lifeguard \ncode into a much easier task of disambiguating registers and direct memory references in the monitored \napplication code. We analyze the hot path in the monitored application code. By keeping track of expressions \nused for forming addresses (i.e., base register, index register, offset .eld, and scale .eld), we determine \neffective address arguments in the path handler that always-alias or may-alias with others. An address \nargument always-aliases with another address argument that is formed using the same expres\u00adsion, and \nit may-aliases with other address arguments. Note that, as in traditional JIT optimizers, our JIT lifeguard \noptimizer is per\u00adforming alias analysis based on a static analysis of the hot path (and not the effective \naddresses in a dynamic instance of the path), so that the dynamically compiled path handler can be applied \nto any instance of the path. Figure 6 shows the outcome of apply\u00ading our alias analysis to the path handlers \nin Figure 5; effective address arguments that are always-aliased are replaced with the same symbol. For \nexample, the two address arguments formed us\u00ading 0x8[%ebx] are replaced with M2 since they always resolve \nto the same effective address and are used to access the same metadata location at runtime. The analysis \nalso notes that M1 and M2 are eight bytes apart and hence the corresponding metadata accesses can be \noptimized using the technique described in Section 3.4. Detecting redundant checks and propagations is \nmuch easier in this representation. For example, given the above con.guration .le, it is easy to determine \nthat the check performed by the third handler call in Figure 6(b) is redundant to that performed by the \nsecond call. In addition to removing redundant events, we can further lever\u00adage the descriptions in the \ncon.guration .le. For propagation-style lifeguards, such as TAINTCHECK and MEMCHECK, a propagation event \nhandler performs a logical OR of the source operands meta\u00addata. There are frequent opportunities to short \ncircuit this operation to improve lifeguard performance. For example, in TAINTCHECK, a destination is \ntainted if at least one of the sources is tainted regard\u00adless of the status of the other source(s). In \ncontrast, short circuiting opportunities are far less common in more general programs, where operands \n(e.g., integers) have signi.cantly larger value ranges and participate in the full set of arithmetic/logical \noperations.  3.3 Exploiting Knowledge Beyond Individual Paths for Further Optimizations The optimizations \ndescribed above are fundamentally limited by the path boundaries. Here, we extend our optimizations to \nconsider the context of individual paths within enclosing loops. We observe that paths inside an application \nloop translate into event sequences that get repeated each loop iteration and conse\u00adquently into repeated \ninvocations of the same lifeguard path han\u00addler. Although the original application loop code is generated \nby traditional compilers that already perform loop optimizations (e.g., loop-invariant code motion), \nthe resulting lifeguard operations of\u00adten still have many redundancies across loop iterations because \nof the many-to-one mapping of application operations to lifeguard op\u00aderations. To exploit this observation, \nwe require the underlying life\u00adguard framework to remember the path delivered prior to the cur\u00adrent path, \nas well as to support looking ahead in the application event sequence for one more path beyond the current \npath. This is a reasonable requirement. For example, LBA uses a log buffer that can contain tens of thousands \nof instruction events. In this way, a given instance of a loop path can be identi.ed as the .rst, the \nlast, or some middle iteration of the loop path. We optimize loop path handlers by eliminating loop redundan\u00adcies \nin a manner similar to that in traditional compilers. We analyze a loop path handler to detect lifeguard \noperations that perform loop\u00adinvariant checks/propagations and loop-dead propagations. It is im\u00adportant \nto note that because we are dealing with paths, the propa\u00adgation/check only has to be invariant on iterations \nof that particular loop path, and might be variant on other paths in the loop [12]. Sim\u00adilarly, loop-dead \npropagations are propagations that are only live on the exit of the loop path. During the monitoring \nrun, the path han\u00addler invokes loop-invariant handlers only on the .rst iteration and loop-dead handlers \nonly on the last iteration. Figure 7 shows an example of eliminating redundancies in loop path handlers. \nThe path in Figure 7(a) is a hot loop path from 181.mcf, a SPEC2000 benchmark. As shown in Figure 7(b), \nthe TAINTCHECK path handler contains 12 instruction handlers before metadata disambiguation. We focus \non Figure 7(c), which shows the handler after all the optimizations in Section 3.2. The .rst event handler \ncall, which merges the taint status of memory M1 into that of register esi, is loop-invariant, because \nboth of their taint metadata are read-only otherwise in the path. Handler call (7), which propagates \nthe status of M2 into ebx, is loop-dead, because the status of ebx is live only at the loop exit. Figure \n7(d) shows the actual generated path handlers. In this case, our optimizations successfully detect that \nall the handlers are either loop-invariant or loop-dead, thus eliminating the need for a loop body handler! \n 3.4 Exploiting Spatial Locality for Cheap Metadata Access After eliminating redundant event handler \ncalls, the remaining event handler calls are inlined to enable a cheap metadata access optimization described \nnext. As discussed in Section 2.3, a com\u00admon metadata design for lifeguards is to shadow each 216 byte \naligned region in the application address space with a second meta\u00addata level chunk. This implies that \nrepeated data accesses in this byte range result in accesses to different locations of this metadata \nchunk. If the optimizer could identify accesses to the same meta\u00addata chunk, it could avoid the .ve instructions \nrequired for com\u00adputing a metadata address for all but the .rst access and perform the remaining accesses \nas offsets of the .rst one. However, because this is as dif.cult as directly disambiguating metadata \naccesses, our before metadata disambiguation, which translates to 81 x86 instructions after inlining, \n(c) the path handler after metadata disambiguation and intra-path redundancy elimination, which results \nin 54 x86 instructions after inlining, and (d) the entry and exit path handlers containing the loop invariant \nand loop-dead handler calls, which results in 12 and 43 x86 instructions, respectively, after inlining. \nBecause all the handler calls in (c) are in either the entry or exit path handlers, the path handler \nfor the body of the loop is empty.  optimizer instead identi.es application memory references in the \ncode path that are likely to be in the same 216 byte address range. It employs the heuristic that memory \nreferences that are formed us\u00ading a base register + offset addressing mode and that differ only in the \noffset are often shadowed by the same metadata chunk. Our evaluations con.rm this to be a highly accurate \nheuristic. Having identi.ed a set of memory references that are likely to be shadowed by the same metadata \nchunk, the optimizer derives the relative distance of the corresponding metadata in the chunk using the \nsize of metadata values and optimizes the path handler as shown in Figure 8. Figure 8(a) shows an excerpt \nof the TAINTCHECK path handler from Figure 6(a) after inlining of event handlers, showing the accesses \nto taint values of two memory locations M1 and M2. Because both memory references are formed in the application \nhot path using addressing modes targeted by our heuristic, the second taint read is performed using the \naddress of the .rst one, as shown in Figure 8(b). Here, the second taint value is a 1 byte offset from \nthe .rst because M1 and M2 are 8 bytes apart and a metadata value is 1 bit for every application byte. \nThis optimized sequence is executed only after a three instruction runtime check is used to determine \nwhen the metadata accesses are indeed to the same Figure 6(a) after inlining of event handlers, showing \nthe accesses to metadata chunk and hence the optimization is safe. If the check taint values of two memory \nlocations M1 (passed to the path handler fails, the unoptimized sequence in Figure 8(a) is executed as \na fall in edi) and M2 (passed to the path handler in ebx) that are 8 bytes back. For applications with \ngood spatial locality, the overheads of apart. (b) The path handler after our metadata address computation \nthis optimization are amortized across multiple metadata accesses optimization: the second taint access \nis performed as an offset of that fall within the same chunk, as shown by our experiments. the .rst \none, because the memory locations are shadowed by the same metadata chunk. 3.5 Summary of Optimizations \n In summary, we optimize decoupled lifeguard code by (i) automat\u00adically constructing path handlers from \nlifeguard event handlers, (ii) ing inlining) after step (i), and that our new, lifeguard domain\u00adperforming \nalias analysis on every hot path of the monitored appli-speci.c optimizations, i.e., steps (ii) (iv), \nlead to signi.cant ben\u00adcation code for disambiguating the metadata manipulated by event e.ts beyond traditional \noptimizations. handlers in the corresponding path handler, (iii) eliminating redun\u00addant event handler \ncalls in the context of individual paths within enclosing loops, including loop-invariant and loop-dead \nhandler 4. Implementation optimizations, and .nally (iv) eliminating expensive metadata ad\u00address computations \nby exploiting the spatial locality of metadata We implemented our proposed lifeguard path optimizer in \ntwo accesses. Experimental evaluation in Section 5 shows that it is sub-frameworks: Valgrind and LBA. \nWe describe the two implemen\u00adoptimal to employ only traditional compiler optimizations (includ-tations \nin Section 4.1 and 4.2, respectively.  4.1 Extending Valgrind for Lifeguard Path Optimizations Valgrind \n[21] is a state-of-the-art dynamic binary instrumentation framework. Given an application executable, \nValgrind disassem\u00adbles up to three branches from the application x86 code at a time into the Valgrind \nintermediate representation (IR). Then, it inserts the relevant lifeguard code before the associated \napplication in\u00adstructions in the IR. After that, it optimizes and converts the IR back to x86 code, caches \nthe code in a hash-indexed code cache, then executes the instrumented code. This instrumentation process \nis performed only when code to execute is not found in the code cache. The overhead is further reduced \nby recording the starting ad\u00addresses of the most frequently used codes in a small array for fast lookup \nand dispatch. Valgrind directly manages shadow registers. The IR optimizations eliminate redundant checks \nand propagation among shadow registers. Therefore, we mainly focus on reducing redundant memory events \nfor Valgrind lifeguards. Starting from Valgrind-3.4.0, we implemented decoupled life\u00adguards and path \noptimizations as follows. First, we extend Valgrind to disassemble up to eight branches from the application \ncode at a time in order to form a path. Second, unlike the original Val\u00adgrind, we insert a lifeguard \npath handler only at the end of the IR of a path. Third, we instrument the application code path to gen\u00aderate \na log of the effective addresses of the memory operations. This log is consumed by the lifeguard path \nhandler. We do not log program counter values because Valgrind already keeps track of them. Fourth, we \nreduce the logging overhead by (i) logging one address for each set of aliasing memory references, and \n(ii) logging loop-invariant memory addresses only in the .rst loop iteration. Fi\u00adnally, we perform path-based \nlifeguard handler optimizations and replace the original Valgrind instrumentation only when the esti\u00admated \nbene.t of the optimizations (i.e., the number of eliminated handler calls) outweighs the logging overhead. \nOur current Valgrind extension is limited in three ways. First, for every path starting address, it can \noptimize only a single hot path, which reduces the coverage of the optimizations because mul\u00adtiple hot \npaths (such as in a hot loop) may share the same starting address. Second, there is no mechanism for \ndetecting the last itera\u00adtion of a self-loop. This prevents loop-dead handler elimination as described \nin Section 3.3. Third, memory event handlers are not in\u00adlined, thus our metadata address optimization \ncannot be performed.  4.2 Extending LBA for Lifeguard Path Optimizations As described in Section 2.2, \nLBA is a state-of-the-art design for a hardware-assisted lifeguard framework. It exploits multi-core \npro\u00adcessors to run a monitored program and its lifeguard on separate cores. A log buffer is maintained \nin the last level on-chip cache for transferring event records from the application core to the core \nrunning the lifeguard. At the lifeguard core, a hardware dispatch mechanism ef.ciently supports event-driven \nlifeguard execution. We extended the baseline LBA simulator with hardware mech\u00adanisms for (i) detecting \npaths in the log record sequence that match registered path handlers; (ii) logging effective address \narguments from the instruction records into a dedicated hardware table for communicating to the path \nhandlers; (iii) dispatching path han\u00addlers; and (iv) remembering the previous path and looking ahead \nin the log to identify the next path for supporting our optimiza\u00adtions for loop path handlers. If there \nis no matching path or the log buffer is not full enough to form a path, we fall back to the baseline \nLBA approach of using instruction handlers to consume the log record sequence. However, note that the \nlog buffer is usually full because the application is typically faster than the lifeguard. With these \nmechanisms, we implemented all the path optimizations de\u00adscribed in Section 3. Table 1. Multithreaded \nBenchmarks for LOCKSET. Benchmark Description and Input blast v2.2.16 [19] Searching a nucleotide and \nproteindatabase of 134K sequences pbzip2 v1.0.1 [26] Parallel data compressor, compress halfof CPU2000 \ns ref input.source pbunzip2 v1.0.1 [26] Decompress pbzip2 s output in parallel zchaff 2002.7.15 [27] \nSAT (Boolean Satis.ability Problem)solver, circuit fault analysis  5. Performance Evaluation We begin \nby presenting the experimental methodology in Sec\u00adtion 5.1. We study the effectiveness of our solution \nin reducing re\u00addundant events in Section 5.2. Then, we study the impact of our techniques on lifeguard \nperformance for both our Valgrind (Sec\u00adtion 5.3) and LBA (Section 5.4) implementations. 5.1 Experimental \nSetup Lifeguards and Benchmarks. Our evaluation uses the four instruction\u00adgrain lifeguards presented \nin Section 2.1: ADDRCHECK, TAINT-CHECK, MEMCHECK, and LOCKSET. We implemented three ver\u00adsions of our \nlifeguard optimizer by gradually applying our proposed optimizations, for the purpose of quantifying \nthe incremental ben\u00ade.ts of our techniques: (i) path(stdopts): applying standard compiler optimizations \non path handlers in the decoupled lifeguards (Section 3.1);  (ii) path+lgopts: in addition to (i), applying \ndomain knowledge to reduce redundant lifeguard handler calls (Sections 3.2, 3.3);  (iii) path+lgopts+maddropts: \nin addition to (i) and (ii), optimizing metadata accesses (Section 3.4). Our evaluation focuses on CPU-intensive \napplications, which are known to incur the largest lifeguard overheads, as opposed to I/O-intensive applications. \nADDRCHECK, MEMCHECK and TAINTCHECK all monitor single-threaded applications. We use ten SPEC2000 integer \nbenchmarks for evaluating them. The bench\u00admarks use reference inputs for our augmented Valgrind framework \nrunning on a real machine, and use test inputs for our augmented LBA running on a simulator. LOCKSET \nis a data race detector. Therefore, we evaluate it using four multi-threaded applications, as shown in \nTable 1, running on a single core. All the experiments are run to completion. We report execution time \nnormalized to a baseline execution that runs on our augmented frameworks but without any path handlers. \nWe observe that this baseline execution performs comparably to the original Valgrind and LBA, incur\u00adring \n4 38X slowdowns for Valgrind and 1.3 13.3X slowdowns for LBA, when compared to benchmark execution without \nany life\u00adguard monitoring. Decoupled-Valgrind on a Real Machine. We extend Valgrind as described in \nSection 4.1, and evaluate our optimization tech\u00adniques using two lifeguards, ADDRCHECK and MEMCHECK, \nthat are available on Valgrind. We run the experiments on an x86-64 machine with dual 2.33GHz quad-core \nIntel Xeon E5345 CPUs, 8MB L2 cache, and 16GB RAM, running the unmodi.ed 64-bit Fedora Core 5 with Linux \n2.6.19 kernel. gcc-3.2.3 is used to com\u00adpile Valgrind and the lifeguards. The default compilation settings \nin Valgrind are used. Denote this set-up as Decoupled-Valgrind. Decoupled-LBA Simulation Platform. We \nextend LBA [5] as de\u00adscribed in Section 4.2. The LBA hardware is simulated on the Vir\u00adtutech Simics [33] \nfull-system simulator. We use the same simu\u00adlation parameters as in [5], as shown in Table 2. The monitored \napplication and the lifeguard are running as two processes on two separate cores. The simulated 32-bit \nFedora Core 5 operating sys\u00ad Table 2. Simulation Setup for LBA. Simulator description Simulator Extensions \nProcessor cores Cache model Target OS Virtutech Simics 3.0.22 Log capture and dispatch Two in-order scalar \ncores g-cache module Fedora Core 5 for x86 Simulation parameters Private L1I Private L1D Shared L2 Main \nMemory Log buffer 16KB, 64B line, 2-way, 1-cycle access lat. 16KB, 64B line, 2-way, 1-cycle access lat. \n512KB, 64B line, 8-way, 10-cycle access lat. 4 banks 200-cycle latency 1/8 of L2 size, assuming 1B per \ncompressed record [5] Figure 10. Impact of aliasing on redundant check detection for ADDRCHECK and LOCKSET \non Decoupled-LBA.  Figure 9. Path coverage for SPEC2000 benchmarks with ref input. tem is modi.ed to \nrecognize the association between the lifeguard process and the application process. The application \ncore stalls if the log buffer is full, while the lifeguard core stalls if the log buffer is empty. The \ndetailed cache contention effects between the application and the lifeguard is modeled by the simulator. \nLife\u00adguard binaries are generated using gcc-3.4.6. Denote this set-up as Decoupled-LBA. Hot Path Detection \nand Path Handler Generation. To sim\u00adplify the prototyping effort, we use of.ine pro.ling to detect hot \npaths of up to 8 branches for both Decoupled-Valgrind and Decoupled-LBA. Moreover, we generate the path \nhandlers of.ine for Decoupled-LBA. However, we ensure that when running the path handlers, the implementations \nmimic a JIT-based approach by limiting the total number of hot path handlers over an entire appli\u00adcation \nto be at most 128 for any one lifeguard. We believe that the of.ine simpli.cation is reasonable because \nhot path detection and optimization overheads have been shown to be small [2, 17]. Figure 9 shows the \ncumulative coverage of paths for the SPEC2000 benchmarks in our study. We see that 128 (256) hot paths \ncover over 85% (90%) of the execution times in 7 out of the 10 benchmarks. Therefore, we generate path \nhandlers as follows. For each benchmark, the path optimizer estimates and ranks the optimization bene.ts \nfor the 256 hottest paths. Then it generates path handlers for the 128 paths with the most bene.t. The \nhan\u00addler generation is performed of.ine for Decoupled-LBA, while it is performed as part of the initialization \nstep in Decoupled-Valgrind, loading the path handlers into the code cache.  5.2 Effectiveness in Reducing \nRedundant Events We start by evaluating how aliases affect the effectiveness in elimi\u00adnating redundant \nchecks. As discussed in Section 3.2, disambigua\u00adtion of the metadata that are manipulated by the lifeguard \nevent handlers in a path handler plays an essential role. Rather than directly disambiguating the indirect \nmemory accesses to meta-data, our solution statically analyzes the application path to dis\u00adambiguate \nthe application s direct memory accesses and then lever\u00adages the one-to-one mapping from data to metadata \nto disambiguate the metadata accesses.  Figure 10 compares our static alias analysis solution against \nmore idealized techniques representing upper-bounds that can be achieved, on Decoupled-LBA. We consider \nthree such idealized schemes, which use different amounts of dynamic information for disambiguating metadata \naccesses. The .gure shows, for ADDR-CHECK and LOCKSET, the percentage of dynamic lifeguard events in \neach benchmark that are identi.ed as redundant by the different schemes. Our scheme, path-alias, represents \nthe results of analyz\u00ading the path handlers corresponding to the selected hot paths of the monitored \nprograms. We estimate the number of detected dynamic redundant events by computing the sum of the number \nof redun\u00addant events detected per path handler multiplied by the execution frequency of the paths. path-ideal-alias \nis similar to path-alias ex\u00adcept that it is enhanced with dynamic runtime information about metadata \naccesses that always alias, even though they could not be determined statically by our algorithm. path*-ideal-alias \nfurther extends path-ideal-alias to detect aliases that span 2, 4 and 8 it\u00aderations of loop paths and \nthe best results are reported. hw .lter is similar to the proposal in [5], which uses a hardware .ltering \nmech\u00adanism to avoid redundant metadata checks. This represents the most ideal setting because all aliases \nare resolved at runtime. We achieve a tighter upper bound by enabling the hardware .lter only in the \nhot paths that were considered for static analysis. In.nite .lter size is used to avoid over.ows. The \nhardware .lter states are preserved across loop path iterations but are .ushed at the beginning of other \nnew paths. Compared to the various upper bounds, we see that our solution is quite close to the upper \nbounds in almost all cases. On aver\u00adage, path-alias detects 15% and 29% redundant checks for ADDR-CHECK \nand LOCKSET, respectively. In the case of pbunzip2, it de\u00adtects that over 50% of LOCKSET events are redundant. \nOn aver\u00adage, path-ideal-alias detects 19% and 30% redundant checks for ADDRCHECK and LOCKSET, respectively. \npath-ideal-alias and path*-ideal-alias achieve similar bene.ts, suggesting that there is little additional \nbene.ts from statically detecting aliases across loop paths iterations. This is because we already take \nadvantage of inter\u00aditeration knowledge in our optimizations. Finally, hw .lter is the best performer \non average, because it makes full use of runtime in\u00adformation. Interestingly, hw .lter was outperformed \nby path-ideal\u00adalias and path*-ideal-alias for LOCKSET monitoring zchaff. This is because checks on loads \ndo not make checks on stores redundant in LOCKSET, but not vice versa. hw .lter has to treat loads and \nstores as entirely separate events. Consequently, given a path with a load preceding a store to the same \naddress, hw .lter cannot .l\u00adter either of them. In contrast, static analysis can eliminate the load because \nit can scan forwards and backwards in the path.   5.3 Lifeguard Acceleration on Decoupled-Valgrind \nWe now evaluate how much ADDRCHECK and MEMCHECK are accelerated using optimized path handlers on Decoupled-Valgrind. \nAs described earlier in Section 4.1, our optimizations are limited in our current implementation in the \nfollowing ways: (i) only one hot path is supported per path address, (ii) loop-dead handler calls are \nnot eliminated, and (iii) our metadata access optimization cannot be performed. In addition, we observe \nthat simply using path handlers without our optimizations enables the Valgrind IR optimizer to eliminate \nmore shadow register operations. Figure 11 shows the execution times of path(stdopts) and path+lgopts \nversions of each lifeguard normalized to the execu\u00adtion time of the baseline lifeguard not using path \nhandlers. Every reported result is the best of .ve runs on a real machine. Because non-dedicated systems \nwere used for the experiments, the best, rather than average, results are presented to limit the unpredictable \neffects of OS and network activities. For ADDRCHECK, we observe that despite the limitations de\u00adscribed \nabove, path+lgopts is faster than the baseline on eight of the ten SPEC2000 benchmarks, with up to 31% \nreduction in the over\u00adhead of monitoring gzip. Loops account for over 95% of gzip exe\u00adcution on reference \ninput. The signi.cant improvement on gzip was due to loop-invariant handler optimizations. However, we \nsee that without domain-knowledge optimizations, path(stdopts) is slower than the baseline, up to 12% \non vpr, because the overhead of log\u00adging outweighs the code improvements made by Valgrind due to longer \npaths. On the other hand, path+lgopts results in modest MEMCHECK improvements for only four benchmarks \n(up to 6% on gzip). Our investigations identi.ed the following reasons why path+lgopts is less effective \non MEMCHECK compared to ADDRCHECK: (i) for a MEMCHECK handler call to be eliminated, both its check and \npropagation must be redundant, and (ii) the shadow register op\u00adtimizations performed by the Valgrind \nIR optimizer overlap with that of our technique, on the other hand ADDRCHECK has no shadow register operations. \nDue to the second reason, we observe that path(stdopts) for MEMCHECK is faster (by 5%) than the base\u00adline \non gzip and vortex. This is a result of increasing the length of paths from 3 branches to 8, which enables \nthe Valgrind optimizer to eliminate more redundant shadow register operations. However, path(stdopts) \nis slower on six of the benchmarks (up to 15% on vpr), while path+lgopts is always comparable or faster \nthan the baseline because it selects only pro.table path handlers. The lifeguard accelerations obtained \nusing our techniques on Decoupled-Valgrind are in fact conservative because the framework currently lacks \nthe features to support our remaining optimizations. For example, the lack of support for inlining path \nhandlers prevents metadata optimizations.  5.4 Lifeguard Acceleration on Decoupled-LBA We now evaluate \nthe lifeguard performance gains from our opti\u00admizations on Decoupled-LBA. Compared to Decoupled-Valgrind, \nDecoupled-LBA has the following advantages: (i) hardware log\u00adging with no runtime penalty, (ii) support \nfor multiple paths per path address leading to better coverage, (iii) a look-ahead mecha\u00adnism for detecting \nlast loop iterations, thus enabling loop-dead han\u00addler optimizations, and (iv) inlining of path handlers \nenabling our metadata access optimization. Consequently, it is a better platform for demonstrating the \nfull potential of our optimizations. Figure 12 shows the relative lifeguard performance gains of path(stdopts), \npath+lgopts, and path+lgopts+maddropts over the baseline. As shown in Figure 12, path+lgopts+maddropts \nis consis\u00adtently the fastest version, followed by path+lgopts indicating that our domain-knowledge and \nmetadata access optimizations offer complimentary lifeguard accelerations. Compared to the baseline, \npath+lgopts+maddropts reduces monitoring overhead by up to 50% for single threaded programs (ADDRCHECK \non gzip) and 53% for multithreaded programs (LOCKSET on pbunzip2). In ad\u00addition, average overhead reductions \nof about 30% are observed for both monitoring scenarios. On the other hand, path(stdopts) with\u00adout the \ndomain-speci.c optimization techniques achieves much smaller gains or even incurs worse performance than \nthe baseline. Overall, our optimizations reduce monitoring overhead on Decoupled-LBA by 19 50% for ADDRCHECK, \n14 38% for MEM-CHECK, 10 42% for TAINTCHECK, and 9 53% for LOCKSET. 6. Conclusion This paper presented \na novel approach to optimizing lifeguards: decoupling the lifeguard code from the monitored program to \nen\u00adable hot-path lifeguard optimizations. Our solution leverages sim\u00adple knowledge about lifeguards to \nreduce redundant lifeguard han\u00addler calls and to accelerate metadata accesses. We implemented our techniques \non both a software-only lifeguard platform (Valgrind) and a hardware-assisted lifeguard platform (LBA). \nOn Valgrind, our techniques reduce monitoring overhead by 2 31% compared to baseline lifeguards. As LBA \nfactors out the runtime overhead of software logging and other limitations of the Valgrind implemen\u00adtation, \nour techniques achieve even better performance on LBA. The overhead of lifeguard monitoring on LBA is \nreduced from 1.3 13.3X down to 0.8 10.5X for single threaded programs and from 3.5 4.9X down to 1.9 4.1X \nfor multithreaded programs. Based on the experimental results, we conclude that path optimizations enabled \nby decoupled lifeguards signi.cantly reduce monitoring overhead. Future work includes .xing the limitations \nof our Val\u00adgrind implementation and generalizing the techniques to handle parallel applications running \non multiple cores. References [1] A. V. Aho, R. Sethi, and J. D. Ullman. Compilers: Principles, Tech\u00adniques, \nand Tools. Addison Wesley, 1986. [2] V. Bala, E. Duesterwald, and S. Banerjia. Dynamo: A Transparent \nDynamic Optimization System. In PLDI, 2000. [3] D. Bruening. Ef.cient, Transparent, and Comprehensive \nRuntime Code Manipulation. PhD thesis, MIT, 2004. [4] W. R. Bush, J. D. Pincus, and D. J. Sielaff. A \nstatic analyzer for .nding dynamic programming errors. Software Practice and Experience, 30 (7), 2000. \n[5] S. Chen, M. Kozuch, T. Strigkos, B. Falsa., P. B. Gibbons, T. C. Mowry, V. Ramachandran, O. Ruwase, \nM. Ryan, and E. Vlachos. Flexible Hardware Acceleration for Instruction-Grain Program Moni\u00adtoring. In \nISCA, 2008. [6] S. Chen, M. Kozuch, P. B. Gibbons, M. Ryan, T. Strigkos, T. C. Mowry, O. Ruwase, E. Vlachos, \nB. Falsa., and V. Ramachandran. Flexible Hardware Acceleration for Instruction-Grain Lifeguards. IEEE \nMicro, 29(1), 2009. Top Picks from the 2008 Computer Archi\u00adtecture Conferences. [7] B. Cmelik and D. \nKeppel. Shade: A Fast Instruction Set Simulator for Execution Pro.ling. In SIGMETRICS, 1994. [8] M. L. \nCorliss, E. C. Lewis, and A. Roth. DISE: A programmable macro engine for customizing applications. In \nISCA, 2003. [9] M. Dalton, H. Kannan, and C. Kozyrakis. Raksha: A Flexible Infor\u00admation Flow Architecture \nfor Software Security. In ISCA, 2007. [10] D. Engler, B. Chelf, A. Chou, and S. Hallem. Checking system \nrules using system-speci.c, programmer-written compiler extensions. In OSDI, 2000. [11] C. Flanagan, \nK. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. Extended static checking for Java. \nIn PLDI, 2002. [12] A. Gal, C. W. Probst, and M. Franz. HotpathVM: An effective JITcompiler for resource-constrained \ndevices. In VEE, 2006. [13] M. L. Goodstein, E. Vlachos, S. Chen, P. B. Gibbons, M. Kozuch, and T. C. \nMowry. Butter.y Analysis: Adapting Data.ow Analysis to Dynamic Parallel Monitoring. In ASPLOS, 2010. \n[14] N. D. Jones. An introduction to partial evaluation. ACM Comput. Surv., 28(3), 1996. [15] I. H. Kazi, \nH. H. Chen, B. Stanley, and D. J. Lilja. Techniques for obtaining high performance in java programs. \nACM Comput. Surv., 32 (3), 2000. [16] P. Lee and M. Leone. Optimizing ML with Runtime Code Generation. \nIn PLDI, 1996. [17] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. J. Reddi, \nand K. Hazelwood. Pin: Building customized program analysis tools with dynamic instrumentation. In PLDI, \n2005. [18] S. Narayanasamy, G. Pokam, and B. Calder. BugNet: Continuously recording program execution \nfor deterministic replay debugging. In ISCA, 2005. [19] National Center for Biotechnology Information. \nftp://ftp.ncbi.nih.gov/blast/. [20] N. Nethercote. Dynamic Binary Analysis and Instrumentation. PhD thesis, \nU. Cambridge, 2004. http://valgrind.org. [21] N. Nethercote and J. Seward. Valgrind: a framework for \nheavyweight dynamic binary instrumentation. In PLDI, 2007. [22] N. Nethercote and J. Seward. Valgrind: \nA program supervision frame\u00adwork. Electronic Notes in Theoretical Computer Science, 89(2), 2003. [23] \nN. Nethercote and J. Seward. How to shadow every byte of memory used by a program. In VEE, 2007. [24] \nJ. Newsome and D. Song. Dynamic Taint Analysis for AutomaticDetection, Analysis, and Signature Generation \nof Exploits on Com\u00admodity Software. In NDSS, 2005. [25] E. B. Nightingale, D. Peek, P. M. Chen, and J. \nFlinn. Parallelizing security checks on commodity hardware. In ASPLOS, 2008. [26] Parallel Bzip2. http://compression.ca/pbzip2/. \n[27] Princeton Zchaff. http://www.princeton.edu/~chaff/zchaff.html. [28] T. A. Proebsting. Optimizing \nan ANSI C interpreter with superopera\u00adtors. In POPL, 1995. [29] F. Qin, C.Wang, Z. Li, H. Kim, Y. Zhou, \nand Y. Wu. LIFT: A low-overhead practical information .ow tracking system for detectingsecurity attacks. \nIn MICRO-39, 2006. [30] O. Ruwase, P. B. Gibbons, T. C. Mowry, V. Ramachandran, S. Chen, M. Kozuch, and \nM. Ryan. Parallelizing Dynamic Information Flow Tracking. In SPAA, 2008. [31] S. Savage, M. Burrows, \nG. Nelson, P. Sobalvarro, and T. Anderson. Eraser: A dynamic race detector for multi-threaded programs. \nACM TOCS, 15(4), 1997. [32] M. Tiwari, S. Mysore, and T. Sherwood. Quantifying the potential of program \nanalysis peripherals. In PACT, 2009. [33] Virtutech Simics. http://www.virtutech.com/. [34] E. Vlachos, \nM. L. Goodstein, M. A. Kozuch, S. Chen, B. Falsa., P. B.Gibbons, and T. C. Mowry. ParaLog: Enabling and \nAccelerating On\u00adline Parallel Monitoring of Multithreaded Applications. In ASPLOS, 2010. [35] E. Witchel \nand M. Rosenblum. Embra: Fast and Flexible Machine Simulation. In SIGMETRICS, 1996. [36] M. Xu, R. Bodik, \nand M. D. Hill. A Flight Data Recorder for enabling full-system multiprocessor deterministic replay. \nIn ISCA, 2003.    \n\t\t\t", "proc_id": "1806596", "abstract": "<p>Dynamic correctness checking tools (a.k.a. lifeguards) can detect a wide array of correctness issues, such as memory, security, and concurrency misbehavior, in unmodified executables at run time. However, lifeguards that are implemented using dynamic binary instrumentation (DBI) often slow down the monitored application by 10-50X, while proposals that replace DBI with hardware still see 3-8X slowdowns. The remaining overhead is the cost of performing the lifeguard analysis itself. In this paper, we explore compiler optimization techniques to reduce this overhead.</p> <p>The lifeguard software is typically structured as a set of event-driven handlers, where the events are individual instructions in the monitored application's dynamic instruction stream. We propose to <i>decouple</i> the lifeguard checking code from the application that it is monitoring so that the lifeguard analysis can be invoked at the granularity of <i>hot paths</i> in the monitored application. In this way, we are able to find many more opportunities for eliminating redundant work in the lifeguard analysis, even starting with well-optimized applications and hand-tuned lifeguard handlers. Experimental results with two lifeguard frameworks - one DBI-based and one hardware-assisted - show significant reduction in monitoring overhead.</p>", "authors": [{"name": "Olatunji Ruwase", "author_profile_id": "81361607878", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2184490", "email_address": "", "orcid_id": ""}, {"name": "Shimin Chen", "author_profile_id": "81350570119", "affiliation": "Intel Labs, Pittsburgh, PA, USA", "person_id": "P2184491", "email_address": "", "orcid_id": ""}, {"name": "Phillip B. Gibbons", "author_profile_id": "81339501335", "affiliation": "Intel Labs, Pittsburgh, PA, USA", "person_id": "P2184492", "email_address": "", "orcid_id": ""}, {"name": "Todd C. Mowry", "author_profile_id": "81100262786", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2184493", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1806596.1806600", "year": "2010", "article_id": "1806600", "conference": "PLDI", "title": "Decoupled lifeguards: enabling path optimizations for dynamic correctness checking tools", "url": "http://dl.acm.org/citation.cfm?id=1806600"}